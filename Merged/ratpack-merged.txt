

package ratpack.server.internal;

import io.netty.buffer.ByteBuf;
import io.netty.channel.*;
import io.netty.handler.codec.http.*;
import io.netty.handler.ssl.SslHandler;
import io.netty.handler.stream.ChunkedNioStream;
import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import ratpack.event.internal.DefaultEventController;
import ratpack.exec.ExecControl;
import ratpack.file.internal.ResponseTransmitter;
import ratpack.handling.DoubleTransmissionException;
import ratpack.handling.RequestOutcome;
import ratpack.handling.internal.DefaultRequestOutcome;
import ratpack.http.Request;
import ratpack.http.SentResponse;
import ratpack.http.internal.*;

import java.io.FileInputStream;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.concurrent.atomic.AtomicBoolean;

public class DefaultResponseTransmitter implements ResponseTransmitter {

  private final static Logger LOGGER = LoggerFactory.getLogger(DefaultResponseTransmitter.class);
  private static final Runnable NOOP_RUNNABLE = () -> {
  };

  private final AtomicBoolean transmitted;
  private final ExecControl execControl;
  private final Channel channel;
  private final FullHttpRequest nettyRequest;
  private final Request ratpackRequest;
  private final HttpHeaders responseHeaders;
  private final DefaultEventController<RequestOutcome> requestOutcomeEventController;
  private final boolean isKeepAlive;
  private final boolean isSsl;

  private long stopTime;

  private Runnable onWritabilityChanged = NOOP_RUNNABLE;

  public DefaultResponseTransmitter(AtomicBoolean transmitted, ExecControl execControl, Channel channel, FullHttpRequest nettyRequest, Request ratpackRequest, HttpHeaders responseHeaders, DefaultEventController<RequestOutcome> requestOutcomeEventController) {
    this.transmitted = transmitted;
    this.execControl = execControl;
    this.channel = channel;
    this.nettyRequest = nettyRequest.retain();
    this.ratpackRequest = ratpackRequest;
    this.responseHeaders = responseHeaders;
    this.requestOutcomeEventController = requestOutcomeEventController;
    this.isKeepAlive = HttpHeaderUtil.isKeepAlive(nettyRequest);
    this.isSsl = channel.pipeline().get(SslHandler.class) != null;
  }

  private ChannelFuture pre(HttpResponseStatus responseStatus) {
    if (transmitted.compareAndSet(false, true)) {
      stopTime = System.nanoTime();

      HttpResponse headersResponse = new CustomHttpResponse(responseStatus, responseHeaders);
      nettyRequest.release();

      if (isKeepAlive) {
        headersResponse.headers().set(HttpHeaderConstants.CONNECTION, HttpHeaderConstants.KEEP_ALIVE);
      }

      if (channel.isOpen()) {
        return channel.writeAndFlush(headersResponse).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);
      } else {
        return null;
      }
    } else {
      String msg = "attempt at double transmission for: " + ratpackRequest.getRawUri();
      LOGGER.warn(msg, new DoubleTransmissionException(msg));
      return null;
    }
  }

  @Override
  public void transmit(HttpResponseStatus responseStatus, ByteBuf body) {
    transmit(responseStatus, new DefaultHttpContent(body));
  }

  private void transmit(final HttpResponseStatus responseStatus, Object body) {
    ChannelFuture channelFuture = pre(responseStatus);
    if (channelFuture == null) {
      return;
    }

    channelFuture.addListener(future -> {
      if (channel.isOpen()) {
        channel.write(body);
        post(responseStatus);
      }
    });
  }

  @Override
  public void transmit(HttpResponseStatus status, Path file) {
    String sizeString = responseHeaders.get(HttpHeaderConstants.CONTENT_LENGTH);
    long size = sizeString == null ? 0 : Long.parseLong(sizeString);
    boolean compress = !responseHeaders.contains(HttpHeaderConstants.CONTENT_ENCODING, HttpHeaderConstants.IDENTITY, true);

    responseHeaders.set(HttpHeaderConstants.CONTENT_LENGTH, size);

    if (!isSsl && !compress && file.getFileSystem().equals(FileSystems.getDefault())) {
      execControl.blocking(() -> new FileInputStream(file.toFile()).getChannel()).then(fileChannel -> {
        FileRegion defaultFileRegion = new DefaultFileRegion(fileChannel, 0, size);
        transmit(status, defaultFileRegion);
      });
    } else {
      execControl.blocking(() ->
          Files.newByteChannel(file)
      ).then(fileChannel ->
          transmit(status, new HttpChunkedInput(new ChunkedNioStream(fileChannel)))
      );
    }
  }

  @Override
  public Subscriber<ByteBuf> transmitter(HttpResponseStatus responseStatus) {
    return new Subscriber<ByteBuf>() {
      private Subscription subscription;
      private final AtomicBoolean done = new AtomicBoolean();

      private final ChannelFutureListener cancelOnFailure = future -> {
        if (!done.get()) {
          if (!future.isSuccess()) {
            cancel();
          }
        }
      };

      private void cancel() {
        if (done.compareAndSet(false, true)) {
          subscription.cancel();
          post(responseStatus);
        }
      }

      @Override
      public void onSubscribe(Subscription subscription) {
        if (subscription == null) {
          throw new NullPointerException("'subscription' is null");
        }
        if (this.subscription != null) {
          subscription.cancel();
          return;
        }

        this.subscription = subscription;

        onWritabilityChanged = () -> {
          if (channel.isWritable() && !done.get()) {
            this.subscription.request(1);
          }
        };

        ChannelFuture channelFuture = pre(responseStatus);
        if (channelFuture == null) {
          subscription.cancel();
          notifyListeners(responseStatus, channel.close());
        } else {
          channelFuture.addListener(cancelOnFailure);
          if (channel.isWritable()) {
            this.subscription.request(1);
          }
        }
      }

      @Override
      public void onNext(ByteBuf o) {
        if (channel.isOpen()) {
          channel.writeAndFlush(new DefaultHttpContent(o)).addListener(cancelOnFailure);
          if (channel.isWritable()) {
            subscription.request(1);
          }
        } else {
          cancel();
        }
      }

      @Override
      public void onError(Throwable t) {
        if (t == null) {
          throw new NullPointerException("error is null");
        }
        LOGGER.warn("Exception thrown transmitting stream", t);
        if (done.compareAndSet(false, true)) {
          post(responseStatus);
        }
      }

      @Override
      public void onComplete() {
        if (done.compareAndSet(false, true)) {
          post(responseStatus);
        }
      }
    };
  }

  private void post(HttpResponseStatus responseStatus) {
    if (channel.isOpen()) {
      ChannelFuture lastContentFuture = channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);
      if (!isKeepAlive) {
        lastContentFuture.addListener(ChannelFutureListener.CLOSE);
      }
      notifyListeners(responseStatus, lastContentFuture);
    } else {
      notifyListeners(responseStatus, channel.newSucceededFuture());
    }
  }

  private void notifyListeners(final HttpResponseStatus responseStatus, ChannelFuture future) {
    if (requestOutcomeEventController.isHasListeners()) {
      future.addListener(ignore -> {
        SentResponse sentResponse = new DefaultSentResponse(new NettyHeadersBackedHeaders(responseHeaders), new DefaultStatus(responseStatus));
        RequestOutcome requestOutcome = new DefaultRequestOutcome(ratpackRequest, sentResponse, stopTime);
        requestOutcomeEventController.fire(requestOutcome);
      });
    }
  }

  public void writabilityChanged() {
    onWritabilityChanged.run();
  }
}

<code block>


package ratpack.server.internal;

import io.netty.buffer.ByteBuf;
import io.netty.channel.*;
import io.netty.handler.codec.http.*;
import io.netty.handler.ssl.SslHandler;
import io.netty.handler.stream.ChunkedNioStream;
import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import ratpack.event.internal.DefaultEventController;
import ratpack.exec.ExecControl;
import ratpack.file.internal.ResponseTransmitter;
import ratpack.handling.DoubleTransmissionException;
import ratpack.handling.RequestOutcome;
import ratpack.handling.internal.DefaultRequestOutcome;
import ratpack.http.Request;
import ratpack.http.SentResponse;
import ratpack.http.internal.*;

import java.io.FileInputStream;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.concurrent.atomic.AtomicBoolean;

public class DefaultResponseTransmitter implements ResponseTransmitter {

  private final static Logger LOGGER = LoggerFactory.getLogger(DefaultResponseTransmitter.class);
  private static final Runnable NOOP_RUNNABLE = () -> {
  };

  private final AtomicBoolean transmitted;
  private final ExecControl execControl;
  private final Channel channel;
  private final FullHttpRequest nettyRequest;
  private final Request ratpackRequest;
  private final HttpHeaders responseHeaders;
  private final DefaultEventController<RequestOutcome> requestOutcomeEventController;
  private final boolean isKeepAlive;
  private final boolean isSsl;

  private long stopTime;

  private Runnable onWritabilityChanged = NOOP_RUNNABLE;

  public DefaultResponseTransmitter(AtomicBoolean transmitted, ExecControl execControl, Channel channel, FullHttpRequest nettyRequest, Request ratpackRequest, HttpHeaders responseHeaders, DefaultEventController<RequestOutcome> requestOutcomeEventController) {
    this.transmitted = transmitted;
    this.execControl = execControl;
    this.channel = channel;
    this.nettyRequest = nettyRequest.retain();
    this.ratpackRequest = ratpackRequest;
    this.responseHeaders = responseHeaders;
    this.requestOutcomeEventController = requestOutcomeEventController;
    this.isKeepAlive = HttpHeaderUtil.isKeepAlive(nettyRequest);
    this.isSsl = channel.pipeline().get(SslHandler.class) != null;
  }

  private ChannelFuture pre(HttpResponseStatus responseStatus) {
    if (transmitted.compareAndSet(false, true)) {
      stopTime = System.nanoTime();

      HttpResponse headersResponse = new CustomHttpResponse(responseStatus, responseHeaders);
      nettyRequest.release();

      if (isKeepAlive) {
        headersResponse.headers().set(HttpHeaderConstants.CONNECTION, HttpHeaderConstants.KEEP_ALIVE);
      }

      if (channel.isOpen()) {
        return channel.writeAndFlush(headersResponse).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);
      } else {
        return null;
      }
    } else {
      String msg = "attempt at double transmission for: " + ratpackRequest.getRawUri();
      LOGGER.warn(msg, new DoubleTransmissionException(msg));
      return null;
    }
  }

  @Override
  public void transmit(HttpResponseStatus responseStatus, ByteBuf body) {
    transmit(responseStatus, new DefaultHttpContent(body), true);
  }

  private void transmit(final HttpResponseStatus responseStatus, Object body, boolean sendLastHttpContent) {
    ChannelFuture channelFuture = pre(responseStatus);
    if (channelFuture == null) {
      return;
    }

    channelFuture.addListener(future -> {
      if (channel.isOpen()) {
        if (sendLastHttpContent) {
          channel.write(body);
          post(responseStatus);
        } else {
          post(responseStatus, channel.writeAndFlush(body));
        }
      }
    });
  }

  @Override
  public void transmit(HttpResponseStatus status, Path file) {
    String sizeString = responseHeaders.get(HttpHeaderConstants.CONTENT_LENGTH);
    long size = sizeString == null ? 0 : Long.parseLong(sizeString);
    boolean compress = !responseHeaders.contains(HttpHeaderConstants.CONTENT_ENCODING, HttpHeaderConstants.IDENTITY, true);

    responseHeaders.set(HttpHeaderConstants.CONTENT_LENGTH, size);

    if (!isSsl && !compress && file.getFileSystem().equals(FileSystems.getDefault())) {
      execControl.blocking(() -> new FileInputStream(file.toFile()).getChannel()).then(fileChannel -> {
        FileRegion defaultFileRegion = new DefaultFileRegion(fileChannel, 0, size);
        transmit(status, defaultFileRegion, true);
      });
    } else {
      execControl.blocking(() ->
          Files.newByteChannel(file)
      ).then(fileChannel ->
          transmit(status, new HttpChunkedInput(new ChunkedNioStream(fileChannel)), false)
      );
    }
  }

  @Override
  public Subscriber<ByteBuf> transmitter(HttpResponseStatus responseStatus) {
    return new Subscriber<ByteBuf>() {
      private Subscription subscription;
      private final AtomicBoolean done = new AtomicBoolean();

      private final ChannelFutureListener cancelOnFailure = future -> {
        if (!done.get()) {
          if (!future.isSuccess()) {
            cancel();
          }
        }
      };

      private void cancel() {
        if (done.compareAndSet(false, true)) {
          subscription.cancel();
          post(responseStatus);
        }
      }

      @Override
      public void onSubscribe(Subscription subscription) {
        if (subscription == null) {
          throw new NullPointerException("'subscription' is null");
        }
        if (this.subscription != null) {
          subscription.cancel();
          return;
        }

        this.subscription = subscription;

        onWritabilityChanged = () -> {
          if (channel.isWritable() && !done.get()) {
            this.subscription.request(1);
          }
        };

        ChannelFuture channelFuture = pre(responseStatus);
        if (channelFuture == null) {
          subscription.cancel();
          notifyListeners(responseStatus, channel.close());
        } else {
          channelFuture.addListener(cancelOnFailure);
          if (channel.isWritable()) {
            this.subscription.request(1);
          }
        }
      }

      @Override
      public void onNext(ByteBuf o) {
        if (channel.isOpen()) {
          channel.writeAndFlush(new DefaultHttpContent(o)).addListener(cancelOnFailure);
          if (channel.isWritable()) {
            subscription.request(1);
          }
        } else {
          cancel();
        }
      }

      @Override
      public void onError(Throwable t) {
        if (t == null) {
          throw new NullPointerException("error is null");
        }
        LOGGER.warn("Exception thrown transmitting stream", t);
        if (done.compareAndSet(false, true)) {
          post(responseStatus);
        }
      }

      @Override
      public void onComplete() {
        if (done.compareAndSet(false, true)) {
          post(responseStatus);
        }
      }
    };
  }

  private void post(HttpResponseStatus responseStatus) {
    post(responseStatus, channel.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT));
  }

  private void post(HttpResponseStatus responseStatus, ChannelFuture lastContentFuture) {
    if (channel.isOpen()) {
      if (!isKeepAlive) {
        lastContentFuture.addListener(ChannelFutureListener.CLOSE);
      }
      notifyListeners(responseStatus, lastContentFuture);
    } else {
      notifyListeners(responseStatus, channel.newSucceededFuture());
    }
  }

  private void notifyListeners(final HttpResponseStatus responseStatus, ChannelFuture future) {
    if (requestOutcomeEventController.isHasListeners()) {
      future.addListener(ignore -> {
        SentResponse sentResponse = new DefaultSentResponse(new NettyHeadersBackedHeaders(responseHeaders), new DefaultStatus(responseStatus));
        RequestOutcome requestOutcome = new DefaultRequestOutcome(ratpackRequest, sentResponse, stopTime);
        requestOutcomeEventController.fire(requestOutcome);
      });
    }
  }

  public void writabilityChanged() {
    onWritabilityChanged.run();
  }
}

<code block>

package ratpack.spring;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static ratpack.jackson.Jackson.json;

import java.util.Collections;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.test.IntegrationTest;
import org.springframework.boot.test.SpringApplicationConfiguration;
import org.springframework.boot.test.TestRestTemplate;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import ratpack.func.Action;
import ratpack.handling.Chain;
import ratpack.jackson.JacksonModule;
import ratpack.server.RatpackServer;
import ratpack.spring.ApplicationTests.Application;
import ratpack.spring.config.EnableRatpack;

@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = Application.class)
@IntegrationTest({ "debug=true", "server.port=0" })
public class ApplicationTests {

  private TestRestTemplate restTemplate = new TestRestTemplate();

  @Autowired
  private RatpackServer server;

  @Test
  public void homePage() {
    assertEquals(
        "{" + System.getProperty("line.separator") + "  \"message\" : \"Hello World\""
            + System.getProperty("line.separator") + "}",
        restTemplate.getForObject("http://localhost:" + server.getBindPort(), String.class));
  }

  @Test
  public void notFound() {
    ResponseEntity<String> response = restTemplate.getForEntity("http://localhost:" + server.getBindPort() + "/none",
        String.class);
    assertEquals(HttpStatus.NOT_FOUND, response.getStatusCode());
    assertNull("Default 404 handler has null body", response.getBody());
  }

  @Configuration
  @EnableAutoConfiguration
  @EnableRatpack
  @Import(MessageService.class)
  protected static class Application {

    @Autowired
    private MessageService service;

    @Bean
    public Action<Chain> handler() {
      return chain -> chain.get(context -> {


        assertNotNull(context.get(MessageService.class));
        context.render(json(Collections.singletonMap("message", service.message())));
      });
    }

    @Bean
    public JacksonModule jacksonGuiceModule() {
      JacksonModule module = new JacksonModule();
      module.configure(config -> {
        config.prettyPrint(true);
      });
      return module;
    }

    public static void main(String[] args) throws Exception {
      SpringApplication.run(Application.class, args);
    }

  }

  @Service
  protected static class MessageService {

    public String message() {
      return "Hello World";
    }

  }

}
<code block>

package ratpack.spring;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static ratpack.jackson.Jackson.fromJson;
import static ratpack.jackson.Jackson.json;

import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.Map;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.test.IntegrationTest;
import org.springframework.boot.test.SpringApplicationConfiguration;
import org.springframework.boot.test.TestRestTemplate;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import ratpack.func.Action;
import ratpack.handling.Chain;
import ratpack.handling.Handler;
import ratpack.jackson.JacksonModule;
import ratpack.server.RatpackServer;
import ratpack.spring.JsonTests.Application;
import ratpack.spring.config.EnableRatpack;

@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = Application.class)
@IntegrationTest("server.port=0")
public class JsonTests {

  private TestRestTemplate restTemplate = new TestRestTemplate();

  @Autowired
  private RatpackServer server;

  @Test
  public void get() {
    String body = restTemplate.getForObject("http://localhost:" + server.getBindPort(), String.class);
    assertTrue("Wrong body" + body, body.contains("{"));
    assertFalse("Wrong body" + body, body.toLowerCase().contains("<html"));
  }

  @Test
  public void post() {
    HttpHeaders headers = new HttpHeaders();
    headers.setContentType(MediaType.APPLICATION_JSON);
    HttpEntity<Map<String, String>> entity = new HttpEntity<Map<String, String>>(Collections.singletonMap("foo", "bar"),
        headers);
    ResponseEntity<String> result = restTemplate.postForEntity("http://localhost:" + server.getBindPort(), entity,
        String.class);
    assertEquals(HttpStatus.OK, result.getStatusCode());
    String body = restTemplate.getForObject("http://localhost:" + server.getBindPort(), String.class);
    assertTrue("Wrong body" + body, body.contains("foo"));
  }

  @Configuration
  @EnableRatpack
  @EnableAutoConfiguration
  protected static class Application {

    private Map<String, Object> map = new LinkedHashMap<String, Object>();

    @Bean
    public Action<Chain> chain() {
      return chain -> chain.all(handler());
    }

    @SuppressWarnings("unchecked")
    @Bean
    public Handler handler() {

      return context -> context.byMethod(spec -> spec.get(() -> context.render(json(map))).post(() -> {
        map.putAll(context.parse(fromJson(Map.class)));
        context.render(json(map));
      }));

    }

    @Bean
    public JacksonModule jacksonGuiceModule() {
      return new JacksonModule();
    }

    public static void main(String[] args) throws Exception {
      SpringApplication.run(Application.class, args);
    }

  }

}
<code block>


package ratpack.site;

import ratpack.codahale.metrics.CodaHaleMetricsModule;
import ratpack.func.Block;
import ratpack.func.Pair;
import ratpack.groovy.template.MarkupTemplateModule;
import ratpack.groovy.template.TextTemplateModule;
import ratpack.guice.Guice;
import ratpack.jackson.JacksonModule;
import ratpack.newrelic.NewRelicModule;
import ratpack.registry.Registry;
import ratpack.rx.RxRatpack;
import ratpack.server.RatpackServer;
import ratpack.server.ServerConfig;
import ratpack.site.github.GitHubApi;
import ratpack.site.github.GitHubData;
import ratpack.site.github.RatpackVersion;
import ratpack.site.github.RatpackVersions;
import asset.pipeline.ratpack.AssetPipelineModule;

import static ratpack.groovy.Groovy.groovyMarkupTemplate;

public class SiteMain {
  public static void main(String... args) throws Exception {
    RatpackServer.start(b -> {
        RxRatpack.initialize();
        ServerConfig serverConfig = ServerConfig.findBaseDir()
          .env()
          .require("/github", SiteModule.GitHubConfig.class)
          .build();

        b
          .serverConfig(serverConfig)
          .registry(
            Guice.registry(s -> s
                .module(JacksonModule.class)
                .module(NewRelicModule.class)
                .module(new AssetPipelineModule())
                .module(new CodaHaleMetricsModule(), c ->
                    c.csv(csv -> csv.enable(false))
                )
                .module(SiteModule.class)
                .module(MarkupTemplateModule.class, conf -> {
                  conf.setAutoNewLine(true);
                  conf.setUseDoubleQuotes(true);
                  conf.setAutoIndent(true);
                })
                .module(TextTemplateModule.class, conf ->
                    conf.setStaticallyCompile(true)
                )
            )
          )
          .handlers(c -> {

            int longCache = 60 * 60 * 24 * 365; 
            int shortCache = 60 * 10; 

            c
              .all(ctx -> {

                String host = ctx.getRequest().getHeaders().get("host");
                if (host != null && (host.endsWith("ratpack-framework.org") || host.equals("www.ratpack.io"))) {
                  ctx.redirect(301, "http://ratpack.io" + ctx.getRequest().getRawUri());
                  return;
                }

                if (ctx.getRequest().getPath().isEmpty() || ctx.getRequest().getPath().equals("index.html")) {
                  ctx.getResponse().getHeaders().set("X-UA-Compatible", "IE=edge,chrome=1");
                }

                ctx.next();
              })

              .prefix("assets", assets -> assets
                  .all(ctx -> {
                    int cacheFor = ctx.getRequest().getQuery().isEmpty() ? shortCache : longCache;
                    ctx.getResponse().getHeaders().add("Cache-Control", "max-age=" + cacheFor + ", public");
                    ctx.next();
                  })
                  .files(f -> f.dir("assets").indexFiles("index.html"))
              )

              .get("index.html", ctx -> {
                ctx.redirect(301, "/");
              })

              .get(ctx -> ctx.render(groovyMarkupTemplate("index.gtpl")))

              .path("reset", ctx -> {
                GitHubApi gitHubApi = ctx.get(GitHubApi.class);
                ctx.byMethod(methods -> {
                  Block impl = () -> {
                    gitHubApi.invalidateCache();
                    ctx.render("ok");
                  };
                  if (ctx.getServerConfig().isDevelopment()) {
                    methods.get(impl);
                  }
                  methods.post(impl);
                });
              })

              .prefix("versions", v -> v
                  .get(ctx ->
                      ctx.render(
                        ctx.get(RatpackVersions.class).getAll()
                          .map(all -> groovyMarkupTemplate("versions.gtpl", m -> m.put("versions", all)))
                      )
                  )
                  .get(":version", ctx ->
                      ctx.render(
                        ctx.get(RatpackVersions.class).getAll()
                          .map(all -> all.version(ctx.getAllPathTokens().get("version")))
                          .onNull(() -> ctx.clientError(404))
                          .flatMap(version -> ctx.get(GitHubData.class).closed(version).map(i -> Pair.of(version, i)))
                          .map(p -> groovyMarkupTemplate("version.gtpl", m -> m.put("version", p.left).put("issues", p.right)))
                      )
                  )
              )

              .prefix("manual", c1 -> c1
                  .fileSystem("manual", c2 -> c2
                      .get(ctx -> ctx.redirect(301, "manual/current"))
                      .prefix(":label", c3 -> c3
                          .all(ctx -> {
                            String label = ctx.getPathTokens().get("label");

                            ctx.get(RatpackVersions.class).getAll().then(all -> {
                              if (label.equals("current") || all.isReleased(label)) {
                                ctx.getResponse().getHeaders().add("Cache-Control", "max-age=" + longCache + ", public");
                              } else if (label.equals("snapshot") || all.isUnreleased(label)) {
                                ctx.getResponse().getHeaders().add("Cache-Control", "max-age=" + shortCache + ", public");
                              }

                              RatpackVersion version;
                              switch (label) {
                                case "current":
                                  version = all.getCurrent();
                                  break;
                                case "snapshot":
                                  version = all.getSnapshot();
                                  break;
                                default:
                                  version = all.version(label);
                                  if (version == null) {
                                    ctx.clientError(404);
                                    return;
                                  }
                                  break;
                              }

                              ctx.next(Registry.single(ctx.getFileSystemBinding().binding(version.getVersion())));
                            });
                          })
                          .files(f -> f.indexFiles("index.html"))
                      )
                  )

              )

              .get("favicon.ico", ctx -> {
                ctx.getResponse().getHeaders().add("Cache-Control", "max-age=" + longCache + ", public");
                ctx.next();
              })
              .files(f -> f.dir("public").indexFiles("index.html"));
          });
      }
    );
  }
}

<code block>



package ratpack.jackson;
<code block>


package ratpack.jackson;

import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;
import com.fasterxml.jackson.core.util.MinimalPrettyPrinter;
import com.fasterxml.jackson.databind.Module;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.ObjectReader;
import com.fasterxml.jackson.databind.ObjectWriter;
import com.google.common.collect.Lists;
import com.google.inject.Provides;
import ratpack.guice.ConfigurableModule;
import ratpack.parse.NullParseOpts;
import ratpack.parse.Parser;
import ratpack.render.Renderer;

import javax.inject.Singleton;
import java.util.Arrays;
import java.util.List;
import java.util.function.Consumer;


@SuppressWarnings("UnusedDeclaration")
public class JacksonModule extends ConfigurableModule<JacksonModule.Config> {


  public static class Config {
    private boolean prettyPrint = true;
    private List<Module> modules = Lists.newLinkedList();
    private List<Consumer<? super ObjectMapper>> configurers = Lists.newLinkedList();


    public boolean isPrettyPrint() {
      return prettyPrint;
    }


    public Config prettyPrint(boolean prettyPrint) {
      this.prettyPrint = prettyPrint;
      return this;
    }


    public List<Module> getModules() {
      return modules;
    }


    public Config modules(Iterable<Module> modules) {
      this.modules.addAll(Lists.newArrayList(modules));
      return this;
    }


    public Config modules(Module... modules) {
      return modules(Arrays.asList(modules));
    }


    public Config withMapper(Consumer<? super ObjectMapper> configurer) {
      this.configurers.add(configurer);
      return this;
    }
  }

  @Override
  protected void configure() {
  }

  @Provides
  @Singleton
  protected ObjectMapper objectMapper(Config config) {
    ObjectMapper objectMapper = new ObjectMapper();
    objectMapper.registerModules(config.getModules());
    for (Consumer<? super ObjectMapper> configurer : config.configurers) {
      configurer.accept(objectMapper);
    }
    return objectMapper;
  }

  @Provides
  @Singleton
  protected ObjectWriter objectWriter(ObjectMapper objectMapper, Config config) {
    return objectMapper.writer(config.isPrettyPrint() ? new DefaultPrettyPrinter() : new MinimalPrettyPrinter());
  }

  @Provides
  @Singleton
  protected ObjectReader objectReader(ObjectMapper objectMapper) {
    return objectMapper.reader();
  }

  @Provides
  @Singleton
  protected Renderer<JsonRender> renderer(ObjectWriter objectWriter) {
    return Jackson.Init.renderer(objectWriter);
  }

  @Provides
  @Singleton
  protected Parser<NullParseOpts> noOptParser() {
    return Jackson.Init.noOptParser();
  }

  @Provides
  @Singleton
  protected Parser<JsonParseOpts> parser(ObjectMapper objectMapper) {
    return Jackson.Init.parser(objectMapper);
  }

}

<code block>

package ratpack.spring;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static ratpack.jackson.Jackson.json;

import java.util.Collections;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.test.IntegrationTest;
import org.springframework.boot.test.SpringApplicationConfiguration;
import org.springframework.boot.test.TestRestTemplate;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import ratpack.func.Action;
import ratpack.handling.Chain;
import ratpack.jackson.guice.JacksonModule;
import ratpack.server.RatpackServer;
import ratpack.spring.ApplicationTests.Application;
import ratpack.spring.config.EnableRatpack;

@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = Application.class)
@IntegrationTest({ "debug=true", "server.port=0" })
public class ApplicationTests {

  private TestRestTemplate restTemplate = new TestRestTemplate();

  @Autowired
  private RatpackServer server;

  @Test
  public void homePage() {
    assertEquals(
        "{" + System.getProperty("line.separator") + "  \"message\" : \"Hello World\""
            + System.getProperty("line.separator") + "}",
        restTemplate.getForObject("http://localhost:" + server.getBindPort(), String.class));
  }

  @Test
  public void notFound() {
    ResponseEntity<String> response = restTemplate.getForEntity("http://localhost:" + server.getBindPort() + "/none",
        String.class);
    assertEquals(HttpStatus.NOT_FOUND, response.getStatusCode());
    assertNull("Default 404 handler has null body", response.getBody());
  }

  @Configuration
  @EnableAutoConfiguration
  @EnableRatpack
  @Import(MessageService.class)
  protected static class Application {

    @Autowired
    private MessageService service;

    @Bean
    public Action<Chain> handler() {
      return chain -> chain.get(context -> {


        assertNotNull(context.get(MessageService.class));
        context.render(json(Collections.singletonMap("message", service.message())));
      });
    }

    @Bean
    public JacksonModule jacksonGuiceModule() {
      JacksonModule module = new JacksonModule();
      module.configure(config -> {
        config.prettyPrint(true);
      });
      return module;
    }

    public static void main(String[] args) throws Exception {
      SpringApplication.run(Application.class, args);
    }

  }

  @Service
  protected static class MessageService {

    public String message() {
      return "Hello World";
    }

  }

}

<code block>

package ratpack.spring;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static ratpack.jackson.Jackson.fromJson;
import static ratpack.jackson.Jackson.json;

import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.Map;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.test.IntegrationTest;
import org.springframework.boot.test.SpringApplicationConfiguration;
import org.springframework.boot.test.TestRestTemplate;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import ratpack.func.Action;
import ratpack.handling.Chain;
import ratpack.handling.Handler;
import ratpack.jackson.guice.JacksonModule;
import ratpack.server.RatpackServer;
import ratpack.spring.JsonTests.Application;
import ratpack.spring.config.EnableRatpack;

@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = Application.class)
@IntegrationTest("server.port=0")
public class JsonTests {

  private TestRestTemplate restTemplate = new TestRestTemplate();

  @Autowired
  private RatpackServer server;

  @Test
  public void get() {
    String body = restTemplate.getForObject("http://localhost:" + server.getBindPort(), String.class);
    assertTrue("Wrong body" + body, body.contains("{"));
    assertFalse("Wrong body" + body, body.toLowerCase().contains("<html"));
  }

  @Test
  public void post() {
    HttpHeaders headers = new HttpHeaders();
    headers.setContentType(MediaType.APPLICATION_JSON);
    HttpEntity<Map<String, String>> entity = new HttpEntity<Map<String, String>>(Collections.singletonMap("foo", "bar"),
        headers);
    ResponseEntity<String> result = restTemplate.postForEntity("http://localhost:" + server.getBindPort(), entity,
        String.class);
    assertEquals(HttpStatus.OK, result.getStatusCode());
    String body = restTemplate.getForObject("http://localhost:" + server.getBindPort(), String.class);
    assertTrue("Wrong body" + body, body.contains("foo"));
  }

  @Configuration
  @EnableRatpack
  @EnableAutoConfiguration
  protected static class Application {

    private Map<String, Object> map = new LinkedHashMap<String, Object>();

    @Bean
    public Action<Chain> chain() {
      return chain -> chain.all(handler());
    }

    @SuppressWarnings("unchecked")
    @Bean
    public Handler handler() {

      return context -> context.byMethod(spec -> spec.get(() -> context.render(json(map))).post(() -> {
        map.putAll(context.parse(fromJson(Map.class)));
        context.render(json(map));
      }));

    }

    @Bean
    public JacksonModule jacksonGuiceModule() {
      return new JacksonModule();
    }

    public static void main(String[] args) throws Exception {
      SpringApplication.run(Application.class, args);
    }

  }

}

<code block>


package ratpack.site;

import ratpack.codahale.metrics.CodaHaleMetricsModule;
import ratpack.func.Block;
import ratpack.func.Pair;
import ratpack.groovy.template.MarkupTemplateModule;
import ratpack.groovy.template.TextTemplateModule;
import ratpack.guice.Guice;
import ratpack.jackson.guice.JacksonModule;
import ratpack.newrelic.NewRelicModule;
import ratpack.registry.Registry;
import ratpack.rx.RxRatpack;
import ratpack.server.RatpackServer;
import ratpack.server.ServerConfig;
import ratpack.site.github.GitHubApi;
import ratpack.site.github.GitHubData;
import ratpack.site.github.RatpackVersion;
import ratpack.site.github.RatpackVersions;
import asset.pipeline.ratpack.AssetPipelineModule;

import static ratpack.groovy.Groovy.groovyMarkupTemplate;

public class SiteMain {
  public static void main(String... args) throws Exception {
    RatpackServer.start(b -> {
        RxRatpack.initialize();
        ServerConfig serverConfig = ServerConfig.findBaseDir()
          .env()
          .require("/github", SiteModule.GitHubConfig.class)
          .build();

        b
          .serverConfig(serverConfig)
          .registry(
            Guice.registry(s -> s
                .module(JacksonModule.class)
                .module(NewRelicModule.class)
                .module(new AssetPipelineModule())
                .module(new CodaHaleMetricsModule(), c ->
                    c.csv(csv -> csv.enable(false))
                )
                .module(SiteModule.class)
                .module(MarkupTemplateModule.class, conf -> {
                  conf.setAutoNewLine(true);
                  conf.setUseDoubleQuotes(true);
                  conf.setAutoIndent(true);
                })
                .module(TextTemplateModule.class, conf ->
                    conf.setStaticallyCompile(true)
                )
            )
          )
          .handlers(c -> {

            int longCache = 60 * 60 * 24 * 365; 
            int shortCache = 60 * 10; 

            c
              .all(ctx -> {

                String host = ctx.getRequest().getHeaders().get("host");
                if (host != null && (host.endsWith("ratpack-framework.org") || host.equals("www.ratpack.io"))) {
                  ctx.redirect(301, "http://ratpack.io" + ctx.getRequest().getRawUri());
                  return;
                }

                if (ctx.getRequest().getPath().isEmpty() || ctx.getRequest().getPath().equals("index.html")) {
                  ctx.getResponse().getHeaders().set("X-UA-Compatible", "IE=edge,chrome=1");
                }

                ctx.next();
              })

              .prefix("assets", assets -> assets
                  .all(ctx -> {
                    int cacheFor = ctx.getRequest().getQuery().isEmpty() ? shortCache : longCache;
                    ctx.getResponse().getHeaders().add("Cache-Control", "max-age=" + cacheFor + ", public");
                    ctx.next();
                  })
                  .files(f -> f.dir("assets").indexFiles("index.html"))
              )

              .get("index.html", ctx -> {
                ctx.redirect(301, "/");
              })

              .get(ctx -> ctx.render(groovyMarkupTemplate("index.gtpl")))

              .path("reset", ctx -> {
                GitHubApi gitHubApi = ctx.get(GitHubApi.class);
                ctx.byMethod(methods -> {
                  Block impl = () -> {
                    gitHubApi.invalidateCache();
                    ctx.render("ok");
                  };
                  if (ctx.getServerConfig().isDevelopment()) {
                    methods.get(impl);
                  }
                  methods.post(impl);
                });
              })

              .prefix("versions", v -> v
                  .get(ctx ->
                      ctx.render(
                        ctx.get(RatpackVersions.class).getAll()
                          .map(all -> groovyMarkupTemplate("versions.gtpl", m -> m.put("versions", all)))
                      )
                  )
                  .get(":version", ctx ->
                      ctx.render(
                        ctx.get(RatpackVersions.class).getAll()
                          .map(all -> all.version(ctx.getAllPathTokens().get("version")))
                          .onNull(() -> ctx.clientError(404))
                          .flatMap(version -> ctx.get(GitHubData.class).closed(version).map(i -> Pair.of(version, i)))
                          .map(p -> groovyMarkupTemplate("version.gtpl", m -> m.put("version", p.left).put("issues", p.right)))
                      )
                  )
              )

              .prefix("manual", c1 -> c1
                  .fileSystem("manual", c2 -> c2
                      .get(ctx -> ctx.redirect(301, "manual/current"))
                      .prefix(":label", c3 -> c3
                          .all(ctx -> {
                            String label = ctx.getPathTokens().get("label");

                            ctx.get(RatpackVersions.class).getAll().then(all -> {
                              if (label.equals("current") || all.isReleased(label)) {
                                ctx.getResponse().getHeaders().add("Cache-Control", "max-age=" + longCache + ", public");
                              } else if (label.equals("snapshot") || all.isUnreleased(label)) {
                                ctx.getResponse().getHeaders().add("Cache-Control", "max-age=" + shortCache + ", public");
                              }

                              RatpackVersion version;
                              switch (label) {
                                case "current":
                                  version = all.getCurrent();
                                  break;
                                case "snapshot":
                                  version = all.getSnapshot();
                                  break;
                                default:
                                  version = all.version(label);
                                  if (version == null) {
                                    ctx.clientError(404);
                                    return;
                                  }
                                  break;
                              }

                              ctx.next(Registry.single(ctx.getFileSystemBinding().binding(version.getVersion())));
                            });
                          })
                          .files(f -> f.indexFiles("index.html"))
                      )
                  )

              )

              .get("favicon.ico", ctx -> {
                ctx.getResponse().getHeaders().add("Cache-Control", "max-age=" + longCache + ", public");
                ctx.next();
              })
              .files(f -> f.dir("public").indexFiles("index.html"));
          });
      }
    );
  }
}

<code block>



package ratpack.jackson;

<code block>



package ratpack.jackson.guice;

<code block>


package ratpack.jackson.guice;

import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;
import com.fasterxml.jackson.core.util.MinimalPrettyPrinter;
import com.fasterxml.jackson.databind.Module;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.ObjectReader;
import com.fasterxml.jackson.databind.ObjectWriter;
import com.google.common.collect.Lists;
import com.google.inject.Provides;
import ratpack.guice.ConfigurableModule;
import ratpack.jackson.Jackson;
import ratpack.jackson.JsonParseOpts;
import ratpack.jackson.JsonRender;
import ratpack.parse.NullParseOpts;
import ratpack.parse.Parser;
import ratpack.render.Renderer;

import javax.inject.Singleton;
import java.util.Arrays;
import java.util.List;
import java.util.function.Consumer;


@SuppressWarnings("UnusedDeclaration")
public class JacksonModule extends ConfigurableModule<JacksonModule.Config> {


  public static class Config {
    private boolean prettyPrint = true;
    private List<Module> modules = Lists.newLinkedList();
    private List<Consumer<? super ObjectMapper>> configurers = Lists.newLinkedList();


    public boolean isPrettyPrint() {
      return prettyPrint;
    }


    public Config prettyPrint(boolean prettyPrint) {
      this.prettyPrint = prettyPrint;
      return this;
    }


    public List<Module> getModules() {
      return modules;
    }


    public Config modules(Iterable<Module> modules) {
      this.modules.addAll(Lists.newArrayList(modules));
      return this;
    }


    public Config modules(Module... modules) {
      return modules(Arrays.asList(modules));
    }


    public Config withMapper(Consumer<? super ObjectMapper> configurer) {
      this.configurers.add(configurer);
      return this;
    }
  }

  @Override
  protected void configure() {
  }

  @Provides
  @Singleton
  protected ObjectMapper objectMapper(Config config) {
    ObjectMapper objectMapper = new ObjectMapper();
    objectMapper.registerModules(config.getModules());
    for (Consumer<? super ObjectMapper> configurer : config.configurers) {
      configurer.accept(objectMapper);
    }
    return objectMapper;
  }

  @Provides
  @Singleton
  protected ObjectWriter objectWriter(ObjectMapper objectMapper, Config config) {
    return objectMapper.writer(config.isPrettyPrint() ? new DefaultPrettyPrinter() : new MinimalPrettyPrinter());
  }

  @Provides
  @Singleton
  protected ObjectReader objectReader(ObjectMapper objectMapper) {
    return objectMapper.reader();
  }

  @Provides
  @Singleton
  protected Renderer<JsonRender> renderer(ObjectWriter objectWriter) {
    return Jackson.Init.renderer(objectWriter);
  }

  @Provides
  @Singleton
  protected Parser<NullParseOpts> noOptParser() {
    return Jackson.Init.noOptParser();
  }

  @Provides
  @Singleton
  protected Parser<JsonParseOpts> parser(ObjectMapper objectMapper) {
    return Jackson.Init.parser(objectMapper);
  }

}
