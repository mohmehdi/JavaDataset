
package com.github.mobile.accounts;

import static android.content.Intent.ACTION_VIEW;
import static android.content.Intent.CATEGORY_BROWSABLE;
import static com.github.mobile.accounts.AccountConstants.PROVIDER_AUTHORITY;
import android.accounts.Account;
import android.accounts.AccountManager;
import android.app.AlertDialog;
import android.app.Application;
import android.content.ComponentName;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.content.pm.LabeledIntent;
import android.content.pm.ResolveInfo;
import android.net.Uri;
import android.os.Bundle;
import android.support.v7.widget.Toolbar;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;
import android.widget.Toast;

import com.alorma.github.basesdk.ApiClient;
import com.alorma.github.basesdk.client.BaseClient;
import com.alorma.github.sdk.bean.dto.response.Token;
import com.alorma.github.sdk.login.AccountsHelper;
import com.alorma.github.sdk.security.GitHub;
import com.alorma.github.sdk.services.login.RequestTokenClient;
import com.alorma.github.sdk.services.user.GetAuthUserClient;
import com.github.mobile.R;
import com.github.mobile.persistence.AccountDataManager;
import com.github.mobile.ui.LightProgressDialog;
import com.github.mobile.ui.MainActivity;
import com.github.mobile.ui.roboactivities.RoboActionBarAccountAuthenticatorActivity;
import com.google.inject.Inject;
import com.squareup.okhttp.HttpUrl;

import java.util.ArrayList;
import java.util.List;

import org.eclipse.egit.github.core.User;

import retrofit.ErrorHandler;
import retrofit.RetrofitError;
import retrofit.client.Response;


public class LoginActivity extends RoboActionBarAccountAuthenticatorActivity implements BaseClient.OnResultCallback<com.alorma.github.sdk.bean.dto.response.User> {


    public static final String PARAM_AUTHTOKEN_TYPE = "authtokenType";


    public static final String PARAM_USERNAME = "username";

    public static final String OAUTH_HOST = "www.github.com";

    private static final String TAG = "LoginActivity";


    private static final long SYNC_PERIOD = 8L * 60L * 60L;

    public static void configureSyncFor(Account account) {
        Log.d(TAG, "Configuring account sync");

        ContentResolver.setIsSyncable(account, PROVIDER_AUTHORITY, 1);
        ContentResolver.setSyncAutomatically(account, PROVIDER_AUTHORITY, true);
        ContentResolver.addPeriodicSync(account, PROVIDER_AUTHORITY,
            new Bundle(), SYNC_PERIOD);
    }

    public static class AccountLoader extends
        AuthenticatedUserTask<List<User>> {

        @Inject
        private AccountDataManager cache;

        protected AccountLoader(Context context) {
            super(context);
        }

        @Override
        protected List<User> run(Account account) throws Exception {
            return cache.getOrgs(true);
        }
    }

    private AccountManager accountManager;

    private Account[] accounts;

    private String accessToken;

    private String scope;

    private RequestTokenClient requestTokenClient;

    private AlertDialog progressDialog;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.login);

        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
        setSupportActionBar(toolbar);

        accountManager = AccountManager.get(this);

        accounts = accountManager.getAccountsByType(getString(R.string.account_type));

        if (accounts != null && accounts.length > 0)
            openMain();
    }

    @Override
    protected void onNewIntent(Intent intent) {
        super.onNewIntent(intent);
        Uri uri = intent.getData();
        if(uri != null && uri.getScheme().equals(getString(R.string.github_oauth_scheme))){
            openLoadingDialog();
            String code = uri.getQueryParameter("code");

            if (requestTokenClient == null) {
                requestTokenClient = new RequestTokenClient(LoginActivity.this, code);
                requestTokenClient.setOnResultCallback(new BaseClient.OnResultCallback<Token>() {
                    @Override
                    public void onResponseOk(Token token, Response r) {
                        if (token.access_token != null) {
                            endAccess(token.access_token, token.scope);
                        } else if (token.error != null) {
                            Toast.makeText(LoginActivity.this, token.error, Toast.LENGTH_LONG).show();
                            progressDialog.dismiss();
                        }
                    }

                    @Override
                    public void onFail(RetrofitError error) {
                        error.printStackTrace();
                    }
                });
                requestTokenClient.execute();
            }
        }
    }

    private void openMain() {
        progressDialog.dismiss();
        Intent intent = new Intent(this, MainActivity.class);
        startActivity(intent);
        finish();
    }

    private void openLoadingDialog() {
        progressDialog = LightProgressDialog.create(this,
                R.string.login_activity_authenticating);
        progressDialog.show();
    }

    @Override
    public void startActivity(Intent intent) {
        if (intent != null && ACTION_VIEW.equals(intent.getAction()))
            intent.addCategory(CATEGORY_BROWSABLE);

        super.startActivity(intent);
    }

    public void handleLogin() {
        openLoginInBrowser(new GitHub(this));
    }

    private void openLoginInBrowser(ApiClient client) {
        String initialScope = "user,public_repo,repo,delete_repo,notifications,gist";
        HttpUrl.Builder url = new HttpUrl.Builder()
                .scheme("https")
                .host(OAUTH_HOST)
                .addPathSegment("login")
                .addPathSegment("oauth")
                .addPathSegment("authorize")
                .addQueryParameter("client_id", client.getApiClient())
                .addQueryParameter("scope", initialScope);

        final List<ResolveInfo> browserList = getBrowserList();

        final List<LabeledIntent> intentList = new ArrayList<>();

        for (final ResolveInfo resolveInfo : browserList) {
            final Intent newIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(url.build().toString()));
            newIntent.setComponent(new ComponentName(resolveInfo.activityInfo.packageName,
                    resolveInfo.activityInfo.name));

            intentList.add(new LabeledIntent(newIntent,
                    resolveInfo.resolvePackageName,
                    resolveInfo.labelRes,
                    resolveInfo.icon));
        }

        final Intent chooser = Intent.createChooser(intentList.remove(0), "Choose your favorite browser");
        LabeledIntent[] extraIntents = intentList.toArray( new LabeledIntent[ intentList.size() ]);
        chooser.putExtra(Intent.EXTRA_INITIAL_INTENTS, extraIntents);

        startActivity(chooser);
    }

    private List<ResolveInfo> getBrowserList() {
        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse("http://sometesturl.com"));

        return getPackageManager().queryIntentActivities(intent, 0);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.m_login:
                handleLogin();
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }

    }

    @Override
    public void onResponseOk(com.alorma.github.sdk.bean.dto.response.User user, Response r) {
        Account account = new Account(user.login, getString(R.string.account_type));
        Bundle userData = AccountsHelper.buildBundle(user.name, user.email, user.avatar_url, scope);
        userData.putString(AccountManager.KEY_AUTHTOKEN, accessToken);

        accountManager.addAccountExplicitly(account, null, userData);
        accountManager.setAuthToken(account, getString(R.string.account_type), accessToken);

        Bundle result = new Bundle();
        result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);
        result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);
        result.putString(AccountManager.KEY_AUTHTOKEN, accessToken);

        setAccountAuthenticatorResult(result);

        openMain();
    }

    @Override
    public void onFail(RetrofitError error) {
        error.printStackTrace();
    }

    private void endAccess(String accessToken, String scope) {
        this.accessToken = accessToken;
        this.scope = scope;

        progressDialog.setMessage(getString(R.string.loading_user));

        GetAuthUserClient userClient = new GetAuthUserClient(this, accessToken);
        userClient.setOnResultCallback(this);
        userClient.execute();
    }

    @Override
    public boolean onCreateOptionsMenu(Menu optionMenu) {
        getMenuInflater().inflate(R.menu.login, optionMenu);
        return true;
    }
}
<code block>
package com.github.mobile.accounts;

import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.support.v7.app.AppCompatActivity;
import android.webkit.WebViewClient;

import com.github.mobile.R;
import com.github.mobile.ui.WebView;

public class LoginWebViewActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        WebView webView = new WebView(this);
        webView.loadUrl(getIntent().getStringExtra(LoginActivity.INTENT_EXTRA_URL));
        webView.setWebViewClient(new WebViewClient() {
            @Override
            public boolean shouldOverrideUrlLoading(android.webkit.WebView view, String url) {
                Uri uri = Uri.parse(url);
                if (uri.getScheme().equals(getString(R.string.github_oauth_scheme))) {
                    Intent data = new Intent();
                    data.setData(uri);
                    setResult(RESULT_OK, data);
                    finish();
                    return true;
                }
                return super.shouldOverrideUrlLoading(view, url);
            }
        });

        setContentView(webView);
    }
}
<code block>

package com.github.mobile.accounts;

import static com.github.mobile.accounts.AccountConstants.PROVIDER_AUTHORITY;
import android.accounts.Account;
import android.accounts.AccountManager;
import android.app.AlertDialog;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.support.v7.widget.Toolbar;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;
import android.widget.Toast;

import com.alorma.github.basesdk.ApiClient;
import com.alorma.github.basesdk.client.BaseClient;
import com.alorma.github.sdk.bean.dto.response.Token;
import com.alorma.github.sdk.login.AccountsHelper;
import com.alorma.github.sdk.security.GitHub;
import com.alorma.github.sdk.services.login.RequestTokenClient;
import com.alorma.github.sdk.services.user.GetAuthUserClient;
import com.github.mobile.R;
import com.github.mobile.persistence.AccountDataManager;
import com.github.mobile.ui.LightProgressDialog;
import com.github.mobile.ui.MainActivity;
import com.github.mobile.ui.roboactivities.RoboActionBarAccountAuthenticatorActivity;
import com.google.inject.Inject;
import com.squareup.okhttp.HttpUrl;

import java.util.List;

import org.eclipse.egit.github.core.User;

import retrofit.RetrofitError;
import retrofit.client.Response;


public class LoginActivity extends RoboActionBarAccountAuthenticatorActivity implements BaseClient.OnResultCallback<com.alorma.github.sdk.bean.dto.response.User> {


    public static final String PARAM_AUTHTOKEN_TYPE = "authtokenType";


    public static final String PARAM_USERNAME = "username";

    public static final String OAUTH_HOST = "www.github.com";

    public static final String INTENT_EXTRA_URL = "url";

    private static int WEBVIEW_REQUEST_CODE = 0;

    private static final String TAG = "LoginActivity";


    private static final long SYNC_PERIOD = 8L * 60L * 60L;

    public static void configureSyncFor(Account account) {
        Log.d(TAG, "Configuring account sync");

        ContentResolver.setIsSyncable(account, PROVIDER_AUTHORITY, 1);
        ContentResolver.setSyncAutomatically(account, PROVIDER_AUTHORITY, true);
        ContentResolver.addPeriodicSync(account, PROVIDER_AUTHORITY,
            new Bundle(), SYNC_PERIOD);
    }

    public static class AccountLoader extends
        AuthenticatedUserTask<List<User>> {

        @Inject
        private AccountDataManager cache;

        protected AccountLoader(Context context) {
            super(context);
        }

        @Override
        protected List<User> run(Account account) throws Exception {
            return cache.getOrgs(true);
        }
    }

    private AccountManager accountManager;

    private Account[] accounts;

    private String accessToken;

    private String scope;

    private RequestTokenClient requestTokenClient;

    private AlertDialog progressDialog;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.login);

        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
        setSupportActionBar(toolbar);

        accountManager = AccountManager.get(this);

        accounts = accountManager.getAccountsByType(getString(R.string.account_type));

        if (accounts != null && accounts.length > 0)
            openMain();
    }

    @Override
    protected void onNewIntent(Intent intent) {
        super.onNewIntent(intent);
        Uri uri = intent.getData();
        onUserLoggedIn(uri);
    }

    private void onUserLoggedIn(Uri uri) {
        if (uri != null && uri.getScheme().equals(getString(R.string.github_oauth_scheme))) {
            openLoadingDialog();
            String code = uri.getQueryParameter("code");
            if (requestTokenClient == null) {
                requestTokenClient = new RequestTokenClient(LoginActivity.this, code);
                requestTokenClient.setOnResultCallback(new BaseClient.OnResultCallback<Token>() {
                    @Override
                    public void onResponseOk(Token token, Response r) {
                        if (token.access_token != null) {
                            endAuth(token.access_token, token.scope);
                        } else if (token.error != null) {
                            Toast.makeText(LoginActivity.this, token.error, Toast.LENGTH_LONG).show();
                            progressDialog.dismiss();
                        }
                    }

                    @Override
                    public void onFail(RetrofitError error) {
                        error.printStackTrace();
                    }
                });
                requestTokenClient.execute();
            }
        }
    }

    private void openMain() {
        if(progressDialog != null)
            progressDialog.dismiss();
        Intent intent = new Intent(this, MainActivity.class);
        startActivity(intent);
        finish();
    }

    private void openLoadingDialog() {
        progressDialog = LightProgressDialog.create(this,
                R.string.login_activity_authenticating);
        progressDialog.show();
    }

    public void handleLogin() {
        openLoginInBrowser(new GitHub(this));
    }

    private void openLoginInBrowser(ApiClient client) {
        String initialScope = "user,public_repo,repo,delete_repo,notifications,gist";
        HttpUrl.Builder url = new HttpUrl.Builder()
                .scheme("https")
                .host(OAUTH_HOST)
                .addPathSegment("login")
                .addPathSegment("oauth")
                .addPathSegment("authorize")
                .addQueryParameter("client_id", client.getApiClient())
                .addQueryParameter("scope", initialScope);

        Intent intent = new Intent(this, LoginWebViewActivity.class);
        intent.putExtra(INTENT_EXTRA_URL, url.toString());
        startActivityForResult(intent, WEBVIEW_REQUEST_CODE);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if(requestCode == WEBVIEW_REQUEST_CODE && resultCode == RESULT_OK)
            onUserLoggedIn(data.getData());
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.m_login:
                handleLogin();
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    public void onResponseOk(com.alorma.github.sdk.bean.dto.response.User user, Response r) {
        Account account = new Account(user.login, getString(R.string.account_type));
        Bundle userData = AccountsHelper.buildBundle(user.name, user.email, user.avatar_url, scope);
        userData.putString(AccountManager.KEY_AUTHTOKEN, accessToken);

        accountManager.addAccountExplicitly(account, null, userData);
        accountManager.setAuthToken(account, getString(R.string.account_type), accessToken);

        Bundle result = new Bundle();
        result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);
        result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);
        result.putString(AccountManager.KEY_AUTHTOKEN, accessToken);

        setAccountAuthenticatorResult(result);

        openMain();
    }

    @Override
    public void onFail(RetrofitError error) {
        error.printStackTrace();
    }

    private void endAuth(String accessToken, String scope) {
        this.accessToken = accessToken;
        this.scope = scope;

        progressDialog.setMessage(getString(R.string.loading_user));

        GetAuthUserClient userClient = new GetAuthUserClient(this, accessToken);
        userClient.setOnResultCallback(this);
        userClient.execute();
    }

    @Override
    public boolean onCreateOptionsMenu(Menu optionMenu) {
        getMenuInflater().inflate(R.menu.login, optionMenu);
        return true;
    }
}
<code block>

package com.github.mobile.tests;

import com.github.mobile.ui.issue.FiltersViewActivity;


public class FiltersViewActivityTest extends ActivityTest<FiltersViewActivity> {


    public FiltersViewActivityTest() {
        super(FiltersViewActivity.class);
    }
}

<code block>

package com.github.mobile.tests;

import static org.eclipse.egit.github.core.event.Event.TYPE_COMMIT_COMMENT;
import static org.eclipse.egit.github.core.event.Event.TYPE_CREATE;
import static org.eclipse.egit.github.core.event.Event.TYPE_DELETE;
import static org.eclipse.egit.github.core.event.Event.TYPE_FOLLOW;
import static org.eclipse.egit.github.core.event.Event.TYPE_GIST;
import static org.eclipse.egit.github.core.event.Event.TYPE_GOLLUM;
import static org.eclipse.egit.github.core.event.Event.TYPE_ISSUES;
import static org.eclipse.egit.github.core.event.Event.TYPE_ISSUE_COMMENT;
import static org.eclipse.egit.github.core.event.Event.TYPE_MEMBER;
import static org.eclipse.egit.github.core.event.Event.TYPE_PUBLIC;
import static org.eclipse.egit.github.core.event.Event.TYPE_PULL_REQUEST;
import static org.eclipse.egit.github.core.event.Event.TYPE_PUSH;
import static org.eclipse.egit.github.core.event.Event.TYPE_TEAM_ADD;
import static org.eclipse.egit.github.core.event.Event.TYPE_WATCH;
import android.content.Context;
import android.test.InstrumentationTestCase;
import android.test.UiThreadTest;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.TextView;

import com.github.mobile.R.id;
import com.github.mobile.ui.user.NewsListAdapter;
import com.github.mobile.util.AvatarLoader;

import java.util.Date;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.Team;
import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.event.CommitCommentPayload;
import org.eclipse.egit.github.core.event.CreatePayload;
import org.eclipse.egit.github.core.event.DeletePayload;
import org.eclipse.egit.github.core.event.Event;
import org.eclipse.egit.github.core.event.EventRepository;
import org.eclipse.egit.github.core.event.FollowPayload;
import org.eclipse.egit.github.core.event.GistPayload;
import org.eclipse.egit.github.core.event.IssueCommentPayload;
import org.eclipse.egit.github.core.event.IssuesPayload;
import org.eclipse.egit.github.core.event.MemberPayload;
import org.eclipse.egit.github.core.event.PullRequestPayload;
import org.eclipse.egit.github.core.event.PushPayload;
import org.eclipse.egit.github.core.event.TeamAddPayload;


public class NewsEventTextTest extends InstrumentationTestCase {

    private NewsListAdapter adapter;

    private TextView text;

    private User actor;

    private EventRepository repo;

    private Date date;

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        date = new Date();
        actor = new User().setLogin("user");
        repo = new EventRepository().setName("user/repo");

        Context context = getInstrumentation().getTargetContext();
        adapter = new NewsListAdapter(LayoutInflater.from(context),
                new AvatarLoader(context));
    }

    private Event createEvent(String type) {
        Event event = new Event();
        event.setCreatedAt(date);
        event.setType(type);
        event.setActor(actor);
        event.setRepo(repo);
        return event;
    }

    private void verify(String expected) {
        CharSequence actual = text.getText();
        assertNotNull(actual);
        assertEquals(expected, actual.toString());
    }

    private void updateView(Event event) {
        adapter.setItems(new Object[] { event });
        View view = adapter.getView(0, null, null);
        assertNotNull(view);
        text = (TextView) view.findViewById(id.tv_event);
        assertNotNull(text);
    }


    @UiThreadTest
    public void testCommitCommentEvent() {
        Event event = createEvent(TYPE_COMMIT_COMMENT);
        event.setPayload(new CommitCommentPayload());
        updateView(event);

        verify("user commented on user/repo");
    }


    @UiThreadTest
    public void testCreateRepositoryEvent() {
        Event event = createEvent(TYPE_CREATE);
        CreatePayload payload = new CreatePayload();
        payload.setRefType("repository");
        event.setPayload(payload);
        updateView(event);

        verify("user created repository repo");
    }


    @UiThreadTest
    public void testCreateBranchEvent() {
        Event event = createEvent(TYPE_CREATE);
        CreatePayload payload = new CreatePayload();
        payload.setRefType("branch");
        payload.setRef("b1");
        event.setPayload(payload);
        updateView(event);

        verify("user created branch b1 at user/repo");
    }


    @UiThreadTest
    public void testDelete() {
        Event event = createEvent(TYPE_DELETE);
        DeletePayload payload = new DeletePayload();
        payload.setRefType("branch");
        payload.setRef("b1");
        event.setPayload(payload);
        updateView(event);

        verify("user deleted branch b1 at user/repo");
    }


    @UiThreadTest
    public void testFollow() {
        Event event = createEvent(TYPE_FOLLOW);
        FollowPayload payload = new FollowPayload();
        payload.setTarget(new User().setLogin("user2"));
        event.setPayload(payload);
        updateView(event);

        verify("user started following user2");
    }


    @UiThreadTest
    public void testGist() {
        Event event = createEvent(TYPE_GIST);
        GistPayload payload = new GistPayload();
        payload.setAction("create");
        payload.setGist(new Gist().setId("1"));
        event.setPayload(payload);
        updateView(event);

        verify("user created Gist 1");
    }


    @UiThreadTest
    public void testWiki() {
        Event event = createEvent(TYPE_GOLLUM);
        updateView(event);

        verify("user updated the wiki in user/repo");
    }


    @UiThreadTest
    public void testIssueComment() {
        Event event = createEvent(TYPE_ISSUE_COMMENT);
        IssueCommentPayload payload = new IssueCommentPayload();
        payload.setIssue(new Issue().setNumber(5));
        event.setPayload(payload);
        updateView(event);

        verify("user commented on issue 5 on user/repo");
    }


    @UiThreadTest
    public void testIssue() {
        Event event = createEvent(TYPE_ISSUES);
        IssuesPayload payload = new IssuesPayload();
        payload.setAction("closed");
        payload.setIssue(new Issue().setNumber(8));
        event.setPayload(payload);
        updateView(event);

        verify("user closed issue 8 on user/repo");
    }


    @UiThreadTest
    public void testAddMember() {
        Event event = createEvent(TYPE_MEMBER);
        event.setPayload(new MemberPayload().setMember(new User()
                .setLogin("person")));
        updateView(event);

        verify("user added person as a collaborator to user/repo");
    }


    @UiThreadTest
    public void testOpenSourced() {
        Event event = createEvent(TYPE_PUBLIC);
        updateView(event);

        verify("user open sourced repository user/repo");
    }


    @UiThreadTest
    public void testWatch() {
        Event event = createEvent(TYPE_WATCH);
        updateView(event);

        verify("user starred user/repo");
    }


    @UiThreadTest
    public void testPullRequest() {
        Event event = createEvent(TYPE_PULL_REQUEST);
        PullRequestPayload payload = new PullRequestPayload();
        payload.setNumber(30);
        payload.setAction("merged");
        event.setPayload(payload);
        updateView(event);

        verify("user merged pull request 30 on user/repo");
    }


    @UiThreadTest
    public void testPush() {
        Event event = createEvent(TYPE_PUSH);
        PushPayload payload = new PushPayload();
        payload.setRef("refs/heads/master");
        event.setPayload(payload);
        updateView(event);

        verify("user pushed to master at user/repo");
    }


    @UiThreadTest
    public void testTeamAdd() {
        Event event = createEvent(TYPE_TEAM_ADD);
        TeamAddPayload payload = new TeamAddPayload();
        payload.setTeam(new Team().setName("t1"));
        payload.setUser(new User().setLogin("u2"));
        event.setPayload(payload);
        updateView(event);

        verify("user added u2 to team t1");
    }
}

<code block>

package com.github.mobile.tests;

import android.app.Activity;
import android.test.ActivityInstrumentationTestCase2;
import android.view.View;
import android.widget.EditText;


public abstract class ActivityTest<T extends Activity> extends
        ActivityInstrumentationTestCase2<T> {


    public ActivityTest(Class<T> activityClass) {
        super(activityClass);
    }


    public void testActivityIsCreated() {
        assertNotNull(getActivity());
    }


    protected EditText editText(final int id) {
        return (EditText) view(id);
    }


    protected View view(final int id) {
        assertNotNull(getActivity());
        View view = getActivity().findViewById(id);
        assertNotNull(view);
        return view;
    }


    protected void focus(final View view) throws Throwable {
        ui(new Runnable() {

            public void run() {
                view.requestFocus();
            }
        });
    }


    protected void ui(Runnable runnable) throws Throwable {
        runTestOnUiThread(runnable);
    }


    protected void send(final String text) {
        getInstrumentation().waitForIdleSync();
        getInstrumentation().sendStringSync(text);
        getInstrumentation().waitForIdleSync();
    }
}

<code block>

package com.github.mobile.tests.user;

import android.net.Uri;
import android.test.AndroidTestCase;

import com.github.mobile.core.user.UserUriMatcher;

import org.eclipse.egit.github.core.User;


public class UserUriMatcherTest extends AndroidTestCase {


    public void testEmptyUri() {
        assertNull(UserUriMatcher.getUser(Uri.parse("")));
    }


    public void testUriWithNoName() {
        assertNull(UserUriMatcher.getUser(Uri.parse("http://github.com")));
        assertNull(UserUriMatcher.getUser(Uri.parse("https://github.com")));
        assertNull(UserUriMatcher.getUser(Uri.parse("http://github.com/")));
        assertNull(UserUriMatcher.getUser(Uri.parse("http://github.com//")));
    }


    public void testHttpUriWithName() {
        User user = UserUriMatcher.getUser(Uri
                .parse("http://github.com/defunkt"));
        assertNotNull(user);
        assertEquals("defunkt", user.getLogin());
    }


    public void testHttpsUriWithName() {
        User user = UserUriMatcher.getUser(Uri
                .parse("https://github.com/mojombo"));
        assertNotNull(user);
        assertEquals("mojombo", user.getLogin());
    }


    public void testUriWithTrailingSlash() {
        User user = UserUriMatcher.getUser(Uri
                .parse("http://github.com/defunkt/"));
        assertNotNull(user);
        assertEquals("defunkt", user.getLogin());
    }


    public void testUriWithTrailingSlashes() {
        User user = UserUriMatcher.getUser(Uri
                .parse("http://github.com/defunkt//"));
        assertNotNull(user);
        assertEquals("defunkt", user.getLogin());
    }
}

<code block>

package com.github.mobile.tests.user;

import android.accounts.Account;
import android.accounts.AccountManager;
import android.test.AndroidTestCase;

import com.github.mobile.accounts.GitHubAccount;
import com.github.mobile.core.user.UserComparator;

import org.eclipse.egit.github.core.User;


public class UserComparatorTest extends AndroidTestCase {


    public void testLoginMatch() {
        GitHubAccount account = new GitHubAccount(new Account("m", "t"),
                AccountManager.get(getContext()));
        UserComparator comparator = new UserComparator(account);

        assertTrue(comparator.compare(new User().setLogin("m"),
                new User().setLogin("a")) < 0);
        assertTrue(comparator.compare(new User().setLogin("a"),
                new User().setLogin("m")) > 0);
        assertTrue(comparator.compare(new User().setLogin("m"),
                new User().setLogin("z")) < 0);
        assertTrue(comparator.compare(new User().setLogin("z"),
                new User().setLogin("m")) > 0);
        assertEquals(
                0,
                comparator.compare(new User().setLogin("m"),
                        new User().setLogin("m")));
    }


    public void testNoLoginMatch() {
        GitHubAccount account = new GitHubAccount(new Account("m", "t"),
                AccountManager.get(getContext()));
        UserComparator comparator = new UserComparator(account);

        assertTrue(comparator.compare(new User().setLogin("a"),
                new User().setLogin("c")) < 0);
        assertTrue(comparator.compare(new User().setLogin("db"),
                new User().setLogin("da")) > 0);
    }
}

<code block>

package com.github.mobile.tests.user;

import android.accounts.AccountManager;

import com.github.mobile.accounts.AccountUtils;
import com.github.mobile.accounts.LoginActivity;
import com.github.mobile.tests.ActivityTest;


public class LoginActivityTest extends ActivityTest<LoginActivity> {


    public LoginActivityTest() {
        super(LoginActivity.class);
    }


    public void testHasAuthenticator() {
        assertTrue(AccountUtils.hasAuthenticator(AccountManager
            .get(getActivity())));
    }

}

<code block>

package com.github.mobile.tests.util;

import android.test.AndroidTestCase;

import com.github.mobile.util.HtmlUtils;


public class HtmlUtilsTest extends AndroidTestCase {

    private String format(String html) {
        CharSequence formatted = HtmlUtils.format(html);
        assertNotNull(formatted);
        return formatted.toString().replace("<githubroot>", "")
                .replace("</githubroot>", "");
    }


    public void testToggleRemoved() {
        String html = "before <span class=\"email-hidden-toggle\"><a href=\"#\">â¦</a></span>after";
        assertEquals("before after", format(html));
    }


    public void testTogglesRemoved() {
        String html = "before <span class=\"email-hidden-toggle\"><a href=\"#\">â¦</a></span>after<span class=\"email-hidden-toggle\"><a href=\"#\">â¦</a></span>";
        assertEquals("before after", format(html));
    }


    public void testEmailQuoted() {
        String html = "before <div class=\"email-quoted-reply\">quoted</div> after";
        assertEquals("before <blockquote>quoted</blockquote> after",
                format(html));
    }


    public void testEmailFragment() {
        String html = "before <div class=\"email-fragment\">in\nside</div> after";
        assertEquals("before in<br>side after", format(html));
    }


    public void testEmailFragments() {
        String html = "before <div class=\"email-fragment\">in\nside</div> after <div class=\"email-fragment\">out\nside</div>";
        assertEquals("before in<br>side after out<br>side", format(html));
    }


    public void testTrailingEmailFragment() {
        String html = "before <div class=\"email-fragment\">in\nside</div>";
        assertEquals("before in<br>side", format(html));
    }


    public void testLeadingBreak() {
        String html = "<br>content";
        assertEquals("content", format(html));
    }


    public void testTrailingBreak() {
        String html = "content<br>";
        assertEquals("content", format(html));
    }


    public void testWrappedBreaks() {
        String html = "<br>content<br>";
        assertEquals("content", format(html));
    }


    public void testWrappedParagraphs() {
        String html = "<p>content</p>";
        assertEquals("content", format(html));
    }


    public void testParagraphReplacedWithBreak() {
        String html = "line1<p>line2</p>";
        assertEquals("line1<br>line2", format(html));
    }


    public void testEmReplacedWithI() {
        String html = "a<em>b</em>c";
        assertEquals(html, format(html));
    }


    public void testStrongReplacedWithB() {
        String html = "<strong>a</strong>";
        assertEquals(html, format(html));
    }


    public void testLeadingWhitespace() {
        String html = " content";
        assertEquals("content", format(html));
    }


    public void testTrailingWhitespace() {
        String html = "content ";
        assertEquals("content", format(html));
    }


    public void testWrappedWhitetspace() {
        String html = " content ";
        assertEquals("content", format(html));
    }


    public void testPreWithNoWhitespace() {
        String html = "a<pre>b</pre> c";
        assertEquals("a<pre>b</pre> c", format(html));
    }


    public void testPreWithSpaces() {
        String html = "a<pre> b</pre> c";
        assertEquals("a<pre>&nbsp;b</pre> c", format(html));
    }


    public void testPreWithTabs() {
        String html = "a<pre>\tb</pre> c";
        assertEquals("a<pre>&nbsp;&nbsp;&nbsp;&nbsp;b</pre> c", format(html));
    }


    public void testPreWithNewline() {
        String html = "a<pre>\nb</pre> c";
        assertEquals("a<pre><br>b</pre> c", format(html));
    }


    public void testPreWithAllWhitepsace() {
        String html = "a<pre>\nb\tc </pre>d";
        assertEquals("a<pre><br>b&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;</pre>d",
                format(html));
    }


    public void testMultiplePresEscaped() {
        String html = "a<pre> c </pre>d<pre>\te\t</pre>";
        assertEquals(
                "a<pre>&nbsp;c&nbsp;</pre>d<pre>&nbsp;&nbsp;&nbsp;&nbsp;e&nbsp;&nbsp;&nbsp;&nbsp;</pre>",
                format(html));
    }


    public void testFormatPreCodeOnly() {
        String html = "<pre><code>a\nb\nc\n</code></pre>";
        assertEquals("<pre><code>a<br>b<br>c</code></pre>", format(html));
    }
}

<code block>

package com.github.mobile.tests.issue;

import android.test.AndroidTestCase;

import com.github.mobile.core.issue.IssueStore;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.RepositoryIssue;
import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.service.IssueService;
import org.eclipse.egit.github.core.service.PullRequestService;


public class IssueStoreTest extends AndroidTestCase {


    public void testReuseIssue() {
        IssueStore store = new IssueStore(new IssueService(),
                new PullRequestService());
        Repository repo = new Repository();
        repo.setName("name");
        repo.setOwner(new User().setLogin("owner"));

        assertNull(store.getIssue(repo, 1));

        RepositoryIssue issue = new RepositoryIssue();
        issue.setRepository(repo).setNumber(1).setBody("body");
        assertSame(issue, store.addIssue(issue));
        assertSame(issue, store.getIssue(repo, 1));

        RepositoryIssue issue2 = new RepositoryIssue();
        issue2.setRepository(repo).setNumber(1).setBody("body2");
        assertSame(issue, store.addIssue(issue2));
        assertEquals(issue2.getBody(), issue.getBody());
        assertSame(issue, store.getIssue(repo, 1));
    }
}

<code block>

package com.github.mobile.tests.issue;

import android.net.Uri;
import android.test.AndroidTestCase;

import com.github.mobile.core.issue.IssueUriMatcher;

import org.eclipse.egit.github.core.RepositoryIssue;


public class IssueUriMatcherTest extends AndroidTestCase {


    public void testEmptyUri() {
        assertNull(IssueUriMatcher.getIssue(Uri.parse("")));
    }


    public void testNonNumericIssueNumber() {
        assertNull(IssueUriMatcher.getIssue(Uri
                .parse("https://github.com/defunkt/resque/issues/fourty")));
    }


    public void testHttpUri() {
        RepositoryIssue issue = IssueUriMatcher.getIssue(Uri
                .parse("https://github.com/defunkt/resque/issues/3"));
        assertNotNull(issue);
        assertEquals(3, issue.getNumber());
        assertNotNull(issue.getRepository());
        assertEquals("resque", issue.getRepository().getName());
        assertNotNull(issue.getRepository().getOwner());
        assertEquals("defunkt", issue.getRepository().getOwner().getLogin());
    }


    public void testPullUri() {
        RepositoryIssue issue = IssueUriMatcher.getIssue(Uri
                .parse("https://github.com/defunkt/resque/pull/3"));
        assertNotNull(issue);
        assertEquals(3, issue.getNumber());
        assertNotNull(issue.getRepository());
        assertEquals("resque", issue.getRepository().getName());
        assertNotNull(issue.getRepository().getOwner());
        assertEquals("defunkt", issue.getRepository().getOwner().getLogin());
    }


    public void testHttpsUri() {
        RepositoryIssue issue = IssueUriMatcher.getIssue(Uri
                .parse("http://github.com/defunkt/resque/issues/15"));
        assertNotNull(issue);
        assertEquals(15, issue.getNumber());
        assertNotNull(issue.getRepository());
        assertEquals("resque", issue.getRepository().getName());
        assertNotNull(issue.getRepository().getOwner());
        assertEquals("defunkt", issue.getRepository().getOwner().getLogin());
    }


    public void testCommentUri() {
        RepositoryIssue issue = IssueUriMatcher
                .getIssue(Uri
                        .parse("https://github.com/defunkt/resque/issues/300#issuecomment-123456"));
        assertNotNull(issue);
        assertEquals(300, issue.getNumber());
        assertNotNull(issue.getRepository());
        assertEquals("resque", issue.getRepository().getName());
        assertNotNull(issue.getRepository().getOwner());
        assertEquals("defunkt", issue.getRepository().getOwner().getLogin());
    }
}

<code block>

package com.github.mobile.tests.issue;

import static android.view.KeyEvent.KEYCODE_DEL;
import android.view.View;
import android.widget.EditText;

import com.github.mobile.R.id;
import com.github.mobile.tests.ActivityTest;
import com.github.mobile.ui.issue.EditIssueActivity;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;


public class EditIssueActivityTest extends ActivityTest<EditIssueActivity> {


    public EditIssueActivityTest() {
        super(EditIssueActivity.class);
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        Repository repo = new Repository();
        repo.setName("repo");
        repo.setOwner(new User().setLogin("owner"));
        setActivityIntent(EditIssueActivity.createIntent(repo));
    }


    public void testSaveMenuEnabled() throws Throwable {
        View saveMenu = view(id.m_apply);
        assertFalse(saveMenu.isEnabled());
        EditText title = editText(id.et_issue_title);
        focus(title);
        send("a");
        assertTrue(saveMenu.isEnabled());
        sendKeys(KEYCODE_DEL);
        assertFalse(saveMenu.isEnabled());
    }
}

<code block>

package com.github.mobile.tests.issue;

import com.github.mobile.core.issue.IssueFilter;
import com.github.mobile.tests.ActivityTest;
import com.github.mobile.ui.issue.EditIssuesFilterActivity;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;


public class EditIssuesFilterActivityTest extends
    ActivityTest<EditIssuesFilterActivity> {


    public EditIssuesFilterActivityTest() {
        super(EditIssuesFilterActivity.class);
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        Repository repo = new Repository();
        repo.setName("name");
        repo.setOwner(new User().setLogin("owner"));
        IssueFilter filter = new IssueFilter(repo);
        setActivityIntent(EditIssuesFilterActivity.createIntent(filter));
    }
}

<code block>

package com.github.mobile.tests.issue;

import android.test.AndroidTestCase;

import com.github.mobile.core.issue.IssueFilter;

import org.eclipse.egit.github.core.Milestone;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;


public class IssueFilterTest extends AndroidTestCase {


    public void testEqualFilter() {
        Repository repo = new Repository().setId(1);
        IssueFilter filter1 = new IssueFilter(repo);

        assertFalse(filter1.equals(null));
        assertFalse(filter1.equals(""));
        assertTrue(filter1.equals(filter1));

        IssueFilter filter2 = new IssueFilter(repo);
        assertEquals(filter1, filter2);
        assertEquals(filter1.hashCode(), filter2.hashCode());

        User user = new User().setId(2);
        filter1.setAssignee(user);
        assertFalse(filter1.equals(filter2));
        filter2.setAssignee(user);
        assertEquals(filter1, filter2);
        assertEquals(filter1.hashCode(), filter2.hashCode());

        filter1.setOpen(false);
        assertFalse(filter1.equals(filter2));
        filter2.setOpen(false);
        assertEquals(filter1, filter2);
        assertEquals(filter1.hashCode(), filter2.hashCode());

        Milestone milestone = new Milestone().setNumber(3);
        filter1.setMilestone(milestone);
        assertFalse(filter1.equals(filter2));
        filter2.setMilestone(milestone);
        assertEquals(filter1, filter2);
        assertEquals(filter1.hashCode(), filter2.hashCode());
    }
}

<code block>

package com.github.mobile.tests.issue;

import static android.view.KeyEvent.KEYCODE_DEL;
import android.view.View;
import android.widget.EditText;

import com.github.mobile.R.id;
import com.github.mobile.tests.ActivityTest;
import com.github.mobile.ui.issue.CreateCommentActivity;

import org.eclipse.egit.github.core.RepositoryId;
import org.eclipse.egit.github.core.User;


public class CreateCommentActivityTest extends
    ActivityTest<CreateCommentActivity> {


    public CreateCommentActivityTest() {
        super(CreateCommentActivity.class);
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        setActivityIntent(CreateCommentActivity.createIntent(new RepositoryId(
            "o", "n"), 1, new User().setLogin("u")));
    }


    public void testEmptyCommentIsProhitibed() throws Throwable {
        View createMenu = view(id.m_apply);
        assertFalse(createMenu.isEnabled());
        final EditText comment = editText(id.et_comment);
        focus(comment);
        send("a");
        assertTrue(createMenu.isEnabled());
        sendKeys(KEYCODE_DEL);
        assertFalse(createMenu.isEnabled());
    }
}

<code block>

package com.github.mobile.tests.commit;

import android.test.AndroidTestCase;

import com.github.mobile.core.commit.FullCommit;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;

import org.eclipse.egit.github.core.CommitComment;
import org.eclipse.egit.github.core.CommitFile;
import org.eclipse.egit.github.core.RepositoryCommit;


public class FullCommitTest extends AndroidTestCase {


    public void testSingleLineCommentSingleFile() {
        RepositoryCommit commit = new RepositoryCommit();
        CommitFile file = new CommitFile();
        file.setFilename("a.txt");
        CommitComment comment = new CommitComment();
        comment.setPath(file.getFilename());
        comment.setPosition(10);
        commit.setFiles(Collections.singletonList(file));
        FullCommit full = new FullCommit(commit, new ArrayList<CommitComment>(
                Collections.singletonList(comment)));
        assertTrue(full.isEmpty());
        assertEquals(1, full.getFiles().size());
        assertEquals(comment, full.getFiles().get(0).get(10).get(0));
    }


    public void testSingleCommentSingleFile() {
        RepositoryCommit commit = new RepositoryCommit();
        CommitFile file = new CommitFile();
        file.setFilename("a.txt");
        CommitComment comment = new CommitComment();
        commit.setFiles(Collections.singletonList(file));
        FullCommit full = new FullCommit(commit, new ArrayList<CommitComment>(
                Collections.singletonList(comment)));
        assertFalse(full.isEmpty());
        assertEquals(comment, full.get(0));
        assertEquals(1, full.getFiles().size());
    }


    public void testSingleCommentNoFiles() {
        RepositoryCommit commit = new RepositoryCommit();
        CommitComment comment = new CommitComment();
        FullCommit full = new FullCommit(commit, new ArrayList<CommitComment>(
                Collections.singletonList(comment)));
        assertFalse(full.isEmpty());
        assertEquals(comment, full.get(0));
        assertTrue(full.getFiles().isEmpty());
    }


    public void testNoCommentsSingleFile() {
        RepositoryCommit commit = new RepositoryCommit();
        CommitFile file = new CommitFile();
        file.setFilename("a.txt");
        commit.setFiles(Collections.singletonList(file));
        FullCommit full = new FullCommit(commit);
        assertTrue(full.isEmpty());
        assertEquals(1, full.getFiles().size());
    }


    public void testBothTypesOfComments() {
        RepositoryCommit commit = new RepositoryCommit();
        CommitFile file = new CommitFile();
        file.setFilename("a.txt");
        commit.setFiles(Collections.singletonList(file));
        CommitComment comment1 = new CommitComment();
        comment1.setPath(file.getFilename());
        comment1.setPosition(10);
        CommitComment comment2 = new CommitComment();
        FullCommit full = new FullCommit(commit, new ArrayList<CommitComment>(
                Arrays.asList(comment1, comment2)));
        assertEquals(1, full.size());
        assertEquals(comment2, full.get(0));
        assertEquals(1, full.getFiles().size());
        assertEquals(comment1, full.getFiles().get(0).get(10).get(0));
    }
}

<code block>

package com.github.mobile.tests.commit;

import android.test.AndroidTestCase;

import com.github.mobile.ui.commit.DiffStyler;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.StringReader;
import java.util.Collections;
import java.util.List;

import org.eclipse.egit.github.core.CommitFile;


public class DiffStylerTest extends AndroidTestCase {

    private void compareStyled(String patch) throws IOException {
        assertNotNull(patch);
        String fileName = "file.txt";
        DiffStyler styler = new DiffStyler(getContext().getResources());
        CommitFile file = new CommitFile();
        file.setFilename(fileName);
        file.setPatch(patch);
        styler.setFiles(Collections.singletonList(file));
        List<CharSequence> styled = styler.get(fileName);
        assertNotNull(styled);
        BufferedReader reader = new BufferedReader(new StringReader(patch));
        String line = reader.readLine();
        int processed = 0;
        while (line != null) {
            assertEquals(line, styled.get(processed).toString());
            line = reader.readLine();
            processed++;
        }
        assertEquals(processed, styled.size());
    }


    public void testEmptyFiles() {
        DiffStyler styler = new DiffStyler(getContext().getResources());
        styler.setFiles(null);
        assertTrue(styler.get("navigation_drawer_header_background").isEmpty());
        styler.setFiles(Collections.<CommitFile>emptyList());
        assertTrue(styler.get("navigation_drawer_header_background").isEmpty());
    }


    public void testEmptyPatch() {
        DiffStyler styler = new DiffStyler(getContext().getResources());
        CommitFile file = new CommitFile();
        file.setFilename("file.txt");
        styler.setFiles(Collections.singletonList(file));
        assertTrue(styler.get("file.txt").isEmpty());
        file.setPatch("");
        assertTrue(styler.get("file.txt").isEmpty());
    }


    public void testOnlyNewline() throws IOException {
        compareStyled("\n");
    }


    public void testEmptyPatchLineWithOtherValidLines() throws IOException {
        compareStyled("@@ 0,1 0,1 @@\n\n-navigation_drawer_header_background\n");
    }


    public void testTrailingEmptyLine() throws IOException {
        compareStyled("@@ 0,1 0,1 @@\n-navigation_drawer_header_background\n\n");
    }


    public void testOnlyNewlines() throws IOException {
        compareStyled("\n\n\n");
    }


    public void testNoTrailingNewlineAfterSecondLine() throws IOException {
        compareStyled("@@ 1,2 1,2 @@\n+navigation_drawer_header_background");
    }


    public void testNoTrailingNewline() throws IOException {
        compareStyled("@@ 1,2 1,2 @@");
    }


    public void testFormattedPatch() throws IOException {
        compareStyled("@@ 1,2 1,2 @@\n+navigation_drawer_header_background\n");
    }
}

<code block>

package com.github.mobile.tests.commit;

import android.test.AndroidTestCase;

import com.github.mobile.core.commit.CommitUtils;

import java.util.Date;

import org.eclipse.egit.github.core.Commit;
import org.eclipse.egit.github.core.CommitFile;
import org.eclipse.egit.github.core.CommitUser;
import org.eclipse.egit.github.core.RepositoryCommit;
import org.eclipse.egit.github.core.User;


public class CommitUtilsTest extends AndroidTestCase {


    public void testAbbreviate() {
        assertNull(CommitUtils.abbreviate((Commit) null));
        assertNull(CommitUtils.abbreviate((RepositoryCommit) null));
        assertNull(CommitUtils.abbreviate((String) null));
        assertEquals("", CommitUtils.abbreviate(""));
        assertEquals("a", CommitUtils.abbreviate("a"));
        assertEquals("abcdefghij", CommitUtils.abbreviate("abcdefghijk"));
        assertEquals("abc", CommitUtils.abbreviate(new Commit().setSha("abc")));
        assertEquals("abcd",
                CommitUtils.abbreviate(new RepositoryCommit().setSha("abcd")));
    }


    public void testGetName() {
        assertNull(CommitUtils.getName((String) null));
        assertNull(CommitUtils.getName((CommitFile) null));
        assertEquals("", CommitUtils.getName(""));
        assertEquals("/", CommitUtils.getName("/"));
        assertEquals("b", CommitUtils.getName("a/b"));
        assertEquals("c",
                CommitUtils.getName(new CommitFile().setFilename("a/b/c")));
    }


    public void testIsValidCommit() {
        assertFalse(CommitUtils.isValidCommit(null));
        assertFalse(CommitUtils.isValidCommit(""));
        assertTrue(CommitUtils.isValidCommit("a"));
        assertTrue(CommitUtils.isValidCommit("bbbbb"));
        assertFalse(CommitUtils.isValidCommit("am"));
        assertFalse(CommitUtils.isValidCommit("xyz"));
    }


    public void testGetAuthor() {
        RepositoryCommit commit = new RepositoryCommit();
        assertNull(CommitUtils.getAuthor(commit));
        Commit rawCommit = new Commit();
        commit.setCommit(rawCommit);
        assertNull(CommitUtils.getAuthor(commit));
        CommitUser user = new CommitUser();
        rawCommit.setAuthor(user);
        assertNull(CommitUtils.getAuthor(commit));
        user.setName("u1");
        assertEquals("u1", CommitUtils.getAuthor(commit));
        commit.setAuthor(new User().setLogin("u2"));
        assertEquals("u2", CommitUtils.getAuthor(commit));
    }


    public void testGetCommitter() {
        RepositoryCommit commit = new RepositoryCommit();
        assertNull(CommitUtils.getCommitter(commit));
        Commit rawCommit = new Commit();
        commit.setCommit(rawCommit);
        assertNull(CommitUtils.getCommitter(commit));
        CommitUser user = new CommitUser();
        rawCommit.setCommitter(user);
        assertNull(CommitUtils.getCommitter(commit));
        user.setName("u1");
        assertEquals("u1", CommitUtils.getCommitter(commit));
        commit.setCommitter(new User().setLogin("u2"));
        assertEquals("u2", CommitUtils.getCommitter(commit));
    }


    public void testGetAuthorDate() {
        RepositoryCommit commit = new RepositoryCommit();
        assertNull(CommitUtils.getAuthorDate(commit));
        Commit rawCommit = new Commit();
        commit.setCommit(rawCommit);
        assertNull(CommitUtils.getAuthorDate(commit));
        CommitUser user = new CommitUser();
        rawCommit.setAuthor(user);
        assertNull(CommitUtils.getAuthorDate(commit));
        user.setDate(new Date(12345));
        assertEquals(new Date(12345), CommitUtils.getAuthorDate(commit));
    }


    public void testGetCommitterDate() {
        RepositoryCommit commit = new RepositoryCommit();
        assertNull(CommitUtils.getCommitterDate(commit));
        Commit rawCommit = new Commit();
        commit.setCommit(rawCommit);
        assertNull(CommitUtils.getCommitterDate(commit));
        CommitUser user = new CommitUser();
        rawCommit.setCommitter(user);
        assertNull(CommitUtils.getCommitterDate(commit));
        user.setDate(new Date(12345));
        assertEquals(new Date(12345), CommitUtils.getCommitterDate(commit));
    }
}

<code block>

package com.github.mobile.tests.commit;

import android.net.Uri;
import android.test.AndroidTestCase;

import com.github.mobile.core.commit.CommitMatch;
import com.github.mobile.core.commit.CommitUriMatcher;


public class CommitUriMatcherTest extends AndroidTestCase {


    public void testEmptyUri() {
        assertNull(CommitUriMatcher.getCommit(Uri.parse("")));
    }


    public void testNonHexId() {
        assertNull(CommitUriMatcher.getCommit(Uri
                .parse("https://github.com/defunkt/resque/commit/abck")));
    }


    public void testHttpUri() {
        CommitMatch commit = CommitUriMatcher.getCommit(Uri
                .parse("https://github.com/defunkt/resque/commit/abcd"));
        assertNotNull(commit);
        assertEquals("abcd", commit.commit);
        assertNotNull(commit.repository);
        assertEquals("resque", commit.repository.getName());
        assertNotNull(commit.repository.getOwner());
        assertEquals("defunkt", commit.repository.getOwner().getLogin());
    }


    public void testHttpsUri() {
        CommitMatch commit = CommitUriMatcher.getCommit(Uri
                .parse("https://github.com/defunkt/resque/commit/1234"));
        assertNotNull(commit);
        assertEquals("1234", commit.commit);
        assertNotNull(commit.repository);
        assertEquals("resque", commit.repository.getName());
        assertNotNull(commit.repository.getOwner());
        assertEquals("defunkt", commit.repository.getOwner().getLogin());
    }


    public void testCommentUri() {
        CommitMatch commit = CommitUriMatcher
                .getCommit(Uri
                        .parse("https://github.com/defunkt/resque/commit/a1b2#commitcomment-1605701"));
        assertNotNull(commit);
        assertEquals("a1b2", commit.commit);
        assertNotNull(commit.repository);
        assertEquals("resque", commit.repository.getName());
        assertNotNull(commit.repository.getOwner());
        assertEquals("defunkt", commit.repository.getOwner().getLogin());
    }
}

<code block>

package com.github.mobile.tests.commit;

import static android.view.KeyEvent.KEYCODE_DEL;
import android.view.View;
import android.widget.EditText;

import com.github.mobile.R.id;
import com.github.mobile.tests.ActivityTest;
import com.github.mobile.ui.commit.CreateCommentActivity;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;


public class CreateCommentActivityTest extends
    ActivityTest<CreateCommentActivity> {


    public CreateCommentActivityTest() {
        super(CreateCommentActivity.class);
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        Repository repo = new Repository();
        repo.setName("name");
        repo.setOwner(new User().setLogin("owner"));
        setActivityIntent(CreateCommentActivity.createIntent(repo, "abcdef"));
    }


    public void testEmptyCommentIsProhitibed() throws Throwable {
        View createMenu = view(id.m_apply);
        assertFalse(createMenu.isEnabled());
        final EditText comment = editText(id.et_comment);
        focus(comment);
        send("a");
        assertTrue(createMenu.isEnabled());
        sendKeys(KEYCODE_DEL);
        assertFalse(createMenu.isEnabled());
    }
}

<code block>

package com.github.mobile.tests.ref;

import android.test.AndroidTestCase;

import com.github.mobile.core.ref.RefUtils;

import org.eclipse.egit.github.core.Reference;


public class RefUtilsTest extends AndroidTestCase {


    public void testIsBranch() {
        assertFalse(RefUtils.isBranch(null));
        assertFalse(RefUtils.isBranch(new Reference()));
        assertFalse(RefUtils.isBranch(new Reference().setRef("")));
        assertFalse(RefUtils.isBranch(new Reference().setRef("navigation_drawer_header_background")));
        assertFalse(RefUtils.isBranch(new Reference().setRef("refs/tags/v1")));
        assertFalse(RefUtils.isBranch(new Reference().setRef("refs/b1")));
        assertTrue(RefUtils.isBranch(new Reference().setRef("refs/heads/b2")));
    }


    public void testIsTag() {
        assertFalse(RefUtils.isTag((Reference) null));
        assertFalse(RefUtils.isTag(new Reference()));
        assertFalse(RefUtils.isTag(new Reference().setRef("")));
        assertFalse(RefUtils.isTag(new Reference().setRef("navigation_drawer_header_background")));
        assertFalse(RefUtils.isTag(new Reference().setRef("refs/b1")));
        assertFalse(RefUtils.isTag(new Reference().setRef("refs/heads/b2")));
        assertTrue(RefUtils.isTag(new Reference().setRef("refs/tags/v1")));
    }


    public void testIsValid() {
        assertFalse(RefUtils.isValid(null));
        assertFalse(RefUtils.isValid(new Reference()));
        assertFalse(RefUtils.isValid(new Reference().setRef("")));
        assertFalse(RefUtils.isValid(new Reference()
            .setRef("refs/pull/6/merge")));
        assertFalse(RefUtils
            .isValid(new Reference().setRef("refs/pull/6/head")));
        assertTrue(RefUtils.isValid(new Reference().setRef("refs/pull")));
        assertTrue(RefUtils.isValid(new Reference().setRef("refs/heads/b1")));
        assertTrue(RefUtils.isValid(new Reference().setRef("refs/tags/v1")));
    }


    public void testGetName() {
        assertNull(RefUtils.getName((Reference) null));
        assertNull(RefUtils.getName(new Reference()));
        assertEquals("", RefUtils.getName(new Reference().setRef("")));
        assertEquals("unchanged",
            RefUtils.getName(new Reference().setRef("unchanged")));
        assertEquals("branch",
            RefUtils.getName(new Reference().setRef("refs/heads/branch")));
        assertEquals("tag",
            RefUtils.getName(new Reference().setRef("refs/tags/tag")));
        assertEquals("notes",
            RefUtils.getName(new Reference().setRef("refs/notes")));

    }


    public void testGetPath() {
        assertNull(RefUtils.getPath(null));
        assertNull(RefUtils.getPath(new Reference()));
        assertEquals("", RefUtils.getPath(new Reference().setRef("")));
        assertEquals("unchanged",
            RefUtils.getPath(new Reference().setRef("unchanged")));
        assertEquals("heads/branch",
            RefUtils.getPath(new Reference().setRef("refs/heads/branch")));
        assertEquals("tags/tag",
            RefUtils.getPath(new Reference().setRef("refs/tags/tag")));
        assertEquals("notes",
            RefUtils.getPath(new Reference().setRef("refs/notes")));

    }
}

<code block>

package com.github.mobile.tests.gist;

import static android.content.Intent.EXTRA_TEXT;
import android.content.Intent;
import android.view.View;
import android.widget.EditText;

import com.github.mobile.R.id;
import com.github.mobile.tests.ActivityTest;
import com.github.mobile.ui.gist.CreateGistActivity;


public class CreateGistActivityTest extends ActivityTest<CreateGistActivity> {


    public CreateGistActivityTest() {
        super(CreateGistActivity.class);
    }


    public void testCreateWithInitialText() {
        setActivityIntent(new Intent().putExtra(EXTRA_TEXT, "gist content"));

        View createMenu = view(id.m_apply);
        assertTrue(createMenu.isEnabled());
        EditText content = editText(id.et_gist_content);
        assertEquals("gist content", content.getText().toString());
    }


    public void testCreateWithNoInitialText() throws Throwable {
        View createMenu = view(id.m_apply);
        assertFalse(createMenu.isEnabled());
        EditText content = editText(id.et_gist_content);
        focus(content);
        send("gist content");
        assertTrue(createMenu.isEnabled());
    }
}

<code block>

package com.github.mobile.tests.gist;

import android.net.Uri;
import android.test.AndroidTestCase;

import com.github.mobile.core.gist.GistUriMatcher;

import org.eclipse.egit.github.core.Gist;


public class GistUriMatcherTest extends AndroidTestCase {


    public void testEmptyUri() {
        assertNull(GistUriMatcher.getGist(Uri.parse("")));
    }


    public void testNonGistId() {
        assertNull(GistUriMatcher.getGist(Uri
                .parse("https://gist.github.com/TEST")));
        assertNull(GistUriMatcher.getGist(Uri
                .parse("https://gist.github.com/abc%20")));
        assertNull(GistUriMatcher.getGist(Uri
                .parse("https://gist.github.com/abcdefg")));
    }


    public void testPublicGist() {
        Gist gist = GistUriMatcher.getGist(Uri
                .parse("https://gist.github.com/1234"));
        assertNotNull(gist);
        assertEquals("1234", gist.getId());
    }


    public void testPrivateGist() {
        Gist gist = GistUriMatcher.getGist(Uri
                .parse("https://gist.github.com/abcd1234abcd1234abcd"));
        assertNotNull(gist);
        assertEquals("abcd1234abcd1234abcd", gist.getId());
    }
}

<code block>

package com.github.mobile.tests.gist;

import static android.view.KeyEvent.KEYCODE_DEL;
import android.view.View;
import android.widget.EditText;

import com.github.mobile.R.id;
import com.github.mobile.tests.ActivityTest;
import com.github.mobile.ui.gist.CreateCommentActivity;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.User;


public class CreateCommentActivityTest extends
    ActivityTest<CreateCommentActivity> {


    public CreateCommentActivityTest() {
        super(CreateCommentActivity.class);
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        setActivityIntent(CreateCommentActivity.createIntent(new Gist().setId(
            "123").setUser(new User().setLogin("abc"))));
    }


    public void testEmptyCommentIsProhibited() throws Throwable {
        View createMenu = view(id.m_apply);
        assertFalse(createMenu.isEnabled());
        final EditText comment = editText(id.et_comment);
        focus(comment);
        send("a");
        assertTrue(createMenu.isEnabled());
        sendKeys(KEYCODE_DEL);
        assertFalse(createMenu.isEnabled());
    }
}

<code block>

package com.github.mobile.tests.gist;

import android.test.AndroidTestCase;

import com.github.mobile.core.gist.GistStore;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.service.GistService;


public class GistStoreTest extends AndroidTestCase {


    public void testReuseIssue() {
        GistStore store = new GistStore(new GistService());
        assertNull(store.getGist("abcd"));

        Gist gist = new Gist();
        gist.setId("abcd").setDescription("description");
        assertSame(gist, store.addGist(gist));
        assertSame(gist, store.getGist("abcd"));

        Gist gist2 = new Gist();
        gist2.setId("abcd").setDescription("description2");
        assertSame(gist, store.addGist(gist2));
        assertEquals(gist2.getDescription(), gist.getDescription());
        assertSame(gist, store.getGist("abcd"));
    }
}

<code block>

package com.github.mobile.tests.gist;

import android.support.v4.view.ViewPager;

import com.github.mobile.R.id;
import com.github.mobile.core.gist.GistStore;
import com.github.mobile.tests.ActivityTest;
import com.github.mobile.ui.gist.GistFilesViewActivity;
import com.google.inject.Inject;

import java.util.LinkedHashMap;
import java.util.Map;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.GistFile;

import roboguice.RoboGuice;


public class GistFilesViewActivityTest extends
    ActivityTest<GistFilesViewActivity> {

    @Inject
    private GistStore store;

    private Gist gist;


    public GistFilesViewActivityTest() {
        super(GistFilesViewActivity.class);
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        RoboGuice.injectMembers(getInstrumentation().getTargetContext()
            .getApplicationContext(), this);

        gist = new Gist();
        gist.setId("abcd");
        Map<String, GistFile> files = new LinkedHashMap<>();
        files.put("a", new GistFile().setFilename("a").setContent("aa"));
        files.put("b", new GistFile().setFilename("b").setContent("bb"));
        gist.setFiles(files);
        store.addGist(gist);
        setActivityIntent(GistFilesViewActivity.createIntent(gist, 0));
    }


    public void testChangingPages() throws Throwable {
        final ViewPager pager = (ViewPager) getActivity().findViewById(
            id.vp_pages);
        assertEquals(0, pager.getCurrentItem());
        ui(new Runnable() {

            public void run() {
                pager.setCurrentItem(1, true);
            }
        });
        assertEquals(1, pager.getCurrentItem());
        ui(new Runnable() {

            public void run() {
                pager.setCurrentItem(0, true);
            }
        });
        assertEquals(0, pager.getCurrentItem());
    }
}

<code block>

package com.github.mobile.tests.repo;

import static com.github.mobile.ui.repo.RecentRepositories.MAX_SIZE;
import android.test.AndroidTestCase;

import com.github.mobile.ui.repo.RecentRepositories;

import org.eclipse.egit.github.core.User;


public class RecentRepositoriesTest extends AndroidTestCase {


    public void testBadInput() {
        User org = new User().setId(20);
        RecentRepositories recent = new RecentRepositories(getContext(), org);
        assertFalse(recent.contains(null));
        assertFalse(recent.contains(-1));
    }


    public void testMaxReached() {
        User org = new User().setId(20);
        RecentRepositories recent = new RecentRepositories(getContext(), org);

        for (int i = 0; i < MAX_SIZE; i++) {
            recent.add(i);
            assertTrue(recent.contains(i));
        }

        recent.add(MAX_SIZE + 1);
        assertTrue(recent.contains(MAX_SIZE + 1));
        assertFalse(recent.contains(0));

        for (int i = 1; i < MAX_SIZE; i++)
            assertTrue(recent.contains(i));
    }


    public void testIO() {
        User org = new User().setId(20);
        RecentRepositories recent1 = new RecentRepositories(getContext(), org);
        long id = 1234;
        recent1.add(id);
        assertTrue(recent1.contains(id));
        recent1.save();
        RecentRepositories recent2 = new RecentRepositories(getContext(), org);
        assertTrue(recent2.contains(id));
    }


    public void testScopedStorage() {
        User org1 = new User().setId(20);
        RecentRepositories recent1 = new RecentRepositories(getContext(), org1);
        long id1 = 1234;
        recent1.add(id1);
        assertTrue(recent1.contains(id1));

        User org2 = new User().setId(40);
        RecentRepositories recent2 = new RecentRepositories(getContext(), org2);
        assertFalse(recent2.contains(id1));
        long id2 = 2345;
        recent2.add(id2);
        assertTrue(recent2.contains(id2));

        recent2.save();
        recent1 = new RecentRepositories(getContext(), org1);
        assertFalse(recent1.contains(id2));
    }
}

<code block>

package com.github.mobile.tests.repo;

import static android.app.SearchManager.QUERY;
import static android.content.Intent.ACTION_SEARCH;
import android.content.Intent;

import com.github.mobile.tests.ActivityTest;
import com.github.mobile.ui.search.SearchActivity;


public class SearchActivityTest extends
    ActivityTest<SearchActivity> {


    public SearchActivityTest() {
        super(SearchActivity.class);
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        setActivityIntent(new Intent(ACTION_SEARCH).putExtra(QUERY, "navigation_drawer_header_background"));
    }
}

<code block>

package com.github.mobile.tests.repo;

import android.test.AndroidTestCase;

import com.github.mobile.core.repo.RepositoryEventMatcher;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.event.Event;
import org.eclipse.egit.github.core.event.ForkPayload;


public class RepositoryEventMatcherTest extends AndroidTestCase {


    public void testIncompleteRepositoryFork() {
        RepositoryEventMatcher matcher = new RepositoryEventMatcher();
        Event event = new Event();
        event.setType(Event.TYPE_FORK);
        ForkPayload payload = new ForkPayload();
        event.setPayload(payload);
        assertNull(matcher.getRepository(event));
        Repository repository = new Repository();
        payload.setForkee(repository);
        assertNull(matcher.getRepository(event));
        repository.setName("repo");
        assertNull(matcher.getRepository(event));
        repository.setOwner(new User());
        assertNull(matcher.getRepository(event));
        repository.getOwner().setLogin("owner");
        assertEquals(repository, matcher.getRepository(event));
    }

}

<code block>

package com.github.mobile.tests.repo;

import android.net.Uri;
import android.test.AndroidTestCase;

import com.github.mobile.core.repo.RepositoryUriMatcher;

import org.eclipse.egit.github.core.Repository;


public class RepositoryUriMatcherTest extends AndroidTestCase {


    public void testEmptyUri() {
        assertNull(RepositoryUriMatcher.getRepository(Uri.parse("")));
    }


    public void testUriWithNoOnwer() {
        assertNull(RepositoryUriMatcher.getRepository(Uri
                .parse("http://github.com")));
        assertNull(RepositoryUriMatcher.getRepository(Uri
                .parse("http://github.com/")));
        assertNull(RepositoryUriMatcher.getRepository(Uri
                .parse("http://github.com//")));
    }


    public void testUriWithNoName() {
        assertNull(RepositoryUriMatcher.getRepository(Uri
                .parse("http://github.com/defunkt")));
        assertNull(RepositoryUriMatcher.getRepository(Uri
                .parse("http://github.com/defunkt/")));
    }


    public void testHttpUriWithOwnerAndName() {
        Repository repo = RepositoryUriMatcher.getRepository(Uri
                .parse("http://github.com/defunkt/resque"));
        assertNotNull(repo);
        assertEquals("resque", repo.getName());
        assertNotNull(repo.getOwner());
        assertEquals("defunkt", repo.getOwner().getLogin());
    }


    public void testHttpsUriWithOwnerAndName() {
        Repository repo = RepositoryUriMatcher.getRepository(Uri
                .parse("https://github.com/mojombo/jekyll"));
        assertNotNull(repo);
        assertEquals("jekyll", repo.getName());
        assertNotNull(repo.getOwner());
        assertEquals("mojombo", repo.getOwner().getLogin());
    }


    public void testInvalidOwner() {
        assertNull(RepositoryUriMatcher.getRepository(Uri
                .parse("http://github.com/blog/page1")));
    }
}

<code block>

package com.github.mobile;

import static android.app.Activity.RESULT_FIRST_USER;


public interface ResultCodes {


    int RESOURCE_CHANGED = RESULT_FIRST_USER;
}

<code block>

package com.github.mobile;

import org.eclipse.egit.github.core.client.GitHubClient;

import java.net.HttpURLConnection;


public class DefaultClient extends GitHubClient {

    private static final String USER_AGENT = "GitHubAndroid/1.6";


    public DefaultClient() {
        super();

        setSerializeNulls(false);
        setUserAgent(USER_AGENT);
    }

    @Override
    protected HttpURLConnection configureRequest(HttpURLConnection request) {
        super.configureRequest(request);

        request.setRequestProperty(HEADER_ACCEPT,
                "application/vnd.github.beta.full+json");

        return request;
    }
}

<code block>

package com.github.mobile;

import static org.eclipse.egit.github.core.RepositoryId.createFromUrl;
import android.content.Intent;

import java.io.Serializable;
import java.util.ArrayList;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.GistFile;
import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.RepositoryId;
import org.eclipse.egit.github.core.User;


public class Intents {


    public static final String INTENT_PREFIX = "com.github.mobile.";


    public static final String INTENT_EXTRA_PREFIX = INTENT_PREFIX + "extra.";


    public static final String EXTRA_REPOSITORY = INTENT_EXTRA_PREFIX
            + "REPOSITORY";


    public static final String EXTRA_REPOSITORIES = INTENT_EXTRA_PREFIX
            + "REPOSITORIES";


    public static final String EXTRA_REPOSITORY_NAME = INTENT_EXTRA_PREFIX
            + "REPOSITORY_NAME";


    public static final String EXTRA_REPOSITORY_OWNER = INTENT_EXTRA_PREFIX
            + "REPOSITORY_OWNER";


    public static final String EXTRA_ISSUE_NUMBER = INTENT_EXTRA_PREFIX
            + "ISSUE_NUMBER";


    public static final String EXTRA_ISSUE = INTENT_EXTRA_PREFIX + "ISSUE";


    public static final String EXTRA_ISSUE_NUMBERS = INTENT_EXTRA_PREFIX
            + "ISSUE_NUMBERS";


    public static final String EXTRA_GIST_ID = INTENT_EXTRA_PREFIX + "GIST_ID";


    public static final String EXTRA_GIST_IDS = INTENT_EXTRA_PREFIX
            + "GIST_IDS";


    public static final String EXTRA_GIST = INTENT_EXTRA_PREFIX + "GIST";


    public static final String EXTRA_GIST_FILE = INTENT_EXTRA_PREFIX
            + "GIST_FILE";


    public static final String EXTRA_USER = INTENT_EXTRA_PREFIX + "USER";


    public static final String EXTRA_USERS = INTENT_EXTRA_PREFIX + "USERS";


    public static final String EXTRA_IS_COLLABORATOR = INTENT_EXTRA_PREFIX + "IS_COLLABORATOR";


    public static final String EXTRA_IS_OWNER = INTENT_EXTRA_PREFIX + "IS_OWNER";


    public static final String EXTRA_ISSUE_FILTER = INTENT_EXTRA_PREFIX
            + "ISSUE_FILTER";


    public static final String EXTRA_COMMENT_BODY = INTENT_EXTRA_PREFIX
            + "COMMENT_BODY";


    public static final String EXTRA_COMMENTS = INTENT_EXTRA_PREFIX
            + "COMMENTS";


    public static final String EXTRA_COMMENT = INTENT_EXTRA_PREFIX + "COMMENT";


    public static final String EXTRA_POSITION = INTENT_EXTRA_PREFIX
            + "POSITION";


    public static final String EXTRA_BASE = INTENT_EXTRA_PREFIX + "BASE";


    public static final String EXTRA_BASES = INTENT_EXTRA_PREFIX + "BASES";


    public static final String EXTRA_HEAD = INTENT_EXTRA_PREFIX + "HEAD";


    public static final String EXTRA_PATH = INTENT_EXTRA_PREFIX + "PATH";


    public static RepositoryId repoFrom(Intent intent) {
        String repoName = intent.getStringExtra(EXTRA_REPOSITORY_NAME);
        String repoOwner = intent.getStringExtra(EXTRA_REPOSITORY_OWNER);
        return RepositoryId.create(repoOwner, repoName);
    }


    public static class Builder {

        private final Intent intent;


        public Builder(String actionSuffix) {

            intent = new Intent(INTENT_PREFIX + actionSuffix);
        }


        public Builder repo(RepositoryId repositoryId) {
            return add(EXTRA_REPOSITORY_NAME, repositoryId.getName()).add(
                    EXTRA_REPOSITORY_OWNER, repositoryId.getOwner());
        }


        public Builder repo(Repository repository) {
            return add(EXTRA_REPOSITORY, repository);
        }


        public Builder issue(Issue issue) {
            return repo(createFromUrl(issue.getHtmlUrl())).add(EXTRA_ISSUE,
                    issue).add(EXTRA_ISSUE_NUMBER, issue.getNumber());
        }


        public Builder gist(Gist gist) {
            return add(EXTRA_GIST, gist);
        }


        public Builder gist(String gist) {
            return add(EXTRA_GIST_ID, gist);
        }


        public Builder gistFile(GistFile file) {
            return add(EXTRA_GIST_FILE, file);
        }


        public Builder user(User user) {
            return add(EXTRA_USER, user);
        }


        public Builder add(String fieldName, String value) {
            intent.putExtra(fieldName, value);
            return this;
        }


        public Builder add(String fieldName, CharSequence[] values) {
            intent.putExtra(fieldName, values);
            return this;
        }


        public Builder add(String fieldName, int value) {
            intent.putExtra(fieldName, value);
            return this;
        }


        public Builder add(String fieldName, int[] values) {
            intent.putExtra(fieldName, values);
            return this;
        }


        public Builder add(String fieldName, boolean[] values) {
            intent.putExtra(fieldName, values);
            return this;
        }


        public Builder add(String fieldName, Serializable value) {
            intent.putExtra(fieldName, value);
            return this;
        }


        public Intent toIntent() {
            return intent;
        }
    }
}

<code block>

package com.github.mobile;

import android.util.Log;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.RandomAccessFile;
import java.nio.channels.FileLock;
import java.util.zip.GZIPOutputStream;


public class RequestWriter {

    private static final String TAG = "RequestWriter";

    private final File handle;

    private final int version;


    public RequestWriter(File file, int formatVersion) {
        handle = file;
        version = formatVersion;
    }

    private void createDirectory(final File dir) {
        if (dir != null && !dir.exists())
            dir.mkdirs();
    }


    public <V> V write(V request) {
        RandomAccessFile dir = null;
        FileLock lock = null;
        ObjectOutputStream output = null;
        try {
            createDirectory(handle.getParentFile());
            dir = new RandomAccessFile(handle, "rw");
            lock = dir.getChannel().lock();
            output = new ObjectOutputStream(new GZIPOutputStream(
                    new FileOutputStream(dir.getFD()), 8192));
            output.writeInt(version);
            output.writeObject(request);
        } catch (IOException e) {
            Log.d(TAG, "Exception writing cache " + handle.getName(), e);
            return null;
        } finally {
            if (output != null)
                try {
                    output.close();
                } catch (IOException e) {
                    Log.d(TAG, "Exception closing stream", e);
                }
            if (lock != null)
                try {
                    lock.release();
                } catch (IOException e) {
                    Log.d(TAG, "Exception unlocking file", e);
                }
            if (dir != null)
                try {
                    dir.close();
                } catch (IOException e) {
                    Log.d(TAG, "Exception closing file", e);
                }
        }
        return request;
    }
}

<code block>

package com.github.mobile;


public interface RequestFuture<V> {


    void success(V response);
}

<code block>

package com.github.mobile;

import android.util.Log;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.RandomAccessFile;
import java.nio.channels.FileLock;
import java.util.zip.GZIPInputStream;


public class RequestReader {

    private static final String TAG = "RequestReader";

    private final File handle;

    private final int version;


    public RequestReader(File file, int formatVersion) {
        handle = file;
        version = formatVersion;
    }


    @SuppressWarnings("unchecked")
    public <V> V read() {
        if (!handle.exists() || handle.length() == 0)
            return null;

        RandomAccessFile dir = null;
        FileLock lock = null;
        ObjectInputStream input = null;
        boolean delete = false;
        try {
            dir = new RandomAccessFile(handle, "rw");
            lock = dir.getChannel().lock();
            input = new ObjectInputStream(new GZIPInputStream(
                    new FileInputStream(dir.getFD()), 8192 * 8));
            int streamVersion = input.readInt();
            if (streamVersion != version) {
                delete = true;
                return null;
            }
            return (V) input.readObject();
        } catch (IOException e) {
            Log.d(TAG, "Exception reading cache " + handle.getName(), e);
            return null;
        } catch (ClassNotFoundException e) {
            Log.d(TAG, "Exception reading cache " + handle.getName(), e);
            return null;
        } finally {
            if (input != null)
                try {
                    input.close();
                } catch (IOException e) {
                    Log.d(TAG, "Exception closing stream", e);
                }
            if (delete)
                try {
                    dir.setLength(0);
                } catch (IOException e) {
                    Log.d(TAG, "Exception truncating file", e);
                }
            if (lock != null)
                try {
                    lock.release();
                } catch (IOException e) {
                    Log.d(TAG, "Exception unlocking file", e);
                }
            if (dir != null)
                try {
                    dir.close();
                } catch (IOException e) {
                    Log.d(TAG, "Exception closing file", e);
                }
        }
    }
}

<code block>

package com.github.mobile;


public interface RequestCodes {


    int GIST_VIEW = 1;


    int ISSUE_VIEW = 2;


    int ISSUE_FILTER_EDIT = 3;


    int ISSUE_CREATE = 4;


    int ISSUE_LABELS_UPDATE = 2;


    int ISSUE_MILESTONE_UPDATE = 3;


    int ISSUE_ASSIGNEE_UPDATE = 4;


    int ISSUE_CLOSE = 5;


    int ISSUE_REOPEN = 6;


    int ISSUE_EDIT = 7;


    int COMMENT_CREATE = 8;


    int GIST_CREATE = 9;


    int COMMIT_VIEW = 10;


    int REF_UPDATE = 11;


    int REPOSITORY_VIEW = 12;


    int OTP_CODE_ENTER = 13;


    int COMMENT_EDIT = 14;


    int COMMENT_DELETE = 15;
}

<code block>

package com.github.mobile;

import android.content.Context;

import com.github.mobile.accounts.AccountClient;
import com.github.mobile.accounts.AccountScope;
import com.github.mobile.accounts.GitHubAccount;
import com.github.mobile.core.commit.CommitStore;
import com.github.mobile.core.gist.GistStore;
import com.github.mobile.core.issue.IssueStore;
import com.github.mobile.persistence.OrganizationRepositories;
import com.github.mobile.sync.SyncCampaign;
import com.google.inject.AbstractModule;
import com.google.inject.Provider;
import com.google.inject.Provides;
import com.google.inject.assistedinject.FactoryModuleBuilder;
import com.google.inject.name.Named;

import java.io.File;
import java.lang.ref.WeakReference;

import org.eclipse.egit.github.core.client.GitHubClient;
import org.eclipse.egit.github.core.service.CommitService;
import org.eclipse.egit.github.core.service.GistService;
import org.eclipse.egit.github.core.service.IssueService;
import org.eclipse.egit.github.core.service.PullRequestService;


public class GitHubModule extends AbstractModule {

    private WeakReference<IssueStore> issues;

    private WeakReference<GistStore> gists;

    private WeakReference<CommitStore> commits;

    @Override
    protected void configure() {
        install(new ServicesModule());
        install(new FactoryModuleBuilder().build(SyncCampaign.Factory.class));
        install(new FactoryModuleBuilder()
                .build(OrganizationRepositories.Factory.class));
        install(AccountScope.module());
    }

    @Provides
    GitHubClient client(Provider<GitHubAccount> accountProvider) {
        return new AccountClient(accountProvider);
    }

    @Provides
    @Named("cacheDir")
    File cacheDir(Context context) {
        return new File(context.getFilesDir(), "cache");
    }

    @Provides
    IssueStore issueStore(IssueService issueService,
            PullRequestService pullService) {
        IssueStore store = issues != null ? issues.get() : null;
        if (store == null) {
            store = new IssueStore(issueService, pullService);
            issues = new WeakReference<>(store);
        }
        return store;
    }

    @Provides
    GistStore gistStore(GistService service) {
        GistStore store = gists != null ? gists.get() : null;
        if (store == null) {
            store = new GistStore(service);
            gists = new WeakReference<>(store);
        }
        return store;
    }

    @Provides
    CommitStore commitStore(CommitService service) {
        CommitStore store = commits != null ? commits.get() : null;
        if (store == null) {
            store = new CommitStore(service);
            commits = new WeakReference<>(store);
        }
        return store;
    }
}

<code block>

package com.github.mobile;

import com.github.mobile.core.search.SearchUserService;
import com.google.inject.AbstractModule;
import com.google.inject.Provides;

import java.io.IOException;

import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.client.GitHubClient;
import org.eclipse.egit.github.core.service.CollaboratorService;
import org.eclipse.egit.github.core.service.CommitService;
import org.eclipse.egit.github.core.service.ContentsService;
import org.eclipse.egit.github.core.service.DataService;
import org.eclipse.egit.github.core.service.EventService;
import org.eclipse.egit.github.core.service.GistService;
import org.eclipse.egit.github.core.service.IssueService;
import org.eclipse.egit.github.core.service.LabelService;
import org.eclipse.egit.github.core.service.MarkdownService;
import org.eclipse.egit.github.core.service.MilestoneService;
import org.eclipse.egit.github.core.service.OrganizationService;
import org.eclipse.egit.github.core.service.PullRequestService;
import org.eclipse.egit.github.core.service.RepositoryService;
import org.eclipse.egit.github.core.service.TeamService;
import org.eclipse.egit.github.core.service.UserService;
import org.eclipse.egit.github.core.service.WatcherService;


public class ServicesModule extends AbstractModule {

    @Override
    protected void configure() {
    }

    @Provides
    IssueService issueService(GitHubClient client) {
        return new IssueService(client);
    }

    @Provides
    PullRequestService pullRequestService(GitHubClient client) {
        return new PullRequestService(client);
    }

    @Provides
    UserService userService(GitHubClient client) {
        return new UserService(client);
    }

    @Provides
    SearchUserService searchUserService(GitHubClient client) {
        return new SearchUserService(client);
    }

    @Provides
    GistService gistService(GitHubClient client) {
        return new GistService(client);
    }

    @Provides
    OrganizationService orgService(GitHubClient client) {
        return new OrganizationService(client);
    }

    @Provides
    RepositoryService repoService(GitHubClient client) {
        return new RepositoryService(client);
    }

    @Provides
    User currentUser(UserService userService) throws IOException {
        return userService.getUser();
    }

    @Provides
    CollaboratorService collaboratorService(GitHubClient client) {
        return new CollaboratorService(client);
    }

    @Provides
    MilestoneService milestoneService(GitHubClient client) {
        return new MilestoneService(client);
    }

    @Provides
    LabelService labelService(GitHubClient client) {
        return new LabelService(client);
    }

    @Provides
    EventService eventService(GitHubClient client) {
        return new EventService(client);
    }

    @Provides
    WatcherService watcherService(GitHubClient client) {
        return new WatcherService(client);
    }

    @Provides
    CommitService commitService(GitHubClient client) {
        return new CommitService(client);
    }

    @Provides
    DataService dataService(GitHubClient client) {
        return new DataService(client);
    }

    @Provides
    MarkdownService markdownService(GitHubClient client) {
        return new MarkdownService(client);
    }

    @Provides
    ContentsService contentsService(GitHubClient client) {
        return new ContentsService(client);
    }

    @Provides
    TeamService teamService(GitHubClient client) {
        return new TeamService(client);
    }
}

<code block>

package com.github.mobile;

import android.accounts.Account;
import android.content.Context;
import android.util.Log;

import com.github.mobile.accounts.AccountUtils;
import com.github.mobile.accounts.AuthenticatedUserLoader;


public abstract class ThrowableLoader<D> extends AuthenticatedUserLoader<D> {

    private static final String TAG = "ThrowableLoader";

    private final D data;

    private Exception exception;


    public ThrowableLoader(Context context, D data) {
        super(context);

        this.data = data;
    }

    @Override
    protected D getAccountFailureData() {
        return data;
    }

    @Override
    public D load(final Account account) {
        exception = null;
        try {
            return loadData();
        } catch (Exception e) {
            if (AccountUtils.isUnauthorized(e)
                    && AccountUtils.updateAccount(account, activity))
                try {
                    return loadData();
                } catch (Exception e2) {
                    e = e2;
                }
            Log.d(TAG, "Exception loading data", e);
            exception = e;
            return data;
        }
    }


    public Exception getException() {
        return exception;
    }


    public Exception clearException() {
        final Exception throwable = exception;
        exception = null;
        return throwable;
    }


    public abstract D loadData() throws Exception;
}

<code block>

package com.github.mobile.core;


public interface OnLoadListener<V> {


  void loaded(V data);
}

<code block>

package com.github.mobile.core;

import android.text.TextUtils;

import java.util.regex.Matcher;


public abstract class UrlMatcher {


    protected boolean isMatch(final String url, final Matcher matcher) {
        return !TextUtils.isEmpty(url) && matcher.reset(url).matches();
    }
}

<code block>

package com.github.mobile.core;

import java.lang.ref.ReferenceQueue;
import java.lang.ref.WeakReference;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;


public abstract class ItemStore {

    private static class ItemReference<V> extends WeakReference<V> {

        private Object id;


        public ItemReference(V item, Object id, ReferenceQueue<? super V> queue) {
            super(item, queue);
            this.id = id;
        }
    }


    protected static class ItemReferences<V> {

        private final ReferenceQueue<V> queue;

        private final Map<Object, ItemReference<V>> items;


        public ItemReferences() {
            queue = new ReferenceQueue<>();
            items = new ConcurrentHashMap<>();
        }

        @SuppressWarnings("rawtypes")
        private void expungeEntries() {
            ItemReference ref;
            while ((ref = (ItemReference) queue.poll()) != null)
                items.remove(ref.id);
        }


        public V get(final Object id) {
            expungeEntries();
            WeakReference<V> ref = items.get(id);
            return ref != null ? ref.get() : null;
        }


        public void put(Object id, V item) {
            expungeEntries();
            items.put(id, new ItemReference<>(item, id, queue));
        }
    }
}

<code block>

package com.github.mobile.core;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.egit.github.core.client.NoSuchPageException;
import org.eclipse.egit.github.core.client.PageIterator;


public abstract class ResourcePager<E> {


    protected int page = 1;


    protected int count = 1;


    protected final Map<Object, E> resources = new LinkedHashMap<>();


    protected boolean hasMore;


    public ResourcePager<E> reset() {
        page = 1;
        return clear();
    }


    public ResourcePager<E> clear() {
        count = Math.max(1, page - 1);
        page = 1;
        resources.clear();
        hasMore = true;
        return this;
    }


    public int size() {
        return resources.size();
    }


    public List<E> getResources() {
        return new ArrayList<>(resources.values());
    }


    public boolean next() throws IOException {
        boolean emptyPage = false;
        PageIterator<E> iterator = createIterator(page, -1);
        try {
            for (int i = 0; i < count && iterator.hasNext(); i++) {
                Collection<E> resourcePage = iterator.next();
                emptyPage = resourcePage.isEmpty();
                if (emptyPage)
                    break;
                for (E resource : resourcePage) {
                    resource = register(resource);
                    if (resource == null)
                        continue;
                    resources.put(getId(resource), resource);
                }
            }

            if (count > 1) {
                page = count;
                count = 1;
            }

            page++;
        } catch (NoSuchPageException e) {
            hasMore = false;
            throw e.getCause();
        }
        hasMore = iterator.hasNext() && !emptyPage;
        return hasMore;
    }


    public boolean hasMore() {
        return hasMore;
    }


    protected E register(final E resource) {
        return resource;
    }


    protected abstract Object getId(E resource);


    public abstract PageIterator<E> createIterator(final int page,
            final int size);
}

<code block>

package com.github.mobile.core.user;

import android.accounts.Account;
import android.content.Context;
import android.util.Log;

import com.github.mobile.accounts.AuthenticatedUserTask;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.service.UserService;


public class RefreshUserTask extends AuthenticatedUserTask<User> {

    private static final String TAG = "RefreshUserTask";

    @Inject
    private UserService service;

    private final String login;


    public RefreshUserTask(Context context, String login) {
        super(context);

        this.login = login;
    }

    @Override
    protected User run(Account account) throws Exception {
        return service.getUser(login);
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception loading user", e);
    }
}
<code block>

package com.github.mobile.core.user;

import android.net.Uri;

import com.github.mobile.core.repo.RepositoryUtils;

import java.util.List;

import org.eclipse.egit.github.core.User;


public class UserUriMatcher {


    public static User getUser(Uri uri) {
        List<String> segments = uri.getPathSegments();
        if (segments == null)
            return null;
        if (segments.size() < 1)
            return null;

        String login = segments.get(0);
        if (!RepositoryUtils.isValidOwner(login))
            return null;

        return new User().setLogin(login);
    }
}

<code block>

package com.github.mobile.core.user;

import org.eclipse.egit.github.core.service.UserService;

import android.accounts.Account;
import android.content.Context;
import android.util.Log;

import com.github.mobile.accounts.AuthenticatedUserTask;
import com.google.inject.Inject;


public class FollowingUserTask extends AuthenticatedUserTask<Boolean> {

    private static final String TAG = "FollowingUserTask";

    @Inject
    private UserService service;

    private final String login;


    public FollowingUserTask(final Context context, final String login) {
        super(context);

        this.login = login;
    }

    @Override
    protected Boolean run(final Account account) throws Exception {
        return service.isFollowing(login);
    }

    @Override
    protected void onException(final Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception checking if following user", e);
    }
}

<code block>

package com.github.mobile.core.user;

import android.accounts.Account;
import android.content.Context;
import android.util.Log;

import com.github.mobile.R;
import com.github.mobile.ui.ProgressDialogTask;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.service.UserService;


public class UnfollowUserTask extends ProgressDialogTask<User> {

    private static final String TAG = "UnfollowUserTask";

    @Inject
    private UserService service;

    private final String login;


    public UnfollowUserTask(final Context context, final String login) {
        super(context);

        this.login = login;
    }


    public void start() {
        showIndeterminate(R.string.unfollowing_user);

        execute();
    }

    @Override
    protected User run(final Account account) throws Exception {
        service.unfollow(login);

        return null;
    }

    @Override
    protected void onException(final Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception unfollowing user", e);
    }
}

<code block>

package com.github.mobile.core.user;

import android.accounts.Account;
import android.content.Context;
import android.util.Log;

import com.github.mobile.R;
import com.github.mobile.ui.ProgressDialogTask;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.service.UserService;


public class FollowUserTask extends ProgressDialogTask<User> {

    private static final String TAG = "FollowUserTask";

    @Inject
    private UserService service;

    private final String login;


    public FollowUserTask(final Context context, final String login) {
        super(context);

        this.login = login;
    }


    public void start() {
        showIndeterminate(R.string.following_user);

        execute();
    }

    @Override
    protected User run(final Account account) throws Exception {
        service.follow(login);

        return null;
    }

    @Override
    protected void onException(final Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception following user", e);
    }
}

<code block>

package com.github.mobile.core.user;

import static java.lang.String.CASE_INSENSITIVE_ORDER;

import com.github.mobile.accounts.GitHubAccount;
import com.google.inject.Inject;

import java.util.Comparator;

import org.eclipse.egit.github.core.User;


public class UserComparator implements Comparator<User> {

    private final String login;


    @Inject
    public UserComparator(final GitHubAccount account) {
        login = account.getUsername();
    }

    @Override
    public int compare(final User lhs, final User rhs) {
        final String lhsLogin = lhs.getLogin();
        final String rhsLogin = rhs.getLogin();

        if (lhsLogin.equals(login))
            return rhsLogin.equals(login) ? 0 : -1;

        if (rhsLogin.equals(login))
            return lhsLogin.equals(login) ? 0 : 1;

        return CASE_INSENSITIVE_ORDER.compare(lhsLogin, rhsLogin);
    }
}

<code block>

package com.github.mobile.core.user;

import static org.eclipse.egit.github.core.event.Event.TYPE_FOLLOW;

import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.event.Event;
import org.eclipse.egit.github.core.event.EventPayload;
import org.eclipse.egit.github.core.event.FollowPayload;


public class UserEventMatcher {


    public static class UserPair {


        public final User from;


        public final User to;

        private UserPair(final User from, final User to) {
            this.from = from;
            this.to = to;
        }
    }


    public UserPair getUsers(final Event event) {
        if (event == null)
            return null;

        EventPayload payload = event.getPayload();
        if (payload == null)
            return null;

        String type = event.getType();
        if (TYPE_FOLLOW.equals(type)) {
            User from = event.getActor();
            User to = ((FollowPayload) event.getPayload()).getTarget();
            if (from != null && to != null)
                return new UserPair(from, to);
        }

        return null;
    }
}

<code block>

package com.github.mobile.core.user;

import com.github.mobile.core.ResourcePager;

import org.eclipse.egit.github.core.User;


public abstract class UserPager extends ResourcePager<User> {

    @Override
    protected Object getId(User resource) {
        return resource.getId();
    }
}

<code block>

package com.github.mobile.core.issue;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.IssueEvent;


public class FullIssue extends ArrayList<Comment> implements Serializable {

    private static final long serialVersionUID = 4586476132467323827L;

    private final Issue issue;

    private Collection<IssueEvent> events;


    public FullIssue(final Issue issue, final Collection<Comment> comments, final Collection<IssueEvent> events) {
        super(comments);

        this.events = events;
        this.issue = issue;
    }


    public FullIssue() {
        this.issue = null;
    }


    public Issue getIssue() {
        return issue;
    }



    public Collection<IssueEvent> getEvents() {
        return events;
    }

}

<code block>

package com.github.mobile.core.issue;

import static org.eclipse.egit.github.core.event.Event.TYPE_ISSUES;
import static org.eclipse.egit.github.core.event.Event.TYPE_ISSUE_COMMENT;
import static org.eclipse.egit.github.core.event.Event.TYPE_PULL_REQUEST;

import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.event.Event;
import org.eclipse.egit.github.core.event.EventPayload;
import org.eclipse.egit.github.core.event.IssueCommentPayload;
import org.eclipse.egit.github.core.event.IssuesPayload;
import org.eclipse.egit.github.core.event.PullRequestPayload;


public class IssueEventMatcher {


    public Issue getIssue(Event event) {
        if (event == null)
            return null;
        EventPayload payload = event.getPayload();
        if (payload == null)
            return null;
        String type = event.getType();
        if (TYPE_ISSUES.equals(type))
            return ((IssuesPayload) payload).getIssue();
        else if (TYPE_ISSUE_COMMENT.equals(type))
            return ((IssueCommentPayload) payload).getIssue();
        else if (TYPE_PULL_REQUEST.equals(type))
            return IssueUtils.toIssue(((PullRequestPayload) payload)
                    .getPullRequest());
        else
            return null;
    }
}

<code block>

package com.github.mobile.core.issue;

import static java.lang.String.CASE_INSENSITIVE_ORDER;
import static org.eclipse.egit.github.core.service.IssueService.DIRECTION_DESCENDING;
import static org.eclipse.egit.github.core.service.IssueService.FIELD_DIRECTION;
import static org.eclipse.egit.github.core.service.IssueService.FIELD_SORT;
import static org.eclipse.egit.github.core.service.IssueService.FILTER_ASSIGNEE;
import static org.eclipse.egit.github.core.service.IssueService.FILTER_LABELS;
import static org.eclipse.egit.github.core.service.IssueService.FILTER_MILESTONE;
import static org.eclipse.egit.github.core.service.IssueService.FILTER_STATE;
import static org.eclipse.egit.github.core.service.IssueService.SORT_CREATED;
import static org.eclipse.egit.github.core.service.IssueService.STATE_CLOSED;
import static org.eclipse.egit.github.core.service.IssueService.STATE_OPEN;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

import org.eclipse.egit.github.core.Label;
import org.eclipse.egit.github.core.Milestone;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;


public class IssueFilter implements Serializable, Cloneable, Comparator<Label> {


    private static final long serialVersionUID = 7310646589186299063L;

    private final Repository repository;

    private Set<Label> labels;

    private Milestone milestone;

    private User assignee;

    private boolean open;


    public IssueFilter(final Repository repository) {
        this.repository = repository;
        open = true;
    }


    public IssueFilter setOpen(final boolean open) {
        this.open = open;
        return this;
    }


    public IssueFilter addLabel(Label label) {
        if (label == null)
            return this;
        if (labels == null)
            labels = new TreeSet<>(this);
        labels.add(label);
        return this;
    }


    public IssueFilter setLabels(Collection<Label> labels) {
        if (labels != null && !labels.isEmpty()) {
            if (this.labels == null)
                this.labels = new TreeSet<>(this);
            else
                this.labels.clear();
            this.labels.addAll(labels);
        } else
            this.labels = null;
        return this;
    }


    public Set<Label> getLabels() {
        return labels;
    }


    public Repository getRepository() {
        return repository;
    }


    public IssueFilter setMilestone(Milestone milestone) {
        this.milestone = milestone;
        return this;
    }


    public Milestone getMilestone() {
        return milestone;
    }


    public IssueFilter setAssignee(User assignee) {
        this.assignee = assignee;
        return this;
    }


    public boolean isOpen() {
        return open;
    }


    public User getAssignee() {
        return assignee;
    }


    public Map<String, String> toFilterMap() {
        final Map<String, String> filter = new HashMap<>();

        filter.put(FIELD_SORT, SORT_CREATED);
        filter.put(FIELD_DIRECTION, DIRECTION_DESCENDING);

        if (assignee != null)
            filter.put(FILTER_ASSIGNEE, assignee.getLogin());

        if (milestone != null)
            filter.put(FILTER_MILESTONE,
                    Integer.toString(milestone.getNumber()));

        if (labels != null && !labels.isEmpty()) {
            StringBuilder labelsQuery = new StringBuilder();
            for (Label label : labels)
                labelsQuery.append(label.getName()).append(',');
            filter.put(FILTER_LABELS, labelsQuery.toString());
        }

        if (open)
            filter.put(FILTER_STATE, STATE_OPEN);
        else
            filter.put(FILTER_STATE, STATE_CLOSED);
        return filter;
    }


    public CharSequence toDisplay() {
        List<String> segments = new ArrayList<>();
        if (open)
            segments.add("Open issues");
        else
            segments.add("Closed issues");

        if (assignee != null)
            segments.add("Assignee: " + assignee.getLogin());

        if (milestone != null)
            segments.add("Milestone: " + milestone.getTitle());

        if (labels != null && !labels.isEmpty()) {
            StringBuilder builder = new StringBuilder("Labels: ");
            for (Label label : labels)
                builder.append(label.getName()).append(',').append(' ');
            builder.deleteCharAt(builder.length() - 1);
            builder.deleteCharAt(builder.length() - 1);
            segments.add(builder.toString());
        }

        if (segments.isEmpty())
            return "";

        StringBuilder all = new StringBuilder();
        for (String segment : segments)
            all.append(segment).append(',').append(' ');
        all.deleteCharAt(all.length() - 1);
        all.deleteCharAt(all.length() - 1);
        return all;
    }

    @Override
    public int hashCode() {
        return Arrays.hashCode(new Object[] { open,
                assignee != null ? assignee.getId() : null,
                milestone != null ? milestone.getNumber() : null,
                assignee != null ? assignee.getId() : null,
                repository != null ? repository.getId() : null, labels });
    }

    private boolean isEqual(Object a, Object b) {
        if (a == null && b == null)
            return true;
        return a != null && a.equals(b);
    }

    private boolean isEqual(Milestone a, Milestone b) {
        if (a == null && b == null)
            return true;
        return a != null && b != null && a.getNumber() == b.getNumber();
    }

    private boolean isEqual(User a, User b) {
        if (a == null && b == null)
            return true;
        return a != null && b != null && a.getId() == b.getId();
    }

    private boolean isEqual(Repository a, Repository b) {
        return a != null && b != null && a.getId() == b.getId();
    }

    @Override
    public boolean equals(Object o) {
        if (o == this)
            return true;
        if (!(o instanceof IssueFilter))
            return false;

        IssueFilter other = (IssueFilter) o;
        return open == other.open && isEqual(milestone, other.milestone)
                && isEqual(assignee, other.assignee)
                && isEqual(repository, repository)
                && isEqual(labels, other.labels);
    }

    @Override
    public IssueFilter clone() {
        try {
            return (IssueFilter) super.clone();
        } catch (CloneNotSupportedException e) {

            throw new IllegalArgumentException(e);
        }
    }

    @Override
    public int compare(Label lhs, Label rhs) {
        return CASE_INSENSITIVE_ORDER.compare(lhs.getName(), rhs.getName());
    }
}

<code block>

package com.github.mobile.core.issue;

import android.text.TextUtils;

import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.PullRequest;


public class IssueUtils {


    public static boolean isPullRequest(final Issue issue) {
        return issue != null && issue.getPullRequest() != null
                && !TextUtils.isEmpty(issue.getPullRequest().getHtmlUrl());
    }


    public static Issue toIssue(final PullRequest pullRequest) {
        if (pullRequest == null)
            return null;

        Issue issue = new Issue();
        issue.setAssignee(pullRequest.getAssignee());
        issue.setBody(pullRequest.getBody());
        issue.setBodyHtml(pullRequest.getBodyHtml());
        issue.setBodyText(pullRequest.getBodyText());
        issue.setClosedAt(pullRequest.getClosedAt());
        issue.setComments(pullRequest.getComments());
        issue.setCreatedAt(pullRequest.getCreatedAt());
        issue.setHtmlUrl(pullRequest.getHtmlUrl());
        issue.setId(pullRequest.getId());
        issue.setMilestone(pullRequest.getMilestone());
        issue.setNumber(pullRequest.getNumber());
        issue.setPullRequest(pullRequest);
        issue.setState(pullRequest.getState());
        issue.setTitle(pullRequest.getTitle());
        issue.setUpdatedAt(pullRequest.getUpdatedAt());
        issue.setUrl(pullRequest.getUrl());
        issue.setUser(pullRequest.getUser());
        return issue;
    }
}

<code block>

package com.github.mobile.core.issue;

import android.net.Uri;
import android.text.TextUtils;

import com.github.mobile.core.repo.RepositoryUtils;

import java.util.List;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.RepositoryIssue;
import org.eclipse.egit.github.core.User;


public class IssueUriMatcher {


    public static RepositoryIssue getIssue(Uri uri) {
        List<String> segments = uri.getPathSegments();
        if (segments == null)
            return null;
        if (segments.size() < 4)
            return null;
        if (!"issues".equals(segments.get(2)) && !"pull".equals(segments.get(2)))
            return null;

        String repoOwner = segments.get(0);
        if (!RepositoryUtils.isValidOwner(repoOwner))
            return null;

        String repoName = segments.get(1);
        if (!RepositoryUtils.isValidRepo(repoName))
            return null;

        String number = segments.get(3);
        if (TextUtils.isEmpty(number))
            return null;

        int issueNumber;
        try {
            issueNumber = Integer.parseInt(number);
        } catch (NumberFormatException nfe) {
            return null;
        }
        if (issueNumber < 1)
            return null;

        Repository repo = new Repository();
        repo.setName(repoName);
        repo.setOwner(new User().setLogin(repoOwner));
        RepositoryIssue issue = new RepositoryIssue();
        issue.setRepository(repo);
        issue.setNumber(issueNumber);
        return issue;
    }
}

<code block>

package com.github.mobile.core.issue;

import com.github.mobile.core.ItemStore;
import com.github.mobile.util.HtmlUtils;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.RepositoryId;
import org.eclipse.egit.github.core.RepositoryIssue;
import org.eclipse.egit.github.core.client.RequestException;
import org.eclipse.egit.github.core.service.IssueService;
import org.eclipse.egit.github.core.service.PullRequestService;


public class IssueStore extends ItemStore {

    private final Map<String, ItemReferences<RepositoryIssue>> repos = new HashMap<>();

    private final IssueService issueService;

    private final PullRequestService pullService;


    public IssueStore(final IssueService issueService,
            final PullRequestService pullService) {
        this.issueService = issueService;
        this.pullService = pullService;
    }


    public RepositoryIssue getIssue(IRepositoryIdProvider repository, int number) {
        ItemReferences<RepositoryIssue> repoIssues = repos.get(repository
                .generateId());
        return repoIssues != null ? repoIssues.get(number) : null;
    }


    public RepositoryIssue addIssue(Issue issue) {
        IRepositoryIdProvider repo = null;
        if (issue instanceof RepositoryIssue)
            repo = ((RepositoryIssue) issue).getRepository();
        if (repo == null)
            repo = RepositoryId.createFromUrl(issue.getHtmlUrl());
        return addIssue(repo, issue);
    }

    private RepositoryIssue createRepositoryIssue(Issue issue) {
        if (issue instanceof RepositoryIssue)
            return (RepositoryIssue) issue;

        RepositoryIssue repoIssue = new RepositoryIssue();
        repoIssue.setAssignee(issue.getAssignee());
        repoIssue.setBody(issue.getBody());
        repoIssue.setBodyHtml(issue.getBodyHtml());
        repoIssue.setBodyText(issue.getBodyText());
        repoIssue.setClosedAt(issue.getClosedAt());
        repoIssue.setComments(issue.getComments());
        repoIssue.setCreatedAt(issue.getCreatedAt());
        repoIssue.setHtmlUrl(issue.getHtmlUrl());
        repoIssue.setId(issue.getId());
        repoIssue.setLabels(issue.getLabels());
        repoIssue.setMilestone(issue.getMilestone());
        repoIssue.setNumber(issue.getNumber());
        repoIssue.setPullRequest(issue.getPullRequest());
        repoIssue.setState(issue.getState());
        repoIssue.setTitle(issue.getTitle());
        repoIssue.setUpdatedAt(issue.getUpdatedAt());
        repoIssue.setUrl(issue.getUrl());
        repoIssue.setUser(issue.getUser());
        return repoIssue;
    }


    public RepositoryIssue addIssue(IRepositoryIdProvider repository,
            Issue issue) {
        issue.setBodyHtml(HtmlUtils.format(issue.getBodyHtml()).toString());
        RepositoryIssue current = getIssue(repository, issue.getNumber());
        if (current != null) {
            current.setAssignee(issue.getAssignee());
            current.setBody(issue.getBody());
            current.setBodyHtml(issue.getBodyHtml());
            current.setClosedAt(issue.getClosedAt());
            current.setComments(issue.getComments());
            current.setLabels(issue.getLabels());
            current.setMilestone(issue.getMilestone());
            current.setPullRequest(issue.getPullRequest());
            current.setState(issue.getState());
            current.setTitle(issue.getTitle());
            current.setUpdatedAt(issue.getUpdatedAt());
            if (issue instanceof RepositoryIssue)
                current.setRepository(((RepositoryIssue) issue).getRepository());
            return current;
        } else {
            String repoId = repository.generateId();
            ItemReferences<RepositoryIssue> repoIssues = repos.get(repoId);
            if (repoIssues == null) {
                repoIssues = new ItemReferences<>();
                repos.put(repoId, repoIssues);
            }
            RepositoryIssue repoIssue = createRepositoryIssue(issue);
            repoIssues.put(issue.getNumber(), repoIssue);
            return repoIssue;
        }
    }


    public RepositoryIssue refreshIssue(IRepositoryIdProvider repository,
            int number) throws IOException {
        Issue issue;
        try {
            issue = issueService.getIssue(repository, number);
            if (IssueUtils.isPullRequest(issue))
                issue = IssueUtils.toIssue(pullService.getPullRequest(
                    repository, number));
        } catch (IOException e) {
            if (e instanceof RequestException
                    && 410 == ((RequestException) e).getStatus())
                try {
                    issue = IssueUtils.toIssue(pullService.getPullRequest(
                            repository, number));
                } catch (IOException e2) {
                    throw e;
                }
            else
                throw e;
        }
        return addIssue(repository, issue);
    }


    public RepositoryIssue editIssue(IRepositoryIdProvider repository,
            Issue issue) throws IOException {
        return addIssue(repository, issueService.editIssue(repository, issue));
    }
}

<code block>

package com.github.mobile.core.issue;

import com.github.mobile.core.ResourcePager;

import org.eclipse.egit.github.core.Issue;


public abstract class IssuePager extends ResourcePager<Issue> {


    protected final IssueStore store;


    public IssuePager(final IssueStore store) {
        this.store = store;
    }

    @Override
    protected Issue register(Issue resource) {
        return store.addIssue(resource);
    }

    @Override
    protected Object getId(Issue resource) {
        return resource.getId();
    }
}

<code block>

package com.github.mobile.core.issue;

import android.accounts.Account;
import android.content.Context;
import android.util.Log;

import com.github.mobile.accounts.AuthenticatedUserTask;
import com.github.mobile.util.HtmlUtils;
import com.github.mobile.util.HttpImageGetter;
import com.google.inject.Inject;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.IssueEvent;
import org.eclipse.egit.github.core.service.IssueService;


public class RefreshIssueTask extends AuthenticatedUserTask<FullIssue> {

    private static final String TAG = "RefreshIssueTask";

    @Inject
    private IssueService service;

    @Inject
    private IssueStore store;

    private final IRepositoryIdProvider repositoryId;

    private final int issueNumber;

    private final HttpImageGetter bodyImageGetter;

    private final HttpImageGetter commentImageGetter;


    public RefreshIssueTask(Context context,
            IRepositoryIdProvider repositoryId, int issueNumber,
            HttpImageGetter bodyImageGetter, HttpImageGetter commentImageGetter) {
        super(context);

        this.repositoryId = repositoryId;
        this.issueNumber = issueNumber;
        this.bodyImageGetter = bodyImageGetter;
        this.commentImageGetter = commentImageGetter;
    }

    @Override
    public FullIssue run(Account account) throws Exception {
        Issue issue = store.refreshIssue(repositoryId, issueNumber);
        bodyImageGetter.encode(issue.getId(), issue.getBodyHtml());
        List<Comment> comments;
        if (issue.getComments() > 0)
            comments = service.getComments(repositoryId, issueNumber);
        else
            comments = Collections.emptyList();

        for (Comment comment : comments) {
            String formatted = HtmlUtils.format(comment.getBodyHtml())
                    .toString();
            comment.setBodyHtml(formatted);
            commentImageGetter.encode(comment.getId(), formatted);
        }

        String[] repo = repositoryId.generateId().split("/");
        Iterator<Collection<IssueEvent>> eventsIterator = service.pageIssueEvents(repo[0], repo[1], issueNumber).iterator();
        List<IssueEvent> events = new ArrayList<>();

        while (eventsIterator.hasNext())
            events.addAll(eventsIterator.next());

        return new FullIssue(issue, comments, events);
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception loading issue", e);
    }
}

<code block>

package com.github.mobile.core.search;

import java.io.Serializable;
import java.util.Date;

import org.eclipse.egit.github.core.util.DateUtils;


public class SearchUser implements Serializable {


    private static final long serialVersionUID = 159979362732689788L;

    private Date createdAt;

    private int followers;

    private String id;

    private String gravatarId;

    private String location;

    private String login;

    private String name;

    private String language;


    public Date getCreatedAt() {
        return DateUtils.clone(createdAt);
    }


    public SearchUser setCreatedAt(Date createdAt) {
        this.createdAt = DateUtils.clone(createdAt);
        return this;
    }


    public int getFollowers() {
        return followers;
    }


    public SearchUser setFollowers(int followers) {
        this.followers = followers;
        return this;
    }


    public String getId() {
        return id;
    }


    public SearchUser setId(String id) {
        this.id = id;
        return this;
    }


    public String getGravatarId() {
        return gravatarId;
    }


    public SearchUser setGravatarId(String gravatarId) {
        this.gravatarId = gravatarId;
        return this;
    }


    public String getLocation() {
        return location;
    }


    public SearchUser setLocation(String location) {
        this.location = location;
        return this;
    }


    public String getLogin() {
        return login;
    }


    public SearchUser setLogin(String login) {
        this.login = login;
        return this;
    }


    public String getName() {
        return name;
    }


    public SearchUser setName(String name) {
        this.name = name;
        return this;
    }


    public String getLanguage() {
        return language;
    }


    public SearchUser setLanguage(String language) {
        this.language = language;
        return this;
    }
}

<code block>

package com.github.mobile.core.search;

import static org.eclipse.egit.github.core.client.IGitHubConstants.CHARSET_UTF8;
import static org.eclipse.egit.github.core.client.IGitHubConstants.PARAM_START_PAGE;
import static org.eclipse.egit.github.core.client.IGitHubConstants.SEGMENT_USER;
import static org.eclipse.egit.github.core.client.IGitHubConstants.SEGMENT_LEGACY;
import static org.eclipse.egit.github.core.client.IGitHubConstants.SEGMENT_SEARCH;

import java.io.IOException;
import java.net.URLEncoder;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.egit.github.core.IResourceProvider;
import org.eclipse.egit.github.core.client.GitHubClient;
import org.eclipse.egit.github.core.client.PagedRequest;
import org.eclipse.egit.github.core.service.UserService;

public class SearchUserService extends UserService {

    private static class UserContainer implements
            IResourceProvider<SearchUser> {

        private List<SearchUser> users;


        @Override
        public List<SearchUser> getResources() {
            return users;
        }
    }


    public SearchUserService() {
        super();
    }


    public SearchUserService(GitHubClient client) {
        super(client);
    }


    public List<SearchUser> searchUsers(final String query)
            throws IOException {
        return searchUsers(query, -1);
    }


    public List<SearchUser> searchUsers(final String query,
            final int startPage) throws IOException {
        if (query == null)
            throw new IllegalArgumentException("Query cannot be null"); 
        if (query.length() == 0)
            throw new IllegalArgumentException("Query cannot be empty"); 

        StringBuilder uri = new StringBuilder(SEGMENT_LEGACY + SEGMENT_USER
                + SEGMENT_SEARCH);
        final String encodedQuery = URLEncoder.encode(query, CHARSET_UTF8)
                .replace("+", "%20") 
                .replace(".", "%2E"); 
        uri.append('/').append(encodedQuery);

        PagedRequest<SearchUser> request = createPagedRequest();

        Map<String, String> params = new HashMap<>(2, 1);
        if (startPage > 0)
            params.put(PARAM_START_PAGE, Integer.toString(startPage));
        if (!params.isEmpty())
            request.setParams(params);

        request.setUri(uri);
        request.setType(UserContainer.class);
        return getAll(request);
    }


    public List<SearchUser> searchUsers(
            final Map<String, String> params) throws IOException {
        return searchUsers(params, -1);
    }


    public List<SearchUser> searchUsers(
            final Map<String, String> queryParams, final int startPage)
            throws IOException {
        if (queryParams == null)
            throw new IllegalArgumentException("Params cannot be null"); 
        if (queryParams.isEmpty())
            throw new IllegalArgumentException("Params cannot be empty"); 

        StringBuilder query = new StringBuilder();
        for (Map.Entry<String, String> param : queryParams.entrySet())
            query.append(param.getKey()).append(':').append(param.getValue())
                .append(' ');
        return searchUsers(query.toString(), startPage);
    }
}

<code block>

package com.github.mobile.core.commit;

import android.net.Uri;

import com.github.mobile.core.repo.RepositoryUtils;

import java.util.List;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;


public class CommitUriMatcher {


    public static CommitMatch getCommit(Uri uri) {
        List<String> segments = uri.getPathSegments();
        if (segments == null)
            return null;
        if (segments.size() < 4)
            return null;
        if (!"commit".equals(segments.get(2)))
            return null;

        String repoOwner = segments.get(0);
        if (!RepositoryUtils.isValidOwner(repoOwner))
            return null;

        String repoName = segments.get(1);
        if (!RepositoryUtils.isValidRepo(repoName))
            return null;

        String commit = segments.get(3);
        if (!CommitUtils.isValidCommit(commit))
            return null;

        Repository repository = new Repository();
        repository.setName(repoName);
        repository.setOwner(new User().setLogin(repoOwner));
        return new CommitMatch(repository, commit);
    }
}

<code block>

package com.github.mobile.core.commit;

import android.text.TextUtils;
import android.widget.ImageView;

import com.github.mobile.ui.StyledText;
import com.github.mobile.util.AvatarLoader;

import java.text.NumberFormat;
import java.util.Collection;
import java.util.Date;

import org.eclipse.egit.github.core.Commit;
import org.eclipse.egit.github.core.CommitFile;
import org.eclipse.egit.github.core.CommitUser;
import org.eclipse.egit.github.core.RepositoryCommit;
import org.eclipse.egit.github.core.User;


public class CommitUtils {


    public static final int LENGTH = 10;

    private static final NumberFormat FORMAT = NumberFormat
            .getIntegerInstance();


    public static String abbreviate(final RepositoryCommit commit) {
        return commit != null ? abbreviate(commit.getSha()) : null;
    }


    public static String abbreviate(final Commit commit) {
        return commit != null ? abbreviate(commit.getSha()) : null;
    }


    public static String abbreviate(final String sha) {
        if (!TextUtils.isEmpty(sha) && sha.length() > LENGTH)
            return sha.substring(0, LENGTH);
        else
            return sha;
    }


    public static boolean isValidCommit(final String sha) {
        return !TextUtils.isEmpty(sha) && sha.matches("[a-fA-F0-9]+");
    }


    public static String getAuthor(final RepositoryCommit commit) {
        User author = commit.getAuthor();
        if (author != null)
            return author.getLogin();

        Commit rawCommit = commit.getCommit();
        if (rawCommit == null)
            return null;

        CommitUser commitAuthor = rawCommit.getAuthor();
        return commitAuthor != null ? commitAuthor.getName() : null;
    }


    public static String getCommitter(final RepositoryCommit commit) {
        User committer = commit.getCommitter();
        if (committer != null)
            return committer.getLogin();

        Commit rawCommit = commit.getCommit();
        if (rawCommit == null)
            return null;

        CommitUser commitCommitter = rawCommit.getCommitter();
        return commitCommitter != null ? commitCommitter.getName() : null;
    }


    public static Date getAuthorDate(final RepositoryCommit commit) {
        Commit rawCommit = commit.getCommit();
        if (rawCommit == null)
            return null;

        CommitUser commitAuthor = rawCommit.getAuthor();
        return commitAuthor != null ? commitAuthor.getDate() : null;
    }


    public static Date getCommitterDate(final RepositoryCommit commit) {
        Commit rawCommit = commit.getCommit();
        if (rawCommit == null)
            return null;

        CommitUser commitCommitter = rawCommit.getCommitter();
        return commitCommitter != null ? commitCommitter.getDate() : null;
    }


    public static ImageView bindAuthor(final RepositoryCommit commit,
            final AvatarLoader avatars, final ImageView view) {
        User author = commit.getAuthor();
        if (author != null)
            avatars.bind(view, author);
        else {
            Commit rawCommit = commit.getCommit();
            if (rawCommit != null)
                avatars.bind(view, rawCommit.getAuthor());
        }
        return view;
    }


    public static ImageView bindCommitter(final RepositoryCommit commit,
            final AvatarLoader avatars, final ImageView view) {
        User committer = commit.getCommitter();
        if (committer != null)
            avatars.bind(view, committer);
        else {
            Commit rawCommit = commit.getCommit();
            if (rawCommit != null)
                avatars.bind(view, rawCommit.getCommitter());
        }
        return view;
    }


    public static String getCommentCount(final RepositoryCommit commit) {
        final Commit rawCommit = commit.getCommit();
        if (rawCommit != null)
            return FORMAT.format(rawCommit.getCommentCount());
        else
            return "0";
    }


    public static StyledText formatStats(final Collection<CommitFile> files) {
        StyledText fileDetails = new StyledText();
        int added = 0;
        int deleted = 0;
        int changed = 0;
        if (files != null)
            for (CommitFile file : files) {
                added += file.getAdditions();
                deleted += file.getDeletions();
                changed++;
            }

        if (changed != 1)
            fileDetails.append(FORMAT.format(changed)).append(" changed files");
        else
            fileDetails.append("1 changed file");
        fileDetails.append(" with ");

        if (added != 1)
            fileDetails.append(FORMAT.format(added)).append(" additions");
        else
            fileDetails.append("1 addition ");
        fileDetails.append(" and ");

        if (deleted != 1)
            fileDetails.append(FORMAT.format(deleted)).append(" deletions");
        else
            fileDetails.append("1 deletion");

        return fileDetails;
    }


    public static String getName(final CommitFile file) {
        return file != null ? getName(file.getFilename()) : null;
    }


    public static String getName(final String path) {
        if (TextUtils.isEmpty(path))
            return path;

        int lastSlash = path.lastIndexOf('/');
        if (lastSlash != -1 && lastSlash + 1 < path.length())
            return path.substring(lastSlash + 1);
        else
            return path;
    }
}

<code block>

package com.github.mobile.core.commit;

import android.text.TextUtils;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import org.eclipse.egit.github.core.CommitComment;
import org.eclipse.egit.github.core.CommitFile;
import org.eclipse.egit.github.core.RepositoryCommit;


public class FullCommit extends ArrayList<CommitComment> implements
        Serializable {

    private static final long serialVersionUID = 2470370479577730822L;

    private final RepositoryCommit commit;

    private final List<FullCommitFile> files;


    public FullCommit(final RepositoryCommit commit) {
        this.commit = commit;
        List<CommitFile> rawFiles = commit.getFiles();
        if (rawFiles != null && !rawFiles.isEmpty()) {
            files = new ArrayList<>(rawFiles.size());
            for (CommitFile file : rawFiles)
                files.add(new FullCommitFile(file));
        } else
            files = Collections.emptyList();
    }


    public FullCommit(final RepositoryCommit commit,
            final Collection<CommitComment> comments) {
        this.commit = commit;

        List<CommitFile> rawFiles = commit.getFiles();
        boolean hasComments = comments != null && !comments.isEmpty();
        boolean hasFiles = rawFiles != null && !rawFiles.isEmpty();
        if (hasFiles) {
            files = new ArrayList<>(rawFiles.size());
            if (hasComments) {
                for (CommitFile file : rawFiles) {
                    Iterator<CommitComment> iterator = comments.iterator();
                    FullCommitFile full = new FullCommitFile(file);
                    while (iterator.hasNext()) {
                        CommitComment comment = iterator.next();
                        if (file.getFilename().equals(comment.getPath())) {
                            full.add(comment);
                            iterator.remove();
                        }
                    }
                    files.add(full);
                }
                hasComments = !comments.isEmpty();
            } else
                for (CommitFile file : rawFiles)
                    files.add(new FullCommitFile(file));
        } else
            files = Collections.emptyList();

        if (hasComments)
            addAll(comments);
    }

    @Override
    public boolean add(final CommitComment comment) {
        String path = comment.getPath();
        if (TextUtils.isEmpty(path))
            return super.add(comment);
        else {
            boolean added = false;
            for (FullCommitFile file : files)
                if (path.equals(file.getFile().getFilename())) {
                    file.add(comment);
                    added = true;
                    break;
                }
            if (!added)
                added = super.add(comment);
            return added;
        }
    }


    public List<FullCommitFile> getFiles() {
        return files;
    }


    public RepositoryCommit getCommit() {
        return commit;
    }
}

<code block>

package com.github.mobile.core.commit;

import android.util.SparseArray;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.eclipse.egit.github.core.CommitComment;
import org.eclipse.egit.github.core.CommitFile;


public class FullCommitFile {

    private final SparseArray<List<CommitComment>> comments = new SparseArray<>(
            4);

    private final CommitFile file;


    public FullCommitFile(final CommitFile file) {
        this.file = file;
    }


    public List<CommitComment> get(final int line) {
        List<CommitComment> lineComments = comments.get(line);
        return lineComments != null ? lineComments : Collections
                .<CommitComment> emptyList();
    }


    public FullCommitFile add(final CommitComment comment) {
        int line = comment.getPosition();
        if (line >= 0) {
            List<CommitComment> lineComments = comments.get(line);
            if (lineComments == null) {
                lineComments = new ArrayList<>(4);
                comments.put(line, lineComments);
            }
            lineComments.add(comment);
        }
        return this;
    }


    public CommitFile getFile() {
        return file;
    }
}

<code block>

package com.github.mobile.core.commit;

import org.eclipse.egit.github.core.Repository;


public class CommitMatch {


    public final Repository repository;


    public final String commit;


    public CommitMatch(final Repository repository, final String commit) {
        this.repository = repository;
        this.commit = commit;
    }
}

<code block>

package com.github.mobile.core.commit;

import com.github.mobile.core.ResourcePager;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.RepositoryCommit;


public abstract class CommitPager extends ResourcePager<RepositoryCommit> {

    private final IRepositoryIdProvider repository;

    private final CommitStore store;


    public CommitPager(final IRepositoryIdProvider repository,
            final CommitStore store) {
        this.repository = repository;
        this.store = store;
    }

    @Override
    protected Object getId(final RepositoryCommit resource) {
        return resource.getSha();
    }

    @Override
    protected RepositoryCommit register(final RepositoryCommit resource) {
        return store.addCommit(repository, resource);
    }
}

<code block>

package com.github.mobile.core.commit;

import android.accounts.Account;
import android.content.Context;
import android.util.Log;

import com.github.mobile.accounts.AuthenticatedUserTask;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.RepositoryCommitCompare;
import org.eclipse.egit.github.core.service.CommitService;


public class CommitCompareTask extends
        AuthenticatedUserTask<RepositoryCommitCompare> {

    private static final String TAG = "CommitCompareTask";

    @Inject
    private CommitService service;

    private final IRepositoryIdProvider repository;

    private final String base;

    private final String head;


    public CommitCompareTask(Context context, IRepositoryIdProvider repository,
            String base, String head) {
        super(context);

        this.repository = repository;
        this.base = base;
        this.head = head;
    }

    @Override
    protected RepositoryCommitCompare run(Account account) throws Exception {
        return service.compare(repository, base, head);
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception loading commit compare", e);
    }
}

<code block>

package com.github.mobile.core.commit;

import com.github.mobile.core.ItemStore;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.RepositoryCommit;
import org.eclipse.egit.github.core.service.CommitService;


public class CommitStore extends ItemStore {

    private final Map<String, ItemReferences<RepositoryCommit>> commits = new HashMap<>();

    private final CommitService service;


    public CommitStore(final CommitService service) {
        this.service = service;
    }


    public RepositoryCommit getCommit(final IRepositoryIdProvider repo,
            final String id) {
        final ItemReferences<RepositoryCommit> repoCommits = commits.get(repo
                .generateId());
        return repoCommits != null ? repoCommits.get(id) : null;
    }


    public RepositoryCommit addCommit(IRepositoryIdProvider repo,
            RepositoryCommit commit) {
        RepositoryCommit current = getCommit(repo, commit.getSha());
        if (current != null) {
            current.setAuthor(commit.getAuthor());
            current.setCommit(commit.getCommit());
            current.setCommitter(commit.getCommitter());
            current.setFiles(commit.getFiles());
            current.setParents(commit.getParents());
            current.setSha(commit.getSha());
            current.setStats(commit.getStats());
            current.setUrl(commit.getUrl());
            return current;
        } else {
            String repoId = repo.generateId();
            ItemReferences<RepositoryCommit> repoCommits = commits.get(repoId);
            if (repoCommits == null) {
                repoCommits = new ItemReferences<>();
                commits.put(repoId, repoCommits);
            }
            repoCommits.put(commit.getSha(), commit);
            return commit;
        }
    }


    public RepositoryCommit refreshCommit(final IRepositoryIdProvider repo,
            final String id) throws IOException {
        return addCommit(repo, service.getCommit(repo, id));
    }
}

<code block>

package com.github.mobile.core.commit;

import android.accounts.Account;
import android.content.Context;
import android.util.Log;

import com.github.mobile.accounts.AuthenticatedUserTask;
import com.github.mobile.util.HtmlUtils;
import com.github.mobile.util.HttpImageGetter;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.egit.github.core.Commit;
import org.eclipse.egit.github.core.CommitComment;
import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.RepositoryCommit;
import org.eclipse.egit.github.core.service.CommitService;


public class RefreshCommitTask extends AuthenticatedUserTask<FullCommit> {

    private static final String TAG = "RefreshCommitTask";

    @Inject
    private CommitStore store;

    @Inject
    private CommitService service;

    private final IRepositoryIdProvider repository;

    private final String id;

    private final HttpImageGetter imageGetter;


    public RefreshCommitTask(Context context, IRepositoryIdProvider repository,
            String id, HttpImageGetter imageGetter) {
        super(context);

        this.repository = repository;
        this.id = id;
        this.imageGetter = imageGetter;
    }

    @Override
    protected FullCommit run(Account account) throws Exception {
        RepositoryCommit commit = store.refreshCommit(repository, id);
        Commit rawCommit = commit.getCommit();
        if (rawCommit != null && rawCommit.getCommentCount() > 0) {
            List<CommitComment> comments = service.getComments(repository,
                    commit.getSha());
            for (CommitComment comment : comments) {
                String formatted = HtmlUtils.format(comment.getBodyHtml())
                        .toString();
                comment.setBodyHtml(formatted);
                imageGetter.encode(comment, formatted);
            }
            return new FullCommit(commit, comments);
        } else
            return new FullCommit(commit);
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception loading commit", e);
    }
}

<code block>

package com.github.mobile.core.ref;

import android.text.TextUtils;

import org.eclipse.egit.github.core.Reference;


public class RefUtils {

    private static final String PREFIX_REFS = "refs/";

    private static final String PREFIX_PULL = PREFIX_REFS + "pull/";

    private static final String PREFIX_TAG = PREFIX_REFS + "tags/";

    private static final String PREFIX_HEADS = PREFIX_REFS + "heads/";


    public static boolean isBranch(final Reference ref) {
        if (ref != null) {
            String name = ref.getRef();
            return !TextUtils.isEmpty(name) && name.startsWith(PREFIX_HEADS);
        } else
            return false;
    }


    public static boolean isTag(final Reference ref) {
        return ref != null && isTag(ref.getRef());
    }


    public static boolean isTag(final String name) {
        return !TextUtils.isEmpty(name) && name.startsWith(PREFIX_TAG);
    }


    public static String getPath(final Reference ref) {
        if (ref == null)
            return null;
        String name = ref.getRef();
        if (!TextUtils.isEmpty(name) && name.startsWith(PREFIX_REFS))
            return name.substring(PREFIX_REFS.length());
        else
            return name;
    }


    public static String getName(final Reference ref) {
        if (ref != null)
            return getName(ref.getRef());
        else
            return null;
    }


    public static String getName(final String name) {
        if (TextUtils.isEmpty(name))
            return name;
        if (name.startsWith(PREFIX_HEADS))
            return name.substring(PREFIX_HEADS.length());
        else if (name.startsWith(PREFIX_TAG))
            return name.substring(PREFIX_TAG.length());
        else if (name.startsWith(PREFIX_REFS))
            return name.substring(PREFIX_REFS.length());
        else
            return name;
    }


    public static boolean isValid(final Reference ref) {
        if (ref == null)
            return false;

        String name = ref.getRef();
        return !TextUtils.isEmpty(name) && !name.startsWith(PREFIX_PULL);
    }
}

<code block>

package com.github.mobile.core.gist;

import static java.lang.String.CASE_INSENSITIVE_ORDER;

import com.github.mobile.core.ItemStore;

import java.io.IOException;
import java.util.Map;
import java.util.TreeMap;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.GistFile;
import org.eclipse.egit.github.core.service.GistService;


public class GistStore extends ItemStore {

    private final ItemReferences<Gist> gists = new ItemReferences<>();

    private final GistService service;


    public GistStore(final GistService service) {
        this.service = service;
    }


    public Gist getGist(String id) {
        return gists.get(id);
    }


    protected Map<String, GistFile> sortFiles(final Gist gist) {
        Map<String, GistFile> files = gist.getFiles();
        if (files == null || files.size() < 2)
            return files;

        Map<String, GistFile> sorted = new TreeMap<>(
                CASE_INSENSITIVE_ORDER);
        sorted.putAll(files);
        return sorted;
    }


    public Gist addGist(Gist gist) {
        Gist current = getGist(gist.getId());
        if (current != null) {
            current.setComments(gist.getComments());
            current.setDescription(gist.getDescription());
            current.setFiles(sortFiles(gist));
            current.setUpdatedAt(gist.getUpdatedAt());
            return current;
        } else {
            gist.setFiles(sortFiles(gist));
            gists.put(gist.getId(), gist);
            return gist;
        }
    }


    public Gist refreshGist(String id) throws IOException {
        return addGist(service.getGist(id));
    }


    public Gist editGist(Gist gist) throws IOException {
        return addGist(service.updateGist(gist));
    }
}

<code block>

package com.github.mobile.core.gist;

import android.accounts.Account;
import android.content.Context;
import android.util.Log;

import com.github.mobile.accounts.AuthenticatedUserTask;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.service.GistService;


public class StarGistTask extends AuthenticatedUserTask<Gist> {

    private static final String TAG = "StarGistTask";

    @Inject
    private GistService service;

    private final String id;


    public StarGistTask(final Context context, final String id) {
        super(context);

        this.id = id;
    }

    @Override
    public Gist run(Account account) throws Exception {
        service.starGist(id);
        return null;
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception starring gist", e);
    }
}

<code block>

package com.github.mobile.core.gist;

import android.net.Uri;
import android.text.TextUtils;

import java.util.List;
import java.util.regex.Pattern;

import org.eclipse.egit.github.core.Gist;


public class GistUriMatcher {

    private static final Pattern PATTERN = Pattern.compile("[a-f0-9]{20}");


    public static Gist getGist(final Uri uri) {
        List<String> segments = uri.getPathSegments();
        if (segments == null)
            return null;
        if (segments.size() != 1)
            return null;

        String gistId = segments.get(0);
        if (TextUtils.isEmpty(gistId))
            return null;

        if (TextUtils.isDigitsOnly(gistId))
            return new Gist().setId(gistId);

        if (PATTERN.matcher(gistId).matches())
            return new Gist().setId(gistId);

        return null;
    }
}

<code block>

package com.github.mobile.core.gist;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.Gist;


public class FullGist extends ArrayList<Comment> implements Serializable {

    private static final long serialVersionUID = -5966699489498437000L;

    private final Gist gist;

    private final boolean starred;


    public FullGist(final Gist gist, final boolean starred,
            final Collection<Comment> comments) {
        super(comments);

        this.starred = starred;
        this.gist = gist;
    }


    public FullGist() {
        this.gist = null;
        this.starred = false;
    }


    public boolean isStarred() {
        return starred;
    }


    public Gist getGist() {
        return gist;
    }
}

<code block>

package com.github.mobile.core.gist;

import android.accounts.Account;
import android.content.Context;
import android.util.Log;

import com.github.mobile.accounts.AuthenticatedUserTask;
import com.github.mobile.util.HtmlUtils;
import com.github.mobile.util.HttpImageGetter;
import com.google.inject.Inject;

import java.util.Collections;
import java.util.List;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.service.GistService;


public class RefreshGistTask extends AuthenticatedUserTask<FullGist> {

    private static final String TAG = "RefreshGistTask";

    @Inject
    private GistStore store;

    @Inject
    private GistService service;

    private final String id;

    private final HttpImageGetter imageGetter;


    public RefreshGistTask(Context context, String gistId,
            HttpImageGetter imageGetter) {
        super(context);

        id = gistId;
        this.imageGetter = imageGetter;
    }

    @Override
    public FullGist run(Account account) throws Exception {
        Gist gist = store.refreshGist(id);
        List<Comment> comments;
        if (gist.getComments() > 0)
            comments = service.getComments(id);
        else
            comments = Collections.emptyList();
        for (Comment comment : comments) {
            String formatted = HtmlUtils.format(comment.getBodyHtml())
                    .toString();
            comment.setBodyHtml(formatted);
            imageGetter.encode(comment, formatted);
        }
        return new FullGist(gist, service.isStarred(id), comments);
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception loading gist", e);
    }
}
<code block>

package com.github.mobile.core.gist;

import static org.eclipse.egit.github.core.event.Event.TYPE_GIST;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.event.Event;
import org.eclipse.egit.github.core.event.EventPayload;
import org.eclipse.egit.github.core.event.GistPayload;


public class GistEventMatcher {


    public Gist getGist(final Event event) {
        if (event == null)
            return null;
        EventPayload payload = event.getPayload();
        if (payload == null)
            return null;
        String type = event.getType();
        if (TYPE_GIST.equals(type))
            return ((GistPayload) payload).getGist();
        else
            return null;
    }
}

<code block>

package com.github.mobile.core.gist;

import android.accounts.Account;
import android.content.Context;
import android.util.Log;

import com.github.mobile.accounts.AuthenticatedUserTask;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.service.GistService;


public class UnstarGistTask extends AuthenticatedUserTask<Gist> {

    private static final String TAG = "UnstarGistTask";

    @Inject
    private GistService service;

    private final String id;


    public UnstarGistTask(final Context context, final String id) {
        super(context);

        this.id = id;
    }

    @Override
    public Gist run(Account account) throws Exception {
        service.unstarGist(id);
        return null;
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception unstarring gist", e);
    }
}

<code block>

package com.github.mobile.core.gist;

import com.github.mobile.core.ResourcePager;

import org.eclipse.egit.github.core.Gist;


public abstract class GistPager extends ResourcePager<Gist> {

    private final GistStore store;


    public GistPager(final GistStore store) {
        this.store = store;
    }

    @Override
    protected Object getId(Gist resource) {
        return resource.getId();
    }

    @Override
    protected Gist register(Gist resource) {
        return store.addGist(resource);
    }
}

<code block>

package com.github.mobile.core.repo;

import android.accounts.Account;
import android.content.Context;
import android.util.Log;

import com.github.mobile.R;
import com.github.mobile.ui.ProgressDialogTask;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.service.WatcherService;


public class UnstarRepositoryTask extends ProgressDialogTask<Void> {

    private static final String TAG = "UnstarRepositoryTask";

    @Inject
    private WatcherService service;

    private final IRepositoryIdProvider repo;


    public UnstarRepositoryTask(Context context, IRepositoryIdProvider repo) {
        super(context);

        this.repo = repo;
    }


    public void start() {
        showIndeterminate(R.string.unstarring_repository);

        execute();
    }

    @Override
    protected Void run(Account account) throws Exception {
        service.unwatch(repo);

        return null;
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception unstarring repository", e);
    }
}

<code block>

package com.github.mobile.core.repo;

import android.accounts.Account;
import android.content.Context;
import android.util.Log;

import com.github.mobile.ui.ProgressDialogTask;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.service.RepositoryService;


public class RefreshRepositoryTask extends ProgressDialogTask<Repository> {

    private static final String TAG = "RefreshRepositoryTask";

    @Inject
    private RepositoryService service;

    private final IRepositoryIdProvider repo;


    public RefreshRepositoryTask(Context context, IRepositoryIdProvider repo) {
        super(context);

        this.repo = repo;
    }

    @Override
    protected Repository run(Account account) throws Exception {
        return service.getRepository(repo);
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception loading repository", e);
    }
}
<code block>

package com.github.mobile.core.repo;

import android.text.TextUtils;

import org.eclipse.egit.github.core.Repository;


public class RepositoryUtils {


    public static boolean isComplete(final Repository repository) {
        return repository.isPrivate() || repository.isFork()
                || repository.getForks() > 0 || repository.getWatchers() > 0
                || repository.isHasIssues();
    }


    public static boolean isValidOwner(final String name) {
        if (TextUtils.isEmpty(name))
            return false;

        return !("about".equals(name) 
                || "account".equals(name) 
                || "admin".equals(name) 
                || "api".equals(name) 
                || "blog".equals(name) 
                || "camo".equals(name) 
                || "contact".equals(name) 
                || "dashboard".equals(name) 
                || "downloads".equals(name) 
                || "edu".equals(name) 
                || "explore".equals(name) 
                || "features".equals(name) 
                || "home".equals(name) 
                || "inbox".equals(name) 
                || "languages".equals(name) 
                || "login".equals(name) 
                || "logout".equals(name) 
                || "new".equals(name) 
                || "notifications".equals(name) 
                || "organizations".equals(name) 
                || "orgs".equals(name) 
                || "repositories".equals(name) 
                || "search".equals(name) 
                || "security".equals(name) 
                || "settings".equals(name) 
                || "stars".equals(name) 
                || "styleguide".equals(name) 
                || "timeline".equals(name) 
                || "training".equals(name) 
                || "users".equals(name) 
                || "watching".equals(name));
    }


    public static boolean isValidRepo(final String name) {
        if (TextUtils.isEmpty(name))
            return false;

        return !("followers".equals(name) || "following".equals(name));
    }
}

<code block>

package com.github.mobile.core.repo;

import android.net.Uri;

import java.util.List;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;


public class RepositoryUriMatcher {


    public static Repository getRepository(Uri uri) {
        List<String> segments = uri.getPathSegments();
        if (segments == null)
            return null;
        if (segments.size() < 2)
            return null;

        String repoOwner = segments.get(0);
        if (!RepositoryUtils.isValidOwner(repoOwner))
            return null;

        String repoName = segments.get(1);
        if (!RepositoryUtils.isValidRepo(repoName))
            return null;

        Repository repository = new Repository();
        repository.setName(repoName);
        repository.setOwner(new User().setLogin(repoOwner));
        return repository;
    }
}

<code block>
package com.github.mobile.core.repo;

import android.accounts.Account;
import android.accounts.AccountManager;
import android.content.Context;
import android.util.Log;

import com.github.mobile.R;
import com.github.mobile.accounts.AccountAuthenticator;
import com.github.mobile.api.GitHubClientV2;
import com.github.mobile.model.Authorization;
import com.github.mobile.ui.ProgressDialogTask;
import com.google.inject.Inject;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.service.OAuthService;
import org.eclipse.egit.github.core.service.RepositoryService;
import org.eclipse.egit.github.core.util.EncodingUtils;


public class DeleteRepositoryTask extends ProgressDialogTask<Void> {
    private static final String TAG = "DeleteRepositoryTask";

    @Inject
    private RepositoryService repositoryService;

    @Inject
    private OAuthService oAuthService;

    private final IRepositoryIdProvider repo;


    public DeleteRepositoryTask(Context context, IRepositoryIdProvider repo) {
        super(context);
        this.repo = repo;
    }


    public void start() {
        showIndeterminate(R.string.deleting_repository);

        execute();
    }

    @Override
    protected Void run(Account account) throws Exception {
        final String id = repo.generateId();
        String[] paths = id.split("/");
        final String owner = paths[0];
        final String repository = paths[1];
        String credentials = null;
        String authToken = null;
        String deleteToken = null;

        AccountManager am = AccountManager.get(context);
        String password = am.getPassword(account);

        System.out.println("password: " + password);
        System.out.println("owner: " + account.name);

        if (password == null) {
            AccountAuthenticator.getAuthorization(oAuthService);
        } else {
            credentials = "Basic " + EncodingUtils.toBase64(account.name + ':' + password);
        }

        List<Authorization> authorizations = GitHubClientV2.getServiceClient().
                getAuthorizations(credentials);

        for (Authorization auth : authorizations) {
            List<String> scopes = auth.getScopes();

            if (scopes.size() == 1 && scopes.get(0).equalsIgnoreCase("delete_repo")) {
                authToken = auth.getToken();
            }
        }

        if (authToken != null) {
            deleteToken = "token " + authToken;
        } else {
            Authorization authorization = new Authorization();
            authorization.setNote("Token for deleting repositories");
            authorization.setScopes(Collections.singletonList("delete_repo"));

            Authorization authorizationResponse = GitHubClientV2.getServiceClient().
                    createDeleteAuthorization(credentials, authorization);

            if (authorizationResponse != null) {
                deleteToken = "token " + authorizationResponse.getToken();
            }
        }

        GitHubClientV2.getServiceClient().deleteRepository(deleteToken, owner, repository);

        return null;
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception deleting repository", e);
    }
}

<code block>

package com.github.mobile.core.repo;

import android.accounts.Account;
import android.content.Context;
import android.util.Log;

import com.github.mobile.R;
import com.github.mobile.ui.ProgressDialogTask;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.service.WatcherService;


public class StarRepositoryTask extends ProgressDialogTask<Void> {

    private static final String TAG = "StarRepositoryTask";

    @Inject
    private WatcherService service;

    private final IRepositoryIdProvider repo;


    public StarRepositoryTask(Context context, IRepositoryIdProvider repo) {
        super(context);

        this.repo = repo;
    }


    public void start() {
        showIndeterminate(R.string.starring_repository);

        execute();
    }

    @Override
    protected Void run(Account account) throws Exception {
        service.watch(repo);

        return null;
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception starring repository", e);
    }
}

<code block>

package com.github.mobile.core.repo;

import static org.eclipse.egit.github.core.event.Event.TYPE_CREATE;
import static org.eclipse.egit.github.core.event.Event.TYPE_FORK;
import static org.eclipse.egit.github.core.event.Event.TYPE_PUBLIC;
import static org.eclipse.egit.github.core.event.Event.TYPE_WATCH;
import android.text.TextUtils;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.event.Event;
import org.eclipse.egit.github.core.event.EventPayload;
import org.eclipse.egit.github.core.event.EventRepository;
import org.eclipse.egit.github.core.event.ForkPayload;


public class RepositoryEventMatcher {


    public static Repository getRepository(final EventRepository repo,
            User actor, User org) {
        if (repo == null)
            return null;

        String id = repo.getName();
        int slash = id.indexOf('/');
        if (slash == -1 || slash + 1 >= id.length())
            return null;

        Repository full = new Repository();
        full.setId(repo.getId());
        full.setName(id.substring(slash + 1));
        String login = id.substring(0, slash);

        if (actor != null && login.equals(actor.getLogin()))
            full.setOwner(actor);
        else if (org != null && login.equals(org.getLogin()))
            full.setOwner(org);
        else
            full.setOwner(new User().setLogin(id.substring(0, slash)));
        return full;
    }


    public Repository getRepository(final Event event) {
        if (event == null)
            return null;

        EventPayload payload = event.getPayload();
        if (payload == null)
            return null;

        String type = event.getType();
        if (TYPE_FORK.equals(type)) {
            Repository repository = ((ForkPayload) payload).getForkee();

            if (repository != null && !TextUtils.isEmpty(repository.getName())
                    && repository.getOwner() != null
                    && !TextUtils.isEmpty(repository.getOwner().getLogin()))
                return repository;
        }

        if (TYPE_CREATE.equals(type) || TYPE_WATCH.equals(type)
                || TYPE_PUBLIC.equals(type))
            return getRepository(event.getRepo(), event.getActor(),
                    event.getOrg());

        return null;
    }
}

<code block>

package com.github.mobile.core.repo;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.service.WatcherService;

import android.accounts.Account;
import android.content.Context;
import android.util.Log;

import com.github.mobile.accounts.AuthenticatedUserTask;
import com.google.inject.Inject;


public class StarredRepositoryTask extends AuthenticatedUserTask<Boolean> {

    private static final String TAG = "StarringRepositoryTask";

    @Inject
    private WatcherService service;

    private final IRepositoryIdProvider repo;


    public StarredRepositoryTask(Context context, IRepositoryIdProvider repo) {
        super(context);

        this.repo = repo;
    }

    @Override
    protected Boolean run(Account account) throws Exception {
        return service.isWatching(repo);
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception checking starring repository status", e);
    }
}

<code block>
package com.github.mobile.core.repo;

import android.accounts.Account;
import android.content.Context;
import android.util.Log;

import com.github.mobile.R;
import com.github.mobile.ui.ProgressDialogTask;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.service.RepositoryService;


public class ForkRepositoryTask extends ProgressDialogTask<Repository> {

    private static final String TAG = "ForkRepositoryTask";

    @Inject
    private RepositoryService service;

    private final IRepositoryIdProvider repo;


    public ForkRepositoryTask(Context context, IRepositoryIdProvider repo) {
        super(context);

        this.repo = repo;
    }


    public void start() {
        showIndeterminate(R.string.forking_repository);

        execute();
    }

    @Override
    protected Repository run(Account account) throws Exception {
        return service.forkRepository(repo);
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception forking repository", e);
    }
}

<code block>

package com.github.mobile.core.code;

import android.accounts.Account;
import android.content.Context;

import com.github.mobile.accounts.AuthenticatedUserTask;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Blob;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.service.DataService;


public class RefreshBlobTask extends AuthenticatedUserTask<Blob> {

    private final Repository repository;

    private final String blobSha;

    @Inject
    private DataService service;


    public RefreshBlobTask(Repository repository, String blobSha,
            Context context) {
        super(context);

        this.repository = repository;
        this.blobSha = blobSha;
    }

    @Override
    protected Blob run(Account account) throws Exception {
        return service.getBlob(repository, blobSha);
    }
}

<code block>

package com.github.mobile.core.code;

import static java.lang.String.CASE_INSENSITIVE_ORDER;
import static org.eclipse.egit.github.core.TreeEntry.TYPE_BLOB;
import static org.eclipse.egit.github.core.TreeEntry.TYPE_TREE;
import android.text.TextUtils;

import com.github.mobile.core.commit.CommitUtils;
import com.github.mobile.core.ref.RefUtils;

import java.util.List;
import java.util.Map;
import java.util.TreeMap;

import org.eclipse.egit.github.core.Reference;
import org.eclipse.egit.github.core.Tree;
import org.eclipse.egit.github.core.TreeEntry;


public class FullTree {


    public static class Entry implements Comparable<Entry> {


        public final Folder parent;


        public final TreeEntry entry;


        public final String name;

        private Entry() {
            this.parent = null;
            this.entry = null;
            this.name = null;
        }

        private Entry(TreeEntry entry, Folder parent) {
            this.entry = entry;
            this.parent = parent;
            this.name = CommitUtils.getName(entry.getPath());
        }

        @Override
        public int compareTo(Entry another) {
            return CASE_INSENSITIVE_ORDER.compare(name, another.name);
        }
    }


    public static class Folder extends Entry {


        public final Map<String, Folder> folders = new TreeMap<>(
                CASE_INSENSITIVE_ORDER);


        public final Map<String, Entry> files = new TreeMap<>(
                CASE_INSENSITIVE_ORDER);

        private Folder() {
            super();
        }

        private Folder(TreeEntry entry, Folder parent) {
            super(entry, parent);
        }

        private void addFile(TreeEntry entry, String[] pathSegments, int index) {
            if (index == pathSegments.length - 1) {
                Entry file = new Entry(entry, this);
                files.put(file.name, file);
            } else {
                Folder folder = folders.get(pathSegments[index]);
                if (folder != null)
                    folder.addFile(entry, pathSegments, index + 1);
            }
        }

        private void addFolder(TreeEntry entry, String[] pathSegments, int index) {
            if (index == pathSegments.length - 1) {
                Folder folder = new Folder(entry, this);
                folders.put(folder.name, folder);
            } else {
                Folder folder = folders.get(pathSegments[index]);
                if (folder != null)
                    folder.addFolder(entry, pathSegments, index + 1);
            }
        }

        private void add(final TreeEntry entry) {
            String type = entry.getType();
            String path = entry.getPath();
            if (TextUtils.isEmpty(path))
                return;

            if (TYPE_BLOB.equals(type)) {
                String[] segments = path.split("/");
                if (segments.length > 1) {
                    Folder folder = folders.get(segments[0]);
                    if (folder != null)
                        folder.addFile(entry, segments, 1);
                } else if (segments.length == 1) {
                    Entry file = new Entry(entry, this);
                    files.put(file.name, file);
                }
            } else if (TYPE_TREE.equals(type)) {
                String[] segments = path.split("/");
                if (segments.length > 1) {
                    Folder folder = folders.get(segments[0]);
                    if (folder != null)
                        folder.addFolder(entry, segments, 1);
                } else if (segments.length == 1) {
                    Folder folder = new Folder(entry, this);
                    folders.put(folder.name, folder);
                }
            }
        }
    }


    public final Tree tree;


    public final Folder root;


    public final Reference reference;


    public final String branch;


    public FullTree(final Tree tree, final Reference reference) {
        this.tree = tree;
        this.reference = reference;
        this.branch = RefUtils.getName(reference);

        root = new Folder();
        List<TreeEntry> entries = tree.getTree();
        if (entries != null && !entries.isEmpty())
            for (TreeEntry entry : entries)
                root.add(entry);
    }
}

<code block>

package com.github.mobile.core.code;

import android.accounts.Account;
import android.content.Context;
import android.text.TextUtils;
import android.util.Log;

import com.github.mobile.accounts.AuthenticatedUserTask;
import com.github.mobile.core.ref.RefUtils;
import com.google.inject.Inject;

import java.io.IOException;

import org.eclipse.egit.github.core.Commit;
import org.eclipse.egit.github.core.Reference;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.Tree;
import org.eclipse.egit.github.core.service.DataService;
import org.eclipse.egit.github.core.service.RepositoryService;


public class RefreshTreeTask extends AuthenticatedUserTask<FullTree> {

    private static final String TAG = "RefreshTreeTask";

    private final Repository repository;

    private final Reference reference;

    @Inject
    private RepositoryService repoService;

    @Inject
    private DataService dataService;


    public RefreshTreeTask(final Repository repository,
            final Reference reference, final Context context) {
        super(context);

        this.repository = repository;
        this.reference = reference;
    }

    private boolean isValidRef(Reference ref) {
        return ref != null && ref.getObject() != null
                && !TextUtils.isEmpty(ref.getObject().getSha());
    }

    @Override
    protected FullTree run(Account account) throws Exception {
        Reference ref = reference;
        String branch = RefUtils.getPath(ref);
        if (branch == null) {
            branch = repository.getMasterBranch();
            if (TextUtils.isEmpty(branch)) {
                branch = repoService.getRepository(repository)
                        .getMasterBranch();
                if (TextUtils.isEmpty(branch))
                    throw new IOException(
                            "Repository does not have master branch");
            }
            branch = "heads/" + branch;
        }

        if (!isValidRef(ref)) {
            ref = dataService.getReference(repository, branch);
            if (!isValidRef(ref))
                throw new IOException(
                        "Reference does not have associated commit SHA-1");
        }

        Commit commit = dataService.getCommit(repository, ref.getObject()
                .getSha());
        if (commit == null || commit.getTree() == null
                || TextUtils.isEmpty(commit.getTree().getSha()))
            throw new IOException("Commit does not have associated tree SHA-1");

        Tree tree = dataService.getTree(repository, commit.getTree().getSha(),
                true);
        return new FullTree(tree, ref);
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception loading tree", e);
    }
}

<code block>

package com.github.mobile.util;

import static android.graphics.Bitmap.Config.ARGB_8888;
import static android.graphics.Color.WHITE;
import static android.graphics.PorterDuff.Mode.DST_IN;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.BitmapFactory.Options;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Point;
import android.graphics.PorterDuffXfermode;
import android.graphics.RectF;
import android.util.Log;
import android.widget.ImageView;

import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;


public class ImageUtils {

    private static final String TAG = "ImageUtils";


    public static Bitmap getBitmap(final String imagePath) {
        return getBitmap(imagePath, 1);
    }


    public static Bitmap getBitmap(final String imagePath, int sampleSize) {
        final Options options = new Options();
        options.inDither = false;
        options.inSampleSize = sampleSize;

        RandomAccessFile file = null;
        try {
            file = new RandomAccessFile(imagePath, "r");
            return BitmapFactory.decodeFileDescriptor(file.getFD(), null,
                    options);
        } catch (IOException e) {
            Log.d(TAG, e.getMessage(), e);
            return null;
        } finally {
            if (file != null)
                try {
                    file.close();
                } catch (IOException e) {
                    Log.d(TAG, e.getMessage(), e);
                }
        }
    }


    public static Bitmap getBitmap(final byte[] image, int sampleSize) {
        final Options options = new Options();
        options.inDither = false;
        options.inSampleSize = sampleSize;
        return BitmapFactory.decodeByteArray(image, 0, image.length, options);
    }


    public static int getScale(Point size, int width, int height) {
        if (size.x > width || size.y > height)
            return Math.max(Math.round((float) size.y / (float) height),
                    Math.round((float) size.x / (float) width));
        else
            return 1;
    }


    public static Point getSize(final String imagePath) {
        final Options options = new Options();
        options.inJustDecodeBounds = true;

        RandomAccessFile file = null;
        try {
            file = new RandomAccessFile(imagePath, "r");
            BitmapFactory.decodeFileDescriptor(file.getFD(), null, options);
            return new Point(options.outWidth, options.outHeight);
        } catch (IOException e) {
            Log.d(TAG, e.getMessage(), e);
            return null;
        } finally {
            if (file != null)
                try {
                    file.close();
                } catch (IOException e) {
                    Log.d(TAG, e.getMessage(), e);
                }
        }
    }


    public static Point getSize(final byte[] image) {
        final Options options = new Options();
        options.inJustDecodeBounds = true;
        BitmapFactory.decodeByteArray(image, 0, image.length, options);
        return new Point(options.outWidth, options.outHeight);
    }


    public static Bitmap getBitmap(final String imagePath, int width, int height) {
        Point size = getSize(imagePath);
        return getBitmap(imagePath, getScale(size, width, height));
    }


    public static Bitmap getBitmap(final byte[] image, int width, int height) {
        Point size = getSize(image);
        return getBitmap(image, getScale(size, width, height));
    }


    public static Bitmap getBitmap(final File image, int width, int height) {
        return getBitmap(image.getAbsolutePath(), width, height);
    }


    public static Bitmap getBitmap(final File image) {
        return getBitmap(image.getAbsolutePath());
    }


    public static void setImage(final String imagePath, final ImageView view) {
        setImage(new File(imagePath), view);
    }


    public static void setImage(final File image, final ImageView view) {
        Bitmap bitmap = getBitmap(image);
        if (bitmap != null)
            view.setImageBitmap(bitmap);
    }


    public static Bitmap roundCorners(final Bitmap source, final float radius) {
        int width = source.getWidth();
        int height = source.getHeight();

        Paint paint = new Paint();
        paint.setAntiAlias(true);
        paint.setColor(WHITE);

        Bitmap clipped = Bitmap.createBitmap(width, height, ARGB_8888);
        Canvas canvas = new Canvas(clipped);
        canvas.drawRoundRect(new RectF(0, 0, width, height), radius, radius,
                paint);
        paint.setXfermode(new PorterDuffXfermode(DST_IN));

        Bitmap rounded = Bitmap.createBitmap(width, height, ARGB_8888);
        canvas = new Canvas(rounded);
        canvas.drawBitmap(source, 0, 0, null);
        canvas.drawBitmap(clipped, 0, 0, paint);

        source.recycle();
        clipped.recycle();

        return rounded;
    }
}

<code block>

package com.github.mobile.util;

import static java.util.Locale.US;
import android.text.TextUtils;

import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;


public class GravatarUtils {


    private static final int HASH_LENGTH = 32;


    private static final String CHARSET = "CP1252";


    private static final MessageDigest MD5;

    static {
        MessageDigest digest;
        try {
            digest = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException e) {
            digest = null;
        }
        MD5 = digest;
    }

    private static String digest(final String value) {
        if (MD5 == null)
            return null;

        byte[] bytes;
        try {
            bytes = value.getBytes(CHARSET);
        } catch (UnsupportedEncodingException e) {
            return null;
        }

        synchronized (MD5) {
            MD5.reset();
            bytes = MD5.digest(bytes);
        }

        String hashed = new BigInteger(1, bytes).toString(16);
        int padding = HASH_LENGTH - hashed.length();
        if (padding == 0)
            return hashed;

        char[] zeros = new char[padding];
        Arrays.fill(zeros, '0');
        return String.valueOf(zeros) + hashed;
    }


    public static String getHash(String email) {
        if (TextUtils.isEmpty(email))
            return null;
        email = email.trim().toLowerCase(US);
        return email.length() > 0 ? digest(email) : null;
    }
}
<code block>

package com.github.mobile.util;

import static android.util.Base64.DEFAULT;
import static android.view.View.GONE;
import static android.view.View.VISIBLE;
import static java.lang.Integer.MAX_VALUE;
import static org.eclipse.egit.github.core.client.IGitHubConstants.HOST_DEFAULT;
import android.accounts.Account;
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.text.Html.ImageGetter;
import android.text.TextUtils;
import android.util.Base64;
import android.widget.TextView;

import com.github.kevinsawicki.http.HttpRequest;
import com.github.kevinsawicki.http.HttpRequest.HttpRequestException;
import com.github.mobile.R;
import com.github.mobile.accounts.AuthenticatedUserTask;
import com.google.inject.Inject;

import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.egit.github.core.RepositoryContents;
import org.eclipse.egit.github.core.RepositoryId;
import org.eclipse.egit.github.core.service.ContentsService;


public class HttpImageGetter implements ImageGetter {

    private static class LoadingImageGetter implements ImageGetter {

        private final Drawable image;

        private LoadingImageGetter(final Context context, final int size) {
            int imageSize = ServiceUtils.getIntPixels(context, size);
            image = context.getResources().getDrawable(
                    R.drawable.image_loading_icon);
            image.setBounds(0, 0, imageSize, imageSize);
        }

        @Override
        public Drawable getDrawable(String source) {
            return image;
        }
    }

    private static boolean containsImages(final String html) {
        return html.contains("<img");
    }

    private final LoadingImageGetter loading;

    private final Context context;

    private final File dir;

    private final int width;

    private final Map<Object, CharSequence> rawHtmlCache = new HashMap<>();

    private final Map<Object, CharSequence> fullHtmlCache = new HashMap<>();

    private final ContentsService service;


    @Inject
    public HttpImageGetter(Context context, ContentsService service) {
        this.context = context;
        this.service = service;
        dir = context.getCacheDir();
        width = ServiceUtils.getDisplayWidth(context);
        loading = new LoadingImageGetter(context, 24);
    }

    private HttpImageGetter show(final TextView view, final CharSequence html) {
        if (TextUtils.isEmpty(html))
            return hide(view);

        view.setText(html);
        view.setVisibility(VISIBLE);
        view.setTag(null);
        return this;
    }

    private HttpImageGetter hide(final TextView view) {
        view.setText(null);
        view.setVisibility(GONE);
        view.setTag(null);
        return this;
    }


    public HttpImageGetter encode(final Object id, final String html) {
        if (TextUtils.isEmpty(html))
            return this;

        CharSequence encoded = HtmlUtils.encode(html, loading);

        if (containsImages(html)) {
            CharSequence currentEncoded = rawHtmlCache.put(id, encoded);

            if (currentEncoded == null
                    || !currentEncoded.toString().equals(encoded.toString()))
                fullHtmlCache.remove(id);
        } else {
            rawHtmlCache.remove(id);
            fullHtmlCache.put(id, encoded);
        }
        return this;
    }


    public HttpImageGetter bind(final TextView view, final String html,
            final Object id) {
        if (TextUtils.isEmpty(html))
            return hide(view);

        CharSequence encoded = fullHtmlCache.get(id);
        if (encoded != null)
            return show(view, encoded);

        encoded = rawHtmlCache.get(id);
        if (encoded == null) {
            encoded = HtmlUtils.encode(html, loading);
            if (containsImages(html))
                rawHtmlCache.put(id, encoded);
            else {
                rawHtmlCache.remove(id);
                fullHtmlCache.put(id, encoded);
                return show(view, encoded);
            }
        }

        if (TextUtils.isEmpty(encoded))
            return hide(view);

        show(view, encoded);
        view.setTag(id);
        new AuthenticatedUserTask<CharSequence>(context) {

            @Override
            protected CharSequence run(Account account) throws Exception {
                return HtmlUtils.encode(html, HttpImageGetter.this);
            }

            @Override
            protected void onSuccess(final CharSequence html) throws Exception {
                fullHtmlCache.put(id, html);

                if (id.equals(view.getTag()))
                    show(view, html);
            }
        }.execute();
        return this;
    }


    private Drawable requestRepositoryImage(final String source)
            throws IOException {
        if (TextUtils.isEmpty(source))
            return null;

        Uri uri = Uri.parse(source);
        if (!HOST_DEFAULT.equals(uri.getHost()))
            return null;

        List<String> segments = uri.getPathSegments();
        if (segments.size() < 5)
            return null;

        String prefix = segments.get(2);



        if (!("raw".equals(prefix) || ("blob".equals(prefix) && !TextUtils
                .isEmpty(uri.getQueryParameter("raw")))))
            return null;

        String owner = segments.get(0);
        if (TextUtils.isEmpty(owner))
            return null;
        String name = segments.get(1);
        if (TextUtils.isEmpty(name))
            return null;
        String branch = segments.get(3);
        if (TextUtils.isEmpty(branch))
            return null;

        StringBuilder path = new StringBuilder(segments.get(4));
        for (int i = 5; i < segments.size(); i++) {
            String segment = segments.get(i);
            if (!TextUtils.isEmpty(segment))
                path.append('/').append(segment);
        }

        if (TextUtils.isEmpty(path))
            return null;

        List<RepositoryContents> contents = service.getContents(
                RepositoryId.create(owner, name), path.toString(), branch);
        if (contents != null && contents.size() == 1) {
            byte[] content = Base64.decode(contents.get(0).getContent(),
                    DEFAULT);
            Bitmap bitmap = ImageUtils.getBitmap(content, width, MAX_VALUE);
            if (bitmap == null)
                return loading.getDrawable(source);
            BitmapDrawable drawable = new BitmapDrawable(
                    context.getResources(), bitmap);
            drawable.setBounds(0, 0, bitmap.getWidth(), bitmap.getHeight());
            return drawable;
        } else
            return null;
    }

    @Override
    public Drawable getDrawable(final String source) {
        try {
            Drawable repositoryImage = requestRepositoryImage(source);
            if (repositoryImage != null)
                return repositoryImage;
        } catch (Exception e) {

        }

        File output = null;
        try {
            output = File.createTempFile("image", ".jpg", dir);
            HttpRequest request = HttpRequest.get(source);
            if (!request.ok())
                throw new IOException("Unexpected response code: "
                        + request.code());
            request.receive(output);
            Bitmap bitmap = ImageUtils.getBitmap(output, width, MAX_VALUE);
            if (bitmap == null)
                return loading.getDrawable(source);

            BitmapDrawable drawable = new BitmapDrawable(
                    context.getResources(), bitmap);
            drawable.setBounds(0, 0, bitmap.getWidth(), bitmap.getHeight());
            return drawable;
        } catch (IOException e) {
            return loading.getDrawable(source);
        } catch (HttpRequestException e) {
            return loading.getDrawable(source);
        } finally {
            if (output != null)
                output.delete();
        }
    }


    public void removeFromCache(final Object id) {
        rawHtmlCache.remove(id);
        fullHtmlCache.remove(id);
    }
}

<code block>

package com.github.mobile.util;

import static android.content.Context.WINDOW_SERVICE;
import static android.util.TypedValue.COMPLEX_UNIT_DIP;
import android.content.Context;
import android.content.res.Resources;
import android.util.TypedValue;
import android.view.Display;
import android.view.View;
import android.view.WindowManager;


public class ServiceUtils {


    public static Display getDisplay(final Context context) {
        return ((WindowManager) context.getSystemService(WINDOW_SERVICE))
                .getDefaultDisplay();
    }


    public static Display getDisplay(final View view) {
        return getDisplay(view.getContext());
    }


    public static int getDisplayWidth(final Context context) {
        return getDisplay(context).getWidth();
    }


    public static int getDisplayWidth(final View view) {
        return getDisplayWidth(view.getContext());
    }


    public static float getPixels(final View view, final int dp) {
        return getPixels(view.getResources(), dp);
    }


    public static float getPixels(final Resources resources, final int dp) {
        return TypedValue.applyDimension(COMPLEX_UNIT_DIP, dp,
                resources.getDisplayMetrics());
    }


    public static int getIntPixels(final View view, final int dp) {
        return getIntPixels(view.getResources(), dp);
    }


    public static int getIntPixels(final Context context, final int dp) {
        return getIntPixels(context.getResources(), dp);
    }


    public static int getIntPixels(final Resources resources, final int dp) {
        float pixels = TypedValue.applyDimension(COMPLEX_UNIT_DIP, dp,
                resources.getDisplayMetrics());
        return (int) Math.floor(pixels + 0.5F);
    }
}

<code block>

package com.github.mobile.util;

import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Paint.Style;
import android.text.Editable;
import android.text.Html.ImageGetter;
import android.text.Html.TagHandler;
import android.text.Layout;
import android.text.Spanned;
import android.text.TextUtils;
import android.text.style.LeadingMarginSpan;
import android.text.style.QuoteSpan;
import android.text.style.StrikethroughSpan;
import android.text.style.TypefaceSpan;

import org.xml.sax.XMLReader;

import java.util.LinkedList;

import static android.graphics.Paint.Style.FILL;
import static android.text.Spanned.SPAN_EXCLUSIVE_EXCLUSIVE;
import static android.text.Spanned.SPAN_MARK_MARK;


public class HtmlUtils {

    private static class ReplySpan implements LeadingMarginSpan {

        private final int color = 0xffDDDDDD;

        @Override
        public int getLeadingMargin(boolean first) {
            return 18;
        }

        @Override
        public void drawLeadingMargin(Canvas c, Paint p, int x, int dir,
                                      int top, int baseline, int bottom, CharSequence text,
                                      int start, int end, boolean first, Layout layout) {
            final Style style = p.getStyle();
            final int color = p.getColor();

            p.setStyle(FILL);
            p.setColor(this.color);

            c.drawRect(x, top, x + dir * 6, bottom, p);

            p.setStyle(style);
            p.setColor(color);
        }
    }

    private static final String TAG_ROOT = "githubroot";

    private static final String ROOT_START = '<' + TAG_ROOT + '>';

    private static final String ROOT_END = "</" + TAG_ROOT + '>';

    private static final String TOGGLE_START = "<span class=\"email-hidden-toggle\">";

    private static final String TOGGLE_END = "</span>";

    private static final String REPLY_START = "<div class=\"email-quoted-reply\">";

    private static final String REPLY_END = "</div>";

    private static final String SIGNATURE_START = "<div class=\"email-signature-reply\">";

    private static final String SIGNATURE_END = "</div>";

    private static final String EMAIL_START = "<div class=\"email-fragment\">";

    private static final String EMAIL_END = "</div>";

    private static final String HIDDEN_REPLY_START = "<div class=\"email-hidden-reply\" style=\" display:none\">";

    private static final String HIDDEN_REPLY_END = "</div>";

    private static final String BREAK = "<br>";

    private static final String PARAGRAPH_START = "<p>";

    private static final String PARAGRAPH_END = "</p>";

    private static final String BLOCKQUOTE_START = "<blockquote>";

    private static final String BLOCKQUOTE_END = "</blockquote>";

    private static final String SPACE = "&nbsp;";

    private static final String PRE_START = "<pre>";

    private static final String PRE_END = "</pre>";

    private static final String CODE_START = "<code>";

    private static final String CODE_END = "</code>";

    private static class ListSeparator {

        private int count;

        public ListSeparator(boolean ordered) {
            count = ordered ? 1 : -1;
        }

        public ListSeparator append(Editable output, int indentLevel) {
            output.append('\n');
            for (int i = 0; i < indentLevel * 2; i++)
                output.append(' ');
            if (count != -1) {
                output.append(Integer.toString(count)).append('.');
                count++;
            } else
                output.append('\u2022');
            output.append(' ').append(' ');
            return this;
        }
    }

    private static final TagHandler TAG_HANDLER = new TagHandler() {

        private static final String TAG_DEL = "del";

        private static final String TAG_UL = "ul";

        private static final String TAG_OL = "ol";

        private static final String TAG_LI = "li";

        private static final String TAG_CODE = "code";

        private static final String TAG_PRE = "pre";

        private int indentLevel;

        private final LinkedList<ListSeparator> listElements = new LinkedList<>();

        @Override
        public void handleTag(final boolean opening, final String tag,
                              final Editable output, final XMLReader xmlReader) {
            if (TAG_DEL.equalsIgnoreCase(tag)) {
                if (opening)
                    startSpan(new StrikethroughSpan(), output);
                else
                    endSpan(StrikethroughSpan.class, output);
                return;
            }

            if (TAG_UL.equalsIgnoreCase(tag)) {
                if (opening) {
                    listElements.addFirst(new ListSeparator(false));
                    indentLevel++;
                } else {
                    listElements.removeFirst();
                    indentLevel--;
                }

                if (!opening && indentLevel == 0)
                    output.append('\n');
                return;
            }

            if (TAG_OL.equalsIgnoreCase(tag)) {
                if (opening) {
                    listElements.addFirst(new ListSeparator(true));
                    indentLevel++;
                } else {
                    listElements.removeFirst();
                    indentLevel--;
                }
                if (!opening && indentLevel == 0)
                    output.append('\n');
                return;
            }

            if (TAG_LI.equalsIgnoreCase(tag) && opening) {
                listElements.getFirst().append(output, indentLevel);
                return;
            }

            if (TAG_CODE.equalsIgnoreCase(tag)) {
                if (opening)
                    startSpan(new TypefaceSpan("monospace"), output);
                else
                    endSpan(TypefaceSpan.class, output);
                return;
            }

            if (TAG_PRE.equalsIgnoreCase(tag)) {
                output.append('\n');
                if (opening)
                    startSpan(new TypefaceSpan("monospace"), output);
                else
                    endSpan(TypefaceSpan.class, output);
                return;
            }

            if (TAG_ROOT.equalsIgnoreCase(tag) && !opening) {

                while (output.length() > 0 && output.charAt(0) == '\n')
                    output.delete(0, 1);


                int last = output.length() - 1;
                while (last >= 0 && output.charAt(last) == '\n') {
                    output.delete(last, last + 1);
                    last = output.length() - 1;
                }

                QuoteSpan[] quoteSpans = output.getSpans(0, output.length(),
                        QuoteSpan.class);
                for (QuoteSpan span : quoteSpans) {
                    int start = output.getSpanStart(span);
                    int end = output.getSpanEnd(span);
                    output.removeSpan(span);
                    output.setSpan(new ReplySpan(), start, end,
                            SPAN_EXCLUSIVE_EXCLUSIVE);
                }
            }
        }
    };

    private static Object getLast(final Spanned text, final Class<?> kind) {
        Object[] spans = text.getSpans(0, text.length(), kind);
        return spans.length > 0 ? spans[spans.length - 1] : null;
    }

    private static void startSpan(Object span, Editable output) {
        int length = output.length();
        output.setSpan(span, length, length, SPAN_MARK_MARK);
    }

    private static void endSpan(Class<?> type, Editable output) {
        int length = output.length();
        Object span = getLast(output, type);
        int start = output.getSpanStart(span);
        output.removeSpan(span);
        if (start != length)
            output.setSpan(span, start, length, SPAN_EXCLUSIVE_EXCLUSIVE);
    }


    public static CharSequence encode(final String html) {
        return encode(html, null);
    }


    public static CharSequence encode(final String html,
                                      final ImageGetter imageGetter) {
        if (TextUtils.isEmpty(html))
            return "";

        return android.text.Html.fromHtml(html, imageGetter, TAG_HANDLER);
    }


    public static final CharSequence format(final String html) {
        if (html == null)
            return "";
        if (html.length() == 0)
            return "";

        StringBuilder formatted = new StringBuilder(html);


        strip(formatted, TOGGLE_START, TOGGLE_END);


        strip(formatted, SIGNATURE_START, SIGNATURE_END);


        replace(formatted, REPLY_START, REPLY_END, BLOCKQUOTE_START,
                BLOCKQUOTE_END);


        strip(formatted, HIDDEN_REPLY_START, HIDDEN_REPLY_END);


        if (replace(formatted, PARAGRAPH_START, BREAK))
            replace(formatted, PARAGRAPH_END, BREAK);

        formatPres(formatted);

        formatEmailFragments(formatted);

        trim(formatted);

        formatted.insert(0, ROOT_START);
        formatted.append(ROOT_END);

        return formatted;
    }

    private static StringBuilder strip(final StringBuilder input,
                                       final String prefix, final String suffix) {
        int start = input.indexOf(prefix);
        while (start != -1) {
            int end = input.indexOf(suffix, start + prefix.length());
            if (end == -1)
                end = input.length();
            input.delete(start, end + suffix.length());
            start = input.indexOf(prefix, start);
        }
        return input;
    }

    private static boolean replace(final StringBuilder input,
                                   final String from, final String to) {
        int start = input.indexOf(from);
        if (start == -1)
            return false;

        final int fromLength = from.length();
        final int toLength = to.length();
        while (start != -1) {
            input.replace(start, start + fromLength, to);
            start = input.indexOf(from, start + toLength);
        }
        return true;
    }

    private static void replaceTag(final StringBuilder input,
                                   final String from, final String to) {
        if (replace(input, '<' + from + '>', '<' + to + '>'))
            replace(input, "</" + from + '>', "</" + to + '>');
    }

    private static StringBuilder replace(final StringBuilder input,
                                         final String fromStart, final String fromEnd, final String toStart,
                                         final String toEnd) {
        int start = input.indexOf(fromStart);
        if (start == -1)
            return input;

        final int fromStartLength = fromStart.length();
        final int fromEndLength = fromEnd.length();
        final int toStartLength = toStart.length();
        while (start != -1) {
            input.replace(start, start + fromStartLength, toStart);
            int end = input.indexOf(fromEnd, start + toStartLength);
            if (end != -1)
                input.replace(end, end + fromEndLength, toEnd);

            start = input.indexOf(fromStart);
        }
        return input;
    }

    private static StringBuilder formatPres(final StringBuilder input) {
        int start = input.indexOf(PRE_START);
        final int spaceAdvance = SPACE.length() - 1;
        final int breakAdvance = BREAK.length() - 1;
        while (start != -1) {
            int end = input.indexOf(PRE_END, start + PRE_START.length());
            if (end == -1)
                break;


            if (input.indexOf(CODE_START, start) == start)
                start += CODE_START.length();
            if (input.indexOf(CODE_END, start) == end - CODE_END.length())
                end -= CODE_END.length();

            for (int i = start; i < end; i++) {
                switch (input.charAt(i)) {
                    case ' ':
                        input.deleteCharAt(i);
                        input.insert(i, SPACE);
                        start += spaceAdvance;
                        end += spaceAdvance;
                        break;
                    case '\t':
                        input.deleteCharAt(i);
                        input.insert(i, SPACE);
                        start += spaceAdvance;
                        end += spaceAdvance;
                        for (int j = 0; j < 3; j++) {
                            input.insert(i, SPACE);
                            start += spaceAdvance + 1;
                            end += spaceAdvance + 1;
                        }
                        break;
                    case '\n':
                        input.deleteCharAt(i);

                        if (i + 1 < end) {
                            input.insert(i, BREAK);
                            start += breakAdvance;
                            end += breakAdvance;
                        }
                        break;
                }
            }
            start = input.indexOf(PRE_START, end + PRE_END.length());
        }
        return input;
    }


    private static StringBuilder formatEmailFragments(final StringBuilder input) {
        int emailStart = input.indexOf(EMAIL_START);
        int breakAdvance = BREAK.length() - 1;
        while (emailStart != -1) {
            int startLength = EMAIL_START.length();
            int emailEnd = input.indexOf(EMAIL_END, emailStart + startLength);
            if (emailEnd == -1)
                break;

            input.delete(emailEnd, emailEnd + EMAIL_END.length());
            input.delete(emailStart, emailStart + startLength);

            int fullEmail = emailEnd - startLength;
            for (int i = emailStart; i < fullEmail; i++)
                if (input.charAt(i) == '\n') {
                    input.deleteCharAt(i);
                    input.insert(i, BREAK);
                    i += breakAdvance;
                    fullEmail += breakAdvance;
                }

            emailStart = input.indexOf(EMAIL_START, fullEmail);
        }
        return input;
    }


    private static StringBuilder trim(final StringBuilder input) {
        int length = input.length();
        int breakLength = BREAK.length();

        while (length > 0) {
            if (input.indexOf(BREAK) == 0)
                input.delete(0, breakLength);
            else if (length >= breakLength
                    && input.lastIndexOf(BREAK) == length - breakLength)
                input.delete(length - breakLength, length);
            else if (Character.isWhitespace(input.charAt(0)))
                input.deleteCharAt(0);
            else if (Character.isWhitespace(input.charAt(length - 1)))
                input.deleteCharAt(length - 1);
            else
                break;
            length = input.length();
        }
        return input;
    }
}

<code block>

package com.github.mobile.util;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;

import static android.content.Context.MODE_PRIVATE;


public class PreferenceUtils {


    public static final String WRAP = "wrap";


    public static final String RENDER_MARKDOWN = "renderMarkdown";


    public static SharedPreferences getCodePreferences(final Context context) {
        return context.getSharedPreferences("code", MODE_PRIVATE);
    }


    public static void save(final Editor editor) {
        editor.apply();
    }
}

<code block>

package com.github.mobile.util;

import static android.content.Intent.ACTION_SEND;
import static android.content.Intent.EXTRA_SUBJECT;
import static android.content.Intent.EXTRA_TEXT;
import android.content.Intent;
import android.text.TextUtils;


public class ShareUtils {


    public static Intent create(final CharSequence subject,
            final CharSequence body) {
        Intent intent = new Intent(ACTION_SEND);
        intent.setType("text/plain");
        if (!TextUtils.isEmpty(subject))
            intent.putExtra(EXTRA_SUBJECT, subject);
        intent.putExtra(EXTRA_TEXT, body);
        return intent;
    }


    public static String getBody(final Intent intent) {
        return intent != null ? intent.getStringExtra(EXTRA_TEXT) : null;
    }


    public static String getSubject(final Intent intent) {
        return intent != null ? intent.getStringExtra(EXTRA_SUBJECT) : null;
    }
}

<code block>

package com.github.mobile.util;

import static org.eclipse.egit.github.core.Blob.ENCODING_BASE64;
import static org.eclipse.egit.github.core.client.IGitHubConstants.CHARSET_UTF8;
import android.os.Build;
import android.net.Uri;
import android.text.TextUtils;
import android.webkit.JavascriptInterface;
import android.webkit.WebSettings;
import android.webkit.WebView;
import android.webkit.WebViewClient;

import com.github.mobile.ui.user.UriLauncherActivity;

import java.io.UnsupportedEncodingException;

import org.eclipse.egit.github.core.Blob;
import org.eclipse.egit.github.core.util.EncodingUtils;


public class SourceEditor {

    private static final String URL_PAGE = "file:///android_asset/source-editor.html";

    private final WebView view;

    private boolean wrap;

    private String name;

    private String content;

    private boolean encoded;

    private boolean markdown;


    public SourceEditor(final WebView view) {
        WebViewClient client = new WebViewClient() {

            @Override
            public boolean shouldOverrideUrlLoading(WebView view, String url) {
                if (URL_PAGE.equals(url)) {
                    view.loadUrl(url);
                    return false;
                } else {
                    UriLauncherActivity.launchUri(view.getContext(), Uri.parse(url));
                    return true;
                }
            }
        };
        view.setWebViewClient(client);

        WebSettings settings = view.getSettings();
        settings.setJavaScriptEnabled(true);
        view.addJavascriptInterface(this, "SourceEditor");
        if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.JELLY_BEAN) {
            settings.setBuiltInZoomControls(true);
            settings.setUseWideViewPort(true);
        }

        this.view = view;
    }


    @JavascriptInterface
    public String getName() {
        return name;
    }


    @JavascriptInterface
    public String getRawContent() {
        return content;
    }


    @JavascriptInterface
    public String getContent() {
        if (encoded)
            try {
                return new String(EncodingUtils.fromBase64(content), CHARSET_UTF8);
            } catch (UnsupportedEncodingException e) {
                return getRawContent();
            }
        else
            return getRawContent();
    }


    @JavascriptInterface
    public boolean getWrap() {
        return wrap;
    }


    public boolean isMarkdown() {
        return markdown;
    }


    public SourceEditor setWrap(final boolean wrap) {
        this.wrap = wrap;
        loadSource();
        return this;
    }


    public SourceEditor setMarkdown(final boolean markdown) {
        this.markdown = markdown;
        return this;
    }


    public SourceEditor setSource(final String name, final String content, final boolean encoded) {
        this.name = name;
        this.content = content;
        this.encoded = encoded;
        loadSource();

        return this;
    }

    private void loadSource() {
        if (name != null && content != null)
            if (markdown)
                view.loadDataWithBaseURL(null, content, "text/html", CHARSET_UTF8, null);
            else
                view.loadUrl(URL_PAGE);
    }


    public SourceEditor setSource(final String name, final Blob blob) {
        String content = blob.getContent();
        if (content == null)
            content = "";
        boolean encoded = !TextUtils.isEmpty(content) && ENCODING_BASE64.equals(blob.getEncoding());
        return setSource(name, content, encoded);
    }


    public SourceEditor toggleWrap() {
        return setWrap(!wrap);
    }


    public SourceEditor toggleMarkdown() {
        return setMarkdown(!markdown);
    }
}

<code block>

package com.github.mobile.util;

import static android.text.format.DateUtils.FORMAT_NUMERIC_DATE;
import static android.text.format.DateUtils.FORMAT_SHOW_DATE;
import static android.text.format.DateUtils.FORMAT_SHOW_YEAR;
import static android.text.format.DateUtils.MINUTE_IN_MILLIS;
import android.text.format.DateUtils;

import java.util.Date;


public class TimeUtils {


    public static CharSequence getRelativeTime(final Date date) {
        long now = System.currentTimeMillis();
        if (Math.abs(now - date.getTime()) > 60000)
            return DateUtils.getRelativeTimeSpanString(date.getTime(), now,
                    MINUTE_IN_MILLIS, FORMAT_SHOW_DATE | FORMAT_SHOW_YEAR
                            | FORMAT_NUMERIC_DATE);
        else
            return "just now";
    }
}

<code block>

package com.github.mobile.util;

import android.content.Context;
import android.graphics.Paint;
import android.graphics.Typeface;
import android.widget.TextView;

import java.util.Arrays;


public class TypefaceUtils {


    public static final String ICON_PRIVATE = "\uf26a";


    public static final String ICON_PUBLIC = "\uf201";


    public static final String ICON_FORK = "\uf202";


    public static final String ICON_CREATE = "\uf203";


    public static final String ICON_DELETE = "\uf204";


    public static final String ICON_PUSH = "\uf205";


    public static final String ICON_WIKI = "\uf207";


    public static final String ICON_UPLOAD = "\uf20C";


    public static final String ICON_GIST = "\uf20E";


    public static final String ICON_ADD_MEMBER = "\uf21A";


    public static final String ICON_MIRROR_PUBLIC = "\uf224";


    public static final String ICON_MIRROR_PRIVATE = "\uf225";


    public static final String ICON_FOLLOW = "\uf21C";


    public static final String ICON_STAR = "\uf02A";


    public static final String ICON_PULL_REQUEST = "\uf222";


    public static final String ICON_ISSUE_OPEN = "\uf226";


    public static final String ICON_ISSUE_REOPEN = "\uf227";


    public static final String ICON_ISSUE_CLOSE = "\uf228";


    public static final String ICON_ISSUE_COMMENT = "\uf229";


    public static final String ICON_COMMENT = "\uf22b";


    public static final String ICON_NEWS = "\uf234";


    public static final String ICON_WATCH = "\uf04e";


    public static final String ICON_TEAM = "\uf019";


    public static final String ICON_CODE = "\uf010";


    public static final String ICON_TAG = "\uf015";


    public static final String ICON_COMMIT = "\uf01f";


    public static final String ICON_MERGE = "\uf023";


    public static final String ICON_KEY = "\uf049";


    public static final String ICON_LOCK = "\uf06a";


    public static final String ICON_MILESTONE = "\uf075";


    public static final String ICON_BOOKMARK = "\uf07b";


    public static final String ICON_PERSON = "\uf218";


    public static final String ICON_ADD = "\uf05d";


    public static final String ICON_BROADCAST = "\uf030";


    public static final String ICON_EDIT = "\uf058";

    private static Typeface OCTICONS;


    public static int getMaxDigits(int... numbers) {
        int max = 1;
        for (int number : numbers)
            max = Math.max(max, (int) Math.log10(number) + 1);
        return max;
    }


    public static int getWidth(TextView view, int numberOfDigits) {
        Paint paint = new Paint();
        paint.setTypeface(view.getTypeface());
        paint.setTextSize(view.getTextSize());
        char[] text = new char[numberOfDigits];
        Arrays.fill(text, '0');
        return Math.round(paint.measureText(text, 0, text.length));
    }


    public static Typeface getOcticons(final Context context) {
        if (OCTICONS == null)
            OCTICONS = getTypeface(context, "octicons-regular-webfont.ttf");
        return OCTICONS;
    }


    public static void setOcticons(final TextView... textViews) {
        if (textViews == null || textViews.length == 0)
            return;

        Typeface typeface = getOcticons(textViews[0].getContext());
        for (TextView textView : textViews)
            textView.setTypeface(typeface);
    }


    public static Typeface getTypeface(final Context context, final String name) {
        return Typeface.createFromAsset(context.getAssets(), name);
    }
}

<code block>

package com.github.mobile.util;

import android.content.Context;
import android.content.res.TypedArray;
import android.graphics.Bitmap;
import android.graphics.drawable.BitmapDrawable;
import android.support.v7.app.ActionBar;
import android.text.TextUtils;
import android.util.Log;
import android.widget.ImageView;

import com.github.mobile.R;
import com.google.inject.Inject;
import com.squareup.okhttp.Cache;
import com.squareup.okhttp.OkHttpClient;
import com.squareup.picasso.OkHttpDownloader;
import com.squareup.picasso.Picasso;
import com.squareup.picasso.Transformation;

import java.io.File;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicReference;

import org.eclipse.egit.github.core.CommitUser;
import org.eclipse.egit.github.core.Contributor;
import org.eclipse.egit.github.core.User;

import roboguice.util.RoboAsyncTask;


public class AvatarLoader {
    static final int DISK_CACHE_SIZE = 50 * 1024 * 1024; 

    private static final String TAG = "AvatarLoader";

    private static final float CORNER_RADIUS_IN_DIP = 3;

    private final Context context;
    private final Picasso p;

    private final float cornerRadius;

    private final RoundedCornersTransformation transformation = new RoundedCornersTransformation();


    private static int avatarSize = 0;


    @Inject
    public AvatarLoader(final Context context) {
        this.context = context;

        OkHttpClient client = new OkHttpClient();


        File cacheDir = new File(context.getCacheDir(), "http");
        Cache cache = new Cache(cacheDir, DISK_CACHE_SIZE);
        client.setCache(cache);

        p = new Picasso.Builder(context).downloader(new OkHttpDownloader(client)).build();

        float density = context.getResources().getDisplayMetrics().density;
        cornerRadius = CORNER_RADIUS_IN_DIP * density;

        if (avatarSize == 0) {
            avatarSize = getMaxAvatarSize(context);
        }



        final File avatarDir = new File(context.getCacheDir(), "avatars/github.com");
        if (avatarDir.isDirectory())
            deleteCache(avatarDir);
    }


    public void bind(final ActionBar actionBar, final User user) {
        bind(actionBar, new AtomicReference<>(user));
    }


    public void bind(final ActionBar actionBar, final AtomicReference<User> userReference) {
        if (userReference == null)
            return;

        final User user = userReference.get();
        if (user == null)
            return;

        String avatarUrl = user.getAvatarUrl();
        if (TextUtils.isEmpty(avatarUrl))
            return;


        if (avatarUrl.contains("?") && !avatarUrl.contains("gravatar")) {
            avatarUrl = avatarUrl.substring(0, avatarUrl.indexOf("?"));
        }

        final String url = avatarUrl;

        new FetchAvatarTask(context) {

            @Override
            public BitmapDrawable call() throws Exception {
                Bitmap image = Bitmap.createScaledBitmap(p.load(url).get(), avatarSize, avatarSize, false);
                return new BitmapDrawable(context.getResources(), ImageUtils.roundCorners(image, cornerRadius));
            }

            @Override
            protected void onSuccess(BitmapDrawable image) throws Exception {
                actionBar.setLogo(image);
            }
        }.execute();
    }


    public void bind(final ImageView view, final User user) {
        bind(view, getAvatarUrl(user));
    }


    public void bind(final ImageView view, final CommitUser user) {
        bind(view, getAvatarUrl(user));
    }


    public void bind(final ImageView view, final Contributor contributor) {
        bind(view, contributor.getAvatarUrl());
    }

    private void bind(final ImageView view, String url) {
        if (url == null) {
            p.load(R.drawable.spinner_inner).resize(avatarSize, avatarSize).into(view);
            return;
        }

        if (url.contains("?") && !url.contains("gravatar")) {
            url = url.substring(0, url.indexOf("?"));
        }

        p.load(url)
                .placeholder(R.drawable.gravatar_icon)
                .resize(avatarSize, avatarSize)
                .transform(transformation)
                .into(view);
    }

    private String getAvatarUrl(User user) {
        if (user == null)
            return null;

        String avatarUrl = user.getAvatarUrl();
        if (TextUtils.isEmpty(avatarUrl)) {
            avatarUrl = getAvatarUrl(GravatarUtils.getHash(user.getEmail()));
        }
        return avatarUrl;
    }

    private String getAvatarUrl(CommitUser user) {
        return getAvatarUrl(GravatarUtils.getHash(user.getEmail()));
    }

    private String getAvatarUrl(String id) {
        if (!TextUtils.isEmpty(id))
            return "http://gravatar.com/avatar/" + id + "?d=404";
        else
            return null;
    }

    private int getMaxAvatarSize(final Context context) {
        int[] attrs = { android.R.attr.layout_height };
        TypedArray array = context.getTheme().obtainStyledAttributes(R.style.AvatarXLarge, attrs);

        int size = array.getLayoutDimension(0, 100);
        array.recycle();
        return size;
    }

    private boolean deleteCache(final File cache) {
        if (cache.isDirectory())
            for (File f : cache.listFiles())
                deleteCache(f);
        return cache.delete();
    }

    private static abstract class FetchAvatarTask extends RoboAsyncTask<BitmapDrawable> {

        private static final Executor EXECUTOR = Executors.newFixedThreadPool(1);

        private FetchAvatarTask(Context context) {
            super(context, EXECUTOR);
        }

        @Override
        protected void onException(Exception e) throws RuntimeException {
            Log.d(TAG, "Avatar load failed", e);
        }
    }

    public class RoundedCornersTransformation implements Transformation {
        @Override
        public Bitmap transform(Bitmap source) {
            return ImageUtils.roundCorners(source, cornerRadius);
        }

        @Override public String key() {
            return "RoundedCornersTransformation";
        }
    }
}

<code block>

package com.github.mobile.util;

import static java.util.Locale.US;
import android.text.TextUtils;


public class MarkdownUtils {

  private static final String[] MARKDOWN_EXTENSIONS = { ".md", ".mkdn",
          ".mdwn", ".mdown", ".markdown", ".mkd", ".mkdown", ".ron" };


  public static boolean isMarkdown(String name) {
      if (TextUtils.isEmpty(name))
          return false;

      name = name.toLowerCase(US);
      for (String extension : MARKDOWN_EXTENSIONS)
          if (name.endsWith(extension))
              return true;

      return false;
  }
}

<code block>
package com.github.mobile.model;

import java.util.HashMap;
import java.util.Map;

public class App {

    private String name;
    private String url;
    private String clientId;
    private Map<String, Object> additionalProperties = new HashMap<>();


    public String getName() {
        return name;
    }


    public void setName(String name) {
        this.name = name;
    }


    public String getUrl() {
        return url;
    }


    public void setUrl(String url) {
        this.url = url;
    }


    public String getClientId() {
        return clientId;
    }


    public void setClientId(String clientId) {
        this.clientId = clientId;
    }

    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    public void setAdditionalProperty(String name, Object value) {
        this.additionalProperties.put(name, value);
    }

}

<code block>
package com.github.mobile.model;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Authorization {

    private int id;
    private String url;
    private App app;
    private String token;
    private String note;
    private Object noteUrl;
    private String createdAt;
    private String updatedAt;
    private List<String> scopes = new ArrayList<>();
    private Map<String, Object> additionalProperties = new HashMap<>();


    public int getId() {
        return id;
    }


    public void setId(int id) {
        this.id = id;
    }


    public String getUrl() {
        return url;
    }


    public void setUrl(String url) {
        this.url = url;
    }


    public App getApp() {
        return app;
    }


    public void setApp(App app) {
        this.app = app;
    }


    public String getToken() {
        return token;
    }


    public void setToken(String token) {
        this.token = token;
    }


    public String getNote() {
        return note;
    }


    public void setNote(String note) {
        this.note = note;
    }


    public Object getNoteUrl() {
        return noteUrl;
    }


    public void setNoteUrl(Object noteUrl) {
        this.noteUrl = noteUrl;
    }


    public String getCreatedAt() {
        return createdAt;
    }


    public void setCreatedAt(String createdAt) {
        this.createdAt = createdAt;
    }


    public String getUpdatedAt() {
        return updatedAt;
    }


    public void setUpdatedAt(String updatedAt) {
        this.updatedAt = updatedAt;
    }


    public List<String> getScopes() {
        return scopes;
    }


    public void setScopes(List<String> scopes) {
        this.scopes = scopes;
    }

    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    public void setAdditionalProperty(String name, Object value) {
        this.additionalProperties.put(name, value);
    }

}
<code block>

package com.github.mobile.sync;

import android.content.SyncResult;
import android.database.SQLException;
import android.util.Log;

import com.github.mobile.persistence.DatabaseCache;
import com.github.mobile.persistence.OrganizationRepositories;
import com.github.mobile.persistence.Organizations;
import com.google.inject.Inject;
import com.google.inject.assistedinject.Assisted;

import java.io.IOException;
import java.util.List;

import org.eclipse.egit.github.core.User;


public class SyncCampaign implements Runnable {

    private static final String TAG = "SyncCampaign";


    public interface Factory {


        SyncCampaign create(SyncResult syncResult);
    }

    @Inject
    private DatabaseCache cache;

    @Inject
    private OrganizationRepositories.Factory repos;

    @Inject
    private Organizations persistedOrgs;

    private final SyncResult syncResult;

    private boolean cancelled = false;


    @Inject
    public SyncCampaign(@Assisted SyncResult syncResult) {
        this.syncResult = syncResult;
    }

    @Override
    public void run() {
        List<User> orgs;
        try {
            orgs = cache.requestAndStore(persistedOrgs);
            syncResult.stats.numUpdates++;
        } catch (IOException | SQLException e) {
            syncResult.stats.numIoExceptions++;
            Log.d(TAG, "Exception requesting users and orgs", e);
            return;
        }

        Log.d(TAG, "Syncing " + orgs.size() + " users and orgs");
        for (User org : orgs) {
            if (cancelled)
                return;

            Log.d(TAG, "Syncing repos for " + org.getLogin());
            try {
                cache.requestAndStore(repos.under(org));
                syncResult.stats.numUpdates++;
            } catch (IOException | SQLException e) {
                syncResult.stats.numIoExceptions++;
                Log.d(TAG, "Exception requesting repositories", e);
            }
        }

        Log.d(TAG, "Sync campaign finished");
    }


    public void cancel() {
        cancelled = true;
        Log.d(TAG, "Cancelled");
    }
}

<code block>

package com.github.mobile.sync;

import android.content.Intent;
import android.os.IBinder;

import com.google.inject.Inject;

import roboguice.inject.ContextScopedProvider;
import roboguice.service.RoboService;


public class SyncAdapterService extends RoboService {

    @Inject
    private ContextScopedProvider<SyncAdapter> syncAdapterProvider;

    @Override
    public IBinder onBind(Intent intent) {
        return syncAdapterProvider.get(this).getSyncAdapterBinder();
    }
}
<code block>

package com.github.mobile.sync;

import android.content.ContentProvider;
import android.content.ContentValues;
import android.database.Cursor;
import android.net.Uri;


public class ContentProviderAdapter extends ContentProvider {

    @Override
    public int delete(Uri uri, String selection, String[] selectionArgs) {
        return 0;
    }

    @Override
    public String getType(Uri uri) {
        return null;
    }

    @Override
    public Uri insert(Uri uri, ContentValues values) {
        return null;
    }

    @Override
    public boolean onCreate() {
        return true;
    }

    @Override
    public Cursor query(Uri uri, String[] projection, String selection,
            String[] selectionArgs, String sortOrder) {
        return null;
    }

    @Override
    public int update(Uri uri, ContentValues values, String selection,
            String[] selectionArgs) {
        return 0;
    }
}

<code block>

package com.github.mobile.sync;

import android.accounts.Account;
import android.accounts.AccountManager;
import android.content.AbstractThreadedSyncAdapter;
import android.content.ContentProviderClient;
import android.content.Context;
import android.content.SyncResult;
import android.os.Bundle;

import com.github.mobile.accounts.AccountScope;
import com.github.mobile.sync.SyncCampaign.Factory;
import com.google.inject.Inject;

import roboguice.inject.ContextScope;
import roboguice.inject.ContextSingleton;


@ContextSingleton
public class SyncAdapter extends AbstractThreadedSyncAdapter {

    @Inject
    private ContextScope contextScope;

    @Inject
    private AccountScope accountScope;

    @Inject
    private Factory campaignFactory;

    private SyncCampaign campaign = null;


    @Inject
    public SyncAdapter(final Context context) {
        super(context, true);
    }

    @Override
    public void onPerformSync(final Account account, final Bundle extras,
            final String authority, final ContentProviderClient provider,
            final SyncResult syncResult) {
        accountScope.enterWith(account, AccountManager.get(getContext()));
        try {
            contextScope.enter(getContext());
            try {
                cancelCampaign();
                campaign = campaignFactory.create(syncResult);
                campaign.run();
            } finally {
                contextScope.exit(getContext());
            }
        } finally {
            accountScope.exit();
        }
    }

    @Override
    public void onSyncCanceled() {
        cancelCampaign();
    }

    private void cancelCampaign() {
        if (campaign != null)
            campaign.cancel();
    }
}

<code block>

package com.github.mobile.accounts;

import static android.accounts.AccountManager.KEY_ACCOUNT_AUTHENTICATOR_RESPONSE;
import static android.accounts.AccountManager.KEY_ACCOUNT_NAME;
import static android.accounts.AccountManager.KEY_ACCOUNT_TYPE;
import static android.accounts.AccountManager.KEY_AUTHTOKEN;
import static android.accounts.AccountManager.KEY_BOOLEAN_RESULT;
import static android.accounts.AccountManager.KEY_INTENT;
import static com.github.mobile.accounts.AccountConstants.ACCOUNT_TYPE;
import static com.github.mobile.accounts.AccountConstants.APP_NOTE;
import static com.github.mobile.accounts.AccountConstants.APP_NOTE_URL;
import static com.github.mobile.accounts.LoginActivity.PARAM_AUTHTOKEN_TYPE;
import static com.github.mobile.accounts.LoginActivity.PARAM_USERNAME;
import android.accounts.AbstractAccountAuthenticator;
import android.accounts.Account;
import android.accounts.AccountAuthenticatorResponse;
import android.accounts.AccountManager;
import android.accounts.NetworkErrorException;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.text.TextUtils;
import android.util.Log;

import com.github.mobile.DefaultClient;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;

import org.eclipse.egit.github.core.Authorization;
import org.eclipse.egit.github.core.service.OAuthService;

public class AccountAuthenticator extends AbstractAccountAuthenticator {

    private static final String TAG = "GHAccountAuthenticator";

    private static final List<String> SCOPES = Arrays.asList("repo", "user", "gist");

    private Context context;

    public AccountAuthenticator(final Context context) {
        super(context);

        this.context = context;
    }


    @Override
    public Bundle addAccount(final AccountAuthenticatorResponse response,
            final String accountType, final String authTokenType,
            final String[] requiredFeatures, final Bundle options)
            throws NetworkErrorException {
        final Intent intent = new Intent(context, LoginActivity.class);
        intent.putExtra(PARAM_AUTHTOKEN_TYPE, authTokenType);
        intent.putExtra(KEY_ACCOUNT_AUTHENTICATOR_RESPONSE, response);
        final Bundle bundle = new Bundle();
        bundle.putParcelable(KEY_INTENT, intent);
        return bundle;
    }

    @Override
    public Bundle confirmCredentials(
            final AccountAuthenticatorResponse response, final Account account,
            final Bundle options) {
        return null;
    }

    @Override
    public Bundle editProperties(final AccountAuthenticatorResponse response,
            final String accountType) {
        return null;
    }

    private static boolean isValidAuthorization(final Authorization auth,
            final List<String> requiredScopes) {
        if (auth == null)
            return false;

        if (!APP_NOTE.equals(auth.getNote()))
            return false;

        if (!APP_NOTE_URL.equals(auth.getNoteUrl()))
            return false;

        List<String> scopes = auth.getScopes();
        return scopes != null && scopes.containsAll(requiredScopes);
    }

    private Intent createLoginIntent(final AccountAuthenticatorResponse response) {
        final Intent intent = new Intent(context, LoginActivity.class);
        intent.putExtra(PARAM_AUTHTOKEN_TYPE, ACCOUNT_TYPE);
        intent.putExtra(KEY_ACCOUNT_AUTHENTICATOR_RESPONSE, response);
        return intent;
    }


    public static String getAuthorization(final OAuthService service) throws IOException {
        for (Authorization auth : service.getAuthorizations())
            if (isValidAuthorization(auth, SCOPES))
                return auth.getToken();
        return null;
    }


    public static String createAuthorization(final OAuthService service) throws IOException {
        Authorization auth = new Authorization();
        auth.setNote(APP_NOTE);
        auth.setNoteUrl(APP_NOTE_URL);
        auth.setScopes(SCOPES);
        auth = service.createAuthorization(auth);
        return auth != null ? auth.getToken() : null;
    }

    @Override
    public Bundle getAuthToken(final AccountAuthenticatorResponse response,
            final Account account, final String authTokenType,
            final Bundle options) throws NetworkErrorException {
        Log.d(TAG, "Retrieving OAuth2 token");

        final Bundle bundle = new Bundle();

        if (!ACCOUNT_TYPE.equals(authTokenType))
            return bundle;

        AccountManager am = AccountManager.get(context);
        String password = am.getPassword(account);
        if (TextUtils.isEmpty(password)) {
            bundle.putParcelable(KEY_INTENT, createLoginIntent(response));
            return bundle;
        }

        DefaultClient client = new DefaultClient();
        client.setCredentials(account.name, password);
        OAuthService service = new OAuthService(client);

        String authToken;
        try {
            authToken = getAuthorization(service);
            if (TextUtils.isEmpty(authToken))
                authToken = createAuthorization(service);
        } catch (IOException e) {
            Log.e(TAG, "Authorization retrieval failed", e);
            throw new NetworkErrorException(e);
        }

        if (TextUtils.isEmpty(authToken))
            bundle.putParcelable(KEY_INTENT, createLoginIntent(response));
        else {
            bundle.putString(KEY_ACCOUNT_NAME, account.name);
            bundle.putString(KEY_ACCOUNT_TYPE, ACCOUNT_TYPE);
            bundle.putString(KEY_AUTHTOKEN, authToken);
            am.clearPassword(account);
        }
        return bundle;
    }

    @Override
    public String getAuthTokenLabel(final String authTokenType) {
        if (ACCOUNT_TYPE.equals(authTokenType))
            return authTokenType;
        else
            return null;
    }

    @Override
    public Bundle hasFeatures(final AccountAuthenticatorResponse response,
            final Account account, final String[] features)
            throws NetworkErrorException {
        final Bundle result = new Bundle();
        result.putBoolean(KEY_BOOLEAN_RESULT, false);
        return result;
    }

    @Override
    public Bundle updateCredentials(
            final AccountAuthenticatorResponse response, final Account account,
            final String authTokenType, final Bundle options) {
        final Intent intent = new Intent(context, LoginActivity.class);
        intent.putExtra(PARAM_AUTHTOKEN_TYPE, authTokenType);
        intent.putExtra(KEY_ACCOUNT_AUTHENTICATOR_RESPONSE, response);
        if (!TextUtils.isEmpty(account.name))
            intent.putExtra(PARAM_USERNAME, account.name);
        final Bundle bundle = new Bundle();
        bundle.putParcelable(KEY_INTENT, intent);
        return bundle;
    }
}

<code block>

package com.github.mobile.accounts;

import static android.util.Log.DEBUG;
import android.text.TextUtils;
import android.util.Log;

import com.github.mobile.DefaultClient;
import com.google.inject.Provider;

import java.net.HttpURLConnection;

import org.eclipse.egit.github.core.client.GitHubClient;


public class AccountClient extends DefaultClient {

    private static final String TAG = "AccountGitHubClient";

    private final Provider<GitHubAccount> accountProvider;


    public AccountClient(final Provider<GitHubAccount> accountProvider) {
        super();

        this.accountProvider = accountProvider;
    }

    @Override
    protected HttpURLConnection configureRequest(final HttpURLConnection request) {
        GitHubAccount account = accountProvider.get();

        if (Log.isLoggable(TAG, DEBUG))
            Log.d(TAG, "Authenticating using " + account);


        String token = account.getAuthToken();
        if (!TextUtils.isEmpty(token))
            setOAuth2Token(token);
        else
            setCredentials(account.getUsername(), account.getPassword());

        return super.configureRequest(request);
    }
}

<code block>

package com.github.mobile.accounts;

import com.google.inject.Key;
import com.google.inject.Provider;
import com.google.inject.Scope;

import java.util.Map;


public abstract class ScopeBase implements Scope {

    private static final Provider<Object> SEEDED_KEY_PROVIDER = new Provider<Object>() {
        public Object get() {
            throw new IllegalStateException("Object not seeded in this scope");
        }
    };


    @SuppressWarnings({ "unchecked" })
    public static <T> Provider<T> seededKeyProvider() {
        return (Provider<T>) SEEDED_KEY_PROVIDER;
    }

    public <T> Provider<T> scope(final Key<T> key, final Provider<T> unscoped) {
        return new Provider<T>() {
            public T get() {
                Map<Key<?>, Object> scopedObjects = getScopedObjectMap(key);

                @SuppressWarnings("unchecked")
                T current = (T) scopedObjects.get(key);
                if (current == null && !scopedObjects.containsKey(key)) {
                    current = unscoped.get();
                    scopedObjects.put(key, current);
                }
                return current;
            }
        };
    }


    protected abstract <T> Map<Key<?>, Object> getScopedObjectMap(Key<T> key);
}

<code block>

package com.github.mobile.accounts;

import android.accounts.Account;
import android.accounts.AccountManager;

import com.google.inject.AbstractModule;
import com.google.inject.Key;
import com.google.inject.Module;
import com.google.inject.OutOfScopeException;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;


public class AccountScope extends ScopeBase {

    private static final Key<GitHubAccount> GITHUB_ACCOUNT_KEY = Key
            .get(GitHubAccount.class);


    public static Module module() {
        return new AbstractModule() {
            public void configure() {
                AccountScope scope = new AccountScope();

                bind(AccountScope.class).toInstance(scope);

                bind(GITHUB_ACCOUNT_KEY).toProvider(
                        AccountScope.<GitHubAccount> seededKeyProvider()).in(
                        scope);
            }
        };
    }

    private final ThreadLocal<GitHubAccount> currentAccount = new ThreadLocal<>();

    private final Map<GitHubAccount, Map<Key<?>, Object>> repoScopeMaps = new ConcurrentHashMap<>();


    public void enterWith(final Account account,
            final AccountManager accountManager) {
        enterWith(new GitHubAccount(account, accountManager));
    }


    public void enterWith(final GitHubAccount account) {
        if (currentAccount.get() != null)
            throw new IllegalStateException(
                    "A scoping block is already in progress");

        currentAccount.set(account);
    }


    public void exit() {
        if (currentAccount.get() == null)
            throw new IllegalStateException("No scoping block in progress");

        currentAccount.remove();
    }

    @Override
    protected <T> Map<Key<?>, Object> getScopedObjectMap(final Key<T> key) {
        GitHubAccount account = currentAccount.get();
        if (account == null)
            throw new OutOfScopeException("Cannot access " + key
                    + " outside of a scoping block");

        Map<Key<?>, Object> scopeMap = repoScopeMaps.get(account);
        if (scopeMap == null) {
            scopeMap = new ConcurrentHashMap<>();
            scopeMap.put(GITHUB_ACCOUNT_KEY, account);
            repoScopeMaps.put(account, scopeMap);
        }
        return scopeMap;
    }
}

<code block>

package com.github.mobile.accounts;


public interface AccountConstants {


    String ACCOUNT_TYPE = "com.github";


    String ACCOUNT_NAME = "GitHub";


    String PROVIDER_AUTHORITY = "com.github.sync";


    String APP_NOTE_URL = "https://github.com/github/android";


    String APP_NOTE = "GitHub Android App";
}

<code block>

package com.github.mobile.accounts;

import android.accounts.Account;
import android.accounts.AccountManager;
import android.app.Activity;
import android.content.Context;

import com.google.inject.Inject;

import java.io.IOException;
import java.util.concurrent.Executor;

import roboguice.inject.ContextScope;
import roboguice.util.RoboAsyncTask;


public abstract class AuthenticatedUserTask<ResultT> extends
        RoboAsyncTask<ResultT> {

    @Inject
    private ContextScope contextScope;

    @Inject
    private AccountScope accountScope;

    @Inject
    private Activity activity;


    protected AuthenticatedUserTask(final Context context) {
        super(context);
    }


    public AuthenticatedUserTask(final Context context, final Executor executor) {
        super(context, executor);
    }

    @Override
    public final ResultT call() throws Exception {
        final AccountManager manager = AccountManager.get(activity);
        final Account account = AccountUtils.getAccount(manager, activity);

        accountScope.enterWith(account, manager);
        try {
            contextScope.enter(getContext());
            try {
                return run(account);
            } catch (IOException e) {


                if (AccountUtils.isUnauthorized(e)
                        && AccountUtils.updateAccount(account, activity))
                    return run(account);
                else
                    throw e;
            } finally {
                contextScope.exit(getContext());
            }
        } finally {
            accountScope.exit();
        }
    }


    protected abstract ResultT run(Account account) throws Exception;
}

<code block>

package com.github.mobile.accounts;

import static android.accounts.AccountManager.KEY_ACCOUNT_NAME;
import static android.content.DialogInterface.BUTTON_POSITIVE;
import static android.util.Log.DEBUG;
import static com.github.mobile.accounts.AccountConstants.ACCOUNT_TYPE;
import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
import android.accounts.Account;
import android.accounts.AccountManager;
import android.accounts.AccountManagerFuture;
import android.accounts.AccountsException;
import android.accounts.AuthenticatorDescription;
import android.accounts.AuthenticatorException;
import android.accounts.OperationCanceledException;
import android.app.Activity;
import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnCancelListener;
import android.content.DialogInterface.OnClickListener;
import android.os.Bundle;
import android.text.TextUtils;
import android.util.Log;

import com.github.mobile.R;
import com.github.mobile.ui.LightAlertDialog;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.client.RequestException;


public class AccountUtils {

    private static final String TAG = "AccountUtils";

    private static boolean AUTHENTICATOR_CHECKED;

    private static boolean HAS_AUTHENTICATOR;

    private static final AtomicInteger UPDATE_COUNT = new AtomicInteger(0);

    private static class AuthenticatorConflictException extends IOException {

        private static final long serialVersionUID = 641279204734869183L;
    }


    public static boolean hasAuthenticator(final AccountManager manager) {
        if (!AUTHENTICATOR_CHECKED) {
            final AuthenticatorDescription[] types = manager
                    .getAuthenticatorTypes();
            if (types != null && types.length > 0)
                for (AuthenticatorDescription descriptor : types)
                    if (descriptor != null
                            && ACCOUNT_TYPE.equals(descriptor.type)) {
                        HAS_AUTHENTICATOR = "com.github.mobile"
                                .equals(descriptor.packageName);
                        break;
                    }
            AUTHENTICATOR_CHECKED = true;
        }

        return HAS_AUTHENTICATOR;
    }


    public static boolean isUser(final Context context, final User user) {
        if (user == null)
            return false;

        String login = user.getLogin();
        if (login == null)
            return false;

        return login.equals(getLogin(context));
    }


    public static String getLogin(final Context context) {
        final Account account = getAccount(context);
        return account != null ? account.name : null;
    }


    public static Account getAccount(final Context context) {
        final Account[] accounts = AccountManager.get(context)
                .getAccountsByType(ACCOUNT_TYPE);
        return accounts.length > 0 ? accounts[0] : null;
    }

    private static Account[] getAccounts(final AccountManager manager)
            throws OperationCanceledException, AuthenticatorException,
            IOException {
        final AccountManagerFuture<Account[]> future = manager
                .getAccountsByTypeAndFeatures(ACCOUNT_TYPE, null, null, null);
        final Account[] accounts = future.getResult();
        if (accounts != null && accounts.length > 0)
            return getPasswordAccessibleAccounts(manager, accounts);
        else
            return new Account[0];
    }


    public static Account getPasswordAccessibleAccount(final Context context) {
        AccountManager manager = AccountManager.get(context);
        Account[] accounts = manager.getAccountsByType(ACCOUNT_TYPE);
        if (accounts == null || accounts.length == 0)
            return null;

        try {
            accounts = getPasswordAccessibleAccounts(manager, accounts);
        } catch (AuthenticatorConflictException e) {
            return null;
        }
        return accounts != null && accounts.length > 0 ? accounts[0] : null;
    }

    private static Account[] getPasswordAccessibleAccounts(
            final AccountManager manager, final Account[] candidates)
            throws AuthenticatorConflictException {
        final List<Account> accessible = new ArrayList<>(
                candidates.length);
        boolean exceptionThrown = false;
        for (Account account : candidates)
            try {
                manager.getPassword(account);
                accessible.add(account);
            } catch (SecurityException ignored) {
                exceptionThrown = true;
            }
        if (accessible.isEmpty() && exceptionThrown)
            throw new AuthenticatorConflictException();
        return accessible.toArray(new Account[accessible.size()]);
    }


    public static Account getAccount(final AccountManager manager,
            final Activity activity) throws IOException, AccountsException {
        final boolean loggable = Log.isLoggable(TAG, DEBUG);
        if (loggable)
            Log.d(TAG, "Getting account");

        if (activity == null)
            throw new IllegalArgumentException("Activity cannot be null");

        if (activity.isFinishing())
            throw new OperationCanceledException();

        Account[] accounts;
        try {
            if (!hasAuthenticator(manager))
                throw new AuthenticatorConflictException();

            while ((accounts = getAccounts(manager)).length == 0) {
                if (loggable)
                    Log.d(TAG, "No GitHub accounts for activity=" + activity);

                Bundle result = manager.addAccount(ACCOUNT_TYPE, null, null,
                        null, activity, null, null).getResult();

                if (loggable)
                    Log.d(TAG,
                            "Added account "
                                    + result.getString(KEY_ACCOUNT_NAME));
            }
        } catch (OperationCanceledException e) {
            Log.d(TAG, "Excepting retrieving account", e);
            activity.finish();
            throw e;
        } catch (AccountsException e) {
            Log.d(TAG, "Excepting retrieving account", e);
            throw e;
        } catch (AuthenticatorConflictException e) {
            activity.runOnUiThread(new Runnable() {

                public void run() {
                    showConflictMessage(activity);
                }
            });
            throw e;
        } catch (IOException e) {
            Log.d(TAG, "Excepting retrieving account", e);
            throw e;
        }

        if (loggable)
            Log.d(TAG, "Returning account " + accounts[0].name);

        return accounts[0];
    }


    public static boolean updateAccount(final Account account,
            final Activity activity) {
        int count = UPDATE_COUNT.get();
        synchronized (UPDATE_COUNT) {


            if (count != UPDATE_COUNT.get())
                return true;

            AccountManager manager = AccountManager.get(activity);
            try {
                if (!hasAuthenticator(manager))
                    throw new AuthenticatorConflictException();
                manager.updateCredentials(account, ACCOUNT_TYPE, null,
                        activity, null, null).getResult();
                UPDATE_COUNT.incrementAndGet();
                return true;
            } catch (OperationCanceledException e) {
                Log.d(TAG, "Excepting retrieving account", e);
                activity.finish();
                return false;
            } catch (AccountsException e) {
                Log.d(TAG, "Excepting retrieving account", e);
                return false;
            } catch (AuthenticatorConflictException e) {
                activity.runOnUiThread(new Runnable() {

                    public void run() {
                        showConflictMessage(activity);
                    }
                });
                return false;
            } catch (IOException e) {
                Log.d(TAG, "Excepting retrieving account", e);
                return false;
            }
        }
    }


    private static void showConflictMessage(final Activity activity) {
        AlertDialog dialog = LightAlertDialog.create(activity);
        dialog.setTitle(activity.getString(R.string.authenticator_conflict_title));
        dialog.setMessage(activity
                .getString(R.string.authenticator_conflict_message));
        dialog.setOnCancelListener(new OnCancelListener() {

            @Override
            public void onCancel(DialogInterface dialog) {
                activity.finish();
            }
        });
        dialog.setButton(BUTTON_POSITIVE,
                activity.getString(android.R.string.ok), new OnClickListener() {

                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        activity.finish();
                    }
                });
        dialog.show();
    }


    public static boolean isUnauthorized(final Exception e) {
        if (e instanceof RequestException)
            return ((RequestException) e).getStatus() == HTTP_UNAUTHORIZED;

        String message = null;
        if (e instanceof IOException)
            message = e.getMessage();
        final Throwable cause = e.getCause();
        if (cause instanceof IOException) {
            String causeMessage = cause.getMessage();
            if (!TextUtils.isEmpty(causeMessage))
                message = causeMessage;
        }

        if (TextUtils.isEmpty(message))
            return false;

        if ("Received authentication challenge is null".equals(message))
            return true;
        return "No authentication challenges found".equals(message);

    }
}

<code block>

package com.github.mobile.accounts;

import java.io.IOException;


public class TwoFactorAuthException extends IOException {


    private static final long serialVersionUID = 3889626691109709714L;


    protected final IOException cause;


    protected final int twoFactorAuthType;


    public TwoFactorAuthException(IOException cause, int twoFactorAuthType) {
        this.cause = cause;
        this.twoFactorAuthType = twoFactorAuthType;
    }

    @Override
    public String getMessage() {
        return cause != null ? cause.getMessage() : super.getMessage();
    }

    @Override
    public IOException getCause() {
        return cause;
    }
}
<code block>
package com.github.mobile.accounts;

import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.support.v7.app.AppCompatActivity;
import android.webkit.WebViewClient;

import com.github.mobile.R;
import com.github.mobile.ui.WebView;

public class LoginWebViewActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        WebView webView = new WebView(this);
        webView.loadUrl(getIntent().getStringExtra(LoginActivity.INTENT_EXTRA_URL));
        webView.setWebViewClient(new WebViewClient() {
            @Override
            public boolean shouldOverrideUrlLoading(android.webkit.WebView view, String url) {
                Uri uri = Uri.parse(url);
                if (uri.getScheme().equals(getString(R.string.github_oauth_scheme))) {
                    Intent data = new Intent();
                    data.setData(uri);
                    setResult(RESULT_OK, data);
                    finish();
                    return true;
                }
                return super.shouldOverrideUrlLoading(view, url);
            }
        });

        setContentView(webView);
    }
}
<code block>

package com.github.mobile.accounts;

import android.text.TextUtils;
import com.github.mobile.DefaultClient;
import org.eclipse.egit.github.core.client.GitHubClient;
import org.eclipse.egit.github.core.client.GitHubRequest;
import org.eclipse.egit.github.core.client.GitHubResponse;

import java.io.IOException;
import java.lang.reflect.Type;
import java.net.HttpURLConnection;


public class TwoFactorAuthClient extends DefaultClient {


    protected static final String HEADER_OTP = "X-GitHub-OTP";


    public static final int TWO_FACTOR_AUTH_TYPE_APP = 1001;


    public static final int TWO_FACTOR_AUTH_TYPE_SMS = 1002;

    private String otpCode;

    public TwoFactorAuthClient() {
        super();
    }


    public void setOtpCode(String otpCode) {
        this.otpCode = otpCode;
    }


    @Override
    public GitHubResponse get(GitHubRequest request) throws IOException {
        HttpURLConnection httpRequest = createGet(request.generateUri());
        if (!TextUtils.isEmpty(otpCode))
            httpRequest.setRequestProperty(HEADER_OTP, otpCode);

        try {
            String accept = request.getResponseContentType();
            if (accept != null)
                httpRequest.setRequestProperty(HEADER_ACCEPT, accept);
            final int code = httpRequest.getResponseCode();
            updateRateLimits(httpRequest);
            if (isOk(code))
                return new GitHubResponse(httpRequest, getBody(request,
                        getStream(httpRequest)));
            if (isEmpty(code))
                return new GitHubResponse(httpRequest, null);
            throw createException(getStream(httpRequest), code,
                    httpRequest.getResponseMessage());
        } catch (IOException e) {
            throw checkTwoFactorAuthError(httpRequest, e);
        }
    }


    @Override
    public <V> V post(final String uri, final Object params, final Type type)
            throws IOException {
        HttpURLConnection request = createPost(uri);
        if (!TextUtils.isEmpty(otpCode))
            request.setRequestProperty(HEADER_OTP, otpCode);

        try {
            return sendJson(request, params, type);
        } catch (IOException e) {
            throw checkTwoFactorAuthError(request, e);
        }
    }

    private IOException checkTwoFactorAuthError(HttpURLConnection request, IOException e) throws IOException {
        String otpHeader = request.getHeaderField(HEADER_OTP);
        if (!TextUtils.isEmpty(otpHeader) && otpHeader.contains("required"))
            return createTwoFactorAuthException(e, otpHeader);
        else
            return e;
    }

    private TwoFactorAuthException createTwoFactorAuthException(
            IOException cause, String otpHeader) {
        int twoFactorAuthType = -1;
        if (otpHeader.contains("app"))
            twoFactorAuthType = TWO_FACTOR_AUTH_TYPE_APP;
        else if (otpHeader.contains("sms"))
            twoFactorAuthType = TWO_FACTOR_AUTH_TYPE_SMS;

        return new TwoFactorAuthException(cause, twoFactorAuthType);
    }

    private <V> V sendJson(final HttpURLConnection request,
           final Object params, final Type type) throws IOException {
        sendParams(request, params);
        final int code = request.getResponseCode();
        updateRateLimits(request);
        if (isOk(code))
            if (type != null)
                return parseJson(getStream(request), type);
            else
                return null;
        if (isEmpty(code))
            return null;
        throw createException(getStream(request), code,
                request.getResponseMessage());
    }
}

<code block>

package com.github.mobile.accounts;

import static android.accounts.AccountManager.ACTION_AUTHENTICATOR_INTENT;
import android.app.Service;
import android.content.Intent;
import android.os.IBinder;


public class AccountAuthenticatorService extends Service {

    private static AccountAuthenticator AUTHENTICATOR;

    public IBinder onBind(Intent intent) {
        return intent.getAction().equals(ACTION_AUTHENTICATOR_INTENT) ? getAuthenticator()
                .getIBinder() : null;
    }

    private AccountAuthenticator getAuthenticator() {
        if (AUTHENTICATOR == null)
            AUTHENTICATOR = new AccountAuthenticator(this);
        return AUTHENTICATOR;
    }
}
<code block>

package com.github.mobile.accounts;

import static android.content.DialogInterface.OnCancelListener;
import static android.view.KeyEvent.ACTION_DOWN;
import static android.view.KeyEvent.KEYCODE_ENTER;
import static android.view.inputmethod.EditorInfo.IME_ACTION_DONE;
import static com.github.mobile.accounts.AccountConstants.ACCOUNT_TYPE;
import static com.github.mobile.accounts.LoginActivity.configureSyncFor;
import android.accounts.Account;
import android.accounts.AccountManager;
import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.os.Bundle;
import android.text.Editable;
import android.text.Html;
import android.text.TextUtils;
import android.text.TextWatcher;
import android.text.method.LinkMovementMethod;
import android.util.Log;
import android.view.KeyEvent;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.widget.EditText;
import android.widget.TextView;

import com.github.kevinsawicki.wishlist.ViewFinder;
import com.github.mobile.R;
import com.github.mobile.ui.LightProgressDialog;
import com.github.mobile.ui.TextWatcherAdapter;
import com.github.mobile.ui.roboactivities.RoboActionBarActivity;

import java.io.IOException;

import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.service.OAuthService;
import org.eclipse.egit.github.core.service.UserService;

import roboguice.util.RoboAsyncTask;


public class TwoFactorAuthActivity extends RoboActionBarActivity {


    public static Intent createIntent(Context context, String username, String password) {
        Intent intent = new Intent(context, TwoFactorAuthActivity.class);
        intent.putExtra(PARAM_USERNAME, username);
        intent.putExtra(PARAM_PASSWORD, password);
        return intent;
    }


    public static final String PARAM_EXCEPTION = "exception";


    public static final String PARAM_USERNAME = "username";


    public static final String PARAM_PASSWORD = "password";

    private static final String TAG = "TwoFactorAuthActivity";

    private AccountManager accountManager;

    private EditText otpCodeText;

    private RoboAsyncTask<User> authenticationTask;

    private MenuItem loginItem;

    private String username;

    private String password;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.login_two_factor_auth);

        setSupportActionBar((android.support.v7.widget.Toolbar) findViewById(R.id.toolbar));

        accountManager = AccountManager.get(this);

        ViewFinder finder = new ViewFinder(this);
        otpCodeText = finder.find(R.id.et_otp_code);

        final Intent intent = getIntent();
        username = intent.getStringExtra(PARAM_USERNAME);
        password = intent.getStringExtra(PARAM_PASSWORD);

        TextView signupText = finder.find(R.id.tv_signup);
        signupText.setMovementMethod(LinkMovementMethod.getInstance());
        signupText.setText(Html.fromHtml(getString(R.string.signup_link_two_factor_auth)));

        TextWatcher watcher = new TextWatcherAdapter() {

            @Override
            public void afterTextChanged(Editable gitDirEditText) {
                updateEnablement();
            }
        };
        otpCodeText.addTextChangedListener(watcher);

        otpCodeText.setOnKeyListener(new View.OnKeyListener() {

            @Override
            public boolean onKey(View v, int keyCode, KeyEvent event) {
                if (event != null && ACTION_DOWN == event.getAction()
                    && keyCode == KEYCODE_ENTER && loginEnabled()) {
                    handleLogin();
                    return true;
                } else
                    return false;
            }
        });

        otpCodeText.setOnEditorActionListener(new TextView.OnEditorActionListener() {

            @Override
            public boolean onEditorAction(TextView v, int actionId,
                KeyEvent event) {
                if (actionId == IME_ACTION_DONE && loginEnabled()) {
                    handleLogin();
                    return true;
                }
                return false;
            }
        });
    }

    @Override
    protected void onResume() {
        super.onResume();
        updateEnablement();
    }

    private boolean loginEnabled() {
        Editable otpCode = otpCodeText.getText();
        return !TextUtils.isEmpty(otpCode) && otpCode.length() == 6;
    }

    private void updateEnablement() {
        if (loginItem != null)
            loginItem.setEnabled(loginEnabled());
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.m_login:
                handleLogin();
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    public boolean onCreateOptionsMenu(Menu optionsMenu) {
        getMenuInflater().inflate(R.menu.login, optionsMenu);
        loginItem = optionsMenu.findItem(R.id.m_login);
        return true;
    }

    private void handleLogin() {
        final String otpCode = otpCodeText.getText().toString();

        final AlertDialog dialog = LightProgressDialog.create(this,
            R.string.login_activity_authenticating);
        dialog.setCancelable(true);
        dialog.setOnCancelListener(new OnCancelListener() {

            @Override
            public void onCancel(DialogInterface dialog) {
                if (authenticationTask != null)
                    authenticationTask.cancel(true);
            }
        });
        dialog.show();

        authenticationTask = new RoboAsyncTask<User>(this) {

            @Override
            public User call() throws Exception {
                TwoFactorAuthClient client = new TwoFactorAuthClient();
                client.setCredentials(username, password);
                client.setOtpCode(otpCode);

                OAuthService service = new OAuthService(client);
                String authToken = AccountAuthenticator.getAuthorization(service);
                if (authToken == null)
                    authToken = AccountAuthenticator.createAuthorization(service);
                client.setOAuth2Token(authToken);

                User user = new UserService(client).getUser();
                Account account = new Account(user.getLogin(), ACCOUNT_TYPE);
                accountManager.addAccountExplicitly(account, password, null);
                accountManager.setAuthToken(account, ACCOUNT_TYPE, authToken);

                configureSyncFor(account);
                try {
                    new LoginActivity.AccountLoader(TwoFactorAuthActivity.this).call();
                } catch (IOException e) {
                    Log.d(TAG, "Exception loading organizations", e);
                }

                return user;
            }

            @Override
            protected void onException(Exception e) throws RuntimeException {
                dialog.dismiss();

                Log.d(TAG, "Exception requesting handling two-factor authentication", e);
                setResult(RESULT_CANCELED, new Intent().putExtra(PARAM_EXCEPTION, e));
                finish();
            }

            @Override
            public void onSuccess(User user) {
                dialog.dismiss();
                setResult(RESULT_OK);
                finish();
            }
        };
        authenticationTask.execute();
    }
}

<code block>

package com.github.mobile.accounts;

import static android.accounts.AccountManager.KEY_AUTHTOKEN;
import static com.github.mobile.accounts.AccountConstants.ACCOUNT_TYPE;
import android.accounts.Account;
import android.accounts.AccountManager;
import android.accounts.AccountManagerFuture;
import android.accounts.AccountsException;
import android.os.Bundle;
import android.util.Log;

import java.io.IOException;


public class GitHubAccount {

    private static final String TAG = "GitHubAccount";

    private final Account account;

    private final AccountManager manager;


    public GitHubAccount(final Account account, final AccountManager manager) {
        this.account = account;
        this.manager = manager;
    }


    public String getUsername() {
        return account.name;
    }


    public String getPassword() {
        return manager.getPassword(account);
    }


    public String getAuthToken() {
        AccountManagerFuture<Bundle> future = manager.getAuthToken(account,
                ACCOUNT_TYPE, false, null, null);

        try {
            Bundle result = future.getResult();
            return result != null ? result.getString(KEY_AUTHTOKEN) : null;
        } catch (AccountsException e) {
            Log.e(TAG, "Auth token lookup failed", e);
            return null;
        } catch (IOException e) {
            Log.e(TAG, "Auth token lookup failed", e);
            return null;
        }
    }

    @Override
    public String toString() {
        return getClass().getSimpleName() + '[' + account.name + ']';
    }
}

<code block>

package com.github.mobile.accounts;

import static com.github.mobile.accounts.AccountConstants.PROVIDER_AUTHORITY;
import android.accounts.Account;
import android.accounts.AccountManager;
import android.app.AlertDialog;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.support.v7.widget.Toolbar;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;
import android.widget.Toast;

import com.alorma.github.basesdk.ApiClient;
import com.alorma.github.basesdk.client.BaseClient;
import com.alorma.github.sdk.bean.dto.response.Token;
import com.alorma.github.sdk.login.AccountsHelper;
import com.alorma.github.sdk.security.GitHub;
import com.alorma.github.sdk.services.login.RequestTokenClient;
import com.alorma.github.sdk.services.user.GetAuthUserClient;
import com.github.mobile.R;
import com.github.mobile.persistence.AccountDataManager;
import com.github.mobile.ui.LightProgressDialog;
import com.github.mobile.ui.MainActivity;
import com.github.mobile.ui.roboactivities.RoboActionBarAccountAuthenticatorActivity;
import com.google.inject.Inject;
import com.squareup.okhttp.HttpUrl;

import java.util.List;

import org.eclipse.egit.github.core.User;

import retrofit.RetrofitError;
import retrofit.client.Response;


public class LoginActivity extends RoboActionBarAccountAuthenticatorActivity implements BaseClient.OnResultCallback<com.alorma.github.sdk.bean.dto.response.User> {


    public static final String PARAM_AUTHTOKEN_TYPE = "authtokenType";


    public static final String PARAM_USERNAME = "username";

    public static final String OAUTH_HOST = "www.github.com";

    public static final String INTENT_EXTRA_URL = "url";

    private static int WEBVIEW_REQUEST_CODE = 0;

    private static final String TAG = "LoginActivity";


    private static final long SYNC_PERIOD = 8L * 60L * 60L;

    public static void configureSyncFor(Account account) {
        Log.d(TAG, "Configuring account sync");

        ContentResolver.setIsSyncable(account, PROVIDER_AUTHORITY, 1);
        ContentResolver.setSyncAutomatically(account, PROVIDER_AUTHORITY, true);
        ContentResolver.addPeriodicSync(account, PROVIDER_AUTHORITY,
            new Bundle(), SYNC_PERIOD);
    }

    public static class AccountLoader extends
        AuthenticatedUserTask<List<User>> {

        @Inject
        private AccountDataManager cache;

        protected AccountLoader(Context context) {
            super(context);
        }

        @Override
        protected List<User> run(Account account) throws Exception {
            return cache.getOrgs(true);
        }
    }

    private AccountManager accountManager;

    private Account[] accounts;

    private String accessToken;

    private String scope;

    private RequestTokenClient requestTokenClient;

    private AlertDialog progressDialog;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.login);

        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
        setSupportActionBar(toolbar);

        accountManager = AccountManager.get(this);

        accounts = accountManager.getAccountsByType(getString(R.string.account_type));

        if (accounts != null && accounts.length > 0)
            openMain();
    }

    @Override
    protected void onNewIntent(Intent intent) {
        super.onNewIntent(intent);
        Uri uri = intent.getData();
        onUserLoggedIn(uri);
    }

    private void onUserLoggedIn(Uri uri) {
        if (uri != null && uri.getScheme().equals(getString(R.string.github_oauth_scheme))) {
            openLoadingDialog();
            String code = uri.getQueryParameter("code");
            if (requestTokenClient == null) {
                requestTokenClient = new RequestTokenClient(LoginActivity.this, code);
                requestTokenClient.setOnResultCallback(new BaseClient.OnResultCallback<Token>() {
                    @Override
                    public void onResponseOk(Token token, Response r) {
                        if (token.access_token != null) {
                            endAuth(token.access_token, token.scope);
                        } else if (token.error != null) {
                            Toast.makeText(LoginActivity.this, token.error, Toast.LENGTH_LONG).show();
                            progressDialog.dismiss();
                        }
                    }

                    @Override
                    public void onFail(RetrofitError error) {
                        error.printStackTrace();
                    }
                });
                requestTokenClient.execute();
            }
        }
    }

    private void openMain() {
        if(progressDialog != null)
            progressDialog.dismiss();
        Intent intent = new Intent(this, MainActivity.class);
        startActivity(intent);
        finish();
    }

    private void openLoadingDialog() {
        progressDialog = LightProgressDialog.create(this,
                R.string.login_activity_authenticating);
        progressDialog.show();
    }

    public void handleLogin() {
        openLoginInBrowser(new GitHub(this));
    }

    private void openLoginInBrowser(ApiClient client) {
        String initialScope = "user,public_repo,repo,delete_repo,notifications,gist";
        HttpUrl.Builder url = new HttpUrl.Builder()
                .scheme("https")
                .host(OAUTH_HOST)
                .addPathSegment("login")
                .addPathSegment("oauth")
                .addPathSegment("authorize")
                .addQueryParameter("client_id", client.getApiClient())
                .addQueryParameter("scope", initialScope);

        Intent intent = new Intent(this, LoginWebViewActivity.class);
        intent.putExtra(INTENT_EXTRA_URL, url.toString());
        startActivityForResult(intent, WEBVIEW_REQUEST_CODE);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if(requestCode == WEBVIEW_REQUEST_CODE && resultCode == RESULT_OK)
            onUserLoggedIn(data.getData());
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.m_login:
                handleLogin();
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    public void onResponseOk(com.alorma.github.sdk.bean.dto.response.User user, Response r) {
        Account account = new Account(user.login, getString(R.string.account_type));
        Bundle userData = AccountsHelper.buildBundle(user.name, user.email, user.avatar_url, scope);
        userData.putString(AccountManager.KEY_AUTHTOKEN, accessToken);

        accountManager.addAccountExplicitly(account, null, userData);
        accountManager.setAuthToken(account, getString(R.string.account_type), accessToken);

        Bundle result = new Bundle();
        result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);
        result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);
        result.putString(AccountManager.KEY_AUTHTOKEN, accessToken);

        setAccountAuthenticatorResult(result);

        openMain();
    }

    @Override
    public void onFail(RetrofitError error) {
        error.printStackTrace();
    }

    private void endAuth(String accessToken, String scope) {
        this.accessToken = accessToken;
        this.scope = scope;

        progressDialog.setMessage(getString(R.string.loading_user));

        GetAuthUserClient userClient = new GetAuthUserClient(this, accessToken);
        userClient.setOnResultCallback(this);
        userClient.execute();
    }

    @Override
    public boolean onCreateOptionsMenu(Menu optionMenu) {
        getMenuInflater().inflate(R.menu.login, optionMenu);
        return true;
    }
}
<code block>

package com.github.mobile.accounts;

import android.accounts.Account;
import android.accounts.AccountManager;
import android.accounts.AccountsException;
import android.app.Activity;
import android.content.Context;

import com.github.kevinsawicki.wishlist.AsyncLoader;
import com.google.inject.Inject;

import java.io.IOException;

import roboguice.RoboGuice;
import roboguice.inject.ContextScope;


public abstract class AuthenticatedUserLoader<D> extends AsyncLoader<D> {

    @Inject
    private ContextScope contextScope;

    @Inject
    private AccountScope accountScope;


    @Inject
    protected Activity activity;


    public AuthenticatedUserLoader(final Context context) {
        super(context);

        RoboGuice.injectMembers(context, this);
    }


    protected abstract D getAccountFailureData();

    @Override
    public final D loadInBackground() {
        final AccountManager manager = AccountManager.get(activity);
        final Account account;
        try {
            account = AccountUtils.getAccount(manager, activity);
        } catch (IOException e) {
            return getAccountFailureData();
        } catch (AccountsException e) {
            return getAccountFailureData();
        }

        accountScope.enterWith(account, manager);
        try {
            contextScope.enter(getContext());
            try {
                return load(account);
            } finally {
                contextScope.exit(getContext());
            }
        } finally {
            accountScope.exit();
        }
    }


    public abstract D load(Account account);
}
<code block>


package com.github.mobile.api;

import com.github.mobile.model.Authorization;

import java.util.List;

import org.eclipse.egit.github.core.client.GitHubClient;

import retrofit.RequestInterceptor;
import retrofit.RestAdapter;
import retrofit.android.AndroidLog;
import retrofit.client.Response;
import retrofit.http.Body;
import retrofit.http.DELETE;
import retrofit.http.GET;
import retrofit.http.Header;
import retrofit.http.POST;
import retrofit.http.Path;

public class GitHubClientV2 extends GitHubClient {
    private static String API_URL = "https://api.github.com";
    private static GitHubClientV2Interface sGitHubClientInterface;

    public static GitHubClientV2Interface getServiceClient() {
        if (sGitHubClientInterface == null) {
            RestAdapter restAdapter = new RestAdapter.Builder()
                    .setRequestInterceptor(new RequestInterceptor() {
                        @Override
                        public void intercept(RequestFacade request) {
                            request.addHeader("Accept", "application/vnd.github.v3.full+json");
                        }
                    })
                    .setEndpoint(API_URL)
                    .setLogLevel(RestAdapter.LogLevel.FULL).setLog(new AndroidLog("Retrofit"))
                    .build();

            sGitHubClientInterface = restAdapter.create(GitHubClientV2Interface.class);
        }

        return sGitHubClientInterface;
    }

    public interface GitHubClientV2Interface {
        @DELETE("/repos/{owner}/{repo}")
        Response deleteRepository(
                @Header("Authorization") String basicCredentials,
                @Path("owner") String owner,
                @Path("repo") String repo);

        @GET("/authorizations")
        List<Authorization> getAuthorizations(@Header("Authorization") String token);

        @POST("/authorizations")
        Authorization createDeleteAuthorization(@Header("Authorization") String basicCredentials,
                                                @Body Authorization authorization);
    }
}

<code block>

package com.github.mobile.persistence;

import android.accounts.Account;
import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteOpenHelper;
import android.database.sqlite.SQLiteQueryBuilder;
import android.util.Log;

import com.github.mobile.RequestFuture;
import com.github.mobile.RequestReader;
import com.github.mobile.RequestWriter;
import com.github.mobile.accounts.AuthenticatedUserTask;
import com.github.mobile.core.issue.IssueFilter;
import com.github.mobile.persistence.OrganizationRepositories.Factory;
import com.google.inject.Inject;
import com.google.inject.name.Named;

import java.io.File;
import java.io.IOException;
import java.text.MessageFormat;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;


public class AccountDataManager {

    private static final String TAG = "AccountDataManager";

    private static final Executor EXECUTOR = Executors.newFixedThreadPool(10);


    private static final int FORMAT_VERSION = 4;

    @Inject
    private Context context;

    @Inject
    private DatabaseCache dbCache;

    @Inject
    private Factory allRepos;

    @Inject
    private Organizations userAndOrgsResource;

    @Inject
    @Named("cacheDir")
    private File root;


    public Context getContext() {
        return context;
    }


    @SuppressWarnings("unchecked")
    private <V> V read(final File file) {
        long start = System.currentTimeMillis();
        long length = file.length();
        Object data = new RequestReader(file, FORMAT_VERSION).read();
        if (data != null)
            Log.d(TAG, MessageFormat.format(
                    "Cache hit to {0}, {1} ms to load {2} bytes",
                    file.getName(), (System.currentTimeMillis() - start),
                    length));
        return (V) data;
    }


    private AccountDataManager write(File file, Object data) {
        new RequestWriter(file, FORMAT_VERSION).write(data);
        return this;
    }


    protected Cursor query(SQLiteOpenHelper helper, String tables,
            String[] columns) {
        return query(helper, tables, columns, null, null);
    }


    protected Cursor query(SQLiteOpenHelper helper, String tables,
            String[] columns, String selection, String[] selectionArgs) {
        SQLiteQueryBuilder builder = new SQLiteQueryBuilder();
        builder.setTables(tables);
        return builder.query(helper.getReadableDatabase(), columns, selection,
                selectionArgs, null, null, null);
    }


    public List<User> getOrgs(boolean forceReload) throws IOException {
        return forceReload ? dbCache.requestAndStore(userAndOrgsResource)
                : dbCache.loadOrRequest(userAndOrgsResource);
    }


    public List<Repository> getRepos(final User user, boolean forceReload)
            throws IOException {
        OrganizationRepositories resource = allRepos.under(user);
        return forceReload ? dbCache.requestAndStore(resource) : dbCache
                .loadOrRequest(resource);
    }


    public Collection<IssueFilter> getIssueFilters() {
        final File cache = new File(root, "issue_filters.ser");
        Collection<IssueFilter> cached = read(cache);
        if (cached != null)
            return cached;
        return Collections.emptyList();
    }


    public void getIssueFilters(
            final RequestFuture<Collection<IssueFilter>> requestFuture) {
        new AuthenticatedUserTask<Collection<IssueFilter>>(context, EXECUTOR) {

            @Override
            public Collection<IssueFilter> run(Account account)
                    throws Exception {
                return getIssueFilters();
            }

            @Override
            protected void onSuccess(Collection<IssueFilter> filters)
                    throws Exception {
                requestFuture.success(filters);
            }
        }.execute();
    }


    public void addIssueFilter(IssueFilter filter) {
        final File cache = new File(root, "issue_filters.ser");
        Collection<IssueFilter> filters = read(cache);
        if (filters == null)
            filters = new HashSet<>();
        if (filters.add(filter))
            write(cache, filters);
    }


    public void addIssueFilter(final IssueFilter filter,
            final RequestFuture<IssueFilter> requestFuture) {
        new AuthenticatedUserTask<IssueFilter>(context, EXECUTOR) {

            @Override
            public IssueFilter run(Account account) throws Exception {
                addIssueFilter(filter);
                return filter;
            }

            @Override
            protected void onSuccess(IssueFilter filter) throws Exception {
                requestFuture.success(filter);
            }

            @Override
            protected void onException(Exception e) throws RuntimeException {
                Log.d(TAG, "Exception adding issue filter", e);
            }
        }.execute();
    }


    public void removeIssueFilter(IssueFilter filter) {
        final File cache = new File(root, "issue_filters.ser");
        Collection<IssueFilter> filters = read(cache);
        if (filters != null && filters.remove(filter))
            write(cache, filters);
    }


    public void removeIssueFilter(final IssueFilter filter,
            final RequestFuture<IssueFilter> requestFuture) {
        new AuthenticatedUserTask<IssueFilter>(context, EXECUTOR) {

            @Override
            public IssueFilter run(Account account) throws Exception {
                removeIssueFilter(filter);
                return filter;
            }

            @Override
            protected void onSuccess(IssueFilter filter) throws Exception {
                requestFuture.success(filter);
            }

            @Override
            protected void onException(Exception e) throws RuntimeException {
                Log.d(TAG, "Exception removing issue filter", e);
            }
        }.execute();
    }
}

<code block>

package com.github.mobile.persistence;

import android.content.ContentValues;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteQueryBuilder;

import com.github.mobile.accounts.GitHubAccount;
import com.google.inject.Inject;
import com.google.inject.Provider;
import com.google.inject.assistedinject.Assisted;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.service.RepositoryService;
import org.eclipse.egit.github.core.service.WatcherService;


public class OrganizationRepositories implements
        PersistableResource<Repository> {


    public interface Factory {


        OrganizationRepositories under(User org);
    }

    private final User org;

    private final RepositoryService repos;

    private final WatcherService watcher;

    private final Provider<GitHubAccount> accountProvider;


    @Inject
    public OrganizationRepositories(@Assisted User orgs,
            RepositoryService repos, WatcherService watcher,
            Provider<GitHubAccount> accountProvider) {
        this.org = orgs;
        this.repos = repos;
        this.watcher = watcher;
        this.accountProvider = accountProvider;
    }

    @Override
    public Cursor getCursor(SQLiteDatabase readableDatabase) {
        SQLiteQueryBuilder builder = new SQLiteQueryBuilder();
        builder.setTables("repos JOIN users ON (repos.ownerId = users.id)");
        return builder.query(readableDatabase, new String[] {
                "repos.repoId, repos.name", "users.id", "users.name",
                "users.avatarurl", "repos.private", "repos.fork",
                "repos.description", "repos.forks", "repos.watchers",
                "repos.language", "repos.hasIssues", "repos.mirrorUrl" },
                "repos.orgId=?",
                new String[] { Integer.toString(org.getId()) }, null, null,
                null);
    }

    @Override
    public Repository loadFrom(Cursor cursor) {
        Repository repo = new Repository();
        repo.setId(cursor.getLong(0));
        repo.setName(cursor.getString(1));

        User owner = new User();
        owner.setId(cursor.getInt(2));
        owner.setLogin(cursor.getString(3));
        owner.setAvatarUrl(cursor.getString(4));
        repo.setOwner(owner);

        repo.setPrivate(cursor.getInt(5) == 1);
        repo.setFork(cursor.getInt(6) == 1);
        repo.setDescription(cursor.getString(7));
        repo.setForks(cursor.getInt(8));
        repo.setWatchers(cursor.getInt(9));
        repo.setLanguage(cursor.getString(10));
        repo.setHasIssues(cursor.getInt(11) == 1);
        repo.setMirrorUrl(cursor.getString(12));

        return repo;
    }

    @Override
    public void store(SQLiteDatabase db, List<Repository> repos) {
        db.delete("repos", "orgId=?",
                new String[] { Integer.toString(org.getId()) });
        if (repos.isEmpty())
            return;

        ContentValues values = new ContentValues(12);
        for (Repository repo : repos) {
            values.clear();

            User owner = repo.getOwner();
            values.put("repoId", repo.getId());
            values.put("name", repo.getName());
            values.put("orgId", org.getId());
            values.put("ownerId", owner.getId());
            values.put("private", repo.isPrivate() ? 1 : 0);
            values.put("fork", repo.isFork() ? 1 : 0);
            values.put("description", repo.getDescription());
            values.put("forks", repo.getForks());
            values.put("watchers", repo.getWatchers());
            values.put("language", repo.getLanguage());
            values.put("hasIssues", repo.isHasIssues() ? 1 : 0);
            values.put("mirrorUrl", repo.getMirrorUrl());
            db.replace("repos", null, values);

            values.clear();

            values.put("id", owner.getId());
            values.put("name", owner.getLogin());
            values.put("avatarurl", owner.getAvatarUrl());
            db.replace("users", null, values);
        }
    }

    @Override
    public List<Repository> request() throws IOException {
        if (isAuthenticatedUser()) {
            Set<Repository> all = new TreeSet<>(
                    new Comparator<Repository>() {

                        @Override
                        public int compare(final Repository repo1,
                                final Repository repo2) {
                            final long id1 = repo1.getId();
                            final long id2 = repo2.getId();
                            if (id1 > id2)
                                return 1;
                            if (id1 < id2)
                                return -1;
                            return 0;
                        }
                    });
            all.addAll(repos.getRepositories());
            all.addAll(watcher.getWatched());
            return new ArrayList<>(all);
        } else
            return repos.getOrgRepositories(org.getLogin());
    }

    private boolean isAuthenticatedUser() {
        return org.getLogin().equals(accountProvider.get().getUsername());
    }

    @Override
    public String toString() {
        return getClass().getSimpleName() + '[' + org.getLogin() + ']';
    }
}

<code block>

package com.github.mobile.persistence;

import android.content.Context;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;

import com.google.inject.Inject;


public class CacheHelper extends SQLiteOpenHelper {


    private static final int VERSION = 8;


    private static final String NAME = "cache.db";


    @Inject
    public CacheHelper(final Context context) {
        super(context, NAME, null, VERSION);
    }

    @Override
    public void onCreate(final SQLiteDatabase db) {
        db.execSQL("CREATE TABLE orgs (id INTEGER PRIMARY KEY);");
        db.execSQL("CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, avatarurl TEXT);");
        db.execSQL("CREATE TABLE repos (id INTEGER PRIMARY KEY, repoId INTEGER, orgId INTEGER, name TEXT, ownerId INTEGER, private INTEGER, fork INTEGER, description TEXT, forks INTEGER, watchers INTEGER, language TEXT, hasIssues INTEGER, mirrorUrl TEXT);");
    }

    @Override
    public void onUpgrade(final SQLiteDatabase db, final int oldVersion,
            final int newVersion) {
        db.execSQL("DROP TABLE IF EXISTS orgs");
        db.execSQL("DROP TABLE IF EXISTS users");
        db.execSQL("DROP TABLE IF EXISTS repos");
        onCreate(db);
    }
}

<code block>

package com.github.mobile.persistence;

import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteException;
import android.database.sqlite.SQLiteOpenHelper;
import android.util.Log;

import com.google.inject.Inject;
import com.google.inject.Provider;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;


public class DatabaseCache {

    private static final String TAG = "DatabaseCache";

    @Inject
    private Provider<CacheHelper> helperProvider;


    protected SQLiteDatabase getWritable(SQLiteOpenHelper helper) {
        try {
            return helper.getWritableDatabase();
        } catch (SQLiteException e1) {

            try {
                return helper.getWritableDatabase();
            } catch (SQLiteException e2) {
                return null;
            }
        }
    }


    protected SQLiteDatabase getReadable(SQLiteOpenHelper helper) {
        try {
            return helper.getReadableDatabase();
        } catch (SQLiteException e1) {

            try {
                return helper.getReadableDatabase();
            } catch (SQLiteException e2) {
                return null;
            }
        }
    }


    public <E> List<E> loadOrRequest(PersistableResource<E> persistableResource)
            throws IOException {
        SQLiteOpenHelper helper = helperProvider.get();
        try {
            List<E> items = loadFromDB(helper, persistableResource);
            if (items != null) {
                Log.d(TAG, "CACHE HIT: Found " + items.size() + " items for "
                        + persistableResource);
                return items;
            }
            return requestAndStore(helper, persistableResource);
        } finally {
            helper.close();
        }
    }


    public <E> List<E> requestAndStore(
            PersistableResource<E> persistableResource) throws IOException {
        SQLiteOpenHelper helper = helperProvider.get();
        try {
            return requestAndStore(helper, persistableResource);
        } finally {
            helper.close();
        }
    }

    private <E> List<E> requestAndStore(final SQLiteOpenHelper helper,
            final PersistableResource<E> persistableResource)
            throws IOException {
        final List<E> items = persistableResource.request();

        final SQLiteDatabase db = getWritable(helper);
        if (db == null)
            return items;

        db.beginTransaction();
        try {
            persistableResource.store(db, items);
            db.setTransactionSuccessful();
        } finally {
            db.endTransaction();
        }
        return items;
    }

    private <E> List<E> loadFromDB(final SQLiteOpenHelper helper,
            final PersistableResource<E> persistableResource) {
        final SQLiteDatabase db = getReadable(helper);
        if (db == null)
            return null;

        Cursor cursor = persistableResource.getCursor(db);
        try {
            if (!cursor.moveToFirst())
                return null;

            List<E> cached = new ArrayList<>();
            do
                cached.add(persistableResource.loadFrom(cursor));
            while (cursor.moveToNext());
            return cached;
        } finally {
            cursor.close();
        }
    }
}

<code block>

package com.github.mobile.persistence;

import android.content.ContentValues;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteQueryBuilder;

import com.google.inject.Inject;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.service.OrganizationService;
import org.eclipse.egit.github.core.service.UserService;


public class Organizations implements PersistableResource<User> {

    private final UserService userService;

    private final OrganizationService orgService;


    @Inject
    public Organizations(OrganizationService orgService, UserService userService) {
        this.orgService = orgService;
        this.userService = userService;
    }

    @Override
    public Cursor getCursor(SQLiteDatabase readableDatabase) {
        SQLiteQueryBuilder builder = new SQLiteQueryBuilder();
        builder.setTables("orgs JOIN users ON (orgs.id = users.id)");
        return builder
                .query(readableDatabase, new String[] { "users.id",
                        "users.name", "users.avatarurl" }, null, null, null,
                        null, null);
    }

    @Override
    public User loadFrom(Cursor cursor) {
        User user = new User();
        user.setId(cursor.getInt(0));
        user.setLogin(cursor.getString(1));
        user.setAvatarUrl(cursor.getString(2));
        return user;
    }

    @Override
    public void store(SQLiteDatabase db, List<User> orgs) {
        db.delete("orgs", null, null);
        if (orgs.isEmpty())
            return;

        ContentValues values = new ContentValues(3);
        for (User user : orgs) {
            values.clear();

            values.put("id", user.getId());
            db.replace("orgs", null, values);

            values.put("name", user.getLogin());
            values.put("avatarurl", user.getAvatarUrl());
            db.replace("users", null, values);
        }
    }

    @Override
    public List<User> request() throws IOException {
        User user = userService.getUser();
        List<User> orgs = orgService.getOrganizations();
        List<User> all = new ArrayList<>(orgs.size() + 1);
        all.add(user);
        all.addAll(orgs);
        return all;
    }
}

<code block>

package com.github.mobile.persistence;

import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;

import java.io.IOException;
import java.util.List;


public interface PersistableResource<E> {


    Cursor getCursor(SQLiteDatabase readableDatabase);


    E loadFrom(Cursor cursor);


    void store(SQLiteDatabase writableDatabase, List<E> items);


    List<E> request() throws IOException;
}

<code block>

package com.github.mobile.ui;

import android.view.View;
import android.widget.BaseAdapter;
import android.widget.HeaderViewListAdapter;
import android.widget.ListView;
import android.widget.ListView.FixedViewInfo;

import java.util.ArrayList;


public class HeaderFooterListAdapter<E extends BaseAdapter> extends
        HeaderViewListAdapter {

    private final ListView list;

    private final ArrayList<FixedViewInfo> headers;

    private final ArrayList<FixedViewInfo> footers;

    private final E wrapped;


    public HeaderFooterListAdapter(ListView view, E adapter) {
        this(new ArrayList<FixedViewInfo>(), new ArrayList<FixedViewInfo>(),
                view, adapter);
    }

    private HeaderFooterListAdapter(ArrayList<FixedViewInfo> headerViewInfos,
            ArrayList<FixedViewInfo> footerViewInfos, ListView view, E adapter) {
        super(headerViewInfos, footerViewInfos, adapter);

        headers = headerViewInfos;
        footers = footerViewInfos;
        list = view;
        wrapped = adapter;
    }


    public HeaderFooterListAdapter<E> addHeader(View view) {
        return addHeader(view, null, false);
    }


    public HeaderFooterListAdapter<E> addHeader(View view, Object data,
            boolean isSelectable) {
        FixedViewInfo info = list.new FixedViewInfo();
        info.view = view;
        info.data = data;
        info.isSelectable = isSelectable;

        headers.add(info);
        wrapped.notifyDataSetChanged();
        return this;
    }


    public HeaderFooterListAdapter<E> addFooter(View view) {
        return addFooter(view, null, false);
    }


    public HeaderFooterListAdapter<E> addFooter(View view, Object data,
            boolean isSelectable) {
        FixedViewInfo info = list.new FixedViewInfo();
        info.view = view;
        info.data = data;
        info.isSelectable = isSelectable;

        footers.add(info);
        wrapped.notifyDataSetChanged();
        return this;
    }

    @Override
    public boolean removeHeader(View v) {
        boolean removed = super.removeHeader(v);
        if (removed)
            wrapped.notifyDataSetChanged();
        return removed;
    }


    public boolean clearHeaders() {
        boolean removed = false;
        if (!headers.isEmpty()) {
            FixedViewInfo[] infos = headers.toArray(new FixedViewInfo[headers
                    .size()]);
            for (FixedViewInfo info : infos)
                removed = super.removeHeader(info.view) || removed;
        }
        if (removed)
            wrapped.notifyDataSetChanged();
        return removed;
    }


    public boolean clearFooters() {
        boolean removed = false;
        if (!footers.isEmpty()) {
            FixedViewInfo[] infos = footers.toArray(new FixedViewInfo[footers
                    .size()]);
            for (FixedViewInfo info : infos)
                removed = super.removeFooter(info.view) || removed;
        }
        if (removed)
            wrapped.notifyDataSetChanged();
        return removed;
    }

    @Override
    public boolean removeFooter(View v) {
        boolean removed = super.removeFooter(v);
        if (removed)
            wrapped.notifyDataSetChanged();
        return removed;
    }

    @Override
    public E getWrappedAdapter() {
        return wrapped;
    }

    @Override
    public boolean isEmpty() {
        return wrapped.isEmpty();
    }
}

<code block>

package com.github.mobile.ui;

import android.os.Bundle;

import com.github.kevinsawicki.wishlist.ViewFinder;
import com.github.mobile.ui.roboactivities.RoboActionBarActivity;

import java.io.Serializable;


public class BaseActivity extends RoboActionBarActivity {


    protected ViewFinder finder;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        finder = new ViewFinder(this);
    }


    @SuppressWarnings("unchecked")
    protected <V extends Serializable> V getSerializableExtra(final String name) {
        return (V) getIntent().getSerializableExtra(name);
    }


    protected int getIntExtra(final String name) {
        return getIntent().getIntExtra(name, -1);
    }


    protected String getStringExtra(final String name) {
        return getIntent().getStringExtra(name);
    }


    protected String[] getStringArrayExtra(final String name) {
        return getIntent().getStringArrayExtra(name);
    }
}

<code block>

package com.github.mobile.ui;

import static org.eclipse.egit.github.core.service.MarkdownService.MODE_GFM;
import android.accounts.Account;
import android.content.Context;
import android.text.Html.ImageGetter;
import android.util.Log;

import com.github.mobile.accounts.AuthenticatedUserLoader;
import com.github.mobile.util.HtmlUtils;
import com.google.inject.Inject;

import java.io.IOException;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.service.MarkdownService;


public class MarkdownLoader extends AuthenticatedUserLoader<CharSequence> {

    private static final String TAG = "MarkdownLoader";

    private final ImageGetter imageGetter;

    private final IRepositoryIdProvider repository;

    private final String raw;

    private boolean encode;

    @Inject
    private MarkdownService service;


    public MarkdownLoader(Context context, IRepositoryIdProvider repository,
            String raw, ImageGetter imageGetter, boolean encode) {
        super(context);

        this.repository = repository;
        this.raw = raw;
        this.imageGetter = imageGetter;
        this.encode = encode;
    }

    @Override
    protected CharSequence getAccountFailureData() {
        return null;
    }

    @Override
    public CharSequence load(Account account) {
        try {
            String html;
            if (repository != null)
                html = service.getRepositoryHtml(repository, raw);
            else
                html = service.getHtml(raw, MODE_GFM);

            if (encode)
                return HtmlUtils.encode(html, imageGetter);
            else
                return html;
        } catch (IOException e) {
            Log.d(TAG, "Loading rendered markdown failed", e);
            return null;
        }
    }
}

<code block>

package com.github.mobile.ui;

import static android.content.Intent.ACTION_VIEW;
import static android.content.Intent.CATEGORY_BROWSABLE;
import static org.eclipse.egit.github.core.event.Event.TYPE_COMMIT_COMMENT;
import static org.eclipse.egit.github.core.event.Event.TYPE_DOWNLOAD;
import static org.eclipse.egit.github.core.event.Event.TYPE_PUSH;
import android.app.AlertDialog;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.text.TextUtils;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.ListView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.kevinsawicki.wishlist.ViewFinder;
import com.github.mobile.R;
import com.github.mobile.core.gist.GistEventMatcher;
import com.github.mobile.core.issue.IssueEventMatcher;
import com.github.mobile.core.repo.RepositoryEventMatcher;
import com.github.mobile.core.user.UserEventMatcher;
import com.github.mobile.core.user.UserEventMatcher.UserPair;
import com.github.mobile.ui.commit.CommitCompareViewActivity;
import com.github.mobile.ui.commit.CommitViewActivity;
import com.github.mobile.ui.gist.GistsViewActivity;
import com.github.mobile.ui.issue.IssuesViewActivity;
import com.github.mobile.ui.repo.RepositoryViewActivity;
import com.github.mobile.ui.user.NewsListAdapter;
import com.github.mobile.util.AvatarLoader;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.egit.github.core.Commit;
import org.eclipse.egit.github.core.CommitComment;
import org.eclipse.egit.github.core.Download;
import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.event.CommitCommentPayload;
import org.eclipse.egit.github.core.event.DownloadPayload;
import org.eclipse.egit.github.core.event.Event;
import org.eclipse.egit.github.core.event.PushPayload;
import org.eclipse.egit.github.core.service.EventService;


public abstract class NewsFragment extends PagedItemFragment<Event> {


    protected final IssueEventMatcher issueMatcher = new IssueEventMatcher();


    protected final GistEventMatcher gistMatcher = new GistEventMatcher();


    protected final RepositoryEventMatcher repoMatcher = new RepositoryEventMatcher();


    protected final UserEventMatcher userMatcher = new UserEventMatcher();

    @Inject
    private AvatarLoader avatars;


    @Inject
    protected EventService service;

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        setEmptyText(R.string.no_news);
    }

    @Override
    public void onListItemClick(ListView l, View v, int position, long id) {
        Event event = (Event) l.getItemAtPosition(position);

        if (TYPE_DOWNLOAD.equals(event.getType())) {
            openDownload(event);
            return;
        }

        if (TYPE_PUSH.equals(event.getType())) {
            openPush(event);
            return;
        }

        if (TYPE_COMMIT_COMMENT.equals(event.getType())) {
            openCommitComment(event);
            return;
        }

        Issue issue = issueMatcher.getIssue(event);
        if (issue != null) {
            Repository repo = RepositoryEventMatcher.getRepository(
                    event.getRepo(), event.getActor(), event.getOrg());
            viewIssue(issue, repo);
            return;
        }

        Gist gist = gistMatcher.getGist(event);
        if (gist != null) {
            startActivity(GistsViewActivity.createIntent(gist));
            return;
        }

        Repository repo = repoMatcher.getRepository(event);
        if (repo != null)
            viewRepository(repo);

        UserPair users = userMatcher.getUsers(event);
        if (users != null)
            viewUser(users);
    }

    @Override
    public boolean onListItemLongClick(ListView l, View v, int position,
            long itemId) {
        if (!isUsable())
            return false;

        final Event event = (Event) l.getItemAtPosition(position);
        final Repository repo = RepositoryEventMatcher.getRepository(
                event.getRepo(), event.getActor(), event.getOrg());
        final User user = event.getActor();

        if (repo != null && user != null) {
            final AlertDialog dialog = LightAlertDialog.create(getActivity());
            dialog.setTitle(R.string.navigate_to);
            dialog.setCanceledOnTouchOutside(true);

            View view = getActivity().getLayoutInflater().inflate(
                    R.layout.nav_dialog, null);
            ViewFinder finder = new ViewFinder(view);
            avatars.bind(finder.imageView(R.id.iv_user_avatar), user);
            avatars.bind(finder.imageView(R.id.iv_repo_avatar), repo.getOwner());
            finder.setText(R.id.tv_login, user.getLogin());
            finder.setText(R.id.tv_repo_name, repo.generateId());
            finder.onClick(R.id.ll_user_area, new OnClickListener() {

                public void onClick(View v) {
                    dialog.dismiss();

                    viewUser(user);
                }
            });
            finder.onClick(R.id.ll_repo_area, new OnClickListener() {

                public void onClick(View v) {
                    dialog.dismiss();

                    viewRepository(repo);
                }
            });
            dialog.setView(view);
            dialog.show();

            return true;
        }

        return false;
    }

    private void openDownload(Event event) {
        Download download = ((DownloadPayload) event.getPayload())
                .getDownload();
        if (download == null)
            return;

        String url = download.getHtmlUrl();
        if (TextUtils.isEmpty(url))
            return;

        Intent intent = new Intent(ACTION_VIEW, Uri.parse(url));
        intent.addCategory(CATEGORY_BROWSABLE);
        startActivity(intent);
    }

    private void openCommitComment(Event event) {
        Repository repo = RepositoryEventMatcher.getRepository(event.getRepo(),
                event.getActor(), event.getOrg());
        if (repo == null)
            return;

        CommitCommentPayload payload = (CommitCommentPayload) event
                .getPayload();
        CommitComment comment = payload.getComment();
        if (comment == null)
            return;

        String sha = comment.getCommitId();
        if (!TextUtils.isEmpty(sha))
            startActivity(CommitViewActivity.createIntent(repo, sha));
    }

    private void openPush(Event event) {
        Repository repo = RepositoryEventMatcher.getRepository(event.getRepo(),
                event.getActor(), event.getOrg());
        if (repo == null)
            return;

        PushPayload payload = (PushPayload) event.getPayload();
        List<Commit> commits = payload.getCommits();
        if (commits == null || commits.isEmpty())
            return;

        if (commits.size() > 1) {
            String base = payload.getBefore();
            String head = payload.getHead();
            if (!TextUtils.isEmpty(base) && !TextUtils.isEmpty(head))
                startActivity(CommitCompareViewActivity.createIntent(repo,
                        base, head));
        } else {
            Commit commit = commits.get(0);
            String sha = commit != null ? commit.getSha() : null;
            if (!TextUtils.isEmpty(sha))
                startActivity(CommitViewActivity.createIntent(repo, sha));
        }
    }


    protected void viewRepository(Repository repository) {
        startActivity(RepositoryViewActivity.createIntent(repository));
    }


    protected void viewUser(UserPair users) {
    }


    protected boolean viewUser(User user) {
        return false;
    }


    protected void viewIssue(Issue issue, Repository repository) {
        if (repository != null)
            startActivity(IssuesViewActivity.createIntent(issue, repository));
        else
            startActivity(IssuesViewActivity.createIntent(issue));
    }

    @Override
    protected SingleTypeAdapter<Event> createAdapter(List<Event> items) {
        return new NewsListAdapter(getActivity().getLayoutInflater(),
                items.toArray(new Event[items.size()]), avatars);
    }

    @Override
    protected int getLoadingMessage() {
        return R.string.loading_news;
    }

    @Override
    protected int getErrorMessage(Exception exception) {
        return R.string.error_news_load;
    }
}

<code block>

package com.github.mobile.ui;

import android.app.Activity;
import android.os.Bundle;
import android.support.v4.app.LoaderManager.LoaderCallbacks;
import android.support.v4.content.Loader;
import android.support.v4.widget.SwipeRefreshLayout;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.animation.AnimationUtils;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.AdapterView.OnItemLongClickListener;
import android.widget.ListAdapter;
import android.widget.ListView;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.Toast;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.mobile.R;
import com.github.mobile.ThrowableLoader;
import com.github.mobile.util.ToastUtils;

import java.util.Collections;
import java.util.List;


public abstract class ItemListFragment<E> extends DialogFragment implements
        LoaderCallbacks<List<E>>, SwipeRefreshLayout.OnRefreshListener {

    private static final String FORCE_REFRESH = "forceRefresh";

    private SwipeRefreshLayout swipeLayout;


    protected static boolean isForceRefresh(Bundle args) {
        return args != null && args.getBoolean(FORCE_REFRESH, false);
    }


    protected List<E> items = Collections.emptyList();


    protected ListView listView;


    protected TextView emptyView;


    protected ProgressBar progressBar;


    protected boolean listShown;

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        if (!items.isEmpty())
            setListShown(true, false);

        getLoaderManager().initLoader(0, null, this);
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        return inflater.inflate(R.layout.item_list, null);
    }

    @Override
    public void onRefresh() {
        forceRefresh();
    }


    @Override
    public void onDestroyView() {
        listShown = false;
        emptyView = null;
        progressBar = null;
        listView = null;

        super.onDestroyView();
    }

    @Override
    public void onViewCreated(View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        swipeLayout = (SwipeRefreshLayout) view.findViewById(R.id.swipe_item);
        swipeLayout.setOnRefreshListener(this);
        swipeLayout.setColorSchemeResources(
                R.color.pager_title_background_top_start,
                R.color.pager_title_background_end,
                R.color.text_link,
                R.color.pager_title_background_end);

        listView = (ListView) view.findViewById(android.R.id.list);
        listView.setOnItemClickListener(new OnItemClickListener() {

            @Override
            public void onItemClick(AdapterView<?> parent, View view,
                    int position, long id) {
                onListItemClick((ListView) parent, view, position, id);
            }
        });
        listView.setOnItemLongClickListener(new OnItemLongClickListener() {

            @Override
            public boolean onItemLongClick(AdapterView<?> parent, View view,
                    int position, long id) {
                return onListItemLongClick((ListView) parent, view, position,
                        id);
            }
        });
        progressBar = (ProgressBar) view.findViewById(R.id.pb_loading);

        emptyView = (TextView) view.findViewById(android.R.id.empty);

        configureList(getActivity(), getListView());
    }

    @Override
    public void onResume() {
        super.onResume();
        refreshWithProgress();
    }


    protected void configureList(Activity activity, ListView listView) {
        listView.setAdapter(createAdapter());
    }


    protected void forceRefresh() {
        Bundle bundle = new Bundle();
        bundle.putBoolean(FORCE_REFRESH, true);
        refresh(bundle);
    }


    public void refresh() {
        refresh(null);
    }

    private void refresh(final Bundle args) {
        if (!isUsable())
            return;

        getLoaderManager().restartLoader(0, args, this);
    }


    protected abstract int getErrorMessage(Exception exception);

    public void onLoadFinished(Loader<List<E>> loader, List<E> items) {
        if (!isUsable())
            return;

        swipeLayout.setRefreshing(false);
        Exception exception = getException(loader);
        if (exception != null) {
            showError(exception, getErrorMessage(exception));
            showList();
            return;
        }

        this.items = items;
        getListAdapter().getWrappedAdapter().setItems(items.toArray());
        showList();
    }


    protected HeaderFooterListAdapter<SingleTypeAdapter<E>> createAdapter() {
        SingleTypeAdapter<E> wrapped = createAdapter(items);
        return new HeaderFooterListAdapter<>(getListView(),
                wrapped);
    }


    protected abstract SingleTypeAdapter<E> createAdapter(final List<E> items);


    protected void showList() {
        setListShown(true, isResumed());
    }

    @Override
    public void onLoaderReset(Loader<List<E>> loader) {

    }


    protected void showError(final Exception e, final int defaultMessage) {
        ToastUtils.show(getActivity(), e, defaultMessage);
    }


    protected Exception getException(final Loader<List<E>> loader) {
        if (loader instanceof ThrowableLoader)
            return ((ThrowableLoader<List<E>>) loader).clearException();
        else
            return null;
    }


    protected void refreshWithProgress() {
        items.clear();
        setListShown(false);
        refresh();
    }


    public ListView getListView() {
        return listView;
    }


    @SuppressWarnings("unchecked")
    protected HeaderFooterListAdapter<SingleTypeAdapter<E>> getListAdapter() {
        if (listView != null)
            return (HeaderFooterListAdapter<SingleTypeAdapter<E>>) listView
                    .getAdapter();
        else
            return null;
    }


    protected ItemListFragment<E> notifyDataSetChanged() {
        HeaderFooterListAdapter<SingleTypeAdapter<E>> root = getListAdapter();
        if (root != null) {
            SingleTypeAdapter<E> typeAdapter = root.getWrappedAdapter();
            if (typeAdapter != null)
                typeAdapter.notifyDataSetChanged();
        }
        return this;
    }


    protected ItemListFragment<E> setListAdapter(final ListAdapter adapter) {
        if (listView != null)
            listView.setAdapter(adapter);
        return this;
    }

    private ItemListFragment<E> fadeIn(final View view, final boolean animate) {
        if (view != null)
            if (animate)
                view.startAnimation(AnimationUtils.loadAnimation(getActivity(),
                        android.R.anim.fade_in));
            else
                view.clearAnimation();
        return this;
    }

    private ItemListFragment<E> show(final View view) {
        ViewUtils.setGone(view, false);
        return this;
    }

    private ItemListFragment<E> hide(final View view) {
        ViewUtils.setGone(view, true);
        return this;
    }


    public ItemListFragment<E> setListShown(final boolean shown) {
        return setListShown(shown, true);
    }


    public ItemListFragment<E> setListShown(final boolean shown,
            final boolean animate) {
        if (!isUsable())
            return this;

        if (shown == listShown) {
            if (shown)


                if (items.isEmpty())
                    hide(listView).show(emptyView);
                else
                    hide(emptyView).show(listView);
            return this;
        }

        listShown = shown;

        if (shown)
            if (!items.isEmpty())
                hide(progressBar).hide(emptyView).fadeIn(listView, animate)
                        .show(listView);
            else
                hide(progressBar).hide(listView).fadeIn(emptyView, animate)
                        .show(emptyView);
        else
            hide(listView).hide(emptyView).fadeIn(progressBar, animate)
                    .show(progressBar);

        return this;
    }


    protected ItemListFragment<E> setEmptyText(final String message) {
        if (emptyView != null)
            emptyView.setText(message);
        return this;
    }


    protected ItemListFragment<E> setEmptyText(final int resId) {
        if (emptyView != null)
            emptyView.setText(resId);
        return this;
    }


    public void onListItemClick(ListView l, View v, int position, long id) {
    }


    public boolean onListItemLongClick(ListView l, View v, int position, long id) {
        return false;
    }
}

<code block>

package com.github.mobile.ui;

import android.text.NoCopySpan;
import android.text.Spannable;
import android.text.method.LinkMovementMethod;
import android.text.method.MovementMethod;
import android.view.MotionEvent;
import android.widget.TextView;

public class SelectableLinkMovementMethod extends LinkMovementMethod {
    private static final int CLICK = 1;
    private static final int UP = 2;
    private static final int DOWN = 3;

    private static SelectableLinkMovementMethod sInstance;
    private static Object FROM_BELOW = new NoCopySpan.Concrete();

    public static MovementMethod getInstance() {
        if (sInstance == null) {
            sInstance = new SelectableLinkMovementMethod();
        }

        return sInstance;
    }



    @Override
    public boolean canSelectArbitrarily() {
        return true;
    }


    @Override
    public boolean onTouchEvent(TextView widget, Spannable buffer,
        MotionEvent event) {
        return true;
    }


}

<code block>

package com.github.mobile.ui;

import android.app.Activity;
import android.os.Bundle;
import android.view.View;

import com.github.kevinsawicki.wishlist.ViewFinder;
import com.github.mobile.ui.roboactivities.RoboSupportFragment;

import java.io.Serializable;


public abstract class DialogFragment extends RoboSupportFragment implements
        DialogResultListener {


    protected ViewFinder finder;


    protected boolean isUsable() {
        return getActivity() != null;
    }

    @Override
    public void onDialogResult(int requestCode, int resultCode, Bundle arguments) {

    }


    @SuppressWarnings("unchecked")
    protected <V extends Serializable> V getSerializableExtra(final String name) {
        Activity activity = getActivity();
        if (activity != null)
            return (V) activity.getIntent().getSerializableExtra(name);
        else
            return null;
    }


    protected String getStringExtra(final String name) {
        Activity activity = getActivity();
        if (activity != null)
            return activity.getIntent().getStringExtra(name);
        else
            return null;
    }

    @Override
    public void onViewCreated(View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        finder = new ViewFinder(view);
    }
}

<code block>

package com.github.mobile.ui;

import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentTransaction;
import android.support.v7.app.ActionBarActivity;
import android.view.ViewGroup;

import java.util.HashSet;
import java.util.Set;


public abstract class FragmentPagerAdapter extends
    android.support.v4.app.FragmentPagerAdapter implements FragmentProvider {

    private final ActionBarActivity activity;

    private final FragmentManager fragmentManager;

    private Fragment selected;

    private final Set<String> tags = new HashSet<>();


    public FragmentPagerAdapter(ActionBarActivity activity) {
        super(activity.getSupportFragmentManager());

        fragmentManager = activity.getSupportFragmentManager();
        this.activity = activity;
    }

    public FragmentPagerAdapter(Fragment fragment) {
        super(fragment.getChildFragmentManager());

        fragmentManager = fragment.getChildFragmentManager();
        this.activity = (ActionBarActivity) fragment.getActivity();
    }

    public boolean isEmpty() {
        return tags.isEmpty();
    }


    public FragmentPagerAdapter clearAdapter() {
        if (tags.isEmpty())
            return this;

        FragmentTransaction transaction = fragmentManager.beginTransaction();
        for (String tag : tags) {
            Fragment fragment = fragmentManager.findFragmentByTag(tag);
            if (fragment != null)
                transaction.remove(fragment);
        }
        transaction.commit();
        tags.clear();

        return this;
    }

    @Override
    public Fragment getSelected() {
        return selected;
    }

    public Object instantiateItem(ViewGroup container, int position) {
        Object fragment = super.instantiateItem(container, position);
        if (fragment instanceof Fragment)
            tags.add(((Fragment) fragment).getTag());
        return fragment;
    }

    @Override
    public void setPrimaryItem(final ViewGroup container, final int position,
        final Object object) {
        super.setPrimaryItem(container, position, object);

        boolean changed = false;
        if (object instanceof Fragment) {
            changed = object != selected;
            selected = (Fragment) object;
        } else {
            changed = object != null;
            selected = null;
        }

        if (changed)
            activity.invalidateOptionsMenu();
    }
}

<code block>

package com.github.mobile.ui;

import android.app.AlertDialog;
import android.content.Context;


public class LightAlertDialog extends AlertDialog {


    public static AlertDialog create(final Context context) {
        return new LightAlertDialog(context, THEME_HOLO_LIGHT);
    }

    private LightAlertDialog(final Context context, final int theme) {
        super(context, theme);
    }

    private LightAlertDialog(final Context context) {
        super(context);
    }


    public static class Builder extends AlertDialog.Builder {


        public static LightAlertDialog.Builder create(final Context context) {
            return new LightAlertDialog.Builder(context, THEME_HOLO_LIGHT);
        }

        private Builder(Context context) {
            super(context);
        }

        private Builder(Context context, int theme) {
            super(context, theme);
        }
    }
}

<code block>

package com.github.mobile.ui;

import android.content.Context;
import android.util.AttributeSet;
import android.view.View;


public class ViewPager extends android.support.v4.view.ViewPager {


    public ViewPager(final Context context) {
        super(context);
    }


    public ViewPager(final Context context, final AttributeSet attrs) {
        super(context, attrs);
    }


    public boolean setItem(final int item) {
        final boolean changed = item != getCurrentItem();
        if (changed)
            setCurrentItem(item, false);
        return changed;
    }


    public boolean setItem(final int item, final OnPageChangeListener listener) {
        final boolean changed = setItem(item);
        if (changed && listener != null)
            listener.onPageSelected(item);
        return changed;
    }


    public void scheduleSetItem(final int item,
                                final OnPageChangeListener listener) {
        post(new Runnable() {

            @Override
            public void run() {
                setItem(item, listener);
            }
        });
    }


    public void scheduleSetItem(final int item) {
        post(new Runnable() {

            @Override
            public void run() {
                setItem(item);
            }
        });
    }

    @Override
    protected boolean canScroll(final View v, final boolean checkV,
                                final int dx, final int x, final int y) {
        return super.canScroll(v, checkV, dx, x, y);
    }
}

<code block>

package com.github.mobile.ui;

import static android.app.Activity.RESULT_CANCELED;
import android.app.AlertDialog;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentActivity;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentTransaction;

import roboguice.fragment.RoboDialogFragment;


public abstract class DialogFragmentHelper extends RoboDialogFragment implements
    OnClickListener {


    private static final String ARG_TITLE = "title";


    private static final String ARG_MESSAGE = "message";


    private static final String ARG_REQUEST_CODE = "requestCode";


    protected static void show(FragmentActivity activity,
        DialogFragmentHelper fragment, Bundle arguments, String tag) {
        FragmentManager manager = activity.getSupportFragmentManager();
        FragmentTransaction transaction = manager.beginTransaction();
        Fragment current = manager.findFragmentByTag(tag);
        if (current != null)
            transaction.remove(current);
        transaction.addToBackStack(null);

        fragment.setArguments(arguments);
        fragment.show(manager, tag);
    }


    protected static Bundle createArguments(final String title,
        final String message, final int requestCode) {
        Bundle arguments = new Bundle();
        arguments.putInt(ARG_REQUEST_CODE, requestCode);
        arguments.putString(ARG_TITLE, title);
        arguments.putString(ARG_MESSAGE, message);
        return arguments;
    }


    protected void onResult(final int resultCode) {
        final DialogFragmentActivity activity = (DialogFragmentActivity) getActivity();
        if (activity != null) {
            final Bundle arguments = getArguments();
            if (arguments != null)
                activity.onDialogResult(arguments.getInt(ARG_REQUEST_CODE),
                    resultCode, arguments);
        }
    }


    protected String getTitle() {
        return getArguments().getString(ARG_TITLE);
    }


    protected String getMessage() {
        return getArguments().getString(ARG_MESSAGE);
    }

    @Override
    public void onCancel(DialogInterface dialog) {
        onResult(RESULT_CANCELED);
    }


    protected AlertDialog createDialog() {
        final AlertDialog dialog = LightAlertDialog.create(getActivity());
        dialog.setTitle(getTitle());
        dialog.setMessage(getMessage());
        dialog.setCancelable(true);
        dialog.setOnCancelListener(this);
        return dialog;
    }

    @Override
    public void onClick(DialogInterface dialog, int which) {
        dialog.dismiss();
    }
}

<code block>
package com.github.mobile.ui;


import android.app.Activity;
import android.content.Context;
import android.content.SharedPreferences;
import android.content.res.Configuration;
import android.graphics.Point;
import android.os.Bundle;
import android.preference.PreferenceManager;
import android.support.annotation.Nullable;
import android.support.v4.app.Fragment;
import android.support.v4.widget.DrawerLayout;
import android.support.v7.app.ActionBar;
import android.support.v7.app.ActionBarActivity;
import android.support.v7.app.ActionBarDrawerToggle;
import android.view.Display;
import android.view.LayoutInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.view.WindowManager;
import android.widget.AdapterView;
import android.widget.ImageView;
import android.widget.ListView;
import android.widget.TextView;

import com.github.mobile.R;
import com.github.mobile.util.AvatarLoader;

import org.eclipse.egit.github.core.User;

public class NavigationDrawerFragment extends Fragment implements AdapterView.OnItemClickListener {

    private static final String STATE_SELECTED_POSITION = "selected_navigation_drawer_position";
    private static final String PREF_USER_LEARNED_DRAWER = "navigation_drawer_learned";

    private NavigationDrawerCallbacks mCallbacks;
    private ActionBarDrawerToggle mDrawerToggle;

    private DrawerLayout mDrawerLayout;
    private ListView mDrawerListView;
    private View mFragmentContainerView;

    private int mCurrentSelectedPosition = 1;
    private boolean mFromSavedInstanceState;
    private boolean mUserLearnedDrawer;

    private ImageView userImage;
    private TextView userRealName;
    private TextView userName;

    public NavigationDrawerFragment() {
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getActivity());
        mUserLearnedDrawer = sp.getBoolean(PREF_USER_LEARNED_DRAWER, false);

        if (savedInstanceState != null) {
            mCurrentSelectedPosition = savedInstanceState.getInt(STATE_SELECTED_POSITION);
            mFromSavedInstanceState = true;
        }
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        setHasOptionsMenu(true);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if (item.getItemId() == android.R.id.home) {
            if (isDrawerOpen())
                mDrawerLayout.closeDrawer(mFragmentContainerView);
            else
                mDrawerLayout.openDrawer(mFragmentContainerView);
        }
        return super.onOptionsItemSelected(item);
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        return inflater.inflate(R.layout.fragment_navigation_drawer, container, false);
    }

    @Override
    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        mDrawerListView = (ListView) view.findViewById(R.id.navigation_drawer_list);
        mDrawerListView.setOnItemClickListener(this);
    }

    public boolean isDrawerOpen() {
        return mDrawerLayout != null && mDrawerLayout.isDrawerOpen(mFragmentContainerView);
    }

    public void setUp(int fragmentId, DrawerLayout drawerLayout, NavigationDrawerAdapter adapter, AvatarLoader avatar,
        User user) {
        mFragmentContainerView = getActivity().findViewById(fragmentId);
        mDrawerLayout = drawerLayout;


        int drawerWidth = checkTabletOrLandscape() ? R.dimen.navigation_drawer_width : materializedWidth();
        mDrawerListView.getLayoutParams().width = drawerWidth;


        View header = getActivity().getLayoutInflater().inflate(R.layout.drawer_header, mDrawerListView, false);
        userImage = (ImageView) header.findViewById(R.id.user_picture);
        userRealName = (TextView) header.findViewById(R.id.user_real_name);
        userName = (TextView) header.findViewById(R.id.user_name);

        avatar.bind(userImage, user);
        userName.setText(user.getLogin());

        String name = user.getName();
        if (name != null) {
            userRealName.setText(user.getName());
        } else {
            userRealName.setVisibility(View.GONE);
        }

        mDrawerListView.addHeaderView(header, null, false);
        mDrawerListView.setAdapter(adapter);
        mDrawerListView.setItemChecked(mCurrentSelectedPosition, true);

        ActionBar actionBar = getActionBar();
        actionBar.setDisplayHomeAsUpEnabled(true);
        actionBar.setHomeButtonEnabled(true);

        mDrawerToggle = new ActionBarDrawerToggle(
            getActivity(), mDrawerLayout,
            R.string.navigation_drawer_open,
            R.string.navigation_drawer_close) {
            @Override
            public void onDrawerClosed(View drawerView) {
                super.onDrawerClosed(drawerView);
                if (!isAdded()) {
                    return;
                }

                getActivity().supportInvalidateOptionsMenu();
            }

            @Override
            public void onDrawerOpened(View drawerView) {
                super.onDrawerOpened(drawerView);
                if (!isAdded()) {
                    return;
                }

                if (!mUserLearnedDrawer) {
                    mUserLearnedDrawer = true;
                    SharedPreferences sp = PreferenceManager
                        .getDefaultSharedPreferences(getActivity());
                    sp.edit().putBoolean(PREF_USER_LEARNED_DRAWER, true).apply();
                }

                getActivity().supportInvalidateOptionsMenu();
            }
        };

        if (!mUserLearnedDrawer && !mFromSavedInstanceState)
            mDrawerLayout.openDrawer(mFragmentContainerView);

        mDrawerLayout.post(new Runnable() {
            @Override
            public void run() {
                mDrawerToggle.syncState();
            }
        });

        mDrawerLayout.setDrawerListener(mDrawerToggle);

    }

    private void selectItem(int position) {
        if (mCallbacks != null && mDrawerListView != null && position != mCurrentSelectedPosition)
            mCallbacks.onNavigationDrawerItemSelected(position);
        if (mDrawerListView != null) mDrawerListView.setItemChecked(position, true);
        if (mDrawerLayout != null) mDrawerLayout.closeDrawer(mFragmentContainerView);
        mCurrentSelectedPosition = position;
    }

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);
        try {
            mCallbacks = (NavigationDrawerCallbacks) activity;
        } catch (ClassCastException e) {
            throw new ClassCastException("Activity must implement NavigationDrawerCallbacks.");
        }
    }

    @Override
    public void onDetach() {
        super.onDetach();
        mCallbacks = null;
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        outState.putInt(STATE_SELECTED_POSITION, mCurrentSelectedPosition);
    }

    @Override
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        mDrawerToggle.onConfigurationChanged(newConfig);
    }

    private ActionBar getActionBar() {
        return ((ActionBarActivity) getActivity()).getSupportActionBar();
    }

    @Override
    public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
        selectItem(position);
    }

    public static interface NavigationDrawerCallbacks {
        void onNavigationDrawerItemSelected(int position);
    }

    public boolean checkTabletOrLandscape() {
        boolean landscape = getActivity().getResources()
                                         .getConfiguration()
                                         .orientation == Configuration.ORIENTATION_LANDSCAPE;
        boolean tablet =
                (getActivity().getResources().getConfiguration().screenLayout & Configuration.SCREENLAYOUT_SIZE_MASK)
                == Configuration.SCREENLAYOUT_SIZE_XLARGE;

        return landscape || tablet;
    }

    public int materializedWidth() {

        WindowManager wm = (WindowManager) getActivity().getSystemService(Context.WINDOW_SERVICE);
        Display display = wm.getDefaultDisplay();
        Point screenSize = new Point();
        display.getSize(screenSize);

        int actionBarHeight = getActionBar().getHeight();

        return screenSize.x - actionBarHeight;

    }
}

<code block>

package com.github.mobile.ui;

import android.content.Context;
import android.util.AttributeSet;


public class WebView extends android.webkit.WebView {


    public WebView(final Context context, final AttributeSet attrs,
                   final int defStyle, final boolean privateBrowsing) {
        super(context, attrs, defStyle, privateBrowsing);
    }


    public WebView(final Context context, final AttributeSet attrs,
                   final int defStyle) {
        super(context, attrs, defStyle);
    }


    public WebView(final Context context, final AttributeSet attrs) {
        super(context, attrs);
    }


    public WebView(final Context context) {
        super(context);
    }

    private boolean canScrollCodeHorizontally(final int direction) {
        final int range = computeHorizontalScrollRange()
                - computeHorizontalScrollExtent();
        if (range == 0)
            return false;

        if (direction < 0)
            return computeHorizontalScrollOffset() > 0;
        else
            return computeHorizontalScrollOffset() < range - 1;
    }

    @Override
    public boolean canScrollHorizontally(final int direction) {
        return super.canScrollHorizontally(direction);
    }
}

<code block>

package com.github.mobile.ui;

import android.support.v4.app.Fragment;
import android.support.v7.app.ActionBarActivity;
import android.view.ViewGroup;


public abstract class FragmentStatePagerAdapter extends
    android.support.v4.app.FragmentStatePagerAdapter implements
    FragmentProvider {

    private final ActionBarActivity activity;

    private Fragment selected;


    public FragmentStatePagerAdapter(final ActionBarActivity activity) {
        super(activity.getSupportFragmentManager());

        this.activity = activity;
    }


    public FragmentStatePagerAdapter(final Fragment fragment) {
        super(fragment.getChildFragmentManager());

        this.activity = (ActionBarActivity) fragment.getActivity();
    }

    @Override
    public Fragment getSelected() {
        return selected;
    }

    @Override
    public void setPrimaryItem(final ViewGroup container, final int position,
        final Object object) {
        super.setPrimaryItem(container, position, object);

        boolean changed = false;
        if (object instanceof Fragment) {
            changed = object != selected;
            selected = (Fragment) object;
        } else {
            changed = object != null;
            selected = null;
        }

        if (changed)
            activity.invalidateOptionsMenu();
    }
}

<code block>
package com.github.mobile.ui;

import static com.github.mobile.ui.NavigationDrawerObject.TYPE_ITEM_MENU;
import static com.github.mobile.ui.NavigationDrawerObject.TYPE_ITEM_ORG;
import static com.github.mobile.ui.NavigationDrawerObject.TYPE_SEPERATOR;
import static com.github.mobile.ui.NavigationDrawerObject.TYPE_SUBHEADER;
import android.content.Context;
import android.graphics.Typeface;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.ImageView;
import android.widget.TextView;

import com.github.mobile.R;
import com.github.mobile.util.AvatarLoader;

import java.util.ArrayList;
import java.util.List;

import org.eclipse.egit.github.core.User;

public class NavigationDrawerAdapter extends BaseAdapter {

    private final Context context;
    private final AvatarLoader avatars;
    private final LayoutInflater inflater;
    private List<User> orgs = new ArrayList<>();
    private List<NavigationDrawerObject> data;

    public NavigationDrawerAdapter(Context context, List<User> orgs, final AvatarLoader avatars) {
        this.orgs.addAll(orgs);
        this.context = context;
        this.inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        this.avatars = avatars;
        createData();
    }

    private void createData() {
        orgs.remove(0);
        String[] names = new String[] { context.getString(R.string.home), context.getString(R.string.gist),
            context.getString(R.string.issue_dashboard), context.getString(R.string.bookmarks) };
        String[] icons = context.getResources().getStringArray(R.array.navigation_drawer_icon_list);
        data = new ArrayList<>();
        int amount = names.length + orgs.size() + 2;
        for (int i = 0; i < amount; i++) {
            if (i < names.length)
                data.add(new NavigationDrawerObject(names[i], icons[i], TYPE_ITEM_MENU));
            else if (i == names.length)
                data.add(new NavigationDrawerObject(TYPE_SEPERATOR));
            else if (i == names.length + 1)
                data.add(new NavigationDrawerObject("Organizations", TYPE_SUBHEADER));
            else
                data.add(new NavigationDrawerObject(orgs.get(i - names.length - 2).getLogin(), TYPE_ITEM_ORG,
                    orgs.get(i - names.length - 2)));
        }
    }

    public void setOrgs(List<User> orgs) {
        this.orgs.addAll(orgs);
        this.orgs.remove(0);
        notifyDataSetChanged();
    }

    @Override
    public int getCount() {
        return data.size();
    }

    @Override
    public NavigationDrawerObject getItem(int position) {
        return data.get(position-1);
    }

    @Override
    public long getItemId(int position) {
        return data.get(position).getType();
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        ViewHolder viewHolder;
        final NavigationDrawerObject obj = data.get(position);
        if (convertView == null || obj.getType() != ((ViewHolder) convertView.getTag()).type) {
            viewHolder = new ViewHolder();
            switch (obj.getType()) {
                case TYPE_ITEM_MENU:
                    convertView = inflater.inflate(R.layout.navigation_drawer_list_item_text, parent, false);
                    viewHolder.name = (TextView) convertView.findViewById(R.id.navigation_drawer_item_name);
                    viewHolder.iconString = (TextView) convertView.findViewById(R.id.navigation_drawer_item_text_icon);
                    break;
                case TYPE_ITEM_ORG:
                    convertView = inflater.inflate(R.layout.navigation_drawer_list_item_image, parent, false);
                    viewHolder.name = (TextView) convertView.findViewById(R.id.navigation_drawer_item_name);
                    viewHolder.iconDrawable = (ImageView) convertView.findViewById(R.id
                        .navigation_drawer_item_drawable_icon);
                    break;
                case TYPE_SUBHEADER:
                    convertView = inflater.inflate(R.layout.navigation_drawer_list_subheader, parent, false);
                    viewHolder.name = (TextView) convertView.findViewById(R.id.navigation_drawer_item_name);
                    convertView.setEnabled(false);
                    convertView.setOnClickListener(null);
                    break;
                default:
                    convertView = inflater.inflate(R.layout.navigation_drawer_list_seperator, parent, false);
                    convertView.setEnabled(false);
                    convertView.setOnClickListener(null);
                    break;
            }
            viewHolder.type = obj.getType();
            convertView.setTag(viewHolder);
        } else {
            viewHolder = (ViewHolder) convertView.getTag();
        }

        switch (obj.getType()) {
            case TYPE_ITEM_MENU:
                Typeface font = Typeface.createFromAsset(context.getAssets(), "octicons.ttf");
                viewHolder.iconString.setTypeface(font);
                viewHolder.iconString.setText(obj.getIconString());
                viewHolder.name.setText(obj.getTitle());
                break;
            case TYPE_ITEM_ORG:
                avatars.bind(viewHolder.iconDrawable, obj.getUser());
                viewHolder.name.setText(obj.getTitle());
                break;
            case TYPE_SUBHEADER:
                viewHolder.name.setText(obj.getTitle());
                break;
        }

        return convertView;
    }

    private class ViewHolder {
        int type;
        TextView name;
        TextView iconString;
        ImageView iconDrawable;
    }
}

<code block>
package com.github.mobile.ui;

import android.content.Context;
import android.support.design.widget.AppBarLayout;
import android.support.design.widget.CoordinatorLayout;
import android.support.v4.view.ViewCompat;
import android.util.AttributeSet;
import android.util.Log;
import android.view.View;

import java.util.List;

public class PatchedScrollingViewBehavior extends AppBarLayout.ScrollingViewBehavior {

    public PatchedScrollingViewBehavior() {
        super();
    }

    public PatchedScrollingViewBehavior(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    @Override
    public boolean onMeasureChild(CoordinatorLayout parent, View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) {
        if(child.getLayoutParams().height == -1) {
            List<View> dependencies = parent.getDependencies(child);
            if(dependencies.isEmpty())
                return false;

            AppBarLayout appBar = findFirstAppBarLayout(dependencies);
            if(appBar != null && ViewCompat.isLaidOut(appBar)) {
                if(ViewCompat.getFitsSystemWindows(appBar))
                    ViewCompat.setFitsSystemWindows(child, true);

                int parentHeight = View.MeasureSpec.getSize(parentHeightMeasureSpec);
                int height = parentHeight - appBar.getMeasuredHeight();
                int heightMeasureSpec = View.MeasureSpec.makeMeasureSpec(height, View.MeasureSpec.EXACTLY);
                parent.onMeasureChild(child, parentWidthMeasureSpec, widthUsed, heightMeasureSpec, heightUsed);
                return true;
            }
        }

        return false;
    }


    private static AppBarLayout findFirstAppBarLayout(List<View> views) {
        int i = 0;

        for(int z = views.size(); i < z; ++i) {
            View view = views.get(i);
            if(view instanceof AppBarLayout) {
                return (AppBarLayout)view;
            }
        }

        return null;
    }
}

<code block>

package com.github.mobile.ui;

import android.content.DialogInterface.OnClickListener;
import android.os.Bundle;

import java.util.ArrayList;


public class SingleChoiceDialogFragment extends DialogFragmentHelper implements
        OnClickListener {


    public static final String ARG_SELECTED = "selected";


    protected static final String ARG_CHOICES = "choices";


    protected static final String ARG_SELECTED_CHOICE = "selectedChoice";


    protected static final String TAG = "single_choice_dialog";


    protected static void show(final DialogFragmentActivity activity,
            final int requestCode, final String title, final String message,
            ArrayList<?> choices, final int selectedChoice,
            final DialogFragmentHelper helper) {
        Bundle arguments = createArguments(title, message, requestCode);
        arguments.putSerializable(ARG_CHOICES, choices);
        arguments.putInt(ARG_SELECTED_CHOICE, selectedChoice);
        show(activity, helper, arguments, TAG);
    }
}

<code block>
package com.github.mobile.ui;

import android.support.v4.app.Fragment;
import android.support.v4.view.ViewPager;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;

public abstract class PagerFragment extends Fragment implements
    ViewPager.OnPageChangeListener {


    protected abstract FragmentProvider getProvider();


    protected Fragment getFragment() {
        FragmentProvider provider = getProvider();
        if (provider != null)
            return provider.getSelected();
        else
            return null;
    }

    @Override
    public boolean onOptionsItemSelected(final MenuItem item) {
        Fragment fragment = getFragment();
        if (fragment != null)
            return fragment.onOptionsItemSelected(item);

        return super.onOptionsItemSelected(item);
    }

    @Override
    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
        Fragment fragment = getFragment();
        if (fragment != null)
            fragment.onCreateOptionsMenu(menu, getActivity().getMenuInflater());
        super.onCreateOptionsMenu(menu, inflater);
    }

    @Override
    public void onPageScrolled(int position, float positionOffset,
        int positionOffsetPixels) {

    }

    @Override
    public void onPageSelected(int position) {

    }

    @Override
    public void onPageScrollStateChanged(int state) {

    }
}
<code block>

package com.github.mobile.ui;

import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.TextView;

import com.github.mobile.R;


public class ResourceLoadingIndicator {

    private HeaderFooterListAdapter<?> adapter;

    private boolean showing;

    private final View view;

    private final TextView textView;


    public ResourceLoadingIndicator(final Context context,
            final int loadingResId) {
        view = LayoutInflater.from(context).inflate(R.layout.loading_item, null);
        textView = (TextView) view.findViewById(R.id.tv_loading);
        textView.setText(loadingResId);
    }


    public ResourceLoadingIndicator setList(
            final HeaderFooterListAdapter<?> adapter) {
        this.adapter = adapter;
        adapter.addFooter(view);
        showing = true;
        return this;
    }


    public ResourceLoadingIndicator setVisible(final boolean visible) {
        if (showing != visible && adapter != null)
            if (visible)
                adapter.addFooter(view);
            else
                adapter.removeFooter(view);
        showing = visible;
        return this;
    }
}

<code block>
package com.github.mobile.ui;

import static com.github.mobile.ui.NavigationDrawerObject.TYPE_SEPERATOR;
import android.app.SearchManager;
import android.content.Context;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.LoaderManager;
import android.support.v4.content.Loader;
import android.support.v4.view.MenuItemCompat;
import android.support.v4.widget.DrawerLayout;
import android.support.v7.widget.SearchView;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.Window;

import com.github.mobile.R;
import com.github.mobile.accounts.AccountUtils;
import com.github.mobile.core.user.UserComparator;
import com.github.mobile.persistence.AccountDataManager;
import com.github.mobile.ui.gist.GistsPagerFragment;
import com.github.mobile.ui.issue.FilterListFragment;
import com.github.mobile.ui.issue.IssueDashboardPagerFragment;
import com.github.mobile.ui.repo.OrganizationLoader;
import com.github.mobile.ui.user.HomePagerFragment;
import com.github.mobile.util.AvatarLoader;
import com.google.inject.Inject;
import com.google.inject.Provider;

import java.util.Collections;
import java.util.List;

import org.eclipse.egit.github.core.User;

public class MainActivity extends BaseActivity implements NavigationDrawerFragment.NavigationDrawerCallbacks,
    LoaderManager.LoaderCallbacks<List<User>> {

    private static final String TAG = "MainActivity";

    private NavigationDrawerFragment mNavigationDrawerFragment;

    @Inject
    private AccountDataManager accountDataManager;

    @Inject
    private Provider<UserComparator> userComparatorProvider;

    private List<User> orgs = Collections.emptyList();

    private NavigationDrawerAdapter navigationAdapter;

    private User org;

    @Inject
    private AvatarLoader avatars;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        setSupportActionBar((android.support.v7.widget.Toolbar) findViewById(R.id.toolbar));

        getSupportLoaderManager().initLoader(0, null, this);

        mNavigationDrawerFragment = (NavigationDrawerFragment)
            getSupportFragmentManager().findFragmentById(R.id.navigation_drawer);
    }

    private void reloadOrgs() {
        getSupportLoaderManager().restartLoader(0, null, this);
    }

    @Override
    public boolean onCreateOptionsMenu(Menu optionMenu) {
        getMenuInflater().inflate(R.menu.home, optionMenu);

        SearchManager searchManager = (SearchManager) getSystemService(Context.SEARCH_SERVICE);
        MenuItem searchItem = optionMenu.findItem(R.id.m_search);
        SearchView searchView = (SearchView) MenuItemCompat.getActionView(searchItem);
        searchView.setSearchableInfo(searchManager.getSearchableInfo(getComponentName()));

        return super.onCreateOptionsMenu(optionMenu);
    }

    @Override
    protected void onResume() {
        super.onResume();



        List<User> currentOrgs = orgs;
        if (currentOrgs != null && !currentOrgs.isEmpty()
            && !AccountUtils.isUser(this, currentOrgs.get(0)))
            reloadOrgs();
    }

    @Override
    public Loader<List<User>> onCreateLoader(int i, Bundle bundle) {
        return new OrganizationLoader(this, accountDataManager,
            userComparatorProvider);
    }

    @Override
    public void onLoadFinished(Loader<List<User>> listLoader, final List<User> orgs) {
        if (orgs.isEmpty())
            return;

        org = orgs.get(0);
        this.orgs = orgs;

        if (navigationAdapter != null)
            navigationAdapter.setOrgs(orgs);
        else {
            navigationAdapter = new NavigationDrawerAdapter(MainActivity.this, orgs, avatars);
            mNavigationDrawerFragment.setUp(
                R.id.navigation_drawer,
                (DrawerLayout) findViewById(R.id.drawer_layout), navigationAdapter, avatars, org);

            Window window = getWindow();
            if (window == null)
                return;
            View view = window.getDecorView();
            if (view == null)
                return;

            view.post(new Runnable() {

                @Override
                public void run() {
                    MainActivity.this.onNavigationDrawerItemSelected(1);
                }
            });
        }
    }

    @Override
    public void onLoaderReset(Loader<List<User>> listLoader) {

    }


    @Override
    public void onNavigationDrawerItemSelected(int position) {
        if (navigationAdapter.getItem(position).getType() == TYPE_SEPERATOR)
            return;
        Fragment fragment;
        Bundle args = new Bundle();
        switch (position) {
            case 1:
                fragment = new HomePagerFragment();
                args.putSerializable("org", org);
                break;
            case 2:
                fragment = new GistsPagerFragment();
                break;
            case 3:
                fragment = new IssueDashboardPagerFragment();
                break;
            case 4:
                fragment = new FilterListFragment();
                break;
            default:
                fragment = new HomePagerFragment();
                args.putSerializable("org", orgs.get(position - 6));
                break;
        }
        fragment.setArguments(args);
        FragmentManager manager = getSupportFragmentManager();
        manager.beginTransaction().replace(R.id.container, fragment).commit();
    }

}

<code block>

package com.github.mobile.ui;

import android.support.v4.app.Fragment;
import android.support.v4.view.ViewPager.OnPageChangeListener;
import android.view.Menu;
import android.view.MenuItem;


public abstract class PagerActivity extends DialogFragmentActivity implements
        OnPageChangeListener {

    private boolean menuCreated;


    protected abstract FragmentProvider getProvider();


    protected Fragment getFragment() {
        FragmentProvider provider = getProvider();
        if (provider != null)
            return provider.getSelected();
        else
            return null;
    }

    @Override
    public boolean onOptionsItemSelected(final MenuItem item) {
        Fragment fragment = getFragment();
        if (fragment != null)
            return fragment.onOptionsItemSelected(item);

        return super.onOptionsItemSelected(item);
    }

    @Override
    public void invalidateOptionsMenu() {
        if (menuCreated)
            super.invalidateOptionsMenu();
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        Fragment fragment = getFragment();
        if (fragment != null)
            fragment.onCreateOptionsMenu(menu, getMenuInflater());

        boolean created = super.onCreateOptionsMenu(menu);
        menuCreated = true;
        return created;
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        Fragment fragment = getFragment();
        if (fragment != null)
            fragment.onPrepareOptionsMenu(menu);
        return super.onPrepareOptionsMenu(menu);
    }

    @Override
    public void onPageScrolled(int position, float positionOffset,
            int positionOffsetPixels) {

    }

    @Override
    public void onPageSelected(int position) {
        invalidateOptionsMenu();
    }

    @Override
    public void onPageScrollStateChanged(int state) {

    }
}

<code block>

package com.github.mobile.ui;

import android.os.Bundle;
import android.support.design.widget.TabLayout;
import android.support.v4.view.PagerAdapter;
import android.view.View;
import android.widget.TabHost.OnTabChangeListener;
import android.widget.TabHost.TabContentFactory;

import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.mobile.R;


public abstract class TabPagerActivity<V extends PagerAdapter & FragmentProvider>
    extends PagerActivity implements OnTabChangeListener, TabContentFactory {


    protected ViewPager pager;


    protected TabLayout slidingTabsLayout;


    protected V adapter;

    @Override
    public void onPageSelected(final int position) {
        super.onPageSelected(position);
    }

    @Override
    public void onTabChanged(String tabId) {
    }

    @Override
    public View createTabContent(String tag) {
        return ViewUtils.setGone(new View(getApplication()), true);
    }


    protected abstract V createAdapter();


    protected String getTitle(final int position) {
        return adapter.getPageTitle(position).toString();
    }


    protected String getIcon(final int position) {
        return null;
    }


    protected TabPagerActivity<V> setGone(boolean gone) {
        ViewUtils.setGone(slidingTabsLayout, gone);
        ViewUtils.setGone(pager, gone);
        return this;
    }


    protected void setCurrentItem(final int position) {

    }


    protected int getContentView() {
        return R.layout.pager_with_tabs;
    }

    private void updateCurrentItem(final int newPosition) {
        if (newPosition > -1 && newPosition < adapter.getCount()) {
            pager.setItem(newPosition);
            setCurrentItem(newPosition);
        }
    }

    private void createPager() {
        adapter = createAdapter();
        invalidateOptionsMenu();
        pager.setAdapter(adapter);
    }

    public void updateTabs() {
        slidingTabsLayout.setupWithViewPager(pager);
    }


    protected void configureTabPager() {
        if (adapter == null) {
            createPager();
            updateTabs();
        }
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(getContentView());

        setSupportActionBar((android.support.v7.widget.Toolbar) findViewById(R.id.toolbar));


        getSupportActionBar().setElevation(0);

        pager = (ViewPager) findViewById(R.id.vp_pages);
        pager.setOnPageChangeListener(this);
        slidingTabsLayout = (TabLayout) findViewById(R.id.sliding_tabs_layout);
    }

    @Override
    protected FragmentProvider getProvider() {
        return adapter;
    }
}

<code block>

package com.github.mobile.ui;

import android.os.Bundle;

import com.github.kevinsawicki.wishlist.ViewFinder;
import com.github.mobile.ui.roboactivities.RoboActionBarActivity;

import java.io.Serializable;


public abstract class DialogFragmentActivity extends
    RoboActionBarActivity implements DialogResultListener {


    protected ViewFinder finder;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        finder = new ViewFinder(this);
    }


    @SuppressWarnings("unchecked")
    protected <V extends Serializable> V getSerializableExtra(final String name) {
        return (V) getIntent().getSerializableExtra(name);
    }


    protected int getIntExtra(final String name) {
        return getIntent().getIntExtra(name, -1);
    }


    protected int[] getIntArrayExtra(final String name) {
        return getIntent().getIntArrayExtra(name);
    }


    protected boolean[] getBooleanArrayExtra(final String name) {
        return getIntent().getBooleanArrayExtra(name);
    }


    protected String getStringExtra(final String name) {
        return getIntent().getStringExtra(name);
    }


    protected String[] getStringArrayExtra(final String name) {
        return getIntent().getStringArrayExtra(name);
    }


    protected CharSequence[] getCharSequenceArrayExtra(final String name) {
        return getIntent().getCharSequenceArrayExtra(name);
    }

    @Override
    public void onDialogResult(int requestCode, int resultCode, Bundle arguments) {

    }
}

<code block>

package com.github.mobile.ui;

import android.app.AlertDialog;
import android.content.Context;

import com.github.mobile.accounts.AuthenticatedUserTask;

import java.util.concurrent.Executor;


public abstract class ProgressDialogTask<E> extends AuthenticatedUserTask<E> {


    protected AlertDialog progress;


    protected ProgressDialogTask(Context context) {
        super(context);
    }


    public ProgressDialogTask(Context context, Executor executor) {
        super(context, executor);
    }


    protected void dismissProgress() {
        if (progress != null) {
            progress.dismiss();
            progress = null;
        }
    }


    protected void showIndeterminate(final CharSequence message) {
        dismissProgress();

        progress = LightProgressDialog.create(getContext(), message);
        progress.show();
    }


    protected void showIndeterminate(final int resId) {
        dismissProgress();

        progress = LightProgressDialog.create(getContext(), resId);
        progress.show();
    }


    @Override
    protected void onSuccess(E e) throws Exception {
        dismissProgress();
    }


    @Override
    protected void onException(Exception e) throws RuntimeException {
        dismissProgress();
    }


    protected String getString(int resId) {
        return getContext().getString(resId);
    }
}

<code block>

package com.github.mobile.ui;

import android.app.Activity;
import android.os.Bundle;
import android.support.v4.content.Loader;
import android.widget.AbsListView;
import android.widget.AbsListView.OnScrollListener;
import android.widget.ListView;

import com.github.mobile.ThrowableLoader;
import com.github.mobile.core.ResourcePager;

import java.io.IOException;
import java.util.List;


public abstract class PagedItemFragment<E> extends ItemListFragment<E>
        implements OnScrollListener {


    protected ResourcePager<E> pager;

    private ResourceLoadingIndicator loadingIndicator;


    protected abstract ResourcePager<E> createPager();


    protected abstract int getLoadingMessage();

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        pager = createPager();
    }


    protected void configureList(Activity activity, ListView listView) {
        super.configureList(activity, listView);

        loadingIndicator = new ResourceLoadingIndicator(activity,
                getLoadingMessage());
        loadingIndicator.setList(getListAdapter());
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        getListView().setOnScrollListener(this);

        getListView().setFastScrollEnabled(true);
    }

    @Override
    public Loader<List<E>> onCreateLoader(int id, Bundle bundle) {
        return new ThrowableLoader<List<E>>(getActivity(), items) {

            @Override
            public List<E> loadData() throws IOException {
                pager.next();
                return pager.getResources();
            }
        };
    }

    @Override
    public void onScrollStateChanged(AbsListView view, int scrollState) {

    }

    @Override
    public void onScroll(AbsListView view, int firstVisibleItem,
            int visibleItemCount, int totalItemCount) {
        if (!isUsable())
            return;
        if (!pager.hasMore())
            return;
        if (getLoaderManager().hasRunningLoaders())
            return;
        if (listView != null
                && listView.getLastVisiblePosition() >= pager.size())
            showMore();
    }

    @Override
    protected void forceRefresh() {
        pager.clear();

        super.forceRefresh();
    }


    private void showMore() {
        refresh();
    }

    @Override
    public void onLoadFinished(Loader<List<E>> loader, List<E> items) {
        loadingIndicator.setVisible(pager.hasMore());

        super.onLoadFinished(loader, items);
    }

    @Override
    protected void refreshWithProgress() {
        pager.reset();
        pager = createPager();

        super.refreshWithProgress();
    }
}

<code block>
package com.github.mobile.ui;

import android.content.Context;
import android.util.AttributeSet;
import android.widget.Checkable;
import android.widget.RelativeLayout;

public class CheckableRelativeLayout extends RelativeLayout implements Checkable {
    private static final int[] CheckedStateSet = {
        android.R.attr.state_checked
    };
    private boolean checked = false;

    public CheckableRelativeLayout(Context context) {
        super(context, null);
    }

    public CheckableRelativeLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public boolean isChecked() {
        return checked;
    }

    public void setChecked(boolean b) {
        checked = b;
        refreshDrawableState();
        forceLayout();
    }

    public void toggle() {
        checked = !checked;
    }

    @Override
    protected int[] onCreateDrawableState(int extraSpace) {
        final int[] drawableState = super.onCreateDrawableState(extraSpace + 1);
        if (isChecked()) {
            mergeDrawableStates(drawableState, CheckedStateSet);
        }
        return drawableState;
    }
}
<code block>

package com.github.mobile.ui;

import static android.app.Activity.RESULT_CANCELED;
import static android.app.Activity.RESULT_OK;
import static android.content.DialogInterface.BUTTON_NEGATIVE;
import static android.content.DialogInterface.BUTTON_POSITIVE;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.os.Bundle;
import android.support.v4.app.FragmentActivity;


public class ConfirmDialogFragment extends DialogFragmentHelper implements
        OnClickListener {

    private static final String TAG = "confirm_dialog";


    public static void show(final FragmentActivity activity,
            final int requestCode, final String title, final String message) {
        show(activity, requestCode, title, message, null);
    }


    public static void show(final FragmentActivity activity,
            final int requestCode, final String title, final String message,
            final Bundle bundle) {
        Bundle arguments = createArguments(title, message, requestCode);
        if (bundle != null)
            arguments.putAll(bundle);
        show(activity, new ConfirmDialogFragment(), arguments, TAG);
    }

    public Dialog onCreateDialog(final Bundle savedInstanceState) {
        AlertDialog dialog = LightAlertDialog.create(getActivity());
        dialog.setTitle(getTitle());
        dialog.setMessage(getMessage());
        dialog.setButton(BUTTON_POSITIVE,
                getResources().getString(android.R.string.yes), this);
        dialog.setButton(BUTTON_NEGATIVE,
                getResources().getString(android.R.string.no), this);
        dialog.setCancelable(true);
        dialog.setOnCancelListener(this);
        return dialog;
    }

    @Override
    public void onClick(DialogInterface dialog, int which) {
        dialog.dismiss();
        switch (which) {
        case BUTTON_POSITIVE:
            onResult(RESULT_OK);
            break;
        case BUTTON_NEGATIVE:
            onResult(RESULT_CANCELED);
            break;
        }
    }
}

<code block>
package com.github.mobile.ui;

import android.os.Bundle;
import android.support.annotation.Nullable;
import android.support.design.widget.TabLayout;
import android.support.v4.view.PagerAdapter;
import android.support.v7.app.ActionBarActivity;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;

import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.mobile.R;

import static android.widget.TabHost.OnTabChangeListener;
import static android.widget.TabHost.TabContentFactory;

public abstract class TabPagerFragment<V extends PagerAdapter & FragmentProvider>
    extends PagerFragment implements OnTabChangeListener, TabContentFactory {



    protected ViewPager pager;


    protected TabLayout slidingTabsLayout;


    protected V adapter;

    @Override
    public void onPageSelected(final int position) {
        super.onPageSelected(position);
    }

    @Override
    public void onTabChanged(String tabId) {
    }

    @Override
    public View createTabContent(String tag) {
        return ViewUtils.setGone(new View(getActivity().getApplication()), true);
    }


    protected abstract V createAdapter();


    protected String getTitle(final int position) {
        return adapter.getPageTitle(position).toString();
    }


    protected String getIcon(final int position) {
        return null;
    }


    protected TabPagerFragment<V> setGone(boolean gone) {
        ViewUtils.setGone(slidingTabsLayout, gone);
        ViewUtils.setGone(pager, gone);
        return this;
    }


    protected void setCurrentItem(final int position) {

    }


    protected int getContentView() {
        return R.layout.pager_with_tabs;
    }

    private void createPager() {
        adapter = createAdapter();
        getActivity().supportInvalidateOptionsMenu();
        pager.setAdapter(adapter);
        slidingTabsLayout.setupWithViewPager(pager);
    }


    protected void configureTabPager() {
        createPager();
    }

    @Override
    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container,
        @Nullable Bundle savedInstanceState) {
        return inflater.inflate(getContentView(), null);
    }

    @Override
    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        setHasOptionsMenu(true);
        view.findViewById(R.id.toolbar).setVisibility(View.GONE);


        ((ActionBarActivity) getActivity()).getSupportActionBar().setElevation(0);

        pager = (ViewPager) view.findViewById(R.id.vp_pages);
        pager.setOnPageChangeListener(this);
        slidingTabsLayout = (TabLayout) view.findViewById(R.id.sliding_tabs_layout);
    }

    @Override
    protected FragmentProvider getProvider() {
        return adapter;
    }

}

<code block>

package com.github.mobile.ui;

import android.app.AlertDialog;
import android.app.ProgressDialog;
import android.content.Context;

import com.github.mobile.R;



public class LightProgressDialog extends ProgressDialog {


    public static AlertDialog create(Context context, int resId) {
        return create(context, context.getResources().getString(resId));
    }


    public static AlertDialog create(Context context, CharSequence message) {
        ProgressDialog dialog = new LightProgressDialog(context, message);
        dialog.setMessage(message);
        dialog.setIndeterminate(true);
        dialog.setProgressStyle(STYLE_SPINNER);
        dialog.setIndeterminateDrawable(context.getResources().getDrawable(R.drawable.spinner));
        return dialog;
    }

    private LightProgressDialog(Context context, CharSequence message) {
        super(context, THEME_HOLO_LIGHT);
    }
}

<code block>

package com.github.mobile.ui;

import android.app.Activity;
import android.os.Bundle;


public interface DialogResultListener {


    void onDialogResult(int requestCode, int resultCode, Bundle arguments);
}

<code block>

package com.github.mobile.ui;

import android.text.Editable;
import android.text.TextWatcher;


public class TextWatcherAdapter implements TextWatcher {

    public void afterTextChanged(Editable s) {
    }

    public void beforeTextChanged(CharSequence s, int start, int count,
            int after) {
    }

    public void onTextChanged(CharSequence s, int start, int before, int count) {
    }
}

<code block>

package com.github.mobile.ui;

import android.support.v4.app.Fragment;


public interface FragmentProvider {


    Fragment getSelected();
}

<code block>

package com.github.mobile.ui;

import static android.graphics.Typeface.BOLD;
import android.text.SpannableStringBuilder;
import android.text.TextUtils;
import android.text.style.BackgroundColorSpan;
import android.text.style.ForegroundColorSpan;
import android.text.style.StyleSpan;
import android.text.style.TypefaceSpan;
import android.text.style.URLSpan;
import android.view.View;
import android.view.View.OnClickListener;

import com.github.mobile.util.TimeUtils;

import java.util.Date;
import java.util.Locale;


public class StyledText extends SpannableStringBuilder {


    public StyledText append(final CharSequence text, final Object span) {
        if (!TextUtils.isEmpty(text)) {
            append(text);
            if (span != null) {
                final int length = length();
                setSpan(span, length - text.length(), length,
                        SPAN_EXCLUSIVE_EXCLUSIVE);
            }
        }
        return this;
    }

    @Override
    public StyledText append(char text) {
        super.append(text);
        return this;
    }

    @Override
    public StyledText append(CharSequence text) {
        if (text != null)
            super.append(text);
        return this;
    }


    public StyledText append(final char text, final Object span) {
        append(text);
        if (span != null) {
            final int length = length();
            setSpan(span, length - 1, length, SPAN_EXCLUSIVE_EXCLUSIVE);
        }
        return this;
    }


    public StyledText bold(final CharSequence text) {
        return append(text, new StyleSpan(BOLD));
    }


    public StyledText background(final CharSequence text, final int color) {
        return append(text, new BackgroundColorSpan(color));
    }


    public StyledText foreground(final CharSequence text, final int color) {
        return append(text, new ForegroundColorSpan(color));
    }


    public StyledText foreground(final char text, final int color) {
        return append(text, new ForegroundColorSpan(color));
    }


    public StyledText monospace(final CharSequence text) {
        return append(text, new TypefaceSpan("monospace"));
    }


    public StyledText url(final CharSequence text,
            final OnClickListener listener) {
        return append(text, new URLSpan(text.toString()) {

            @Override
            public void onClick(View widget) {
                listener.onClick(widget);
            }
        });
    }


    public StyledText url(final CharSequence text) {
        return append(text, new URLSpan(text.toString()));
    }


    public StyledText append(final Date date) {
        final CharSequence time = TimeUtils.getRelativeTime(date);


        final int timeLength = time.length();
        if (length() > 0 && timeLength > 0
                && Character.isUpperCase(time.charAt(0))) {
            append(time.subSequence(0, 1).toString()
                    .toLowerCase(Locale.getDefault()));
            append(time.subSequence(1, timeLength));
        } else
            append(time);

        return this;
    }
}

<code block>
package com.github.mobile.ui;

import org.eclipse.egit.github.core.User;

public class NavigationDrawerObject {
    public static final int TYPE_SEPERATOR = -1;
    public static final int TYPE_SUBHEADER = 0;
    public static final int TYPE_ITEM_MENU = 1;
    public static final int TYPE_ITEM_ORG = 2;

    private String title;
    private String iconString;
    private User user;
    private int type;

    public NavigationDrawerObject(String title, String icon, int type) {
        this.title = title;
        this.iconString = icon;
        this.type = type;
    }

    public NavigationDrawerObject(String title, int type, User user) {
        this.title = title;
        this.type = type;
        this.user = user;

    }

    public NavigationDrawerObject(String title, int type) {
        this.title = title;
        this.type = type;
    }

    public NavigationDrawerObject(int type) {
        this.type = type;
    }

    public User getUser() {
        return user;
    }


    public int getType() {
        return type;
    }

    public String getTitle() {
        return title;
    }

    public String getIconString() {
        return iconString;
    }
}
<code block>

package com.github.mobile.ui.user;

import org.eclipse.egit.github.core.User;


public interface OrganizationSelectionProvider {


    User addListener(OrganizationSelectionListener listener);


    OrganizationSelectionProvider removeListener(
            OrganizationSelectionListener listener);
}

<code block>

package com.github.mobile.ui.user;

import android.view.View;
import android.widget.ListView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.mobile.accounts.AccountUtils;
import com.github.mobile.ui.PagedItemFragment;
import com.github.mobile.util.AvatarLoader;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.service.UserService;


public abstract class PagedUserFragment extends PagedItemFragment<User> {


    @Inject
    protected AvatarLoader avatars;


    @Inject
    protected UserService service;

    @Override
    protected SingleTypeAdapter<User> createAdapter(List<User> items) {
        User[] users = items.toArray(new User[items.size()]);
        return new UserListAdapter(getActivity().getLayoutInflater(), users,
                avatars);
    }

    @Override
    public void onListItemClick(ListView l, View v, int position, long id) {
        User user = (User) l.getItemAtPosition(position);
        if (!AccountUtils.isUser(getActivity(), user))
            startActivity(UserViewActivity.createIntent(user));
    }
}

<code block>
package com.github.mobile.ui.user;

import android.text.TextUtils;

import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.mobile.core.issue.IssueUtils;
import com.github.mobile.ui.StyledText;
import com.github.mobile.util.TimeUtils;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.Commit;
import org.eclipse.egit.github.core.CommitComment;
import org.eclipse.egit.github.core.Download;
import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.PullRequest;
import org.eclipse.egit.github.core.Team;
import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.event.CommitCommentPayload;
import org.eclipse.egit.github.core.event.CreatePayload;
import org.eclipse.egit.github.core.event.DeletePayload;
import org.eclipse.egit.github.core.event.DownloadPayload;
import org.eclipse.egit.github.core.event.Event;
import org.eclipse.egit.github.core.event.EventRepository;
import org.eclipse.egit.github.core.event.FollowPayload;
import org.eclipse.egit.github.core.event.GistPayload;
import org.eclipse.egit.github.core.event.IssueCommentPayload;
import org.eclipse.egit.github.core.event.IssuesPayload;
import org.eclipse.egit.github.core.event.MemberPayload;
import org.eclipse.egit.github.core.event.PullRequestPayload;
import org.eclipse.egit.github.core.event.PullRequestReviewCommentPayload;
import org.eclipse.egit.github.core.event.PushPayload;
import org.eclipse.egit.github.core.event.TeamAddPayload;

import java.util.List;

import static com.github.kevinsawicki.wishlist.ViewUpdater.FORMAT_INT;

public class IconAndViewTextManager {
    public static final String ISSUES_PAYLOAD_ACTION_OPENED = "opened";
    public static final String ISSUES_PAYLOAD_ACTION_REOPENED = "reopened";
    public static final String ISSUES_PAYLOAD_ACTION_CLOSED = "closed";
    private final NewsListAdapter newsListAdapter;

    public IconAndViewTextManager(NewsListAdapter newsListAdapter) {
        this.newsListAdapter = newsListAdapter;
    }

    private void appendComment(final StyledText details,
            final Comment comment) {
        if (comment != null)
            appendText(details, comment.getBody());
    }

    private void appendCommitComment(final StyledText details,
            final CommitComment comment) {
        if (comment == null)
            return;

        String id = comment.getCommitId();
        if (!TextUtils.isEmpty(id)) {
            if (id.length() > 10)
                id = id.substring(0, 10);
            appendText(details, "Comment in");
            details.append(' ');
            details.monospace(id);
            details.append(':').append('\n');
        }
        appendComment(details, comment);
    }

    private void appendText(final StyledText details, String text) {
        if (text == null)
            return;
        text = text.trim();
        if (text.length() == 0)
            return;

        details.append(text);
    }

    private StyledText boldActor(final StyledText text, final Event event) {
        return boldUser(text, event.getActor());
    }

    private StyledText boldUser(final StyledText text, final User user) {
        if (user != null)
            text.bold(user.getLogin());
        return text;
    }

    private StyledText boldRepo(final StyledText text, final Event event) {
        EventRepository repo = event.getRepo();
        if (repo != null)
            text.bold(repo.getName());
        return text;
    }

    private StyledText boldRepoName(final StyledText text,
            final Event event) {
        EventRepository repo = event.getRepo();
        if (repo != null) {
            String name = repo.getName();
            if (!TextUtils.isEmpty(name)) {
                int slash = name.indexOf('/');
                if (slash != -1 && slash + 1 < name.length())
                    text.bold(name.substring(slash + 1));
            }
        }
        return text;
    }

    void formatCommitComment(Event event, StyledText main,
                                    StyledText details) {
        boldActor(main, event);
        main.append(" commented on ");
        boldRepo(main, event);

        CommitCommentPayload payload = (CommitCommentPayload) event
                .getPayload();
        appendCommitComment(details, payload.getComment());
    }

    void formatDownload(Event event, StyledText main,
                               StyledText details) {
        boldActor(main, event);
        main.append(" uploaded a file to ");
        boldRepo(main, event);

        DownloadPayload payload = (DownloadPayload) event.getPayload();
        Download download = payload.getDownload();
        if (download != null)
            appendText(details, download.getName());
    }

    void formatCreate(Event event, StyledText main,
                             StyledText details) {
        boldActor(main, event);

        main.append(" created ");
        CreatePayload payload = (CreatePayload) event.getPayload();
        String refType = payload.getRefType();
        main.append(refType);
        main.append(' ');
        if (!"repository".equals(refType)) {
            main.append(payload.getRef());
            main.append(" at ");
            boldRepo(main, event);
        } else
            boldRepoName(main, event);
    }

    void formatDelete(Event event, StyledText main,
                             StyledText details) {
        boldActor(main, event);

        DeletePayload payload = (DeletePayload) event.getPayload();
        main.append(" deleted ");
        main.append(payload.getRefType());
        main.append(' ');
        main.append(payload.getRef());
        main.append(" at ");

        boldRepo(main, event);
    }

    void formatFollow(Event event, StyledText main,
                             StyledText details) {
        boldActor(main, event);
        main.append(" started following ");
        boldUser(main, ((FollowPayload) event.getPayload()).getTarget());
    }

    void formatFork(Event event, StyledText main,
                           StyledText details) {
        boldActor(main, event);
        main.append(" forked repository ");
        boldRepo(main, event);
    }

    void formatGist(Event event, StyledText main,
                           StyledText details) {
        boldActor(main, event);

        GistPayload payload = (GistPayload) event.getPayload();

        main.append(' ');
        String action = payload.getAction();
        if ("create".equals(action))
            main.append("created");
        else if ("update".equals(action))
            main.append("updated");
        else
            main.append(action);
        main.append(" Gist ");
        main.append(payload.getGist().getId());
    }

    void formatWiki(Event event, StyledText main,
                           StyledText details) {
        boldActor(main, event);
        main.append(" updated the wiki in ");
        boldRepo(main, event);
    }

    void formatIssueComment(Event event, StyledText main,
                                   StyledText details) {
        boldActor(main, event);

        main.append(" commented on ");

        IssueCommentPayload payload = (IssueCommentPayload) event.getPayload();

        Issue issue = payload.getIssue();
        String number;
        if (IssueUtils.isPullRequest(issue))
            number = "pull request " + issue.getNumber();
        else
            number = "issue " + issue.getNumber();
        main.bold(number);

        main.append(" on ");

        boldRepo(main, event);

        appendComment(details, payload.getComment());
    }

    void formatIssues(Event event, StyledText main,
                             StyledText details) {
        boldActor(main, event);

        IssuesPayload payload = (IssuesPayload) event.getPayload();
        String action = payload.getAction();
        Issue issue = payload.getIssue();
        main.append(' ');
        main.append(action);
        main.append(' ');
        main.bold("issue " + issue.getNumber());
        main.append(" on ");

        boldRepo(main, event);

        appendText(details, issue.getTitle());
    }

    void formatAddMember(Event event, StyledText main,
                                StyledText details) {
        boldActor(main, event);
        main.append(" added ");
        User member = ((MemberPayload) event.getPayload()).getMember();
        if (member != null)
            main.bold(member.getLogin());
        main.append(" as a collaborator to ");
        boldRepo(main, event);
    }

    void formatPublic(Event event, StyledText main,
                             StyledText details) {
        boldActor(main, event);
        main.append(" open sourced repository ");
        boldRepo(main, event);
    }

    void formatWatch(Event event, StyledText main,
                            StyledText details) {
        boldActor(main, event);
        main.append(" starred ");
        boldRepo(main, event);
    }

    void formatReviewComment(Event event, StyledText main,
                                    StyledText details) {
        boldActor(main, event);
        main.append(" commented on ");
        boldRepo(main, event);

        PullRequestReviewCommentPayload payload = (PullRequestReviewCommentPayload) event
                .getPayload();
        appendCommitComment(details, payload.getComment());
    }

    void formatPullRequest(Event event, StyledText main,
                                  StyledText details) {
        boldActor(main, event);

        PullRequestPayload payload = (PullRequestPayload) event.getPayload();
        String action = payload.getAction();
        if ("synchronize".equals(action))
            action = "updated";
        main.append(' ');
        main.append(action);
        main.append(' ');
        main.bold("pull request " + payload.getNumber());
        main.append(" on ");

        boldRepo(main, event);

        if (ISSUES_PAYLOAD_ACTION_OPENED.equals(action) || "closed".equals(action)) {
            PullRequest request = payload.getPullRequest();
            if (request != null) {
                String title = request.getTitle();
                if (!TextUtils.isEmpty(title))
                    details.append(title);
            }
        }
    }

    void formatPush(Event event, StyledText main,
                           StyledText details) {
        boldActor(main, event);

        main.append(" pushed to ");
        PushPayload payload = (PushPayload) event.getPayload();
        String ref = payload.getRef();
        if (ref.startsWith("refs/heads/"))
            ref = ref.substring(11);
        main.bold(ref);
        main.append(" at ");

        boldRepo(main, event);

        final List<Commit> commits = payload.getCommits();
        int size = commits != null ? commits.size() : -1;
        if (size > 0) {
            if (size != 1)
                details.append(FORMAT_INT.format(size)).append(" new commits");
            else
                details.append("1 new commit");

            int max = 3;
            int appended = 0;
            for (Commit commit : commits) {
                if (commit == null)
                    continue;

                String sha = commit.getSha();
                if (TextUtils.isEmpty(sha))
                    continue;

                details.append('\n');
                if (sha.length() > 7)
                    details.monospace(sha.substring(0, 7));
                else
                    details.monospace(sha);

                String message = commit.getMessage();
                if (!TextUtils.isEmpty(message)) {
                    details.append(' ');
                    int newline = message.indexOf('\n');
                    if (newline > 0)
                        details.append(message.subSequence(0, newline));
                    else
                        details.append(message);
                }

                appended++;
                if (appended == max)
                    break;
            }
        }
    }

    void formatTeamAdd(Event event, StyledText main,
                              StyledText details) {
        boldActor(main, event);

        TeamAddPayload payload = (TeamAddPayload) event.getPayload();

        main.append(" added ");

        User user = payload.getUser();
        if (user != null)
            boldUser(main, user);
        else
            boldRepoName(main, event);

        main.append(" to team");

        Team team = payload.getTeam();
        String teamName = team != null ? team.getName() : null;
        if (teamName != null)
            main.append(' ').bold(teamName);
    }

    protected void update(int position, Event event) {
        newsListAdapter.getAvatars().bind(newsListAdapter.imageViewAgent(0), event.getActor());

        StyledText main = new StyledText();
        StyledText details = new StyledText();
        String icon = setIconAndFormatStyledText(event, main, details);

        if (icon != null)
            ViewUtils.setGone(newsListAdapter.setTextAgent(3, icon), false);
        else
            newsListAdapter.setGoneAgent(3, true);

        newsListAdapter.setTextAgent(1, main);

        if (!TextUtils.isEmpty(details))
            ViewUtils.setGone(newsListAdapter.setTextAgent(2, details), false);
        else
            newsListAdapter.setGoneAgent(2, true);

        newsListAdapter.setTextAgent(4, TimeUtils.getRelativeTime(event.getCreatedAt()));
    }

    String setIconAndFormatStyledText(Event event, StyledText main, StyledText details) {

        return EventType.valueOf(event.getType()).generateIconAndFormatStyledText(this, event, main, details);
    }
}
<code block>

package com.github.mobile.ui.user;

import android.os.Bundle;

import com.github.mobile.R;



public abstract class FollowersFragment extends PagedUserFragment {

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        setEmptyText(R.string.no_followers);
    }

    @Override
    protected int getLoadingMessage() {
        return R.string.loading_followers;
    }

    @Override
    protected int getErrorMessage(Exception exception) {
        return R.string.error_followers_load;
    }
}

<code block>

package com.github.mobile.ui.user;

import static com.github.mobile.Intents.EXTRA_USER;
import android.os.Bundle;
import android.support.v4.content.Loader;
import android.view.View;
import android.widget.ListView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.mobile.R;
import com.github.mobile.ThrowableLoader;
import com.github.mobile.accounts.AccountUtils;
import com.github.mobile.ui.ItemListFragment;
import com.github.mobile.util.AvatarLoader;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.service.OrganizationService;


public class MembersFragment extends ItemListFragment<User> {

    private User org;

    @Inject
    private OrganizationService service;

    @Inject
    private AvatarLoader avatars;

    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);

        if (org != null)
            outState.putSerializable(EXTRA_USER, org);
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        org = (User) getArguments().getSerializable("org");
        if (org == null && savedInstanceState != null)
            org = (User) savedInstanceState.getSerializable(EXTRA_USER);
        setEmptyText(R.string.no_members);

        super.onActivityCreated(savedInstanceState);
    }

    @Override
    public Loader<List<User>> onCreateLoader(int id, Bundle args) {
        return new ThrowableLoader<List<User>>(getActivity(), items) {

            @Override
            public List<User> loadData() throws Exception {
                return service.getMembers(org.getLogin());
            }
        };
    }

    @Override
    protected SingleTypeAdapter<User> createAdapter(List<User> items) {
        User[] users = items.toArray(new User[items.size()]);
        return new UserListAdapter(getActivity().getLayoutInflater(), users,
                avatars);
    }

    @Override
    public void onListItemClick(ListView l, View v, int position, long id) {
        User user = (User) l.getItemAtPosition(position);
        if (!AccountUtils.isUser(getActivity(), user))
            startActivity(UserViewActivity.createIntent(user));
    }

    @Override
    protected int getErrorMessage(Exception exception) {
        return R.string.error_members_load;
    }
}

<code block>

package com.github.mobile.ui.user;

import static com.github.mobile.Intents.EXTRA_USER;
import android.app.Activity;

import com.github.mobile.core.ResourcePager;
import com.github.mobile.core.user.UserPager;

import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.client.PageIterator;


public class UserFollowingFragment extends FollowingFragment {

    private User user;

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);

        user = getSerializableExtra(EXTRA_USER);
    }

    @Override
    protected ResourcePager<User> createPager() {
        return new UserPager() {

            @Override
            public PageIterator<User> createIterator(int page, int size) {
                return service.pageFollowing(user.getLogin(), page, size);
            }
        };
    }
}

<code block>

package com.github.mobile.ui.user;

import android.text.TextUtils;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.ImageView;
import android.widget.TextView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.mobile.R;
import com.github.mobile.util.AvatarLoader;
import com.github.mobile.util.TypefaceUtils;

import org.eclipse.egit.github.core.event.CreatePayload;
import org.eclipse.egit.github.core.event.Event;
import org.eclipse.egit.github.core.event.EventPayload;
import org.eclipse.egit.github.core.event.GistPayload;
import org.eclipse.egit.github.core.event.IssueCommentPayload;
import org.eclipse.egit.github.core.event.IssuesPayload;

import static org.eclipse.egit.github.core.event.Event.TYPE_COMMIT_COMMENT;
import static org.eclipse.egit.github.core.event.Event.TYPE_CREATE;
import static org.eclipse.egit.github.core.event.Event.TYPE_DELETE;
import static org.eclipse.egit.github.core.event.Event.TYPE_DOWNLOAD;
import static org.eclipse.egit.github.core.event.Event.TYPE_FOLLOW;
import static org.eclipse.egit.github.core.event.Event.TYPE_FORK;
import static org.eclipse.egit.github.core.event.Event.TYPE_FORK_APPLY;
import static org.eclipse.egit.github.core.event.Event.TYPE_GIST;
import static org.eclipse.egit.github.core.event.Event.TYPE_GOLLUM;
import static org.eclipse.egit.github.core.event.Event.TYPE_ISSUES;
import static org.eclipse.egit.github.core.event.Event.TYPE_ISSUE_COMMENT;
import static org.eclipse.egit.github.core.event.Event.TYPE_MEMBER;
import static org.eclipse.egit.github.core.event.Event.TYPE_PUBLIC;
import static org.eclipse.egit.github.core.event.Event.TYPE_PULL_REQUEST;
import static org.eclipse.egit.github.core.event.Event.TYPE_PULL_REQUEST_REVIEW_COMMENT;
import static org.eclipse.egit.github.core.event.Event.TYPE_PUSH;
import static org.eclipse.egit.github.core.event.Event.TYPE_TEAM_ADD;
import static org.eclipse.egit.github.core.event.Event.TYPE_WATCH;


public class NewsListAdapter extends SingleTypeAdapter<Event> {

    private final IconAndViewTextManager iconAndViewTextManager = new IconAndViewTextManager(this);


    public static boolean isValid(final Event event) {
        if (event == null)
            return false;

        final EventPayload payload = event.getPayload();
        if (payload == null || EventPayload.class.equals(payload.getClass()))
            return false;

        final String type = event.getType();
        if (TextUtils.isEmpty(type))
            return false;

        return TYPE_COMMIT_COMMENT.equals(type) 
                || (TYPE_CREATE.equals(type) 
                && ((CreatePayload) payload).getRefType() != null) 
                || TYPE_DELETE.equals(type) 
                || TYPE_DOWNLOAD.equals(type) 
                || TYPE_FOLLOW.equals(type) 
                || TYPE_FORK.equals(type) 
                || TYPE_FORK_APPLY.equals(type) 
                || (TYPE_GIST.equals(type) 
                && ((GistPayload) payload).getGist() != null) 
                || TYPE_GOLLUM.equals(type) 
                || (TYPE_ISSUE_COMMENT.equals(type) 
                && ((IssueCommentPayload) payload).getIssue() != null) 
                || (TYPE_ISSUES.equals(type) 
                && ((IssuesPayload) payload).getIssue() != null) 
                || TYPE_MEMBER.equals(type) 
                || TYPE_PUBLIC.equals(type) 
                || TYPE_PULL_REQUEST.equals(type) 
                || TYPE_PULL_REQUEST_REVIEW_COMMENT.equals(type) 
                || TYPE_PUSH.equals(type) 
                || TYPE_TEAM_ADD.equals(type) 
                || TYPE_WATCH.equals(type);
    }

    private final AvatarLoader avatars;


    public NewsListAdapter(LayoutInflater inflater, Event[] elements,
            AvatarLoader avatars) {
        super(inflater, R.layout.news_item);

        this.avatars = avatars;
        setItems(elements);
    }


    public NewsListAdapter(LayoutInflater inflater, AvatarLoader avatars) {
        this(inflater, null, avatars);
    }

    @Override
    public long getItemId(final int position) {
        final String id = getItem(position).getId();
        return !TextUtils.isEmpty(id) ? id.hashCode() : super
                .getItemId(position);
    }

    @Override
    protected int[] getChildViewIds() {
        return new int[] { R.id.iv_avatar, R.id.tv_event, R.id.tv_event_details,
                R.id.tv_event_icon, R.id.tv_event_date };
    }

    @Override
    protected View initialize(View view) {
        view = super.initialize(view);

        TypefaceUtils.setOcticons(textView(view, 3));
        return view;
    }

    @Override
    protected void update(int position, Event event) {

        iconAndViewTextManager.update(position, event);
    }

    public AvatarLoader getAvatars() {
        return avatars;
    }

    ImageView imageViewAgent(int childViewIndex) {
        return this.imageView(childViewIndex);
    }

    TextView setTextAgent(int childViewIndex, CharSequence text) {
        return this.setText(childViewIndex, text);
    }

    View setGoneAgent(int childViewIndex, boolean gone) {
        return this.setGone(childViewIndex, gone);
    }
}

<code block>

package com.github.mobile.ui.user;

import com.github.mobile.core.ResourcePager;

import org.eclipse.egit.github.core.client.PageIterator;
import org.eclipse.egit.github.core.event.Event;


public class UserReceivedNewsFragment extends UserNewsFragment {

    @Override
    protected ResourcePager<Event> createPager() {
        return new EventPager() {

            @Override
            public PageIterator<Event> createIterator(int page, int size) {
                return service.pageUserReceivedEvents(org.getLogin(), false,
                        page, size);
            }
        };
    }
}

<code block>

package com.github.mobile.ui.user;

import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
import static android.content.Intent.FLAG_ACTIVITY_SINGLE_TOP;
import static com.github.mobile.Intents.EXTRA_USER;
import static com.github.mobile.util.TypefaceUtils.ICON_FOLLOW;
import static com.github.mobile.util.TypefaceUtils.ICON_NEWS;
import static com.github.mobile.util.TypefaceUtils.ICON_PUBLIC;
import static com.github.mobile.util.TypefaceUtils.ICON_WATCH;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.ActionBar;
import android.text.TextUtils;
import android.view.Menu;
import android.view.MenuItem;
import android.widget.ProgressBar;

import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.mobile.Intents.Builder;
import com.github.mobile.R;
import com.github.mobile.core.user.FollowUserTask;
import com.github.mobile.core.user.FollowingUserTask;
import com.github.mobile.core.user.RefreshUserTask;
import com.github.mobile.core.user.UnfollowUserTask;
import com.github.mobile.ui.MainActivity;
import com.github.mobile.ui.TabPagerActivity;
import com.github.mobile.util.AvatarLoader;
import com.github.mobile.util.ToastUtils;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.User;


public class UserViewActivity extends TabPagerActivity<UserPagerAdapter>
    implements OrganizationSelectionProvider {


    public static Intent createIntent(User user) {
        return new Builder("user.VIEW").user(user).toIntent();
    }

    @Inject
    private AvatarLoader avatars;

    private User user;

    private ProgressBar loadingBar;

    private boolean isFollowing;

    private boolean followingStatusChecked;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        user = (User) getIntent().getSerializableExtra(EXTRA_USER);
        loadingBar = finder.find(R.id.pb_loading);

        ActionBar actionBar = getSupportActionBar();
        actionBar.setDisplayHomeAsUpEnabled(true);
        actionBar.setTitle(user.getLogin());

        if (!TextUtils.isEmpty(user.getAvatarUrl()))
            configurePager();
        else {
            ViewUtils.setGone(loadingBar, false);
            setGone(true);
            new RefreshUserTask(this, user.getLogin()) {

                @Override
                protected void onSuccess(User fullUser) throws Exception {
                    super.onSuccess(fullUser);

                    user = fullUser;
                    configurePager();
                }

                @Override
                protected void onException(Exception e) throws RuntimeException {
                    super.onException(e);

                    ToastUtils.show(UserViewActivity.this,
                        R.string.error_person_load);
                    ViewUtils.setGone(loadingBar, true);
                }
            }.execute();
        }
    }

    @Override
    public boolean onCreateOptionsMenu(Menu optionsMenu) {
        getMenuInflater().inflate(R.menu.user_follow, optionsMenu);

        return super.onCreateOptionsMenu(optionsMenu);
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        MenuItem followItem = menu.findItem(R.id.m_follow);

        followItem.setVisible(followingStatusChecked);
        followItem.setTitle(isFollowing ? R.string.unfollow : R.string.follow);

        return super.onPrepareOptionsMenu(menu);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.m_follow:
                followUser();
                return true;
            case android.R.id.home:
                Intent intent = new Intent(this, MainActivity.class);
                intent.addFlags(FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_SINGLE_TOP);
                startActivity(intent);
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }

    }

    private void configurePager() {
        avatars.bind(getSupportActionBar(), user);
        configureTabPager();
        ViewUtils.setGone(loadingBar, true);
        setGone(false);
        checkFollowingUserStatus();
    }

    @Override
    public User addListener(OrganizationSelectionListener listener) {
        return user;
    }

    @Override
    public OrganizationSelectionProvider removeListener(
        OrganizationSelectionListener listener) {
        return this;
    }

    @Override
    protected UserPagerAdapter createAdapter() {
        return new UserPagerAdapter(this);
    }

    @Override
    protected int getContentView() {
        return R.layout.tabbed_progress_pager;
    }

    @Override
    protected String getIcon(int position) {
        switch (position) {
            case 0:
                return ICON_NEWS;
            case 1:
                return ICON_PUBLIC;
            case 2:
                return ICON_WATCH;
            case 3:
                return ICON_FOLLOW;
            default:
                return super.getIcon(position);
        }
    }

    private void followUser() {
        if (isFollowing)
            new UnfollowUserTask(this, user.getLogin()) {

                @Override
                protected void onSuccess(User user) throws Exception {
                    super.onSuccess(user);

                    isFollowing = !isFollowing;
                }

                @Override
                protected void onException(Exception e) throws RuntimeException {
                    super.onException(e);

                    ToastUtils.show(UserViewActivity.this,
                        R.string.error_unfollowing_person);
                }
            }.start();
        else
            new FollowUserTask(this, user.getLogin()) {

                @Override
                protected void onSuccess(User user) throws Exception {
                    super.onSuccess(user);

                    isFollowing = !isFollowing;
                }

                @Override
                protected void onException(Exception e) throws RuntimeException {
                    super.onException(e);

                    ToastUtils.show(UserViewActivity.this,
                        R.string.error_following_person);
                }
            }.start();
    }

    private void checkFollowingUserStatus() {
        followingStatusChecked = false;
        new FollowingUserTask(this, user.getLogin()) {

            @Override
            protected void onSuccess(Boolean following) throws Exception {
                super.onSuccess(following);

                isFollowing = following;
                followingStatusChecked = true;
                invalidateOptionsMenu();
            }
        }.execute();
    }
}

<code block>

package com.github.mobile.ui.user;

import com.github.mobile.accounts.AccountUtils;
import com.github.mobile.core.ResourcePager;

import org.eclipse.egit.github.core.client.PageIterator;
import org.eclipse.egit.github.core.event.Event;


public class OrganizationNewsFragment extends UserNewsFragment {

    @Override
    protected ResourcePager<Event> createPager() {
        return new EventPager() {

            @Override
            public PageIterator<Event> createIterator(int page, int size) {
                String account = AccountUtils.getLogin(getActivity());
                return service.pageUserOrgEvents(account, org.getLogin(), page,
                        size);
            }
        };
    }
}

<code block>

package com.github.mobile.ui.user;

import static com.github.mobile.Intents.EXTRA_USER;
import android.app.Activity;

import com.github.mobile.core.ResourcePager;
import com.github.mobile.core.user.UserPager;

import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.client.PageIterator;


public class UserFollowersFragment extends FollowersFragment {

    private User user;

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);

        user = getSerializableExtra(EXTRA_USER);
    }

    @Override
    protected ResourcePager<User> createPager() {
        return new UserPager() {

            @Override
            public PageIterator<User> createIterator(int page, int size) {
                return service.pageFollowers(user.getLogin(), page, size);
            }
        };
    }
}

<code block>

package com.github.mobile.ui.user;

import com.github.mobile.core.ResourcePager;

import org.eclipse.egit.github.core.client.PageIterator;
import org.eclipse.egit.github.core.event.Event;


public class UserCreatedNewsFragment extends UserNewsFragment {

    @Override
    protected ResourcePager<Event> createPager() {
        return new EventPager() {

            @Override
            public PageIterator<Event> createIterator(int page, int size) {
                return service
                        .pageUserEvents(org.getLogin(), false, page, size);
            }
        };
    }
}

<code block>

package com.github.mobile.ui.user;

import com.github.mobile.core.ResourcePager;
import com.github.mobile.core.user.UserPager;

import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.client.PageIterator;


public class MyFollowersFragment extends FollowersFragment {

    @Override
    protected ResourcePager<User> createPager() {
        return new UserPager() {

            @Override
            public PageIterator<User> createIterator(int page, int size) {
                return service.pageFollowers(page, size);
            }
        };
    }
}
<code block>

package com.github.mobile.ui.user;

import static com.github.mobile.Intents.EXTRA_USER;
import android.os.Bundle;

import com.github.mobile.core.user.UserEventMatcher.UserPair;
import com.github.mobile.ui.NewsFragment;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;


public abstract class UserNewsFragment extends NewsFragment implements
    OrganizationSelectionListener {


    protected User org;

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);

        if (org != null)
            outState.putSerializable(EXTRA_USER, org);
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        if (getActivity() instanceof OrganizationSelectionProvider)
            org = ((OrganizationSelectionProvider) getActivity()).addListener(this);

        if (getArguments() != null && getArguments().containsKey("org"))
            org = (User) getArguments().getSerializable("org");

        if (org == null && savedInstanceState != null)
            org = (User) savedInstanceState.get(EXTRA_USER);

        super.onActivityCreated(savedInstanceState);
    }

    @Override
    public void onDetach() {
        if (getActivity() != null && getActivity() instanceof OrganizationSelectionProvider) {
            OrganizationSelectionProvider selectionProvider = (OrganizationSelectionProvider) getActivity();
            selectionProvider.removeListener(this);
        }

        super.onDetach();
    }

    @Override
    protected void viewRepository(Repository repository) {
        User owner = repository.getOwner();
        if (owner != null && org.getLogin().equals(owner.getLogin()))
            repository.setOwner(org);

        super.viewRepository(repository);
    }

    @Override
    public void onOrganizationSelected(User organization) {
        int previousOrgId = org != null ? org.getId() : -1;
        org = organization;

        if (previousOrgId != org.getId())
            refreshWithProgress();
    }

    @Override
    protected boolean viewUser(User user) {
        if (org.getId() != user.getId()) {
            startActivity(UserViewActivity.createIntent(user));
            return true;
        }
        return false;
    }

    @Override
    protected void viewUser(UserPair users) {
        if (!viewUser(users.from))
            viewUser(users.to);
    }
}

<code block>

package com.github.mobile.ui.user;

import android.view.LayoutInflater;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.mobile.R;
import com.github.mobile.util.AvatarLoader;

import org.eclipse.egit.github.core.User;


public class UserListAdapter extends SingleTypeAdapter<User> {

    private final AvatarLoader avatars;


    public UserListAdapter(final LayoutInflater inflater,
            final User[] elements, final AvatarLoader avatars) {
        super(inflater, R.layout.user_item);

        this.avatars = avatars;
        setItems(elements);
    }

    @Override
    public long getItemId(final int position) {
        return getItem(position).getId();
    }

    @Override
    protected int[] getChildViewIds() {
        return new int[] { R.id.iv_avatar, R.id.tv_login };
    }

    @Override
    protected void update(final int position, final User user) {
        avatars.bind(imageView(0), user);
        setText(1, user.getLogin());
    }
}

<code block>

package com.github.mobile.ui.user;

import android.os.Bundle;

import com.github.mobile.R;



public abstract class FollowingFragment extends PagedUserFragment {

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        setEmptyText(R.string.no_people);
    }

    @Override
    protected int getLoadingMessage() {
        return R.string.loading_people;
    }

    @Override
    protected int getErrorMessage(Exception exception) {
        return R.string.error_people_load;
    }
}

<code block>

package com.github.mobile.ui.user;

import org.eclipse.egit.github.core.User;


public interface OrganizationSelectionListener {


    void onOrganizationSelected(User organization);
}
<code block>
package com.github.mobile.ui.user;

import com.github.mobile.ui.StyledText;
import com.github.mobile.util.TypefaceUtils;

import org.eclipse.egit.github.core.event.Event;
import org.eclipse.egit.github.core.event.IssuesPayload;

public enum EventType {
    CommitCommentEvent {
        @Override
        public String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details) {
            iconAndViewTextManager.formatCommitComment(event, main, details);
            return TypefaceUtils.ICON_COMMENT;
        }
    },
    CreateEvent {
        @Override
        public String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details) {
            iconAndViewTextManager.formatCreate(event, main, details);
            return TypefaceUtils.ICON_CREATE;
        }
    },
    DeleteEvent {
        @Override
        public String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details) {
            iconAndViewTextManager.formatDelete(event, main, details);
            return TypefaceUtils.ICON_DELETE;
        }
    },
    DownloadEvent {
        @Override
        public String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details) {
            iconAndViewTextManager.formatDownload(event, main, details);
            return TypefaceUtils.ICON_UPLOAD;
        }
    },
    FollowEvent {
        @Override
        public String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details) {
            iconAndViewTextManager.formatFollow(event, main, details);
            return TypefaceUtils.ICON_FOLLOW;
        }
    },
    ForkEvent {
        @Override
        public String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details) {
            iconAndViewTextManager.formatFork(event, main, details);
            return TypefaceUtils.ICON_FORK;
        }
    },
    GistEvent {
        @Override
        public String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details) {
            iconAndViewTextManager.formatGist(event, main, details);
            return TypefaceUtils.ICON_GIST;
        }
    },
    GollumEvent {
        @Override
        public String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details) {
            iconAndViewTextManager.formatWiki(event, main, details);
            return TypefaceUtils.ICON_WIKI;
        }
    },
    IssueCommentEvent {
        @Override
        public String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details) {
            iconAndViewTextManager.formatIssueComment(event, main, details);
            return TypefaceUtils.ICON_ISSUE_COMMENT;
        }
    },
    IssuesEvent {
        @Override
        public String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details) {
            iconAndViewTextManager.formatIssues(event, main, details);
            String action = ((IssuesPayload) event.getPayload()).getAction();
            String icon = null;
            if (IconAndViewTextManager.ISSUES_PAYLOAD_ACTION_OPENED.equals(action))
                icon = TypefaceUtils.ICON_ISSUE_OPEN;
            else if (IconAndViewTextManager.ISSUES_PAYLOAD_ACTION_REOPENED.equals(action))
                icon = TypefaceUtils.ICON_ISSUE_REOPEN;
            else if (IconAndViewTextManager.ISSUES_PAYLOAD_ACTION_CLOSED.equals(action))
                icon = TypefaceUtils.ICON_ISSUE_CLOSE;
            return icon;
        }
    },
    MemberEvent {
        @Override
        public String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details) {
            iconAndViewTextManager.formatAddMember(event, main, details);
            return TypefaceUtils.ICON_ADD_MEMBER;
        }
    },
    PublicEvent {
        @Override
        public String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details) {
            iconAndViewTextManager.formatPublic(event, main, details);
            return null;
        }
    },
    PullRequestEvent {
        @Override
        public String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details) {
            iconAndViewTextManager.formatPullRequest(event, main, details);
            return TypefaceUtils.ICON_PULL_REQUEST;
        }
    },
    PullRequestReviewCommentEvent {
        @Override
        public String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details) {
            iconAndViewTextManager.formatReviewComment(event, main, details);
            return TypefaceUtils.ICON_COMMENT;
        }
    },
    PushEvent {
        @Override
        public String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details) {
            iconAndViewTextManager.formatPush(event, main, details);
            return TypefaceUtils.ICON_PUSH;
        }
    },
    TeamAddEvent {
        @Override
        public String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details) {
            iconAndViewTextManager.formatTeamAdd(event, main, details);
            return TypefaceUtils.ICON_ADD_MEMBER;
        }
    },
    WatchEvent {
        @Override
        public String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details) {
            iconAndViewTextManager.formatWatch(event, main, details);
            return TypefaceUtils.ICON_STAR;
        }
    },
    ;

    public abstract String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details);
}

<code block>

package com.github.mobile.ui.user;

import com.github.mobile.core.ResourcePager;
import com.github.mobile.core.user.UserPager;

import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.client.PageIterator;


public class MyFollowingFragment extends FollowingFragment {

    @Override
    protected ResourcePager<User> createPager() {
        return new UserPager() {

            @Override
            public PageIterator<User> createIterator(int page, int size) {
                return service.pageFollowing(page, size);
            }
        };
    }
}

<code block>

package com.github.mobile.ui.user;

import android.content.res.Resources;
import android.support.v4.app.Fragment;
import android.support.v7.app.ActionBarActivity;

import com.github.mobile.R;
import com.github.mobile.ui.FragmentPagerAdapter;
import com.github.mobile.ui.repo.UserRepositoryListFragment;


public class UserPagerAdapter extends FragmentPagerAdapter {

    private final Resources resources;


    public UserPagerAdapter(final ActionBarActivity activity) {
        super(activity);

        resources = activity.getResources();
    }

    @Override
    public Fragment getItem(final int position) {
        switch (position) {
        case 0:
            return new UserCreatedNewsFragment();
        case 1:
            return new UserRepositoryListFragment();
        case 2:
            return new UserFollowersFragment();
        case 3:
            return new UserFollowingFragment();
        default:
            return null;
        }
    }

    @Override
    public int getCount() {
        return 4;
    }

    @Override
    public CharSequence getPageTitle(int position) {
        switch (position) {
        case 0:
            return resources.getString(R.string.tab_news);
        case 1:
            return resources.getString(R.string.tab_repositories);
        case 2:
            return resources.getString(R.string.tab_followers);
        case 3:
            return resources.getString(R.string.tab_following);
        default:
            return null;
        }
    }
}

<code block>

package com.github.mobile.ui.user;

import android.content.res.Resources;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.view.ViewGroup;

import com.github.mobile.R;
import com.github.mobile.ui.FragmentPagerAdapter;
import com.github.mobile.ui.repo.RepositoryListFragment;

import java.util.HashSet;
import java.util.Set;

import org.eclipse.egit.github.core.User;


public class HomePagerAdapter extends FragmentPagerAdapter {

    private final User org;

    private boolean defaultUser;

    private final FragmentManager fragmentManager;

    private final Resources resources;

    private final Set<String> tags = new HashSet<>();


    public HomePagerAdapter(final Fragment fragment,
        final boolean defaultUser, final User org) {
        super(fragment);

        this.org = org;
        fragmentManager = fragment.getChildFragmentManager();
        resources = fragment.getResources();
        this.defaultUser = defaultUser;
    }

    @Override
    public Fragment getItem(int position) {
        Fragment fragment = null;
        switch (position) {
            case 0:
                fragment = defaultUser ? new UserReceivedNewsFragment()
                    : new OrganizationNewsFragment();
                break;
            case 1:
                fragment = new RepositoryListFragment();
                break;
            case 2:
                fragment = defaultUser ? new MyFollowersFragment()
                    : new MembersFragment();
                break;
            case 3:
                fragment = new MyFollowingFragment();
                break;
        }

        if (fragment != null) {
            Bundle args = new Bundle();
            args.putSerializable("org", org);
            fragment.setArguments(args);
        }
        return fragment;
    }

    @Override
    public int getItemPosition(Object object) {
        return POSITION_NONE;
    }

    public Object instantiateItem(ViewGroup container, int position) {
        Object fragment = super.instantiateItem(container, position);
        if (fragment instanceof Fragment)
            tags.add(((Fragment) fragment).getTag());
        return fragment;
    }

    @Override
    public int getCount() {
        return defaultUser ? 4 : 3;
    }

    @Override
    public CharSequence getPageTitle(int position) {
        switch (position) {
            case 0:
                return resources.getString(R.string.tab_news);
            case 1:
                return resources.getString(R.string.tab_repositories);
            case 2:
                return resources.getString(defaultUser ? R.string.tab_followers_self
                    : R.string.tab_members);
            case 3:
                return resources.getString(R.string.tab_following_self);
            default:
                return null;
        }
    }
}

<code block>

package com.github.mobile.ui.user;

import static android.content.DialogInterface.BUTTON_POSITIVE;
import static android.content.Intent.ACTION_VIEW;
import static android.content.Intent.CATEGORY_BROWSABLE;
import static org.eclipse.egit.github.core.client.IGitHubConstants.HOST_DEFAULT;
import static org.eclipse.egit.github.core.client.IGitHubConstants.HOST_GISTS;
import static org.eclipse.egit.github.core.client.IGitHubConstants.PROTOCOL_HTTPS;
import android.app.Activity;
import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnCancelListener;
import android.content.DialogInterface.OnClickListener;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.text.TextUtils;

import com.github.mobile.R;
import com.github.mobile.core.commit.CommitMatch;
import com.github.mobile.core.commit.CommitUriMatcher;
import com.github.mobile.core.gist.GistUriMatcher;
import com.github.mobile.core.issue.IssueUriMatcher;
import com.github.mobile.core.repo.RepositoryUriMatcher;
import com.github.mobile.core.user.UserUriMatcher;
import com.github.mobile.ui.LightAlertDialog;
import com.github.mobile.ui.commit.CommitViewActivity;
import com.github.mobile.ui.gist.GistsViewActivity;
import com.github.mobile.ui.issue.IssuesViewActivity;
import com.github.mobile.ui.repo.RepositoryViewActivity;

import java.net.URI;
import java.text.MessageFormat;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.RepositoryIssue;
import org.eclipse.egit.github.core.User;


public class UriLauncherActivity extends Activity {

    static public void launchUri(Context context, Uri data) {
        Intent intent = getIntentForURI(data);
        if (intent != null) {
            context.startActivity(intent);
        } else {
            context.startActivity(new Intent(ACTION_VIEW, data).addCategory(CATEGORY_BROWSABLE));
        }
    }


    static public Intent convert(final Intent intent) {
        if (intent == null)
            return null;

        if (!ACTION_VIEW.equals(intent.getAction()))
            return null;

        Uri data = intent.getData();
        if (data == null)
            return null;

        if (TextUtils.isEmpty(data.getHost()) || TextUtils.isEmpty(data.getScheme())) {
            String host = data.getHost();
            if (TextUtils.isEmpty(host))
                host = HOST_DEFAULT;
            String scheme = data.getScheme();
            if (TextUtils.isEmpty(scheme))
                scheme = PROTOCOL_HTTPS;
            String prefix = scheme + "://" + host;

            String path = data.getPath();
            if (!TextUtils.isEmpty(path))
                if (path.charAt(0) == '/')
                    data = Uri.parse(prefix + path);
                else
                    data = Uri.parse(prefix + '/' + path);
            else
                data = Uri.parse(prefix);
            intent.setData(data);
        }

        return getIntentForURI(data);
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        final Intent intent = getIntent();
        final Uri data = intent.getData();

        final Intent newIntent = getIntentForURI(data);
        if (newIntent != null) {
            startActivity(newIntent);
            finish();
            return;
        }

        if (!intent.hasCategory(CATEGORY_BROWSABLE)) {
            startActivity(new Intent(ACTION_VIEW, data).addCategory(CATEGORY_BROWSABLE));
            finish();
        } else {
            showParseError(data.toString());
        }
    }

    static private Intent getIntentForURI(Uri data) {
        if (HOST_GISTS.equals(data.getHost())) {
            Gist gist = GistUriMatcher.getGist(data);
            if (gist != null) {
                return GistsViewActivity.createIntent(gist);
            }
        } else if (HOST_DEFAULT.equals(data.getHost())) {
            CommitMatch commit = CommitUriMatcher.getCommit(data);
            if (commit != null) {
                return CommitViewActivity.createIntent(commit.repository, commit.commit);
            }

            RepositoryIssue issue = IssueUriMatcher.getIssue(data);
            if (issue != null) {
                return IssuesViewActivity.createIntent(issue, issue.getRepository());
            }

            Repository repository = RepositoryUriMatcher.getRepository(data);
            if (repository != null) {
                return RepositoryViewActivity.createIntent(repository);
            }

            User user = UserUriMatcher.getUser(data);
            if (user != null) {
                return UserViewActivity.createIntent(user);
            }
        }

        return null;
    }

    private void showParseError(String url) {
        AlertDialog dialog = LightAlertDialog.create(this);
        dialog.setTitle(R.string.title_invalid_github_url);
        dialog.setMessage(MessageFormat.format(getString(R.string.message_invalid_github_url), url));
        dialog.setOnCancelListener(new OnCancelListener() {

            @Override
            public void onCancel(DialogInterface dialog) {
                finish();
            }
        });
        dialog.setButton(BUTTON_POSITIVE, getString(android.R.string.ok),
                new OnClickListener() {

                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        finish();
                    }
                });
        dialog.show();
    }
}

<code block>

package com.github.mobile.ui.user;

import com.github.mobile.core.ResourcePager;

import org.eclipse.egit.github.core.event.Event;


public abstract class EventPager extends ResourcePager<Event> {

    @Override
    protected Object getId(Event resource) {
        return resource.getId();
    }

    @Override
    protected Event register(Event resource) {
        return NewsListAdapter.isValid(resource) ? resource : null;
    }
}

<code block>
package com.github.mobile.ui.user;

import android.content.Context;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.support.annotation.Nullable;
import android.view.View;

import com.github.mobile.accounts.AccountUtils;
import com.github.mobile.ui.TabPagerFragment;
import com.github.mobile.util.PreferenceUtils;

import org.eclipse.egit.github.core.User;

public class HomePagerFragment extends TabPagerFragment<HomePagerAdapter> {

    private static final String TAG = "HomePagerFragment";

    private static final String PREF_ORG_ID = "orgId";

    private SharedPreferences sharedPreferences;

    private boolean isDefaultUser;

    private User org;

    @Override
    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        sharedPreferences = getActivity().getPreferences(Context.MODE_PRIVATE);
        setOrg((User) getArguments().getSerializable("org"));
    }

    private void setOrg(User org) {
        PreferenceUtils.save(sharedPreferences.edit().putInt(PREF_ORG_ID,
            org.getId()));
        this.org = org;
        this.isDefaultUser = AccountUtils.isUser(getActivity(), org);
        configureTabPager();
    }

    @Override
    protected HomePagerAdapter createAdapter() {
        return new HomePagerAdapter(this, isDefaultUser, org);
    }
}

<code block>

package com.github.mobile.ui.issue;

import static com.github.mobile.RequestCodes.ISSUE_VIEW;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.widget.ListView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.mobile.R;
import com.github.mobile.core.ResourcePager;
import com.github.mobile.core.issue.IssueStore;
import com.github.mobile.ui.PagedItemFragment;
import com.github.mobile.util.AvatarLoader;
import com.google.inject.Inject;

import java.util.List;
import java.util.Map;

import org.eclipse.egit.github.core.RepositoryIssue;
import org.eclipse.egit.github.core.client.PageIterator;
import org.eclipse.egit.github.core.service.IssueService;


public class DashboardIssueFragment extends PagedItemFragment<RepositoryIssue> {


    public static final String ARG_FILTER = "filter";

    @Inject
    private IssueService service;

    @Inject
    private IssueStore store;

    @Inject
    private AvatarLoader avatars;

    private Map<String, String> filterData;

    @SuppressWarnings("unchecked")
    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        filterData = (Map<String, String>) getArguments().getSerializable(
                ARG_FILTER);
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (requestCode == ISSUE_VIEW) {
            notifyDataSetChanged();
            forceRefresh();
            return;
        }

        super.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    public void onListItemClick(ListView l, View v, int position, long id) {
        startActivityForResult(
                IssuesViewActivity.createIntent(items, position
                        - getListAdapter().getHeadersCount()), ISSUE_VIEW);
    }

    @Override
    protected ResourcePager<RepositoryIssue> createPager() {
        return new ResourcePager<RepositoryIssue>() {

            @Override
            protected RepositoryIssue register(RepositoryIssue resource) {
                return store.addIssue(resource);
            }

            @Override
            protected Object getId(RepositoryIssue resource) {
                return resource.getId();
            }

            @Override
            public PageIterator<RepositoryIssue> createIterator(int page,
                    int size) {
                return service.pageIssues(filterData, page, size);
            }
        };
    }

    @Override
    protected int getLoadingMessage() {
        return R.string.loading_issues;
    }

    @Override
    protected int getErrorMessage(Exception exception) {
        return R.string.error_issues_load;
    }

    @Override
    protected SingleTypeAdapter<RepositoryIssue> createAdapter(
            List<RepositoryIssue> items) {
        return new DashboardIssueListAdapter(avatars, getActivity()
                .getLayoutInflater(), items.toArray(new RepositoryIssue[items
                .size()]));
    }
}

<code block>

package com.github.mobile.ui.issue;

import android.accounts.Account;
import android.app.Activity;
import android.content.Context;
import android.util.Log;

import com.github.mobile.R;
import com.github.mobile.ui.ProgressDialogTask;
import com.github.mobile.util.ToastUtils;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.service.IssueService;


public class DeleteCommentTask extends ProgressDialogTask<Comment> {

    private static final String TAG = "DeleteCommentTask";

    private final IRepositoryIdProvider repository;

    private final Comment comment;

    @Inject
    private IssueService service;


    public DeleteCommentTask(final Context context,
            final IRepositoryIdProvider repository,
            final Comment comment) {
        super(context);

        this.repository = repository;
        this.comment = comment;
    }

    @Override
    protected Comment run(Account account) throws Exception {
        service.deleteComment(repository, comment.getId());
        return comment;
    }


    public DeleteCommentTask start() {
        showIndeterminate(R.string.deleting_comment);

        execute();
        return this;
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception deleting comment on issue", e);

        ToastUtils.show((Activity) getContext(), e.getMessage());
    }
}

<code block>

package com.github.mobile.ui.issue;

import static java.lang.String.CASE_INSENSITIVE_ORDER;
import static org.eclipse.egit.github.core.service.IssueService.STATE_CLOSED;
import static org.eclipse.egit.github.core.service.IssueService.STATE_OPEN;
import android.accounts.Account;
import android.util.Log;

import com.github.mobile.R;
import com.github.mobile.ui.DialogFragmentActivity;
import com.github.mobile.ui.ProgressDialogTask;
import com.github.mobile.util.ToastUtils;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.Milestone;
import org.eclipse.egit.github.core.service.MilestoneService;


public class MilestoneDialog {

    private static final String TAG = "MilestoneDialog";

    private MilestoneService service;

    private ArrayList<Milestone> repositoryMilestones;

    private final int requestCode;

    private final DialogFragmentActivity activity;

    private final IRepositoryIdProvider repository;


    public MilestoneDialog(final DialogFragmentActivity activity,
            final int requestCode, final IRepositoryIdProvider repository,
            final MilestoneService service) {
        this.activity = activity;
        this.requestCode = requestCode;
        this.repository = repository;
        this.service = service;
    }


    public List<Milestone> getMilestones() {
        return repositoryMilestones;
    }

    private void load(final Milestone selectedMilestone) {
        new ProgressDialogTask<ArrayList<Milestone>>(activity) {

            @Override
            public ArrayList<Milestone> run(Account account) throws Exception {
                ArrayList<Milestone> milestones = new ArrayList<>();
                milestones
                        .addAll(service.getMilestones(repository, STATE_OPEN));
                milestones.addAll(service.getMilestones(repository,
                        STATE_CLOSED));
                Collections.sort(milestones, new Comparator<Milestone>() {

                    public int compare(Milestone m1, Milestone m2) {
                        return CASE_INSENSITIVE_ORDER.compare(m1.getTitle(),
                                m2.getTitle());
                    }
                });
                return milestones;
            }

            @Override
            protected void onSuccess(ArrayList<Milestone> all) throws Exception {
                super.onSuccess(all);

                repositoryMilestones = all;
                show(selectedMilestone);
            }

            @Override
            protected void onException(Exception e) throws RuntimeException {
                super.onException(e);

                Log.d(TAG, "Exception loading milestones", e);
                ToastUtils.show(activity, e, R.string.error_milestones_load);
            }

            @Override
            public void execute() {
                showIndeterminate(R.string.loading_milestones);

                super.execute();
            }
        }.execute();
    }


    public void show(Milestone selectedMilestone) {
        if (repositoryMilestones == null) {
            load(selectedMilestone);
            return;
        }

        int checked = -1;
        if (selectedMilestone != null)
            for (int i = 0; i < repositoryMilestones.size(); i++)
                if (selectedMilestone.getNumber() == repositoryMilestones
                        .get(i).getNumber()) {
                    checked = i;
                    break;
                }
        MilestoneDialogFragment.show(activity, requestCode,
                activity.getString(R.string.select_milestone), null,
                repositoryMilestones, checked);
    }


    public int getMilestoneNumber(String title) {
        if (repositoryMilestones == null)
            return -1;
        for (Milestone milestone : repositoryMilestones)
            if (title.equals(milestone.getTitle()))
                return milestone.getNumber();
        return -1;
    }
}

<code block>

package com.github.mobile.ui.issue;

import static com.github.mobile.RequestCodes.ISSUE_LABELS_UPDATE;
import android.accounts.Account;

import com.github.mobile.R;
import com.github.mobile.core.issue.IssueStore;
import com.github.mobile.ui.DialogFragmentActivity;
import com.github.mobile.ui.ProgressDialogTask;
import com.google.inject.Inject;

import java.util.Arrays;
import java.util.List;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.Label;
import org.eclipse.egit.github.core.service.LabelService;


public class EditLabelsTask extends ProgressDialogTask<Issue> {

    @Inject
    private IssueStore store;

    @Inject
    private LabelService service;

    private final LabelsDialog labelsDialog;

    private final IRepositoryIdProvider repositoryId;

    private final int issueNumber;

    private Label[] labels;


    public EditLabelsTask(final DialogFragmentActivity activity,
            final IRepositoryIdProvider repositoryId, final int issueNumber) {
        super(activity);

        this.repositoryId = repositoryId;
        this.issueNumber = issueNumber;
        labelsDialog = new LabelsDialog(activity, ISSUE_LABELS_UPDATE,
                repositoryId, service);
    }


    public EditLabelsTask prompt(List<Label> labels) {
        labelsDialog.show(labels);
        return this;
    }


    public EditLabelsTask edit(Label[] labels) {
        showIndeterminate(R.string.updating_labels);

        this.labels = labels;

        execute();
        return this;
    }

    @Override
    public Issue run(Account account) throws Exception {
        Issue editedIssue = new Issue();
        editedIssue.setNumber(issueNumber);
        if (labels != null && labels.length > 0)
            editedIssue.setLabels(Arrays.asList(labels));
        return store.editIssue(repositoryId, editedIssue);
    }
}

<code block>

package com.github.mobile.ui.issue;

import android.view.LayoutInflater;
import android.widget.TextView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.mobile.R;
import com.github.mobile.core.issue.IssueFilter;
import com.github.mobile.util.AvatarLoader;

import java.util.Collection;

import org.eclipse.egit.github.core.Label;
import org.eclipse.egit.github.core.Milestone;
import org.eclipse.egit.github.core.User;


public class FilterListAdapter extends SingleTypeAdapter<IssueFilter> {

    private final AvatarLoader avatars;


    public FilterListAdapter(LayoutInflater inflater, IssueFilter[] elements,
            AvatarLoader avatars) {
        super(inflater, R.layout.issues_filter_item);

        this.avatars = avatars;
        setItems(elements);
    }

    @Override
    protected int[] getChildViewIds() {
        return new int[] { R.id.iv_avatar, R.id.tv_repo_name, R.id.tv_filter_state,
                R.id.tv_filter_labels, R.id.tv_filter_milestone, R.id.ll_assignee,
                R.id.tv_filter_assignee, R.id.iv_assignee_avatar };
    }

    @Override
    protected void update(int position, IssueFilter filter) {
        avatars.bind(imageView(0), filter.getRepository().getOwner());
        setText(1, filter.getRepository().generateId());
        if (filter.isOpen())
            setText(2, R.string.open_issues);
        else
            setText(2, R.string.closed_issues);

        Collection<Label> labels = filter.getLabels();
        if (labels != null && !labels.isEmpty()) {
            TextView labelsText = textView(3);
            LabelDrawableSpan.setText(labelsText, labels);
            ViewUtils.setGone(labelsText, false);
        } else
            setGone(3, true);

        Milestone milestone = filter.getMilestone();
        if (milestone != null)
            ViewUtils.setGone(setText(4, milestone.getTitle()), false);
        else
            setGone(4, true);

        User assignee = filter.getAssignee();
        if (assignee != null) {
            avatars.bind(imageView(7), assignee);
            ViewUtils.setGone(setText(6, assignee.getLogin()), false);
        } else
            setGone(5, true);
    }
}

<code block>

package com.github.mobile.ui.issue;

import static com.github.mobile.Intents.EXTRA_ISSUE_NUMBER;
import static com.github.mobile.Intents.EXTRA_REPOSITORY_NAME;
import static com.github.mobile.Intents.EXTRA_REPOSITORY_OWNER;
import static com.github.mobile.Intents.EXTRA_USER;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.ActionBar;

import com.github.mobile.Intents.Builder;
import com.github.mobile.R;
import com.github.mobile.ui.comment.CommentPreviewPagerAdapter;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.RepositoryId;
import org.eclipse.egit.github.core.User;


public class CreateCommentActivity extends
        com.github.mobile.ui.comment.CreateCommentActivity {


    public static Intent createIntent(RepositoryId repoId, int issueNumber,
            User user) {
        Builder builder = new Builder("issue.comment.create.VIEW");
        builder.repo(repoId);
        builder.add(EXTRA_ISSUE_NUMBER, issueNumber);
        builder.add(EXTRA_USER, user);
        return builder.toIntent();
    }

    private RepositoryId repositoryId;

    private int issueNumber;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        issueNumber = getIntExtra(EXTRA_ISSUE_NUMBER);
        repositoryId = new RepositoryId(getStringExtra(EXTRA_REPOSITORY_OWNER),
                getStringExtra(EXTRA_REPOSITORY_NAME));

        super.onCreate(savedInstanceState);

        ActionBar actionBar = getSupportActionBar();
        actionBar.setTitle(getString(R.string.issue_title) + issueNumber);
        actionBar.setSubtitle(repositoryId.generateId());
        avatars.bind(actionBar, (User) getSerializableExtra(EXTRA_USER));
    }

    @Override
    protected void createComment(String comment) {
        new CreateCommentTask(this, repositoryId, issueNumber, comment) {

            @Override
            protected void onSuccess(Comment comment) throws Exception {
                super.onSuccess(comment);

                finish(comment);
            }
        }.start();
    }

    @Override
    protected CommentPreviewPagerAdapter createAdapter() {
        return new CommentPreviewPagerAdapter(this, repositoryId);
    }
}

<code block>

package com.github.mobile.ui.issue;

import static android.graphics.Paint.STRIKE_THRU_TEXT_FLAG;
import static org.eclipse.egit.github.core.service.IssueService.STATE_CLOSED;
import android.graphics.Color;
import android.text.TextUtils;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.TextView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.mobile.R;
import com.github.mobile.ui.StyledText;
import com.github.mobile.util.AvatarLoader;
import com.github.mobile.util.TypefaceUtils;

import java.util.Date;
import java.util.List;

import org.eclipse.egit.github.core.Label;


public abstract class IssueListAdapter<V> extends SingleTypeAdapter<V> {


    protected static final int MAX_LABELS = 8;


    protected final AvatarLoader avatars;


    private final TextView numberView;


    private int numberWidth;


    public IssueListAdapter(int viewId, LayoutInflater inflater,
            Object[] elements, AvatarLoader avatars) {
        super(inflater, viewId);

        this.avatars = avatars;
        numberView = (TextView) inflater.inflate(viewId, null).findViewById(
                R.id.tv_issue_number);
        setItems(elements);
    }


    protected abstract int getNumber(V issue);

    @SuppressWarnings("unchecked")
    private void computeNumberWidth(final Object[] items) {
        int[] numbers = new int[items.length];
        for (int i = 0; i < numbers.length; i++)
            numbers[i] = getNumber((V) items[i]);
        int digits = Math.max(TypefaceUtils.getMaxDigits(numbers), 4);
        numberWidth = TypefaceUtils.getWidth(numberView, digits)
                + numberView.getPaddingLeft() + numberView.getPaddingRight();
    }

    @Override
    public void setItems(final Object[] items) {
        super.setItems(items);

        computeNumberWidth(items);
    }


    protected void updateNumber(int number, String state, int flags,
            int viewIndex) {
        TextView view = textView(viewIndex);
        view.setText(Integer.toString(number));
        if (STATE_CLOSED.equals(state))
            view.setPaintFlags(flags | STRIKE_THRU_TEXT_FLAG);
        else
            view.setPaintFlags(flags);
        view.getLayoutParams().width = numberWidth;
    }


    protected void updateReporter(String reporter, Date date, int viewIndex) {
        StyledText reporterText = new StyledText();
        reporterText.bold(reporter);
        reporterText.append(' ');
        reporterText.append(date);
        setText(viewIndex, reporterText);
    }


    protected void updateLabels(final List<Label> labels, final int viewIndex) {
        if (labels != null && !labels.isEmpty()) {
            int size = Math.min(labels.size(), MAX_LABELS);
            for (int i = 0; i < size; i++) {
                String color = labels.get(i).getColor();
                if (!TextUtils.isEmpty(color)) {
                    View view = view(viewIndex + i);
                    view.setBackgroundColor(Color.parseColor('#' + color));
                    ViewUtils.setGone(view, false);
                } else
                    setGone(viewIndex + i, true);
            }
            for (int i = size; i < MAX_LABELS; i++)
                setGone(viewIndex + i, true);
        } else
            for (int i = 0; i < MAX_LABELS; i++)
                setGone(viewIndex + i, true);
    }
}

<code block>

package com.github.mobile.ui.issue;

import android.view.LayoutInflater;
import android.view.View;
import android.widget.TextView;

import com.github.mobile.R;
import com.github.mobile.core.issue.IssueUtils;
import com.github.mobile.util.AvatarLoader;
import com.github.mobile.util.TypefaceUtils;

import org.eclipse.egit.github.core.RepositoryIssue;


public class DashboardIssueListAdapter extends
        IssueListAdapter<RepositoryIssue> {

    private int numberPaintFlags;


    public DashboardIssueListAdapter(AvatarLoader avatars,
            LayoutInflater inflater, RepositoryIssue[] elements) {
        super(R.layout.dashboard_issue_item, inflater, elements, avatars);
    }

    @Override
    public long getItemId(final int position) {
        return getItem(position).getId();
    }

    @Override
    protected int getNumber(final RepositoryIssue issue) {
        return issue.getNumber();
    }

    @Override
    protected View initialize(View view) {
        view = super.initialize(view);

        numberPaintFlags = textView(view, 1).getPaintFlags();
        TypefaceUtils.setOcticons(textView(view, 6),
                (TextView) view.findViewById(R.id.tv_comment_icon));
        return view;
    }

    @Override
    protected int[] getChildViewIds() {
        return new int[] { R.id.tv_issue_repo_name, R.id.tv_issue_number,
                R.id.tv_issue_title, R.id.iv_avatar, R.id.tv_issue_creation,
                R.id.tv_issue_comments, R.id.tv_pull_request_icon, R.id.v_label0,
                R.id.v_label1, R.id.v_label2, R.id.v_label3, R.id.v_label4,
                R.id.v_label5, R.id.v_label6, R.id.v_label7 };
    }

    @Override
    protected void update(int position, RepositoryIssue issue) {
        updateNumber(issue.getNumber(), issue.getState(), numberPaintFlags, 1);

        avatars.bind(imageView(3), issue.getUser());

        String[] segments = issue.getUrl().split("/");
        int length = segments.length;
        if (length >= 4)
            setText(0, segments[length - 4] + '/' + segments[length - 3]);
        else
            setText(0, null);

        setGone(6, !IssueUtils.isPullRequest(issue));

        setText(2, issue.getTitle());

        updateReporter(issue.getUser().getLogin(), issue.getCreatedAt(), 4);
        setNumber(5, issue.getComments());
        updateLabels(issue.getLabels(), 7);
    }
}

<code block>

package com.github.mobile.ui.issue;

import static android.app.Activity.RESULT_OK;
import static android.content.DialogInterface.BUTTON_NEGATIVE;
import static android.content.DialogInterface.BUTTON_NEUTRAL;
import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.DialogInterface;
import android.os.Bundle;
import android.text.TextUtils;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ListView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.mobile.R;
import com.github.mobile.ui.DialogFragmentActivity;
import com.github.mobile.ui.SingleChoiceDialogFragment;

import java.util.ArrayList;

import org.eclipse.egit.github.core.Milestone;


public class MilestoneDialogFragment extends SingleChoiceDialogFragment {

    private static class MilestoneListAdapter extends
            SingleTypeAdapter<Milestone> {

        private final int selected;

        public MilestoneListAdapter(LayoutInflater inflater,
                Milestone[] milestones, int selected) {
            super(inflater, R.layout.milestone_item);

            this.selected = selected;
            setItems(milestones);
        }

        @Override
        protected int[] getChildViewIds() {
            return new int[] { R.id.rb_selected, R.id.tv_milestone_title,
                    R.id.tv_milestone_description };
        }

        @Override
        protected void update(int position, Milestone item) {
            setText(1, item.getTitle());

            String description = item.getDescription();
            if (!TextUtils.isEmpty(description))
                ViewUtils.setGone(setText(2, description), false);
            else
                setGone(2, true);

            setChecked(0, selected == position);
        }

        @Override
        public long getItemId(int position) {
            return getItem(position).getNumber();
        }
    }


    public static Milestone getSelected(Bundle arguments) {
        return (Milestone) arguments.getSerializable(ARG_SELECTED);
    }


    public static void show(final DialogFragmentActivity activity,
            final int requestCode, final String title, final String message,
            ArrayList<Milestone> choices, final int selectedChoice) {
        show(activity, requestCode, title, message, choices, selectedChoice,
                new MilestoneDialogFragment());
    }

    @Override
    public Dialog onCreateDialog(final Bundle savedInstanceState) {
        Activity activity = getActivity();
        Bundle arguments = getArguments();

        final AlertDialog dialog = createDialog();
        dialog.setButton(BUTTON_NEGATIVE, activity.getString(R.string.cancel),
                this);
        dialog.setButton(BUTTON_NEUTRAL, activity.getString(R.string.clear), this);

        LayoutInflater inflater = activity.getLayoutInflater();

        ListView view = (ListView) inflater.inflate(R.layout.dialog_list_view,
                null);
        view.setOnItemClickListener(new OnItemClickListener() {

            @Override
            public void onItemClick(AdapterView<?> parent, View view,
                    int position, long id) {
                onClick(dialog, position);
            }
        });

        ArrayList<Milestone> choices = getChoices();
        int selected = arguments.getInt(ARG_SELECTED_CHOICE);
        MilestoneListAdapter adapter = new MilestoneListAdapter(inflater,
                choices.toArray(new Milestone[choices.size()]), selected);
        view.setAdapter(adapter);
        if (selected >= 0)
            view.setSelection(selected);
        dialog.setView(view);

        return dialog;
    }

    @SuppressWarnings("unchecked")
    private ArrayList<Milestone> getChoices() {
        return (ArrayList<Milestone>) getArguments().getSerializable(
                ARG_CHOICES);
    }

    @Override
    public void onClick(DialogInterface dialog, int which) {
        super.onClick(dialog, which);

        switch (which) {
        case BUTTON_NEGATIVE:
            break;
        case BUTTON_NEUTRAL:
            onResult(RESULT_OK);
            break;
        default:
            getArguments().putSerializable(ARG_SELECTED,
                    getChoices().get(which));
            onResult(RESULT_OK);
        }
    }
}

<code block>

package com.github.mobile.ui.issue;

import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
import static android.content.Intent.FLAG_ACTIVITY_SINGLE_TOP;
import static com.github.mobile.Intents.EXTRA_ISSUE_NUMBERS;
import static com.github.mobile.Intents.EXTRA_POSITION;
import static com.github.mobile.Intents.EXTRA_REPOSITORIES;
import static com.github.mobile.Intents.EXTRA_REPOSITORY;
import android.accounts.Account;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.ActionBar;
import android.view.Menu;
import android.view.MenuItem;

import com.github.mobile.Intents.Builder;
import com.github.mobile.R;
import com.github.mobile.accounts.AccountUtils;
import com.github.mobile.accounts.AuthenticatedUserTask;
import com.github.mobile.core.issue.IssueStore;
import com.github.mobile.core.issue.IssueUtils;
import com.github.mobile.core.repo.RefreshRepositoryTask;
import com.github.mobile.ui.FragmentProvider;
import com.github.mobile.ui.PagerActivity;
import com.github.mobile.ui.ViewPager;
import com.github.mobile.ui.repo.RepositoryViewActivity;
import com.github.mobile.ui.user.UriLauncherActivity;
import com.github.mobile.util.AvatarLoader;
import com.google.inject.Inject;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;

import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.RepositoryId;
import org.eclipse.egit.github.core.RepositoryIssue;
import org.eclipse.egit.github.core.Team;
import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.service.CollaboratorService;
import org.eclipse.egit.github.core.service.TeamService;


public class IssuesViewActivity extends PagerActivity {

    private static final String EXTRA_PULL_REQUESTS = "pullRequests";


    public static Intent createIntent(final Issue issue) {
        return createIntent(Collections.singletonList(issue), 0);
    }


    public static Intent createIntent(final Issue issue,
        final Repository repository) {
        return createIntent(Collections.singletonList(issue), repository, 0);
    }


    public static Intent createIntent(final Collection<? extends Issue> issues,
        final Repository repository, final int position) {
        int[] numbers = new int[issues.size()];
        boolean[] pullRequests = new boolean[issues.size()];
        int index = 0;
        for (Issue issue : issues) {
            numbers[index] = issue.getNumber();
            pullRequests[index] = IssueUtils.isPullRequest(issue);
            index++;
        }
        return new Builder("issues.VIEW").add(EXTRA_ISSUE_NUMBERS, numbers)
            .add(EXTRA_REPOSITORY, repository)
            .add(EXTRA_POSITION, position)
            .add(EXTRA_PULL_REQUESTS, pullRequests).toIntent();
    }


    public static Intent createIntent(Collection<? extends Issue> issues,
        int position) {
        final int count = issues.size();
        int[] numbers = new int[count];
        boolean[] pullRequests = new boolean[count];
        ArrayList<RepositoryId> repos = new ArrayList<>(count);
        int index = 0;
        for (Issue issue : issues) {
            numbers[index] = issue.getNumber();
            pullRequests[index] = IssueUtils.isPullRequest(issue);
            index++;

            RepositoryId repoId = null;
            if (issue instanceof RepositoryIssue) {
                Repository issueRepo = ((RepositoryIssue) issue)
                    .getRepository();
                if (issueRepo != null) {
                    User owner = issueRepo.getOwner();
                    if (owner != null)
                        repoId = RepositoryId.create(owner.getLogin(),
                            issueRepo.getName());
                }
            }
            if (repoId == null)
                repoId = RepositoryId.createFromUrl(issue.getHtmlUrl());
            repos.add(repoId);
        }

        Builder builder = new Builder("issues.VIEW");
        builder.add(EXTRA_ISSUE_NUMBERS, numbers);
        builder.add(EXTRA_REPOSITORIES, repos);
        builder.add(EXTRA_POSITION, position);
        builder.add(EXTRA_PULL_REQUESTS, pullRequests);
        return builder.toIntent();
    }

    private ViewPager pager;

    private int[] issueNumbers;

    private boolean[] pullRequests;

    private ArrayList<RepositoryId> repoIds;

    private Repository repo;

    @Inject
    private AvatarLoader avatars;

    @Inject
    private IssueStore store;

    @Inject
    private TeamService teamService;

    @Inject
    private CollaboratorService collaboratorService;

    private final AtomicReference<User> user = new AtomicReference<>();

    private boolean isCollaborator;

    private boolean isOwner;

    private IssuesPagerAdapter adapter;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        issueNumbers = getIntArrayExtra(EXTRA_ISSUE_NUMBERS);
        pullRequests = getBooleanArrayExtra(EXTRA_PULL_REQUESTS);
        repoIds = getSerializableExtra(EXTRA_REPOSITORIES);
        repo = getSerializableExtra(EXTRA_REPOSITORY);

        setContentView(R.layout.pager);

        setSupportActionBar((android.support.v7.widget.Toolbar) findViewById(R.id.toolbar));

        getSupportActionBar().setDisplayHomeAsUpEnabled(true);
        if (repo != null) {
            ActionBar actionBar = getSupportActionBar();
            actionBar.setSubtitle(repo.generateId());
            user.set(repo.getOwner());
            avatars.bind(actionBar, user);
        }



        if (issueNumbers.length == 1
            && (user.get() == null || user.get().getAvatarUrl() == null))
            new RefreshRepositoryTask(this, repo != null ? repo : repoIds.get(0)) {

                @Override
                protected void onSuccess(Repository fullRepository)
                    throws Exception {
                    super.onSuccess(fullRepository);

                    avatars.bind(getSupportActionBar(),
                        fullRepository.getOwner());
                }
            }.execute();

        isOwner = false;
        if(repo != null) {
            if (!AccountUtils.isUser(this, repo.getOwner()))
                checkOwnerStatus();
            else
                isOwner = repo.getOwner().getLogin().equals(AccountUtils.getLogin(this));
        }

        isCollaborator = false;
        checkCollaboratorStatus();
    }

    private void configurePager() {
        int initialPosition = getIntExtra(EXTRA_POSITION);
        pager = finder.find(R.id.vp_pages);

        if (repo != null)
            adapter = new IssuesPagerAdapter(this, repo, issueNumbers, isCollaborator, isOwner);
        else
            adapter = new IssuesPagerAdapter(this, repoIds, issueNumbers, store, isCollaborator, isOwner);
        pager.setAdapter(adapter);

        pager.setOnPageChangeListener(this);
        pager.scheduleSetItem(initialPosition, this);
        onPageSelected(initialPosition);
    }

    private void updateTitle(final int position) {
        int number = issueNumbers[position];
        boolean pullRequest = pullRequests[position];

        if (pullRequest)
            getSupportActionBar().setTitle(
                getString(R.string.pull_request_title) + number);
        else
            getSupportActionBar().setTitle(
                getString(R.string.issue_title) + number);
    }

    @Override
    public void onPageSelected(final int position) {
        super.onPageSelected(position);

        if (repo != null) {
            updateTitle(position);
            return;
        }

        if (repoIds == null)
            return;

        ActionBar actionBar = getSupportActionBar();
        RepositoryId repoId = repoIds.get(position);
        if (repoId != null) {
            updateTitle(position);
            actionBar.setSubtitle(repoId.generateId());
            RepositoryIssue issue = store.getIssue(repoId,
                issueNumbers[position]);
            if (issue != null) {
                Repository fullRepo = issue.getRepository();
                if (fullRepo != null && fullRepo.getOwner() != null) {
                    user.set(fullRepo.getOwner());
                    avatars.bind(actionBar, user);
                } else
                    actionBar.setLogo(null);
            } else
                actionBar.setLogo(null);
        } else {
            actionBar.setSubtitle(null);
            actionBar.setLogo(null);
        }
    }

    @Override
    public void onDialogResult(int requestCode, int resultCode, Bundle arguments) {
        adapter.onDialogResult(pager.getCurrentItem(), requestCode, resultCode,
            arguments);
    }

    @Override
    public void startActivity(Intent intent) {
        Intent converted = UriLauncherActivity.convert(intent);
        if (converted != null)
            super.startActivity(converted);
        else
            super.startActivity(intent);
    }

    @Override
    protected FragmentProvider getProvider() {
        return adapter;
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {

        return super.onPrepareOptionsMenu(menu);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                Repository repository = repo;
                if (repository == null) {
                    int position = pager.getCurrentItem();
                    RepositoryId repoId = repoIds.get(position);
                    if (repoId != null) {
                        RepositoryIssue issue = store.getIssue(repoId,
                            issueNumbers[position]);
                        if (issue != null)
                            repository = issue.getRepository();
                    }
                }
                if (repository != null) {
                    Intent intent = RepositoryViewActivity.createIntent(repository);
                    intent.addFlags(FLAG_ACTIVITY_CLEAR_TOP
                        | FLAG_ACTIVITY_SINGLE_TOP);
                    startActivity(intent);
                }
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    private void checkCollaboratorStatus() {
        new AuthenticatedUserTask<Boolean>(this) {

            @Override
            protected Boolean run(Account account) throws Exception {
                return collaboratorService.isCollaborator(repo != null ? repo : repoIds.get(0),
                    AccountUtils.getLogin(IssuesViewActivity.this));
            }

            @Override
            protected void onThrowable(Throwable t) throws RuntimeException {
                invalidateOptionsMenu();
                configurePager();
            }

            @Override
            protected void onSuccess(Boolean collaborator) throws Exception {
                super.onSuccess(collaborator);

                isCollaborator = collaborator;
                invalidateOptionsMenu();
                configurePager();
            }
        }.execute();
    }

    private void checkOwnerStatus() {
        new AuthenticatedUserTask<Boolean>(this) {

            @Override
            protected Boolean run(Account account) throws Exception {
                List<Team> teams = teamService.getTeams(repo.getOwner().getLogin());
                List<User> users = teamService.getMembers(teams.get(0).getId());

                String userName = AccountUtils.getLogin(IssuesViewActivity.this);
                for(User user : users)
                    if(user.getLogin().equals(userName))
                        return true;

                return false;
            }

            @Override
            protected void onThrowable(Throwable t) throws RuntimeException {
                invalidateOptionsMenu();
                configurePager();
            }

            @Override
            protected void onSuccess(Boolean owner) throws Exception {
                super.onSuccess(owner);

                isOwner = owner;
                invalidateOptionsMenu();
                configurePager();
            }
        }.execute();
    }
}

<code block>

package com.github.mobile.ui.issue;

import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
import static android.content.Intent.FLAG_ACTIVITY_SINGLE_TOP;
import static com.github.mobile.Intents.EXTRA_ISSUE_FILTER;
import static com.github.mobile.Intents.EXTRA_REPOSITORY;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.ActionBar;
import android.view.MenuItem;

import com.github.mobile.Intents.Builder;
import com.github.mobile.R;
import com.github.mobile.core.issue.IssueFilter;
import com.github.mobile.ui.DialogFragmentActivity;
import com.github.mobile.util.AvatarLoader;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Repository;


public class IssueBrowseActivity extends DialogFragmentActivity {


    public static Intent createIntent(IssueFilter filter) {
        return new Builder("repo.issues.VIEW").repo(filter.getRepository())
            .add(EXTRA_ISSUE_FILTER, filter).toIntent();
    }

    private Repository repo;

    @Inject
    private AvatarLoader avatars;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        repo = getSerializableExtra(EXTRA_REPOSITORY);

        setContentView(R.layout.repo_issue_list);

        setSupportActionBar((android.support.v7.widget.Toolbar) findViewById(R.id.toolbar));

        ActionBar actionBar = getSupportActionBar();
        actionBar.setTitle(repo.getName());
        actionBar.setSubtitle(repo.getOwner().getLogin());
        actionBar.setDisplayHomeAsUpEnabled(true);
        avatars.bind(actionBar, repo.getOwner());
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                Intent intent = FiltersViewActivity.createIntent();
                intent.addFlags(FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_SINGLE_TOP);
                startActivity(intent);
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }
}

<code block>

package com.github.mobile.ui.issue;

import static com.github.mobile.RequestCodes.ISSUE_MILESTONE_UPDATE;
import android.accounts.Account;

import com.github.mobile.R;
import com.github.mobile.core.issue.IssueStore;
import com.github.mobile.ui.DialogFragmentActivity;
import com.github.mobile.ui.ProgressDialogTask;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.Milestone;
import org.eclipse.egit.github.core.service.MilestoneService;


public class EditMilestoneTask extends ProgressDialogTask<Issue> {

    @Inject
    private MilestoneService service;

    @Inject
    private IssueStore store;

    private final MilestoneDialog milestoneDialog;

    private final IRepositoryIdProvider repositoryId;

    private final int issueNumber;

    private int milestoneNumber;


    public EditMilestoneTask(final DialogFragmentActivity activity,
            final IRepositoryIdProvider repositoryId, final int issueNumber) {
        super(activity);

        this.repositoryId = repositoryId;
        this.issueNumber = issueNumber;
        milestoneDialog = new MilestoneDialog(activity, ISSUE_MILESTONE_UPDATE,
                repositoryId, service);
    }

    @Override
    protected Issue run(Account account) throws Exception {
        Issue editedIssue = new Issue();
        editedIssue.setNumber(issueNumber);
        editedIssue.setMilestone(new Milestone().setNumber(milestoneNumber));
        return store.editIssue(repositoryId, editedIssue);
    }


    public EditMilestoneTask prompt(Milestone milestone) {
        milestoneDialog.show(milestone);
        return this;
    }


    public EditMilestoneTask edit(Milestone milestone) {
        if (milestone != null)
            milestoneNumber = milestone.getNumber();
        else
            milestoneNumber = -1;

        showIndeterminate(R.string.updating_milestone);

        super.execute();

        return this;
    }
}

<code block>

package com.github.mobile.ui.issue;

import android.view.LayoutInflater;
import android.view.View;
import android.widget.TextView;

import com.github.mobile.R;
import com.github.mobile.core.issue.IssueUtils;
import com.github.mobile.util.AvatarLoader;
import com.github.mobile.util.TypefaceUtils;

import org.eclipse.egit.github.core.Issue;


public class RepositoryIssueListAdapter extends IssueListAdapter<Issue> {

    private int numberPaintFlags;


    public RepositoryIssueListAdapter(LayoutInflater inflater,
            Issue[] elements, AvatarLoader avatars) {
        super(R.layout.repo_issue_item, inflater, elements, avatars);
    }

    @Override
    public long getItemId(int position) {
        return getItem(position).getId();
    }

    @Override
    protected View initialize(View view) {
        view = super.initialize(view);

        numberPaintFlags = textView(view, 0).getPaintFlags();
        TypefaceUtils.setOcticons(textView(view, 5),
                (TextView) view.findViewById(R.id.tv_comment_icon));
        return view;
    }

    @Override
    protected int getNumber(Issue issue) {
        return issue.getNumber();
    }

    @Override
    protected int[] getChildViewIds() {
        return new int[] { R.id.tv_issue_number, R.id.tv_issue_title, R.id.iv_avatar,
                R.id.tv_issue_creation, R.id.tv_issue_comments,
                R.id.tv_pull_request_icon, R.id.v_label0, R.id.v_label1, R.id.v_label2,
                R.id.v_label3, R.id.v_label4, R.id.v_label5, R.id.v_label6, R.id.v_label7 };
    }

    @Override
    protected void update(int position, Issue issue) {
        updateNumber(issue.getNumber(), issue.getState(), numberPaintFlags, 0);

        avatars.bind(imageView(2), issue.getUser());

        setGone(5, !IssueUtils.isPullRequest(issue));

        setText(1, issue.getTitle());

        updateReporter(issue.getUser().getLogin(), issue.getCreatedAt(), 3);
        setNumber(4, issue.getComments());
        updateLabels(issue.getLabels(), 6);
    }
}

<code block>

package com.github.mobile.ui.issue;

import static android.app.SearchManager.APP_DATA;
import static android.app.SearchManager.QUERY;
import static android.content.Intent.ACTION_SEARCH;
import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
import static android.content.Intent.FLAG_ACTIVITY_SINGLE_TOP;
import static com.github.mobile.Intents.EXTRA_REPOSITORY;
import android.app.SearchManager;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.support.v4.view.MenuItemCompat;
import android.support.v7.app.ActionBar;
import android.support.v7.widget.SearchView;
import android.view.Menu;
import android.view.MenuItem;

import com.github.mobile.R;
import com.github.mobile.ui.repo.RepositoryViewActivity;
import com.github.mobile.ui.roboactivities.RoboActionBarActivity;
import com.github.mobile.util.AvatarLoader;
import com.github.mobile.util.ToastUtils;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Repository;


public class IssueSearchActivity extends RoboActionBarActivity {

    @Inject
    private AvatarLoader avatars;

    private Repository repository;

    private SearchIssueListFragment issueFragment;

    @Override
    public boolean onCreateOptionsMenu(Menu options) {
        getMenuInflater().inflate(R.menu.search, options);

        SearchManager searchManager = (SearchManager) getSystemService(Context.SEARCH_SERVICE);
        MenuItem searchItem = options.findItem(R.id.m_search);
        SearchView searchView = (SearchView) MenuItemCompat.getActionView(searchItem);
        searchView.setSearchableInfo(searchManager.getSearchableInfo(getComponentName()));

        Bundle args = new Bundle();
        args.putSerializable(EXTRA_REPOSITORY, repository);
        searchView.setAppSearchData(args);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.m_clear:
                IssueSearchSuggestionsProvider.clear(this);
                ToastUtils.show(this, R.string.search_history_cleared);
                return true;
            case android.R.id.home:
                Intent intent = RepositoryViewActivity.createIntent(repository);
                intent.addFlags(FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_SINGLE_TOP);
                startActivity(intent);
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.issue_search);

        setSupportActionBar((android.support.v7.widget.Toolbar) findViewById(R.id.toolbar));

        ActionBar actionBar = getSupportActionBar();
        Bundle appData = getIntent().getBundleExtra(APP_DATA);
        if (appData != null) {
            repository = (Repository) appData.getSerializable(EXTRA_REPOSITORY);
            if (repository != null) {
                actionBar.setSubtitle(repository.generateId());
                actionBar.setDisplayHomeAsUpEnabled(true);
            }
        }
        avatars.bind(actionBar, repository.getOwner());

        issueFragment = (SearchIssueListFragment) getSupportFragmentManager()
            .findFragmentById(android.R.id.list);

        handleIntent(getIntent());
    }

    @Override
    protected void onNewIntent(Intent intent) {
        setIntent(intent);
        issueFragment.setListShown(false);
        handleIntent(intent);
        issueFragment.refresh();
    }

    private void handleIntent(Intent intent) {
        if (ACTION_SEARCH.equals(intent.getAction()))
            search(intent.getStringExtra(QUERY));
    }

    private void search(final String query) {
        getSupportActionBar().setTitle(query);
        IssueSearchSuggestionsProvider.save(this, query);
        issueFragment.setQuery(query);
    }
}

<code block>

package com.github.mobile.ui.issue;

import android.accounts.Account;
import android.app.Activity;
import android.util.Log;

import com.github.mobile.R;
import com.github.mobile.core.issue.IssueStore;
import com.github.mobile.ui.ProgressDialogTask;
import com.github.mobile.util.ToastUtils;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.service.IssueService;


public class CreateIssueTask extends ProgressDialogTask<Issue> {

    private static final String TAG = "CreateIssueTask";

    @Inject
    private IssueService service;

    @Inject
    private IssueStore store;

    private final IRepositoryIdProvider repository;

    private final Issue issue;


    public CreateIssueTask(final Activity activity,
            final IRepositoryIdProvider repository, final Issue issue) {
        super(activity);

        this.repository = repository;
        this.issue = issue;
    }


    public CreateIssueTask create() {
        showIndeterminate(R.string.creating_issue);

        execute();
        return this;
    }

    @Override
    public Issue run(Account account) throws Exception {
        return store.addIssue(service.createIssue(repository, issue));
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.e(TAG, "Exception creating issue", e);
        ToastUtils.show((Activity) getContext(), e.getMessage());
    }
}

<code block>

package com.github.mobile.ui.issue;

import static android.app.Activity.RESULT_OK;
import static android.content.DialogInterface.BUTTON_NEGATIVE;
import static android.content.DialogInterface.BUTTON_NEUTRAL;
import static android.content.DialogInterface.BUTTON_POSITIVE;
import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ListView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.mobile.R;
import com.github.mobile.ui.DialogFragmentActivity;
import com.github.mobile.ui.DialogFragmentHelper;
import com.github.mobile.ui.LightAlertDialog;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;

import org.eclipse.egit.github.core.Label;


public class LabelsDialogFragment extends DialogFragmentHelper implements
        OnClickListener {


    public static final String ARG_SELECTED = "selected";

    private static final String ARG_CHOICES = "choices";

    private static final String ARG_SELECTED_CHOICES = "selectedChoices";

    private static final String TAG = "multi_choice_dialog";

    private static class LabelListAdapter extends SingleTypeAdapter<Label>
            implements OnItemClickListener {

        private final boolean[] selected;

        public LabelListAdapter(LayoutInflater inflater, Label[] labels,
                boolean[] selected) {
            super(inflater, R.layout.label_item);

            this.selected = selected;
            setItems(labels);
        }

        @Override
        public void onItemClick(AdapterView<?> parent, View view, int position,
                long id) {
            selected[position] = !selected[position];
            notifyDataSetChanged();
        }

        @Override
        protected int[] getChildViewIds() {
            return new int[] { R.id.tv_label_name, R.id.cb_selected };
        }

        @Override
        protected void update(int position, Label item) {
            LabelDrawableSpan.setText(textView(0), item);
            setChecked(1, selected[position]);
        }
    }


    @SuppressWarnings("unchecked")
    public static ArrayList<Label> getSelected(Bundle arguments) {
        return (ArrayList<Label>) arguments.getSerializable(ARG_SELECTED);
    }


    public static void show(final DialogFragmentActivity activity,
            final int requestCode, final String title, final String message,
            final ArrayList<Label> choices, final boolean[] selectedChoices) {
        Bundle arguments = createArguments(title, message, requestCode);
        arguments.putSerializable(ARG_CHOICES, choices);
        arguments.putBooleanArray(ARG_SELECTED_CHOICES, selectedChoices);
        show(activity, new LabelsDialogFragment(), arguments, TAG);
    }

    @Override
    public Dialog onCreateDialog(final Bundle savedInstanceState) {
        Bundle arguments = getArguments();
        Activity activity = getActivity();

        ArrayList<Label> choices = getChoices();
        boolean[] selectedChoices = arguments
                .getBooleanArray(ARG_SELECTED_CHOICES);
        HashSet<String> selected = new HashSet<>();
        if (selectedChoices != null)
            for (int i = 0; i < choices.size(); i++)
                if (selectedChoices[i])
                    selected.add(choices.get(i).getName());
        arguments.putSerializable(ARG_SELECTED, selected);

        LayoutInflater inflater = activity.getLayoutInflater();
        ListView view = (ListView) inflater.inflate(R.layout.dialog_list_view,
                null);
        LabelListAdapter adapter = new LabelListAdapter(inflater,
                choices.toArray(new Label[choices.size()]), selectedChoices);
        view.setAdapter(adapter);
        view.setOnItemClickListener(adapter);

        AlertDialog dialog = LightAlertDialog.create(activity);
        dialog.setCancelable(true);
        dialog.setOnCancelListener(this);
        dialog.setButton(BUTTON_NEGATIVE, activity.getString(R.string.cancel),
                this);
        dialog.setButton(BUTTON_NEUTRAL, activity.getString(R.string.clear), this);
        dialog.setButton(BUTTON_POSITIVE, activity.getString(R.string.apply),
                this);
        dialog.setTitle(getTitle());
        dialog.setMessage(getMessage());
        dialog.setView(view);
        return dialog;
    }

    @SuppressWarnings("unchecked")
    private ArrayList<Label> getChoices() {
        return (ArrayList<Label>) getArguments().getSerializable(ARG_CHOICES);
    }

    @Override
    protected void onResult(int resultCode) {
        Bundle arguments = getArguments();
        ArrayList<Label> selected = new ArrayList<>();
        boolean[] selectedChoices = arguments
                .getBooleanArray(ARG_SELECTED_CHOICES);
        ArrayList<Label> choices = getChoices();
        for (int i = 0; i < selectedChoices.length; i++)
            if (selectedChoices[i])
                selected.add(choices.get(i));
        arguments.putSerializable(ARG_SELECTED, selected);

        super.onResult(resultCode);
    }

    @Override
    public void onClick(DialogInterface dialog, int which) {
        super.onClick(dialog, which);

        switch (which) {
        case BUTTON_NEUTRAL:
            Arrays.fill(getArguments().getBooleanArray(ARG_SELECTED_CHOICES),
                    false);
        case BUTTON_POSITIVE:
            onResult(RESULT_OK);
        }
    }
}

<code block>

package com.github.mobile.ui.issue;

import android.content.Context;
import android.content.SearchRecentSuggestionsProvider;
import android.provider.SearchRecentSuggestions;


public class IssueSearchSuggestionsProvider extends
        SearchRecentSuggestionsProvider {

    private static final String AUTHORITY = "com.github.search.suggest.recent.issues";


    public static void save(Context context, String query) {
        suggestions(context).saveRecentQuery(query, null);
    }


    public static void clear(Context context) {
        suggestions(context).clearHistory();
    }

    private static SearchRecentSuggestions suggestions(Context context) {
        return new SearchRecentSuggestions(context, AUTHORITY,
                DATABASE_MODE_QUERIES);
    }


    public IssueSearchSuggestionsProvider() {
        setupSuggestions(AUTHORITY, DATABASE_MODE_QUERIES);
    }
}
<code block>

package com.github.mobile.ui.issue;

import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
import static android.content.Intent.FLAG_ACTIVITY_SINGLE_TOP;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.ActionBar;
import android.util.TypedValue;
import android.view.MenuItem;
import android.view.View;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemLongClickListener;

import com.github.mobile.Intents.Builder;
import com.github.mobile.R;
import com.github.mobile.RequestFuture;
import com.github.mobile.core.issue.IssueFilter;
import com.github.mobile.persistence.AccountDataManager;
import com.github.mobile.ui.ConfirmDialogFragment;
import com.github.mobile.ui.DialogFragmentActivity;
import com.github.mobile.ui.MainActivity;
import com.google.inject.Inject;


public class FiltersViewActivity extends DialogFragmentActivity implements
    OnItemLongClickListener {


    public static Intent createIntent() {
        return new Builder("repo.issues.filters.VIEW").toIntent();
    }

    private static final String ARG_FILTER = "filter";

    private static final int REQUEST_DELETE = 1;

    @Inject
    private AccountDataManager cache;

    private FilterListFragment fragment;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.issues_filter_list);

        setSupportActionBar((android.support.v7.widget.Toolbar) findViewById(R.id.toolbar));

        ActionBar actionBar = getSupportActionBar();
        actionBar.setTitle(R.string.bookmarks);
        actionBar.setIcon(R.drawable.ic_bookmark_white_24dp);
        actionBar.setDisplayHomeAsUpEnabled(true);

        fragment = (FilterListFragment) getSupportFragmentManager()
            .findFragmentById(android.R.id.list);
        fragment.getListView().setOnItemLongClickListener(this);
    }

    @Override
    public void onDialogResult(int requestCode, int resultCode, Bundle arguments) {
        if (requestCode == REQUEST_DELETE && resultCode == RESULT_OK) {
            IssueFilter filter = (IssueFilter) arguments
                .getSerializable(ARG_FILTER);
            cache.removeIssueFilter(filter, new RequestFuture<IssueFilter>() {

                @Override
                public void success(IssueFilter response) {
                    if (fragment != null)
                        fragment.refresh();
                }
            });
            return;
        }

        super.onDialogResult(requestCode, resultCode, arguments);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                Intent intent = new Intent(this, MainActivity.class);
                intent.addFlags(FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_SINGLE_TOP);
                startActivity(intent);
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    public boolean onItemLongClick(AdapterView<?> parent, View view,
        int position, long id) {
        IssueFilter filter = (IssueFilter) parent.getItemAtPosition(position);
        Bundle args = new Bundle();
        args.putSerializable(ARG_FILTER, filter);
        ConfirmDialogFragment.show(this, REQUEST_DELETE,
            getString(R.string.confirm_bookmark_delete_title),
            getString(R.string.confirm_bookmark_delete_message), args);
        return true;
    }
}

<code block>

package com.github.mobile.ui.issue;

import android.accounts.Account;

import com.github.mobile.R;
import com.github.mobile.core.issue.IssueStore;
import com.github.mobile.ui.DialogFragmentActivity;
import com.github.mobile.ui.ProgressDialogTask;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.Issue;


public class EditIssueTask extends ProgressDialogTask<Issue> {

    @Inject
    private IssueStore store;

    private final IRepositoryIdProvider repositoryId;

    private final Issue issue;


    public EditIssueTask(final DialogFragmentActivity activity,
            final IRepositoryIdProvider repositoryId, final Issue issue) {
        super(activity);

        this.repositoryId = repositoryId;
        this.issue = issue;
    }

    @Override
    protected Issue run(Account account) throws Exception {
        return store.editIssue(repositoryId, issue);
    }


    public EditIssueTask edit() {
        showIndeterminate(R.string.updating_issue);

        execute();
        return this;
    }
}

<code block>

package com.github.mobile.ui.issue;

import android.text.TextUtils;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.TextView;

import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.mobile.R;
import com.github.mobile.util.AvatarLoader;
import com.github.mobile.util.TypefaceUtils;

import org.eclipse.egit.github.core.SearchIssue;
import org.eclipse.egit.github.core.User;


public class SearchIssueListAdapter extends IssueListAdapter<SearchIssue> {

    private int numberPaintFlags;


    public SearchIssueListAdapter(LayoutInflater inflater,
            SearchIssue[] elements, AvatarLoader avatars) {
        super(R.layout.repo_issue_item, inflater, elements, avatars);
    }

    @Override
    public long getItemId(int position) {
        return getItem(position).getNumber();
    }

    @Override
    protected int getNumber(SearchIssue issue) {
        return issue.getNumber();
    }

    @Override
    protected View initialize(View view) {
        view = super.initialize(view);

        numberPaintFlags = textView(view, 0).getPaintFlags();
        TypefaceUtils.setOcticons(
                (TextView) view.findViewById(R.id.tv_pull_request_icon),
                (TextView) view.findViewById(R.id.tv_comment_icon));
        for (int i = 0; i < MAX_LABELS; i++)
            ViewUtils.setGone(view.findViewById(R.id.v_label0 + i), true);
        ViewUtils.setGone(view.findViewById(R.id.tv_pull_request_icon), true);
        return view;
    }

    @Override
    protected int[] getChildViewIds() {
        return new int[] { R.id.tv_issue_number, R.id.tv_issue_title, R.id.iv_avatar,
                R.id.tv_issue_creation, R.id.tv_issue_comments };
    }

    @Override
    protected void update(int position, SearchIssue issue) {
        updateNumber(issue.getNumber(), issue.getState(), numberPaintFlags, 0);

        String gravatarId = issue.getGravatarId();
        User user;
        if (!TextUtils.isEmpty(gravatarId))
            user = new User().setGravatarId(gravatarId);
        else
            user = null;
        avatars.bind(imageView(2), user);

        setText(1, issue.getTitle());

        updateReporter(issue.getUser(), issue.getCreatedAt(), 3);
        setNumber(4, issue.getComments());
    }
}

<code block>

package com.github.mobile.ui.issue;

import static android.app.Activity.RESULT_OK;
import static android.content.DialogInterface.BUTTON_NEGATIVE;
import static android.content.DialogInterface.BUTTON_NEUTRAL;
import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.DialogInterface;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ListView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.mobile.R;
import com.github.mobile.ui.DialogFragmentActivity;
import com.github.mobile.ui.SingleChoiceDialogFragment;
import com.github.mobile.util.AvatarLoader;
import com.google.inject.Inject;

import java.util.ArrayList;

import org.eclipse.egit.github.core.User;


public class AssigneeDialogFragment extends SingleChoiceDialogFragment {

    private static class UserListAdapter extends SingleTypeAdapter<User> {

        private final int selected;

        private final AvatarLoader loader;

        public UserListAdapter(LayoutInflater inflater, User[] users,
                int selected, AvatarLoader loader) {
            super(inflater, R.layout.collaborator_item);

            this.selected = selected;
            this.loader = loader;
            setItems(users);
        }

        @Override
        public long getItemId(int position) {
            return getItem(position).getId();
        }

        @Override
        protected int[] getChildViewIds() {
            return new int[] { R.id.tv_login, R.id.iv_avatar, R.id.rb_selected };
        }

        @Override
        protected void update(int position, User item) {
            setText(0, item.getLogin());
            loader.bind(imageView(1), item);
            setChecked(2, selected == position);
        }
    }


    public static User getSelected(Bundle arguments) {
        return (User) arguments.getSerializable(ARG_SELECTED);
    }


    public static void show(final DialogFragmentActivity activity,
            final int requestCode, final String title, final String message,
            ArrayList<User> choices, final int selectedChoice) {
        show(activity, requestCode, title, message, choices, selectedChoice,
                new AssigneeDialogFragment());
    }

    @Inject
    private AvatarLoader loader;

    @Override
    public Dialog onCreateDialog(final Bundle savedInstanceState) {
        Activity activity = getActivity();
        Bundle arguments = getArguments();

        final AlertDialog dialog = createDialog();
        dialog.setButton(BUTTON_NEGATIVE, activity.getString(R.string.cancel),
                this);
        dialog.setButton(BUTTON_NEUTRAL, activity.getString(R.string.clear), this);

        LayoutInflater inflater = activity.getLayoutInflater();

        ListView view = (ListView) inflater.inflate(R.layout.dialog_list_view,
                null);
        view.setOnItemClickListener(new OnItemClickListener() {

            @Override
            public void onItemClick(AdapterView<?> parent, View view,
                    int position, long id) {
                onClick(dialog, position);
            }
        });

        ArrayList<User> choices = getChoices();
        int selected = arguments.getInt(ARG_SELECTED_CHOICE);
        UserListAdapter adapter = new UserListAdapter(inflater,
                choices.toArray(new User[choices.size()]), selected, loader);
        view.setAdapter(adapter);
        if (selected >= 0)
            view.setSelection(selected);
        dialog.setView(view);

        return dialog;
    }

    @SuppressWarnings("unchecked")
    private ArrayList<User> getChoices() {
        return (ArrayList<User>) getArguments().getSerializable(ARG_CHOICES);
    }

    @Override
    public void onClick(DialogInterface dialog, int which) {
        super.onClick(dialog, which);

        switch (which) {
        case BUTTON_NEGATIVE:
            break;
        case BUTTON_NEUTRAL:
            onResult(RESULT_OK);
            break;
        default:
            getArguments().putSerializable(ARG_SELECTED,
                    getChoices().get(which));
            onResult(RESULT_OK);
        }
    }
}

<code block>

package com.github.mobile.ui.issue;

import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
import static android.content.Intent.FLAG_ACTIVITY_SINGLE_TOP;
import static com.github.mobile.util.TypefaceUtils.ICON_ADD;
import static com.github.mobile.util.TypefaceUtils.ICON_BROADCAST;
import static com.github.mobile.util.TypefaceUtils.ICON_FOLLOW;
import static com.github.mobile.util.TypefaceUtils.ICON_WATCH;
import android.content.Intent;
import android.os.Bundle;
import android.support.annotation.Nullable;
import android.view.MenuItem;
import android.view.View;

import com.github.mobile.ui.MainActivity;
import com.github.mobile.ui.TabPagerFragment;


public class IssueDashboardPagerFragment extends
    TabPagerFragment<IssueDashboardPagerAdapter> {

    @Override
    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        configureTabPager();
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                Intent intent = new Intent(getActivity(), MainActivity.class);
                intent.addFlags(FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_SINGLE_TOP);
                startActivity(intent);
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    protected IssueDashboardPagerAdapter createAdapter() {
        return new IssueDashboardPagerAdapter(this);
    }

    @Override
    protected String getIcon(int position) {
        switch (position) {
            case 0:
                return ICON_WATCH;
            case 1:
                return ICON_FOLLOW;
            case 2:
                return ICON_ADD;
            case 3:
                return ICON_BROADCAST;
            default:
                return super.getIcon(position);
        }
    }
}

<code block>

package com.github.mobile.ui.issue;

import static java.lang.String.CASE_INSENSITIVE_ORDER;
import android.accounts.Account;
import android.util.Log;

import com.github.mobile.R;
import com.github.mobile.ui.DialogFragmentActivity;
import com.github.mobile.ui.ProgressDialogTask;
import com.github.mobile.util.ToastUtils;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.service.CollaboratorService;


public class AssigneeDialog {

    private static final String TAG = "AssigneeDialog";

    private CollaboratorService service;

    private Map<String, User> collaborators;

    private final int requestCode;

    private final DialogFragmentActivity activity;

    private final IRepositoryIdProvider repository;


    public AssigneeDialog(final DialogFragmentActivity activity,
            final int requestCode, final IRepositoryIdProvider repository,
            final CollaboratorService service) {
        this.activity = activity;
        this.requestCode = requestCode;
        this.repository = repository;
        this.service = service;
    }

    private void load(final User selectedAssignee) {
        new ProgressDialogTask<List<User>>(activity) {

            @Override
            public List<User> run(Account account) throws Exception {
                List<User> users = service.getCollaborators(repository);
                Map<String, User> loadedCollaborators = new TreeMap<>(
                        CASE_INSENSITIVE_ORDER);
                for (User user : users)
                    loadedCollaborators.put(user.getLogin(), user);
                collaborators = loadedCollaborators;
                return users;
            }

            @Override
            protected void onSuccess(List<User> all) throws Exception {
                super.onSuccess(all);

                show(selectedAssignee);
            }

            @Override
            protected void onException(Exception e) throws RuntimeException {
                super.onException(e);

                Log.d(TAG, "Exception loading collaborators", e);
                ToastUtils.show(activity, e, R.string.error_collaborators_load);
            }

            @Override
            public void execute() {
                showIndeterminate(R.string.loading_collaborators);

                super.execute();
            }
        }.execute();
    }


    public void show(User selectedAssignee) {
        if (collaborators == null) {
            load(selectedAssignee);
            return;
        }

        final ArrayList<User> users = new ArrayList<>(
                collaborators.values());
        int checked = -1;
        if (selectedAssignee != null)
            for (int i = 0; i < users.size(); i++)
                if (selectedAssignee.getLogin().equals(users.get(i).getLogin()))
                    checked = i;
        AssigneeDialogFragment.show(activity, requestCode,
                activity.getString(R.string.select_assignee), null, users,
                checked);
    }
}

<code block>

package com.github.mobile.ui.issue;

import static android.app.Activity.RESULT_OK;
import static android.view.View.GONE;
import static android.view.View.VISIBLE;
import static com.github.mobile.Intents.EXTRA_COMMENT;
import static com.github.mobile.Intents.EXTRA_ISSUE;
import static com.github.mobile.Intents.EXTRA_ISSUE_NUMBER;
import static com.github.mobile.Intents.EXTRA_IS_COLLABORATOR;
import static com.github.mobile.Intents.EXTRA_IS_OWNER;
import static com.github.mobile.Intents.EXTRA_REPOSITORY_NAME;
import static com.github.mobile.Intents.EXTRA_REPOSITORY_OWNER;
import static com.github.mobile.Intents.EXTRA_USER;
import static com.github.mobile.RequestCodes.COMMENT_CREATE;
import static com.github.mobile.RequestCodes.COMMENT_DELETE;
import static com.github.mobile.RequestCodes.COMMENT_EDIT;
import static com.github.mobile.RequestCodes.ISSUE_ASSIGNEE_UPDATE;
import static com.github.mobile.RequestCodes.ISSUE_CLOSE;
import static com.github.mobile.RequestCodes.ISSUE_EDIT;
import static com.github.mobile.RequestCodes.ISSUE_LABELS_UPDATE;
import static com.github.mobile.RequestCodes.ISSUE_MILESTONE_UPDATE;
import static com.github.mobile.RequestCodes.ISSUE_REOPEN;
import static com.github.mobile.util.TypefaceUtils.ICON_COMMIT;
import static org.eclipse.egit.github.core.service.IssueService.STATE_OPEN;
import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.text.TextUtils;
import android.util.TypedValue;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.LinearLayout.LayoutParams;
import android.widget.ListView;
import android.widget.ProgressBar;
import android.widget.TextView;

import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.mobile.R;
import com.github.mobile.accounts.AccountUtils;
import com.github.mobile.core.issue.FullIssue;
import com.github.mobile.core.issue.IssueStore;
import com.github.mobile.core.issue.IssueUtils;
import com.github.mobile.core.issue.RefreshIssueTask;
import com.github.mobile.ui.ConfirmDialogFragment;
import com.github.mobile.ui.DialogFragment;
import com.github.mobile.ui.DialogFragmentActivity;
import com.github.mobile.ui.HeaderFooterListAdapter;
import com.github.mobile.ui.SelectableLinkMovementMethod;
import com.github.mobile.ui.StyledText;
import com.github.mobile.ui.comment.CommentListAdapter;
import com.github.mobile.ui.comment.DeleteCommentListener;
import com.github.mobile.ui.comment.EditCommentListener;
import com.github.mobile.ui.commit.CommitCompareViewActivity;
import com.github.mobile.util.AvatarLoader;
import com.github.mobile.util.HttpImageGetter;
import com.github.mobile.util.ShareUtils;
import com.github.mobile.util.ToastUtils;
import com.github.mobile.util.TypefaceUtils;
import com.google.inject.Inject;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.List;
import java.util.Locale;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.IssueEvent;
import org.eclipse.egit.github.core.Label;
import org.eclipse.egit.github.core.Milestone;
import org.eclipse.egit.github.core.PullRequest;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.RepositoryId;
import org.eclipse.egit.github.core.User;


public class IssueFragment extends DialogFragment {

    private int issueNumber;

    private List<Comment> comments;

    private List<Object> items;

    private RepositoryId repositoryId;

    private Issue issue;

    private User user;

    private boolean isCollaborator;

    private boolean isOwner;

    @Inject
    private AvatarLoader avatars;

    @Inject
    private IssueStore store;

    private ListView list;

    private ProgressBar progress;

    private View headerView;

    private View loadingView;

    private View footerView;

    private HeaderFooterListAdapter<CommentListAdapter> adapter;

    private EditMilestoneTask milestoneTask;

    private EditAssigneeTask assigneeTask;

    private EditLabelsTask labelsTask;

    private EditStateTask stateTask;

    private TextView stateText;

    private TextView titleText;

    private TextView bodyText;

    private TextView authorText;

    private TextView createdDateText;

    private ImageView creatorAvatar;

    private ViewGroup commitsView;

    private TextView assigneeText;

    private ImageView assigneeAvatar;

    private TextView labelsArea;

    private View milestoneArea;

    private View milestoneProgressArea;

    private TextView milestoneText;

    private MenuItem stateItem;

    @Inject
    private HttpImageGetter bodyImageGetter;

    @Inject
    private HttpImageGetter commentImageGetter;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        Bundle args = getArguments();
        repositoryId = RepositoryId.create(
                args.getString(EXTRA_REPOSITORY_OWNER),
                args.getString(EXTRA_REPOSITORY_NAME));
        issueNumber = args.getInt(EXTRA_ISSUE_NUMBER);
        user = (User) args.getSerializable(EXTRA_USER);
        isCollaborator = args.getBoolean(EXTRA_IS_COLLABORATOR, false);
        isOwner = args.getBoolean(EXTRA_IS_OWNER, false);

        DialogFragmentActivity dialogActivity = (DialogFragmentActivity) getActivity();

        milestoneTask = new EditMilestoneTask(dialogActivity, repositoryId,
                issueNumber) {

            @Override
            protected void onSuccess(Issue editedIssue) throws Exception {
                super.onSuccess(editedIssue);

                updateHeader(editedIssue);
            }
        };

        assigneeTask = new EditAssigneeTask(dialogActivity, repositoryId,
                issueNumber) {

            @Override
            protected void onSuccess(Issue editedIssue) throws Exception {
                super.onSuccess(editedIssue);

                updateHeader(editedIssue);
            }
        };

        labelsTask = new EditLabelsTask(dialogActivity, repositoryId,
                issueNumber) {

            @Override
            protected void onSuccess(Issue editedIssue) throws Exception {
                super.onSuccess(editedIssue);

                updateHeader(editedIssue);
            }
        };

        stateTask = new EditStateTask(dialogActivity, repositoryId, issueNumber) {

            @Override
            protected void onSuccess(Issue editedIssue) throws Exception {
                super.onSuccess(editedIssue);

                updateHeader(editedIssue);
            }
        };
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        adapter.addHeader(headerView);
        adapter.addFooter(footerView);

        issue = store.getIssue(repositoryId, issueNumber);

        TextView loadingText = (TextView) loadingView
                .findViewById(R.id.tv_loading);
        loadingText.setText(R.string.loading_comments);

        if (issue == null || (issue.getComments() > 0 && items == null))
            adapter.addHeader(loadingView);

        if (issue != null && items != null)
            updateList(issue, items);
        else {
            if (issue != null)
                updateHeader(issue);
            refreshIssue();
        }
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        return inflater.inflate(R.layout.comment_list, null);
    }

    @Override
    public void onViewCreated(View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        list = finder.find(android.R.id.list);
        progress = finder.find(R.id.pb_loading);

        LayoutInflater inflater = getLayoutInflater(savedInstanceState);

        headerView = inflater.inflate(R.layout.issue_header, null);

        stateText = (TextView) headerView.findViewById(R.id.tv_state);
        titleText = (TextView) headerView.findViewById(R.id.tv_issue_title);
        authorText = (TextView) headerView.findViewById(R.id.tv_issue_author);
        createdDateText = (TextView) headerView
                .findViewById(R.id.tv_issue_creation_date);
        creatorAvatar = (ImageView) headerView.findViewById(R.id.iv_avatar);
        commitsView = (ViewGroup) headerView.findViewById(R.id.ll_issue_commits);
        assigneeText = (TextView) headerView.findViewById(R.id.tv_assignee_name);
        assigneeAvatar = (ImageView) headerView
                .findViewById(R.id.iv_assignee_avatar);
        labelsArea = (TextView) headerView.findViewById(R.id.tv_labels);
        milestoneArea = headerView.findViewById(R.id.ll_milestone);
        milestoneText = (TextView) headerView.findViewById(R.id.tv_milestone);
        milestoneProgressArea = headerView.findViewById(R.id.v_closed);
        bodyText = (TextView) headerView.findViewById(R.id.tv_issue_body);
        bodyText.setMovementMethod(SelectableLinkMovementMethod.getInstance());

        loadingView = inflater.inflate(R.layout.loading_item, null);

        footerView = inflater.inflate(R.layout.footer_separator, null);

        commitsView.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                if (IssueUtils.isPullRequest(issue))
                    openPullRequestCommits();
            }
        });

        stateText.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                if (issue != null)
                    stateTask.confirm(STATE_OPEN.equals(issue.getState()));
            }
        });

        milestoneArea.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                if (issue != null && isCollaborator)
                    milestoneTask.prompt(issue.getMilestone());
            }
        });

        headerView.findViewById(R.id.ll_assignee).setOnClickListener(
                new OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        if (issue != null && isCollaborator)
                            assigneeTask.prompt(issue.getAssignee());
                    }
                });

        labelsArea.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                if (issue != null && isCollaborator)
                    labelsTask.prompt(issue.getLabels());
            }
        });

        Activity activity = getActivity();
        String userName = AccountUtils.getLogin(activity);

        adapter = new HeaderFooterListAdapter<>(list,
                new CommentListAdapter(activity.getLayoutInflater(), null, avatars,
                        commentImageGetter, editCommentListener, deleteCommentListener, userName, isOwner, issue));
        list.setAdapter(adapter);
    }

    private void updateHeader(final Issue issue) {
        if (!isUsable())
            return;

        titleText.setText(issue.getTitle());

        String body = issue.getBodyHtml();
        if (!TextUtils.isEmpty(body))
            bodyImageGetter.bind(bodyText, body, issue.getId());
        else
            bodyText.setText(R.string.no_description_given);

        authorText.setText(issue.getUser().getLogin());
        createdDateText.setText(new StyledText().append(
                getString(R.string.prefix_opened)).append(issue.getCreatedAt()));
        avatars.bind(creatorAvatar, issue.getUser());

        if (IssueUtils.isPullRequest(issue) && issue.getPullRequest().getCommits() > 0) {
            ViewUtils.setGone(commitsView, false);

            TextView icon = (TextView) headerView.findViewById(R.id.tv_commit_icon);
            TypefaceUtils.setOcticons(icon);
            icon.setText(ICON_COMMIT);

            String commits = getString(R.string.pull_request_commits,
                    issue.getPullRequest().getCommits());
            ((TextView) headerView.findViewById(R.id.tv_pull_request_commits)).setText(commits);
        } else
            ViewUtils.setGone(commitsView, true);

        boolean open = STATE_OPEN.equals(issue.getState());
        if (!open) {
            StyledText text = new StyledText();
            text.bold(getString(R.string.closed));
            Date closedAt = issue.getClosedAt();
            if (closedAt != null)
                text.append(' ').append(closedAt);
            stateText.setText(text);
        }
        ViewUtils.setGone(stateText, open);

        User assignee = issue.getAssignee();
        if (assignee != null) {
            StyledText name = new StyledText();
            name.bold(assignee.getLogin());
            name.append(' ').append(getString(R.string.assigned));
            assigneeText.setText(name);
            assigneeAvatar.setVisibility(VISIBLE);
            avatars.bind(assigneeAvatar, assignee);
        } else {
            assigneeAvatar.setVisibility(GONE);
            assigneeText.setText(R.string.unassigned);
        }

        List<Label> labels = issue.getLabels();
        if (labels != null && !labels.isEmpty()) {
            LabelDrawableSpan.setText(labelsArea, labels);
            labelsArea.setVisibility(VISIBLE);
        } else
            labelsArea.setVisibility(GONE);

        if (issue.getMilestone() != null) {
            Milestone milestone = issue.getMilestone();
            StyledText milestoneLabel = new StyledText();
            milestoneLabel.append(getString(R.string.milestone_prefix));
            milestoneLabel.append(' ');
            milestoneLabel.bold(milestone.getTitle());
            milestoneText.setText(milestoneLabel);
            float closed = milestone.getClosedIssues();
            float total = closed + milestone.getOpenIssues();
            if (total > 0) {
                ((LayoutParams) milestoneProgressArea.getLayoutParams()).weight = closed
                        / total;
                milestoneProgressArea.setVisibility(VISIBLE);
            } else
                milestoneProgressArea.setVisibility(GONE);
            milestoneArea.setVisibility(VISIBLE);
        } else
            milestoneArea.setVisibility(GONE);

        String state = issue.getState();
        if (state != null && state.length() > 0)
            state = state.substring(0, 1).toUpperCase(Locale.US)
                    + state.substring(1);
        else
            state = "";

        ViewUtils.setGone(progress, true);
        ViewUtils.setGone(list, false);
        updateStateItem(issue);
    }

    private void refreshIssue() {
        new RefreshIssueTask(getActivity(), repositoryId, issueNumber,
                bodyImageGetter, commentImageGetter) {

            @Override
            protected void onException(Exception e) throws RuntimeException {
                super.onException(e);
                ToastUtils.show(getActivity(), e, R.string.error_issue_load);
                ViewUtils.setGone(progress, true);
            }

            @Override
            protected void onSuccess(FullIssue fullIssue) throws Exception {
                super.onSuccess(fullIssue);
                if (!isUsable())
                    return;

                issue = fullIssue.getIssue();
                comments = fullIssue;

                List<IssueEvent> events = (List<IssueEvent>) fullIssue.getEvents();
                int numEvents = events.size();

                List<Object> allItems = new ArrayList<>();

                int start = 0;
                for (Comment comment : fullIssue) {
                    for (int e = start; e < numEvents; e++) {
                        IssueEvent event = events.get(e);
                        if (comment.getCreatedAt().after(event.getCreatedAt())) {
                            allItems.add(event);
                            start++;
                        } else {
                            e = events.size();
                        }
                    }
                    allItems.add(comment);
                }


                for(int e = start; e < events.size(); e++) {
                    IssueEvent event = events.get(e);
                    allItems.add(event);
                }

                items = allItems;
                updateList(fullIssue.getIssue(), allItems);
            }
        }.execute();
    }

    private void updateList(Issue issue, List<Object> items) {
        adapter.getWrappedAdapter().setItems(items);
        adapter.removeHeader(loadingView);
        adapter.getWrappedAdapter().setIssue(issue);

        headerView.setVisibility(VISIBLE);
        updateHeader(issue);
    }

    @Override
    public void onDialogResult(int requestCode, int resultCode, Bundle arguments) {
        if (RESULT_OK != resultCode)
            return;

        switch (requestCode) {
        case ISSUE_MILESTONE_UPDATE:
            milestoneTask.edit(MilestoneDialogFragment.getSelected(arguments));
            break;
        case ISSUE_ASSIGNEE_UPDATE:
            assigneeTask.edit(AssigneeDialogFragment.getSelected(arguments));
            break;
        case ISSUE_LABELS_UPDATE:
            ArrayList<Label> labels = LabelsDialogFragment
                    .getSelected(arguments);
            if (labels != null && !labels.isEmpty())
                labelsTask.edit(labels.toArray(new Label[labels.size()]));
            else
                labelsTask.edit(null);
            break;
        case ISSUE_CLOSE:
            stateTask.edit(true);
            break;
        case ISSUE_REOPEN:
            stateTask.edit(false);
            break;
        case COMMENT_DELETE:
            final Comment comment = (Comment) arguments.getSerializable(EXTRA_COMMENT);
            new DeleteCommentTask(getActivity(), repositoryId, comment) {
                @Override
                protected void onSuccess(Comment comment) throws Exception {
                    super.onSuccess(comment);

                    if (comments != null && comment != null) {
                        int position = Collections.binarySearch(comments,
                                comment, new Comparator<Comment>() {
                                    public int compare(Comment lhs, Comment rhs) {
                                        return Long.valueOf(lhs.getId())
                                                .compareTo(rhs.getId());
                                    }
                                });
                        comments.remove(position);
                        updateList(issue, items);
                    } else
                        refreshIssue();
                }
            }.start();
            break;
        }
    }

    private void updateStateItem(Issue issue) {
        if (issue != null && stateItem != null) {
            if (STATE_OPEN.equals(issue.getState())) {
                stateItem.setTitle(R.string.close);
                stateItem.setIcon(R.drawable.ic_github_issue_closed_white_24dp);
            } else {
                stateItem.setTitle(R.string.reopen);
                stateItem.setIcon(R.drawable.ic_github_issue_reopened_white_24dp);
            }
        }
    }

    @Override
    public void onPrepareOptionsMenu(Menu menu) {
        super.onPrepareOptionsMenu(menu);
        MenuItem editItem = menu.findItem(R.id.m_edit);
        MenuItem stateItem = menu.findItem(R.id.m_state);
        if (editItem != null && stateItem != null) {
            boolean isCreator = false;
            if(issue != null)
                isCreator = issue.getUser().getLogin().equals(AccountUtils.getLogin(getActivity()));
            editItem.setVisible(isOwner || isCollaborator || isCreator);
            stateItem.setVisible(isOwner || isCollaborator || isCreator);
        }
        updateStateItem(issue);
    }

    @Override
    public void onCreateOptionsMenu(Menu optionsMenu, MenuInflater inflater) {
        inflater.inflate(R.menu.issue_view, optionsMenu);
        stateItem = optionsMenu.findItem(R.id.m_state);
        updateStateItem(issue);
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (RESULT_OK != resultCode || data == null)
            return;

        switch (requestCode) {
        case ISSUE_EDIT:
            Issue editedIssue = (Issue) data.getSerializableExtra(EXTRA_ISSUE);
            bodyImageGetter.encode(editedIssue.getId(), editedIssue.getBodyHtml());
            updateHeader(editedIssue);
            return;
        case COMMENT_CREATE:
            Comment comment = (Comment) data
                    .getSerializableExtra(EXTRA_COMMENT);
            if (items != null) {
                items.add(comment);
                issue.setComments(issue.getComments() + 1);
                updateList(issue, items);
            } else
                refreshIssue();
            return;
        case COMMENT_EDIT:
            comment = (Comment) data
                    .getSerializableExtra(EXTRA_COMMENT);
            if (comments != null && comment != null) {
                int position = Collections.binarySearch(comments, comment, new Comparator<Comment>() {
                    public int compare(Comment lhs, Comment rhs) {
                        return Long.valueOf(lhs.getId()).compareTo(rhs.getId());
                    }
                });
                commentImageGetter.removeFromCache(comment.getId());
                comments.set(position, comment);
                updateList(issue, items);
            } else
                refreshIssue();
        }
    }

    private void shareIssue() {
        String id = repositoryId.generateId();
        if (IssueUtils.isPullRequest(issue))
            startActivity(ShareUtils.create("Pull Request " + issueNumber
                    + " on " + id, "https://github.com/" + id + "/pull/"
                    + issueNumber));
        else
            startActivity(ShareUtils
                    .create("Issue " + issueNumber + " on " + id,
                            "https://github.com/" + id + "/issues/"
                                    + issueNumber));
    }

    private void openPullRequestCommits() {
        if (IssueUtils.isPullRequest(issue)) {
            PullRequest pullRequest = issue.getPullRequest();

            String base = pullRequest.getBase().getSha();
            String head = pullRequest.getHead().getSha();
            Repository repo = pullRequest.getBase().getRepo();
            startActivity(CommitCompareViewActivity.createIntent(repo, base, head));
        }
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
        case R.id.m_edit:
            if (issue != null)
                startActivityForResult(EditIssueActivity.createIntent(issue,
                                repositoryId.getOwner(), repositoryId.getName(), user),
                        ISSUE_EDIT);
            return true;
        case R.id.m_comment:
            if (issue != null)
                startActivityForResult(CreateCommentActivity.createIntent(
                        repositoryId, issueNumber, user), COMMENT_CREATE);
            return true;
        case R.id.m_refresh:
            refreshIssue();
            return true;
        case R.id.m_share:
            if (issue != null)
                shareIssue();
            return true;
        case R.id.m_state:
            if (issue != null)
                stateTask.confirm(STATE_OPEN.equals(issue.getState()));
            return true;
        default:
            return super.onOptionsItemSelected(item);
        }
    }


    final EditCommentListener editCommentListener = new EditCommentListener() {
        public void onEditComment(Comment comment) {
            startActivityForResult(EditCommentActivity.createIntent(
                    repositoryId, issueNumber, comment, user), COMMENT_EDIT);
        }
    };


    final DeleteCommentListener deleteCommentListener = new DeleteCommentListener() {
        public void onDeleteComment(Comment comment) {
            Bundle args = new Bundle();
            args.putSerializable(EXTRA_COMMENT, comment);
            ConfirmDialogFragment.show(
                    getActivity(),
                    COMMENT_DELETE,
                    getActivity()
                            .getString(R.string.confirm_comment_delete_title),
                    getActivity().getString(
                            R.string.confirm_comment_delete_message), args);
        }
    };
}

<code block>

package com.github.mobile.ui.issue;

import static com.github.mobile.ui.issue.DashboardIssueFragment.ARG_FILTER;
import static org.eclipse.egit.github.core.service.IssueService.DIRECTION_DESCENDING;
import static org.eclipse.egit.github.core.service.IssueService.FIELD_DIRECTION;
import static org.eclipse.egit.github.core.service.IssueService.FIELD_FILTER;
import static org.eclipse.egit.github.core.service.IssueService.FIELD_SORT;
import static org.eclipse.egit.github.core.service.IssueService.FILTER_ASSIGNED;
import static org.eclipse.egit.github.core.service.IssueService.FILTER_CREATED;
import static org.eclipse.egit.github.core.service.IssueService.FILTER_MENTIONED;
import static org.eclipse.egit.github.core.service.IssueService.FILTER_SUBSCRIBED;
import static org.eclipse.egit.github.core.service.IssueService.SORT_UPDATED;
import android.content.res.Resources;
import android.os.Bundle;
import android.support.v4.app.Fragment;

import com.github.mobile.R;
import com.github.mobile.ui.FragmentStatePagerAdapter;

import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;


public class IssueDashboardPagerAdapter extends FragmentStatePagerAdapter {

    private final Resources resources;


    public IssueDashboardPagerAdapter(final Fragment fragment) {
        super(fragment);

        resources = fragment.getResources();
    }

    @Override
    public int getCount() {
        return 4;
    }

    @Override
    public Fragment getItem(final int position) {
        String filter = null;
        switch (position) {
            case 0:
                filter = FILTER_SUBSCRIBED;
                break;
            case 1:
                filter = FILTER_ASSIGNED;
                break;
            case 2:
                filter = FILTER_CREATED;
                break;
            case 3:
                filter = FILTER_MENTIONED;
                break;
            default:
                return null;
        }
        final Map<String, String> filterData = new HashMap<>();
        filterData.put(FIELD_FILTER, filter);
        filterData.put(FIELD_SORT, SORT_UPDATED);
        filterData.put(FIELD_DIRECTION, DIRECTION_DESCENDING);
        Bundle bundle = new Bundle();
        bundle.putSerializable(ARG_FILTER, (Serializable) filterData);
        DashboardIssueFragment fragment = new DashboardIssueFragment();
        fragment.setArguments(bundle);
        return fragment;
    }

    @Override
    public CharSequence getPageTitle(final int position) {
        switch (position) {
            case 0:
                return resources.getString(R.string.tab_watched);
            case 1:
                return resources.getString(R.string.tab_assigned);
            case 2:
                return resources.getString(R.string.tab_created);
            case 3:
                return resources.getString(R.string.tab_mentioned);
            default:
                return null;
        }
    }
}

<code block>

package com.github.mobile.ui.issue;

import android.accounts.Account;
import android.app.Activity;
import android.content.Context;
import android.util.Log;

import com.github.mobile.R;
import com.github.mobile.ui.ProgressDialogTask;
import com.github.mobile.util.HtmlUtils;
import com.github.mobile.util.ToastUtils;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.service.IssueService;


public class EditCommentTask extends ProgressDialogTask<Comment> {

    private static final String TAG = "EditCommentTask";

    private final IRepositoryIdProvider repository;

    private final Comment comment;

    @Inject
    private IssueService service;


    public EditCommentTask(final Context context,
            final IRepositoryIdProvider repository,
            final Comment comment) {
        super(context);

        this.repository = repository;
        this.comment = comment;
    }

    @Override
    protected Comment run(Account account) throws Exception {
        Comment edited = service.editComment(repository, comment);
        String formatted = HtmlUtils.format(edited.getBodyHtml()).toString();
        edited.setBodyHtml(formatted);
        return edited;
    }


    public EditCommentTask start() {
        showIndeterminate(R.string.editing_comment);

        execute();
        return this;
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception editing comment on issue", e);

        ToastUtils.show((Activity) getContext(), e.getMessage());
    }
}

<code block>

package com.github.mobile.ui.issue;

import static android.graphics.Color.WHITE;
import static android.graphics.Typeface.DEFAULT_BOLD;
import static java.lang.Integer.MIN_VALUE;
import static java.lang.String.CASE_INSENSITIVE_ORDER;
import static java.util.Locale.US;
import android.content.res.Resources;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Rect;
import android.graphics.drawable.Drawable;
import android.graphics.drawable.GradientDrawable;
import android.graphics.drawable.LayerDrawable;
import android.graphics.drawable.PaintDrawable;
import android.text.style.DynamicDrawableSpan;
import android.widget.TextView;

import com.github.mobile.R;
import com.github.mobile.ui.StyledText;
import com.github.mobile.util.ServiceUtils;

import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;

import org.eclipse.egit.github.core.Label;


public class LabelDrawableSpan extends DynamicDrawableSpan {

    private static final int PADDING_LEFT = 10;

    private static final int PADDING_RIGHT = 10;

    private static final int PADDING_TOP = 8;

    private static final int PADDING_BOTTOM = 8;

    private static class LabelDrawable extends PaintDrawable {

        private final String name;

        private final float height;

        private final float paddingLeft;

        private final float textHeight;

        private final int textColor;

        private final LayerDrawable layers;


        public LabelDrawable(final float paddingLeft, final float textHeight,
                final Rect bounds, final Resources resources,
                final float textSize, final String name, final int bg) {
            this.paddingLeft = paddingLeft;
            this.textHeight = textHeight;
            this.name = name;
            height = bounds.height();

            float[] hsv = new float[3];
            Color.colorToHSV(bg, hsv);
            if ((hsv[2] > 0.6 && hsv[1] < 0.4)
                    || (hsv[2] > 0.7 && hsv[0] > 40 && hsv[0] < 200)) {
                hsv[2] = 0.4F;
                textColor = Color.HSVToColor(hsv);
            } else
                textColor = WHITE;

            layers = (LayerDrawable) resources
                    .getDrawable(R.drawable.label_background);
            ((GradientDrawable) ((LayerDrawable) layers
                    .findDrawableByLayerId(R.id.item_outer_layer))
                    .findDrawableByLayerId(R.id.item_outer)).setColor(bg);
            ((GradientDrawable) ((LayerDrawable) layers
                    .findDrawableByLayerId(R.id.item_inner_layer))
                    .findDrawableByLayerId(R.id.item_inner)).setColor(bg);
            ((GradientDrawable) layers.findDrawableByLayerId(R.id.item_bg))
                    .setColor(bg);

            Paint p = getPaint();
            p.setAntiAlias(true);
            p.setColor(resources.getColor(android.R.color.transparent));
            p.setTypeface(DEFAULT_BOLD);
            p.setTextSize(textSize);

            layers.setBounds(bounds);
            setBounds(bounds);
        }

        @Override
        public void draw(final Canvas canvas) {
            super.draw(canvas);

            layers.draw(canvas);

            final Paint paint = getPaint();
            final int original = paint.getColor();

            paint.setColor(textColor);
            canvas.drawText(name, paddingLeft, height
                    - ((height - textHeight) / 2), paint);

            paint.setColor(original);
        }
    }


    public static void setText(final TextView view,
            final Collection<Label> labels) {
        final Label[] sortedLabels = labels.toArray(new Label[labels.size()]);
        Arrays.sort(sortedLabels, new Comparator<Label>() {

            @Override
            public int compare(final Label lhs, final Label rhs) {
                return CASE_INSENSITIVE_ORDER.compare(lhs.getName(),
                        rhs.getName());
            }
        });
        setText(view, sortedLabels);
    }


    public static void setText(final TextView view, final Label label) {
        setText(view, new Label[] { label });
    }

    private static void setText(final TextView view, final Label[] labels) {
        final Resources resources = view.getResources();
        final float paddingTop = ServiceUtils.getPixels(resources, PADDING_TOP);
        final float paddingLeft = ServiceUtils.getPixels(resources,
                PADDING_LEFT);
        final float paddingRight = ServiceUtils.getPixels(resources,
                PADDING_RIGHT);
        final float paddingBottom = ServiceUtils.getPixels(resources,
                PADDING_BOTTOM);

        Paint p = new Paint();
        p.setTypeface(DEFAULT_BOLD);
        p.setTextSize(view.getTextSize());

        final Rect textBounds = new Rect();
        String[] names = new String[labels.length];
        int[] nameWidths = new int[labels.length];
        int textHeight = MIN_VALUE;
        for (int i = 0; i < labels.length; i++) {
            String name = labels[i].getName().toUpperCase(US);
            textBounds.setEmpty();
            p.getTextBounds(name, 0, name.length(), textBounds);
            names[i] = name;
            textHeight = Math.max(textBounds.height(), textHeight);
            nameWidths[i] = textBounds.width();
        }

        final float textSize = view.getTextSize();
        final StyledText text = new StyledText();
        for (int i = 0; i < labels.length; i++) {
            Rect bounds = new Rect();
            bounds.right = Math.round(nameWidths[i] + paddingLeft
                    + paddingRight + 0.5F);
            bounds.bottom = Math.round(textHeight + paddingTop + paddingBottom
                    + 0.5F);

            text.append('\uFFFC', new LabelDrawableSpan(resources, textSize,
                    labels[i].getColor(), paddingLeft, textHeight, bounds,
                    names[i]));

            if (i + 1 < labels.length)
                text.append(' ');
        }
        view.setText(text);
    }

    private final Resources resources;

    private final float textSize;

    private final String name;

    private final int color;

    private final float textHeight;

    private final float paddingLeft;

    private final Rect bounds;


    public LabelDrawableSpan(final Resources resources, final float textSize,
            final String color, final float paddingLeft,
            final float textHeight, final Rect bounds, final String name) {
        this.resources = resources;
        this.textSize = textSize;
        this.color = Color.parseColor('#' + color);
        this.paddingLeft = paddingLeft;
        this.textHeight = textHeight;
        this.bounds = bounds;
        this.name = name;
    }

    @Override
    public Drawable getDrawable() {
        return new LabelDrawable(paddingLeft, textHeight, bounds, resources,
                textSize, name, color);
    }
}

<code block>

package com.github.mobile.ui.issue;

import static java.lang.String.CASE_INSENSITIVE_ORDER;
import android.accounts.Account;
import android.util.Log;

import com.github.mobile.R;
import com.github.mobile.ui.DialogFragmentActivity;
import com.github.mobile.ui.ProgressDialogTask;
import com.github.mobile.util.ToastUtils;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.Label;
import org.eclipse.egit.github.core.service.LabelService;


public class LabelsDialog {

    private static final String TAG = "LabelsDialog";

    private final LabelService service;

    private final int requestCode;

    private final DialogFragmentActivity activity;

    private final IRepositoryIdProvider repository;

    private Map<String, Label> labels;


    public LabelsDialog(final DialogFragmentActivity activity,
            final int requestCode, final IRepositoryIdProvider repository,
            final LabelService service) {
        this.activity = activity;
        this.requestCode = requestCode;
        this.repository = repository;
        this.service = service;
    }

    private void load(final Collection<Label> selectedLabels) {
        new ProgressDialogTask<List<Label>>(activity) {

            @Override
            public List<Label> run(Account account) throws Exception {
                List<Label> repositoryLabels = service.getLabels(repository);
                Map<String, Label> loadedLabels = new TreeMap<>(
                        CASE_INSENSITIVE_ORDER);
                for (Label label : repositoryLabels)
                    loadedLabels.put(label.getName(), label);
                labels = loadedLabels;
                return repositoryLabels;
            }

            @Override
            protected void onSuccess(List<Label> all) throws Exception {
                super.onSuccess(all);

                show(selectedLabels);
            }

            @Override
            protected void onException(Exception e) throws RuntimeException {
                super.onException(e);

                Log.d(TAG, "Exception loading labels", e);
                ToastUtils.show(activity, e, R.string.error_labels_load);
            }

            @Override
            public void execute() {
                showIndeterminate(R.string.loading_labels);

                super.execute();
            }
        }.execute();
    }


    public void show(Collection<Label> selectedLabels) {
        if (labels == null) {
            load(selectedLabels);
            return;
        }

        final ArrayList<Label> names = new ArrayList<>(labels.values());
        final boolean[] checked = new boolean[names.size()];
        if (selectedLabels != null && !selectedLabels.isEmpty()) {
            Set<String> selectedNames = new HashSet<>();
            for (Label label : selectedLabels)
                selectedNames.add(label.getName());
            for (int i = 0; i < checked.length; i++)
                if (selectedNames.contains(names.get(i).getName()))
                    checked[i] = true;
        }
        LabelsDialogFragment.show(activity, requestCode,
                activity.getString(R.string.select_labels), null, names, checked);
    }
}

<code block>

package com.github.mobile.ui.issue;

import static android.view.View.GONE;
import static android.view.View.VISIBLE;
import static com.github.mobile.Intents.EXTRA_ISSUE;
import static com.github.mobile.Intents.EXTRA_REPOSITORY_NAME;
import static com.github.mobile.Intents.EXTRA_REPOSITORY_OWNER;
import static com.github.mobile.Intents.EXTRA_USER;
import static com.github.mobile.RequestCodes.ISSUE_ASSIGNEE_UPDATE;
import static com.github.mobile.RequestCodes.ISSUE_LABELS_UPDATE;
import static com.github.mobile.RequestCodes.ISSUE_MILESTONE_UPDATE;
import android.accounts.Account;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.ActionBar;
import android.text.Editable;
import android.text.TextUtils;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.EditText;
import android.widget.ImageView;
import android.widget.LinearLayout.LayoutParams;
import android.widget.TextView;

import com.github.mobile.Intents.Builder;
import com.github.mobile.R;
import com.github.mobile.accounts.AccountUtils;
import com.github.mobile.accounts.AuthenticatedUserTask;
import com.github.mobile.core.issue.IssueUtils;
import com.github.mobile.ui.DialogFragmentActivity;
import com.github.mobile.ui.StyledText;
import com.github.mobile.ui.TextWatcherAdapter;
import com.github.mobile.util.AvatarLoader;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.Label;
import org.eclipse.egit.github.core.Milestone;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.RepositoryId;
import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.service.CollaboratorService;
import org.eclipse.egit.github.core.service.LabelService;
import org.eclipse.egit.github.core.service.MilestoneService;


public class EditIssueActivity extends DialogFragmentActivity {


    public static Intent createIntent(Repository repository) {
        return createIntent(null, repository.getOwner().getLogin(),
            repository.getName(), repository.getOwner());
    }


    public static Intent createIntent(final Issue issue,
        final String repositoryOwner, final String repositoryName,
        final User user) {
        Builder builder = new Builder("repo.issues.edit.VIEW");
        if (user != null)
            builder.add(EXTRA_USER, user);
        builder.add(EXTRA_REPOSITORY_NAME, repositoryName);
        builder.add(EXTRA_REPOSITORY_OWNER, repositoryOwner);
        if (issue != null)
            builder.issue(issue);
        return builder.toIntent();
    }

    private EditText titleText;

    private EditText bodyText;

    private View milestoneGraph;

    private TextView milestoneText;

    private View milestoneClosed;

    private ImageView assigneeAvatar;

    private TextView assigneeText;

    private TextView labelsText;

    @Inject
    private AvatarLoader avatars;

    @Inject
    private MilestoneService milestoneService;

    @Inject
    private CollaboratorService collaboratorService;

    @Inject
    private LabelService labelService;

    private Issue issue;

    private RepositoryId repository;

    private MenuItem saveItem;

    private MilestoneDialog milestoneDialog;

    private AssigneeDialog assigneeDialog;

    private LabelsDialog labelsDialog;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.issue_edit);

        titleText = finder.find(R.id.et_issue_title);
        bodyText = finder.find(R.id.et_issue_body);
        milestoneGraph = finder.find(R.id.ll_milestone_graph);
        milestoneText = finder.find(R.id.tv_milestone);
        milestoneClosed = finder.find(R.id.v_closed);
        assigneeAvatar = finder.find(R.id.iv_assignee_avatar);
        assigneeText = finder.find(R.id.tv_assignee_name);
        labelsText = finder.find(R.id.tv_labels);

        checkCollaboratorStatus();

        Intent intent = getIntent();

        if (savedInstanceState != null)
            issue = (Issue) savedInstanceState.getSerializable(EXTRA_ISSUE);
        if (issue == null)
            issue = (Issue) intent.getSerializableExtra(EXTRA_ISSUE);
        if (issue == null)
            issue = new Issue();

        repository = RepositoryId.create(
            intent.getStringExtra(EXTRA_REPOSITORY_OWNER),
            intent.getStringExtra(EXTRA_REPOSITORY_NAME));

        setSupportActionBar((android.support.v7.widget.Toolbar) findViewById(R.id.toolbar));

        ActionBar actionBar = getSupportActionBar();
        if (issue.getNumber() > 0)
            if (IssueUtils.isPullRequest(issue))
                actionBar.setTitle(getString(R.string.pull_request_title)
                    + issue.getNumber());
            else
                actionBar.setTitle(getString(R.string.issue_title)
                    + issue.getNumber());
        else
            actionBar.setTitle(R.string.new_issue);
        actionBar.setSubtitle(repository.generateId());
        avatars.bind(actionBar, (User) intent.getSerializableExtra(EXTRA_USER));

        titleText.addTextChangedListener(new TextWatcherAdapter() {

            @Override
            public void afterTextChanged(Editable s) {
                updateSaveMenu(s);
            }
        });

        updateSaveMenu();
        titleText.setText(issue.getTitle());
        bodyText.setText(issue.getBody());
    }

    @Override
    public void onDialogResult(int requestCode, int resultCode, Bundle arguments) {
        if (RESULT_OK != resultCode)
            return;

        switch (requestCode) {
            case ISSUE_MILESTONE_UPDATE:
                issue.setMilestone(MilestoneDialogFragment.getSelected(arguments));
                updateMilestone();
                break;
            case ISSUE_ASSIGNEE_UPDATE:
                User assignee = AssigneeDialogFragment.getSelected(arguments);
                if (assignee != null)
                    issue.setAssignee(assignee);
                else
                    issue.setAssignee(new User().setLogin(""));
                updateAssignee();
                break;
            case ISSUE_LABELS_UPDATE:
                issue.setLabels(LabelsDialogFragment.getSelected(arguments));
                updateLabels();
                break;
        }
    }

    private void showMainContent() {
        finder.find(R.id.sv_issue_content).setVisibility(View.VISIBLE);
        finder.find(R.id.pb_loading).setVisibility(View.GONE);
    }

    private void showCollaboratorOptions() {
        finder.find(R.id.tv_milestone_label).setVisibility(View.VISIBLE);
        finder.find(R.id.ll_milestone).setVisibility(View.VISIBLE);
        finder.find(R.id.tv_labels_label).setVisibility(View.VISIBLE);
        finder.find(R.id.ll_labels).setVisibility(View.VISIBLE);
        finder.find(R.id.tv_assignee_label).setVisibility(View.VISIBLE);
        finder.find(R.id.ll_assignee).setVisibility(View.VISIBLE);

        finder.onClick(R.id.ll_milestone, new OnClickListener() {

            @Override
            public void onClick(View v) {
                if (milestoneDialog == null)
                    milestoneDialog = new MilestoneDialog(
                        EditIssueActivity.this, ISSUE_MILESTONE_UPDATE,
                        repository, milestoneService);
                milestoneDialog.show(issue.getMilestone());
            }
        });

        finder.onClick(R.id.ll_assignee, new OnClickListener() {

            @Override
            public void onClick(View v) {
                if (assigneeDialog == null)
                    assigneeDialog = new AssigneeDialog(EditIssueActivity.this,
                        ISSUE_ASSIGNEE_UPDATE, repository,
                        collaboratorService);
                assigneeDialog.show(issue.getAssignee());
            }
        });

        finder.onClick(R.id.ll_labels, new OnClickListener() {

            @Override
            public void onClick(View v) {
                if (labelsDialog == null)
                    labelsDialog = new LabelsDialog(EditIssueActivity.this,
                        ISSUE_LABELS_UPDATE, repository, labelService);
                labelsDialog.show(issue.getLabels());
            }
        });

        updateAssignee();
        updateLabels();
        updateMilestone();
    }

    private void updateMilestone() {
        Milestone milestone = issue.getMilestone();
        if (milestone != null) {
            milestoneText.setText(milestone.getTitle());
            float closed = milestone.getClosedIssues();
            float total = closed + milestone.getOpenIssues();
            if (total > 0) {
                ((LayoutParams) milestoneClosed.getLayoutParams()).weight = closed
                    / total;
                milestoneClosed.setVisibility(VISIBLE);
            } else
                milestoneClosed.setVisibility(GONE);
            milestoneGraph.setVisibility(VISIBLE);
        } else {
            milestoneText.setText(R.string.none);
            milestoneGraph.setVisibility(GONE);
        }
    }

    private void updateAssignee() {
        User assignee = issue.getAssignee();
        String login = assignee != null ? assignee.getLogin() : null;
        if (!TextUtils.isEmpty(login)) {
            assigneeText.setText(new StyledText().bold(login));
            assigneeAvatar.setVisibility(VISIBLE);
            avatars.bind(assigneeAvatar, assignee);
        } else {
            assigneeAvatar.setVisibility(GONE);
            assigneeText.setText(R.string.unassigned);
        }
    }

    private void updateLabels() {
        List<Label> labels = issue.getLabels();
        if (labels != null && !labels.isEmpty())
            LabelDrawableSpan.setText(labelsText, labels);
        else
            labelsText.setText(R.string.none);
    }

    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);

        outState.putSerializable(EXTRA_ISSUE, issue);
    }

    private void updateSaveMenu() {
        if (titleText != null)
            updateSaveMenu(titleText.getText());
    }

    private void updateSaveMenu(final CharSequence text) {
        if (saveItem != null)
            saveItem.setEnabled(!TextUtils.isEmpty(text));
    }

    @Override
    public boolean onCreateOptionsMenu(Menu options) {
        getMenuInflater().inflate(R.menu.issue_edit, options);
        saveItem = options.findItem(R.id.m_apply);
        updateSaveMenu();
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.m_apply:
                issue.setTitle(titleText.getText().toString());
                issue.setBody(bodyText.getText().toString());
                if (issue.getNumber() > 0)
                    new EditIssueTask(this, repository, issue) {

                        @Override
                        protected void onSuccess(Issue editedIssue)
                            throws Exception {
                            super.onSuccess(editedIssue);

                            Intent intent = new Intent();
                            intent.putExtra(EXTRA_ISSUE, editedIssue);
                            setResult(RESULT_OK, intent);
                            finish();
                        }
                    }.edit();
                else
                    new CreateIssueTask(this, repository, issue) {

                        @Override
                        protected void onSuccess(Issue created) throws Exception {
                            super.onSuccess(created);

                            Intent intent = new Intent();
                            intent.putExtra(EXTRA_ISSUE, created);
                            setResult(RESULT_OK, intent);
                            finish();
                        }

                    }.create();
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    private void checkCollaboratorStatus() {
        new AuthenticatedUserTask<Boolean>(this) {

            @Override
            public Boolean run(Account account) throws Exception {
                return collaboratorService.isCollaborator(
                    repository, AccountUtils.getLogin(EditIssueActivity.this));
            }

            @Override
            protected void onSuccess(Boolean isCollaborator) throws Exception {
                super.onSuccess(isCollaborator);

                showMainContent();
                if (isCollaborator)
                    showCollaboratorOptions();
            }

            @Override
            protected void onException(Exception e) throws RuntimeException {
                super.onException(e);

                showMainContent();
            }
        }.execute();
    }
}

<code block>

package com.github.mobile.ui.issue;

import static android.view.View.GONE;
import static com.github.mobile.Intents.EXTRA_ISSUE_FILTER;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.ActionBar;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.ImageView;
import android.widget.RadioButton;
import android.widget.TextView;

import com.github.mobile.Intents.Builder;
import com.github.mobile.R;
import com.github.mobile.core.issue.IssueFilter;
import com.github.mobile.ui.DialogFragmentActivity;
import com.github.mobile.util.AvatarLoader;
import com.google.inject.Inject;

import java.util.Set;

import org.eclipse.egit.github.core.Label;
import org.eclipse.egit.github.core.Milestone;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.service.CollaboratorService;
import org.eclipse.egit.github.core.service.LabelService;
import org.eclipse.egit.github.core.service.MilestoneService;


public class EditIssuesFilterActivity extends DialogFragmentActivity {


    public static Intent createIntent(IssueFilter filter) {
        return new Builder("repo.issues.filter.VIEW").add(EXTRA_ISSUE_FILTER,
            filter).toIntent();
    }

    private static final int REQUEST_LABELS = 1;

    private static final int REQUEST_MILESTONE = 2;

    private static final int REQUEST_ASSIGNEE = 3;

    @Inject
    private CollaboratorService collaborators;

    @Inject
    private MilestoneService milestones;

    @Inject
    private LabelService labels;

    @Inject
    private AvatarLoader avatars;

    private LabelsDialog labelsDialog;

    private MilestoneDialog milestoneDialog;

    private AssigneeDialog assigneeDialog;

    private IssueFilter filter;

    private TextView labelsText;

    private TextView milestoneText;

    private TextView assigneeText;

    private ImageView avatarView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.issues_filter_edit);

        labelsText = finder.find(R.id.tv_labels);
        milestoneText = finder.find(R.id.tv_milestone);
        assigneeText = finder.find(R.id.tv_assignee);
        avatarView = finder.find(R.id.iv_avatar);

        if (savedInstanceState != null)
            filter = (IssueFilter) savedInstanceState
                .getSerializable(EXTRA_ISSUE_FILTER);

        if (filter == null)
            filter = (IssueFilter) getIntent().getSerializableExtra(
                EXTRA_ISSUE_FILTER);

        final Repository repository = filter.getRepository();

        setSupportActionBar((android.support.v7.widget.Toolbar) findViewById(R.id.toolbar));

        ActionBar actionBar = getSupportActionBar();
        actionBar.setTitle(R.string.filter_issues_title);
        actionBar.setSubtitle(repository.generateId());
        avatars.bind(actionBar, repository.getOwner());

        OnClickListener assigneeListener = new OnClickListener() {

            public void onClick(View v) {
                if (assigneeDialog == null)
                    assigneeDialog = new AssigneeDialog(
                        EditIssuesFilterActivity.this, REQUEST_ASSIGNEE,
                        repository, collaborators);
                assigneeDialog.show(filter.getAssignee());
            }
        };

        findViewById(R.id.tv_assignee_label)
            .setOnClickListener(assigneeListener);
        assigneeText.setOnClickListener(assigneeListener);

        OnClickListener milestoneListener = new OnClickListener() {

            public void onClick(View v) {
                if (milestoneDialog == null)
                    milestoneDialog = new MilestoneDialog(
                        EditIssuesFilterActivity.this, REQUEST_MILESTONE,
                        repository, milestones);
                milestoneDialog.show(filter.getMilestone());
            }
        };

        findViewById(R.id.tv_milestone_label)
            .setOnClickListener(milestoneListener);
        milestoneText.setOnClickListener(milestoneListener);

        OnClickListener labelsListener = new OnClickListener() {

            public void onClick(View v) {
                if (labelsDialog == null)
                    labelsDialog = new LabelsDialog(
                        EditIssuesFilterActivity.this, REQUEST_LABELS,
                        repository, labels);
                labelsDialog.show(filter.getLabels());
            }
        };

        findViewById(R.id.tv_labels_label)
            .setOnClickListener(labelsListener);
        labelsText.setOnClickListener(labelsListener);

        updateAssignee();
        updateMilestone();
        updateLabels();

        RadioButton openButton = (RadioButton) findViewById(R.id.rb_open);

        openButton.setOnCheckedChangeListener(new OnCheckedChangeListener() {

            public void onCheckedChanged(CompoundButton buttonView,
                boolean isChecked) {
                if (isChecked)
                    filter.setOpen(true);
            }
        });

        RadioButton closedButton = (RadioButton) findViewById(R.id.rb_closed);

        closedButton.setOnCheckedChangeListener(new OnCheckedChangeListener() {

            public void onCheckedChanged(CompoundButton buttonView,
                boolean isChecked) {
                if (isChecked)
                    filter.setOpen(false);
            }
        });

        if (filter.isOpen())
            openButton.setChecked(true);
        else
            closedButton.setChecked(true);
    }

    @Override
    public boolean onCreateOptionsMenu(Menu options) {
        getMenuInflater().inflate(R.menu.issue_filter, options);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.m_apply:
                Intent intent = new Intent();
                intent.putExtra(EXTRA_ISSUE_FILTER, filter);
                setResult(RESULT_OK, intent);
                finish();
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);

        outState.putSerializable(EXTRA_ISSUE_FILTER, filter);
    }

    private void updateLabels() {
        Set<Label> selected = filter.getLabels();
        if (selected != null)
            LabelDrawableSpan.setText(labelsText, selected);
        else
            labelsText.setText(R.string.none);
    }

    private void updateMilestone() {
        Milestone selected = filter.getMilestone();
        if (selected != null)
            milestoneText.setText(selected.getTitle());
        else
            milestoneText.setText(R.string.none);
    }

    private void updateAssignee() {
        User selected = filter.getAssignee();
        if (selected != null) {
            avatars.bind(avatarView, selected);
            assigneeText.setText(selected.getLogin());
        } else {
            avatarView.setVisibility(GONE);
            assigneeText.setText(R.string.assignee_anyone);
        }
    }

    @Override
    public void onDialogResult(int requestCode, int resultCode, Bundle arguments) {
        if (RESULT_OK != resultCode)
            return;

        switch (requestCode) {
            case REQUEST_LABELS:
                filter.setLabels(LabelsDialogFragment.getSelected(arguments));
                updateLabels();
                break;
            case REQUEST_MILESTONE:
                filter.setMilestone(MilestoneDialogFragment.getSelected(arguments));
                updateMilestone();
                break;
            case REQUEST_ASSIGNEE:
                filter.setAssignee(AssigneeDialogFragment.getSelected(arguments));
                updateAssignee();
                break;
        }
    }
}

<code block>
package com.github.mobile.ui.issue;

import static java.lang.String.CASE_INSENSITIVE_ORDER;
import android.os.Bundle;
import android.support.v4.content.Loader;
import android.view.View;
import android.widget.ListView;

import com.github.kevinsawicki.wishlist.AsyncLoader;
import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.mobile.R;
import com.github.mobile.core.issue.IssueFilter;
import com.github.mobile.persistence.AccountDataManager;
import com.github.mobile.ui.ItemListFragment;
import com.github.mobile.util.AvatarLoader;
import com.google.inject.Inject;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;


public class FilterListFragment extends ItemListFragment<IssueFilter> implements
        Comparator<IssueFilter> {

    @Inject
    private AccountDataManager cache;

    @Inject
    private AvatarLoader avatars;

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        setEmptyText(R.string.no_bookmarks);
    }

    @Override
    public Loader<List<IssueFilter>> onCreateLoader(int id, Bundle args) {
        return new AsyncLoader<List<IssueFilter>>(getActivity()) {

            @Override
            public List<IssueFilter> loadInBackground() {
                List<IssueFilter> filters = new ArrayList<>(
                        cache.getIssueFilters());
                Collections.sort(filters, FilterListFragment.this);
                return filters;
            }
        };
    }

    @Override
    public void onListItemClick(ListView l, View v, int position, long id) {
        IssueFilter filter = (IssueFilter) l.getItemAtPosition(position);
        startActivity(IssueBrowseActivity.createIntent(filter));
    }

    @Override
    public void onResume() {
        super.onResume();

        refresh();
    }

    @Override
    protected int getErrorMessage(Exception exception) {
        return R.string.error_bookmarks_load;
    }

    @Override
    protected SingleTypeAdapter<IssueFilter> createAdapter(
            List<IssueFilter> items) {
        return new FilterListAdapter(getActivity().getLayoutInflater(),
                items.toArray(new IssueFilter[items.size()]), avatars);
    }

    @Override
    public int compare(final IssueFilter lhs, final IssueFilter rhs) {
        int compare = CASE_INSENSITIVE_ORDER.compare(lhs.getRepository()
                .generateId(), rhs.getRepository().generateId());
        if (compare == 0)
            compare = CASE_INSENSITIVE_ORDER.compare(
                    lhs.toDisplay().toString(), rhs.toDisplay().toString());
        return compare;
    }
}

<code block>

package com.github.mobile.ui.issue;

import static com.github.mobile.Intents.EXTRA_ISSUE_NUMBER;
import static com.github.mobile.Intents.EXTRA_IS_COLLABORATOR;
import static com.github.mobile.Intents.EXTRA_IS_OWNER;
import static com.github.mobile.Intents.EXTRA_REPOSITORY_NAME;
import static com.github.mobile.Intents.EXTRA_REPOSITORY_OWNER;
import static com.github.mobile.Intents.EXTRA_USER;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v7.app.ActionBarActivity;
import android.util.SparseArray;
import android.view.ViewGroup;

import com.github.mobile.core.issue.IssueStore;
import com.github.mobile.ui.FragmentStatePagerAdapter;

import java.util.List;

import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.RepositoryId;
import org.eclipse.egit.github.core.RepositoryIssue;
import org.eclipse.egit.github.core.User;


public class IssuesPagerAdapter extends FragmentStatePagerAdapter {

    private final Repository repo;

    private final List<RepositoryId> repos;

    private final int[] issues;

    private final SparseArray<IssueFragment> fragments = new SparseArray<>();

    private final IssueStore store;

    private boolean isCollaborator;

    private boolean isOwner;


    public IssuesPagerAdapter(ActionBarActivity activity,
            List<RepositoryId> repoIds, int[] issueNumbers,
            IssueStore issueStore, boolean collaborator, boolean owner) {
        super(activity);

        repos = repoIds;
        repo = null;
        issues = issueNumbers;
        store = issueStore;
        isCollaborator = collaborator;
        isOwner = owner;
    }


    public IssuesPagerAdapter(ActionBarActivity activity,
            Repository repository, int[] issueNumbers,
            boolean collaborator, boolean owner) {
        super(activity);

        repos = null;
        repo = repository;
        issues = issueNumbers;
        store = null;
        isCollaborator = collaborator;
        isOwner = owner;
    }

    @Override
    public Fragment getItem(int position) {
        IssueFragment fragment = new IssueFragment();
        Bundle args = new Bundle();
        if (repo != null) {
            args.putString(EXTRA_REPOSITORY_NAME, repo.getName());
            User owner = repo.getOwner();
            args.putString(EXTRA_REPOSITORY_OWNER, owner.getLogin());
            args.putSerializable(EXTRA_USER, owner);
        } else {
            RepositoryId repo = repos.get(position);
            args.putString(EXTRA_REPOSITORY_NAME, repo.getName());
            args.putString(EXTRA_REPOSITORY_OWNER, repo.getOwner());
            RepositoryIssue issue = store.getIssue(repo, issues[position]);
            if (issue != null && issue.getUser() != null) {
                Repository fullRepo = issue.getRepository();
                if (fullRepo != null && fullRepo.getOwner() != null)
                    args.putSerializable(EXTRA_USER, fullRepo.getOwner());
            }
        }
        args.putInt(EXTRA_ISSUE_NUMBER, issues[position]);
        args.putBoolean(EXTRA_IS_COLLABORATOR, isCollaborator);
        args.putBoolean(EXTRA_IS_OWNER, isOwner);
        fragment.setArguments(args);
        return fragment;
    }

    @Override
    public void destroyItem(ViewGroup container, int position, Object object) {
        super.destroyItem(container, position, object);

        fragments.remove(position);
    }

    @Override
    public Object instantiateItem(ViewGroup container, int position) {
        Object fragment = super.instantiateItem(container, position);
        if (fragment instanceof IssueFragment)
            fragments.put(position, (IssueFragment) fragment);
        return fragment;
    }

    @Override
    public int getCount() {
        return issues.length;
    }


    public IssuesPagerAdapter onDialogResult(int position, int requestCode,
            int resultCode, Bundle arguments) {
        IssueFragment fragment = fragments.get(position);
        if (fragment != null)
            fragment.onDialogResult(requestCode, resultCode, arguments);
        return this;
    }
}

<code block>

package com.github.mobile.ui.issue;

import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
import static android.content.Intent.FLAG_ACTIVITY_SINGLE_TOP;
import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.support.annotation.Nullable;
import android.view.LayoutInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemLongClickListener;

import com.github.mobile.Intents.Builder;
import com.github.mobile.R;
import com.github.mobile.RequestFuture;
import com.github.mobile.core.issue.IssueFilter;
import com.github.mobile.persistence.AccountDataManager;
import com.github.mobile.ui.ConfirmDialogFragment;
import com.github.mobile.ui.DialogFragment;
import com.github.mobile.ui.MainActivity;
import com.google.inject.Inject;


public class FiltersViewFragment extends DialogFragment implements
    OnItemLongClickListener {


    public static Intent createIntent() {
        return new Builder("repo.issues.filters.VIEW").toIntent();
    }

    private static final String ARG_FILTER = "filter";

    private static final int REQUEST_DELETE = 1;

    @Inject
    private AccountDataManager cache;

    private FilterListFragment fragment;


    @Override
    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container,
        @Nullable Bundle savedInstanceState) {
        return inflater.inflate(R.layout.issues_filter_list, null);
    }

    @Override
    public void onViewCreated(View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        fragment = (FilterListFragment) getChildFragmentManager().findFragmentById(android.R.id.list);
        fragment.getListView().setOnItemLongClickListener(this);
    }

    @Override
    public void onDialogResult(int requestCode, int resultCode, Bundle arguments) {
        if (requestCode == REQUEST_DELETE && resultCode == Activity.RESULT_OK) {
            IssueFilter filter = (IssueFilter) arguments
                .getSerializable(ARG_FILTER);
            cache.removeIssueFilter(filter, new RequestFuture<IssueFilter>() {

                @Override
                public void success(IssueFilter response) {
                    if (fragment != null)
                        fragment.refresh();
                }
            });
            return;
        }

        super.onDialogResult(requestCode, resultCode, arguments);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                Intent intent = new Intent(getActivity(), MainActivity.class);
                intent.addFlags(FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_SINGLE_TOP);
                startActivity(intent);
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    public boolean onItemLongClick(AdapterView<?> parent, View view,
        int position, long id) {
        IssueFilter filter = (IssueFilter) parent.getItemAtPosition(position);
        Bundle args = new Bundle();
        args.putSerializable(ARG_FILTER, filter);
        ConfirmDialogFragment.show(getActivity(), REQUEST_DELETE,
            getString(R.string.confirm_bookmark_delete_title),
            getString(R.string.confirm_bookmark_delete_message), args);
        return true;
    }
}

<code block>

package com.github.mobile.ui.issue;

import static com.github.mobile.RequestCodes.ISSUE_ASSIGNEE_UPDATE;
import android.accounts.Account;

import com.github.mobile.R;
import com.github.mobile.core.issue.IssueStore;
import com.github.mobile.ui.DialogFragmentActivity;
import com.github.mobile.ui.ProgressDialogTask;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.service.CollaboratorService;


public class EditAssigneeTask extends ProgressDialogTask<Issue> {

    @Inject
    private CollaboratorService service;

    @Inject
    private IssueStore store;

    private final AssigneeDialog assigneeDialog;

    private final IRepositoryIdProvider repositoryId;

    private final int issueNumber;

    private User assignee;


    public EditAssigneeTask(final DialogFragmentActivity activity,
            final IRepositoryIdProvider repositoryId, final int issueNumber) {
        super(activity);

        this.repositoryId = repositoryId;
        this.issueNumber = issueNumber;
        assigneeDialog = new AssigneeDialog(activity, ISSUE_ASSIGNEE_UPDATE,
                repositoryId, service);
    }


    public EditAssigneeTask prompt(User assignee) {
        assigneeDialog.show(assignee);
        return this;
    }


    public EditAssigneeTask edit(User user) {
        showIndeterminate(R.string.updating_assignee);

        this.assignee = user;

        execute();
        return this;
    }

    @Override
    protected Issue run(Account account) throws Exception {
        Issue editedIssue = new Issue();
        if (assignee != null)
            editedIssue.setAssignee(assignee);
        else
            editedIssue.setAssignee(new User().setLogin(""));
        editedIssue.setNumber(issueNumber);
        return store.editIssue(repositoryId, editedIssue);
    }
}

<code block>

package com.github.mobile.ui.issue;

import static com.github.mobile.Intents.EXTRA_COMMENT;
import static com.github.mobile.Intents.EXTRA_ISSUE_NUMBER;
import static com.github.mobile.Intents.EXTRA_REPOSITORY_NAME;
import static com.github.mobile.Intents.EXTRA_REPOSITORY_OWNER;
import static com.github.mobile.Intents.EXTRA_USER;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.ActionBar;

import com.github.mobile.Intents.Builder;
import com.github.mobile.R;
import com.github.mobile.ui.comment.CommentPreviewPagerAdapter;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.RepositoryId;
import org.eclipse.egit.github.core.User;


public class EditCommentActivity extends
        com.github.mobile.ui.comment.CreateCommentActivity {


    public static Intent createIntent(RepositoryId repoId, int issueNumber, Comment comment,
            User user) {
        Builder builder = new Builder("issue.comment.edit.VIEW");
        builder.repo(repoId);
        builder.add(EXTRA_COMMENT, comment);
        builder.add(EXTRA_ISSUE_NUMBER, issueNumber);
        builder.add(EXTRA_USER, user);
        return builder.toIntent();
    }

    private RepositoryId repositoryId;


    private Comment comment;

    private int issueNumber;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        comment = getSerializableExtra(EXTRA_COMMENT);
        issueNumber = getIntExtra(EXTRA_ISSUE_NUMBER);
        repositoryId = new RepositoryId(getStringExtra(EXTRA_REPOSITORY_OWNER),
                getStringExtra(EXTRA_REPOSITORY_NAME));

        super.onCreate(savedInstanceState);

        ActionBar actionBar = getSupportActionBar();
        actionBar.setTitle(getString(R.string.issue_title) + issueNumber);
        actionBar.setSubtitle(repositoryId.generateId());
        avatars.bind(actionBar, (User) getSerializableExtra(EXTRA_USER));
    }

    @Override
    protected void createComment(String comment) {
        editComment(comment);
    }


    protected void editComment(String commentText) {
        comment.setBody(commentText);

        new EditCommentTask(this, repositoryId, comment) {
            @Override
            protected void onSuccess(Comment comment) throws Exception {
                super.onSuccess(comment);

                finish(comment);
            }
        }.start();
    }

    @Override
    protected CommentPreviewPagerAdapter createAdapter() {
        CommentPreviewPagerAdapter commentPreviewPagerAdapter = new CommentPreviewPagerAdapter(this, repositoryId);
        commentPreviewPagerAdapter.setCommentText(comment != null ? comment.getBody() : null);
        return commentPreviewPagerAdapter;
    }
}

<code block>

package com.github.mobile.ui.issue;

import static com.github.mobile.RequestCodes.ISSUE_CLOSE;
import static com.github.mobile.RequestCodes.ISSUE_REOPEN;
import static org.eclipse.egit.github.core.service.IssueService.STATE_CLOSED;
import static org.eclipse.egit.github.core.service.IssueService.STATE_OPEN;
import android.accounts.Account;

import com.github.mobile.R;
import com.github.mobile.core.issue.IssueStore;
import com.github.mobile.ui.ConfirmDialogFragment;
import com.github.mobile.ui.DialogFragmentActivity;
import com.github.mobile.ui.ProgressDialogTask;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.Issue;


public class EditStateTask extends ProgressDialogTask<Issue> {

    @Inject
    private IssueStore store;

    private final IRepositoryIdProvider repositoryId;

    private final int issueNumber;

    private boolean close;


    public EditStateTask(final DialogFragmentActivity activity,
            final IRepositoryIdProvider repositoryId, final int issueNumber) {
        super(activity);

        this.repositoryId = repositoryId;
        this.issueNumber = issueNumber;
    }


    public EditStateTask confirm(boolean close) {
        if (close)
            ConfirmDialogFragment.show((DialogFragmentActivity) getContext(),
                    ISSUE_CLOSE, getString(R.string.issue_confirm_close_title),
                    getString(R.string.issue_confirm_close_message));
        else
            ConfirmDialogFragment.show((DialogFragmentActivity) getContext(),
                    ISSUE_REOPEN, getString(R.string.issue_confirm_reopen_title),
                    getString(R.string.issue_confirm_reopen_message));

        return this;
    }

    @Override
    protected Issue run(Account account) throws Exception {
        Issue editedIssue = new Issue();
        editedIssue.setNumber(issueNumber);
        if (close)
            editedIssue.setState(STATE_CLOSED);
        else
            editedIssue.setState(STATE_OPEN);
        return store.editIssue(repositoryId, editedIssue);
    }


    public EditStateTask edit(boolean close) {
        if (close)
            showIndeterminate(R.string.closing_issue);
        else
            showIndeterminate(R.string.reopening_issue);

        this.close = close;

        execute();
        return this;
    }
}

<code block>

package com.github.mobile.ui.issue;

import static android.app.SearchManager.APP_DATA;
import static com.github.mobile.Intents.EXTRA_REPOSITORY;
import static org.eclipse.egit.github.core.service.IssueService.STATE_OPEN;
import android.os.Bundle;
import android.support.v4.content.Loader;
import android.view.View;
import android.widget.ListView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.mobile.R;
import com.github.mobile.ThrowableLoader;
import com.github.mobile.ui.ItemListFragment;
import com.github.mobile.util.AvatarLoader;
import com.google.inject.Inject;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.SearchIssue;
import org.eclipse.egit.github.core.service.IssueService;


public class SearchIssueListFragment extends ItemListFragment<SearchIssue>
        implements Comparator<SearchIssue> {

    @Inject
    private IssueService service;

    @Inject
    private AvatarLoader avatars;

    private Repository repository;

    private String query;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        Bundle appData = getActivity().getIntent().getBundleExtra(APP_DATA);
        if (appData != null)
            repository = (Repository) appData.getSerializable(EXTRA_REPOSITORY);
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        setEmptyText(R.string.no_issues);
    }


    public SearchIssueListFragment setQuery(final String query) {
        this.query = query;
        return this;
    }

    @Override
    public void onListItemClick(ListView l, View v, int position, long id) {
        final SearchIssue searchIssue = (SearchIssue) l
                .getItemAtPosition(position);
        Issue issue = new Issue().setNumber(searchIssue.getNumber());
        startActivity(IssuesViewActivity.createIntent(issue, repository));
    }

    @Override
    public Loader<List<SearchIssue>> onCreateLoader(int id, Bundle args) {
        return new ThrowableLoader<List<SearchIssue>>(getActivity(), items) {

            public List<SearchIssue> loadData() throws Exception {
                if (repository == null)
                    return Collections.emptyList();
                List<SearchIssue> matches = new ArrayList<>();

                matches.addAll(service.searchIssues(repository, STATE_OPEN, query));

                Collections.sort(matches, SearchIssueListFragment.this);
                return matches;
            }
        };
    }

    @Override
    protected int getErrorMessage(Exception exception) {
        return R.string.error_issues_load;
    }

    @Override
    protected SingleTypeAdapter<SearchIssue> createAdapter(
            List<SearchIssue> items) {
        return new SearchIssueListAdapter(getActivity().getLayoutInflater(),
                items.toArray(new SearchIssue[items.size()]), avatars);
    }

    @Override
    public int compare(SearchIssue lhs, SearchIssue rhs) {
        return rhs.getNumber() - lhs.getNumber();
    }
}

<code block>

package com.github.mobile.ui.issue;

import android.accounts.Account;
import android.app.Activity;
import android.content.Context;
import android.util.Log;

import com.github.mobile.R;
import com.github.mobile.ui.ProgressDialogTask;
import com.github.mobile.util.HtmlUtils;
import com.github.mobile.util.ToastUtils;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.service.IssueService;


public class CreateCommentTask extends ProgressDialogTask<Comment> {

    private static final String TAG = "CreateCommentTask";

    private final IRepositoryIdProvider repository;

    private final int issueNumber;

    private final String comment;

    @Inject
    private IssueService service;


    public CreateCommentTask(final Context context,
            final IRepositoryIdProvider repository, final int issueNumber,
            final String comment) {
        super(context);

        this.repository = repository;
        this.issueNumber = issueNumber;
        this.comment = comment;
    }

    @Override
    protected Comment run(Account account) throws Exception {
        Comment created = service.createComment(repository, issueNumber,
                comment);
        String formatted = HtmlUtils.format(created.getBodyHtml()).toString();
        created.setBodyHtml(formatted);
        return created;
    }


    public CreateCommentTask start() {
        showIndeterminate(R.string.creating_comment);

        execute();
        return this;
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception creating comment on issue", e);

        ToastUtils.show((Activity) getContext(), e.getMessage());
    }
}

<code block>

package com.github.mobile.ui.issue;

import static android.app.Activity.RESULT_OK;
import static android.view.View.GONE;
import static android.view.View.VISIBLE;
import static com.github.mobile.Intents.EXTRA_ISSUE;
import static com.github.mobile.Intents.EXTRA_ISSUE_FILTER;
import static com.github.mobile.Intents.EXTRA_REPOSITORY;
import static com.github.mobile.RequestCodes.ISSUE_CREATE;
import static com.github.mobile.RequestCodes.ISSUE_FILTER_EDIT;
import static com.github.mobile.RequestCodes.ISSUE_VIEW;
import android.app.Activity;
import android.app.SearchManager;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.support.v4.view.MenuItemCompat;
import android.support.v7.widget.SearchView;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.widget.ImageView;
import android.widget.ListView;
import android.widget.TextView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.mobile.R;
import com.github.mobile.RequestFuture;
import com.github.mobile.core.ResourcePager;
import com.github.mobile.core.issue.IssueFilter;
import com.github.mobile.core.issue.IssuePager;
import com.github.mobile.core.issue.IssueStore;
import com.github.mobile.persistence.AccountDataManager;
import com.github.mobile.ui.PagedItemFragment;
import com.github.mobile.util.AvatarLoader;
import com.github.mobile.util.ToastUtils;
import com.google.inject.Inject;

import java.util.Collection;
import java.util.List;

import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.Label;
import org.eclipse.egit.github.core.Milestone;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.client.PageIterator;
import org.eclipse.egit.github.core.service.IssueService;


public class IssuesFragment extends PagedItemFragment<Issue> {

    @Inject
    private AccountDataManager cache;

    @Inject
    private IssueService service;

    @Inject
    private IssueStore store;

    private IssueFilter filter;

    private Repository repository;

    private View filterHeader;

    private TextView state;

    private ImageView assigneeAvatar;

    private View assigneeArea;

    private TextView assignee;

    private TextView labels;

    private TextView milestone;

    @Inject
    private AvatarLoader avatars;

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);

        filter = getSerializableExtra(EXTRA_ISSUE_FILTER);
        repository = getSerializableExtra(EXTRA_REPOSITORY);
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        if (filter == null)
            filter = new IssueFilter(repository);
    }

    @Override
    public void onViewCreated(View view, Bundle savedInstanceState) {
        filterHeader = getLayoutInflater(savedInstanceState).inflate(
                R.layout.issues_filter_header, null);
        state = (TextView) filterHeader.findViewById(R.id.tv_filter_state);
        labels = (TextView) filterHeader.findViewById(R.id.tv_filter_labels);
        milestone = (TextView) filterHeader
                .findViewById(R.id.tv_filter_milestone);
        assigneeArea = filterHeader.findViewById(R.id.ll_assignee);
        assignee = (TextView) filterHeader.findViewById(R.id.tv_filter_assignee);
        assigneeAvatar = (ImageView) filterHeader
                .findViewById(R.id.iv_assignee_avatar);
        updateFilterSummary();

        super.onViewCreated(view, savedInstanceState);
    }

    @Override
    protected void configureList(Activity activity, ListView listView) {
        super.configureList(activity, listView);

        getListAdapter().addHeader(filterHeader, filter, true);
    }

    private void updateFilterSummary() {
        if (filter.isOpen())
            state.setText(R.string.open_issues);
        else
            state.setText(R.string.closed_issues);

        Collection<Label> filterLabels = filter.getLabels();
        if (filterLabels != null && !filterLabels.isEmpty()) {
            LabelDrawableSpan.setText(labels, filterLabels);
            labels.setVisibility(VISIBLE);
        } else
            labels.setVisibility(GONE);

        Milestone filterMilestone = filter.getMilestone();
        if (filterMilestone != null) {
            milestone.setText(filterMilestone.getTitle());
            milestone.setVisibility(VISIBLE);
        } else
            milestone.setVisibility(GONE);

        User user = filter.getAssignee();
        if (user != null) {
            avatars.bind(assigneeAvatar, user);
            assignee.setText(user.getLogin());
            assigneeArea.setVisibility(VISIBLE);
        } else
            assigneeArea.setVisibility(GONE);
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        setEmptyText(R.string.no_issues);
    }

    @Override
    public void onListItemClick(ListView l, View v, int position, long id) {
        if (position == 0)
            startActivityForResult(
                    EditIssuesFilterActivity.createIntent(filter),
                    ISSUE_FILTER_EDIT);
        else
            startActivityForResult(
                    IssuesViewActivity.createIntent(items, repository, position
                            - getListAdapter().getHeadersCount()), ISSUE_VIEW);
    }

    @Override
    public void onCreateOptionsMenu(Menu optionsMenu, MenuInflater inflater) {
        inflater.inflate(R.menu.issues, optionsMenu);

        SearchManager searchManager = (SearchManager) getActivity().getSystemService(Context.SEARCH_SERVICE);
        MenuItem searchItem = optionsMenu.findItem(R.id.m_search);
        SearchView searchView = (SearchView) MenuItemCompat.getActionView(searchItem);
        searchView.setSearchableInfo(searchManager.getSearchableInfo(getActivity().getComponentName()));

        Bundle args = new Bundle();
        args.putSerializable(EXTRA_REPOSITORY, repository);
        searchView.setAppSearchData(args);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if (!isUsable())
            return false;
        switch (item.getItemId()) {
        case R.id.create_issue:
            startActivityForResult(EditIssueActivity.createIntent(repository),
                    ISSUE_CREATE);
            return true;
        case R.id.m_filter:
            startActivityForResult(
                    EditIssuesFilterActivity.createIntent(filter),
                    ISSUE_FILTER_EDIT);
            return true;
        case R.id.m_bookmark:
            cache.addIssueFilter(filter, new RequestFuture<IssueFilter>() {

                public void success(IssueFilter response) {
                    ToastUtils.show(getActivity(), R.string.message_filter_saved);
                }
            });
            return true;
        default:
            return super.onOptionsItemSelected(item);
        }
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (resultCode == RESULT_OK && requestCode == ISSUE_FILTER_EDIT
                && data != null) {
            IssueFilter newFilter = (IssueFilter) data
                    .getSerializableExtra(EXTRA_ISSUE_FILTER);
            if (!filter.equals(newFilter)) {
                filter = newFilter;
                updateFilterSummary();
                pager.reset();
                refreshWithProgress();
                return;
            }
        }

        if (requestCode == ISSUE_VIEW) {
            notifyDataSetChanged();
            forceRefresh();
            return;
        }

        if (requestCode == ISSUE_CREATE && resultCode == RESULT_OK) {
            Issue created = (Issue) data.getSerializableExtra(EXTRA_ISSUE);
            forceRefresh();
            startActivityForResult(
                    IssuesViewActivity.createIntent(created, repository),
                    ISSUE_VIEW);
            return;
        }

        super.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    protected ResourcePager<Issue> createPager() {
        return new IssuePager(store) {

            @Override
            public PageIterator<Issue> createIterator(int page, int size) {
                return service.pageIssues(repository, filter.toFilterMap(),
                        page, size);
            }
        };
    }

    @Override
    protected int getLoadingMessage() {
        return R.string.loading_issues;
    }

    @Override
    protected int getErrorMessage(Exception exception) {
        return R.string.error_issues_load;
    }

    @Override
    protected SingleTypeAdapter<Issue> createAdapter(List<Issue> items) {
        return new RepositoryIssueListAdapter(
                getActivity().getLayoutInflater(),
                items.toArray(new Issue[items.size()]), avatars);
    }
}

<code block>

package com.github.mobile.ui.search;

import android.content.Context;
import android.view.LayoutInflater;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.mobile.R;
import com.github.mobile.core.search.SearchUser;
import com.github.mobile.util.AvatarLoader;


public class SearchUserListAdapter extends SingleTypeAdapter<SearchUser> {

    private final AvatarLoader avatars;


    public SearchUserListAdapter(final Context context,
            final SearchUser[] elements, final AvatarLoader avatars) {
        super(LayoutInflater.from(context), R.layout.user_item);

        this.avatars = avatars;
        setItems(elements);
    }

    @Override
    public long getItemId(final int position) {
        String userId = getItem(position).getId();
        return Long.parseLong(userId.replace("user-", ""));
    }

    @Override
    protected int[] getChildViewIds() {
        return new int[] { R.id.iv_avatar, R.id.tv_login };
    }

    @Override
    protected void update(final int position, final SearchUser user) {
        setText(1, user.getLogin());
    }
}

<code block>

package com.github.mobile.ui.search;

import android.text.TextUtils;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.TextView;

import com.github.mobile.R;
import com.github.mobile.ui.StyledText;
import com.github.mobile.ui.repo.RepositoryListAdapter;
import com.github.mobile.util.TypefaceUtils;

import org.eclipse.egit.github.core.SearchRepository;


public class SearchRepositoryListAdapter extends
        RepositoryListAdapter<SearchRepository> {


    public SearchRepositoryListAdapter(LayoutInflater inflater,
            SearchRepository[] elements) {
        super(R.layout.user_repo_item, inflater, elements);
    }

    @Override
    public long getItemId(final int position) {
        final String id = getItem(position).getId();
        return !TextUtils.isEmpty(id) ? id.hashCode() : super
                .getItemId(position);
    }

    @Override
    protected View initialize(View view) {
        view = super.initialize(view);

        TypefaceUtils.setOcticons(textView(view, 0),
                (TextView) view.findViewById(R.id.tv_forks_icon),
                (TextView) view.findViewById(R.id.tv_watchers_icon));
        return view;
    }

    @Override
    protected int[] getChildViewIds() {
        return new int[] { R.id.tv_repo_icon, R.id.tv_repo_description,
                R.id.tv_language, R.id.tv_watchers, R.id.tv_forks, R.id.tv_repo_name };
    }

    @Override
    protected void update(int position, SearchRepository repository) {
        StyledText name = new StyledText();
        name.append(repository.getOwner()).append('/');
        name.bold(repository.getName());
        setText(5, name);

        updateDetails(repository.getDescription(), repository.getLanguage(),
                repository.getWatchers(), repository.getForks(),
                repository.isPrivate(), repository.isFork(), null);
    }
}

<code block>

package com.github.mobile.ui.search;

import static android.app.SearchManager.QUERY;
import static android.content.Intent.ACTION_SEARCH;
import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
import static android.content.Intent.FLAG_ACTIVITY_SINGLE_TOP;
import static com.github.mobile.util.TypefaceUtils.ICON_PERSON;
import static com.github.mobile.util.TypefaceUtils.ICON_PUBLIC;
import android.app.SearchManager;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.support.v4.app.FragmentManager;
import android.support.v4.view.MenuItemCompat;
import android.support.v7.app.ActionBar;
import android.support.v7.widget.SearchView;
import android.view.Menu;
import android.view.MenuItem;
import android.widget.ProgressBar;

import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.mobile.R;
import com.github.mobile.ui.MainActivity;
import com.github.mobile.ui.TabPagerActivity;
import com.github.mobile.util.ToastUtils;


public class SearchActivity extends TabPagerActivity<SearchPagerAdapter> {

    private ProgressBar loadingBar;

    private SearchRepositoryListFragment repoFragment;

    private SearchUserListFragment userFragment;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        loadingBar = finder.find(R.id.pb_loading);

        ActionBar actionBar = getSupportActionBar();
        actionBar.setDisplayHomeAsUpEnabled(true);

        configurePager();
        handleIntent(getIntent());
    }

    @Override
    public boolean onCreateOptionsMenu(Menu options) {
        getMenuInflater().inflate(R.menu.search, options);

        SearchManager searchManager = (SearchManager) getSystemService(Context.SEARCH_SERVICE);
        MenuItem searchItem = options.findItem(R.id.m_search);
        SearchView searchView = (SearchView) MenuItemCompat.getActionView(searchItem);
        searchView.setSearchableInfo(searchManager.getSearchableInfo(getComponentName()));

        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.m_clear:
                RepositorySearchSuggestionsProvider.clear(this);
                ToastUtils.show(this, R.string.search_history_cleared);
                return true;
            case android.R.id.home:
                Intent intent = new Intent(this, MainActivity.class);
                intent.addFlags(FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_SINGLE_TOP);
                startActivity(intent);
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    protected SearchPagerAdapter createAdapter() {
        return new SearchPagerAdapter(this);
    }

    @Override
    protected int getContentView() {
        return R.layout.tabbed_progress_pager;
    }

    @Override
    protected String getIcon(int position) {
        switch (position) {
            case 0:
                return ICON_PUBLIC;
            case 1:
                return ICON_PERSON;
            default:
                return super.getIcon(position);
        }
    }

    @Override
    protected void onNewIntent(Intent intent) {
        setIntent(intent);
        handleIntent(intent);
    }

    private void handleIntent(Intent intent) {
        if (ACTION_SEARCH.equals(intent.getAction()))
            search(intent.getStringExtra(QUERY));
    }

    private void search(final String query) {
        getSupportActionBar().setTitle(query);
        RepositorySearchSuggestionsProvider.save(this, query);

        findFragments();

        if (repoFragment != null && userFragment != null) {
            repoFragment.setListShown(false);
            userFragment.setListShown(false);

            repoFragment.refresh();
            userFragment.refresh();
        }
    }

    private void configurePager() {
        configureTabPager();
        ViewUtils.setGone(loadingBar, true);
        setGone(false);
    }

    private void findFragments() {
        if (repoFragment == null || userFragment == null) {
            FragmentManager fm = getSupportFragmentManager();
            repoFragment = (SearchRepositoryListFragment) fm.findFragmentByTag(
                "android:switcher:" + pager.getId() + ":" + 0);
            userFragment = (SearchUserListFragment) fm.findFragmentByTag(
                "android:switcher:" + pager.getId() + ":" + 1);
        }
    }
}

<code block>

package com.github.mobile.ui.search;

import static android.app.SearchManager.QUERY;
import android.app.Activity;
import android.os.Bundle;
import android.support.v4.content.Loader;
import android.view.View;
import android.widget.ListView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.mobile.R;
import com.github.mobile.ThrowableLoader;
import com.github.mobile.accounts.AccountUtils;
import com.github.mobile.core.search.SearchUser;
import com.github.mobile.core.search.SearchUserService;
import com.github.mobile.core.user.RefreshUserTask;
import com.github.mobile.ui.ItemListFragment;
import com.github.mobile.ui.user.UserViewActivity;
import com.github.mobile.util.AvatarLoader;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.egit.github.core.User;


public class SearchUserListFragment extends ItemListFragment<SearchUser> {

    private String query;

    @Inject
    private SearchUserService service;

    @Inject
    private AvatarLoader avatars;

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        setEmptyText(R.string.no_people);
    }

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);

        query = getStringExtra(QUERY);
    }

    @Override
    public void refresh() {
        query = getStringExtra(QUERY);

        super.refresh();
    }

    @Override
    public Loader<List<SearchUser>> onCreateLoader(int id, Bundle args) {
        return new ThrowableLoader<List<SearchUser>>(getActivity(), items) {

            @Override
            public List<SearchUser> loadData() throws Exception {
                return service.searchUsers(query);
            }
        };
    }

    @Override
    protected SingleTypeAdapter<SearchUser> createAdapter(List<SearchUser> items) {
        return new SearchUserListAdapter(getActivity(),
                items.toArray(new SearchUser[items.size()]), avatars);
    }

    @Override
    public void onListItemClick(ListView l, View v, int position, long id) {
        final SearchUser result = (SearchUser) l.getItemAtPosition(position);
        new RefreshUserTask(getActivity(), result.getLogin()) {

            @Override
            protected void onSuccess(User user) throws Exception {
                super.onSuccess(user);

                if (!AccountUtils.isUser(getActivity(), user))
                    startActivity(UserViewActivity.createIntent(user));
            }
        }.execute();
    }

    @Override
    protected int getErrorMessage(Exception exception) {
        return R.string.error_users_search;
    }
}

<code block>

package com.github.mobile.ui.search;

import android.content.Context;
import android.content.SearchRecentSuggestionsProvider;
import android.provider.SearchRecentSuggestions;


public class RepositorySearchSuggestionsProvider extends
        SearchRecentSuggestionsProvider {

    private static final String AUTHORITY = "com.github.search.suggest.recent.repos";


    public static void save(Context context, String query) {
        suggestions(context).saveRecentQuery(query, null);
    }


    public static void clear(Context context) {
        suggestions(context).clearHistory();
    }

    private static SearchRecentSuggestions suggestions(Context context) {
        return new SearchRecentSuggestions(context, AUTHORITY,
                DATABASE_MODE_QUERIES);
    }


    public RepositorySearchSuggestionsProvider() {
        setupSuggestions(AUTHORITY, DATABASE_MODE_QUERIES);
    }
}
<code block>

package com.github.mobile.ui.search;

import android.content.res.Resources;
import android.support.v4.app.Fragment;
import android.support.v7.app.ActionBarActivity;

import com.github.mobile.R;
import com.github.mobile.ui.FragmentPagerAdapter;


public class SearchPagerAdapter extends FragmentPagerAdapter {

    private final Resources resources;


    public SearchPagerAdapter(ActionBarActivity activity) {
        super(activity);

        resources = activity.getResources();
    }

    @Override
    public CharSequence getPageTitle(int position) {
        switch (position) {
        case 0:
            return resources.getString(R.string.tab_repositories);
        case 1:
            return resources.getString(R.string.tab_users);
        default:
            return null;
        }
    }

    @Override
    public Fragment getItem(int position) {
        switch (position) {
        case 0:
            return new SearchRepositoryListFragment();
        case 1:
            return new SearchUserListFragment();
        default:
            return null;
        }
    }

    @Override
    public int getCount() {
        return 2;
    }
}

<code block>

package com.github.mobile.ui.search;

import static android.app.SearchManager.QUERY;
import android.app.Activity;
import android.os.Bundle;
import android.support.v4.content.Loader;
import android.text.TextUtils;
import android.view.View;
import android.widget.ListView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.mobile.R;
import com.github.mobile.ThrowableLoader;
import com.github.mobile.core.repo.RefreshRepositoryTask;
import com.github.mobile.ui.ItemListFragment;
import com.github.mobile.ui.repo.RepositoryViewActivity;
import com.google.inject.Inject;

import java.io.IOException;
import java.text.MessageFormat;
import java.util.Collections;
import java.util.List;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.RepositoryId;
import org.eclipse.egit.github.core.SearchRepository;
import org.eclipse.egit.github.core.service.RepositoryService;


public class SearchRepositoryListFragment extends
        ItemListFragment<SearchRepository> {

    @Inject
    private RepositoryService service;

    private String query;

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        setEmptyText(R.string.no_repositories);
    }

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);

        query = getStringExtra(QUERY);
    }

    @Override
    public void refresh() {
        query = getStringExtra(QUERY);

        super.refresh();
    }

    @Override
    public void onListItemClick(ListView l, View v, int position, long id) {
        final SearchRepository result = (SearchRepository) l
                .getItemAtPosition(position);
        new RefreshRepositoryTask(getActivity(), result) {

            @Override
            public void execute() {
                showIndeterminate(MessageFormat.format(
                        getString(R.string.opening_repository),
                        result.generateId()));

                super.execute();
            }

            @Override
            protected void onSuccess(Repository repository) throws Exception {
                super.onSuccess(repository);

                startActivity(RepositoryViewActivity.createIntent(repository));
            }
        }.execute();
    }


    private boolean openRepositoryMatch(final String query) {
        if (TextUtils.isEmpty(query))
            return false;

        RepositoryId repoId = RepositoryId.createFromId(query.trim());
        if (repoId == null)
            return false;

        Repository repo;
        try {
            repo = service.getRepository(repoId);
        } catch (IOException e) {
            return false;
        }

        startActivity(RepositoryViewActivity.createIntent(repo));
        final Activity activity = getActivity();
        if (activity != null)
            activity.finish();
        return true;
    }

    @Override
    public Loader<List<SearchRepository>> onCreateLoader(int id, Bundle args) {
        return new ThrowableLoader<List<SearchRepository>>(getActivity(), items) {

            @Override
            public List<SearchRepository> loadData() throws Exception {
                if (openRepositoryMatch(query))
                    return Collections.emptyList();
                else
                    return service.searchRepositories(query);
            }
        };
    }

    @Override
    protected int getErrorMessage(Exception exception) {
        return R.string.error_repos_load;
    }

    @Override
    protected SingleTypeAdapter<SearchRepository> createAdapter(
            List<SearchRepository> items) {
        return new SearchRepositoryListAdapter(getActivity()
                .getLayoutInflater(), items.toArray(new SearchRepository[items
                .size()]));
    }
}

<code block>

package com.github.mobile.ui.comment;

import android.content.Intent;
import android.os.Bundle;
import android.text.TextUtils;
import android.view.Menu;
import android.view.MenuItem;

import com.github.mobile.R;
import com.github.mobile.ui.TabPagerActivity;
import com.github.mobile.util.AvatarLoader;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Comment;

import static com.github.mobile.Intents.EXTRA_COMMENT;
import static com.github.mobile.util.TypefaceUtils.ICON_EDIT;
import static com.github.mobile.util.TypefaceUtils.ICON_WATCH;


public abstract class CreateCommentActivity extends
    TabPagerActivity<CommentPreviewPagerAdapter> {

    private MenuItem applyItem;


    @Inject
    protected AvatarLoader avatars;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        getSupportActionBar().setDisplayHomeAsUpEnabled(true);

        configureTabPager();
    }

    @Override
    public void onPageSelected(int position) {
        super.onPageSelected(position);
        adapter.setCurrentItem(position);
    }

    @Override
    public void invalidateOptionsMenu() {
        super.invalidateOptionsMenu();

        if (applyItem != null)
            applyItem.setEnabled(adapter != null
                && !TextUtils.isEmpty(adapter.getCommentText()));
    }

    @Override
    protected void setCurrentItem(int position) {
        super.setCurrentItem(position);

        adapter.setCurrentItem(position);
    }


    protected abstract void createComment(String comment);


    protected void finish(Comment comment) {
        Intent data = new Intent();
        data.putExtra(EXTRA_COMMENT, comment);
        setResult(RESULT_OK, data);
        finish();
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                finish();
                return true;
            case R.id.m_apply:
                createComment(adapter.getCommentText());
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    protected String getTitle(final int position) {
        switch (position) {
            case 0:
                return getString(R.string.write);
            case 1:
                return getString(R.string.preview);
            default:
                return super.getTitle(position);
        }
    }

    @Override
    protected String getIcon(final int position) {
        switch (position) {
            case 0:
                return ICON_EDIT;
            case 1:
                return ICON_WATCH;
            default:
                return super.getIcon(position);
        }
    }

    @Override
    protected CommentPreviewPagerAdapter createAdapter() {
        return new CommentPreviewPagerAdapter(this, null);
    }

    @Override
    public boolean onCreateOptionsMenu(Menu options) {
        getMenuInflater().inflate(R.menu.comment, options);
        applyItem = options.findItem(R.id.m_apply);
        return true;
    }
}

<code block>

package com.github.mobile.ui.comment;

import android.app.Activity;
import android.os.Bundle;
import android.text.Editable;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.widget.EditText;

import com.github.mobile.R;
import com.github.mobile.ui.DialogFragment;
import com.github.mobile.ui.TextWatcherAdapter;


public class RawCommentFragment extends DialogFragment {

    private EditText commentText;


    private String initComment;

    @Override
    public void onViewCreated(View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        commentText = finder.find(R.id.et_comment);
        commentText.addTextChangedListener(new TextWatcherAdapter() {

            @Override
            public void afterTextChanged(Editable s) {
                Activity activity = getActivity();
                if (activity != null)
                    activity.invalidateOptionsMenu();
            }
        });
        commentText.setOnTouchListener(new View.OnTouchListener() {

            @Override
            public boolean onTouch(View v, MotionEvent event) {
                commentText.requestFocusFromTouch();
                return false;
            }
        });

        setText(initComment);
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        return inflater.inflate(R.layout.comment_create, null);
    }


    public String getText() {
        return commentText.getText().toString();
    }


    public void setText(String comment) {
        if (commentText != null) {
            commentText.setText(comment);
            commentText.selectAll();
        } else {
            initComment = comment;
        }
    }
}

<code block>

package com.github.mobile.ui.comment;

import android.content.Context;
import android.support.v4.app.Fragment;
import android.support.v7.app.ActionBarActivity;

import com.github.mobile.R;
import com.github.mobile.ui.FragmentPagerAdapter;

import org.eclipse.egit.github.core.IRepositoryIdProvider;


public class CommentPreviewPagerAdapter extends FragmentPagerAdapter {

    private final IRepositoryIdProvider repo;

    private RawCommentFragment textFragment;

    private RenderedCommentFragment htmlFragment;


    private String initComment;

    private Context context;


    public CommentPreviewPagerAdapter(ActionBarActivity activity,
            IRepositoryIdProvider repo) {
        super(activity);
        this.context = activity.getApplicationContext();
        this.repo = repo;
    }

    @Override
    public Fragment getItem(final int position) {
        switch (position) {
        case 0:
            textFragment = new RawCommentFragment();
            textFragment.setText(initComment);
            return textFragment;
        case 1:
            htmlFragment = new RenderedCommentFragment();
            return htmlFragment;
        default:
            return null;
        }
    }

    @Override
    public int getCount() {
        return 2;
    }


    public String getCommentText() {
        return textFragment != null ? textFragment.getText() : null;
    }


    public void setCommentText(String comment) {
        if(textFragment != null)
            textFragment.setText(comment);
        initComment = comment;
    }


    public CommentPreviewPagerAdapter setCurrentItem(int position) {
        if (position == 1 && htmlFragment != null)
            htmlFragment.setText(getCommentText(), repo);
        return this;
    }

    @Override
    public CharSequence getPageTitle(int position) {
        switch (position) {
            case 0:
                return context.getResources().getString(R.string.write);
            case 1:
                return context.getResources().getString(R.string.preview);
            default:
                return "";
        }
    }
}

<code block>

package com.github.mobile.ui.comment;

import org.eclipse.egit.github.core.Comment;


public interface DeleteCommentListener {


    void onDeleteComment(Comment comment);
}
<code block>

package com.github.mobile.ui.comment;

import org.eclipse.egit.github.core.Comment;


public interface EditCommentListener {


    void onEditComment(Comment comment);
}
<code block>

package com.github.mobile.ui.comment;

import android.content.Context;
import android.support.v7.widget.PopupMenu;
import android.text.Html;
import android.text.method.LinkMovementMethod;
import android.view.LayoutInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.ImageView;

import com.github.kevinsawicki.wishlist.MultiTypeAdapter;
import com.github.mobile.R;
import com.github.mobile.util.AvatarLoader;
import com.github.mobile.util.HttpImageGetter;
import com.github.mobile.util.TimeUtils;
import com.github.mobile.util.TypefaceUtils;

import java.util.Collection;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.IssueEvent;


public class CommentListAdapter extends MultiTypeAdapter {

    private final AvatarLoader avatars;

    private final HttpImageGetter imageGetter;


    private final EditCommentListener editCommentListener;


    private final DeleteCommentListener deleteCommentListener;

    private final boolean isOwner;

    private final String userName;

    private Context context;

    private Issue issue;


    public CommentListAdapter(LayoutInflater inflater, Comment[] elements,
            AvatarLoader avatars, HttpImageGetter imageGetter, Issue issue) {
        this(inflater, elements, avatars, imageGetter, null, null, null, false, issue);
        this.context = inflater.getContext();
    }


    public CommentListAdapter(LayoutInflater inflater, AvatarLoader avatars,
            HttpImageGetter imageGetter, Issue issue) {
        this(inflater, null, avatars, imageGetter, issue);
        this.context = inflater.getContext();
    }


    public CommentListAdapter(LayoutInflater inflater, Comment[] elements,
            AvatarLoader avatars, HttpImageGetter imageGetter,
            EditCommentListener editCommentListener, DeleteCommentListener deleteCommentListener,
            String userName, boolean isOwner, Issue issue) {
        super(inflater);

        this.issue = issue;
        this.userName = userName;
        this.isOwner = isOwner;
        this.context = inflater.getContext();
        this.avatars = avatars;
        this.imageGetter = imageGetter;
        this.editCommentListener = editCommentListener;
        this.deleteCommentListener = deleteCommentListener;
        setItems(elements);
    }

    @Override
    protected void update(int position, Object obj, int type) {
        if(type == 0)
            updateComment((Comment) obj);
        else
            updateEvent((IssueEvent) obj);
    }

    protected void updateEvent(final IssueEvent event) {
        TypefaceUtils.setOcticons(textView(0));
        String message = String.format("<b>%s</b> %s", event.getActor().getLogin(), event.getEvent());
        avatars.bind(imageView(2), event.getActor());

        String eventString = event.getEvent();

        switch (eventString) {
        case "assigned":
        case "unassigned":
            setText(0, TypefaceUtils.ICON_PERSON);
            textView(0).setTextColor(
                    context.getResources().getColor(R.color.text_description));
            break;
        case "labeled":
        case "unlabeled":
            setText(0, TypefaceUtils.ICON_TAG);
            textView(0).setTextColor(
                    context.getResources().getColor(R.color.text_description));
            break;
        case "referenced":
            setText(0, TypefaceUtils.ICON_BOOKMARK);
            textView(0).setTextColor(
                    context.getResources().getColor(R.color.text_description));
            break;
        case "milestoned":
        case "demilestoned":
            setText(0, TypefaceUtils.ICON_MILESTONE);
            textView(0).setTextColor(
                    context.getResources().getColor(R.color.text_description));
            break;
        case "closed":
            setText(0, TypefaceUtils.ICON_ISSUE_CLOSE);
            textView(0).setTextColor(
                    context.getResources().getColor(R.color.issue_event_closed));
            break;
        case "reopened":
            setText(0, TypefaceUtils.ICON_ISSUE_REOPEN);
            textView(0).setTextColor(
                    context.getResources().getColor(R.color.issue_event_reopened));
            break;
        case "renamed":
            setText(0, TypefaceUtils.ICON_EDIT);
            textView(0).setTextColor(
                    context.getResources().getColor(R.color.text_description));
            break;
        case "merged":
            message += String.format(" commit <b>%s</b> into <tt>%s</tt> from <tt>%s</tt>", event.getCommitId().substring(0,6), issue.getPullRequest().getBase().getRef(),
                issue.getPullRequest().getHead().getRef());
            setText(0, TypefaceUtils.ICON_MERGE);
            textView(0).setTextColor(
                    context.getResources().getColor(R.color.issue_event_merged));
            break;
        case "locked":
            setText(0, TypefaceUtils.ICON_LOCK);
            textView(0).setTextColor(
                    context.getResources().getColor(R.color.issue_event_lock));
            break;
        case "unlocked":
            setText(0, TypefaceUtils.ICON_KEY);
            textView(0).setTextColor(
                    context.getResources().getColor(R.color.issue_event_lock));
            break;
        }

        message += " " + TimeUtils.getRelativeTime(event.getCreatedAt());
        setText(1, Html.fromHtml(message));
    }

    protected void updateComment(final Comment comment) {
        imageGetter.bind(textView(0), comment.getBodyHtml(), comment.getId());
        avatars.bind(imageView(3), comment.getUser());

        setText(1, comment.getUser().getLogin());
        setText(2, TimeUtils.getRelativeTime(comment.getUpdatedAt()));

        final boolean canEdit = (isOwner || comment.getUser().getLogin().equals(userName))
            && editCommentListener != null;

        final boolean canDelete = (isOwner || comment.getUser().getLogin().equals(userName))
            && deleteCommentListener != null;

        final ImageView ivMore = view(4);

        if(!canEdit && !canDelete)
            ivMore.setVisibility(View.INVISIBLE);
        else
            ivMore.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                showMorePopup(ivMore, comment, canEdit, canDelete);
            }
        });
    }

    private void showMorePopup(View v, final Comment comment, final boolean canEdit, final boolean canDelete ) {
        PopupMenu menu = new PopupMenu(context, v);
        menu.inflate(R.menu.comment_popup);

        menu.getMenu().findItem(R.id.m_edit).setEnabled(canEdit);
        menu.getMenu().findItem(R.id.m_delete).setEnabled(canDelete);

        menu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {
            @Override
            public boolean onMenuItemClick(MenuItem menuItem) {
                switch (menuItem.getItemId()) {
                    case R.id.m_edit:
                        if (editCommentListener != null) {
                            editCommentListener.onEditComment(comment);
                        }
                        break;
                    case R.id.m_delete:
                        if (deleteCommentListener != null) {
                            deleteCommentListener.onDeleteComment(comment);
                        }
                        break;
                }
                return false;
            }
        });

        menu.show();
    }

    public MultiTypeAdapter setItems(Collection<?> items) {
        if (items == null || items.isEmpty())
            return this;
        return setItems(items.toArray());
    }

    public MultiTypeAdapter setItems(final Object[] items) {
        if (items == null || items.length == 0)
            return this;

        this.clear();

        for (Object item : items) {
            if(item instanceof Comment)
                this.addItem(0, item);
            else
                this.addItem(1, item);
        }

        notifyDataSetChanged();
        return this;
    }

    public void setIssue(Issue issue) {
        this.issue = issue;
    }

    @Override
    protected View initialize(int type, View view) {
        view = super.initialize(type, view);

        textView(view, 0).setMovementMethod(LinkMovementMethod.getInstance());
        return view;
    }

    @Override
    public int getViewTypeCount() {
        return 2;
    }

    @Override
    protected int getChildLayoutId(int type) {
        if(type == 0)
            return R.layout.comment_item;
        else
            return R.layout.comment_event_item;
    }

    @Override
    protected int[] getChildViewIds(int type) {
        if(type == 0)
            return new int[] { R.id.tv_comment_body, R.id.tv_comment_author,
                    R.id.tv_comment_date, R.id.iv_avatar, R.id.iv_more };
        else
            return new int[]{R.id.tv_event_icon, R.id.tv_event, R.id.iv_avatar};
    }
}

<code block>

package com.github.mobile.ui.comment;

import android.os.Bundle;
import android.support.v4.app.LoaderManager.LoaderCallbacks;
import android.support.v4.content.Loader;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ProgressBar;
import android.widget.TextView;

import com.github.kevinsawicki.wishlist.Keyboard;
import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.mobile.R;
import com.github.mobile.ui.DialogFragment;
import com.github.mobile.ui.MarkdownLoader;
import com.github.mobile.util.HttpImageGetter;
import com.github.mobile.util.ToastUtils;
import com.google.inject.Inject;

import java.io.Serializable;

import org.eclipse.egit.github.core.IRepositoryIdProvider;


public class RenderedCommentFragment extends DialogFragment implements
        LoaderCallbacks<CharSequence> {

    private static final String ARG_TEXT = "text";

    private static final String ARG_REPO = "repo";

    private ProgressBar progress;

    private TextView bodyText;

    @Inject
    private HttpImageGetter imageGetter;

    @Override
    public void onViewCreated(View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        progress = finder.find(R.id.pb_loading);
        bodyText = finder.find(R.id.tv_comment_body);
    }


    public void setText(final String raw, final IRepositoryIdProvider repo) {
        Bundle args = new Bundle();
        args.putCharSequence(ARG_TEXT, raw);
        if (repo instanceof Serializable)
            args.putSerializable(ARG_REPO, (Serializable) repo);
        getLoaderManager().restartLoader(0, args, this);
        Keyboard.hideSoftInput(bodyText);
        showLoading(true);
    }

    private void showLoading(final boolean loading) {
        ViewUtils.setGone(progress, !loading);
        ViewUtils.setGone(bodyText, loading);
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        return inflater.inflate(R.layout.comment_preview, null);
    }

    @Override
    public Loader<CharSequence> onCreateLoader(int loader, Bundle args) {
        final CharSequence raw = args.getCharSequence(ARG_TEXT);
        final IRepositoryIdProvider repo = (IRepositoryIdProvider) args
                .getSerializable(ARG_REPO);
        return new MarkdownLoader(getActivity(), repo, raw.toString(),
                imageGetter, true);
    }

    @Override
    public void onLoadFinished(Loader<CharSequence> loader,
            CharSequence rendered) {
        if (rendered == null)
            ToastUtils.show(getActivity(), R.string.error_rendering_markdown);
        bodyText.setText(rendered);
        showLoading(false);
    }

    @Override
    public void onLoaderReset(Loader<CharSequence> loader) {
    }
}

<code block>

package com.github.mobile.ui.commit;

import static com.github.mobile.Intents.EXTRA_BASE;
import static com.github.mobile.Intents.EXTRA_PATH;
import static com.github.mobile.Intents.EXTRA_POSITION;
import static com.github.mobile.Intents.EXTRA_REPOSITORY;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.ActionBar;
import android.text.TextUtils;

import com.github.mobile.Intents.Builder;
import com.github.mobile.R;
import com.github.mobile.core.commit.CommitUtils;
import com.github.mobile.ui.comment.CommentPreviewPagerAdapter;

import org.eclipse.egit.github.core.CommitComment;
import org.eclipse.egit.github.core.Repository;


public class CreateCommentActivity extends
        com.github.mobile.ui.comment.CreateCommentActivity {


    public static Intent createIntent(Repository repository, String commit) {
        return createIntent(repository, commit, null, -1);
    }


    public static Intent createIntent(Repository repository, String commit,
            String path, int position) {
        Builder builder = new Builder("commit.comment.create.VIEW");
        builder.repo(repository);
        builder.add(EXTRA_BASE, commit);
        if (isLineComment(path, position))
            builder.add(EXTRA_PATH, path).add(EXTRA_POSITION, position);
        return builder.toIntent();
    }

    private static boolean isLineComment(final String path, final int position) {
        return !TextUtils.isEmpty(path) && position > -1;
    }

    private Repository repository;

    private String commit;

    private int position;

    private String path;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        repository = getSerializableExtra(EXTRA_REPOSITORY);
        commit = getStringExtra(EXTRA_BASE);
        position = getIntExtra(EXTRA_POSITION);
        path = getStringExtra(EXTRA_PATH);

        super.onCreate(savedInstanceState);

        ActionBar actionBar = getSupportActionBar();
        actionBar.setTitle(getString(R.string.commit_prefix)
                + CommitUtils.abbreviate(commit));
        actionBar.setSubtitle(repository.generateId());
        avatars.bind(actionBar, repository.getOwner());
    }

    @Override
    protected void createComment(String comment) {
        CommitComment commitComment = new CommitComment();
        commitComment.setBody(comment);
        if (isLineComment(path, position))
            commitComment.setPath(path).setPosition(position);
        new CreateCommentTask(this, repository, commit, commitComment) {

            @Override
            protected void onSuccess(CommitComment comment) throws Exception {
                super.onSuccess(comment);

                finish(comment);
            }

        }.start();
    }

    @Override
    protected CommentPreviewPagerAdapter createAdapter() {
        return new CommentPreviewPagerAdapter(this, repository);
    }
}

<code block>

package com.github.mobile.ui.commit;

import static android.app.Activity.RESULT_OK;
import static android.content.DialogInterface.BUTTON_NEGATIVE;
import static android.graphics.Paint.UNDERLINE_TEXT_FLAG;
import static com.github.mobile.Intents.EXTRA_BASE;
import static com.github.mobile.Intents.EXTRA_COMMENT;
import static com.github.mobile.Intents.EXTRA_REPOSITORY;
import static com.github.mobile.RequestCodes.COMMENT_CREATE;
import android.accounts.Account;
import android.annotation.SuppressLint;
import android.app.AlertDialog;
import android.content.ClipData;
import android.content.ClipboardManager;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.os.Build;
import android.os.Bundle;
import android.text.TextUtils;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ImageView;
import android.widget.ListView;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.Toast;

import com.github.kevinsawicki.wishlist.ViewFinder;
import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.mobile.R;
import com.github.mobile.core.commit.CommitStore;
import com.github.mobile.core.commit.CommitUtils;
import com.github.mobile.core.commit.FullCommit;
import com.github.mobile.core.commit.FullCommitFile;
import com.github.mobile.core.commit.RefreshCommitTask;
import com.github.mobile.ui.DialogFragment;
import com.github.mobile.ui.HeaderFooterListAdapter;
import com.github.mobile.ui.LightAlertDialog;
import com.github.mobile.ui.StyledText;
import com.github.mobile.util.AvatarLoader;
import com.github.mobile.util.HttpImageGetter;
import com.github.mobile.util.ShareUtils;
import com.github.mobile.util.ToastUtils;
import com.google.inject.Inject;

import java.util.Collections;
import java.util.Date;
import java.util.List;

import org.eclipse.egit.github.core.Commit;
import org.eclipse.egit.github.core.CommitComment;
import org.eclipse.egit.github.core.CommitFile;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.RepositoryCommit;


public class CommitDiffListFragment extends DialogFragment implements
        OnItemClickListener {

    private DiffStyler diffStyler;

    private ListView list;

    private ProgressBar progress;

    private Repository repository;

    private String base;

    private RepositoryCommit commit;

    private List<CommitComment> comments;

    private List<FullCommitFile> files;

    @Inject
    private AvatarLoader avatars;

    @Inject
    private CommitStore store;

    private View loadingView;

    private View commitHeader;

    private TextView commitMessage;

    private View authorArea;

    private ImageView authorAvatar;

    private TextView authorName;

    private TextView authorDate;

    private View committerArea;

    private ImageView committerAvatar;

    private TextView committerName;

    private TextView committerDate;

    private HeaderFooterListAdapter<CommitFileListAdapter> adapter;

    @Inject
    private HttpImageGetter commentImageGetter;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        Bundle args = getArguments();
        base = args.getString(EXTRA_BASE);
        repository = (Repository) args.getSerializable(EXTRA_REPOSITORY);
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        commit = store.getCommit(repository, base);

        ((TextView) loadingView.findViewById(R.id.tv_loading))
                .setText(R.string.loading_files_and_comments);

        if (files == null
                || (commit != null && commit.getCommit().getCommentCount() > 0 && comments == null))
            adapter.addFooter(loadingView);

        if (commit != null && comments != null && files != null)
            updateList(commit, comments, files);
        else {
            if (commit != null)
                updateHeader(commit);
            refreshCommit();
        }
    }

    private void addComment(final CommitComment comment) {
        if (comments != null && files != null) {
            comments.add(comment);
            Commit rawCommit = commit.getCommit();
            if (rawCommit != null)
                rawCommit.setCommentCount(rawCommit.getCommentCount() + 1);
            commentImageGetter.encode(comment, comment.getBodyHtml());
            updateItems(comments, files);
        } else
            refreshCommit();
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (RESULT_OK == resultCode && COMMENT_CREATE == requestCode
                && data != null) {
            CommitComment comment = (CommitComment) data
                    .getSerializableExtra(EXTRA_COMMENT);
            addComment(comment);
            return;
        }

        super.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    public void onCreateOptionsMenu(final Menu optionsMenu,
            final MenuInflater inflater) {
        inflater.inflate(R.menu.commit_view, optionsMenu);
    }

    @Override
    public boolean onOptionsItemSelected(final MenuItem item) {
        if (!isUsable())
            return false;

        switch (item.getItemId()) {
        case R.id.m_refresh:
            refreshCommit();
            return true;
        case R.id.m_copy_hash:
            copyHashToClipboard();
            return true;
        case R.id.m_comment:
            startActivityForResult(
                    CreateCommentActivity.createIntent(repository, base),
                    COMMENT_CREATE);
            return true;
        case R.id.m_share:
            shareCommit();
            return true;
        default:
            return super.onOptionsItemSelected(item);
        }
    }

    @SuppressLint("NewApi")
    private void copyHashToClipboard() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
            ClipboardManager manager = (ClipboardManager) getActivity().getSystemService(Context.CLIPBOARD_SERVICE);
            ClipData clip = ClipData.newPlainText("hash", commit.getSha());
            manager.setPrimaryClip(clip);
        } else {
            android.text.ClipboardManager manager = (android.text.ClipboardManager) getActivity().getSystemService
                    (Context.CLIPBOARD_SERVICE);
            manager.setText(commit.getSha());
        }
        Toast.makeText(getActivity(), R.string.toast_msg_copied, Toast.LENGTH_SHORT).show();
    }

    private void shareCommit() {
        String id = repository.generateId();
        startActivity(ShareUtils.create(
                "Commit " + CommitUtils.abbreviate(base) + " on " + id,
                "https://github.com/" + id + "/commit/" + base));
    }

    private void refreshCommit() {
        new RefreshCommitTask(getActivity(), repository, base,
                commentImageGetter) {

            @Override
            protected FullCommit run(Account account) throws Exception {
                FullCommit full = super.run(account);

                List<CommitFile> files = full.getCommit().getFiles();
                diffStyler.setFiles(files);
                if (files != null)
                    Collections.sort(files, new CommitFileComparator());
                return full;
            }

            @Override
            protected void onSuccess(FullCommit commit) throws Exception {
                super.onSuccess(commit);
                updateList(commit.getCommit(), commit, commit.getFiles());
            }

            @Override
            protected void onException(Exception e) throws RuntimeException {
                super.onException(e);
                ToastUtils.show(getActivity(), e, R.string.error_commit_load);
                ViewUtils.setGone(progress, true);
            }

        }.execute();
    }

    private boolean isDifferentCommitter(final String author,
            final String committer) {
        return committer != null && !committer.equals(author);
    }

    private void addCommitDetails(RepositoryCommit commit) {
        adapter.addHeader(commitHeader);

        commitMessage.setText(commit.getCommit().getMessage());

        String commitAuthor = CommitUtils.getAuthor(commit);
        String commitCommitter = CommitUtils.getCommitter(commit);

        if (commitAuthor != null) {
            CommitUtils.bindAuthor(commit, avatars, authorAvatar);
            authorName.setText(commitAuthor);
            StyledText styledAuthor = new StyledText();
            styledAuthor.append(getString(R.string.authored));

            Date commitAuthorDate = CommitUtils.getAuthorDate(commit);
            if (commitAuthorDate != null)
                styledAuthor.append(' ').append(commitAuthorDate);

            authorDate.setText(styledAuthor);
            ViewUtils.setGone(authorArea, false);
        } else
            ViewUtils.setGone(authorArea, true);

        if (isDifferentCommitter(commitAuthor, commitCommitter)) {
            CommitUtils.bindCommitter(commit, avatars, committerAvatar);
            committerName.setText(commitCommitter);
            StyledText styledCommitter = new StyledText();
            styledCommitter.append(getString(R.string.committed));

            Date commitCommitterDate = CommitUtils.getCommitterDate(commit);
            if (commitCommitterDate != null)
                styledCommitter.append(' ').append(commitCommitterDate);

            committerDate.setText(styledCommitter);
            ViewUtils.setGone(committerArea, false);
        } else
            ViewUtils.setGone(committerArea, true);
    }

    private void addDiffStats(RepositoryCommit commit, LayoutInflater inflater) {
        View fileHeader = inflater.inflate(R.layout.commit_file_details_header,
                null);
        ((TextView) fileHeader.findViewById(R.id.tv_commit_file_summary))
                .setText(CommitUtils.formatStats(commit.getFiles()));
        adapter.addHeader(fileHeader);
    }

    private void addCommitParents(RepositoryCommit commit,
            LayoutInflater inflater) {
        List<Commit> parents = commit.getParents();
        if (parents == null || parents.isEmpty())
            return;

        for (Commit parent : parents) {
            View parentView = inflater.inflate(R.layout.commit_parent_item, null);
            TextView parentIdText = (TextView) parentView
                    .findViewById(R.id.tv_commit_id);
            parentIdText.setPaintFlags(parentIdText.getPaintFlags()
                    | UNDERLINE_TEXT_FLAG);
            StyledText parentText = new StyledText();
            parentText.append(getString(R.string.parent_prefix));
            parentText.monospace(CommitUtils.abbreviate(parent));
            parentIdText.setText(parentText);
            adapter.addHeader(parentView, parent, true);
        }
    }

    private void updateHeader(RepositoryCommit commit) {
        ViewUtils.setGone(progress, true);
        ViewUtils.setGone(list, false);

        addCommitDetails(commit);
        addCommitParents(commit, getActivity().getLayoutInflater());
    }

    private void updateList(RepositoryCommit commit,
            List<CommitComment> comments, List<FullCommitFile> files) {
        if (!isUsable())
            return;

        this.commit = commit;
        this.comments = comments;
        this.files = files;

        adapter.clearHeaders();
        adapter.clearFooters();
        updateHeader(commit);
        addDiffStats(commit, getActivity().getLayoutInflater());
        updateItems(comments, files);
    }

    private void updateItems(List<CommitComment> comments,
            List<FullCommitFile> files) {
        CommitFileListAdapter rootAdapter = adapter.getWrappedAdapter();
        rootAdapter.clear();
        for (FullCommitFile file : files)
            rootAdapter.addItem(file);
        for (CommitComment comment : comments)
            rootAdapter.addComment(comment);
    }

    @Override
    public void onViewCreated(View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        list = finder.find(android.R.id.list);
        progress = finder.find(R.id.pb_loading);

        diffStyler = new DiffStyler(getResources());

        list.setOnItemClickListener(this);

        LayoutInflater inflater = getActivity().getLayoutInflater();

        adapter = new HeaderFooterListAdapter<>(list,
                new CommitFileListAdapter(inflater, diffStyler, avatars,
                        commentImageGetter));
        adapter.addFooter(inflater.inflate(R.layout.footer_separator, null));
        list.setAdapter(adapter);

        commitHeader = inflater.inflate(R.layout.commit_header, null);
        commitMessage = (TextView) commitHeader
                .findViewById(R.id.tv_commit_message);

        authorArea = commitHeader.findViewById(R.id.ll_author);
        authorAvatar = (ImageView) commitHeader.findViewById(R.id.iv_author);
        authorName = (TextView) commitHeader.findViewById(R.id.tv_author);
        authorDate = (TextView) commitHeader.findViewById(R.id.tv_author_date);

        committerArea = commitHeader.findViewById(R.id.ll_committer);
        committerAvatar = (ImageView) commitHeader
                .findViewById(R.id.iv_committer);
        committerName = (TextView) commitHeader.findViewById(R.id.tv_committer);
        committerDate = (TextView) commitHeader.findViewById(R.id.tv_commit_date);

        loadingView = inflater.inflate(R.layout.loading_item, null);
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        return inflater.inflate(R.layout.commit_diff_list, null);
    }

    private void showFileOptions(CharSequence line, final int position,
            final CommitFile file) {
        final AlertDialog dialog = LightAlertDialog.create(getActivity());
        dialog.setTitle(CommitUtils.getName(file));
        dialog.setCanceledOnTouchOutside(true);

        View view = getActivity().getLayoutInflater().inflate(
                R.layout.diff_line_dialog, null);
        ViewFinder finder = new ViewFinder(view);

        TextView diff = finder.textView(R.id.tv_diff);
        diff.setText(line);
        diffStyler.updateColors(line, diff);

        finder.setText(R.id.tv_commit, getString(R.string.commit_prefix)
                + CommitUtils.abbreviate(commit));

        finder.find(R.id.ll_view_area).setOnClickListener(new OnClickListener() {

            public void onClick(View v) {
                dialog.dismiss();

                openFile(file);
            }
        });

        finder.find(R.id.ll_comment_area).setOnClickListener(
                new OnClickListener() {

                    public void onClick(View v) {
                        dialog.dismiss();

                        startActivityForResult(CreateCommentActivity
                                        .createIntent(repository, commit.getSha(),
                                                file.getFilename(), position),
                                COMMENT_CREATE);
                    }
                });

        dialog.setView(view);
        dialog.setButton(BUTTON_NEGATIVE, getString(R.string.cancel),
                new DialogInterface.OnClickListener() {

                    public void onClick(DialogInterface dialog, int which) {
                        dialog.dismiss();
                    }
                });
        dialog.show();
    }

    private void openFile(CommitFile file) {
        if (!TextUtils.isEmpty(file.getFilename())
                && !TextUtils.isEmpty(file.getSha()))
            startActivity(CommitFileViewActivity.createIntent(repository, base,
                    file));
    }


    private void selectPreviousFile(int position, Object item,
            AdapterView<?> parent) {
        CharSequence line;
        if (item instanceof CharSequence)
            line = (CharSequence) item;
        else
            line = null;

        int linePosition = 0;
        while (--position >= 0) {
            item = parent.getItemAtPosition(position);

            if (item instanceof CommitFile) {
                if (line != null)
                    showFileOptions(line, linePosition, (CommitFile) item);
                break;
            } else if (item instanceof CharSequence)
                if (line != null)
                    linePosition++;
                else
                    line = (CharSequence) item;
        }
    }

    @Override
    public void onItemClick(AdapterView<?> parent, View view, int position,
            long id) {
        Object item = parent.getItemAtPosition(position);
        if (item instanceof Commit)
            startActivity(CommitViewActivity.createIntent(repository,
                    ((Commit) item).getSha()));
        else if (item instanceof CommitFile)
            openFile((CommitFile) item);
        else if (item instanceof CharSequence)
            selectPreviousFile(position, item, parent);
        else if (item instanceof CommitComment)
            if (!TextUtils.isEmpty(((CommitComment) item).getPath()))
                selectPreviousFile(position, item, parent);
    }
}

<code block>

package com.github.mobile.ui.commit;

import static com.github.mobile.Intents.EXTRA_BASE;
import static com.github.mobile.Intents.EXTRA_REPOSITORY;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v7.app.ActionBarActivity;

import com.github.mobile.ui.FragmentStatePagerAdapter;

import org.eclipse.egit.github.core.Repository;


public class CommitPagerAdapter extends FragmentStatePagerAdapter {

    private final Repository repository;

    private final CharSequence[] ids;


    public CommitPagerAdapter(ActionBarActivity activity,
            Repository repository, CharSequence[] ids) {
        super(activity);

        this.repository = repository;
        this.ids = ids;
    }

    @Override
    public Fragment getItem(final int position) {
        Bundle arguments = new Bundle();
        arguments.putString(EXTRA_BASE, ids[position].toString());
        arguments.putSerializable(EXTRA_REPOSITORY, repository);
        CommitDiffListFragment fragment = new CommitDiffListFragment();
        fragment.setArguments(arguments);
        return fragment;
    }

    @Override
    public int getCount() {
        return ids.length;
    }
}

<code block>

package com.github.mobile.ui.commit;

import static com.github.kevinsawicki.wishlist.ViewUpdater.FORMAT_INT;
import android.content.res.Resources;
import android.text.TextUtils;
import android.view.LayoutInflater;

import com.github.kevinsawicki.wishlist.MultiTypeAdapter;
import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.mobile.R;
import com.github.mobile.core.commit.FullCommitFile;
import com.github.mobile.ui.StyledText;
import com.github.mobile.util.AvatarLoader;
import com.github.mobile.util.HttpImageGetter;
import com.github.mobile.util.TimeUtils;

import java.util.List;

import org.eclipse.egit.github.core.CommitComment;
import org.eclipse.egit.github.core.CommitFile;


public class CommitFileListAdapter extends MultiTypeAdapter {

    private static final int TYPE_FILE_HEADER = 0;

    private static final int TYPE_FILE_LINE = 1;

    private static final int TYPE_LINE_COMMENT = 2;

    private static final int TYPE_COMMENT = 3;

    private final DiffStyler diffStyler;

    private final HttpImageGetter imageGetter;

    private final AvatarLoader avatars;

    private final int addTextColor;

    private final int removeTextColor;


    public CommitFileListAdapter(final LayoutInflater inflater,
            final DiffStyler diffStyler, final AvatarLoader avatars,
            final HttpImageGetter imageGetter) {
        super(inflater);

        this.diffStyler = diffStyler;
        this.avatars = avatars;
        this.imageGetter = imageGetter;

        Resources resources = inflater.getContext().getResources();
        addTextColor = resources.getColor(R.color.diff_add_text);
        removeTextColor = resources.getColor(R.color.diff_remove_text);
    }

    @Override
    public int getViewTypeCount() {
        return 4;
    }

    @Override
    public long getItemId(int position) {
        switch (getItemViewType(position)) {
        case TYPE_FILE_HEADER:
            String sha = ((CommitFile) getItem(position)).getSha();
            if (!TextUtils.isEmpty(sha))
                return sha.hashCode();
            else
                return super.getItemId(position);
        case TYPE_COMMENT:
        case TYPE_LINE_COMMENT:
            return ((CommitComment) getItem(position)).getId();
        default:
            return super.getItemId(position);
        }

    }


    public void addItem(final FullCommitFile file) {
        addItem(TYPE_FILE_HEADER, file.getFile());
        List<CharSequence> lines = diffStyler.get(file.getFile().getFilename());
        int number = 0;
        for (CharSequence line : lines) {
            addItem(TYPE_FILE_LINE, line);
            for (CommitComment comment : file.get(number))
                addItem(TYPE_LINE_COMMENT, comment);
            number++;
        }
    }


    public void addItem(final CommitFile file) {
        addItem(TYPE_FILE_HEADER, file);
        addItems(TYPE_FILE_LINE, diffStyler.get(file.getFilename()));
    }


    public void addComment(final CommitComment comment) {
        addItem(TYPE_COMMENT, comment);
    }

    @Override
    protected int getChildLayoutId(final int type) {
        switch (type) {
        case TYPE_FILE_HEADER:
            return R.layout.commit_diff_file_header;
        case TYPE_FILE_LINE:
            return R.layout.commit_diff_line;
        case TYPE_LINE_COMMENT:
            return R.layout.diff_comment_item;
        case TYPE_COMMENT:
            return R.layout.commit_comment_item;
        default:
            return -1;
        }
    }

    @Override
    protected int[] getChildViewIds(final int type) {
        switch (type) {
        case TYPE_FILE_HEADER:
            return new int[] { R.id.tv_name, R.id.tv_folder, R.id.tv_stats };
        case TYPE_FILE_LINE:
            return new int[] { R.id.tv_diff };
        case TYPE_LINE_COMMENT:
        case TYPE_COMMENT:
            return new int[] { R.id.tv_comment_body, R.id.iv_avatar,
                    R.id.tv_comment_author, R.id.tv_comment_date };
        default:
            return null;
        }
    }

    @Override
    protected void update(final int position, final Object item, final int type) {
        switch (type) {
        case TYPE_FILE_HEADER:
            CommitFile file = (CommitFile) item;
            String path = file.getFilename();
            int lastSlash = path.lastIndexOf('/');
            if (lastSlash != -1) {
                setText(0, path.substring(lastSlash + 1));
                ViewUtils.setGone(setText(1, path.substring(0, lastSlash + 1)),
                        false);
            } else {
                setText(0, path);
                setGone(1, true);
            }

            StyledText stats = new StyledText();
            stats.foreground('+', addTextColor);
            stats.foreground(FORMAT_INT.format(file.getAdditions()),
                    addTextColor);
            stats.append(' ').append(' ').append(' ');
            stats.foreground('-', removeTextColor);
            stats.foreground(FORMAT_INT.format(file.getDeletions()),
                    removeTextColor);
            setText(2, stats);
            return;
        case TYPE_FILE_LINE:
            CharSequence text = (CharSequence) item;
            diffStyler.updateColors((CharSequence) item, setText(0, text));
            return;
        case TYPE_LINE_COMMENT:
        case TYPE_COMMENT:
            CommitComment comment = (CommitComment) item;
            avatars.bind(imageView(1), comment.getUser());
            setText(2, comment.getUser().getLogin());
            setText(3, TimeUtils.getRelativeTime(comment.getUpdatedAt()));
            imageGetter.bind(textView(0), comment.getBodyHtml(),
                    comment.getId());
        }
    }
}

<code block>

package com.github.mobile.ui.commit;

import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
import static android.content.Intent.FLAG_ACTIVITY_SINGLE_TOP;
import static com.github.mobile.Intents.EXTRA_BASES;
import static com.github.mobile.Intents.EXTRA_POSITION;
import static com.github.mobile.Intents.EXTRA_REPOSITORY;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.ActionBar;
import android.view.MenuItem;

import com.github.mobile.Intents.Builder;
import com.github.mobile.R;
import com.github.mobile.core.commit.CommitUtils;
import com.github.mobile.ui.FragmentProvider;
import com.github.mobile.ui.PagerActivity;
import com.github.mobile.ui.ViewPager;
import com.github.mobile.ui.repo.RepositoryViewActivity;
import com.github.mobile.util.AvatarLoader;
import com.google.inject.Inject;

import java.util.Collection;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.RepositoryCommit;


public class CommitViewActivity extends PagerActivity {


    public static Intent createIntent(final Repository repository,
        final String id) {
        return createIntent(repository, 0, id);
    }


    public static Intent createIntent(final Repository repository,
        final int position, final Collection<RepositoryCommit> commits) {
        String[] ids = new String[commits.size()];
        int index = 0;
        for (RepositoryCommit commit : commits)
            ids[index++] = commit.getSha();
        return createIntent(repository, position, ids);
    }


    public static Intent createIntent(final Repository repository,
        final int position, final String... ids) {
        Builder builder = new Builder("commits.VIEW");
        builder.add(EXTRA_POSITION, position);
        builder.add(EXTRA_BASES, ids);
        builder.repo(repository);
        return builder.toIntent();
    }

    private ViewPager pager;

    private Repository repository;

    private CharSequence[] ids;

    private int initialPosition;

    @Inject
    private AvatarLoader avatars;

    private CommitPagerAdapter adapter;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.pager);

        setSupportActionBar((android.support.v7.widget.Toolbar) findViewById(R.id.toolbar));

        pager = finder.find(R.id.vp_pages);

        repository = getSerializableExtra(EXTRA_REPOSITORY);
        ids = getCharSequenceArrayExtra(EXTRA_BASES);
        initialPosition = getIntExtra(EXTRA_POSITION);

        adapter = new CommitPagerAdapter(this, repository, ids);
        pager.setAdapter(adapter);
        pager.setOnPageChangeListener(this);
        pager.scheduleSetItem(initialPosition, this);
        onPageSelected(initialPosition);

        ActionBar actionBar = getSupportActionBar();
        actionBar.setDisplayHomeAsUpEnabled(true);
        actionBar.setSubtitle(repository.generateId());
        avatars.bind(actionBar, repository.getOwner());
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                Intent intent = RepositoryViewActivity.createIntent(repository);
                intent.addFlags(FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_SINGLE_TOP);
                startActivity(intent);
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    public void onPageSelected(int position) {
        super.onPageSelected(position);

        final String id = CommitUtils.abbreviate(ids[position].toString());
        getSupportActionBar().setTitle(getString(R.string.commit_prefix) + id);
    }

    @Override
    protected FragmentProvider getProvider() {
        return adapter;
    }
}

<code block>

package com.github.mobile.ui.commit;

import android.text.TextUtils;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.TextView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.mobile.R;
import com.github.mobile.core.commit.CommitUtils;
import com.github.mobile.ui.StyledText;
import com.github.mobile.util.AvatarLoader;
import com.github.mobile.util.TypefaceUtils;

import java.util.Collection;

import org.eclipse.egit.github.core.RepositoryCommit;


public class CommitListAdapter extends SingleTypeAdapter<RepositoryCommit> {

    private final AvatarLoader avatars;


    public CommitListAdapter(int viewId, LayoutInflater inflater,
            Collection<RepositoryCommit> elements, AvatarLoader avatars) {
        super(inflater, viewId);

        this.avatars = avatars;
        setItems(elements);
    }

    @Override
    public long getItemId(int position) {
        String sha = getItem(position).getSha();
        if (!TextUtils.isEmpty(sha))
            return sha.hashCode();
        else
            return super.getItemId(position);
    }

    @Override
    protected int[] getChildViewIds() {
        return new int[] { R.id.tv_commit_id, R.id.tv_commit_author, R.id.iv_avatar,
                R.id.tv_commit_message, R.id.tv_commit_comments };
    }

    @Override
    protected View initialize(View view) {
        view = super.initialize(view);

        TypefaceUtils.setOcticons((TextView) view
                .findViewById(R.id.tv_comment_icon));
        return view;
    }

    @Override
    protected void update(int position, RepositoryCommit item) {
        setText(0, CommitUtils.abbreviate(item.getSha()));

        StyledText authorText = new StyledText();
        authorText.bold(CommitUtils.getAuthor(item));
        authorText.append(' ');
        authorText.append(CommitUtils.getAuthorDate(item));
        setText(1, authorText);

        CommitUtils.bindAuthor(item, avatars, imageView(2));
        setText(3, item.getCommit().getMessage());
        setText(4, CommitUtils.getCommentCount(item));
    }
}

<code block>

package com.github.mobile.ui.commit;

import static com.github.mobile.Intents.EXTRA_BASE;
import static com.github.mobile.Intents.EXTRA_HEAD;
import static com.github.mobile.Intents.EXTRA_PATH;
import static com.github.mobile.Intents.EXTRA_REPOSITORY;
import static com.github.mobile.util.PreferenceUtils.RENDER_MARKDOWN;
import static com.github.mobile.util.PreferenceUtils.WRAP;
import android.content.Intent;
import android.os.Bundle;
import android.support.v4.app.LoaderManager.LoaderCallbacks;
import android.support.v4.content.Loader;
import android.support.v7.app.ActionBar;
import android.text.TextUtils;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;
import android.webkit.WebView;
import android.widget.ProgressBar;

import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.mobile.Intents.Builder;
import com.github.mobile.R;
import com.github.mobile.core.code.RefreshBlobTask;
import com.github.mobile.core.commit.CommitUtils;
import com.github.mobile.ui.BaseActivity;
import com.github.mobile.ui.MarkdownLoader;
import com.github.mobile.util.AvatarLoader;
import com.github.mobile.util.HttpImageGetter;
import com.github.mobile.util.MarkdownUtils;
import com.github.mobile.util.PreferenceUtils;
import com.github.mobile.util.ShareUtils;
import com.github.mobile.util.SourceEditor;
import com.github.mobile.util.ToastUtils;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Blob;
import org.eclipse.egit.github.core.CommitFile;
import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.util.EncodingUtils;


public class CommitFileViewActivity extends BaseActivity implements
    LoaderCallbacks<CharSequence> {

    private static final String TAG = "CommitFileViewActivity";

    private static final String ARG_TEXT = "text";

    private static final String ARG_REPO = "repo";


    public static Intent createIntent(Repository repository, String commit,
        CommitFile file) {
        Builder builder = new Builder("commit.file.VIEW");
        builder.repo(repository);
        builder.add(EXTRA_HEAD, commit);
        builder.add(EXTRA_PATH, file.getFilename());
        builder.add(EXTRA_BASE, file.getSha());
        return builder.toIntent();
    }

    private Repository repo;

    private String commit;

    private String sha;

    private String path;

    private String file;

    private boolean isMarkdownFile;

    private String renderedMarkdown;

    private Blob blob;

    private ProgressBar loadingBar;

    private WebView codeView;

    private SourceEditor editor;

    private MenuItem markdownItem;

    @Inject
    private AvatarLoader avatars;

    @Inject
    private HttpImageGetter imageGetter;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.commit_file_view);

        setSupportActionBar((android.support.v7.widget.Toolbar) findViewById(R.id.toolbar));

        repo = getSerializableExtra(EXTRA_REPOSITORY);
        commit = getStringExtra(EXTRA_HEAD);
        sha = getStringExtra(EXTRA_BASE);
        path = getStringExtra(EXTRA_PATH);

        loadingBar = finder.find(R.id.pb_loading);
        codeView = finder.find(R.id.wv_code);

        file = CommitUtils.getName(path);
        isMarkdownFile = MarkdownUtils.isMarkdown(file);

        editor = new SourceEditor(codeView);
        editor.setWrap(PreferenceUtils.getCodePreferences(this).getBoolean(
            WRAP, false));

        ActionBar actionBar = getSupportActionBar();
        int lastSlash = path.lastIndexOf('/');
        if (lastSlash != -1)
            actionBar.setTitle(path.substring(lastSlash + 1));
        else
            actionBar.setTitle(path);
        actionBar.setSubtitle(getString(R.string.commit_prefix)
            + CommitUtils.abbreviate(commit));
        avatars.bind(actionBar, repo.getOwner());

        loadContent();
    }

    @Override
    public boolean onCreateOptionsMenu(final Menu optionsMenu) {
        getMenuInflater().inflate(R.menu.file_view, optionsMenu);

        MenuItem wrapItem = optionsMenu.findItem(R.id.m_wrap);
        if (PreferenceUtils.getCodePreferences(this).getBoolean(WRAP, false))
            wrapItem.setTitle(R.string.disable_wrapping);
        else
            wrapItem.setTitle(R.string.enable_wrapping);

        markdownItem = optionsMenu.findItem(R.id.m_render_markdown);
        if (isMarkdownFile) {
            markdownItem.setEnabled(blob != null);
            markdownItem.setVisible(true);
            if (PreferenceUtils.getCodePreferences(this).getBoolean(
                RENDER_MARKDOWN, true))
                markdownItem.setTitle(R.string.show_raw_markdown);
            else
                markdownItem.setTitle(R.string.render_markdown);
        }

        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.m_wrap:
                if (editor.getWrap())
                    item.setTitle(R.string.enable_wrapping);
                else
                    item.setTitle(R.string.disable_wrapping);
                editor.toggleWrap();
                PreferenceUtils.save(PreferenceUtils.getCodePreferences(this)
                    .edit().putBoolean(WRAP, editor.getWrap()));
                return true;

            case R.id.m_share:
                shareFile();
                return true;

            case R.id.m_render_markdown:
                if (editor.isMarkdown()) {
                    item.setTitle(R.string.render_markdown);
                    editor.toggleMarkdown();
                    editor.setSource(file, blob);
                } else {
                    item.setTitle(R.string.show_raw_markdown);
                    editor.toggleMarkdown();
                    if (renderedMarkdown != null)
                        editor.setSource(file, renderedMarkdown, false);
                    else
                        loadMarkdown();
                }
                PreferenceUtils.save(PreferenceUtils.getCodePreferences(this)
                    .edit().putBoolean(RENDER_MARKDOWN, editor.isMarkdown()));
                return true;

            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    public Loader<CharSequence> onCreateLoader(int loader, Bundle args) {
        final String raw = args.getString(ARG_TEXT);
        final IRepositoryIdProvider repo = (IRepositoryIdProvider) args
            .getSerializable(ARG_REPO);
        return new MarkdownLoader(this, repo, raw, imageGetter, false);
    }

    @Override
    public void onLoadFinished(Loader<CharSequence> loader,
        CharSequence rendered) {
        if (rendered == null)
            ToastUtils.show(this, R.string.error_rendering_markdown);

        ViewUtils.setGone(loadingBar, true);
        ViewUtils.setGone(codeView, false);

        if (!TextUtils.isEmpty(rendered)) {
            renderedMarkdown = rendered.toString();
            if (markdownItem != null)
                markdownItem.setEnabled(true);
            editor.setMarkdown(true).setSource(file, renderedMarkdown, false);
        }
    }

    @Override
    public void onLoaderReset(Loader<CharSequence> loader) {
    }

    private void shareFile() {
        String id = repo.generateId();
        startActivity(ShareUtils.create(
            path + " at " + CommitUtils.abbreviate(commit) + " on " + id,
            "https://github.com/" + id + "/blob/" + commit + '/' + path));
    }

    private void loadMarkdown() {
        ViewUtils.setGone(loadingBar, false);
        ViewUtils.setGone(codeView, true);

        String markdown = new String(
            EncodingUtils.fromBase64(blob.getContent()));
        Bundle args = new Bundle();
        args.putCharSequence(ARG_TEXT, markdown);
        args.putSerializable(ARG_REPO, repo);
        getSupportLoaderManager().restartLoader(0, args, this);
    }

    private void loadContent() {
        new RefreshBlobTask(repo, sha, this) {

            @Override
            protected void onSuccess(Blob blob) throws Exception {
                super.onSuccess(blob);

                ViewUtils.setGone(loadingBar, true);
                ViewUtils.setGone(codeView, false);

                editor.setSource(path, blob);
                CommitFileViewActivity.this.blob = blob;

                if (markdownItem != null)
                    markdownItem.setEnabled(true);

                if (isMarkdownFile
                    && PreferenceUtils.getCodePreferences(
                    CommitFileViewActivity.this).getBoolean(
                    RENDER_MARKDOWN, true))
                    loadMarkdown();
                else {
                    ViewUtils.setGone(loadingBar, true);
                    ViewUtils.setGone(codeView, false);
                    editor.setSource(path, blob);
                }
            }

            @Override
            protected void onException(Exception e) throws RuntimeException {
                super.onException(e);

                Log.d(TAG, "Loading commit file contents failed", e);

                ViewUtils.setGone(loadingBar, true);
                ViewUtils.setGone(codeView, false);
                ToastUtils.show(CommitFileViewActivity.this, e,
                    R.string.error_file_load);
            }
        }.execute();
    }

}

<code block>

package com.github.mobile.ui.commit;

import android.content.res.Resources;
import android.text.TextUtils;
import android.widget.TextView;

import com.github.mobile.R;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.egit.github.core.CommitFile;


public class DiffStyler {

    private final Map<String, List<CharSequence>> diffs = new HashMap<>();

    private final int markerColor;

    private final int defaultColor;


    public DiffStyler(final Resources resources) {
        markerColor = resources.getColor(R.color.diff_marker_text);
        defaultColor = resources.getColor(R.color.text);
    }

    private int nextLine(final String patch, final int start, final int length) {
        final int end = patch.indexOf('\n', start);
        if (end != -1)
            return end;
        else
            return length;
    }


    public void updateColors(final CharSequence line, final TextView view) {
        if (TextUtils.isEmpty(line)) {
            view.setBackgroundResource(R.drawable.list_item_background);
            view.setTextColor(defaultColor);
            return;
        }

        switch (line.charAt(0)) {
        case '@':
            view.setBackgroundResource(R.drawable.diff_marker_background);
            view.setTextColor(markerColor);
            return;
        case '+':
            view.setBackgroundResource(R.drawable.diff_add_background);
            view.setTextColor(defaultColor);
            return;
        case '-':
            view.setBackgroundResource(R.drawable.diff_remove_background);
            view.setTextColor(defaultColor);
            return;
        default:
            view.setBackgroundResource(R.drawable.list_item_background);
            view.setTextColor(defaultColor);
        }
    }


    public DiffStyler setFiles(final Collection<CommitFile> files) {
        diffs.clear();
        if (files == null || files.isEmpty())
            return this;

        for (CommitFile file : files) {
            String patch = file.getPatch();
            if (TextUtils.isEmpty(patch))
                continue;

            int start = 0;
            int length = patch.length();
            int end = nextLine(patch, start, length);
            List<CharSequence> lines = new ArrayList<>();
            while (start < length) {
                lines.add(patch.substring(start, end));
                start = end + 1;
                end = nextLine(patch, start, length);
            }
            diffs.put(file.getFilename(), lines);
        }
        return this;
    }


    public List<CharSequence> get(final String file) {
        if (TextUtils.isEmpty(file))
            return Collections.emptyList();
        List<CharSequence> lines = diffs.get(file);
        return lines != null ? lines : Collections.<CharSequence>emptyList();
    }
}

<code block>

package com.github.mobile.ui.commit;

import static android.app.Activity.RESULT_OK;
import static com.github.mobile.Intents.EXTRA_REPOSITORY;
import static com.github.mobile.RequestCodes.COMMIT_VIEW;
import static com.github.mobile.RequestCodes.REF_UPDATE;
import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.support.v4.content.Loader;
import android.text.TextUtils;
import android.view.LayoutInflater;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.ListView;
import android.widget.TextView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.mobile.R;
import com.github.mobile.ThrowableLoader;
import com.github.mobile.core.ResourcePager;
import com.github.mobile.core.commit.CommitPager;
import com.github.mobile.core.commit.CommitStore;
import com.github.mobile.core.ref.RefUtils;
import com.github.mobile.ui.DialogFragmentActivity;
import com.github.mobile.ui.DialogResultListener;
import com.github.mobile.ui.ItemListFragment;
import com.github.mobile.ui.PagedItemFragment;
import com.github.mobile.ui.ref.RefDialog;
import com.github.mobile.ui.ref.RefDialogFragment;
import com.github.mobile.util.AvatarLoader;
import com.github.mobile.util.TypefaceUtils;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.egit.github.core.Commit;
import org.eclipse.egit.github.core.Reference;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.RepositoryCommit;
import org.eclipse.egit.github.core.client.PageIterator;
import org.eclipse.egit.github.core.service.CommitService;
import org.eclipse.egit.github.core.service.DataService;
import org.eclipse.egit.github.core.service.RepositoryService;


public class CommitListFragment extends PagedItemFragment<RepositoryCommit>
        implements DialogResultListener {


    @Inject
    protected AvatarLoader avatars;

    @Inject
    private CommitService service;

    @Inject
    private CommitStore store;

    private Repository repository;

    private RefDialog dialog;

    private TextView branchIconView;

    private TextView branchView;

    private View branchFooterView;

    @Inject
    private DataService dataService;

    @Inject
    private RepositoryService repoService;

    private String ref;

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);

        repository = getSerializableExtra(EXTRA_REPOSITORY);
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        setEmptyText(R.string.no_commits);
    }

    @Override
    public Loader<List<RepositoryCommit>> onCreateLoader(int id, Bundle bundle) {
        final ThrowableLoader<List<RepositoryCommit>> parentLoader = (ThrowableLoader<List<RepositoryCommit>>) super
                .onCreateLoader(id, bundle);
        return new ThrowableLoader<List<RepositoryCommit>>(getActivity(), items) {

            @Override
            public List<RepositoryCommit> loadData() throws Exception {
                if (TextUtils.isEmpty(ref)) {
                    String defaultBranch = repository.getMasterBranch();
                    if (TextUtils.isEmpty(defaultBranch)) {
                        defaultBranch = repoService.getRepository(repository)
                                .getMasterBranch();
                        if (TextUtils.isEmpty(defaultBranch))
                            defaultBranch = "master";
                    }
                    ref = defaultBranch;
                }

                return parentLoader.loadData();
            }
        };
    }

    public void onLoadFinished(Loader<List<RepositoryCommit>> loader,
            List<RepositoryCommit> items) {
        super.onLoadFinished(loader, items);

        if (ref != null)
            updateRefLabel();
    }

    @Override
    protected ResourcePager<RepositoryCommit> createPager() {
        return new CommitPager(repository, store) {

            private String last;

            @Override
            protected RepositoryCommit register(RepositoryCommit resource) {


                List<Commit> parents = resource.getParents();
                if (parents != null && !parents.isEmpty())
                    last = parents.get(0).getSha();
                else
                    last = null;

                return super.register(resource);
            }

            @Override
            public PageIterator<RepositoryCommit> createIterator(int page,
                    int size) {
                if (page > 1 || ref == null)
                    return service.pageCommits(repository, last, null, size);
                else
                    return service.pageCommits(repository, ref, null, size);
            }

            @Override
            public ResourcePager<RepositoryCommit> clear() {
                last = null;
                return super.clear();
            }
        };
    }

    @Override
    protected int getLoadingMessage() {
        return R.string.loading_commits;
    }

    @Override
    protected int getErrorMessage(Exception exception) {
        return R.string.error_commits_load;
    }

    @Override
    protected SingleTypeAdapter<RepositoryCommit> createAdapter(
            List<RepositoryCommit> items) {
        return new CommitListAdapter(R.layout.commit_item, getActivity()
                .getLayoutInflater(), items, avatars);
    }

    @Override
    public void onListItemClick(ListView l, View v, int position, long id) {
        Object item = l.getItemAtPosition(position);
        if (item instanceof RepositoryCommit)
            startActivityForResult(CommitViewActivity.createIntent(repository,
                    position, items), COMMIT_VIEW);
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (requestCode == COMMIT_VIEW) {
            notifyDataSetChanged();
            return;
        }

        super.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    public void onDialogResult(int requestCode, int resultCode, Bundle arguments) {
        if (RESULT_OK != resultCode)
            return;

        switch (requestCode) {
        case REF_UPDATE:
            setRef(RefDialogFragment.getSelected(arguments));
            break;
        }
    }

    private void updateRefLabel() {
        branchView.setText(RefUtils.getName(ref));
        if (RefUtils.isTag(ref))
            branchIconView.setText(R.string.icon_tag);
        else
            branchIconView.setText(R.string.icon_fork);
    }

    private void setRef(final Reference ref) {
        this.ref = ref.getRef();
        updateRefLabel();
        refreshWithProgress();
    }

    private void switchRefs() {
        if (ref == null)
            return;

        if (dialog == null)
            dialog = new RefDialog((DialogFragmentActivity) getActivity(),
                    REF_UPDATE, repository, dataService);
        dialog.show(new Reference().setRef(ref));
    }

    @Override
    public ItemListFragment<RepositoryCommit> setListShown(boolean shown,
            boolean animate) {
        ViewUtils.setGone(branchFooterView, !shown);
        return super.setListShown(shown, animate);
    }

    @Override
    public void onViewCreated(View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        branchFooterView = finder.find(R.id.rl_branch);
        branchView = finder.find(R.id.tv_branch);
        branchIconView = finder.find(R.id.tv_branch_icon);
        TypefaceUtils.setOcticons(branchIconView);
        branchFooterView.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                switchRefs();
            }
        });
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        return inflater.inflate(R.layout.commit_list, null);
    }
}

<code block>

package com.github.mobile.ui.commit;

import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
import static android.content.Intent.FLAG_ACTIVITY_SINGLE_TOP;
import static com.github.mobile.Intents.EXTRA_BASE;
import static com.github.mobile.Intents.EXTRA_HEAD;
import static com.github.mobile.Intents.EXTRA_REPOSITORY;
import android.content.Intent;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v7.app.ActionBar;
import android.view.Menu;
import android.view.MenuItem;

import com.github.mobile.Intents.Builder;
import com.github.mobile.R;
import com.github.mobile.ui.DialogFragmentActivity;
import com.github.mobile.ui.repo.RepositoryViewActivity;
import com.github.mobile.util.AvatarLoader;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Repository;


public class CommitCompareViewActivity extends DialogFragmentActivity {


    public static Intent createIntent(final Repository repository,
        final String base, final String head) {
        Builder builder = new Builder("commits.compare.VIEW");
        builder.add(EXTRA_BASE, base);
        builder.add(EXTRA_HEAD, head);
        builder.repo(repository);
        return builder.toIntent();
    }

    private Repository repository;

    @Inject
    private AvatarLoader avatars;

    private Fragment fragment;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        repository = getSerializableExtra(EXTRA_REPOSITORY);

        setContentView(R.layout.commit_compare);

        setSupportActionBar((android.support.v7.widget.Toolbar) findViewById(R.id.toolbar));

        ActionBar actionBar = getSupportActionBar();
        actionBar.setDisplayHomeAsUpEnabled(true);
        actionBar.setSubtitle(repository.generateId());
        avatars.bind(actionBar, repository.getOwner());

        fragment = getSupportFragmentManager()
            .findFragmentById(android.R.id.list);
    }

    @Override
    public boolean onCreateOptionsMenu(Menu optionsMenu) {
        if (fragment != null)
            fragment.onCreateOptionsMenu(optionsMenu, getMenuInflater());

        return super.onCreateOptionsMenu(optionsMenu);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                Intent intent = RepositoryViewActivity.createIntent(repository);
                intent.addFlags(FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_SINGLE_TOP);
                startActivity(intent);
                return true;
            default:
                if (fragment != null)
                    return fragment.onOptionsItemSelected(item);
                else
                    return super.onOptionsItemSelected(item);
        }
    }
}

<code block>

package com.github.mobile.ui.commit;

import static java.lang.String.CASE_INSENSITIVE_ORDER;

import java.util.Comparator;

import org.eclipse.egit.github.core.CommitFile;


public class CommitFileComparator implements Comparator<CommitFile> {

    @Override
    public int compare(final CommitFile lhs, final CommitFile rhs) {
        String lPath = lhs.getFilename();
        final int lSlash = lPath.lastIndexOf('/');
        if (lSlash != -1)
            lPath = lPath.substring(lSlash + 1);

        String rPath = rhs.getFilename();
        final int rSlash = rPath.lastIndexOf('/');
        if (rSlash != -1)
            rPath = rPath.substring(rSlash + 1);

        return CASE_INSENSITIVE_ORDER.compare(lPath, rPath);
    }
}

<code block>

package com.github.mobile.ui.commit;

import android.accounts.Account;
import android.app.Activity;
import android.util.Log;

import com.github.mobile.R;
import com.github.mobile.ui.ProgressDialogTask;
import com.github.mobile.util.HtmlUtils;
import com.github.mobile.util.ToastUtils;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.CommitComment;
import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.service.CommitService;


public class CreateCommentTask extends ProgressDialogTask<CommitComment> {

    private static final String TAG = "CreateCommentTask";

    @Inject
    private CommitService service;

    private final IRepositoryIdProvider repository;

    private final String commit;

    private final CommitComment comment;


    protected CreateCommentTask(final Activity activity,
            final IRepositoryIdProvider repository, final String commit,
            final CommitComment comment) {
        super(activity);

        this.repository = repository;
        this.commit = commit;
        this.comment = comment;
    }


    public CreateCommentTask start() {
        showIndeterminate(R.string.creating_comment);
        execute();
        return this;
    }

    @Override
    public CommitComment run(final Account account) throws Exception {
        CommitComment created = service.addComment(repository, commit, comment);
        String formatted = HtmlUtils.format(created.getBodyHtml()).toString();
        created.setBodyHtml(formatted);
        return created;

    }

    @Override
    protected void onException(final Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception creating comment on commit", e);

        ToastUtils.show((Activity) getContext(), e.getMessage());
    }
}

<code block>

package com.github.mobile.ui.commit;

import static com.github.mobile.Intents.EXTRA_BASE;
import static com.github.mobile.Intents.EXTRA_HEAD;
import static com.github.mobile.Intents.EXTRA_REPOSITORY;
import android.accounts.Account;
import android.app.Activity;
import android.os.Bundle;
import android.text.TextUtils;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ListView;
import android.widget.ProgressBar;
import android.widget.TextView;

import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.mobile.R;
import com.github.mobile.core.commit.CommitCompareTask;
import com.github.mobile.core.commit.CommitUtils;
import com.github.mobile.ui.DialogFragment;
import com.github.mobile.ui.HeaderFooterListAdapter;
import com.github.mobile.util.AvatarLoader;
import com.github.mobile.util.ToastUtils;
import com.google.inject.Inject;

import java.text.MessageFormat;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

import org.eclipse.egit.github.core.CommitFile;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.RepositoryCommit;
import org.eclipse.egit.github.core.RepositoryCommitCompare;


public class CommitCompareListFragment extends DialogFragment implements
        OnItemClickListener {

    private DiffStyler diffStyler;

    private ListView list;

    private ProgressBar progress;

    private Repository repository;

    private String base;

    private String head;

    @Inject
    private AvatarLoader avatars;

    private HeaderFooterListAdapter<CommitFileListAdapter> adapter;

    private RepositoryCommitCompare compare;

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);

        repository = getSerializableExtra(EXTRA_REPOSITORY);
        base = getStringExtra(EXTRA_BASE);
        head = getStringExtra(EXTRA_HEAD);
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        diffStyler = new DiffStyler(getResources());
        compareCommits();
    }

    @Override
    public void onCreateOptionsMenu(final Menu optionsMenu,
            final MenuInflater inflater) {
        inflater.inflate(R.menu.refresh, optionsMenu);
    }

    @Override
    public boolean onOptionsItemSelected(final MenuItem item) {
        if (!isUsable())
            return false;

        switch (item.getItemId()) {
        case R.id.m_refresh:
            compareCommits();
            return true;
        default:
            return super.onOptionsItemSelected(item);
        }
    }

    private void compareCommits() {
        new CommitCompareTask(getActivity(), repository, base, head) {

            @Override
            protected RepositoryCommitCompare run(Account account)
                    throws Exception {
                RepositoryCommitCompare compare = super.run(account);

                List<CommitFile> files = compare.getFiles();
                diffStyler.setFiles(files);
                if (files != null)
                    Collections.sort(files, new CommitFileComparator());
                return compare;
            }

            @Override
            protected void onSuccess(RepositoryCommitCompare compare)
                    throws Exception {
                super.onSuccess(compare);

                updateList(compare);
            }

            @Override
            protected void onException(Exception e) throws RuntimeException {
                super.onException(e);

                ToastUtils.show(getActivity(), e, R.string.error_commits_load);
            }

        }.execute();
    }

    private void updateList(RepositoryCommitCompare compare) {
        if (!isUsable())
            return;

        this.compare = compare;

        ViewUtils.setGone(progress, true);
        ViewUtils.setGone(list, false);

        LayoutInflater inflater = getActivity().getLayoutInflater();
        adapter.clearHeaders();
        adapter.getWrappedAdapter().clear();

        List<RepositoryCommit> commits = compare.getCommits();
        if (commits != null && !commits.isEmpty()) {
            View commitHeader = inflater.inflate(R.layout.commit_details_header,
                    null);
            ((TextView) commitHeader.findViewById(R.id.tv_commit_summary))
                    .setText(MessageFormat.format(
                            getString(R.string.comparing_commits), commits.size()));
            adapter.addHeader(commitHeader);
            adapter.addHeader(inflater.inflate(R.layout.list_divider, null));
            CommitListAdapter commitAdapter = new CommitListAdapter(
                    R.layout.commit_item, inflater, commits, avatars);
            for (int i = 0; i < commits.size(); i++) {
                RepositoryCommit commit = commits.get(i);
                View view = commitAdapter.getView(i, null, null);
                adapter.addHeader(view, commit, true);
                adapter.addHeader(inflater.inflate(R.layout.list_divider, null));
            }
        }

        CommitFileListAdapter rootAdapter = adapter.getWrappedAdapter();
        rootAdapter.clear();
        List<CommitFile> files = compare.getFiles();
        if (files != null && !files.isEmpty()) {
            addFileStatHeader(files, inflater);
            for (CommitFile file : files)
                rootAdapter.addItem(file);
        }
    }

    private void addFileStatHeader(List<CommitFile> files,
            LayoutInflater inflater) {
        View fileHeader = inflater.inflate(
                R.layout.commit_compare_file_details_header, null);
        ((TextView) fileHeader.findViewById(R.id.tv_commit_file_summary))
                .setText(CommitUtils.formatStats(files));
        adapter.addHeader(fileHeader);
    }

    @Override
    public void onViewCreated(View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        list = finder.find(android.R.id.list);
        progress = finder.find(R.id.pb_loading);

        LayoutInflater inflater = getActivity().getLayoutInflater();

        list.setOnItemClickListener(this);

        adapter = new HeaderFooterListAdapter<>(list,
                new CommitFileListAdapter(inflater, diffStyler, null, null));
        adapter.addFooter(inflater.inflate(R.layout.footer_separator, null));
        list.setAdapter(adapter);
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        return inflater.inflate(R.layout.commit_diff_list, container);
    }

    private void openCommit(final RepositoryCommit commit) {
        if (compare != null) {
            int commitPosition = 0;
            Collection<RepositoryCommit> commits = compare.getCommits();
            for (RepositoryCommit candidate : commits)
                if (commit == candidate)
                    break;
                else
                    commitPosition++;
            if (commitPosition < commits.size())
                startActivity(CommitViewActivity.createIntent(repository,
                        commitPosition, commits));
        } else
            startActivity(CommitViewActivity.createIntent(repository,
                    commit.getSha()));
    }

    private void openFile(final CommitFile file) {
        if (!TextUtils.isEmpty(file.getFilename())
                && !TextUtils.isEmpty(file.getSha()))
            startActivity(CommitFileViewActivity.createIntent(repository, head,
                    file));
    }

    private void openLine(AdapterView<?> parent, int position) {
        Object item = null;
        while (--position >= 0) {
            item = parent.getItemAtPosition(position);
            if (item instanceof CommitFile) {
                openFile((CommitFile) item);
                return;
            }
        }
    }

    @Override
    public void onItemClick(AdapterView<?> parent, View view, int position,
            long id) {
        Object item = parent.getItemAtPosition(position);
        if (item instanceof RepositoryCommit)
            openCommit((RepositoryCommit) item);
        else if (item instanceof CommitFile)
            openFile((CommitFile) item);
        else if (item instanceof CharSequence)
            openLine(parent, position);
    }
}

<code block>

package com.github.mobile.ui.ref;

import static java.lang.String.CASE_INSENSITIVE_ORDER;
import android.accounts.Account;
import android.util.Log;

import com.github.mobile.R;
import com.github.mobile.core.ref.RefUtils;
import com.github.mobile.ui.DialogFragmentActivity;
import com.github.mobile.ui.ProgressDialogTask;
import com.github.mobile.util.ToastUtils;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.Reference;
import org.eclipse.egit.github.core.service.DataService;


public class RefDialog {

    private static final String TAG = "RefDialog";

    private final DataService service;

    private Map<String, Reference> refs;

    private final int requestCode;

    private final DialogFragmentActivity activity;

    private final IRepositoryIdProvider repository;


    public RefDialog(final DialogFragmentActivity activity,
            final int requestCode, final IRepositoryIdProvider repository,
            final DataService service) {
        this.activity = activity;
        this.requestCode = requestCode;
        this.repository = repository;
        this.service = service;
    }

    private void load(final Reference selectedRef) {
        new ProgressDialogTask<List<Reference>>(activity) {

            @Override
            public List<Reference> run(Account account) throws Exception {
                List<Reference> allRefs = service.getReferences(repository);
                Map<String, Reference> loadedRefs = new TreeMap<>(
                        CASE_INSENSITIVE_ORDER);
                for (Reference ref : allRefs)
                    if (RefUtils.isValid(ref))
                        loadedRefs.put(ref.getRef(), ref);
                refs = loadedRefs;
                return allRefs;
            }

            @Override
            protected void onSuccess(List<Reference> all) throws Exception {
                super.onSuccess(all);

                show(selectedRef);
            }

            @Override
            protected void onException(Exception e) throws RuntimeException {
                super.onException(e);

                Log.d(TAG, "Exception loading references", e);
                ToastUtils.show(activity, e, R.string.error_refs_load);
            }

            @Override
            public void execute() {
                showIndeterminate(R.string.loading_refs);

                super.execute();
            }
        }.execute();
    }


    public void show(Reference selectedRef) {
        if (refs == null || refs.isEmpty()) {
            load(selectedRef);
            return;
        }

        final ArrayList<Reference> refList = new ArrayList<>(
                refs.values());
        int checked = -1;
        if (selectedRef != null) {
            String ref = selectedRef.getRef();
            for (int i = 0; i < refList.size(); i++) {
                String candidate = refList.get(i).getRef();
                if (ref.equals(candidate)) {
                    checked = i;
                    break;
                } else if (ref.equals(RefUtils.getName(candidate))) {
                    checked = i;
                    break;
                }
            }
        }

        RefDialogFragment.show(activity, requestCode,
                activity.getString(R.string.select_ref), null, refList, checked);
    }
}

<code block>

package com.github.mobile.ui.ref;

import static android.app.Activity.RESULT_OK;
import static android.content.DialogInterface.BUTTON_NEGATIVE;
import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.DialogInterface;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ListView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.mobile.R;
import com.github.mobile.core.ref.RefUtils;
import com.github.mobile.ui.DialogFragmentActivity;
import com.github.mobile.ui.SingleChoiceDialogFragment;
import com.github.mobile.util.TypefaceUtils;

import java.util.ArrayList;

import org.eclipse.egit.github.core.Reference;


public class RefDialogFragment extends SingleChoiceDialogFragment {

    private static class RefListAdapter extends SingleTypeAdapter<Reference> {

        private final int selected;

        public RefListAdapter(LayoutInflater inflater, Reference[] refs,
                int selected) {
            super(inflater, R.layout.ref_item);

            this.selected = selected;
            setItems(refs);
        }

        @Override
        public long getItemId(int position) {
            return getItem(position).getRef().hashCode();
        }

        @Override
        protected int[] getChildViewIds() {
            return new int[] { R.id.tv_ref_icon, R.id.tv_ref, R.id.rb_selected };
        }

        @Override
        protected View initialize(View view) {
            view = super.initialize(view);

            TypefaceUtils.setOcticons(textView(0));
            return view;
        }

        @Override
        protected void update(int position, Reference item) {
            if (RefUtils.isTag(item))
                setText(0, R.string.icon_tag);
            else
                setText(0, R.string.icon_fork);
            setText(1, RefUtils.getName(item));
            setChecked(2, selected == position);
        }
    }


    public static Reference getSelected(Bundle arguments) {
        return (Reference) arguments.getSerializable(ARG_SELECTED);
    }


    public static void show(final DialogFragmentActivity activity,
            final int requestCode, final String title, final String message,
            ArrayList<Reference> choices, final int selectedChoice) {
        show(activity, requestCode, title, message, choices, selectedChoice,
                new RefDialogFragment());
    }

    @Override
    public Dialog onCreateDialog(final Bundle savedInstanceState) {
        Activity activity = getActivity();
        Bundle arguments = getArguments();

        final AlertDialog dialog = createDialog();
        dialog.setButton(BUTTON_NEGATIVE, activity.getString(R.string.cancel),
                this);

        LayoutInflater inflater = activity.getLayoutInflater();

        ListView view = (ListView) inflater.inflate(R.layout.dialog_list_view,
                null);
        view.setOnItemClickListener(new OnItemClickListener() {

            @Override
            public void onItemClick(AdapterView<?> parent, View view,
                    int position, long id) {
                onClick(dialog, position);
            }
        });

        ArrayList<Reference> choices = getChoices();
        int selected = arguments.getInt(ARG_SELECTED_CHOICE);
        RefListAdapter adapter = new RefListAdapter(inflater,
                choices.toArray(new Reference[choices.size()]), selected);
        view.setAdapter(adapter);
        if (selected >= 0)
            view.setSelection(selected);
        dialog.setView(view);

        return dialog;
    }

    @SuppressWarnings("unchecked")
    private ArrayList<Reference> getChoices() {
        return (ArrayList<Reference>) getArguments().getSerializable(
                ARG_CHOICES);
    }

    @Override
    public void onClick(DialogInterface dialog, int which) {
        super.onClick(dialog, which);

        switch (which) {
        case BUTTON_NEGATIVE:
            break;
        default:
            getArguments().putSerializable(ARG_SELECTED,
                    getChoices().get(which));
            onResult(RESULT_OK);
        }
    }
}

<code block>

package com.github.mobile.ui.ref;

import android.app.Activity;
import android.content.Context;
import android.text.format.Formatter;
import android.view.View;
import android.widget.TextView;

import com.github.kevinsawicki.wishlist.MultiTypeAdapter;
import com.github.mobile.R;
import com.github.mobile.core.code.FullTree.Entry;
import com.github.mobile.core.code.FullTree.Folder;
import com.github.mobile.core.commit.CommitUtils;
import com.github.mobile.util.ServiceUtils;
import com.github.mobile.util.TypefaceUtils;


public class CodeTreeAdapter extends MultiTypeAdapter {

    private static final int TYPE_BLOB = 0;

    private static final int TYPE_TREE = 1;

    private static final int INDENTED_PADDING = 16;

    private final Context context;

    private final int indentedPaddingLeft;

    private int paddingLeft;

    private int paddingRight;

    private int paddingTop;

    private int paddingBottom;

    private boolean indented;


    public CodeTreeAdapter(Activity activity) {
        super(activity);

        this.context = activity;
        indentedPaddingLeft = ServiceUtils.getIntPixels(
                activity.getResources(), INDENTED_PADDING);
    }


    public CodeTreeAdapter setIndented(final boolean indented) {
        this.indented = indented;
        return this;
    }

    @Override
    public int getViewTypeCount() {
        return 2;
    }


    public void setItems(final Folder root) {
        clear();

        addItems(TYPE_TREE, root.folders.values());
        addItems(TYPE_BLOB, root.files.values());
    }

    @Override
    protected int getChildLayoutId(final int type) {
        switch (type) {
        case TYPE_BLOB:
            return R.layout.blob_item;
        case TYPE_TREE:
            return R.layout.folder_item;
        default:
            return -1;
        }
    }

    @Override
    protected int[] getChildViewIds(final int type) {
        switch (type) {
        case TYPE_BLOB:
            return new int[] { R.id.tv_file, R.id.tv_size };
        case TYPE_TREE:
            return new int[] { R.id.tv_folder, R.id.tv_folders, R.id.tv_files };
        default:
            return null;
        }
    }

    @Override
    protected View initialize(final int type, View view) {
        view = super.initialize(type, view);

        paddingLeft = view.getPaddingLeft();
        paddingRight = view.getPaddingRight();
        paddingTop = view.getPaddingTop();
        paddingBottom = view.getPaddingBottom();

        switch (type) {
        case TYPE_BLOB:
            TypefaceUtils.setOcticons((TextView) view
                    .findViewById(R.id.tv_file_icon));
            break;
        case TYPE_TREE:
            TypefaceUtils.setOcticons(
                    (TextView) view.findViewById(R.id.tv_folder_icon),
                    (TextView) view.findViewById(R.id.tv_folders_icon),
                    (TextView) view.findViewById(R.id.tv_files_icon));
        }

        return view;
    }

    @Override
    protected void update(final int position, final Object item, final int type) {
        if (indented)
            updater.view.setPadding(indentedPaddingLeft, paddingTop,
                    paddingRight, paddingBottom);
        else
            updater.view.setPadding(paddingLeft, paddingTop, paddingRight,
                    paddingBottom);

        switch (type) {
        case TYPE_BLOB:
            Entry file = (Entry) item;
            setText(0, file.name);
            setText(1, Formatter.formatFileSize(context, file.entry.getSize()));

            break;
        case TYPE_TREE:
            Folder folder = (Folder) item;
            setText(0, CommitUtils.getName(folder.name));
            setNumber(1, folder.folders.size());
            setNumber(2, folder.files.size());
            break;
        }
    }
}

<code block>

package com.github.mobile.ui.ref;

import android.content.Intent;
import android.os.Bundle;
import android.support.v4.app.LoaderManager.LoaderCallbacks;
import android.support.v4.content.Loader;
import android.support.v7.app.ActionBar;
import android.text.TextUtils;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;
import android.webkit.WebView;
import android.widget.ProgressBar;

import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.mobile.Intents.Builder;
import com.github.mobile.R;
import com.github.mobile.core.code.RefreshBlobTask;
import com.github.mobile.core.commit.CommitUtils;
import com.github.mobile.ui.BaseActivity;
import com.github.mobile.ui.MarkdownLoader;
import com.github.mobile.util.AvatarLoader;
import com.github.mobile.util.HttpImageGetter;
import com.github.mobile.util.MarkdownUtils;
import com.github.mobile.util.PreferenceUtils;
import com.github.mobile.util.ShareUtils;
import com.github.mobile.util.SourceEditor;
import com.github.mobile.util.ToastUtils;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Blob;
import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.util.EncodingUtils;

import static com.github.mobile.Intents.EXTRA_BASE;
import static com.github.mobile.Intents.EXTRA_HEAD;
import static com.github.mobile.Intents.EXTRA_PATH;
import static com.github.mobile.Intents.EXTRA_REPOSITORY;
import static com.github.mobile.util.PreferenceUtils.RENDER_MARKDOWN;
import static com.github.mobile.util.PreferenceUtils.WRAP;


public class BranchFileViewActivity extends BaseActivity implements
    LoaderCallbacks<CharSequence> {

    private static final String TAG = "BranchFileViewActivity";

    private static final String ARG_TEXT = "text";

    private static final String ARG_REPO = "repo";


    public static Intent createIntent(Repository repository, String branch,
        String file, String blobSha) {
        Builder builder = new Builder("branch.file.VIEW");
        builder.repo(repository);
        builder.add(EXTRA_BASE, blobSha);
        builder.add(EXTRA_PATH, file);
        builder.add(EXTRA_HEAD, branch);
        return builder.toIntent();
    }

    private Repository repo;

    private String sha;

    private String path;

    private String file;

    private String branch;

    private boolean isMarkdownFile;

    private String renderedMarkdown;

    private Blob blob;

    private ProgressBar loadingBar;

    private WebView codeView;

    private SourceEditor editor;

    private MenuItem markdownItem;

    @Inject
    private AvatarLoader avatars;

    @Inject
    private HttpImageGetter imageGetter;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.commit_file_view);

        repo = getSerializableExtra(EXTRA_REPOSITORY);
        sha = getStringExtra(EXTRA_BASE);
        path = getStringExtra(EXTRA_PATH);
        branch = getStringExtra(EXTRA_HEAD);

        loadingBar = finder.find(R.id.pb_loading);
        codeView = finder.find(R.id.wv_code);

        codeView.getSettings().setBuiltInZoomControls(true);
        codeView.getSettings().setUseWideViewPort(true);

        file = CommitUtils.getName(path);
        isMarkdownFile = MarkdownUtils.isMarkdown(file);
        editor = new SourceEditor(codeView);
        editor.setWrap(PreferenceUtils.getCodePreferences(this).getBoolean(
            WRAP, false));

        setSupportActionBar((android.support.v7.widget.Toolbar) findViewById(R.id.toolbar));

        ActionBar actionBar = getSupportActionBar();
        actionBar.setTitle(file);
        actionBar.setSubtitle(branch);
        avatars.bind(actionBar, repo.getOwner());

        loadContent();
    }

    @Override
    public boolean onCreateOptionsMenu(final Menu optionsMenu) {
        getMenuInflater().inflate(R.menu.file_view, optionsMenu);

        MenuItem wrapItem = optionsMenu.findItem(R.id.m_wrap);
        if (PreferenceUtils.getCodePreferences(this).getBoolean(WRAP, false))
            wrapItem.setTitle(R.string.disable_wrapping);
        else
            wrapItem.setTitle(R.string.enable_wrapping);

        markdownItem = optionsMenu.findItem(R.id.m_render_markdown);
        if (isMarkdownFile) {
            markdownItem.setEnabled(blob != null);
            markdownItem.setVisible(true);
            if (PreferenceUtils.getCodePreferences(this).getBoolean(
                RENDER_MARKDOWN, true))
                markdownItem.setTitle(R.string.show_raw_markdown);
            else
                markdownItem.setTitle(R.string.render_markdown);
        }

        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.m_wrap:
                if (editor.getWrap())
                    item.setTitle(R.string.enable_wrapping);
                else
                    item.setTitle(R.string.disable_wrapping);
                editor.toggleWrap();
                PreferenceUtils.save(PreferenceUtils.getCodePreferences(this)
                    .edit().putBoolean(WRAP, editor.getWrap()));
                return true;

            case R.id.m_share:
                shareFile();
                return true;

            case R.id.m_render_markdown:
                if (editor.isMarkdown()) {
                    item.setTitle(R.string.render_markdown);
                    editor.toggleMarkdown();
                    editor.setSource(file, blob);
                } else {
                    item.setTitle(R.string.show_raw_markdown);
                    editor.toggleMarkdown();
                    if (renderedMarkdown != null)
                        editor.setSource(file, renderedMarkdown, false);
                    else
                        loadMarkdown();
                }
                PreferenceUtils.save(PreferenceUtils.getCodePreferences(this)
                    .edit().putBoolean(RENDER_MARKDOWN, editor.isMarkdown()));
                return true;

            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    public Loader<CharSequence> onCreateLoader(int loader, Bundle args) {
        final String raw = args.getString(ARG_TEXT);
        final IRepositoryIdProvider repo = (IRepositoryIdProvider) args
            .getSerializable(ARG_REPO);
        return new MarkdownLoader(this, repo, raw, imageGetter, false);
    }

    @Override
    public void onLoadFinished(Loader<CharSequence> loader,
        CharSequence rendered) {
        if (rendered == null)
            ToastUtils.show(this, R.string.error_rendering_markdown);

        ViewUtils.setGone(loadingBar, true);
        ViewUtils.setGone(codeView, false);

        if (!TextUtils.isEmpty(rendered)) {
            renderedMarkdown = rendered.toString();
            if (markdownItem != null)
                markdownItem.setEnabled(true);
            editor.setMarkdown(true).setSource(file, renderedMarkdown, false);
        }
    }

    @Override
    public void onLoaderReset(Loader<CharSequence> loader) {
    }

    private void shareFile() {
        String id = repo.generateId();
        startActivity(ShareUtils.create(path + " at " + branch + " on " + id,
            "https://github.com/" + id + "/blob/" + branch + '/' + path));
    }

    private void loadMarkdown() {
        ViewUtils.setGone(loadingBar, false);
        ViewUtils.setGone(codeView, true);

        String markdown = new String(
            EncodingUtils.fromBase64(blob.getContent()));
        Bundle args = new Bundle();
        args.putCharSequence(ARG_TEXT, markdown);
        args.putSerializable(ARG_REPO, repo);
        getSupportLoaderManager().restartLoader(0, args, this);
    }

    private void loadContent() {
        ViewUtils.setGone(loadingBar, false);
        ViewUtils.setGone(codeView, true);

        new RefreshBlobTask(repo, sha, this) {

            @Override
            protected void onSuccess(Blob blob) throws Exception {
                super.onSuccess(blob);

                BranchFileViewActivity.this.blob = blob;

                if (markdownItem != null)
                    markdownItem.setEnabled(true);

                if (isMarkdownFile
                    && PreferenceUtils.getCodePreferences(
                    BranchFileViewActivity.this).getBoolean(
                    RENDER_MARKDOWN, true))
                    loadMarkdown();
                else {
                    ViewUtils.setGone(loadingBar, true);
                    ViewUtils.setGone(codeView, false);

                    editor.setMarkdown(false).setSource(file, blob);
                }
            }

            @Override
            protected void onException(Exception e) throws RuntimeException {
                super.onException(e);

                Log.d(TAG, "Loading file contents failed", e);

                ViewUtils.setGone(loadingBar, true);
                ViewUtils.setGone(codeView, false);
                ToastUtils.show(BranchFileViewActivity.this, e,
                    R.string.error_file_load);
            }
        }.execute();
    }

}

<code block>

package com.github.mobile.ui.gist;


import static org.eclipse.egit.github.core.client.IGitHubConstants.SEGMENT_COMMENTS;
import static org.eclipse.egit.github.core.client.IGitHubConstants.SEGMENT_GISTS;
import android.accounts.Account;
import android.app.Activity;
import android.util.Log;

import com.github.mobile.R;
import com.github.mobile.ui.ProgressDialogTask;
import com.github.mobile.util.ToastUtils;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.service.GistService;


public class DeleteCommentTask extends ProgressDialogTask<Comment> {

    private static final String TAG = "DeleteCommentTask";

    private final Comment comment;

    @Inject
    private GistService service;

    private final String gistId;


    public DeleteCommentTask(Activity activity, String gistId, Comment comment) {
        super(activity);

        this.gistId = gistId;
        this.comment = comment;
    }

    @Override
    protected Comment run(Account account) throws Exception {
        deleteComment(gistId, comment.getId());
        return comment;
    }


    public DeleteCommentTask start() {
        showIndeterminate(R.string.deleting_comment);

        execute();
        return this;
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception deleting comment on gist", e);

        ToastUtils.show((Activity) getContext(), e.getMessage());
    }


    private void deleteComment(String gistId, long commentId) throws Exception {
        service.getClient().delete(SEGMENT_GISTS + '/' + gistId + SEGMENT_COMMENTS + '/' + commentId);
    }
}

<code block>

package com.github.mobile.ui.gist;

import static com.github.mobile.Intents.EXTRA_GIST;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.ActionBar;

import com.github.mobile.Intents.Builder;
import com.github.mobile.R;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.User;


public class CreateCommentActivity extends
        com.github.mobile.ui.comment.CreateCommentActivity {


    public static Intent createIntent(Gist gist) {
        Builder builder = new Builder("gist.comment.create.VIEW");
        builder.gist(gist);
        return builder.toIntent();
    }

    private Gist gist;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        gist = getSerializableExtra(EXTRA_GIST);

        ActionBar actionBar = getSupportActionBar();
        actionBar.setTitle(getString(R.string.gist_title) + gist.getId());
        User user = gist.getUser();
        if (user != null)
            actionBar.setSubtitle(user.getLogin());
        avatars.bind(actionBar, user);
    }

    @Override
    protected void createComment(String comment) {
        new CreateCommentTask(this, gist.getId(), comment) {

            @Override
            protected void onSuccess(Comment comment) throws Exception {
                super.onSuccess(comment);

                finish(comment);
            }

        }.start();
    }
}

<code block>

package com.github.mobile.ui.gist;

import static android.app.Activity.RESULT_OK;
import static android.view.View.GONE;
import static android.view.View.VISIBLE;
import static com.github.mobile.Intents.EXTRA_COMMENT;
import static com.github.mobile.Intents.EXTRA_GIST_ID;
import static com.github.mobile.RequestCodes.COMMENT_CREATE;
import static com.github.mobile.RequestCodes.COMMENT_DELETE;
import static com.github.mobile.RequestCodes.COMMENT_EDIT;
import android.app.Activity;
import android.content.Intent;
import android.graphics.Typeface;
import android.os.Bundle;
import android.support.v4.app.FragmentActivity;
import android.text.TextUtils;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ListView;
import android.widget.ProgressBar;
import android.widget.TextView;

import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.mobile.R;
import com.github.mobile.accounts.AccountUtils;
import com.github.mobile.core.OnLoadListener;
import com.github.mobile.core.gist.FullGist;
import com.github.mobile.core.gist.GistStore;
import com.github.mobile.core.gist.RefreshGistTask;
import com.github.mobile.core.gist.StarGistTask;
import com.github.mobile.core.gist.UnstarGistTask;
import com.github.mobile.ui.ConfirmDialogFragment;
import com.github.mobile.ui.DialogFragment;
import com.github.mobile.ui.DialogFragmentActivity;
import com.github.mobile.ui.HeaderFooterListAdapter;
import com.github.mobile.ui.StyledText;
import com.github.mobile.ui.comment.CommentListAdapter;
import com.github.mobile.ui.comment.DeleteCommentListener;
import com.github.mobile.ui.comment.EditCommentListener;
import com.github.mobile.util.AvatarLoader;
import com.github.mobile.util.HttpImageGetter;
import com.github.mobile.util.ShareUtils;
import com.github.mobile.util.ToastUtils;
import com.github.mobile.util.TypefaceUtils;
import com.google.inject.Inject;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.List;
import java.util.Map;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.GistFile;
import org.eclipse.egit.github.core.User;


public class GistFragment extends DialogFragment implements OnItemClickListener {

    private String gistId;

    private List<Comment> comments;

    private Gist gist;

    private ListView list;

    private ProgressBar progress;

    @Inject
    private GistStore store;

    @Inject
    private HttpImageGetter imageGetter;

    private View headerView;

    private View footerView;

    private TextView created;

    private TextView updated;

    private TextView description;

    private View loadingView;

    private HeaderFooterListAdapter<CommentListAdapter> adapter;

    private boolean starred;

    private boolean loadFinished;

    @Inject
    private AvatarLoader avatars;

    private List<View> fileHeaders = new ArrayList<>();

    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        gistId = getArguments().getString(EXTRA_GIST_ID);
        gist = store.getGist(gistId);
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        View root = inflater.inflate(R.layout.comment_list, null);

        headerView = inflater.inflate(R.layout.gist_header, null);
        created = (TextView) headerView.findViewById(R.id.tv_gist_creation);
        updated = (TextView) headerView.findViewById(R.id.tv_gist_updated);
        description = (TextView) headerView
                .findViewById(R.id.tv_gist_description);

        loadingView = inflater.inflate(R.layout.loading_item, null);
        ((TextView) loadingView.findViewById(R.id.tv_loading))
                .setText(R.string.loading_comments);

        footerView = inflater.inflate(R.layout.footer_separator, null);

        return root;
    }

    @Override
    public void onViewCreated(View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        list = finder.find(android.R.id.list);
        progress = finder.find(R.id.pb_loading);

        Activity activity = getActivity();
        User user = gist.getUser();
        String userName = null;
        if(user != null) userName = user.getLogin();
        adapter = new HeaderFooterListAdapter<>(list,
                new CommentListAdapter(activity.getLayoutInflater(), null, avatars,
                        imageGetter, editCommentListener, deleteCommentListener, userName, false, null));
        list.setAdapter(adapter);
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        list.setOnItemClickListener(this);
        adapter.addHeader(headerView);
        adapter.addFooter(footerView);

        if (gist != null) {
            updateHeader(gist);
            updateFiles(gist);
        }

        if (gist == null || (gist.getComments() > 0 && comments == null))
            adapter.addHeader(loadingView, null, false);

        if (gist != null && comments != null)
            updateList(gist, comments);
        else
            refreshGist();
    }

    private boolean isOwner() {
        if (gist == null)
            return false;
        User user = gist.getUser();
        if (user == null)
            return false;
        String login = AccountUtils.getLogin(getActivity());
        return login != null && login.equals(user.getLogin());
    }

    private void updateHeader(Gist gist) {
        Date createdAt = gist.getCreatedAt();
        if (createdAt != null) {
            StyledText text = new StyledText();
            text.append(getString(R.string.prefix_created));
            text.append(createdAt);
            created.setText(text);
            created.setVisibility(VISIBLE);
        } else
            created.setVisibility(GONE);

        Date updatedAt = gist.getUpdatedAt();
        if (updatedAt != null && !updatedAt.equals(createdAt)) {
            StyledText text = new StyledText();
            text.append(getString(R.string.prefix_updated));
            text.append(updatedAt);
            updated.setText(text);
            updated.setVisibility(VISIBLE);
        } else
            updated.setVisibility(GONE);

        String desc = gist.getDescription();
        if (!TextUtils.isEmpty(desc))
            description.setText(desc);
        else
            description.setText(R.string.no_description_given);

        ViewUtils.setGone(progress, true);
        ViewUtils.setGone(list, false);
    }

    @Override
    public void onCreateOptionsMenu(Menu options, MenuInflater inflater) {
        inflater.inflate(R.menu.gist_view, options);
    }

    @Override
    public void onPrepareOptionsMenu(Menu menu) {
        boolean owner = isOwner();
        if (!owner) {
            menu.removeItem(R.id.m_delete);
            MenuItem starItem = menu.findItem(R.id.m_star);
            starItem.setEnabled(loadFinished && !owner);
            if (starred)
                starItem.setTitle(R.string.unstar);
            else
                starItem.setTitle(R.string.star);
        } else
            menu.removeItem(R.id.m_star);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if (gist == null)
            return super.onOptionsItemSelected(item);

        switch (item.getItemId()) {
        case R.id.m_comment:
            startActivityForResult(CreateCommentActivity.createIntent(gist),
                    COMMENT_CREATE);
            return true;
        case R.id.m_star:
            if (starred)
                unstarGist();
            else
                starGist();
            return true;
        case R.id.m_refresh:
            refreshGist();
            return true;
        case R.id.m_share:
            shareGist();
            return true;
        default:
            return super.onOptionsItemSelected(item);
        }
    }

    private void starGist() {
        ToastUtils.show(getActivity(), R.string.starring_gist);

        new StarGistTask(getActivity(), gistId) {

            @Override
            protected void onSuccess(Gist gist) throws Exception {
                super.onSuccess(gist);

                starred = true;
            }

            @Override
            protected void onException(Exception e) throws RuntimeException {
                super.onException(e);

                ToastUtils.show((Activity) getContext(), e.getMessage());
            }

        }.execute();
    }

    private void shareGist() {
        StringBuilder subject = new StringBuilder("Gist ");
        String id = gist.getId();
        subject.append(id);
        User user = gist.getUser();
        if (user != null && !TextUtils.isEmpty(user.getLogin()))
            subject.append(" by ").append(user.getLogin());
        startActivity(ShareUtils.create(subject, "https://gist.github.com/"
                + id));
    }

    private void unstarGist() {
        ToastUtils.show(getActivity(), R.string.unstarring_gist);

        new UnstarGistTask(getActivity(), gistId) {

            @Override
            protected void onSuccess(Gist gist) throws Exception {
                super.onSuccess(gist);

                starred = false;
            }

            protected void onException(Exception e) throws RuntimeException {
                super.onException(e);

                ToastUtils.show((Activity) getContext(), e.getMessage());
            }

        }.execute();
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (RESULT_OK != resultCode || data == null)
            return;

        switch (requestCode) {
        case COMMENT_CREATE:
            Comment comment = (Comment) data
                    .getSerializableExtra(EXTRA_COMMENT);
            if (comments != null) {
                comments.add(comment);
                gist.setComments(gist.getComments() + 1);
                updateList(gist, comments);
            } else
                refreshGist();
            return;
        case COMMENT_EDIT:
            comment = (Comment) data.getSerializableExtra(EXTRA_COMMENT);
            if (comments != null && comment != null) {
                int position = Collections.binarySearch(comments, comment,
                        new Comparator<Comment>() {
                            public int compare(Comment lhs, Comment rhs) {
                                return Long.valueOf(lhs.getId()).compareTo(
                                        rhs.getId());
                            }
                        });
                imageGetter.removeFromCache(comment.getId());
                comments.set(position, comment);
                updateList(gist, comments);
            } else
                refreshGist();
            return;
        }

        super.onActivityResult(requestCode, resultCode, data);
    }

    private void updateFiles(Gist gist) {
        final Activity activity = getActivity();
        if (activity == null)
            return;

        for (View header : fileHeaders)
            adapter.removeHeader(header);
        fileHeaders.clear();

        Map<String, GistFile> files = gist.getFiles();
        if (files == null || files.isEmpty())
            return;

        final LayoutInflater inflater = activity.getLayoutInflater();
        final Typeface octicons = TypefaceUtils.getOcticons(activity);
        for (GistFile file : files.values()) {
            View fileView = inflater.inflate(R.layout.gist_file_item, null);
            ((TextView) fileView.findViewById(R.id.tv_file)).setText(file
                    .getFilename());
            ((TextView) fileView.findViewById(R.id.tv_file_icon))
                    .setTypeface(octicons);
            adapter.addHeader(fileView, file, true);
            fileHeaders.add(fileView);
        }
    }

    private void updateList(Gist gist, List<Comment> comments) {
        adapter.getWrappedAdapter().setItems(
                comments.toArray(new Comment[comments.size()]));
        adapter.removeHeader(loadingView);

        headerView.setVisibility(VISIBLE);
        updateHeader(gist);

        updateFiles(gist);
    }

    private void refreshGist() {
        new RefreshGistTask(getActivity(), gistId, imageGetter) {

            @Override
            protected void onException(Exception e) throws RuntimeException {
                super.onException(e);
                ToastUtils.show(getActivity(), e, R.string.error_gist_load);
            }

            @SuppressWarnings("unchecked")
            @Override
            protected void onSuccess(FullGist fullGist) throws Exception {
                super.onSuccess(fullGist);

                if (!isUsable())
                    return;

                FragmentActivity activity = getActivity();
                if (activity instanceof OnLoadListener)
                    ((OnLoadListener<Gist>) activity)
                            .loaded(fullGist.getGist());

                starred = fullGist.isStarred();
                loadFinished = true;
                gist = fullGist.getGist();
                comments = fullGist;
                updateList(fullGist.getGist(), fullGist);
            }

        }.execute();
    }

    @Override
    public void onItemClick(AdapterView<?> parent, View view, int position,
            long id) {
        Object item = parent.getItemAtPosition(position);
        if (item instanceof GistFile)
            startActivity(GistFilesViewActivity
                    .createIntent(gist, position - 1));
    }

    @Override
    public void onDialogResult(int requestCode, int resultCode, Bundle arguments) {
        if (RESULT_OK != resultCode)
            return;

        switch (requestCode) {
        case COMMENT_DELETE:
            final Comment comment = (Comment) arguments
                    .getSerializable(EXTRA_COMMENT);
            new DeleteCommentTask(getActivity(), gist.getId(), comment) {
                @Override
                protected void onSuccess(Comment comment) throws Exception {
                    super.onSuccess(comment);


                    if (comments != null && comment != null) {
                        int position = Collections.binarySearch(comments,
                                comment, new Comparator<Comment>() {
                                    public int compare(Comment lhs, Comment rhs) {
                                        return Long.valueOf(lhs.getId())
                                                .compareTo(rhs.getId());
                                    }
                                });
                        comments.remove(position);
                        updateList(gist, comments);
                    } else
                        refreshGist();
                }
            }.start();
            break;
        }
    }


    final EditCommentListener editCommentListener = new EditCommentListener() {
        public void onEditComment(Comment comment) {
            startActivityForResult(
                    EditCommentActivity.createIntent(gist, comment),
                    COMMENT_EDIT);
        }
    };


    final DeleteCommentListener deleteCommentListener = new DeleteCommentListener() {
        public void onDeleteComment(Comment comment) {
            Bundle args = new Bundle();
            args.putSerializable(EXTRA_COMMENT, comment);
            ConfirmDialogFragment.show(
                    getActivity(),
                    COMMENT_DELETE,
                    getActivity()
                            .getString(R.string.confirm_comment_delete_title),
                    getActivity().getString(
                            R.string.confirm_comment_delete_message), args);
        }
    };
}

<code block>

package com.github.mobile.ui.gist;

import static com.github.mobile.Intents.EXTRA_GIST_ID;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v7.app.ActionBarActivity;
import android.util.SparseArray;
import android.view.ViewGroup;

import com.github.mobile.ui.FragmentStatePagerAdapter;


public class GistsPagerAdapter extends FragmentStatePagerAdapter {

    private final String[] ids;

    private final SparseArray<GistFragment> fragments = new SparseArray<>();


    public GistsPagerAdapter(ActionBarActivity activity, String[] gistIds) {
        super(activity);

        this.ids = gistIds;
    }

    @Override
    public Fragment getItem(int position) {
        Fragment fragment = new GistFragment();
        Bundle args = new Bundle();
        args.putString(EXTRA_GIST_ID, ids[position]);
        fragment.setArguments(args);
        return fragment;
    }

    @Override
    public int getCount() {
        return ids.length;
    }

    @Override
    public void destroyItem(ViewGroup container, int position, Object object) {
        super.destroyItem(container, position, object);

        fragments.remove(position);
    }

    @Override
    public Object instantiateItem(ViewGroup container, int position) {
        Object fragment = super.instantiateItem(container, position);
        if (fragment instanceof GistFragment)
            fragments.put(position, (GistFragment) fragment);
        return fragment;
    }


    public GistsPagerAdapter onDialogResult(int position, int requestCode,
            int resultCode, Bundle arguments) {
        GistFragment fragment = fragments.get(position);
        if (fragment != null)
            fragment.onDialogResult(requestCode, resultCode, arguments);
        return this;
    }
}

<code block>

package com.github.mobile.ui.gist;

import com.github.mobile.core.ResourcePager;
import com.github.mobile.core.gist.GistPager;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.client.PageIterator;


public class StarredGistsFragment extends GistsFragment {

    @Override
    protected ResourcePager<Gist> createPager() {
        return new GistPager(store) {

            @Override
            public PageIterator<Gist> createIterator(int page, int size) {
                return service.pageStarredGists(page, size);
            }
        };
    }
}

<code block>

package com.github.mobile.ui.gist;

import static com.github.mobile.RequestCodes.GIST_CREATE;
import static com.github.mobile.RequestCodes.GIST_VIEW;
import android.content.Intent;
import android.os.Bundle;
import android.view.MenuItem;
import android.view.View;
import android.widget.ListView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.mobile.R;
import com.github.mobile.core.gist.GistStore;
import com.github.mobile.ui.PagedItemFragment;
import com.github.mobile.util.AvatarLoader;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.service.GistService;


public abstract class GistsFragment extends PagedItemFragment<Gist> {


    @Inject
    protected AvatarLoader avatars;


    @Inject
    protected GistService service;


    @Inject
    protected GistStore store;

    @Override
    public void onListItemClick(ListView l, View v, int position, long id) {
        startActivityForResult(GistsViewActivity.createIntent(items, position),
                GIST_VIEW);
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        setEmptyText(R.string.no_gists);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if (!isUsable())
            return false;
        switch (item.getItemId()) {
        case R.id.m_create:
            startActivityForResult(new Intent(getActivity(),
                    CreateGistActivity.class), GIST_CREATE);
            return true;
        default:
            return super.onOptionsItemSelected(item);
        }
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (requestCode == GIST_VIEW || requestCode == GIST_CREATE) {
            notifyDataSetChanged();
            forceRefresh();
            return;
        }

        super.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    protected int getErrorMessage(Exception exception) {
        return R.string.error_gists_load;
    }

    @Override
    protected int getLoadingMessage() {
        return R.string.loading_gists;
    }

    @Override
    protected SingleTypeAdapter<Gist> createAdapter(List<Gist> items) {
        return new GistListAdapter(avatars, getActivity(), items);
    }
}

<code block>

package com.github.mobile.ui.gist;

import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
import static android.content.Intent.FLAG_ACTIVITY_SINGLE_TOP;
import static com.github.mobile.Intents.EXTRA_GIST;
import static com.github.mobile.Intents.EXTRA_GIST_ID;
import static com.github.mobile.Intents.EXTRA_GIST_IDS;
import static com.github.mobile.Intents.EXTRA_POSITION;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.ActionBar;
import android.view.MenuItem;

import com.github.mobile.Intents.Builder;
import com.github.mobile.R;
import com.github.mobile.core.OnLoadListener;
import com.github.mobile.core.gist.GistStore;
import com.github.mobile.ui.ConfirmDialogFragment;
import com.github.mobile.ui.FragmentProvider;
import com.github.mobile.ui.MainActivity;
import com.github.mobile.ui.PagerActivity;
import com.github.mobile.ui.ViewPager;
import com.github.mobile.ui.user.UriLauncherActivity;
import com.github.mobile.util.AvatarLoader;
import com.google.inject.Inject;

import java.io.Serializable;
import java.util.List;

import org.eclipse.egit.github.core.Gist;


public class GistsViewActivity extends PagerActivity implements
    OnLoadListener<Gist> {

    private static final int REQUEST_CONFIRM_DELETE = 1;


    public static Intent createIntent(Gist gist) {
        return new Builder("gists.VIEW").gist(gist).add(EXTRA_POSITION, 0)
            .toIntent();
    }


    public static Intent createIntent(List<Gist> gists, int position) {
        String[] ids = new String[gists.size()];
        int index = 0;
        for (Gist gist : gists)
            ids[index++] = gist.getId();
        return new Builder("gists.VIEW")
            .add(EXTRA_GIST_IDS, (Serializable) ids)
            .add(EXTRA_POSITION, position).toIntent();
    }

    private ViewPager pager;

    private String[] gists;

    private Gist gist;

    private int initialPosition;

    @Inject
    private GistStore store;

    @Inject
    private AvatarLoader avatars;

    private GistsPagerAdapter adapter;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.pager);

        setSupportActionBar((android.support.v7.widget.Toolbar) findViewById(R.id.toolbar));

        gists = getStringArrayExtra(EXTRA_GIST_IDS);
        gist = getSerializableExtra(EXTRA_GIST);
        initialPosition = getIntExtra(EXTRA_POSITION);
        pager = finder.find(R.id.vp_pages);

        getSupportActionBar().setDisplayHomeAsUpEnabled(true);



        if (gists == null && gist != null) {
            if (gist.getCreatedAt() != null) {
                Gist stored = store.getGist(gist.getId());
                if (stored == null)
                    store.addGist(gist);
            }
            gists = new String[] { gist.getId() };
        }

        adapter = new GistsPagerAdapter(this, gists);
        pager.setAdapter(adapter);
        pager.setOnPageChangeListener(this);
        pager.scheduleSetItem(initialPosition, this);
        onPageSelected(initialPosition);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                finish();
                Intent intent = new Intent(this, MainActivity.class);
                intent.addFlags(FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_SINGLE_TOP);
                startActivity(intent);
                return true;
            case R.id.m_delete:
                String gistId = gists[pager.getCurrentItem()];
                Bundle args = new Bundle();
                args.putString(EXTRA_GIST_ID, gistId);
                ConfirmDialogFragment.show(this, REQUEST_CONFIRM_DELETE,
                    getString(R.string.confirm_gist_delete_title),
                    getString(R.string.confirm_gist_delete_message), args);
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    public void onDialogResult(int requestCode, int resultCode, Bundle arguments) {
        if (REQUEST_CONFIRM_DELETE == requestCode && RESULT_OK == resultCode) {
            final String gistId = arguments.getString(EXTRA_GIST_ID);
            new DeleteGistTask(this, gistId).start();
            return;
        }

        adapter.onDialogResult(pager.getCurrentItem(), requestCode, resultCode,
            arguments);

        super.onDialogResult(requestCode, resultCode, arguments);
    }

    @Override
    public void onPageSelected(int position) {
        super.onPageSelected(position);

        String gistId = gists[position];
        Gist gist = store.getGist(gistId);
        updateActionBar(gist, gistId);
    }

    @Override
    public void startActivity(Intent intent) {
        Intent converted = UriLauncherActivity.convert(intent);
        if (converted != null)
            super.startActivity(converted);
        else
            super.startActivity(intent);
    }

    @Override
    protected FragmentProvider getProvider() {
        return adapter;
    }

    private void updateActionBar(Gist gist, String gistId) {
        ActionBar actionBar = getSupportActionBar();
        if (gist == null) {
            actionBar.setSubtitle(null);
            actionBar.setLogo(null);
            actionBar.setIcon(R.drawable.app_icon);
        } else if (gist.getUser() != null) {
            avatars.bind(actionBar, gist.getUser());
            actionBar.setSubtitle(gist.getUser().getLogin());
        } else {
            actionBar.setSubtitle(R.string.anonymous);
            actionBar.setLogo(null);
            actionBar.setIcon(R.drawable.app_icon);
        }
        actionBar.setTitle(getString(R.string.gist_title) + gistId);
    }

    @Override
    public void loaded(Gist gist) {
        if (gists[pager.getCurrentItem()].equals(gist.getId()))
            updateActionBar(gist, gist.getId());
    }
}

<code block>

package com.github.mobile.ui.gist;

import android.content.res.Resources;
import android.support.v4.app.Fragment;

import com.github.mobile.R;
import com.github.mobile.ui.FragmentPagerAdapter;


public class GistQueriesPagerAdapter extends FragmentPagerAdapter {

    private final Resources resources;


    public GistQueriesPagerAdapter(Fragment fragment) {
        super(fragment);

        resources = fragment.getResources();
    }

    @Override
    public int getCount() {
        return 3;
    }

    @Override
    public Fragment getItem(int position) {
        switch (position) {
            case 0:
                return new MyGistsFragment();
            case 1:
                return new StarredGistsFragment();
            case 2:
                return new PublicGistsFragment();
            default:
                return null;
        }
    }

    @Override
    public CharSequence getPageTitle(int position) {
        switch (position) {
            case 0:
                return resources.getString(R.string.tab_mine);
            case 1:
                return resources.getString(R.string.tab_starred);
            case 2:
                return resources.getString(R.string.tab_all);
            default:
                return null;
        }
    }
}

<code block>

package com.github.mobile.ui.gist;

import android.accounts.Account;
import android.app.Activity;
import android.util.Log;

import com.github.mobile.R;
import com.github.mobile.ui.ProgressDialogTask;
import com.github.mobile.util.ToastUtils;
import com.google.inject.Inject;

import java.util.Collections;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.GistFile;
import org.eclipse.egit.github.core.service.GistService;


public class CreateGistTask extends ProgressDialogTask<Gist> {

    private static final String TAG = "CreateGistTask";

    @Inject
    private GistService service;

    private final String description;

    private final boolean isPublic;

    private final String name;

    private final String content;


    public CreateGistTask(Activity activity, String description,
            boolean isPublic, String name, String content) {
        super(activity);

        this.description = description;
        this.isPublic = isPublic;
        this.name = name;
        this.content = content;
    }

    @Override
    public Gist run(Account account) throws Exception {
        Gist gist = new Gist();
        gist.setDescription(description);
        gist.setPublic(isPublic);

        GistFile file = new GistFile();
        file.setContent(content);
        file.setFilename(name);
        gist.setFiles(Collections.singletonMap(name, file));

        return service.createGist(gist);
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception creating Gist", e);
        ToastUtils.show((Activity) getContext(), e.getMessage());
    }


    public void create() {
        showIndeterminate(R.string.creating_gist);

        execute();
    }
}

<code block>

package com.github.mobile.ui.gist;

import static com.github.mobile.Intents.EXTRA_GIST_FILE;
import static com.github.mobile.Intents.EXTRA_GIST_ID;
import static com.github.mobile.util.PreferenceUtils.WRAP;
import android.accounts.Account;
import android.app.Activity;
import android.content.SharedPreferences;
import android.content.SharedPreferences.OnSharedPreferenceChangeListener;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.webkit.WebView;

import com.github.mobile.R;
import com.github.mobile.accounts.AuthenticatedUserTask;
import com.github.mobile.core.gist.GistStore;
import com.github.mobile.ui.DialogFragment;
import com.github.mobile.util.PreferenceUtils;
import com.github.mobile.util.SourceEditor;
import com.github.mobile.util.ToastUtils;
import com.google.inject.Inject;

import java.io.IOException;
import java.util.Map;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.GistFile;


public class GistFileFragment extends DialogFragment implements
        OnSharedPreferenceChangeListener {

    private WebView webView;

    private String gistId;

    private GistFile file;

    private Gist gist;

    @Inject
    private GistStore store;

    private SourceEditor editor;

    private SharedPreferences codePrefs;

    private MenuItem wrapItem;

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);

        gistId = getStringExtra(EXTRA_GIST_ID);
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        file = (GistFile) getArguments().get(EXTRA_GIST_FILE);
        gist = store.getGist(gistId);
        if (gist == null)
            gist = new Gist().setId(gistId);

        codePrefs = PreferenceUtils.getCodePreferences(getActivity());
        codePrefs.registerOnSharedPreferenceChangeListener(this);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();

        codePrefs.unregisterOnSharedPreferenceChangeListener(this);
    }

    public void onDestroyView() {
        super.onDestroyView();
    }

    @Override
    public void onCreateOptionsMenu(Menu optionsMenu, MenuInflater inflater) {
        inflater.inflate(R.menu.code_view, optionsMenu);

        wrapItem = optionsMenu.findItem(R.id.m_wrap);
        updateWrapItem();
    }

    private void updateWrapItem() {
        if (wrapItem != null)
            if (codePrefs.getBoolean(WRAP, false))
                wrapItem.setTitle(R.string.disable_wrapping);
            else
                wrapItem.setTitle(R.string.enable_wrapping);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
        case R.id.m_wrap:
            if (editor.getWrap()) {
                item.setTitle(R.string.enable_wrapping);
                editor.setWrap(false);
            } else {
                item.setTitle(R.string.disable_wrapping);
                editor.setWrap(true);
            }
            PreferenceUtils.save(codePrefs.edit().putBoolean(WRAP,
                    editor.getWrap()));
            return true;
        default:
            return super.onOptionsItemSelected(item);
        }
    }

    private void loadSource() {
        new AuthenticatedUserTask<GistFile>(getActivity()) {

            @Override
            public GistFile run(Account account) throws Exception {
                gist = store.refreshGist(gistId);
                Map<String, GistFile> files = gist.getFiles();
                if (files == null)
                    throw new IOException();
                GistFile loadedFile = files.get(file.getFilename());
                if (loadedFile == null)
                    throw new IOException();
                return loadedFile;
            }

            @Override
            protected void onException(Exception e) throws RuntimeException {
                super.onException(e);

                ToastUtils.show(getActivity(), e, R.string.error_gist_file_load);
            }

            @Override
            protected void onSuccess(GistFile loadedFile) throws Exception {
                super.onSuccess(loadedFile);

                if (loadedFile == null)
                    return;

                file = loadedFile;
                getArguments().putSerializable(EXTRA_GIST_FILE, file);
                if (file.getContent() != null)
                    showSource();
            }

        }.execute();
    }

    private void showSource() {
        editor.setSource(file.getFilename(), file.getContent(), false);
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        return inflater.inflate(R.layout.gist_file_view, null);
    }

    @Override
    public void onViewCreated(View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        webView = finder.find(R.id.wv_code);

        editor = new SourceEditor(webView);
        editor.setWrap(PreferenceUtils.getCodePreferences(getActivity())
                .getBoolean(WRAP, false));

        if (file.getContent() != null)
            showSource();
        else
            loadSource();
    }

    @Override
    public void onSharedPreferenceChanged(SharedPreferences sharedPreferences,
            String key) {
        if (WRAP.equals(key)) {
            updateWrapItem();
            editor.setWrap(sharedPreferences.getBoolean(WRAP, false));
        }
    }
}

<code block>

package com.github.mobile.ui.gist;

import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
import static android.content.Intent.FLAG_ACTIVITY_SINGLE_TOP;
import static com.github.mobile.Intents.EXTRA_GIST_ID;
import static com.github.mobile.Intents.EXTRA_POSITION;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.ActionBar;
import android.view.MenuItem;
import android.widget.ProgressBar;

import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.mobile.Intents.Builder;
import com.github.mobile.R;
import com.github.mobile.core.gist.FullGist;
import com.github.mobile.core.gist.GistStore;
import com.github.mobile.core.gist.RefreshGistTask;
import com.github.mobile.ui.FragmentProvider;
import com.github.mobile.ui.PagerActivity;
import com.github.mobile.ui.ViewPager;
import com.github.mobile.util.AvatarLoader;
import com.github.mobile.util.HttpImageGetter;
import com.google.inject.Inject;
import com.viewpagerindicator.TitlePageIndicator;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.User;


public class GistFilesViewActivity extends PagerActivity {


    public static Intent createIntent(Gist gist, int position) {
        return new Builder("gist.files.VIEW").gist(gist.getId())
            .add(EXTRA_POSITION, position).toIntent();
    }

    private String gistId;

    private int initialPosition;

    private ViewPager pager;

    private ProgressBar loadingBar;

    private TitlePageIndicator indicator;

    private Gist gist;

    @Inject
    private GistStore store;

    @Inject
    private AvatarLoader avatars;

    @Inject
    private HttpImageGetter imageGetter;

    private GistFilesPagerAdapter adapter;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        gistId = getStringExtra(EXTRA_GIST_ID);
        initialPosition = getIntExtra(EXTRA_POSITION);

        setContentView(R.layout.pager_with_title);

        setSupportActionBar((android.support.v7.widget.Toolbar) findViewById(R.id.toolbar));

        pager = finder.find(R.id.vp_pages);
        loadingBar = finder.find(R.id.pb_loading);
        indicator = finder.find(R.id.tpi_header);

        if (initialPosition < 0)
            initialPosition = 0;

        getSupportActionBar().setTitle(getString(R.string.gist_title) + gistId);

        gist = store.getGist(gistId);
        if (gist != null)
            configurePager();
        else {
            ViewUtils.setGone(loadingBar, false);
            ViewUtils.setGone(pager, true);
            ViewUtils.setGone(indicator, true);
            new RefreshGistTask(this, gistId, imageGetter) {

                @Override
                protected void onSuccess(FullGist gist) throws Exception {
                    super.onSuccess(gist);

                    GistFilesViewActivity.this.gist = gist.getGist();
                    configurePager();
                }

            }.execute();
        }
    }

    private void configurePager() {
        ActionBar actionBar = getSupportActionBar();
        actionBar.setDisplayHomeAsUpEnabled(true);
        User author = gist.getUser();
        if (author != null) {
            actionBar.setSubtitle(author.getLogin());
            avatars.bind(actionBar, author);
        } else
            actionBar.setSubtitle(R.string.anonymous);

        ViewUtils.setGone(loadingBar, true);
        ViewUtils.setGone(pager, false);
        ViewUtils.setGone(indicator, false);

        adapter = new GistFilesPagerAdapter(this, gist);
        pager.setAdapter(adapter);
        indicator.setViewPager(pager);

        if (initialPosition < adapter.getCount()) {
            pager.scheduleSetItem(initialPosition);
            onPageSelected(initialPosition);
        }
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                if (gist != null) {
                    Intent intent = GistsViewActivity.createIntent(gist);
                    intent.addFlags(FLAG_ACTIVITY_CLEAR_TOP
                        | FLAG_ACTIVITY_SINGLE_TOP);
                    startActivity(intent);
                }
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    protected FragmentProvider getProvider() {
        return adapter;
    }
}

<code block>

package com.github.mobile.ui.gist;

import static com.github.mobile.Intents.EXTRA_GIST_FILE;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v7.app.ActionBarActivity;

import com.github.mobile.ui.FragmentPagerAdapter;

import java.util.Map;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.GistFile;


public class GistFilesPagerAdapter extends FragmentPagerAdapter {

    private final GistFile[] files;


    public GistFilesPagerAdapter(ActionBarActivity activity, Gist gist) {
        super(activity);

        Map<String, GistFile> gistFiles = gist.getFiles();
        if (gistFiles != null && !gistFiles.isEmpty())
            files = gistFiles.values().toArray(new GistFile[gistFiles.size()]);
        else
            files = new GistFile[0];
    }

    @Override
    public CharSequence getPageTitle(int position) {
        return files[position].getFilename();
    }

    @Override
    public Fragment getItem(final int position) {
        GistFile file = files[position];
        Fragment fragment = new GistFileFragment();
        Bundle args = new Bundle();
        args.putSerializable(EXTRA_GIST_FILE, file);
        fragment.setArguments(args);
        return fragment;
    }

    @Override
    public int getCount() {
        return files.length;
    }
}

<code block>

package com.github.mobile.ui.gist;

import com.github.mobile.core.ResourcePager;
import com.github.mobile.core.gist.GistPager;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.client.PageIterator;


public class PublicGistsFragment extends GistsFragment {

    @Override
    protected ResourcePager<Gist> createPager() {
        return new GistPager(store) {

            @Override
            public PageIterator<Gist> createIterator(int page, int size) {
                return service.pagePublicGists(page, size);
            }
        };
    }
}

<code block>

package com.github.mobile.ui.gist;

import static android.app.Activity.RESULT_OK;
import android.accounts.Account;
import android.app.Activity;
import android.util.Log;

import com.github.mobile.R;
import com.github.mobile.ui.ProgressDialogTask;
import com.github.mobile.util.ToastUtils;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.service.GistService;


public class DeleteGistTask extends ProgressDialogTask<Gist> {

    private static final String TAG = "DeleteGistTask";

    private final String id;

    @Inject
    private GistService service;


    public DeleteGistTask(final Activity context, final String gistId) {
        super(context);

        id = gistId;
    }


    public void start() {
        showIndeterminate(R.string.deleting_gist);

        execute();
    }

    @Override
    public Gist run(Account account) throws Exception {
        service.deleteGist(id);
        return null;
    }

    @Override
    protected void onSuccess(Gist gist) throws Exception {
        super.onSuccess(gist);

        Activity activity = (Activity) getContext();
        activity.setResult(RESULT_OK);
        activity.finish();
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception deleting Gist", e);
        ToastUtils.show((Activity) getContext(), e.getMessage());
    }
}

<code block>
package com.github.mobile.ui.gist;

import static com.github.mobile.util.TypefaceUtils.ICON_PERSON;
import static com.github.mobile.util.TypefaceUtils.ICON_STAR;
import static com.github.mobile.util.TypefaceUtils.ICON_TEAM;
import android.os.Bundle;
import android.support.annotation.Nullable;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;

import com.github.mobile.R;
import com.github.mobile.ui.TabPagerFragment;

public class GistsPagerFragment extends TabPagerFragment<GistQueriesPagerAdapter> {

    @Override
    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        configureTabPager();
    }

    private void randomGist() {
        new RandomGistTask(this.getActivity()).start();
    }

    @Override
    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
        inflater.inflate(R.menu.gists, menu);
        super.onCreateOptionsMenu(menu, inflater);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.m_random:
                randomGist();
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    protected GistQueriesPagerAdapter createAdapter() {
        return new GistQueriesPagerAdapter(this);
    }

    @Override
    protected String getIcon(int position) {
        switch (position) {
            case 0:
                return ICON_PERSON;
            case 1:
                return ICON_STAR;
            case 2:
                return ICON_TEAM;
            default:
                return super.getIcon(position);
        }
    }
}

<code block>

package com.github.mobile.ui.gist;

import static android.app.Activity.RESULT_OK;
import static com.github.mobile.RequestCodes.GIST_CREATE;
import static com.github.mobile.RequestCodes.GIST_VIEW;
import android.content.Intent;

import com.github.mobile.accounts.GitHubAccount;
import com.github.mobile.core.ResourcePager;
import com.github.mobile.core.gist.GistPager;
import com.google.inject.Inject;
import com.google.inject.Provider;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.client.PageIterator;


public class MyGistsFragment extends GistsFragment {

    @Inject
    private Provider<GitHubAccount> accountProvider;

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if ((requestCode == GIST_CREATE || requestCode == GIST_VIEW)
                && RESULT_OK == resultCode) {
            forceRefresh();
            return;
        }

        super.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    protected ResourcePager<Gist> createPager() {
        return new GistPager(store) {

            @Override
            public PageIterator<Gist> createIterator(int page, int size) {
                return service.pageGists(accountProvider.get().getUsername(),
                        page, size);
            }
        };
    }
}

<code block>

package com.github.mobile.ui.gist;

import static org.eclipse.egit.github.core.client.IGitHubConstants.SEGMENT_COMMENTS;
import static org.eclipse.egit.github.core.client.IGitHubConstants.SEGMENT_GISTS;
import android.accounts.Account;
import android.app.Activity;
import android.util.Log;

import com.github.mobile.R;
import com.github.mobile.ui.ProgressDialogTask;
import com.github.mobile.util.HtmlUtils;
import com.github.mobile.util.ToastUtils;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.service.GistService;


public class EditCommentTask extends ProgressDialogTask<Comment> {

    private static final String TAG = "EditCommentTask";

    @Inject
    private GistService service;

    private final Comment comment;

    private final String gistId;


    protected EditCommentTask(Activity activity, String gistId, Comment comment) {
        super(activity);

        this.gistId = gistId;
        this.comment = comment;
    }


    public EditCommentTask start() {
        showIndeterminate(R.string.editing_comment);
        execute();
        return this;
    }

    @Override
    public Comment run(Account account) throws Exception {
        Comment edited = editComment(gistId, comment);
        String formatted = HtmlUtils.format(edited.getBodyHtml()).toString();
        edited.setBodyHtml(formatted);
        return edited;

    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception editing comment on gist", e);

        ToastUtils.show((Activity) getContext(), e.getMessage());
    }


    private Comment editComment(String gistId, Comment comment)
            throws Exception {
        return service.getClient().post(SEGMENT_GISTS + '/' + gistId + SEGMENT_COMMENTS + '/' + comment.getId(), comment, Comment.class);
    }
}

<code block>

package com.github.mobile.ui.gist;

import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
import static android.content.Intent.FLAG_ACTIVITY_SINGLE_TOP;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.ActionBar;
import android.text.Editable;
import android.text.TextUtils;
import android.view.Menu;
import android.view.MenuItem;
import android.widget.CheckBox;
import android.widget.EditText;

import com.github.mobile.R;
import com.github.mobile.ui.BaseActivity;
import com.github.mobile.ui.MainActivity;
import com.github.mobile.ui.TextWatcherAdapter;
import com.github.mobile.util.ShareUtils;

import org.eclipse.egit.github.core.Gist;


public class CreateGistActivity extends BaseActivity {

    private EditText descriptionText;

    private EditText nameText;

    private EditText contentText;

    private CheckBox publicCheckBox;

    private MenuItem createItem;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.gist_create);

        setSupportActionBar((android.support.v7.widget.Toolbar) findViewById(R.id.toolbar));

        descriptionText = finder.find(R.id.et_gist_description);
        nameText = finder.find(R.id.et_gist_name);
        contentText = finder.find(R.id.et_gist_content);
        publicCheckBox = finder.find(R.id.cb_public);

        ActionBar actionBar = getSupportActionBar();
        actionBar.setTitle(R.string.new_gist);
        actionBar.setIcon(R.drawable.ic_github_gist_white_32dp);
        actionBar.setDisplayHomeAsUpEnabled(true);

        String text = ShareUtils.getBody(getIntent());
        if (!TextUtils.isEmpty(text))
            contentText.setText(text);

        String subject = ShareUtils.getSubject(getIntent());
        if (!TextUtils.isEmpty(subject))
            descriptionText.setText(subject);

        contentText.addTextChangedListener(new TextWatcherAdapter() {

            @Override
            public void afterTextChanged(Editable s) {
                updateCreateMenu(s);
            }
        });
        updateCreateMenu();
    }

    private void updateCreateMenu() {
        if (contentText != null)
            updateCreateMenu(contentText.getText());
    }

    private void updateCreateMenu(CharSequence text) {
        if (createItem != null)
            createItem.setEnabled(!TextUtils.isEmpty(text));
    }

    @Override
    public boolean onCreateOptionsMenu(Menu options) {
        getMenuInflater().inflate(R.menu.gist_create, options);
        createItem = options.findItem(R.id.m_apply);
        updateCreateMenu();
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.m_apply:
                createGist();
                return true;
            case android.R.id.home:
                finish();
                Intent intent = new Intent(this, MainActivity.class);
                intent.addFlags(FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_SINGLE_TOP);
                startActivity(intent);
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    private void createGist() {
        final boolean isPublic = publicCheckBox.isChecked();

        String enteredDescription = descriptionText.getText().toString().trim();
        final String description = enteredDescription.length() > 0 ? enteredDescription
            : getString(R.string.gist_description_hint);

        String enteredName = nameText.getText().toString().trim();
        final String name = enteredName.length() > 0 ? enteredName
            : getString(R.string.gist_file_name_hint);

        final String content = contentText.getText().toString();

        new CreateGistTask(this, description, isPublic, name, content) {

            @Override
            protected void onSuccess(Gist gist) throws Exception {
                super.onSuccess(gist);

                startActivity(GistsViewActivity.createIntent(gist));
                setResult(RESULT_OK);
                finish();
            }
        }.create();
    }
}

<code block>

package com.github.mobile.ui.gist;

import android.app.Activity;
import android.text.TextUtils;
import android.view.View;
import android.widget.TextView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.mobile.R;
import com.github.mobile.ui.StyledText;
import com.github.mobile.util.AvatarLoader;
import com.github.mobile.util.TypefaceUtils;

import java.util.Collection;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.User;


public class GistListAdapter extends SingleTypeAdapter<Gist> {

    private final AvatarLoader avatars;

    private String anonymous;


    public GistListAdapter(AvatarLoader avatars, Activity activity,
            Collection<Gist> elements) {
        super(activity, R.layout.gist_item);

        this.avatars = avatars;
        setItems(elements);
    }

    @Override
    public long getItemId(final int position) {
        final String id = getItem(position).getId();
        return !TextUtils.isEmpty(id) ? id.hashCode() : super
                .getItemId(position);
    }

    @Override
    protected int[] getChildViewIds() {
        return new int[] { R.id.tv_gist_id, R.id.tv_gist_title, R.id.tv_gist_author,
                R.id.tv_gist_comments, R.id.tv_gist_files, R.id.iv_avatar };
    }

    @Override
    protected View initialize(View view) {
        view = super.initialize(view);

        TypefaceUtils.setOcticons(
                (TextView) view.findViewById(R.id.tv_comment_icon),
                (TextView) view.findViewById(R.id.tv_file_icon));
        anonymous = view.getResources().getString(R.string.anonymous);
        return view;
    }

    @Override
    protected void update(int position, Gist gist) {
        setText(0, gist.getId());

        String description = gist.getDescription();
        if (!TextUtils.isEmpty(description))
            setText(1, description);
        else
            setText(1, R.string.no_description_given);

        User user = gist.getUser();
        avatars.bind(imageView(5), user);

        StyledText authorText = new StyledText();
        if (user != null)
            authorText.bold(user.getLogin());
        else
            authorText.bold(anonymous);
        authorText.append(' ');
        authorText.append(gist.getCreatedAt());
        setText(2, authorText);

        setNumber(3, gist.getComments());
        setNumber(4, gist.getFiles().size());
    }
}

<code block>

package com.github.mobile.ui.gist;

import static com.github.mobile.RequestCodes.GIST_VIEW;
import android.accounts.Account;
import android.app.Activity;
import android.util.Log;

import com.github.mobile.R;
import com.github.mobile.core.gist.GistStore;
import com.github.mobile.ui.ProgressDialogTask;
import com.github.mobile.util.ToastUtils;
import com.google.inject.Inject;

import java.util.Collection;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.client.PageIterator;
import org.eclipse.egit.github.core.service.GistService;


public class RandomGistTask extends ProgressDialogTask<Gist> {

    private static final String TAG = "RandomGistTask";

    @Inject
    private GistService service;

    @Inject
    private GistStore store;


    public RandomGistTask(final Activity context) {
        super(context);
    }


    public void start() {
        showIndeterminate(R.string.random_gist);

        execute();
    }

    @Override
    protected Gist run(Account account) throws Exception {
        PageIterator<Gist> pages = service.pagePublicGists(1);
        pages.next();
        int randomPage = 1 + (int) (Math.random() * ((pages.getLastPage() - 1) + 1));

        Collection<Gist> gists = service.pagePublicGists(randomPage, 1).next();


        if (gists.isEmpty()) {
            randomPage = 1 + (int) (Math.random() * ((pages.getLastPage() - 1) + 1));
            gists = service.pagePublicGists(randomPage, 1).next();
        }

        if (gists.isEmpty())
            throw new IllegalArgumentException(getContext().getString(
                    R.string.no_gists_found));

        return store.addGist(gists.iterator().next());
    }

    @Override
    protected void onSuccess(Gist gist) throws Exception {
        super.onSuccess(gist);

        ((Activity) getContext()).startActivityForResult(
                GistsViewActivity.createIntent(gist), GIST_VIEW);
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception opening random Gist", e);
        ToastUtils.show((Activity) getContext(), e.getMessage());
    }
}

<code block>

package com.github.mobile.ui.gist;

import static com.github.mobile.Intents.EXTRA_COMMENT;
import static com.github.mobile.Intents.EXTRA_GIST;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.ActionBar;

import com.github.mobile.Intents.Builder;
import com.github.mobile.R;
import com.github.mobile.ui.comment.CommentPreviewPagerAdapter;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.User;


public class EditCommentActivity extends
        com.github.mobile.ui.comment.CreateCommentActivity {


    public static Intent createIntent(Gist gist, Comment comment) {
        Builder builder = new Builder("gist.comment.edit.VIEW");
        builder.gist(gist);
        builder.add(EXTRA_COMMENT, comment);
        return builder.toIntent();
    }

    private Gist gist;


    private Comment comment;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        gist = getSerializableExtra(EXTRA_GIST);
        comment = getSerializableExtra(EXTRA_COMMENT);
        super.onCreate(savedInstanceState);

        ActionBar actionBar = getSupportActionBar();
        actionBar.setTitle(getString(R.string.gist_title) + gist.getId());
        User user = gist.getUser();
        if (user != null)
            actionBar.setSubtitle(user.getLogin());
        avatars.bind(actionBar, user);
    }

    @Override
    protected void createComment(String comment) {
        editComment(comment);
    }


    protected void editComment(String commentText) {
        comment.setBody(commentText);

        new EditCommentTask(this, gist.getId(), comment) {
            @Override
            protected void onSuccess(Comment comment) throws Exception {
                super.onSuccess(comment);

                finish(comment);
            }
        }.start();
    }

    @Override
    protected CommentPreviewPagerAdapter createAdapter() {
        CommentPreviewPagerAdapter commentPreviewPagerAdapter = new CommentPreviewPagerAdapter(this, null);
        commentPreviewPagerAdapter.setCommentText(comment != null ? comment.getBody() : null);
        return commentPreviewPagerAdapter;
    }
}

<code block>

package com.github.mobile.ui.gist;

import android.accounts.Account;
import android.app.Activity;
import android.util.Log;

import com.github.mobile.R;
import com.github.mobile.ui.ProgressDialogTask;
import com.github.mobile.util.HtmlUtils;
import com.github.mobile.util.ToastUtils;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.service.GistService;


public class CreateCommentTask extends ProgressDialogTask<Comment> {

    private static final String TAG = "CreateCommentTask";

    @Inject
    private GistService service;

    private final String id;

    private final String comment;


    protected CreateCommentTask(Activity activity, String gistId, String comment) {
        super(activity);

        this.id = gistId;
        this.comment = comment;
    }


    public CreateCommentTask start() {
        showIndeterminate(R.string.creating_comment);
        execute();
        return this;
    }

    @Override
    public Comment run(Account account) throws Exception {
        Comment created = service.createComment(id, comment);
        String formatted = HtmlUtils.format(created.getBodyHtml()).toString();
        created.setBodyHtml(formatted);
        return created;

    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception creating comment on gist", e);

        ToastUtils.show((Activity) getContext(), e.getMessage());
    }
}

<code block>
package com.github.mobile.ui.roboactivities;

import android.accounts.AccountAuthenticatorResponse;
import android.accounts.AccountManager;
import android.os.Bundle;
import android.support.v7.app.ActionBarActivity;


public class ActionBarAccountAuthenticatorActivity extends ActionBarActivity {
    private AccountAuthenticatorResponse mAccountAuthenticatorResponse = null;
    private Bundle mResultBundle = null;


    public final void setAccountAuthenticatorResult(Bundle result) {
        mResultBundle = result;
    }


    protected void onCreate(Bundle icicle) {
        super.onCreate(icicle);

        mAccountAuthenticatorResponse =
            getIntent().getParcelableExtra(AccountManager.KEY_ACCOUNT_AUTHENTICATOR_RESPONSE);

        if (mAccountAuthenticatorResponse != null) {
            mAccountAuthenticatorResponse.onRequestContinued();
        }
    }


    public void finish() {
        if (mAccountAuthenticatorResponse != null) {

            if (mResultBundle != null) {
                mAccountAuthenticatorResponse.onResult(mResultBundle);
            } else {
                mAccountAuthenticatorResponse.onError(AccountManager.ERROR_CODE_CANCELED,
                    "canceled");
            }
            mAccountAuthenticatorResponse = null;
        }
        super.finish();
    }
}
<code block>
package com.github.mobile.ui.roboactivities;

import android.accounts.AccountAuthenticatorActivity;
import android.content.Intent;
import android.content.res.Configuration;
import android.os.Bundle;

import com.google.inject.Key;

import java.util.HashMap;
import java.util.Map;

import roboguice.RoboGuice;
import roboguice.activity.event.OnActivityResultEvent;
import roboguice.activity.event.OnConfigurationChangedEvent;
import roboguice.activity.event.OnContentChangedEvent;
import roboguice.activity.event.OnCreateEvent;
import roboguice.activity.event.OnDestroyEvent;
import roboguice.activity.event.OnNewIntentEvent;
import roboguice.activity.event.OnPauseEvent;
import roboguice.activity.event.OnRestartEvent;
import roboguice.activity.event.OnResumeEvent;
import roboguice.activity.event.OnStartEvent;
import roboguice.activity.event.OnStopEvent;
import roboguice.event.EventManager;
import roboguice.inject.RoboInjector;
import roboguice.util.RoboContext;


public class RoboActionBarAccountAuthenticatorActivity extends ActionBarAccountAuthenticatorActivity implements RoboContext {
    protected EventManager eventManager;
    protected HashMap<Key<?>, Object> scopedObjects = new HashMap<>();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        final RoboInjector injector = RoboGuice.getInjector(this);
        eventManager = injector.getInstance(EventManager.class);
        injector.injectMembersWithoutViews(this);
        super.onCreate(savedInstanceState);
        eventManager.fire(new OnCreateEvent(savedInstanceState));
    }

    @Override
    protected void onRestart() {
        super.onRestart();
        eventManager.fire(new OnRestartEvent());
    }

    @Override
    protected void onStart() {
        super.onStart();
        eventManager.fire(new OnStartEvent());
    }

    @Override
    protected void onResume() {
        super.onResume();
        eventManager.fire(new OnResumeEvent());
    }

    @Override
    protected void onPause() {
        super.onPause();
        eventManager.fire(new OnPauseEvent());
    }

    @Override
    protected void onNewIntent( Intent intent ) {
        super.onNewIntent(intent);
        eventManager.fire(new OnNewIntentEvent());
    }

    @Override
    protected void onStop() {
        try {
            eventManager.fire(new OnStopEvent());
        } finally {
            super.onStop();
        }
    }

    @Override
    protected void onDestroy() {
        try {
            eventManager.fire(new OnDestroyEvent());
        } finally {
            try {
                RoboGuice.destroyInjector(this);
            } finally {
                super.onDestroy();
            }
        }
    }

    @Override
    public void onConfigurationChanged(Configuration newConfig) {
        final Configuration currentConfig = getResources().getConfiguration();
        super.onConfigurationChanged(newConfig);
        eventManager.fire(new OnConfigurationChangedEvent(currentConfig, newConfig));
    }

    @Override
    public void onSupportContentChanged() {
        super.onSupportContentChanged();
        RoboGuice.getInjector(this).injectViewMembers(this);
        eventManager.fire(new OnContentChangedEvent());
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        eventManager.fire(new OnActivityResultEvent(requestCode, resultCode, data));
    }

    @Override
    public Map<Key<?>, Object> getScopedObjectMap() {
        return scopedObjects;
    }
}

<code block>
package com.github.mobile.ui.roboactivities;

import roboguice.RoboGuice;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.view.View;


public abstract class RoboSupportFragment extends Fragment {

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        RoboGuice.getInjector(getActivity()).injectMembersWithoutViews(this);
    }

    @Override
    public void onViewCreated(View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        RoboGuice.getInjector(getActivity()).injectViewMembers(this);
    }
}

<code block>
package com.github.mobile.ui.roboactivities;

import android.content.Intent;
import android.content.res.Configuration;
import android.os.Bundle;
import android.support.v7.app.ActionBarActivity;

import com.google.inject.Key;

import java.util.HashMap;
import java.util.Map;

import roboguice.RoboGuice;
import roboguice.activity.event.OnActivityResultEvent;
import roboguice.activity.event.OnConfigurationChangedEvent;
import roboguice.activity.event.OnContentChangedEvent;
import roboguice.activity.event.OnCreateEvent;
import roboguice.activity.event.OnDestroyEvent;
import roboguice.activity.event.OnNewIntentEvent;
import roboguice.activity.event.OnPauseEvent;
import roboguice.activity.event.OnRestartEvent;
import roboguice.activity.event.OnResumeEvent;
import roboguice.activity.event.OnStartEvent;
import roboguice.activity.event.OnStopEvent;
import roboguice.event.EventManager;
import roboguice.inject.RoboInjector;
import roboguice.util.RoboContext;


public class RoboActionBarActivity extends ActionBarActivity implements RoboContext {

    protected EventManager eventManager;
    protected HashMap<Key<?>, Object> scopedObjects = new HashMap<>();

    @Override
    protected void onCreate( Bundle savedInstanceState ) {

        final RoboInjector injector = RoboGuice.getInjector(this);
        eventManager = injector.getInstance( EventManager.class );
        injector.injectMembersWithoutViews( this );
        super.onCreate( savedInstanceState );
        eventManager.fire( new OnCreateEvent( savedInstanceState ) );
    }

    @Override
    protected void onRestart() {

        super.onRestart();
        eventManager.fire( new OnRestartEvent() );
    }

    @Override
    protected void onStart() {

        super.onStart();
        eventManager.fire( new OnStartEvent() );
    }

    @Override
    protected void onResume() {

        super.onResume();
        eventManager.fire( new OnResumeEvent() );
    }

    @Override
    protected void onPause() {

        super.onPause();
        eventManager.fire( new OnPauseEvent() );
    }

    @Override
    protected void onNewIntent( Intent intent ) {

        super.onNewIntent( intent );
        eventManager.fire( new OnNewIntentEvent() );
    }

    @Override
    protected void onStop() {

        try {
            eventManager.fire( new OnStopEvent() );
        }
        finally {
            super.onStop();
        }
    }

    @Override
    protected void onDestroy() {

        try {
            eventManager.fire( new OnDestroyEvent() );
        }
        finally {
            try {
                RoboGuice.destroyInjector( this );
            }
            finally {
                super.onDestroy();
            }
        }
    }

    @Override
    public void onConfigurationChanged( Configuration newConfig ) {

        final Configuration currentConfig = getResources().getConfiguration();
        super.onConfigurationChanged( newConfig );
        eventManager.fire( new OnConfigurationChangedEvent( currentConfig, newConfig ) );
    }

    @Override
    public void onSupportContentChanged() {

        super.onSupportContentChanged();
        RoboGuice.getInjector( this ).injectViewMembers( this );
        eventManager.fire( new OnContentChangedEvent() );
    }

    @Override
    protected void onActivityResult( int requestCode, int resultCode, Intent data ) {

        super.onActivityResult( requestCode, resultCode, data );
        eventManager.fire( new OnActivityResultEvent( requestCode, resultCode, data ) );
    }

    @Override
    public Map<Key<?>, Object> getScopedObjectMap() {

        return scopedObjects;
    }
}

<code block>

package com.github.mobile.ui.repo;

import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
import static android.content.Intent.FLAG_ACTIVITY_SINGLE_TOP;
import static com.github.mobile.Intents.EXTRA_REPOSITORY;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.ActionBar;
import android.view.MenuItem;

import com.github.mobile.Intents;
import com.github.mobile.R;
import com.github.mobile.ui.DialogFragmentActivity;
import com.github.mobile.util.AvatarLoader;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;


public class RepositoryContributorsActivity extends DialogFragmentActivity {


    public static Intent createIntent(Repository repository) {
        return new Intents.Builder("repo.contributors.VIEW").repo(repository).toIntent();
    }

    private Repository repository;

    @Inject
    private AvatarLoader avatars;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.repo_contributors);

        repository = getSerializableExtra(EXTRA_REPOSITORY);

        setSupportActionBar((android.support.v7.widget.Toolbar) findViewById(R.id.toolbar));

        ActionBar actionBar = getSupportActionBar();
        actionBar.setTitle(repository.getName());
        actionBar.setSubtitle(R.string.contributors);
        actionBar.setDisplayHomeAsUpEnabled(true);

        User owner = repository.getOwner();
        avatars.bind(getSupportActionBar(), owner);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                Intent intent = RepositoryViewActivity.createIntent(repository);
                intent.addFlags(FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_SINGLE_TOP);
                startActivity(intent);
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }
}

<code block>

package com.github.mobile.ui.repo;

import static com.github.mobile.Intents.EXTRA_USER;
import static com.github.mobile.RequestCodes.REPOSITORY_VIEW;
import static com.github.mobile.ResultCodes.RESOURCE_CHANGED;
import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.widget.ListView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.mobile.R;
import com.github.mobile.core.ResourcePager;
import com.github.mobile.ui.PagedItemFragment;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.client.PageIterator;
import org.eclipse.egit.github.core.service.RepositoryService;


public class UserRepositoryListFragment extends PagedItemFragment<Repository> {

    @Inject
    private RepositoryService service;

    private User user;

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);

        user = getSerializableExtra(EXTRA_USER);
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        setEmptyText(R.string.no_repositories);
    }

    @Override
    protected ResourcePager<Repository> createPager() {
        return new ResourcePager<Repository>() {

            @Override
            protected Object getId(Repository resource) {
                return resource.getId();
            }

            @Override
            public PageIterator<Repository> createIterator(int page, int size) {
                return service.pageRepositories(user.getLogin(), page, size);
            }
        };
    }

    @Override
    protected int getLoadingMessage() {
        return R.string.loading_repositories;
    }

    @Override
    protected int getErrorMessage(Exception exception) {
        return R.string.error_repos_load;
    }

    @Override
    protected SingleTypeAdapter<Repository> createAdapter(List<Repository> items) {
        return new UserRepositoryListAdapter(getActivity().getLayoutInflater(),
                items.toArray(new Repository[items.size()]), user);
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (requestCode == REPOSITORY_VIEW && resultCode == RESOURCE_CHANGED) {
            forceRefresh();
            return;
        }

        super.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    public void onListItemClick(ListView list, View v, int position, long id) {
        Repository repo = (Repository) list.getItemAtPosition(position);
        startActivityForResult(RepositoryViewActivity.createIntent(repo),
                REPOSITORY_VIEW);
    }
}

<code block>

package com.github.mobile.ui.repo;

import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
import static android.content.Intent.FLAG_ACTIVITY_SINGLE_TOP;
import static com.github.mobile.Intents.EXTRA_REPOSITORY;
import static com.github.mobile.ResultCodes.RESOURCE_CHANGED;
import static com.github.mobile.ui.repo.RepositoryPagerAdapter.ITEM_CODE;
import static com.github.mobile.util.TypefaceUtils.ICON_CODE;
import static com.github.mobile.util.TypefaceUtils.ICON_COMMIT;
import static com.github.mobile.util.TypefaceUtils.ICON_ISSUE_OPEN;
import static com.github.mobile.util.TypefaceUtils.ICON_NEWS;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.support.v7.app.ActionBar;
import android.text.TextUtils;
import android.view.Menu;
import android.view.MenuItem;
import android.widget.ProgressBar;

import com.afollestad.materialdialogs.MaterialDialog;
import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.mobile.Intents.Builder;
import com.github.mobile.R;
import com.github.mobile.core.repo.DeleteRepositoryTask;
import com.github.mobile.core.repo.ForkRepositoryTask;
import com.github.mobile.core.repo.RefreshRepositoryTask;
import com.github.mobile.core.repo.RepositoryUtils;
import com.github.mobile.core.repo.StarRepositoryTask;
import com.github.mobile.core.repo.StarredRepositoryTask;
import com.github.mobile.core.repo.UnstarRepositoryTask;
import com.github.mobile.ui.TabPagerActivity;
import com.github.mobile.ui.user.UriLauncherActivity;
import com.github.mobile.ui.user.UserViewActivity;
import com.github.mobile.util.AvatarLoader;
import com.github.mobile.util.ShareUtils;
import com.github.mobile.util.ToastUtils;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.service.RepositoryService;
import org.eclipse.egit.github.core.service.UserService;


public class RepositoryViewActivity extends TabPagerActivity<RepositoryPagerAdapter> {
    public static final String TAG = "RepositoryViewActivity";

    @Inject
    private RepositoryService repositoryService;

    @Inject
    private UserService userService;


    public static Intent createIntent(Repository repository) {
        return new Builder("repo.VIEW").repo(repository).toIntent();
    }

    private Repository repository;

    @Inject
    private AvatarLoader avatars;

    private ProgressBar loadingBar;

    private boolean isStarred;

    private boolean starredStatusChecked;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        repository = getSerializableExtra(EXTRA_REPOSITORY);

        loadingBar = finder.find(R.id.progress_bar);

        User owner = repository.getOwner();

        ActionBar actionBar = getSupportActionBar();
        actionBar.setTitle(repository.getName());
        actionBar.setSubtitle(owner.getLogin());
        actionBar.setDisplayHomeAsUpEnabled(true);

        if (owner.getAvatarUrl() != null && RepositoryUtils.isComplete(repository))
            configurePager();
        else {
            avatars.bind(getSupportActionBar(), owner);
            ViewUtils.setGone(loadingBar, false);
            setGone(true);
            new RefreshRepositoryTask(this, repository) {

                @Override
                protected void onSuccess(Repository fullRepository) throws Exception {
                    super.onSuccess(fullRepository);

                    repository = fullRepository;
                    configurePager();
                }

                @Override
                protected void onException(Exception e) throws RuntimeException {
                    super.onException(e);

                    ToastUtils.show(RepositoryViewActivity.this, R.string.error_repo_load);
                    ViewUtils.setGone(loadingBar, true);
                }
            }.execute();
        }
    }

    @Override
    public boolean onCreateOptionsMenu(Menu optionsMenu) {
        getMenuInflater().inflate(R.menu.repository, optionsMenu);
        return super.onCreateOptionsMenu(optionsMenu);
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        MenuItem followItem = menu.findItem(R.id.m_star);

        followItem.setVisible(starredStatusChecked);
        followItem.setTitle(isStarred ? R.string.unstar : R.string.star);

        return super.onPrepareOptionsMenu(menu);
    }

    @Override
    public void onBackPressed() {
        if (adapter == null || pager.getCurrentItem() != ITEM_CODE || !adapter.onBackPressed())
            super.onBackPressed();
    }

    private void configurePager() {
        avatars.bind(getSupportActionBar(), repository.getOwner());
        configureTabPager();
        ViewUtils.setGone(loadingBar, true);
        setGone(false);
        checkStarredRepositoryStatus();
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.m_star:
                starRepository();
                return true;
            case R.id.m_fork:
                forkRepository();
                return true;
            case R.id.m_contributors:
                startActivity(RepositoryContributorsActivity.createIntent(repository));
                return true;
            case R.id.m_share:
                shareRepository();
                return true;
            case R.id.m_delete:
                deleteRepository();
                return true;
            case R.id.m_refresh:
                checkStarredRepositoryStatus();
                return super.onOptionsItemSelected(item);
            case android.R.id.home:
                finish();
                Intent intent = UserViewActivity.createIntent(repository.getOwner());
                intent.addFlags(FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_SINGLE_TOP);
                startActivity(intent);
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    public void onDialogResult(int requestCode, int resultCode, Bundle arguments) {
        adapter.onDialogResult(pager.getCurrentItem(), requestCode, resultCode, arguments);
    }

    @Override
    protected RepositoryPagerAdapter createAdapter() {
        return new RepositoryPagerAdapter(this, repository.isHasIssues());
    }

    @Override
    protected int getContentView() {
        return R.layout.tabbed_progress_pager;
    }

    @Override
    protected String getIcon(int position) {
        switch (position) {
            case 0:
                return ICON_NEWS;
            case 1:
                return ICON_CODE;
            case 2:
                return ICON_COMMIT;
            case 3:
                return ICON_ISSUE_OPEN;
            default:
                return super.getIcon(position);
        }
    }

    private void starRepository() {
        if (isStarred)
            new UnstarRepositoryTask(this, repository) {

                @Override
                protected void onSuccess(Void v) throws Exception {
                    super.onSuccess(v);

                    isStarred = !isStarred;
                    setResult(RESOURCE_CHANGED);
                }

                @Override
                protected void onException(Exception e) throws RuntimeException {
                    super.onException(e);

                    ToastUtils.show(RepositoryViewActivity.this, R.string.error_unstarring_repository);
                }
            }.start();
        else
            new StarRepositoryTask(this, repository) {

                @Override
                protected void onSuccess(Void v) throws Exception {
                    super.onSuccess(v);

                    isStarred = !isStarred;
                    setResult(RESOURCE_CHANGED);
                }

                @Override
                protected void onException(Exception e) throws RuntimeException {
                    super.onException(e);

                    ToastUtils.show(RepositoryViewActivity.this, R.string.error_starring_repository);
                }
            }.start();
    }

    private void checkStarredRepositoryStatus() {
        starredStatusChecked = false;
        new StarredRepositoryTask(this, repository) {

            @Override
            protected void onSuccess(Boolean watching) throws Exception {
                super.onSuccess(watching);

                isStarred = watching;
                starredStatusChecked = true;
                invalidateOptionsMenu();
            }
        }.execute();
    }

    private void shareRepository() {
        String repoUrl = repository.getHtmlUrl();
        if (TextUtils.isEmpty(repoUrl))
            repoUrl = "https://github.com/" + repository.generateId();
        Intent sharingIntent = ShareUtils.create(repository.generateId(), repoUrl);
        startActivity(sharingIntent);
    }

    private void forkRepository() {
        new ForkRepositoryTask(this, repository) {

            @Override
            protected void onSuccess(Repository e) throws Exception {
                super.onSuccess(e);

                if (e != null) {
                    UriLauncherActivity.launchUri(getContext(), Uri.parse(e.getHtmlUrl()));
                } else {
                    ToastUtils.show(RepositoryViewActivity.this, R.string.error_forking_repository);
                }
            }

            @Override
            protected void onException(Exception e) throws RuntimeException {
                super.onException(e);

                ToastUtils.show(RepositoryViewActivity.this, R.string.error_forking_repository);
            }
        }.start();
    }

    private void deleteRepository() {
        new MaterialDialog.Builder(this)
                .title(R.string.are_you_sure)
                .content(R.string.unexpected_bad_things)
                .positiveText(R.string.not_sure)
                .negativeText(R.string.delete_cap)
                .callback(new MaterialDialog.ButtonCallback() {
                    @Override
                    public void onPositive(MaterialDialog dialog) {
                        super.onPositive(dialog);
                        dialog.dismiss();
                    }

                    @Override
                    public void onNegative(MaterialDialog dialog) {
                        super.onNegative(dialog);
                        dialog.dismiss();

                        new DeleteRepositoryTask(RepositoryViewActivity.this, repository) {

                            @Override
                            protected void onSuccess(Void v) throws Exception {
                                super.onSuccess(v);
                                onBackPressed();
                                ToastUtils.show(RepositoryViewActivity.this, R.string.delete_successful);
                            }

                            @Override
                            protected void onException(Exception e) throws RuntimeException {
                                super.onException(e);

                                ToastUtils.show(RepositoryViewActivity.this, R.string.error_deleting_repository);
                            }
                        }.start();
                    }
                })
                .show();
    }
}

<code block>

package com.github.mobile.ui.repo;

import android.view.LayoutInflater;
import android.view.View;
import android.widget.TextView;

import com.github.mobile.R;
import com.github.mobile.ui.StyledText;
import com.github.mobile.util.TypefaceUtils;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;


public class UserRepositoryListAdapter extends
        RepositoryListAdapter<Repository> {

    private final String login;

    private int descriptionColor;


    public UserRepositoryListAdapter(LayoutInflater inflater,
            Repository[] elements, User user) {
        super(R.layout.user_repo_item, inflater, elements);

        login = user.getLogin();
    }

    @Override
    public long getItemId(final int position) {
        return getItem(position).getId();
    }

    @Override
    protected View initialize(View view) {
        view = super.initialize(view);

        TypefaceUtils.setOcticons(textView(view, 0),
                (TextView) view.findViewById(R.id.tv_forks_icon),
                (TextView) view.findViewById(R.id.tv_watchers_icon));
        descriptionColor = view.getResources().getColor(R.color.text_description);
        return view;
    }

    @Override
    protected int[] getChildViewIds() {
        return new int[] { R.id.tv_repo_icon, R.id.tv_repo_description,
                R.id.tv_language, R.id.tv_watchers, R.id.tv_forks, R.id.tv_repo_name };
    }

    @Override
    protected void update(int position, Repository repository) {
        StyledText name = new StyledText();
        if (!login.equals(repository.getOwner().getLogin()))
            name.foreground(repository.getOwner().getLogin(), descriptionColor)
                    .foreground('/', descriptionColor);
        name.bold(repository.getName());
        setText(5, name);

        updateDetails(repository.getDescription(), repository.getLanguage(),
                repository.getWatchers(), repository.getForks(),
                repository.isPrivate(), repository.isFork(),
                repository.getMirrorUrl());
    }
}

<code block>

package com.github.mobile.ui.repo;

import static com.github.mobile.util.TypefaceUtils.ICON_FORK;
import static com.github.mobile.util.TypefaceUtils.ICON_MIRROR_PRIVATE;
import static com.github.mobile.util.TypefaceUtils.ICON_MIRROR_PUBLIC;
import static com.github.mobile.util.TypefaceUtils.ICON_PRIVATE;
import static com.github.mobile.util.TypefaceUtils.ICON_PUBLIC;
import android.text.TextUtils;
import android.view.LayoutInflater;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.kevinsawicki.wishlist.ViewUtils;


public abstract class RepositoryListAdapter<V> extends SingleTypeAdapter<V> {


    public RepositoryListAdapter(int viewId, LayoutInflater inflater,
            Object[] elements) {
        super(inflater, viewId);

        setItems(elements);
    }


    protected void updateDetails(final String description,
            final String language, final int watchers, final int forks,
            final boolean isPrivate, final boolean isFork,
            final String mirrorUrl) {
        if (TextUtils.isEmpty(mirrorUrl))
            if (isPrivate)
                setText(0, ICON_PRIVATE);
            else if (isFork)
                setText(0, ICON_FORK);
            else
                setText(0, ICON_PUBLIC);
        else {
            if (isPrivate)
                setText(0, ICON_MIRROR_PRIVATE);
            else
                setText(0, ICON_MIRROR_PUBLIC);
        }

        if (!TextUtils.isEmpty(description))
            ViewUtils.setGone(setText(1, description), false);
        else
            setGone(1, true);

        if (!TextUtils.isEmpty(language))
            ViewUtils.setGone(setText(2, language), false);
        else
            setGone(2, true);

        setNumber(3, watchers);
        setNumber(4, forks);
    }
}

<code block>

package com.github.mobile.ui.repo;

import android.accounts.Account;
import android.app.Activity;
import android.util.Log;

import com.github.mobile.R;
import com.github.mobile.accounts.AuthenticatedUserLoader;
import com.github.mobile.core.user.UserComparator;
import com.github.mobile.persistence.AccountDataManager;
import com.github.mobile.util.ToastUtils;
import com.google.inject.Inject;
import com.google.inject.Provider;

import java.io.IOException;
import java.util.Collections;
import java.util.List;

import org.eclipse.egit.github.core.User;


public class OrganizationLoader extends AuthenticatedUserLoader<List<User>> {

    private static final String TAG = "OrganizationLoader";

    private final Provider<UserComparator> userComparatorProvider;

    private final AccountDataManager accountDataManager;


    @Inject
    public OrganizationLoader(Activity activity,
            AccountDataManager accountDataManager,
            Provider<UserComparator> userComparatorProvider) {
        super(activity);

        this.accountDataManager = accountDataManager;
        this.userComparatorProvider = userComparatorProvider;
    }

    @Override
    protected List<User> getAccountFailureData() {
        return Collections.emptyList();
    }

    @Override
    public List<User> load(final Account account) {
        List<User> orgs;
        try {
            orgs = accountDataManager.getOrgs(false);
        } catch (final IOException e) {
            Log.e(TAG, "Exception loading organizations", e);
            ToastUtils.show(activity, e, R.string.error_orgs_load);
            return Collections.emptyList();
        }
        Collections.sort(orgs, userComparatorProvider.get());
        return orgs;
    }
}

<code block>

package com.github.mobile.ui.repo;

import static com.github.mobile.Intents.EXTRA_REPOSITORY;
import android.app.Activity;
import android.os.Bundle;
import android.support.v4.content.Loader;
import android.view.View;
import android.widget.ListView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.mobile.R;
import com.github.mobile.ThrowableLoader;
import com.github.mobile.accounts.AccountUtils;
import com.github.mobile.core.user.RefreshUserTask;
import com.github.mobile.ui.ItemListFragment;
import com.github.mobile.ui.user.UserViewActivity;
import com.github.mobile.util.AvatarLoader;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.egit.github.core.Contributor;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.service.RepositoryService;


public class RepositoryContributorsFragment extends ItemListFragment<Contributor> {


    @Inject
    protected AvatarLoader avatars;


    @Inject
    protected RepositoryService service;

    private Repository repo;

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);

        repo = getSerializableExtra(EXTRA_REPOSITORY);
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        setEmptyText(R.string.no_contributors);
    }

    @Override
    public Loader<List<Contributor>> onCreateLoader(int id, Bundle args) {
        return new ThrowableLoader<List<Contributor>>(getActivity(), items) {

            @Override
            public List<Contributor> loadData() throws Exception {
                return service.getContributors(repo, false);
            }
        };
    }

    @Override
    protected SingleTypeAdapter<Contributor> createAdapter(List<Contributor> items) {
        return new ContributorListAdapter(getActivity(),
                items.toArray(new Contributor[items.size()]), avatars);
    }

    @Override
    public void onListItemClick(ListView l, View v, int position, long id) {
        final Contributor contributor = (Contributor) l.getItemAtPosition(position);
        new RefreshUserTask(getActivity(), contributor.getLogin()) {

            @Override
            protected void onSuccess(User user) throws Exception {
                super.onSuccess(user);

                if (!AccountUtils.isUser(getActivity(), user))
                    startActivity(UserViewActivity.createIntent(user));
            }
        }.execute();
    }

    @Override
    protected int getErrorMessage(Exception exception) {
        return R.string.error_contributors_load;
    }
}

<code block>

package com.github.mobile.ui.repo;

import static java.lang.String.CASE_INSENSITIVE_ORDER;
import android.content.Context;
import android.os.AsyncTask;

import com.github.mobile.RequestReader;
import com.github.mobile.RequestWriter;

import java.io.File;
import java.io.Serializable;
import java.util.Comparator;
import java.util.Iterator;
import java.util.LinkedHashSet;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;


public class RecentRepositories implements Comparator<Repository>, Serializable {


    public static final int MAX_SIZE = 5;

    private static final long serialVersionUID = 580345177644233739L;

    private static final int VERSION = 2;

    private static File getFile(final Context context, final User organization) {
        return new File(context.getFilesDir(), "recent-repos-"
                + organization.getId() + ".ser");
    }

    private LinkedHashSet<Long> ids;

    private final File file;

    private int id;


    public RecentRepositories(final Context context, final User organization) {
        file = getFile(context, organization);
        id = organization.getId();
    }

    private void load() {
        LinkedHashSet<Long> loaded = new RequestReader(file, VERSION).read();
        if (loaded == null)
            loaded = new LinkedHashSet<>();
        ids = loaded;
        trim();
    }

    private void trim() {
        Iterator<Long> iterator = ids.iterator();
        while (iterator.hasNext() && ids.size() > MAX_SIZE) {
            iterator.next();
            iterator.remove();
        }
    }


    public RecentRepositories add(final Repository repo) {
        return repo != null ? add(repo.getId()) : this;
    }


    public RecentRepositories add(final long id) {
        if (ids == null)
            load();
        ids.remove(id);
        ids.add(id);
        trim();
        return this;
    }


    public RecentRepositories remove(final Repository repo) {
        return repo != null ? remove(repo.getId()) : this;
    }


    public RecentRepositories remove(final long id) {
        if (ids == null)
            load();
        ids.remove(id);
        return this;
    }


    public RecentRepositories saveAsync() {
        if (ids != null)
            new AsyncTask<Void, Void, Void>() {

                @Override
                protected Void doInBackground(Void... params) {
                    save();
                    return null;
                }
            }.execute();
        return this;
    }


    public RecentRepositories save() {
        final LinkedHashSet<Long> save = ids;
        if (save != null)
            new RequestWriter(file, VERSION).write(save);
        return this;
    }


    public boolean contains(Repository repository) {
        return repository != null && contains(repository.getId());
    }


    public boolean contains(long id) {
        if (ids == null)
            load();
        return ids.contains(id);
    }

    @Override
    public int compare(final Repository lhs, final Repository rhs) {
        final boolean lRecent = contains(lhs);
        final boolean rRecent = contains(rhs);
        if (lRecent && !rRecent)
            return -1;
        if (!lRecent && rRecent)
            return 1;

        final int order = CASE_INSENSITIVE_ORDER.compare(lhs.getName(),
                rhs.getName());
        if (order == 0)
            if (id == lhs.getOwner().getId())
                return -1;
            else if (id == rhs.getOwner().getId())
                return 1;
            else
                return CASE_INSENSITIVE_ORDER.compare(
                        lhs.getOwner().getLogin(), rhs.getOwner().getLogin());
        else
            return order;
    }
}

<code block>

package com.github.mobile.ui.repo;

import android.content.Context;
import android.view.LayoutInflater;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.mobile.R;
import com.github.mobile.util.AvatarLoader;

import org.eclipse.egit.github.core.Contributor;


public class ContributorListAdapter extends SingleTypeAdapter<Contributor> {

    private final Context context;

    private final AvatarLoader avatars;


    public ContributorListAdapter(final Context context,
            final Contributor[] elements, final AvatarLoader avatars) {
        super(LayoutInflater.from(context), R.layout.contributor_item);

        this.context = context.getApplicationContext();
        this.avatars = avatars;
        setItems(elements);
    }

    @Override
    public long getItemId(final int position) {
        return getItem(position).getId();
    }

    @Override
    protected int[] getChildViewIds() {
        return new int[] { R.id.iv_avatar, R.id.tv_login, R.id.tv_contributions };
    }

    @Override
    protected void update(int position, Contributor contributor) {
        avatars.bind(imageView(0), contributor);
        setText(1, contributor.getLogin());
        setText(2, context.getString(R.string.contributions, contributor.getContributions()));
    }
}

<code block>

package com.github.mobile.ui.repo;

import android.content.res.Resources;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v7.app.ActionBarActivity;

import com.github.mobile.R;
import com.github.mobile.ui.FragmentPagerAdapter;
import com.github.mobile.ui.code.RepositoryCodeFragment;
import com.github.mobile.ui.commit.CommitListFragment;
import com.github.mobile.ui.issue.IssuesFragment;


public class RepositoryPagerAdapter extends FragmentPagerAdapter {


    public static final int ITEM_CODE = 1;


    public static final int ITEM_COMMITS = 2;

    private final Resources resources;

    private final boolean hasIssues;

    private RepositoryCodeFragment codeFragment;

    private CommitListFragment commitsFragment;


    public RepositoryPagerAdapter(ActionBarActivity activity,
            boolean hasIssues) {
        super(activity);

        resources = activity.getResources();
        this.hasIssues = hasIssues;
    }

    @Override
    public CharSequence getPageTitle(int position) {
        switch (position) {
        case 0:
            return resources.getString(R.string.tab_news);
        case 1:
            return resources.getString(R.string.tab_code);
        case 2:
            return resources.getString(R.string.tab_commits);
        case 3:
            return resources.getString(R.string.tab_issues);
        default:
            return null;
        }
    }

    @Override
    public Fragment getItem(int position) {
        switch (position) {
        case 0:
            return new RepositoryNewsFragment();
        case 1:
            codeFragment = new RepositoryCodeFragment();
            return codeFragment;
        case 2:
            commitsFragment = new CommitListFragment();
            return commitsFragment;
        case 3:
            return new IssuesFragment();
        default:
            return null;
        }
    }

    @Override
    public int getCount() {
        return hasIssues ? 4 : 3;
    }


    public boolean onBackPressed() {
        return codeFragment != null && codeFragment.onBackPressed();
    }


    public RepositoryPagerAdapter onDialogResult(int position, int requestCode,
            int resultCode, Bundle arguments) {
        if (position == ITEM_CODE && codeFragment != null)
            codeFragment.onDialogResult(requestCode, resultCode, arguments);
        else if (position == ITEM_COMMITS && commitsFragment != null)
            commitsFragment.onDialogResult(requestCode, resultCode, arguments);

        return this;
    }
}

<code block>

package com.github.mobile.ui.repo;

import static com.github.mobile.Intents.EXTRA_USER;
import static com.github.mobile.RequestCodes.REPOSITORY_VIEW;
import static com.github.mobile.ResultCodes.RESOURCE_CHANGED;
import static java.util.Locale.US;
import android.app.Activity;
import android.app.AlertDialog;
import android.content.Intent;
import android.os.Bundle;
import android.support.v4.content.Loader;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.ListView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.kevinsawicki.wishlist.ViewFinder;
import com.github.mobile.R;
import com.github.mobile.ThrowableLoader;
import com.github.mobile.persistence.AccountDataManager;
import com.github.mobile.ui.HeaderFooterListAdapter;
import com.github.mobile.ui.ItemListFragment;
import com.github.mobile.ui.LightAlertDialog;
import com.github.mobile.ui.user.OrganizationSelectionListener;
import com.github.mobile.ui.user.OrganizationSelectionProvider;
import com.github.mobile.ui.user.UserViewActivity;
import com.github.mobile.util.AvatarLoader;
import com.google.inject.Inject;

import java.util.Collections;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;


public class RepositoryListFragment extends ItemListFragment<Repository>
    implements OrganizationSelectionListener {

    @Inject
    private AccountDataManager cache;

    @Inject
    private AvatarLoader avatars;

    private final AtomicReference<User> org = new AtomicReference<>();

    private RecentRepositories recentRepos;

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);

        User org = this.org.get();
        if (org != null)
            outState.putSerializable(EXTRA_USER, org);
    }

    @Override
    protected void configureList(Activity activity, ListView listView) {
        super.configureList(activity, listView);

        listView.setDividerHeight(0);
        updateHeaders(items);
    }

    @Override
    public void onDetach() {
        if (getActivity() != null && getActivity() instanceof OrganizationSelectionProvider) {
            OrganizationSelectionProvider selectionProvider = (OrganizationSelectionProvider) getActivity();
            selectionProvider.removeListener(this);
        }

        super.onDetach();
    }

    @Override
    public void onOrganizationSelected(final User organization) {
        User previousOrg = org.get();
        int previousOrgId = previousOrg != null ? previousOrg.getId() : -1;
        org.set(organization);

        if (recentRepos != null)
            recentRepos.saveAsync();


        if (previousOrgId != organization.getId()) {
            Activity activity = getActivity();
            if (activity != null)
                recentRepos = new RecentRepositories(activity, organization);

            refreshWithProgress();
        }
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        Activity activity = getActivity();
        User currentOrg = null;

        if (getActivity() instanceof OrganizationSelectionProvider)
            currentOrg = ((OrganizationSelectionProvider) activity)
                .addListener(this);

        if (getArguments() != null && getArguments().containsKey("org"))
            currentOrg = (User) getArguments().getSerializable("org");

        if (currentOrg == null && savedInstanceState != null)
            currentOrg = (User) savedInstanceState.getSerializable(EXTRA_USER);
        org.set(currentOrg);
        if (currentOrg != null)
            recentRepos = new RecentRepositories(activity, currentOrg);

        setEmptyText(R.string.no_repositories);

        super.onActivityCreated(savedInstanceState);
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {

        if (requestCode == REPOSITORY_VIEW && resultCode == RESOURCE_CHANGED) {
            forceRefresh();
            return;
        }

        super.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    public void onListItemClick(ListView list, View v, int position, long id) {
        Repository repo = (Repository) list.getItemAtPosition(position);
        if (recentRepos != null)
            recentRepos.add(repo);

        startActivityForResult(RepositoryViewActivity.createIntent(repo),
            REPOSITORY_VIEW);
    }

    @Override
    public boolean onListItemLongClick(ListView list, View v, int position,
        long itemId) {
        if (!isUsable())
            return false;

        final Repository repo = (Repository) list.getItemAtPosition(position);
        if (repo == null)
            return false;

        final AlertDialog dialog = LightAlertDialog.create(getActivity());
        dialog.setCanceledOnTouchOutside(true);

        dialog.setTitle(repo.generateId());

        View view = getActivity().getLayoutInflater().inflate(
            R.layout.repo_dialog, null);
        ViewFinder finder = new ViewFinder(view);

        final User owner = repo.getOwner();
        avatars.bind(finder.imageView(R.id.iv_owner_avatar), owner);
        finder.setText(R.id.tv_owner_name, getString(R.string.navigate_to_user, owner.getLogin()));
        finder.onClick(R.id.ll_owner_area, new OnClickListener() {

            public void onClick(View v) {
                dialog.dismiss();

                viewUser(owner);
            }
        });

        if ((recentRepos != null) && (recentRepos.contains(repo))) {
            finder.find(R.id.divider).setVisibility(View.VISIBLE);
            finder.find(R.id.ll_recent_repo_area).setVisibility(View.VISIBLE);
            finder.onClick(R.id.ll_recent_repo_area, new OnClickListener() {

                public void onClick(View v) {
                    dialog.dismiss();

                    recentRepos.remove(repo);
                    refresh();
                }
            });
        }

        dialog.setView(view);
        dialog.show();

        return true;
    }

    private void viewUser(User user) {
        if (org.get().getId() != user.getId())
            startActivity(UserViewActivity.createIntent(user));
    }

    @Override
    public void onStop() {
        super.onStop();

        if (recentRepos != null)
            recentRepos.saveAsync();
    }

    private void updateHeaders(final List<Repository> repos) {
        HeaderFooterListAdapter<?> rootAdapter = getListAdapter();
        if (rootAdapter == null)
            return;

        DefaultRepositoryListAdapter adapter = (DefaultRepositoryListAdapter) rootAdapter
            .getWrappedAdapter();
        adapter.clearHeaders();

        if (repos.isEmpty())
            return;


        Repository first = repos.get(0);
        if (recentRepos.contains(first))
            adapter.registerHeader(first, getString(R.string.recently_viewed));


        int index;
        Repository current = null;
        for (index = 0; index < repos.size(); index++) {
            Repository repository = repos.get(index);
            if (recentRepos.contains(repository.getId()))
                current = repository;
            else
                break;
        }

        if (index >= repos.size())
            return;

        if (current != null)
            adapter.registerNoSeparator(current);


        current = repos.get(index);
        char start = Character.toLowerCase(current.getName().charAt(0));
        adapter.registerHeader(current,
            Character.toString(start).toUpperCase(US));

        char previousHeader = start;
        for (index = index + 1; index < repos.size(); index++) {
            current = repos.get(index);
            char repoStart = Character.toLowerCase(current.getName().charAt(0));
            if (repoStart <= start)
                continue;



            if (previousHeader != repoStart)
                adapter.registerNoSeparator(repos.get(index - 1));

            adapter.registerHeader(current, Character.toString(repoStart)
                .toUpperCase(US));
            previousHeader = repoStart;
            start = repoStart++;
        }


        adapter.registerNoSeparator(repos.get(repos.size() - 1));
    }

    @Override
    public Loader<List<Repository>> onCreateLoader(int id, final Bundle args) {
        return new ThrowableLoader<List<Repository>>(getActivity(), items) {

            @Override
            public List<Repository> loadData() throws Exception {
                User org = RepositoryListFragment.this.org.get();
                if (org == null)
                    return Collections.emptyList();

                List<Repository> repos = cache.getRepos(org,
                    isForceRefresh(args));
                Collections.sort(repos, recentRepos);
                updateHeaders(repos);
                return repos;
            }
        };
    }

    @Override
    protected SingleTypeAdapter<Repository> createAdapter(List<Repository> items) {
        return new DefaultRepositoryListAdapter(getActivity()
            .getLayoutInflater(),
            items.toArray(new Repository[items.size()]), org);
    }

    @Override
    protected int getErrorMessage(Exception exception) {
        return R.string.error_repos_load;
    }
}

<code block>

package com.github.mobile.ui.repo;

import static com.github.mobile.Intents.EXTRA_REPOSITORY;
import android.app.Activity;

import com.github.mobile.core.ResourcePager;
import com.github.mobile.core.user.UserEventMatcher.UserPair;
import com.github.mobile.ui.NewsFragment;
import com.github.mobile.ui.issue.IssuesViewActivity;
import com.github.mobile.ui.user.EventPager;
import com.github.mobile.ui.user.UserViewActivity;

import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.client.PageIterator;
import org.eclipse.egit.github.core.event.Event;


public class RepositoryNewsFragment extends NewsFragment {

    private Repository repo;

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);

        repo = getSerializableExtra(EXTRA_REPOSITORY);
    }

    @Override
    protected ResourcePager<Event> createPager() {
        return new EventPager() {

            @Override
            public PageIterator<Event> createIterator(int page, int size) {
                return service.pageEvents(repo, page, size);
            }
        };
    }


    @Override
    protected void viewRepository(Repository repository) {
        if (!repo.generateId().equals(repository.generateId()))
            super.viewRepository(repository);
    }

    @Override
    protected void viewIssue(Issue issue, Repository repository) {
        startActivity(IssuesViewActivity.createIntent(issue, repo));
    }

    @Override
    protected boolean viewUser(User user) {
        if (repo.getOwner().getId() != user.getId()) {
            startActivity(UserViewActivity.createIntent(user));
            return true;
        }
        return false;
    }

    @Override
    protected void viewUser(UserPair users) {
        if (!viewUser(users.from))
            viewUser(users.to);
    }
}

<code block>

package com.github.mobile.ui.repo;

import android.view.LayoutInflater;
import android.view.View;
import android.widget.TextView;

import com.github.mobile.R;
import com.github.mobile.ui.StyledText;
import com.github.mobile.util.TypefaceUtils;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicReference;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;


public class DefaultRepositoryListAdapter extends
        RepositoryListAdapter<Repository> {

    private int descriptionColor;

    private final AtomicReference<User> account;

    private final Map<Long, String> headers = new HashMap<>();

    private final Set<Long> noSeparators = new HashSet<>();


    public DefaultRepositoryListAdapter(LayoutInflater inflater,
            Repository[] elements, AtomicReference<User> account) {
        super(R.layout.repo_item, inflater, elements);

        this.account = account;
    }


    public DefaultRepositoryListAdapter clearHeaders() {
        headers.clear();
        noSeparators.clear();
        return this;
    }


    public DefaultRepositoryListAdapter registerHeader(Repository repository,
            String text) {
        headers.put(repository.getId(), text);
        return this;
    }


    public DefaultRepositoryListAdapter registerNoSeparator(
            Repository repository) {
        noSeparators.add(repository.getId());
        return this;
    }

    @Override
    protected View initialize(View view) {
        view = super.initialize(view);

        TypefaceUtils.setOcticons(textView(view, 0),
                (TextView) view.findViewById(R.id.tv_forks_icon),
                (TextView) view.findViewById(R.id.tv_watchers_icon));
        descriptionColor = view.getResources().getColor(R.color.text_description);
        return view;
    }

    @Override
    protected int[] getChildViewIds() {
        return new int[] { R.id.tv_repo_icon, R.id.tv_repo_description,
                R.id.tv_language, R.id.tv_watchers, R.id.tv_forks, R.id.ll_header,
                R.id.tv_header, R.id.v_separator, R.id.tv_repo_name };
    }

    @Override
    protected void update(int position, Repository repository) {
        String headerValue = headers.get(repository.getId());
        if (headerValue != null) {
            setGone(5, false);
            setText(6, headerValue);
        } else
            setGone(5, true);

        setGone(7, noSeparators.contains(repository.getId()));

        StyledText name = new StyledText();
        if (!account.get().getLogin().equals(repository.getOwner().getLogin()))
            name.foreground(repository.getOwner().getLogin(), descriptionColor)
                    .foreground('/', descriptionColor);
        name.bold(repository.getName());
        setText(8, name);

        updateDetails(repository.getDescription(), repository.getLanguage(),
                repository.getWatchers(), repository.getForks(),
                repository.isPrivate(), repository.isFork(),
                repository.getMirrorUrl());
    }
}

<code block>

package com.github.mobile.ui.code;

import static android.app.Activity.RESULT_OK;
import static com.github.mobile.Intents.EXTRA_REPOSITORY;
import static com.github.mobile.RequestCodes.REF_UPDATE;
import android.app.Activity;
import android.os.Bundle;
import android.text.method.LinkMovementMethod;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ListView;
import android.widget.ProgressBar;
import android.widget.TextView;

import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.mobile.R;
import com.github.mobile.core.code.FullTree;
import com.github.mobile.core.code.FullTree.Entry;
import com.github.mobile.core.code.FullTree.Folder;
import com.github.mobile.core.code.RefreshTreeTask;
import com.github.mobile.core.ref.RefUtils;
import com.github.mobile.ui.DialogFragment;
import com.github.mobile.ui.DialogFragmentActivity;
import com.github.mobile.ui.HeaderFooterListAdapter;
import com.github.mobile.ui.StyledText;
import com.github.mobile.ui.ref.BranchFileViewActivity;
import com.github.mobile.ui.ref.CodeTreeAdapter;
import com.github.mobile.ui.ref.RefDialog;
import com.github.mobile.ui.ref.RefDialogFragment;
import com.github.mobile.util.ToastUtils;
import com.github.mobile.util.TypefaceUtils;
import com.google.inject.Inject;

import java.util.LinkedList;

import org.eclipse.egit.github.core.Reference;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.service.DataService;


public class RepositoryCodeFragment extends DialogFragment implements
        OnItemClickListener {

    private FullTree tree;

    private ListView listView;

    private ProgressBar progressView;

    private TextView branchIconView;

    private TextView branchView;

    private TextView pathView;

    private View pathHeaderView;

    private View branchFooterView;

    private HeaderFooterListAdapter<CodeTreeAdapter> adapter;

    private boolean pathShowing;

    private Folder folder;

    private Repository repository;

    @Inject
    private DataService service;

    private RefDialog dialog;

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);

        repository = getSerializableExtra(EXTRA_REPOSITORY);
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        if (tree == null || folder == null)
            refreshTree(null);
        else
            setFolder(tree, folder);
    }

    @Override
    public void onCreateOptionsMenu(Menu optionsMenu, MenuInflater inflater) {
        inflater.inflate(R.menu.refresh, optionsMenu);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
        case R.id.m_refresh:
            if (tree != null)
                refreshTree(new Reference().setRef(tree.reference.getRef()));
            else
                refreshTree(null);
            return true;
        default:
            return super.onOptionsItemSelected(item);
        }
    }

    private void showLoading(final boolean loading) {
        ViewUtils.setGone(progressView, !loading);
        ViewUtils.setGone(listView, loading);
        ViewUtils.setGone(branchFooterView, loading);
    }

    private void refreshTree(final Reference reference) {
        showLoading(true);
        new RefreshTreeTask(repository, reference, getActivity()) {

            @Override
            protected void onSuccess(final FullTree fullTree) throws Exception {
                super.onSuccess(fullTree);

                if (folder == null || folder.parent == null)
                    setFolder(fullTree, fullTree.root);
                else {

                    Folder current = folder;
                    LinkedList<Folder> stack = new LinkedList<>();
                    while (current != null && current.parent != null) {
                        stack.addFirst(current);
                        current = current.parent;
                    }
                    Folder refreshed = fullTree.root;
                    while (!stack.isEmpty()) {
                        refreshed = refreshed.folders
                                .get(stack.removeFirst().name);
                        if (refreshed == null)
                            break;
                    }
                    if (refreshed != null)
                        setFolder(fullTree, refreshed);
                    else
                        setFolder(fullTree, fullTree.root);
                }
            }

            @Override
            protected void onException(Exception e) throws RuntimeException {
                super.onException(e);

                showLoading(false);
                ToastUtils.show(getActivity(), e, R.string.error_code_load);
            }

        }.execute();
    }

    private void switchBranches() {
        if (tree == null)
            return;

        if (dialog == null)
            dialog = new RefDialog((DialogFragmentActivity) getActivity(),
                    REF_UPDATE, repository, service);
        dialog.show(tree.reference);
    }

    @Override
    public void onDialogResult(int requestCode, int resultCode, Bundle arguments) {
        if (RESULT_OK != resultCode)
            return;

        switch (requestCode) {
        case REF_UPDATE:
            refreshTree(RefDialogFragment.getSelected(arguments));
            break;
        }
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        return inflater.inflate(R.layout.repo_code, null);
    }

    @Override
    public void onViewCreated(View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        progressView = finder.find(R.id.pb_loading);
        listView = finder.find(android.R.id.list);
        listView.setOnItemClickListener(this);

        Activity activity = getActivity();
        adapter = new HeaderFooterListAdapter<>(listView,
                new CodeTreeAdapter(activity));

        branchFooterView = finder.find(R.id.rl_branch);
        branchView = finder.find(R.id.tv_branch);
        branchIconView = finder.find(R.id.tv_branch_icon);
        branchFooterView.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                switchBranches();
            }
        });

        pathHeaderView = activity.getLayoutInflater().inflate(R.layout.path_item,
                null);
        pathView = (TextView) pathHeaderView.findViewById(R.id.tv_path);
        pathView.setMovementMethod(LinkMovementMethod.getInstance());
        if (pathShowing)
            adapter.addHeader(pathHeaderView);

        TypefaceUtils.setOcticons(branchIconView,
                (TextView) pathHeaderView.findViewById(R.id.tv_folder_icon));
        listView.setAdapter(adapter);
    }


    public boolean onBackPressed() {
        if (folder != null && folder.parent != null) {
            setFolder(tree, folder.parent);
            return true;
        } else
            return false;
    }

    private void setFolder(final FullTree tree, final Folder folder) {
        this.folder = folder;
        this.tree = tree;

        showLoading(false);

        branchView.setText(tree.branch);
        if (RefUtils.isTag(tree.reference))
            branchIconView.setText(R.string.icon_tag);
        else
            branchIconView.setText(R.string.icon_fork);

        adapter.getWrappedAdapter().setIndented(folder.entry != null);

        if (folder.entry != null) {
            int textLightColor = getResources().getColor(R.color.text_light);
            final String[] segments = folder.entry.getPath().split("/");
            StyledText text = new StyledText();
            for (int i = 0; i < segments.length - 1; i++) {
                final int index = i;
                text.url(segments[i], new OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        Folder clicked = folder;
                        for (int i = index; i < segments.length - 1; i++) {
                            clicked = clicked.parent;
                            if (clicked == null)
                                return;
                        }
                        setFolder(tree, clicked);
                    }
                }).append(' ').foreground('/', textLightColor).append(' ');
            }
            text.bold(segments[segments.length - 1]);
            pathView.setText(text);
            if (!pathShowing) {
                adapter.addHeader(pathHeaderView);
                pathShowing = true;
            }
        } else if (pathShowing) {
            adapter.removeHeader(pathHeaderView);
            pathShowing = false;
        }

        adapter.getWrappedAdapter().setItems(folder);
        listView.setSelection(0);
    }

    @Override
    public void onItemClick(AdapterView<?> parent, View view, int position,
            long id) {
        Entry entry = (Entry) parent.getItemAtPosition(position);
        if (tree == null || entry == null)
            return;

        if (entry instanceof Folder)
            setFolder(tree, (Folder) entry);
        else
            startActivity(BranchFileViewActivity.createIntent(repository,
                    tree.branch, entry.entry.getPath(), entry.entry.getSha()));
    }
}

<code block>

package com.github.pockethub.tests;

import com.github.pockethub.ui.issue.FiltersViewActivity;


public class FiltersViewActivityTest extends ActivityTest<FiltersViewActivity> {


    public FiltersViewActivityTest() {
        super(FiltersViewActivity.class);
    }
}

<code block>

package com.github.pockethub.tests;

import static org.eclipse.egit.github.core.event.Event.TYPE_COMMIT_COMMENT;
import static org.eclipse.egit.github.core.event.Event.TYPE_CREATE;
import static org.eclipse.egit.github.core.event.Event.TYPE_DELETE;
import static org.eclipse.egit.github.core.event.Event.TYPE_FOLLOW;
import static org.eclipse.egit.github.core.event.Event.TYPE_GIST;
import static org.eclipse.egit.github.core.event.Event.TYPE_GOLLUM;
import static org.eclipse.egit.github.core.event.Event.TYPE_ISSUES;
import static org.eclipse.egit.github.core.event.Event.TYPE_ISSUE_COMMENT;
import static org.eclipse.egit.github.core.event.Event.TYPE_MEMBER;
import static org.eclipse.egit.github.core.event.Event.TYPE_PUBLIC;
import static org.eclipse.egit.github.core.event.Event.TYPE_PULL_REQUEST;
import static org.eclipse.egit.github.core.event.Event.TYPE_PUSH;
import static org.eclipse.egit.github.core.event.Event.TYPE_TEAM_ADD;
import static org.eclipse.egit.github.core.event.Event.TYPE_WATCH;
import android.content.Context;
import android.test.InstrumentationTestCase;
import android.test.UiThreadTest;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.TextView;

import com.github.pockethub.R.id;
import com.github.pockethub.ui.user.NewsListAdapter;
import com.github.pockethub.util.AvatarLoader;

import java.util.Date;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.Team;
import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.event.CommitCommentPayload;
import org.eclipse.egit.github.core.event.CreatePayload;
import org.eclipse.egit.github.core.event.DeletePayload;
import org.eclipse.egit.github.core.event.Event;
import org.eclipse.egit.github.core.event.EventRepository;
import org.eclipse.egit.github.core.event.FollowPayload;
import org.eclipse.egit.github.core.event.GistPayload;
import org.eclipse.egit.github.core.event.IssueCommentPayload;
import org.eclipse.egit.github.core.event.IssuesPayload;
import org.eclipse.egit.github.core.event.MemberPayload;
import org.eclipse.egit.github.core.event.PullRequestPayload;
import org.eclipse.egit.github.core.event.PushPayload;
import org.eclipse.egit.github.core.event.TeamAddPayload;


public class NewsEventTextTest extends InstrumentationTestCase {

    private NewsListAdapter adapter;

    private TextView text;

    private User actor;

    private EventRepository repo;

    private Date date;

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        date = new Date();
        actor = new User().setLogin("user");
        repo = new EventRepository().setName("user/repo");

        Context context = getInstrumentation().getTargetContext();
        adapter = new NewsListAdapter(LayoutInflater.from(context),
                new AvatarLoader(context));
    }

    private Event createEvent(String type) {
        Event event = new Event();
        event.setCreatedAt(date);
        event.setType(type);
        event.setActor(actor);
        event.setRepo(repo);
        return event;
    }

    private void verify(String expected) {
        CharSequence actual = text.getText();
        assertNotNull(actual);
        assertEquals(expected, actual.toString());
    }

    private void updateView(Event event) {
        adapter.setItems(new Object[] { event });
        View view = adapter.getView(0, null, null);
        assertNotNull(view);
        text = (TextView) view.findViewById(id.tv_event);
        assertNotNull(text);
    }


    @UiThreadTest
    public void testCommitCommentEvent() {
        Event event = createEvent(TYPE_COMMIT_COMMENT);
        event.setPayload(new CommitCommentPayload());
        updateView(event);

        verify("user commented on user/repo");
    }


    @UiThreadTest
    public void testCreateRepositoryEvent() {
        Event event = createEvent(TYPE_CREATE);
        CreatePayload payload = new CreatePayload();
        payload.setRefType("repository");
        event.setPayload(payload);
        updateView(event);

        verify("user created repository repo");
    }


    @UiThreadTest
    public void testCreateBranchEvent() {
        Event event = createEvent(TYPE_CREATE);
        CreatePayload payload = new CreatePayload();
        payload.setRefType("branch");
        payload.setRef("b1");
        event.setPayload(payload);
        updateView(event);

        verify("user created branch b1 at user/repo");
    }


    @UiThreadTest
    public void testDelete() {
        Event event = createEvent(TYPE_DELETE);
        DeletePayload payload = new DeletePayload();
        payload.setRefType("branch");
        payload.setRef("b1");
        event.setPayload(payload);
        updateView(event);

        verify("user deleted branch b1 at user/repo");
    }


    @UiThreadTest
    public void testFollow() {
        Event event = createEvent(TYPE_FOLLOW);
        FollowPayload payload = new FollowPayload();
        payload.setTarget(new User().setLogin("user2"));
        event.setPayload(payload);
        updateView(event);

        verify("user started following user2");
    }


    @UiThreadTest
    public void testGist() {
        Event event = createEvent(TYPE_GIST);
        GistPayload payload = new GistPayload();
        payload.setAction("create");
        payload.setGist(new Gist().setId("1"));
        event.setPayload(payload);
        updateView(event);

        verify("user created Gist 1");
    }


    @UiThreadTest
    public void testWiki() {
        Event event = createEvent(TYPE_GOLLUM);
        updateView(event);

        verify("user updated the wiki in user/repo");
    }


    @UiThreadTest
    public void testIssueComment() {
        Event event = createEvent(TYPE_ISSUE_COMMENT);
        IssueCommentPayload payload = new IssueCommentPayload();
        payload.setIssue(new Issue().setNumber(5));
        event.setPayload(payload);
        updateView(event);

        verify("user commented on issue 5 on user/repo");
    }


    @UiThreadTest
    public void testIssue() {
        Event event = createEvent(TYPE_ISSUES);
        IssuesPayload payload = new IssuesPayload();
        payload.setAction("closed");
        payload.setIssue(new Issue().setNumber(8));
        event.setPayload(payload);
        updateView(event);

        verify("user closed issue 8 on user/repo");
    }


    @UiThreadTest
    public void testAddMember() {
        Event event = createEvent(TYPE_MEMBER);
        event.setPayload(new MemberPayload().setMember(new User()
                .setLogin("person")));
        updateView(event);

        verify("user added person as a collaborator to user/repo");
    }


    @UiThreadTest
    public void testOpenSourced() {
        Event event = createEvent(TYPE_PUBLIC);
        updateView(event);

        verify("user open sourced repository user/repo");
    }


    @UiThreadTest
    public void testWatch() {
        Event event = createEvent(TYPE_WATCH);
        updateView(event);

        verify("user starred user/repo");
    }


    @UiThreadTest
    public void testPullRequest() {
        Event event = createEvent(TYPE_PULL_REQUEST);
        PullRequestPayload payload = new PullRequestPayload();
        payload.setNumber(30);
        payload.setAction("merged");
        event.setPayload(payload);
        updateView(event);

        verify("user merged pull request 30 on user/repo");
    }


    @UiThreadTest
    public void testPush() {
        Event event = createEvent(TYPE_PUSH);
        PushPayload payload = new PushPayload();
        payload.setRef("refs/heads/master");
        event.setPayload(payload);
        updateView(event);

        verify("user pushed to master at user/repo");
    }


    @UiThreadTest
    public void testTeamAdd() {
        Event event = createEvent(TYPE_TEAM_ADD);
        TeamAddPayload payload = new TeamAddPayload();
        payload.setTeam(new Team().setName("t1"));
        payload.setUser(new User().setLogin("u2"));
        event.setPayload(payload);
        updateView(event);

        verify("user added u2 to team t1");
    }
}

<code block>

package com.github.pockethub.tests;

import android.app.Activity;
import android.test.ActivityInstrumentationTestCase2;
import android.view.View;
import android.widget.EditText;


public abstract class ActivityTest<T extends Activity> extends
        ActivityInstrumentationTestCase2<T> {


    public ActivityTest(Class<T> activityClass) {
        super(activityClass);
    }


    public void testActivityIsCreated() {
        assertNotNull(getActivity());
    }


    protected EditText editText(final int id) {
        return (EditText) view(id);
    }


    protected View view(final int id) {
        assertNotNull(getActivity());
        View view = getActivity().findViewById(id);
        assertNotNull(view);
        return view;
    }


    protected void focus(final View view) throws Throwable {
        ui(new Runnable() {

            public void run() {
                view.requestFocus();
            }
        });
    }


    protected void ui(Runnable runnable) throws Throwable {
        runTestOnUiThread(runnable);
    }


    protected void send(final String text) {
        getInstrumentation().waitForIdleSync();
        getInstrumentation().sendStringSync(text);
        getInstrumentation().waitForIdleSync();
    }
}

<code block>

package com.github.pockethub.tests.user;

import android.net.Uri;
import android.test.AndroidTestCase;

import com.github.pockethub.core.user.UserUriMatcher;

import org.eclipse.egit.github.core.User;


public class UserUriMatcherTest extends AndroidTestCase {


    public void testEmptyUri() {
        assertNull(UserUriMatcher.getUser(Uri.parse("")));
    }


    public void testUriWithNoName() {
        assertNull(UserUriMatcher.getUser(Uri.parse("http://github.com")));
        assertNull(UserUriMatcher.getUser(Uri.parse("https://github.com")));
        assertNull(UserUriMatcher.getUser(Uri.parse("http://github.com/")));
        assertNull(UserUriMatcher.getUser(Uri.parse("http://github.com//")));
    }


    public void testHttpUriWithName() {
        User user = UserUriMatcher.getUser(Uri
                .parse("http://github.com/defunkt"));
        assertNotNull(user);
        assertEquals("defunkt", user.getLogin());
    }


    public void testHttpsUriWithName() {
        User user = UserUriMatcher.getUser(Uri
                .parse("https://github.com/mojombo"));
        assertNotNull(user);
        assertEquals("mojombo", user.getLogin());
    }


    public void testUriWithTrailingSlash() {
        User user = UserUriMatcher.getUser(Uri
                .parse("http://github.com/defunkt/"));
        assertNotNull(user);
        assertEquals("defunkt", user.getLogin());
    }


    public void testUriWithTrailingSlashes() {
        User user = UserUriMatcher.getUser(Uri
                .parse("http://github.com/defunkt//"));
        assertNotNull(user);
        assertEquals("defunkt", user.getLogin());
    }
}

<code block>

package com.github.pockethub.tests.user;

import android.accounts.Account;
import android.accounts.AccountManager;
import android.test.AndroidTestCase;

import com.github.pockethub.accounts.GitHubAccount;
import com.github.pockethub.core.user.UserComparator;

import org.eclipse.egit.github.core.User;


public class UserComparatorTest extends AndroidTestCase {


    public void testLoginMatch() {
        GitHubAccount account = new GitHubAccount(new Account("m", "t"),
                AccountManager.get(getContext()));
        UserComparator comparator = new UserComparator(account);

        assertTrue(comparator.compare(new User().setLogin("m"),
                new User().setLogin("a")) < 0);
        assertTrue(comparator.compare(new User().setLogin("a"),
                new User().setLogin("m")) > 0);
        assertTrue(comparator.compare(new User().setLogin("m"),
                new User().setLogin("z")) < 0);
        assertTrue(comparator.compare(new User().setLogin("z"),
                new User().setLogin("m")) > 0);
        assertEquals(
                0,
                comparator.compare(new User().setLogin("m"),
                        new User().setLogin("m")));
    }


    public void testNoLoginMatch() {
        GitHubAccount account = new GitHubAccount(new Account("m", "t"),
                AccountManager.get(getContext()));
        UserComparator comparator = new UserComparator(account);

        assertTrue(comparator.compare(new User().setLogin("a"),
                new User().setLogin("c")) < 0);
        assertTrue(comparator.compare(new User().setLogin("db"),
                new User().setLogin("da")) > 0);
    }
}

<code block>

package com.github.pockethub.tests.user;

import android.accounts.AccountManager;

import com.github.pockethub.accounts.AccountUtils;
import com.github.pockethub.accounts.LoginActivity;
import com.github.pockethub.tests.ActivityTest;


public class LoginActivityTest extends ActivityTest<LoginActivity> {


    public LoginActivityTest() {
        super(LoginActivity.class);
    }


    public void testHasAuthenticator() {
        assertTrue(AccountUtils.hasAuthenticator(AccountManager
            .get(getActivity())));
    }

}

<code block>

package com.github.pockethub.tests.util;

import android.test.AndroidTestCase;

import com.github.pockethub.util.HtmlUtils;


public class HtmlUtilsTest extends AndroidTestCase {

    private String format(String html) {
        CharSequence formatted = HtmlUtils.format(html);
        assertNotNull(formatted);
        return formatted.toString().replace("<githubroot>", "")
                .replace("</githubroot>", "");
    }


    public void testToggleRemoved() {
        String html = "before <span class=\"email-hidden-toggle\"><a href=\"#\">â¦</a></span>after";
        assertEquals("before after", format(html));
    }


    public void testTogglesRemoved() {
        String html = "before <span class=\"email-hidden-toggle\"><a href=\"#\">â¦</a></span>after<span class=\"email-hidden-toggle\"><a href=\"#\">â¦</a></span>";
        assertEquals("before after", format(html));
    }


    public void testEmailQuoted() {
        String html = "before <div class=\"email-quoted-reply\">quoted</div> after";
        assertEquals("before <blockquote>quoted</blockquote> after",
                format(html));
    }


    public void testEmailFragment() {
        String html = "before <div class=\"email-fragment\">in\nside</div> after";
        assertEquals("before in<br>side after", format(html));
    }


    public void testEmailFragments() {
        String html = "before <div class=\"email-fragment\">in\nside</div> after <div class=\"email-fragment\">out\nside</div>";
        assertEquals("before in<br>side after out<br>side", format(html));
    }


    public void testTrailingEmailFragment() {
        String html = "before <div class=\"email-fragment\">in\nside</div>";
        assertEquals("before in<br>side", format(html));
    }


    public void testLeadingBreak() {
        String html = "<br>content";
        assertEquals("content", format(html));
    }


    public void testTrailingBreak() {
        String html = "content<br>";
        assertEquals("content", format(html));
    }


    public void testWrappedBreaks() {
        String html = "<br>content<br>";
        assertEquals("content", format(html));
    }


    public void testWrappedParagraphs() {
        String html = "<p>content</p>";
        assertEquals("content", format(html));
    }


    public void testParagraphReplacedWithBreak() {
        String html = "line1<p>line2</p>";
        assertEquals("line1<br>line2", format(html));
    }


    public void testEmReplacedWithI() {
        String html = "a<em>b</em>c";
        assertEquals(html, format(html));
    }


    public void testStrongReplacedWithB() {
        String html = "<strong>a</strong>";
        assertEquals(html, format(html));
    }


    public void testLeadingWhitespace() {
        String html = " content";
        assertEquals("content", format(html));
    }


    public void testTrailingWhitespace() {
        String html = "content ";
        assertEquals("content", format(html));
    }


    public void testWrappedWhitetspace() {
        String html = " content ";
        assertEquals("content", format(html));
    }


    public void testPreWithNoWhitespace() {
        String html = "a<pre>b</pre> c";
        assertEquals("a<pre>b</pre> c", format(html));
    }


    public void testPreWithSpaces() {
        String html = "a<pre> b</pre> c";
        assertEquals("a<pre>&nbsp;b</pre> c", format(html));
    }


    public void testPreWithTabs() {
        String html = "a<pre>\tb</pre> c";
        assertEquals("a<pre>&nbsp;&nbsp;&nbsp;&nbsp;b</pre> c", format(html));
    }


    public void testPreWithNewline() {
        String html = "a<pre>\nb</pre> c";
        assertEquals("a<pre><br>b</pre> c", format(html));
    }


    public void testPreWithAllWhitepsace() {
        String html = "a<pre>\nb\tc </pre>d";
        assertEquals("a<pre><br>b&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;</pre>d",
                format(html));
    }


    public void testMultiplePresEscaped() {
        String html = "a<pre> c </pre>d<pre>\te\t</pre>";
        assertEquals(
                "a<pre>&nbsp;c&nbsp;</pre>d<pre>&nbsp;&nbsp;&nbsp;&nbsp;e&nbsp;&nbsp;&nbsp;&nbsp;</pre>",
                format(html));
    }


    public void testFormatPreCodeOnly() {
        String html = "<pre><code>a\nb\nc\n</code></pre>";
        assertEquals("<pre><code>a<br>b<br>c</code></pre>", format(html));
    }
}

<code block>

package com.github.pockethub.tests.issue;

import android.test.AndroidTestCase;

import com.github.pockethub.core.issue.IssueStore;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.RepositoryIssue;
import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.service.IssueService;
import org.eclipse.egit.github.core.service.PullRequestService;


public class IssueStoreTest extends AndroidTestCase {


    public void testReuseIssue() {
        IssueStore store = new IssueStore(new IssueService(),
                new PullRequestService());
        Repository repo = new Repository();
        repo.setName("name");
        repo.setOwner(new User().setLogin("owner"));

        assertNull(store.getIssue(repo, 1));

        RepositoryIssue issue = new RepositoryIssue();
        issue.setRepository(repo).setNumber(1).setBody("body");
        assertSame(issue, store.addIssue(issue));
        assertSame(issue, store.getIssue(repo, 1));

        RepositoryIssue issue2 = new RepositoryIssue();
        issue2.setRepository(repo).setNumber(1).setBody("body2");
        assertSame(issue, store.addIssue(issue2));
        assertEquals(issue2.getBody(), issue.getBody());
        assertSame(issue, store.getIssue(repo, 1));
    }
}

<code block>

package com.github.pockethub.tests.issue;

import android.net.Uri;
import android.test.AndroidTestCase;

import com.github.pockethub.core.issue.IssueUriMatcher;

import org.eclipse.egit.github.core.RepositoryIssue;


public class IssueUriMatcherTest extends AndroidTestCase {


    public void testEmptyUri() {
        assertNull(IssueUriMatcher.getIssue(Uri.parse("")));
    }


    public void testNonNumericIssueNumber() {
        assertNull(IssueUriMatcher.getIssue(Uri
                .parse("https://github.com/defunkt/resque/issues/fourty")));
    }


    public void testHttpUri() {
        RepositoryIssue issue = IssueUriMatcher.getIssue(Uri
                .parse("https://github.com/defunkt/resque/issues/3"));
        assertNotNull(issue);
        assertEquals(3, issue.getNumber());
        assertNotNull(issue.getRepository());
        assertEquals("resque", issue.getRepository().getName());
        assertNotNull(issue.getRepository().getOwner());
        assertEquals("defunkt", issue.getRepository().getOwner().getLogin());
    }


    public void testPullUri() {
        RepositoryIssue issue = IssueUriMatcher.getIssue(Uri
                .parse("https://github.com/defunkt/resque/pull/3"));
        assertNotNull(issue);
        assertEquals(3, issue.getNumber());
        assertNotNull(issue.getRepository());
        assertEquals("resque", issue.getRepository().getName());
        assertNotNull(issue.getRepository().getOwner());
        assertEquals("defunkt", issue.getRepository().getOwner().getLogin());
    }


    public void testHttpsUri() {
        RepositoryIssue issue = IssueUriMatcher.getIssue(Uri
                .parse("http://github.com/defunkt/resque/issues/15"));
        assertNotNull(issue);
        assertEquals(15, issue.getNumber());
        assertNotNull(issue.getRepository());
        assertEquals("resque", issue.getRepository().getName());
        assertNotNull(issue.getRepository().getOwner());
        assertEquals("defunkt", issue.getRepository().getOwner().getLogin());
    }


    public void testCommentUri() {
        RepositoryIssue issue = IssueUriMatcher
                .getIssue(Uri
                        .parse("https://github.com/defunkt/resque/issues/300#issuecomment-123456"));
        assertNotNull(issue);
        assertEquals(300, issue.getNumber());
        assertNotNull(issue.getRepository());
        assertEquals("resque", issue.getRepository().getName());
        assertNotNull(issue.getRepository().getOwner());
        assertEquals("defunkt", issue.getRepository().getOwner().getLogin());
    }
}

<code block>

package com.github.pockethub.tests.issue;

import static android.view.KeyEvent.KEYCODE_DEL;
import android.view.View;
import android.widget.EditText;

import com.github.pockethub.R.id;
import com.github.pockethub.tests.ActivityTest;
import com.github.pockethub.ui.issue.EditIssueActivity;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;


public class EditIssueActivityTest extends ActivityTest<EditIssueActivity> {


    public EditIssueActivityTest() {
        super(EditIssueActivity.class);
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        Repository repo = new Repository();
        repo.setName("repo");
        repo.setOwner(new User().setLogin("owner"));
        setActivityIntent(EditIssueActivity.createIntent(repo));
    }


    public void testSaveMenuEnabled() throws Throwable {
        View saveMenu = view(id.m_apply);
        assertFalse(saveMenu.isEnabled());
        EditText title = editText(id.et_issue_title);
        focus(title);
        send("a");
        assertTrue(saveMenu.isEnabled());
        sendKeys(KEYCODE_DEL);
        assertFalse(saveMenu.isEnabled());
    }
}

<code block>

package com.github.pockethub.tests.issue;

import com.github.pockethub.core.issue.IssueFilter;
import com.github.pockethub.tests.ActivityTest;
import com.github.pockethub.ui.issue.EditIssuesFilterActivity;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;


public class EditIssuesFilterActivityTest extends
    ActivityTest<EditIssuesFilterActivity> {


    public EditIssuesFilterActivityTest() {
        super(EditIssuesFilterActivity.class);
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        Repository repo = new Repository();
        repo.setName("name");
        repo.setOwner(new User().setLogin("owner"));
        IssueFilter filter = new IssueFilter(repo);
        setActivityIntent(EditIssuesFilterActivity.createIntent(filter));
    }
}

<code block>

package com.github.pockethub.tests.issue;

import android.test.AndroidTestCase;

import com.github.pockethub.core.issue.IssueFilter;

import org.eclipse.egit.github.core.Milestone;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;


public class IssueFilterTest extends AndroidTestCase {


    public void testEqualFilter() {
        Repository repo = new Repository().setId(1);
        IssueFilter filter1 = new IssueFilter(repo);

        assertFalse(filter1.equals(null));
        assertFalse(filter1.equals(""));
        assertTrue(filter1.equals(filter1));

        IssueFilter filter2 = new IssueFilter(repo);
        assertEquals(filter1, filter2);
        assertEquals(filter1.hashCode(), filter2.hashCode());

        User user = new User().setId(2);
        filter1.setAssignee(user);
        assertFalse(filter1.equals(filter2));
        filter2.setAssignee(user);
        assertEquals(filter1, filter2);
        assertEquals(filter1.hashCode(), filter2.hashCode());

        filter1.setOpen(false);
        assertFalse(filter1.equals(filter2));
        filter2.setOpen(false);
        assertEquals(filter1, filter2);
        assertEquals(filter1.hashCode(), filter2.hashCode());

        Milestone milestone = new Milestone().setNumber(3);
        filter1.setMilestone(milestone);
        assertFalse(filter1.equals(filter2));
        filter2.setMilestone(milestone);
        assertEquals(filter1, filter2);
        assertEquals(filter1.hashCode(), filter2.hashCode());
    }
}

<code block>

package com.github.pockethub.tests.issue;

import static android.view.KeyEvent.KEYCODE_DEL;
import android.view.View;
import android.widget.EditText;

import com.github.pockethub.R.id;
import com.github.pockethub.tests.ActivityTest;
import com.github.pockethub.ui.issue.CreateCommentActivity;

import org.eclipse.egit.github.core.RepositoryId;
import org.eclipse.egit.github.core.User;


public class CreateCommentActivityTest extends
    ActivityTest<CreateCommentActivity> {


    public CreateCommentActivityTest() {
        super(CreateCommentActivity.class);
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        setActivityIntent(CreateCommentActivity.createIntent(new RepositoryId(
            "o", "n"), 1, new User().setLogin("u")));
    }


    public void testEmptyCommentIsProhitibed() throws Throwable {
        View createMenu = view(id.m_apply);
        assertFalse(createMenu.isEnabled());
        final EditText comment = editText(id.et_comment);
        focus(comment);
        send("a");
        assertTrue(createMenu.isEnabled());
        sendKeys(KEYCODE_DEL);
        assertFalse(createMenu.isEnabled());
    }
}

<code block>

package com.github.pockethub.tests.commit;

import android.test.AndroidTestCase;

import com.github.pockethub.core.commit.FullCommit;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;

import org.eclipse.egit.github.core.CommitComment;
import org.eclipse.egit.github.core.CommitFile;
import org.eclipse.egit.github.core.RepositoryCommit;


public class FullCommitTest extends AndroidTestCase {


    public void testSingleLineCommentSingleFile() {
        RepositoryCommit commit = new RepositoryCommit();
        CommitFile file = new CommitFile();
        file.setFilename("a.txt");
        CommitComment comment = new CommitComment();
        comment.setPath(file.getFilename());
        comment.setPosition(10);
        commit.setFiles(Collections.singletonList(file));
        FullCommit full = new FullCommit(commit, new ArrayList<CommitComment>(
                Collections.singletonList(comment)));
        assertTrue(full.isEmpty());
        assertEquals(1, full.getFiles().size());
        assertEquals(comment, full.getFiles().get(0).get(10).get(0));
    }


    public void testSingleCommentSingleFile() {
        RepositoryCommit commit = new RepositoryCommit();
        CommitFile file = new CommitFile();
        file.setFilename("a.txt");
        CommitComment comment = new CommitComment();
        commit.setFiles(Collections.singletonList(file));
        FullCommit full = new FullCommit(commit, new ArrayList<CommitComment>(
                Collections.singletonList(comment)));
        assertFalse(full.isEmpty());
        assertEquals(comment, full.get(0));
        assertEquals(1, full.getFiles().size());
    }


    public void testSingleCommentNoFiles() {
        RepositoryCommit commit = new RepositoryCommit();
        CommitComment comment = new CommitComment();
        FullCommit full = new FullCommit(commit, new ArrayList<CommitComment>(
                Collections.singletonList(comment)));
        assertFalse(full.isEmpty());
        assertEquals(comment, full.get(0));
        assertTrue(full.getFiles().isEmpty());
    }


    public void testNoCommentsSingleFile() {
        RepositoryCommit commit = new RepositoryCommit();
        CommitFile file = new CommitFile();
        file.setFilename("a.txt");
        commit.setFiles(Collections.singletonList(file));
        FullCommit full = new FullCommit(commit);
        assertTrue(full.isEmpty());
        assertEquals(1, full.getFiles().size());
    }


    public void testBothTypesOfComments() {
        RepositoryCommit commit = new RepositoryCommit();
        CommitFile file = new CommitFile();
        file.setFilename("a.txt");
        commit.setFiles(Collections.singletonList(file));
        CommitComment comment1 = new CommitComment();
        comment1.setPath(file.getFilename());
        comment1.setPosition(10);
        CommitComment comment2 = new CommitComment();
        FullCommit full = new FullCommit(commit, new ArrayList<CommitComment>(
                Arrays.asList(comment1, comment2)));
        assertEquals(1, full.size());
        assertEquals(comment2, full.get(0));
        assertEquals(1, full.getFiles().size());
        assertEquals(comment1, full.getFiles().get(0).get(10).get(0));
    }
}

<code block>

package com.github.pockethub.tests.commit;

import android.test.AndroidTestCase;

import com.github.pockethub.ui.commit.DiffStyler;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.StringReader;
import java.util.Collections;
import java.util.List;

import org.eclipse.egit.github.core.CommitFile;


public class DiffStylerTest extends AndroidTestCase {

    private void compareStyled(String patch) throws IOException {
        assertNotNull(patch);
        String fileName = "file.txt";
        DiffStyler styler = new DiffStyler(getContext().getResources());
        CommitFile file = new CommitFile();
        file.setFilename(fileName);
        file.setPatch(patch);
        styler.setFiles(Collections.singletonList(file));
        List<CharSequence> styled = styler.get(fileName);
        assertNotNull(styled);
        BufferedReader reader = new BufferedReader(new StringReader(patch));
        String line = reader.readLine();
        int processed = 0;
        while (line != null) {
            assertEquals(line, styled.get(processed).toString());
            line = reader.readLine();
            processed++;
        }
        assertEquals(processed, styled.size());
    }


    public void testEmptyFiles() {
        DiffStyler styler = new DiffStyler(getContext().getResources());
        styler.setFiles(null);
        assertTrue(styler.get("navigation_drawer_header_background").isEmpty());
        styler.setFiles(Collections.<CommitFile>emptyList());
        assertTrue(styler.get("navigation_drawer_header_background").isEmpty());
    }


    public void testEmptyPatch() {
        DiffStyler styler = new DiffStyler(getContext().getResources());
        CommitFile file = new CommitFile();
        file.setFilename("file.txt");
        styler.setFiles(Collections.singletonList(file));
        assertTrue(styler.get("file.txt").isEmpty());
        file.setPatch("");
        assertTrue(styler.get("file.txt").isEmpty());
    }


    public void testOnlyNewline() throws IOException {
        compareStyled("\n");
    }


    public void testEmptyPatchLineWithOtherValidLines() throws IOException {
        compareStyled("@@ 0,1 0,1 @@\n\n-navigation_drawer_header_background\n");
    }


    public void testTrailingEmptyLine() throws IOException {
        compareStyled("@@ 0,1 0,1 @@\n-navigation_drawer_header_background\n\n");
    }


    public void testOnlyNewlines() throws IOException {
        compareStyled("\n\n\n");
    }


    public void testNoTrailingNewlineAfterSecondLine() throws IOException {
        compareStyled("@@ 1,2 1,2 @@\n+navigation_drawer_header_background");
    }


    public void testNoTrailingNewline() throws IOException {
        compareStyled("@@ 1,2 1,2 @@");
    }


    public void testFormattedPatch() throws IOException {
        compareStyled("@@ 1,2 1,2 @@\n+navigation_drawer_header_background\n");
    }
}

<code block>

package com.github.pockethub.tests.commit;

import android.test.AndroidTestCase;

import com.github.pockethub.core.commit.CommitUtils;

import java.util.Date;

import org.eclipse.egit.github.core.Commit;
import org.eclipse.egit.github.core.CommitFile;
import org.eclipse.egit.github.core.CommitUser;
import org.eclipse.egit.github.core.RepositoryCommit;
import org.eclipse.egit.github.core.User;


public class CommitUtilsTest extends AndroidTestCase {


    public void testAbbreviate() {
        assertNull(CommitUtils.abbreviate((Commit) null));
        assertNull(CommitUtils.abbreviate((RepositoryCommit) null));
        assertNull(CommitUtils.abbreviate((String) null));
        assertEquals("", CommitUtils.abbreviate(""));
        assertEquals("a", CommitUtils.abbreviate("a"));
        assertEquals("abcdefghij", CommitUtils.abbreviate("abcdefghijk"));
        assertEquals("abc", CommitUtils.abbreviate(new Commit().setSha("abc")));
        assertEquals("abcd",
                CommitUtils.abbreviate(new RepositoryCommit().setSha("abcd")));
    }


    public void testGetName() {
        assertNull(CommitUtils.getName((String) null));
        assertNull(CommitUtils.getName((CommitFile) null));
        assertEquals("", CommitUtils.getName(""));
        assertEquals("/", CommitUtils.getName("/"));
        assertEquals("b", CommitUtils.getName("a/b"));
        assertEquals("c",
                CommitUtils.getName(new CommitFile().setFilename("a/b/c")));
    }


    public void testIsValidCommit() {
        assertFalse(CommitUtils.isValidCommit(null));
        assertFalse(CommitUtils.isValidCommit(""));
        assertTrue(CommitUtils.isValidCommit("a"));
        assertTrue(CommitUtils.isValidCommit("bbbbb"));
        assertFalse(CommitUtils.isValidCommit("am"));
        assertFalse(CommitUtils.isValidCommit("xyz"));
    }


    public void testGetAuthor() {
        RepositoryCommit commit = new RepositoryCommit();
        assertNull(CommitUtils.getAuthor(commit));
        Commit rawCommit = new Commit();
        commit.setCommit(rawCommit);
        assertNull(CommitUtils.getAuthor(commit));
        CommitUser user = new CommitUser();
        rawCommit.setAuthor(user);
        assertNull(CommitUtils.getAuthor(commit));
        user.setName("u1");
        assertEquals("u1", CommitUtils.getAuthor(commit));
        commit.setAuthor(new User().setLogin("u2"));
        assertEquals("u2", CommitUtils.getAuthor(commit));
    }


    public void testGetCommitter() {
        RepositoryCommit commit = new RepositoryCommit();
        assertNull(CommitUtils.getCommitter(commit));
        Commit rawCommit = new Commit();
        commit.setCommit(rawCommit);
        assertNull(CommitUtils.getCommitter(commit));
        CommitUser user = new CommitUser();
        rawCommit.setCommitter(user);
        assertNull(CommitUtils.getCommitter(commit));
        user.setName("u1");
        assertEquals("u1", CommitUtils.getCommitter(commit));
        commit.setCommitter(new User().setLogin("u2"));
        assertEquals("u2", CommitUtils.getCommitter(commit));
    }


    public void testGetAuthorDate() {
        RepositoryCommit commit = new RepositoryCommit();
        assertNull(CommitUtils.getAuthorDate(commit));
        Commit rawCommit = new Commit();
        commit.setCommit(rawCommit);
        assertNull(CommitUtils.getAuthorDate(commit));
        CommitUser user = new CommitUser();
        rawCommit.setAuthor(user);
        assertNull(CommitUtils.getAuthorDate(commit));
        user.setDate(new Date(12345));
        assertEquals(new Date(12345), CommitUtils.getAuthorDate(commit));
    }


    public void testGetCommitterDate() {
        RepositoryCommit commit = new RepositoryCommit();
        assertNull(CommitUtils.getCommitterDate(commit));
        Commit rawCommit = new Commit();
        commit.setCommit(rawCommit);
        assertNull(CommitUtils.getCommitterDate(commit));
        CommitUser user = new CommitUser();
        rawCommit.setCommitter(user);
        assertNull(CommitUtils.getCommitterDate(commit));
        user.setDate(new Date(12345));
        assertEquals(new Date(12345), CommitUtils.getCommitterDate(commit));
    }
}

<code block>

package com.github.pockethub.tests.commit;

import android.net.Uri;
import android.test.AndroidTestCase;

import com.github.pockethub.core.commit.CommitMatch;
import com.github.pockethub.core.commit.CommitUriMatcher;


public class CommitUriMatcherTest extends AndroidTestCase {


    public void testEmptyUri() {
        assertNull(CommitUriMatcher.getCommit(Uri.parse("")));
    }


    public void testNonHexId() {
        assertNull(CommitUriMatcher.getCommit(Uri
                .parse("https://github.com/defunkt/resque/commit/abck")));
    }


    public void testHttpUri() {
        CommitMatch commit = CommitUriMatcher.getCommit(Uri
                .parse("https://github.com/defunkt/resque/commit/abcd"));
        assertNotNull(commit);
        assertEquals("abcd", commit.commit);
        assertNotNull(commit.repository);
        assertEquals("resque", commit.repository.getName());
        assertNotNull(commit.repository.getOwner());
        assertEquals("defunkt", commit.repository.getOwner().getLogin());
    }


    public void testHttpsUri() {
        CommitMatch commit = CommitUriMatcher.getCommit(Uri
                .parse("https://github.com/defunkt/resque/commit/1234"));
        assertNotNull(commit);
        assertEquals("1234", commit.commit);
        assertNotNull(commit.repository);
        assertEquals("resque", commit.repository.getName());
        assertNotNull(commit.repository.getOwner());
        assertEquals("defunkt", commit.repository.getOwner().getLogin());
    }


    public void testCommentUri() {
        CommitMatch commit = CommitUriMatcher
                .getCommit(Uri
                        .parse("https://github.com/defunkt/resque/commit/a1b2#commitcomment-1605701"));
        assertNotNull(commit);
        assertEquals("a1b2", commit.commit);
        assertNotNull(commit.repository);
        assertEquals("resque", commit.repository.getName());
        assertNotNull(commit.repository.getOwner());
        assertEquals("defunkt", commit.repository.getOwner().getLogin());
    }
}

<code block>

package com.github.pockethub.tests.commit;

import static android.view.KeyEvent.KEYCODE_DEL;
import android.view.View;
import android.widget.EditText;

import com.github.pockethub.R.id;
import com.github.pockethub.tests.ActivityTest;
import com.github.pockethub.ui.commit.CreateCommentActivity;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;


public class CreateCommentActivityTest extends
    ActivityTest<CreateCommentActivity> {


    public CreateCommentActivityTest() {
        super(CreateCommentActivity.class);
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        Repository repo = new Repository();
        repo.setName("name");
        repo.setOwner(new User().setLogin("owner"));
        setActivityIntent(CreateCommentActivity.createIntent(repo, "abcdef"));
    }


    public void testEmptyCommentIsProhitibed() throws Throwable {
        View createMenu = view(id.m_apply);
        assertFalse(createMenu.isEnabled());
        final EditText comment = editText(id.et_comment);
        focus(comment);
        send("a");
        assertTrue(createMenu.isEnabled());
        sendKeys(KEYCODE_DEL);
        assertFalse(createMenu.isEnabled());
    }
}

<code block>

package com.github.pockethub.tests.ref;

import android.test.AndroidTestCase;

import com.github.pockethub.core.ref.RefUtils;

import org.eclipse.egit.github.core.Reference;


public class RefUtilsTest extends AndroidTestCase {


    public void testIsBranch() {
        assertFalse(RefUtils.isBranch(null));
        assertFalse(RefUtils.isBranch(new Reference()));
        assertFalse(RefUtils.isBranch(new Reference().setRef("")));
        assertFalse(RefUtils.isBranch(new Reference().setRef("navigation_drawer_header_background")));
        assertFalse(RefUtils.isBranch(new Reference().setRef("refs/tags/v1")));
        assertFalse(RefUtils.isBranch(new Reference().setRef("refs/b1")));
        assertTrue(RefUtils.isBranch(new Reference().setRef("refs/heads/b2")));
    }


    public void testIsTag() {
        assertFalse(RefUtils.isTag((Reference) null));
        assertFalse(RefUtils.isTag(new Reference()));
        assertFalse(RefUtils.isTag(new Reference().setRef("")));
        assertFalse(RefUtils.isTag(new Reference().setRef("navigation_drawer_header_background")));
        assertFalse(RefUtils.isTag(new Reference().setRef("refs/b1")));
        assertFalse(RefUtils.isTag(new Reference().setRef("refs/heads/b2")));
        assertTrue(RefUtils.isTag(new Reference().setRef("refs/tags/v1")));
    }


    public void testIsValid() {
        assertFalse(RefUtils.isValid(null));
        assertFalse(RefUtils.isValid(new Reference()));
        assertFalse(RefUtils.isValid(new Reference().setRef("")));
        assertFalse(RefUtils.isValid(new Reference()
            .setRef("refs/pull/6/merge")));
        assertFalse(RefUtils
            .isValid(new Reference().setRef("refs/pull/6/head")));
        assertTrue(RefUtils.isValid(new Reference().setRef("refs/pull")));
        assertTrue(RefUtils.isValid(new Reference().setRef("refs/heads/b1")));
        assertTrue(RefUtils.isValid(new Reference().setRef("refs/tags/v1")));
    }


    public void testGetName() {
        assertNull(RefUtils.getName((Reference) null));
        assertNull(RefUtils.getName(new Reference()));
        assertEquals("", RefUtils.getName(new Reference().setRef("")));
        assertEquals("unchanged",
            RefUtils.getName(new Reference().setRef("unchanged")));
        assertEquals("branch",
            RefUtils.getName(new Reference().setRef("refs/heads/branch")));
        assertEquals("tag",
            RefUtils.getName(new Reference().setRef("refs/tags/tag")));
        assertEquals("notes",
            RefUtils.getName(new Reference().setRef("refs/notes")));

    }


    public void testGetPath() {
        assertNull(RefUtils.getPath(null));
        assertNull(RefUtils.getPath(new Reference()));
        assertEquals("", RefUtils.getPath(new Reference().setRef("")));
        assertEquals("unchanged",
            RefUtils.getPath(new Reference().setRef("unchanged")));
        assertEquals("heads/branch",
            RefUtils.getPath(new Reference().setRef("refs/heads/branch")));
        assertEquals("tags/tag",
            RefUtils.getPath(new Reference().setRef("refs/tags/tag")));
        assertEquals("notes",
            RefUtils.getPath(new Reference().setRef("refs/notes")));

    }
}

<code block>

package com.github.pockethub.tests.gist;

import static android.content.Intent.EXTRA_TEXT;
import android.content.Intent;
import android.view.View;
import android.widget.EditText;

import com.github.pockethub.R.id;
import com.github.pockethub.tests.ActivityTest;
import com.github.pockethub.ui.gist.CreateGistActivity;


public class CreateGistActivityTest extends ActivityTest<CreateGistActivity> {


    public CreateGistActivityTest() {
        super(CreateGistActivity.class);
    }


    public void testCreateWithInitialText() {
        setActivityIntent(new Intent().putExtra(EXTRA_TEXT, "gist content"));

        View createMenu = view(id.m_apply);
        assertTrue(createMenu.isEnabled());
        EditText content = editText(id.et_gist_content);
        assertEquals("gist content", content.getText().toString());
    }


    public void testCreateWithNoInitialText() throws Throwable {
        View createMenu = view(id.m_apply);
        assertFalse(createMenu.isEnabled());
        EditText content = editText(id.et_gist_content);
        focus(content);
        send("gist content");
        assertTrue(createMenu.isEnabled());
    }
}

<code block>

package com.github.pockethub.tests.gist;

import android.net.Uri;
import android.test.AndroidTestCase;

import com.github.pockethub.core.gist.GistUriMatcher;

import org.eclipse.egit.github.core.Gist;


public class GistUriMatcherTest extends AndroidTestCase {


    public void testEmptyUri() {
        assertNull(GistUriMatcher.getGist(Uri.parse("")));
    }


    public void testNonGistId() {
        assertNull(GistUriMatcher.getGist(Uri
                .parse("https://gist.github.com/TEST")));
        assertNull(GistUriMatcher.getGist(Uri
                .parse("https://gist.github.com/abc%20")));
        assertNull(GistUriMatcher.getGist(Uri
                .parse("https://gist.github.com/abcdefg")));
    }


    public void testPublicGist() {
        Gist gist = GistUriMatcher.getGist(Uri
                .parse("https://gist.github.com/1234"));
        assertNotNull(gist);
        assertEquals("1234", gist.getId());
    }


    public void testPrivateGist() {
        Gist gist = GistUriMatcher.getGist(Uri
                .parse("https://gist.github.com/abcd1234abcd1234abcd"));
        assertNotNull(gist);
        assertEquals("abcd1234abcd1234abcd", gist.getId());
    }
}

<code block>

package com.github.pockethub.tests.gist;

import static android.view.KeyEvent.KEYCODE_DEL;
import android.view.View;
import android.widget.EditText;

import com.github.pockethub.R.id;
import com.github.pockethub.tests.ActivityTest;
import com.github.pockethub.ui.gist.CreateCommentActivity;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.User;


public class CreateCommentActivityTest extends
    ActivityTest<CreateCommentActivity> {


    public CreateCommentActivityTest() {
        super(CreateCommentActivity.class);
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        setActivityIntent(CreateCommentActivity.createIntent(new Gist().setId(
            "123").setUser(new User().setLogin("abc"))));
    }


    public void testEmptyCommentIsProhibited() throws Throwable {
        View createMenu = view(id.m_apply);
        assertFalse(createMenu.isEnabled());
        final EditText comment = editText(id.et_comment);
        focus(comment);
        send("a");
        assertTrue(createMenu.isEnabled());
        sendKeys(KEYCODE_DEL);
        assertFalse(createMenu.isEnabled());
    }
}

<code block>

package com.github.pockethub.tests.gist;

import android.test.AndroidTestCase;

import com.github.pockethub.core.gist.GistStore;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.service.GistService;


public class GistStoreTest extends AndroidTestCase {


    public void testReuseIssue() {
        GistStore store = new GistStore(new GistService());
        assertNull(store.getGist("abcd"));

        Gist gist = new Gist();
        gist.setId("abcd").setDescription("description");
        assertSame(gist, store.addGist(gist));
        assertSame(gist, store.getGist("abcd"));

        Gist gist2 = new Gist();
        gist2.setId("abcd").setDescription("description2");
        assertSame(gist, store.addGist(gist2));
        assertEquals(gist2.getDescription(), gist.getDescription());
        assertSame(gist, store.getGist("abcd"));
    }
}

<code block>

package com.github.pockethub.tests.gist;

import android.support.v4.view.ViewPager;

import com.github.pockethub.R.id;
import com.github.pockethub.core.gist.GistStore;
import com.github.pockethub.tests.ActivityTest;
import com.github.pockethub.ui.gist.GistFilesViewActivity;
import com.google.inject.Inject;

import java.util.LinkedHashMap;
import java.util.Map;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.GistFile;

import roboguice.RoboGuice;


public class GistFilesViewActivityTest extends
    ActivityTest<GistFilesViewActivity> {

    @Inject
    private GistStore store;

    private Gist gist;


    public GistFilesViewActivityTest() {
        super(GistFilesViewActivity.class);
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        RoboGuice.injectMembers(getInstrumentation().getTargetContext()
            .getApplicationContext(), this);

        gist = new Gist();
        gist.setId("abcd");
        Map<String, GistFile> files = new LinkedHashMap<>();
        files.put("a", new GistFile().setFilename("a").setContent("aa"));
        files.put("b", new GistFile().setFilename("b").setContent("bb"));
        gist.setFiles(files);
        store.addGist(gist);
        setActivityIntent(GistFilesViewActivity.createIntent(gist, 0));
    }


    public void testChangingPages() throws Throwable {
        final ViewPager pager = (ViewPager) getActivity().findViewById(
            id.vp_pages);
        assertEquals(0, pager.getCurrentItem());
        ui(new Runnable() {

            public void run() {
                pager.setCurrentItem(1, true);
            }
        });
        assertEquals(1, pager.getCurrentItem());
        ui(new Runnable() {

            public void run() {
                pager.setCurrentItem(0, true);
            }
        });
        assertEquals(0, pager.getCurrentItem());
    }
}

<code block>

package com.github.pockethub.tests.repo;

import static com.github.pockethub.ui.repo.RecentRepositories.MAX_SIZE;
import android.test.AndroidTestCase;

import com.github.pockethub.ui.repo.RecentRepositories;

import org.eclipse.egit.github.core.User;


public class RecentRepositoriesTest extends AndroidTestCase {


    public void testBadInput() {
        User org = new User().setId(20);
        RecentRepositories recent = new RecentRepositories(getContext(), org);
        assertFalse(recent.contains(null));
        assertFalse(recent.contains(-1));
    }


    public void testMaxReached() {
        User org = new User().setId(20);
        RecentRepositories recent = new RecentRepositories(getContext(), org);

        for (int i = 0; i < MAX_SIZE; i++) {
            recent.add(i);
            assertTrue(recent.contains(i));
        }

        recent.add(MAX_SIZE + 1);
        assertTrue(recent.contains(MAX_SIZE + 1));
        assertFalse(recent.contains(0));

        for (int i = 1; i < MAX_SIZE; i++)
            assertTrue(recent.contains(i));
    }


    public void testIO() {
        User org = new User().setId(20);
        RecentRepositories recent1 = new RecentRepositories(getContext(), org);
        long id = 1234;
        recent1.add(id);
        assertTrue(recent1.contains(id));
        recent1.save();
        RecentRepositories recent2 = new RecentRepositories(getContext(), org);
        assertTrue(recent2.contains(id));
    }


    public void testScopedStorage() {
        User org1 = new User().setId(20);
        RecentRepositories recent1 = new RecentRepositories(getContext(), org1);
        long id1 = 1234;
        recent1.add(id1);
        assertTrue(recent1.contains(id1));

        User org2 = new User().setId(40);
        RecentRepositories recent2 = new RecentRepositories(getContext(), org2);
        assertFalse(recent2.contains(id1));
        long id2 = 2345;
        recent2.add(id2);
        assertTrue(recent2.contains(id2));

        recent2.save();
        recent1 = new RecentRepositories(getContext(), org1);
        assertFalse(recent1.contains(id2));
    }
}

<code block>

package com.github.pockethub.tests.repo;

import static android.app.SearchManager.QUERY;
import static android.content.Intent.ACTION_SEARCH;
import android.content.Intent;

import com.github.pockethub.tests.ActivityTest;
import com.github.pockethub.ui.search.SearchActivity;


public class SearchActivityTest extends
    ActivityTest<SearchActivity> {


    public SearchActivityTest() {
        super(SearchActivity.class);
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        setActivityIntent(new Intent(ACTION_SEARCH).putExtra(QUERY, "navigation_drawer_header_background"));
    }
}

<code block>

package com.github.pockethub.tests.repo;

import android.test.AndroidTestCase;

import com.github.pockethub.core.repo.RepositoryEventMatcher;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.event.Event;
import org.eclipse.egit.github.core.event.ForkPayload;


public class RepositoryEventMatcherTest extends AndroidTestCase {


    public void testIncompleteRepositoryFork() {
        RepositoryEventMatcher matcher = new RepositoryEventMatcher();
        Event event = new Event();
        event.setType(Event.TYPE_FORK);
        ForkPayload payload = new ForkPayload();
        event.setPayload(payload);
        assertNull(matcher.getRepository(event));
        Repository repository = new Repository();
        payload.setForkee(repository);
        assertNull(matcher.getRepository(event));
        repository.setName("repo");
        assertNull(matcher.getRepository(event));
        repository.setOwner(new User());
        assertNull(matcher.getRepository(event));
        repository.getOwner().setLogin("owner");
        assertEquals(repository, matcher.getRepository(event));
    }

}

<code block>

package com.github.pockethub.tests.repo;

import android.net.Uri;
import android.test.AndroidTestCase;

import com.github.pockethub.core.repo.RepositoryUriMatcher;

import org.eclipse.egit.github.core.Repository;


public class RepositoryUriMatcherTest extends AndroidTestCase {


    public void testEmptyUri() {
        assertNull(RepositoryUriMatcher.getRepository(Uri.parse("")));
    }


    public void testUriWithNoOnwer() {
        assertNull(RepositoryUriMatcher.getRepository(Uri
                .parse("http://github.com")));
        assertNull(RepositoryUriMatcher.getRepository(Uri
                .parse("http://github.com/")));
        assertNull(RepositoryUriMatcher.getRepository(Uri
                .parse("http://github.com//")));
    }


    public void testUriWithNoName() {
        assertNull(RepositoryUriMatcher.getRepository(Uri
                .parse("http://github.com/defunkt")));
        assertNull(RepositoryUriMatcher.getRepository(Uri
                .parse("http://github.com/defunkt/")));
    }


    public void testHttpUriWithOwnerAndName() {
        Repository repo = RepositoryUriMatcher.getRepository(Uri
                .parse("http://github.com/defunkt/resque"));
        assertNotNull(repo);
        assertEquals("resque", repo.getName());
        assertNotNull(repo.getOwner());
        assertEquals("defunkt", repo.getOwner().getLogin());
    }


    public void testHttpsUriWithOwnerAndName() {
        Repository repo = RepositoryUriMatcher.getRepository(Uri
                .parse("https://github.com/mojombo/jekyll"));
        assertNotNull(repo);
        assertEquals("jekyll", repo.getName());
        assertNotNull(repo.getOwner());
        assertEquals("mojombo", repo.getOwner().getLogin());
    }


    public void testInvalidOwner() {
        assertNull(RepositoryUriMatcher.getRepository(Uri
                .parse("http://github.com/blog/page1")));
    }
}

<code block>

package com.github.pockethub;

import static android.app.Activity.RESULT_FIRST_USER;


public interface ResultCodes {


    int RESOURCE_CHANGED = RESULT_FIRST_USER;
}

<code block>

package com.github.pockethub;

import org.eclipse.egit.github.core.client.GitHubClient;

import java.net.HttpURLConnection;


public class DefaultClient extends GitHubClient {

    private static final String USER_AGENT = "GitHubAndroid/1.6";


    public DefaultClient() {
        super();

        setSerializeNulls(false);
        setUserAgent(USER_AGENT);
    }

    @Override
    protected HttpURLConnection configureRequest(HttpURLConnection request) {
        super.configureRequest(request);

        request.setRequestProperty(HEADER_ACCEPT,
                "application/vnd.github.beta.full+json");

        return request;
    }
}

<code block>

package com.github.pockethub;

import static org.eclipse.egit.github.core.RepositoryId.createFromUrl;
import android.content.Intent;

import java.io.Serializable;
import java.util.ArrayList;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.GistFile;
import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.RepositoryId;
import org.eclipse.egit.github.core.User;


public class Intents {


    public static final String INTENT_PREFIX = "com.github.mobile.";


    public static final String INTENT_EXTRA_PREFIX = INTENT_PREFIX + "extra.";


    public static final String EXTRA_REPOSITORY = INTENT_EXTRA_PREFIX
            + "REPOSITORY";


    public static final String EXTRA_REPOSITORIES = INTENT_EXTRA_PREFIX
            + "REPOSITORIES";


    public static final String EXTRA_REPOSITORY_NAME = INTENT_EXTRA_PREFIX
            + "REPOSITORY_NAME";


    public static final String EXTRA_REPOSITORY_OWNER = INTENT_EXTRA_PREFIX
            + "REPOSITORY_OWNER";


    public static final String EXTRA_ISSUE_NUMBER = INTENT_EXTRA_PREFIX
            + "ISSUE_NUMBER";


    public static final String EXTRA_ISSUE = INTENT_EXTRA_PREFIX + "ISSUE";


    public static final String EXTRA_ISSUE_NUMBERS = INTENT_EXTRA_PREFIX
            + "ISSUE_NUMBERS";


    public static final String EXTRA_GIST_ID = INTENT_EXTRA_PREFIX + "GIST_ID";


    public static final String EXTRA_GIST_IDS = INTENT_EXTRA_PREFIX
            + "GIST_IDS";


    public static final String EXTRA_GIST = INTENT_EXTRA_PREFIX + "GIST";


    public static final String EXTRA_GIST_FILE = INTENT_EXTRA_PREFIX
            + "GIST_FILE";


    public static final String EXTRA_USER = INTENT_EXTRA_PREFIX + "USER";


    public static final String EXTRA_USERS = INTENT_EXTRA_PREFIX + "USERS";


    public static final String EXTRA_IS_COLLABORATOR = INTENT_EXTRA_PREFIX + "IS_COLLABORATOR";


    public static final String EXTRA_IS_OWNER = INTENT_EXTRA_PREFIX + "IS_OWNER";


    public static final String EXTRA_ISSUE_FILTER = INTENT_EXTRA_PREFIX
            + "ISSUE_FILTER";


    public static final String EXTRA_COMMENT_BODY = INTENT_EXTRA_PREFIX
            + "COMMENT_BODY";


    public static final String EXTRA_COMMENTS = INTENT_EXTRA_PREFIX
            + "COMMENTS";


    public static final String EXTRA_COMMENT = INTENT_EXTRA_PREFIX + "COMMENT";


    public static final String EXTRA_POSITION = INTENT_EXTRA_PREFIX
            + "POSITION";


    public static final String EXTRA_BASE = INTENT_EXTRA_PREFIX + "BASE";


    public static final String EXTRA_BASES = INTENT_EXTRA_PREFIX + "BASES";


    public static final String EXTRA_HEAD = INTENT_EXTRA_PREFIX + "HEAD";


    public static final String EXTRA_PATH = INTENT_EXTRA_PREFIX + "PATH";


    public static RepositoryId repoFrom(Intent intent) {
        String repoName = intent.getStringExtra(EXTRA_REPOSITORY_NAME);
        String repoOwner = intent.getStringExtra(EXTRA_REPOSITORY_OWNER);
        return RepositoryId.create(repoOwner, repoName);
    }


    public static class Builder {

        private final Intent intent;


        public Builder(String actionSuffix) {

            intent = new Intent(INTENT_PREFIX + actionSuffix);
        }


        public Builder repo(RepositoryId repositoryId) {
            return add(EXTRA_REPOSITORY_NAME, repositoryId.getName()).add(
                    EXTRA_REPOSITORY_OWNER, repositoryId.getOwner());
        }


        public Builder repo(Repository repository) {
            return add(EXTRA_REPOSITORY, repository);
        }


        public Builder issue(Issue issue) {
            return repo(createFromUrl(issue.getHtmlUrl())).add(EXTRA_ISSUE,
                    issue).add(EXTRA_ISSUE_NUMBER, issue.getNumber());
        }


        public Builder gist(Gist gist) {
            return add(EXTRA_GIST, gist);
        }


        public Builder gist(String gist) {
            return add(EXTRA_GIST_ID, gist);
        }


        public Builder gistFile(GistFile file) {
            return add(EXTRA_GIST_FILE, file);
        }


        public Builder user(User user) {
            return add(EXTRA_USER, user);
        }


        public Builder add(String fieldName, String value) {
            intent.putExtra(fieldName, value);
            return this;
        }


        public Builder add(String fieldName, CharSequence[] values) {
            intent.putExtra(fieldName, values);
            return this;
        }


        public Builder add(String fieldName, int value) {
            intent.putExtra(fieldName, value);
            return this;
        }


        public Builder add(String fieldName, int[] values) {
            intent.putExtra(fieldName, values);
            return this;
        }


        public Builder add(String fieldName, boolean[] values) {
            intent.putExtra(fieldName, values);
            return this;
        }


        public Builder add(String fieldName, Serializable value) {
            intent.putExtra(fieldName, value);
            return this;
        }


        public Intent toIntent() {
            return intent;
        }
    }
}

<code block>

package com.github.pockethub;

import android.util.Log;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.RandomAccessFile;
import java.nio.channels.FileLock;
import java.util.zip.GZIPOutputStream;


public class RequestWriter {

    private static final String TAG = "RequestWriter";

    private final File handle;

    private final int version;


    public RequestWriter(File file, int formatVersion) {
        handle = file;
        version = formatVersion;
    }

    private void createDirectory(final File dir) {
        if (dir != null && !dir.exists())
            dir.mkdirs();
    }


    public <V> V write(V request) {
        RandomAccessFile dir = null;
        FileLock lock = null;
        ObjectOutputStream output = null;
        try {
            createDirectory(handle.getParentFile());
            dir = new RandomAccessFile(handle, "rw");
            lock = dir.getChannel().lock();
            output = new ObjectOutputStream(new GZIPOutputStream(
                    new FileOutputStream(dir.getFD()), 8192));
            output.writeInt(version);
            output.writeObject(request);
        } catch (IOException e) {
            Log.d(TAG, "Exception writing cache " + handle.getName(), e);
            return null;
        } finally {
            if (output != null)
                try {
                    output.close();
                } catch (IOException e) {
                    Log.d(TAG, "Exception closing stream", e);
                }
            if (lock != null)
                try {
                    lock.release();
                } catch (IOException e) {
                    Log.d(TAG, "Exception unlocking file", e);
                }
            if (dir != null)
                try {
                    dir.close();
                } catch (IOException e) {
                    Log.d(TAG, "Exception closing file", e);
                }
        }
        return request;
    }
}

<code block>

package com.github.pockethub;


public interface RequestFuture<V> {


    void success(V response);
}

<code block>

package com.github.pockethub;

import android.util.Log;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.RandomAccessFile;
import java.nio.channels.FileLock;
import java.util.zip.GZIPInputStream;


public class RequestReader {

    private static final String TAG = "RequestReader";

    private final File handle;

    private final int version;


    public RequestReader(File file, int formatVersion) {
        handle = file;
        version = formatVersion;
    }


    @SuppressWarnings("unchecked")
    public <V> V read() {
        if (!handle.exists() || handle.length() == 0)
            return null;

        RandomAccessFile dir = null;
        FileLock lock = null;
        ObjectInputStream input = null;
        boolean delete = false;
        try {
            dir = new RandomAccessFile(handle, "rw");
            lock = dir.getChannel().lock();
            input = new ObjectInputStream(new GZIPInputStream(
                    new FileInputStream(dir.getFD()), 8192 * 8));
            int streamVersion = input.readInt();
            if (streamVersion != version) {
                delete = true;
                return null;
            }
            return (V) input.readObject();
        } catch (IOException e) {
            Log.d(TAG, "Exception reading cache " + handle.getName(), e);
            return null;
        } catch (ClassNotFoundException e) {
            Log.d(TAG, "Exception reading cache " + handle.getName(), e);
            return null;
        } finally {
            if (input != null)
                try {
                    input.close();
                } catch (IOException e) {
                    Log.d(TAG, "Exception closing stream", e);
                }
            if (delete)
                try {
                    dir.setLength(0);
                } catch (IOException e) {
                    Log.d(TAG, "Exception truncating file", e);
                }
            if (lock != null)
                try {
                    lock.release();
                } catch (IOException e) {
                    Log.d(TAG, "Exception unlocking file", e);
                }
            if (dir != null)
                try {
                    dir.close();
                } catch (IOException e) {
                    Log.d(TAG, "Exception closing file", e);
                }
        }
    }
}

<code block>

package com.github.pockethub;


public interface RequestCodes {


    int GIST_VIEW = 1;


    int ISSUE_VIEW = 2;


    int ISSUE_FILTER_EDIT = 3;


    int ISSUE_CREATE = 4;


    int ISSUE_LABELS_UPDATE = 2;


    int ISSUE_MILESTONE_UPDATE = 3;


    int ISSUE_ASSIGNEE_UPDATE = 4;


    int ISSUE_CLOSE = 5;


    int ISSUE_REOPEN = 6;


    int ISSUE_EDIT = 7;


    int COMMENT_CREATE = 8;


    int GIST_CREATE = 9;


    int COMMIT_VIEW = 10;


    int REF_UPDATE = 11;


    int REPOSITORY_VIEW = 12;


    int OTP_CODE_ENTER = 13;


    int COMMENT_EDIT = 14;


    int COMMENT_DELETE = 15;
}

<code block>

package com.github.pockethub;

import android.content.Context;

import com.github.pockethub.accounts.AccountClient;
import com.github.pockethub.accounts.AccountScope;
import com.github.pockethub.accounts.GitHubAccount;
import com.github.pockethub.core.commit.CommitStore;
import com.github.pockethub.core.gist.GistStore;
import com.github.pockethub.core.issue.IssueStore;
import com.github.pockethub.persistence.OrganizationRepositories;
import com.github.pockethub.sync.SyncCampaign;
import com.google.inject.AbstractModule;
import com.google.inject.Provider;
import com.google.inject.Provides;
import com.google.inject.assistedinject.FactoryModuleBuilder;
import com.google.inject.name.Named;

import java.io.File;
import java.lang.ref.WeakReference;

import org.eclipse.egit.github.core.client.GitHubClient;
import org.eclipse.egit.github.core.service.CommitService;
import org.eclipse.egit.github.core.service.GistService;
import org.eclipse.egit.github.core.service.IssueService;
import org.eclipse.egit.github.core.service.PullRequestService;


public class GitHubModule extends AbstractModule {

    private WeakReference<IssueStore> issues;

    private WeakReference<GistStore> gists;

    private WeakReference<CommitStore> commits;

    @Override
    protected void configure() {
        install(new ServicesModule());
        install(new FactoryModuleBuilder().build(SyncCampaign.Factory.class));
        install(new FactoryModuleBuilder()
                .build(OrganizationRepositories.Factory.class));
        install(AccountScope.module());
    }

    @Provides
    GitHubClient client(Provider<GitHubAccount> accountProvider) {
        return new AccountClient(accountProvider);
    }

    @Provides
    @Named("cacheDir")
    File cacheDir(Context context) {
        return new File(context.getFilesDir(), "cache");
    }

    @Provides
    IssueStore issueStore(IssueService issueService,
            PullRequestService pullService) {
        IssueStore store = issues != null ? issues.get() : null;
        if (store == null) {
            store = new IssueStore(issueService, pullService);
            issues = new WeakReference<>(store);
        }
        return store;
    }

    @Provides
    GistStore gistStore(GistService service) {
        GistStore store = gists != null ? gists.get() : null;
        if (store == null) {
            store = new GistStore(service);
            gists = new WeakReference<>(store);
        }
        return store;
    }

    @Provides
    CommitStore commitStore(CommitService service) {
        CommitStore store = commits != null ? commits.get() : null;
        if (store == null) {
            store = new CommitStore(service);
            commits = new WeakReference<>(store);
        }
        return store;
    }
}

<code block>

package com.github.pockethub;

import com.github.pockethub.core.search.SearchUserService;
import com.google.inject.AbstractModule;
import com.google.inject.Provides;

import java.io.IOException;

import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.client.GitHubClient;
import org.eclipse.egit.github.core.service.CollaboratorService;
import org.eclipse.egit.github.core.service.CommitService;
import org.eclipse.egit.github.core.service.ContentsService;
import org.eclipse.egit.github.core.service.DataService;
import org.eclipse.egit.github.core.service.EventService;
import org.eclipse.egit.github.core.service.GistService;
import org.eclipse.egit.github.core.service.IssueService;
import org.eclipse.egit.github.core.service.LabelService;
import org.eclipse.egit.github.core.service.MarkdownService;
import org.eclipse.egit.github.core.service.MilestoneService;
import org.eclipse.egit.github.core.service.OrganizationService;
import org.eclipse.egit.github.core.service.PullRequestService;
import org.eclipse.egit.github.core.service.RepositoryService;
import org.eclipse.egit.github.core.service.TeamService;
import org.eclipse.egit.github.core.service.UserService;
import org.eclipse.egit.github.core.service.WatcherService;


public class ServicesModule extends AbstractModule {

    @Override
    protected void configure() {
    }

    @Provides
    IssueService issueService(GitHubClient client) {
        return new IssueService(client);
    }

    @Provides
    PullRequestService pullRequestService(GitHubClient client) {
        return new PullRequestService(client);
    }

    @Provides
    UserService userService(GitHubClient client) {
        return new UserService(client);
    }

    @Provides
    SearchUserService searchUserService(GitHubClient client) {
        return new SearchUserService(client);
    }

    @Provides
    GistService gistService(GitHubClient client) {
        return new GistService(client);
    }

    @Provides
    OrganizationService orgService(GitHubClient client) {
        return new OrganizationService(client);
    }

    @Provides
    RepositoryService repoService(GitHubClient client) {
        return new RepositoryService(client);
    }

    @Provides
    User currentUser(UserService userService) throws IOException {
        return userService.getUser();
    }

    @Provides
    CollaboratorService collaboratorService(GitHubClient client) {
        return new CollaboratorService(client);
    }

    @Provides
    MilestoneService milestoneService(GitHubClient client) {
        return new MilestoneService(client);
    }

    @Provides
    LabelService labelService(GitHubClient client) {
        return new LabelService(client);
    }

    @Provides
    EventService eventService(GitHubClient client) {
        return new EventService(client);
    }

    @Provides
    WatcherService watcherService(GitHubClient client) {
        return new WatcherService(client);
    }

    @Provides
    CommitService commitService(GitHubClient client) {
        return new CommitService(client);
    }

    @Provides
    DataService dataService(GitHubClient client) {
        return new DataService(client);
    }

    @Provides
    MarkdownService markdownService(GitHubClient client) {
        return new MarkdownService(client);
    }

    @Provides
    ContentsService contentsService(GitHubClient client) {
        return new ContentsService(client);
    }

    @Provides
    TeamService teamService(GitHubClient client) {
        return new TeamService(client);
    }
}

<code block>

package com.github.pockethub;

import android.accounts.Account;
import android.content.Context;
import android.util.Log;

import com.github.pockethub.accounts.AccountUtils;
import com.github.pockethub.accounts.AuthenticatedUserLoader;


public abstract class ThrowableLoader<D> extends AuthenticatedUserLoader<D> {

    private static final String TAG = "ThrowableLoader";

    private final D data;

    private Exception exception;


    public ThrowableLoader(Context context, D data) {
        super(context);

        this.data = data;
    }

    @Override
    protected D getAccountFailureData() {
        return data;
    }

    @Override
    public D load(final Account account) {
        exception = null;
        try {
            return loadData();
        } catch (Exception e) {
            if (AccountUtils.isUnauthorized(e)
                    && AccountUtils.updateAccount(account, activity))
                try {
                    return loadData();
                } catch (Exception e2) {
                    e = e2;
                }
            Log.d(TAG, "Exception loading data", e);
            exception = e;
            return data;
        }
    }


    public Exception getException() {
        return exception;
    }


    public Exception clearException() {
        final Exception throwable = exception;
        exception = null;
        return throwable;
    }


    public abstract D loadData() throws Exception;
}

<code block>

package com.github.pockethub.core;


public interface OnLoadListener<V> {


  void loaded(V data);
}

<code block>

package com.github.pockethub.core;

import android.text.TextUtils;

import java.util.regex.Matcher;


public abstract class UrlMatcher {


    protected boolean isMatch(final String url, final Matcher matcher) {
        return !TextUtils.isEmpty(url) && matcher.reset(url).matches();
    }
}

<code block>

package com.github.pockethub.core;

import java.lang.ref.ReferenceQueue;
import java.lang.ref.WeakReference;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;


public abstract class ItemStore {

    private static class ItemReference<V> extends WeakReference<V> {

        private Object id;


        public ItemReference(V item, Object id, ReferenceQueue<? super V> queue) {
            super(item, queue);
            this.id = id;
        }
    }


    protected static class ItemReferences<V> {

        private final ReferenceQueue<V> queue;

        private final Map<Object, ItemReference<V>> items;


        public ItemReferences() {
            queue = new ReferenceQueue<>();
            items = new ConcurrentHashMap<>();
        }

        @SuppressWarnings("rawtypes")
        private void expungeEntries() {
            ItemReference ref;
            while ((ref = (ItemReference) queue.poll()) != null)
                items.remove(ref.id);
        }


        public V get(final Object id) {
            expungeEntries();
            WeakReference<V> ref = items.get(id);
            return ref != null ? ref.get() : null;
        }


        public void put(Object id, V item) {
            expungeEntries();
            items.put(id, new ItemReference<>(item, id, queue));
        }
    }
}

<code block>

package com.github.pockethub.core;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.egit.github.core.client.NoSuchPageException;
import org.eclipse.egit.github.core.client.PageIterator;


public abstract class ResourcePager<E> {


    protected int page = 1;


    protected int count = 1;


    protected final Map<Object, E> resources = new LinkedHashMap<>();


    protected boolean hasMore;


    public ResourcePager<E> reset() {
        page = 1;
        return clear();
    }


    public ResourcePager<E> clear() {
        count = Math.max(1, page - 1);
        page = 1;
        resources.clear();
        hasMore = true;
        return this;
    }


    public int size() {
        return resources.size();
    }


    public List<E> getResources() {
        return new ArrayList<>(resources.values());
    }


    public boolean next() throws IOException {
        boolean emptyPage = false;
        PageIterator<E> iterator = createIterator(page, -1);
        try {
            for (int i = 0; i < count && iterator.hasNext(); i++) {
                Collection<E> resourcePage = iterator.next();
                emptyPage = resourcePage.isEmpty();
                if (emptyPage)
                    break;
                for (E resource : resourcePage) {
                    resource = register(resource);
                    if (resource == null)
                        continue;
                    resources.put(getId(resource), resource);
                }
            }

            if (count > 1) {
                page = count;
                count = 1;
            }

            page++;
        } catch (NoSuchPageException e) {
            hasMore = false;
            throw e.getCause();
        }
        hasMore = iterator.hasNext() && !emptyPage;
        return hasMore;
    }


    public boolean hasMore() {
        return hasMore;
    }


    protected E register(final E resource) {
        return resource;
    }


    protected abstract Object getId(E resource);


    public abstract PageIterator<E> createIterator(final int page,
            final int size);
}

<code block>

package com.github.pockethub.core.user;

import android.accounts.Account;
import android.content.Context;
import android.util.Log;

import com.github.pockethub.accounts.AuthenticatedUserTask;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.service.UserService;


public class RefreshUserTask extends AuthenticatedUserTask<User> {

    private static final String TAG = "RefreshUserTask";

    @Inject
    private UserService service;

    private final String login;


    public RefreshUserTask(Context context, String login) {
        super(context);

        this.login = login;
    }

    @Override
    protected User run(Account account) throws Exception {
        return service.getUser(login);
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception loading user", e);
    }
}
<code block>

package com.github.pockethub.core.user;

import android.net.Uri;

import com.github.pockethub.core.repo.RepositoryUtils;

import java.util.List;

import org.eclipse.egit.github.core.User;


public class UserUriMatcher {


    public static User getUser(Uri uri) {
        List<String> segments = uri.getPathSegments();
        if (segments == null)
            return null;
        if (segments.size() < 1)
            return null;

        String login = segments.get(0);
        if (!RepositoryUtils.isValidOwner(login))
            return null;

        return new User().setLogin(login);
    }
}

<code block>

package com.github.pockethub.core.user;

import org.eclipse.egit.github.core.service.UserService;

import android.accounts.Account;
import android.content.Context;
import android.util.Log;

import com.github.pockethub.accounts.AuthenticatedUserTask;
import com.google.inject.Inject;


public class FollowingUserTask extends AuthenticatedUserTask<Boolean> {

    private static final String TAG = "FollowingUserTask";

    @Inject
    private UserService service;

    private final String login;


    public FollowingUserTask(final Context context, final String login) {
        super(context);

        this.login = login;
    }

    @Override
    protected Boolean run(final Account account) throws Exception {
        return service.isFollowing(login);
    }

    @Override
    protected void onException(final Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception checking if following user", e);
    }
}

<code block>

package com.github.pockethub.core.user;

import android.accounts.Account;
import android.content.Context;
import android.util.Log;

import com.github.pockethub.R;
import com.github.pockethub.ui.ProgressDialogTask;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.service.UserService;


public class UnfollowUserTask extends ProgressDialogTask<User> {

    private static final String TAG = "UnfollowUserTask";

    @Inject
    private UserService service;

    private final String login;


    public UnfollowUserTask(final Context context, final String login) {
        super(context);

        this.login = login;
    }


    public void start() {
        showIndeterminate(R.string.unfollowing_user);

        execute();
    }

    @Override
    protected User run(final Account account) throws Exception {
        service.unfollow(login);

        return null;
    }

    @Override
    protected void onException(final Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception unfollowing user", e);
    }
}

<code block>

package com.github.pockethub.core.user;

import android.accounts.Account;
import android.content.Context;
import android.util.Log;

import com.github.pockethub.R;
import com.github.pockethub.ui.ProgressDialogTask;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.service.UserService;


public class FollowUserTask extends ProgressDialogTask<User> {

    private static final String TAG = "FollowUserTask";

    @Inject
    private UserService service;

    private final String login;


    public FollowUserTask(final Context context, final String login) {
        super(context);

        this.login = login;
    }


    public void start() {
        showIndeterminate(R.string.following_user);

        execute();
    }

    @Override
    protected User run(final Account account) throws Exception {
        service.follow(login);

        return null;
    }

    @Override
    protected void onException(final Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception following user", e);
    }
}

<code block>

package com.github.pockethub.core.user;

import static java.lang.String.CASE_INSENSITIVE_ORDER;

import com.github.pockethub.accounts.GitHubAccount;
import com.google.inject.Inject;

import java.util.Comparator;

import org.eclipse.egit.github.core.User;


public class UserComparator implements Comparator<User> {

    private final String login;


    @Inject
    public UserComparator(final GitHubAccount account) {
        login = account.getUsername();
    }

    @Override
    public int compare(final User lhs, final User rhs) {
        final String lhsLogin = lhs.getLogin();
        final String rhsLogin = rhs.getLogin();

        if (lhsLogin.equals(login))
            return rhsLogin.equals(login) ? 0 : -1;

        if (rhsLogin.equals(login))
            return lhsLogin.equals(login) ? 0 : 1;

        return CASE_INSENSITIVE_ORDER.compare(lhsLogin, rhsLogin);
    }
}

<code block>

package com.github.pockethub.core.user;

import static org.eclipse.egit.github.core.event.Event.TYPE_FOLLOW;

import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.event.Event;
import org.eclipse.egit.github.core.event.EventPayload;
import org.eclipse.egit.github.core.event.FollowPayload;


public class UserEventMatcher {


    public static class UserPair {


        public final User from;


        public final User to;

        private UserPair(final User from, final User to) {
            this.from = from;
            this.to = to;
        }
    }


    public UserPair getUsers(final Event event) {
        if (event == null)
            return null;

        EventPayload payload = event.getPayload();
        if (payload == null)
            return null;

        String type = event.getType();
        if (TYPE_FOLLOW.equals(type)) {
            User from = event.getActor();
            User to = ((FollowPayload) event.getPayload()).getTarget();
            if (from != null && to != null)
                return new UserPair(from, to);
        }

        return null;
    }
}

<code block>

package com.github.pockethub.core.user;

import com.github.pockethub.core.ResourcePager;

import org.eclipse.egit.github.core.User;


public abstract class UserPager extends ResourcePager<User> {

    @Override
    protected Object getId(User resource) {
        return resource.getId();
    }
}

<code block>

package com.github.pockethub.core.issue;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.IssueEvent;


public class FullIssue extends ArrayList<Comment> implements Serializable {

    private static final long serialVersionUID = 4586476132467323827L;

    private final Issue issue;

    private Collection<IssueEvent> events;


    public FullIssue(final Issue issue, final Collection<Comment> comments, final Collection<IssueEvent> events) {
        super(comments);

        this.events = events;
        this.issue = issue;
    }


    public FullIssue() {
        this.issue = null;
    }


    public Issue getIssue() {
        return issue;
    }



    public Collection<IssueEvent> getEvents() {
        return events;
    }

}

<code block>

package com.github.pockethub.core.issue;

import static org.eclipse.egit.github.core.event.Event.TYPE_ISSUES;
import static org.eclipse.egit.github.core.event.Event.TYPE_ISSUE_COMMENT;
import static org.eclipse.egit.github.core.event.Event.TYPE_PULL_REQUEST;

import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.event.Event;
import org.eclipse.egit.github.core.event.EventPayload;
import org.eclipse.egit.github.core.event.IssueCommentPayload;
import org.eclipse.egit.github.core.event.IssuesPayload;
import org.eclipse.egit.github.core.event.PullRequestPayload;


public class IssueEventMatcher {


    public Issue getIssue(Event event) {
        if (event == null)
            return null;
        EventPayload payload = event.getPayload();
        if (payload == null)
            return null;
        String type = event.getType();
        if (TYPE_ISSUES.equals(type))
            return ((IssuesPayload) payload).getIssue();
        else if (TYPE_ISSUE_COMMENT.equals(type))
            return ((IssueCommentPayload) payload).getIssue();
        else if (TYPE_PULL_REQUEST.equals(type))
            return IssueUtils.toIssue(((PullRequestPayload) payload)
                    .getPullRequest());
        else
            return null;
    }
}

<code block>

package com.github.pockethub.core.issue;

import static java.lang.String.CASE_INSENSITIVE_ORDER;
import static org.eclipse.egit.github.core.service.IssueService.DIRECTION_DESCENDING;
import static org.eclipse.egit.github.core.service.IssueService.FIELD_DIRECTION;
import static org.eclipse.egit.github.core.service.IssueService.FIELD_SORT;
import static org.eclipse.egit.github.core.service.IssueService.FILTER_ASSIGNEE;
import static org.eclipse.egit.github.core.service.IssueService.FILTER_LABELS;
import static org.eclipse.egit.github.core.service.IssueService.FILTER_MILESTONE;
import static org.eclipse.egit.github.core.service.IssueService.FILTER_STATE;
import static org.eclipse.egit.github.core.service.IssueService.SORT_CREATED;
import static org.eclipse.egit.github.core.service.IssueService.STATE_CLOSED;
import static org.eclipse.egit.github.core.service.IssueService.STATE_OPEN;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

import org.eclipse.egit.github.core.Label;
import org.eclipse.egit.github.core.Milestone;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;


public class IssueFilter implements Serializable, Cloneable, Comparator<Label> {


    private static final long serialVersionUID = 7310646589186299063L;

    private final Repository repository;

    private Set<Label> labels;

    private Milestone milestone;

    private User assignee;

    private boolean open;


    public IssueFilter(final Repository repository) {
        this.repository = repository;
        open = true;
    }


    public IssueFilter setOpen(final boolean open) {
        this.open = open;
        return this;
    }


    public IssueFilter addLabel(Label label) {
        if (label == null)
            return this;
        if (labels == null)
            labels = new TreeSet<>(this);
        labels.add(label);
        return this;
    }


    public IssueFilter setLabels(Collection<Label> labels) {
        if (labels != null && !labels.isEmpty()) {
            if (this.labels == null)
                this.labels = new TreeSet<>(this);
            else
                this.labels.clear();
            this.labels.addAll(labels);
        } else
            this.labels = null;
        return this;
    }


    public Set<Label> getLabels() {
        return labels;
    }


    public Repository getRepository() {
        return repository;
    }


    public IssueFilter setMilestone(Milestone milestone) {
        this.milestone = milestone;
        return this;
    }


    public Milestone getMilestone() {
        return milestone;
    }


    public IssueFilter setAssignee(User assignee) {
        this.assignee = assignee;
        return this;
    }


    public boolean isOpen() {
        return open;
    }


    public User getAssignee() {
        return assignee;
    }


    public Map<String, String> toFilterMap() {
        final Map<String, String> filter = new HashMap<>();

        filter.put(FIELD_SORT, SORT_CREATED);
        filter.put(FIELD_DIRECTION, DIRECTION_DESCENDING);

        if (assignee != null)
            filter.put(FILTER_ASSIGNEE, assignee.getLogin());

        if (milestone != null)
            filter.put(FILTER_MILESTONE,
                    Integer.toString(milestone.getNumber()));

        if (labels != null && !labels.isEmpty()) {
            StringBuilder labelsQuery = new StringBuilder();
            for (Label label : labels)
                labelsQuery.append(label.getName()).append(',');
            filter.put(FILTER_LABELS, labelsQuery.toString());
        }

        if (open)
            filter.put(FILTER_STATE, STATE_OPEN);
        else
            filter.put(FILTER_STATE, STATE_CLOSED);
        return filter;
    }


    public CharSequence toDisplay() {
        List<String> segments = new ArrayList<>();
        if (open)
            segments.add("Open issues");
        else
            segments.add("Closed issues");

        if (assignee != null)
            segments.add("Assignee: " + assignee.getLogin());

        if (milestone != null)
            segments.add("Milestone: " + milestone.getTitle());

        if (labels != null && !labels.isEmpty()) {
            StringBuilder builder = new StringBuilder("Labels: ");
            for (Label label : labels)
                builder.append(label.getName()).append(',').append(' ');
            builder.deleteCharAt(builder.length() - 1);
            builder.deleteCharAt(builder.length() - 1);
            segments.add(builder.toString());
        }

        if (segments.isEmpty())
            return "";

        StringBuilder all = new StringBuilder();
        for (String segment : segments)
            all.append(segment).append(',').append(' ');
        all.deleteCharAt(all.length() - 1);
        all.deleteCharAt(all.length() - 1);
        return all;
    }

    @Override
    public int hashCode() {
        return Arrays.hashCode(new Object[] { open,
                assignee != null ? assignee.getId() : null,
                milestone != null ? milestone.getNumber() : null,
                assignee != null ? assignee.getId() : null,
                repository != null ? repository.getId() : null, labels });
    }

    private boolean isEqual(Object a, Object b) {
        if (a == null && b == null)
            return true;
        return a != null && a.equals(b);
    }

    private boolean isEqual(Milestone a, Milestone b) {
        if (a == null && b == null)
            return true;
        return a != null && b != null && a.getNumber() == b.getNumber();
    }

    private boolean isEqual(User a, User b) {
        if (a == null && b == null)
            return true;
        return a != null && b != null && a.getId() == b.getId();
    }

    private boolean isEqual(Repository a, Repository b) {
        return a != null && b != null && a.getId() == b.getId();
    }

    @Override
    public boolean equals(Object o) {
        if (o == this)
            return true;
        if (!(o instanceof IssueFilter))
            return false;

        IssueFilter other = (IssueFilter) o;
        return open == other.open && isEqual(milestone, other.milestone)
                && isEqual(assignee, other.assignee)
                && isEqual(repository, repository)
                && isEqual(labels, other.labels);
    }

    @Override
    public IssueFilter clone() {
        try {
            return (IssueFilter) super.clone();
        } catch (CloneNotSupportedException e) {

            throw new IllegalArgumentException(e);
        }
    }

    @Override
    public int compare(Label lhs, Label rhs) {
        return CASE_INSENSITIVE_ORDER.compare(lhs.getName(), rhs.getName());
    }
}

<code block>

package com.github.pockethub.core.issue;

import android.text.TextUtils;

import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.PullRequest;


public class IssueUtils {


    public static boolean isPullRequest(final Issue issue) {
        return issue != null && issue.getPullRequest() != null
                && !TextUtils.isEmpty(issue.getPullRequest().getHtmlUrl());
    }


    public static Issue toIssue(final PullRequest pullRequest) {
        if (pullRequest == null)
            return null;

        Issue issue = new Issue();
        issue.setAssignee(pullRequest.getAssignee());
        issue.setBody(pullRequest.getBody());
        issue.setBodyHtml(pullRequest.getBodyHtml());
        issue.setBodyText(pullRequest.getBodyText());
        issue.setClosedAt(pullRequest.getClosedAt());
        issue.setComments(pullRequest.getComments());
        issue.setCreatedAt(pullRequest.getCreatedAt());
        issue.setHtmlUrl(pullRequest.getHtmlUrl());
        issue.setId(pullRequest.getId());
        issue.setMilestone(pullRequest.getMilestone());
        issue.setNumber(pullRequest.getNumber());
        issue.setPullRequest(pullRequest);
        issue.setState(pullRequest.getState());
        issue.setTitle(pullRequest.getTitle());
        issue.setUpdatedAt(pullRequest.getUpdatedAt());
        issue.setUrl(pullRequest.getUrl());
        issue.setUser(pullRequest.getUser());
        return issue;
    }
}

<code block>

package com.github.pockethub.core.issue;

import android.net.Uri;
import android.text.TextUtils;

import com.github.pockethub.core.repo.RepositoryUtils;

import java.util.List;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.RepositoryIssue;
import org.eclipse.egit.github.core.User;


public class IssueUriMatcher {


    public static RepositoryIssue getIssue(Uri uri) {
        List<String> segments = uri.getPathSegments();
        if (segments == null)
            return null;
        if (segments.size() < 4)
            return null;
        if (!"issues".equals(segments.get(2)) && !"pull".equals(segments.get(2)))
            return null;

        String repoOwner = segments.get(0);
        if (!RepositoryUtils.isValidOwner(repoOwner))
            return null;

        String repoName = segments.get(1);
        if (!RepositoryUtils.isValidRepo(repoName))
            return null;

        String number = segments.get(3);
        if (TextUtils.isEmpty(number))
            return null;

        int issueNumber;
        try {
            issueNumber = Integer.parseInt(number);
        } catch (NumberFormatException nfe) {
            return null;
        }
        if (issueNumber < 1)
            return null;

        Repository repo = new Repository();
        repo.setName(repoName);
        repo.setOwner(new User().setLogin(repoOwner));
        RepositoryIssue issue = new RepositoryIssue();
        issue.setRepository(repo);
        issue.setNumber(issueNumber);
        return issue;
    }
}

<code block>

package com.github.pockethub.core.issue;

import com.github.pockethub.core.ItemStore;
import com.github.pockethub.util.HtmlUtils;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.RepositoryId;
import org.eclipse.egit.github.core.RepositoryIssue;
import org.eclipse.egit.github.core.client.RequestException;
import org.eclipse.egit.github.core.service.IssueService;
import org.eclipse.egit.github.core.service.PullRequestService;


public class IssueStore extends ItemStore {

    private final Map<String, ItemReferences<RepositoryIssue>> repos = new HashMap<>();

    private final IssueService issueService;

    private final PullRequestService pullService;


    public IssueStore(final IssueService issueService,
            final PullRequestService pullService) {
        this.issueService = issueService;
        this.pullService = pullService;
    }


    public RepositoryIssue getIssue(IRepositoryIdProvider repository, int number) {
        ItemReferences<RepositoryIssue> repoIssues = repos.get(repository
                .generateId());
        return repoIssues != null ? repoIssues.get(number) : null;
    }


    public RepositoryIssue addIssue(Issue issue) {
        IRepositoryIdProvider repo = null;
        if (issue instanceof RepositoryIssue)
            repo = ((RepositoryIssue) issue).getRepository();
        if (repo == null)
            repo = RepositoryId.createFromUrl(issue.getHtmlUrl());
        return addIssue(repo, issue);
    }

    private RepositoryIssue createRepositoryIssue(Issue issue) {
        if (issue instanceof RepositoryIssue)
            return (RepositoryIssue) issue;

        RepositoryIssue repoIssue = new RepositoryIssue();
        repoIssue.setAssignee(issue.getAssignee());
        repoIssue.setBody(issue.getBody());
        repoIssue.setBodyHtml(issue.getBodyHtml());
        repoIssue.setBodyText(issue.getBodyText());
        repoIssue.setClosedAt(issue.getClosedAt());
        repoIssue.setComments(issue.getComments());
        repoIssue.setCreatedAt(issue.getCreatedAt());
        repoIssue.setHtmlUrl(issue.getHtmlUrl());
        repoIssue.setId(issue.getId());
        repoIssue.setLabels(issue.getLabels());
        repoIssue.setMilestone(issue.getMilestone());
        repoIssue.setNumber(issue.getNumber());
        repoIssue.setPullRequest(issue.getPullRequest());
        repoIssue.setState(issue.getState());
        repoIssue.setTitle(issue.getTitle());
        repoIssue.setUpdatedAt(issue.getUpdatedAt());
        repoIssue.setUrl(issue.getUrl());
        repoIssue.setUser(issue.getUser());
        return repoIssue;
    }


    public RepositoryIssue addIssue(IRepositoryIdProvider repository,
            Issue issue) {
        issue.setBodyHtml(HtmlUtils.format(issue.getBodyHtml()).toString());
        RepositoryIssue current = getIssue(repository, issue.getNumber());
        if (current != null) {
            current.setAssignee(issue.getAssignee());
            current.setBody(issue.getBody());
            current.setBodyHtml(issue.getBodyHtml());
            current.setClosedAt(issue.getClosedAt());
            current.setComments(issue.getComments());
            current.setLabels(issue.getLabels());
            current.setMilestone(issue.getMilestone());
            current.setPullRequest(issue.getPullRequest());
            current.setState(issue.getState());
            current.setTitle(issue.getTitle());
            current.setUpdatedAt(issue.getUpdatedAt());
            if (issue instanceof RepositoryIssue)
                current.setRepository(((RepositoryIssue) issue).getRepository());
            return current;
        } else {
            String repoId = repository.generateId();
            ItemReferences<RepositoryIssue> repoIssues = repos.get(repoId);
            if (repoIssues == null) {
                repoIssues = new ItemReferences<>();
                repos.put(repoId, repoIssues);
            }
            RepositoryIssue repoIssue = createRepositoryIssue(issue);
            repoIssues.put(issue.getNumber(), repoIssue);
            return repoIssue;
        }
    }


    public RepositoryIssue refreshIssue(IRepositoryIdProvider repository,
            int number) throws IOException {
        Issue issue;
        try {
            issue = issueService.getIssue(repository, number);
            if (IssueUtils.isPullRequest(issue))
                issue = IssueUtils.toIssue(pullService.getPullRequest(
                    repository, number));
        } catch (IOException e) {
            if (e instanceof RequestException
                    && 410 == ((RequestException) e).getStatus())
                try {
                    issue = IssueUtils.toIssue(pullService.getPullRequest(
                            repository, number));
                } catch (IOException e2) {
                    throw e;
                }
            else
                throw e;
        }
        return addIssue(repository, issue);
    }


    public RepositoryIssue editIssue(IRepositoryIdProvider repository,
            Issue issue) throws IOException {
        return addIssue(repository, issueService.editIssue(repository, issue));
    }
}

<code block>

package com.github.pockethub.core.issue;

import com.github.pockethub.core.ResourcePager;

import org.eclipse.egit.github.core.Issue;


public abstract class IssuePager extends ResourcePager<Issue> {


    protected final IssueStore store;


    public IssuePager(final IssueStore store) {
        this.store = store;
    }

    @Override
    protected Issue register(Issue resource) {
        return store.addIssue(resource);
    }

    @Override
    protected Object getId(Issue resource) {
        return resource.getId();
    }
}

<code block>

package com.github.pockethub.core.issue;

import android.accounts.Account;
import android.content.Context;
import android.util.Log;

import com.github.pockethub.accounts.AuthenticatedUserTask;
import com.github.pockethub.util.HtmlUtils;
import com.github.pockethub.util.HttpImageGetter;
import com.google.inject.Inject;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.IssueEvent;
import org.eclipse.egit.github.core.service.IssueService;


public class RefreshIssueTask extends AuthenticatedUserTask<FullIssue> {

    private static final String TAG = "RefreshIssueTask";

    @Inject
    private IssueService service;

    @Inject
    private IssueStore store;

    private final IRepositoryIdProvider repositoryId;

    private final int issueNumber;

    private final HttpImageGetter bodyImageGetter;

    private final HttpImageGetter commentImageGetter;


    public RefreshIssueTask(Context context,
            IRepositoryIdProvider repositoryId, int issueNumber,
            HttpImageGetter bodyImageGetter, HttpImageGetter commentImageGetter) {
        super(context);

        this.repositoryId = repositoryId;
        this.issueNumber = issueNumber;
        this.bodyImageGetter = bodyImageGetter;
        this.commentImageGetter = commentImageGetter;
    }

    @Override
    public FullIssue run(Account account) throws Exception {
        Issue issue = store.refreshIssue(repositoryId, issueNumber);
        bodyImageGetter.encode(issue.getId(), issue.getBodyHtml());
        List<Comment> comments;
        if (issue.getComments() > 0)
            comments = service.getComments(repositoryId, issueNumber);
        else
            comments = Collections.emptyList();

        for (Comment comment : comments) {
            String formatted = HtmlUtils.format(comment.getBodyHtml())
                    .toString();
            comment.setBodyHtml(formatted);
            commentImageGetter.encode(comment.getId(), formatted);
        }

        String[] repo = repositoryId.generateId().split("/");
        Iterator<Collection<IssueEvent>> eventsIterator = service.pageIssueEvents(repo[0], repo[1], issueNumber).iterator();
        List<IssueEvent> events = new ArrayList<>();

        while (eventsIterator.hasNext())
            events.addAll(eventsIterator.next());

        return new FullIssue(issue, comments, events);
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception loading issue", e);
    }
}

<code block>

package com.github.pockethub.core.search;

import java.io.Serializable;
import java.util.Date;

import org.eclipse.egit.github.core.util.DateUtils;


public class SearchUser implements Serializable {


    private static final long serialVersionUID = 159979362732689788L;

    private Date createdAt;

    private int followers;

    private String id;

    private String gravatarId;

    private String location;

    private String login;

    private String name;

    private String language;


    public Date getCreatedAt() {
        return DateUtils.clone(createdAt);
    }


    public SearchUser setCreatedAt(Date createdAt) {
        this.createdAt = DateUtils.clone(createdAt);
        return this;
    }


    public int getFollowers() {
        return followers;
    }


    public SearchUser setFollowers(int followers) {
        this.followers = followers;
        return this;
    }


    public String getId() {
        return id;
    }


    public SearchUser setId(String id) {
        this.id = id;
        return this;
    }


    public String getGravatarId() {
        return gravatarId;
    }


    public SearchUser setGravatarId(String gravatarId) {
        this.gravatarId = gravatarId;
        return this;
    }


    public String getLocation() {
        return location;
    }


    public SearchUser setLocation(String location) {
        this.location = location;
        return this;
    }


    public String getLogin() {
        return login;
    }


    public SearchUser setLogin(String login) {
        this.login = login;
        return this;
    }


    public String getName() {
        return name;
    }


    public SearchUser setName(String name) {
        this.name = name;
        return this;
    }


    public String getLanguage() {
        return language;
    }


    public SearchUser setLanguage(String language) {
        this.language = language;
        return this;
    }
}

<code block>

package com.github.pockethub.core.search;

import static org.eclipse.egit.github.core.client.IGitHubConstants.CHARSET_UTF8;
import static org.eclipse.egit.github.core.client.IGitHubConstants.PARAM_START_PAGE;
import static org.eclipse.egit.github.core.client.IGitHubConstants.SEGMENT_USER;
import static org.eclipse.egit.github.core.client.IGitHubConstants.SEGMENT_LEGACY;
import static org.eclipse.egit.github.core.client.IGitHubConstants.SEGMENT_SEARCH;

import java.io.IOException;
import java.net.URLEncoder;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.egit.github.core.IResourceProvider;
import org.eclipse.egit.github.core.client.GitHubClient;
import org.eclipse.egit.github.core.client.PagedRequest;
import org.eclipse.egit.github.core.service.UserService;

public class SearchUserService extends UserService {

    private static class UserContainer implements
            IResourceProvider<SearchUser> {

        private List<SearchUser> users;


        @Override
        public List<SearchUser> getResources() {
            return users;
        }
    }


    public SearchUserService() {
        super();
    }


    public SearchUserService(GitHubClient client) {
        super(client);
    }


    public List<SearchUser> searchUsers(final String query)
            throws IOException {
        return searchUsers(query, -1);
    }


    public List<SearchUser> searchUsers(final String query,
            final int startPage) throws IOException {
        if (query == null)
            throw new IllegalArgumentException("Query cannot be null"); 
        if (query.length() == 0)
            throw new IllegalArgumentException("Query cannot be empty"); 

        StringBuilder uri = new StringBuilder(SEGMENT_LEGACY + SEGMENT_USER
                + SEGMENT_SEARCH);
        final String encodedQuery = URLEncoder.encode(query, CHARSET_UTF8)
                .replace("+", "%20") 
                .replace(".", "%2E"); 
        uri.append('/').append(encodedQuery);

        PagedRequest<SearchUser> request = createPagedRequest();

        Map<String, String> params = new HashMap<>(2, 1);
        if (startPage > 0)
            params.put(PARAM_START_PAGE, Integer.toString(startPage));
        if (!params.isEmpty())
            request.setParams(params);

        request.setUri(uri);
        request.setType(UserContainer.class);
        return getAll(request);
    }


    public List<SearchUser> searchUsers(
            final Map<String, String> params) throws IOException {
        return searchUsers(params, -1);
    }


    public List<SearchUser> searchUsers(
            final Map<String, String> queryParams, final int startPage)
            throws IOException {
        if (queryParams == null)
            throw new IllegalArgumentException("Params cannot be null"); 
        if (queryParams.isEmpty())
            throw new IllegalArgumentException("Params cannot be empty"); 

        StringBuilder query = new StringBuilder();
        for (Map.Entry<String, String> param : queryParams.entrySet())
            query.append(param.getKey()).append(':').append(param.getValue())
                .append(' ');
        return searchUsers(query.toString(), startPage);
    }
}

<code block>

package com.github.pockethub.core.commit;

import android.net.Uri;

import com.github.pockethub.core.repo.RepositoryUtils;

import java.util.List;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;


public class CommitUriMatcher {


    public static CommitMatch getCommit(Uri uri) {
        List<String> segments = uri.getPathSegments();
        if (segments == null)
            return null;
        if (segments.size() < 4)
            return null;
        if (!"commit".equals(segments.get(2)))
            return null;

        String repoOwner = segments.get(0);
        if (!RepositoryUtils.isValidOwner(repoOwner))
            return null;

        String repoName = segments.get(1);
        if (!RepositoryUtils.isValidRepo(repoName))
            return null;

        String commit = segments.get(3);
        if (!CommitUtils.isValidCommit(commit))
            return null;

        Repository repository = new Repository();
        repository.setName(repoName);
        repository.setOwner(new User().setLogin(repoOwner));
        return new CommitMatch(repository, commit);
    }
}

<code block>

package com.github.pockethub.core.commit;

import android.text.TextUtils;
import android.widget.ImageView;

import com.github.pockethub.ui.StyledText;
import com.github.pockethub.util.AvatarLoader;

import java.text.NumberFormat;
import java.util.Collection;
import java.util.Date;

import org.eclipse.egit.github.core.Commit;
import org.eclipse.egit.github.core.CommitFile;
import org.eclipse.egit.github.core.CommitUser;
import org.eclipse.egit.github.core.RepositoryCommit;
import org.eclipse.egit.github.core.User;


public class CommitUtils {


    public static final int LENGTH = 10;

    private static final NumberFormat FORMAT = NumberFormat
            .getIntegerInstance();


    public static String abbreviate(final RepositoryCommit commit) {
        return commit != null ? abbreviate(commit.getSha()) : null;
    }


    public static String abbreviate(final Commit commit) {
        return commit != null ? abbreviate(commit.getSha()) : null;
    }


    public static String abbreviate(final String sha) {
        if (!TextUtils.isEmpty(sha) && sha.length() > LENGTH)
            return sha.substring(0, LENGTH);
        else
            return sha;
    }


    public static boolean isValidCommit(final String sha) {
        return !TextUtils.isEmpty(sha) && sha.matches("[a-fA-F0-9]+");
    }


    public static String getAuthor(final RepositoryCommit commit) {
        User author = commit.getAuthor();
        if (author != null)
            return author.getLogin();

        Commit rawCommit = commit.getCommit();
        if (rawCommit == null)
            return null;

        CommitUser commitAuthor = rawCommit.getAuthor();
        return commitAuthor != null ? commitAuthor.getName() : null;
    }


    public static String getCommitter(final RepositoryCommit commit) {
        User committer = commit.getCommitter();
        if (committer != null)
            return committer.getLogin();

        Commit rawCommit = commit.getCommit();
        if (rawCommit == null)
            return null;

        CommitUser commitCommitter = rawCommit.getCommitter();
        return commitCommitter != null ? commitCommitter.getName() : null;
    }


    public static Date getAuthorDate(final RepositoryCommit commit) {
        Commit rawCommit = commit.getCommit();
        if (rawCommit == null)
            return null;

        CommitUser commitAuthor = rawCommit.getAuthor();
        return commitAuthor != null ? commitAuthor.getDate() : null;
    }


    public static Date getCommitterDate(final RepositoryCommit commit) {
        Commit rawCommit = commit.getCommit();
        if (rawCommit == null)
            return null;

        CommitUser commitCommitter = rawCommit.getCommitter();
        return commitCommitter != null ? commitCommitter.getDate() : null;
    }


    public static ImageView bindAuthor(final RepositoryCommit commit,
            final AvatarLoader avatars, final ImageView view) {
        User author = commit.getAuthor();
        if (author != null)
            avatars.bind(view, author);
        else {
            Commit rawCommit = commit.getCommit();
            if (rawCommit != null)
                avatars.bind(view, rawCommit.getAuthor());
        }
        return view;
    }


    public static ImageView bindCommitter(final RepositoryCommit commit,
            final AvatarLoader avatars, final ImageView view) {
        User committer = commit.getCommitter();
        if (committer != null)
            avatars.bind(view, committer);
        else {
            Commit rawCommit = commit.getCommit();
            if (rawCommit != null)
                avatars.bind(view, rawCommit.getCommitter());
        }
        return view;
    }


    public static String getCommentCount(final RepositoryCommit commit) {
        final Commit rawCommit = commit.getCommit();
        if (rawCommit != null)
            return FORMAT.format(rawCommit.getCommentCount());
        else
            return "0";
    }


    public static StyledText formatStats(final Collection<CommitFile> files) {
        StyledText fileDetails = new StyledText();
        int added = 0;
        int deleted = 0;
        int changed = 0;
        if (files != null)
            for (CommitFile file : files) {
                added += file.getAdditions();
                deleted += file.getDeletions();
                changed++;
            }

        if (changed != 1)
            fileDetails.append(FORMAT.format(changed)).append(" changed files");
        else
            fileDetails.append("1 changed file");
        fileDetails.append(" with ");

        if (added != 1)
            fileDetails.append(FORMAT.format(added)).append(" additions");
        else
            fileDetails.append("1 addition ");
        fileDetails.append(" and ");

        if (deleted != 1)
            fileDetails.append(FORMAT.format(deleted)).append(" deletions");
        else
            fileDetails.append("1 deletion");

        return fileDetails;
    }


    public static String getName(final CommitFile file) {
        return file != null ? getName(file.getFilename()) : null;
    }


    public static String getName(final String path) {
        if (TextUtils.isEmpty(path))
            return path;

        int lastSlash = path.lastIndexOf('/');
        if (lastSlash != -1 && lastSlash + 1 < path.length())
            return path.substring(lastSlash + 1);
        else
            return path;
    }
}

<code block>

package com.github.pockethub.core.commit;

import android.text.TextUtils;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import org.eclipse.egit.github.core.CommitComment;
import org.eclipse.egit.github.core.CommitFile;
import org.eclipse.egit.github.core.RepositoryCommit;


public class FullCommit extends ArrayList<CommitComment> implements
        Serializable {

    private static final long serialVersionUID = 2470370479577730822L;

    private final RepositoryCommit commit;

    private final List<FullCommitFile> files;


    public FullCommit(final RepositoryCommit commit) {
        this.commit = commit;
        List<CommitFile> rawFiles = commit.getFiles();
        if (rawFiles != null && !rawFiles.isEmpty()) {
            files = new ArrayList<>(rawFiles.size());
            for (CommitFile file : rawFiles)
                files.add(new FullCommitFile(file));
        } else
            files = Collections.emptyList();
    }


    public FullCommit(final RepositoryCommit commit,
            final Collection<CommitComment> comments) {
        this.commit = commit;

        List<CommitFile> rawFiles = commit.getFiles();
        boolean hasComments = comments != null && !comments.isEmpty();
        boolean hasFiles = rawFiles != null && !rawFiles.isEmpty();
        if (hasFiles) {
            files = new ArrayList<>(rawFiles.size());
            if (hasComments) {
                for (CommitFile file : rawFiles) {
                    Iterator<CommitComment> iterator = comments.iterator();
                    FullCommitFile full = new FullCommitFile(file);
                    while (iterator.hasNext()) {
                        CommitComment comment = iterator.next();
                        if (file.getFilename().equals(comment.getPath())) {
                            full.add(comment);
                            iterator.remove();
                        }
                    }
                    files.add(full);
                }
                hasComments = !comments.isEmpty();
            } else
                for (CommitFile file : rawFiles)
                    files.add(new FullCommitFile(file));
        } else
            files = Collections.emptyList();

        if (hasComments)
            addAll(comments);
    }

    @Override
    public boolean add(final CommitComment comment) {
        String path = comment.getPath();
        if (TextUtils.isEmpty(path))
            return super.add(comment);
        else {
            boolean added = false;
            for (FullCommitFile file : files)
                if (path.equals(file.getFile().getFilename())) {
                    file.add(comment);
                    added = true;
                    break;
                }
            if (!added)
                added = super.add(comment);
            return added;
        }
    }


    public List<FullCommitFile> getFiles() {
        return files;
    }


    public RepositoryCommit getCommit() {
        return commit;
    }
}

<code block>

package com.github.pockethub.core.commit;

import android.util.SparseArray;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.eclipse.egit.github.core.CommitComment;
import org.eclipse.egit.github.core.CommitFile;


public class FullCommitFile {

    private final SparseArray<List<CommitComment>> comments = new SparseArray<>(
            4);

    private final CommitFile file;


    public FullCommitFile(final CommitFile file) {
        this.file = file;
    }


    public List<CommitComment> get(final int line) {
        List<CommitComment> lineComments = comments.get(line);
        return lineComments != null ? lineComments : Collections
                .<CommitComment> emptyList();
    }


    public FullCommitFile add(final CommitComment comment) {
        int line = comment.getPosition();
        if (line >= 0) {
            List<CommitComment> lineComments = comments.get(line);
            if (lineComments == null) {
                lineComments = new ArrayList<>(4);
                comments.put(line, lineComments);
            }
            lineComments.add(comment);
        }
        return this;
    }


    public CommitFile getFile() {
        return file;
    }
}

<code block>

package com.github.pockethub.core.commit;

import org.eclipse.egit.github.core.Repository;


public class CommitMatch {


    public final Repository repository;


    public final String commit;


    public CommitMatch(final Repository repository, final String commit) {
        this.repository = repository;
        this.commit = commit;
    }
}

<code block>

package com.github.pockethub.core.commit;

import com.github.pockethub.core.ResourcePager;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.RepositoryCommit;


public abstract class CommitPager extends ResourcePager<RepositoryCommit> {

    private final IRepositoryIdProvider repository;

    private final CommitStore store;


    public CommitPager(final IRepositoryIdProvider repository,
            final CommitStore store) {
        this.repository = repository;
        this.store = store;
    }

    @Override
    protected Object getId(final RepositoryCommit resource) {
        return resource.getSha();
    }

    @Override
    protected RepositoryCommit register(final RepositoryCommit resource) {
        return store.addCommit(repository, resource);
    }
}

<code block>

package com.github.pockethub.core.commit;

import android.accounts.Account;
import android.content.Context;
import android.util.Log;

import com.github.pockethub.accounts.AuthenticatedUserTask;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.RepositoryCommitCompare;
import org.eclipse.egit.github.core.service.CommitService;


public class CommitCompareTask extends
        AuthenticatedUserTask<RepositoryCommitCompare> {

    private static final String TAG = "CommitCompareTask";

    @Inject
    private CommitService service;

    private final IRepositoryIdProvider repository;

    private final String base;

    private final String head;


    public CommitCompareTask(Context context, IRepositoryIdProvider repository,
            String base, String head) {
        super(context);

        this.repository = repository;
        this.base = base;
        this.head = head;
    }

    @Override
    protected RepositoryCommitCompare run(Account account) throws Exception {
        return service.compare(repository, base, head);
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception loading commit compare", e);
    }
}

<code block>

package com.github.pockethub.core.commit;

import com.github.pockethub.core.ItemStore;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.RepositoryCommit;
import org.eclipse.egit.github.core.service.CommitService;


public class CommitStore extends ItemStore {

    private final Map<String, ItemReferences<RepositoryCommit>> commits = new HashMap<>();

    private final CommitService service;


    public CommitStore(final CommitService service) {
        this.service = service;
    }


    public RepositoryCommit getCommit(final IRepositoryIdProvider repo,
            final String id) {
        final ItemReferences<RepositoryCommit> repoCommits = commits.get(repo
                .generateId());
        return repoCommits != null ? repoCommits.get(id) : null;
    }


    public RepositoryCommit addCommit(IRepositoryIdProvider repo,
            RepositoryCommit commit) {
        RepositoryCommit current = getCommit(repo, commit.getSha());
        if (current != null) {
            current.setAuthor(commit.getAuthor());
            current.setCommit(commit.getCommit());
            current.setCommitter(commit.getCommitter());
            current.setFiles(commit.getFiles());
            current.setParents(commit.getParents());
            current.setSha(commit.getSha());
            current.setStats(commit.getStats());
            current.setUrl(commit.getUrl());
            return current;
        } else {
            String repoId = repo.generateId();
            ItemReferences<RepositoryCommit> repoCommits = commits.get(repoId);
            if (repoCommits == null) {
                repoCommits = new ItemReferences<>();
                commits.put(repoId, repoCommits);
            }
            repoCommits.put(commit.getSha(), commit);
            return commit;
        }
    }


    public RepositoryCommit refreshCommit(final IRepositoryIdProvider repo,
            final String id) throws IOException {
        return addCommit(repo, service.getCommit(repo, id));
    }
}

<code block>

package com.github.pockethub.core.commit;

import android.accounts.Account;
import android.content.Context;
import android.util.Log;

import com.github.pockethub.accounts.AuthenticatedUserTask;
import com.github.pockethub.util.HtmlUtils;
import com.github.pockethub.util.HttpImageGetter;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.egit.github.core.Commit;
import org.eclipse.egit.github.core.CommitComment;
import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.RepositoryCommit;
import org.eclipse.egit.github.core.service.CommitService;


public class RefreshCommitTask extends AuthenticatedUserTask<FullCommit> {

    private static final String TAG = "RefreshCommitTask";

    @Inject
    private CommitStore store;

    @Inject
    private CommitService service;

    private final IRepositoryIdProvider repository;

    private final String id;

    private final HttpImageGetter imageGetter;


    public RefreshCommitTask(Context context, IRepositoryIdProvider repository,
            String id, HttpImageGetter imageGetter) {
        super(context);

        this.repository = repository;
        this.id = id;
        this.imageGetter = imageGetter;
    }

    @Override
    protected FullCommit run(Account account) throws Exception {
        RepositoryCommit commit = store.refreshCommit(repository, id);
        Commit rawCommit = commit.getCommit();
        if (rawCommit != null && rawCommit.getCommentCount() > 0) {
            List<CommitComment> comments = service.getComments(repository,
                    commit.getSha());
            for (CommitComment comment : comments) {
                String formatted = HtmlUtils.format(comment.getBodyHtml())
                        .toString();
                comment.setBodyHtml(formatted);
                imageGetter.encode(comment, formatted);
            }
            return new FullCommit(commit, comments);
        } else
            return new FullCommit(commit);
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception loading commit", e);
    }
}

<code block>

package com.github.pockethub.core.ref;

import android.text.TextUtils;

import org.eclipse.egit.github.core.Reference;


public class RefUtils {

    private static final String PREFIX_REFS = "refs/";

    private static final String PREFIX_PULL = PREFIX_REFS + "pull/";

    private static final String PREFIX_TAG = PREFIX_REFS + "tags/";

    private static final String PREFIX_HEADS = PREFIX_REFS + "heads/";


    public static boolean isBranch(final Reference ref) {
        if (ref != null) {
            String name = ref.getRef();
            return !TextUtils.isEmpty(name) && name.startsWith(PREFIX_HEADS);
        } else
            return false;
    }


    public static boolean isTag(final Reference ref) {
        return ref != null && isTag(ref.getRef());
    }


    public static boolean isTag(final String name) {
        return !TextUtils.isEmpty(name) && name.startsWith(PREFIX_TAG);
    }


    public static String getPath(final Reference ref) {
        if (ref == null)
            return null;
        String name = ref.getRef();
        if (!TextUtils.isEmpty(name) && name.startsWith(PREFIX_REFS))
            return name.substring(PREFIX_REFS.length());
        else
            return name;
    }


    public static String getName(final Reference ref) {
        if (ref != null)
            return getName(ref.getRef());
        else
            return null;
    }


    public static String getName(final String name) {
        if (TextUtils.isEmpty(name))
            return name;
        if (name.startsWith(PREFIX_HEADS))
            return name.substring(PREFIX_HEADS.length());
        else if (name.startsWith(PREFIX_TAG))
            return name.substring(PREFIX_TAG.length());
        else if (name.startsWith(PREFIX_REFS))
            return name.substring(PREFIX_REFS.length());
        else
            return name;
    }


    public static boolean isValid(final Reference ref) {
        if (ref == null)
            return false;

        String name = ref.getRef();
        return !TextUtils.isEmpty(name) && !name.startsWith(PREFIX_PULL);
    }
}

<code block>

package com.github.pockethub.core.gist;

import static java.lang.String.CASE_INSENSITIVE_ORDER;

import com.github.pockethub.core.ItemStore;

import java.io.IOException;
import java.util.Map;
import java.util.TreeMap;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.GistFile;
import org.eclipse.egit.github.core.service.GistService;


public class GistStore extends ItemStore {

    private final ItemReferences<Gist> gists = new ItemReferences<>();

    private final GistService service;


    public GistStore(final GistService service) {
        this.service = service;
    }


    public Gist getGist(String id) {
        return gists.get(id);
    }


    protected Map<String, GistFile> sortFiles(final Gist gist) {
        Map<String, GistFile> files = gist.getFiles();
        if (files == null || files.size() < 2)
            return files;

        Map<String, GistFile> sorted = new TreeMap<>(
                CASE_INSENSITIVE_ORDER);
        sorted.putAll(files);
        return sorted;
    }


    public Gist addGist(Gist gist) {
        Gist current = getGist(gist.getId());
        if (current != null) {
            current.setComments(gist.getComments());
            current.setDescription(gist.getDescription());
            current.setFiles(sortFiles(gist));
            current.setUpdatedAt(gist.getUpdatedAt());
            return current;
        } else {
            gist.setFiles(sortFiles(gist));
            gists.put(gist.getId(), gist);
            return gist;
        }
    }


    public Gist refreshGist(String id) throws IOException {
        return addGist(service.getGist(id));
    }


    public Gist editGist(Gist gist) throws IOException {
        return addGist(service.updateGist(gist));
    }
}

<code block>

package com.github.pockethub.core.gist;

import android.accounts.Account;
import android.content.Context;
import android.util.Log;

import com.github.pockethub.accounts.AuthenticatedUserTask;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.service.GistService;


public class StarGistTask extends AuthenticatedUserTask<Gist> {

    private static final String TAG = "StarGistTask";

    @Inject
    private GistService service;

    private final String id;


    public StarGistTask(final Context context, final String id) {
        super(context);

        this.id = id;
    }

    @Override
    public Gist run(Account account) throws Exception {
        service.starGist(id);
        return null;
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception starring gist", e);
    }
}

<code block>

package com.github.pockethub.core.gist;

import android.net.Uri;
import android.text.TextUtils;

import java.util.List;
import java.util.regex.Pattern;

import org.eclipse.egit.github.core.Gist;


public class GistUriMatcher {

    private static final Pattern PATTERN = Pattern.compile("[a-f0-9]{20}");


    public static Gist getGist(final Uri uri) {
        List<String> segments = uri.getPathSegments();
        if (segments == null)
            return null;
        if (segments.size() != 1)
            return null;

        String gistId = segments.get(0);
        if (TextUtils.isEmpty(gistId))
            return null;

        if (TextUtils.isDigitsOnly(gistId))
            return new Gist().setId(gistId);

        if (PATTERN.matcher(gistId).matches())
            return new Gist().setId(gistId);

        return null;
    }
}

<code block>

package com.github.pockethub.core.gist;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.Gist;


public class FullGist extends ArrayList<Comment> implements Serializable {

    private static final long serialVersionUID = -5966699489498437000L;

    private final Gist gist;

    private final boolean starred;


    public FullGist(final Gist gist, final boolean starred,
            final Collection<Comment> comments) {
        super(comments);

        this.starred = starred;
        this.gist = gist;
    }


    public FullGist() {
        this.gist = null;
        this.starred = false;
    }


    public boolean isStarred() {
        return starred;
    }


    public Gist getGist() {
        return gist;
    }
}

<code block>

package com.github.pockethub.core.gist;

import android.accounts.Account;
import android.content.Context;
import android.util.Log;

import com.github.pockethub.accounts.AuthenticatedUserTask;
import com.github.pockethub.util.HtmlUtils;
import com.github.pockethub.util.HttpImageGetter;
import com.google.inject.Inject;

import java.util.Collections;
import java.util.List;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.service.GistService;


public class RefreshGistTask extends AuthenticatedUserTask<FullGist> {

    private static final String TAG = "RefreshGistTask";

    @Inject
    private GistStore store;

    @Inject
    private GistService service;

    private final String id;

    private final HttpImageGetter imageGetter;


    public RefreshGistTask(Context context, String gistId,
            HttpImageGetter imageGetter) {
        super(context);

        id = gistId;
        this.imageGetter = imageGetter;
    }

    @Override
    public FullGist run(Account account) throws Exception {
        Gist gist = store.refreshGist(id);
        List<Comment> comments;
        if (gist.getComments() > 0)
            comments = service.getComments(id);
        else
            comments = Collections.emptyList();
        for (Comment comment : comments) {
            String formatted = HtmlUtils.format(comment.getBodyHtml())
                    .toString();
            comment.setBodyHtml(formatted);
            imageGetter.encode(comment, formatted);
        }
        return new FullGist(gist, service.isStarred(id), comments);
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception loading gist", e);
    }
}
<code block>

package com.github.pockethub.core.gist;

import static org.eclipse.egit.github.core.event.Event.TYPE_GIST;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.event.Event;
import org.eclipse.egit.github.core.event.EventPayload;
import org.eclipse.egit.github.core.event.GistPayload;


public class GistEventMatcher {


    public Gist getGist(final Event event) {
        if (event == null)
            return null;
        EventPayload payload = event.getPayload();
        if (payload == null)
            return null;
        String type = event.getType();
        if (TYPE_GIST.equals(type))
            return ((GistPayload) payload).getGist();
        else
            return null;
    }
}

<code block>

package com.github.pockethub.core.gist;

import android.accounts.Account;
import android.content.Context;
import android.util.Log;

import com.github.pockethub.accounts.AuthenticatedUserTask;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.service.GistService;


public class UnstarGistTask extends AuthenticatedUserTask<Gist> {

    private static final String TAG = "UnstarGistTask";

    @Inject
    private GistService service;

    private final String id;


    public UnstarGistTask(final Context context, final String id) {
        super(context);

        this.id = id;
    }

    @Override
    public Gist run(Account account) throws Exception {
        service.unstarGist(id);
        return null;
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception unstarring gist", e);
    }
}

<code block>

package com.github.pockethub.core.gist;

import com.github.pockethub.core.ResourcePager;

import org.eclipse.egit.github.core.Gist;


public abstract class GistPager extends ResourcePager<Gist> {

    private final GistStore store;


    public GistPager(final GistStore store) {
        this.store = store;
    }

    @Override
    protected Object getId(Gist resource) {
        return resource.getId();
    }

    @Override
    protected Gist register(Gist resource) {
        return store.addGist(resource);
    }
}

<code block>

package com.github.pockethub.core.repo;

import android.accounts.Account;
import android.content.Context;
import android.util.Log;

import com.github.pockethub.R;
import com.github.pockethub.ui.ProgressDialogTask;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.service.WatcherService;


public class UnstarRepositoryTask extends ProgressDialogTask<Void> {

    private static final String TAG = "UnstarRepositoryTask";

    @Inject
    private WatcherService service;

    private final IRepositoryIdProvider repo;


    public UnstarRepositoryTask(Context context, IRepositoryIdProvider repo) {
        super(context);

        this.repo = repo;
    }


    public void start() {
        showIndeterminate(R.string.unstarring_repository);

        execute();
    }

    @Override
    protected Void run(Account account) throws Exception {
        service.unwatch(repo);

        return null;
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception unstarring repository", e);
    }
}

<code block>

package com.github.pockethub.core.repo;

import android.accounts.Account;
import android.content.Context;
import android.util.Log;

import com.github.pockethub.ui.ProgressDialogTask;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.service.RepositoryService;


public class RefreshRepositoryTask extends ProgressDialogTask<Repository> {

    private static final String TAG = "RefreshRepositoryTask";

    @Inject
    private RepositoryService service;

    private final IRepositoryIdProvider repo;


    public RefreshRepositoryTask(Context context, IRepositoryIdProvider repo) {
        super(context);

        this.repo = repo;
    }

    @Override
    protected Repository run(Account account) throws Exception {
        return service.getRepository(repo);
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception loading repository", e);
    }
}
<code block>

package com.github.pockethub.core.repo;

import android.text.TextUtils;

import org.eclipse.egit.github.core.Repository;


public class RepositoryUtils {


    public static boolean isComplete(final Repository repository) {
        return repository.isPrivate() || repository.isFork()
                || repository.getForks() > 0 || repository.getWatchers() > 0
                || repository.isHasIssues();
    }


    public static boolean isValidOwner(final String name) {
        if (TextUtils.isEmpty(name))
            return false;

        return !("about".equals(name) 
                || "account".equals(name) 
                || "admin".equals(name) 
                || "api".equals(name) 
                || "blog".equals(name) 
                || "camo".equals(name) 
                || "contact".equals(name) 
                || "dashboard".equals(name) 
                || "downloads".equals(name) 
                || "edu".equals(name) 
                || "explore".equals(name) 
                || "features".equals(name) 
                || "home".equals(name) 
                || "inbox".equals(name) 
                || "languages".equals(name) 
                || "login".equals(name) 
                || "logout".equals(name) 
                || "new".equals(name) 
                || "notifications".equals(name) 
                || "organizations".equals(name) 
                || "orgs".equals(name) 
                || "repositories".equals(name) 
                || "search".equals(name) 
                || "security".equals(name) 
                || "settings".equals(name) 
                || "stars".equals(name) 
                || "styleguide".equals(name) 
                || "timeline".equals(name) 
                || "training".equals(name) 
                || "users".equals(name) 
                || "watching".equals(name));
    }


    public static boolean isValidRepo(final String name) {
        if (TextUtils.isEmpty(name))
            return false;

        return !("followers".equals(name) || "following".equals(name));
    }
}

<code block>

package com.github.pockethub.core.repo;

import android.net.Uri;

import java.util.List;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;


public class RepositoryUriMatcher {


    public static Repository getRepository(Uri uri) {
        List<String> segments = uri.getPathSegments();
        if (segments == null)
            return null;
        if (segments.size() < 2)
            return null;

        String repoOwner = segments.get(0);
        if (!RepositoryUtils.isValidOwner(repoOwner))
            return null;

        String repoName = segments.get(1);
        if (!RepositoryUtils.isValidRepo(repoName))
            return null;

        Repository repository = new Repository();
        repository.setName(repoName);
        repository.setOwner(new User().setLogin(repoOwner));
        return repository;
    }
}

<code block>
package com.github.pockethub.core.repo;

import android.accounts.Account;
import android.accounts.AccountManager;
import android.content.Context;
import android.util.Log;

import com.github.pockethub.R;
import com.github.pockethub.accounts.AccountAuthenticator;
import com.github.pockethub.api.GitHubClientV2;
import com.github.pockethub.model.Authorization;
import com.github.pockethub.ui.ProgressDialogTask;
import com.google.inject.Inject;

import java.util.Collections;
import java.util.List;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.service.OAuthService;
import org.eclipse.egit.github.core.service.RepositoryService;
import org.eclipse.egit.github.core.util.EncodingUtils;


public class DeleteRepositoryTask extends ProgressDialogTask<Void> {
    private static final String TAG = "DeleteRepositoryTask";

    @Inject
    private RepositoryService repositoryService;

    @Inject
    private OAuthService oAuthService;

    private final IRepositoryIdProvider repo;


    public DeleteRepositoryTask(Context context, IRepositoryIdProvider repo) {
        super(context);
        this.repo = repo;
    }


    public void start() {
        showIndeterminate(R.string.deleting_repository);

        execute();
    }

    @Override
    protected Void run(Account account) throws Exception {
        final String id = repo.generateId();
        String[] paths = id.split("/");
        final String owner = paths[0];
        final String repository = paths[1];
        String credentials = null;
        String authToken = null;
        String deleteToken = null;

        AccountManager am = AccountManager.get(context);
        String password = am.getPassword(account);

        System.out.println("password: " + password);
        System.out.println("owner: " + account.name);

        if (password == null) {
            AccountAuthenticator.getAuthorization(oAuthService);
        } else {
            credentials = "Basic " + EncodingUtils.toBase64(account.name + ':' + password);
        }

        List<Authorization> authorizations = GitHubClientV2.getServiceClient().
                getAuthorizations(credentials);

        for (Authorization auth : authorizations) {
            List<String> scopes = auth.getScopes();

            if (scopes.size() == 1 && scopes.get(0).equalsIgnoreCase("delete_repo")) {
                authToken = auth.getToken();
            }
        }

        if (authToken != null) {
            deleteToken = "token " + authToken;
        } else {
            Authorization authorization = new Authorization();
            authorization.setNote("Token for deleting repositories");
            authorization.setScopes(Collections.singletonList("delete_repo"));

            Authorization authorizationResponse = GitHubClientV2.getServiceClient().
                    createDeleteAuthorization(credentials, authorization);

            if (authorizationResponse != null) {
                deleteToken = "token " + authorizationResponse.getToken();
            }
        }

        GitHubClientV2.getServiceClient().deleteRepository(deleteToken, owner, repository);

        return null;
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception deleting repository", e);
    }
}

<code block>

package com.github.pockethub.core.repo;

import android.accounts.Account;
import android.content.Context;
import android.util.Log;

import com.github.pockethub.R;
import com.github.pockethub.ui.ProgressDialogTask;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.service.WatcherService;


public class StarRepositoryTask extends ProgressDialogTask<Void> {

    private static final String TAG = "StarRepositoryTask";

    @Inject
    private WatcherService service;

    private final IRepositoryIdProvider repo;


    public StarRepositoryTask(Context context, IRepositoryIdProvider repo) {
        super(context);

        this.repo = repo;
    }


    public void start() {
        showIndeterminate(R.string.starring_repository);

        execute();
    }

    @Override
    protected Void run(Account account) throws Exception {
        service.watch(repo);

        return null;
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception starring repository", e);
    }
}

<code block>

package com.github.pockethub.core.repo;

import static org.eclipse.egit.github.core.event.Event.TYPE_CREATE;
import static org.eclipse.egit.github.core.event.Event.TYPE_FORK;
import static org.eclipse.egit.github.core.event.Event.TYPE_PUBLIC;
import static org.eclipse.egit.github.core.event.Event.TYPE_WATCH;
import android.text.TextUtils;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.event.Event;
import org.eclipse.egit.github.core.event.EventPayload;
import org.eclipse.egit.github.core.event.EventRepository;
import org.eclipse.egit.github.core.event.ForkPayload;


public class RepositoryEventMatcher {


    public static Repository getRepository(final EventRepository repo,
            User actor, User org) {
        if (repo == null)
            return null;

        String id = repo.getName();
        int slash = id.indexOf('/');
        if (slash == -1 || slash + 1 >= id.length())
            return null;

        Repository full = new Repository();
        full.setId(repo.getId());
        full.setName(id.substring(slash + 1));
        String login = id.substring(0, slash);

        if (actor != null && login.equals(actor.getLogin()))
            full.setOwner(actor);
        else if (org != null && login.equals(org.getLogin()))
            full.setOwner(org);
        else
            full.setOwner(new User().setLogin(id.substring(0, slash)));
        return full;
    }


    public Repository getRepository(final Event event) {
        if (event == null)
            return null;

        EventPayload payload = event.getPayload();
        if (payload == null)
            return null;

        String type = event.getType();
        if (TYPE_FORK.equals(type)) {
            Repository repository = ((ForkPayload) payload).getForkee();

            if (repository != null && !TextUtils.isEmpty(repository.getName())
                    && repository.getOwner() != null
                    && !TextUtils.isEmpty(repository.getOwner().getLogin()))
                return repository;
        }

        if (TYPE_CREATE.equals(type) || TYPE_WATCH.equals(type)
                || TYPE_PUBLIC.equals(type))
            return getRepository(event.getRepo(), event.getActor(),
                    event.getOrg());

        return null;
    }
}

<code block>

package com.github.pockethub.core.repo;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.service.WatcherService;

import android.accounts.Account;
import android.content.Context;
import android.util.Log;

import com.github.pockethub.accounts.AuthenticatedUserTask;
import com.google.inject.Inject;


public class StarredRepositoryTask extends AuthenticatedUserTask<Boolean> {

    private static final String TAG = "StarringRepositoryTask";

    @Inject
    private WatcherService service;

    private final IRepositoryIdProvider repo;


    public StarredRepositoryTask(Context context, IRepositoryIdProvider repo) {
        super(context);

        this.repo = repo;
    }

    @Override
    protected Boolean run(Account account) throws Exception {
        return service.isWatching(repo);
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception checking starring repository status", e);
    }
}

<code block>
package com.github.pockethub.core.repo;

import android.accounts.Account;
import android.content.Context;
import android.util.Log;

import com.github.pockethub.R;
import com.github.pockethub.ui.ProgressDialogTask;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.service.RepositoryService;


public class ForkRepositoryTask extends ProgressDialogTask<Repository> {

    private static final String TAG = "ForkRepositoryTask";

    @Inject
    private RepositoryService service;

    private final IRepositoryIdProvider repo;


    public ForkRepositoryTask(Context context, IRepositoryIdProvider repo) {
        super(context);

        this.repo = repo;
    }


    public void start() {
        showIndeterminate(R.string.forking_repository);

        execute();
    }

    @Override
    protected Repository run(Account account) throws Exception {
        return service.forkRepository(repo);
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception forking repository", e);
    }
}

<code block>

package com.github.pockethub.core.code;

import android.accounts.Account;
import android.content.Context;

import com.github.pockethub.accounts.AuthenticatedUserTask;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Blob;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.service.DataService;


public class RefreshBlobTask extends AuthenticatedUserTask<Blob> {

    private final Repository repository;

    private final String blobSha;

    @Inject
    private DataService service;


    public RefreshBlobTask(Repository repository, String blobSha,
            Context context) {
        super(context);

        this.repository = repository;
        this.blobSha = blobSha;
    }

    @Override
    protected Blob run(Account account) throws Exception {
        return service.getBlob(repository, blobSha);
    }
}

<code block>

package com.github.pockethub.core.code;

import static java.lang.String.CASE_INSENSITIVE_ORDER;
import static org.eclipse.egit.github.core.TreeEntry.TYPE_BLOB;
import static org.eclipse.egit.github.core.TreeEntry.TYPE_TREE;
import android.text.TextUtils;

import com.github.pockethub.core.commit.CommitUtils;
import com.github.pockethub.core.ref.RefUtils;

import java.util.List;
import java.util.Map;
import java.util.TreeMap;

import org.eclipse.egit.github.core.Reference;
import org.eclipse.egit.github.core.Tree;
import org.eclipse.egit.github.core.TreeEntry;


public class FullTree {


    public static class Entry implements Comparable<Entry> {


        public final Folder parent;


        public final TreeEntry entry;


        public final String name;

        private Entry() {
            this.parent = null;
            this.entry = null;
            this.name = null;
        }

        private Entry(TreeEntry entry, Folder parent) {
            this.entry = entry;
            this.parent = parent;
            this.name = CommitUtils.getName(entry.getPath());
        }

        @Override
        public int compareTo(Entry another) {
            return CASE_INSENSITIVE_ORDER.compare(name, another.name);
        }
    }


    public static class Folder extends Entry {


        public final Map<String, Folder> folders = new TreeMap<>(
                CASE_INSENSITIVE_ORDER);


        public final Map<String, Entry> files = new TreeMap<>(
                CASE_INSENSITIVE_ORDER);

        private Folder() {
            super();
        }

        private Folder(TreeEntry entry, Folder parent) {
            super(entry, parent);
        }

        private void addFile(TreeEntry entry, String[] pathSegments, int index) {
            if (index == pathSegments.length - 1) {
                Entry file = new Entry(entry, this);
                files.put(file.name, file);
            } else {
                Folder folder = folders.get(pathSegments[index]);
                if (folder != null)
                    folder.addFile(entry, pathSegments, index + 1);
            }
        }

        private void addFolder(TreeEntry entry, String[] pathSegments, int index) {
            if (index == pathSegments.length - 1) {
                Folder folder = new Folder(entry, this);
                folders.put(folder.name, folder);
            } else {
                Folder folder = folders.get(pathSegments[index]);
                if (folder != null)
                    folder.addFolder(entry, pathSegments, index + 1);
            }
        }

        private void add(final TreeEntry entry) {
            String type = entry.getType();
            String path = entry.getPath();
            if (TextUtils.isEmpty(path))
                return;

            if (TYPE_BLOB.equals(type)) {
                String[] segments = path.split("/");
                if (segments.length > 1) {
                    Folder folder = folders.get(segments[0]);
                    if (folder != null)
                        folder.addFile(entry, segments, 1);
                } else if (segments.length == 1) {
                    Entry file = new Entry(entry, this);
                    files.put(file.name, file);
                }
            } else if (TYPE_TREE.equals(type)) {
                String[] segments = path.split("/");
                if (segments.length > 1) {
                    Folder folder = folders.get(segments[0]);
                    if (folder != null)
                        folder.addFolder(entry, segments, 1);
                } else if (segments.length == 1) {
                    Folder folder = new Folder(entry, this);
                    folders.put(folder.name, folder);
                }
            }
        }
    }


    public final Tree tree;


    public final Folder root;


    public final Reference reference;


    public final String branch;


    public FullTree(final Tree tree, final Reference reference) {
        this.tree = tree;
        this.reference = reference;
        this.branch = RefUtils.getName(reference);

        root = new Folder();
        List<TreeEntry> entries = tree.getTree();
        if (entries != null && !entries.isEmpty())
            for (TreeEntry entry : entries)
                root.add(entry);
    }
}

<code block>

package com.github.pockethub.core.code;

import android.accounts.Account;
import android.content.Context;
import android.text.TextUtils;
import android.util.Log;

import com.github.pockethub.accounts.AuthenticatedUserTask;
import com.github.pockethub.core.ref.RefUtils;
import com.google.inject.Inject;

import java.io.IOException;

import org.eclipse.egit.github.core.Commit;
import org.eclipse.egit.github.core.Reference;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.Tree;
import org.eclipse.egit.github.core.service.DataService;
import org.eclipse.egit.github.core.service.RepositoryService;


public class RefreshTreeTask extends AuthenticatedUserTask<FullTree> {

    private static final String TAG = "RefreshTreeTask";

    private final Repository repository;

    private final Reference reference;

    @Inject
    private RepositoryService repoService;

    @Inject
    private DataService dataService;


    public RefreshTreeTask(final Repository repository,
            final Reference reference, final Context context) {
        super(context);

        this.repository = repository;
        this.reference = reference;
    }

    private boolean isValidRef(Reference ref) {
        return ref != null && ref.getObject() != null
                && !TextUtils.isEmpty(ref.getObject().getSha());
    }

    @Override
    protected FullTree run(Account account) throws Exception {
        Reference ref = reference;
        String branch = RefUtils.getPath(ref);
        if (branch == null) {
            branch = repository.getMasterBranch();
            if (TextUtils.isEmpty(branch)) {
                branch = repoService.getRepository(repository)
                        .getMasterBranch();
                if (TextUtils.isEmpty(branch))
                    throw new IOException(
                            "Repository does not have master branch");
            }
            branch = "heads/" + branch;
        }

        if (!isValidRef(ref)) {
            ref = dataService.getReference(repository, branch);
            if (!isValidRef(ref))
                throw new IOException(
                        "Reference does not have associated commit SHA-1");
        }

        Commit commit = dataService.getCommit(repository, ref.getObject()
                .getSha());
        if (commit == null || commit.getTree() == null
                || TextUtils.isEmpty(commit.getTree().getSha()))
            throw new IOException("Commit does not have associated tree SHA-1");

        Tree tree = dataService.getTree(repository, commit.getTree().getSha(),
                true);
        return new FullTree(tree, ref);
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception loading tree", e);
    }
}

<code block>

package com.github.pockethub.util;

import static android.graphics.Bitmap.Config.ARGB_8888;
import static android.graphics.Color.WHITE;
import static android.graphics.PorterDuff.Mode.DST_IN;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.BitmapFactory.Options;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Point;
import android.graphics.PorterDuffXfermode;
import android.graphics.RectF;
import android.util.Log;
import android.widget.ImageView;

import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;


public class ImageUtils {

    private static final String TAG = "ImageUtils";


    public static Bitmap getBitmap(final String imagePath) {
        return getBitmap(imagePath, 1);
    }


    public static Bitmap getBitmap(final String imagePath, int sampleSize) {
        final Options options = new Options();
        options.inDither = false;
        options.inSampleSize = sampleSize;

        RandomAccessFile file = null;
        try {
            file = new RandomAccessFile(imagePath, "r");
            return BitmapFactory.decodeFileDescriptor(file.getFD(), null,
                    options);
        } catch (IOException e) {
            Log.d(TAG, e.getMessage(), e);
            return null;
        } finally {
            if (file != null)
                try {
                    file.close();
                } catch (IOException e) {
                    Log.d(TAG, e.getMessage(), e);
                }
        }
    }


    public static Bitmap getBitmap(final byte[] image, int sampleSize) {
        final Options options = new Options();
        options.inDither = false;
        options.inSampleSize = sampleSize;
        return BitmapFactory.decodeByteArray(image, 0, image.length, options);
    }


    public static int getScale(Point size, int width, int height) {
        if (size.x > width || size.y > height)
            return Math.max(Math.round((float) size.y / (float) height),
                    Math.round((float) size.x / (float) width));
        else
            return 1;
    }


    public static Point getSize(final String imagePath) {
        final Options options = new Options();
        options.inJustDecodeBounds = true;

        RandomAccessFile file = null;
        try {
            file = new RandomAccessFile(imagePath, "r");
            BitmapFactory.decodeFileDescriptor(file.getFD(), null, options);
            return new Point(options.outWidth, options.outHeight);
        } catch (IOException e) {
            Log.d(TAG, e.getMessage(), e);
            return null;
        } finally {
            if (file != null)
                try {
                    file.close();
                } catch (IOException e) {
                    Log.d(TAG, e.getMessage(), e);
                }
        }
    }


    public static Point getSize(final byte[] image) {
        final Options options = new Options();
        options.inJustDecodeBounds = true;
        BitmapFactory.decodeByteArray(image, 0, image.length, options);
        return new Point(options.outWidth, options.outHeight);
    }


    public static Bitmap getBitmap(final String imagePath, int width, int height) {
        Point size = getSize(imagePath);
        return getBitmap(imagePath, getScale(size, width, height));
    }


    public static Bitmap getBitmap(final byte[] image, int width, int height) {
        Point size = getSize(image);
        return getBitmap(image, getScale(size, width, height));
    }


    public static Bitmap getBitmap(final File image, int width, int height) {
        return getBitmap(image.getAbsolutePath(), width, height);
    }


    public static Bitmap getBitmap(final File image) {
        return getBitmap(image.getAbsolutePath());
    }


    public static void setImage(final String imagePath, final ImageView view) {
        setImage(new File(imagePath), view);
    }


    public static void setImage(final File image, final ImageView view) {
        Bitmap bitmap = getBitmap(image);
        if (bitmap != null)
            view.setImageBitmap(bitmap);
    }


    public static Bitmap roundCorners(final Bitmap source, final float radius) {
        int width = source.getWidth();
        int height = source.getHeight();

        Paint paint = new Paint();
        paint.setAntiAlias(true);
        paint.setColor(WHITE);

        Bitmap clipped = Bitmap.createBitmap(width, height, ARGB_8888);
        Canvas canvas = new Canvas(clipped);
        canvas.drawRoundRect(new RectF(0, 0, width, height), radius, radius,
                paint);
        paint.setXfermode(new PorterDuffXfermode(DST_IN));

        Bitmap rounded = Bitmap.createBitmap(width, height, ARGB_8888);
        canvas = new Canvas(rounded);
        canvas.drawBitmap(source, 0, 0, null);
        canvas.drawBitmap(clipped, 0, 0, paint);

        source.recycle();
        clipped.recycle();

        return rounded;
    }
}

<code block>

package com.github.pockethub.util;

import static java.util.Locale.US;
import android.text.TextUtils;

import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;


public class GravatarUtils {


    private static final int HASH_LENGTH = 32;


    private static final String CHARSET = "CP1252";


    private static final MessageDigest MD5;

    static {
        MessageDigest digest;
        try {
            digest = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException e) {
            digest = null;
        }
        MD5 = digest;
    }

    private static String digest(final String value) {
        if (MD5 == null)
            return null;

        byte[] bytes;
        try {
            bytes = value.getBytes(CHARSET);
        } catch (UnsupportedEncodingException e) {
            return null;
        }

        synchronized (MD5) {
            MD5.reset();
            bytes = MD5.digest(bytes);
        }

        String hashed = new BigInteger(1, bytes).toString(16);
        int padding = HASH_LENGTH - hashed.length();
        if (padding == 0)
            return hashed;

        char[] zeros = new char[padding];
        Arrays.fill(zeros, '0');
        return String.valueOf(zeros) + hashed;
    }


    public static String getHash(String email) {
        if (TextUtils.isEmpty(email))
            return null;
        email = email.trim().toLowerCase(US);
        return email.length() > 0 ? digest(email) : null;
    }
}
<code block>

package com.github.pockethub.util;

import static android.util.Base64.DEFAULT;
import static android.view.View.GONE;
import static android.view.View.VISIBLE;
import static java.lang.Integer.MAX_VALUE;
import static org.eclipse.egit.github.core.client.IGitHubConstants.HOST_DEFAULT;
import android.accounts.Account;
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.text.Html.ImageGetter;
import android.text.TextUtils;
import android.util.Base64;
import android.widget.TextView;

import com.github.kevinsawicki.http.HttpRequest;
import com.github.kevinsawicki.http.HttpRequest.HttpRequestException;
import com.github.pockethub.R;
import com.github.pockethub.accounts.AuthenticatedUserTask;
import com.google.inject.Inject;

import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.egit.github.core.RepositoryContents;
import org.eclipse.egit.github.core.RepositoryId;
import org.eclipse.egit.github.core.service.ContentsService;


public class HttpImageGetter implements ImageGetter {

    private static class LoadingImageGetter implements ImageGetter {

        private final Drawable image;

        private LoadingImageGetter(final Context context, final int size) {
            int imageSize = ServiceUtils.getIntPixels(context, size);
            image = context.getResources().getDrawable(
                    R.drawable.image_loading_icon);
            image.setBounds(0, 0, imageSize, imageSize);
        }

        @Override
        public Drawable getDrawable(String source) {
            return image;
        }
    }

    private static boolean containsImages(final String html) {
        return html.contains("<img");
    }

    private final LoadingImageGetter loading;

    private final Context context;

    private final File dir;

    private final int width;

    private final Map<Object, CharSequence> rawHtmlCache = new HashMap<>();

    private final Map<Object, CharSequence> fullHtmlCache = new HashMap<>();

    private final ContentsService service;


    @Inject
    public HttpImageGetter(Context context, ContentsService service) {
        this.context = context;
        this.service = service;
        dir = context.getCacheDir();
        width = ServiceUtils.getDisplayWidth(context);
        loading = new LoadingImageGetter(context, 24);
    }

    private HttpImageGetter show(final TextView view, final CharSequence html) {
        if (TextUtils.isEmpty(html))
            return hide(view);

        view.setText(html);
        view.setVisibility(VISIBLE);
        view.setTag(null);
        return this;
    }

    private HttpImageGetter hide(final TextView view) {
        view.setText(null);
        view.setVisibility(GONE);
        view.setTag(null);
        return this;
    }


    public HttpImageGetter encode(final Object id, final String html) {
        if (TextUtils.isEmpty(html))
            return this;

        CharSequence encoded = HtmlUtils.encode(html, loading);

        if (containsImages(html)) {
            CharSequence currentEncoded = rawHtmlCache.put(id, encoded);

            if (currentEncoded == null
                    || !currentEncoded.toString().equals(encoded.toString()))
                fullHtmlCache.remove(id);
        } else {
            rawHtmlCache.remove(id);
            fullHtmlCache.put(id, encoded);
        }
        return this;
    }


    public HttpImageGetter bind(final TextView view, final String html,
            final Object id) {
        if (TextUtils.isEmpty(html))
            return hide(view);

        CharSequence encoded = fullHtmlCache.get(id);
        if (encoded != null)
            return show(view, encoded);

        encoded = rawHtmlCache.get(id);
        if (encoded == null) {
            encoded = HtmlUtils.encode(html, loading);
            if (containsImages(html))
                rawHtmlCache.put(id, encoded);
            else {
                rawHtmlCache.remove(id);
                fullHtmlCache.put(id, encoded);
                return show(view, encoded);
            }
        }

        if (TextUtils.isEmpty(encoded))
            return hide(view);

        show(view, encoded);
        view.setTag(id);
        new AuthenticatedUserTask<CharSequence>(context) {

            @Override
            protected CharSequence run(Account account) throws Exception {
                return HtmlUtils.encode(html, HttpImageGetter.this);
            }

            @Override
            protected void onSuccess(final CharSequence html) throws Exception {
                fullHtmlCache.put(id, html);

                if (id.equals(view.getTag()))
                    show(view, html);
            }
        }.execute();
        return this;
    }


    private Drawable requestRepositoryImage(final String source)
            throws IOException {
        if (TextUtils.isEmpty(source))
            return null;

        Uri uri = Uri.parse(source);
        if (!HOST_DEFAULT.equals(uri.getHost()))
            return null;

        List<String> segments = uri.getPathSegments();
        if (segments.size() < 5)
            return null;

        String prefix = segments.get(2);



        if (!("raw".equals(prefix) || ("blob".equals(prefix) && !TextUtils
                .isEmpty(uri.getQueryParameter("raw")))))
            return null;

        String owner = segments.get(0);
        if (TextUtils.isEmpty(owner))
            return null;
        String name = segments.get(1);
        if (TextUtils.isEmpty(name))
            return null;
        String branch = segments.get(3);
        if (TextUtils.isEmpty(branch))
            return null;

        StringBuilder path = new StringBuilder(segments.get(4));
        for (int i = 5; i < segments.size(); i++) {
            String segment = segments.get(i);
            if (!TextUtils.isEmpty(segment))
                path.append('/').append(segment);
        }

        if (TextUtils.isEmpty(path))
            return null;

        List<RepositoryContents> contents = service.getContents(
                RepositoryId.create(owner, name), path.toString(), branch);
        if (contents != null && contents.size() == 1) {
            byte[] content = Base64.decode(contents.get(0).getContent(),
                    DEFAULT);
            Bitmap bitmap = ImageUtils.getBitmap(content, width, MAX_VALUE);
            if (bitmap == null)
                return loading.getDrawable(source);
            BitmapDrawable drawable = new BitmapDrawable(
                    context.getResources(), bitmap);
            drawable.setBounds(0, 0, bitmap.getWidth(), bitmap.getHeight());
            return drawable;
        } else
            return null;
    }

    @Override
    public Drawable getDrawable(final String source) {
        try {
            Drawable repositoryImage = requestRepositoryImage(source);
            if (repositoryImage != null)
                return repositoryImage;
        } catch (Exception e) {

        }

        File output = null;
        try {
            output = File.createTempFile("image", ".jpg", dir);
            HttpRequest request = HttpRequest.get(source);
            if (!request.ok())
                throw new IOException("Unexpected response code: "
                        + request.code());
            request.receive(output);
            Bitmap bitmap = ImageUtils.getBitmap(output, width, MAX_VALUE);
            if (bitmap == null)
                return loading.getDrawable(source);

            BitmapDrawable drawable = new BitmapDrawable(
                    context.getResources(), bitmap);
            drawable.setBounds(0, 0, bitmap.getWidth(), bitmap.getHeight());
            return drawable;
        } catch (IOException e) {
            return loading.getDrawable(source);
        } catch (HttpRequestException e) {
            return loading.getDrawable(source);
        } finally {
            if (output != null)
                output.delete();
        }
    }


    public void removeFromCache(final Object id) {
        rawHtmlCache.remove(id);
        fullHtmlCache.remove(id);
    }
}

<code block>

package com.github.pockethub.util;

import static android.content.Context.WINDOW_SERVICE;
import static android.util.TypedValue.COMPLEX_UNIT_DIP;
import android.content.Context;
import android.content.res.Resources;
import android.util.TypedValue;
import android.view.Display;
import android.view.View;
import android.view.WindowManager;


public class ServiceUtils {


    public static Display getDisplay(final Context context) {
        return ((WindowManager) context.getSystemService(WINDOW_SERVICE))
                .getDefaultDisplay();
    }


    public static Display getDisplay(final View view) {
        return getDisplay(view.getContext());
    }


    public static int getDisplayWidth(final Context context) {
        return getDisplay(context).getWidth();
    }


    public static int getDisplayWidth(final View view) {
        return getDisplayWidth(view.getContext());
    }


    public static float getPixels(final View view, final int dp) {
        return getPixels(view.getResources(), dp);
    }


    public static float getPixels(final Resources resources, final int dp) {
        return TypedValue.applyDimension(COMPLEX_UNIT_DIP, dp,
                resources.getDisplayMetrics());
    }


    public static int getIntPixels(final View view, final int dp) {
        return getIntPixels(view.getResources(), dp);
    }


    public static int getIntPixels(final Context context, final int dp) {
        return getIntPixels(context.getResources(), dp);
    }


    public static int getIntPixels(final Resources resources, final int dp) {
        float pixels = TypedValue.applyDimension(COMPLEX_UNIT_DIP, dp,
                resources.getDisplayMetrics());
        return (int) Math.floor(pixels + 0.5F);
    }
}

<code block>

package com.github.pockethub.util;

import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Paint.Style;
import android.text.Editable;
import android.text.Html.ImageGetter;
import android.text.Html.TagHandler;
import android.text.Layout;
import android.text.Spanned;
import android.text.TextUtils;
import android.text.style.LeadingMarginSpan;
import android.text.style.QuoteSpan;
import android.text.style.StrikethroughSpan;
import android.text.style.TypefaceSpan;

import org.xml.sax.XMLReader;

import java.util.LinkedList;

import static android.graphics.Paint.Style.FILL;
import static android.text.Spanned.SPAN_EXCLUSIVE_EXCLUSIVE;
import static android.text.Spanned.SPAN_MARK_MARK;


public class HtmlUtils {

    private static class ReplySpan implements LeadingMarginSpan {

        private final int color = 0xffDDDDDD;

        @Override
        public int getLeadingMargin(boolean first) {
            return 18;
        }

        @Override
        public void drawLeadingMargin(Canvas c, Paint p, int x, int dir,
                                      int top, int baseline, int bottom, CharSequence text,
                                      int start, int end, boolean first, Layout layout) {
            final Style style = p.getStyle();
            final int color = p.getColor();

            p.setStyle(FILL);
            p.setColor(this.color);

            c.drawRect(x, top, x + dir * 6, bottom, p);

            p.setStyle(style);
            p.setColor(color);
        }
    }

    private static final String TAG_ROOT = "githubroot";

    private static final String ROOT_START = '<' + TAG_ROOT + '>';

    private static final String ROOT_END = "</" + TAG_ROOT + '>';

    private static final String TOGGLE_START = "<span class=\"email-hidden-toggle\">";

    private static final String TOGGLE_END = "</span>";

    private static final String REPLY_START = "<div class=\"email-quoted-reply\">";

    private static final String REPLY_END = "</div>";

    private static final String SIGNATURE_START = "<div class=\"email-signature-reply\">";

    private static final String SIGNATURE_END = "</div>";

    private static final String EMAIL_START = "<div class=\"email-fragment\">";

    private static final String EMAIL_END = "</div>";

    private static final String HIDDEN_REPLY_START = "<div class=\"email-hidden-reply\" style=\" display:none\">";

    private static final String HIDDEN_REPLY_END = "</div>";

    private static final String BREAK = "<br>";

    private static final String PARAGRAPH_START = "<p>";

    private static final String PARAGRAPH_END = "</p>";

    private static final String BLOCKQUOTE_START = "<blockquote>";

    private static final String BLOCKQUOTE_END = "</blockquote>";

    private static final String SPACE = "&nbsp;";

    private static final String PRE_START = "<pre>";

    private static final String PRE_END = "</pre>";

    private static final String CODE_START = "<code>";

    private static final String CODE_END = "</code>";

    private static class ListSeparator {

        private int count;

        public ListSeparator(boolean ordered) {
            count = ordered ? 1 : -1;
        }

        public ListSeparator append(Editable output, int indentLevel) {
            output.append('\n');
            for (int i = 0; i < indentLevel * 2; i++)
                output.append(' ');
            if (count != -1) {
                output.append(Integer.toString(count)).append('.');
                count++;
            } else
                output.append('\u2022');
            output.append(' ').append(' ');
            return this;
        }
    }

    private static final TagHandler TAG_HANDLER = new TagHandler() {

        private static final String TAG_DEL = "del";

        private static final String TAG_UL = "ul";

        private static final String TAG_OL = "ol";

        private static final String TAG_LI = "li";

        private static final String TAG_CODE = "code";

        private static final String TAG_PRE = "pre";

        private int indentLevel;

        private final LinkedList<ListSeparator> listElements = new LinkedList<>();

        @Override
        public void handleTag(final boolean opening, final String tag,
                              final Editable output, final XMLReader xmlReader) {
            if (TAG_DEL.equalsIgnoreCase(tag)) {
                if (opening)
                    startSpan(new StrikethroughSpan(), output);
                else
                    endSpan(StrikethroughSpan.class, output);
                return;
            }

            if (TAG_UL.equalsIgnoreCase(tag)) {
                if (opening) {
                    listElements.addFirst(new ListSeparator(false));
                    indentLevel++;
                } else {
                    listElements.removeFirst();
                    indentLevel--;
                }

                if (!opening && indentLevel == 0)
                    output.append('\n');
                return;
            }

            if (TAG_OL.equalsIgnoreCase(tag)) {
                if (opening) {
                    listElements.addFirst(new ListSeparator(true));
                    indentLevel++;
                } else {
                    listElements.removeFirst();
                    indentLevel--;
                }
                if (!opening && indentLevel == 0)
                    output.append('\n');
                return;
            }

            if (TAG_LI.equalsIgnoreCase(tag) && opening) {
                listElements.getFirst().append(output, indentLevel);
                return;
            }

            if (TAG_CODE.equalsIgnoreCase(tag)) {
                if (opening)
                    startSpan(new TypefaceSpan("monospace"), output);
                else
                    endSpan(TypefaceSpan.class, output);
                return;
            }

            if (TAG_PRE.equalsIgnoreCase(tag)) {
                output.append('\n');
                if (opening)
                    startSpan(new TypefaceSpan("monospace"), output);
                else
                    endSpan(TypefaceSpan.class, output);
                return;
            }

            if (TAG_ROOT.equalsIgnoreCase(tag) && !opening) {

                while (output.length() > 0 && output.charAt(0) == '\n')
                    output.delete(0, 1);


                int last = output.length() - 1;
                while (last >= 0 && output.charAt(last) == '\n') {
                    output.delete(last, last + 1);
                    last = output.length() - 1;
                }

                QuoteSpan[] quoteSpans = output.getSpans(0, output.length(),
                        QuoteSpan.class);
                for (QuoteSpan span : quoteSpans) {
                    int start = output.getSpanStart(span);
                    int end = output.getSpanEnd(span);
                    output.removeSpan(span);
                    output.setSpan(new ReplySpan(), start, end,
                            SPAN_EXCLUSIVE_EXCLUSIVE);
                }
            }
        }
    };

    private static Object getLast(final Spanned text, final Class<?> kind) {
        Object[] spans = text.getSpans(0, text.length(), kind);
        return spans.length > 0 ? spans[spans.length - 1] : null;
    }

    private static void startSpan(Object span, Editable output) {
        int length = output.length();
        output.setSpan(span, length, length, SPAN_MARK_MARK);
    }

    private static void endSpan(Class<?> type, Editable output) {
        int length = output.length();
        Object span = getLast(output, type);
        int start = output.getSpanStart(span);
        output.removeSpan(span);
        if (start != length)
            output.setSpan(span, start, length, SPAN_EXCLUSIVE_EXCLUSIVE);
    }


    public static CharSequence encode(final String html) {
        return encode(html, null);
    }


    public static CharSequence encode(final String html,
                                      final ImageGetter imageGetter) {
        if (TextUtils.isEmpty(html))
            return "";

        return android.text.Html.fromHtml(html, imageGetter, TAG_HANDLER);
    }


    public static final CharSequence format(final String html) {
        if (html == null)
            return "";
        if (html.length() == 0)
            return "";

        StringBuilder formatted = new StringBuilder(html);


        strip(formatted, TOGGLE_START, TOGGLE_END);


        strip(formatted, SIGNATURE_START, SIGNATURE_END);


        replace(formatted, REPLY_START, REPLY_END, BLOCKQUOTE_START,
                BLOCKQUOTE_END);


        strip(formatted, HIDDEN_REPLY_START, HIDDEN_REPLY_END);


        if (replace(formatted, PARAGRAPH_START, BREAK))
            replace(formatted, PARAGRAPH_END, BREAK);

        formatPres(formatted);

        formatEmailFragments(formatted);

        trim(formatted);

        formatted.insert(0, ROOT_START);
        formatted.append(ROOT_END);

        return formatted;
    }

    private static StringBuilder strip(final StringBuilder input,
                                       final String prefix, final String suffix) {
        int start = input.indexOf(prefix);
        while (start != -1) {
            int end = input.indexOf(suffix, start + prefix.length());
            if (end == -1)
                end = input.length();
            input.delete(start, end + suffix.length());
            start = input.indexOf(prefix, start);
        }
        return input;
    }

    private static boolean replace(final StringBuilder input,
                                   final String from, final String to) {
        int start = input.indexOf(from);
        if (start == -1)
            return false;

        final int fromLength = from.length();
        final int toLength = to.length();
        while (start != -1) {
            input.replace(start, start + fromLength, to);
            start = input.indexOf(from, start + toLength);
        }
        return true;
    }

    private static void replaceTag(final StringBuilder input,
                                   final String from, final String to) {
        if (replace(input, '<' + from + '>', '<' + to + '>'))
            replace(input, "</" + from + '>', "</" + to + '>');
    }

    private static StringBuilder replace(final StringBuilder input,
                                         final String fromStart, final String fromEnd, final String toStart,
                                         final String toEnd) {
        int start = input.indexOf(fromStart);
        if (start == -1)
            return input;

        final int fromStartLength = fromStart.length();
        final int fromEndLength = fromEnd.length();
        final int toStartLength = toStart.length();
        while (start != -1) {
            input.replace(start, start + fromStartLength, toStart);
            int end = input.indexOf(fromEnd, start + toStartLength);
            if (end != -1)
                input.replace(end, end + fromEndLength, toEnd);

            start = input.indexOf(fromStart);
        }
        return input;
    }

    private static StringBuilder formatPres(final StringBuilder input) {
        int start = input.indexOf(PRE_START);
        final int spaceAdvance = SPACE.length() - 1;
        final int breakAdvance = BREAK.length() - 1;
        while (start != -1) {
            int end = input.indexOf(PRE_END, start + PRE_START.length());
            if (end == -1)
                break;


            if (input.indexOf(CODE_START, start) == start)
                start += CODE_START.length();
            if (input.indexOf(CODE_END, start) == end - CODE_END.length())
                end -= CODE_END.length();

            for (int i = start; i < end; i++) {
                switch (input.charAt(i)) {
                    case ' ':
                        input.deleteCharAt(i);
                        input.insert(i, SPACE);
                        start += spaceAdvance;
                        end += spaceAdvance;
                        break;
                    case '\t':
                        input.deleteCharAt(i);
                        input.insert(i, SPACE);
                        start += spaceAdvance;
                        end += spaceAdvance;
                        for (int j = 0; j < 3; j++) {
                            input.insert(i, SPACE);
                            start += spaceAdvance + 1;
                            end += spaceAdvance + 1;
                        }
                        break;
                    case '\n':
                        input.deleteCharAt(i);

                        if (i + 1 < end) {
                            input.insert(i, BREAK);
                            start += breakAdvance;
                            end += breakAdvance;
                        }
                        break;
                }
            }
            start = input.indexOf(PRE_START, end + PRE_END.length());
        }
        return input;
    }


    private static StringBuilder formatEmailFragments(final StringBuilder input) {
        int emailStart = input.indexOf(EMAIL_START);
        int breakAdvance = BREAK.length() - 1;
        while (emailStart != -1) {
            int startLength = EMAIL_START.length();
            int emailEnd = input.indexOf(EMAIL_END, emailStart + startLength);
            if (emailEnd == -1)
                break;

            input.delete(emailEnd, emailEnd + EMAIL_END.length());
            input.delete(emailStart, emailStart + startLength);

            int fullEmail = emailEnd - startLength;
            for (int i = emailStart; i < fullEmail; i++)
                if (input.charAt(i) == '\n') {
                    input.deleteCharAt(i);
                    input.insert(i, BREAK);
                    i += breakAdvance;
                    fullEmail += breakAdvance;
                }

            emailStart = input.indexOf(EMAIL_START, fullEmail);
        }
        return input;
    }


    private static StringBuilder trim(final StringBuilder input) {
        int length = input.length();
        int breakLength = BREAK.length();

        while (length > 0) {
            if (input.indexOf(BREAK) == 0)
                input.delete(0, breakLength);
            else if (length >= breakLength
                    && input.lastIndexOf(BREAK) == length - breakLength)
                input.delete(length - breakLength, length);
            else if (Character.isWhitespace(input.charAt(0)))
                input.deleteCharAt(0);
            else if (Character.isWhitespace(input.charAt(length - 1)))
                input.deleteCharAt(length - 1);
            else
                break;
            length = input.length();
        }
        return input;
    }
}

<code block>

package com.github.pockethub.util;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;

import static android.content.Context.MODE_PRIVATE;


public class PreferenceUtils {


    public static final String WRAP = "wrap";


    public static final String RENDER_MARKDOWN = "renderMarkdown";


    public static SharedPreferences getCodePreferences(final Context context) {
        return context.getSharedPreferences("code", MODE_PRIVATE);
    }


    public static void save(final Editor editor) {
        editor.apply();
    }
}

<code block>

package com.github.pockethub.util;

import static android.content.Intent.ACTION_SEND;
import static android.content.Intent.EXTRA_SUBJECT;
import static android.content.Intent.EXTRA_TEXT;
import android.content.Intent;
import android.text.TextUtils;


public class ShareUtils {


    public static Intent create(final CharSequence subject,
            final CharSequence body) {
        Intent intent = new Intent(ACTION_SEND);
        intent.setType("text/plain");
        if (!TextUtils.isEmpty(subject))
            intent.putExtra(EXTRA_SUBJECT, subject);
        intent.putExtra(EXTRA_TEXT, body);
        return intent;
    }


    public static String getBody(final Intent intent) {
        return intent != null ? intent.getStringExtra(EXTRA_TEXT) : null;
    }


    public static String getSubject(final Intent intent) {
        return intent != null ? intent.getStringExtra(EXTRA_SUBJECT) : null;
    }
}

<code block>

package com.github.pockethub.util;

import static org.eclipse.egit.github.core.Blob.ENCODING_BASE64;
import static org.eclipse.egit.github.core.client.IGitHubConstants.CHARSET_UTF8;
import android.os.Build;
import android.net.Uri;
import android.text.TextUtils;
import android.webkit.JavascriptInterface;
import android.webkit.WebSettings;
import android.webkit.WebView;
import android.webkit.WebViewClient;

import com.github.pockethub.ui.user.UriLauncherActivity;

import java.io.UnsupportedEncodingException;

import org.eclipse.egit.github.core.Blob;
import org.eclipse.egit.github.core.util.EncodingUtils;


public class SourceEditor {

    private static final String URL_PAGE = "file:///android_asset/source-editor.html";

    private final WebView view;

    private boolean wrap;

    private String name;

    private String content;

    private boolean encoded;

    private boolean markdown;


    public SourceEditor(final WebView view) {
        WebViewClient client = new WebViewClient() {

            @Override
            public boolean shouldOverrideUrlLoading(WebView view, String url) {
                if (URL_PAGE.equals(url)) {
                    view.loadUrl(url);
                    return false;
                } else {
                    UriLauncherActivity.launchUri(view.getContext(), Uri.parse(url));
                    return true;
                }
            }
        };
        view.setWebViewClient(client);

        WebSettings settings = view.getSettings();
        settings.setJavaScriptEnabled(true);
        view.addJavascriptInterface(this, "SourceEditor");
        if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.JELLY_BEAN) {
            settings.setBuiltInZoomControls(true);
            settings.setUseWideViewPort(true);
        }

        this.view = view;
    }


    @JavascriptInterface
    public String getName() {
        return name;
    }


    @JavascriptInterface
    public String getRawContent() {
        return content;
    }


    @JavascriptInterface
    public String getContent() {
        if (encoded)
            try {
                return new String(EncodingUtils.fromBase64(content), CHARSET_UTF8);
            } catch (UnsupportedEncodingException e) {
                return getRawContent();
            }
        else
            return getRawContent();
    }


    @JavascriptInterface
    public boolean getWrap() {
        return wrap;
    }


    public boolean isMarkdown() {
        return markdown;
    }


    public SourceEditor setWrap(final boolean wrap) {
        this.wrap = wrap;
        loadSource();
        return this;
    }


    public SourceEditor setMarkdown(final boolean markdown) {
        this.markdown = markdown;
        return this;
    }


    public SourceEditor setSource(final String name, final String content, final boolean encoded) {
        this.name = name;
        this.content = content;
        this.encoded = encoded;
        loadSource();

        return this;
    }

    private void loadSource() {
        if (name != null && content != null)
            if (markdown)
                view.loadDataWithBaseURL(null, content, "text/html", CHARSET_UTF8, null);
            else
                view.loadUrl(URL_PAGE);
    }


    public SourceEditor setSource(final String name, final Blob blob) {
        String content = blob.getContent();
        if (content == null)
            content = "";
        boolean encoded = !TextUtils.isEmpty(content) && ENCODING_BASE64.equals(blob.getEncoding());
        return setSource(name, content, encoded);
    }


    public SourceEditor toggleWrap() {
        return setWrap(!wrap);
    }


    public SourceEditor toggleMarkdown() {
        return setMarkdown(!markdown);
    }
}

<code block>

package com.github.pockethub.util;

import static android.text.format.DateUtils.FORMAT_NUMERIC_DATE;
import static android.text.format.DateUtils.FORMAT_SHOW_DATE;
import static android.text.format.DateUtils.FORMAT_SHOW_YEAR;
import static android.text.format.DateUtils.MINUTE_IN_MILLIS;
import android.text.format.DateUtils;

import java.util.Date;


public class TimeUtils {


    public static CharSequence getRelativeTime(final Date date) {
        long now = System.currentTimeMillis();
        if (Math.abs(now - date.getTime()) > 60000)
            return DateUtils.getRelativeTimeSpanString(date.getTime(), now,
                    MINUTE_IN_MILLIS, FORMAT_SHOW_DATE | FORMAT_SHOW_YEAR
                            | FORMAT_NUMERIC_DATE);
        else
            return "just now";
    }
}

<code block>

package com.github.pockethub.util;

import android.content.Context;
import android.graphics.Paint;
import android.graphics.Typeface;
import android.widget.TextView;

import java.util.Arrays;


public class TypefaceUtils {


    public static final String ICON_PRIVATE = "\uf26a";


    public static final String ICON_PUBLIC = "\uf201";


    public static final String ICON_FORK = "\uf202";


    public static final String ICON_CREATE = "\uf203";


    public static final String ICON_DELETE = "\uf204";


    public static final String ICON_PUSH = "\uf205";


    public static final String ICON_WIKI = "\uf207";


    public static final String ICON_UPLOAD = "\uf20C";


    public static final String ICON_GIST = "\uf20E";


    public static final String ICON_ADD_MEMBER = "\uf21A";


    public static final String ICON_MIRROR_PUBLIC = "\uf224";


    public static final String ICON_MIRROR_PRIVATE = "\uf225";


    public static final String ICON_FOLLOW = "\uf21C";


    public static final String ICON_STAR = "\uf02A";


    public static final String ICON_PULL_REQUEST = "\uf222";


    public static final String ICON_ISSUE_OPEN = "\uf226";


    public static final String ICON_ISSUE_REOPEN = "\uf227";


    public static final String ICON_ISSUE_CLOSE = "\uf228";


    public static final String ICON_ISSUE_COMMENT = "\uf229";


    public static final String ICON_COMMENT = "\uf22b";


    public static final String ICON_NEWS = "\uf234";


    public static final String ICON_WATCH = "\uf04e";


    public static final String ICON_TEAM = "\uf019";


    public static final String ICON_CODE = "\uf010";


    public static final String ICON_TAG = "\uf015";


    public static final String ICON_COMMIT = "\uf01f";


    public static final String ICON_MERGE = "\uf023";


    public static final String ICON_KEY = "\uf049";


    public static final String ICON_LOCK = "\uf06a";


    public static final String ICON_MILESTONE = "\uf075";


    public static final String ICON_BOOKMARK = "\uf07b";


    public static final String ICON_PERSON = "\uf218";


    public static final String ICON_ADD = "\uf05d";


    public static final String ICON_BROADCAST = "\uf030";


    public static final String ICON_EDIT = "\uf058";

    private static Typeface OCTICONS;


    public static int getMaxDigits(int... numbers) {
        int max = 1;
        for (int number : numbers)
            max = Math.max(max, (int) Math.log10(number) + 1);
        return max;
    }


    public static int getWidth(TextView view, int numberOfDigits) {
        Paint paint = new Paint();
        paint.setTypeface(view.getTypeface());
        paint.setTextSize(view.getTextSize());
        char[] text = new char[numberOfDigits];
        Arrays.fill(text, '0');
        return Math.round(paint.measureText(text, 0, text.length));
    }


    public static Typeface getOcticons(final Context context) {
        if (OCTICONS == null)
            OCTICONS = getTypeface(context, "octicons-regular-webfont.ttf");
        return OCTICONS;
    }


    public static void setOcticons(final TextView... textViews) {
        if (textViews == null || textViews.length == 0)
            return;

        Typeface typeface = getOcticons(textViews[0].getContext());
        for (TextView textView : textViews)
            textView.setTypeface(typeface);
    }


    public static Typeface getTypeface(final Context context, final String name) {
        return Typeface.createFromAsset(context.getAssets(), name);
    }
}

<code block>

package com.github.pockethub.util;

import android.content.Context;
import android.content.res.TypedArray;
import android.graphics.Bitmap;
import android.graphics.drawable.BitmapDrawable;
import android.support.v7.app.ActionBar;
import android.text.TextUtils;
import android.util.Log;
import android.widget.ImageView;

import com.github.pockethub.R;
import com.google.inject.Inject;
import com.squareup.okhttp.Cache;
import com.squareup.okhttp.OkHttpClient;
import com.squareup.picasso.OkHttpDownloader;
import com.squareup.picasso.Picasso;
import com.squareup.picasso.Transformation;

import java.io.File;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicReference;

import org.eclipse.egit.github.core.CommitUser;
import org.eclipse.egit.github.core.Contributor;
import org.eclipse.egit.github.core.User;

import roboguice.util.RoboAsyncTask;


public class AvatarLoader {
    static final int DISK_CACHE_SIZE = 50 * 1024 * 1024; 

    private static final String TAG = "AvatarLoader";

    private static final float CORNER_RADIUS_IN_DIP = 3;

    private final Context context;
    private final Picasso p;

    private final float cornerRadius;

    private final RoundedCornersTransformation transformation = new RoundedCornersTransformation();


    private static int avatarSize = 0;


    @Inject
    public AvatarLoader(final Context context) {
        this.context = context;

        OkHttpClient client = new OkHttpClient();


        File cacheDir = new File(context.getCacheDir(), "http");
        Cache cache = new Cache(cacheDir, DISK_CACHE_SIZE);
        client.setCache(cache);

        p = new Picasso.Builder(context).downloader(new OkHttpDownloader(client)).build();

        float density = context.getResources().getDisplayMetrics().density;
        cornerRadius = CORNER_RADIUS_IN_DIP * density;

        if (avatarSize == 0) {
            avatarSize = getMaxAvatarSize(context);
        }



        final File avatarDir = new File(context.getCacheDir(), "avatars/github.com");
        if (avatarDir.isDirectory())
            deleteCache(avatarDir);
    }


    public void bind(final ActionBar actionBar, final User user) {
        bind(actionBar, new AtomicReference<>(user));
    }


    public void bind(final ActionBar actionBar, final AtomicReference<User> userReference) {
        if (userReference == null)
            return;

        final User user = userReference.get();
        if (user == null)
            return;

        String avatarUrl = user.getAvatarUrl();
        if (TextUtils.isEmpty(avatarUrl))
            return;


        if (avatarUrl.contains("?") && !avatarUrl.contains("gravatar")) {
            avatarUrl = avatarUrl.substring(0, avatarUrl.indexOf("?"));
        }

        final String url = avatarUrl;

        new FetchAvatarTask(context) {

            @Override
            public BitmapDrawable call() throws Exception {
                Bitmap image = Bitmap.createScaledBitmap(p.load(url).get(), avatarSize, avatarSize, false);
                return new BitmapDrawable(context.getResources(), ImageUtils.roundCorners(image, cornerRadius));
            }

            @Override
            protected void onSuccess(BitmapDrawable image) throws Exception {
                actionBar.setLogo(image);
            }
        }.execute();
    }


    public void bind(final ImageView view, final User user) {
        bind(view, getAvatarUrl(user));
    }


    public void bind(final ImageView view, final CommitUser user) {
        bind(view, getAvatarUrl(user));
    }


    public void bind(final ImageView view, final Contributor contributor) {
        bind(view, contributor.getAvatarUrl());
    }

    private void bind(final ImageView view, String url) {
        if (url == null) {
            p.load(R.drawable.spinner_inner).resize(avatarSize, avatarSize).into(view);
            return;
        }

        if (url.contains("?") && !url.contains("gravatar")) {
            url = url.substring(0, url.indexOf("?"));
        }

        p.load(url)
                .placeholder(R.drawable.gravatar_icon)
                .resize(avatarSize, avatarSize)
                .transform(transformation)
                .into(view);
    }

    private String getAvatarUrl(User user) {
        if (user == null)
            return null;

        String avatarUrl = user.getAvatarUrl();
        if (TextUtils.isEmpty(avatarUrl)) {
            avatarUrl = getAvatarUrl(GravatarUtils.getHash(user.getEmail()));
        }
        return avatarUrl;
    }

    private String getAvatarUrl(CommitUser user) {
        return getAvatarUrl(GravatarUtils.getHash(user.getEmail()));
    }

    private String getAvatarUrl(String id) {
        if (!TextUtils.isEmpty(id))
            return "http://gravatar.com/avatar/" + id + "?d=404";
        else
            return null;
    }

    private int getMaxAvatarSize(final Context context) {
        int[] attrs = { android.R.attr.layout_height };
        TypedArray array = context.getTheme().obtainStyledAttributes(R.style.AvatarXLarge, attrs);

        int size = array.getLayoutDimension(0, 100);
        array.recycle();
        return size;
    }

    private boolean deleteCache(final File cache) {
        if (cache.isDirectory())
            for (File f : cache.listFiles())
                deleteCache(f);
        return cache.delete();
    }

    private static abstract class FetchAvatarTask extends RoboAsyncTask<BitmapDrawable> {

        private static final Executor EXECUTOR = Executors.newFixedThreadPool(1);

        private FetchAvatarTask(Context context) {
            super(context, EXECUTOR);
        }

        @Override
        protected void onException(Exception e) throws RuntimeException {
            Log.d(TAG, "Avatar load failed", e);
        }
    }

    public class RoundedCornersTransformation implements Transformation {
        @Override
        public Bitmap transform(Bitmap source) {
            return ImageUtils.roundCorners(source, cornerRadius);
        }

        @Override public String key() {
            return "RoundedCornersTransformation";
        }
    }
}

<code block>

package com.github.pockethub.util;

import static java.util.Locale.US;
import android.text.TextUtils;


public class MarkdownUtils {

  private static final String[] MARKDOWN_EXTENSIONS = { ".md", ".mkdn",
          ".mdwn", ".mdown", ".markdown", ".mkd", ".mkdown", ".ron" };


  public static boolean isMarkdown(String name) {
      if (TextUtils.isEmpty(name))
          return false;

      name = name.toLowerCase(US);
      for (String extension : MARKDOWN_EXTENSIONS)
          if (name.endsWith(extension))
              return true;

      return false;
  }
}

<code block>
package com.github.pockethub.model;

import java.util.HashMap;
import java.util.Map;

public class App {

    private String name;
    private String url;
    private String clientId;
    private Map<String, Object> additionalProperties = new HashMap<>();


    public String getName() {
        return name;
    }


    public void setName(String name) {
        this.name = name;
    }


    public String getUrl() {
        return url;
    }


    public void setUrl(String url) {
        this.url = url;
    }


    public String getClientId() {
        return clientId;
    }


    public void setClientId(String clientId) {
        this.clientId = clientId;
    }

    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    public void setAdditionalProperty(String name, Object value) {
        this.additionalProperties.put(name, value);
    }

}

<code block>
package com.github.pockethub.model;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Authorization {

    private int id;
    private String url;
    private App app;
    private String token;
    private String note;
    private Object noteUrl;
    private String createdAt;
    private String updatedAt;
    private List<String> scopes = new ArrayList<>();
    private Map<String, Object> additionalProperties = new HashMap<>();


    public int getId() {
        return id;
    }


    public void setId(int id) {
        this.id = id;
    }


    public String getUrl() {
        return url;
    }


    public void setUrl(String url) {
        this.url = url;
    }


    public App getApp() {
        return app;
    }


    public void setApp(App app) {
        this.app = app;
    }


    public String getToken() {
        return token;
    }


    public void setToken(String token) {
        this.token = token;
    }


    public String getNote() {
        return note;
    }


    public void setNote(String note) {
        this.note = note;
    }


    public Object getNoteUrl() {
        return noteUrl;
    }


    public void setNoteUrl(Object noteUrl) {
        this.noteUrl = noteUrl;
    }


    public String getCreatedAt() {
        return createdAt;
    }


    public void setCreatedAt(String createdAt) {
        this.createdAt = createdAt;
    }


    public String getUpdatedAt() {
        return updatedAt;
    }


    public void setUpdatedAt(String updatedAt) {
        this.updatedAt = updatedAt;
    }


    public List<String> getScopes() {
        return scopes;
    }


    public void setScopes(List<String> scopes) {
        this.scopes = scopes;
    }

    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    public void setAdditionalProperty(String name, Object value) {
        this.additionalProperties.put(name, value);
    }

}
<code block>

package com.github.pockethub.sync;

import android.content.SyncResult;
import android.database.SQLException;
import android.util.Log;

import com.github.pockethub.persistence.DatabaseCache;
import com.github.pockethub.persistence.OrganizationRepositories;
import com.github.pockethub.persistence.Organizations;
import com.google.inject.Inject;
import com.google.inject.assistedinject.Assisted;

import java.io.IOException;
import java.util.List;

import org.eclipse.egit.github.core.User;


public class SyncCampaign implements Runnable {

    private static final String TAG = "SyncCampaign";


    public interface Factory {


        SyncCampaign create(SyncResult syncResult);
    }

    @Inject
    private DatabaseCache cache;

    @Inject
    private OrganizationRepositories.Factory repos;

    @Inject
    private Organizations persistedOrgs;

    private final SyncResult syncResult;

    private boolean cancelled = false;


    @Inject
    public SyncCampaign(@Assisted SyncResult syncResult) {
        this.syncResult = syncResult;
    }

    @Override
    public void run() {
        List<User> orgs;
        try {
            orgs = cache.requestAndStore(persistedOrgs);
            syncResult.stats.numUpdates++;
        } catch (IOException | SQLException e) {
            syncResult.stats.numIoExceptions++;
            Log.d(TAG, "Exception requesting users and orgs", e);
            return;
        }

        Log.d(TAG, "Syncing " + orgs.size() + " users and orgs");
        for (User org : orgs) {
            if (cancelled)
                return;

            Log.d(TAG, "Syncing repos for " + org.getLogin());
            try {
                cache.requestAndStore(repos.under(org));
                syncResult.stats.numUpdates++;
            } catch (IOException | SQLException e) {
                syncResult.stats.numIoExceptions++;
                Log.d(TAG, "Exception requesting repositories", e);
            }
        }

        Log.d(TAG, "Sync campaign finished");
    }


    public void cancel() {
        cancelled = true;
        Log.d(TAG, "Cancelled");
    }
}

<code block>

package com.github.pockethub.sync;

import android.content.Intent;
import android.os.IBinder;

import com.google.inject.Inject;

import roboguice.inject.ContextScopedProvider;
import roboguice.service.RoboService;


public class SyncAdapterService extends RoboService {

    @Inject
    private ContextScopedProvider<SyncAdapter> syncAdapterProvider;

    @Override
    public IBinder onBind(Intent intent) {
        return syncAdapterProvider.get(this).getSyncAdapterBinder();
    }
}
<code block>

package com.github.pockethub.sync;

import android.content.ContentProvider;
import android.content.ContentValues;
import android.database.Cursor;
import android.net.Uri;


public class ContentProviderAdapter extends ContentProvider {

    @Override
    public int delete(Uri uri, String selection, String[] selectionArgs) {
        return 0;
    }

    @Override
    public String getType(Uri uri) {
        return null;
    }

    @Override
    public Uri insert(Uri uri, ContentValues values) {
        return null;
    }

    @Override
    public boolean onCreate() {
        return true;
    }

    @Override
    public Cursor query(Uri uri, String[] projection, String selection,
            String[] selectionArgs, String sortOrder) {
        return null;
    }

    @Override
    public int update(Uri uri, ContentValues values, String selection,
            String[] selectionArgs) {
        return 0;
    }
}

<code block>

package com.github.pockethub.sync;

import android.accounts.Account;
import android.accounts.AccountManager;
import android.content.AbstractThreadedSyncAdapter;
import android.content.ContentProviderClient;
import android.content.Context;
import android.content.SyncResult;
import android.os.Bundle;

import com.github.pockethub.accounts.AccountScope;
import com.github.pockethub.sync.SyncCampaign.Factory;
import com.google.inject.Inject;

import roboguice.inject.ContextScope;
import roboguice.inject.ContextSingleton;


@ContextSingleton
public class SyncAdapter extends AbstractThreadedSyncAdapter {

    @Inject
    private ContextScope contextScope;

    @Inject
    private AccountScope accountScope;

    @Inject
    private Factory campaignFactory;

    private SyncCampaign campaign = null;


    @Inject
    public SyncAdapter(final Context context) {
        super(context, true);
    }

    @Override
    public void onPerformSync(final Account account, final Bundle extras,
            final String authority, final ContentProviderClient provider,
            final SyncResult syncResult) {
        accountScope.enterWith(account, AccountManager.get(getContext()));
        try {
            contextScope.enter(getContext());
            try {
                cancelCampaign();
                campaign = campaignFactory.create(syncResult);
                campaign.run();
            } finally {
                contextScope.exit(getContext());
            }
        } finally {
            accountScope.exit();
        }
    }

    @Override
    public void onSyncCanceled() {
        cancelCampaign();
    }

    private void cancelCampaign() {
        if (campaign != null)
            campaign.cancel();
    }
}

<code block>

package com.github.pockethub.accounts;

import static android.accounts.AccountManager.KEY_ACCOUNT_AUTHENTICATOR_RESPONSE;
import static android.accounts.AccountManager.KEY_ACCOUNT_NAME;
import static android.accounts.AccountManager.KEY_ACCOUNT_TYPE;
import static android.accounts.AccountManager.KEY_AUTHTOKEN;
import static android.accounts.AccountManager.KEY_BOOLEAN_RESULT;
import static android.accounts.AccountManager.KEY_INTENT;
import static com.github.pockethub.accounts.AccountConstants.ACCOUNT_TYPE;
import static com.github.pockethub.accounts.AccountConstants.APP_NOTE;
import static com.github.pockethub.accounts.AccountConstants.APP_NOTE_URL;
import static com.github.pockethub.accounts.LoginActivity.PARAM_AUTHTOKEN_TYPE;
import static com.github.pockethub.accounts.LoginActivity.PARAM_USERNAME;
import android.accounts.AbstractAccountAuthenticator;
import android.accounts.Account;
import android.accounts.AccountAuthenticatorResponse;
import android.accounts.AccountManager;
import android.accounts.NetworkErrorException;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.text.TextUtils;
import android.util.Log;

import com.github.pockethub.DefaultClient;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;

import org.eclipse.egit.github.core.Authorization;
import org.eclipse.egit.github.core.service.OAuthService;

public class AccountAuthenticator extends AbstractAccountAuthenticator {

    private static final String TAG = "GHAccountAuthenticator";

    private static final List<String> SCOPES = Arrays.asList("repo", "user", "gist");

    private Context context;

    public AccountAuthenticator(final Context context) {
        super(context);

        this.context = context;
    }


    @Override
    public Bundle addAccount(final AccountAuthenticatorResponse response,
            final String accountType, final String authTokenType,
            final String[] requiredFeatures, final Bundle options)
            throws NetworkErrorException {
        final Intent intent = new Intent(context, LoginActivity.class);
        intent.putExtra(PARAM_AUTHTOKEN_TYPE, authTokenType);
        intent.putExtra(KEY_ACCOUNT_AUTHENTICATOR_RESPONSE, response);
        final Bundle bundle = new Bundle();
        bundle.putParcelable(KEY_INTENT, intent);
        return bundle;
    }

    @Override
    public Bundle confirmCredentials(
            final AccountAuthenticatorResponse response, final Account account,
            final Bundle options) {
        return null;
    }

    @Override
    public Bundle editProperties(final AccountAuthenticatorResponse response,
            final String accountType) {
        return null;
    }

    private static boolean isValidAuthorization(final Authorization auth,
            final List<String> requiredScopes) {
        if (auth == null)
            return false;

        if (!APP_NOTE.equals(auth.getNote()))
            return false;

        if (!APP_NOTE_URL.equals(auth.getNoteUrl()))
            return false;

        List<String> scopes = auth.getScopes();
        return scopes != null && scopes.containsAll(requiredScopes);
    }

    private Intent createLoginIntent(final AccountAuthenticatorResponse response) {
        final Intent intent = new Intent(context, LoginActivity.class);
        intent.putExtra(PARAM_AUTHTOKEN_TYPE, ACCOUNT_TYPE);
        intent.putExtra(KEY_ACCOUNT_AUTHENTICATOR_RESPONSE, response);
        return intent;
    }


    public static String getAuthorization(final OAuthService service) throws IOException {
        for (Authorization auth : service.getAuthorizations())
            if (isValidAuthorization(auth, SCOPES))
                return auth.getToken();
        return null;
    }


    public static String createAuthorization(final OAuthService service) throws IOException {
        Authorization auth = new Authorization();
        auth.setNote(APP_NOTE);
        auth.setNoteUrl(APP_NOTE_URL);
        auth.setScopes(SCOPES);
        auth = service.createAuthorization(auth);
        return auth != null ? auth.getToken() : null;
    }

    @Override
    public Bundle getAuthToken(final AccountAuthenticatorResponse response,
            final Account account, final String authTokenType,
            final Bundle options) throws NetworkErrorException {
        Log.d(TAG, "Retrieving OAuth2 token");

        final Bundle bundle = new Bundle();

        if (!ACCOUNT_TYPE.equals(authTokenType))
            return bundle;

        AccountManager am = AccountManager.get(context);
        String password = am.getPassword(account);
        if (TextUtils.isEmpty(password)) {
            bundle.putParcelable(KEY_INTENT, createLoginIntent(response));
            return bundle;
        }

        DefaultClient client = new DefaultClient();
        client.setCredentials(account.name, password);
        OAuthService service = new OAuthService(client);

        String authToken;
        try {
            authToken = getAuthorization(service);
            if (TextUtils.isEmpty(authToken))
                authToken = createAuthorization(service);
        } catch (IOException e) {
            Log.e(TAG, "Authorization retrieval failed", e);
            throw new NetworkErrorException(e);
        }

        if (TextUtils.isEmpty(authToken))
            bundle.putParcelable(KEY_INTENT, createLoginIntent(response));
        else {
            bundle.putString(KEY_ACCOUNT_NAME, account.name);
            bundle.putString(KEY_ACCOUNT_TYPE, ACCOUNT_TYPE);
            bundle.putString(KEY_AUTHTOKEN, authToken);
            am.clearPassword(account);
        }
        return bundle;
    }

    @Override
    public String getAuthTokenLabel(final String authTokenType) {
        if (ACCOUNT_TYPE.equals(authTokenType))
            return authTokenType;
        else
            return null;
    }

    @Override
    public Bundle hasFeatures(final AccountAuthenticatorResponse response,
            final Account account, final String[] features)
            throws NetworkErrorException {
        final Bundle result = new Bundle();
        result.putBoolean(KEY_BOOLEAN_RESULT, false);
        return result;
    }

    @Override
    public Bundle updateCredentials(
            final AccountAuthenticatorResponse response, final Account account,
            final String authTokenType, final Bundle options) {
        final Intent intent = new Intent(context, LoginActivity.class);
        intent.putExtra(PARAM_AUTHTOKEN_TYPE, authTokenType);
        intent.putExtra(KEY_ACCOUNT_AUTHENTICATOR_RESPONSE, response);
        if (!TextUtils.isEmpty(account.name))
            intent.putExtra(PARAM_USERNAME, account.name);
        final Bundle bundle = new Bundle();
        bundle.putParcelable(KEY_INTENT, intent);
        return bundle;
    }
}

<code block>

package com.github.pockethub.accounts;

import static android.util.Log.DEBUG;
import android.text.TextUtils;
import android.util.Log;

import com.github.pockethub.DefaultClient;
import com.google.inject.Provider;

import java.net.HttpURLConnection;

import org.eclipse.egit.github.core.client.GitHubClient;


public class AccountClient extends DefaultClient {

    private static final String TAG = "AccountGitHubClient";

    private final Provider<GitHubAccount> accountProvider;


    public AccountClient(final Provider<GitHubAccount> accountProvider) {
        super();

        this.accountProvider = accountProvider;
    }

    @Override
    protected HttpURLConnection configureRequest(final HttpURLConnection request) {
        GitHubAccount account = accountProvider.get();

        if (Log.isLoggable(TAG, DEBUG))
            Log.d(TAG, "Authenticating using " + account);


        String token = account.getAuthToken();
        if (!TextUtils.isEmpty(token))
            setOAuth2Token(token);
        else
            setCredentials(account.getUsername(), account.getPassword());

        return super.configureRequest(request);
    }
}

<code block>

package com.github.pockethub.accounts;

import com.google.inject.Key;
import com.google.inject.Provider;
import com.google.inject.Scope;

import java.util.Map;


public abstract class ScopeBase implements Scope {

    private static final Provider<Object> SEEDED_KEY_PROVIDER = new Provider<Object>() {
        public Object get() {
            throw new IllegalStateException("Object not seeded in this scope");
        }
    };


    @SuppressWarnings({ "unchecked" })
    public static <T> Provider<T> seededKeyProvider() {
        return (Provider<T>) SEEDED_KEY_PROVIDER;
    }

    public <T> Provider<T> scope(final Key<T> key, final Provider<T> unscoped) {
        return new Provider<T>() {
            public T get() {
                Map<Key<?>, Object> scopedObjects = getScopedObjectMap(key);

                @SuppressWarnings("unchecked")
                T current = (T) scopedObjects.get(key);
                if (current == null && !scopedObjects.containsKey(key)) {
                    current = unscoped.get();
                    scopedObjects.put(key, current);
                }
                return current;
            }
        };
    }


    protected abstract <T> Map<Key<?>, Object> getScopedObjectMap(Key<T> key);
}

<code block>

package com.github.pockethub.accounts;

import android.accounts.Account;
import android.accounts.AccountManager;

import com.google.inject.AbstractModule;
import com.google.inject.Key;
import com.google.inject.Module;
import com.google.inject.OutOfScopeException;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;


public class AccountScope extends ScopeBase {

    private static final Key<GitHubAccount> GITHUB_ACCOUNT_KEY = Key
            .get(GitHubAccount.class);


    public static Module module() {
        return new AbstractModule() {
            public void configure() {
                AccountScope scope = new AccountScope();

                bind(AccountScope.class).toInstance(scope);

                bind(GITHUB_ACCOUNT_KEY).toProvider(
                        AccountScope.<GitHubAccount> seededKeyProvider()).in(
                        scope);
            }
        };
    }

    private final ThreadLocal<GitHubAccount> currentAccount = new ThreadLocal<>();

    private final Map<GitHubAccount, Map<Key<?>, Object>> repoScopeMaps = new ConcurrentHashMap<>();


    public void enterWith(final Account account,
            final AccountManager accountManager) {
        enterWith(new GitHubAccount(account, accountManager));
    }


    public void enterWith(final GitHubAccount account) {
        if (currentAccount.get() != null)
            throw new IllegalStateException(
                    "A scoping block is already in progress");

        currentAccount.set(account);
    }


    public void exit() {
        if (currentAccount.get() == null)
            throw new IllegalStateException("No scoping block in progress");

        currentAccount.remove();
    }

    @Override
    protected <T> Map<Key<?>, Object> getScopedObjectMap(final Key<T> key) {
        GitHubAccount account = currentAccount.get();
        if (account == null)
            throw new OutOfScopeException("Cannot access " + key
                    + " outside of a scoping block");

        Map<Key<?>, Object> scopeMap = repoScopeMaps.get(account);
        if (scopeMap == null) {
            scopeMap = new ConcurrentHashMap<>();
            scopeMap.put(GITHUB_ACCOUNT_KEY, account);
            repoScopeMaps.put(account, scopeMap);
        }
        return scopeMap;
    }
}

<code block>

package com.github.pockethub.accounts;


public interface AccountConstants {


    String ACCOUNT_TYPE = "com.github";


    String ACCOUNT_NAME = "GitHub";


    String PROVIDER_AUTHORITY = "com.github.sync";


    String APP_NOTE_URL = "https://github.com/github/android";


    String APP_NOTE = "GitHub Android App";
}

<code block>

package com.github.pockethub.accounts;

import android.accounts.Account;
import android.accounts.AccountManager;
import android.app.Activity;
import android.content.Context;

import com.google.inject.Inject;

import java.io.IOException;
import java.util.concurrent.Executor;

import roboguice.inject.ContextScope;
import roboguice.util.RoboAsyncTask;


public abstract class AuthenticatedUserTask<ResultT> extends
        RoboAsyncTask<ResultT> {

    @Inject
    private ContextScope contextScope;

    @Inject
    private AccountScope accountScope;

    @Inject
    private Activity activity;


    protected AuthenticatedUserTask(final Context context) {
        super(context);
    }


    public AuthenticatedUserTask(final Context context, final Executor executor) {
        super(context, executor);
    }

    @Override
    public final ResultT call() throws Exception {
        final AccountManager manager = AccountManager.get(activity);
        final Account account = AccountUtils.getAccount(manager, activity);

        accountScope.enterWith(account, manager);
        try {
            contextScope.enter(getContext());
            try {
                return run(account);
            } catch (IOException e) {


                if (AccountUtils.isUnauthorized(e)
                        && AccountUtils.updateAccount(account, activity))
                    return run(account);
                else
                    throw e;
            } finally {
                contextScope.exit(getContext());
            }
        } finally {
            accountScope.exit();
        }
    }


    protected abstract ResultT run(Account account) throws Exception;
}

<code block>

package com.github.pockethub.accounts;

import static android.accounts.AccountManager.KEY_ACCOUNT_NAME;
import static android.content.DialogInterface.BUTTON_POSITIVE;
import static android.util.Log.DEBUG;
import static com.github.pockethub.accounts.AccountConstants.ACCOUNT_TYPE;
import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
import android.accounts.Account;
import android.accounts.AccountManager;
import android.accounts.AccountManagerFuture;
import android.accounts.AccountsException;
import android.accounts.AuthenticatorDescription;
import android.accounts.AuthenticatorException;
import android.accounts.OperationCanceledException;
import android.app.Activity;
import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnCancelListener;
import android.content.DialogInterface.OnClickListener;
import android.os.Bundle;
import android.text.TextUtils;
import android.util.Log;

import com.github.pockethub.R;
import com.github.pockethub.ui.LightAlertDialog;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.client.RequestException;


public class AccountUtils {

    private static final String TAG = "AccountUtils";

    private static boolean AUTHENTICATOR_CHECKED;

    private static boolean HAS_AUTHENTICATOR;

    private static final AtomicInteger UPDATE_COUNT = new AtomicInteger(0);

    private static class AuthenticatorConflictException extends IOException {

        private static final long serialVersionUID = 641279204734869183L;
    }


    public static boolean hasAuthenticator(final AccountManager manager) {
        if (!AUTHENTICATOR_CHECKED) {
            final AuthenticatorDescription[] types = manager
                    .getAuthenticatorTypes();
            if (types != null && types.length > 0)
                for (AuthenticatorDescription descriptor : types)
                    if (descriptor != null
                            && ACCOUNT_TYPE.equals(descriptor.type)) {
                        HAS_AUTHENTICATOR = "com.github.mobile"
                                .equals(descriptor.packageName);
                        break;
                    }
            AUTHENTICATOR_CHECKED = true;
        }

        return HAS_AUTHENTICATOR;
    }


    public static boolean isUser(final Context context, final User user) {
        if (user == null)
            return false;

        String login = user.getLogin();
        if (login == null)
            return false;

        return login.equals(getLogin(context));
    }


    public static String getLogin(final Context context) {
        final Account account = getAccount(context);
        return account != null ? account.name : null;
    }


    public static Account getAccount(final Context context) {
        final Account[] accounts = AccountManager.get(context)
                .getAccountsByType(ACCOUNT_TYPE);
        return accounts.length > 0 ? accounts[0] : null;
    }

    private static Account[] getAccounts(final AccountManager manager)
            throws OperationCanceledException, AuthenticatorException,
            IOException {
        final AccountManagerFuture<Account[]> future = manager
                .getAccountsByTypeAndFeatures(ACCOUNT_TYPE, null, null, null);
        final Account[] accounts = future.getResult();
        if (accounts != null && accounts.length > 0)
            return getPasswordAccessibleAccounts(manager, accounts);
        else
            return new Account[0];
    }


    public static Account getPasswordAccessibleAccount(final Context context) {
        AccountManager manager = AccountManager.get(context);
        Account[] accounts = manager.getAccountsByType(ACCOUNT_TYPE);
        if (accounts == null || accounts.length == 0)
            return null;

        try {
            accounts = getPasswordAccessibleAccounts(manager, accounts);
        } catch (AuthenticatorConflictException e) {
            return null;
        }
        return accounts != null && accounts.length > 0 ? accounts[0] : null;
    }

    private static Account[] getPasswordAccessibleAccounts(
            final AccountManager manager, final Account[] candidates)
            throws AuthenticatorConflictException {
        final List<Account> accessible = new ArrayList<>(
                candidates.length);
        boolean exceptionThrown = false;
        for (Account account : candidates)
            try {
                manager.getPassword(account);
                accessible.add(account);
            } catch (SecurityException ignored) {
                exceptionThrown = true;
            }
        if (accessible.isEmpty() && exceptionThrown)
            throw new AuthenticatorConflictException();
        return accessible.toArray(new Account[accessible.size()]);
    }


    public static Account getAccount(final AccountManager manager,
            final Activity activity) throws IOException, AccountsException {
        final boolean loggable = Log.isLoggable(TAG, DEBUG);
        if (loggable)
            Log.d(TAG, "Getting account");

        if (activity == null)
            throw new IllegalArgumentException("Activity cannot be null");

        if (activity.isFinishing())
            throw new OperationCanceledException();

        Account[] accounts;
        try {
            if (!hasAuthenticator(manager))
                throw new AuthenticatorConflictException();

            while ((accounts = getAccounts(manager)).length == 0) {
                if (loggable)
                    Log.d(TAG, "No GitHub accounts for activity=" + activity);

                Bundle result = manager.addAccount(ACCOUNT_TYPE, null, null,
                        null, activity, null, null).getResult();

                if (loggable)
                    Log.d(TAG,
                            "Added account "
                                    + result.getString(KEY_ACCOUNT_NAME));
            }
        } catch (OperationCanceledException e) {
            Log.d(TAG, "Excepting retrieving account", e);
            activity.finish();
            throw e;
        } catch (AccountsException e) {
            Log.d(TAG, "Excepting retrieving account", e);
            throw e;
        } catch (AuthenticatorConflictException e) {
            activity.runOnUiThread(new Runnable() {

                public void run() {
                    showConflictMessage(activity);
                }
            });
            throw e;
        } catch (IOException e) {
            Log.d(TAG, "Excepting retrieving account", e);
            throw e;
        }

        if (loggable)
            Log.d(TAG, "Returning account " + accounts[0].name);

        return accounts[0];
    }


    public static boolean updateAccount(final Account account,
            final Activity activity) {
        int count = UPDATE_COUNT.get();
        synchronized (UPDATE_COUNT) {


            if (count != UPDATE_COUNT.get())
                return true;

            AccountManager manager = AccountManager.get(activity);
            try {
                if (!hasAuthenticator(manager))
                    throw new AuthenticatorConflictException();
                manager.updateCredentials(account, ACCOUNT_TYPE, null,
                        activity, null, null).getResult();
                UPDATE_COUNT.incrementAndGet();
                return true;
            } catch (OperationCanceledException e) {
                Log.d(TAG, "Excepting retrieving account", e);
                activity.finish();
                return false;
            } catch (AccountsException e) {
                Log.d(TAG, "Excepting retrieving account", e);
                return false;
            } catch (AuthenticatorConflictException e) {
                activity.runOnUiThread(new Runnable() {

                    public void run() {
                        showConflictMessage(activity);
                    }
                });
                return false;
            } catch (IOException e) {
                Log.d(TAG, "Excepting retrieving account", e);
                return false;
            }
        }
    }


    private static void showConflictMessage(final Activity activity) {
        AlertDialog dialog = LightAlertDialog.create(activity);
        dialog.setTitle(activity.getString(R.string.authenticator_conflict_title));
        dialog.setMessage(activity
                .getString(R.string.authenticator_conflict_message));
        dialog.setOnCancelListener(new OnCancelListener() {

            @Override
            public void onCancel(DialogInterface dialog) {
                activity.finish();
            }
        });
        dialog.setButton(BUTTON_POSITIVE,
                activity.getString(android.R.string.ok), new OnClickListener() {

                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        activity.finish();
                    }
                });
        dialog.show();
    }


    public static boolean isUnauthorized(final Exception e) {
        if (e instanceof RequestException)
            return ((RequestException) e).getStatus() == HTTP_UNAUTHORIZED;

        String message = null;
        if (e instanceof IOException)
            message = e.getMessage();
        final Throwable cause = e.getCause();
        if (cause instanceof IOException) {
            String causeMessage = cause.getMessage();
            if (!TextUtils.isEmpty(causeMessage))
                message = causeMessage;
        }

        if (TextUtils.isEmpty(message))
            return false;

        if ("Received authentication challenge is null".equals(message))
            return true;
        return "No authentication challenges found".equals(message);

    }
}

<code block>

package com.github.pockethub.accounts;

import java.io.IOException;


public class TwoFactorAuthException extends IOException {


    private static final long serialVersionUID = 3889626691109709714L;


    protected final IOException cause;


    protected final int twoFactorAuthType;


    public TwoFactorAuthException(IOException cause, int twoFactorAuthType) {
        this.cause = cause;
        this.twoFactorAuthType = twoFactorAuthType;
    }

    @Override
    public String getMessage() {
        return cause != null ? cause.getMessage() : super.getMessage();
    }

    @Override
    public IOException getCause() {
        return cause;
    }
}
<code block>
package com.github.pockethub.accounts;

import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.support.v7.app.AppCompatActivity;
import android.webkit.WebViewClient;

import com.github.pockethub.R;
import com.github.pockethub.ui.WebView;

public class LoginWebViewActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        WebView webView = new WebView(this);
        webView.loadUrl(getIntent().getStringExtra(LoginActivity.INTENT_EXTRA_URL));
        webView.setWebViewClient(new WebViewClient() {
            @Override
            public boolean shouldOverrideUrlLoading(android.webkit.WebView view, String url) {
                Uri uri = Uri.parse(url);
                if (uri.getScheme().equals(getString(R.string.github_oauth_scheme))) {
                    Intent data = new Intent();
                    data.setData(uri);
                    setResult(RESULT_OK, data);
                    finish();
                    return true;
                }
                return super.shouldOverrideUrlLoading(view, url);
            }
        });

        setContentView(webView);
    }
}
<code block>

package com.github.pockethub.accounts;

import android.text.TextUtils;
import com.github.pockethub.DefaultClient;
import org.eclipse.egit.github.core.client.GitHubClient;
import org.eclipse.egit.github.core.client.GitHubRequest;
import org.eclipse.egit.github.core.client.GitHubResponse;

import java.io.IOException;
import java.lang.reflect.Type;
import java.net.HttpURLConnection;


public class TwoFactorAuthClient extends DefaultClient {


    protected static final String HEADER_OTP = "X-GitHub-OTP";


    public static final int TWO_FACTOR_AUTH_TYPE_APP = 1001;


    public static final int TWO_FACTOR_AUTH_TYPE_SMS = 1002;

    private String otpCode;

    public TwoFactorAuthClient() {
        super();
    }


    public void setOtpCode(String otpCode) {
        this.otpCode = otpCode;
    }


    @Override
    public GitHubResponse get(GitHubRequest request) throws IOException {
        HttpURLConnection httpRequest = createGet(request.generateUri());
        if (!TextUtils.isEmpty(otpCode))
            httpRequest.setRequestProperty(HEADER_OTP, otpCode);

        try {
            String accept = request.getResponseContentType();
            if (accept != null)
                httpRequest.setRequestProperty(HEADER_ACCEPT, accept);
            final int code = httpRequest.getResponseCode();
            updateRateLimits(httpRequest);
            if (isOk(code))
                return new GitHubResponse(httpRequest, getBody(request,
                        getStream(httpRequest)));
            if (isEmpty(code))
                return new GitHubResponse(httpRequest, null);
            throw createException(getStream(httpRequest), code,
                    httpRequest.getResponseMessage());
        } catch (IOException e) {
            throw checkTwoFactorAuthError(httpRequest, e);
        }
    }


    @Override
    public <V> V post(final String uri, final Object params, final Type type)
            throws IOException {
        HttpURLConnection request = createPost(uri);
        if (!TextUtils.isEmpty(otpCode))
            request.setRequestProperty(HEADER_OTP, otpCode);

        try {
            return sendJson(request, params, type);
        } catch (IOException e) {
            throw checkTwoFactorAuthError(request, e);
        }
    }

    private IOException checkTwoFactorAuthError(HttpURLConnection request, IOException e) throws IOException {
        String otpHeader = request.getHeaderField(HEADER_OTP);
        if (!TextUtils.isEmpty(otpHeader) && otpHeader.contains("required"))
            return createTwoFactorAuthException(e, otpHeader);
        else
            return e;
    }

    private TwoFactorAuthException createTwoFactorAuthException(
            IOException cause, String otpHeader) {
        int twoFactorAuthType = -1;
        if (otpHeader.contains("app"))
            twoFactorAuthType = TWO_FACTOR_AUTH_TYPE_APP;
        else if (otpHeader.contains("sms"))
            twoFactorAuthType = TWO_FACTOR_AUTH_TYPE_SMS;

        return new TwoFactorAuthException(cause, twoFactorAuthType);
    }

    private <V> V sendJson(final HttpURLConnection request,
           final Object params, final Type type) throws IOException {
        sendParams(request, params);
        final int code = request.getResponseCode();
        updateRateLimits(request);
        if (isOk(code))
            if (type != null)
                return parseJson(getStream(request), type);
            else
                return null;
        if (isEmpty(code))
            return null;
        throw createException(getStream(request), code,
                request.getResponseMessage());
    }
}

<code block>

package com.github.pockethub.accounts;

import static android.accounts.AccountManager.ACTION_AUTHENTICATOR_INTENT;
import android.app.Service;
import android.content.Intent;
import android.os.IBinder;


public class AccountAuthenticatorService extends Service {

    private static AccountAuthenticator AUTHENTICATOR;

    public IBinder onBind(Intent intent) {
        return intent.getAction().equals(ACTION_AUTHENTICATOR_INTENT) ? getAuthenticator()
                .getIBinder() : null;
    }

    private AccountAuthenticator getAuthenticator() {
        if (AUTHENTICATOR == null)
            AUTHENTICATOR = new AccountAuthenticator(this);
        return AUTHENTICATOR;
    }
}
<code block>

package com.github.pockethub.accounts;

import static android.content.DialogInterface.OnCancelListener;
import static android.view.KeyEvent.ACTION_DOWN;
import static android.view.KeyEvent.KEYCODE_ENTER;
import static android.view.inputmethod.EditorInfo.IME_ACTION_DONE;
import static com.github.pockethub.accounts.AccountConstants.ACCOUNT_TYPE;
import static com.github.pockethub.accounts.LoginActivity.configureSyncFor;
import android.accounts.Account;
import android.accounts.AccountManager;
import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.os.Bundle;
import android.text.Editable;
import android.text.Html;
import android.text.TextUtils;
import android.text.TextWatcher;
import android.text.method.LinkMovementMethod;
import android.util.Log;
import android.view.KeyEvent;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.widget.EditText;
import android.widget.TextView;

import com.github.kevinsawicki.wishlist.ViewFinder;
import com.github.pockethub.R;
import com.github.pockethub.ui.LightProgressDialog;
import com.github.pockethub.ui.TextWatcherAdapter;
import com.github.pockethub.ui.roboactivities.RoboActionBarActivity;

import java.io.IOException;

import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.service.OAuthService;
import org.eclipse.egit.github.core.service.UserService;

import roboguice.util.RoboAsyncTask;


public class TwoFactorAuthActivity extends RoboActionBarActivity {


    public static Intent createIntent(Context context, String username, String password) {
        Intent intent = new Intent(context, TwoFactorAuthActivity.class);
        intent.putExtra(PARAM_USERNAME, username);
        intent.putExtra(PARAM_PASSWORD, password);
        return intent;
    }


    public static final String PARAM_EXCEPTION = "exception";


    public static final String PARAM_USERNAME = "username";


    public static final String PARAM_PASSWORD = "password";

    private static final String TAG = "TwoFactorAuthActivity";

    private AccountManager accountManager;

    private EditText otpCodeText;

    private RoboAsyncTask<User> authenticationTask;

    private MenuItem loginItem;

    private String username;

    private String password;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.login_two_factor_auth);

        setSupportActionBar((android.support.v7.widget.Toolbar) findViewById(R.id.toolbar));

        accountManager = AccountManager.get(this);

        ViewFinder finder = new ViewFinder(this);
        otpCodeText = finder.find(R.id.et_otp_code);

        final Intent intent = getIntent();
        username = intent.getStringExtra(PARAM_USERNAME);
        password = intent.getStringExtra(PARAM_PASSWORD);

        TextView signupText = finder.find(R.id.tv_signup);
        signupText.setMovementMethod(LinkMovementMethod.getInstance());
        signupText.setText(Html.fromHtml(getString(R.string.signup_link_two_factor_auth)));

        TextWatcher watcher = new TextWatcherAdapter() {

            @Override
            public void afterTextChanged(Editable gitDirEditText) {
                updateEnablement();
            }
        };
        otpCodeText.addTextChangedListener(watcher);

        otpCodeText.setOnKeyListener(new View.OnKeyListener() {

            @Override
            public boolean onKey(View v, int keyCode, KeyEvent event) {
                if (event != null && ACTION_DOWN == event.getAction()
                    && keyCode == KEYCODE_ENTER && loginEnabled()) {
                    handleLogin();
                    return true;
                } else
                    return false;
            }
        });

        otpCodeText.setOnEditorActionListener(new TextView.OnEditorActionListener() {

            @Override
            public boolean onEditorAction(TextView v, int actionId,
                KeyEvent event) {
                if (actionId == IME_ACTION_DONE && loginEnabled()) {
                    handleLogin();
                    return true;
                }
                return false;
            }
        });
    }

    @Override
    protected void onResume() {
        super.onResume();
        updateEnablement();
    }

    private boolean loginEnabled() {
        Editable otpCode = otpCodeText.getText();
        return !TextUtils.isEmpty(otpCode) && otpCode.length() == 6;
    }

    private void updateEnablement() {
        if (loginItem != null)
            loginItem.setEnabled(loginEnabled());
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.m_login:
                handleLogin();
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    public boolean onCreateOptionsMenu(Menu optionsMenu) {
        getMenuInflater().inflate(R.menu.login, optionsMenu);
        loginItem = optionsMenu.findItem(R.id.m_login);
        return true;
    }

    private void handleLogin() {
        final String otpCode = otpCodeText.getText().toString();

        final AlertDialog dialog = LightProgressDialog.create(this,
            R.string.login_activity_authenticating);
        dialog.setCancelable(true);
        dialog.setOnCancelListener(new OnCancelListener() {

            @Override
            public void onCancel(DialogInterface dialog) {
                if (authenticationTask != null)
                    authenticationTask.cancel(true);
            }
        });
        dialog.show();

        authenticationTask = new RoboAsyncTask<User>(this) {

            @Override
            public User call() throws Exception {
                TwoFactorAuthClient client = new TwoFactorAuthClient();
                client.setCredentials(username, password);
                client.setOtpCode(otpCode);

                OAuthService service = new OAuthService(client);
                String authToken = AccountAuthenticator.getAuthorization(service);
                if (authToken == null)
                    authToken = AccountAuthenticator.createAuthorization(service);
                client.setOAuth2Token(authToken);

                User user = new UserService(client).getUser();
                Account account = new Account(user.getLogin(), ACCOUNT_TYPE);
                accountManager.addAccountExplicitly(account, password, null);
                accountManager.setAuthToken(account, ACCOUNT_TYPE, authToken);

                configureSyncFor(account);
                try {
                    new LoginActivity.AccountLoader(TwoFactorAuthActivity.this).call();
                } catch (IOException e) {
                    Log.d(TAG, "Exception loading organizations", e);
                }

                return user;
            }

            @Override
            protected void onException(Exception e) throws RuntimeException {
                dialog.dismiss();

                Log.d(TAG, "Exception requesting handling two-factor authentication", e);
                setResult(RESULT_CANCELED, new Intent().putExtra(PARAM_EXCEPTION, e));
                finish();
            }

            @Override
            public void onSuccess(User user) {
                dialog.dismiss();
                setResult(RESULT_OK);
                finish();
            }
        };
        authenticationTask.execute();
    }
}

<code block>

package com.github.pockethub.accounts;

import static android.accounts.AccountManager.KEY_AUTHTOKEN;
import static com.github.pockethub.accounts.AccountConstants.ACCOUNT_TYPE;
import android.accounts.Account;
import android.accounts.AccountManager;
import android.accounts.AccountManagerFuture;
import android.accounts.AccountsException;
import android.os.Bundle;
import android.util.Log;

import java.io.IOException;


public class GitHubAccount {

    private static final String TAG = "GitHubAccount";

    private final Account account;

    private final AccountManager manager;


    public GitHubAccount(final Account account, final AccountManager manager) {
        this.account = account;
        this.manager = manager;
    }


    public String getUsername() {
        return account.name;
    }


    public String getPassword() {
        return manager.getPassword(account);
    }


    public String getAuthToken() {
        AccountManagerFuture<Bundle> future = manager.getAuthToken(account,
                ACCOUNT_TYPE, false, null, null);

        try {
            Bundle result = future.getResult();
            return result != null ? result.getString(KEY_AUTHTOKEN) : null;
        } catch (AccountsException e) {
            Log.e(TAG, "Auth token lookup failed", e);
            return null;
        } catch (IOException e) {
            Log.e(TAG, "Auth token lookup failed", e);
            return null;
        }
    }

    @Override
    public String toString() {
        return getClass().getSimpleName() + '[' + account.name + ']';
    }
}

<code block>

package com.github.pockethub.accounts;

import static com.github.pockethub.accounts.AccountConstants.PROVIDER_AUTHORITY;
import android.accounts.Account;
import android.accounts.AccountManager;
import android.app.AlertDialog;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.support.v7.widget.Toolbar;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;
import android.widget.Toast;

import com.alorma.github.basesdk.ApiClient;
import com.alorma.github.basesdk.client.BaseClient;
import com.alorma.github.sdk.bean.dto.response.Token;
import com.alorma.github.sdk.login.AccountsHelper;
import com.alorma.github.sdk.security.GitHub;
import com.alorma.github.sdk.services.login.RequestTokenClient;
import com.alorma.github.sdk.services.user.GetAuthUserClient;
import com.github.pockethub.R;
import com.github.pockethub.persistence.AccountDataManager;
import com.github.pockethub.ui.LightProgressDialog;
import com.github.pockethub.ui.MainActivity;
import com.github.pockethub.ui.roboactivities.RoboActionBarAccountAuthenticatorActivity;
import com.google.inject.Inject;
import com.squareup.okhttp.HttpUrl;

import java.util.List;

import org.eclipse.egit.github.core.User;

import retrofit.RetrofitError;
import retrofit.client.Response;


public class LoginActivity extends RoboActionBarAccountAuthenticatorActivity implements BaseClient.OnResultCallback<com.alorma.github.sdk.bean.dto.response.User> {


    public static final String PARAM_AUTHTOKEN_TYPE = "authtokenType";


    public static final String PARAM_USERNAME = "username";

    public static final String OAUTH_HOST = "www.github.com";

    public static final String INTENT_EXTRA_URL = "url";

    private static int WEBVIEW_REQUEST_CODE = 0;

    private static final String TAG = "LoginActivity";


    private static final long SYNC_PERIOD = 8L * 60L * 60L;

    public static void configureSyncFor(Account account) {
        Log.d(TAG, "Configuring account sync");

        ContentResolver.setIsSyncable(account, PROVIDER_AUTHORITY, 1);
        ContentResolver.setSyncAutomatically(account, PROVIDER_AUTHORITY, true);
        ContentResolver.addPeriodicSync(account, PROVIDER_AUTHORITY,
            new Bundle(), SYNC_PERIOD);
    }

    public static class AccountLoader extends
        AuthenticatedUserTask<List<User>> {

        @Inject
        private AccountDataManager cache;

        protected AccountLoader(Context context) {
            super(context);
        }

        @Override
        protected List<User> run(Account account) throws Exception {
            return cache.getOrgs(true);
        }
    }

    private AccountManager accountManager;

    private Account[] accounts;

    private String accessToken;

    private String scope;

    private RequestTokenClient requestTokenClient;

    private AlertDialog progressDialog;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.login);

        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
        setSupportActionBar(toolbar);

        accountManager = AccountManager.get(this);

        accounts = accountManager.getAccountsByType(getString(R.string.account_type));

        if (accounts != null && accounts.length > 0)
            openMain();
    }

    @Override
    protected void onNewIntent(Intent intent) {
        super.onNewIntent(intent);
        Uri uri = intent.getData();
        onUserLoggedIn(uri);
    }

    private void onUserLoggedIn(Uri uri) {
        if (uri != null && uri.getScheme().equals(getString(R.string.github_oauth_scheme))) {
            openLoadingDialog();
            String code = uri.getQueryParameter("code");
            if (requestTokenClient == null) {
                requestTokenClient = new RequestTokenClient(LoginActivity.this, code);
                requestTokenClient.setOnResultCallback(new BaseClient.OnResultCallback<Token>() {
                    @Override
                    public void onResponseOk(Token token, Response r) {
                        if (token.access_token != null) {
                            endAuth(token.access_token, token.scope);
                        } else if (token.error != null) {
                            Toast.makeText(LoginActivity.this, token.error, Toast.LENGTH_LONG).show();
                            progressDialog.dismiss();
                        }
                    }

                    @Override
                    public void onFail(RetrofitError error) {
                        error.printStackTrace();
                    }
                });
                requestTokenClient.execute();
            }
        }
    }

    private void openMain() {
        if(progressDialog != null)
            progressDialog.dismiss();
        Intent intent = new Intent(this, MainActivity.class);
        startActivity(intent);
        finish();
    }

    private void openLoadingDialog() {
        progressDialog = LightProgressDialog.create(this,
                R.string.login_activity_authenticating);
        progressDialog.show();
    }

    public void handleLogin() {
        openLoginInBrowser(new GitHub(this));
    }

    private void openLoginInBrowser(ApiClient client) {
        String initialScope = "user,public_repo,repo,delete_repo,notifications,gist";
        HttpUrl.Builder url = new HttpUrl.Builder()
                .scheme("https")
                .host(OAUTH_HOST)
                .addPathSegment("login")
                .addPathSegment("oauth")
                .addPathSegment("authorize")
                .addQueryParameter("client_id", client.getApiClient())
                .addQueryParameter("scope", initialScope);

        Intent intent = new Intent(this, LoginWebViewActivity.class);
        intent.putExtra(INTENT_EXTRA_URL, url.toString());
        startActivityForResult(intent, WEBVIEW_REQUEST_CODE);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if(requestCode == WEBVIEW_REQUEST_CODE && resultCode == RESULT_OK)
            onUserLoggedIn(data.getData());
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.m_login:
                handleLogin();
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    public void onResponseOk(com.alorma.github.sdk.bean.dto.response.User user, Response r) {
        Account account = new Account(user.login, getString(R.string.account_type));
        Bundle userData = AccountsHelper.buildBundle(user.name, user.email, user.avatar_url, scope);
        userData.putString(AccountManager.KEY_AUTHTOKEN, accessToken);

        accountManager.addAccountExplicitly(account, null, userData);
        accountManager.setAuthToken(account, getString(R.string.account_type), accessToken);

        Bundle result = new Bundle();
        result.putString(AccountManager.KEY_ACCOUNT_NAME, account.name);
        result.putString(AccountManager.KEY_ACCOUNT_TYPE, account.type);
        result.putString(AccountManager.KEY_AUTHTOKEN, accessToken);

        setAccountAuthenticatorResult(result);

        openMain();
    }

    @Override
    public void onFail(RetrofitError error) {
        error.printStackTrace();
    }

    private void endAuth(String accessToken, String scope) {
        this.accessToken = accessToken;
        this.scope = scope;

        progressDialog.setMessage(getString(R.string.loading_user));

        GetAuthUserClient userClient = new GetAuthUserClient(this, accessToken);
        userClient.setOnResultCallback(this);
        userClient.execute();
    }

    @Override
    public boolean onCreateOptionsMenu(Menu optionMenu) {
        getMenuInflater().inflate(R.menu.login, optionMenu);
        return true;
    }
}
<code block>

package com.github.pockethub.accounts;

import android.accounts.Account;
import android.accounts.AccountManager;
import android.accounts.AccountsException;
import android.app.Activity;
import android.content.Context;

import com.github.kevinsawicki.wishlist.AsyncLoader;
import com.google.inject.Inject;

import java.io.IOException;

import roboguice.RoboGuice;
import roboguice.inject.ContextScope;


public abstract class AuthenticatedUserLoader<D> extends AsyncLoader<D> {

    @Inject
    private ContextScope contextScope;

    @Inject
    private AccountScope accountScope;


    @Inject
    protected Activity activity;


    public AuthenticatedUserLoader(final Context context) {
        super(context);

        RoboGuice.injectMembers(context, this);
    }


    protected abstract D getAccountFailureData();

    @Override
    public final D loadInBackground() {
        final AccountManager manager = AccountManager.get(activity);
        final Account account;
        try {
            account = AccountUtils.getAccount(manager, activity);
        } catch (IOException e) {
            return getAccountFailureData();
        } catch (AccountsException e) {
            return getAccountFailureData();
        }

        accountScope.enterWith(account, manager);
        try {
            contextScope.enter(getContext());
            try {
                return load(account);
            } finally {
                contextScope.exit(getContext());
            }
        } finally {
            accountScope.exit();
        }
    }


    public abstract D load(Account account);
}
<code block>


package com.github.pockethub.api;

import com.github.pockethub.model.Authorization;

import java.util.List;

import org.eclipse.egit.github.core.client.GitHubClient;

import retrofit.RequestInterceptor;
import retrofit.RestAdapter;
import retrofit.android.AndroidLog;
import retrofit.client.Response;
import retrofit.http.Body;
import retrofit.http.DELETE;
import retrofit.http.GET;
import retrofit.http.Header;
import retrofit.http.POST;
import retrofit.http.Path;

public class GitHubClientV2 extends GitHubClient {
    private static String API_URL = "https://api.github.com";
    private static GitHubClientV2Interface sGitHubClientInterface;

    public static GitHubClientV2Interface getServiceClient() {
        if (sGitHubClientInterface == null) {
            RestAdapter restAdapter = new RestAdapter.Builder()
                    .setRequestInterceptor(new RequestInterceptor() {
                        @Override
                        public void intercept(RequestFacade request) {
                            request.addHeader("Accept", "application/vnd.github.v3.full+json");
                        }
                    })
                    .setEndpoint(API_URL)
                    .setLogLevel(RestAdapter.LogLevel.FULL).setLog(new AndroidLog("Retrofit"))
                    .build();

            sGitHubClientInterface = restAdapter.create(GitHubClientV2Interface.class);
        }

        return sGitHubClientInterface;
    }

    public interface GitHubClientV2Interface {
        @DELETE("/repos/{owner}/{repo}")
        Response deleteRepository(
                @Header("Authorization") String basicCredentials,
                @Path("owner") String owner,
                @Path("repo") String repo);

        @GET("/authorizations")
        List<Authorization> getAuthorizations(@Header("Authorization") String token);

        @POST("/authorizations")
        Authorization createDeleteAuthorization(@Header("Authorization") String basicCredentials,
                                                @Body Authorization authorization);
    }
}

<code block>

package com.github.pockethub.persistence;

import android.accounts.Account;
import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteOpenHelper;
import android.database.sqlite.SQLiteQueryBuilder;
import android.util.Log;

import com.github.pockethub.RequestFuture;
import com.github.pockethub.RequestReader;
import com.github.pockethub.RequestWriter;
import com.github.pockethub.accounts.AuthenticatedUserTask;
import com.github.pockethub.core.issue.IssueFilter;
import com.github.pockethub.persistence.OrganizationRepositories.Factory;
import com.google.inject.Inject;
import com.google.inject.name.Named;

import java.io.File;
import java.io.IOException;
import java.text.MessageFormat;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;


public class AccountDataManager {

    private static final String TAG = "AccountDataManager";

    private static final Executor EXECUTOR = Executors.newFixedThreadPool(10);


    private static final int FORMAT_VERSION = 4;

    @Inject
    private Context context;

    @Inject
    private DatabaseCache dbCache;

    @Inject
    private Factory allRepos;

    @Inject
    private Organizations userAndOrgsResource;

    @Inject
    @Named("cacheDir")
    private File root;


    public Context getContext() {
        return context;
    }


    @SuppressWarnings("unchecked")
    private <V> V read(final File file) {
        long start = System.currentTimeMillis();
        long length = file.length();
        Object data = new RequestReader(file, FORMAT_VERSION).read();
        if (data != null)
            Log.d(TAG, MessageFormat.format(
                    "Cache hit to {0}, {1} ms to load {2} bytes",
                    file.getName(), (System.currentTimeMillis() - start),
                    length));
        return (V) data;
    }


    private AccountDataManager write(File file, Object data) {
        new RequestWriter(file, FORMAT_VERSION).write(data);
        return this;
    }


    protected Cursor query(SQLiteOpenHelper helper, String tables,
            String[] columns) {
        return query(helper, tables, columns, null, null);
    }


    protected Cursor query(SQLiteOpenHelper helper, String tables,
            String[] columns, String selection, String[] selectionArgs) {
        SQLiteQueryBuilder builder = new SQLiteQueryBuilder();
        builder.setTables(tables);
        return builder.query(helper.getReadableDatabase(), columns, selection,
                selectionArgs, null, null, null);
    }


    public List<User> getOrgs(boolean forceReload) throws IOException {
        return forceReload ? dbCache.requestAndStore(userAndOrgsResource)
                : dbCache.loadOrRequest(userAndOrgsResource);
    }


    public List<Repository> getRepos(final User user, boolean forceReload)
            throws IOException {
        OrganizationRepositories resource = allRepos.under(user);
        return forceReload ? dbCache.requestAndStore(resource) : dbCache
                .loadOrRequest(resource);
    }


    public Collection<IssueFilter> getIssueFilters() {
        final File cache = new File(root, "issue_filters.ser");
        Collection<IssueFilter> cached = read(cache);
        if (cached != null)
            return cached;
        return Collections.emptyList();
    }


    public void getIssueFilters(
            final RequestFuture<Collection<IssueFilter>> requestFuture) {
        new AuthenticatedUserTask<Collection<IssueFilter>>(context, EXECUTOR) {

            @Override
            public Collection<IssueFilter> run(Account account)
                    throws Exception {
                return getIssueFilters();
            }

            @Override
            protected void onSuccess(Collection<IssueFilter> filters)
                    throws Exception {
                requestFuture.success(filters);
            }
        }.execute();
    }


    public void addIssueFilter(IssueFilter filter) {
        final File cache = new File(root, "issue_filters.ser");
        Collection<IssueFilter> filters = read(cache);
        if (filters == null)
            filters = new HashSet<>();
        if (filters.add(filter))
            write(cache, filters);
    }


    public void addIssueFilter(final IssueFilter filter,
            final RequestFuture<IssueFilter> requestFuture) {
        new AuthenticatedUserTask<IssueFilter>(context, EXECUTOR) {

            @Override
            public IssueFilter run(Account account) throws Exception {
                addIssueFilter(filter);
                return filter;
            }

            @Override
            protected void onSuccess(IssueFilter filter) throws Exception {
                requestFuture.success(filter);
            }

            @Override
            protected void onException(Exception e) throws RuntimeException {
                Log.d(TAG, "Exception adding issue filter", e);
            }
        }.execute();
    }


    public void removeIssueFilter(IssueFilter filter) {
        final File cache = new File(root, "issue_filters.ser");
        Collection<IssueFilter> filters = read(cache);
        if (filters != null && filters.remove(filter))
            write(cache, filters);
    }


    public void removeIssueFilter(final IssueFilter filter,
            final RequestFuture<IssueFilter> requestFuture) {
        new AuthenticatedUserTask<IssueFilter>(context, EXECUTOR) {

            @Override
            public IssueFilter run(Account account) throws Exception {
                removeIssueFilter(filter);
                return filter;
            }

            @Override
            protected void onSuccess(IssueFilter filter) throws Exception {
                requestFuture.success(filter);
            }

            @Override
            protected void onException(Exception e) throws RuntimeException {
                Log.d(TAG, "Exception removing issue filter", e);
            }
        }.execute();
    }
}

<code block>

package com.github.pockethub.persistence;

import android.content.ContentValues;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteQueryBuilder;

import com.github.pockethub.accounts.GitHubAccount;
import com.google.inject.Inject;
import com.google.inject.Provider;
import com.google.inject.assistedinject.Assisted;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.service.RepositoryService;
import org.eclipse.egit.github.core.service.WatcherService;


public class OrganizationRepositories implements
        PersistableResource<Repository> {


    public interface Factory {


        OrganizationRepositories under(User org);
    }

    private final User org;

    private final RepositoryService repos;

    private final WatcherService watcher;

    private final Provider<GitHubAccount> accountProvider;


    @Inject
    public OrganizationRepositories(@Assisted User orgs,
            RepositoryService repos, WatcherService watcher,
            Provider<GitHubAccount> accountProvider) {
        this.org = orgs;
        this.repos = repos;
        this.watcher = watcher;
        this.accountProvider = accountProvider;
    }

    @Override
    public Cursor getCursor(SQLiteDatabase readableDatabase) {
        SQLiteQueryBuilder builder = new SQLiteQueryBuilder();
        builder.setTables("repos JOIN users ON (repos.ownerId = users.id)");
        return builder.query(readableDatabase, new String[] {
                "repos.repoId, repos.name", "users.id", "users.name",
                "users.avatarurl", "repos.private", "repos.fork",
                "repos.description", "repos.forks", "repos.watchers",
                "repos.language", "repos.hasIssues", "repos.mirrorUrl" },
                "repos.orgId=?",
                new String[] { Integer.toString(org.getId()) }, null, null,
                null);
    }

    @Override
    public Repository loadFrom(Cursor cursor) {
        Repository repo = new Repository();
        repo.setId(cursor.getLong(0));
        repo.setName(cursor.getString(1));

        User owner = new User();
        owner.setId(cursor.getInt(2));
        owner.setLogin(cursor.getString(3));
        owner.setAvatarUrl(cursor.getString(4));
        repo.setOwner(owner);

        repo.setPrivate(cursor.getInt(5) == 1);
        repo.setFork(cursor.getInt(6) == 1);
        repo.setDescription(cursor.getString(7));
        repo.setForks(cursor.getInt(8));
        repo.setWatchers(cursor.getInt(9));
        repo.setLanguage(cursor.getString(10));
        repo.setHasIssues(cursor.getInt(11) == 1);
        repo.setMirrorUrl(cursor.getString(12));

        return repo;
    }

    @Override
    public void store(SQLiteDatabase db, List<Repository> repos) {
        db.delete("repos", "orgId=?",
                new String[] { Integer.toString(org.getId()) });
        if (repos.isEmpty())
            return;

        ContentValues values = new ContentValues(12);
        for (Repository repo : repos) {
            values.clear();

            User owner = repo.getOwner();
            values.put("repoId", repo.getId());
            values.put("name", repo.getName());
            values.put("orgId", org.getId());
            values.put("ownerId", owner.getId());
            values.put("private", repo.isPrivate() ? 1 : 0);
            values.put("fork", repo.isFork() ? 1 : 0);
            values.put("description", repo.getDescription());
            values.put("forks", repo.getForks());
            values.put("watchers", repo.getWatchers());
            values.put("language", repo.getLanguage());
            values.put("hasIssues", repo.isHasIssues() ? 1 : 0);
            values.put("mirrorUrl", repo.getMirrorUrl());
            db.replace("repos", null, values);

            values.clear();

            values.put("id", owner.getId());
            values.put("name", owner.getLogin());
            values.put("avatarurl", owner.getAvatarUrl());
            db.replace("users", null, values);
        }
    }

    @Override
    public List<Repository> request() throws IOException {
        if (isAuthenticatedUser()) {
            Set<Repository> all = new TreeSet<>(
                    new Comparator<Repository>() {

                        @Override
                        public int compare(final Repository repo1,
                                final Repository repo2) {
                            final long id1 = repo1.getId();
                            final long id2 = repo2.getId();
                            if (id1 > id2)
                                return 1;
                            if (id1 < id2)
                                return -1;
                            return 0;
                        }
                    });
            all.addAll(repos.getRepositories());
            all.addAll(watcher.getWatched());
            return new ArrayList<>(all);
        } else
            return repos.getOrgRepositories(org.getLogin());
    }

    private boolean isAuthenticatedUser() {
        return org.getLogin().equals(accountProvider.get().getUsername());
    }

    @Override
    public String toString() {
        return getClass().getSimpleName() + '[' + org.getLogin() + ']';
    }
}

<code block>

package com.github.pockethub.persistence;

import android.content.Context;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;

import com.google.inject.Inject;


public class CacheHelper extends SQLiteOpenHelper {


    private static final int VERSION = 8;


    private static final String NAME = "cache.db";


    @Inject
    public CacheHelper(final Context context) {
        super(context, NAME, null, VERSION);
    }

    @Override
    public void onCreate(final SQLiteDatabase db) {
        db.execSQL("CREATE TABLE orgs (id INTEGER PRIMARY KEY);");
        db.execSQL("CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, avatarurl TEXT);");
        db.execSQL("CREATE TABLE repos (id INTEGER PRIMARY KEY, repoId INTEGER, orgId INTEGER, name TEXT, ownerId INTEGER, private INTEGER, fork INTEGER, description TEXT, forks INTEGER, watchers INTEGER, language TEXT, hasIssues INTEGER, mirrorUrl TEXT);");
    }

    @Override
    public void onUpgrade(final SQLiteDatabase db, final int oldVersion,
            final int newVersion) {
        db.execSQL("DROP TABLE IF EXISTS orgs");
        db.execSQL("DROP TABLE IF EXISTS users");
        db.execSQL("DROP TABLE IF EXISTS repos");
        onCreate(db);
    }
}

<code block>

package com.github.pockethub.persistence;

import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteException;
import android.database.sqlite.SQLiteOpenHelper;
import android.util.Log;

import com.google.inject.Inject;
import com.google.inject.Provider;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;


public class DatabaseCache {

    private static final String TAG = "DatabaseCache";

    @Inject
    private Provider<CacheHelper> helperProvider;


    protected SQLiteDatabase getWritable(SQLiteOpenHelper helper) {
        try {
            return helper.getWritableDatabase();
        } catch (SQLiteException e1) {

            try {
                return helper.getWritableDatabase();
            } catch (SQLiteException e2) {
                return null;
            }
        }
    }


    protected SQLiteDatabase getReadable(SQLiteOpenHelper helper) {
        try {
            return helper.getReadableDatabase();
        } catch (SQLiteException e1) {

            try {
                return helper.getReadableDatabase();
            } catch (SQLiteException e2) {
                return null;
            }
        }
    }


    public <E> List<E> loadOrRequest(PersistableResource<E> persistableResource)
            throws IOException {
        SQLiteOpenHelper helper = helperProvider.get();
        try {
            List<E> items = loadFromDB(helper, persistableResource);
            if (items != null) {
                Log.d(TAG, "CACHE HIT: Found " + items.size() + " items for "
                        + persistableResource);
                return items;
            }
            return requestAndStore(helper, persistableResource);
        } finally {
            helper.close();
        }
    }


    public <E> List<E> requestAndStore(
            PersistableResource<E> persistableResource) throws IOException {
        SQLiteOpenHelper helper = helperProvider.get();
        try {
            return requestAndStore(helper, persistableResource);
        } finally {
            helper.close();
        }
    }

    private <E> List<E> requestAndStore(final SQLiteOpenHelper helper,
            final PersistableResource<E> persistableResource)
            throws IOException {
        final List<E> items = persistableResource.request();

        final SQLiteDatabase db = getWritable(helper);
        if (db == null)
            return items;

        db.beginTransaction();
        try {
            persistableResource.store(db, items);
            db.setTransactionSuccessful();
        } finally {
            db.endTransaction();
        }
        return items;
    }

    private <E> List<E> loadFromDB(final SQLiteOpenHelper helper,
            final PersistableResource<E> persistableResource) {
        final SQLiteDatabase db = getReadable(helper);
        if (db == null)
            return null;

        Cursor cursor = persistableResource.getCursor(db);
        try {
            if (!cursor.moveToFirst())
                return null;

            List<E> cached = new ArrayList<>();
            do
                cached.add(persistableResource.loadFrom(cursor));
            while (cursor.moveToNext());
            return cached;
        } finally {
            cursor.close();
        }
    }
}

<code block>

package com.github.pockethub.persistence;

import android.content.ContentValues;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteQueryBuilder;

import com.google.inject.Inject;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.service.OrganizationService;
import org.eclipse.egit.github.core.service.UserService;


public class Organizations implements PersistableResource<User> {

    private final UserService userService;

    private final OrganizationService orgService;


    @Inject
    public Organizations(OrganizationService orgService, UserService userService) {
        this.orgService = orgService;
        this.userService = userService;
    }

    @Override
    public Cursor getCursor(SQLiteDatabase readableDatabase) {
        SQLiteQueryBuilder builder = new SQLiteQueryBuilder();
        builder.setTables("orgs JOIN users ON (orgs.id = users.id)");
        return builder
                .query(readableDatabase, new String[] { "users.id",
                        "users.name", "users.avatarurl" }, null, null, null,
                        null, null);
    }

    @Override
    public User loadFrom(Cursor cursor) {
        User user = new User();
        user.setId(cursor.getInt(0));
        user.setLogin(cursor.getString(1));
        user.setAvatarUrl(cursor.getString(2));
        return user;
    }

    @Override
    public void store(SQLiteDatabase db, List<User> orgs) {
        db.delete("orgs", null, null);
        if (orgs.isEmpty())
            return;

        ContentValues values = new ContentValues(3);
        for (User user : orgs) {
            values.clear();

            values.put("id", user.getId());
            db.replace("orgs", null, values);

            values.put("name", user.getLogin());
            values.put("avatarurl", user.getAvatarUrl());
            db.replace("users", null, values);
        }
    }

    @Override
    public List<User> request() throws IOException {
        User user = userService.getUser();
        List<User> orgs = orgService.getOrganizations();
        List<User> all = new ArrayList<>(orgs.size() + 1);
        all.add(user);
        all.addAll(orgs);
        return all;
    }
}

<code block>

package com.github.pockethub.persistence;

import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;

import java.io.IOException;
import java.util.List;


public interface PersistableResource<E> {


    Cursor getCursor(SQLiteDatabase readableDatabase);


    E loadFrom(Cursor cursor);


    void store(SQLiteDatabase writableDatabase, List<E> items);


    List<E> request() throws IOException;
}

<code block>

package com.github.pockethub.ui;

import android.view.View;
import android.widget.BaseAdapter;
import android.widget.HeaderViewListAdapter;
import android.widget.ListView;
import android.widget.ListView.FixedViewInfo;

import java.util.ArrayList;


public class HeaderFooterListAdapter<E extends BaseAdapter> extends
        HeaderViewListAdapter {

    private final ListView list;

    private final ArrayList<FixedViewInfo> headers;

    private final ArrayList<FixedViewInfo> footers;

    private final E wrapped;


    public HeaderFooterListAdapter(ListView view, E adapter) {
        this(new ArrayList<FixedViewInfo>(), new ArrayList<FixedViewInfo>(),
                view, adapter);
    }

    private HeaderFooterListAdapter(ArrayList<FixedViewInfo> headerViewInfos,
            ArrayList<FixedViewInfo> footerViewInfos, ListView view, E adapter) {
        super(headerViewInfos, footerViewInfos, adapter);

        headers = headerViewInfos;
        footers = footerViewInfos;
        list = view;
        wrapped = adapter;
    }


    public HeaderFooterListAdapter<E> addHeader(View view) {
        return addHeader(view, null, false);
    }


    public HeaderFooterListAdapter<E> addHeader(View view, Object data,
            boolean isSelectable) {
        FixedViewInfo info = list.new FixedViewInfo();
        info.view = view;
        info.data = data;
        info.isSelectable = isSelectable;

        headers.add(info);
        wrapped.notifyDataSetChanged();
        return this;
    }


    public HeaderFooterListAdapter<E> addFooter(View view) {
        return addFooter(view, null, false);
    }


    public HeaderFooterListAdapter<E> addFooter(View view, Object data,
            boolean isSelectable) {
        FixedViewInfo info = list.new FixedViewInfo();
        info.view = view;
        info.data = data;
        info.isSelectable = isSelectable;

        footers.add(info);
        wrapped.notifyDataSetChanged();
        return this;
    }

    @Override
    public boolean removeHeader(View v) {
        boolean removed = super.removeHeader(v);
        if (removed)
            wrapped.notifyDataSetChanged();
        return removed;
    }


    public boolean clearHeaders() {
        boolean removed = false;
        if (!headers.isEmpty()) {
            FixedViewInfo[] infos = headers.toArray(new FixedViewInfo[headers
                    .size()]);
            for (FixedViewInfo info : infos)
                removed = super.removeHeader(info.view) || removed;
        }
        if (removed)
            wrapped.notifyDataSetChanged();
        return removed;
    }


    public boolean clearFooters() {
        boolean removed = false;
        if (!footers.isEmpty()) {
            FixedViewInfo[] infos = footers.toArray(new FixedViewInfo[footers
                    .size()]);
            for (FixedViewInfo info : infos)
                removed = super.removeFooter(info.view) || removed;
        }
        if (removed)
            wrapped.notifyDataSetChanged();
        return removed;
    }

    @Override
    public boolean removeFooter(View v) {
        boolean removed = super.removeFooter(v);
        if (removed)
            wrapped.notifyDataSetChanged();
        return removed;
    }

    @Override
    public E getWrappedAdapter() {
        return wrapped;
    }

    @Override
    public boolean isEmpty() {
        return wrapped.isEmpty();
    }
}

<code block>

package com.github.pockethub.ui;

import android.os.Bundle;

import com.github.kevinsawicki.wishlist.ViewFinder;
import com.github.pockethub.ui.roboactivities.RoboActionBarActivity;

import java.io.Serializable;


public class BaseActivity extends RoboActionBarActivity {


    protected ViewFinder finder;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        finder = new ViewFinder(this);
    }


    @SuppressWarnings("unchecked")
    protected <V extends Serializable> V getSerializableExtra(final String name) {
        return (V) getIntent().getSerializableExtra(name);
    }


    protected int getIntExtra(final String name) {
        return getIntent().getIntExtra(name, -1);
    }


    protected String getStringExtra(final String name) {
        return getIntent().getStringExtra(name);
    }


    protected String[] getStringArrayExtra(final String name) {
        return getIntent().getStringArrayExtra(name);
    }
}

<code block>

package com.github.pockethub.ui;

import static org.eclipse.egit.github.core.service.MarkdownService.MODE_GFM;
import android.accounts.Account;
import android.content.Context;
import android.text.Html.ImageGetter;
import android.util.Log;

import com.github.pockethub.accounts.AuthenticatedUserLoader;
import com.github.pockethub.util.HtmlUtils;
import com.google.inject.Inject;

import java.io.IOException;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.service.MarkdownService;


public class MarkdownLoader extends AuthenticatedUserLoader<CharSequence> {

    private static final String TAG = "MarkdownLoader";

    private final ImageGetter imageGetter;

    private final IRepositoryIdProvider repository;

    private final String raw;

    private boolean encode;

    @Inject
    private MarkdownService service;


    public MarkdownLoader(Context context, IRepositoryIdProvider repository,
            String raw, ImageGetter imageGetter, boolean encode) {
        super(context);

        this.repository = repository;
        this.raw = raw;
        this.imageGetter = imageGetter;
        this.encode = encode;
    }

    @Override
    protected CharSequence getAccountFailureData() {
        return null;
    }

    @Override
    public CharSequence load(Account account) {
        try {
            String html;
            if (repository != null)
                html = service.getRepositoryHtml(repository, raw);
            else
                html = service.getHtml(raw, MODE_GFM);

            if (encode)
                return HtmlUtils.encode(html, imageGetter);
            else
                return html;
        } catch (IOException e) {
            Log.d(TAG, "Loading rendered markdown failed", e);
            return null;
        }
    }
}

<code block>

package com.github.pockethub.ui;

import static android.content.Intent.ACTION_VIEW;
import static android.content.Intent.CATEGORY_BROWSABLE;
import static org.eclipse.egit.github.core.event.Event.TYPE_COMMIT_COMMENT;
import static org.eclipse.egit.github.core.event.Event.TYPE_DOWNLOAD;
import static org.eclipse.egit.github.core.event.Event.TYPE_PUSH;
import android.app.AlertDialog;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.text.TextUtils;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.ListView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.kevinsawicki.wishlist.ViewFinder;
import com.github.pockethub.R;
import com.github.pockethub.core.gist.GistEventMatcher;
import com.github.pockethub.core.issue.IssueEventMatcher;
import com.github.pockethub.core.repo.RepositoryEventMatcher;
import com.github.pockethub.core.user.UserEventMatcher;
import com.github.pockethub.core.user.UserEventMatcher.UserPair;
import com.github.pockethub.ui.commit.CommitCompareViewActivity;
import com.github.pockethub.ui.commit.CommitViewActivity;
import com.github.pockethub.ui.gist.GistsViewActivity;
import com.github.pockethub.ui.issue.IssuesViewActivity;
import com.github.pockethub.ui.repo.RepositoryViewActivity;
import com.github.pockethub.ui.user.NewsListAdapter;
import com.github.pockethub.util.AvatarLoader;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.egit.github.core.Commit;
import org.eclipse.egit.github.core.CommitComment;
import org.eclipse.egit.github.core.Download;
import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.event.CommitCommentPayload;
import org.eclipse.egit.github.core.event.DownloadPayload;
import org.eclipse.egit.github.core.event.Event;
import org.eclipse.egit.github.core.event.PushPayload;
import org.eclipse.egit.github.core.service.EventService;


public abstract class NewsFragment extends PagedItemFragment<Event> {


    protected final IssueEventMatcher issueMatcher = new IssueEventMatcher();


    protected final GistEventMatcher gistMatcher = new GistEventMatcher();


    protected final RepositoryEventMatcher repoMatcher = new RepositoryEventMatcher();


    protected final UserEventMatcher userMatcher = new UserEventMatcher();

    @Inject
    private AvatarLoader avatars;


    @Inject
    protected EventService service;

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        setEmptyText(R.string.no_news);
    }

    @Override
    public void onListItemClick(ListView l, View v, int position, long id) {
        Event event = (Event) l.getItemAtPosition(position);

        if (TYPE_DOWNLOAD.equals(event.getType())) {
            openDownload(event);
            return;
        }

        if (TYPE_PUSH.equals(event.getType())) {
            openPush(event);
            return;
        }

        if (TYPE_COMMIT_COMMENT.equals(event.getType())) {
            openCommitComment(event);
            return;
        }

        Issue issue = issueMatcher.getIssue(event);
        if (issue != null) {
            Repository repo = RepositoryEventMatcher.getRepository(
                    event.getRepo(), event.getActor(), event.getOrg());
            viewIssue(issue, repo);
            return;
        }

        Gist gist = gistMatcher.getGist(event);
        if (gist != null) {
            startActivity(GistsViewActivity.createIntent(gist));
            return;
        }

        Repository repo = repoMatcher.getRepository(event);
        if (repo != null)
            viewRepository(repo);

        UserPair users = userMatcher.getUsers(event);
        if (users != null)
            viewUser(users);
    }

    @Override
    public boolean onListItemLongClick(ListView l, View v, int position,
            long itemId) {
        if (!isUsable())
            return false;

        final Event event = (Event) l.getItemAtPosition(position);
        final Repository repo = RepositoryEventMatcher.getRepository(
                event.getRepo(), event.getActor(), event.getOrg());
        final User user = event.getActor();

        if (repo != null && user != null) {
            final AlertDialog dialog = LightAlertDialog.create(getActivity());
            dialog.setTitle(R.string.navigate_to);
            dialog.setCanceledOnTouchOutside(true);

            View view = getActivity().getLayoutInflater().inflate(
                    R.layout.nav_dialog, null);
            ViewFinder finder = new ViewFinder(view);
            avatars.bind(finder.imageView(R.id.iv_user_avatar), user);
            avatars.bind(finder.imageView(R.id.iv_repo_avatar), repo.getOwner());
            finder.setText(R.id.tv_login, user.getLogin());
            finder.setText(R.id.tv_repo_name, repo.generateId());
            finder.onClick(R.id.ll_user_area, new OnClickListener() {

                public void onClick(View v) {
                    dialog.dismiss();

                    viewUser(user);
                }
            });
            finder.onClick(R.id.ll_repo_area, new OnClickListener() {

                public void onClick(View v) {
                    dialog.dismiss();

                    viewRepository(repo);
                }
            });
            dialog.setView(view);
            dialog.show();

            return true;
        }

        return false;
    }

    private void openDownload(Event event) {
        Download download = ((DownloadPayload) event.getPayload())
                .getDownload();
        if (download == null)
            return;

        String url = download.getHtmlUrl();
        if (TextUtils.isEmpty(url))
            return;

        Intent intent = new Intent(ACTION_VIEW, Uri.parse(url));
        intent.addCategory(CATEGORY_BROWSABLE);
        startActivity(intent);
    }

    private void openCommitComment(Event event) {
        Repository repo = RepositoryEventMatcher.getRepository(event.getRepo(),
                event.getActor(), event.getOrg());
        if (repo == null)
            return;

        CommitCommentPayload payload = (CommitCommentPayload) event
                .getPayload();
        CommitComment comment = payload.getComment();
        if (comment == null)
            return;

        String sha = comment.getCommitId();
        if (!TextUtils.isEmpty(sha))
            startActivity(CommitViewActivity.createIntent(repo, sha));
    }

    private void openPush(Event event) {
        Repository repo = RepositoryEventMatcher.getRepository(event.getRepo(),
                event.getActor(), event.getOrg());
        if (repo == null)
            return;

        PushPayload payload = (PushPayload) event.getPayload();
        List<Commit> commits = payload.getCommits();
        if (commits == null || commits.isEmpty())
            return;

        if (commits.size() > 1) {
            String base = payload.getBefore();
            String head = payload.getHead();
            if (!TextUtils.isEmpty(base) && !TextUtils.isEmpty(head))
                startActivity(CommitCompareViewActivity.createIntent(repo,
                        base, head));
        } else {
            Commit commit = commits.get(0);
            String sha = commit != null ? commit.getSha() : null;
            if (!TextUtils.isEmpty(sha))
                startActivity(CommitViewActivity.createIntent(repo, sha));
        }
    }


    protected void viewRepository(Repository repository) {
        startActivity(RepositoryViewActivity.createIntent(repository));
    }


    protected void viewUser(UserPair users) {
    }


    protected boolean viewUser(User user) {
        return false;
    }


    protected void viewIssue(Issue issue, Repository repository) {
        if (repository != null)
            startActivity(IssuesViewActivity.createIntent(issue, repository));
        else
            startActivity(IssuesViewActivity.createIntent(issue));
    }

    @Override
    protected SingleTypeAdapter<Event> createAdapter(List<Event> items) {
        return new NewsListAdapter(getActivity().getLayoutInflater(),
                items.toArray(new Event[items.size()]), avatars);
    }

    @Override
    protected int getLoadingMessage() {
        return R.string.loading_news;
    }

    @Override
    protected int getErrorMessage(Exception exception) {
        return R.string.error_news_load;
    }
}

<code block>

package com.github.pockethub.ui;

import android.app.Activity;
import android.os.Bundle;
import android.support.v4.app.LoaderManager.LoaderCallbacks;
import android.support.v4.content.Loader;
import android.support.v4.widget.SwipeRefreshLayout;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.animation.AnimationUtils;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.AdapterView.OnItemLongClickListener;
import android.widget.ListAdapter;
import android.widget.ListView;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.Toast;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.pockethub.R;
import com.github.pockethub.ThrowableLoader;
import com.github.pockethub.util.ToastUtils;

import java.util.Collections;
import java.util.List;


public abstract class ItemListFragment<E> extends DialogFragment implements
        LoaderCallbacks<List<E>>, SwipeRefreshLayout.OnRefreshListener {

    private static final String FORCE_REFRESH = "forceRefresh";

    private SwipeRefreshLayout swipeLayout;


    protected static boolean isForceRefresh(Bundle args) {
        return args != null && args.getBoolean(FORCE_REFRESH, false);
    }


    protected List<E> items = Collections.emptyList();


    protected ListView listView;


    protected TextView emptyView;


    protected ProgressBar progressBar;


    protected boolean listShown;

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        if (!items.isEmpty())
            setListShown(true, false);

        getLoaderManager().initLoader(0, null, this);
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        return inflater.inflate(R.layout.item_list, null);
    }

    @Override
    public void onRefresh() {
        forceRefresh();
    }


    @Override
    public void onDestroyView() {
        listShown = false;
        emptyView = null;
        progressBar = null;
        listView = null;

        super.onDestroyView();
    }

    @Override
    public void onViewCreated(View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        swipeLayout = (SwipeRefreshLayout) view.findViewById(R.id.swipe_item);
        swipeLayout.setOnRefreshListener(this);
        swipeLayout.setColorSchemeResources(
                R.color.pager_title_background_top_start,
                R.color.pager_title_background_end,
                R.color.text_link,
                R.color.pager_title_background_end);

        listView = (ListView) view.findViewById(android.R.id.list);
        listView.setOnItemClickListener(new OnItemClickListener() {

            @Override
            public void onItemClick(AdapterView<?> parent, View view,
                    int position, long id) {
                onListItemClick((ListView) parent, view, position, id);
            }
        });
        listView.setOnItemLongClickListener(new OnItemLongClickListener() {

            @Override
            public boolean onItemLongClick(AdapterView<?> parent, View view,
                    int position, long id) {
                return onListItemLongClick((ListView) parent, view, position,
                        id);
            }
        });
        progressBar = (ProgressBar) view.findViewById(R.id.pb_loading);

        emptyView = (TextView) view.findViewById(android.R.id.empty);

        configureList(getActivity(), getListView());
    }

    @Override
    public void onResume() {
        super.onResume();
        refreshWithProgress();
    }


    protected void configureList(Activity activity, ListView listView) {
        listView.setAdapter(createAdapter());
    }


    protected void forceRefresh() {
        Bundle bundle = new Bundle();
        bundle.putBoolean(FORCE_REFRESH, true);
        refresh(bundle);
    }


    public void refresh() {
        refresh(null);
    }

    private void refresh(final Bundle args) {
        if (!isUsable())
            return;

        getLoaderManager().restartLoader(0, args, this);
    }


    protected abstract int getErrorMessage(Exception exception);

    public void onLoadFinished(Loader<List<E>> loader, List<E> items) {
        if (!isUsable())
            return;

        swipeLayout.setRefreshing(false);
        Exception exception = getException(loader);
        if (exception != null) {
            showError(exception, getErrorMessage(exception));
            showList();
            return;
        }

        this.items = items;
        getListAdapter().getWrappedAdapter().setItems(items.toArray());
        showList();
    }


    protected HeaderFooterListAdapter<SingleTypeAdapter<E>> createAdapter() {
        SingleTypeAdapter<E> wrapped = createAdapter(items);
        return new HeaderFooterListAdapter<>(getListView(),
                wrapped);
    }


    protected abstract SingleTypeAdapter<E> createAdapter(final List<E> items);


    protected void showList() {
        setListShown(true, isResumed());
    }

    @Override
    public void onLoaderReset(Loader<List<E>> loader) {

    }


    protected void showError(final Exception e, final int defaultMessage) {
        ToastUtils.show(getActivity(), e, defaultMessage);
    }


    protected Exception getException(final Loader<List<E>> loader) {
        if (loader instanceof ThrowableLoader)
            return ((ThrowableLoader<List<E>>) loader).clearException();
        else
            return null;
    }


    protected void refreshWithProgress() {
        items.clear();
        setListShown(false);
        refresh();
    }


    public ListView getListView() {
        return listView;
    }


    @SuppressWarnings("unchecked")
    protected HeaderFooterListAdapter<SingleTypeAdapter<E>> getListAdapter() {
        if (listView != null)
            return (HeaderFooterListAdapter<SingleTypeAdapter<E>>) listView
                    .getAdapter();
        else
            return null;
    }


    protected ItemListFragment<E> notifyDataSetChanged() {
        HeaderFooterListAdapter<SingleTypeAdapter<E>> root = getListAdapter();
        if (root != null) {
            SingleTypeAdapter<E> typeAdapter = root.getWrappedAdapter();
            if (typeAdapter != null)
                typeAdapter.notifyDataSetChanged();
        }
        return this;
    }


    protected ItemListFragment<E> setListAdapter(final ListAdapter adapter) {
        if (listView != null)
            listView.setAdapter(adapter);
        return this;
    }

    private ItemListFragment<E> fadeIn(final View view, final boolean animate) {
        if (view != null)
            if (animate)
                view.startAnimation(AnimationUtils.loadAnimation(getActivity(),
                        android.R.anim.fade_in));
            else
                view.clearAnimation();
        return this;
    }

    private ItemListFragment<E> show(final View view) {
        ViewUtils.setGone(view, false);
        return this;
    }

    private ItemListFragment<E> hide(final View view) {
        ViewUtils.setGone(view, true);
        return this;
    }


    public ItemListFragment<E> setListShown(final boolean shown) {
        return setListShown(shown, true);
    }


    public ItemListFragment<E> setListShown(final boolean shown,
            final boolean animate) {
        if (!isUsable())
            return this;

        if (shown == listShown) {
            if (shown)


                if (items.isEmpty())
                    hide(listView).show(emptyView);
                else
                    hide(emptyView).show(listView);
            return this;
        }

        listShown = shown;

        if (shown)
            if (!items.isEmpty())
                hide(progressBar).hide(emptyView).fadeIn(listView, animate)
                        .show(listView);
            else
                hide(progressBar).hide(listView).fadeIn(emptyView, animate)
                        .show(emptyView);
        else
            hide(listView).hide(emptyView).fadeIn(progressBar, animate)
                    .show(progressBar);

        return this;
    }


    protected ItemListFragment<E> setEmptyText(final String message) {
        if (emptyView != null)
            emptyView.setText(message);
        return this;
    }


    protected ItemListFragment<E> setEmptyText(final int resId) {
        if (emptyView != null)
            emptyView.setText(resId);
        return this;
    }


    public void onListItemClick(ListView l, View v, int position, long id) {
    }


    public boolean onListItemLongClick(ListView l, View v, int position, long id) {
        return false;
    }
}

<code block>

package com.github.pockethub.ui;

import android.text.NoCopySpan;
import android.text.Spannable;
import android.text.method.LinkMovementMethod;
import android.text.method.MovementMethod;
import android.view.MotionEvent;
import android.widget.TextView;

public class SelectableLinkMovementMethod extends LinkMovementMethod {
    private static final int CLICK = 1;
    private static final int UP = 2;
    private static final int DOWN = 3;

    private static SelectableLinkMovementMethod sInstance;
    private static Object FROM_BELOW = new NoCopySpan.Concrete();

    public static MovementMethod getInstance() {
        if (sInstance == null) {
            sInstance = new SelectableLinkMovementMethod();
        }

        return sInstance;
    }



    @Override
    public boolean canSelectArbitrarily() {
        return true;
    }


    @Override
    public boolean onTouchEvent(TextView widget, Spannable buffer,
        MotionEvent event) {
        return true;
    }


}

<code block>

package com.github.pockethub.ui;

import android.app.Activity;
import android.os.Bundle;
import android.view.View;

import com.github.kevinsawicki.wishlist.ViewFinder;
import com.github.pockethub.ui.roboactivities.RoboSupportFragment;

import java.io.Serializable;


public abstract class DialogFragment extends RoboSupportFragment implements
        DialogResultListener {


    protected ViewFinder finder;


    protected boolean isUsable() {
        return getActivity() != null;
    }

    @Override
    public void onDialogResult(int requestCode, int resultCode, Bundle arguments) {

    }


    @SuppressWarnings("unchecked")
    protected <V extends Serializable> V getSerializableExtra(final String name) {
        Activity activity = getActivity();
        if (activity != null)
            return (V) activity.getIntent().getSerializableExtra(name);
        else
            return null;
    }


    protected String getStringExtra(final String name) {
        Activity activity = getActivity();
        if (activity != null)
            return activity.getIntent().getStringExtra(name);
        else
            return null;
    }

    @Override
    public void onViewCreated(View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        finder = new ViewFinder(view);
    }
}

<code block>

package com.github.pockethub.ui;

import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentTransaction;
import android.support.v7.app.ActionBarActivity;
import android.view.ViewGroup;

import java.util.HashSet;
import java.util.Set;


public abstract class FragmentPagerAdapter extends
    android.support.v4.app.FragmentPagerAdapter implements FragmentProvider {

    private final ActionBarActivity activity;

    private final FragmentManager fragmentManager;

    private Fragment selected;

    private final Set<String> tags = new HashSet<>();


    public FragmentPagerAdapter(ActionBarActivity activity) {
        super(activity.getSupportFragmentManager());

        fragmentManager = activity.getSupportFragmentManager();
        this.activity = activity;
    }

    public FragmentPagerAdapter(Fragment fragment) {
        super(fragment.getChildFragmentManager());

        fragmentManager = fragment.getChildFragmentManager();
        this.activity = (ActionBarActivity) fragment.getActivity();
    }

    public boolean isEmpty() {
        return tags.isEmpty();
    }


    public FragmentPagerAdapter clearAdapter() {
        if (tags.isEmpty())
            return this;

        FragmentTransaction transaction = fragmentManager.beginTransaction();
        for (String tag : tags) {
            Fragment fragment = fragmentManager.findFragmentByTag(tag);
            if (fragment != null)
                transaction.remove(fragment);
        }
        transaction.commit();
        tags.clear();

        return this;
    }

    @Override
    public Fragment getSelected() {
        return selected;
    }

    public Object instantiateItem(ViewGroup container, int position) {
        Object fragment = super.instantiateItem(container, position);
        if (fragment instanceof Fragment)
            tags.add(((Fragment) fragment).getTag());
        return fragment;
    }

    @Override
    public void setPrimaryItem(final ViewGroup container, final int position,
        final Object object) {
        super.setPrimaryItem(container, position, object);

        boolean changed = false;
        if (object instanceof Fragment) {
            changed = object != selected;
            selected = (Fragment) object;
        } else {
            changed = object != null;
            selected = null;
        }

        if (changed)
            activity.invalidateOptionsMenu();
    }
}

<code block>

package com.github.pockethub.ui;

import android.app.AlertDialog;
import android.content.Context;


public class LightAlertDialog extends AlertDialog {


    public static AlertDialog create(final Context context) {
        return new LightAlertDialog(context, THEME_HOLO_LIGHT);
    }

    private LightAlertDialog(final Context context, final int theme) {
        super(context, theme);
    }

    private LightAlertDialog(final Context context) {
        super(context);
    }


    public static class Builder extends AlertDialog.Builder {


        public static LightAlertDialog.Builder create(final Context context) {
            return new LightAlertDialog.Builder(context, THEME_HOLO_LIGHT);
        }

        private Builder(Context context) {
            super(context);
        }

        private Builder(Context context, int theme) {
            super(context, theme);
        }
    }
}

<code block>

package com.github.pockethub.ui;

import android.content.Context;
import android.util.AttributeSet;
import android.view.View;


public class ViewPager extends android.support.v4.view.ViewPager {


    public ViewPager(final Context context) {
        super(context);
    }


    public ViewPager(final Context context, final AttributeSet attrs) {
        super(context, attrs);
    }


    public boolean setItem(final int item) {
        final boolean changed = item != getCurrentItem();
        if (changed)
            setCurrentItem(item, false);
        return changed;
    }


    public boolean setItem(final int item, final OnPageChangeListener listener) {
        final boolean changed = setItem(item);
        if (changed && listener != null)
            listener.onPageSelected(item);
        return changed;
    }


    public void scheduleSetItem(final int item,
                                final OnPageChangeListener listener) {
        post(new Runnable() {

            @Override
            public void run() {
                setItem(item, listener);
            }
        });
    }


    public void scheduleSetItem(final int item) {
        post(new Runnable() {

            @Override
            public void run() {
                setItem(item);
            }
        });
    }

    @Override
    protected boolean canScroll(final View v, final boolean checkV,
                                final int dx, final int x, final int y) {
        return super.canScroll(v, checkV, dx, x, y);
    }
}

<code block>

package com.github.pockethub.ui;

import static android.app.Activity.RESULT_CANCELED;
import android.app.AlertDialog;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentActivity;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentTransaction;

import roboguice.fragment.RoboDialogFragment;


public abstract class DialogFragmentHelper extends RoboDialogFragment implements
    OnClickListener {


    private static final String ARG_TITLE = "title";


    private static final String ARG_MESSAGE = "message";


    private static final String ARG_REQUEST_CODE = "requestCode";


    protected static void show(FragmentActivity activity,
        DialogFragmentHelper fragment, Bundle arguments, String tag) {
        FragmentManager manager = activity.getSupportFragmentManager();
        FragmentTransaction transaction = manager.beginTransaction();
        Fragment current = manager.findFragmentByTag(tag);
        if (current != null)
            transaction.remove(current);
        transaction.addToBackStack(null);

        fragment.setArguments(arguments);
        fragment.show(manager, tag);
    }


    protected static Bundle createArguments(final String title,
        final String message, final int requestCode) {
        Bundle arguments = new Bundle();
        arguments.putInt(ARG_REQUEST_CODE, requestCode);
        arguments.putString(ARG_TITLE, title);
        arguments.putString(ARG_MESSAGE, message);
        return arguments;
    }


    protected void onResult(final int resultCode) {
        final DialogFragmentActivity activity = (DialogFragmentActivity) getActivity();
        if (activity != null) {
            final Bundle arguments = getArguments();
            if (arguments != null)
                activity.onDialogResult(arguments.getInt(ARG_REQUEST_CODE),
                    resultCode, arguments);
        }
    }


    protected String getTitle() {
        return getArguments().getString(ARG_TITLE);
    }


    protected String getMessage() {
        return getArguments().getString(ARG_MESSAGE);
    }

    @Override
    public void onCancel(DialogInterface dialog) {
        onResult(RESULT_CANCELED);
    }


    protected AlertDialog createDialog() {
        final AlertDialog dialog = LightAlertDialog.create(getActivity());
        dialog.setTitle(getTitle());
        dialog.setMessage(getMessage());
        dialog.setCancelable(true);
        dialog.setOnCancelListener(this);
        return dialog;
    }

    @Override
    public void onClick(DialogInterface dialog, int which) {
        dialog.dismiss();
    }
}

<code block>
package com.github.pockethub.ui;


import android.app.Activity;
import android.content.Context;
import android.content.SharedPreferences;
import android.content.res.Configuration;
import android.graphics.Point;
import android.os.Bundle;
import android.preference.PreferenceManager;
import android.support.annotation.Nullable;
import android.support.v4.app.Fragment;
import android.support.v4.widget.DrawerLayout;
import android.support.v7.app.ActionBar;
import android.support.v7.app.ActionBarActivity;
import android.support.v7.app.ActionBarDrawerToggle;
import android.view.Display;
import android.view.LayoutInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.view.WindowManager;
import android.widget.AdapterView;
import android.widget.ImageView;
import android.widget.ListView;
import android.widget.TextView;

import com.github.pockethub.R;
import com.github.pockethub.util.AvatarLoader;

import org.eclipse.egit.github.core.User;

public class NavigationDrawerFragment extends Fragment implements AdapterView.OnItemClickListener {

    private static final String STATE_SELECTED_POSITION = "selected_navigation_drawer_position";
    private static final String PREF_USER_LEARNED_DRAWER = "navigation_drawer_learned";

    private NavigationDrawerCallbacks mCallbacks;
    private ActionBarDrawerToggle mDrawerToggle;

    private DrawerLayout mDrawerLayout;
    private ListView mDrawerListView;
    private View mFragmentContainerView;

    private int mCurrentSelectedPosition = 1;
    private boolean mFromSavedInstanceState;
    private boolean mUserLearnedDrawer;

    private ImageView userImage;
    private TextView userRealName;
    private TextView userName;

    public NavigationDrawerFragment() {
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getActivity());
        mUserLearnedDrawer = sp.getBoolean(PREF_USER_LEARNED_DRAWER, false);

        if (savedInstanceState != null) {
            mCurrentSelectedPosition = savedInstanceState.getInt(STATE_SELECTED_POSITION);
            mFromSavedInstanceState = true;
        }
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        setHasOptionsMenu(true);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if (item.getItemId() == android.R.id.home) {
            if (isDrawerOpen())
                mDrawerLayout.closeDrawer(mFragmentContainerView);
            else
                mDrawerLayout.openDrawer(mFragmentContainerView);
        }
        return super.onOptionsItemSelected(item);
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        return inflater.inflate(R.layout.fragment_navigation_drawer, container, false);
    }

    @Override
    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        mDrawerListView = (ListView) view.findViewById(R.id.navigation_drawer_list);
        mDrawerListView.setOnItemClickListener(this);
    }

    public boolean isDrawerOpen() {
        return mDrawerLayout != null && mDrawerLayout.isDrawerOpen(mFragmentContainerView);
    }

    public void setUp(int fragmentId, DrawerLayout drawerLayout, NavigationDrawerAdapter adapter, AvatarLoader avatar,
        User user) {
        mFragmentContainerView = getActivity().findViewById(fragmentId);
        mDrawerLayout = drawerLayout;


        int drawerWidth = checkTabletOrLandscape() ? R.dimen.navigation_drawer_width : materializedWidth();
        mDrawerListView.getLayoutParams().width = drawerWidth;


        View header = getActivity().getLayoutInflater().inflate(R.layout.drawer_header, mDrawerListView, false);
        userImage = (ImageView) header.findViewById(R.id.user_picture);
        userRealName = (TextView) header.findViewById(R.id.user_real_name);
        userName = (TextView) header.findViewById(R.id.user_name);

        avatar.bind(userImage, user);
        userName.setText(user.getLogin());

        String name = user.getName();
        if (name != null) {
            userRealName.setText(user.getName());
        } else {
            userRealName.setVisibility(View.GONE);
        }

        mDrawerListView.addHeaderView(header, null, false);
        mDrawerListView.setAdapter(adapter);
        mDrawerListView.setItemChecked(mCurrentSelectedPosition, true);

        ActionBar actionBar = getActionBar();
        actionBar.setDisplayHomeAsUpEnabled(true);
        actionBar.setHomeButtonEnabled(true);

        mDrawerToggle = new ActionBarDrawerToggle(
            getActivity(), mDrawerLayout,
            R.string.navigation_drawer_open,
            R.string.navigation_drawer_close) {
            @Override
            public void onDrawerClosed(View drawerView) {
                super.onDrawerClosed(drawerView);
                if (!isAdded()) {
                    return;
                }

                getActivity().supportInvalidateOptionsMenu();
            }

            @Override
            public void onDrawerOpened(View drawerView) {
                super.onDrawerOpened(drawerView);
                if (!isAdded()) {
                    return;
                }

                if (!mUserLearnedDrawer) {
                    mUserLearnedDrawer = true;
                    SharedPreferences sp = PreferenceManager
                        .getDefaultSharedPreferences(getActivity());
                    sp.edit().putBoolean(PREF_USER_LEARNED_DRAWER, true).apply();
                }

                getActivity().supportInvalidateOptionsMenu();
            }
        };

        if (!mUserLearnedDrawer && !mFromSavedInstanceState)
            mDrawerLayout.openDrawer(mFragmentContainerView);

        mDrawerLayout.post(new Runnable() {
            @Override
            public void run() {
                mDrawerToggle.syncState();
            }
        });

        mDrawerLayout.setDrawerListener(mDrawerToggle);

    }

    private void selectItem(int position) {
        if (mCallbacks != null && mDrawerListView != null && position != mCurrentSelectedPosition)
            mCallbacks.onNavigationDrawerItemSelected(position);
        if (mDrawerListView != null) mDrawerListView.setItemChecked(position, true);
        if (mDrawerLayout != null) mDrawerLayout.closeDrawer(mFragmentContainerView);
        mCurrentSelectedPosition = position;
    }

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);
        try {
            mCallbacks = (NavigationDrawerCallbacks) activity;
        } catch (ClassCastException e) {
            throw new ClassCastException("Activity must implement NavigationDrawerCallbacks.");
        }
    }

    @Override
    public void onDetach() {
        super.onDetach();
        mCallbacks = null;
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        outState.putInt(STATE_SELECTED_POSITION, mCurrentSelectedPosition);
    }

    @Override
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        mDrawerToggle.onConfigurationChanged(newConfig);
    }

    private ActionBar getActionBar() {
        return ((ActionBarActivity) getActivity()).getSupportActionBar();
    }

    @Override
    public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
        selectItem(position);
    }

    public static interface NavigationDrawerCallbacks {
        void onNavigationDrawerItemSelected(int position);
    }

    public boolean checkTabletOrLandscape() {
        boolean landscape = getActivity().getResources()
                                         .getConfiguration()
                                         .orientation == Configuration.ORIENTATION_LANDSCAPE;
        boolean tablet =
                (getActivity().getResources().getConfiguration().screenLayout & Configuration.SCREENLAYOUT_SIZE_MASK)
                == Configuration.SCREENLAYOUT_SIZE_XLARGE;

        return landscape || tablet;
    }

    public int materializedWidth() {

        WindowManager wm = (WindowManager) getActivity().getSystemService(Context.WINDOW_SERVICE);
        Display display = wm.getDefaultDisplay();
        Point screenSize = new Point();
        display.getSize(screenSize);

        int actionBarHeight = getActionBar().getHeight();

        return screenSize.x - actionBarHeight;

    }
}

<code block>

package com.github.pockethub.ui;

import android.content.Context;
import android.util.AttributeSet;


public class WebView extends android.webkit.WebView {


    public WebView(final Context context, final AttributeSet attrs,
                   final int defStyle, final boolean privateBrowsing) {
        super(context, attrs, defStyle, privateBrowsing);
    }


    public WebView(final Context context, final AttributeSet attrs,
                   final int defStyle) {
        super(context, attrs, defStyle);
    }


    public WebView(final Context context, final AttributeSet attrs) {
        super(context, attrs);
    }


    public WebView(final Context context) {
        super(context);
    }

    private boolean canScrollCodeHorizontally(final int direction) {
        final int range = computeHorizontalScrollRange()
                - computeHorizontalScrollExtent();
        if (range == 0)
            return false;

        if (direction < 0)
            return computeHorizontalScrollOffset() > 0;
        else
            return computeHorizontalScrollOffset() < range - 1;
    }

    @Override
    public boolean canScrollHorizontally(final int direction) {
        return super.canScrollHorizontally(direction);
    }
}

<code block>

package com.github.pockethub.ui;

import android.support.v4.app.Fragment;
import android.support.v7.app.ActionBarActivity;
import android.view.ViewGroup;


public abstract class FragmentStatePagerAdapter extends
    android.support.v4.app.FragmentStatePagerAdapter implements
    FragmentProvider {

    private final ActionBarActivity activity;

    private Fragment selected;


    public FragmentStatePagerAdapter(final ActionBarActivity activity) {
        super(activity.getSupportFragmentManager());

        this.activity = activity;
    }


    public FragmentStatePagerAdapter(final Fragment fragment) {
        super(fragment.getChildFragmentManager());

        this.activity = (ActionBarActivity) fragment.getActivity();
    }

    @Override
    public Fragment getSelected() {
        return selected;
    }

    @Override
    public void setPrimaryItem(final ViewGroup container, final int position,
        final Object object) {
        super.setPrimaryItem(container, position, object);

        boolean changed = false;
        if (object instanceof Fragment) {
            changed = object != selected;
            selected = (Fragment) object;
        } else {
            changed = object != null;
            selected = null;
        }

        if (changed)
            activity.invalidateOptionsMenu();
    }
}

<code block>
package com.github.pockethub.ui;

import static com.github.pockethub.ui.NavigationDrawerObject.TYPE_ITEM_MENU;
import static com.github.pockethub.ui.NavigationDrawerObject.TYPE_ITEM_ORG;
import static com.github.pockethub.ui.NavigationDrawerObject.TYPE_SEPERATOR;
import static com.github.pockethub.ui.NavigationDrawerObject.TYPE_SUBHEADER;
import android.content.Context;
import android.graphics.Typeface;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.ImageView;
import android.widget.TextView;

import com.github.pockethub.R;
import com.github.pockethub.util.AvatarLoader;

import java.util.ArrayList;
import java.util.List;

import org.eclipse.egit.github.core.User;

public class NavigationDrawerAdapter extends BaseAdapter {

    private final Context context;
    private final AvatarLoader avatars;
    private final LayoutInflater inflater;
    private List<User> orgs = new ArrayList<>();
    private List<NavigationDrawerObject> data;

    public NavigationDrawerAdapter(Context context, List<User> orgs, final AvatarLoader avatars) {
        this.orgs.addAll(orgs);
        this.context = context;
        this.inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        this.avatars = avatars;
        createData();
    }

    private void createData() {
        orgs.remove(0);
        String[] names = new String[] { context.getString(R.string.home), context.getString(R.string.gist),
            context.getString(R.string.issue_dashboard), context.getString(R.string.bookmarks) };
        String[] icons = context.getResources().getStringArray(R.array.navigation_drawer_icon_list);
        data = new ArrayList<>();
        int amount = names.length + orgs.size() + 2;
        for (int i = 0; i < amount; i++) {
            if (i < names.length)
                data.add(new NavigationDrawerObject(names[i], icons[i], TYPE_ITEM_MENU));
            else if (i == names.length)
                data.add(new NavigationDrawerObject(TYPE_SEPERATOR));
            else if (i == names.length + 1)
                data.add(new NavigationDrawerObject("Organizations", TYPE_SUBHEADER));
            else
                data.add(new NavigationDrawerObject(orgs.get(i - names.length - 2).getLogin(), TYPE_ITEM_ORG,
                    orgs.get(i - names.length - 2)));
        }
    }

    public void setOrgs(List<User> orgs) {
        this.orgs.addAll(orgs);
        this.orgs.remove(0);
        notifyDataSetChanged();
    }

    @Override
    public int getCount() {
        return data.size();
    }

    @Override
    public NavigationDrawerObject getItem(int position) {
        return data.get(position-1);
    }

    @Override
    public long getItemId(int position) {
        return data.get(position).getType();
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        ViewHolder viewHolder;
        final NavigationDrawerObject obj = data.get(position);
        if (convertView == null || obj.getType() != ((ViewHolder) convertView.getTag()).type) {
            viewHolder = new ViewHolder();
            switch (obj.getType()) {
                case TYPE_ITEM_MENU:
                    convertView = inflater.inflate(R.layout.navigation_drawer_list_item_text, parent, false);
                    viewHolder.name = (TextView) convertView.findViewById(R.id.navigation_drawer_item_name);
                    viewHolder.iconString = (TextView) convertView.findViewById(R.id.navigation_drawer_item_text_icon);
                    break;
                case TYPE_ITEM_ORG:
                    convertView = inflater.inflate(R.layout.navigation_drawer_list_item_image, parent, false);
                    viewHolder.name = (TextView) convertView.findViewById(R.id.navigation_drawer_item_name);
                    viewHolder.iconDrawable = (ImageView) convertView.findViewById(R.id
                        .navigation_drawer_item_drawable_icon);
                    break;
                case TYPE_SUBHEADER:
                    convertView = inflater.inflate(R.layout.navigation_drawer_list_subheader, parent, false);
                    viewHolder.name = (TextView) convertView.findViewById(R.id.navigation_drawer_item_name);
                    convertView.setEnabled(false);
                    convertView.setOnClickListener(null);
                    break;
                default:
                    convertView = inflater.inflate(R.layout.navigation_drawer_list_seperator, parent, false);
                    convertView.setEnabled(false);
                    convertView.setOnClickListener(null);
                    break;
            }
            viewHolder.type = obj.getType();
            convertView.setTag(viewHolder);
        } else {
            viewHolder = (ViewHolder) convertView.getTag();
        }

        switch (obj.getType()) {
            case TYPE_ITEM_MENU:
                Typeface font = Typeface.createFromAsset(context.getAssets(), "octicons.ttf");
                viewHolder.iconString.setTypeface(font);
                viewHolder.iconString.setText(obj.getIconString());
                viewHolder.name.setText(obj.getTitle());
                break;
            case TYPE_ITEM_ORG:
                avatars.bind(viewHolder.iconDrawable, obj.getUser());
                viewHolder.name.setText(obj.getTitle());
                break;
            case TYPE_SUBHEADER:
                viewHolder.name.setText(obj.getTitle());
                break;
        }

        return convertView;
    }

    private class ViewHolder {
        int type;
        TextView name;
        TextView iconString;
        ImageView iconDrawable;
    }
}

<code block>
package com.github.pockethub.ui;

import android.content.Context;
import android.support.design.widget.AppBarLayout;
import android.support.design.widget.CoordinatorLayout;
import android.support.v4.view.ViewCompat;
import android.util.AttributeSet;
import android.view.View;

import java.util.List;

public class PatchedScrollingViewBehavior extends AppBarLayout.ScrollingViewBehavior {

    public PatchedScrollingViewBehavior() {
        super();
    }

    public PatchedScrollingViewBehavior(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    @Override
    public boolean onMeasureChild(CoordinatorLayout parent, View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) {
        if(child.getLayoutParams().height == -1) {
            List<View> dependencies = parent.getDependencies(child);
            if(dependencies.isEmpty())
                return false;

            AppBarLayout appBar = findFirstAppBarLayout(dependencies);
            if(appBar != null && ViewCompat.isLaidOut(appBar)) {
                if(ViewCompat.getFitsSystemWindows(appBar))
                    ViewCompat.setFitsSystemWindows(child, true);

                int parentHeight = View.MeasureSpec.getSize(parentHeightMeasureSpec);
                int height = parentHeight - appBar.getMeasuredHeight();
                int heightMeasureSpec = View.MeasureSpec.makeMeasureSpec(height, View.MeasureSpec.EXACTLY);
                parent.onMeasureChild(child, parentWidthMeasureSpec, widthUsed, heightMeasureSpec, heightUsed);
                return true;
            }
        }

        return false;
    }


    private static AppBarLayout findFirstAppBarLayout(List<View> views) {
        int i = 0;

        for(int z = views.size(); i < z; ++i) {
            View view = views.get(i);
            if(view instanceof AppBarLayout) {
                return (AppBarLayout)view;
            }
        }

        return null;
    }
}

<code block>

package com.github.pockethub.ui;

import android.content.DialogInterface.OnClickListener;
import android.os.Bundle;

import java.util.ArrayList;


public class SingleChoiceDialogFragment extends DialogFragmentHelper implements
        OnClickListener {


    public static final String ARG_SELECTED = "selected";


    protected static final String ARG_CHOICES = "choices";


    protected static final String ARG_SELECTED_CHOICE = "selectedChoice";


    protected static final String TAG = "single_choice_dialog";


    protected static void show(final DialogFragmentActivity activity,
            final int requestCode, final String title, final String message,
            ArrayList<?> choices, final int selectedChoice,
            final DialogFragmentHelper helper) {
        Bundle arguments = createArguments(title, message, requestCode);
        arguments.putSerializable(ARG_CHOICES, choices);
        arguments.putInt(ARG_SELECTED_CHOICE, selectedChoice);
        show(activity, helper, arguments, TAG);
    }
}

<code block>
package com.github.pockethub.ui;

import android.support.v4.app.Fragment;
import android.support.v4.view.ViewPager;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;

public abstract class PagerFragment extends Fragment implements
    ViewPager.OnPageChangeListener {


    protected abstract FragmentProvider getProvider();


    protected Fragment getFragment() {
        FragmentProvider provider = getProvider();
        if (provider != null)
            return provider.getSelected();
        else
            return null;
    }

    @Override
    public boolean onOptionsItemSelected(final MenuItem item) {
        Fragment fragment = getFragment();
        if (fragment != null)
            return fragment.onOptionsItemSelected(item);

        return super.onOptionsItemSelected(item);
    }

    @Override
    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
        Fragment fragment = getFragment();
        if (fragment != null)
            fragment.onCreateOptionsMenu(menu, getActivity().getMenuInflater());
        super.onCreateOptionsMenu(menu, inflater);
    }

    @Override
    public void onPageScrolled(int position, float positionOffset,
        int positionOffsetPixels) {

    }

    @Override
    public void onPageSelected(int position) {

    }

    @Override
    public void onPageScrollStateChanged(int state) {

    }
}
<code block>

package com.github.pockethub.ui;

import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.TextView;

import com.github.pockethub.R;


public class ResourceLoadingIndicator {

    private HeaderFooterListAdapter<?> adapter;

    private boolean showing;

    private final View view;

    private final TextView textView;


    public ResourceLoadingIndicator(final Context context,
            final int loadingResId) {
        view = LayoutInflater.from(context).inflate(R.layout.loading_item, null);
        textView = (TextView) view.findViewById(R.id.tv_loading);
        textView.setText(loadingResId);
    }


    public ResourceLoadingIndicator setList(
            final HeaderFooterListAdapter<?> adapter) {
        this.adapter = adapter;
        adapter.addFooter(view);
        showing = true;
        return this;
    }


    public ResourceLoadingIndicator setVisible(final boolean visible) {
        if (showing != visible && adapter != null)
            if (visible)
                adapter.addFooter(view);
            else
                adapter.removeFooter(view);
        showing = visible;
        return this;
    }
}

<code block>
package com.github.pockethub.ui;

import static com.github.pockethub.ui.NavigationDrawerObject.TYPE_SEPERATOR;
import android.app.SearchManager;
import android.content.Context;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.LoaderManager;
import android.support.v4.content.Loader;
import android.support.v4.view.MenuItemCompat;
import android.support.v4.widget.DrawerLayout;
import android.support.v7.widget.SearchView;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.Window;

import com.github.pockethub.R;
import com.github.pockethub.accounts.AccountUtils;
import com.github.pockethub.core.user.UserComparator;
import com.github.pockethub.persistence.AccountDataManager;
import com.github.pockethub.ui.gist.GistsPagerFragment;
import com.github.pockethub.ui.issue.FilterListFragment;
import com.github.pockethub.ui.issue.IssueDashboardPagerFragment;
import com.github.pockethub.ui.repo.OrganizationLoader;
import com.github.pockethub.ui.user.HomePagerFragment;
import com.github.pockethub.util.AvatarLoader;
import com.google.inject.Inject;
import com.google.inject.Provider;

import java.util.Collections;
import java.util.List;

import org.eclipse.egit.github.core.User;

public class MainActivity extends BaseActivity implements NavigationDrawerFragment.NavigationDrawerCallbacks,
    LoaderManager.LoaderCallbacks<List<User>> {

    private static final String TAG = "MainActivity";

    private NavigationDrawerFragment mNavigationDrawerFragment;

    @Inject
    private AccountDataManager accountDataManager;

    @Inject
    private Provider<UserComparator> userComparatorProvider;

    private List<User> orgs = Collections.emptyList();

    private NavigationDrawerAdapter navigationAdapter;

    private User org;

    @Inject
    private AvatarLoader avatars;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        setSupportActionBar((android.support.v7.widget.Toolbar) findViewById(R.id.toolbar));

        getSupportLoaderManager().initLoader(0, null, this);

        mNavigationDrawerFragment = (NavigationDrawerFragment)
            getSupportFragmentManager().findFragmentById(R.id.navigation_drawer);
    }

    private void reloadOrgs() {
        getSupportLoaderManager().restartLoader(0, null, this);
    }

    @Override
    public boolean onCreateOptionsMenu(Menu optionMenu) {
        getMenuInflater().inflate(R.menu.home, optionMenu);

        SearchManager searchManager = (SearchManager) getSystemService(Context.SEARCH_SERVICE);
        MenuItem searchItem = optionMenu.findItem(R.id.m_search);
        SearchView searchView = (SearchView) MenuItemCompat.getActionView(searchItem);
        searchView.setSearchableInfo(searchManager.getSearchableInfo(getComponentName()));

        return super.onCreateOptionsMenu(optionMenu);
    }

    @Override
    protected void onResume() {
        super.onResume();



        List<User> currentOrgs = orgs;
        if (currentOrgs != null && !currentOrgs.isEmpty()
            && !AccountUtils.isUser(this, currentOrgs.get(0)))
            reloadOrgs();
    }

    @Override
    public Loader<List<User>> onCreateLoader(int i, Bundle bundle) {
        return new OrganizationLoader(this, accountDataManager,
            userComparatorProvider);
    }

    @Override
    public void onLoadFinished(Loader<List<User>> listLoader, final List<User> orgs) {
        if (orgs.isEmpty())
            return;

        org = orgs.get(0);
        this.orgs = orgs;

        if (navigationAdapter != null)
            navigationAdapter.setOrgs(orgs);
        else {
            navigationAdapter = new NavigationDrawerAdapter(MainActivity.this, orgs, avatars);
            mNavigationDrawerFragment.setUp(
                R.id.navigation_drawer,
                (DrawerLayout) findViewById(R.id.drawer_layout), navigationAdapter, avatars, org);

            Window window = getWindow();
            if (window == null)
                return;
            View view = window.getDecorView();
            if (view == null)
                return;

            view.post(new Runnable() {

                @Override
                public void run() {
                    MainActivity.this.onNavigationDrawerItemSelected(1);
                }
            });
        }
    }

    @Override
    public void onLoaderReset(Loader<List<User>> listLoader) {

    }


    @Override
    public void onNavigationDrawerItemSelected(int position) {
        if (navigationAdapter.getItem(position).getType() == TYPE_SEPERATOR)
            return;
        Fragment fragment;
        Bundle args = new Bundle();
        switch (position) {
            case 1:
                fragment = new HomePagerFragment();
                args.putSerializable("org", org);
                break;
            case 2:
                fragment = new GistsPagerFragment();
                break;
            case 3:
                fragment = new IssueDashboardPagerFragment();
                break;
            case 4:
                fragment = new FilterListFragment();
                break;
            default:
                fragment = new HomePagerFragment();
                args.putSerializable("org", orgs.get(position - 6));
                break;
        }
        fragment.setArguments(args);
        FragmentManager manager = getSupportFragmentManager();
        manager.beginTransaction().replace(R.id.container, fragment).commit();
    }

}

<code block>

package com.github.pockethub.ui;

import android.support.v4.app.Fragment;
import android.support.v4.view.ViewPager.OnPageChangeListener;
import android.view.Menu;
import android.view.MenuItem;


public abstract class PagerActivity extends DialogFragmentActivity implements
        OnPageChangeListener {

    private boolean menuCreated;


    protected abstract FragmentProvider getProvider();


    protected Fragment getFragment() {
        FragmentProvider provider = getProvider();
        if (provider != null)
            return provider.getSelected();
        else
            return null;
    }

    @Override
    public boolean onOptionsItemSelected(final MenuItem item) {
        Fragment fragment = getFragment();
        if (fragment != null)
            return fragment.onOptionsItemSelected(item);

        return super.onOptionsItemSelected(item);
    }

    @Override
    public void invalidateOptionsMenu() {
        if (menuCreated)
            super.invalidateOptionsMenu();
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        Fragment fragment = getFragment();
        if (fragment != null)
            fragment.onCreateOptionsMenu(menu, getMenuInflater());

        boolean created = super.onCreateOptionsMenu(menu);
        menuCreated = true;
        return created;
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        Fragment fragment = getFragment();
        if (fragment != null)
            fragment.onPrepareOptionsMenu(menu);
        return super.onPrepareOptionsMenu(menu);
    }

    @Override
    public void onPageScrolled(int position, float positionOffset,
            int positionOffsetPixels) {

    }

    @Override
    public void onPageSelected(int position) {
        invalidateOptionsMenu();
    }

    @Override
    public void onPageScrollStateChanged(int state) {

    }
}

<code block>

package com.github.pockethub.ui;

import android.os.Bundle;
import android.support.design.widget.TabLayout;
import android.support.v4.view.PagerAdapter;
import android.view.View;
import android.widget.TabHost.OnTabChangeListener;
import android.widget.TabHost.TabContentFactory;

import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.pockethub.R;


public abstract class TabPagerActivity<V extends PagerAdapter & FragmentProvider>
    extends PagerActivity implements OnTabChangeListener, TabContentFactory {


    protected ViewPager pager;


    protected TabLayout slidingTabsLayout;


    protected V adapter;

    @Override
    public void onPageSelected(final int position) {
        super.onPageSelected(position);
    }

    @Override
    public void onTabChanged(String tabId) {
    }

    @Override
    public View createTabContent(String tag) {
        return ViewUtils.setGone(new View(getApplication()), true);
    }


    protected abstract V createAdapter();


    protected String getTitle(final int position) {
        return adapter.getPageTitle(position).toString();
    }


    protected String getIcon(final int position) {
        return null;
    }


    protected TabPagerActivity<V> setGone(boolean gone) {
        ViewUtils.setGone(slidingTabsLayout, gone);
        ViewUtils.setGone(pager, gone);
        return this;
    }


    protected void setCurrentItem(final int position) {

    }


    protected int getContentView() {
        return R.layout.pager_with_tabs;
    }

    private void updateCurrentItem(final int newPosition) {
        if (newPosition > -1 && newPosition < adapter.getCount()) {
            pager.setItem(newPosition);
            setCurrentItem(newPosition);
        }
    }

    private void createPager() {
        adapter = createAdapter();
        invalidateOptionsMenu();
        pager.setAdapter(adapter);
    }

    public void updateTabs() {
        slidingTabsLayout.setupWithViewPager(pager);
    }


    protected void configureTabPager() {
        if (adapter == null) {
            createPager();
            updateTabs();
        }
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(getContentView());

        setSupportActionBar((android.support.v7.widget.Toolbar) findViewById(R.id.toolbar));


        getSupportActionBar().setElevation(0);

        pager = (ViewPager) findViewById(R.id.vp_pages);
        pager.setOnPageChangeListener(this);
        slidingTabsLayout = (TabLayout) findViewById(R.id.sliding_tabs_layout);
    }

    @Override
    protected FragmentProvider getProvider() {
        return adapter;
    }
}

<code block>

package com.github.pockethub.ui;

import android.os.Bundle;

import com.github.kevinsawicki.wishlist.ViewFinder;
import com.github.pockethub.ui.roboactivities.RoboActionBarActivity;

import java.io.Serializable;


public abstract class DialogFragmentActivity extends
    RoboActionBarActivity implements DialogResultListener {


    protected ViewFinder finder;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        finder = new ViewFinder(this);
    }


    @SuppressWarnings("unchecked")
    protected <V extends Serializable> V getSerializableExtra(final String name) {
        return (V) getIntent().getSerializableExtra(name);
    }


    protected int getIntExtra(final String name) {
        return getIntent().getIntExtra(name, -1);
    }


    protected int[] getIntArrayExtra(final String name) {
        return getIntent().getIntArrayExtra(name);
    }


    protected boolean[] getBooleanArrayExtra(final String name) {
        return getIntent().getBooleanArrayExtra(name);
    }


    protected String getStringExtra(final String name) {
        return getIntent().getStringExtra(name);
    }


    protected String[] getStringArrayExtra(final String name) {
        return getIntent().getStringArrayExtra(name);
    }


    protected CharSequence[] getCharSequenceArrayExtra(final String name) {
        return getIntent().getCharSequenceArrayExtra(name);
    }

    @Override
    public void onDialogResult(int requestCode, int resultCode, Bundle arguments) {

    }
}

<code block>

package com.github.pockethub.ui;

import android.app.AlertDialog;
import android.content.Context;

import com.github.pockethub.accounts.AuthenticatedUserTask;

import java.util.concurrent.Executor;


public abstract class ProgressDialogTask<E> extends AuthenticatedUserTask<E> {


    protected AlertDialog progress;


    protected ProgressDialogTask(Context context) {
        super(context);
    }


    public ProgressDialogTask(Context context, Executor executor) {
        super(context, executor);
    }


    protected void dismissProgress() {
        if (progress != null) {
            progress.dismiss();
            progress = null;
        }
    }


    protected void showIndeterminate(final CharSequence message) {
        dismissProgress();

        progress = LightProgressDialog.create(getContext(), message);
        progress.show();
    }


    protected void showIndeterminate(final int resId) {
        dismissProgress();

        progress = LightProgressDialog.create(getContext(), resId);
        progress.show();
    }


    @Override
    protected void onSuccess(E e) throws Exception {
        dismissProgress();
    }


    @Override
    protected void onException(Exception e) throws RuntimeException {
        dismissProgress();
    }


    protected String getString(int resId) {
        return getContext().getString(resId);
    }
}

<code block>

package com.github.pockethub.ui;

import android.app.Activity;
import android.os.Bundle;
import android.support.v4.content.Loader;
import android.widget.AbsListView;
import android.widget.AbsListView.OnScrollListener;
import android.widget.ListView;

import com.github.pockethub.ThrowableLoader;
import com.github.pockethub.core.ResourcePager;

import java.io.IOException;
import java.util.List;


public abstract class PagedItemFragment<E> extends ItemListFragment<E>
        implements OnScrollListener {


    protected ResourcePager<E> pager;

    private ResourceLoadingIndicator loadingIndicator;


    protected abstract ResourcePager<E> createPager();


    protected abstract int getLoadingMessage();

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        pager = createPager();
    }


    protected void configureList(Activity activity, ListView listView) {
        super.configureList(activity, listView);

        loadingIndicator = new ResourceLoadingIndicator(activity,
                getLoadingMessage());
        loadingIndicator.setList(getListAdapter());
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        getListView().setOnScrollListener(this);

        getListView().setFastScrollEnabled(true);
    }

    @Override
    public Loader<List<E>> onCreateLoader(int id, Bundle bundle) {
        return new ThrowableLoader<List<E>>(getActivity(), items) {

            @Override
            public List<E> loadData() throws IOException {
                pager.next();
                return pager.getResources();
            }
        };
    }

    @Override
    public void onScrollStateChanged(AbsListView view, int scrollState) {

    }

    @Override
    public void onScroll(AbsListView view, int firstVisibleItem,
            int visibleItemCount, int totalItemCount) {
        if (!isUsable())
            return;
        if (!pager.hasMore())
            return;
        if (getLoaderManager().hasRunningLoaders())
            return;
        if (listView != null
                && listView.getLastVisiblePosition() >= pager.size())
            showMore();
    }

    @Override
    protected void forceRefresh() {
        pager.clear();

        super.forceRefresh();
    }


    private void showMore() {
        refresh();
    }

    @Override
    public void onLoadFinished(Loader<List<E>> loader, List<E> items) {
        loadingIndicator.setVisible(pager.hasMore());

        super.onLoadFinished(loader, items);
    }

    @Override
    protected void refreshWithProgress() {
        pager.reset();
        pager = createPager();

        super.refreshWithProgress();
    }
}

<code block>
package com.github.pockethub.ui;

import android.content.Context;
import android.util.AttributeSet;
import android.widget.Checkable;
import android.widget.RelativeLayout;

public class CheckableRelativeLayout extends RelativeLayout implements Checkable {
    private static final int[] CheckedStateSet = {
        android.R.attr.state_checked
    };
    private boolean checked = false;

    public CheckableRelativeLayout(Context context) {
        super(context, null);
    }

    public CheckableRelativeLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public boolean isChecked() {
        return checked;
    }

    public void setChecked(boolean b) {
        checked = b;
        refreshDrawableState();
        forceLayout();
    }

    public void toggle() {
        checked = !checked;
    }

    @Override
    protected int[] onCreateDrawableState(int extraSpace) {
        final int[] drawableState = super.onCreateDrawableState(extraSpace + 1);
        if (isChecked()) {
            mergeDrawableStates(drawableState, CheckedStateSet);
        }
        return drawableState;
    }
}
<code block>

package com.github.pockethub.ui;

import static android.app.Activity.RESULT_CANCELED;
import static android.app.Activity.RESULT_OK;
import static android.content.DialogInterface.BUTTON_NEGATIVE;
import static android.content.DialogInterface.BUTTON_POSITIVE;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.os.Bundle;
import android.support.v4.app.FragmentActivity;


public class ConfirmDialogFragment extends DialogFragmentHelper implements
        OnClickListener {

    private static final String TAG = "confirm_dialog";


    public static void show(final FragmentActivity activity,
            final int requestCode, final String title, final String message) {
        show(activity, requestCode, title, message, null);
    }


    public static void show(final FragmentActivity activity,
            final int requestCode, final String title, final String message,
            final Bundle bundle) {
        Bundle arguments = createArguments(title, message, requestCode);
        if (bundle != null)
            arguments.putAll(bundle);
        show(activity, new ConfirmDialogFragment(), arguments, TAG);
    }

    public Dialog onCreateDialog(final Bundle savedInstanceState) {
        AlertDialog dialog = LightAlertDialog.create(getActivity());
        dialog.setTitle(getTitle());
        dialog.setMessage(getMessage());
        dialog.setButton(BUTTON_POSITIVE,
                getResources().getString(android.R.string.yes), this);
        dialog.setButton(BUTTON_NEGATIVE,
                getResources().getString(android.R.string.no), this);
        dialog.setCancelable(true);
        dialog.setOnCancelListener(this);
        return dialog;
    }

    @Override
    public void onClick(DialogInterface dialog, int which) {
        dialog.dismiss();
        switch (which) {
        case BUTTON_POSITIVE:
            onResult(RESULT_OK);
            break;
        case BUTTON_NEGATIVE:
            onResult(RESULT_CANCELED);
            break;
        }
    }
}

<code block>
package com.github.pockethub.ui;

import android.os.Bundle;
import android.support.annotation.Nullable;
import android.support.design.widget.TabLayout;
import android.support.v4.view.PagerAdapter;
import android.support.v7.app.ActionBarActivity;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;

import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.pockethub.R;

import static android.widget.TabHost.OnTabChangeListener;
import static android.widget.TabHost.TabContentFactory;

public abstract class TabPagerFragment<V extends PagerAdapter & FragmentProvider>
    extends PagerFragment implements OnTabChangeListener, TabContentFactory {



    protected ViewPager pager;


    protected TabLayout slidingTabsLayout;


    protected V adapter;

    @Override
    public void onPageSelected(final int position) {
        super.onPageSelected(position);
    }

    @Override
    public void onTabChanged(String tabId) {
    }

    @Override
    public View createTabContent(String tag) {
        return ViewUtils.setGone(new View(getActivity().getApplication()), true);
    }


    protected abstract V createAdapter();


    protected String getTitle(final int position) {
        return adapter.getPageTitle(position).toString();
    }


    protected String getIcon(final int position) {
        return null;
    }


    protected TabPagerFragment<V> setGone(boolean gone) {
        ViewUtils.setGone(slidingTabsLayout, gone);
        ViewUtils.setGone(pager, gone);
        return this;
    }


    protected void setCurrentItem(final int position) {

    }


    protected int getContentView() {
        return R.layout.pager_with_tabs;
    }

    private void createPager() {
        adapter = createAdapter();
        getActivity().supportInvalidateOptionsMenu();
        pager.setAdapter(adapter);
        slidingTabsLayout.setupWithViewPager(pager);
    }


    protected void configureTabPager() {
        createPager();
    }

    @Override
    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container,
        @Nullable Bundle savedInstanceState) {
        return inflater.inflate(getContentView(), null);
    }

    @Override
    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        setHasOptionsMenu(true);
        view.findViewById(R.id.toolbar).setVisibility(View.GONE);


        ((ActionBarActivity) getActivity()).getSupportActionBar().setElevation(0);

        pager = (ViewPager) view.findViewById(R.id.vp_pages);
        pager.setOnPageChangeListener(this);
        slidingTabsLayout = (TabLayout) view.findViewById(R.id.sliding_tabs_layout);
    }

    @Override
    protected FragmentProvider getProvider() {
        return adapter;
    }

}

<code block>

package com.github.pockethub.ui;

import android.app.AlertDialog;
import android.app.ProgressDialog;
import android.content.Context;

import com.github.pockethub.R;



public class LightProgressDialog extends ProgressDialog {


    public static AlertDialog create(Context context, int resId) {
        return create(context, context.getResources().getString(resId));
    }


    public static AlertDialog create(Context context, CharSequence message) {
        ProgressDialog dialog = new LightProgressDialog(context, message);
        dialog.setMessage(message);
        dialog.setIndeterminate(true);
        dialog.setProgressStyle(STYLE_SPINNER);
        dialog.setIndeterminateDrawable(context.getResources().getDrawable(R.drawable.spinner));
        return dialog;
    }

    private LightProgressDialog(Context context, CharSequence message) {
        super(context, THEME_HOLO_LIGHT);
    }
}

<code block>

package com.github.pockethub.ui;

import android.app.Activity;
import android.os.Bundle;


public interface DialogResultListener {


    void onDialogResult(int requestCode, int resultCode, Bundle arguments);
}

<code block>

package com.github.pockethub.ui;

import android.text.Editable;
import android.text.TextWatcher;


public class TextWatcherAdapter implements TextWatcher {

    public void afterTextChanged(Editable s) {
    }

    public void beforeTextChanged(CharSequence s, int start, int count,
            int after) {
    }

    public void onTextChanged(CharSequence s, int start, int before, int count) {
    }
}

<code block>

package com.github.pockethub.ui;

import android.support.v4.app.Fragment;


public interface FragmentProvider {


    Fragment getSelected();
}

<code block>

package com.github.pockethub.ui;

import static android.graphics.Typeface.BOLD;
import android.text.SpannableStringBuilder;
import android.text.TextUtils;
import android.text.style.BackgroundColorSpan;
import android.text.style.ForegroundColorSpan;
import android.text.style.StyleSpan;
import android.text.style.TypefaceSpan;
import android.text.style.URLSpan;
import android.view.View;
import android.view.View.OnClickListener;

import com.github.pockethub.util.TimeUtils;

import java.util.Date;
import java.util.Locale;


public class StyledText extends SpannableStringBuilder {


    public StyledText append(final CharSequence text, final Object span) {
        if (!TextUtils.isEmpty(text)) {
            append(text);
            if (span != null) {
                final int length = length();
                setSpan(span, length - text.length(), length,
                        SPAN_EXCLUSIVE_EXCLUSIVE);
            }
        }
        return this;
    }

    @Override
    public StyledText append(char text) {
        super.append(text);
        return this;
    }

    @Override
    public StyledText append(CharSequence text) {
        if (text != null)
            super.append(text);
        return this;
    }


    public StyledText append(final char text, final Object span) {
        append(text);
        if (span != null) {
            final int length = length();
            setSpan(span, length - 1, length, SPAN_EXCLUSIVE_EXCLUSIVE);
        }
        return this;
    }


    public StyledText bold(final CharSequence text) {
        return append(text, new StyleSpan(BOLD));
    }


    public StyledText background(final CharSequence text, final int color) {
        return append(text, new BackgroundColorSpan(color));
    }


    public StyledText foreground(final CharSequence text, final int color) {
        return append(text, new ForegroundColorSpan(color));
    }


    public StyledText foreground(final char text, final int color) {
        return append(text, new ForegroundColorSpan(color));
    }


    public StyledText monospace(final CharSequence text) {
        return append(text, new TypefaceSpan("monospace"));
    }


    public StyledText url(final CharSequence text,
            final OnClickListener listener) {
        return append(text, new URLSpan(text.toString()) {

            @Override
            public void onClick(View widget) {
                listener.onClick(widget);
            }
        });
    }


    public StyledText url(final CharSequence text) {
        return append(text, new URLSpan(text.toString()));
    }


    public StyledText append(final Date date) {
        final CharSequence time = TimeUtils.getRelativeTime(date);


        final int timeLength = time.length();
        if (length() > 0 && timeLength > 0
                && Character.isUpperCase(time.charAt(0))) {
            append(time.subSequence(0, 1).toString()
                    .toLowerCase(Locale.getDefault()));
            append(time.subSequence(1, timeLength));
        } else
            append(time);

        return this;
    }
}

<code block>
package com.github.pockethub.ui;

import org.eclipse.egit.github.core.User;

public class NavigationDrawerObject {
    public static final int TYPE_SEPERATOR = -1;
    public static final int TYPE_SUBHEADER = 0;
    public static final int TYPE_ITEM_MENU = 1;
    public static final int TYPE_ITEM_ORG = 2;

    private String title;
    private String iconString;
    private User user;
    private int type;

    public NavigationDrawerObject(String title, String icon, int type) {
        this.title = title;
        this.iconString = icon;
        this.type = type;
    }

    public NavigationDrawerObject(String title, int type, User user) {
        this.title = title;
        this.type = type;
        this.user = user;

    }

    public NavigationDrawerObject(String title, int type) {
        this.title = title;
        this.type = type;
    }

    public NavigationDrawerObject(int type) {
        this.type = type;
    }

    public User getUser() {
        return user;
    }


    public int getType() {
        return type;
    }

    public String getTitle() {
        return title;
    }

    public String getIconString() {
        return iconString;
    }
}
<code block>

package com.github.pockethub.ui.user;

import org.eclipse.egit.github.core.User;


public interface OrganizationSelectionProvider {


    User addListener(OrganizationSelectionListener listener);


    OrganizationSelectionProvider removeListener(
            OrganizationSelectionListener listener);
}

<code block>

package com.github.pockethub.ui.user;

import android.view.View;
import android.widget.ListView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.pockethub.accounts.AccountUtils;
import com.github.pockethub.ui.PagedItemFragment;
import com.github.pockethub.util.AvatarLoader;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.service.UserService;


public abstract class PagedUserFragment extends PagedItemFragment<User> {


    @Inject
    protected AvatarLoader avatars;


    @Inject
    protected UserService service;

    @Override
    protected SingleTypeAdapter<User> createAdapter(List<User> items) {
        User[] users = items.toArray(new User[items.size()]);
        return new UserListAdapter(getActivity().getLayoutInflater(), users,
                avatars);
    }

    @Override
    public void onListItemClick(ListView l, View v, int position, long id) {
        User user = (User) l.getItemAtPosition(position);
        if (!AccountUtils.isUser(getActivity(), user))
            startActivity(UserViewActivity.createIntent(user));
    }
}

<code block>
package com.github.pockethub.ui.user;

import android.text.TextUtils;

import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.pockethub.core.issue.IssueUtils;
import com.github.pockethub.ui.StyledText;
import com.github.pockethub.util.TimeUtils;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.Commit;
import org.eclipse.egit.github.core.CommitComment;
import org.eclipse.egit.github.core.Download;
import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.PullRequest;
import org.eclipse.egit.github.core.Team;
import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.event.CommitCommentPayload;
import org.eclipse.egit.github.core.event.CreatePayload;
import org.eclipse.egit.github.core.event.DeletePayload;
import org.eclipse.egit.github.core.event.DownloadPayload;
import org.eclipse.egit.github.core.event.Event;
import org.eclipse.egit.github.core.event.EventRepository;
import org.eclipse.egit.github.core.event.FollowPayload;
import org.eclipse.egit.github.core.event.GistPayload;
import org.eclipse.egit.github.core.event.IssueCommentPayload;
import org.eclipse.egit.github.core.event.IssuesPayload;
import org.eclipse.egit.github.core.event.MemberPayload;
import org.eclipse.egit.github.core.event.PullRequestPayload;
import org.eclipse.egit.github.core.event.PullRequestReviewCommentPayload;
import org.eclipse.egit.github.core.event.PushPayload;
import org.eclipse.egit.github.core.event.TeamAddPayload;

import java.util.List;

import static com.github.kevinsawicki.wishlist.ViewUpdater.FORMAT_INT;

public class IconAndViewTextManager {
    public static final String ISSUES_PAYLOAD_ACTION_OPENED = "opened";
    public static final String ISSUES_PAYLOAD_ACTION_REOPENED = "reopened";
    public static final String ISSUES_PAYLOAD_ACTION_CLOSED = "closed";
    private final NewsListAdapter newsListAdapter;

    public IconAndViewTextManager(NewsListAdapter newsListAdapter) {
        this.newsListAdapter = newsListAdapter;
    }

    private void appendComment(final StyledText details,
            final Comment comment) {
        if (comment != null)
            appendText(details, comment.getBody());
    }

    private void appendCommitComment(final StyledText details,
            final CommitComment comment) {
        if (comment == null)
            return;

        String id = comment.getCommitId();
        if (!TextUtils.isEmpty(id)) {
            if (id.length() > 10)
                id = id.substring(0, 10);
            appendText(details, "Comment in");
            details.append(' ');
            details.monospace(id);
            details.append(':').append('\n');
        }
        appendComment(details, comment);
    }

    private void appendText(final StyledText details, String text) {
        if (text == null)
            return;
        text = text.trim();
        if (text.length() == 0)
            return;

        details.append(text);
    }

    private StyledText boldActor(final StyledText text, final Event event) {
        return boldUser(text, event.getActor());
    }

    private StyledText boldUser(final StyledText text, final User user) {
        if (user != null)
            text.bold(user.getLogin());
        return text;
    }

    private StyledText boldRepo(final StyledText text, final Event event) {
        EventRepository repo = event.getRepo();
        if (repo != null)
            text.bold(repo.getName());
        return text;
    }

    private StyledText boldRepoName(final StyledText text,
            final Event event) {
        EventRepository repo = event.getRepo();
        if (repo != null) {
            String name = repo.getName();
            if (!TextUtils.isEmpty(name)) {
                int slash = name.indexOf('/');
                if (slash != -1 && slash + 1 < name.length())
                    text.bold(name.substring(slash + 1));
            }
        }
        return text;
    }

    void formatCommitComment(Event event, StyledText main,
                                    StyledText details) {
        boldActor(main, event);
        main.append(" commented on ");
        boldRepo(main, event);

        CommitCommentPayload payload = (CommitCommentPayload) event
                .getPayload();
        appendCommitComment(details, payload.getComment());
    }

    void formatDownload(Event event, StyledText main,
                               StyledText details) {
        boldActor(main, event);
        main.append(" uploaded a file to ");
        boldRepo(main, event);

        DownloadPayload payload = (DownloadPayload) event.getPayload();
        Download download = payload.getDownload();
        if (download != null)
            appendText(details, download.getName());
    }

    void formatCreate(Event event, StyledText main,
                             StyledText details) {
        boldActor(main, event);

        main.append(" created ");
        CreatePayload payload = (CreatePayload) event.getPayload();
        String refType = payload.getRefType();
        main.append(refType);
        main.append(' ');
        if (!"repository".equals(refType)) {
            main.append(payload.getRef());
            main.append(" at ");
            boldRepo(main, event);
        } else
            boldRepoName(main, event);
    }

    void formatDelete(Event event, StyledText main,
                             StyledText details) {
        boldActor(main, event);

        DeletePayload payload = (DeletePayload) event.getPayload();
        main.append(" deleted ");
        main.append(payload.getRefType());
        main.append(' ');
        main.append(payload.getRef());
        main.append(" at ");

        boldRepo(main, event);
    }

    void formatFollow(Event event, StyledText main,
                             StyledText details) {
        boldActor(main, event);
        main.append(" started following ");
        boldUser(main, ((FollowPayload) event.getPayload()).getTarget());
    }

    void formatFork(Event event, StyledText main,
                           StyledText details) {
        boldActor(main, event);
        main.append(" forked repository ");
        boldRepo(main, event);
    }

    void formatGist(Event event, StyledText main,
                           StyledText details) {
        boldActor(main, event);

        GistPayload payload = (GistPayload) event.getPayload();

        main.append(' ');
        String action = payload.getAction();
        if ("create".equals(action))
            main.append("created");
        else if ("update".equals(action))
            main.append("updated");
        else
            main.append(action);
        main.append(" Gist ");
        main.append(payload.getGist().getId());
    }

    void formatWiki(Event event, StyledText main,
                           StyledText details) {
        boldActor(main, event);
        main.append(" updated the wiki in ");
        boldRepo(main, event);
    }

    void formatIssueComment(Event event, StyledText main,
                                   StyledText details) {
        boldActor(main, event);

        main.append(" commented on ");

        IssueCommentPayload payload = (IssueCommentPayload) event.getPayload();

        Issue issue = payload.getIssue();
        String number;
        if (IssueUtils.isPullRequest(issue))
            number = "pull request " + issue.getNumber();
        else
            number = "issue " + issue.getNumber();
        main.bold(number);

        main.append(" on ");

        boldRepo(main, event);

        appendComment(details, payload.getComment());
    }

    void formatIssues(Event event, StyledText main,
                             StyledText details) {
        boldActor(main, event);

        IssuesPayload payload = (IssuesPayload) event.getPayload();
        String action = payload.getAction();
        Issue issue = payload.getIssue();
        main.append(' ');
        main.append(action);
        main.append(' ');
        main.bold("issue " + issue.getNumber());
        main.append(" on ");

        boldRepo(main, event);

        appendText(details, issue.getTitle());
    }

    void formatAddMember(Event event, StyledText main,
                                StyledText details) {
        boldActor(main, event);
        main.append(" added ");
        User member = ((MemberPayload) event.getPayload()).getMember();
        if (member != null)
            main.bold(member.getLogin());
        main.append(" as a collaborator to ");
        boldRepo(main, event);
    }

    void formatPublic(Event event, StyledText main,
                             StyledText details) {
        boldActor(main, event);
        main.append(" open sourced repository ");
        boldRepo(main, event);
    }

    void formatWatch(Event event, StyledText main,
                            StyledText details) {
        boldActor(main, event);
        main.append(" starred ");
        boldRepo(main, event);
    }

    void formatReviewComment(Event event, StyledText main,
                                    StyledText details) {
        boldActor(main, event);
        main.append(" commented on ");
        boldRepo(main, event);

        PullRequestReviewCommentPayload payload = (PullRequestReviewCommentPayload) event
                .getPayload();
        appendCommitComment(details, payload.getComment());
    }

    void formatPullRequest(Event event, StyledText main,
                                  StyledText details) {
        boldActor(main, event);

        PullRequestPayload payload = (PullRequestPayload) event.getPayload();
        String action = payload.getAction();
        if ("synchronize".equals(action))
            action = "updated";
        main.append(' ');
        main.append(action);
        main.append(' ');
        main.bold("pull request " + payload.getNumber());
        main.append(" on ");

        boldRepo(main, event);

        if (ISSUES_PAYLOAD_ACTION_OPENED.equals(action) || "closed".equals(action)) {
            PullRequest request = payload.getPullRequest();
            if (request != null) {
                String title = request.getTitle();
                if (!TextUtils.isEmpty(title))
                    details.append(title);
            }
        }
    }

    void formatPush(Event event, StyledText main,
                           StyledText details) {
        boldActor(main, event);

        main.append(" pushed to ");
        PushPayload payload = (PushPayload) event.getPayload();
        String ref = payload.getRef();
        if (ref.startsWith("refs/heads/"))
            ref = ref.substring(11);
        main.bold(ref);
        main.append(" at ");

        boldRepo(main, event);

        final List<Commit> commits = payload.getCommits();
        int size = commits != null ? commits.size() : -1;
        if (size > 0) {
            if (size != 1)
                details.append(FORMAT_INT.format(size)).append(" new commits");
            else
                details.append("1 new commit");

            int max = 3;
            int appended = 0;
            for (Commit commit : commits) {
                if (commit == null)
                    continue;

                String sha = commit.getSha();
                if (TextUtils.isEmpty(sha))
                    continue;

                details.append('\n');
                if (sha.length() > 7)
                    details.monospace(sha.substring(0, 7));
                else
                    details.monospace(sha);

                String message = commit.getMessage();
                if (!TextUtils.isEmpty(message)) {
                    details.append(' ');
                    int newline = message.indexOf('\n');
                    if (newline > 0)
                        details.append(message.subSequence(0, newline));
                    else
                        details.append(message);
                }

                appended++;
                if (appended == max)
                    break;
            }
        }
    }

    void formatTeamAdd(Event event, StyledText main,
                              StyledText details) {
        boldActor(main, event);

        TeamAddPayload payload = (TeamAddPayload) event.getPayload();

        main.append(" added ");

        User user = payload.getUser();
        if (user != null)
            boldUser(main, user);
        else
            boldRepoName(main, event);

        main.append(" to team");

        Team team = payload.getTeam();
        String teamName = team != null ? team.getName() : null;
        if (teamName != null)
            main.append(' ').bold(teamName);
    }

    protected void update(int position, Event event) {
        newsListAdapter.getAvatars().bind(newsListAdapter.imageViewAgent(0), event.getActor());

        StyledText main = new StyledText();
        StyledText details = new StyledText();
        String icon = setIconAndFormatStyledText(event, main, details);

        if (icon != null)
            ViewUtils.setGone(newsListAdapter.setTextAgent(3, icon), false);
        else
            newsListAdapter.setGoneAgent(3, true);

        newsListAdapter.setTextAgent(1, main);

        if (!TextUtils.isEmpty(details))
            ViewUtils.setGone(newsListAdapter.setTextAgent(2, details), false);
        else
            newsListAdapter.setGoneAgent(2, true);

        newsListAdapter.setTextAgent(4, TimeUtils.getRelativeTime(event.getCreatedAt()));
    }

    String setIconAndFormatStyledText(Event event, StyledText main, StyledText details) {

        return EventType.valueOf(event.getType()).generateIconAndFormatStyledText(this, event, main, details);
    }
}
<code block>

package com.github.pockethub.ui.user;

import android.os.Bundle;

import com.github.pockethub.R;



public abstract class FollowersFragment extends PagedUserFragment {

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        setEmptyText(R.string.no_followers);
    }

    @Override
    protected int getLoadingMessage() {
        return R.string.loading_followers;
    }

    @Override
    protected int getErrorMessage(Exception exception) {
        return R.string.error_followers_load;
    }
}

<code block>

package com.github.pockethub.ui.user;

import static com.github.pockethub.Intents.EXTRA_USER;
import android.os.Bundle;
import android.support.v4.content.Loader;
import android.view.View;
import android.widget.ListView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.pockethub.R;
import com.github.pockethub.ThrowableLoader;
import com.github.pockethub.accounts.AccountUtils;
import com.github.pockethub.ui.ItemListFragment;
import com.github.pockethub.util.AvatarLoader;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.service.OrganizationService;


public class MembersFragment extends ItemListFragment<User> {

    private User org;

    @Inject
    private OrganizationService service;

    @Inject
    private AvatarLoader avatars;

    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);

        if (org != null)
            outState.putSerializable(EXTRA_USER, org);
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        org = (User) getArguments().getSerializable("org");
        if (org == null && savedInstanceState != null)
            org = (User) savedInstanceState.getSerializable(EXTRA_USER);
        setEmptyText(R.string.no_members);

        super.onActivityCreated(savedInstanceState);
    }

    @Override
    public Loader<List<User>> onCreateLoader(int id, Bundle args) {
        return new ThrowableLoader<List<User>>(getActivity(), items) {

            @Override
            public List<User> loadData() throws Exception {
                return service.getMembers(org.getLogin());
            }
        };
    }

    @Override
    protected SingleTypeAdapter<User> createAdapter(List<User> items) {
        User[] users = items.toArray(new User[items.size()]);
        return new UserListAdapter(getActivity().getLayoutInflater(), users,
                avatars);
    }

    @Override
    public void onListItemClick(ListView l, View v, int position, long id) {
        User user = (User) l.getItemAtPosition(position);
        if (!AccountUtils.isUser(getActivity(), user))
            startActivity(UserViewActivity.createIntent(user));
    }

    @Override
    protected int getErrorMessage(Exception exception) {
        return R.string.error_members_load;
    }
}

<code block>

package com.github.pockethub.ui.user;

import static com.github.pockethub.Intents.EXTRA_USER;
import android.app.Activity;

import com.github.pockethub.core.ResourcePager;
import com.github.pockethub.core.user.UserPager;

import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.client.PageIterator;


public class UserFollowingFragment extends FollowingFragment {

    private User user;

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);

        user = getSerializableExtra(EXTRA_USER);
    }

    @Override
    protected ResourcePager<User> createPager() {
        return new UserPager() {

            @Override
            public PageIterator<User> createIterator(int page, int size) {
                return service.pageFollowing(user.getLogin(), page, size);
            }
        };
    }
}

<code block>

package com.github.pockethub.ui.user;

import android.text.TextUtils;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.ImageView;
import android.widget.TextView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.pockethub.R;
import com.github.pockethub.util.AvatarLoader;
import com.github.pockethub.util.TypefaceUtils;

import org.eclipse.egit.github.core.event.CreatePayload;
import org.eclipse.egit.github.core.event.Event;
import org.eclipse.egit.github.core.event.EventPayload;
import org.eclipse.egit.github.core.event.GistPayload;
import org.eclipse.egit.github.core.event.IssueCommentPayload;
import org.eclipse.egit.github.core.event.IssuesPayload;

import static org.eclipse.egit.github.core.event.Event.TYPE_COMMIT_COMMENT;
import static org.eclipse.egit.github.core.event.Event.TYPE_CREATE;
import static org.eclipse.egit.github.core.event.Event.TYPE_DELETE;
import static org.eclipse.egit.github.core.event.Event.TYPE_DOWNLOAD;
import static org.eclipse.egit.github.core.event.Event.TYPE_FOLLOW;
import static org.eclipse.egit.github.core.event.Event.TYPE_FORK;
import static org.eclipse.egit.github.core.event.Event.TYPE_FORK_APPLY;
import static org.eclipse.egit.github.core.event.Event.TYPE_GIST;
import static org.eclipse.egit.github.core.event.Event.TYPE_GOLLUM;
import static org.eclipse.egit.github.core.event.Event.TYPE_ISSUES;
import static org.eclipse.egit.github.core.event.Event.TYPE_ISSUE_COMMENT;
import static org.eclipse.egit.github.core.event.Event.TYPE_MEMBER;
import static org.eclipse.egit.github.core.event.Event.TYPE_PUBLIC;
import static org.eclipse.egit.github.core.event.Event.TYPE_PULL_REQUEST;
import static org.eclipse.egit.github.core.event.Event.TYPE_PULL_REQUEST_REVIEW_COMMENT;
import static org.eclipse.egit.github.core.event.Event.TYPE_PUSH;
import static org.eclipse.egit.github.core.event.Event.TYPE_TEAM_ADD;
import static org.eclipse.egit.github.core.event.Event.TYPE_WATCH;


public class NewsListAdapter extends SingleTypeAdapter<Event> {

    private final IconAndViewTextManager iconAndViewTextManager = new IconAndViewTextManager(this);


    public static boolean isValid(final Event event) {
        if (event == null)
            return false;

        final EventPayload payload = event.getPayload();
        if (payload == null || EventPayload.class.equals(payload.getClass()))
            return false;

        final String type = event.getType();
        if (TextUtils.isEmpty(type))
            return false;

        return TYPE_COMMIT_COMMENT.equals(type) 
                || (TYPE_CREATE.equals(type) 
                && ((CreatePayload) payload).getRefType() != null) 
                || TYPE_DELETE.equals(type) 
                || TYPE_DOWNLOAD.equals(type) 
                || TYPE_FOLLOW.equals(type) 
                || TYPE_FORK.equals(type) 
                || TYPE_FORK_APPLY.equals(type) 
                || (TYPE_GIST.equals(type) 
                && ((GistPayload) payload).getGist() != null) 
                || TYPE_GOLLUM.equals(type) 
                || (TYPE_ISSUE_COMMENT.equals(type) 
                && ((IssueCommentPayload) payload).getIssue() != null) 
                || (TYPE_ISSUES.equals(type) 
                && ((IssuesPayload) payload).getIssue() != null) 
                || TYPE_MEMBER.equals(type) 
                || TYPE_PUBLIC.equals(type) 
                || TYPE_PULL_REQUEST.equals(type) 
                || TYPE_PULL_REQUEST_REVIEW_COMMENT.equals(type) 
                || TYPE_PUSH.equals(type) 
                || TYPE_TEAM_ADD.equals(type) 
                || TYPE_WATCH.equals(type);
    }

    private final AvatarLoader avatars;


    public NewsListAdapter(LayoutInflater inflater, Event[] elements,
            AvatarLoader avatars) {
        super(inflater, R.layout.news_item);

        this.avatars = avatars;
        setItems(elements);
    }


    public NewsListAdapter(LayoutInflater inflater, AvatarLoader avatars) {
        this(inflater, null, avatars);
    }

    @Override
    public long getItemId(final int position) {
        final String id = getItem(position).getId();
        return !TextUtils.isEmpty(id) ? id.hashCode() : super
                .getItemId(position);
    }

    @Override
    protected int[] getChildViewIds() {
        return new int[] { R.id.iv_avatar, R.id.tv_event, R.id.tv_event_details,
                R.id.tv_event_icon, R.id.tv_event_date };
    }

    @Override
    protected View initialize(View view) {
        view = super.initialize(view);

        TypefaceUtils.setOcticons(textView(view, 3));
        return view;
    }

    @Override
    protected void update(int position, Event event) {

        iconAndViewTextManager.update(position, event);
    }

    public AvatarLoader getAvatars() {
        return avatars;
    }

    ImageView imageViewAgent(int childViewIndex) {
        return this.imageView(childViewIndex);
    }

    TextView setTextAgent(int childViewIndex, CharSequence text) {
        return this.setText(childViewIndex, text);
    }

    View setGoneAgent(int childViewIndex, boolean gone) {
        return this.setGone(childViewIndex, gone);
    }
}

<code block>

package com.github.pockethub.ui.user;

import com.github.pockethub.core.ResourcePager;

import org.eclipse.egit.github.core.client.PageIterator;
import org.eclipse.egit.github.core.event.Event;


public class UserReceivedNewsFragment extends UserNewsFragment {

    @Override
    protected ResourcePager<Event> createPager() {
        return new EventPager() {

            @Override
            public PageIterator<Event> createIterator(int page, int size) {
                return service.pageUserReceivedEvents(org.getLogin(), false,
                        page, size);
            }
        };
    }
}

<code block>

package com.github.pockethub.ui.user;

import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
import static android.content.Intent.FLAG_ACTIVITY_SINGLE_TOP;
import static com.github.pockethub.Intents.EXTRA_USER;
import static com.github.pockethub.util.TypefaceUtils.ICON_FOLLOW;
import static com.github.pockethub.util.TypefaceUtils.ICON_NEWS;
import static com.github.pockethub.util.TypefaceUtils.ICON_PUBLIC;
import static com.github.pockethub.util.TypefaceUtils.ICON_WATCH;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.ActionBar;
import android.text.TextUtils;
import android.view.Menu;
import android.view.MenuItem;
import android.widget.ProgressBar;

import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.pockethub.Intents.Builder;
import com.github.pockethub.R;
import com.github.pockethub.core.user.FollowUserTask;
import com.github.pockethub.core.user.FollowingUserTask;
import com.github.pockethub.core.user.RefreshUserTask;
import com.github.pockethub.core.user.UnfollowUserTask;
import com.github.pockethub.ui.MainActivity;
import com.github.pockethub.ui.TabPagerActivity;
import com.github.pockethub.util.AvatarLoader;
import com.github.pockethub.util.ToastUtils;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.User;


public class UserViewActivity extends TabPagerActivity<UserPagerAdapter>
    implements OrganizationSelectionProvider {


    public static Intent createIntent(User user) {
        return new Builder("user.VIEW").user(user).toIntent();
    }

    @Inject
    private AvatarLoader avatars;

    private User user;

    private ProgressBar loadingBar;

    private boolean isFollowing;

    private boolean followingStatusChecked;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        user = (User) getIntent().getSerializableExtra(EXTRA_USER);
        loadingBar = finder.find(R.id.pb_loading);

        ActionBar actionBar = getSupportActionBar();
        actionBar.setDisplayHomeAsUpEnabled(true);
        actionBar.setTitle(user.getLogin());

        if (!TextUtils.isEmpty(user.getAvatarUrl()))
            configurePager();
        else {
            ViewUtils.setGone(loadingBar, false);
            setGone(true);
            new RefreshUserTask(this, user.getLogin()) {

                @Override
                protected void onSuccess(User fullUser) throws Exception {
                    super.onSuccess(fullUser);

                    user = fullUser;
                    configurePager();
                }

                @Override
                protected void onException(Exception e) throws RuntimeException {
                    super.onException(e);

                    ToastUtils.show(UserViewActivity.this,
                        R.string.error_person_load);
                    ViewUtils.setGone(loadingBar, true);
                }
            }.execute();
        }
    }

    @Override
    public boolean onCreateOptionsMenu(Menu optionsMenu) {
        getMenuInflater().inflate(R.menu.user_follow, optionsMenu);

        return super.onCreateOptionsMenu(optionsMenu);
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        MenuItem followItem = menu.findItem(R.id.m_follow);

        followItem.setVisible(followingStatusChecked);
        followItem.setTitle(isFollowing ? R.string.unfollow : R.string.follow);

        return super.onPrepareOptionsMenu(menu);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.m_follow:
                followUser();
                return true;
            case android.R.id.home:
                Intent intent = new Intent(this, MainActivity.class);
                intent.addFlags(FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_SINGLE_TOP);
                startActivity(intent);
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }

    }

    private void configurePager() {
        avatars.bind(getSupportActionBar(), user);
        configureTabPager();
        ViewUtils.setGone(loadingBar, true);
        setGone(false);
        checkFollowingUserStatus();
    }

    @Override
    public User addListener(OrganizationSelectionListener listener) {
        return user;
    }

    @Override
    public OrganizationSelectionProvider removeListener(
        OrganizationSelectionListener listener) {
        return this;
    }

    @Override
    protected UserPagerAdapter createAdapter() {
        return new UserPagerAdapter(this);
    }

    @Override
    protected int getContentView() {
        return R.layout.tabbed_progress_pager;
    }

    @Override
    protected String getIcon(int position) {
        switch (position) {
            case 0:
                return ICON_NEWS;
            case 1:
                return ICON_PUBLIC;
            case 2:
                return ICON_WATCH;
            case 3:
                return ICON_FOLLOW;
            default:
                return super.getIcon(position);
        }
    }

    private void followUser() {
        if (isFollowing)
            new UnfollowUserTask(this, user.getLogin()) {

                @Override
                protected void onSuccess(User user) throws Exception {
                    super.onSuccess(user);

                    isFollowing = !isFollowing;
                }

                @Override
                protected void onException(Exception e) throws RuntimeException {
                    super.onException(e);

                    ToastUtils.show(UserViewActivity.this,
                        R.string.error_unfollowing_person);
                }
            }.start();
        else
            new FollowUserTask(this, user.getLogin()) {

                @Override
                protected void onSuccess(User user) throws Exception {
                    super.onSuccess(user);

                    isFollowing = !isFollowing;
                }

                @Override
                protected void onException(Exception e) throws RuntimeException {
                    super.onException(e);

                    ToastUtils.show(UserViewActivity.this,
                        R.string.error_following_person);
                }
            }.start();
    }

    private void checkFollowingUserStatus() {
        followingStatusChecked = false;
        new FollowingUserTask(this, user.getLogin()) {

            @Override
            protected void onSuccess(Boolean following) throws Exception {
                super.onSuccess(following);

                isFollowing = following;
                followingStatusChecked = true;
                invalidateOptionsMenu();
            }
        }.execute();
    }
}

<code block>

package com.github.pockethub.ui.user;

import com.github.pockethub.accounts.AccountUtils;
import com.github.pockethub.core.ResourcePager;

import org.eclipse.egit.github.core.client.PageIterator;
import org.eclipse.egit.github.core.event.Event;


public class OrganizationNewsFragment extends UserNewsFragment {

    @Override
    protected ResourcePager<Event> createPager() {
        return new EventPager() {

            @Override
            public PageIterator<Event> createIterator(int page, int size) {
                String account = AccountUtils.getLogin(getActivity());
                return service.pageUserOrgEvents(account, org.getLogin(), page,
                        size);
            }
        };
    }
}

<code block>

package com.github.pockethub.ui.user;

import static com.github.pockethub.Intents.EXTRA_USER;
import android.app.Activity;

import com.github.pockethub.core.ResourcePager;
import com.github.pockethub.core.user.UserPager;

import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.client.PageIterator;


public class UserFollowersFragment extends FollowersFragment {

    private User user;

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);

        user = getSerializableExtra(EXTRA_USER);
    }

    @Override
    protected ResourcePager<User> createPager() {
        return new UserPager() {

            @Override
            public PageIterator<User> createIterator(int page, int size) {
                return service.pageFollowers(user.getLogin(), page, size);
            }
        };
    }
}

<code block>

package com.github.pockethub.ui.user;

import com.github.pockethub.core.ResourcePager;

import org.eclipse.egit.github.core.client.PageIterator;
import org.eclipse.egit.github.core.event.Event;


public class UserCreatedNewsFragment extends UserNewsFragment {

    @Override
    protected ResourcePager<Event> createPager() {
        return new EventPager() {

            @Override
            public PageIterator<Event> createIterator(int page, int size) {
                return service
                        .pageUserEvents(org.getLogin(), false, page, size);
            }
        };
    }
}

<code block>

package com.github.pockethub.ui.user;

import com.github.pockethub.core.ResourcePager;
import com.github.pockethub.core.user.UserPager;

import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.client.PageIterator;


public class MyFollowersFragment extends FollowersFragment {

    @Override
    protected ResourcePager<User> createPager() {
        return new UserPager() {

            @Override
            public PageIterator<User> createIterator(int page, int size) {
                return service.pageFollowers(page, size);
            }
        };
    }
}
<code block>

package com.github.pockethub.ui.user;

import static com.github.pockethub.Intents.EXTRA_USER;
import android.os.Bundle;

import com.github.pockethub.core.user.UserEventMatcher.UserPair;
import com.github.pockethub.ui.NewsFragment;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;


public abstract class UserNewsFragment extends NewsFragment implements
    OrganizationSelectionListener {


    protected User org;

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);

        if (org != null)
            outState.putSerializable(EXTRA_USER, org);
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        if (getActivity() instanceof OrganizationSelectionProvider)
            org = ((OrganizationSelectionProvider) getActivity()).addListener(this);

        if (getArguments() != null && getArguments().containsKey("org"))
            org = (User) getArguments().getSerializable("org");

        if (org == null && savedInstanceState != null)
            org = (User) savedInstanceState.get(EXTRA_USER);

        super.onActivityCreated(savedInstanceState);
    }

    @Override
    public void onDetach() {
        if (getActivity() != null && getActivity() instanceof OrganizationSelectionProvider) {
            OrganizationSelectionProvider selectionProvider = (OrganizationSelectionProvider) getActivity();
            selectionProvider.removeListener(this);
        }

        super.onDetach();
    }

    @Override
    protected void viewRepository(Repository repository) {
        User owner = repository.getOwner();
        if (owner != null && org.getLogin().equals(owner.getLogin()))
            repository.setOwner(org);

        super.viewRepository(repository);
    }

    @Override
    public void onOrganizationSelected(User organization) {
        int previousOrgId = org != null ? org.getId() : -1;
        org = organization;

        if (previousOrgId != org.getId())
            refreshWithProgress();
    }

    @Override
    protected boolean viewUser(User user) {
        if (org.getId() != user.getId()) {
            startActivity(UserViewActivity.createIntent(user));
            return true;
        }
        return false;
    }

    @Override
    protected void viewUser(UserPair users) {
        if (!viewUser(users.from))
            viewUser(users.to);
    }
}

<code block>

package com.github.pockethub.ui.user;

import android.view.LayoutInflater;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.pockethub.R;
import com.github.pockethub.util.AvatarLoader;

import org.eclipse.egit.github.core.User;


public class UserListAdapter extends SingleTypeAdapter<User> {

    private final AvatarLoader avatars;


    public UserListAdapter(final LayoutInflater inflater,
            final User[] elements, final AvatarLoader avatars) {
        super(inflater, R.layout.user_item);

        this.avatars = avatars;
        setItems(elements);
    }

    @Override
    public long getItemId(final int position) {
        return getItem(position).getId();
    }

    @Override
    protected int[] getChildViewIds() {
        return new int[] { R.id.iv_avatar, R.id.tv_login };
    }

    @Override
    protected void update(final int position, final User user) {
        avatars.bind(imageView(0), user);
        setText(1, user.getLogin());
    }
}

<code block>

package com.github.pockethub.ui.user;

import android.os.Bundle;

import com.github.pockethub.R;



public abstract class FollowingFragment extends PagedUserFragment {

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        setEmptyText(R.string.no_people);
    }

    @Override
    protected int getLoadingMessage() {
        return R.string.loading_people;
    }

    @Override
    protected int getErrorMessage(Exception exception) {
        return R.string.error_people_load;
    }
}

<code block>

package com.github.pockethub.ui.user;

import org.eclipse.egit.github.core.User;


public interface OrganizationSelectionListener {


    void onOrganizationSelected(User organization);
}
<code block>
package com.github.pockethub.ui.user;

import com.github.pockethub.ui.StyledText;
import com.github.pockethub.util.TypefaceUtils;

import org.eclipse.egit.github.core.event.Event;
import org.eclipse.egit.github.core.event.IssuesPayload;

public enum EventType {
    CommitCommentEvent {
        @Override
        public String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details) {
            iconAndViewTextManager.formatCommitComment(event, main, details);
            return TypefaceUtils.ICON_COMMENT;
        }
    },
    CreateEvent {
        @Override
        public String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details) {
            iconAndViewTextManager.formatCreate(event, main, details);
            return TypefaceUtils.ICON_CREATE;
        }
    },
    DeleteEvent {
        @Override
        public String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details) {
            iconAndViewTextManager.formatDelete(event, main, details);
            return TypefaceUtils.ICON_DELETE;
        }
    },
    DownloadEvent {
        @Override
        public String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details) {
            iconAndViewTextManager.formatDownload(event, main, details);
            return TypefaceUtils.ICON_UPLOAD;
        }
    },
    FollowEvent {
        @Override
        public String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details) {
            iconAndViewTextManager.formatFollow(event, main, details);
            return TypefaceUtils.ICON_FOLLOW;
        }
    },
    ForkEvent {
        @Override
        public String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details) {
            iconAndViewTextManager.formatFork(event, main, details);
            return TypefaceUtils.ICON_FORK;
        }
    },
    GistEvent {
        @Override
        public String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details) {
            iconAndViewTextManager.formatGist(event, main, details);
            return TypefaceUtils.ICON_GIST;
        }
    },
    GollumEvent {
        @Override
        public String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details) {
            iconAndViewTextManager.formatWiki(event, main, details);
            return TypefaceUtils.ICON_WIKI;
        }
    },
    IssueCommentEvent {
        @Override
        public String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details) {
            iconAndViewTextManager.formatIssueComment(event, main, details);
            return TypefaceUtils.ICON_ISSUE_COMMENT;
        }
    },
    IssuesEvent {
        @Override
        public String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details) {
            iconAndViewTextManager.formatIssues(event, main, details);
            String action = ((IssuesPayload) event.getPayload()).getAction();
            String icon = null;
            if (IconAndViewTextManager.ISSUES_PAYLOAD_ACTION_OPENED.equals(action))
                icon = TypefaceUtils.ICON_ISSUE_OPEN;
            else if (IconAndViewTextManager.ISSUES_PAYLOAD_ACTION_REOPENED.equals(action))
                icon = TypefaceUtils.ICON_ISSUE_REOPEN;
            else if (IconAndViewTextManager.ISSUES_PAYLOAD_ACTION_CLOSED.equals(action))
                icon = TypefaceUtils.ICON_ISSUE_CLOSE;
            return icon;
        }
    },
    MemberEvent {
        @Override
        public String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details) {
            iconAndViewTextManager.formatAddMember(event, main, details);
            return TypefaceUtils.ICON_ADD_MEMBER;
        }
    },
    PublicEvent {
        @Override
        public String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details) {
            iconAndViewTextManager.formatPublic(event, main, details);
            return null;
        }
    },
    PullRequestEvent {
        @Override
        public String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details) {
            iconAndViewTextManager.formatPullRequest(event, main, details);
            return TypefaceUtils.ICON_PULL_REQUEST;
        }
    },
    PullRequestReviewCommentEvent {
        @Override
        public String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details) {
            iconAndViewTextManager.formatReviewComment(event, main, details);
            return TypefaceUtils.ICON_COMMENT;
        }
    },
    PushEvent {
        @Override
        public String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details) {
            iconAndViewTextManager.formatPush(event, main, details);
            return TypefaceUtils.ICON_PUSH;
        }
    },
    TeamAddEvent {
        @Override
        public String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details) {
            iconAndViewTextManager.formatTeamAdd(event, main, details);
            return TypefaceUtils.ICON_ADD_MEMBER;
        }
    },
    WatchEvent {
        @Override
        public String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details) {
            iconAndViewTextManager.formatWatch(event, main, details);
            return TypefaceUtils.ICON_STAR;
        }
    },
    ;

    public abstract String generateIconAndFormatStyledText(IconAndViewTextManager iconAndViewTextManager, Event event, StyledText main, StyledText details);
}

<code block>

package com.github.pockethub.ui.user;

import com.github.pockethub.core.ResourcePager;
import com.github.pockethub.core.user.UserPager;

import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.client.PageIterator;


public class MyFollowingFragment extends FollowingFragment {

    @Override
    protected ResourcePager<User> createPager() {
        return new UserPager() {

            @Override
            public PageIterator<User> createIterator(int page, int size) {
                return service.pageFollowing(page, size);
            }
        };
    }
}

<code block>

package com.github.pockethub.ui.user;

import android.content.res.Resources;
import android.support.v4.app.Fragment;
import android.support.v7.app.ActionBarActivity;

import com.github.pockethub.R;
import com.github.pockethub.ui.FragmentPagerAdapter;
import com.github.pockethub.ui.repo.UserRepositoryListFragment;


public class UserPagerAdapter extends FragmentPagerAdapter {

    private final Resources resources;


    public UserPagerAdapter(final ActionBarActivity activity) {
        super(activity);

        resources = activity.getResources();
    }

    @Override
    public Fragment getItem(final int position) {
        switch (position) {
        case 0:
            return new UserCreatedNewsFragment();
        case 1:
            return new UserRepositoryListFragment();
        case 2:
            return new UserFollowersFragment();
        case 3:
            return new UserFollowingFragment();
        default:
            return null;
        }
    }

    @Override
    public int getCount() {
        return 4;
    }

    @Override
    public CharSequence getPageTitle(int position) {
        switch (position) {
        case 0:
            return resources.getString(R.string.tab_news);
        case 1:
            return resources.getString(R.string.tab_repositories);
        case 2:
            return resources.getString(R.string.tab_followers);
        case 3:
            return resources.getString(R.string.tab_following);
        default:
            return null;
        }
    }
}

<code block>

package com.github.pockethub.ui.user;

import android.content.res.Resources;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.view.ViewGroup;

import com.github.pockethub.R;
import com.github.pockethub.ui.FragmentPagerAdapter;
import com.github.pockethub.ui.repo.RepositoryListFragment;

import java.util.HashSet;
import java.util.Set;

import org.eclipse.egit.github.core.User;


public class HomePagerAdapter extends FragmentPagerAdapter {

    private final User org;

    private boolean defaultUser;

    private final FragmentManager fragmentManager;

    private final Resources resources;

    private final Set<String> tags = new HashSet<>();


    public HomePagerAdapter(final Fragment fragment,
        final boolean defaultUser, final User org) {
        super(fragment);

        this.org = org;
        fragmentManager = fragment.getChildFragmentManager();
        resources = fragment.getResources();
        this.defaultUser = defaultUser;
    }

    @Override
    public Fragment getItem(int position) {
        Fragment fragment = null;
        switch (position) {
            case 0:
                fragment = defaultUser ? new UserReceivedNewsFragment()
                    : new OrganizationNewsFragment();
                break;
            case 1:
                fragment = new RepositoryListFragment();
                break;
            case 2:
                fragment = defaultUser ? new MyFollowersFragment()
                    : new MembersFragment();
                break;
            case 3:
                fragment = new MyFollowingFragment();
                break;
        }

        if (fragment != null) {
            Bundle args = new Bundle();
            args.putSerializable("org", org);
            fragment.setArguments(args);
        }
        return fragment;
    }

    @Override
    public int getItemPosition(Object object) {
        return POSITION_NONE;
    }

    public Object instantiateItem(ViewGroup container, int position) {
        Object fragment = super.instantiateItem(container, position);
        if (fragment instanceof Fragment)
            tags.add(((Fragment) fragment).getTag());
        return fragment;
    }

    @Override
    public int getCount() {
        return defaultUser ? 4 : 3;
    }

    @Override
    public CharSequence getPageTitle(int position) {
        switch (position) {
            case 0:
                return resources.getString(R.string.tab_news);
            case 1:
                return resources.getString(R.string.tab_repositories);
            case 2:
                return resources.getString(defaultUser ? R.string.tab_followers_self
                    : R.string.tab_members);
            case 3:
                return resources.getString(R.string.tab_following_self);
            default:
                return null;
        }
    }
}

<code block>

package com.github.pockethub.ui.user;

import static android.content.DialogInterface.BUTTON_POSITIVE;
import static android.content.Intent.ACTION_VIEW;
import static android.content.Intent.CATEGORY_BROWSABLE;
import static org.eclipse.egit.github.core.client.IGitHubConstants.HOST_DEFAULT;
import static org.eclipse.egit.github.core.client.IGitHubConstants.HOST_GISTS;
import static org.eclipse.egit.github.core.client.IGitHubConstants.PROTOCOL_HTTPS;
import android.app.Activity;
import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnCancelListener;
import android.content.DialogInterface.OnClickListener;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.text.TextUtils;

import com.github.pockethub.R;
import com.github.pockethub.core.commit.CommitMatch;
import com.github.pockethub.core.commit.CommitUriMatcher;
import com.github.pockethub.core.gist.GistUriMatcher;
import com.github.pockethub.core.issue.IssueUriMatcher;
import com.github.pockethub.core.repo.RepositoryUriMatcher;
import com.github.pockethub.core.user.UserUriMatcher;
import com.github.pockethub.ui.LightAlertDialog;
import com.github.pockethub.ui.commit.CommitViewActivity;
import com.github.pockethub.ui.gist.GistsViewActivity;
import com.github.pockethub.ui.issue.IssuesViewActivity;
import com.github.pockethub.ui.repo.RepositoryViewActivity;

import java.net.URI;
import java.text.MessageFormat;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.RepositoryIssue;
import org.eclipse.egit.github.core.User;


public class UriLauncherActivity extends Activity {

    static public void launchUri(Context context, Uri data) {
        Intent intent = getIntentForURI(data);
        if (intent != null) {
            context.startActivity(intent);
        } else {
            context.startActivity(new Intent(ACTION_VIEW, data).addCategory(CATEGORY_BROWSABLE));
        }
    }


    static public Intent convert(final Intent intent) {
        if (intent == null)
            return null;

        if (!ACTION_VIEW.equals(intent.getAction()))
            return null;

        Uri data = intent.getData();
        if (data == null)
            return null;

        if (TextUtils.isEmpty(data.getHost()) || TextUtils.isEmpty(data.getScheme())) {
            String host = data.getHost();
            if (TextUtils.isEmpty(host))
                host = HOST_DEFAULT;
            String scheme = data.getScheme();
            if (TextUtils.isEmpty(scheme))
                scheme = PROTOCOL_HTTPS;
            String prefix = scheme + "://" + host;

            String path = data.getPath();
            if (!TextUtils.isEmpty(path))
                if (path.charAt(0) == '/')
                    data = Uri.parse(prefix + path);
                else
                    data = Uri.parse(prefix + '/' + path);
            else
                data = Uri.parse(prefix);
            intent.setData(data);
        }

        return getIntentForURI(data);
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        final Intent intent = getIntent();
        final Uri data = intent.getData();

        final Intent newIntent = getIntentForURI(data);
        if (newIntent != null) {
            startActivity(newIntent);
            finish();
            return;
        }

        if (!intent.hasCategory(CATEGORY_BROWSABLE)) {
            startActivity(new Intent(ACTION_VIEW, data).addCategory(CATEGORY_BROWSABLE));
            finish();
        } else {
            showParseError(data.toString());
        }
    }

    static private Intent getIntentForURI(Uri data) {
        if (HOST_GISTS.equals(data.getHost())) {
            Gist gist = GistUriMatcher.getGist(data);
            if (gist != null) {
                return GistsViewActivity.createIntent(gist);
            }
        } else if (HOST_DEFAULT.equals(data.getHost())) {
            CommitMatch commit = CommitUriMatcher.getCommit(data);
            if (commit != null) {
                return CommitViewActivity.createIntent(commit.repository, commit.commit);
            }

            RepositoryIssue issue = IssueUriMatcher.getIssue(data);
            if (issue != null) {
                return IssuesViewActivity.createIntent(issue, issue.getRepository());
            }

            Repository repository = RepositoryUriMatcher.getRepository(data);
            if (repository != null) {
                return RepositoryViewActivity.createIntent(repository);
            }

            User user = UserUriMatcher.getUser(data);
            if (user != null) {
                return UserViewActivity.createIntent(user);
            }
        }

        return null;
    }

    private void showParseError(String url) {
        AlertDialog dialog = LightAlertDialog.create(this);
        dialog.setTitle(R.string.title_invalid_github_url);
        dialog.setMessage(MessageFormat.format(getString(R.string.message_invalid_github_url), url));
        dialog.setOnCancelListener(new OnCancelListener() {

            @Override
            public void onCancel(DialogInterface dialog) {
                finish();
            }
        });
        dialog.setButton(BUTTON_POSITIVE, getString(android.R.string.ok),
                new OnClickListener() {

                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        finish();
                    }
                });
        dialog.show();
    }
}

<code block>

package com.github.pockethub.ui.user;

import com.github.pockethub.core.ResourcePager;

import org.eclipse.egit.github.core.event.Event;


public abstract class EventPager extends ResourcePager<Event> {

    @Override
    protected Object getId(Event resource) {
        return resource.getId();
    }

    @Override
    protected Event register(Event resource) {
        return NewsListAdapter.isValid(resource) ? resource : null;
    }
}

<code block>
package com.github.pockethub.ui.user;

import android.content.Context;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.support.annotation.Nullable;
import android.view.View;

import com.github.pockethub.accounts.AccountUtils;
import com.github.pockethub.ui.TabPagerFragment;
import com.github.pockethub.util.PreferenceUtils;

import org.eclipse.egit.github.core.User;

public class HomePagerFragment extends TabPagerFragment<HomePagerAdapter> {

    private static final String TAG = "HomePagerFragment";

    private static final String PREF_ORG_ID = "orgId";

    private SharedPreferences sharedPreferences;

    private boolean isDefaultUser;

    private User org;

    @Override
    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        sharedPreferences = getActivity().getPreferences(Context.MODE_PRIVATE);
        setOrg((User) getArguments().getSerializable("org"));
    }

    private void setOrg(User org) {
        PreferenceUtils.save(sharedPreferences.edit().putInt(PREF_ORG_ID,
            org.getId()));
        this.org = org;
        this.isDefaultUser = AccountUtils.isUser(getActivity(), org);
        configureTabPager();
    }

    @Override
    protected HomePagerAdapter createAdapter() {
        return new HomePagerAdapter(this, isDefaultUser, org);
    }
}

<code block>

package com.github.pockethub.ui.issue;

import static com.github.pockethub.RequestCodes.ISSUE_VIEW;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.widget.ListView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.pockethub.R;
import com.github.pockethub.core.ResourcePager;
import com.github.pockethub.core.issue.IssueStore;
import com.github.pockethub.ui.PagedItemFragment;
import com.github.pockethub.util.AvatarLoader;
import com.google.inject.Inject;

import java.util.List;
import java.util.Map;

import org.eclipse.egit.github.core.RepositoryIssue;
import org.eclipse.egit.github.core.client.PageIterator;
import org.eclipse.egit.github.core.service.IssueService;


public class DashboardIssueFragment extends PagedItemFragment<RepositoryIssue> {


    public static final String ARG_FILTER = "filter";

    @Inject
    private IssueService service;

    @Inject
    private IssueStore store;

    @Inject
    private AvatarLoader avatars;

    private Map<String, String> filterData;

    @SuppressWarnings("unchecked")
    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        filterData = (Map<String, String>) getArguments().getSerializable(
                ARG_FILTER);
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (requestCode == ISSUE_VIEW) {
            notifyDataSetChanged();
            forceRefresh();
            return;
        }

        super.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    public void onListItemClick(ListView l, View v, int position, long id) {
        startActivityForResult(
                IssuesViewActivity.createIntent(items, position
                        - getListAdapter().getHeadersCount()), ISSUE_VIEW);
    }

    @Override
    protected ResourcePager<RepositoryIssue> createPager() {
        return new ResourcePager<RepositoryIssue>() {

            @Override
            protected RepositoryIssue register(RepositoryIssue resource) {
                return store.addIssue(resource);
            }

            @Override
            protected Object getId(RepositoryIssue resource) {
                return resource.getId();
            }

            @Override
            public PageIterator<RepositoryIssue> createIterator(int page,
                    int size) {
                return service.pageIssues(filterData, page, size);
            }
        };
    }

    @Override
    protected int getLoadingMessage() {
        return R.string.loading_issues;
    }

    @Override
    protected int getErrorMessage(Exception exception) {
        return R.string.error_issues_load;
    }

    @Override
    protected SingleTypeAdapter<RepositoryIssue> createAdapter(
            List<RepositoryIssue> items) {
        return new DashboardIssueListAdapter(avatars, getActivity()
                .getLayoutInflater(), items.toArray(new RepositoryIssue[items
                .size()]));
    }
}

<code block>

package com.github.pockethub.ui.issue;

import android.accounts.Account;
import android.app.Activity;
import android.content.Context;
import android.util.Log;

import com.github.pockethub.R;
import com.github.pockethub.ui.ProgressDialogTask;
import com.github.pockethub.util.ToastUtils;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.service.IssueService;


public class DeleteCommentTask extends ProgressDialogTask<Comment> {

    private static final String TAG = "DeleteCommentTask";

    private final IRepositoryIdProvider repository;

    private final Comment comment;

    @Inject
    private IssueService service;


    public DeleteCommentTask(final Context context,
            final IRepositoryIdProvider repository,
            final Comment comment) {
        super(context);

        this.repository = repository;
        this.comment = comment;
    }

    @Override
    protected Comment run(Account account) throws Exception {
        service.deleteComment(repository, comment.getId());
        return comment;
    }


    public DeleteCommentTask start() {
        showIndeterminate(R.string.deleting_comment);

        execute();
        return this;
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception deleting comment on issue", e);

        ToastUtils.show((Activity) getContext(), e.getMessage());
    }
}

<code block>

package com.github.pockethub.ui.issue;

import static java.lang.String.CASE_INSENSITIVE_ORDER;
import static org.eclipse.egit.github.core.service.IssueService.STATE_CLOSED;
import static org.eclipse.egit.github.core.service.IssueService.STATE_OPEN;
import android.accounts.Account;
import android.util.Log;

import com.github.pockethub.R;
import com.github.pockethub.ui.DialogFragmentActivity;
import com.github.pockethub.ui.ProgressDialogTask;
import com.github.pockethub.util.ToastUtils;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.Milestone;
import org.eclipse.egit.github.core.service.MilestoneService;


public class MilestoneDialog {

    private static final String TAG = "MilestoneDialog";

    private MilestoneService service;

    private ArrayList<Milestone> repositoryMilestones;

    private final int requestCode;

    private final DialogFragmentActivity activity;

    private final IRepositoryIdProvider repository;


    public MilestoneDialog(final DialogFragmentActivity activity,
            final int requestCode, final IRepositoryIdProvider repository,
            final MilestoneService service) {
        this.activity = activity;
        this.requestCode = requestCode;
        this.repository = repository;
        this.service = service;
    }


    public List<Milestone> getMilestones() {
        return repositoryMilestones;
    }

    private void load(final Milestone selectedMilestone) {
        new ProgressDialogTask<ArrayList<Milestone>>(activity) {

            @Override
            public ArrayList<Milestone> run(Account account) throws Exception {
                ArrayList<Milestone> milestones = new ArrayList<>();
                milestones
                        .addAll(service.getMilestones(repository, STATE_OPEN));
                milestones.addAll(service.getMilestones(repository,
                        STATE_CLOSED));
                Collections.sort(milestones, new Comparator<Milestone>() {

                    public int compare(Milestone m1, Milestone m2) {
                        return CASE_INSENSITIVE_ORDER.compare(m1.getTitle(),
                                m2.getTitle());
                    }
                });
                return milestones;
            }

            @Override
            protected void onSuccess(ArrayList<Milestone> all) throws Exception {
                super.onSuccess(all);

                repositoryMilestones = all;
                show(selectedMilestone);
            }

            @Override
            protected void onException(Exception e) throws RuntimeException {
                super.onException(e);

                Log.d(TAG, "Exception loading milestones", e);
                ToastUtils.show(activity, e, R.string.error_milestones_load);
            }

            @Override
            public void execute() {
                showIndeterminate(R.string.loading_milestones);

                super.execute();
            }
        }.execute();
    }


    public void show(Milestone selectedMilestone) {
        if (repositoryMilestones == null) {
            load(selectedMilestone);
            return;
        }

        int checked = -1;
        if (selectedMilestone != null)
            for (int i = 0; i < repositoryMilestones.size(); i++)
                if (selectedMilestone.getNumber() == repositoryMilestones
                        .get(i).getNumber()) {
                    checked = i;
                    break;
                }
        MilestoneDialogFragment.show(activity, requestCode,
                activity.getString(R.string.select_milestone), null,
                repositoryMilestones, checked);
    }


    public int getMilestoneNumber(String title) {
        if (repositoryMilestones == null)
            return -1;
        for (Milestone milestone : repositoryMilestones)
            if (title.equals(milestone.getTitle()))
                return milestone.getNumber();
        return -1;
    }
}

<code block>

package com.github.pockethub.ui.issue;

import static com.github.pockethub.RequestCodes.ISSUE_LABELS_UPDATE;
import android.accounts.Account;

import com.github.pockethub.R;
import com.github.pockethub.core.issue.IssueStore;
import com.github.pockethub.ui.DialogFragmentActivity;
import com.github.pockethub.ui.ProgressDialogTask;
import com.google.inject.Inject;

import java.util.Arrays;
import java.util.List;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.Label;
import org.eclipse.egit.github.core.service.LabelService;


public class EditLabelsTask extends ProgressDialogTask<Issue> {

    @Inject
    private IssueStore store;

    @Inject
    private LabelService service;

    private final LabelsDialog labelsDialog;

    private final IRepositoryIdProvider repositoryId;

    private final int issueNumber;

    private Label[] labels;


    public EditLabelsTask(final DialogFragmentActivity activity,
            final IRepositoryIdProvider repositoryId, final int issueNumber) {
        super(activity);

        this.repositoryId = repositoryId;
        this.issueNumber = issueNumber;
        labelsDialog = new LabelsDialog(activity, ISSUE_LABELS_UPDATE,
                repositoryId, service);
    }


    public EditLabelsTask prompt(List<Label> labels) {
        labelsDialog.show(labels);
        return this;
    }


    public EditLabelsTask edit(Label[] labels) {
        showIndeterminate(R.string.updating_labels);

        this.labels = labels;

        execute();
        return this;
    }

    @Override
    public Issue run(Account account) throws Exception {
        Issue editedIssue = new Issue();
        editedIssue.setNumber(issueNumber);
        if (labels != null && labels.length > 0)
            editedIssue.setLabels(Arrays.asList(labels));
        return store.editIssue(repositoryId, editedIssue);
    }
}

<code block>

package com.github.pockethub.ui.issue;

import android.view.LayoutInflater;
import android.widget.TextView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.pockethub.R;
import com.github.pockethub.core.issue.IssueFilter;
import com.github.pockethub.util.AvatarLoader;

import java.util.Collection;

import org.eclipse.egit.github.core.Label;
import org.eclipse.egit.github.core.Milestone;
import org.eclipse.egit.github.core.User;


public class FilterListAdapter extends SingleTypeAdapter<IssueFilter> {

    private final AvatarLoader avatars;


    public FilterListAdapter(LayoutInflater inflater, IssueFilter[] elements,
            AvatarLoader avatars) {
        super(inflater, R.layout.issues_filter_item);

        this.avatars = avatars;
        setItems(elements);
    }

    @Override
    protected int[] getChildViewIds() {
        return new int[] { R.id.iv_avatar, R.id.tv_repo_name, R.id.tv_filter_state,
                R.id.tv_filter_labels, R.id.tv_filter_milestone, R.id.ll_assignee,
                R.id.tv_filter_assignee, R.id.iv_assignee_avatar };
    }

    @Override
    protected void update(int position, IssueFilter filter) {
        avatars.bind(imageView(0), filter.getRepository().getOwner());
        setText(1, filter.getRepository().generateId());
        if (filter.isOpen())
            setText(2, R.string.open_issues);
        else
            setText(2, R.string.closed_issues);

        Collection<Label> labels = filter.getLabels();
        if (labels != null && !labels.isEmpty()) {
            TextView labelsText = textView(3);
            LabelDrawableSpan.setText(labelsText, labels);
            ViewUtils.setGone(labelsText, false);
        } else
            setGone(3, true);

        Milestone milestone = filter.getMilestone();
        if (milestone != null)
            ViewUtils.setGone(setText(4, milestone.getTitle()), false);
        else
            setGone(4, true);

        User assignee = filter.getAssignee();
        if (assignee != null) {
            avatars.bind(imageView(7), assignee);
            ViewUtils.setGone(setText(6, assignee.getLogin()), false);
        } else
            setGone(5, true);
    }
}

<code block>

package com.github.pockethub.ui.issue;

import static com.github.pockethub.Intents.EXTRA_ISSUE_NUMBER;
import static com.github.pockethub.Intents.EXTRA_REPOSITORY_NAME;
import static com.github.pockethub.Intents.EXTRA_REPOSITORY_OWNER;
import static com.github.pockethub.Intents.EXTRA_USER;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.ActionBar;

import com.github.pockethub.Intents.Builder;
import com.github.pockethub.R;
import com.github.pockethub.ui.comment.CommentPreviewPagerAdapter;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.RepositoryId;
import org.eclipse.egit.github.core.User;


public class CreateCommentActivity extends
        com.github.pockethub.ui.comment.CreateCommentActivity {


    public static Intent createIntent(RepositoryId repoId, int issueNumber,
            User user) {
        Builder builder = new Builder("issue.comment.create.VIEW");
        builder.repo(repoId);
        builder.add(EXTRA_ISSUE_NUMBER, issueNumber);
        builder.add(EXTRA_USER, user);
        return builder.toIntent();
    }

    private RepositoryId repositoryId;

    private int issueNumber;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        issueNumber = getIntExtra(EXTRA_ISSUE_NUMBER);
        repositoryId = new RepositoryId(getStringExtra(EXTRA_REPOSITORY_OWNER),
                getStringExtra(EXTRA_REPOSITORY_NAME));

        super.onCreate(savedInstanceState);

        ActionBar actionBar = getSupportActionBar();
        actionBar.setTitle(getString(R.string.issue_title) + issueNumber);
        actionBar.setSubtitle(repositoryId.generateId());
        avatars.bind(actionBar, (User) getSerializableExtra(EXTRA_USER));
    }

    @Override
    protected void createComment(String comment) {
        new CreateCommentTask(this, repositoryId, issueNumber, comment) {

            @Override
            protected void onSuccess(Comment comment) throws Exception {
                super.onSuccess(comment);

                finish(comment);
            }
        }.start();
    }

    @Override
    protected CommentPreviewPagerAdapter createAdapter() {
        return new CommentPreviewPagerAdapter(this, repositoryId);
    }
}

<code block>

package com.github.pockethub.ui.issue;

import static android.graphics.Paint.STRIKE_THRU_TEXT_FLAG;
import static org.eclipse.egit.github.core.service.IssueService.STATE_CLOSED;
import android.graphics.Color;
import android.text.TextUtils;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.TextView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.pockethub.R;
import com.github.pockethub.ui.StyledText;
import com.github.pockethub.util.AvatarLoader;
import com.github.pockethub.util.TypefaceUtils;

import java.util.Date;
import java.util.List;

import org.eclipse.egit.github.core.Label;


public abstract class IssueListAdapter<V> extends SingleTypeAdapter<V> {


    protected static final int MAX_LABELS = 8;


    protected final AvatarLoader avatars;


    private final TextView numberView;


    private int numberWidth;


    public IssueListAdapter(int viewId, LayoutInflater inflater,
            Object[] elements, AvatarLoader avatars) {
        super(inflater, viewId);

        this.avatars = avatars;
        numberView = (TextView) inflater.inflate(viewId, null).findViewById(
                R.id.tv_issue_number);
        setItems(elements);
    }


    protected abstract int getNumber(V issue);

    @SuppressWarnings("unchecked")
    private void computeNumberWidth(final Object[] items) {
        int[] numbers = new int[items.length];
        for (int i = 0; i < numbers.length; i++)
            numbers[i] = getNumber((V) items[i]);
        int digits = Math.max(TypefaceUtils.getMaxDigits(numbers), 4);
        numberWidth = TypefaceUtils.getWidth(numberView, digits)
                + numberView.getPaddingLeft() + numberView.getPaddingRight();
    }

    @Override
    public void setItems(final Object[] items) {
        super.setItems(items);

        computeNumberWidth(items);
    }


    protected void updateNumber(int number, String state, int flags,
            int viewIndex) {
        TextView view = textView(viewIndex);
        view.setText(Integer.toString(number));
        if (STATE_CLOSED.equals(state))
            view.setPaintFlags(flags | STRIKE_THRU_TEXT_FLAG);
        else
            view.setPaintFlags(flags);
        view.getLayoutParams().width = numberWidth;
    }


    protected void updateReporter(String reporter, Date date, int viewIndex) {
        StyledText reporterText = new StyledText();
        reporterText.bold(reporter);
        reporterText.append(' ');
        reporterText.append(date);
        setText(viewIndex, reporterText);
    }


    protected void updateLabels(final List<Label> labels, final int viewIndex) {
        if (labels != null && !labels.isEmpty()) {
            int size = Math.min(labels.size(), MAX_LABELS);
            for (int i = 0; i < size; i++) {
                String color = labels.get(i).getColor();
                if (!TextUtils.isEmpty(color)) {
                    View view = view(viewIndex + i);
                    view.setBackgroundColor(Color.parseColor('#' + color));
                    ViewUtils.setGone(view, false);
                } else
                    setGone(viewIndex + i, true);
            }
            for (int i = size; i < MAX_LABELS; i++)
                setGone(viewIndex + i, true);
        } else
            for (int i = 0; i < MAX_LABELS; i++)
                setGone(viewIndex + i, true);
    }
}

<code block>

package com.github.pockethub.ui.issue;

import android.view.LayoutInflater;
import android.view.View;
import android.widget.TextView;

import com.github.pockethub.R;
import com.github.pockethub.core.issue.IssueUtils;
import com.github.pockethub.util.AvatarLoader;
import com.github.pockethub.util.TypefaceUtils;

import org.eclipse.egit.github.core.RepositoryIssue;


public class DashboardIssueListAdapter extends
        IssueListAdapter<RepositoryIssue> {

    private int numberPaintFlags;


    public DashboardIssueListAdapter(AvatarLoader avatars,
            LayoutInflater inflater, RepositoryIssue[] elements) {
        super(R.layout.dashboard_issue_item, inflater, elements, avatars);
    }

    @Override
    public long getItemId(final int position) {
        return getItem(position).getId();
    }

    @Override
    protected int getNumber(final RepositoryIssue issue) {
        return issue.getNumber();
    }

    @Override
    protected View initialize(View view) {
        view = super.initialize(view);

        numberPaintFlags = textView(view, 1).getPaintFlags();
        TypefaceUtils.setOcticons(textView(view, 6),
                (TextView) view.findViewById(R.id.tv_comment_icon));
        return view;
    }

    @Override
    protected int[] getChildViewIds() {
        return new int[] { R.id.tv_issue_repo_name, R.id.tv_issue_number,
                R.id.tv_issue_title, R.id.iv_avatar, R.id.tv_issue_creation,
                R.id.tv_issue_comments, R.id.tv_pull_request_icon, R.id.v_label0,
                R.id.v_label1, R.id.v_label2, R.id.v_label3, R.id.v_label4,
                R.id.v_label5, R.id.v_label6, R.id.v_label7 };
    }

    @Override
    protected void update(int position, RepositoryIssue issue) {
        updateNumber(issue.getNumber(), issue.getState(), numberPaintFlags, 1);

        avatars.bind(imageView(3), issue.getUser());

        String[] segments = issue.getUrl().split("/");
        int length = segments.length;
        if (length >= 4)
            setText(0, segments[length - 4] + '/' + segments[length - 3]);
        else
            setText(0, null);

        setGone(6, !IssueUtils.isPullRequest(issue));

        setText(2, issue.getTitle());

        updateReporter(issue.getUser().getLogin(), issue.getCreatedAt(), 4);
        setNumber(5, issue.getComments());
        updateLabels(issue.getLabels(), 7);
    }
}

<code block>

package com.github.pockethub.ui.issue;

import static android.app.Activity.RESULT_OK;
import static android.content.DialogInterface.BUTTON_NEGATIVE;
import static android.content.DialogInterface.BUTTON_NEUTRAL;
import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.DialogInterface;
import android.os.Bundle;
import android.text.TextUtils;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ListView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.pockethub.R;
import com.github.pockethub.ui.DialogFragmentActivity;
import com.github.pockethub.ui.SingleChoiceDialogFragment;

import java.util.ArrayList;

import org.eclipse.egit.github.core.Milestone;


public class MilestoneDialogFragment extends SingleChoiceDialogFragment {

    private static class MilestoneListAdapter extends
            SingleTypeAdapter<Milestone> {

        private final int selected;

        public MilestoneListAdapter(LayoutInflater inflater,
                Milestone[] milestones, int selected) {
            super(inflater, R.layout.milestone_item);

            this.selected = selected;
            setItems(milestones);
        }

        @Override
        protected int[] getChildViewIds() {
            return new int[] { R.id.rb_selected, R.id.tv_milestone_title,
                    R.id.tv_milestone_description };
        }

        @Override
        protected void update(int position, Milestone item) {
            setText(1, item.getTitle());

            String description = item.getDescription();
            if (!TextUtils.isEmpty(description))
                ViewUtils.setGone(setText(2, description), false);
            else
                setGone(2, true);

            setChecked(0, selected == position);
        }

        @Override
        public long getItemId(int position) {
            return getItem(position).getNumber();
        }
    }


    public static Milestone getSelected(Bundle arguments) {
        return (Milestone) arguments.getSerializable(ARG_SELECTED);
    }


    public static void show(final DialogFragmentActivity activity,
            final int requestCode, final String title, final String message,
            ArrayList<Milestone> choices, final int selectedChoice) {
        show(activity, requestCode, title, message, choices, selectedChoice,
                new MilestoneDialogFragment());
    }

    @Override
    public Dialog onCreateDialog(final Bundle savedInstanceState) {
        Activity activity = getActivity();
        Bundle arguments = getArguments();

        final AlertDialog dialog = createDialog();
        dialog.setButton(BUTTON_NEGATIVE, activity.getString(R.string.cancel),
                this);
        dialog.setButton(BUTTON_NEUTRAL, activity.getString(R.string.clear), this);

        LayoutInflater inflater = activity.getLayoutInflater();

        ListView view = (ListView) inflater.inflate(R.layout.dialog_list_view,
                null);
        view.setOnItemClickListener(new OnItemClickListener() {

            @Override
            public void onItemClick(AdapterView<?> parent, View view,
                    int position, long id) {
                onClick(dialog, position);
            }
        });

        ArrayList<Milestone> choices = getChoices();
        int selected = arguments.getInt(ARG_SELECTED_CHOICE);
        MilestoneListAdapter adapter = new MilestoneListAdapter(inflater,
                choices.toArray(new Milestone[choices.size()]), selected);
        view.setAdapter(adapter);
        if (selected >= 0)
            view.setSelection(selected);
        dialog.setView(view);

        return dialog;
    }

    @SuppressWarnings("unchecked")
    private ArrayList<Milestone> getChoices() {
        return (ArrayList<Milestone>) getArguments().getSerializable(
                ARG_CHOICES);
    }

    @Override
    public void onClick(DialogInterface dialog, int which) {
        super.onClick(dialog, which);

        switch (which) {
        case BUTTON_NEGATIVE:
            break;
        case BUTTON_NEUTRAL:
            onResult(RESULT_OK);
            break;
        default:
            getArguments().putSerializable(ARG_SELECTED,
                    getChoices().get(which));
            onResult(RESULT_OK);
        }
    }
}

<code block>

package com.github.pockethub.ui.issue;

import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
import static android.content.Intent.FLAG_ACTIVITY_SINGLE_TOP;
import static com.github.pockethub.Intents.EXTRA_ISSUE_NUMBERS;
import static com.github.pockethub.Intents.EXTRA_POSITION;
import static com.github.pockethub.Intents.EXTRA_REPOSITORIES;
import static com.github.pockethub.Intents.EXTRA_REPOSITORY;
import android.accounts.Account;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.ActionBar;
import android.view.Menu;
import android.view.MenuItem;

import com.github.pockethub.Intents.Builder;
import com.github.pockethub.R;
import com.github.pockethub.accounts.AccountUtils;
import com.github.pockethub.accounts.AuthenticatedUserTask;
import com.github.pockethub.core.issue.IssueStore;
import com.github.pockethub.core.issue.IssueUtils;
import com.github.pockethub.core.repo.RefreshRepositoryTask;
import com.github.pockethub.ui.FragmentProvider;
import com.github.pockethub.ui.PagerActivity;
import com.github.pockethub.ui.ViewPager;
import com.github.pockethub.ui.repo.RepositoryViewActivity;
import com.github.pockethub.ui.user.UriLauncherActivity;
import com.github.pockethub.util.AvatarLoader;
import com.google.inject.Inject;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;

import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.RepositoryId;
import org.eclipse.egit.github.core.RepositoryIssue;
import org.eclipse.egit.github.core.Team;
import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.service.CollaboratorService;
import org.eclipse.egit.github.core.service.TeamService;


public class IssuesViewActivity extends PagerActivity {

    private static final String EXTRA_PULL_REQUESTS = "pullRequests";


    public static Intent createIntent(final Issue issue) {
        return createIntent(Collections.singletonList(issue), 0);
    }


    public static Intent createIntent(final Issue issue,
        final Repository repository) {
        return createIntent(Collections.singletonList(issue), repository, 0);
    }


    public static Intent createIntent(final Collection<? extends Issue> issues,
        final Repository repository, final int position) {
        int[] numbers = new int[issues.size()];
        boolean[] pullRequests = new boolean[issues.size()];
        int index = 0;
        for (Issue issue : issues) {
            numbers[index] = issue.getNumber();
            pullRequests[index] = IssueUtils.isPullRequest(issue);
            index++;
        }
        return new Builder("issues.VIEW").add(EXTRA_ISSUE_NUMBERS, numbers)
            .add(EXTRA_REPOSITORY, repository)
            .add(EXTRA_POSITION, position)
            .add(EXTRA_PULL_REQUESTS, pullRequests).toIntent();
    }


    public static Intent createIntent(Collection<? extends Issue> issues,
        int position) {
        final int count = issues.size();
        int[] numbers = new int[count];
        boolean[] pullRequests = new boolean[count];
        ArrayList<RepositoryId> repos = new ArrayList<>(count);
        int index = 0;
        for (Issue issue : issues) {
            numbers[index] = issue.getNumber();
            pullRequests[index] = IssueUtils.isPullRequest(issue);
            index++;

            RepositoryId repoId = null;
            if (issue instanceof RepositoryIssue) {
                Repository issueRepo = ((RepositoryIssue) issue)
                    .getRepository();
                if (issueRepo != null) {
                    User owner = issueRepo.getOwner();
                    if (owner != null)
                        repoId = RepositoryId.create(owner.getLogin(),
                            issueRepo.getName());
                }
            }
            if (repoId == null)
                repoId = RepositoryId.createFromUrl(issue.getHtmlUrl());
            repos.add(repoId);
        }

        Builder builder = new Builder("issues.VIEW");
        builder.add(EXTRA_ISSUE_NUMBERS, numbers);
        builder.add(EXTRA_REPOSITORIES, repos);
        builder.add(EXTRA_POSITION, position);
        builder.add(EXTRA_PULL_REQUESTS, pullRequests);
        return builder.toIntent();
    }

    private ViewPager pager;

    private int[] issueNumbers;

    private boolean[] pullRequests;

    private ArrayList<RepositoryId> repoIds;

    private Repository repo;

    @Inject
    private AvatarLoader avatars;

    @Inject
    private IssueStore store;

    @Inject
    private TeamService teamService;

    @Inject
    private CollaboratorService collaboratorService;

    private final AtomicReference<User> user = new AtomicReference<>();

    private boolean isCollaborator;

    private boolean isOwner;

    private IssuesPagerAdapter adapter;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        issueNumbers = getIntArrayExtra(EXTRA_ISSUE_NUMBERS);
        pullRequests = getBooleanArrayExtra(EXTRA_PULL_REQUESTS);
        repoIds = getSerializableExtra(EXTRA_REPOSITORIES);
        repo = getSerializableExtra(EXTRA_REPOSITORY);

        setContentView(R.layout.pager);

        setSupportActionBar((android.support.v7.widget.Toolbar) findViewById(R.id.toolbar));

        getSupportActionBar().setDisplayHomeAsUpEnabled(true);
        if (repo != null) {
            ActionBar actionBar = getSupportActionBar();
            actionBar.setSubtitle(repo.generateId());
            user.set(repo.getOwner());
            avatars.bind(actionBar, user);
        }



        if (issueNumbers.length == 1
            && (user.get() == null || user.get().getAvatarUrl() == null))
            new RefreshRepositoryTask(this, repo != null ? repo : repoIds.get(0)) {

                @Override
                protected void onSuccess(Repository fullRepository)
                    throws Exception {
                    super.onSuccess(fullRepository);

                    avatars.bind(getSupportActionBar(),
                        fullRepository.getOwner());
                }
            }.execute();

        isOwner = false;
        if(repo != null) {
            if (!AccountUtils.isUser(this, repo.getOwner()))
                checkOwnerStatus();
            else
                isOwner = repo.getOwner().getLogin().equals(AccountUtils.getLogin(this));
        }

        isCollaborator = false;
        checkCollaboratorStatus();
    }

    private void configurePager() {
        int initialPosition = getIntExtra(EXTRA_POSITION);
        pager = finder.find(R.id.vp_pages);

        if (repo != null)
            adapter = new IssuesPagerAdapter(this, repo, issueNumbers, isCollaborator, isOwner);
        else
            adapter = new IssuesPagerAdapter(this, repoIds, issueNumbers, store, isCollaborator, isOwner);
        pager.setAdapter(adapter);

        pager.setOnPageChangeListener(this);
        pager.scheduleSetItem(initialPosition, this);
        onPageSelected(initialPosition);
    }

    private void updateTitle(final int position) {
        int number = issueNumbers[position];
        boolean pullRequest = pullRequests[position];

        if (pullRequest)
            getSupportActionBar().setTitle(
                getString(R.string.pull_request_title) + number);
        else
            getSupportActionBar().setTitle(
                getString(R.string.issue_title) + number);
    }

    @Override
    public void onPageSelected(final int position) {
        super.onPageSelected(position);

        if (repo != null) {
            updateTitle(position);
            return;
        }

        if (repoIds == null)
            return;

        ActionBar actionBar = getSupportActionBar();
        RepositoryId repoId = repoIds.get(position);
        if (repoId != null) {
            updateTitle(position);
            actionBar.setSubtitle(repoId.generateId());
            RepositoryIssue issue = store.getIssue(repoId,
                issueNumbers[position]);
            if (issue != null) {
                Repository fullRepo = issue.getRepository();
                if (fullRepo != null && fullRepo.getOwner() != null) {
                    user.set(fullRepo.getOwner());
                    avatars.bind(actionBar, user);
                } else
                    actionBar.setLogo(null);
            } else
                actionBar.setLogo(null);
        } else {
            actionBar.setSubtitle(null);
            actionBar.setLogo(null);
        }
    }

    @Override
    public void onDialogResult(int requestCode, int resultCode, Bundle arguments) {
        adapter.onDialogResult(pager.getCurrentItem(), requestCode, resultCode,
            arguments);
    }

    @Override
    public void startActivity(Intent intent) {
        Intent converted = UriLauncherActivity.convert(intent);
        if (converted != null)
            super.startActivity(converted);
        else
            super.startActivity(intent);
    }

    @Override
    protected FragmentProvider getProvider() {
        return adapter;
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {

        return super.onPrepareOptionsMenu(menu);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                Repository repository = repo;
                if (repository == null) {
                    int position = pager.getCurrentItem();
                    RepositoryId repoId = repoIds.get(position);
                    if (repoId != null) {
                        RepositoryIssue issue = store.getIssue(repoId,
                            issueNumbers[position]);
                        if (issue != null)
                            repository = issue.getRepository();
                    }
                }
                if (repository != null) {
                    Intent intent = RepositoryViewActivity.createIntent(repository);
                    intent.addFlags(FLAG_ACTIVITY_CLEAR_TOP
                        | FLAG_ACTIVITY_SINGLE_TOP);
                    startActivity(intent);
                }
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    private void checkCollaboratorStatus() {
        new AuthenticatedUserTask<Boolean>(this) {

            @Override
            protected Boolean run(Account account) throws Exception {
                return collaboratorService.isCollaborator(repo != null ? repo : repoIds.get(0),
                    AccountUtils.getLogin(IssuesViewActivity.this));
            }

            @Override
            protected void onThrowable(Throwable t) throws RuntimeException {
                invalidateOptionsMenu();
                configurePager();
            }

            @Override
            protected void onSuccess(Boolean collaborator) throws Exception {
                super.onSuccess(collaborator);

                isCollaborator = collaborator;
                invalidateOptionsMenu();
                configurePager();
            }
        }.execute();
    }

    private void checkOwnerStatus() {
        new AuthenticatedUserTask<Boolean>(this) {

            @Override
            protected Boolean run(Account account) throws Exception {
                List<Team> teams = teamService.getTeams(repo.getOwner().getLogin());
                List<User> users = teamService.getMembers(teams.get(0).getId());

                String userName = AccountUtils.getLogin(IssuesViewActivity.this);
                for(User user : users)
                    if(user.getLogin().equals(userName))
                        return true;

                return false;
            }

            @Override
            protected void onThrowable(Throwable t) throws RuntimeException {
                invalidateOptionsMenu();
                configurePager();
            }

            @Override
            protected void onSuccess(Boolean owner) throws Exception {
                super.onSuccess(owner);

                isOwner = owner;
                invalidateOptionsMenu();
                configurePager();
            }
        }.execute();
    }
}

<code block>

package com.github.pockethub.ui.issue;

import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
import static android.content.Intent.FLAG_ACTIVITY_SINGLE_TOP;
import static com.github.pockethub.Intents.EXTRA_ISSUE_FILTER;
import static com.github.pockethub.Intents.EXTRA_REPOSITORY;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.ActionBar;
import android.view.MenuItem;

import com.github.pockethub.Intents.Builder;
import com.github.pockethub.R;
import com.github.pockethub.core.issue.IssueFilter;
import com.github.pockethub.ui.DialogFragmentActivity;
import com.github.pockethub.util.AvatarLoader;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Repository;


public class IssueBrowseActivity extends DialogFragmentActivity {


    public static Intent createIntent(IssueFilter filter) {
        return new Builder("repo.issues.VIEW").repo(filter.getRepository())
            .add(EXTRA_ISSUE_FILTER, filter).toIntent();
    }

    private Repository repo;

    @Inject
    private AvatarLoader avatars;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        repo = getSerializableExtra(EXTRA_REPOSITORY);

        setContentView(R.layout.repo_issue_list);

        setSupportActionBar((android.support.v7.widget.Toolbar) findViewById(R.id.toolbar));

        ActionBar actionBar = getSupportActionBar();
        actionBar.setTitle(repo.getName());
        actionBar.setSubtitle(repo.getOwner().getLogin());
        actionBar.setDisplayHomeAsUpEnabled(true);
        avatars.bind(actionBar, repo.getOwner());
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                Intent intent = FiltersViewActivity.createIntent();
                intent.addFlags(FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_SINGLE_TOP);
                startActivity(intent);
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }
}

<code block>

package com.github.pockethub.ui.issue;

import static com.github.pockethub.RequestCodes.ISSUE_MILESTONE_UPDATE;
import android.accounts.Account;

import com.github.pockethub.R;
import com.github.pockethub.core.issue.IssueStore;
import com.github.pockethub.ui.DialogFragmentActivity;
import com.github.pockethub.ui.ProgressDialogTask;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.Milestone;
import org.eclipse.egit.github.core.service.MilestoneService;


public class EditMilestoneTask extends ProgressDialogTask<Issue> {

    @Inject
    private MilestoneService service;

    @Inject
    private IssueStore store;

    private final MilestoneDialog milestoneDialog;

    private final IRepositoryIdProvider repositoryId;

    private final int issueNumber;

    private int milestoneNumber;


    public EditMilestoneTask(final DialogFragmentActivity activity,
            final IRepositoryIdProvider repositoryId, final int issueNumber) {
        super(activity);

        this.repositoryId = repositoryId;
        this.issueNumber = issueNumber;
        milestoneDialog = new MilestoneDialog(activity, ISSUE_MILESTONE_UPDATE,
                repositoryId, service);
    }

    @Override
    protected Issue run(Account account) throws Exception {
        Issue editedIssue = new Issue();
        editedIssue.setNumber(issueNumber);
        editedIssue.setMilestone(new Milestone().setNumber(milestoneNumber));
        return store.editIssue(repositoryId, editedIssue);
    }


    public EditMilestoneTask prompt(Milestone milestone) {
        milestoneDialog.show(milestone);
        return this;
    }


    public EditMilestoneTask edit(Milestone milestone) {
        if (milestone != null)
            milestoneNumber = milestone.getNumber();
        else
            milestoneNumber = -1;

        showIndeterminate(R.string.updating_milestone);

        super.execute();

        return this;
    }
}

<code block>

package com.github.pockethub.ui.issue;

import android.view.LayoutInflater;
import android.view.View;
import android.widget.TextView;

import com.github.pockethub.R;
import com.github.pockethub.core.issue.IssueUtils;
import com.github.pockethub.util.AvatarLoader;
import com.github.pockethub.util.TypefaceUtils;

import org.eclipse.egit.github.core.Issue;


public class RepositoryIssueListAdapter extends IssueListAdapter<Issue> {

    private int numberPaintFlags;


    public RepositoryIssueListAdapter(LayoutInflater inflater,
            Issue[] elements, AvatarLoader avatars) {
        super(R.layout.repo_issue_item, inflater, elements, avatars);
    }

    @Override
    public long getItemId(int position) {
        return getItem(position).getId();
    }

    @Override
    protected View initialize(View view) {
        view = super.initialize(view);

        numberPaintFlags = textView(view, 0).getPaintFlags();
        TypefaceUtils.setOcticons(textView(view, 5),
                (TextView) view.findViewById(R.id.tv_comment_icon));
        return view;
    }

    @Override
    protected int getNumber(Issue issue) {
        return issue.getNumber();
    }

    @Override
    protected int[] getChildViewIds() {
        return new int[] { R.id.tv_issue_number, R.id.tv_issue_title, R.id.iv_avatar,
                R.id.tv_issue_creation, R.id.tv_issue_comments,
                R.id.tv_pull_request_icon, R.id.v_label0, R.id.v_label1, R.id.v_label2,
                R.id.v_label3, R.id.v_label4, R.id.v_label5, R.id.v_label6, R.id.v_label7 };
    }

    @Override
    protected void update(int position, Issue issue) {
        updateNumber(issue.getNumber(), issue.getState(), numberPaintFlags, 0);

        avatars.bind(imageView(2), issue.getUser());

        setGone(5, !IssueUtils.isPullRequest(issue));

        setText(1, issue.getTitle());

        updateReporter(issue.getUser().getLogin(), issue.getCreatedAt(), 3);
        setNumber(4, issue.getComments());
        updateLabels(issue.getLabels(), 6);
    }
}

<code block>

package com.github.pockethub.ui.issue;

import static android.app.SearchManager.APP_DATA;
import static android.app.SearchManager.QUERY;
import static android.content.Intent.ACTION_SEARCH;
import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
import static android.content.Intent.FLAG_ACTIVITY_SINGLE_TOP;
import static com.github.pockethub.Intents.EXTRA_REPOSITORY;
import android.app.SearchManager;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.support.v4.view.MenuItemCompat;
import android.support.v7.app.ActionBar;
import android.support.v7.widget.SearchView;
import android.view.Menu;
import android.view.MenuItem;

import com.github.pockethub.R;
import com.github.pockethub.ui.repo.RepositoryViewActivity;
import com.github.pockethub.ui.roboactivities.RoboActionBarActivity;
import com.github.pockethub.util.AvatarLoader;
import com.github.pockethub.util.ToastUtils;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Repository;


public class IssueSearchActivity extends RoboActionBarActivity {

    @Inject
    private AvatarLoader avatars;

    private Repository repository;

    private SearchIssueListFragment issueFragment;

    @Override
    public boolean onCreateOptionsMenu(Menu options) {
        getMenuInflater().inflate(R.menu.search, options);

        SearchManager searchManager = (SearchManager) getSystemService(Context.SEARCH_SERVICE);
        MenuItem searchItem = options.findItem(R.id.m_search);
        SearchView searchView = (SearchView) MenuItemCompat.getActionView(searchItem);
        searchView.setSearchableInfo(searchManager.getSearchableInfo(getComponentName()));

        Bundle args = new Bundle();
        args.putSerializable(EXTRA_REPOSITORY, repository);
        searchView.setAppSearchData(args);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.m_clear:
                IssueSearchSuggestionsProvider.clear(this);
                ToastUtils.show(this, R.string.search_history_cleared);
                return true;
            case android.R.id.home:
                Intent intent = RepositoryViewActivity.createIntent(repository);
                intent.addFlags(FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_SINGLE_TOP);
                startActivity(intent);
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.issue_search);

        setSupportActionBar((android.support.v7.widget.Toolbar) findViewById(R.id.toolbar));

        ActionBar actionBar = getSupportActionBar();
        Bundle appData = getIntent().getBundleExtra(APP_DATA);
        if (appData != null) {
            repository = (Repository) appData.getSerializable(EXTRA_REPOSITORY);
            if (repository != null) {
                actionBar.setSubtitle(repository.generateId());
                actionBar.setDisplayHomeAsUpEnabled(true);
            }
        }
        avatars.bind(actionBar, repository.getOwner());

        issueFragment = (SearchIssueListFragment) getSupportFragmentManager()
            .findFragmentById(android.R.id.list);

        handleIntent(getIntent());
    }

    @Override
    protected void onNewIntent(Intent intent) {
        setIntent(intent);
        issueFragment.setListShown(false);
        handleIntent(intent);
        issueFragment.refresh();
    }

    private void handleIntent(Intent intent) {
        if (ACTION_SEARCH.equals(intent.getAction()))
            search(intent.getStringExtra(QUERY));
    }

    private void search(final String query) {
        getSupportActionBar().setTitle(query);
        IssueSearchSuggestionsProvider.save(this, query);
        issueFragment.setQuery(query);
    }
}

<code block>

package com.github.pockethub.ui.issue;

import android.accounts.Account;
import android.app.Activity;
import android.util.Log;

import com.github.pockethub.R;
import com.github.pockethub.core.issue.IssueStore;
import com.github.pockethub.ui.ProgressDialogTask;
import com.github.pockethub.util.ToastUtils;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.service.IssueService;


public class CreateIssueTask extends ProgressDialogTask<Issue> {

    private static final String TAG = "CreateIssueTask";

    @Inject
    private IssueService service;

    @Inject
    private IssueStore store;

    private final IRepositoryIdProvider repository;

    private final Issue issue;


    public CreateIssueTask(final Activity activity,
            final IRepositoryIdProvider repository, final Issue issue) {
        super(activity);

        this.repository = repository;
        this.issue = issue;
    }


    public CreateIssueTask create() {
        showIndeterminate(R.string.creating_issue);

        execute();
        return this;
    }

    @Override
    public Issue run(Account account) throws Exception {
        return store.addIssue(service.createIssue(repository, issue));
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.e(TAG, "Exception creating issue", e);
        ToastUtils.show((Activity) getContext(), e.getMessage());
    }
}

<code block>

package com.github.pockethub.ui.issue;

import static android.app.Activity.RESULT_OK;
import static android.content.DialogInterface.BUTTON_NEGATIVE;
import static android.content.DialogInterface.BUTTON_NEUTRAL;
import static android.content.DialogInterface.BUTTON_POSITIVE;
import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ListView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.pockethub.R;
import com.github.pockethub.ui.DialogFragmentActivity;
import com.github.pockethub.ui.DialogFragmentHelper;
import com.github.pockethub.ui.LightAlertDialog;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;

import org.eclipse.egit.github.core.Label;


public class LabelsDialogFragment extends DialogFragmentHelper implements
        OnClickListener {


    public static final String ARG_SELECTED = "selected";

    private static final String ARG_CHOICES = "choices";

    private static final String ARG_SELECTED_CHOICES = "selectedChoices";

    private static final String TAG = "multi_choice_dialog";

    private static class LabelListAdapter extends SingleTypeAdapter<Label>
            implements OnItemClickListener {

        private final boolean[] selected;

        public LabelListAdapter(LayoutInflater inflater, Label[] labels,
                boolean[] selected) {
            super(inflater, R.layout.label_item);

            this.selected = selected;
            setItems(labels);
        }

        @Override
        public void onItemClick(AdapterView<?> parent, View view, int position,
                long id) {
            selected[position] = !selected[position];
            notifyDataSetChanged();
        }

        @Override
        protected int[] getChildViewIds() {
            return new int[] { R.id.tv_label_name, R.id.cb_selected };
        }

        @Override
        protected void update(int position, Label item) {
            LabelDrawableSpan.setText(textView(0), item);
            setChecked(1, selected[position]);
        }
    }


    @SuppressWarnings("unchecked")
    public static ArrayList<Label> getSelected(Bundle arguments) {
        return (ArrayList<Label>) arguments.getSerializable(ARG_SELECTED);
    }


    public static void show(final DialogFragmentActivity activity,
            final int requestCode, final String title, final String message,
            final ArrayList<Label> choices, final boolean[] selectedChoices) {
        Bundle arguments = createArguments(title, message, requestCode);
        arguments.putSerializable(ARG_CHOICES, choices);
        arguments.putBooleanArray(ARG_SELECTED_CHOICES, selectedChoices);
        show(activity, new LabelsDialogFragment(), arguments, TAG);
    }

    @Override
    public Dialog onCreateDialog(final Bundle savedInstanceState) {
        Bundle arguments = getArguments();
        Activity activity = getActivity();

        ArrayList<Label> choices = getChoices();
        boolean[] selectedChoices = arguments
                .getBooleanArray(ARG_SELECTED_CHOICES);
        HashSet<String> selected = new HashSet<>();
        if (selectedChoices != null)
            for (int i = 0; i < choices.size(); i++)
                if (selectedChoices[i])
                    selected.add(choices.get(i).getName());
        arguments.putSerializable(ARG_SELECTED, selected);

        LayoutInflater inflater = activity.getLayoutInflater();
        ListView view = (ListView) inflater.inflate(R.layout.dialog_list_view,
                null);
        LabelListAdapter adapter = new LabelListAdapter(inflater,
                choices.toArray(new Label[choices.size()]), selectedChoices);
        view.setAdapter(adapter);
        view.setOnItemClickListener(adapter);

        AlertDialog dialog = LightAlertDialog.create(activity);
        dialog.setCancelable(true);
        dialog.setOnCancelListener(this);
        dialog.setButton(BUTTON_NEGATIVE, activity.getString(R.string.cancel),
                this);
        dialog.setButton(BUTTON_NEUTRAL, activity.getString(R.string.clear), this);
        dialog.setButton(BUTTON_POSITIVE, activity.getString(R.string.apply),
                this);
        dialog.setTitle(getTitle());
        dialog.setMessage(getMessage());
        dialog.setView(view);
        return dialog;
    }

    @SuppressWarnings("unchecked")
    private ArrayList<Label> getChoices() {
        return (ArrayList<Label>) getArguments().getSerializable(ARG_CHOICES);
    }

    @Override
    protected void onResult(int resultCode) {
        Bundle arguments = getArguments();
        ArrayList<Label> selected = new ArrayList<>();
        boolean[] selectedChoices = arguments
                .getBooleanArray(ARG_SELECTED_CHOICES);
        ArrayList<Label> choices = getChoices();
        for (int i = 0; i < selectedChoices.length; i++)
            if (selectedChoices[i])
                selected.add(choices.get(i));
        arguments.putSerializable(ARG_SELECTED, selected);

        super.onResult(resultCode);
    }

    @Override
    public void onClick(DialogInterface dialog, int which) {
        super.onClick(dialog, which);

        switch (which) {
        case BUTTON_NEUTRAL:
            Arrays.fill(getArguments().getBooleanArray(ARG_SELECTED_CHOICES),
                    false);
        case BUTTON_POSITIVE:
            onResult(RESULT_OK);
        }
    }
}

<code block>

package com.github.pockethub.ui.issue;

import android.content.Context;
import android.content.SearchRecentSuggestionsProvider;
import android.provider.SearchRecentSuggestions;


public class IssueSearchSuggestionsProvider extends
        SearchRecentSuggestionsProvider {

    private static final String AUTHORITY = "com.github.search.suggest.recent.issues";


    public static void save(Context context, String query) {
        suggestions(context).saveRecentQuery(query, null);
    }


    public static void clear(Context context) {
        suggestions(context).clearHistory();
    }

    private static SearchRecentSuggestions suggestions(Context context) {
        return new SearchRecentSuggestions(context, AUTHORITY,
                DATABASE_MODE_QUERIES);
    }


    public IssueSearchSuggestionsProvider() {
        setupSuggestions(AUTHORITY, DATABASE_MODE_QUERIES);
    }
}
<code block>

package com.github.pockethub.ui.issue;

import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
import static android.content.Intent.FLAG_ACTIVITY_SINGLE_TOP;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.ActionBar;
import android.view.MenuItem;
import android.view.View;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemLongClickListener;

import com.github.pockethub.Intents.Builder;
import com.github.pockethub.R;
import com.github.pockethub.RequestFuture;
import com.github.pockethub.core.issue.IssueFilter;
import com.github.pockethub.persistence.AccountDataManager;
import com.github.pockethub.ui.ConfirmDialogFragment;
import com.github.pockethub.ui.DialogFragmentActivity;
import com.github.pockethub.ui.MainActivity;
import com.google.inject.Inject;


public class FiltersViewActivity extends DialogFragmentActivity implements
    OnItemLongClickListener {


    public static Intent createIntent() {
        return new Builder("repo.issues.filters.VIEW").toIntent();
    }

    private static final String ARG_FILTER = "filter";

    private static final int REQUEST_DELETE = 1;

    @Inject
    private AccountDataManager cache;

    private FilterListFragment fragment;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.issues_filter_list);

        setSupportActionBar((android.support.v7.widget.Toolbar) findViewById(R.id.toolbar));

        ActionBar actionBar = getSupportActionBar();
        actionBar.setTitle(R.string.bookmarks);
        actionBar.setIcon(R.drawable.ic_bookmark_white_24dp);
        actionBar.setDisplayHomeAsUpEnabled(true);

        fragment = (FilterListFragment) getSupportFragmentManager()
            .findFragmentById(android.R.id.list);
        fragment.getListView().setOnItemLongClickListener(this);
    }

    @Override
    public void onDialogResult(int requestCode, int resultCode, Bundle arguments) {
        if (requestCode == REQUEST_DELETE && resultCode == RESULT_OK) {
            IssueFilter filter = (IssueFilter) arguments
                .getSerializable(ARG_FILTER);
            cache.removeIssueFilter(filter, new RequestFuture<IssueFilter>() {

                @Override
                public void success(IssueFilter response) {
                    if (fragment != null)
                        fragment.refresh();
                }
            });
            return;
        }

        super.onDialogResult(requestCode, resultCode, arguments);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                Intent intent = new Intent(this, MainActivity.class);
                intent.addFlags(FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_SINGLE_TOP);
                startActivity(intent);
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    public boolean onItemLongClick(AdapterView<?> parent, View view,
        int position, long id) {
        IssueFilter filter = (IssueFilter) parent.getItemAtPosition(position);
        Bundle args = new Bundle();
        args.putSerializable(ARG_FILTER, filter);
        ConfirmDialogFragment.show(this, REQUEST_DELETE,
            getString(R.string.confirm_bookmark_delete_title),
            getString(R.string.confirm_bookmark_delete_message), args);
        return true;
    }
}

<code block>

package com.github.pockethub.ui.issue;

import android.accounts.Account;

import com.github.pockethub.R;
import com.github.pockethub.core.issue.IssueStore;
import com.github.pockethub.ui.DialogFragmentActivity;
import com.github.pockethub.ui.ProgressDialogTask;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.Issue;


public class EditIssueTask extends ProgressDialogTask<Issue> {

    @Inject
    private IssueStore store;

    private final IRepositoryIdProvider repositoryId;

    private final Issue issue;


    public EditIssueTask(final DialogFragmentActivity activity,
            final IRepositoryIdProvider repositoryId, final Issue issue) {
        super(activity);

        this.repositoryId = repositoryId;
        this.issue = issue;
    }

    @Override
    protected Issue run(Account account) throws Exception {
        return store.editIssue(repositoryId, issue);
    }


    public EditIssueTask edit() {
        showIndeterminate(R.string.updating_issue);

        execute();
        return this;
    }
}

<code block>

package com.github.pockethub.ui.issue;

import android.text.TextUtils;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.TextView;

import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.pockethub.R;
import com.github.pockethub.util.AvatarLoader;
import com.github.pockethub.util.TypefaceUtils;

import org.eclipse.egit.github.core.SearchIssue;
import org.eclipse.egit.github.core.User;


public class SearchIssueListAdapter extends IssueListAdapter<SearchIssue> {

    private int numberPaintFlags;


    public SearchIssueListAdapter(LayoutInflater inflater,
            SearchIssue[] elements, AvatarLoader avatars) {
        super(R.layout.repo_issue_item, inflater, elements, avatars);
    }

    @Override
    public long getItemId(int position) {
        return getItem(position).getNumber();
    }

    @Override
    protected int getNumber(SearchIssue issue) {
        return issue.getNumber();
    }

    @Override
    protected View initialize(View view) {
        view = super.initialize(view);

        numberPaintFlags = textView(view, 0).getPaintFlags();
        TypefaceUtils.setOcticons(
                (TextView) view.findViewById(R.id.tv_pull_request_icon),
                (TextView) view.findViewById(R.id.tv_comment_icon));
        for (int i = 0; i < MAX_LABELS; i++)
            ViewUtils.setGone(view.findViewById(R.id.v_label0 + i), true);
        ViewUtils.setGone(view.findViewById(R.id.tv_pull_request_icon), true);
        return view;
    }

    @Override
    protected int[] getChildViewIds() {
        return new int[] { R.id.tv_issue_number, R.id.tv_issue_title, R.id.iv_avatar,
                R.id.tv_issue_creation, R.id.tv_issue_comments };
    }

    @Override
    protected void update(int position, SearchIssue issue) {
        updateNumber(issue.getNumber(), issue.getState(), numberPaintFlags, 0);

        String gravatarId = issue.getGravatarId();
        User user;
        if (!TextUtils.isEmpty(gravatarId))
            user = new User().setGravatarId(gravatarId);
        else
            user = null;
        avatars.bind(imageView(2), user);

        setText(1, issue.getTitle());

        updateReporter(issue.getUser(), issue.getCreatedAt(), 3);
        setNumber(4, issue.getComments());
    }
}

<code block>

package com.github.pockethub.ui.issue;

import static android.app.Activity.RESULT_OK;
import static android.content.DialogInterface.BUTTON_NEGATIVE;
import static android.content.DialogInterface.BUTTON_NEUTRAL;
import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.DialogInterface;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ListView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.pockethub.R;
import com.github.pockethub.ui.DialogFragmentActivity;
import com.github.pockethub.ui.SingleChoiceDialogFragment;
import com.github.pockethub.util.AvatarLoader;
import com.google.inject.Inject;

import java.util.ArrayList;

import org.eclipse.egit.github.core.User;


public class AssigneeDialogFragment extends SingleChoiceDialogFragment {

    private static class UserListAdapter extends SingleTypeAdapter<User> {

        private final int selected;

        private final AvatarLoader loader;

        public UserListAdapter(LayoutInflater inflater, User[] users,
                int selected, AvatarLoader loader) {
            super(inflater, R.layout.collaborator_item);

            this.selected = selected;
            this.loader = loader;
            setItems(users);
        }

        @Override
        public long getItemId(int position) {
            return getItem(position).getId();
        }

        @Override
        protected int[] getChildViewIds() {
            return new int[] { R.id.tv_login, R.id.iv_avatar, R.id.rb_selected };
        }

        @Override
        protected void update(int position, User item) {
            setText(0, item.getLogin());
            loader.bind(imageView(1), item);
            setChecked(2, selected == position);
        }
    }


    public static User getSelected(Bundle arguments) {
        return (User) arguments.getSerializable(ARG_SELECTED);
    }


    public static void show(final DialogFragmentActivity activity,
            final int requestCode, final String title, final String message,
            ArrayList<User> choices, final int selectedChoice) {
        show(activity, requestCode, title, message, choices, selectedChoice,
                new AssigneeDialogFragment());
    }

    @Inject
    private AvatarLoader loader;

    @Override
    public Dialog onCreateDialog(final Bundle savedInstanceState) {
        Activity activity = getActivity();
        Bundle arguments = getArguments();

        final AlertDialog dialog = createDialog();
        dialog.setButton(BUTTON_NEGATIVE, activity.getString(R.string.cancel),
                this);
        dialog.setButton(BUTTON_NEUTRAL, activity.getString(R.string.clear), this);

        LayoutInflater inflater = activity.getLayoutInflater();

        ListView view = (ListView) inflater.inflate(R.layout.dialog_list_view,
                null);
        view.setOnItemClickListener(new OnItemClickListener() {

            @Override
            public void onItemClick(AdapterView<?> parent, View view,
                    int position, long id) {
                onClick(dialog, position);
            }
        });

        ArrayList<User> choices = getChoices();
        int selected = arguments.getInt(ARG_SELECTED_CHOICE);
        UserListAdapter adapter = new UserListAdapter(inflater,
                choices.toArray(new User[choices.size()]), selected, loader);
        view.setAdapter(adapter);
        if (selected >= 0)
            view.setSelection(selected);
        dialog.setView(view);

        return dialog;
    }

    @SuppressWarnings("unchecked")
    private ArrayList<User> getChoices() {
        return (ArrayList<User>) getArguments().getSerializable(ARG_CHOICES);
    }

    @Override
    public void onClick(DialogInterface dialog, int which) {
        super.onClick(dialog, which);

        switch (which) {
        case BUTTON_NEGATIVE:
            break;
        case BUTTON_NEUTRAL:
            onResult(RESULT_OK);
            break;
        default:
            getArguments().putSerializable(ARG_SELECTED,
                    getChoices().get(which));
            onResult(RESULT_OK);
        }
    }
}

<code block>

package com.github.pockethub.ui.issue;

import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
import static android.content.Intent.FLAG_ACTIVITY_SINGLE_TOP;
import static com.github.pockethub.util.TypefaceUtils.ICON_ADD;
import static com.github.pockethub.util.TypefaceUtils.ICON_BROADCAST;
import static com.github.pockethub.util.TypefaceUtils.ICON_FOLLOW;
import static com.github.pockethub.util.TypefaceUtils.ICON_WATCH;
import android.content.Intent;
import android.os.Bundle;
import android.support.annotation.Nullable;
import android.view.MenuItem;
import android.view.View;

import com.github.pockethub.ui.MainActivity;
import com.github.pockethub.ui.TabPagerFragment;


public class IssueDashboardPagerFragment extends
    TabPagerFragment<IssueDashboardPagerAdapter> {

    @Override
    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        configureTabPager();
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                Intent intent = new Intent(getActivity(), MainActivity.class);
                intent.addFlags(FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_SINGLE_TOP);
                startActivity(intent);
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    protected IssueDashboardPagerAdapter createAdapter() {
        return new IssueDashboardPagerAdapter(this);
    }

    @Override
    protected String getIcon(int position) {
        switch (position) {
            case 0:
                return ICON_WATCH;
            case 1:
                return ICON_FOLLOW;
            case 2:
                return ICON_ADD;
            case 3:
                return ICON_BROADCAST;
            default:
                return super.getIcon(position);
        }
    }
}

<code block>

package com.github.pockethub.ui.issue;

import static java.lang.String.CASE_INSENSITIVE_ORDER;
import android.accounts.Account;
import android.util.Log;

import com.github.pockethub.R;
import com.github.pockethub.ui.DialogFragmentActivity;
import com.github.pockethub.ui.ProgressDialogTask;
import com.github.pockethub.util.ToastUtils;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.service.CollaboratorService;


public class AssigneeDialog {

    private static final String TAG = "AssigneeDialog";

    private CollaboratorService service;

    private Map<String, User> collaborators;

    private final int requestCode;

    private final DialogFragmentActivity activity;

    private final IRepositoryIdProvider repository;


    public AssigneeDialog(final DialogFragmentActivity activity,
            final int requestCode, final IRepositoryIdProvider repository,
            final CollaboratorService service) {
        this.activity = activity;
        this.requestCode = requestCode;
        this.repository = repository;
        this.service = service;
    }

    private void load(final User selectedAssignee) {
        new ProgressDialogTask<List<User>>(activity) {

            @Override
            public List<User> run(Account account) throws Exception {
                List<User> users = service.getCollaborators(repository);
                Map<String, User> loadedCollaborators = new TreeMap<>(
                        CASE_INSENSITIVE_ORDER);
                for (User user : users)
                    loadedCollaborators.put(user.getLogin(), user);
                collaborators = loadedCollaborators;
                return users;
            }

            @Override
            protected void onSuccess(List<User> all) throws Exception {
                super.onSuccess(all);

                show(selectedAssignee);
            }

            @Override
            protected void onException(Exception e) throws RuntimeException {
                super.onException(e);

                Log.d(TAG, "Exception loading collaborators", e);
                ToastUtils.show(activity, e, R.string.error_collaborators_load);
            }

            @Override
            public void execute() {
                showIndeterminate(R.string.loading_collaborators);

                super.execute();
            }
        }.execute();
    }


    public void show(User selectedAssignee) {
        if (collaborators == null) {
            load(selectedAssignee);
            return;
        }

        final ArrayList<User> users = new ArrayList<>(
                collaborators.values());
        int checked = -1;
        if (selectedAssignee != null)
            for (int i = 0; i < users.size(); i++)
                if (selectedAssignee.getLogin().equals(users.get(i).getLogin()))
                    checked = i;
        AssigneeDialogFragment.show(activity, requestCode,
                activity.getString(R.string.select_assignee), null, users,
                checked);
    }
}

<code block>

package com.github.pockethub.ui.issue;

import static android.app.Activity.RESULT_OK;
import static android.view.View.GONE;
import static android.view.View.VISIBLE;
import static com.github.pockethub.Intents.EXTRA_COMMENT;
import static com.github.pockethub.Intents.EXTRA_ISSUE;
import static com.github.pockethub.Intents.EXTRA_ISSUE_NUMBER;
import static com.github.pockethub.Intents.EXTRA_IS_COLLABORATOR;
import static com.github.pockethub.Intents.EXTRA_IS_OWNER;
import static com.github.pockethub.Intents.EXTRA_REPOSITORY_NAME;
import static com.github.pockethub.Intents.EXTRA_REPOSITORY_OWNER;
import static com.github.pockethub.Intents.EXTRA_USER;
import static com.github.pockethub.RequestCodes.COMMENT_CREATE;
import static com.github.pockethub.RequestCodes.COMMENT_DELETE;
import static com.github.pockethub.RequestCodes.COMMENT_EDIT;
import static com.github.pockethub.RequestCodes.ISSUE_ASSIGNEE_UPDATE;
import static com.github.pockethub.RequestCodes.ISSUE_CLOSE;
import static com.github.pockethub.RequestCodes.ISSUE_EDIT;
import static com.github.pockethub.RequestCodes.ISSUE_LABELS_UPDATE;
import static com.github.pockethub.RequestCodes.ISSUE_MILESTONE_UPDATE;
import static com.github.pockethub.RequestCodes.ISSUE_REOPEN;
import static com.github.pockethub.util.TypefaceUtils.ICON_COMMIT;
import static org.eclipse.egit.github.core.service.IssueService.STATE_OPEN;
import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.text.TextUtils;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.LinearLayout.LayoutParams;
import android.widget.ListView;
import android.widget.ProgressBar;
import android.widget.TextView;

import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.pockethub.R;
import com.github.pockethub.accounts.AccountUtils;
import com.github.pockethub.core.issue.FullIssue;
import com.github.pockethub.core.issue.IssueStore;
import com.github.pockethub.core.issue.IssueUtils;
import com.github.pockethub.core.issue.RefreshIssueTask;
import com.github.pockethub.ui.ConfirmDialogFragment;
import com.github.pockethub.ui.DialogFragment;
import com.github.pockethub.ui.DialogFragmentActivity;
import com.github.pockethub.ui.HeaderFooterListAdapter;
import com.github.pockethub.ui.SelectableLinkMovementMethod;
import com.github.pockethub.ui.StyledText;
import com.github.pockethub.ui.comment.CommentListAdapter;
import com.github.pockethub.ui.comment.DeleteCommentListener;
import com.github.pockethub.ui.comment.EditCommentListener;
import com.github.pockethub.ui.commit.CommitCompareViewActivity;
import com.github.pockethub.util.AvatarLoader;
import com.github.pockethub.util.HttpImageGetter;
import com.github.pockethub.util.ShareUtils;
import com.github.pockethub.util.ToastUtils;
import com.github.pockethub.util.TypefaceUtils;
import com.google.inject.Inject;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.List;
import java.util.Locale;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.IssueEvent;
import org.eclipse.egit.github.core.Label;
import org.eclipse.egit.github.core.Milestone;
import org.eclipse.egit.github.core.PullRequest;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.RepositoryId;
import org.eclipse.egit.github.core.User;


public class IssueFragment extends DialogFragment {

    private int issueNumber;

    private List<Comment> comments;

    private List<Object> items;

    private RepositoryId repositoryId;

    private Issue issue;

    private User user;

    private boolean isCollaborator;

    private boolean isOwner;

    @Inject
    private AvatarLoader avatars;

    @Inject
    private IssueStore store;

    private ListView list;

    private ProgressBar progress;

    private View headerView;

    private View loadingView;

    private View footerView;

    private HeaderFooterListAdapter<CommentListAdapter> adapter;

    private EditMilestoneTask milestoneTask;

    private EditAssigneeTask assigneeTask;

    private EditLabelsTask labelsTask;

    private EditStateTask stateTask;

    private TextView stateText;

    private TextView titleText;

    private TextView bodyText;

    private TextView authorText;

    private TextView createdDateText;

    private ImageView creatorAvatar;

    private ViewGroup commitsView;

    private TextView assigneeText;

    private ImageView assigneeAvatar;

    private TextView labelsArea;

    private View milestoneArea;

    private View milestoneProgressArea;

    private TextView milestoneText;

    private MenuItem stateItem;

    @Inject
    private HttpImageGetter bodyImageGetter;

    @Inject
    private HttpImageGetter commentImageGetter;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        Bundle args = getArguments();
        repositoryId = RepositoryId.create(
                args.getString(EXTRA_REPOSITORY_OWNER),
                args.getString(EXTRA_REPOSITORY_NAME));
        issueNumber = args.getInt(EXTRA_ISSUE_NUMBER);
        user = (User) args.getSerializable(EXTRA_USER);
        isCollaborator = args.getBoolean(EXTRA_IS_COLLABORATOR, false);
        isOwner = args.getBoolean(EXTRA_IS_OWNER, false);

        DialogFragmentActivity dialogActivity = (DialogFragmentActivity) getActivity();

        milestoneTask = new EditMilestoneTask(dialogActivity, repositoryId,
                issueNumber) {

            @Override
            protected void onSuccess(Issue editedIssue) throws Exception {
                super.onSuccess(editedIssue);

                updateHeader(editedIssue);
            }
        };

        assigneeTask = new EditAssigneeTask(dialogActivity, repositoryId,
                issueNumber) {

            @Override
            protected void onSuccess(Issue editedIssue) throws Exception {
                super.onSuccess(editedIssue);

                updateHeader(editedIssue);
            }
        };

        labelsTask = new EditLabelsTask(dialogActivity, repositoryId,
                issueNumber) {

            @Override
            protected void onSuccess(Issue editedIssue) throws Exception {
                super.onSuccess(editedIssue);

                updateHeader(editedIssue);
            }
        };

        stateTask = new EditStateTask(dialogActivity, repositoryId, issueNumber) {

            @Override
            protected void onSuccess(Issue editedIssue) throws Exception {
                super.onSuccess(editedIssue);

                updateHeader(editedIssue);
            }
        };
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        adapter.addHeader(headerView);
        adapter.addFooter(footerView);

        issue = store.getIssue(repositoryId, issueNumber);

        TextView loadingText = (TextView) loadingView
                .findViewById(R.id.tv_loading);
        loadingText.setText(R.string.loading_comments);

        if (issue == null || (issue.getComments() > 0 && items == null))
            adapter.addHeader(loadingView);

        if (issue != null && items != null)
            updateList(issue, items);
        else {
            if (issue != null)
                updateHeader(issue);
            refreshIssue();
        }
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        return inflater.inflate(R.layout.comment_list, null);
    }

    @Override
    public void onViewCreated(View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        list = finder.find(android.R.id.list);
        progress = finder.find(R.id.pb_loading);

        LayoutInflater inflater = getLayoutInflater(savedInstanceState);

        headerView = inflater.inflate(R.layout.issue_header, null);

        stateText = (TextView) headerView.findViewById(R.id.tv_state);
        titleText = (TextView) headerView.findViewById(R.id.tv_issue_title);
        authorText = (TextView) headerView.findViewById(R.id.tv_issue_author);
        createdDateText = (TextView) headerView
                .findViewById(R.id.tv_issue_creation_date);
        creatorAvatar = (ImageView) headerView.findViewById(R.id.iv_avatar);
        commitsView = (ViewGroup) headerView.findViewById(R.id.ll_issue_commits);
        assigneeText = (TextView) headerView.findViewById(R.id.tv_assignee_name);
        assigneeAvatar = (ImageView) headerView
                .findViewById(R.id.iv_assignee_avatar);
        labelsArea = (TextView) headerView.findViewById(R.id.tv_labels);
        milestoneArea = headerView.findViewById(R.id.ll_milestone);
        milestoneText = (TextView) headerView.findViewById(R.id.tv_milestone);
        milestoneProgressArea = headerView.findViewById(R.id.v_closed);
        bodyText = (TextView) headerView.findViewById(R.id.tv_issue_body);
        bodyText.setMovementMethod(SelectableLinkMovementMethod.getInstance());

        loadingView = inflater.inflate(R.layout.loading_item, null);

        footerView = inflater.inflate(R.layout.footer_separator, null);

        commitsView.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                if (IssueUtils.isPullRequest(issue))
                    openPullRequestCommits();
            }
        });

        stateText.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                if (issue != null)
                    stateTask.confirm(STATE_OPEN.equals(issue.getState()));
            }
        });

        milestoneArea.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                if (issue != null && isCollaborator)
                    milestoneTask.prompt(issue.getMilestone());
            }
        });

        headerView.findViewById(R.id.ll_assignee).setOnClickListener(
                new OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        if (issue != null && isCollaborator)
                            assigneeTask.prompt(issue.getAssignee());
                    }
                });

        labelsArea.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                if (issue != null && isCollaborator)
                    labelsTask.prompt(issue.getLabels());
            }
        });

        Activity activity = getActivity();
        String userName = AccountUtils.getLogin(activity);

        adapter = new HeaderFooterListAdapter<>(list,
                new CommentListAdapter(activity.getLayoutInflater(), null, avatars,
                        commentImageGetter, editCommentListener, deleteCommentListener, userName, isOwner, issue));
        list.setAdapter(adapter);
    }

    private void updateHeader(final Issue issue) {
        if (!isUsable())
            return;

        titleText.setText(issue.getTitle());

        String body = issue.getBodyHtml();
        if (!TextUtils.isEmpty(body))
            bodyImageGetter.bind(bodyText, body, issue.getId());
        else
            bodyText.setText(R.string.no_description_given);

        authorText.setText(issue.getUser().getLogin());
        createdDateText.setText(new StyledText().append(
                getString(R.string.prefix_opened)).append(issue.getCreatedAt()));
        avatars.bind(creatorAvatar, issue.getUser());

        if (IssueUtils.isPullRequest(issue) && issue.getPullRequest().getCommits() > 0) {
            ViewUtils.setGone(commitsView, false);

            TextView icon = (TextView) headerView.findViewById(R.id.tv_commit_icon);
            TypefaceUtils.setOcticons(icon);
            icon.setText(ICON_COMMIT);

            String commits = getString(R.string.pull_request_commits,
                    issue.getPullRequest().getCommits());
            ((TextView) headerView.findViewById(R.id.tv_pull_request_commits)).setText(commits);
        } else
            ViewUtils.setGone(commitsView, true);

        boolean open = STATE_OPEN.equals(issue.getState());
        if (!open) {
            StyledText text = new StyledText();
            text.bold(getString(R.string.closed));
            Date closedAt = issue.getClosedAt();
            if (closedAt != null)
                text.append(' ').append(closedAt);
            stateText.setText(text);
        }
        ViewUtils.setGone(stateText, open);

        User assignee = issue.getAssignee();
        if (assignee != null) {
            StyledText name = new StyledText();
            name.bold(assignee.getLogin());
            name.append(' ').append(getString(R.string.assigned));
            assigneeText.setText(name);
            assigneeAvatar.setVisibility(VISIBLE);
            avatars.bind(assigneeAvatar, assignee);
        } else {
            assigneeAvatar.setVisibility(GONE);
            assigneeText.setText(R.string.unassigned);
        }

        List<Label> labels = issue.getLabels();
        if (labels != null && !labels.isEmpty()) {
            LabelDrawableSpan.setText(labelsArea, labels);
            labelsArea.setVisibility(VISIBLE);
        } else
            labelsArea.setVisibility(GONE);

        if (issue.getMilestone() != null) {
            Milestone milestone = issue.getMilestone();
            StyledText milestoneLabel = new StyledText();
            milestoneLabel.append(getString(R.string.milestone_prefix));
            milestoneLabel.append(' ');
            milestoneLabel.bold(milestone.getTitle());
            milestoneText.setText(milestoneLabel);
            float closed = milestone.getClosedIssues();
            float total = closed + milestone.getOpenIssues();
            if (total > 0) {
                ((LayoutParams) milestoneProgressArea.getLayoutParams()).weight = closed
                        / total;
                milestoneProgressArea.setVisibility(VISIBLE);
            } else
                milestoneProgressArea.setVisibility(GONE);
            milestoneArea.setVisibility(VISIBLE);
        } else
            milestoneArea.setVisibility(GONE);

        String state = issue.getState();
        if (state != null && state.length() > 0)
            state = state.substring(0, 1).toUpperCase(Locale.US)
                    + state.substring(1);
        else
            state = "";

        ViewUtils.setGone(progress, true);
        ViewUtils.setGone(list, false);
        updateStateItem(issue);
    }

    private void refreshIssue() {
        new RefreshIssueTask(getActivity(), repositoryId, issueNumber,
                bodyImageGetter, commentImageGetter) {

            @Override
            protected void onException(Exception e) throws RuntimeException {
                super.onException(e);
                ToastUtils.show(getActivity(), e, R.string.error_issue_load);
                ViewUtils.setGone(progress, true);
            }

            @Override
            protected void onSuccess(FullIssue fullIssue) throws Exception {
                super.onSuccess(fullIssue);
                if (!isUsable())
                    return;

                issue = fullIssue.getIssue();
                comments = fullIssue;

                List<IssueEvent> events = (List<IssueEvent>) fullIssue.getEvents();
                int numEvents = events.size();

                List<Object> allItems = new ArrayList<>();

                int start = 0;
                for (Comment comment : fullIssue) {
                    for (int e = start; e < numEvents; e++) {
                        IssueEvent event = events.get(e);
                        if (comment.getCreatedAt().after(event.getCreatedAt())) {
                            allItems.add(event);
                            start++;
                        } else {
                            e = events.size();
                        }
                    }
                    allItems.add(comment);
                }


                for(int e = start; e < events.size(); e++) {
                    IssueEvent event = events.get(e);
                    allItems.add(event);
                }

                items = allItems;
                updateList(fullIssue.getIssue(), allItems);
            }
        }.execute();
    }

    private void updateList(Issue issue, List<Object> items) {
        adapter.getWrappedAdapter().setItems(items);
        adapter.removeHeader(loadingView);
        adapter.getWrappedAdapter().setIssue(issue);

        headerView.setVisibility(VISIBLE);
        updateHeader(issue);
    }

    @Override
    public void onDialogResult(int requestCode, int resultCode, Bundle arguments) {
        if (RESULT_OK != resultCode)
            return;

        switch (requestCode) {
        case ISSUE_MILESTONE_UPDATE:
            milestoneTask.edit(MilestoneDialogFragment.getSelected(arguments));
            break;
        case ISSUE_ASSIGNEE_UPDATE:
            assigneeTask.edit(AssigneeDialogFragment.getSelected(arguments));
            break;
        case ISSUE_LABELS_UPDATE:
            ArrayList<Label> labels = LabelsDialogFragment
                    .getSelected(arguments);
            if (labels != null && !labels.isEmpty())
                labelsTask.edit(labels.toArray(new Label[labels.size()]));
            else
                labelsTask.edit(null);
            break;
        case ISSUE_CLOSE:
            stateTask.edit(true);
            break;
        case ISSUE_REOPEN:
            stateTask.edit(false);
            break;
        case COMMENT_DELETE:
            final Comment comment = (Comment) arguments.getSerializable(EXTRA_COMMENT);
            new DeleteCommentTask(getActivity(), repositoryId, comment) {
                @Override
                protected void onSuccess(Comment comment) throws Exception {
                    super.onSuccess(comment);

                    if (comments != null && comment != null) {
                        int position = Collections.binarySearch(comments,
                                comment, new Comparator<Comment>() {
                                    public int compare(Comment lhs, Comment rhs) {
                                        return Long.valueOf(lhs.getId())
                                                .compareTo(rhs.getId());
                                    }
                                });
                        comments.remove(position);
                        updateList(issue, items);
                    } else
                        refreshIssue();
                }
            }.start();
            break;
        }
    }

    private void updateStateItem(Issue issue) {
        if (issue != null && stateItem != null) {
            if (STATE_OPEN.equals(issue.getState())) {
                stateItem.setTitle(R.string.close);
                stateItem.setIcon(R.drawable.ic_github_issue_closed_white_24dp);
            } else {
                stateItem.setTitle(R.string.reopen);
                stateItem.setIcon(R.drawable.ic_github_issue_reopened_white_24dp);
            }
        }
    }

    @Override
    public void onPrepareOptionsMenu(Menu menu) {
        super.onPrepareOptionsMenu(menu);
        MenuItem editItem = menu.findItem(R.id.m_edit);
        MenuItem stateItem = menu.findItem(R.id.m_state);
        if (editItem != null && stateItem != null) {
            boolean isCreator = false;
            if(issue != null)
                isCreator = issue.getUser().getLogin().equals(AccountUtils.getLogin(getActivity()));
            editItem.setVisible(isOwner || isCollaborator || isCreator);
            stateItem.setVisible(isOwner || isCollaborator || isCreator);
        }
        updateStateItem(issue);
    }

    @Override
    public void onCreateOptionsMenu(Menu optionsMenu, MenuInflater inflater) {
        inflater.inflate(R.menu.issue_view, optionsMenu);
        stateItem = optionsMenu.findItem(R.id.m_state);
        updateStateItem(issue);
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (RESULT_OK != resultCode || data == null)
            return;

        switch (requestCode) {
        case ISSUE_EDIT:
            Issue editedIssue = (Issue) data.getSerializableExtra(EXTRA_ISSUE);
            bodyImageGetter.encode(editedIssue.getId(), editedIssue.getBodyHtml());
            updateHeader(editedIssue);
            return;
        case COMMENT_CREATE:
            Comment comment = (Comment) data
                    .getSerializableExtra(EXTRA_COMMENT);
            if (items != null) {
                items.add(comment);
                issue.setComments(issue.getComments() + 1);
                updateList(issue, items);
            } else
                refreshIssue();
            return;
        case COMMENT_EDIT:
            comment = (Comment) data
                    .getSerializableExtra(EXTRA_COMMENT);
            if (comments != null && comment != null) {
                int position = Collections.binarySearch(comments, comment, new Comparator<Comment>() {
                    public int compare(Comment lhs, Comment rhs) {
                        return Long.valueOf(lhs.getId()).compareTo(rhs.getId());
                    }
                });
                commentImageGetter.removeFromCache(comment.getId());
                comments.set(position, comment);
                updateList(issue, items);
            } else
                refreshIssue();
        }
    }

    private void shareIssue() {
        String id = repositoryId.generateId();
        if (IssueUtils.isPullRequest(issue))
            startActivity(ShareUtils.create("Pull Request " + issueNumber
                    + " on " + id, "https://github.com/" + id + "/pull/"
                    + issueNumber));
        else
            startActivity(ShareUtils
                    .create("Issue " + issueNumber + " on " + id,
                            "https://github.com/" + id + "/issues/"
                                    + issueNumber));
    }

    private void openPullRequestCommits() {
        if (IssueUtils.isPullRequest(issue)) {
            PullRequest pullRequest = issue.getPullRequest();

            String base = pullRequest.getBase().getSha();
            String head = pullRequest.getHead().getSha();
            Repository repo = pullRequest.getBase().getRepo();
            startActivity(CommitCompareViewActivity.createIntent(repo, base, head));
        }
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
        case R.id.m_edit:
            if (issue != null)
                startActivityForResult(EditIssueActivity.createIntent(issue,
                                repositoryId.getOwner(), repositoryId.getName(), user),
                        ISSUE_EDIT);
            return true;
        case R.id.m_comment:
            if (issue != null)
                startActivityForResult(CreateCommentActivity.createIntent(
                        repositoryId, issueNumber, user), COMMENT_CREATE);
            return true;
        case R.id.m_refresh:
            refreshIssue();
            return true;
        case R.id.m_share:
            if (issue != null)
                shareIssue();
            return true;
        case R.id.m_state:
            if (issue != null)
                stateTask.confirm(STATE_OPEN.equals(issue.getState()));
            return true;
        default:
            return super.onOptionsItemSelected(item);
        }
    }


    final EditCommentListener editCommentListener = new EditCommentListener() {
        public void onEditComment(Comment comment) {
            startActivityForResult(EditCommentActivity.createIntent(
                    repositoryId, issueNumber, comment, user), COMMENT_EDIT);
        }
    };


    final DeleteCommentListener deleteCommentListener = new DeleteCommentListener() {
        public void onDeleteComment(Comment comment) {
            Bundle args = new Bundle();
            args.putSerializable(EXTRA_COMMENT, comment);
            ConfirmDialogFragment.show(
                    getActivity(),
                    COMMENT_DELETE,
                    getActivity()
                            .getString(R.string.confirm_comment_delete_title),
                    getActivity().getString(
                            R.string.confirm_comment_delete_message), args);
        }
    };
}

<code block>

package com.github.pockethub.ui.issue;

import static com.github.pockethub.ui.issue.DashboardIssueFragment.ARG_FILTER;
import static org.eclipse.egit.github.core.service.IssueService.DIRECTION_DESCENDING;
import static org.eclipse.egit.github.core.service.IssueService.FIELD_DIRECTION;
import static org.eclipse.egit.github.core.service.IssueService.FIELD_FILTER;
import static org.eclipse.egit.github.core.service.IssueService.FIELD_SORT;
import static org.eclipse.egit.github.core.service.IssueService.FILTER_ASSIGNED;
import static org.eclipse.egit.github.core.service.IssueService.FILTER_CREATED;
import static org.eclipse.egit.github.core.service.IssueService.FILTER_MENTIONED;
import static org.eclipse.egit.github.core.service.IssueService.FILTER_SUBSCRIBED;
import static org.eclipse.egit.github.core.service.IssueService.SORT_UPDATED;
import android.content.res.Resources;
import android.os.Bundle;
import android.support.v4.app.Fragment;

import com.github.pockethub.R;
import com.github.pockethub.ui.FragmentStatePagerAdapter;

import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;


public class IssueDashboardPagerAdapter extends FragmentStatePagerAdapter {

    private final Resources resources;


    public IssueDashboardPagerAdapter(final Fragment fragment) {
        super(fragment);

        resources = fragment.getResources();
    }

    @Override
    public int getCount() {
        return 4;
    }

    @Override
    public Fragment getItem(final int position) {
        String filter = null;
        switch (position) {
            case 0:
                filter = FILTER_SUBSCRIBED;
                break;
            case 1:
                filter = FILTER_ASSIGNED;
                break;
            case 2:
                filter = FILTER_CREATED;
                break;
            case 3:
                filter = FILTER_MENTIONED;
                break;
            default:
                return null;
        }
        final Map<String, String> filterData = new HashMap<>();
        filterData.put(FIELD_FILTER, filter);
        filterData.put(FIELD_SORT, SORT_UPDATED);
        filterData.put(FIELD_DIRECTION, DIRECTION_DESCENDING);
        Bundle bundle = new Bundle();
        bundle.putSerializable(ARG_FILTER, (Serializable) filterData);
        DashboardIssueFragment fragment = new DashboardIssueFragment();
        fragment.setArguments(bundle);
        return fragment;
    }

    @Override
    public CharSequence getPageTitle(final int position) {
        switch (position) {
            case 0:
                return resources.getString(R.string.tab_watched);
            case 1:
                return resources.getString(R.string.tab_assigned);
            case 2:
                return resources.getString(R.string.tab_created);
            case 3:
                return resources.getString(R.string.tab_mentioned);
            default:
                return null;
        }
    }
}

<code block>

package com.github.pockethub.ui.issue;

import android.accounts.Account;
import android.app.Activity;
import android.content.Context;
import android.util.Log;

import com.github.pockethub.R;
import com.github.pockethub.ui.ProgressDialogTask;
import com.github.pockethub.util.HtmlUtils;
import com.github.pockethub.util.ToastUtils;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.service.IssueService;


public class EditCommentTask extends ProgressDialogTask<Comment> {

    private static final String TAG = "EditCommentTask";

    private final IRepositoryIdProvider repository;

    private final Comment comment;

    @Inject
    private IssueService service;


    public EditCommentTask(final Context context,
            final IRepositoryIdProvider repository,
            final Comment comment) {
        super(context);

        this.repository = repository;
        this.comment = comment;
    }

    @Override
    protected Comment run(Account account) throws Exception {
        Comment edited = service.editComment(repository, comment);
        String formatted = HtmlUtils.format(edited.getBodyHtml()).toString();
        edited.setBodyHtml(formatted);
        return edited;
    }


    public EditCommentTask start() {
        showIndeterminate(R.string.editing_comment);

        execute();
        return this;
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception editing comment on issue", e);

        ToastUtils.show((Activity) getContext(), e.getMessage());
    }
}

<code block>

package com.github.pockethub.ui.issue;

import static android.graphics.Color.WHITE;
import static android.graphics.Typeface.DEFAULT_BOLD;
import static java.lang.Integer.MIN_VALUE;
import static java.lang.String.CASE_INSENSITIVE_ORDER;
import static java.util.Locale.US;
import android.content.res.Resources;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Rect;
import android.graphics.drawable.Drawable;
import android.graphics.drawable.GradientDrawable;
import android.graphics.drawable.LayerDrawable;
import android.graphics.drawable.PaintDrawable;
import android.text.style.DynamicDrawableSpan;
import android.widget.TextView;

import com.github.pockethub.R;
import com.github.pockethub.ui.StyledText;
import com.github.pockethub.util.ServiceUtils;

import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;

import org.eclipse.egit.github.core.Label;


public class LabelDrawableSpan extends DynamicDrawableSpan {

    private static final int PADDING_LEFT = 10;

    private static final int PADDING_RIGHT = 10;

    private static final int PADDING_TOP = 8;

    private static final int PADDING_BOTTOM = 8;

    private static class LabelDrawable extends PaintDrawable {

        private final String name;

        private final float height;

        private final float paddingLeft;

        private final float textHeight;

        private final int textColor;

        private final LayerDrawable layers;


        public LabelDrawable(final float paddingLeft, final float textHeight,
                final Rect bounds, final Resources resources,
                final float textSize, final String name, final int bg) {
            this.paddingLeft = paddingLeft;
            this.textHeight = textHeight;
            this.name = name;
            height = bounds.height();

            float[] hsv = new float[3];
            Color.colorToHSV(bg, hsv);
            if ((hsv[2] > 0.6 && hsv[1] < 0.4)
                    || (hsv[2] > 0.7 && hsv[0] > 40 && hsv[0] < 200)) {
                hsv[2] = 0.4F;
                textColor = Color.HSVToColor(hsv);
            } else
                textColor = WHITE;

            layers = (LayerDrawable) resources
                    .getDrawable(R.drawable.label_background);
            ((GradientDrawable) ((LayerDrawable) layers
                    .findDrawableByLayerId(R.id.item_outer_layer))
                    .findDrawableByLayerId(R.id.item_outer)).setColor(bg);
            ((GradientDrawable) ((LayerDrawable) layers
                    .findDrawableByLayerId(R.id.item_inner_layer))
                    .findDrawableByLayerId(R.id.item_inner)).setColor(bg);
            ((GradientDrawable) layers.findDrawableByLayerId(R.id.item_bg))
                    .setColor(bg);

            Paint p = getPaint();
            p.setAntiAlias(true);
            p.setColor(resources.getColor(android.R.color.transparent));
            p.setTypeface(DEFAULT_BOLD);
            p.setTextSize(textSize);

            layers.setBounds(bounds);
            setBounds(bounds);
        }

        @Override
        public void draw(final Canvas canvas) {
            super.draw(canvas);

            layers.draw(canvas);

            final Paint paint = getPaint();
            final int original = paint.getColor();

            paint.setColor(textColor);
            canvas.drawText(name, paddingLeft, height
                    - ((height - textHeight) / 2), paint);

            paint.setColor(original);
        }
    }


    public static void setText(final TextView view,
            final Collection<Label> labels) {
        final Label[] sortedLabels = labels.toArray(new Label[labels.size()]);
        Arrays.sort(sortedLabels, new Comparator<Label>() {

            @Override
            public int compare(final Label lhs, final Label rhs) {
                return CASE_INSENSITIVE_ORDER.compare(lhs.getName(),
                        rhs.getName());
            }
        });
        setText(view, sortedLabels);
    }


    public static void setText(final TextView view, final Label label) {
        setText(view, new Label[] { label });
    }

    private static void setText(final TextView view, final Label[] labels) {
        final Resources resources = view.getResources();
        final float paddingTop = ServiceUtils.getPixels(resources, PADDING_TOP);
        final float paddingLeft = ServiceUtils.getPixels(resources,
                PADDING_LEFT);
        final float paddingRight = ServiceUtils.getPixels(resources,
                PADDING_RIGHT);
        final float paddingBottom = ServiceUtils.getPixels(resources,
                PADDING_BOTTOM);

        Paint p = new Paint();
        p.setTypeface(DEFAULT_BOLD);
        p.setTextSize(view.getTextSize());

        final Rect textBounds = new Rect();
        String[] names = new String[labels.length];
        int[] nameWidths = new int[labels.length];
        int textHeight = MIN_VALUE;
        for (int i = 0; i < labels.length; i++) {
            String name = labels[i].getName().toUpperCase(US);
            textBounds.setEmpty();
            p.getTextBounds(name, 0, name.length(), textBounds);
            names[i] = name;
            textHeight = Math.max(textBounds.height(), textHeight);
            nameWidths[i] = textBounds.width();
        }

        final float textSize = view.getTextSize();
        final StyledText text = new StyledText();
        for (int i = 0; i < labels.length; i++) {
            Rect bounds = new Rect();
            bounds.right = Math.round(nameWidths[i] + paddingLeft
                    + paddingRight + 0.5F);
            bounds.bottom = Math.round(textHeight + paddingTop + paddingBottom
                    + 0.5F);

            text.append('\uFFFC', new LabelDrawableSpan(resources, textSize,
                    labels[i].getColor(), paddingLeft, textHeight, bounds,
                    names[i]));

            if (i + 1 < labels.length)
                text.append(' ');
        }
        view.setText(text);
    }

    private final Resources resources;

    private final float textSize;

    private final String name;

    private final int color;

    private final float textHeight;

    private final float paddingLeft;

    private final Rect bounds;


    public LabelDrawableSpan(final Resources resources, final float textSize,
            final String color, final float paddingLeft,
            final float textHeight, final Rect bounds, final String name) {
        this.resources = resources;
        this.textSize = textSize;
        this.color = Color.parseColor('#' + color);
        this.paddingLeft = paddingLeft;
        this.textHeight = textHeight;
        this.bounds = bounds;
        this.name = name;
    }

    @Override
    public Drawable getDrawable() {
        return new LabelDrawable(paddingLeft, textHeight, bounds, resources,
                textSize, name, color);
    }
}

<code block>

package com.github.pockethub.ui.issue;

import static java.lang.String.CASE_INSENSITIVE_ORDER;
import android.accounts.Account;
import android.util.Log;

import com.github.pockethub.R;
import com.github.pockethub.ui.DialogFragmentActivity;
import com.github.pockethub.ui.ProgressDialogTask;
import com.github.pockethub.util.ToastUtils;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.Label;
import org.eclipse.egit.github.core.service.LabelService;


public class LabelsDialog {

    private static final String TAG = "LabelsDialog";

    private final LabelService service;

    private final int requestCode;

    private final DialogFragmentActivity activity;

    private final IRepositoryIdProvider repository;

    private Map<String, Label> labels;


    public LabelsDialog(final DialogFragmentActivity activity,
            final int requestCode, final IRepositoryIdProvider repository,
            final LabelService service) {
        this.activity = activity;
        this.requestCode = requestCode;
        this.repository = repository;
        this.service = service;
    }

    private void load(final Collection<Label> selectedLabels) {
        new ProgressDialogTask<List<Label>>(activity) {

            @Override
            public List<Label> run(Account account) throws Exception {
                List<Label> repositoryLabels = service.getLabels(repository);
                Map<String, Label> loadedLabels = new TreeMap<>(
                        CASE_INSENSITIVE_ORDER);
                for (Label label : repositoryLabels)
                    loadedLabels.put(label.getName(), label);
                labels = loadedLabels;
                return repositoryLabels;
            }

            @Override
            protected void onSuccess(List<Label> all) throws Exception {
                super.onSuccess(all);

                show(selectedLabels);
            }

            @Override
            protected void onException(Exception e) throws RuntimeException {
                super.onException(e);

                Log.d(TAG, "Exception loading labels", e);
                ToastUtils.show(activity, e, R.string.error_labels_load);
            }

            @Override
            public void execute() {
                showIndeterminate(R.string.loading_labels);

                super.execute();
            }
        }.execute();
    }


    public void show(Collection<Label> selectedLabels) {
        if (labels == null) {
            load(selectedLabels);
            return;
        }

        final ArrayList<Label> names = new ArrayList<>(labels.values());
        final boolean[] checked = new boolean[names.size()];
        if (selectedLabels != null && !selectedLabels.isEmpty()) {
            Set<String> selectedNames = new HashSet<>();
            for (Label label : selectedLabels)
                selectedNames.add(label.getName());
            for (int i = 0; i < checked.length; i++)
                if (selectedNames.contains(names.get(i).getName()))
                    checked[i] = true;
        }
        LabelsDialogFragment.show(activity, requestCode,
                activity.getString(R.string.select_labels), null, names, checked);
    }
}

<code block>

package com.github.pockethub.ui.issue;

import static android.view.View.GONE;
import static android.view.View.VISIBLE;
import static com.github.pockethub.Intents.EXTRA_ISSUE;
import static com.github.pockethub.Intents.EXTRA_REPOSITORY_NAME;
import static com.github.pockethub.Intents.EXTRA_REPOSITORY_OWNER;
import static com.github.pockethub.Intents.EXTRA_USER;
import static com.github.pockethub.RequestCodes.ISSUE_ASSIGNEE_UPDATE;
import static com.github.pockethub.RequestCodes.ISSUE_LABELS_UPDATE;
import static com.github.pockethub.RequestCodes.ISSUE_MILESTONE_UPDATE;
import android.accounts.Account;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.ActionBar;
import android.text.Editable;
import android.text.TextUtils;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.EditText;
import android.widget.ImageView;
import android.widget.LinearLayout.LayoutParams;
import android.widget.TextView;

import com.github.pockethub.Intents.Builder;
import com.github.pockethub.R;
import com.github.pockethub.accounts.AccountUtils;
import com.github.pockethub.accounts.AuthenticatedUserTask;
import com.github.pockethub.core.issue.IssueUtils;
import com.github.pockethub.ui.DialogFragmentActivity;
import com.github.pockethub.ui.StyledText;
import com.github.pockethub.ui.TextWatcherAdapter;
import com.github.pockethub.util.AvatarLoader;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.Label;
import org.eclipse.egit.github.core.Milestone;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.RepositoryId;
import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.service.CollaboratorService;
import org.eclipse.egit.github.core.service.LabelService;
import org.eclipse.egit.github.core.service.MilestoneService;


public class EditIssueActivity extends DialogFragmentActivity {


    public static Intent createIntent(Repository repository) {
        return createIntent(null, repository.getOwner().getLogin(),
            repository.getName(), repository.getOwner());
    }


    public static Intent createIntent(final Issue issue,
        final String repositoryOwner, final String repositoryName,
        final User user) {
        Builder builder = new Builder("repo.issues.edit.VIEW");
        if (user != null)
            builder.add(EXTRA_USER, user);
        builder.add(EXTRA_REPOSITORY_NAME, repositoryName);
        builder.add(EXTRA_REPOSITORY_OWNER, repositoryOwner);
        if (issue != null)
            builder.issue(issue);
        return builder.toIntent();
    }

    private EditText titleText;

    private EditText bodyText;

    private View milestoneGraph;

    private TextView milestoneText;

    private View milestoneClosed;

    private ImageView assigneeAvatar;

    private TextView assigneeText;

    private TextView labelsText;

    @Inject
    private AvatarLoader avatars;

    @Inject
    private MilestoneService milestoneService;

    @Inject
    private CollaboratorService collaboratorService;

    @Inject
    private LabelService labelService;

    private Issue issue;

    private RepositoryId repository;

    private MenuItem saveItem;

    private MilestoneDialog milestoneDialog;

    private AssigneeDialog assigneeDialog;

    private LabelsDialog labelsDialog;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.issue_edit);

        titleText = finder.find(R.id.et_issue_title);
        bodyText = finder.find(R.id.et_issue_body);
        milestoneGraph = finder.find(R.id.ll_milestone_graph);
        milestoneText = finder.find(R.id.tv_milestone);
        milestoneClosed = finder.find(R.id.v_closed);
        assigneeAvatar = finder.find(R.id.iv_assignee_avatar);
        assigneeText = finder.find(R.id.tv_assignee_name);
        labelsText = finder.find(R.id.tv_labels);

        checkCollaboratorStatus();

        Intent intent = getIntent();

        if (savedInstanceState != null)
            issue = (Issue) savedInstanceState.getSerializable(EXTRA_ISSUE);
        if (issue == null)
            issue = (Issue) intent.getSerializableExtra(EXTRA_ISSUE);
        if (issue == null)
            issue = new Issue();

        repository = RepositoryId.create(
            intent.getStringExtra(EXTRA_REPOSITORY_OWNER),
            intent.getStringExtra(EXTRA_REPOSITORY_NAME));

        setSupportActionBar((android.support.v7.widget.Toolbar) findViewById(R.id.toolbar));

        ActionBar actionBar = getSupportActionBar();
        if (issue.getNumber() > 0)
            if (IssueUtils.isPullRequest(issue))
                actionBar.setTitle(getString(R.string.pull_request_title)
                    + issue.getNumber());
            else
                actionBar.setTitle(getString(R.string.issue_title)
                    + issue.getNumber());
        else
            actionBar.setTitle(R.string.new_issue);
        actionBar.setSubtitle(repository.generateId());
        avatars.bind(actionBar, (User) intent.getSerializableExtra(EXTRA_USER));

        titleText.addTextChangedListener(new TextWatcherAdapter() {

            @Override
            public void afterTextChanged(Editable s) {
                updateSaveMenu(s);
            }
        });

        updateSaveMenu();
        titleText.setText(issue.getTitle());
        bodyText.setText(issue.getBody());
    }

    @Override
    public void onDialogResult(int requestCode, int resultCode, Bundle arguments) {
        if (RESULT_OK != resultCode)
            return;

        switch (requestCode) {
            case ISSUE_MILESTONE_UPDATE:
                issue.setMilestone(MilestoneDialogFragment.getSelected(arguments));
                updateMilestone();
                break;
            case ISSUE_ASSIGNEE_UPDATE:
                User assignee = AssigneeDialogFragment.getSelected(arguments);
                if (assignee != null)
                    issue.setAssignee(assignee);
                else
                    issue.setAssignee(new User().setLogin(""));
                updateAssignee();
                break;
            case ISSUE_LABELS_UPDATE:
                issue.setLabels(LabelsDialogFragment.getSelected(arguments));
                updateLabels();
                break;
        }
    }

    private void showMainContent() {
        finder.find(R.id.sv_issue_content).setVisibility(View.VISIBLE);
        finder.find(R.id.pb_loading).setVisibility(View.GONE);
    }

    private void showCollaboratorOptions() {
        finder.find(R.id.tv_milestone_label).setVisibility(View.VISIBLE);
        finder.find(R.id.ll_milestone).setVisibility(View.VISIBLE);
        finder.find(R.id.tv_labels_label).setVisibility(View.VISIBLE);
        finder.find(R.id.ll_labels).setVisibility(View.VISIBLE);
        finder.find(R.id.tv_assignee_label).setVisibility(View.VISIBLE);
        finder.find(R.id.ll_assignee).setVisibility(View.VISIBLE);

        finder.onClick(R.id.ll_milestone, new OnClickListener() {

            @Override
            public void onClick(View v) {
                if (milestoneDialog == null)
                    milestoneDialog = new MilestoneDialog(
                        EditIssueActivity.this, ISSUE_MILESTONE_UPDATE,
                        repository, milestoneService);
                milestoneDialog.show(issue.getMilestone());
            }
        });

        finder.onClick(R.id.ll_assignee, new OnClickListener() {

            @Override
            public void onClick(View v) {
                if (assigneeDialog == null)
                    assigneeDialog = new AssigneeDialog(EditIssueActivity.this,
                        ISSUE_ASSIGNEE_UPDATE, repository,
                        collaboratorService);
                assigneeDialog.show(issue.getAssignee());
            }
        });

        finder.onClick(R.id.ll_labels, new OnClickListener() {

            @Override
            public void onClick(View v) {
                if (labelsDialog == null)
                    labelsDialog = new LabelsDialog(EditIssueActivity.this,
                        ISSUE_LABELS_UPDATE, repository, labelService);
                labelsDialog.show(issue.getLabels());
            }
        });

        updateAssignee();
        updateLabels();
        updateMilestone();
    }

    private void updateMilestone() {
        Milestone milestone = issue.getMilestone();
        if (milestone != null) {
            milestoneText.setText(milestone.getTitle());
            float closed = milestone.getClosedIssues();
            float total = closed + milestone.getOpenIssues();
            if (total > 0) {
                ((LayoutParams) milestoneClosed.getLayoutParams()).weight = closed
                    / total;
                milestoneClosed.setVisibility(VISIBLE);
            } else
                milestoneClosed.setVisibility(GONE);
            milestoneGraph.setVisibility(VISIBLE);
        } else {
            milestoneText.setText(R.string.none);
            milestoneGraph.setVisibility(GONE);
        }
    }

    private void updateAssignee() {
        User assignee = issue.getAssignee();
        String login = assignee != null ? assignee.getLogin() : null;
        if (!TextUtils.isEmpty(login)) {
            assigneeText.setText(new StyledText().bold(login));
            assigneeAvatar.setVisibility(VISIBLE);
            avatars.bind(assigneeAvatar, assignee);
        } else {
            assigneeAvatar.setVisibility(GONE);
            assigneeText.setText(R.string.unassigned);
        }
    }

    private void updateLabels() {
        List<Label> labels = issue.getLabels();
        if (labels != null && !labels.isEmpty())
            LabelDrawableSpan.setText(labelsText, labels);
        else
            labelsText.setText(R.string.none);
    }

    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);

        outState.putSerializable(EXTRA_ISSUE, issue);
    }

    private void updateSaveMenu() {
        if (titleText != null)
            updateSaveMenu(titleText.getText());
    }

    private void updateSaveMenu(final CharSequence text) {
        if (saveItem != null)
            saveItem.setEnabled(!TextUtils.isEmpty(text));
    }

    @Override
    public boolean onCreateOptionsMenu(Menu options) {
        getMenuInflater().inflate(R.menu.issue_edit, options);
        saveItem = options.findItem(R.id.m_apply);
        updateSaveMenu();
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.m_apply:
                issue.setTitle(titleText.getText().toString());
                issue.setBody(bodyText.getText().toString());
                if (issue.getNumber() > 0)
                    new EditIssueTask(this, repository, issue) {

                        @Override
                        protected void onSuccess(Issue editedIssue)
                            throws Exception {
                            super.onSuccess(editedIssue);

                            Intent intent = new Intent();
                            intent.putExtra(EXTRA_ISSUE, editedIssue);
                            setResult(RESULT_OK, intent);
                            finish();
                        }
                    }.edit();
                else
                    new CreateIssueTask(this, repository, issue) {

                        @Override
                        protected void onSuccess(Issue created) throws Exception {
                            super.onSuccess(created);

                            Intent intent = new Intent();
                            intent.putExtra(EXTRA_ISSUE, created);
                            setResult(RESULT_OK, intent);
                            finish();
                        }

                    }.create();
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    private void checkCollaboratorStatus() {
        new AuthenticatedUserTask<Boolean>(this) {

            @Override
            public Boolean run(Account account) throws Exception {
                return collaboratorService.isCollaborator(
                    repository, AccountUtils.getLogin(EditIssueActivity.this));
            }

            @Override
            protected void onSuccess(Boolean isCollaborator) throws Exception {
                super.onSuccess(isCollaborator);

                showMainContent();
                if (isCollaborator)
                    showCollaboratorOptions();
            }

            @Override
            protected void onException(Exception e) throws RuntimeException {
                super.onException(e);

                showMainContent();
            }
        }.execute();
    }
}

<code block>

package com.github.pockethub.ui.issue;

import static android.view.View.GONE;
import static com.github.pockethub.Intents.EXTRA_ISSUE_FILTER;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.ActionBar;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.ImageView;
import android.widget.RadioButton;
import android.widget.TextView;

import com.github.pockethub.Intents.Builder;
import com.github.pockethub.R;
import com.github.pockethub.core.issue.IssueFilter;
import com.github.pockethub.ui.DialogFragmentActivity;
import com.github.pockethub.util.AvatarLoader;
import com.google.inject.Inject;

import java.util.Set;

import org.eclipse.egit.github.core.Label;
import org.eclipse.egit.github.core.Milestone;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.service.CollaboratorService;
import org.eclipse.egit.github.core.service.LabelService;
import org.eclipse.egit.github.core.service.MilestoneService;


public class EditIssuesFilterActivity extends DialogFragmentActivity {


    public static Intent createIntent(IssueFilter filter) {
        return new Builder("repo.issues.filter.VIEW").add(EXTRA_ISSUE_FILTER,
            filter).toIntent();
    }

    private static final int REQUEST_LABELS = 1;

    private static final int REQUEST_MILESTONE = 2;

    private static final int REQUEST_ASSIGNEE = 3;

    @Inject
    private CollaboratorService collaborators;

    @Inject
    private MilestoneService milestones;

    @Inject
    private LabelService labels;

    @Inject
    private AvatarLoader avatars;

    private LabelsDialog labelsDialog;

    private MilestoneDialog milestoneDialog;

    private AssigneeDialog assigneeDialog;

    private IssueFilter filter;

    private TextView labelsText;

    private TextView milestoneText;

    private TextView assigneeText;

    private ImageView avatarView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.issues_filter_edit);

        labelsText = finder.find(R.id.tv_labels);
        milestoneText = finder.find(R.id.tv_milestone);
        assigneeText = finder.find(R.id.tv_assignee);
        avatarView = finder.find(R.id.iv_avatar);

        if (savedInstanceState != null)
            filter = (IssueFilter) savedInstanceState
                .getSerializable(EXTRA_ISSUE_FILTER);

        if (filter == null)
            filter = (IssueFilter) getIntent().getSerializableExtra(
                EXTRA_ISSUE_FILTER);

        final Repository repository = filter.getRepository();

        setSupportActionBar((android.support.v7.widget.Toolbar) findViewById(R.id.toolbar));

        ActionBar actionBar = getSupportActionBar();
        actionBar.setTitle(R.string.filter_issues_title);
        actionBar.setSubtitle(repository.generateId());
        avatars.bind(actionBar, repository.getOwner());

        OnClickListener assigneeListener = new OnClickListener() {

            public void onClick(View v) {
                if (assigneeDialog == null)
                    assigneeDialog = new AssigneeDialog(
                        EditIssuesFilterActivity.this, REQUEST_ASSIGNEE,
                        repository, collaborators);
                assigneeDialog.show(filter.getAssignee());
            }
        };

        findViewById(R.id.tv_assignee_label)
            .setOnClickListener(assigneeListener);
        assigneeText.setOnClickListener(assigneeListener);

        OnClickListener milestoneListener = new OnClickListener() {

            public void onClick(View v) {
                if (milestoneDialog == null)
                    milestoneDialog = new MilestoneDialog(
                        EditIssuesFilterActivity.this, REQUEST_MILESTONE,
                        repository, milestones);
                milestoneDialog.show(filter.getMilestone());
            }
        };

        findViewById(R.id.tv_milestone_label)
            .setOnClickListener(milestoneListener);
        milestoneText.setOnClickListener(milestoneListener);

        OnClickListener labelsListener = new OnClickListener() {

            public void onClick(View v) {
                if (labelsDialog == null)
                    labelsDialog = new LabelsDialog(
                        EditIssuesFilterActivity.this, REQUEST_LABELS,
                        repository, labels);
                labelsDialog.show(filter.getLabels());
            }
        };

        findViewById(R.id.tv_labels_label)
            .setOnClickListener(labelsListener);
        labelsText.setOnClickListener(labelsListener);

        updateAssignee();
        updateMilestone();
        updateLabels();

        RadioButton openButton = (RadioButton) findViewById(R.id.rb_open);

        openButton.setOnCheckedChangeListener(new OnCheckedChangeListener() {

            public void onCheckedChanged(CompoundButton buttonView,
                boolean isChecked) {
                if (isChecked)
                    filter.setOpen(true);
            }
        });

        RadioButton closedButton = (RadioButton) findViewById(R.id.rb_closed);

        closedButton.setOnCheckedChangeListener(new OnCheckedChangeListener() {

            public void onCheckedChanged(CompoundButton buttonView,
                boolean isChecked) {
                if (isChecked)
                    filter.setOpen(false);
            }
        });

        if (filter.isOpen())
            openButton.setChecked(true);
        else
            closedButton.setChecked(true);
    }

    @Override
    public boolean onCreateOptionsMenu(Menu options) {
        getMenuInflater().inflate(R.menu.issue_filter, options);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.m_apply:
                Intent intent = new Intent();
                intent.putExtra(EXTRA_ISSUE_FILTER, filter);
                setResult(RESULT_OK, intent);
                finish();
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);

        outState.putSerializable(EXTRA_ISSUE_FILTER, filter);
    }

    private void updateLabels() {
        Set<Label> selected = filter.getLabels();
        if (selected != null)
            LabelDrawableSpan.setText(labelsText, selected);
        else
            labelsText.setText(R.string.none);
    }

    private void updateMilestone() {
        Milestone selected = filter.getMilestone();
        if (selected != null)
            milestoneText.setText(selected.getTitle());
        else
            milestoneText.setText(R.string.none);
    }

    private void updateAssignee() {
        User selected = filter.getAssignee();
        if (selected != null) {
            avatars.bind(avatarView, selected);
            assigneeText.setText(selected.getLogin());
        } else {
            avatarView.setVisibility(GONE);
            assigneeText.setText(R.string.assignee_anyone);
        }
    }

    @Override
    public void onDialogResult(int requestCode, int resultCode, Bundle arguments) {
        if (RESULT_OK != resultCode)
            return;

        switch (requestCode) {
            case REQUEST_LABELS:
                filter.setLabels(LabelsDialogFragment.getSelected(arguments));
                updateLabels();
                break;
            case REQUEST_MILESTONE:
                filter.setMilestone(MilestoneDialogFragment.getSelected(arguments));
                updateMilestone();
                break;
            case REQUEST_ASSIGNEE:
                filter.setAssignee(AssigneeDialogFragment.getSelected(arguments));
                updateAssignee();
                break;
        }
    }
}

<code block>
package com.github.pockethub.ui.issue;

import static java.lang.String.CASE_INSENSITIVE_ORDER;
import android.os.Bundle;
import android.support.v4.content.Loader;
import android.view.View;
import android.widget.ListView;

import com.github.kevinsawicki.wishlist.AsyncLoader;
import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.pockethub.R;
import com.github.pockethub.core.issue.IssueFilter;
import com.github.pockethub.persistence.AccountDataManager;
import com.github.pockethub.ui.ItemListFragment;
import com.github.pockethub.util.AvatarLoader;
import com.google.inject.Inject;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;


public class FilterListFragment extends ItemListFragment<IssueFilter> implements
        Comparator<IssueFilter> {

    @Inject
    private AccountDataManager cache;

    @Inject
    private AvatarLoader avatars;

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        setEmptyText(R.string.no_bookmarks);
    }

    @Override
    public Loader<List<IssueFilter>> onCreateLoader(int id, Bundle args) {
        return new AsyncLoader<List<IssueFilter>>(getActivity()) {

            @Override
            public List<IssueFilter> loadInBackground() {
                List<IssueFilter> filters = new ArrayList<>(
                        cache.getIssueFilters());
                Collections.sort(filters, FilterListFragment.this);
                return filters;
            }
        };
    }

    @Override
    public void onListItemClick(ListView l, View v, int position, long id) {
        IssueFilter filter = (IssueFilter) l.getItemAtPosition(position);
        startActivity(IssueBrowseActivity.createIntent(filter));
    }

    @Override
    public void onResume() {
        super.onResume();

        refresh();
    }

    @Override
    protected int getErrorMessage(Exception exception) {
        return R.string.error_bookmarks_load;
    }

    @Override
    protected SingleTypeAdapter<IssueFilter> createAdapter(
            List<IssueFilter> items) {
        return new FilterListAdapter(getActivity().getLayoutInflater(),
                items.toArray(new IssueFilter[items.size()]), avatars);
    }

    @Override
    public int compare(final IssueFilter lhs, final IssueFilter rhs) {
        int compare = CASE_INSENSITIVE_ORDER.compare(lhs.getRepository()
                .generateId(), rhs.getRepository().generateId());
        if (compare == 0)
            compare = CASE_INSENSITIVE_ORDER.compare(
                    lhs.toDisplay().toString(), rhs.toDisplay().toString());
        return compare;
    }
}

<code block>

package com.github.pockethub.ui.issue;

import static com.github.pockethub.Intents.EXTRA_ISSUE_NUMBER;
import static com.github.pockethub.Intents.EXTRA_IS_COLLABORATOR;
import static com.github.pockethub.Intents.EXTRA_IS_OWNER;
import static com.github.pockethub.Intents.EXTRA_REPOSITORY_NAME;
import static com.github.pockethub.Intents.EXTRA_REPOSITORY_OWNER;
import static com.github.pockethub.Intents.EXTRA_USER;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v7.app.ActionBarActivity;
import android.util.SparseArray;
import android.view.ViewGroup;

import com.github.pockethub.core.issue.IssueStore;
import com.github.pockethub.ui.FragmentStatePagerAdapter;

import java.util.List;

import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.RepositoryId;
import org.eclipse.egit.github.core.RepositoryIssue;
import org.eclipse.egit.github.core.User;


public class IssuesPagerAdapter extends FragmentStatePagerAdapter {

    private final Repository repo;

    private final List<RepositoryId> repos;

    private final int[] issues;

    private final SparseArray<IssueFragment> fragments = new SparseArray<>();

    private final IssueStore store;

    private boolean isCollaborator;

    private boolean isOwner;


    public IssuesPagerAdapter(ActionBarActivity activity,
            List<RepositoryId> repoIds, int[] issueNumbers,
            IssueStore issueStore, boolean collaborator, boolean owner) {
        super(activity);

        repos = repoIds;
        repo = null;
        issues = issueNumbers;
        store = issueStore;
        isCollaborator = collaborator;
        isOwner = owner;
    }


    public IssuesPagerAdapter(ActionBarActivity activity,
            Repository repository, int[] issueNumbers,
            boolean collaborator, boolean owner) {
        super(activity);

        repos = null;
        repo = repository;
        issues = issueNumbers;
        store = null;
        isCollaborator = collaborator;
        isOwner = owner;
    }

    @Override
    public Fragment getItem(int position) {
        IssueFragment fragment = new IssueFragment();
        Bundle args = new Bundle();
        if (repo != null) {
            args.putString(EXTRA_REPOSITORY_NAME, repo.getName());
            User owner = repo.getOwner();
            args.putString(EXTRA_REPOSITORY_OWNER, owner.getLogin());
            args.putSerializable(EXTRA_USER, owner);
        } else {
            RepositoryId repo = repos.get(position);
            args.putString(EXTRA_REPOSITORY_NAME, repo.getName());
            args.putString(EXTRA_REPOSITORY_OWNER, repo.getOwner());
            RepositoryIssue issue = store.getIssue(repo, issues[position]);
            if (issue != null && issue.getUser() != null) {
                Repository fullRepo = issue.getRepository();
                if (fullRepo != null && fullRepo.getOwner() != null)
                    args.putSerializable(EXTRA_USER, fullRepo.getOwner());
            }
        }
        args.putInt(EXTRA_ISSUE_NUMBER, issues[position]);
        args.putBoolean(EXTRA_IS_COLLABORATOR, isCollaborator);
        args.putBoolean(EXTRA_IS_OWNER, isOwner);
        fragment.setArguments(args);
        return fragment;
    }

    @Override
    public void destroyItem(ViewGroup container, int position, Object object) {
        super.destroyItem(container, position, object);

        fragments.remove(position);
    }

    @Override
    public Object instantiateItem(ViewGroup container, int position) {
        Object fragment = super.instantiateItem(container, position);
        if (fragment instanceof IssueFragment)
            fragments.put(position, (IssueFragment) fragment);
        return fragment;
    }

    @Override
    public int getCount() {
        return issues.length;
    }


    public IssuesPagerAdapter onDialogResult(int position, int requestCode,
            int resultCode, Bundle arguments) {
        IssueFragment fragment = fragments.get(position);
        if (fragment != null)
            fragment.onDialogResult(requestCode, resultCode, arguments);
        return this;
    }
}

<code block>

package com.github.pockethub.ui.issue;

import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
import static android.content.Intent.FLAG_ACTIVITY_SINGLE_TOP;
import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.support.annotation.Nullable;
import android.view.LayoutInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemLongClickListener;

import com.github.pockethub.Intents.Builder;
import com.github.pockethub.R;
import com.github.pockethub.RequestFuture;
import com.github.pockethub.core.issue.IssueFilter;
import com.github.pockethub.persistence.AccountDataManager;
import com.github.pockethub.ui.ConfirmDialogFragment;
import com.github.pockethub.ui.DialogFragment;
import com.github.pockethub.ui.MainActivity;
import com.google.inject.Inject;


public class FiltersViewFragment extends DialogFragment implements
    OnItemLongClickListener {


    public static Intent createIntent() {
        return new Builder("repo.issues.filters.VIEW").toIntent();
    }

    private static final String ARG_FILTER = "filter";

    private static final int REQUEST_DELETE = 1;

    @Inject
    private AccountDataManager cache;

    private FilterListFragment fragment;


    @Override
    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container,
        @Nullable Bundle savedInstanceState) {
        return inflater.inflate(R.layout.issues_filter_list, null);
    }

    @Override
    public void onViewCreated(View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        fragment = (FilterListFragment) getChildFragmentManager().findFragmentById(android.R.id.list);
        fragment.getListView().setOnItemLongClickListener(this);
    }

    @Override
    public void onDialogResult(int requestCode, int resultCode, Bundle arguments) {
        if (requestCode == REQUEST_DELETE && resultCode == Activity.RESULT_OK) {
            IssueFilter filter = (IssueFilter) arguments
                .getSerializable(ARG_FILTER);
            cache.removeIssueFilter(filter, new RequestFuture<IssueFilter>() {

                @Override
                public void success(IssueFilter response) {
                    if (fragment != null)
                        fragment.refresh();
                }
            });
            return;
        }

        super.onDialogResult(requestCode, resultCode, arguments);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                Intent intent = new Intent(getActivity(), MainActivity.class);
                intent.addFlags(FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_SINGLE_TOP);
                startActivity(intent);
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    public boolean onItemLongClick(AdapterView<?> parent, View view,
        int position, long id) {
        IssueFilter filter = (IssueFilter) parent.getItemAtPosition(position);
        Bundle args = new Bundle();
        args.putSerializable(ARG_FILTER, filter);
        ConfirmDialogFragment.show(getActivity(), REQUEST_DELETE,
            getString(R.string.confirm_bookmark_delete_title),
            getString(R.string.confirm_bookmark_delete_message), args);
        return true;
    }
}

<code block>

package com.github.pockethub.ui.issue;

import static com.github.pockethub.RequestCodes.ISSUE_ASSIGNEE_UPDATE;
import android.accounts.Account;

import com.github.pockethub.R;
import com.github.pockethub.core.issue.IssueStore;
import com.github.pockethub.ui.DialogFragmentActivity;
import com.github.pockethub.ui.ProgressDialogTask;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.service.CollaboratorService;


public class EditAssigneeTask extends ProgressDialogTask<Issue> {

    @Inject
    private CollaboratorService service;

    @Inject
    private IssueStore store;

    private final AssigneeDialog assigneeDialog;

    private final IRepositoryIdProvider repositoryId;

    private final int issueNumber;

    private User assignee;


    public EditAssigneeTask(final DialogFragmentActivity activity,
            final IRepositoryIdProvider repositoryId, final int issueNumber) {
        super(activity);

        this.repositoryId = repositoryId;
        this.issueNumber = issueNumber;
        assigneeDialog = new AssigneeDialog(activity, ISSUE_ASSIGNEE_UPDATE,
                repositoryId, service);
    }


    public EditAssigneeTask prompt(User assignee) {
        assigneeDialog.show(assignee);
        return this;
    }


    public EditAssigneeTask edit(User user) {
        showIndeterminate(R.string.updating_assignee);

        this.assignee = user;

        execute();
        return this;
    }

    @Override
    protected Issue run(Account account) throws Exception {
        Issue editedIssue = new Issue();
        if (assignee != null)
            editedIssue.setAssignee(assignee);
        else
            editedIssue.setAssignee(new User().setLogin(""));
        editedIssue.setNumber(issueNumber);
        return store.editIssue(repositoryId, editedIssue);
    }
}

<code block>

package com.github.pockethub.ui.issue;

import static com.github.pockethub.Intents.EXTRA_COMMENT;
import static com.github.pockethub.Intents.EXTRA_ISSUE_NUMBER;
import static com.github.pockethub.Intents.EXTRA_REPOSITORY_NAME;
import static com.github.pockethub.Intents.EXTRA_REPOSITORY_OWNER;
import static com.github.pockethub.Intents.EXTRA_USER;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.ActionBar;

import com.github.pockethub.Intents.Builder;
import com.github.pockethub.R;
import com.github.pockethub.ui.comment.CommentPreviewPagerAdapter;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.RepositoryId;
import org.eclipse.egit.github.core.User;


public class EditCommentActivity extends
        com.github.pockethub.ui.comment.CreateCommentActivity {


    public static Intent createIntent(RepositoryId repoId, int issueNumber, Comment comment,
            User user) {
        Builder builder = new Builder("issue.comment.edit.VIEW");
        builder.repo(repoId);
        builder.add(EXTRA_COMMENT, comment);
        builder.add(EXTRA_ISSUE_NUMBER, issueNumber);
        builder.add(EXTRA_USER, user);
        return builder.toIntent();
    }

    private RepositoryId repositoryId;


    private Comment comment;

    private int issueNumber;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        comment = getSerializableExtra(EXTRA_COMMENT);
        issueNumber = getIntExtra(EXTRA_ISSUE_NUMBER);
        repositoryId = new RepositoryId(getStringExtra(EXTRA_REPOSITORY_OWNER),
                getStringExtra(EXTRA_REPOSITORY_NAME));

        super.onCreate(savedInstanceState);

        ActionBar actionBar = getSupportActionBar();
        actionBar.setTitle(getString(R.string.issue_title) + issueNumber);
        actionBar.setSubtitle(repositoryId.generateId());
        avatars.bind(actionBar, (User) getSerializableExtra(EXTRA_USER));
    }

    @Override
    protected void createComment(String comment) {
        editComment(comment);
    }


    protected void editComment(String commentText) {
        comment.setBody(commentText);

        new EditCommentTask(this, repositoryId, comment) {
            @Override
            protected void onSuccess(Comment comment) throws Exception {
                super.onSuccess(comment);

                finish(comment);
            }
        }.start();
    }

    @Override
    protected CommentPreviewPagerAdapter createAdapter() {
        CommentPreviewPagerAdapter commentPreviewPagerAdapter = new CommentPreviewPagerAdapter(this, repositoryId);
        commentPreviewPagerAdapter.setCommentText(comment != null ? comment.getBody() : null);
        return commentPreviewPagerAdapter;
    }
}

<code block>

package com.github.pockethub.ui.issue;

import static com.github.pockethub.RequestCodes.ISSUE_CLOSE;
import static com.github.pockethub.RequestCodes.ISSUE_REOPEN;
import static org.eclipse.egit.github.core.service.IssueService.STATE_CLOSED;
import static org.eclipse.egit.github.core.service.IssueService.STATE_OPEN;
import android.accounts.Account;

import com.github.pockethub.R;
import com.github.pockethub.core.issue.IssueStore;
import com.github.pockethub.ui.ConfirmDialogFragment;
import com.github.pockethub.ui.DialogFragmentActivity;
import com.github.pockethub.ui.ProgressDialogTask;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.Issue;


public class EditStateTask extends ProgressDialogTask<Issue> {

    @Inject
    private IssueStore store;

    private final IRepositoryIdProvider repositoryId;

    private final int issueNumber;

    private boolean close;


    public EditStateTask(final DialogFragmentActivity activity,
            final IRepositoryIdProvider repositoryId, final int issueNumber) {
        super(activity);

        this.repositoryId = repositoryId;
        this.issueNumber = issueNumber;
    }


    public EditStateTask confirm(boolean close) {
        if (close)
            ConfirmDialogFragment.show((DialogFragmentActivity) getContext(),
                    ISSUE_CLOSE, getString(R.string.issue_confirm_close_title),
                    getString(R.string.issue_confirm_close_message));
        else
            ConfirmDialogFragment.show((DialogFragmentActivity) getContext(),
                    ISSUE_REOPEN, getString(R.string.issue_confirm_reopen_title),
                    getString(R.string.issue_confirm_reopen_message));

        return this;
    }

    @Override
    protected Issue run(Account account) throws Exception {
        Issue editedIssue = new Issue();
        editedIssue.setNumber(issueNumber);
        if (close)
            editedIssue.setState(STATE_CLOSED);
        else
            editedIssue.setState(STATE_OPEN);
        return store.editIssue(repositoryId, editedIssue);
    }


    public EditStateTask edit(boolean close) {
        if (close)
            showIndeterminate(R.string.closing_issue);
        else
            showIndeterminate(R.string.reopening_issue);

        this.close = close;

        execute();
        return this;
    }
}

<code block>

package com.github.pockethub.ui.issue;

import static android.app.SearchManager.APP_DATA;
import static com.github.pockethub.Intents.EXTRA_REPOSITORY;
import static org.eclipse.egit.github.core.service.IssueService.STATE_OPEN;
import android.os.Bundle;
import android.support.v4.content.Loader;
import android.view.View;
import android.widget.ListView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.pockethub.R;
import com.github.pockethub.ThrowableLoader;
import com.github.pockethub.ui.ItemListFragment;
import com.github.pockethub.util.AvatarLoader;
import com.google.inject.Inject;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.SearchIssue;
import org.eclipse.egit.github.core.service.IssueService;


public class SearchIssueListFragment extends ItemListFragment<SearchIssue>
        implements Comparator<SearchIssue> {

    @Inject
    private IssueService service;

    @Inject
    private AvatarLoader avatars;

    private Repository repository;

    private String query;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        Bundle appData = getActivity().getIntent().getBundleExtra(APP_DATA);
        if (appData != null)
            repository = (Repository) appData.getSerializable(EXTRA_REPOSITORY);
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        setEmptyText(R.string.no_issues);
    }


    public SearchIssueListFragment setQuery(final String query) {
        this.query = query;
        return this;
    }

    @Override
    public void onListItemClick(ListView l, View v, int position, long id) {
        final SearchIssue searchIssue = (SearchIssue) l
                .getItemAtPosition(position);
        Issue issue = new Issue().setNumber(searchIssue.getNumber());
        startActivity(IssuesViewActivity.createIntent(issue, repository));
    }

    @Override
    public Loader<List<SearchIssue>> onCreateLoader(int id, Bundle args) {
        return new ThrowableLoader<List<SearchIssue>>(getActivity(), items) {

            public List<SearchIssue> loadData() throws Exception {
                if (repository == null)
                    return Collections.emptyList();
                List<SearchIssue> matches = new ArrayList<>();

                matches.addAll(service.searchIssues(repository, STATE_OPEN, query));

                Collections.sort(matches, SearchIssueListFragment.this);
                return matches;
            }
        };
    }

    @Override
    protected int getErrorMessage(Exception exception) {
        return R.string.error_issues_load;
    }

    @Override
    protected SingleTypeAdapter<SearchIssue> createAdapter(
            List<SearchIssue> items) {
        return new SearchIssueListAdapter(getActivity().getLayoutInflater(),
                items.toArray(new SearchIssue[items.size()]), avatars);
    }

    @Override
    public int compare(SearchIssue lhs, SearchIssue rhs) {
        return rhs.getNumber() - lhs.getNumber();
    }
}

<code block>

package com.github.pockethub.ui.issue;

import android.accounts.Account;
import android.app.Activity;
import android.content.Context;
import android.util.Log;

import com.github.pockethub.R;
import com.github.pockethub.ui.ProgressDialogTask;
import com.github.pockethub.util.HtmlUtils;
import com.github.pockethub.util.ToastUtils;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.service.IssueService;


public class CreateCommentTask extends ProgressDialogTask<Comment> {

    private static final String TAG = "CreateCommentTask";

    private final IRepositoryIdProvider repository;

    private final int issueNumber;

    private final String comment;

    @Inject
    private IssueService service;


    public CreateCommentTask(final Context context,
            final IRepositoryIdProvider repository, final int issueNumber,
            final String comment) {
        super(context);

        this.repository = repository;
        this.issueNumber = issueNumber;
        this.comment = comment;
    }

    @Override
    protected Comment run(Account account) throws Exception {
        Comment created = service.createComment(repository, issueNumber,
                comment);
        String formatted = HtmlUtils.format(created.getBodyHtml()).toString();
        created.setBodyHtml(formatted);
        return created;
    }


    public CreateCommentTask start() {
        showIndeterminate(R.string.creating_comment);

        execute();
        return this;
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception creating comment on issue", e);

        ToastUtils.show((Activity) getContext(), e.getMessage());
    }
}

<code block>

package com.github.pockethub.ui.issue;

import static android.app.Activity.RESULT_OK;
import static android.view.View.GONE;
import static android.view.View.VISIBLE;
import static com.github.pockethub.Intents.EXTRA_ISSUE;
import static com.github.pockethub.Intents.EXTRA_ISSUE_FILTER;
import static com.github.pockethub.Intents.EXTRA_REPOSITORY;
import static com.github.pockethub.RequestCodes.ISSUE_CREATE;
import static com.github.pockethub.RequestCodes.ISSUE_FILTER_EDIT;
import static com.github.pockethub.RequestCodes.ISSUE_VIEW;
import android.app.Activity;
import android.app.SearchManager;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.support.v4.view.MenuItemCompat;
import android.support.v7.widget.SearchView;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.widget.ImageView;
import android.widget.ListView;
import android.widget.TextView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.pockethub.R;
import com.github.pockethub.RequestFuture;
import com.github.pockethub.core.ResourcePager;
import com.github.pockethub.core.issue.IssueFilter;
import com.github.pockethub.core.issue.IssuePager;
import com.github.pockethub.core.issue.IssueStore;
import com.github.pockethub.persistence.AccountDataManager;
import com.github.pockethub.ui.PagedItemFragment;
import com.github.pockethub.util.AvatarLoader;
import com.github.pockethub.util.ToastUtils;
import com.google.inject.Inject;

import java.util.Collection;
import java.util.List;

import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.Label;
import org.eclipse.egit.github.core.Milestone;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.client.PageIterator;
import org.eclipse.egit.github.core.service.IssueService;


public class IssuesFragment extends PagedItemFragment<Issue> {

    @Inject
    private AccountDataManager cache;

    @Inject
    private IssueService service;

    @Inject
    private IssueStore store;

    private IssueFilter filter;

    private Repository repository;

    private View filterHeader;

    private TextView state;

    private ImageView assigneeAvatar;

    private View assigneeArea;

    private TextView assignee;

    private TextView labels;

    private TextView milestone;

    @Inject
    private AvatarLoader avatars;

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);

        filter = getSerializableExtra(EXTRA_ISSUE_FILTER);
        repository = getSerializableExtra(EXTRA_REPOSITORY);
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        if (filter == null)
            filter = new IssueFilter(repository);
    }

    @Override
    public void onViewCreated(View view, Bundle savedInstanceState) {
        filterHeader = getLayoutInflater(savedInstanceState).inflate(
                R.layout.issues_filter_header, null);
        state = (TextView) filterHeader.findViewById(R.id.tv_filter_state);
        labels = (TextView) filterHeader.findViewById(R.id.tv_filter_labels);
        milestone = (TextView) filterHeader
                .findViewById(R.id.tv_filter_milestone);
        assigneeArea = filterHeader.findViewById(R.id.ll_assignee);
        assignee = (TextView) filterHeader.findViewById(R.id.tv_filter_assignee);
        assigneeAvatar = (ImageView) filterHeader
                .findViewById(R.id.iv_assignee_avatar);
        updateFilterSummary();

        super.onViewCreated(view, savedInstanceState);
    }

    @Override
    protected void configureList(Activity activity, ListView listView) {
        super.configureList(activity, listView);

        getListAdapter().addHeader(filterHeader, filter, true);
    }

    private void updateFilterSummary() {
        if (filter.isOpen())
            state.setText(R.string.open_issues);
        else
            state.setText(R.string.closed_issues);

        Collection<Label> filterLabels = filter.getLabels();
        if (filterLabels != null && !filterLabels.isEmpty()) {
            LabelDrawableSpan.setText(labels, filterLabels);
            labels.setVisibility(VISIBLE);
        } else
            labels.setVisibility(GONE);

        Milestone filterMilestone = filter.getMilestone();
        if (filterMilestone != null) {
            milestone.setText(filterMilestone.getTitle());
            milestone.setVisibility(VISIBLE);
        } else
            milestone.setVisibility(GONE);

        User user = filter.getAssignee();
        if (user != null) {
            avatars.bind(assigneeAvatar, user);
            assignee.setText(user.getLogin());
            assigneeArea.setVisibility(VISIBLE);
        } else
            assigneeArea.setVisibility(GONE);
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        setEmptyText(R.string.no_issues);
    }

    @Override
    public void onListItemClick(ListView l, View v, int position, long id) {
        if (position == 0)
            startActivityForResult(
                    EditIssuesFilterActivity.createIntent(filter),
                    ISSUE_FILTER_EDIT);
        else
            startActivityForResult(
                    IssuesViewActivity.createIntent(items, repository, position
                            - getListAdapter().getHeadersCount()), ISSUE_VIEW);
    }

    @Override
    public void onCreateOptionsMenu(Menu optionsMenu, MenuInflater inflater) {
        inflater.inflate(R.menu.issues, optionsMenu);

        SearchManager searchManager = (SearchManager) getActivity().getSystemService(Context.SEARCH_SERVICE);
        MenuItem searchItem = optionsMenu.findItem(R.id.m_search);
        SearchView searchView = (SearchView) MenuItemCompat.getActionView(searchItem);
        searchView.setSearchableInfo(searchManager.getSearchableInfo(getActivity().getComponentName()));

        Bundle args = new Bundle();
        args.putSerializable(EXTRA_REPOSITORY, repository);
        searchView.setAppSearchData(args);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if (!isUsable())
            return false;
        switch (item.getItemId()) {
        case R.id.create_issue:
            startActivityForResult(EditIssueActivity.createIntent(repository),
                    ISSUE_CREATE);
            return true;
        case R.id.m_filter:
            startActivityForResult(
                    EditIssuesFilterActivity.createIntent(filter),
                    ISSUE_FILTER_EDIT);
            return true;
        case R.id.m_bookmark:
            cache.addIssueFilter(filter, new RequestFuture<IssueFilter>() {

                public void success(IssueFilter response) {
                    ToastUtils.show(getActivity(), R.string.message_filter_saved);
                }
            });
            return true;
        default:
            return super.onOptionsItemSelected(item);
        }
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (resultCode == RESULT_OK && requestCode == ISSUE_FILTER_EDIT
                && data != null) {
            IssueFilter newFilter = (IssueFilter) data
                    .getSerializableExtra(EXTRA_ISSUE_FILTER);
            if (!filter.equals(newFilter)) {
                filter = newFilter;
                updateFilterSummary();
                pager.reset();
                refreshWithProgress();
                return;
            }
        }

        if (requestCode == ISSUE_VIEW) {
            notifyDataSetChanged();
            forceRefresh();
            return;
        }

        if (requestCode == ISSUE_CREATE && resultCode == RESULT_OK) {
            Issue created = (Issue) data.getSerializableExtra(EXTRA_ISSUE);
            forceRefresh();
            startActivityForResult(
                    IssuesViewActivity.createIntent(created, repository),
                    ISSUE_VIEW);
            return;
        }

        super.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    protected ResourcePager<Issue> createPager() {
        return new IssuePager(store) {

            @Override
            public PageIterator<Issue> createIterator(int page, int size) {
                return service.pageIssues(repository, filter.toFilterMap(),
                        page, size);
            }
        };
    }

    @Override
    protected int getLoadingMessage() {
        return R.string.loading_issues;
    }

    @Override
    protected int getErrorMessage(Exception exception) {
        return R.string.error_issues_load;
    }

    @Override
    protected SingleTypeAdapter<Issue> createAdapter(List<Issue> items) {
        return new RepositoryIssueListAdapter(
                getActivity().getLayoutInflater(),
                items.toArray(new Issue[items.size()]), avatars);
    }
}

<code block>

package com.github.pockethub.ui.search;

import android.content.Context;
import android.view.LayoutInflater;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.pockethub.R;
import com.github.pockethub.core.search.SearchUser;
import com.github.pockethub.util.AvatarLoader;


public class SearchUserListAdapter extends SingleTypeAdapter<SearchUser> {

    private final AvatarLoader avatars;


    public SearchUserListAdapter(final Context context,
            final SearchUser[] elements, final AvatarLoader avatars) {
        super(LayoutInflater.from(context), R.layout.user_item);

        this.avatars = avatars;
        setItems(elements);
    }

    @Override
    public long getItemId(final int position) {
        String userId = getItem(position).getId();
        return Long.parseLong(userId.replace("user-", ""));
    }

    @Override
    protected int[] getChildViewIds() {
        return new int[] { R.id.iv_avatar, R.id.tv_login };
    }

    @Override
    protected void update(final int position, final SearchUser user) {
        setText(1, user.getLogin());
    }
}

<code block>

package com.github.pockethub.ui.search;

import android.text.TextUtils;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.TextView;

import com.github.pockethub.R;
import com.github.pockethub.ui.StyledText;
import com.github.pockethub.ui.repo.RepositoryListAdapter;
import com.github.pockethub.util.TypefaceUtils;

import org.eclipse.egit.github.core.SearchRepository;


public class SearchRepositoryListAdapter extends
        RepositoryListAdapter<SearchRepository> {


    public SearchRepositoryListAdapter(LayoutInflater inflater,
            SearchRepository[] elements) {
        super(R.layout.user_repo_item, inflater, elements);
    }

    @Override
    public long getItemId(final int position) {
        final String id = getItem(position).getId();
        return !TextUtils.isEmpty(id) ? id.hashCode() : super
                .getItemId(position);
    }

    @Override
    protected View initialize(View view) {
        view = super.initialize(view);

        TypefaceUtils.setOcticons(textView(view, 0),
                (TextView) view.findViewById(R.id.tv_forks_icon),
                (TextView) view.findViewById(R.id.tv_watchers_icon));
        return view;
    }

    @Override
    protected int[] getChildViewIds() {
        return new int[] { R.id.tv_repo_icon, R.id.tv_repo_description,
                R.id.tv_language, R.id.tv_watchers, R.id.tv_forks, R.id.tv_repo_name };
    }

    @Override
    protected void update(int position, SearchRepository repository) {
        StyledText name = new StyledText();
        name.append(repository.getOwner()).append('/');
        name.bold(repository.getName());
        setText(5, name);

        updateDetails(repository.getDescription(), repository.getLanguage(),
                repository.getWatchers(), repository.getForks(),
                repository.isPrivate(), repository.isFork(), null);
    }
}

<code block>

package com.github.pockethub.ui.search;

import static android.app.SearchManager.QUERY;
import static android.content.Intent.ACTION_SEARCH;
import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
import static android.content.Intent.FLAG_ACTIVITY_SINGLE_TOP;
import static com.github.pockethub.util.TypefaceUtils.ICON_PERSON;
import static com.github.pockethub.util.TypefaceUtils.ICON_PUBLIC;
import android.app.SearchManager;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.support.v4.app.FragmentManager;
import android.support.v4.view.MenuItemCompat;
import android.support.v7.app.ActionBar;
import android.support.v7.widget.SearchView;
import android.view.Menu;
import android.view.MenuItem;
import android.widget.ProgressBar;

import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.pockethub.R;
import com.github.pockethub.ui.MainActivity;
import com.github.pockethub.ui.TabPagerActivity;
import com.github.pockethub.util.ToastUtils;


public class SearchActivity extends TabPagerActivity<SearchPagerAdapter> {

    private ProgressBar loadingBar;

    private SearchRepositoryListFragment repoFragment;

    private SearchUserListFragment userFragment;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        loadingBar = finder.find(R.id.pb_loading);

        ActionBar actionBar = getSupportActionBar();
        actionBar.setDisplayHomeAsUpEnabled(true);

        configurePager();
        handleIntent(getIntent());
    }

    @Override
    public boolean onCreateOptionsMenu(Menu options) {
        getMenuInflater().inflate(R.menu.search, options);

        SearchManager searchManager = (SearchManager) getSystemService(Context.SEARCH_SERVICE);
        MenuItem searchItem = options.findItem(R.id.m_search);
        SearchView searchView = (SearchView) MenuItemCompat.getActionView(searchItem);
        searchView.setSearchableInfo(searchManager.getSearchableInfo(getComponentName()));

        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.m_clear:
                RepositorySearchSuggestionsProvider.clear(this);
                ToastUtils.show(this, R.string.search_history_cleared);
                return true;
            case android.R.id.home:
                Intent intent = new Intent(this, MainActivity.class);
                intent.addFlags(FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_SINGLE_TOP);
                startActivity(intent);
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    protected SearchPagerAdapter createAdapter() {
        return new SearchPagerAdapter(this);
    }

    @Override
    protected int getContentView() {
        return R.layout.tabbed_progress_pager;
    }

    @Override
    protected String getIcon(int position) {
        switch (position) {
            case 0:
                return ICON_PUBLIC;
            case 1:
                return ICON_PERSON;
            default:
                return super.getIcon(position);
        }
    }

    @Override
    protected void onNewIntent(Intent intent) {
        setIntent(intent);
        handleIntent(intent);
    }

    private void handleIntent(Intent intent) {
        if (ACTION_SEARCH.equals(intent.getAction()))
            search(intent.getStringExtra(QUERY));
    }

    private void search(final String query) {
        getSupportActionBar().setTitle(query);
        RepositorySearchSuggestionsProvider.save(this, query);

        findFragments();

        if (repoFragment != null && userFragment != null) {
            repoFragment.setListShown(false);
            userFragment.setListShown(false);

            repoFragment.refresh();
            userFragment.refresh();
        }
    }

    private void configurePager() {
        configureTabPager();
        ViewUtils.setGone(loadingBar, true);
        setGone(false);
    }

    private void findFragments() {
        if (repoFragment == null || userFragment == null) {
            FragmentManager fm = getSupportFragmentManager();
            repoFragment = (SearchRepositoryListFragment) fm.findFragmentByTag(
                "android:switcher:" + pager.getId() + ":" + 0);
            userFragment = (SearchUserListFragment) fm.findFragmentByTag(
                "android:switcher:" + pager.getId() + ":" + 1);
        }
    }
}

<code block>

package com.github.pockethub.ui.search;

import static android.app.SearchManager.QUERY;
import android.app.Activity;
import android.os.Bundle;
import android.support.v4.content.Loader;
import android.view.View;
import android.widget.ListView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.pockethub.R;
import com.github.pockethub.ThrowableLoader;
import com.github.pockethub.accounts.AccountUtils;
import com.github.pockethub.core.search.SearchUser;
import com.github.pockethub.core.search.SearchUserService;
import com.github.pockethub.core.user.RefreshUserTask;
import com.github.pockethub.ui.ItemListFragment;
import com.github.pockethub.ui.user.UserViewActivity;
import com.github.pockethub.util.AvatarLoader;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.egit.github.core.User;


public class SearchUserListFragment extends ItemListFragment<SearchUser> {

    private String query;

    @Inject
    private SearchUserService service;

    @Inject
    private AvatarLoader avatars;

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        setEmptyText(R.string.no_people);
    }

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);

        query = getStringExtra(QUERY);
    }

    @Override
    public void refresh() {
        query = getStringExtra(QUERY);

        super.refresh();
    }

    @Override
    public Loader<List<SearchUser>> onCreateLoader(int id, Bundle args) {
        return new ThrowableLoader<List<SearchUser>>(getActivity(), items) {

            @Override
            public List<SearchUser> loadData() throws Exception {
                return service.searchUsers(query);
            }
        };
    }

    @Override
    protected SingleTypeAdapter<SearchUser> createAdapter(List<SearchUser> items) {
        return new SearchUserListAdapter(getActivity(),
                items.toArray(new SearchUser[items.size()]), avatars);
    }

    @Override
    public void onListItemClick(ListView l, View v, int position, long id) {
        final SearchUser result = (SearchUser) l.getItemAtPosition(position);
        new RefreshUserTask(getActivity(), result.getLogin()) {

            @Override
            protected void onSuccess(User user) throws Exception {
                super.onSuccess(user);

                if (!AccountUtils.isUser(getActivity(), user))
                    startActivity(UserViewActivity.createIntent(user));
            }
        }.execute();
    }

    @Override
    protected int getErrorMessage(Exception exception) {
        return R.string.error_users_search;
    }
}

<code block>

package com.github.pockethub.ui.search;

import android.content.Context;
import android.content.SearchRecentSuggestionsProvider;
import android.provider.SearchRecentSuggestions;


public class RepositorySearchSuggestionsProvider extends
        SearchRecentSuggestionsProvider {

    private static final String AUTHORITY = "com.github.search.suggest.recent.repos";


    public static void save(Context context, String query) {
        suggestions(context).saveRecentQuery(query, null);
    }


    public static void clear(Context context) {
        suggestions(context).clearHistory();
    }

    private static SearchRecentSuggestions suggestions(Context context) {
        return new SearchRecentSuggestions(context, AUTHORITY,
                DATABASE_MODE_QUERIES);
    }


    public RepositorySearchSuggestionsProvider() {
        setupSuggestions(AUTHORITY, DATABASE_MODE_QUERIES);
    }
}
<code block>

package com.github.pockethub.ui.search;

import android.content.res.Resources;
import android.support.v4.app.Fragment;
import android.support.v7.app.ActionBarActivity;

import com.github.pockethub.R;
import com.github.pockethub.ui.FragmentPagerAdapter;


public class SearchPagerAdapter extends FragmentPagerAdapter {

    private final Resources resources;


    public SearchPagerAdapter(ActionBarActivity activity) {
        super(activity);

        resources = activity.getResources();
    }

    @Override
    public CharSequence getPageTitle(int position) {
        switch (position) {
        case 0:
            return resources.getString(R.string.tab_repositories);
        case 1:
            return resources.getString(R.string.tab_users);
        default:
            return null;
        }
    }

    @Override
    public Fragment getItem(int position) {
        switch (position) {
        case 0:
            return new SearchRepositoryListFragment();
        case 1:
            return new SearchUserListFragment();
        default:
            return null;
        }
    }

    @Override
    public int getCount() {
        return 2;
    }
}

<code block>

package com.github.pockethub.ui.search;

import static android.app.SearchManager.QUERY;
import android.app.Activity;
import android.os.Bundle;
import android.support.v4.content.Loader;
import android.text.TextUtils;
import android.view.View;
import android.widget.ListView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.pockethub.R;
import com.github.pockethub.ThrowableLoader;
import com.github.pockethub.core.repo.RefreshRepositoryTask;
import com.github.pockethub.ui.ItemListFragment;
import com.github.pockethub.ui.repo.RepositoryViewActivity;
import com.google.inject.Inject;

import java.io.IOException;
import java.text.MessageFormat;
import java.util.Collections;
import java.util.List;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.RepositoryId;
import org.eclipse.egit.github.core.SearchRepository;
import org.eclipse.egit.github.core.service.RepositoryService;


public class SearchRepositoryListFragment extends
        ItemListFragment<SearchRepository> {

    @Inject
    private RepositoryService service;

    private String query;

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        setEmptyText(R.string.no_repositories);
    }

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);

        query = getStringExtra(QUERY);
    }

    @Override
    public void refresh() {
        query = getStringExtra(QUERY);

        super.refresh();
    }

    @Override
    public void onListItemClick(ListView l, View v, int position, long id) {
        final SearchRepository result = (SearchRepository) l
                .getItemAtPosition(position);
        new RefreshRepositoryTask(getActivity(), result) {

            @Override
            public void execute() {
                showIndeterminate(MessageFormat.format(
                        getString(R.string.opening_repository),
                        result.generateId()));

                super.execute();
            }

            @Override
            protected void onSuccess(Repository repository) throws Exception {
                super.onSuccess(repository);

                startActivity(RepositoryViewActivity.createIntent(repository));
            }
        }.execute();
    }


    private boolean openRepositoryMatch(final String query) {
        if (TextUtils.isEmpty(query))
            return false;

        RepositoryId repoId = RepositoryId.createFromId(query.trim());
        if (repoId == null)
            return false;

        Repository repo;
        try {
            repo = service.getRepository(repoId);
        } catch (IOException e) {
            return false;
        }

        startActivity(RepositoryViewActivity.createIntent(repo));
        final Activity activity = getActivity();
        if (activity != null)
            activity.finish();
        return true;
    }

    @Override
    public Loader<List<SearchRepository>> onCreateLoader(int id, Bundle args) {
        return new ThrowableLoader<List<SearchRepository>>(getActivity(), items) {

            @Override
            public List<SearchRepository> loadData() throws Exception {
                if (openRepositoryMatch(query))
                    return Collections.emptyList();
                else
                    return service.searchRepositories(query);
            }
        };
    }

    @Override
    protected int getErrorMessage(Exception exception) {
        return R.string.error_repos_load;
    }

    @Override
    protected SingleTypeAdapter<SearchRepository> createAdapter(
            List<SearchRepository> items) {
        return new SearchRepositoryListAdapter(getActivity()
                .getLayoutInflater(), items.toArray(new SearchRepository[items
                .size()]));
    }
}

<code block>

package com.github.pockethub.ui.comment;

import android.content.Intent;
import android.os.Bundle;
import android.text.TextUtils;
import android.view.Menu;
import android.view.MenuItem;

import com.github.pockethub.R;
import com.github.pockethub.ui.TabPagerActivity;
import com.github.pockethub.util.AvatarLoader;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Comment;

import static com.github.pockethub.Intents.EXTRA_COMMENT;
import static com.github.pockethub.util.TypefaceUtils.ICON_EDIT;
import static com.github.pockethub.util.TypefaceUtils.ICON_WATCH;


public abstract class CreateCommentActivity extends
    TabPagerActivity<CommentPreviewPagerAdapter> {

    private MenuItem applyItem;


    @Inject
    protected AvatarLoader avatars;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        getSupportActionBar().setDisplayHomeAsUpEnabled(true);

        configureTabPager();
    }

    @Override
    public void onPageSelected(int position) {
        super.onPageSelected(position);
        adapter.setCurrentItem(position);
    }

    @Override
    public void invalidateOptionsMenu() {
        super.invalidateOptionsMenu();

        if (applyItem != null)
            applyItem.setEnabled(adapter != null
                && !TextUtils.isEmpty(adapter.getCommentText()));
    }

    @Override
    protected void setCurrentItem(int position) {
        super.setCurrentItem(position);

        adapter.setCurrentItem(position);
    }


    protected abstract void createComment(String comment);


    protected void finish(Comment comment) {
        Intent data = new Intent();
        data.putExtra(EXTRA_COMMENT, comment);
        setResult(RESULT_OK, data);
        finish();
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                finish();
                return true;
            case R.id.m_apply:
                createComment(adapter.getCommentText());
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    protected String getTitle(final int position) {
        switch (position) {
            case 0:
                return getString(R.string.write);
            case 1:
                return getString(R.string.preview);
            default:
                return super.getTitle(position);
        }
    }

    @Override
    protected String getIcon(final int position) {
        switch (position) {
            case 0:
                return ICON_EDIT;
            case 1:
                return ICON_WATCH;
            default:
                return super.getIcon(position);
        }
    }

    @Override
    protected CommentPreviewPagerAdapter createAdapter() {
        return new CommentPreviewPagerAdapter(this, null);
    }

    @Override
    public boolean onCreateOptionsMenu(Menu options) {
        getMenuInflater().inflate(R.menu.comment, options);
        applyItem = options.findItem(R.id.m_apply);
        return true;
    }
}

<code block>

package com.github.pockethub.ui.comment;

import android.app.Activity;
import android.os.Bundle;
import android.text.Editable;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.widget.EditText;

import com.github.pockethub.R;
import com.github.pockethub.ui.DialogFragment;
import com.github.pockethub.ui.TextWatcherAdapter;


public class RawCommentFragment extends DialogFragment {

    private EditText commentText;


    private String initComment;

    @Override
    public void onViewCreated(View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        commentText = finder.find(R.id.et_comment);
        commentText.addTextChangedListener(new TextWatcherAdapter() {

            @Override
            public void afterTextChanged(Editable s) {
                Activity activity = getActivity();
                if (activity != null)
                    activity.invalidateOptionsMenu();
            }
        });
        commentText.setOnTouchListener(new View.OnTouchListener() {

            @Override
            public boolean onTouch(View v, MotionEvent event) {
                commentText.requestFocusFromTouch();
                return false;
            }
        });

        setText(initComment);
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        return inflater.inflate(R.layout.comment_create, null);
    }


    public String getText() {
        return commentText.getText().toString();
    }


    public void setText(String comment) {
        if (commentText != null) {
            commentText.setText(comment);
            commentText.selectAll();
        } else {
            initComment = comment;
        }
    }
}

<code block>

package com.github.pockethub.ui.comment;

import android.content.Context;
import android.support.v4.app.Fragment;
import android.support.v7.app.ActionBarActivity;

import com.github.pockethub.R;
import com.github.pockethub.ui.FragmentPagerAdapter;

import org.eclipse.egit.github.core.IRepositoryIdProvider;


public class CommentPreviewPagerAdapter extends FragmentPagerAdapter {

    private final IRepositoryIdProvider repo;

    private RawCommentFragment textFragment;

    private RenderedCommentFragment htmlFragment;


    private String initComment;

    private Context context;


    public CommentPreviewPagerAdapter(ActionBarActivity activity,
            IRepositoryIdProvider repo) {
        super(activity);
        this.context = activity.getApplicationContext();
        this.repo = repo;
    }

    @Override
    public Fragment getItem(final int position) {
        switch (position) {
        case 0:
            textFragment = new RawCommentFragment();
            textFragment.setText(initComment);
            return textFragment;
        case 1:
            htmlFragment = new RenderedCommentFragment();
            return htmlFragment;
        default:
            return null;
        }
    }

    @Override
    public int getCount() {
        return 2;
    }


    public String getCommentText() {
        return textFragment != null ? textFragment.getText() : null;
    }


    public void setCommentText(String comment) {
        if(textFragment != null)
            textFragment.setText(comment);
        initComment = comment;
    }


    public CommentPreviewPagerAdapter setCurrentItem(int position) {
        if (position == 1 && htmlFragment != null)
            htmlFragment.setText(getCommentText(), repo);
        return this;
    }

    @Override
    public CharSequence getPageTitle(int position) {
        switch (position) {
            case 0:
                return context.getResources().getString(R.string.write);
            case 1:
                return context.getResources().getString(R.string.preview);
            default:
                return "";
        }
    }
}

<code block>

package com.github.pockethub.ui.comment;

import org.eclipse.egit.github.core.Comment;


public interface DeleteCommentListener {


    void onDeleteComment(Comment comment);
}
<code block>

package com.github.pockethub.ui.comment;

import org.eclipse.egit.github.core.Comment;


public interface EditCommentListener {


    void onEditComment(Comment comment);
}
<code block>

package com.github.pockethub.ui.comment;

import android.content.Context;
import android.support.v7.widget.PopupMenu;
import android.text.Html;
import android.text.method.LinkMovementMethod;
import android.view.LayoutInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.ImageView;

import com.github.kevinsawicki.wishlist.MultiTypeAdapter;
import com.github.pockethub.R;
import com.github.pockethub.util.AvatarLoader;
import com.github.pockethub.util.HttpImageGetter;
import com.github.pockethub.util.TimeUtils;
import com.github.pockethub.util.TypefaceUtils;

import java.util.Collection;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.IssueEvent;


public class CommentListAdapter extends MultiTypeAdapter {

    private final AvatarLoader avatars;

    private final HttpImageGetter imageGetter;


    private final EditCommentListener editCommentListener;


    private final DeleteCommentListener deleteCommentListener;

    private final boolean isOwner;

    private final String userName;

    private Context context;

    private Issue issue;


    public CommentListAdapter(LayoutInflater inflater, Comment[] elements,
            AvatarLoader avatars, HttpImageGetter imageGetter, Issue issue) {
        this(inflater, elements, avatars, imageGetter, null, null, null, false, issue);
        this.context = inflater.getContext();
    }


    public CommentListAdapter(LayoutInflater inflater, AvatarLoader avatars,
            HttpImageGetter imageGetter, Issue issue) {
        this(inflater, null, avatars, imageGetter, issue);
        this.context = inflater.getContext();
    }


    public CommentListAdapter(LayoutInflater inflater, Comment[] elements,
            AvatarLoader avatars, HttpImageGetter imageGetter,
            EditCommentListener editCommentListener, DeleteCommentListener deleteCommentListener,
            String userName, boolean isOwner, Issue issue) {
        super(inflater);

        this.issue = issue;
        this.userName = userName;
        this.isOwner = isOwner;
        this.context = inflater.getContext();
        this.avatars = avatars;
        this.imageGetter = imageGetter;
        this.editCommentListener = editCommentListener;
        this.deleteCommentListener = deleteCommentListener;
        setItems(elements);
    }

    @Override
    protected void update(int position, Object obj, int type) {
        if(type == 0)
            updateComment((Comment) obj);
        else
            updateEvent((IssueEvent) obj);
    }

    protected void updateEvent(final IssueEvent event) {
        TypefaceUtils.setOcticons(textView(0));
        String message = String.format("<b>%s</b> %s", event.getActor().getLogin(), event.getEvent());
        avatars.bind(imageView(2), event.getActor());

        String eventString = event.getEvent();

        switch (eventString) {
        case "assigned":
        case "unassigned":
            setText(0, TypefaceUtils.ICON_PERSON);
            textView(0).setTextColor(
                    context.getResources().getColor(R.color.text_description));
            break;
        case "labeled":
        case "unlabeled":
            setText(0, TypefaceUtils.ICON_TAG);
            textView(0).setTextColor(
                    context.getResources().getColor(R.color.text_description));
            break;
        case "referenced":
            setText(0, TypefaceUtils.ICON_BOOKMARK);
            textView(0).setTextColor(
                    context.getResources().getColor(R.color.text_description));
            break;
        case "milestoned":
        case "demilestoned":
            setText(0, TypefaceUtils.ICON_MILESTONE);
            textView(0).setTextColor(
                    context.getResources().getColor(R.color.text_description));
            break;
        case "closed":
            setText(0, TypefaceUtils.ICON_ISSUE_CLOSE);
            textView(0).setTextColor(
                    context.getResources().getColor(R.color.issue_event_closed));
            break;
        case "reopened":
            setText(0, TypefaceUtils.ICON_ISSUE_REOPEN);
            textView(0).setTextColor(
                    context.getResources().getColor(R.color.issue_event_reopened));
            break;
        case "renamed":
            setText(0, TypefaceUtils.ICON_EDIT);
            textView(0).setTextColor(
                    context.getResources().getColor(R.color.text_description));
            break;
        case "merged":
            message += String.format(" commit <b>%s</b> into <tt>%s</tt> from <tt>%s</tt>", event.getCommitId().substring(0,6), issue.getPullRequest().getBase().getRef(),
                issue.getPullRequest().getHead().getRef());
            setText(0, TypefaceUtils.ICON_MERGE);
            textView(0).setTextColor(
                    context.getResources().getColor(R.color.issue_event_merged));
            break;
        case "locked":
            setText(0, TypefaceUtils.ICON_LOCK);
            textView(0).setTextColor(
                    context.getResources().getColor(R.color.issue_event_lock));
            break;
        case "unlocked":
            setText(0, TypefaceUtils.ICON_KEY);
            textView(0).setTextColor(
                    context.getResources().getColor(R.color.issue_event_lock));
            break;
        }

        message += " " + TimeUtils.getRelativeTime(event.getCreatedAt());
        setText(1, Html.fromHtml(message));
    }

    protected void updateComment(final Comment comment) {
        imageGetter.bind(textView(0), comment.getBodyHtml(), comment.getId());
        avatars.bind(imageView(3), comment.getUser());

        setText(1, comment.getUser().getLogin());
        setText(2, TimeUtils.getRelativeTime(comment.getUpdatedAt()));

        final boolean canEdit = (isOwner || comment.getUser().getLogin().equals(userName))
            && editCommentListener != null;

        final boolean canDelete = (isOwner || comment.getUser().getLogin().equals(userName))
            && deleteCommentListener != null;

        final ImageView ivMore = view(4);

        if(!canEdit && !canDelete)
            ivMore.setVisibility(View.INVISIBLE);
        else
            ivMore.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                showMorePopup(ivMore, comment, canEdit, canDelete);
            }
        });
    }

    private void showMorePopup(View v, final Comment comment, final boolean canEdit, final boolean canDelete ) {
        PopupMenu menu = new PopupMenu(context, v);
        menu.inflate(R.menu.comment_popup);

        menu.getMenu().findItem(R.id.m_edit).setEnabled(canEdit);
        menu.getMenu().findItem(R.id.m_delete).setEnabled(canDelete);

        menu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {
            @Override
            public boolean onMenuItemClick(MenuItem menuItem) {
                switch (menuItem.getItemId()) {
                    case R.id.m_edit:
                        if (editCommentListener != null) {
                            editCommentListener.onEditComment(comment);
                        }
                        break;
                    case R.id.m_delete:
                        if (deleteCommentListener != null) {
                            deleteCommentListener.onDeleteComment(comment);
                        }
                        break;
                }
                return false;
            }
        });

        menu.show();
    }

    public MultiTypeAdapter setItems(Collection<?> items) {
        if (items == null || items.isEmpty())
            return this;
        return setItems(items.toArray());
    }

    public MultiTypeAdapter setItems(final Object[] items) {
        if (items == null || items.length == 0)
            return this;

        this.clear();

        for (Object item : items) {
            if(item instanceof Comment)
                this.addItem(0, item);
            else
                this.addItem(1, item);
        }

        notifyDataSetChanged();
        return this;
    }

    public void setIssue(Issue issue) {
        this.issue = issue;
    }

    @Override
    protected View initialize(int type, View view) {
        view = super.initialize(type, view);

        textView(view, 0).setMovementMethod(LinkMovementMethod.getInstance());
        return view;
    }

    @Override
    public int getViewTypeCount() {
        return 2;
    }

    @Override
    protected int getChildLayoutId(int type) {
        if(type == 0)
            return R.layout.comment_item;
        else
            return R.layout.comment_event_item;
    }

    @Override
    protected int[] getChildViewIds(int type) {
        if(type == 0)
            return new int[] { R.id.tv_comment_body, R.id.tv_comment_author,
                    R.id.tv_comment_date, R.id.iv_avatar, R.id.iv_more };
        else
            return new int[]{R.id.tv_event_icon, R.id.tv_event, R.id.iv_avatar};
    }
}

<code block>

package com.github.pockethub.ui.comment;

import android.os.Bundle;
import android.support.v4.app.LoaderManager.LoaderCallbacks;
import android.support.v4.content.Loader;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ProgressBar;
import android.widget.TextView;

import com.github.kevinsawicki.wishlist.Keyboard;
import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.pockethub.R;
import com.github.pockethub.ui.DialogFragment;
import com.github.pockethub.ui.MarkdownLoader;
import com.github.pockethub.util.HttpImageGetter;
import com.github.pockethub.util.ToastUtils;
import com.google.inject.Inject;

import java.io.Serializable;

import org.eclipse.egit.github.core.IRepositoryIdProvider;


public class RenderedCommentFragment extends DialogFragment implements
        LoaderCallbacks<CharSequence> {

    private static final String ARG_TEXT = "text";

    private static final String ARG_REPO = "repo";

    private ProgressBar progress;

    private TextView bodyText;

    @Inject
    private HttpImageGetter imageGetter;

    @Override
    public void onViewCreated(View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        progress = finder.find(R.id.pb_loading);
        bodyText = finder.find(R.id.tv_comment_body);
    }


    public void setText(final String raw, final IRepositoryIdProvider repo) {
        Bundle args = new Bundle();
        args.putCharSequence(ARG_TEXT, raw);
        if (repo instanceof Serializable)
            args.putSerializable(ARG_REPO, (Serializable) repo);
        getLoaderManager().restartLoader(0, args, this);
        Keyboard.hideSoftInput(bodyText);
        showLoading(true);
    }

    private void showLoading(final boolean loading) {
        ViewUtils.setGone(progress, !loading);
        ViewUtils.setGone(bodyText, loading);
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        return inflater.inflate(R.layout.comment_preview, null);
    }

    @Override
    public Loader<CharSequence> onCreateLoader(int loader, Bundle args) {
        final CharSequence raw = args.getCharSequence(ARG_TEXT);
        final IRepositoryIdProvider repo = (IRepositoryIdProvider) args
                .getSerializable(ARG_REPO);
        return new MarkdownLoader(getActivity(), repo, raw.toString(),
                imageGetter, true);
    }

    @Override
    public void onLoadFinished(Loader<CharSequence> loader,
            CharSequence rendered) {
        if (rendered == null)
            ToastUtils.show(getActivity(), R.string.error_rendering_markdown);
        bodyText.setText(rendered);
        showLoading(false);
    }

    @Override
    public void onLoaderReset(Loader<CharSequence> loader) {
    }
}

<code block>

package com.github.pockethub.ui.commit;

import static com.github.pockethub.Intents.EXTRA_BASE;
import static com.github.pockethub.Intents.EXTRA_PATH;
import static com.github.pockethub.Intents.EXTRA_POSITION;
import static com.github.pockethub.Intents.EXTRA_REPOSITORY;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.ActionBar;
import android.text.TextUtils;

import com.github.pockethub.Intents.Builder;
import com.github.pockethub.R;
import com.github.pockethub.core.commit.CommitUtils;
import com.github.pockethub.ui.comment.CommentPreviewPagerAdapter;

import org.eclipse.egit.github.core.CommitComment;
import org.eclipse.egit.github.core.Repository;


public class CreateCommentActivity extends
        com.github.pockethub.ui.comment.CreateCommentActivity {


    public static Intent createIntent(Repository repository, String commit) {
        return createIntent(repository, commit, null, -1);
    }


    public static Intent createIntent(Repository repository, String commit,
            String path, int position) {
        Builder builder = new Builder("commit.comment.create.VIEW");
        builder.repo(repository);
        builder.add(EXTRA_BASE, commit);
        if (isLineComment(path, position))
            builder.add(EXTRA_PATH, path).add(EXTRA_POSITION, position);
        return builder.toIntent();
    }

    private static boolean isLineComment(final String path, final int position) {
        return !TextUtils.isEmpty(path) && position > -1;
    }

    private Repository repository;

    private String commit;

    private int position;

    private String path;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        repository = getSerializableExtra(EXTRA_REPOSITORY);
        commit = getStringExtra(EXTRA_BASE);
        position = getIntExtra(EXTRA_POSITION);
        path = getStringExtra(EXTRA_PATH);

        super.onCreate(savedInstanceState);

        ActionBar actionBar = getSupportActionBar();
        actionBar.setTitle(getString(R.string.commit_prefix)
                + CommitUtils.abbreviate(commit));
        actionBar.setSubtitle(repository.generateId());
        avatars.bind(actionBar, repository.getOwner());
    }

    @Override
    protected void createComment(String comment) {
        CommitComment commitComment = new CommitComment();
        commitComment.setBody(comment);
        if (isLineComment(path, position))
            commitComment.setPath(path).setPosition(position);
        new CreateCommentTask(this, repository, commit, commitComment) {

            @Override
            protected void onSuccess(CommitComment comment) throws Exception {
                super.onSuccess(comment);

                finish(comment);
            }

        }.start();
    }

    @Override
    protected CommentPreviewPagerAdapter createAdapter() {
        return new CommentPreviewPagerAdapter(this, repository);
    }
}

<code block>

package com.github.pockethub.ui.commit;

import static android.app.Activity.RESULT_OK;
import static android.content.DialogInterface.BUTTON_NEGATIVE;
import static android.graphics.Paint.UNDERLINE_TEXT_FLAG;
import static com.github.pockethub.Intents.EXTRA_BASE;
import static com.github.pockethub.Intents.EXTRA_COMMENT;
import static com.github.pockethub.Intents.EXTRA_REPOSITORY;
import static com.github.pockethub.RequestCodes.COMMENT_CREATE;
import android.accounts.Account;
import android.annotation.SuppressLint;
import android.app.AlertDialog;
import android.content.ClipData;
import android.content.ClipboardManager;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.os.Build;
import android.os.Bundle;
import android.text.TextUtils;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ImageView;
import android.widget.ListView;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.Toast;

import com.github.kevinsawicki.wishlist.ViewFinder;
import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.pockethub.R;
import com.github.pockethub.core.commit.CommitStore;
import com.github.pockethub.core.commit.CommitUtils;
import com.github.pockethub.core.commit.FullCommit;
import com.github.pockethub.core.commit.FullCommitFile;
import com.github.pockethub.core.commit.RefreshCommitTask;
import com.github.pockethub.ui.DialogFragment;
import com.github.pockethub.ui.HeaderFooterListAdapter;
import com.github.pockethub.ui.LightAlertDialog;
import com.github.pockethub.ui.StyledText;
import com.github.pockethub.util.AvatarLoader;
import com.github.pockethub.util.HttpImageGetter;
import com.github.pockethub.util.ShareUtils;
import com.github.pockethub.util.ToastUtils;
import com.google.inject.Inject;

import java.util.Collections;
import java.util.Date;
import java.util.List;

import org.eclipse.egit.github.core.Commit;
import org.eclipse.egit.github.core.CommitComment;
import org.eclipse.egit.github.core.CommitFile;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.RepositoryCommit;


public class CommitDiffListFragment extends DialogFragment implements
        OnItemClickListener {

    private DiffStyler diffStyler;

    private ListView list;

    private ProgressBar progress;

    private Repository repository;

    private String base;

    private RepositoryCommit commit;

    private List<CommitComment> comments;

    private List<FullCommitFile> files;

    @Inject
    private AvatarLoader avatars;

    @Inject
    private CommitStore store;

    private View loadingView;

    private View commitHeader;

    private TextView commitMessage;

    private View authorArea;

    private ImageView authorAvatar;

    private TextView authorName;

    private TextView authorDate;

    private View committerArea;

    private ImageView committerAvatar;

    private TextView committerName;

    private TextView committerDate;

    private HeaderFooterListAdapter<CommitFileListAdapter> adapter;

    @Inject
    private HttpImageGetter commentImageGetter;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        Bundle args = getArguments();
        base = args.getString(EXTRA_BASE);
        repository = (Repository) args.getSerializable(EXTRA_REPOSITORY);
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        commit = store.getCommit(repository, base);

        ((TextView) loadingView.findViewById(R.id.tv_loading))
                .setText(R.string.loading_files_and_comments);

        if (files == null
                || (commit != null && commit.getCommit().getCommentCount() > 0 && comments == null))
            adapter.addFooter(loadingView);

        if (commit != null && comments != null && files != null)
            updateList(commit, comments, files);
        else {
            if (commit != null)
                updateHeader(commit);
            refreshCommit();
        }
    }

    private void addComment(final CommitComment comment) {
        if (comments != null && files != null) {
            comments.add(comment);
            Commit rawCommit = commit.getCommit();
            if (rawCommit != null)
                rawCommit.setCommentCount(rawCommit.getCommentCount() + 1);
            commentImageGetter.encode(comment, comment.getBodyHtml());
            updateItems(comments, files);
        } else
            refreshCommit();
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (RESULT_OK == resultCode && COMMENT_CREATE == requestCode
                && data != null) {
            CommitComment comment = (CommitComment) data
                    .getSerializableExtra(EXTRA_COMMENT);
            addComment(comment);
            return;
        }

        super.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    public void onCreateOptionsMenu(final Menu optionsMenu,
            final MenuInflater inflater) {
        inflater.inflate(R.menu.commit_view, optionsMenu);
    }

    @Override
    public boolean onOptionsItemSelected(final MenuItem item) {
        if (!isUsable())
            return false;

        switch (item.getItemId()) {
        case R.id.m_refresh:
            refreshCommit();
            return true;
        case R.id.m_copy_hash:
            copyHashToClipboard();
            return true;
        case R.id.m_comment:
            startActivityForResult(
                    CreateCommentActivity.createIntent(repository, base),
                    COMMENT_CREATE);
            return true;
        case R.id.m_share:
            shareCommit();
            return true;
        default:
            return super.onOptionsItemSelected(item);
        }
    }

    @SuppressLint("NewApi")
    private void copyHashToClipboard() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
            ClipboardManager manager = (ClipboardManager) getActivity().getSystemService(Context.CLIPBOARD_SERVICE);
            ClipData clip = ClipData.newPlainText("hash", commit.getSha());
            manager.setPrimaryClip(clip);
        } else {
            android.text.ClipboardManager manager = (android.text.ClipboardManager) getActivity().getSystemService
                    (Context.CLIPBOARD_SERVICE);
            manager.setText(commit.getSha());
        }
        Toast.makeText(getActivity(), R.string.toast_msg_copied, Toast.LENGTH_SHORT).show();
    }

    private void shareCommit() {
        String id = repository.generateId();
        startActivity(ShareUtils.create(
                "Commit " + CommitUtils.abbreviate(base) + " on " + id,
                "https://github.com/" + id + "/commit/" + base));
    }

    private void refreshCommit() {
        new RefreshCommitTask(getActivity(), repository, base,
                commentImageGetter) {

            @Override
            protected FullCommit run(Account account) throws Exception {
                FullCommit full = super.run(account);

                List<CommitFile> files = full.getCommit().getFiles();
                diffStyler.setFiles(files);
                if (files != null)
                    Collections.sort(files, new CommitFileComparator());
                return full;
            }

            @Override
            protected void onSuccess(FullCommit commit) throws Exception {
                super.onSuccess(commit);
                updateList(commit.getCommit(), commit, commit.getFiles());
            }

            @Override
            protected void onException(Exception e) throws RuntimeException {
                super.onException(e);
                ToastUtils.show(getActivity(), e, R.string.error_commit_load);
                ViewUtils.setGone(progress, true);
            }

        }.execute();
    }

    private boolean isDifferentCommitter(final String author,
            final String committer) {
        return committer != null && !committer.equals(author);
    }

    private void addCommitDetails(RepositoryCommit commit) {
        adapter.addHeader(commitHeader);

        commitMessage.setText(commit.getCommit().getMessage());

        String commitAuthor = CommitUtils.getAuthor(commit);
        String commitCommitter = CommitUtils.getCommitter(commit);

        if (commitAuthor != null) {
            CommitUtils.bindAuthor(commit, avatars, authorAvatar);
            authorName.setText(commitAuthor);
            StyledText styledAuthor = new StyledText();
            styledAuthor.append(getString(R.string.authored));

            Date commitAuthorDate = CommitUtils.getAuthorDate(commit);
            if (commitAuthorDate != null)
                styledAuthor.append(' ').append(commitAuthorDate);

            authorDate.setText(styledAuthor);
            ViewUtils.setGone(authorArea, false);
        } else
            ViewUtils.setGone(authorArea, true);

        if (isDifferentCommitter(commitAuthor, commitCommitter)) {
            CommitUtils.bindCommitter(commit, avatars, committerAvatar);
            committerName.setText(commitCommitter);
            StyledText styledCommitter = new StyledText();
            styledCommitter.append(getString(R.string.committed));

            Date commitCommitterDate = CommitUtils.getCommitterDate(commit);
            if (commitCommitterDate != null)
                styledCommitter.append(' ').append(commitCommitterDate);

            committerDate.setText(styledCommitter);
            ViewUtils.setGone(committerArea, false);
        } else
            ViewUtils.setGone(committerArea, true);
    }

    private void addDiffStats(RepositoryCommit commit, LayoutInflater inflater) {
        View fileHeader = inflater.inflate(R.layout.commit_file_details_header,
                null);
        ((TextView) fileHeader.findViewById(R.id.tv_commit_file_summary))
                .setText(CommitUtils.formatStats(commit.getFiles()));
        adapter.addHeader(fileHeader);
    }

    private void addCommitParents(RepositoryCommit commit,
            LayoutInflater inflater) {
        List<Commit> parents = commit.getParents();
        if (parents == null || parents.isEmpty())
            return;

        for (Commit parent : parents) {
            View parentView = inflater.inflate(R.layout.commit_parent_item, null);
            TextView parentIdText = (TextView) parentView
                    .findViewById(R.id.tv_commit_id);
            parentIdText.setPaintFlags(parentIdText.getPaintFlags()
                    | UNDERLINE_TEXT_FLAG);
            StyledText parentText = new StyledText();
            parentText.append(getString(R.string.parent_prefix));
            parentText.monospace(CommitUtils.abbreviate(parent));
            parentIdText.setText(parentText);
            adapter.addHeader(parentView, parent, true);
        }
    }

    private void updateHeader(RepositoryCommit commit) {
        ViewUtils.setGone(progress, true);
        ViewUtils.setGone(list, false);

        addCommitDetails(commit);
        addCommitParents(commit, getActivity().getLayoutInflater());
    }

    private void updateList(RepositoryCommit commit,
            List<CommitComment> comments, List<FullCommitFile> files) {
        if (!isUsable())
            return;

        this.commit = commit;
        this.comments = comments;
        this.files = files;

        adapter.clearHeaders();
        adapter.clearFooters();
        updateHeader(commit);
        addDiffStats(commit, getActivity().getLayoutInflater());
        updateItems(comments, files);
    }

    private void updateItems(List<CommitComment> comments,
            List<FullCommitFile> files) {
        CommitFileListAdapter rootAdapter = adapter.getWrappedAdapter();
        rootAdapter.clear();
        for (FullCommitFile file : files)
            rootAdapter.addItem(file);
        for (CommitComment comment : comments)
            rootAdapter.addComment(comment);
    }

    @Override
    public void onViewCreated(View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        list = finder.find(android.R.id.list);
        progress = finder.find(R.id.pb_loading);

        diffStyler = new DiffStyler(getResources());

        list.setOnItemClickListener(this);

        LayoutInflater inflater = getActivity().getLayoutInflater();

        adapter = new HeaderFooterListAdapter<>(list,
                new CommitFileListAdapter(inflater, diffStyler, avatars,
                        commentImageGetter));
        adapter.addFooter(inflater.inflate(R.layout.footer_separator, null));
        list.setAdapter(adapter);

        commitHeader = inflater.inflate(R.layout.commit_header, null);
        commitMessage = (TextView) commitHeader
                .findViewById(R.id.tv_commit_message);

        authorArea = commitHeader.findViewById(R.id.ll_author);
        authorAvatar = (ImageView) commitHeader.findViewById(R.id.iv_author);
        authorName = (TextView) commitHeader.findViewById(R.id.tv_author);
        authorDate = (TextView) commitHeader.findViewById(R.id.tv_author_date);

        committerArea = commitHeader.findViewById(R.id.ll_committer);
        committerAvatar = (ImageView) commitHeader
                .findViewById(R.id.iv_committer);
        committerName = (TextView) commitHeader.findViewById(R.id.tv_committer);
        committerDate = (TextView) commitHeader.findViewById(R.id.tv_commit_date);

        loadingView = inflater.inflate(R.layout.loading_item, null);
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        return inflater.inflate(R.layout.commit_diff_list, null);
    }

    private void showFileOptions(CharSequence line, final int position,
            final CommitFile file) {
        final AlertDialog dialog = LightAlertDialog.create(getActivity());
        dialog.setTitle(CommitUtils.getName(file));
        dialog.setCanceledOnTouchOutside(true);

        View view = getActivity().getLayoutInflater().inflate(
                R.layout.diff_line_dialog, null);
        ViewFinder finder = new ViewFinder(view);

        TextView diff = finder.textView(R.id.tv_diff);
        diff.setText(line);
        diffStyler.updateColors(line, diff);

        finder.setText(R.id.tv_commit, getString(R.string.commit_prefix)
                + CommitUtils.abbreviate(commit));

        finder.find(R.id.ll_view_area).setOnClickListener(new OnClickListener() {

            public void onClick(View v) {
                dialog.dismiss();

                openFile(file);
            }
        });

        finder.find(R.id.ll_comment_area).setOnClickListener(
                new OnClickListener() {

                    public void onClick(View v) {
                        dialog.dismiss();

                        startActivityForResult(CreateCommentActivity
                                        .createIntent(repository, commit.getSha(),
                                                file.getFilename(), position),
                                COMMENT_CREATE);
                    }
                });

        dialog.setView(view);
        dialog.setButton(BUTTON_NEGATIVE, getString(R.string.cancel),
                new DialogInterface.OnClickListener() {

                    public void onClick(DialogInterface dialog, int which) {
                        dialog.dismiss();
                    }
                });
        dialog.show();
    }

    private void openFile(CommitFile file) {
        if (!TextUtils.isEmpty(file.getFilename())
                && !TextUtils.isEmpty(file.getSha()))
            startActivity(CommitFileViewActivity.createIntent(repository, base,
                    file));
    }


    private void selectPreviousFile(int position, Object item,
            AdapterView<?> parent) {
        CharSequence line;
        if (item instanceof CharSequence)
            line = (CharSequence) item;
        else
            line = null;

        int linePosition = 0;
        while (--position >= 0) {
            item = parent.getItemAtPosition(position);

            if (item instanceof CommitFile) {
                if (line != null)
                    showFileOptions(line, linePosition, (CommitFile) item);
                break;
            } else if (item instanceof CharSequence)
                if (line != null)
                    linePosition++;
                else
                    line = (CharSequence) item;
        }
    }

    @Override
    public void onItemClick(AdapterView<?> parent, View view, int position,
            long id) {
        Object item = parent.getItemAtPosition(position);
        if (item instanceof Commit)
            startActivity(CommitViewActivity.createIntent(repository,
                    ((Commit) item).getSha()));
        else if (item instanceof CommitFile)
            openFile((CommitFile) item);
        else if (item instanceof CharSequence)
            selectPreviousFile(position, item, parent);
        else if (item instanceof CommitComment)
            if (!TextUtils.isEmpty(((CommitComment) item).getPath()))
                selectPreviousFile(position, item, parent);
    }
}

<code block>

package com.github.pockethub.ui.commit;

import static com.github.pockethub.Intents.EXTRA_BASE;
import static com.github.pockethub.Intents.EXTRA_REPOSITORY;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v7.app.ActionBarActivity;

import com.github.pockethub.ui.FragmentStatePagerAdapter;

import org.eclipse.egit.github.core.Repository;


public class CommitPagerAdapter extends FragmentStatePagerAdapter {

    private final Repository repository;

    private final CharSequence[] ids;


    public CommitPagerAdapter(ActionBarActivity activity,
            Repository repository, CharSequence[] ids) {
        super(activity);

        this.repository = repository;
        this.ids = ids;
    }

    @Override
    public Fragment getItem(final int position) {
        Bundle arguments = new Bundle();
        arguments.putString(EXTRA_BASE, ids[position].toString());
        arguments.putSerializable(EXTRA_REPOSITORY, repository);
        CommitDiffListFragment fragment = new CommitDiffListFragment();
        fragment.setArguments(arguments);
        return fragment;
    }

    @Override
    public int getCount() {
        return ids.length;
    }
}

<code block>

package com.github.pockethub.ui.commit;

import static com.github.kevinsawicki.wishlist.ViewUpdater.FORMAT_INT;
import android.content.res.Resources;
import android.text.TextUtils;
import android.view.LayoutInflater;

import com.github.kevinsawicki.wishlist.MultiTypeAdapter;
import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.pockethub.R;
import com.github.pockethub.core.commit.FullCommitFile;
import com.github.pockethub.ui.StyledText;
import com.github.pockethub.util.AvatarLoader;
import com.github.pockethub.util.HttpImageGetter;
import com.github.pockethub.util.TimeUtils;

import java.util.List;

import org.eclipse.egit.github.core.CommitComment;
import org.eclipse.egit.github.core.CommitFile;


public class CommitFileListAdapter extends MultiTypeAdapter {

    private static final int TYPE_FILE_HEADER = 0;

    private static final int TYPE_FILE_LINE = 1;

    private static final int TYPE_LINE_COMMENT = 2;

    private static final int TYPE_COMMENT = 3;

    private final DiffStyler diffStyler;

    private final HttpImageGetter imageGetter;

    private final AvatarLoader avatars;

    private final int addTextColor;

    private final int removeTextColor;


    public CommitFileListAdapter(final LayoutInflater inflater,
            final DiffStyler diffStyler, final AvatarLoader avatars,
            final HttpImageGetter imageGetter) {
        super(inflater);

        this.diffStyler = diffStyler;
        this.avatars = avatars;
        this.imageGetter = imageGetter;

        Resources resources = inflater.getContext().getResources();
        addTextColor = resources.getColor(R.color.diff_add_text);
        removeTextColor = resources.getColor(R.color.diff_remove_text);
    }

    @Override
    public int getViewTypeCount() {
        return 4;
    }

    @Override
    public long getItemId(int position) {
        switch (getItemViewType(position)) {
        case TYPE_FILE_HEADER:
            String sha = ((CommitFile) getItem(position)).getSha();
            if (!TextUtils.isEmpty(sha))
                return sha.hashCode();
            else
                return super.getItemId(position);
        case TYPE_COMMENT:
        case TYPE_LINE_COMMENT:
            return ((CommitComment) getItem(position)).getId();
        default:
            return super.getItemId(position);
        }

    }


    public void addItem(final FullCommitFile file) {
        addItem(TYPE_FILE_HEADER, file.getFile());
        List<CharSequence> lines = diffStyler.get(file.getFile().getFilename());
        int number = 0;
        for (CharSequence line : lines) {
            addItem(TYPE_FILE_LINE, line);
            for (CommitComment comment : file.get(number))
                addItem(TYPE_LINE_COMMENT, comment);
            number++;
        }
    }


    public void addItem(final CommitFile file) {
        addItem(TYPE_FILE_HEADER, file);
        addItems(TYPE_FILE_LINE, diffStyler.get(file.getFilename()));
    }


    public void addComment(final CommitComment comment) {
        addItem(TYPE_COMMENT, comment);
    }

    @Override
    protected int getChildLayoutId(final int type) {
        switch (type) {
        case TYPE_FILE_HEADER:
            return R.layout.commit_diff_file_header;
        case TYPE_FILE_LINE:
            return R.layout.commit_diff_line;
        case TYPE_LINE_COMMENT:
            return R.layout.diff_comment_item;
        case TYPE_COMMENT:
            return R.layout.commit_comment_item;
        default:
            return -1;
        }
    }

    @Override
    protected int[] getChildViewIds(final int type) {
        switch (type) {
        case TYPE_FILE_HEADER:
            return new int[] { R.id.tv_name, R.id.tv_folder, R.id.tv_stats };
        case TYPE_FILE_LINE:
            return new int[] { R.id.tv_diff };
        case TYPE_LINE_COMMENT:
        case TYPE_COMMENT:
            return new int[] { R.id.tv_comment_body, R.id.iv_avatar,
                    R.id.tv_comment_author, R.id.tv_comment_date };
        default:
            return null;
        }
    }

    @Override
    protected void update(final int position, final Object item, final int type) {
        switch (type) {
        case TYPE_FILE_HEADER:
            CommitFile file = (CommitFile) item;
            String path = file.getFilename();
            int lastSlash = path.lastIndexOf('/');
            if (lastSlash != -1) {
                setText(0, path.substring(lastSlash + 1));
                ViewUtils.setGone(setText(1, path.substring(0, lastSlash + 1)),
                        false);
            } else {
                setText(0, path);
                setGone(1, true);
            }

            StyledText stats = new StyledText();
            stats.foreground('+', addTextColor);
            stats.foreground(FORMAT_INT.format(file.getAdditions()),
                    addTextColor);
            stats.append(' ').append(' ').append(' ');
            stats.foreground('-', removeTextColor);
            stats.foreground(FORMAT_INT.format(file.getDeletions()),
                    removeTextColor);
            setText(2, stats);
            return;
        case TYPE_FILE_LINE:
            CharSequence text = (CharSequence) item;
            diffStyler.updateColors((CharSequence) item, setText(0, text));
            return;
        case TYPE_LINE_COMMENT:
        case TYPE_COMMENT:
            CommitComment comment = (CommitComment) item;
            avatars.bind(imageView(1), comment.getUser());
            setText(2, comment.getUser().getLogin());
            setText(3, TimeUtils.getRelativeTime(comment.getUpdatedAt()));
            imageGetter.bind(textView(0), comment.getBodyHtml(),
                    comment.getId());
        }
    }
}

<code block>

package com.github.pockethub.ui.commit;

import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
import static android.content.Intent.FLAG_ACTIVITY_SINGLE_TOP;
import static com.github.pockethub.Intents.EXTRA_BASES;
import static com.github.pockethub.Intents.EXTRA_POSITION;
import static com.github.pockethub.Intents.EXTRA_REPOSITORY;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.ActionBar;
import android.view.MenuItem;

import com.github.pockethub.Intents.Builder;
import com.github.pockethub.R;
import com.github.pockethub.core.commit.CommitUtils;
import com.github.pockethub.ui.FragmentProvider;
import com.github.pockethub.ui.PagerActivity;
import com.github.pockethub.ui.ViewPager;
import com.github.pockethub.ui.repo.RepositoryViewActivity;
import com.github.pockethub.util.AvatarLoader;
import com.google.inject.Inject;

import java.util.Collection;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.RepositoryCommit;


public class CommitViewActivity extends PagerActivity {


    public static Intent createIntent(final Repository repository,
        final String id) {
        return createIntent(repository, 0, id);
    }


    public static Intent createIntent(final Repository repository,
        final int position, final Collection<RepositoryCommit> commits) {
        String[] ids = new String[commits.size()];
        int index = 0;
        for (RepositoryCommit commit : commits)
            ids[index++] = commit.getSha();
        return createIntent(repository, position, ids);
    }


    public static Intent createIntent(final Repository repository,
        final int position, final String... ids) {
        Builder builder = new Builder("commits.VIEW");
        builder.add(EXTRA_POSITION, position);
        builder.add(EXTRA_BASES, ids);
        builder.repo(repository);
        return builder.toIntent();
    }

    private ViewPager pager;

    private Repository repository;

    private CharSequence[] ids;

    private int initialPosition;

    @Inject
    private AvatarLoader avatars;

    private CommitPagerAdapter adapter;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.pager);

        setSupportActionBar((android.support.v7.widget.Toolbar) findViewById(R.id.toolbar));

        pager = finder.find(R.id.vp_pages);

        repository = getSerializableExtra(EXTRA_REPOSITORY);
        ids = getCharSequenceArrayExtra(EXTRA_BASES);
        initialPosition = getIntExtra(EXTRA_POSITION);

        adapter = new CommitPagerAdapter(this, repository, ids);
        pager.setAdapter(adapter);
        pager.setOnPageChangeListener(this);
        pager.scheduleSetItem(initialPosition, this);
        onPageSelected(initialPosition);

        ActionBar actionBar = getSupportActionBar();
        actionBar.setDisplayHomeAsUpEnabled(true);
        actionBar.setSubtitle(repository.generateId());
        avatars.bind(actionBar, repository.getOwner());
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                Intent intent = RepositoryViewActivity.createIntent(repository);
                intent.addFlags(FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_SINGLE_TOP);
                startActivity(intent);
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    public void onPageSelected(int position) {
        super.onPageSelected(position);

        final String id = CommitUtils.abbreviate(ids[position].toString());
        getSupportActionBar().setTitle(getString(R.string.commit_prefix) + id);
    }

    @Override
    protected FragmentProvider getProvider() {
        return adapter;
    }
}

<code block>

package com.github.pockethub.ui.commit;

import android.text.TextUtils;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.TextView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.pockethub.R;
import com.github.pockethub.core.commit.CommitUtils;
import com.github.pockethub.ui.StyledText;
import com.github.pockethub.util.AvatarLoader;
import com.github.pockethub.util.TypefaceUtils;

import java.util.Collection;

import org.eclipse.egit.github.core.RepositoryCommit;


public class CommitListAdapter extends SingleTypeAdapter<RepositoryCommit> {

    private final AvatarLoader avatars;


    public CommitListAdapter(int viewId, LayoutInflater inflater,
            Collection<RepositoryCommit> elements, AvatarLoader avatars) {
        super(inflater, viewId);

        this.avatars = avatars;
        setItems(elements);
    }

    @Override
    public long getItemId(int position) {
        String sha = getItem(position).getSha();
        if (!TextUtils.isEmpty(sha))
            return sha.hashCode();
        else
            return super.getItemId(position);
    }

    @Override
    protected int[] getChildViewIds() {
        return new int[] { R.id.tv_commit_id, R.id.tv_commit_author, R.id.iv_avatar,
                R.id.tv_commit_message, R.id.tv_commit_comments };
    }

    @Override
    protected View initialize(View view) {
        view = super.initialize(view);

        TypefaceUtils.setOcticons((TextView) view
                .findViewById(R.id.tv_comment_icon));
        return view;
    }

    @Override
    protected void update(int position, RepositoryCommit item) {
        setText(0, CommitUtils.abbreviate(item.getSha()));

        StyledText authorText = new StyledText();
        authorText.bold(CommitUtils.getAuthor(item));
        authorText.append(' ');
        authorText.append(CommitUtils.getAuthorDate(item));
        setText(1, authorText);

        CommitUtils.bindAuthor(item, avatars, imageView(2));
        setText(3, item.getCommit().getMessage());
        setText(4, CommitUtils.getCommentCount(item));
    }
}

<code block>

package com.github.pockethub.ui.commit;

import static com.github.pockethub.Intents.EXTRA_BASE;
import static com.github.pockethub.Intents.EXTRA_HEAD;
import static com.github.pockethub.Intents.EXTRA_PATH;
import static com.github.pockethub.Intents.EXTRA_REPOSITORY;
import static com.github.pockethub.util.PreferenceUtils.RENDER_MARKDOWN;
import static com.github.pockethub.util.PreferenceUtils.WRAP;
import android.content.Intent;
import android.os.Bundle;
import android.support.v4.app.LoaderManager.LoaderCallbacks;
import android.support.v4.content.Loader;
import android.support.v7.app.ActionBar;
import android.text.TextUtils;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;
import android.webkit.WebView;
import android.widget.ProgressBar;

import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.pockethub.Intents.Builder;
import com.github.pockethub.R;
import com.github.pockethub.core.code.RefreshBlobTask;
import com.github.pockethub.core.commit.CommitUtils;
import com.github.pockethub.ui.BaseActivity;
import com.github.pockethub.ui.MarkdownLoader;
import com.github.pockethub.util.AvatarLoader;
import com.github.pockethub.util.HttpImageGetter;
import com.github.pockethub.util.MarkdownUtils;
import com.github.pockethub.util.PreferenceUtils;
import com.github.pockethub.util.ShareUtils;
import com.github.pockethub.util.SourceEditor;
import com.github.pockethub.util.ToastUtils;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Blob;
import org.eclipse.egit.github.core.CommitFile;
import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.util.EncodingUtils;


public class CommitFileViewActivity extends BaseActivity implements
    LoaderCallbacks<CharSequence> {

    private static final String TAG = "CommitFileViewActivity";

    private static final String ARG_TEXT = "text";

    private static final String ARG_REPO = "repo";


    public static Intent createIntent(Repository repository, String commit,
        CommitFile file) {
        Builder builder = new Builder("commit.file.VIEW");
        builder.repo(repository);
        builder.add(EXTRA_HEAD, commit);
        builder.add(EXTRA_PATH, file.getFilename());
        builder.add(EXTRA_BASE, file.getSha());
        return builder.toIntent();
    }

    private Repository repo;

    private String commit;

    private String sha;

    private String path;

    private String file;

    private boolean isMarkdownFile;

    private String renderedMarkdown;

    private Blob blob;

    private ProgressBar loadingBar;

    private WebView codeView;

    private SourceEditor editor;

    private MenuItem markdownItem;

    @Inject
    private AvatarLoader avatars;

    @Inject
    private HttpImageGetter imageGetter;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.commit_file_view);

        setSupportActionBar((android.support.v7.widget.Toolbar) findViewById(R.id.toolbar));

        repo = getSerializableExtra(EXTRA_REPOSITORY);
        commit = getStringExtra(EXTRA_HEAD);
        sha = getStringExtra(EXTRA_BASE);
        path = getStringExtra(EXTRA_PATH);

        loadingBar = finder.find(R.id.pb_loading);
        codeView = finder.find(R.id.wv_code);

        file = CommitUtils.getName(path);
        isMarkdownFile = MarkdownUtils.isMarkdown(file);

        editor = new SourceEditor(codeView);
        editor.setWrap(PreferenceUtils.getCodePreferences(this).getBoolean(
            WRAP, false));

        ActionBar actionBar = getSupportActionBar();
        int lastSlash = path.lastIndexOf('/');
        if (lastSlash != -1)
            actionBar.setTitle(path.substring(lastSlash + 1));
        else
            actionBar.setTitle(path);
        actionBar.setSubtitle(getString(R.string.commit_prefix)
            + CommitUtils.abbreviate(commit));
        avatars.bind(actionBar, repo.getOwner());

        loadContent();
    }

    @Override
    public boolean onCreateOptionsMenu(final Menu optionsMenu) {
        getMenuInflater().inflate(R.menu.file_view, optionsMenu);

        MenuItem wrapItem = optionsMenu.findItem(R.id.m_wrap);
        if (PreferenceUtils.getCodePreferences(this).getBoolean(WRAP, false))
            wrapItem.setTitle(R.string.disable_wrapping);
        else
            wrapItem.setTitle(R.string.enable_wrapping);

        markdownItem = optionsMenu.findItem(R.id.m_render_markdown);
        if (isMarkdownFile) {
            markdownItem.setEnabled(blob != null);
            markdownItem.setVisible(true);
            if (PreferenceUtils.getCodePreferences(this).getBoolean(
                RENDER_MARKDOWN, true))
                markdownItem.setTitle(R.string.show_raw_markdown);
            else
                markdownItem.setTitle(R.string.render_markdown);
        }

        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.m_wrap:
                if (editor.getWrap())
                    item.setTitle(R.string.enable_wrapping);
                else
                    item.setTitle(R.string.disable_wrapping);
                editor.toggleWrap();
                PreferenceUtils.save(PreferenceUtils.getCodePreferences(this)
                    .edit().putBoolean(WRAP, editor.getWrap()));
                return true;

            case R.id.m_share:
                shareFile();
                return true;

            case R.id.m_render_markdown:
                if (editor.isMarkdown()) {
                    item.setTitle(R.string.render_markdown);
                    editor.toggleMarkdown();
                    editor.setSource(file, blob);
                } else {
                    item.setTitle(R.string.show_raw_markdown);
                    editor.toggleMarkdown();
                    if (renderedMarkdown != null)
                        editor.setSource(file, renderedMarkdown, false);
                    else
                        loadMarkdown();
                }
                PreferenceUtils.save(PreferenceUtils.getCodePreferences(this)
                    .edit().putBoolean(RENDER_MARKDOWN, editor.isMarkdown()));
                return true;

            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    public Loader<CharSequence> onCreateLoader(int loader, Bundle args) {
        final String raw = args.getString(ARG_TEXT);
        final IRepositoryIdProvider repo = (IRepositoryIdProvider) args
            .getSerializable(ARG_REPO);
        return new MarkdownLoader(this, repo, raw, imageGetter, false);
    }

    @Override
    public void onLoadFinished(Loader<CharSequence> loader,
        CharSequence rendered) {
        if (rendered == null)
            ToastUtils.show(this, R.string.error_rendering_markdown);

        ViewUtils.setGone(loadingBar, true);
        ViewUtils.setGone(codeView, false);

        if (!TextUtils.isEmpty(rendered)) {
            renderedMarkdown = rendered.toString();
            if (markdownItem != null)
                markdownItem.setEnabled(true);
            editor.setMarkdown(true).setSource(file, renderedMarkdown, false);
        }
    }

    @Override
    public void onLoaderReset(Loader<CharSequence> loader) {
    }

    private void shareFile() {
        String id = repo.generateId();
        startActivity(ShareUtils.create(
            path + " at " + CommitUtils.abbreviate(commit) + " on " + id,
            "https://github.com/" + id + "/blob/" + commit + '/' + path));
    }

    private void loadMarkdown() {
        ViewUtils.setGone(loadingBar, false);
        ViewUtils.setGone(codeView, true);

        String markdown = new String(
            EncodingUtils.fromBase64(blob.getContent()));
        Bundle args = new Bundle();
        args.putCharSequence(ARG_TEXT, markdown);
        args.putSerializable(ARG_REPO, repo);
        getSupportLoaderManager().restartLoader(0, args, this);
    }

    private void loadContent() {
        new RefreshBlobTask(repo, sha, this) {

            @Override
            protected void onSuccess(Blob blob) throws Exception {
                super.onSuccess(blob);

                ViewUtils.setGone(loadingBar, true);
                ViewUtils.setGone(codeView, false);

                editor.setSource(path, blob);
                CommitFileViewActivity.this.blob = blob;

                if (markdownItem != null)
                    markdownItem.setEnabled(true);

                if (isMarkdownFile
                    && PreferenceUtils.getCodePreferences(
                    CommitFileViewActivity.this).getBoolean(
                    RENDER_MARKDOWN, true))
                    loadMarkdown();
                else {
                    ViewUtils.setGone(loadingBar, true);
                    ViewUtils.setGone(codeView, false);
                    editor.setSource(path, blob);
                }
            }

            @Override
            protected void onException(Exception e) throws RuntimeException {
                super.onException(e);

                Log.d(TAG, "Loading commit file contents failed", e);

                ViewUtils.setGone(loadingBar, true);
                ViewUtils.setGone(codeView, false);
                ToastUtils.show(CommitFileViewActivity.this, e,
                    R.string.error_file_load);
            }
        }.execute();
    }

}

<code block>

package com.github.pockethub.ui.commit;

import android.content.res.Resources;
import android.text.TextUtils;
import android.widget.TextView;

import com.github.pockethub.R;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.egit.github.core.CommitFile;


public class DiffStyler {

    private final Map<String, List<CharSequence>> diffs = new HashMap<>();

    private final int markerColor;

    private final int defaultColor;


    public DiffStyler(final Resources resources) {
        markerColor = resources.getColor(R.color.diff_marker_text);
        defaultColor = resources.getColor(R.color.text);
    }

    private int nextLine(final String patch, final int start, final int length) {
        final int end = patch.indexOf('\n', start);
        if (end != -1)
            return end;
        else
            return length;
    }


    public void updateColors(final CharSequence line, final TextView view) {
        if (TextUtils.isEmpty(line)) {
            view.setBackgroundResource(R.drawable.list_item_background);
            view.setTextColor(defaultColor);
            return;
        }

        switch (line.charAt(0)) {
        case '@':
            view.setBackgroundResource(R.drawable.diff_marker_background);
            view.setTextColor(markerColor);
            return;
        case '+':
            view.setBackgroundResource(R.drawable.diff_add_background);
            view.setTextColor(defaultColor);
            return;
        case '-':
            view.setBackgroundResource(R.drawable.diff_remove_background);
            view.setTextColor(defaultColor);
            return;
        default:
            view.setBackgroundResource(R.drawable.list_item_background);
            view.setTextColor(defaultColor);
        }
    }


    public DiffStyler setFiles(final Collection<CommitFile> files) {
        diffs.clear();
        if (files == null || files.isEmpty())
            return this;

        for (CommitFile file : files) {
            String patch = file.getPatch();
            if (TextUtils.isEmpty(patch))
                continue;

            int start = 0;
            int length = patch.length();
            int end = nextLine(patch, start, length);
            List<CharSequence> lines = new ArrayList<>();
            while (start < length) {
                lines.add(patch.substring(start, end));
                start = end + 1;
                end = nextLine(patch, start, length);
            }
            diffs.put(file.getFilename(), lines);
        }
        return this;
    }


    public List<CharSequence> get(final String file) {
        if (TextUtils.isEmpty(file))
            return Collections.emptyList();
        List<CharSequence> lines = diffs.get(file);
        return lines != null ? lines : Collections.<CharSequence>emptyList();
    }
}

<code block>

package com.github.pockethub.ui.commit;

import static android.app.Activity.RESULT_OK;
import static com.github.pockethub.Intents.EXTRA_REPOSITORY;
import static com.github.pockethub.RequestCodes.COMMIT_VIEW;
import static com.github.pockethub.RequestCodes.REF_UPDATE;
import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.support.v4.content.Loader;
import android.text.TextUtils;
import android.view.LayoutInflater;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.ListView;
import android.widget.TextView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.pockethub.R;
import com.github.pockethub.ThrowableLoader;
import com.github.pockethub.core.ResourcePager;
import com.github.pockethub.core.commit.CommitPager;
import com.github.pockethub.core.commit.CommitStore;
import com.github.pockethub.core.ref.RefUtils;
import com.github.pockethub.ui.DialogFragmentActivity;
import com.github.pockethub.ui.DialogResultListener;
import com.github.pockethub.ui.ItemListFragment;
import com.github.pockethub.ui.PagedItemFragment;
import com.github.pockethub.ui.ref.RefDialog;
import com.github.pockethub.ui.ref.RefDialogFragment;
import com.github.pockethub.util.AvatarLoader;
import com.github.pockethub.util.TypefaceUtils;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.egit.github.core.Commit;
import org.eclipse.egit.github.core.Reference;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.RepositoryCommit;
import org.eclipse.egit.github.core.client.PageIterator;
import org.eclipse.egit.github.core.service.CommitService;
import org.eclipse.egit.github.core.service.DataService;
import org.eclipse.egit.github.core.service.RepositoryService;


public class CommitListFragment extends PagedItemFragment<RepositoryCommit>
        implements DialogResultListener {


    @Inject
    protected AvatarLoader avatars;

    @Inject
    private CommitService service;

    @Inject
    private CommitStore store;

    private Repository repository;

    private RefDialog dialog;

    private TextView branchIconView;

    private TextView branchView;

    private View branchFooterView;

    @Inject
    private DataService dataService;

    @Inject
    private RepositoryService repoService;

    private String ref;

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);

        repository = getSerializableExtra(EXTRA_REPOSITORY);
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        setEmptyText(R.string.no_commits);
    }

    @Override
    public Loader<List<RepositoryCommit>> onCreateLoader(int id, Bundle bundle) {
        final ThrowableLoader<List<RepositoryCommit>> parentLoader = (ThrowableLoader<List<RepositoryCommit>>) super
                .onCreateLoader(id, bundle);
        return new ThrowableLoader<List<RepositoryCommit>>(getActivity(), items) {

            @Override
            public List<RepositoryCommit> loadData() throws Exception {
                if (TextUtils.isEmpty(ref)) {
                    String defaultBranch = repository.getMasterBranch();
                    if (TextUtils.isEmpty(defaultBranch)) {
                        defaultBranch = repoService.getRepository(repository)
                                .getMasterBranch();
                        if (TextUtils.isEmpty(defaultBranch))
                            defaultBranch = "master";
                    }
                    ref = defaultBranch;
                }

                return parentLoader.loadData();
            }
        };
    }

    public void onLoadFinished(Loader<List<RepositoryCommit>> loader,
            List<RepositoryCommit> items) {
        super.onLoadFinished(loader, items);

        if (ref != null)
            updateRefLabel();
    }

    @Override
    protected ResourcePager<RepositoryCommit> createPager() {
        return new CommitPager(repository, store) {

            private String last;

            @Override
            protected RepositoryCommit register(RepositoryCommit resource) {


                List<Commit> parents = resource.getParents();
                if (parents != null && !parents.isEmpty())
                    last = parents.get(0).getSha();
                else
                    last = null;

                return super.register(resource);
            }

            @Override
            public PageIterator<RepositoryCommit> createIterator(int page,
                    int size) {
                if (page > 1 || ref == null)
                    return service.pageCommits(repository, last, null, size);
                else
                    return service.pageCommits(repository, ref, null, size);
            }

            @Override
            public ResourcePager<RepositoryCommit> clear() {
                last = null;
                return super.clear();
            }
        };
    }

    @Override
    protected int getLoadingMessage() {
        return R.string.loading_commits;
    }

    @Override
    protected int getErrorMessage(Exception exception) {
        return R.string.error_commits_load;
    }

    @Override
    protected SingleTypeAdapter<RepositoryCommit> createAdapter(
            List<RepositoryCommit> items) {
        return new CommitListAdapter(R.layout.commit_item, getActivity()
                .getLayoutInflater(), items, avatars);
    }

    @Override
    public void onListItemClick(ListView l, View v, int position, long id) {
        Object item = l.getItemAtPosition(position);
        if (item instanceof RepositoryCommit)
            startActivityForResult(CommitViewActivity.createIntent(repository,
                    position, items), COMMIT_VIEW);
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (requestCode == COMMIT_VIEW) {
            notifyDataSetChanged();
            return;
        }

        super.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    public void onDialogResult(int requestCode, int resultCode, Bundle arguments) {
        if (RESULT_OK != resultCode)
            return;

        switch (requestCode) {
        case REF_UPDATE:
            setRef(RefDialogFragment.getSelected(arguments));
            break;
        }
    }

    private void updateRefLabel() {
        branchView.setText(RefUtils.getName(ref));
        if (RefUtils.isTag(ref))
            branchIconView.setText(R.string.icon_tag);
        else
            branchIconView.setText(R.string.icon_fork);
    }

    private void setRef(final Reference ref) {
        this.ref = ref.getRef();
        updateRefLabel();
        refreshWithProgress();
    }

    private void switchRefs() {
        if (ref == null)
            return;

        if (dialog == null)
            dialog = new RefDialog((DialogFragmentActivity) getActivity(),
                    REF_UPDATE, repository, dataService);
        dialog.show(new Reference().setRef(ref));
    }

    @Override
    public ItemListFragment<RepositoryCommit> setListShown(boolean shown,
            boolean animate) {
        ViewUtils.setGone(branchFooterView, !shown);
        return super.setListShown(shown, animate);
    }

    @Override
    public void onViewCreated(View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        branchFooterView = finder.find(R.id.rl_branch);
        branchView = finder.find(R.id.tv_branch);
        branchIconView = finder.find(R.id.tv_branch_icon);
        TypefaceUtils.setOcticons(branchIconView);
        branchFooterView.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                switchRefs();
            }
        });
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        return inflater.inflate(R.layout.commit_list, null);
    }
}

<code block>

package com.github.pockethub.ui.commit;

import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
import static android.content.Intent.FLAG_ACTIVITY_SINGLE_TOP;
import static com.github.pockethub.Intents.EXTRA_BASE;
import static com.github.pockethub.Intents.EXTRA_HEAD;
import static com.github.pockethub.Intents.EXTRA_REPOSITORY;
import android.content.Intent;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v7.app.ActionBar;
import android.view.Menu;
import android.view.MenuItem;

import com.github.pockethub.Intents.Builder;
import com.github.pockethub.R;
import com.github.pockethub.ui.DialogFragmentActivity;
import com.github.pockethub.ui.repo.RepositoryViewActivity;
import com.github.pockethub.util.AvatarLoader;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Repository;


public class CommitCompareViewActivity extends DialogFragmentActivity {


    public static Intent createIntent(final Repository repository,
        final String base, final String head) {
        Builder builder = new Builder("commits.compare.VIEW");
        builder.add(EXTRA_BASE, base);
        builder.add(EXTRA_HEAD, head);
        builder.repo(repository);
        return builder.toIntent();
    }

    private Repository repository;

    @Inject
    private AvatarLoader avatars;

    private Fragment fragment;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        repository = getSerializableExtra(EXTRA_REPOSITORY);

        setContentView(R.layout.commit_compare);

        setSupportActionBar((android.support.v7.widget.Toolbar) findViewById(R.id.toolbar));

        ActionBar actionBar = getSupportActionBar();
        actionBar.setDisplayHomeAsUpEnabled(true);
        actionBar.setSubtitle(repository.generateId());
        avatars.bind(actionBar, repository.getOwner());

        fragment = getSupportFragmentManager()
            .findFragmentById(android.R.id.list);
    }

    @Override
    public boolean onCreateOptionsMenu(Menu optionsMenu) {
        if (fragment != null)
            fragment.onCreateOptionsMenu(optionsMenu, getMenuInflater());

        return super.onCreateOptionsMenu(optionsMenu);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                Intent intent = RepositoryViewActivity.createIntent(repository);
                intent.addFlags(FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_SINGLE_TOP);
                startActivity(intent);
                return true;
            default:
                if (fragment != null)
                    return fragment.onOptionsItemSelected(item);
                else
                    return super.onOptionsItemSelected(item);
        }
    }
}

<code block>

package com.github.pockethub.ui.commit;

import static java.lang.String.CASE_INSENSITIVE_ORDER;

import java.util.Comparator;

import org.eclipse.egit.github.core.CommitFile;


public class CommitFileComparator implements Comparator<CommitFile> {

    @Override
    public int compare(final CommitFile lhs, final CommitFile rhs) {
        String lPath = lhs.getFilename();
        final int lSlash = lPath.lastIndexOf('/');
        if (lSlash != -1)
            lPath = lPath.substring(lSlash + 1);

        String rPath = rhs.getFilename();
        final int rSlash = rPath.lastIndexOf('/');
        if (rSlash != -1)
            rPath = rPath.substring(rSlash + 1);

        return CASE_INSENSITIVE_ORDER.compare(lPath, rPath);
    }
}

<code block>

package com.github.pockethub.ui.commit;

import android.accounts.Account;
import android.app.Activity;
import android.util.Log;

import com.github.pockethub.R;
import com.github.pockethub.ui.ProgressDialogTask;
import com.github.pockethub.util.HtmlUtils;
import com.github.pockethub.util.ToastUtils;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.CommitComment;
import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.service.CommitService;


public class CreateCommentTask extends ProgressDialogTask<CommitComment> {

    private static final String TAG = "CreateCommentTask";

    @Inject
    private CommitService service;

    private final IRepositoryIdProvider repository;

    private final String commit;

    private final CommitComment comment;


    protected CreateCommentTask(final Activity activity,
            final IRepositoryIdProvider repository, final String commit,
            final CommitComment comment) {
        super(activity);

        this.repository = repository;
        this.commit = commit;
        this.comment = comment;
    }


    public CreateCommentTask start() {
        showIndeterminate(R.string.creating_comment);
        execute();
        return this;
    }

    @Override
    public CommitComment run(final Account account) throws Exception {
        CommitComment created = service.addComment(repository, commit, comment);
        String formatted = HtmlUtils.format(created.getBodyHtml()).toString();
        created.setBodyHtml(formatted);
        return created;

    }

    @Override
    protected void onException(final Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception creating comment on commit", e);

        ToastUtils.show((Activity) getContext(), e.getMessage());
    }
}

<code block>

package com.github.pockethub.ui.commit;

import static com.github.pockethub.Intents.EXTRA_BASE;
import static com.github.pockethub.Intents.EXTRA_HEAD;
import static com.github.pockethub.Intents.EXTRA_REPOSITORY;
import android.accounts.Account;
import android.app.Activity;
import android.os.Bundle;
import android.text.TextUtils;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ListView;
import android.widget.ProgressBar;
import android.widget.TextView;

import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.pockethub.R;
import com.github.pockethub.core.commit.CommitCompareTask;
import com.github.pockethub.core.commit.CommitUtils;
import com.github.pockethub.ui.DialogFragment;
import com.github.pockethub.ui.HeaderFooterListAdapter;
import com.github.pockethub.util.AvatarLoader;
import com.github.pockethub.util.ToastUtils;
import com.google.inject.Inject;

import java.text.MessageFormat;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

import org.eclipse.egit.github.core.CommitFile;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.RepositoryCommit;
import org.eclipse.egit.github.core.RepositoryCommitCompare;


public class CommitCompareListFragment extends DialogFragment implements
        OnItemClickListener {

    private DiffStyler diffStyler;

    private ListView list;

    private ProgressBar progress;

    private Repository repository;

    private String base;

    private String head;

    @Inject
    private AvatarLoader avatars;

    private HeaderFooterListAdapter<CommitFileListAdapter> adapter;

    private RepositoryCommitCompare compare;

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);

        repository = getSerializableExtra(EXTRA_REPOSITORY);
        base = getStringExtra(EXTRA_BASE);
        head = getStringExtra(EXTRA_HEAD);
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        diffStyler = new DiffStyler(getResources());
        compareCommits();
    }

    @Override
    public void onCreateOptionsMenu(final Menu optionsMenu,
            final MenuInflater inflater) {
        inflater.inflate(R.menu.refresh, optionsMenu);
    }

    @Override
    public boolean onOptionsItemSelected(final MenuItem item) {
        if (!isUsable())
            return false;

        switch (item.getItemId()) {
        case R.id.m_refresh:
            compareCommits();
            return true;
        default:
            return super.onOptionsItemSelected(item);
        }
    }

    private void compareCommits() {
        new CommitCompareTask(getActivity(), repository, base, head) {

            @Override
            protected RepositoryCommitCompare run(Account account)
                    throws Exception {
                RepositoryCommitCompare compare = super.run(account);

                List<CommitFile> files = compare.getFiles();
                diffStyler.setFiles(files);
                if (files != null)
                    Collections.sort(files, new CommitFileComparator());
                return compare;
            }

            @Override
            protected void onSuccess(RepositoryCommitCompare compare)
                    throws Exception {
                super.onSuccess(compare);

                updateList(compare);
            }

            @Override
            protected void onException(Exception e) throws RuntimeException {
                super.onException(e);

                ToastUtils.show(getActivity(), e, R.string.error_commits_load);
            }

        }.execute();
    }

    private void updateList(RepositoryCommitCompare compare) {
        if (!isUsable())
            return;

        this.compare = compare;

        ViewUtils.setGone(progress, true);
        ViewUtils.setGone(list, false);

        LayoutInflater inflater = getActivity().getLayoutInflater();
        adapter.clearHeaders();
        adapter.getWrappedAdapter().clear();

        List<RepositoryCommit> commits = compare.getCommits();
        if (commits != null && !commits.isEmpty()) {
            View commitHeader = inflater.inflate(R.layout.commit_details_header,
                    null);
            ((TextView) commitHeader.findViewById(R.id.tv_commit_summary))
                    .setText(MessageFormat.format(
                            getString(R.string.comparing_commits), commits.size()));
            adapter.addHeader(commitHeader);
            adapter.addHeader(inflater.inflate(R.layout.list_divider, null));
            CommitListAdapter commitAdapter = new CommitListAdapter(
                    R.layout.commit_item, inflater, commits, avatars);
            for (int i = 0; i < commits.size(); i++) {
                RepositoryCommit commit = commits.get(i);
                View view = commitAdapter.getView(i, null, null);
                adapter.addHeader(view, commit, true);
                adapter.addHeader(inflater.inflate(R.layout.list_divider, null));
            }
        }

        CommitFileListAdapter rootAdapter = adapter.getWrappedAdapter();
        rootAdapter.clear();
        List<CommitFile> files = compare.getFiles();
        if (files != null && !files.isEmpty()) {
            addFileStatHeader(files, inflater);
            for (CommitFile file : files)
                rootAdapter.addItem(file);
        }
    }

    private void addFileStatHeader(List<CommitFile> files,
            LayoutInflater inflater) {
        View fileHeader = inflater.inflate(
                R.layout.commit_compare_file_details_header, null);
        ((TextView) fileHeader.findViewById(R.id.tv_commit_file_summary))
                .setText(CommitUtils.formatStats(files));
        adapter.addHeader(fileHeader);
    }

    @Override
    public void onViewCreated(View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        list = finder.find(android.R.id.list);
        progress = finder.find(R.id.pb_loading);

        LayoutInflater inflater = getActivity().getLayoutInflater();

        list.setOnItemClickListener(this);

        adapter = new HeaderFooterListAdapter<>(list,
                new CommitFileListAdapter(inflater, diffStyler, null, null));
        adapter.addFooter(inflater.inflate(R.layout.footer_separator, null));
        list.setAdapter(adapter);
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        return inflater.inflate(R.layout.commit_diff_list, container);
    }

    private void openCommit(final RepositoryCommit commit) {
        if (compare != null) {
            int commitPosition = 0;
            Collection<RepositoryCommit> commits = compare.getCommits();
            for (RepositoryCommit candidate : commits)
                if (commit == candidate)
                    break;
                else
                    commitPosition++;
            if (commitPosition < commits.size())
                startActivity(CommitViewActivity.createIntent(repository,
                        commitPosition, commits));
        } else
            startActivity(CommitViewActivity.createIntent(repository,
                    commit.getSha()));
    }

    private void openFile(final CommitFile file) {
        if (!TextUtils.isEmpty(file.getFilename())
                && !TextUtils.isEmpty(file.getSha()))
            startActivity(CommitFileViewActivity.createIntent(repository, head,
                    file));
    }

    private void openLine(AdapterView<?> parent, int position) {
        Object item = null;
        while (--position >= 0) {
            item = parent.getItemAtPosition(position);
            if (item instanceof CommitFile) {
                openFile((CommitFile) item);
                return;
            }
        }
    }

    @Override
    public void onItemClick(AdapterView<?> parent, View view, int position,
            long id) {
        Object item = parent.getItemAtPosition(position);
        if (item instanceof RepositoryCommit)
            openCommit((RepositoryCommit) item);
        else if (item instanceof CommitFile)
            openFile((CommitFile) item);
        else if (item instanceof CharSequence)
            openLine(parent, position);
    }
}

<code block>

package com.github.pockethub.ui.ref;

import static java.lang.String.CASE_INSENSITIVE_ORDER;
import android.accounts.Account;
import android.util.Log;

import com.github.pockethub.R;
import com.github.pockethub.core.ref.RefUtils;
import com.github.pockethub.ui.DialogFragmentActivity;
import com.github.pockethub.ui.ProgressDialogTask;
import com.github.pockethub.util.ToastUtils;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.Reference;
import org.eclipse.egit.github.core.service.DataService;


public class RefDialog {

    private static final String TAG = "RefDialog";

    private final DataService service;

    private Map<String, Reference> refs;

    private final int requestCode;

    private final DialogFragmentActivity activity;

    private final IRepositoryIdProvider repository;


    public RefDialog(final DialogFragmentActivity activity,
            final int requestCode, final IRepositoryIdProvider repository,
            final DataService service) {
        this.activity = activity;
        this.requestCode = requestCode;
        this.repository = repository;
        this.service = service;
    }

    private void load(final Reference selectedRef) {
        new ProgressDialogTask<List<Reference>>(activity) {

            @Override
            public List<Reference> run(Account account) throws Exception {
                List<Reference> allRefs = service.getReferences(repository);
                Map<String, Reference> loadedRefs = new TreeMap<>(
                        CASE_INSENSITIVE_ORDER);
                for (Reference ref : allRefs)
                    if (RefUtils.isValid(ref))
                        loadedRefs.put(ref.getRef(), ref);
                refs = loadedRefs;
                return allRefs;
            }

            @Override
            protected void onSuccess(List<Reference> all) throws Exception {
                super.onSuccess(all);

                show(selectedRef);
            }

            @Override
            protected void onException(Exception e) throws RuntimeException {
                super.onException(e);

                Log.d(TAG, "Exception loading references", e);
                ToastUtils.show(activity, e, R.string.error_refs_load);
            }

            @Override
            public void execute() {
                showIndeterminate(R.string.loading_refs);

                super.execute();
            }
        }.execute();
    }


    public void show(Reference selectedRef) {
        if (refs == null || refs.isEmpty()) {
            load(selectedRef);
            return;
        }

        final ArrayList<Reference> refList = new ArrayList<>(
                refs.values());
        int checked = -1;
        if (selectedRef != null) {
            String ref = selectedRef.getRef();
            for (int i = 0; i < refList.size(); i++) {
                String candidate = refList.get(i).getRef();
                if (ref.equals(candidate)) {
                    checked = i;
                    break;
                } else if (ref.equals(RefUtils.getName(candidate))) {
                    checked = i;
                    break;
                }
            }
        }

        RefDialogFragment.show(activity, requestCode,
                activity.getString(R.string.select_ref), null, refList, checked);
    }
}

<code block>

package com.github.pockethub.ui.ref;

import static android.app.Activity.RESULT_OK;
import static android.content.DialogInterface.BUTTON_NEGATIVE;
import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.DialogInterface;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ListView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.pockethub.R;
import com.github.pockethub.core.ref.RefUtils;
import com.github.pockethub.ui.DialogFragmentActivity;
import com.github.pockethub.ui.SingleChoiceDialogFragment;
import com.github.pockethub.util.TypefaceUtils;

import java.util.ArrayList;

import org.eclipse.egit.github.core.Reference;


public class RefDialogFragment extends SingleChoiceDialogFragment {

    private static class RefListAdapter extends SingleTypeAdapter<Reference> {

        private final int selected;

        public RefListAdapter(LayoutInflater inflater, Reference[] refs,
                int selected) {
            super(inflater, R.layout.ref_item);

            this.selected = selected;
            setItems(refs);
        }

        @Override
        public long getItemId(int position) {
            return getItem(position).getRef().hashCode();
        }

        @Override
        protected int[] getChildViewIds() {
            return new int[] { R.id.tv_ref_icon, R.id.tv_ref, R.id.rb_selected };
        }

        @Override
        protected View initialize(View view) {
            view = super.initialize(view);

            TypefaceUtils.setOcticons(textView(0));
            return view;
        }

        @Override
        protected void update(int position, Reference item) {
            if (RefUtils.isTag(item))
                setText(0, R.string.icon_tag);
            else
                setText(0, R.string.icon_fork);
            setText(1, RefUtils.getName(item));
            setChecked(2, selected == position);
        }
    }


    public static Reference getSelected(Bundle arguments) {
        return (Reference) arguments.getSerializable(ARG_SELECTED);
    }


    public static void show(final DialogFragmentActivity activity,
            final int requestCode, final String title, final String message,
            ArrayList<Reference> choices, final int selectedChoice) {
        show(activity, requestCode, title, message, choices, selectedChoice,
                new RefDialogFragment());
    }

    @Override
    public Dialog onCreateDialog(final Bundle savedInstanceState) {
        Activity activity = getActivity();
        Bundle arguments = getArguments();

        final AlertDialog dialog = createDialog();
        dialog.setButton(BUTTON_NEGATIVE, activity.getString(R.string.cancel),
                this);

        LayoutInflater inflater = activity.getLayoutInflater();

        ListView view = (ListView) inflater.inflate(R.layout.dialog_list_view,
                null);
        view.setOnItemClickListener(new OnItemClickListener() {

            @Override
            public void onItemClick(AdapterView<?> parent, View view,
                    int position, long id) {
                onClick(dialog, position);
            }
        });

        ArrayList<Reference> choices = getChoices();
        int selected = arguments.getInt(ARG_SELECTED_CHOICE);
        RefListAdapter adapter = new RefListAdapter(inflater,
                choices.toArray(new Reference[choices.size()]), selected);
        view.setAdapter(adapter);
        if (selected >= 0)
            view.setSelection(selected);
        dialog.setView(view);

        return dialog;
    }

    @SuppressWarnings("unchecked")
    private ArrayList<Reference> getChoices() {
        return (ArrayList<Reference>) getArguments().getSerializable(
                ARG_CHOICES);
    }

    @Override
    public void onClick(DialogInterface dialog, int which) {
        super.onClick(dialog, which);

        switch (which) {
        case BUTTON_NEGATIVE:
            break;
        default:
            getArguments().putSerializable(ARG_SELECTED,
                    getChoices().get(which));
            onResult(RESULT_OK);
        }
    }
}

<code block>

package com.github.pockethub.ui.ref;

import android.app.Activity;
import android.content.Context;
import android.text.format.Formatter;
import android.view.View;
import android.widget.TextView;

import com.github.kevinsawicki.wishlist.MultiTypeAdapter;
import com.github.pockethub.R;
import com.github.pockethub.core.code.FullTree.Entry;
import com.github.pockethub.core.code.FullTree.Folder;
import com.github.pockethub.core.commit.CommitUtils;
import com.github.pockethub.util.ServiceUtils;
import com.github.pockethub.util.TypefaceUtils;


public class CodeTreeAdapter extends MultiTypeAdapter {

    private static final int TYPE_BLOB = 0;

    private static final int TYPE_TREE = 1;

    private static final int INDENTED_PADDING = 16;

    private final Context context;

    private final int indentedPaddingLeft;

    private int paddingLeft;

    private int paddingRight;

    private int paddingTop;

    private int paddingBottom;

    private boolean indented;


    public CodeTreeAdapter(Activity activity) {
        super(activity);

        this.context = activity;
        indentedPaddingLeft = ServiceUtils.getIntPixels(
                activity.getResources(), INDENTED_PADDING);
    }


    public CodeTreeAdapter setIndented(final boolean indented) {
        this.indented = indented;
        return this;
    }

    @Override
    public int getViewTypeCount() {
        return 2;
    }


    public void setItems(final Folder root) {
        clear();

        addItems(TYPE_TREE, root.folders.values());
        addItems(TYPE_BLOB, root.files.values());
    }

    @Override
    protected int getChildLayoutId(final int type) {
        switch (type) {
        case TYPE_BLOB:
            return R.layout.blob_item;
        case TYPE_TREE:
            return R.layout.folder_item;
        default:
            return -1;
        }
    }

    @Override
    protected int[] getChildViewIds(final int type) {
        switch (type) {
        case TYPE_BLOB:
            return new int[] { R.id.tv_file, R.id.tv_size };
        case TYPE_TREE:
            return new int[] { R.id.tv_folder, R.id.tv_folders, R.id.tv_files };
        default:
            return null;
        }
    }

    @Override
    protected View initialize(final int type, View view) {
        view = super.initialize(type, view);

        paddingLeft = view.getPaddingLeft();
        paddingRight = view.getPaddingRight();
        paddingTop = view.getPaddingTop();
        paddingBottom = view.getPaddingBottom();

        switch (type) {
        case TYPE_BLOB:
            TypefaceUtils.setOcticons((TextView) view
                    .findViewById(R.id.tv_file_icon));
            break;
        case TYPE_TREE:
            TypefaceUtils.setOcticons(
                    (TextView) view.findViewById(R.id.tv_folder_icon),
                    (TextView) view.findViewById(R.id.tv_folders_icon),
                    (TextView) view.findViewById(R.id.tv_files_icon));
        }

        return view;
    }

    @Override
    protected void update(final int position, final Object item, final int type) {
        if (indented)
            updater.view.setPadding(indentedPaddingLeft, paddingTop,
                    paddingRight, paddingBottom);
        else
            updater.view.setPadding(paddingLeft, paddingTop, paddingRight,
                    paddingBottom);

        switch (type) {
        case TYPE_BLOB:
            Entry file = (Entry) item;
            setText(0, file.name);
            setText(1, Formatter.formatFileSize(context, file.entry.getSize()));

            break;
        case TYPE_TREE:
            Folder folder = (Folder) item;
            setText(0, CommitUtils.getName(folder.name));
            setNumber(1, folder.folders.size());
            setNumber(2, folder.files.size());
            break;
        }
    }
}

<code block>

package com.github.pockethub.ui.ref;

import android.content.Intent;
import android.os.Bundle;
import android.support.v4.app.LoaderManager.LoaderCallbacks;
import android.support.v4.content.Loader;
import android.support.v7.app.ActionBar;
import android.text.TextUtils;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;
import android.webkit.WebView;
import android.widget.ProgressBar;

import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.pockethub.Intents.Builder;
import com.github.pockethub.R;
import com.github.pockethub.core.code.RefreshBlobTask;
import com.github.pockethub.core.commit.CommitUtils;
import com.github.pockethub.ui.BaseActivity;
import com.github.pockethub.ui.MarkdownLoader;
import com.github.pockethub.util.AvatarLoader;
import com.github.pockethub.util.HttpImageGetter;
import com.github.pockethub.util.MarkdownUtils;
import com.github.pockethub.util.PreferenceUtils;
import com.github.pockethub.util.ShareUtils;
import com.github.pockethub.util.SourceEditor;
import com.github.pockethub.util.ToastUtils;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Blob;
import org.eclipse.egit.github.core.IRepositoryIdProvider;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.util.EncodingUtils;

import static com.github.pockethub.Intents.EXTRA_BASE;
import static com.github.pockethub.Intents.EXTRA_HEAD;
import static com.github.pockethub.Intents.EXTRA_PATH;
import static com.github.pockethub.Intents.EXTRA_REPOSITORY;
import static com.github.pockethub.util.PreferenceUtils.RENDER_MARKDOWN;
import static com.github.pockethub.util.PreferenceUtils.WRAP;


public class BranchFileViewActivity extends BaseActivity implements
    LoaderCallbacks<CharSequence> {

    private static final String TAG = "BranchFileViewActivity";

    private static final String ARG_TEXT = "text";

    private static final String ARG_REPO = "repo";


    public static Intent createIntent(Repository repository, String branch,
        String file, String blobSha) {
        Builder builder = new Builder("branch.file.VIEW");
        builder.repo(repository);
        builder.add(EXTRA_BASE, blobSha);
        builder.add(EXTRA_PATH, file);
        builder.add(EXTRA_HEAD, branch);
        return builder.toIntent();
    }

    private Repository repo;

    private String sha;

    private String path;

    private String file;

    private String branch;

    private boolean isMarkdownFile;

    private String renderedMarkdown;

    private Blob blob;

    private ProgressBar loadingBar;

    private WebView codeView;

    private SourceEditor editor;

    private MenuItem markdownItem;

    @Inject
    private AvatarLoader avatars;

    @Inject
    private HttpImageGetter imageGetter;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.commit_file_view);

        repo = getSerializableExtra(EXTRA_REPOSITORY);
        sha = getStringExtra(EXTRA_BASE);
        path = getStringExtra(EXTRA_PATH);
        branch = getStringExtra(EXTRA_HEAD);

        loadingBar = finder.find(R.id.pb_loading);
        codeView = finder.find(R.id.wv_code);

        codeView.getSettings().setBuiltInZoomControls(true);
        codeView.getSettings().setUseWideViewPort(true);

        file = CommitUtils.getName(path);
        isMarkdownFile = MarkdownUtils.isMarkdown(file);
        editor = new SourceEditor(codeView);
        editor.setWrap(PreferenceUtils.getCodePreferences(this).getBoolean(
            WRAP, false));

        setSupportActionBar((android.support.v7.widget.Toolbar) findViewById(R.id.toolbar));

        ActionBar actionBar = getSupportActionBar();
        actionBar.setTitle(file);
        actionBar.setSubtitle(branch);
        avatars.bind(actionBar, repo.getOwner());

        loadContent();
    }

    @Override
    public boolean onCreateOptionsMenu(final Menu optionsMenu) {
        getMenuInflater().inflate(R.menu.file_view, optionsMenu);

        MenuItem wrapItem = optionsMenu.findItem(R.id.m_wrap);
        if (PreferenceUtils.getCodePreferences(this).getBoolean(WRAP, false))
            wrapItem.setTitle(R.string.disable_wrapping);
        else
            wrapItem.setTitle(R.string.enable_wrapping);

        markdownItem = optionsMenu.findItem(R.id.m_render_markdown);
        if (isMarkdownFile) {
            markdownItem.setEnabled(blob != null);
            markdownItem.setVisible(true);
            if (PreferenceUtils.getCodePreferences(this).getBoolean(
                RENDER_MARKDOWN, true))
                markdownItem.setTitle(R.string.show_raw_markdown);
            else
                markdownItem.setTitle(R.string.render_markdown);
        }

        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.m_wrap:
                if (editor.getWrap())
                    item.setTitle(R.string.enable_wrapping);
                else
                    item.setTitle(R.string.disable_wrapping);
                editor.toggleWrap();
                PreferenceUtils.save(PreferenceUtils.getCodePreferences(this)
                    .edit().putBoolean(WRAP, editor.getWrap()));
                return true;

            case R.id.m_share:
                shareFile();
                return true;

            case R.id.m_render_markdown:
                if (editor.isMarkdown()) {
                    item.setTitle(R.string.render_markdown);
                    editor.toggleMarkdown();
                    editor.setSource(file, blob);
                } else {
                    item.setTitle(R.string.show_raw_markdown);
                    editor.toggleMarkdown();
                    if (renderedMarkdown != null)
                        editor.setSource(file, renderedMarkdown, false);
                    else
                        loadMarkdown();
                }
                PreferenceUtils.save(PreferenceUtils.getCodePreferences(this)
                    .edit().putBoolean(RENDER_MARKDOWN, editor.isMarkdown()));
                return true;

            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    public Loader<CharSequence> onCreateLoader(int loader, Bundle args) {
        final String raw = args.getString(ARG_TEXT);
        final IRepositoryIdProvider repo = (IRepositoryIdProvider) args
            .getSerializable(ARG_REPO);
        return new MarkdownLoader(this, repo, raw, imageGetter, false);
    }

    @Override
    public void onLoadFinished(Loader<CharSequence> loader,
        CharSequence rendered) {
        if (rendered == null)
            ToastUtils.show(this, R.string.error_rendering_markdown);

        ViewUtils.setGone(loadingBar, true);
        ViewUtils.setGone(codeView, false);

        if (!TextUtils.isEmpty(rendered)) {
            renderedMarkdown = rendered.toString();
            if (markdownItem != null)
                markdownItem.setEnabled(true);
            editor.setMarkdown(true).setSource(file, renderedMarkdown, false);
        }
    }

    @Override
    public void onLoaderReset(Loader<CharSequence> loader) {
    }

    private void shareFile() {
        String id = repo.generateId();
        startActivity(ShareUtils.create(path + " at " + branch + " on " + id,
            "https://github.com/" + id + "/blob/" + branch + '/' + path));
    }

    private void loadMarkdown() {
        ViewUtils.setGone(loadingBar, false);
        ViewUtils.setGone(codeView, true);

        String markdown = new String(
            EncodingUtils.fromBase64(blob.getContent()));
        Bundle args = new Bundle();
        args.putCharSequence(ARG_TEXT, markdown);
        args.putSerializable(ARG_REPO, repo);
        getSupportLoaderManager().restartLoader(0, args, this);
    }

    private void loadContent() {
        ViewUtils.setGone(loadingBar, false);
        ViewUtils.setGone(codeView, true);

        new RefreshBlobTask(repo, sha, this) {

            @Override
            protected void onSuccess(Blob blob) throws Exception {
                super.onSuccess(blob);

                BranchFileViewActivity.this.blob = blob;

                if (markdownItem != null)
                    markdownItem.setEnabled(true);

                if (isMarkdownFile
                    && PreferenceUtils.getCodePreferences(
                    BranchFileViewActivity.this).getBoolean(
                    RENDER_MARKDOWN, true))
                    loadMarkdown();
                else {
                    ViewUtils.setGone(loadingBar, true);
                    ViewUtils.setGone(codeView, false);

                    editor.setMarkdown(false).setSource(file, blob);
                }
            }

            @Override
            protected void onException(Exception e) throws RuntimeException {
                super.onException(e);

                Log.d(TAG, "Loading file contents failed", e);

                ViewUtils.setGone(loadingBar, true);
                ViewUtils.setGone(codeView, false);
                ToastUtils.show(BranchFileViewActivity.this, e,
                    R.string.error_file_load);
            }
        }.execute();
    }

}

<code block>

package com.github.pockethub.ui.gist;


import static org.eclipse.egit.github.core.client.IGitHubConstants.SEGMENT_COMMENTS;
import static org.eclipse.egit.github.core.client.IGitHubConstants.SEGMENT_GISTS;
import android.accounts.Account;
import android.app.Activity;
import android.util.Log;

import com.github.pockethub.R;
import com.github.pockethub.ui.ProgressDialogTask;
import com.github.pockethub.util.ToastUtils;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.service.GistService;


public class DeleteCommentTask extends ProgressDialogTask<Comment> {

    private static final String TAG = "DeleteCommentTask";

    private final Comment comment;

    @Inject
    private GistService service;

    private final String gistId;


    public DeleteCommentTask(Activity activity, String gistId, Comment comment) {
        super(activity);

        this.gistId = gistId;
        this.comment = comment;
    }

    @Override
    protected Comment run(Account account) throws Exception {
        deleteComment(gistId, comment.getId());
        return comment;
    }


    public DeleteCommentTask start() {
        showIndeterminate(R.string.deleting_comment);

        execute();
        return this;
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception deleting comment on gist", e);

        ToastUtils.show((Activity) getContext(), e.getMessage());
    }


    private void deleteComment(String gistId, long commentId) throws Exception {
        service.getClient().delete(SEGMENT_GISTS + '/' + gistId + SEGMENT_COMMENTS + '/' + commentId);
    }
}

<code block>

package com.github.pockethub.ui.gist;

import static com.github.pockethub.Intents.EXTRA_GIST;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.ActionBar;

import com.github.pockethub.Intents.Builder;
import com.github.pockethub.R;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.User;


public class CreateCommentActivity extends
        com.github.pockethub.ui.comment.CreateCommentActivity {


    public static Intent createIntent(Gist gist) {
        Builder builder = new Builder("gist.comment.create.VIEW");
        builder.gist(gist);
        return builder.toIntent();
    }

    private Gist gist;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        gist = getSerializableExtra(EXTRA_GIST);

        ActionBar actionBar = getSupportActionBar();
        actionBar.setTitle(getString(R.string.gist_title) + gist.getId());
        User user = gist.getUser();
        if (user != null)
            actionBar.setSubtitle(user.getLogin());
        avatars.bind(actionBar, user);
    }

    @Override
    protected void createComment(String comment) {
        new CreateCommentTask(this, gist.getId(), comment) {

            @Override
            protected void onSuccess(Comment comment) throws Exception {
                super.onSuccess(comment);

                finish(comment);
            }

        }.start();
    }
}

<code block>

package com.github.pockethub.ui.gist;

import static android.app.Activity.RESULT_OK;
import static android.view.View.GONE;
import static android.view.View.VISIBLE;
import static com.github.pockethub.Intents.EXTRA_COMMENT;
import static com.github.pockethub.Intents.EXTRA_GIST_ID;
import static com.github.pockethub.RequestCodes.COMMENT_CREATE;
import static com.github.pockethub.RequestCodes.COMMENT_DELETE;
import static com.github.pockethub.RequestCodes.COMMENT_EDIT;
import android.app.Activity;
import android.content.Intent;
import android.graphics.Typeface;
import android.os.Bundle;
import android.support.v4.app.FragmentActivity;
import android.text.TextUtils;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ListView;
import android.widget.ProgressBar;
import android.widget.TextView;

import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.pockethub.R;
import com.github.pockethub.accounts.AccountUtils;
import com.github.pockethub.core.OnLoadListener;
import com.github.pockethub.core.gist.FullGist;
import com.github.pockethub.core.gist.GistStore;
import com.github.pockethub.core.gist.RefreshGistTask;
import com.github.pockethub.core.gist.StarGistTask;
import com.github.pockethub.core.gist.UnstarGistTask;
import com.github.pockethub.ui.ConfirmDialogFragment;
import com.github.pockethub.ui.DialogFragment;
import com.github.pockethub.ui.HeaderFooterListAdapter;
import com.github.pockethub.ui.StyledText;
import com.github.pockethub.ui.comment.CommentListAdapter;
import com.github.pockethub.ui.comment.DeleteCommentListener;
import com.github.pockethub.ui.comment.EditCommentListener;
import com.github.pockethub.util.AvatarLoader;
import com.github.pockethub.util.HttpImageGetter;
import com.github.pockethub.util.ShareUtils;
import com.github.pockethub.util.ToastUtils;
import com.github.pockethub.util.TypefaceUtils;
import com.google.inject.Inject;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.List;
import java.util.Map;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.GistFile;
import org.eclipse.egit.github.core.User;


public class GistFragment extends DialogFragment implements OnItemClickListener {

    private String gistId;

    private List<Comment> comments;

    private Gist gist;

    private ListView list;

    private ProgressBar progress;

    @Inject
    private GistStore store;

    @Inject
    private HttpImageGetter imageGetter;

    private View headerView;

    private View footerView;

    private TextView created;

    private TextView updated;

    private TextView description;

    private View loadingView;

    private HeaderFooterListAdapter<CommentListAdapter> adapter;

    private boolean starred;

    private boolean loadFinished;

    @Inject
    private AvatarLoader avatars;

    private List<View> fileHeaders = new ArrayList<>();

    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        gistId = getArguments().getString(EXTRA_GIST_ID);
        gist = store.getGist(gistId);
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        View root = inflater.inflate(R.layout.comment_list, null);

        headerView = inflater.inflate(R.layout.gist_header, null);
        created = (TextView) headerView.findViewById(R.id.tv_gist_creation);
        updated = (TextView) headerView.findViewById(R.id.tv_gist_updated);
        description = (TextView) headerView
                .findViewById(R.id.tv_gist_description);

        loadingView = inflater.inflate(R.layout.loading_item, null);
        ((TextView) loadingView.findViewById(R.id.tv_loading))
                .setText(R.string.loading_comments);

        footerView = inflater.inflate(R.layout.footer_separator, null);

        return root;
    }

    @Override
    public void onViewCreated(View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        list = finder.find(android.R.id.list);
        progress = finder.find(R.id.pb_loading);

        Activity activity = getActivity();
        User user = gist.getUser();
        String userName = null;
        if(user != null) userName = user.getLogin();
        adapter = new HeaderFooterListAdapter<>(list,
                new CommentListAdapter(activity.getLayoutInflater(), null, avatars,
                        imageGetter, editCommentListener, deleteCommentListener, userName, false, null));
        list.setAdapter(adapter);
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        list.setOnItemClickListener(this);
        adapter.addHeader(headerView);
        adapter.addFooter(footerView);

        if (gist != null) {
            updateHeader(gist);
            updateFiles(gist);
        }

        if (gist == null || (gist.getComments() > 0 && comments == null))
            adapter.addHeader(loadingView, null, false);

        if (gist != null && comments != null)
            updateList(gist, comments);
        else
            refreshGist();
    }

    private boolean isOwner() {
        if (gist == null)
            return false;
        User user = gist.getUser();
        if (user == null)
            return false;
        String login = AccountUtils.getLogin(getActivity());
        return login != null && login.equals(user.getLogin());
    }

    private void updateHeader(Gist gist) {
        Date createdAt = gist.getCreatedAt();
        if (createdAt != null) {
            StyledText text = new StyledText();
            text.append(getString(R.string.prefix_created));
            text.append(createdAt);
            created.setText(text);
            created.setVisibility(VISIBLE);
        } else
            created.setVisibility(GONE);

        Date updatedAt = gist.getUpdatedAt();
        if (updatedAt != null && !updatedAt.equals(createdAt)) {
            StyledText text = new StyledText();
            text.append(getString(R.string.prefix_updated));
            text.append(updatedAt);
            updated.setText(text);
            updated.setVisibility(VISIBLE);
        } else
            updated.setVisibility(GONE);

        String desc = gist.getDescription();
        if (!TextUtils.isEmpty(desc))
            description.setText(desc);
        else
            description.setText(R.string.no_description_given);

        ViewUtils.setGone(progress, true);
        ViewUtils.setGone(list, false);
    }

    @Override
    public void onCreateOptionsMenu(Menu options, MenuInflater inflater) {
        inflater.inflate(R.menu.gist_view, options);
    }

    @Override
    public void onPrepareOptionsMenu(Menu menu) {
        boolean owner = isOwner();
        if (!owner) {
            menu.removeItem(R.id.m_delete);
            MenuItem starItem = menu.findItem(R.id.m_star);
            starItem.setEnabled(loadFinished && !owner);
            if (starred)
                starItem.setTitle(R.string.unstar);
            else
                starItem.setTitle(R.string.star);
        } else
            menu.removeItem(R.id.m_star);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if (gist == null)
            return super.onOptionsItemSelected(item);

        switch (item.getItemId()) {
        case R.id.m_comment:
            startActivityForResult(CreateCommentActivity.createIntent(gist),
                    COMMENT_CREATE);
            return true;
        case R.id.m_star:
            if (starred)
                unstarGist();
            else
                starGist();
            return true;
        case R.id.m_refresh:
            refreshGist();
            return true;
        case R.id.m_share:
            shareGist();
            return true;
        default:
            return super.onOptionsItemSelected(item);
        }
    }

    private void starGist() {
        ToastUtils.show(getActivity(), R.string.starring_gist);

        new StarGistTask(getActivity(), gistId) {

            @Override
            protected void onSuccess(Gist gist) throws Exception {
                super.onSuccess(gist);

                starred = true;
            }

            @Override
            protected void onException(Exception e) throws RuntimeException {
                super.onException(e);

                ToastUtils.show((Activity) getContext(), e.getMessage());
            }

        }.execute();
    }

    private void shareGist() {
        StringBuilder subject = new StringBuilder("Gist ");
        String id = gist.getId();
        subject.append(id);
        User user = gist.getUser();
        if (user != null && !TextUtils.isEmpty(user.getLogin()))
            subject.append(" by ").append(user.getLogin());
        startActivity(ShareUtils.create(subject, "https://gist.github.com/"
                + id));
    }

    private void unstarGist() {
        ToastUtils.show(getActivity(), R.string.unstarring_gist);

        new UnstarGistTask(getActivity(), gistId) {

            @Override
            protected void onSuccess(Gist gist) throws Exception {
                super.onSuccess(gist);

                starred = false;
            }

            protected void onException(Exception e) throws RuntimeException {
                super.onException(e);

                ToastUtils.show((Activity) getContext(), e.getMessage());
            }

        }.execute();
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (RESULT_OK != resultCode || data == null)
            return;

        switch (requestCode) {
        case COMMENT_CREATE:
            Comment comment = (Comment) data
                    .getSerializableExtra(EXTRA_COMMENT);
            if (comments != null) {
                comments.add(comment);
                gist.setComments(gist.getComments() + 1);
                updateList(gist, comments);
            } else
                refreshGist();
            return;
        case COMMENT_EDIT:
            comment = (Comment) data.getSerializableExtra(EXTRA_COMMENT);
            if (comments != null && comment != null) {
                int position = Collections.binarySearch(comments, comment,
                        new Comparator<Comment>() {
                            public int compare(Comment lhs, Comment rhs) {
                                return Long.valueOf(lhs.getId()).compareTo(
                                        rhs.getId());
                            }
                        });
                imageGetter.removeFromCache(comment.getId());
                comments.set(position, comment);
                updateList(gist, comments);
            } else
                refreshGist();
            return;
        }

        super.onActivityResult(requestCode, resultCode, data);
    }

    private void updateFiles(Gist gist) {
        final Activity activity = getActivity();
        if (activity == null)
            return;

        for (View header : fileHeaders)
            adapter.removeHeader(header);
        fileHeaders.clear();

        Map<String, GistFile> files = gist.getFiles();
        if (files == null || files.isEmpty())
            return;

        final LayoutInflater inflater = activity.getLayoutInflater();
        final Typeface octicons = TypefaceUtils.getOcticons(activity);
        for (GistFile file : files.values()) {
            View fileView = inflater.inflate(R.layout.gist_file_item, null);
            ((TextView) fileView.findViewById(R.id.tv_file)).setText(file
                    .getFilename());
            ((TextView) fileView.findViewById(R.id.tv_file_icon))
                    .setTypeface(octicons);
            adapter.addHeader(fileView, file, true);
            fileHeaders.add(fileView);
        }
    }

    private void updateList(Gist gist, List<Comment> comments) {
        adapter.getWrappedAdapter().setItems(
                comments.toArray(new Comment[comments.size()]));
        adapter.removeHeader(loadingView);

        headerView.setVisibility(VISIBLE);
        updateHeader(gist);

        updateFiles(gist);
    }

    private void refreshGist() {
        new RefreshGistTask(getActivity(), gistId, imageGetter) {

            @Override
            protected void onException(Exception e) throws RuntimeException {
                super.onException(e);
                ToastUtils.show(getActivity(), e, R.string.error_gist_load);
            }

            @SuppressWarnings("unchecked")
            @Override
            protected void onSuccess(FullGist fullGist) throws Exception {
                super.onSuccess(fullGist);

                if (!isUsable())
                    return;

                FragmentActivity activity = getActivity();
                if (activity instanceof OnLoadListener)
                    ((OnLoadListener<Gist>) activity)
                            .loaded(fullGist.getGist());

                starred = fullGist.isStarred();
                loadFinished = true;
                gist = fullGist.getGist();
                comments = fullGist;
                updateList(fullGist.getGist(), fullGist);
            }

        }.execute();
    }

    @Override
    public void onItemClick(AdapterView<?> parent, View view, int position,
            long id) {
        Object item = parent.getItemAtPosition(position);
        if (item instanceof GistFile)
            startActivity(GistFilesViewActivity
                    .createIntent(gist, position - 1));
    }

    @Override
    public void onDialogResult(int requestCode, int resultCode, Bundle arguments) {
        if (RESULT_OK != resultCode)
            return;

        switch (requestCode) {
        case COMMENT_DELETE:
            final Comment comment = (Comment) arguments
                    .getSerializable(EXTRA_COMMENT);
            new DeleteCommentTask(getActivity(), gist.getId(), comment) {
                @Override
                protected void onSuccess(Comment comment) throws Exception {
                    super.onSuccess(comment);


                    if (comments != null && comment != null) {
                        int position = Collections.binarySearch(comments,
                                comment, new Comparator<Comment>() {
                                    public int compare(Comment lhs, Comment rhs) {
                                        return Long.valueOf(lhs.getId())
                                                .compareTo(rhs.getId());
                                    }
                                });
                        comments.remove(position);
                        updateList(gist, comments);
                    } else
                        refreshGist();
                }
            }.start();
            break;
        }
    }


    final EditCommentListener editCommentListener = new EditCommentListener() {
        public void onEditComment(Comment comment) {
            startActivityForResult(
                    EditCommentActivity.createIntent(gist, comment),
                    COMMENT_EDIT);
        }
    };


    final DeleteCommentListener deleteCommentListener = new DeleteCommentListener() {
        public void onDeleteComment(Comment comment) {
            Bundle args = new Bundle();
            args.putSerializable(EXTRA_COMMENT, comment);
            ConfirmDialogFragment.show(
                    getActivity(),
                    COMMENT_DELETE,
                    getActivity()
                            .getString(R.string.confirm_comment_delete_title),
                    getActivity().getString(
                            R.string.confirm_comment_delete_message), args);
        }
    };
}

<code block>

package com.github.pockethub.ui.gist;

import static com.github.pockethub.Intents.EXTRA_GIST_ID;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v7.app.ActionBarActivity;
import android.util.SparseArray;
import android.view.ViewGroup;

import com.github.pockethub.ui.FragmentStatePagerAdapter;


public class GistsPagerAdapter extends FragmentStatePagerAdapter {

    private final String[] ids;

    private final SparseArray<GistFragment> fragments = new SparseArray<>();


    public GistsPagerAdapter(ActionBarActivity activity, String[] gistIds) {
        super(activity);

        this.ids = gistIds;
    }

    @Override
    public Fragment getItem(int position) {
        Fragment fragment = new GistFragment();
        Bundle args = new Bundle();
        args.putString(EXTRA_GIST_ID, ids[position]);
        fragment.setArguments(args);
        return fragment;
    }

    @Override
    public int getCount() {
        return ids.length;
    }

    @Override
    public void destroyItem(ViewGroup container, int position, Object object) {
        super.destroyItem(container, position, object);

        fragments.remove(position);
    }

    @Override
    public Object instantiateItem(ViewGroup container, int position) {
        Object fragment = super.instantiateItem(container, position);
        if (fragment instanceof GistFragment)
            fragments.put(position, (GistFragment) fragment);
        return fragment;
    }


    public GistsPagerAdapter onDialogResult(int position, int requestCode,
            int resultCode, Bundle arguments) {
        GistFragment fragment = fragments.get(position);
        if (fragment != null)
            fragment.onDialogResult(requestCode, resultCode, arguments);
        return this;
    }
}

<code block>

package com.github.pockethub.ui.gist;

import com.github.pockethub.core.ResourcePager;
import com.github.pockethub.core.gist.GistPager;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.client.PageIterator;


public class StarredGistsFragment extends GistsFragment {

    @Override
    protected ResourcePager<Gist> createPager() {
        return new GistPager(store) {

            @Override
            public PageIterator<Gist> createIterator(int page, int size) {
                return service.pageStarredGists(page, size);
            }
        };
    }
}

<code block>

package com.github.pockethub.ui.gist;

import static com.github.pockethub.RequestCodes.GIST_CREATE;
import static com.github.pockethub.RequestCodes.GIST_VIEW;
import android.content.Intent;
import android.os.Bundle;
import android.view.MenuItem;
import android.view.View;
import android.widget.ListView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.pockethub.R;
import com.github.pockethub.core.gist.GistStore;
import com.github.pockethub.ui.PagedItemFragment;
import com.github.pockethub.util.AvatarLoader;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.service.GistService;


public abstract class GistsFragment extends PagedItemFragment<Gist> {


    @Inject
    protected AvatarLoader avatars;


    @Inject
    protected GistService service;


    @Inject
    protected GistStore store;

    @Override
    public void onListItemClick(ListView l, View v, int position, long id) {
        startActivityForResult(GistsViewActivity.createIntent(items, position),
                GIST_VIEW);
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        setEmptyText(R.string.no_gists);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if (!isUsable())
            return false;
        switch (item.getItemId()) {
        case R.id.m_create:
            startActivityForResult(new Intent(getActivity(),
                    CreateGistActivity.class), GIST_CREATE);
            return true;
        default:
            return super.onOptionsItemSelected(item);
        }
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (requestCode == GIST_VIEW || requestCode == GIST_CREATE) {
            notifyDataSetChanged();
            forceRefresh();
            return;
        }

        super.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    protected int getErrorMessage(Exception exception) {
        return R.string.error_gists_load;
    }

    @Override
    protected int getLoadingMessage() {
        return R.string.loading_gists;
    }

    @Override
    protected SingleTypeAdapter<Gist> createAdapter(List<Gist> items) {
        return new GistListAdapter(avatars, getActivity(), items);
    }
}

<code block>

package com.github.pockethub.ui.gist;

import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
import static android.content.Intent.FLAG_ACTIVITY_SINGLE_TOP;
import static com.github.pockethub.Intents.EXTRA_GIST;
import static com.github.pockethub.Intents.EXTRA_GIST_ID;
import static com.github.pockethub.Intents.EXTRA_GIST_IDS;
import static com.github.pockethub.Intents.EXTRA_POSITION;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.ActionBar;
import android.view.MenuItem;

import com.github.pockethub.Intents.Builder;
import com.github.pockethub.R;
import com.github.pockethub.core.OnLoadListener;
import com.github.pockethub.core.gist.GistStore;
import com.github.pockethub.ui.ConfirmDialogFragment;
import com.github.pockethub.ui.FragmentProvider;
import com.github.pockethub.ui.MainActivity;
import com.github.pockethub.ui.PagerActivity;
import com.github.pockethub.ui.ViewPager;
import com.github.pockethub.ui.user.UriLauncherActivity;
import com.github.pockethub.util.AvatarLoader;
import com.google.inject.Inject;

import java.io.Serializable;
import java.util.List;

import org.eclipse.egit.github.core.Gist;


public class GistsViewActivity extends PagerActivity implements
    OnLoadListener<Gist> {

    private static final int REQUEST_CONFIRM_DELETE = 1;


    public static Intent createIntent(Gist gist) {
        return new Builder("gists.VIEW").gist(gist).add(EXTRA_POSITION, 0)
            .toIntent();
    }


    public static Intent createIntent(List<Gist> gists, int position) {
        String[] ids = new String[gists.size()];
        int index = 0;
        for (Gist gist : gists)
            ids[index++] = gist.getId();
        return new Builder("gists.VIEW")
            .add(EXTRA_GIST_IDS, (Serializable) ids)
            .add(EXTRA_POSITION, position).toIntent();
    }

    private ViewPager pager;

    private String[] gists;

    private Gist gist;

    private int initialPosition;

    @Inject
    private GistStore store;

    @Inject
    private AvatarLoader avatars;

    private GistsPagerAdapter adapter;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.pager);

        setSupportActionBar((android.support.v7.widget.Toolbar) findViewById(R.id.toolbar));

        gists = getStringArrayExtra(EXTRA_GIST_IDS);
        gist = getSerializableExtra(EXTRA_GIST);
        initialPosition = getIntExtra(EXTRA_POSITION);
        pager = finder.find(R.id.vp_pages);

        getSupportActionBar().setDisplayHomeAsUpEnabled(true);



        if (gists == null && gist != null) {
            if (gist.getCreatedAt() != null) {
                Gist stored = store.getGist(gist.getId());
                if (stored == null)
                    store.addGist(gist);
            }
            gists = new String[] { gist.getId() };
        }

        adapter = new GistsPagerAdapter(this, gists);
        pager.setAdapter(adapter);
        pager.setOnPageChangeListener(this);
        pager.scheduleSetItem(initialPosition, this);
        onPageSelected(initialPosition);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                finish();
                Intent intent = new Intent(this, MainActivity.class);
                intent.addFlags(FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_SINGLE_TOP);
                startActivity(intent);
                return true;
            case R.id.m_delete:
                String gistId = gists[pager.getCurrentItem()];
                Bundle args = new Bundle();
                args.putString(EXTRA_GIST_ID, gistId);
                ConfirmDialogFragment.show(this, REQUEST_CONFIRM_DELETE,
                    getString(R.string.confirm_gist_delete_title),
                    getString(R.string.confirm_gist_delete_message), args);
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    public void onDialogResult(int requestCode, int resultCode, Bundle arguments) {
        if (REQUEST_CONFIRM_DELETE == requestCode && RESULT_OK == resultCode) {
            final String gistId = arguments.getString(EXTRA_GIST_ID);
            new DeleteGistTask(this, gistId).start();
            return;
        }

        adapter.onDialogResult(pager.getCurrentItem(), requestCode, resultCode,
            arguments);

        super.onDialogResult(requestCode, resultCode, arguments);
    }

    @Override
    public void onPageSelected(int position) {
        super.onPageSelected(position);

        String gistId = gists[position];
        Gist gist = store.getGist(gistId);
        updateActionBar(gist, gistId);
    }

    @Override
    public void startActivity(Intent intent) {
        Intent converted = UriLauncherActivity.convert(intent);
        if (converted != null)
            super.startActivity(converted);
        else
            super.startActivity(intent);
    }

    @Override
    protected FragmentProvider getProvider() {
        return adapter;
    }

    private void updateActionBar(Gist gist, String gistId) {
        ActionBar actionBar = getSupportActionBar();
        if (gist == null) {
            actionBar.setSubtitle(null);
            actionBar.setLogo(null);
            actionBar.setIcon(R.drawable.app_icon);
        } else if (gist.getUser() != null) {
            avatars.bind(actionBar, gist.getUser());
            actionBar.setSubtitle(gist.getUser().getLogin());
        } else {
            actionBar.setSubtitle(R.string.anonymous);
            actionBar.setLogo(null);
            actionBar.setIcon(R.drawable.app_icon);
        }
        actionBar.setTitle(getString(R.string.gist_title) + gistId);
    }

    @Override
    public void loaded(Gist gist) {
        if (gists[pager.getCurrentItem()].equals(gist.getId()))
            updateActionBar(gist, gist.getId());
    }
}

<code block>

package com.github.pockethub.ui.gist;

import android.content.res.Resources;
import android.support.v4.app.Fragment;

import com.github.pockethub.R;
import com.github.pockethub.ui.FragmentPagerAdapter;


public class GistQueriesPagerAdapter extends FragmentPagerAdapter {

    private final Resources resources;


    public GistQueriesPagerAdapter(Fragment fragment) {
        super(fragment);

        resources = fragment.getResources();
    }

    @Override
    public int getCount() {
        return 3;
    }

    @Override
    public Fragment getItem(int position) {
        switch (position) {
            case 0:
                return new MyGistsFragment();
            case 1:
                return new StarredGistsFragment();
            case 2:
                return new PublicGistsFragment();
            default:
                return null;
        }
    }

    @Override
    public CharSequence getPageTitle(int position) {
        switch (position) {
            case 0:
                return resources.getString(R.string.tab_mine);
            case 1:
                return resources.getString(R.string.tab_starred);
            case 2:
                return resources.getString(R.string.tab_all);
            default:
                return null;
        }
    }
}

<code block>

package com.github.pockethub.ui.gist;

import android.accounts.Account;
import android.app.Activity;
import android.util.Log;

import com.github.pockethub.R;
import com.github.pockethub.ui.ProgressDialogTask;
import com.github.pockethub.util.ToastUtils;
import com.google.inject.Inject;

import java.util.Collections;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.GistFile;
import org.eclipse.egit.github.core.service.GistService;


public class CreateGistTask extends ProgressDialogTask<Gist> {

    private static final String TAG = "CreateGistTask";

    @Inject
    private GistService service;

    private final String description;

    private final boolean isPublic;

    private final String name;

    private final String content;


    public CreateGistTask(Activity activity, String description,
            boolean isPublic, String name, String content) {
        super(activity);

        this.description = description;
        this.isPublic = isPublic;
        this.name = name;
        this.content = content;
    }

    @Override
    public Gist run(Account account) throws Exception {
        Gist gist = new Gist();
        gist.setDescription(description);
        gist.setPublic(isPublic);

        GistFile file = new GistFile();
        file.setContent(content);
        file.setFilename(name);
        gist.setFiles(Collections.singletonMap(name, file));

        return service.createGist(gist);
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception creating Gist", e);
        ToastUtils.show((Activity) getContext(), e.getMessage());
    }


    public void create() {
        showIndeterminate(R.string.creating_gist);

        execute();
    }
}

<code block>

package com.github.pockethub.ui.gist;

import static com.github.pockethub.Intents.EXTRA_GIST_FILE;
import static com.github.pockethub.Intents.EXTRA_GIST_ID;
import static com.github.pockethub.util.PreferenceUtils.WRAP;
import android.accounts.Account;
import android.app.Activity;
import android.content.SharedPreferences;
import android.content.SharedPreferences.OnSharedPreferenceChangeListener;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.webkit.WebView;

import com.github.pockethub.R;
import com.github.pockethub.accounts.AuthenticatedUserTask;
import com.github.pockethub.core.gist.GistStore;
import com.github.pockethub.ui.DialogFragment;
import com.github.pockethub.util.PreferenceUtils;
import com.github.pockethub.util.SourceEditor;
import com.github.pockethub.util.ToastUtils;
import com.google.inject.Inject;

import java.io.IOException;
import java.util.Map;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.GistFile;


public class GistFileFragment extends DialogFragment implements
        OnSharedPreferenceChangeListener {

    private WebView webView;

    private String gistId;

    private GistFile file;

    private Gist gist;

    @Inject
    private GistStore store;

    private SourceEditor editor;

    private SharedPreferences codePrefs;

    private MenuItem wrapItem;

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);

        gistId = getStringExtra(EXTRA_GIST_ID);
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        file = (GistFile) getArguments().get(EXTRA_GIST_FILE);
        gist = store.getGist(gistId);
        if (gist == null)
            gist = new Gist().setId(gistId);

        codePrefs = PreferenceUtils.getCodePreferences(getActivity());
        codePrefs.registerOnSharedPreferenceChangeListener(this);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();

        codePrefs.unregisterOnSharedPreferenceChangeListener(this);
    }

    public void onDestroyView() {
        super.onDestroyView();
    }

    @Override
    public void onCreateOptionsMenu(Menu optionsMenu, MenuInflater inflater) {
        inflater.inflate(R.menu.code_view, optionsMenu);

        wrapItem = optionsMenu.findItem(R.id.m_wrap);
        updateWrapItem();
    }

    private void updateWrapItem() {
        if (wrapItem != null)
            if (codePrefs.getBoolean(WRAP, false))
                wrapItem.setTitle(R.string.disable_wrapping);
            else
                wrapItem.setTitle(R.string.enable_wrapping);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
        case R.id.m_wrap:
            if (editor.getWrap()) {
                item.setTitle(R.string.enable_wrapping);
                editor.setWrap(false);
            } else {
                item.setTitle(R.string.disable_wrapping);
                editor.setWrap(true);
            }
            PreferenceUtils.save(codePrefs.edit().putBoolean(WRAP,
                    editor.getWrap()));
            return true;
        default:
            return super.onOptionsItemSelected(item);
        }
    }

    private void loadSource() {
        new AuthenticatedUserTask<GistFile>(getActivity()) {

            @Override
            public GistFile run(Account account) throws Exception {
                gist = store.refreshGist(gistId);
                Map<String, GistFile> files = gist.getFiles();
                if (files == null)
                    throw new IOException();
                GistFile loadedFile = files.get(file.getFilename());
                if (loadedFile == null)
                    throw new IOException();
                return loadedFile;
            }

            @Override
            protected void onException(Exception e) throws RuntimeException {
                super.onException(e);

                ToastUtils.show(getActivity(), e, R.string.error_gist_file_load);
            }

            @Override
            protected void onSuccess(GistFile loadedFile) throws Exception {
                super.onSuccess(loadedFile);

                if (loadedFile == null)
                    return;

                file = loadedFile;
                getArguments().putSerializable(EXTRA_GIST_FILE, file);
                if (file.getContent() != null)
                    showSource();
            }

        }.execute();
    }

    private void showSource() {
        editor.setSource(file.getFilename(), file.getContent(), false);
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        return inflater.inflate(R.layout.gist_file_view, null);
    }

    @Override
    public void onViewCreated(View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        webView = finder.find(R.id.wv_code);

        editor = new SourceEditor(webView);
        editor.setWrap(PreferenceUtils.getCodePreferences(getActivity())
                .getBoolean(WRAP, false));

        if (file.getContent() != null)
            showSource();
        else
            loadSource();
    }

    @Override
    public void onSharedPreferenceChanged(SharedPreferences sharedPreferences,
            String key) {
        if (WRAP.equals(key)) {
            updateWrapItem();
            editor.setWrap(sharedPreferences.getBoolean(WRAP, false));
        }
    }
}

<code block>

package com.github.pockethub.ui.gist;

import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
import static android.content.Intent.FLAG_ACTIVITY_SINGLE_TOP;
import static com.github.pockethub.Intents.EXTRA_GIST_ID;
import static com.github.pockethub.Intents.EXTRA_POSITION;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.ActionBar;
import android.view.MenuItem;
import android.widget.ProgressBar;

import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.pockethub.Intents.Builder;
import com.github.pockethub.R;
import com.github.pockethub.core.gist.FullGist;
import com.github.pockethub.core.gist.GistStore;
import com.github.pockethub.core.gist.RefreshGistTask;
import com.github.pockethub.ui.FragmentProvider;
import com.github.pockethub.ui.PagerActivity;
import com.github.pockethub.ui.ViewPager;
import com.github.pockethub.util.AvatarLoader;
import com.github.pockethub.util.HttpImageGetter;
import com.google.inject.Inject;
import com.viewpagerindicator.TitlePageIndicator;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.User;


public class GistFilesViewActivity extends PagerActivity {


    public static Intent createIntent(Gist gist, int position) {
        return new Builder("gist.files.VIEW").gist(gist.getId())
            .add(EXTRA_POSITION, position).toIntent();
    }

    private String gistId;

    private int initialPosition;

    private ViewPager pager;

    private ProgressBar loadingBar;

    private TitlePageIndicator indicator;

    private Gist gist;

    @Inject
    private GistStore store;

    @Inject
    private AvatarLoader avatars;

    @Inject
    private HttpImageGetter imageGetter;

    private GistFilesPagerAdapter adapter;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        gistId = getStringExtra(EXTRA_GIST_ID);
        initialPosition = getIntExtra(EXTRA_POSITION);

        setContentView(R.layout.pager_with_title);

        setSupportActionBar((android.support.v7.widget.Toolbar) findViewById(R.id.toolbar));

        pager = finder.find(R.id.vp_pages);
        loadingBar = finder.find(R.id.pb_loading);
        indicator = finder.find(R.id.tpi_header);

        if (initialPosition < 0)
            initialPosition = 0;

        getSupportActionBar().setTitle(getString(R.string.gist_title) + gistId);

        gist = store.getGist(gistId);
        if (gist != null)
            configurePager();
        else {
            ViewUtils.setGone(loadingBar, false);
            ViewUtils.setGone(pager, true);
            ViewUtils.setGone(indicator, true);
            new RefreshGistTask(this, gistId, imageGetter) {

                @Override
                protected void onSuccess(FullGist gist) throws Exception {
                    super.onSuccess(gist);

                    GistFilesViewActivity.this.gist = gist.getGist();
                    configurePager();
                }

            }.execute();
        }
    }

    private void configurePager() {
        ActionBar actionBar = getSupportActionBar();
        actionBar.setDisplayHomeAsUpEnabled(true);
        User author = gist.getUser();
        if (author != null) {
            actionBar.setSubtitle(author.getLogin());
            avatars.bind(actionBar, author);
        } else
            actionBar.setSubtitle(R.string.anonymous);

        ViewUtils.setGone(loadingBar, true);
        ViewUtils.setGone(pager, false);
        ViewUtils.setGone(indicator, false);

        adapter = new GistFilesPagerAdapter(this, gist);
        pager.setAdapter(adapter);
        indicator.setViewPager(pager);

        if (initialPosition < adapter.getCount()) {
            pager.scheduleSetItem(initialPosition);
            onPageSelected(initialPosition);
        }
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                if (gist != null) {
                    Intent intent = GistsViewActivity.createIntent(gist);
                    intent.addFlags(FLAG_ACTIVITY_CLEAR_TOP
                        | FLAG_ACTIVITY_SINGLE_TOP);
                    startActivity(intent);
                }
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    protected FragmentProvider getProvider() {
        return adapter;
    }
}

<code block>

package com.github.pockethub.ui.gist;

import static com.github.pockethub.Intents.EXTRA_GIST_FILE;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v7.app.ActionBarActivity;

import com.github.pockethub.ui.FragmentPagerAdapter;

import java.util.Map;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.GistFile;


public class GistFilesPagerAdapter extends FragmentPagerAdapter {

    private final GistFile[] files;


    public GistFilesPagerAdapter(ActionBarActivity activity, Gist gist) {
        super(activity);

        Map<String, GistFile> gistFiles = gist.getFiles();
        if (gistFiles != null && !gistFiles.isEmpty())
            files = gistFiles.values().toArray(new GistFile[gistFiles.size()]);
        else
            files = new GistFile[0];
    }

    @Override
    public CharSequence getPageTitle(int position) {
        return files[position].getFilename();
    }

    @Override
    public Fragment getItem(final int position) {
        GistFile file = files[position];
        Fragment fragment = new GistFileFragment();
        Bundle args = new Bundle();
        args.putSerializable(EXTRA_GIST_FILE, file);
        fragment.setArguments(args);
        return fragment;
    }

    @Override
    public int getCount() {
        return files.length;
    }
}

<code block>

package com.github.pockethub.ui.gist;

import com.github.pockethub.core.ResourcePager;
import com.github.pockethub.core.gist.GistPager;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.client.PageIterator;


public class PublicGistsFragment extends GistsFragment {

    @Override
    protected ResourcePager<Gist> createPager() {
        return new GistPager(store) {

            @Override
            public PageIterator<Gist> createIterator(int page, int size) {
                return service.pagePublicGists(page, size);
            }
        };
    }
}

<code block>

package com.github.pockethub.ui.gist;

import static android.app.Activity.RESULT_OK;
import android.accounts.Account;
import android.app.Activity;
import android.util.Log;

import com.github.pockethub.R;
import com.github.pockethub.ui.ProgressDialogTask;
import com.github.pockethub.util.ToastUtils;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.service.GistService;


public class DeleteGistTask extends ProgressDialogTask<Gist> {

    private static final String TAG = "DeleteGistTask";

    private final String id;

    @Inject
    private GistService service;


    public DeleteGistTask(final Activity context, final String gistId) {
        super(context);

        id = gistId;
    }


    public void start() {
        showIndeterminate(R.string.deleting_gist);

        execute();
    }

    @Override
    public Gist run(Account account) throws Exception {
        service.deleteGist(id);
        return null;
    }

    @Override
    protected void onSuccess(Gist gist) throws Exception {
        super.onSuccess(gist);

        Activity activity = (Activity) getContext();
        activity.setResult(RESULT_OK);
        activity.finish();
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception deleting Gist", e);
        ToastUtils.show((Activity) getContext(), e.getMessage());
    }
}

<code block>
package com.github.pockethub.ui.gist;

import static com.github.pockethub.util.TypefaceUtils.ICON_PERSON;
import static com.github.pockethub.util.TypefaceUtils.ICON_STAR;
import static com.github.pockethub.util.TypefaceUtils.ICON_TEAM;
import android.os.Bundle;
import android.support.annotation.Nullable;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;

import com.github.pockethub.R;
import com.github.pockethub.ui.TabPagerFragment;

public class GistsPagerFragment extends TabPagerFragment<GistQueriesPagerAdapter> {

    @Override
    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        configureTabPager();
    }

    private void randomGist() {
        new RandomGistTask(this.getActivity()).start();
    }

    @Override
    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
        inflater.inflate(R.menu.gists, menu);
        super.onCreateOptionsMenu(menu, inflater);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.m_random:
                randomGist();
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    protected GistQueriesPagerAdapter createAdapter() {
        return new GistQueriesPagerAdapter(this);
    }

    @Override
    protected String getIcon(int position) {
        switch (position) {
            case 0:
                return ICON_PERSON;
            case 1:
                return ICON_STAR;
            case 2:
                return ICON_TEAM;
            default:
                return super.getIcon(position);
        }
    }
}

<code block>

package com.github.pockethub.ui.gist;

import static android.app.Activity.RESULT_OK;
import static com.github.pockethub.RequestCodes.GIST_CREATE;
import static com.github.pockethub.RequestCodes.GIST_VIEW;
import android.content.Intent;

import com.github.pockethub.accounts.GitHubAccount;
import com.github.pockethub.core.ResourcePager;
import com.github.pockethub.core.gist.GistPager;
import com.google.inject.Inject;
import com.google.inject.Provider;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.client.PageIterator;


public class MyGistsFragment extends GistsFragment {

    @Inject
    private Provider<GitHubAccount> accountProvider;

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if ((requestCode == GIST_CREATE || requestCode == GIST_VIEW)
                && RESULT_OK == resultCode) {
            forceRefresh();
            return;
        }

        super.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    protected ResourcePager<Gist> createPager() {
        return new GistPager(store) {

            @Override
            public PageIterator<Gist> createIterator(int page, int size) {
                return service.pageGists(accountProvider.get().getUsername(),
                        page, size);
            }
        };
    }
}

<code block>

package com.github.pockethub.ui.gist;

import static org.eclipse.egit.github.core.client.IGitHubConstants.SEGMENT_COMMENTS;
import static org.eclipse.egit.github.core.client.IGitHubConstants.SEGMENT_GISTS;
import android.accounts.Account;
import android.app.Activity;
import android.util.Log;

import com.github.pockethub.R;
import com.github.pockethub.ui.ProgressDialogTask;
import com.github.pockethub.util.HtmlUtils;
import com.github.pockethub.util.ToastUtils;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.service.GistService;


public class EditCommentTask extends ProgressDialogTask<Comment> {

    private static final String TAG = "EditCommentTask";

    @Inject
    private GistService service;

    private final Comment comment;

    private final String gistId;


    protected EditCommentTask(Activity activity, String gistId, Comment comment) {
        super(activity);

        this.gistId = gistId;
        this.comment = comment;
    }


    public EditCommentTask start() {
        showIndeterminate(R.string.editing_comment);
        execute();
        return this;
    }

    @Override
    public Comment run(Account account) throws Exception {
        Comment edited = editComment(gistId, comment);
        String formatted = HtmlUtils.format(edited.getBodyHtml()).toString();
        edited.setBodyHtml(formatted);
        return edited;

    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception editing comment on gist", e);

        ToastUtils.show((Activity) getContext(), e.getMessage());
    }


    private Comment editComment(String gistId, Comment comment)
            throws Exception {
        return service.getClient().post(SEGMENT_GISTS + '/' + gistId + SEGMENT_COMMENTS + '/' + comment.getId(), comment, Comment.class);
    }
}

<code block>

package com.github.pockethub.ui.gist;

import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
import static android.content.Intent.FLAG_ACTIVITY_SINGLE_TOP;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.ActionBar;
import android.text.Editable;
import android.text.TextUtils;
import android.view.Menu;
import android.view.MenuItem;
import android.widget.CheckBox;
import android.widget.EditText;

import com.github.pockethub.R;
import com.github.pockethub.ui.BaseActivity;
import com.github.pockethub.ui.MainActivity;
import com.github.pockethub.ui.TextWatcherAdapter;
import com.github.pockethub.util.ShareUtils;

import org.eclipse.egit.github.core.Gist;


public class CreateGistActivity extends BaseActivity {

    private EditText descriptionText;

    private EditText nameText;

    private EditText contentText;

    private CheckBox publicCheckBox;

    private MenuItem createItem;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.gist_create);

        setSupportActionBar((android.support.v7.widget.Toolbar) findViewById(R.id.toolbar));

        descriptionText = finder.find(R.id.et_gist_description);
        nameText = finder.find(R.id.et_gist_name);
        contentText = finder.find(R.id.et_gist_content);
        publicCheckBox = finder.find(R.id.cb_public);

        ActionBar actionBar = getSupportActionBar();
        actionBar.setTitle(R.string.new_gist);
        actionBar.setIcon(R.drawable.ic_github_gist_white_32dp);
        actionBar.setDisplayHomeAsUpEnabled(true);

        String text = ShareUtils.getBody(getIntent());
        if (!TextUtils.isEmpty(text))
            contentText.setText(text);

        String subject = ShareUtils.getSubject(getIntent());
        if (!TextUtils.isEmpty(subject))
            descriptionText.setText(subject);

        contentText.addTextChangedListener(new TextWatcherAdapter() {

            @Override
            public void afterTextChanged(Editable s) {
                updateCreateMenu(s);
            }
        });
        updateCreateMenu();
    }

    private void updateCreateMenu() {
        if (contentText != null)
            updateCreateMenu(contentText.getText());
    }

    private void updateCreateMenu(CharSequence text) {
        if (createItem != null)
            createItem.setEnabled(!TextUtils.isEmpty(text));
    }

    @Override
    public boolean onCreateOptionsMenu(Menu options) {
        getMenuInflater().inflate(R.menu.gist_create, options);
        createItem = options.findItem(R.id.m_apply);
        updateCreateMenu();
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.m_apply:
                createGist();
                return true;
            case android.R.id.home:
                finish();
                Intent intent = new Intent(this, MainActivity.class);
                intent.addFlags(FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_SINGLE_TOP);
                startActivity(intent);
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    private void createGist() {
        final boolean isPublic = publicCheckBox.isChecked();

        String enteredDescription = descriptionText.getText().toString().trim();
        final String description = enteredDescription.length() > 0 ? enteredDescription
            : getString(R.string.gist_description_hint);

        String enteredName = nameText.getText().toString().trim();
        final String name = enteredName.length() > 0 ? enteredName
            : getString(R.string.gist_file_name_hint);

        final String content = contentText.getText().toString();

        new CreateGistTask(this, description, isPublic, name, content) {

            @Override
            protected void onSuccess(Gist gist) throws Exception {
                super.onSuccess(gist);

                startActivity(GistsViewActivity.createIntent(gist));
                setResult(RESULT_OK);
                finish();
            }
        }.create();
    }
}

<code block>

package com.github.pockethub.ui.gist;

import android.app.Activity;
import android.text.TextUtils;
import android.view.View;
import android.widget.TextView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.pockethub.R;
import com.github.pockethub.ui.StyledText;
import com.github.pockethub.util.AvatarLoader;
import com.github.pockethub.util.TypefaceUtils;

import java.util.Collection;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.User;


public class GistListAdapter extends SingleTypeAdapter<Gist> {

    private final AvatarLoader avatars;

    private String anonymous;


    public GistListAdapter(AvatarLoader avatars, Activity activity,
            Collection<Gist> elements) {
        super(activity, R.layout.gist_item);

        this.avatars = avatars;
        setItems(elements);
    }

    @Override
    public long getItemId(final int position) {
        final String id = getItem(position).getId();
        return !TextUtils.isEmpty(id) ? id.hashCode() : super
                .getItemId(position);
    }

    @Override
    protected int[] getChildViewIds() {
        return new int[] { R.id.tv_gist_id, R.id.tv_gist_title, R.id.tv_gist_author,
                R.id.tv_gist_comments, R.id.tv_gist_files, R.id.iv_avatar };
    }

    @Override
    protected View initialize(View view) {
        view = super.initialize(view);

        TypefaceUtils.setOcticons(
                (TextView) view.findViewById(R.id.tv_comment_icon),
                (TextView) view.findViewById(R.id.tv_file_icon));
        anonymous = view.getResources().getString(R.string.anonymous);
        return view;
    }

    @Override
    protected void update(int position, Gist gist) {
        setText(0, gist.getId());

        String description = gist.getDescription();
        if (!TextUtils.isEmpty(description))
            setText(1, description);
        else
            setText(1, R.string.no_description_given);

        User user = gist.getUser();
        avatars.bind(imageView(5), user);

        StyledText authorText = new StyledText();
        if (user != null)
            authorText.bold(user.getLogin());
        else
            authorText.bold(anonymous);
        authorText.append(' ');
        authorText.append(gist.getCreatedAt());
        setText(2, authorText);

        setNumber(3, gist.getComments());
        setNumber(4, gist.getFiles().size());
    }
}

<code block>

package com.github.pockethub.ui.gist;

import static com.github.pockethub.RequestCodes.GIST_VIEW;
import android.accounts.Account;
import android.app.Activity;
import android.util.Log;

import com.github.pockethub.R;
import com.github.pockethub.core.gist.GistStore;
import com.github.pockethub.ui.ProgressDialogTask;
import com.github.pockethub.util.ToastUtils;
import com.google.inject.Inject;

import java.util.Collection;

import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.client.PageIterator;
import org.eclipse.egit.github.core.service.GistService;


public class RandomGistTask extends ProgressDialogTask<Gist> {

    private static final String TAG = "RandomGistTask";

    @Inject
    private GistService service;

    @Inject
    private GistStore store;


    public RandomGistTask(final Activity context) {
        super(context);
    }


    public void start() {
        showIndeterminate(R.string.random_gist);

        execute();
    }

    @Override
    protected Gist run(Account account) throws Exception {
        PageIterator<Gist> pages = service.pagePublicGists(1);
        pages.next();
        int randomPage = 1 + (int) (Math.random() * ((pages.getLastPage() - 1) + 1));

        Collection<Gist> gists = service.pagePublicGists(randomPage, 1).next();


        if (gists.isEmpty()) {
            randomPage = 1 + (int) (Math.random() * ((pages.getLastPage() - 1) + 1));
            gists = service.pagePublicGists(randomPage, 1).next();
        }

        if (gists.isEmpty())
            throw new IllegalArgumentException(getContext().getString(
                    R.string.no_gists_found));

        return store.addGist(gists.iterator().next());
    }

    @Override
    protected void onSuccess(Gist gist) throws Exception {
        super.onSuccess(gist);

        ((Activity) getContext()).startActivityForResult(
                GistsViewActivity.createIntent(gist), GIST_VIEW);
    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception opening random Gist", e);
        ToastUtils.show((Activity) getContext(), e.getMessage());
    }
}

<code block>

package com.github.pockethub.ui.gist;

import static com.github.pockethub.Intents.EXTRA_COMMENT;
import static com.github.pockethub.Intents.EXTRA_GIST;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.ActionBar;

import com.github.pockethub.Intents.Builder;
import com.github.pockethub.R;
import com.github.pockethub.ui.comment.CommentPreviewPagerAdapter;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.User;


public class EditCommentActivity extends
        com.github.pockethub.ui.comment.CreateCommentActivity {


    public static Intent createIntent(Gist gist, Comment comment) {
        Builder builder = new Builder("gist.comment.edit.VIEW");
        builder.gist(gist);
        builder.add(EXTRA_COMMENT, comment);
        return builder.toIntent();
    }

    private Gist gist;


    private Comment comment;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        gist = getSerializableExtra(EXTRA_GIST);
        comment = getSerializableExtra(EXTRA_COMMENT);
        super.onCreate(savedInstanceState);

        ActionBar actionBar = getSupportActionBar();
        actionBar.setTitle(getString(R.string.gist_title) + gist.getId());
        User user = gist.getUser();
        if (user != null)
            actionBar.setSubtitle(user.getLogin());
        avatars.bind(actionBar, user);
    }

    @Override
    protected void createComment(String comment) {
        editComment(comment);
    }


    protected void editComment(String commentText) {
        comment.setBody(commentText);

        new EditCommentTask(this, gist.getId(), comment) {
            @Override
            protected void onSuccess(Comment comment) throws Exception {
                super.onSuccess(comment);

                finish(comment);
            }
        }.start();
    }

    @Override
    protected CommentPreviewPagerAdapter createAdapter() {
        CommentPreviewPagerAdapter commentPreviewPagerAdapter = new CommentPreviewPagerAdapter(this, null);
        commentPreviewPagerAdapter.setCommentText(comment != null ? comment.getBody() : null);
        return commentPreviewPagerAdapter;
    }
}

<code block>

package com.github.pockethub.ui.gist;

import android.accounts.Account;
import android.app.Activity;
import android.util.Log;

import com.github.pockethub.R;
import com.github.pockethub.ui.ProgressDialogTask;
import com.github.pockethub.util.HtmlUtils;
import com.github.pockethub.util.ToastUtils;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Comment;
import org.eclipse.egit.github.core.Gist;
import org.eclipse.egit.github.core.service.GistService;


public class CreateCommentTask extends ProgressDialogTask<Comment> {

    private static final String TAG = "CreateCommentTask";

    @Inject
    private GistService service;

    private final String id;

    private final String comment;


    protected CreateCommentTask(Activity activity, String gistId, String comment) {
        super(activity);

        this.id = gistId;
        this.comment = comment;
    }


    public CreateCommentTask start() {
        showIndeterminate(R.string.creating_comment);
        execute();
        return this;
    }

    @Override
    public Comment run(Account account) throws Exception {
        Comment created = service.createComment(id, comment);
        String formatted = HtmlUtils.format(created.getBodyHtml()).toString();
        created.setBodyHtml(formatted);
        return created;

    }

    @Override
    protected void onException(Exception e) throws RuntimeException {
        super.onException(e);

        Log.d(TAG, "Exception creating comment on gist", e);

        ToastUtils.show((Activity) getContext(), e.getMessage());
    }
}

<code block>
package com.github.pockethub.ui.roboactivities;

import android.accounts.AccountAuthenticatorResponse;
import android.accounts.AccountManager;
import android.os.Bundle;
import android.support.v7.app.ActionBarActivity;


public class ActionBarAccountAuthenticatorActivity extends ActionBarActivity {
    private AccountAuthenticatorResponse mAccountAuthenticatorResponse = null;
    private Bundle mResultBundle = null;


    public final void setAccountAuthenticatorResult(Bundle result) {
        mResultBundle = result;
    }


    protected void onCreate(Bundle icicle) {
        super.onCreate(icicle);

        mAccountAuthenticatorResponse =
            getIntent().getParcelableExtra(AccountManager.KEY_ACCOUNT_AUTHENTICATOR_RESPONSE);

        if (mAccountAuthenticatorResponse != null) {
            mAccountAuthenticatorResponse.onRequestContinued();
        }
    }


    public void finish() {
        if (mAccountAuthenticatorResponse != null) {

            if (mResultBundle != null) {
                mAccountAuthenticatorResponse.onResult(mResultBundle);
            } else {
                mAccountAuthenticatorResponse.onError(AccountManager.ERROR_CODE_CANCELED,
                    "canceled");
            }
            mAccountAuthenticatorResponse = null;
        }
        super.finish();
    }
}
<code block>
package com.github.pockethub.ui.roboactivities;

import android.accounts.AccountAuthenticatorActivity;
import android.content.Intent;
import android.content.res.Configuration;
import android.os.Bundle;

import com.google.inject.Key;

import java.util.HashMap;
import java.util.Map;

import roboguice.RoboGuice;
import roboguice.activity.event.OnActivityResultEvent;
import roboguice.activity.event.OnConfigurationChangedEvent;
import roboguice.activity.event.OnContentChangedEvent;
import roboguice.activity.event.OnCreateEvent;
import roboguice.activity.event.OnDestroyEvent;
import roboguice.activity.event.OnNewIntentEvent;
import roboguice.activity.event.OnPauseEvent;
import roboguice.activity.event.OnRestartEvent;
import roboguice.activity.event.OnResumeEvent;
import roboguice.activity.event.OnStartEvent;
import roboguice.activity.event.OnStopEvent;
import roboguice.event.EventManager;
import roboguice.inject.RoboInjector;
import roboguice.util.RoboContext;


public class RoboActionBarAccountAuthenticatorActivity extends ActionBarAccountAuthenticatorActivity implements RoboContext {
    protected EventManager eventManager;
    protected HashMap<Key<?>, Object> scopedObjects = new HashMap<>();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        final RoboInjector injector = RoboGuice.getInjector(this);
        eventManager = injector.getInstance(EventManager.class);
        injector.injectMembersWithoutViews(this);
        super.onCreate(savedInstanceState);
        eventManager.fire(new OnCreateEvent(savedInstanceState));
    }

    @Override
    protected void onRestart() {
        super.onRestart();
        eventManager.fire(new OnRestartEvent());
    }

    @Override
    protected void onStart() {
        super.onStart();
        eventManager.fire(new OnStartEvent());
    }

    @Override
    protected void onResume() {
        super.onResume();
        eventManager.fire(new OnResumeEvent());
    }

    @Override
    protected void onPause() {
        super.onPause();
        eventManager.fire(new OnPauseEvent());
    }

    @Override
    protected void onNewIntent( Intent intent ) {
        super.onNewIntent(intent);
        eventManager.fire(new OnNewIntentEvent());
    }

    @Override
    protected void onStop() {
        try {
            eventManager.fire(new OnStopEvent());
        } finally {
            super.onStop();
        }
    }

    @Override
    protected void onDestroy() {
        try {
            eventManager.fire(new OnDestroyEvent());
        } finally {
            try {
                RoboGuice.destroyInjector(this);
            } finally {
                super.onDestroy();
            }
        }
    }

    @Override
    public void onConfigurationChanged(Configuration newConfig) {
        final Configuration currentConfig = getResources().getConfiguration();
        super.onConfigurationChanged(newConfig);
        eventManager.fire(new OnConfigurationChangedEvent(currentConfig, newConfig));
    }

    @Override
    public void onSupportContentChanged() {
        super.onSupportContentChanged();
        RoboGuice.getInjector(this).injectViewMembers(this);
        eventManager.fire(new OnContentChangedEvent());
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        eventManager.fire(new OnActivityResultEvent(requestCode, resultCode, data));
    }

    @Override
    public Map<Key<?>, Object> getScopedObjectMap() {
        return scopedObjects;
    }
}

<code block>
package com.github.pockethub.ui.roboactivities;

import roboguice.RoboGuice;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.view.View;


public abstract class RoboSupportFragment extends Fragment {

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        RoboGuice.getInjector(getActivity()).injectMembersWithoutViews(this);
    }

    @Override
    public void onViewCreated(View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        RoboGuice.getInjector(getActivity()).injectViewMembers(this);
    }
}

<code block>
package com.github.pockethub.ui.roboactivities;

import android.content.Intent;
import android.content.res.Configuration;
import android.os.Bundle;
import android.support.v7.app.ActionBarActivity;

import com.google.inject.Key;

import java.util.HashMap;
import java.util.Map;

import roboguice.RoboGuice;
import roboguice.activity.event.OnActivityResultEvent;
import roboguice.activity.event.OnConfigurationChangedEvent;
import roboguice.activity.event.OnContentChangedEvent;
import roboguice.activity.event.OnCreateEvent;
import roboguice.activity.event.OnDestroyEvent;
import roboguice.activity.event.OnNewIntentEvent;
import roboguice.activity.event.OnPauseEvent;
import roboguice.activity.event.OnRestartEvent;
import roboguice.activity.event.OnResumeEvent;
import roboguice.activity.event.OnStartEvent;
import roboguice.activity.event.OnStopEvent;
import roboguice.event.EventManager;
import roboguice.inject.RoboInjector;
import roboguice.util.RoboContext;


public class RoboActionBarActivity extends ActionBarActivity implements RoboContext {

    protected EventManager eventManager;
    protected HashMap<Key<?>, Object> scopedObjects = new HashMap<>();

    @Override
    protected void onCreate( Bundle savedInstanceState ) {

        final RoboInjector injector = RoboGuice.getInjector(this);
        eventManager = injector.getInstance( EventManager.class );
        injector.injectMembersWithoutViews( this );
        super.onCreate( savedInstanceState );
        eventManager.fire( new OnCreateEvent( savedInstanceState ) );
    }

    @Override
    protected void onRestart() {

        super.onRestart();
        eventManager.fire( new OnRestartEvent() );
    }

    @Override
    protected void onStart() {

        super.onStart();
        eventManager.fire( new OnStartEvent() );
    }

    @Override
    protected void onResume() {

        super.onResume();
        eventManager.fire( new OnResumeEvent() );
    }

    @Override
    protected void onPause() {

        super.onPause();
        eventManager.fire( new OnPauseEvent() );
    }

    @Override
    protected void onNewIntent( Intent intent ) {

        super.onNewIntent( intent );
        eventManager.fire( new OnNewIntentEvent() );
    }

    @Override
    protected void onStop() {

        try {
            eventManager.fire( new OnStopEvent() );
        }
        finally {
            super.onStop();
        }
    }

    @Override
    protected void onDestroy() {

        try {
            eventManager.fire( new OnDestroyEvent() );
        }
        finally {
            try {
                RoboGuice.destroyInjector( this );
            }
            finally {
                super.onDestroy();
            }
        }
    }

    @Override
    public void onConfigurationChanged( Configuration newConfig ) {

        final Configuration currentConfig = getResources().getConfiguration();
        super.onConfigurationChanged( newConfig );
        eventManager.fire( new OnConfigurationChangedEvent( currentConfig, newConfig ) );
    }

    @Override
    public void onSupportContentChanged() {

        super.onSupportContentChanged();
        RoboGuice.getInjector( this ).injectViewMembers( this );
        eventManager.fire( new OnContentChangedEvent() );
    }

    @Override
    protected void onActivityResult( int requestCode, int resultCode, Intent data ) {

        super.onActivityResult( requestCode, resultCode, data );
        eventManager.fire( new OnActivityResultEvent( requestCode, resultCode, data ) );
    }

    @Override
    public Map<Key<?>, Object> getScopedObjectMap() {

        return scopedObjects;
    }
}

<code block>

package com.github.pockethub.ui.repo;

import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
import static android.content.Intent.FLAG_ACTIVITY_SINGLE_TOP;
import static com.github.pockethub.Intents.EXTRA_REPOSITORY;
import android.content.Intent;
import android.os.Bundle;
import android.support.v7.app.ActionBar;
import android.view.MenuItem;

import com.github.pockethub.Intents;
import com.github.pockethub.R;
import com.github.pockethub.ui.DialogFragmentActivity;
import com.github.pockethub.util.AvatarLoader;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;


public class RepositoryContributorsActivity extends DialogFragmentActivity {


    public static Intent createIntent(Repository repository) {
        return new Intents.Builder("repo.contributors.VIEW").repo(repository).toIntent();
    }

    private Repository repository;

    @Inject
    private AvatarLoader avatars;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.repo_contributors);

        repository = getSerializableExtra(EXTRA_REPOSITORY);

        setSupportActionBar((android.support.v7.widget.Toolbar) findViewById(R.id.toolbar));

        ActionBar actionBar = getSupportActionBar();
        actionBar.setTitle(repository.getName());
        actionBar.setSubtitle(R.string.contributors);
        actionBar.setDisplayHomeAsUpEnabled(true);

        User owner = repository.getOwner();
        avatars.bind(getSupportActionBar(), owner);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                Intent intent = RepositoryViewActivity.createIntent(repository);
                intent.addFlags(FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_SINGLE_TOP);
                startActivity(intent);
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }
}

<code block>

package com.github.pockethub.ui.repo;

import static com.github.pockethub.Intents.EXTRA_USER;
import static com.github.pockethub.RequestCodes.REPOSITORY_VIEW;
import static com.github.pockethub.ResultCodes.RESOURCE_CHANGED;
import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.widget.ListView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.pockethub.R;
import com.github.pockethub.core.ResourcePager;
import com.github.pockethub.ui.PagedItemFragment;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.client.PageIterator;
import org.eclipse.egit.github.core.service.RepositoryService;


public class UserRepositoryListFragment extends PagedItemFragment<Repository> {

    @Inject
    private RepositoryService service;

    private User user;

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);

        user = getSerializableExtra(EXTRA_USER);
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        setEmptyText(R.string.no_repositories);
    }

    @Override
    protected ResourcePager<Repository> createPager() {
        return new ResourcePager<Repository>() {

            @Override
            protected Object getId(Repository resource) {
                return resource.getId();
            }

            @Override
            public PageIterator<Repository> createIterator(int page, int size) {
                return service.pageRepositories(user.getLogin(), page, size);
            }
        };
    }

    @Override
    protected int getLoadingMessage() {
        return R.string.loading_repositories;
    }

    @Override
    protected int getErrorMessage(Exception exception) {
        return R.string.error_repos_load;
    }

    @Override
    protected SingleTypeAdapter<Repository> createAdapter(List<Repository> items) {
        return new UserRepositoryListAdapter(getActivity().getLayoutInflater(),
                items.toArray(new Repository[items.size()]), user);
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (requestCode == REPOSITORY_VIEW && resultCode == RESOURCE_CHANGED) {
            forceRefresh();
            return;
        }

        super.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    public void onListItemClick(ListView list, View v, int position, long id) {
        Repository repo = (Repository) list.getItemAtPosition(position);
        startActivityForResult(RepositoryViewActivity.createIntent(repo),
                REPOSITORY_VIEW);
    }
}

<code block>

package com.github.pockethub.ui.repo;

import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
import static android.content.Intent.FLAG_ACTIVITY_SINGLE_TOP;
import static com.github.pockethub.Intents.EXTRA_REPOSITORY;
import static com.github.pockethub.ResultCodes.RESOURCE_CHANGED;
import static com.github.pockethub.ui.repo.RepositoryPagerAdapter.ITEM_CODE;
import static com.github.pockethub.util.TypefaceUtils.ICON_CODE;
import static com.github.pockethub.util.TypefaceUtils.ICON_COMMIT;
import static com.github.pockethub.util.TypefaceUtils.ICON_ISSUE_OPEN;
import static com.github.pockethub.util.TypefaceUtils.ICON_NEWS;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.support.v7.app.ActionBar;
import android.text.TextUtils;
import android.view.Menu;
import android.view.MenuItem;
import android.widget.ProgressBar;

import com.afollestad.materialdialogs.MaterialDialog;
import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.pockethub.Intents.Builder;
import com.github.pockethub.R;
import com.github.pockethub.core.repo.DeleteRepositoryTask;
import com.github.pockethub.core.repo.ForkRepositoryTask;
import com.github.pockethub.core.repo.RefreshRepositoryTask;
import com.github.pockethub.core.repo.RepositoryUtils;
import com.github.pockethub.core.repo.StarRepositoryTask;
import com.github.pockethub.core.repo.StarredRepositoryTask;
import com.github.pockethub.core.repo.UnstarRepositoryTask;
import com.github.pockethub.ui.TabPagerActivity;
import com.github.pockethub.ui.user.UriLauncherActivity;
import com.github.pockethub.ui.user.UserViewActivity;
import com.github.pockethub.util.AvatarLoader;
import com.github.pockethub.util.ShareUtils;
import com.github.pockethub.util.ToastUtils;
import com.google.inject.Inject;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.service.RepositoryService;
import org.eclipse.egit.github.core.service.UserService;


public class RepositoryViewActivity extends TabPagerActivity<RepositoryPagerAdapter> {
    public static final String TAG = "RepositoryViewActivity";

    @Inject
    private RepositoryService repositoryService;

    @Inject
    private UserService userService;


    public static Intent createIntent(Repository repository) {
        return new Builder("repo.VIEW").repo(repository).toIntent();
    }

    private Repository repository;

    @Inject
    private AvatarLoader avatars;

    private ProgressBar loadingBar;

    private boolean isStarred;

    private boolean starredStatusChecked;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        repository = getSerializableExtra(EXTRA_REPOSITORY);

        loadingBar = finder.find(R.id.progress_bar);

        User owner = repository.getOwner();

        ActionBar actionBar = getSupportActionBar();
        actionBar.setTitle(repository.getName());
        actionBar.setSubtitle(owner.getLogin());
        actionBar.setDisplayHomeAsUpEnabled(true);

        if (owner.getAvatarUrl() != null && RepositoryUtils.isComplete(repository))
            configurePager();
        else {
            avatars.bind(getSupportActionBar(), owner);
            ViewUtils.setGone(loadingBar, false);
            setGone(true);
            new RefreshRepositoryTask(this, repository) {

                @Override
                protected void onSuccess(Repository fullRepository) throws Exception {
                    super.onSuccess(fullRepository);

                    repository = fullRepository;
                    configurePager();
                }

                @Override
                protected void onException(Exception e) throws RuntimeException {
                    super.onException(e);

                    ToastUtils.show(RepositoryViewActivity.this, R.string.error_repo_load);
                    ViewUtils.setGone(loadingBar, true);
                }
            }.execute();
        }
    }

    @Override
    public boolean onCreateOptionsMenu(Menu optionsMenu) {
        getMenuInflater().inflate(R.menu.repository, optionsMenu);
        return super.onCreateOptionsMenu(optionsMenu);
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        MenuItem followItem = menu.findItem(R.id.m_star);

        followItem.setVisible(starredStatusChecked);
        followItem.setTitle(isStarred ? R.string.unstar : R.string.star);

        return super.onPrepareOptionsMenu(menu);
    }

    @Override
    public void onBackPressed() {
        if (adapter == null || pager.getCurrentItem() != ITEM_CODE || !adapter.onBackPressed())
            super.onBackPressed();
    }

    private void configurePager() {
        avatars.bind(getSupportActionBar(), repository.getOwner());
        configureTabPager();
        ViewUtils.setGone(loadingBar, true);
        setGone(false);
        checkStarredRepositoryStatus();
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.m_star:
                starRepository();
                return true;
            case R.id.m_fork:
                forkRepository();
                return true;
            case R.id.m_contributors:
                startActivity(RepositoryContributorsActivity.createIntent(repository));
                return true;
            case R.id.m_share:
                shareRepository();
                return true;
            case R.id.m_delete:
                deleteRepository();
                return true;
            case R.id.m_refresh:
                checkStarredRepositoryStatus();
                return super.onOptionsItemSelected(item);
            case android.R.id.home:
                finish();
                Intent intent = UserViewActivity.createIntent(repository.getOwner());
                intent.addFlags(FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_SINGLE_TOP);
                startActivity(intent);
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    public void onDialogResult(int requestCode, int resultCode, Bundle arguments) {
        adapter.onDialogResult(pager.getCurrentItem(), requestCode, resultCode, arguments);
    }

    @Override
    protected RepositoryPagerAdapter createAdapter() {
        return new RepositoryPagerAdapter(this, repository.isHasIssues());
    }

    @Override
    protected int getContentView() {
        return R.layout.tabbed_progress_pager;
    }

    @Override
    protected String getIcon(int position) {
        switch (position) {
            case 0:
                return ICON_NEWS;
            case 1:
                return ICON_CODE;
            case 2:
                return ICON_COMMIT;
            case 3:
                return ICON_ISSUE_OPEN;
            default:
                return super.getIcon(position);
        }
    }

    private void starRepository() {
        if (isStarred)
            new UnstarRepositoryTask(this, repository) {

                @Override
                protected void onSuccess(Void v) throws Exception {
                    super.onSuccess(v);

                    isStarred = !isStarred;
                    setResult(RESOURCE_CHANGED);
                }

                @Override
                protected void onException(Exception e) throws RuntimeException {
                    super.onException(e);

                    ToastUtils.show(RepositoryViewActivity.this, R.string.error_unstarring_repository);
                }
            }.start();
        else
            new StarRepositoryTask(this, repository) {

                @Override
                protected void onSuccess(Void v) throws Exception {
                    super.onSuccess(v);

                    isStarred = !isStarred;
                    setResult(RESOURCE_CHANGED);
                }

                @Override
                protected void onException(Exception e) throws RuntimeException {
                    super.onException(e);

                    ToastUtils.show(RepositoryViewActivity.this, R.string.error_starring_repository);
                }
            }.start();
    }

    private void checkStarredRepositoryStatus() {
        starredStatusChecked = false;
        new StarredRepositoryTask(this, repository) {

            @Override
            protected void onSuccess(Boolean watching) throws Exception {
                super.onSuccess(watching);

                isStarred = watching;
                starredStatusChecked = true;
                invalidateOptionsMenu();
            }
        }.execute();
    }

    private void shareRepository() {
        String repoUrl = repository.getHtmlUrl();
        if (TextUtils.isEmpty(repoUrl))
            repoUrl = "https://github.com/" + repository.generateId();
        Intent sharingIntent = ShareUtils.create(repository.generateId(), repoUrl);
        startActivity(sharingIntent);
    }

    private void forkRepository() {
        new ForkRepositoryTask(this, repository) {

            @Override
            protected void onSuccess(Repository e) throws Exception {
                super.onSuccess(e);

                if (e != null) {
                    UriLauncherActivity.launchUri(getContext(), Uri.parse(e.getHtmlUrl()));
                } else {
                    ToastUtils.show(RepositoryViewActivity.this, R.string.error_forking_repository);
                }
            }

            @Override
            protected void onException(Exception e) throws RuntimeException {
                super.onException(e);

                ToastUtils.show(RepositoryViewActivity.this, R.string.error_forking_repository);
            }
        }.start();
    }

    private void deleteRepository() {
        new MaterialDialog.Builder(this)
                .title(R.string.are_you_sure)
                .content(R.string.unexpected_bad_things)
                .positiveText(R.string.not_sure)
                .negativeText(R.string.delete_cap)
                .callback(new MaterialDialog.ButtonCallback() {
                    @Override
                    public void onPositive(MaterialDialog dialog) {
                        super.onPositive(dialog);
                        dialog.dismiss();
                    }

                    @Override
                    public void onNegative(MaterialDialog dialog) {
                        super.onNegative(dialog);
                        dialog.dismiss();

                        new DeleteRepositoryTask(RepositoryViewActivity.this, repository) {

                            @Override
                            protected void onSuccess(Void v) throws Exception {
                                super.onSuccess(v);
                                onBackPressed();
                                ToastUtils.show(RepositoryViewActivity.this, R.string.delete_successful);
                            }

                            @Override
                            protected void onException(Exception e) throws RuntimeException {
                                super.onException(e);

                                ToastUtils.show(RepositoryViewActivity.this, R.string.error_deleting_repository);
                            }
                        }.start();
                    }
                })
                .show();
    }
}

<code block>

package com.github.pockethub.ui.repo;

import android.view.LayoutInflater;
import android.view.View;
import android.widget.TextView;

import com.github.pockethub.R;
import com.github.pockethub.ui.StyledText;
import com.github.pockethub.util.TypefaceUtils;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;


public class UserRepositoryListAdapter extends
        RepositoryListAdapter<Repository> {

    private final String login;

    private int descriptionColor;


    public UserRepositoryListAdapter(LayoutInflater inflater,
            Repository[] elements, User user) {
        super(R.layout.user_repo_item, inflater, elements);

        login = user.getLogin();
    }

    @Override
    public long getItemId(final int position) {
        return getItem(position).getId();
    }

    @Override
    protected View initialize(View view) {
        view = super.initialize(view);

        TypefaceUtils.setOcticons(textView(view, 0),
                (TextView) view.findViewById(R.id.tv_forks_icon),
                (TextView) view.findViewById(R.id.tv_watchers_icon));
        descriptionColor = view.getResources().getColor(R.color.text_description);
        return view;
    }

    @Override
    protected int[] getChildViewIds() {
        return new int[] { R.id.tv_repo_icon, R.id.tv_repo_description,
                R.id.tv_language, R.id.tv_watchers, R.id.tv_forks, R.id.tv_repo_name };
    }

    @Override
    protected void update(int position, Repository repository) {
        StyledText name = new StyledText();
        if (!login.equals(repository.getOwner().getLogin()))
            name.foreground(repository.getOwner().getLogin(), descriptionColor)
                    .foreground('/', descriptionColor);
        name.bold(repository.getName());
        setText(5, name);

        updateDetails(repository.getDescription(), repository.getLanguage(),
                repository.getWatchers(), repository.getForks(),
                repository.isPrivate(), repository.isFork(),
                repository.getMirrorUrl());
    }
}

<code block>

package com.github.pockethub.ui.repo;

import static com.github.pockethub.util.TypefaceUtils.ICON_FORK;
import static com.github.pockethub.util.TypefaceUtils.ICON_MIRROR_PRIVATE;
import static com.github.pockethub.util.TypefaceUtils.ICON_MIRROR_PUBLIC;
import static com.github.pockethub.util.TypefaceUtils.ICON_PRIVATE;
import static com.github.pockethub.util.TypefaceUtils.ICON_PUBLIC;
import android.text.TextUtils;
import android.view.LayoutInflater;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.kevinsawicki.wishlist.ViewUtils;


public abstract class RepositoryListAdapter<V> extends SingleTypeAdapter<V> {


    public RepositoryListAdapter(int viewId, LayoutInflater inflater,
            Object[] elements) {
        super(inflater, viewId);

        setItems(elements);
    }


    protected void updateDetails(final String description,
            final String language, final int watchers, final int forks,
            final boolean isPrivate, final boolean isFork,
            final String mirrorUrl) {
        if (TextUtils.isEmpty(mirrorUrl))
            if (isPrivate)
                setText(0, ICON_PRIVATE);
            else if (isFork)
                setText(0, ICON_FORK);
            else
                setText(0, ICON_PUBLIC);
        else {
            if (isPrivate)
                setText(0, ICON_MIRROR_PRIVATE);
            else
                setText(0, ICON_MIRROR_PUBLIC);
        }

        if (!TextUtils.isEmpty(description))
            ViewUtils.setGone(setText(1, description), false);
        else
            setGone(1, true);

        if (!TextUtils.isEmpty(language))
            ViewUtils.setGone(setText(2, language), false);
        else
            setGone(2, true);

        setNumber(3, watchers);
        setNumber(4, forks);
    }
}

<code block>

package com.github.pockethub.ui.repo;

import android.accounts.Account;
import android.app.Activity;
import android.util.Log;

import com.github.pockethub.R;
import com.github.pockethub.accounts.AuthenticatedUserLoader;
import com.github.pockethub.core.user.UserComparator;
import com.github.pockethub.persistence.AccountDataManager;
import com.github.pockethub.util.ToastUtils;
import com.google.inject.Inject;
import com.google.inject.Provider;

import java.io.IOException;
import java.util.Collections;
import java.util.List;

import org.eclipse.egit.github.core.User;


public class OrganizationLoader extends AuthenticatedUserLoader<List<User>> {

    private static final String TAG = "OrganizationLoader";

    private final Provider<UserComparator> userComparatorProvider;

    private final AccountDataManager accountDataManager;


    @Inject
    public OrganizationLoader(Activity activity,
            AccountDataManager accountDataManager,
            Provider<UserComparator> userComparatorProvider) {
        super(activity);

        this.accountDataManager = accountDataManager;
        this.userComparatorProvider = userComparatorProvider;
    }

    @Override
    protected List<User> getAccountFailureData() {
        return Collections.emptyList();
    }

    @Override
    public List<User> load(final Account account) {
        List<User> orgs;
        try {
            orgs = accountDataManager.getOrgs(false);
        } catch (final IOException e) {
            Log.e(TAG, "Exception loading organizations", e);
            ToastUtils.show(activity, e, R.string.error_orgs_load);
            return Collections.emptyList();
        }
        Collections.sort(orgs, userComparatorProvider.get());
        return orgs;
    }
}

<code block>

package com.github.pockethub.ui.repo;

import static com.github.pockethub.Intents.EXTRA_REPOSITORY;
import android.app.Activity;
import android.os.Bundle;
import android.support.v4.content.Loader;
import android.view.View;
import android.widget.ListView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.pockethub.R;
import com.github.pockethub.ThrowableLoader;
import com.github.pockethub.accounts.AccountUtils;
import com.github.pockethub.core.user.RefreshUserTask;
import com.github.pockethub.ui.ItemListFragment;
import com.github.pockethub.ui.user.UserViewActivity;
import com.github.pockethub.util.AvatarLoader;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.egit.github.core.Contributor;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.service.RepositoryService;


public class RepositoryContributorsFragment extends ItemListFragment<Contributor> {


    @Inject
    protected AvatarLoader avatars;


    @Inject
    protected RepositoryService service;

    private Repository repo;

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);

        repo = getSerializableExtra(EXTRA_REPOSITORY);
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        setEmptyText(R.string.no_contributors);
    }

    @Override
    public Loader<List<Contributor>> onCreateLoader(int id, Bundle args) {
        return new ThrowableLoader<List<Contributor>>(getActivity(), items) {

            @Override
            public List<Contributor> loadData() throws Exception {
                return service.getContributors(repo, false);
            }
        };
    }

    @Override
    protected SingleTypeAdapter<Contributor> createAdapter(List<Contributor> items) {
        return new ContributorListAdapter(getActivity(),
                items.toArray(new Contributor[items.size()]), avatars);
    }

    @Override
    public void onListItemClick(ListView l, View v, int position, long id) {
        final Contributor contributor = (Contributor) l.getItemAtPosition(position);
        new RefreshUserTask(getActivity(), contributor.getLogin()) {

            @Override
            protected void onSuccess(User user) throws Exception {
                super.onSuccess(user);

                if (!AccountUtils.isUser(getActivity(), user))
                    startActivity(UserViewActivity.createIntent(user));
            }
        }.execute();
    }

    @Override
    protected int getErrorMessage(Exception exception) {
        return R.string.error_contributors_load;
    }
}

<code block>

package com.github.pockethub.ui.repo;

import static java.lang.String.CASE_INSENSITIVE_ORDER;
import android.content.Context;
import android.os.AsyncTask;

import com.github.pockethub.RequestReader;
import com.github.pockethub.RequestWriter;

import java.io.File;
import java.io.Serializable;
import java.util.Comparator;
import java.util.Iterator;
import java.util.LinkedHashSet;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;


public class RecentRepositories implements Comparator<Repository>, Serializable {


    public static final int MAX_SIZE = 5;

    private static final long serialVersionUID = 580345177644233739L;

    private static final int VERSION = 2;

    private static File getFile(final Context context, final User organization) {
        return new File(context.getFilesDir(), "recent-repos-"
                + organization.getId() + ".ser");
    }

    private LinkedHashSet<Long> ids;

    private final File file;

    private int id;


    public RecentRepositories(final Context context, final User organization) {
        file = getFile(context, organization);
        id = organization.getId();
    }

    private void load() {
        LinkedHashSet<Long> loaded = new RequestReader(file, VERSION).read();
        if (loaded == null)
            loaded = new LinkedHashSet<>();
        ids = loaded;
        trim();
    }

    private void trim() {
        Iterator<Long> iterator = ids.iterator();
        while (iterator.hasNext() && ids.size() > MAX_SIZE) {
            iterator.next();
            iterator.remove();
        }
    }


    public RecentRepositories add(final Repository repo) {
        return repo != null ? add(repo.getId()) : this;
    }


    public RecentRepositories add(final long id) {
        if (ids == null)
            load();
        ids.remove(id);
        ids.add(id);
        trim();
        return this;
    }


    public RecentRepositories remove(final Repository repo) {
        return repo != null ? remove(repo.getId()) : this;
    }


    public RecentRepositories remove(final long id) {
        if (ids == null)
            load();
        ids.remove(id);
        return this;
    }


    public RecentRepositories saveAsync() {
        if (ids != null)
            new AsyncTask<Void, Void, Void>() {

                @Override
                protected Void doInBackground(Void... params) {
                    save();
                    return null;
                }
            }.execute();
        return this;
    }


    public RecentRepositories save() {
        final LinkedHashSet<Long> save = ids;
        if (save != null)
            new RequestWriter(file, VERSION).write(save);
        return this;
    }


    public boolean contains(Repository repository) {
        return repository != null && contains(repository.getId());
    }


    public boolean contains(long id) {
        if (ids == null)
            load();
        return ids.contains(id);
    }

    @Override
    public int compare(final Repository lhs, final Repository rhs) {
        final boolean lRecent = contains(lhs);
        final boolean rRecent = contains(rhs);
        if (lRecent && !rRecent)
            return -1;
        if (!lRecent && rRecent)
            return 1;

        final int order = CASE_INSENSITIVE_ORDER.compare(lhs.getName(),
                rhs.getName());
        if (order == 0)
            if (id == lhs.getOwner().getId())
                return -1;
            else if (id == rhs.getOwner().getId())
                return 1;
            else
                return CASE_INSENSITIVE_ORDER.compare(
                        lhs.getOwner().getLogin(), rhs.getOwner().getLogin());
        else
            return order;
    }
}

<code block>

package com.github.pockethub.ui.repo;

import android.content.Context;
import android.view.LayoutInflater;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.pockethub.R;
import com.github.pockethub.util.AvatarLoader;

import org.eclipse.egit.github.core.Contributor;


public class ContributorListAdapter extends SingleTypeAdapter<Contributor> {

    private final Context context;

    private final AvatarLoader avatars;


    public ContributorListAdapter(final Context context,
            final Contributor[] elements, final AvatarLoader avatars) {
        super(LayoutInflater.from(context), R.layout.contributor_item);

        this.context = context.getApplicationContext();
        this.avatars = avatars;
        setItems(elements);
    }

    @Override
    public long getItemId(final int position) {
        return getItem(position).getId();
    }

    @Override
    protected int[] getChildViewIds() {
        return new int[] { R.id.iv_avatar, R.id.tv_login, R.id.tv_contributions };
    }

    @Override
    protected void update(int position, Contributor contributor) {
        avatars.bind(imageView(0), contributor);
        setText(1, contributor.getLogin());
        setText(2, context.getString(R.string.contributions, contributor.getContributions()));
    }
}

<code block>

package com.github.pockethub.ui.repo;

import android.content.res.Resources;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v7.app.ActionBarActivity;

import com.github.pockethub.R;
import com.github.pockethub.ui.FragmentPagerAdapter;
import com.github.pockethub.ui.code.RepositoryCodeFragment;
import com.github.pockethub.ui.commit.CommitListFragment;
import com.github.pockethub.ui.issue.IssuesFragment;


public class RepositoryPagerAdapter extends FragmentPagerAdapter {


    public static final int ITEM_CODE = 1;


    public static final int ITEM_COMMITS = 2;

    private final Resources resources;

    private final boolean hasIssues;

    private RepositoryCodeFragment codeFragment;

    private CommitListFragment commitsFragment;


    public RepositoryPagerAdapter(ActionBarActivity activity,
            boolean hasIssues) {
        super(activity);

        resources = activity.getResources();
        this.hasIssues = hasIssues;
    }

    @Override
    public CharSequence getPageTitle(int position) {
        switch (position) {
        case 0:
            return resources.getString(R.string.tab_news);
        case 1:
            return resources.getString(R.string.tab_code);
        case 2:
            return resources.getString(R.string.tab_commits);
        case 3:
            return resources.getString(R.string.tab_issues);
        default:
            return null;
        }
    }

    @Override
    public Fragment getItem(int position) {
        switch (position) {
        case 0:
            return new RepositoryNewsFragment();
        case 1:
            codeFragment = new RepositoryCodeFragment();
            return codeFragment;
        case 2:
            commitsFragment = new CommitListFragment();
            return commitsFragment;
        case 3:
            return new IssuesFragment();
        default:
            return null;
        }
    }

    @Override
    public int getCount() {
        return hasIssues ? 4 : 3;
    }


    public boolean onBackPressed() {
        return codeFragment != null && codeFragment.onBackPressed();
    }


    public RepositoryPagerAdapter onDialogResult(int position, int requestCode,
            int resultCode, Bundle arguments) {
        if (position == ITEM_CODE && codeFragment != null)
            codeFragment.onDialogResult(requestCode, resultCode, arguments);
        else if (position == ITEM_COMMITS && commitsFragment != null)
            commitsFragment.onDialogResult(requestCode, resultCode, arguments);

        return this;
    }
}

<code block>

package com.github.pockethub.ui.repo;

import static com.github.pockethub.Intents.EXTRA_USER;
import static com.github.pockethub.RequestCodes.REPOSITORY_VIEW;
import static com.github.pockethub.ResultCodes.RESOURCE_CHANGED;
import static java.util.Locale.US;
import android.app.Activity;
import android.app.AlertDialog;
import android.content.Intent;
import android.os.Bundle;
import android.support.v4.content.Loader;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.ListView;

import com.github.kevinsawicki.wishlist.SingleTypeAdapter;
import com.github.kevinsawicki.wishlist.ViewFinder;
import com.github.pockethub.R;
import com.github.pockethub.ThrowableLoader;
import com.github.pockethub.persistence.AccountDataManager;
import com.github.pockethub.ui.HeaderFooterListAdapter;
import com.github.pockethub.ui.ItemListFragment;
import com.github.pockethub.ui.LightAlertDialog;
import com.github.pockethub.ui.user.OrganizationSelectionListener;
import com.github.pockethub.ui.user.OrganizationSelectionProvider;
import com.github.pockethub.ui.user.UserViewActivity;
import com.github.pockethub.util.AvatarLoader;
import com.google.inject.Inject;

import java.util.Collections;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;


public class RepositoryListFragment extends ItemListFragment<Repository>
    implements OrganizationSelectionListener {

    @Inject
    private AccountDataManager cache;

    @Inject
    private AvatarLoader avatars;

    private final AtomicReference<User> org = new AtomicReference<>();

    private RecentRepositories recentRepos;

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);

        User org = this.org.get();
        if (org != null)
            outState.putSerializable(EXTRA_USER, org);
    }

    @Override
    protected void configureList(Activity activity, ListView listView) {
        super.configureList(activity, listView);

        listView.setDividerHeight(0);
        updateHeaders(items);
    }

    @Override
    public void onDetach() {
        if (getActivity() != null && getActivity() instanceof OrganizationSelectionProvider) {
            OrganizationSelectionProvider selectionProvider = (OrganizationSelectionProvider) getActivity();
            selectionProvider.removeListener(this);
        }

        super.onDetach();
    }

    @Override
    public void onOrganizationSelected(final User organization) {
        User previousOrg = org.get();
        int previousOrgId = previousOrg != null ? previousOrg.getId() : -1;
        org.set(organization);

        if (recentRepos != null)
            recentRepos.saveAsync();


        if (previousOrgId != organization.getId()) {
            Activity activity = getActivity();
            if (activity != null)
                recentRepos = new RecentRepositories(activity, organization);

            refreshWithProgress();
        }
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        Activity activity = getActivity();
        User currentOrg = null;

        if (getActivity() instanceof OrganizationSelectionProvider)
            currentOrg = ((OrganizationSelectionProvider) activity)
                .addListener(this);

        if (getArguments() != null && getArguments().containsKey("org"))
            currentOrg = (User) getArguments().getSerializable("org");

        if (currentOrg == null && savedInstanceState != null)
            currentOrg = (User) savedInstanceState.getSerializable(EXTRA_USER);
        org.set(currentOrg);
        if (currentOrg != null)
            recentRepos = new RecentRepositories(activity, currentOrg);

        setEmptyText(R.string.no_repositories);

        super.onActivityCreated(savedInstanceState);
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {

        if (requestCode == REPOSITORY_VIEW && resultCode == RESOURCE_CHANGED) {
            forceRefresh();
            return;
        }

        super.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    public void onListItemClick(ListView list, View v, int position, long id) {
        Repository repo = (Repository) list.getItemAtPosition(position);
        if (recentRepos != null)
            recentRepos.add(repo);

        startActivityForResult(RepositoryViewActivity.createIntent(repo),
            REPOSITORY_VIEW);
    }

    @Override
    public boolean onListItemLongClick(ListView list, View v, int position,
        long itemId) {
        if (!isUsable())
            return false;

        final Repository repo = (Repository) list.getItemAtPosition(position);
        if (repo == null)
            return false;

        final AlertDialog dialog = LightAlertDialog.create(getActivity());
        dialog.setCanceledOnTouchOutside(true);

        dialog.setTitle(repo.generateId());

        View view = getActivity().getLayoutInflater().inflate(
            R.layout.repo_dialog, null);
        ViewFinder finder = new ViewFinder(view);

        final User owner = repo.getOwner();
        avatars.bind(finder.imageView(R.id.iv_owner_avatar), owner);
        finder.setText(R.id.tv_owner_name, getString(R.string.navigate_to_user, owner.getLogin()));
        finder.onClick(R.id.ll_owner_area, new OnClickListener() {

            public void onClick(View v) {
                dialog.dismiss();

                viewUser(owner);
            }
        });

        if ((recentRepos != null) && (recentRepos.contains(repo))) {
            finder.find(R.id.divider).setVisibility(View.VISIBLE);
            finder.find(R.id.ll_recent_repo_area).setVisibility(View.VISIBLE);
            finder.onClick(R.id.ll_recent_repo_area, new OnClickListener() {

                public void onClick(View v) {
                    dialog.dismiss();

                    recentRepos.remove(repo);
                    refresh();
                }
            });
        }

        dialog.setView(view);
        dialog.show();

        return true;
    }

    private void viewUser(User user) {
        if (org.get().getId() != user.getId())
            startActivity(UserViewActivity.createIntent(user));
    }

    @Override
    public void onStop() {
        super.onStop();

        if (recentRepos != null)
            recentRepos.saveAsync();
    }

    private void updateHeaders(final List<Repository> repos) {
        HeaderFooterListAdapter<?> rootAdapter = getListAdapter();
        if (rootAdapter == null)
            return;

        DefaultRepositoryListAdapter adapter = (DefaultRepositoryListAdapter) rootAdapter
            .getWrappedAdapter();
        adapter.clearHeaders();

        if (repos.isEmpty())
            return;


        Repository first = repos.get(0);
        if (recentRepos.contains(first))
            adapter.registerHeader(first, getString(R.string.recently_viewed));


        int index;
        Repository current = null;
        for (index = 0; index < repos.size(); index++) {
            Repository repository = repos.get(index);
            if (recentRepos.contains(repository.getId()))
                current = repository;
            else
                break;
        }

        if (index >= repos.size())
            return;

        if (current != null)
            adapter.registerNoSeparator(current);


        current = repos.get(index);
        char start = Character.toLowerCase(current.getName().charAt(0));
        adapter.registerHeader(current,
            Character.toString(start).toUpperCase(US));

        char previousHeader = start;
        for (index = index + 1; index < repos.size(); index++) {
            current = repos.get(index);
            char repoStart = Character.toLowerCase(current.getName().charAt(0));
            if (repoStart <= start)
                continue;



            if (previousHeader != repoStart)
                adapter.registerNoSeparator(repos.get(index - 1));

            adapter.registerHeader(current, Character.toString(repoStart)
                .toUpperCase(US));
            previousHeader = repoStart;
            start = repoStart++;
        }


        adapter.registerNoSeparator(repos.get(repos.size() - 1));
    }

    @Override
    public Loader<List<Repository>> onCreateLoader(int id, final Bundle args) {
        return new ThrowableLoader<List<Repository>>(getActivity(), items) {

            @Override
            public List<Repository> loadData() throws Exception {
                User org = RepositoryListFragment.this.org.get();
                if (org == null)
                    return Collections.emptyList();

                List<Repository> repos = cache.getRepos(org,
                    isForceRefresh(args));
                Collections.sort(repos, recentRepos);
                updateHeaders(repos);
                return repos;
            }
        };
    }

    @Override
    protected SingleTypeAdapter<Repository> createAdapter(List<Repository> items) {
        return new DefaultRepositoryListAdapter(getActivity()
            .getLayoutInflater(),
            items.toArray(new Repository[items.size()]), org);
    }

    @Override
    protected int getErrorMessage(Exception exception) {
        return R.string.error_repos_load;
    }
}

<code block>

package com.github.pockethub.ui.repo;

import static com.github.pockethub.Intents.EXTRA_REPOSITORY;
import android.app.Activity;

import com.github.pockethub.core.ResourcePager;
import com.github.pockethub.core.user.UserEventMatcher.UserPair;
import com.github.pockethub.ui.NewsFragment;
import com.github.pockethub.ui.issue.IssuesViewActivity;
import com.github.pockethub.ui.user.EventPager;
import com.github.pockethub.ui.user.UserViewActivity;

import org.eclipse.egit.github.core.Issue;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;
import org.eclipse.egit.github.core.client.PageIterator;
import org.eclipse.egit.github.core.event.Event;


public class RepositoryNewsFragment extends NewsFragment {

    private Repository repo;

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);

        repo = getSerializableExtra(EXTRA_REPOSITORY);
    }

    @Override
    protected ResourcePager<Event> createPager() {
        return new EventPager() {

            @Override
            public PageIterator<Event> createIterator(int page, int size) {
                return service.pageEvents(repo, page, size);
            }
        };
    }


    @Override
    protected void viewRepository(Repository repository) {
        if (!repo.generateId().equals(repository.generateId()))
            super.viewRepository(repository);
    }

    @Override
    protected void viewIssue(Issue issue, Repository repository) {
        startActivity(IssuesViewActivity.createIntent(issue, repo));
    }

    @Override
    protected boolean viewUser(User user) {
        if (repo.getOwner().getId() != user.getId()) {
            startActivity(UserViewActivity.createIntent(user));
            return true;
        }
        return false;
    }

    @Override
    protected void viewUser(UserPair users) {
        if (!viewUser(users.from))
            viewUser(users.to);
    }
}

<code block>

package com.github.pockethub.ui.repo;

import android.view.LayoutInflater;
import android.view.View;
import android.widget.TextView;

import com.github.pockethub.R;
import com.github.pockethub.ui.StyledText;
import com.github.pockethub.util.TypefaceUtils;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicReference;

import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.User;


public class DefaultRepositoryListAdapter extends
        RepositoryListAdapter<Repository> {

    private int descriptionColor;

    private final AtomicReference<User> account;

    private final Map<Long, String> headers = new HashMap<>();

    private final Set<Long> noSeparators = new HashSet<>();


    public DefaultRepositoryListAdapter(LayoutInflater inflater,
            Repository[] elements, AtomicReference<User> account) {
        super(R.layout.repo_item, inflater, elements);

        this.account = account;
    }


    public DefaultRepositoryListAdapter clearHeaders() {
        headers.clear();
        noSeparators.clear();
        return this;
    }


    public DefaultRepositoryListAdapter registerHeader(Repository repository,
            String text) {
        headers.put(repository.getId(), text);
        return this;
    }


    public DefaultRepositoryListAdapter registerNoSeparator(
            Repository repository) {
        noSeparators.add(repository.getId());
        return this;
    }

    @Override
    protected View initialize(View view) {
        view = super.initialize(view);

        TypefaceUtils.setOcticons(textView(view, 0),
                (TextView) view.findViewById(R.id.tv_forks_icon),
                (TextView) view.findViewById(R.id.tv_watchers_icon));
        descriptionColor = view.getResources().getColor(R.color.text_description);
        return view;
    }

    @Override
    protected int[] getChildViewIds() {
        return new int[] { R.id.tv_repo_icon, R.id.tv_repo_description,
                R.id.tv_language, R.id.tv_watchers, R.id.tv_forks, R.id.ll_header,
                R.id.tv_header, R.id.v_separator, R.id.tv_repo_name };
    }

    @Override
    protected void update(int position, Repository repository) {
        String headerValue = headers.get(repository.getId());
        if (headerValue != null) {
            setGone(5, false);
            setText(6, headerValue);
        } else
            setGone(5, true);

        setGone(7, noSeparators.contains(repository.getId()));

        StyledText name = new StyledText();
        if (!account.get().getLogin().equals(repository.getOwner().getLogin()))
            name.foreground(repository.getOwner().getLogin(), descriptionColor)
                    .foreground('/', descriptionColor);
        name.bold(repository.getName());
        setText(8, name);

        updateDetails(repository.getDescription(), repository.getLanguage(),
                repository.getWatchers(), repository.getForks(),
                repository.isPrivate(), repository.isFork(),
                repository.getMirrorUrl());
    }
}

<code block>

package com.github.pockethub.ui.code;

import static android.app.Activity.RESULT_OK;
import static com.github.pockethub.Intents.EXTRA_REPOSITORY;
import static com.github.pockethub.RequestCodes.REF_UPDATE;
import android.app.Activity;
import android.os.Bundle;
import android.text.method.LinkMovementMethod;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ListView;
import android.widget.ProgressBar;
import android.widget.TextView;

import com.github.kevinsawicki.wishlist.ViewUtils;
import com.github.pockethub.R;
import com.github.pockethub.core.code.FullTree;
import com.github.pockethub.core.code.FullTree.Entry;
import com.github.pockethub.core.code.FullTree.Folder;
import com.github.pockethub.core.code.RefreshTreeTask;
import com.github.pockethub.core.ref.RefUtils;
import com.github.pockethub.ui.DialogFragment;
import com.github.pockethub.ui.DialogFragmentActivity;
import com.github.pockethub.ui.HeaderFooterListAdapter;
import com.github.pockethub.ui.StyledText;
import com.github.pockethub.ui.ref.BranchFileViewActivity;
import com.github.pockethub.ui.ref.CodeTreeAdapter;
import com.github.pockethub.ui.ref.RefDialog;
import com.github.pockethub.ui.ref.RefDialogFragment;
import com.github.pockethub.util.ToastUtils;
import com.github.pockethub.util.TypefaceUtils;
import com.google.inject.Inject;

import java.util.LinkedList;

import org.eclipse.egit.github.core.Reference;
import org.eclipse.egit.github.core.Repository;
import org.eclipse.egit.github.core.service.DataService;


public class RepositoryCodeFragment extends DialogFragment implements
        OnItemClickListener {

    private FullTree tree;

    private ListView listView;

    private ProgressBar progressView;

    private TextView branchIconView;

    private TextView branchView;

    private TextView pathView;

    private View pathHeaderView;

    private View branchFooterView;

    private HeaderFooterListAdapter<CodeTreeAdapter> adapter;

    private boolean pathShowing;

    private Folder folder;

    private Repository repository;

    @Inject
    private DataService service;

    private RefDialog dialog;

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);

        repository = getSerializableExtra(EXTRA_REPOSITORY);
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        if (tree == null || folder == null)
            refreshTree(null);
        else
            setFolder(tree, folder);
    }

    @Override
    public void onCreateOptionsMenu(Menu optionsMenu, MenuInflater inflater) {
        inflater.inflate(R.menu.refresh, optionsMenu);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
        case R.id.m_refresh:
            if (tree != null)
                refreshTree(new Reference().setRef(tree.reference.getRef()));
            else
                refreshTree(null);
            return true;
        default:
            return super.onOptionsItemSelected(item);
        }
    }

    private void showLoading(final boolean loading) {
        ViewUtils.setGone(progressView, !loading);
        ViewUtils.setGone(listView, loading);
        ViewUtils.setGone(branchFooterView, loading);
    }

    private void refreshTree(final Reference reference) {
        showLoading(true);
        new RefreshTreeTask(repository, reference, getActivity()) {

            @Override
            protected void onSuccess(final FullTree fullTree) throws Exception {
                super.onSuccess(fullTree);

                if (folder == null || folder.parent == null)
                    setFolder(fullTree, fullTree.root);
                else {

                    Folder current = folder;
                    LinkedList<Folder> stack = new LinkedList<>();
                    while (current != null && current.parent != null) {
                        stack.addFirst(current);
                        current = current.parent;
                    }
                    Folder refreshed = fullTree.root;
                    while (!stack.isEmpty()) {
                        refreshed = refreshed.folders
                                .get(stack.removeFirst().name);
                        if (refreshed == null)
                            break;
                    }
                    if (refreshed != null)
                        setFolder(fullTree, refreshed);
                    else
                        setFolder(fullTree, fullTree.root);
                }
            }

            @Override
            protected void onException(Exception e) throws RuntimeException {
                super.onException(e);

                showLoading(false);
                ToastUtils.show(getActivity(), e, R.string.error_code_load);
            }

        }.execute();
    }

    private void switchBranches() {
        if (tree == null)
            return;

        if (dialog == null)
            dialog = new RefDialog((DialogFragmentActivity) getActivity(),
                    REF_UPDATE, repository, service);
        dialog.show(tree.reference);
    }

    @Override
    public void onDialogResult(int requestCode, int resultCode, Bundle arguments) {
        if (RESULT_OK != resultCode)
            return;

        switch (requestCode) {
        case REF_UPDATE:
            refreshTree(RefDialogFragment.getSelected(arguments));
            break;
        }
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        return inflater.inflate(R.layout.repo_code, null);
    }

    @Override
    public void onViewCreated(View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        progressView = finder.find(R.id.pb_loading);
        listView = finder.find(android.R.id.list);
        listView.setOnItemClickListener(this);

        Activity activity = getActivity();
        adapter = new HeaderFooterListAdapter<>(listView,
                new CodeTreeAdapter(activity));

        branchFooterView = finder.find(R.id.rl_branch);
        branchView = finder.find(R.id.tv_branch);
        branchIconView = finder.find(R.id.tv_branch_icon);
        branchFooterView.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                switchBranches();
            }
        });

        pathHeaderView = activity.getLayoutInflater().inflate(R.layout.path_item,
                null);
        pathView = (TextView) pathHeaderView.findViewById(R.id.tv_path);
        pathView.setMovementMethod(LinkMovementMethod.getInstance());
        if (pathShowing)
            adapter.addHeader(pathHeaderView);

        TypefaceUtils.setOcticons(branchIconView,
                (TextView) pathHeaderView.findViewById(R.id.tv_folder_icon));
        listView.setAdapter(adapter);
    }


    public boolean onBackPressed() {
        if (folder != null && folder.parent != null) {
            setFolder(tree, folder.parent);
            return true;
        } else
            return false;
    }

    private void setFolder(final FullTree tree, final Folder folder) {
        this.folder = folder;
        this.tree = tree;

        showLoading(false);

        branchView.setText(tree.branch);
        if (RefUtils.isTag(tree.reference))
            branchIconView.setText(R.string.icon_tag);
        else
            branchIconView.setText(R.string.icon_fork);

        adapter.getWrappedAdapter().setIndented(folder.entry != null);

        if (folder.entry != null) {
            int textLightColor = getResources().getColor(R.color.text_light);
            final String[] segments = folder.entry.getPath().split("/");
            StyledText text = new StyledText();
            for (int i = 0; i < segments.length - 1; i++) {
                final int index = i;
                text.url(segments[i], new OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        Folder clicked = folder;
                        for (int i = index; i < segments.length - 1; i++) {
                            clicked = clicked.parent;
                            if (clicked == null)
                                return;
                        }
                        setFolder(tree, clicked);
                    }
                }).append(' ').foreground('/', textLightColor).append(' ');
            }
            text.bold(segments[segments.length - 1]);
            pathView.setText(text);
            if (!pathShowing) {
                adapter.addHeader(pathHeaderView);
                pathShowing = true;
            }
        } else if (pathShowing) {
            adapter.removeHeader(pathHeaderView);
            pathShowing = false;
        }

        adapter.getWrappedAdapter().setItems(folder);
        listView.setSelection(0);
    }

    @Override
    public void onItemClick(AdapterView<?> parent, View view, int position,
            long id) {
        Entry entry = (Entry) parent.getItemAtPosition(position);
        if (tree == null || entry == null)
            return;

        if (entry instanceof Folder)
            setFolder(tree, (Folder) entry);
        else
            startActivity(BranchFileViewActivity.createIntent(repository,
                    tree.branch, entry.entry.getPath(), entry.entry.getSha()));
    }
}
