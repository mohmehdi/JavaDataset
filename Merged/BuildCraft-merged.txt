
package buildcraft.core.lib.gui.buttons;

public interface IButtonTextureSet {

	int getX();

	int getY();

	int getHeight();

	int getWidth();
}

<code block>

package buildcraft.core.lib.gui.buttons;

import org.lwjgl.opengl.GL11;

import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.FontRenderer;
import net.minecraft.client.gui.GuiButton;
import net.minecraft.util.ResourceLocation;
import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.relauncher.SideOnly;

import buildcraft.core.lib.gui.tooltips.IToolTipProvider;
import buildcraft.core.lib.gui.tooltips.ToolTip;

@SideOnly(Side.CLIENT)
public class GuiBetterButton extends GuiButton implements IToolTipProvider {

	public static final ResourceLocation BUTTON_TEXTURES = new ResourceLocation("buildcraftcore:textures/gui/buttons.png");
	protected final IButtonTextureSet texture;
	private ToolTip toolTip;

	public GuiBetterButton(int id, int x, int y, String label) {
		this(id, x, y, 200, StandardButtonTextureSets.LARGE_BUTTON, label);
	}

	public GuiBetterButton(int id, int x, int y, int width, String label) {
		this(id, x, y, width, StandardButtonTextureSets.LARGE_BUTTON, label);
	}

	public GuiBetterButton(int id, int x, int y, int width, IButtonTextureSet texture, String label) {
		super(id, x, y, width, texture.getHeight(), label);
		this.texture = texture;
	}

	public int getWidth() {
		return width;
	}

	public int getHeight() {
		return texture.getHeight();
	}

	public int getTextColor(boolean mouseOver) {
		if (!enabled) {
			return 0xffa0a0a0;
		} else if (mouseOver) {
			return 0xffffa0;
		} else {
			return 0xe0e0e0;
		}
	}

	public boolean isMouseOverButton(int mouseX, int mouseY) {
		return mouseX >= xPosition && mouseY >= yPosition && mouseX < xPosition + width && mouseY < yPosition + getHeight();
	}

	protected void bindButtonTextures(Minecraft minecraft) {
		minecraft.renderEngine.bindTexture(BUTTON_TEXTURES);
	}

	@Override
	public void drawButton(Minecraft minecraft, int mouseX, int mouseY) {
		if (!visible) {
			return;
		}
		
		FontRenderer fontrenderer = minecraft.fontRenderer;
		bindButtonTextures(minecraft);
		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
		int xOffset = texture.getX();
		int yOffset = texture.getY();
		int h = texture.getHeight();
		int w = texture.getWidth();
		boolean mouseOver = isMouseOverButton(mouseX, mouseY);
		int hoverState = getHoverState(mouseOver);
		drawTexturedModalRect(xPosition, yPosition, xOffset, yOffset + hoverState * h, width / 2, h);
		drawTexturedModalRect(xPosition + width / 2, yPosition, xOffset + w - width / 2, yOffset + hoverState * h, width / 2, h);
		mouseDragged(minecraft, mouseX, mouseY);
		drawCenteredString(fontrenderer, displayString, xPosition + width / 2, yPosition + (h - 8) / 2, getTextColor(mouseOver));
	}

	@Override
	public ToolTip getToolTip() {
		return toolTip;
	}

	public void setToolTip(ToolTip tips) {
		this.toolTip = tips;
	}

	@Override
	public boolean isToolTipVisible() {
		return visible;
	}

	@Override
	public boolean isMouseOver(int mouseX, int mouseY) {
		return isMouseOverButton(mouseX, mouseY);
	}
}

<code block>

package buildcraft.core.lib.gui.buttons;

public enum StandardButtonTextureSets implements IButtonTextureSet {

	LARGE_BUTTON(0, 0, 20, 200),
	SMALL_BUTTON(0, 80, 15, 200),
    LEFT_BUTTON(204, 0, 16, 10),
    RIGHT_BUTTON(214, 0, 16, 10);
	private final int x, y, height, width;

	private StandardButtonTextureSets(int x, int y, int height, int width) {
		this.x = x;
		this.y = y;
		this.height = height;
		this.width = width;
	}

	@Override
	public int getX() {
		return x;
	}

	@Override
	public int getY() {
		return y;
	}

	@Override
	public int getHeight() {
		return height;
	}

	@Override
	public int getWidth() {
		return width;
	}
}

<code block>

package buildcraft.core.lib.gui.buttons;

public class ButtonTextureSet implements IButtonTextureSet {

	private final int x, y, height, width;

	public ButtonTextureSet(int x, int y, int height, int width) {
		this.x = x;
		this.y = y;
		this.height = height;
		this.width = width;
	}

	@Override
	public int getX() {
		return x;
	}

	@Override
	public int getY() {
		return y;
	}

	@Override
	public int getHeight() {
		return height;
	}

	@Override
	public int getWidth() {
		return width;
	}
}

<code block>

package buildcraft.builders;

import io.netty.buffer.ByteBuf;

import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.AxisAlignedBB;
import cpw.mods.fml.relauncher.Side;

import buildcraft.BuildCraftCore;
import buildcraft.api.core.IAreaProvider;
import buildcraft.api.filler.FillerManager;
import buildcraft.api.statements.IStatementContainer;
import buildcraft.api.statements.IStatementParameter;
import buildcraft.api.statements.StatementManager;
import buildcraft.api.tiles.IControllable;
import buildcraft.api.tiles.IHasWork;
import buildcraft.core.Box;
import buildcraft.core.Box.Kind;
import buildcraft.core.blueprints.BptBuilderTemplate;
import buildcraft.core.blueprints.BptContext;
import buildcraft.core.builders.TileAbstractBuilder;
import buildcraft.core.builders.patterns.FillerPattern;
import buildcraft.core.builders.patterns.PatternFill;
import buildcraft.core.internal.ILEDProvider;
import buildcraft.core.lib.inventory.SimpleInventory;
import buildcraft.core.lib.network.command.CommandWriter;
import buildcraft.core.lib.network.command.ICommandReceiver;
import buildcraft.core.lib.network.command.PacketCommand;
import buildcraft.core.lib.utils.NetworkUtils;
import buildcraft.core.lib.utils.Utils;

public class TileFiller extends TileAbstractBuilder implements IHasWork, IControllable, ICommandReceiver, IStatementContainer, ILEDProvider {
	private static int POWER_ACTIVATION = 500;

	public FillerPattern currentPattern = PatternFill.INSTANCE;
	public IStatementParameter[] patternParameters;

	private BptBuilderTemplate currentTemplate;
	private BptContext context;

	private final Box box = new Box();
	private boolean done = false;
	private SimpleInventory inv = new SimpleInventory(27, "Filler", 64);

	private NBTTagCompound initNBT = null;

	public TileFiller() {
		inv.addListener(this);
		box.kind = Kind.STRIPES;
	}

	@Override
	public void initialize() {
		super.initialize();

		if (worldObj.isRemote) {
			return;
		}

		IAreaProvider a = Utils.getNearbyAreaProvider(worldObj, xCoord, yCoord,
				zCoord);

		if (a != null) {
			box.initialize(a);

			if (a instanceof TileMarker) {
				a.removeFromWorld();
			}

			sendNetworkUpdate();
		}

		if (currentPattern != null && currentTemplate == null && box.isInitialized()) {
			currentTemplate = currentPattern
					.getTemplateBuilder(box, getWorldObj(), patternParameters);
			context = currentTemplate.getContext();
		}

		if (initNBT != null && currentTemplate != null) {
			currentTemplate.loadBuildStateToNBT(
					initNBT.getCompoundTag("builderState"), this);
		}

		initNBT = null;
	}

	@Override
	public void updateEntity() {
		super.updateEntity();

		if (worldObj.isRemote) {
			return;
		}

		if (mode == Mode.Off) {
			return;
		}

		if (!box.isInitialized()) {
			return;
		}

		if (getBattery().getEnergyStored() < POWER_ACTIVATION) {
			return;
		}

		boolean oldDone = done;

		if (done) {
			if (mode == Mode.Loop) {
				done = false;
			} else {
				return;
			}
		}

		if (currentPattern != null && currentTemplate == null) {
			currentTemplate = currentPattern.getTemplateBuilder(box, getWorldObj(), patternParameters);
			context = currentTemplate.getContext();
		}

		if (currentTemplate != null) {
			currentTemplate.buildNextSlot(worldObj, this, xCoord, yCoord, zCoord);

			if (currentTemplate.isDone(this)) {
				done = true;
				currentTemplate = null;
			}
		}

		if (oldDone != done) {
			sendNetworkUpdate();
		}
	}

	@Override
	public final int getSizeInventory() {
		return inv.getSizeInventory();
	}

	@Override
	public ItemStack getStackInSlot(int slot) {
		return inv.getStackInSlot(slot);
	}

	@Override
	public ItemStack decrStackSize(int slot, int amount) {
		return inv.decrStackSize(slot, amount);
	}

	@Override
	public void setInventorySlotContents(int slot, ItemStack stack) {
		inv.setInventorySlotContents(slot, stack);
	}

	@Override
	public ItemStack getStackInSlotOnClosing(int slot) {
		return inv.getStackInSlotOnClosing(slot);
	}

	@Override
	public String getInventoryName() {
		return "Filler";
	}

	@Override
	public void readFromNBT(NBTTagCompound nbt) {
		super.readFromNBT(nbt);

		inv.readFromNBT(nbt);

		if (nbt.hasKey("pattern")) {
			currentPattern = (FillerPattern) FillerManager.registry.getPattern(nbt.getString("pattern"));
		}

		if (currentPattern == null) {
			currentPattern = PatternFill.INSTANCE;
		}

		if (nbt.hasKey("pp")) {
			readParametersFromNBT(nbt.getCompoundTag("pp"));
		} else {
			initPatternParameters();
		}

		if (nbt.hasKey("box")) {
			box.initialize(nbt.getCompoundTag("box"));
		}

		done = nbt.getBoolean("done");


		initNBT = (NBTTagCompound) nbt.getCompoundTag("bpt").copy();
	}

	@Override
	public void writeToNBT(NBTTagCompound nbt) {
		super.writeToNBT(nbt);

		inv.writeToNBT(nbt);

		if (currentPattern != null) {
			nbt.setString("pattern", currentPattern.getUniqueTag());
		}

		NBTTagCompound boxStore = new NBTTagCompound();
		box.writeToNBT(boxStore);
		nbt.setTag("box", boxStore);

		nbt.setBoolean("done", done);

		NBTTagCompound bptNBT = new NBTTagCompound();

		if (currentTemplate != null) {
			NBTTagCompound builderCpt = new NBTTagCompound();
			currentTemplate.saveBuildStateToNBT(builderCpt, this);
			bptNBT.setTag("builderState", builderCpt);
		}

		nbt.setTag("bpt", bptNBT);

		NBTTagCompound ppNBT = new NBTTagCompound();
		writeParametersToNBT(ppNBT);
		nbt.setTag("pp", ppNBT);
	}

	@Override
	public int getInventoryStackLimit() {
		return inv.getInventoryStackLimit();
	}

	@Override
	public boolean isUseableByPlayer(EntityPlayer entityplayer) {
		if (worldObj.getTileEntity(xCoord, yCoord, zCoord) != this) {
			return false;
		}

		return entityplayer.getDistanceSq(xCoord + 0.5D, yCoord + 0.5D,
				zCoord + 0.5D) <= 64D;
	}

	@Override
	public void invalidate() {
		super.invalidate();
		destroy();
	}

	private void initPatternParameters() {
		patternParameters = new IStatementParameter[currentPattern.maxParameters()];
		for (int i = 0; i < currentPattern.minParameters(); i++) {
			patternParameters[i] = currentPattern.createParameter(i);
		}
	}

	public void setPattern(FillerPattern pattern) {
		if (pattern != null && currentPattern != pattern) {
			currentPattern = pattern;
			currentTemplate = null;
			done = false;
			initPatternParameters();
			sendNetworkUpdate();
		}
	}

	private void writeParametersToNBT(NBTTagCompound nbt) {
		nbt.setByte("length", (byte) (patternParameters != null ? patternParameters.length : 0));
		if (patternParameters != null) {
			for (int i = 0; i < patternParameters.length; i++) {
				if (patternParameters[i] != null) {
					NBTTagCompound patternData = new NBTTagCompound();
					patternData.setString("kind", patternParameters[i].getUniqueTag());
					patternParameters[i].writeToNBT(patternData);
					nbt.setTag("p" + i, patternData);
				}
			}
		}
	}

	private void readParametersFromNBT(NBTTagCompound nbt) {
		patternParameters = new IStatementParameter[nbt.getByte("length")];
		for (int i = 0; i < patternParameters.length; i++) {
			if (nbt.hasKey("p" + i)) {
				NBTTagCompound patternData = nbt.getCompoundTag("p" + i);
				patternParameters[i] = StatementManager.createParameter(patternData.getString("kind"));
				patternParameters[i].readFromNBT(patternData);
			}
		}
	}

	@Override
	public void writeData(ByteBuf data) {
		box.writeData(data);
		data.writeBoolean(done);
		NetworkUtils.writeUTF(data, currentPattern.getUniqueTag());

		NBTTagCompound parameterData = new NBTTagCompound();
		writeParametersToNBT(parameterData);
		NetworkUtils.writeNBT(data, parameterData);
	}

	@Override
	public void readData(ByteBuf data) {
		box.readData(data);
		done = data.readBoolean();
		FillerPattern pattern = (FillerPattern) FillerManager.registry.getPattern(NetworkUtils.readUTF(data));
		NBTTagCompound parameterData = NetworkUtils.readNBT(data);
		readParametersFromNBT(parameterData);
		setPattern(pattern);

		worldObj.markBlockForUpdate(xCoord, yCoord, zCoord);
	}

	@Override
	public boolean hasWork() {
		return !done && mode != Mode.Off;
	}

	@Override
	public void openInventory() {
	}

	@Override
	public void closeInventory() {
	}

	@Override
	public boolean isItemValidForSlot(int slot, ItemStack stack) {
		return true;
	}

	public void rpcSetPatternFromString (final String name) {
		BuildCraftCore.instance.sendToServer(new PacketCommand(this, "setPattern", new CommandWriter() {
			public void write(ByteBuf data) {
				NetworkUtils.writeUTF(data, name);
			}
		}));
	}

	@Override
	public void receiveCommand(String command, Side side, Object sender, ByteBuf stream) {
		super.receiveCommand(command, side, sender, stream);
		if (side.isServer() && "setPattern".equals(command)) {
			String name = NetworkUtils.readUTF(stream);
			setPattern((FillerPattern) FillerManager.registry.getPattern(name));
		} else if (side.isServer() && "setParameters".equals(command)) {
			NBTTagCompound patternData = NetworkUtils.readNBT(stream);
			readParametersFromNBT(patternData);
		}
	}

	@Override
	public boolean hasCustomInventoryName() {
		return false;
	}

	@Override
	public Box getBox() {
		return box;
	}

	@Override
	public AxisAlignedBB getRenderBoundingBox() {
		return new Box (this).extendToEncompass(box).expand(50).getBoundingBox();
	}

	@Override
	public boolean isBuildingMaterialSlot(int i) {
		return true;
	}

	@Override
	public boolean acceptsControlMode(Mode mode) {
		return mode == IControllable.Mode.On ||
				mode == IControllable.Mode.Off ||
				mode == IControllable.Mode.Loop;
	}

	@Override
	public TileEntity getTile() {
		return this;
	}

	public void rpcSetParameter(int i, IStatementParameter patternParameter) {
		BuildCraftCore.instance.sendToServer(new PacketCommand(this, "setParameters", new CommandWriter() {
			public void write(ByteBuf data) {
				NBTTagCompound parameterData = new NBTTagCompound();
				writeParametersToNBT(parameterData);
				NetworkUtils.writeNBT(data, parameterData);
			}
		}));
	}

	public int getIconGlowLevel(int renderPass) {
		if (renderPass == 1) { 
			return done ? 15 : 0;
		} else if (renderPass == 2) { 
			return 0;
		} else {
			return -1;
		}
	}

	@Override
	public int getLEDLevel(int led) {
		return (led == 0 ? done : buildersInAction.size() > 0) ? 15 : 0;
	}
}

<code block>

package buildcraft.builders.gui;

import net.minecraft.client.gui.GuiButton;
import net.minecraft.inventory.IInventory;
import net.minecraft.util.ResourceLocation;

import buildcraft.api.filler.FillerManager;
import buildcraft.api.statements.IStatement;
import buildcraft.api.statements.IStatementParameter;
import buildcraft.api.statements.StatementMouseClick;
import buildcraft.builders.TileFiller;
import buildcraft.core.builders.patterns.FillerPattern;
import buildcraft.core.lib.gui.AdvancedSlot;
import buildcraft.core.lib.gui.GuiAdvancedInterface;
import buildcraft.core.lib.gui.GuiTools;
import buildcraft.core.lib.gui.StatementParameterSlot;
import buildcraft.core.lib.gui.StatementSlot;
import buildcraft.core.lib.gui.buttons.GuiBetterButton;
import buildcraft.core.lib.gui.buttons.StandardButtonTextureSets;
import buildcraft.core.lib.utils.StringUtils;

public class GuiFiller extends GuiAdvancedInterface {
	class FillerParameterSlot extends StatementParameterSlot {
		public FillerParameterSlot(int x, int y, int slot) {
			super(instance, x, y, slot, fakeStatementSlot);
		}

		@Override
		public IStatementParameter getParameter() {
			if (slot >= instance.filler.patternParameters.length) {
				return null;
			} else {
				return instance.filler.patternParameters[slot];
			}
		}

		@Override
		public void setParameter(IStatementParameter param, boolean notifyServer) {

		}
	}

	private static final ResourceLocation TEXTURE = new ResourceLocation("buildcraftbuilders:textures/gui/filler.png");
	private final IInventory playerInventory;
	private final TileFiller filler;
	private final GuiFiller instance;
	private final StatementSlot fakeStatementSlot;

	public GuiFiller(IInventory playerInventory, TileFiller filler) {
		super(new ContainerFiller(playerInventory, filler), filler, TEXTURE);
		this.playerInventory = playerInventory;
		this.filler = filler;
		this.instance = this;
		this.fakeStatementSlot = new StatementSlot(instance, -1, -1, 0) {
			@Override
			public IStatement getStatement() {
				return instance.filler.currentPattern;
			}
		};
		xSize = 175;
		ySize = 240;
	}

	@Override
	public void initGui() {
		super.initGui();
		buttonList.clear();

		buttonList.add(new GuiBetterButton(0, guiLeft + 38 - 18, guiTop + 30, 10,
				StandardButtonTextureSets.LEFT_BUTTON, ""));
		buttonList.add(new GuiBetterButton(1, guiLeft + 38 + 16 + 8, guiTop + 30, 10,
				StandardButtonTextureSets.RIGHT_BUTTON, ""));

		slots.clear();
		for (int i = 0; i < 4; i++) {
			slots.add(new FillerParameterSlot(77 + (i * 18), 30, i));
		}
	}

	@Override
	protected void actionPerformed(GuiButton button) {
		super.actionPerformed(button);

		if (button.id == 0) {
			filler.currentPattern = (FillerPattern) FillerManager.registry.getPreviousPattern(filler.currentPattern);
		} else if (button.id == 1) {
			filler.currentPattern = (FillerPattern) FillerManager.registry.getNextPattern(filler.currentPattern);
		}

		filler.rpcSetPatternFromString(filler.currentPattern.getUniqueTag());
	}

	@Override
	protected void mouseClicked(int x, int y, int k) {
		super.mouseClicked(x, y, k);

		AdvancedSlot slot = getSlotAtLocation(x, y);

		if (slot != null) {
			int i  = ((FillerParameterSlot) slot).slot;
			if (i < filler.patternParameters.length) {
				if (filler.patternParameters[i] != null) {
					filler.patternParameters[i].onClick(filler, filler.currentPattern, mc.thePlayer.inventory.getItemStack(),
							new StatementMouseClick(k, isShiftKeyDown()));
				} else {
					filler.patternParameters[i] = filler.currentPattern.createParameter(i);
				}
				filler.rpcSetParameter(i, filler.patternParameters[i]);
			}
		}
	}

	@Override
	protected void drawGuiContainerBackgroundLayer(float f, int mx, int my) {
		super.drawGuiContainerBackgroundLayer(f, mx, my);
		drawBackgroundSlots();
	}

	@Override
	protected void drawGuiContainerForegroundLayer(int mx, int my) {
		super.drawGuiContainerForegroundLayer(mx, my);

		String title = StringUtils.localize("tile.fillerBlock.name");
		fontRendererObj.drawString(title, getCenteredOffset(title), 6, 0x404040);
		fontRendererObj.drawString(StringUtils.localize("gui.filling.resources"), 8, 74, 0x404040);
		fontRendererObj.drawString(StringUtils.localize("gui.inventory"), 8, 142, 0x404040);
		GuiTools.drawCenteredString(fontRendererObj, filler.currentPattern.getDescription(), 56);

		drawTooltipForSlotAt(mx, my);
	}
}

<code block>

package buildcraft.core.lib.gui.buttons;

import net.minecraft.util.ResourceLocation;

public interface IButtonTextureSet {

	int getX();

	int getY();

	int getHeight();

	int getWidth();

	ResourceLocation getTexture();
}

<code block>

package buildcraft.core.lib.gui.buttons;

import org.lwjgl.opengl.GL11;

import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.FontRenderer;
import net.minecraft.client.gui.GuiButton;
import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.relauncher.SideOnly;

import buildcraft.core.lib.gui.tooltips.IToolTipProvider;
import buildcraft.core.lib.gui.tooltips.ToolTip;

@SideOnly(Side.CLIENT)
public class GuiBetterButton extends GuiButton implements IToolTipProvider {
	protected final IButtonTextureSet texture;
	private ToolTip toolTip;

	public GuiBetterButton(int id, int x, int y, String label) {
		this(id, x, y, 200, StandardButtonTextureSets.LARGE_BUTTON, label);
	}

	public GuiBetterButton(int id, int x, int y, int width, String label) {
		this(id, x, y, width, StandardButtonTextureSets.LARGE_BUTTON, label);
	}

	public GuiBetterButton(int id, int x, int y, int width, IButtonTextureSet texture, String label) {
		super(id, x, y, width, texture.getHeight(), label);
		this.texture = texture;
	}

	public int getWidth() {
		return width;
	}

	public int getHeight() {
		return texture.getHeight();
	}

	public int getTextColor(boolean mouseOver) {
		if (!enabled) {
			return 0xffa0a0a0;
		} else if (mouseOver) {
			return 0xffffa0;
		} else {
			return 0xe0e0e0;
		}
	}

	public boolean isMouseOverButton(int mouseX, int mouseY) {
		return mouseX >= xPosition && mouseY >= yPosition && mouseX < xPosition + width && mouseY < yPosition + getHeight();
	}

	protected void bindButtonTextures(Minecraft minecraft) {
		minecraft.renderEngine.bindTexture(texture.getTexture());
	}

	@Override
	public void drawButton(Minecraft minecraft, int mouseX, int mouseY) {
		if (!visible) {
			return;
		}
		
		FontRenderer fontrenderer = minecraft.fontRenderer;
		bindButtonTextures(minecraft);
		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
		int xOffset = texture.getX();
		int yOffset = texture.getY();
		int h = texture.getHeight();
		int w = texture.getWidth();
		boolean mouseOver = isMouseOverButton(mouseX, mouseY);
		int hoverState = getHoverState(mouseOver);
		drawTexturedModalRect(xPosition, yPosition, xOffset, yOffset + hoverState * h, width / 2, h);
		drawTexturedModalRect(xPosition + width / 2, yPosition, xOffset + w - width / 2, yOffset + hoverState * h, width / 2, h);
		mouseDragged(minecraft, mouseX, mouseY);
		drawCenteredString(fontrenderer, displayString, xPosition + width / 2, yPosition + (h - 8) / 2, getTextColor(mouseOver));
	}

	@Override
	public ToolTip getToolTip() {
		return toolTip;
	}

	public GuiBetterButton setToolTip(ToolTip tips) {
		this.toolTip = tips;
		return this;
	}

	@Override
	public boolean isToolTipVisible() {
		return visible;
	}

	@Override
	public boolean isMouseOver(int mouseX, int mouseY) {
		return isMouseOverButton(mouseX, mouseY);
	}
}

<code block>

package buildcraft.core.lib.gui.buttons;

import net.minecraft.util.ResourceLocation;

public enum StandardButtonTextureSets implements IButtonTextureSet {
	LARGE_BUTTON(0, 0, 20, 200),
	SMALL_BUTTON(0, 80, 15, 200),
    LEFT_BUTTON(204, 0, 16, 10),
    RIGHT_BUTTON(214, 0, 16, 10);
	public static final ResourceLocation BUTTON_TEXTURES = new ResourceLocation("buildcraftcore:textures/gui/buttons.png");
	private final int x, y, height, width;

	private StandardButtonTextureSets(int x, int y, int height, int width) {
		this.x = x;
		this.y = y;
		this.height = height;
		this.width = width;
	}

	@Override
	public int getX() {
		return x;
	}

	@Override
	public int getY() {
		return y;
	}

	@Override
	public int getHeight() {
		return height;
	}

	@Override
	public int getWidth() {
		return width;
	}

	@Override
	public ResourceLocation getTexture() {
		return BUTTON_TEXTURES;
	}
}

<code block>

package buildcraft.core.lib.gui.buttons;

import net.minecraft.util.ResourceLocation;

public class ButtonTextureSet implements IButtonTextureSet {
	private final ResourceLocation texture;
	private final int x, y, height, width;

	public ButtonTextureSet(int x, int y, int height, int width) {
		this(x, y, height, width, StandardButtonTextureSets.BUTTON_TEXTURES);
	}

	public ButtonTextureSet(int x, int y, int height, int width, ResourceLocation texture) {
		this.x = x;
		this.y = y;
		this.height = height;
		this.width = width;
		this.texture = texture;
	}

	@Override
	public int getX() {
		return x;
	}

	@Override
	public int getY() {
		return y;
	}

	@Override
	public int getHeight() {
		return height;
	}

	@Override
	public int getWidth() {
		return width;
	}

	@Override
	public ResourceLocation getTexture() {
		return texture;
	}
}

<code block>

package buildcraft.builders;

import io.netty.buffer.ByteBuf;

import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.AxisAlignedBB;
import cpw.mods.fml.relauncher.Side;

import buildcraft.BuildCraftCore;
import buildcraft.api.core.IAreaProvider;
import buildcraft.api.filler.FillerManager;
import buildcraft.api.statements.IStatementContainer;
import buildcraft.api.statements.IStatementParameter;
import buildcraft.api.statements.StatementManager;
import buildcraft.api.tiles.IControllable;
import buildcraft.api.tiles.IHasWork;
import buildcraft.core.Box;
import buildcraft.core.Box.Kind;
import buildcraft.core.blueprints.BptBuilderTemplate;
import buildcraft.core.blueprints.BptContext;
import buildcraft.core.builders.TileAbstractBuilder;
import buildcraft.core.builders.patterns.FillerPattern;
import buildcraft.core.builders.patterns.PatternFill;
import buildcraft.core.internal.ILEDProvider;
import buildcraft.core.lib.inventory.SimpleInventory;
import buildcraft.core.lib.network.command.CommandWriter;
import buildcraft.core.lib.network.command.ICommandReceiver;
import buildcraft.core.lib.network.command.PacketCommand;
import buildcraft.core.lib.utils.NetworkUtils;
import buildcraft.core.lib.utils.Utils;

public class TileFiller extends TileAbstractBuilder implements IHasWork, IControllable, ICommandReceiver, IStatementContainer, ILEDProvider {
	private static int POWER_ACTIVATION = 500;

	public FillerPattern currentPattern = PatternFill.INSTANCE;
	public IStatementParameter[] patternParameters;

	private BptBuilderTemplate currentTemplate;
	private BptContext context;

	private final Box box = new Box();
	private boolean done = false;
	private boolean excavate = true;
	private SimpleInventory inv = new SimpleInventory(27, "Filler", 64);

	private NBTTagCompound initNBT = null;

	public TileFiller() {
		inv.addListener(this);
		box.kind = Kind.STRIPES;
	}

	public boolean isExcavate() {
		return excavate;
	}

	@Override
	public void initialize() {
		super.initialize();

		if (worldObj.isRemote) {
			return;
		}

		IAreaProvider a = Utils.getNearbyAreaProvider(worldObj, xCoord, yCoord,
				zCoord);

		if (a != null) {
			box.initialize(a);

			if (a instanceof TileMarker) {
				a.removeFromWorld();
			}

			sendNetworkUpdate();
		}

		if (currentTemplate == null) {
			initTemplate();
		}

		if (initNBT != null && currentTemplate != null) {
			currentTemplate.loadBuildStateToNBT(
					initNBT.getCompoundTag("builderState"), this);
		}

		initNBT = null;
	}

	private void initTemplate() {
		if (currentPattern != null && box.isInitialized()) {
			currentTemplate = currentPattern.getTemplateBuilder(box, getWorldObj(), patternParameters);
			context = currentTemplate.getContext();
			currentTemplate.blueprint.excavate = excavate;
		}
	}

	@Override
	public void updateEntity() {
		super.updateEntity();

		if (worldObj.isRemote) {
			return;
		}

		if (mode == Mode.Off) {
			return;
		}

		if (!box.isInitialized()) {
			return;
		}

		if (getBattery().getEnergyStored() < POWER_ACTIVATION) {
			return;
		}

		boolean oldDone = done;

		if (done) {
			if (mode == Mode.Loop) {
				done = false;
			} else {
				return;
			}
		}

		if (currentTemplate == null) {
			initTemplate();
		}

		if (currentTemplate != null) {
			currentTemplate.buildNextSlot(worldObj, this, xCoord, yCoord, zCoord);

			if (currentTemplate.isDone(this)) {
				done = true;
				currentTemplate = null;
			}
		}

		if (oldDone != done) {
			sendNetworkUpdate();
		}
	}

	@Override
	public final int getSizeInventory() {
		return inv.getSizeInventory();
	}

	@Override
	public ItemStack getStackInSlot(int slot) {
		return inv.getStackInSlot(slot);
	}

	@Override
	public ItemStack decrStackSize(int slot, int amount) {
		return inv.decrStackSize(slot, amount);
	}

	@Override
	public void setInventorySlotContents(int slot, ItemStack stack) {
		inv.setInventorySlotContents(slot, stack);
	}

	@Override
	public ItemStack getStackInSlotOnClosing(int slot) {
		return inv.getStackInSlotOnClosing(slot);
	}

	@Override
	public String getInventoryName() {
		return "Filler";
	}

	@Override
	public void readFromNBT(NBTTagCompound nbt) {
		super.readFromNBT(nbt);

		inv.readFromNBT(nbt);

		if (nbt.hasKey("pattern")) {
			currentPattern = (FillerPattern) FillerManager.registry.getPattern(nbt.getString("pattern"));
		}

		if (currentPattern == null) {
			currentPattern = PatternFill.INSTANCE;
		}

		if (nbt.hasKey("pp")) {
			readParametersFromNBT(nbt.getCompoundTag("pp"));
		} else {
			initPatternParameters();
		}

		if (nbt.hasKey("box")) {
			box.initialize(nbt.getCompoundTag("box"));
		}

		done = nbt.getBoolean("done");
		excavate = nbt.hasKey("excavate") ? nbt.getBoolean("excavate") : true;


		initNBT = (NBTTagCompound) nbt.getCompoundTag("bpt").copy();
	}

	@Override
	public void writeToNBT(NBTTagCompound nbt) {
		super.writeToNBT(nbt);

		inv.writeToNBT(nbt);

		if (currentPattern != null) {
			nbt.setString("pattern", currentPattern.getUniqueTag());
		}

		NBTTagCompound boxStore = new NBTTagCompound();
		box.writeToNBT(boxStore);
		nbt.setTag("box", boxStore);

		nbt.setBoolean("done", done);
		nbt.setBoolean("excavate", excavate);

		NBTTagCompound bptNBT = new NBTTagCompound();

		if (currentTemplate != null) {
			NBTTagCompound builderCpt = new NBTTagCompound();
			currentTemplate.saveBuildStateToNBT(builderCpt, this);
			bptNBT.setTag("builderState", builderCpt);
		}

		nbt.setTag("bpt", bptNBT);

		NBTTagCompound ppNBT = new NBTTagCompound();
		writeParametersToNBT(ppNBT);
		nbt.setTag("pp", ppNBT);
	}

	@Override
		public int getInventoryStackLimit() {
		return inv.getInventoryStackLimit();
	}

	@Override
	public boolean isUseableByPlayer(EntityPlayer entityplayer) {
		if (worldObj.getTileEntity(xCoord, yCoord, zCoord) != this) {
			return false;
		}

		return entityplayer.getDistanceSq(xCoord + 0.5D, yCoord + 0.5D,
				zCoord + 0.5D) <= 64D;
	}

	@Override
	public void invalidate() {
		super.invalidate();
		destroy();
	}

	private void initPatternParameters() {
		patternParameters = new IStatementParameter[currentPattern.maxParameters()];
		for (int i = 0; i < currentPattern.minParameters(); i++) {
			patternParameters[i] = currentPattern.createParameter(i);
		}
	}

	public void setPattern(FillerPattern pattern) {
		if (pattern != null && currentPattern != pattern) {
			currentPattern = pattern;
			currentTemplate = null;
			done = false;
			initPatternParameters();
			sendNetworkUpdate();
		}
	}

	private void writeParametersToNBT(NBTTagCompound nbt) {
		nbt.setByte("length", (byte) (patternParameters != null ? patternParameters.length : 0));
		if (patternParameters != null) {
			for (int i = 0; i < patternParameters.length; i++) {
				if (patternParameters[i] != null) {
					NBTTagCompound patternData = new NBTTagCompound();
					patternData.setString("kind", patternParameters[i].getUniqueTag());
					patternParameters[i].writeToNBT(patternData);
					nbt.setTag("p" + i, patternData);
				}
			}
		}
	}

	private void readParametersFromNBT(NBTTagCompound nbt) {
		patternParameters = new IStatementParameter[nbt.getByte("length")];
		for (int i = 0; i < patternParameters.length; i++) {
			if (nbt.hasKey("p" + i)) {
				NBTTagCompound patternData = nbt.getCompoundTag("p" + i);
				patternParameters[i] = StatementManager.createParameter(patternData.getString("kind"));
				patternParameters[i].readFromNBT(patternData);
			}
		}
	}

	@Override
	public void writeData(ByteBuf data) {
		box.writeData(data);
		data.writeByte((done ? 1 : 0) | (excavate ? 2 : 0));
		NetworkUtils.writeUTF(data, currentPattern.getUniqueTag());

		NBTTagCompound parameterData = new NBTTagCompound();
		writeParametersToNBT(parameterData);
		NetworkUtils.writeNBT(data, parameterData);
	}

	@Override
	public void readData(ByteBuf data) {
		box.readData(data);
		int flags = data.readUnsignedByte();
		done = (flags & 1) > 0;
		excavate = (flags & 2) > 0;
		FillerPattern pattern = (FillerPattern) FillerManager.registry.getPattern(NetworkUtils.readUTF(data));
		NBTTagCompound parameterData = NetworkUtils.readNBT(data);
		readParametersFromNBT(parameterData);
		setPattern(pattern);

		worldObj.markBlockForUpdate(xCoord, yCoord, zCoord);
	}

	@Override
	public boolean hasWork() {
		return !done && mode != Mode.Off;
	}

	@Override
	public void openInventory() {
	}

	@Override
	public void closeInventory() {
	}

	@Override
	public boolean isItemValidForSlot(int slot, ItemStack stack) {
		return true;
	}

	public void rpcSetPatternFromString(final String name) {
		BuildCraftCore.instance.sendToServer(new PacketCommand(this, "setPattern", new CommandWriter() {
			public void write(ByteBuf data) {
				NetworkUtils.writeUTF(data, name);
			}
		}));
	}

	@Override
	public void receiveCommand(String command, Side side, Object sender, ByteBuf stream) {
		super.receiveCommand(command, side, sender, stream);
		if (side.isServer()) {
			if ("setPattern".equals(command)) {
				String name = NetworkUtils.readUTF(stream);
				setPattern((FillerPattern) FillerManager.registry.getPattern(name));

				done = false;
			} else if ("setParameters".equals(command)) {
				NBTTagCompound patternData = NetworkUtils.readNBT(stream);
				readParametersFromNBT(patternData);

				done = false;
			} else if ("setFlags".equals(command)) {
				excavate = stream.readBoolean();
				currentTemplate = null;

				sendNetworkUpdate();
				done = false;
			}
		}
	}

	@Override
	public boolean hasCustomInventoryName() {
		return false;
	}

	@Override
	public Box getBox() {
		return box;
	}

	@Override
	public AxisAlignedBB getRenderBoundingBox() {
		return new Box (this).extendToEncompass(box).expand(50).getBoundingBox();
	}

	@Override
	public boolean isBuildingMaterialSlot(int i) {
		return true;
	}

	@Override
	public boolean acceptsControlMode(Mode mode) {
		return mode == IControllable.Mode.On ||
				mode == IControllable.Mode.Off ||
				mode == IControllable.Mode.Loop;
	}

	@Override
	public TileEntity getTile() {
		return this;
	}

	public void rpcSetParameter(int i, IStatementParameter patternParameter) {
		BuildCraftCore.instance.sendToServer(new PacketCommand(this, "setParameters", new CommandWriter() {
			public void write(ByteBuf data) {
				NBTTagCompound parameterData = new NBTTagCompound();
				writeParametersToNBT(parameterData);
				NetworkUtils.writeNBT(data, parameterData);
			}
		}));
	}

	public int getIconGlowLevel(int renderPass) {
		if (renderPass == 1) { 
			return done ? 15 : 0;
		} else if (renderPass == 2) { 
			return 0;
		} else {
			return -1;
		}
	}

	@Override
	public int getLEDLevel(int led) {
		return (led == 0 ? done : buildersInAction.size() > 0) ? 15 : 0;
	}

	public void setExcavate(boolean excavate) {
		this.excavate = excavate;
	}
}

<code block>

package buildcraft.builders.gui;

import io.netty.buffer.ByteBuf;

import net.minecraft.client.gui.GuiButton;
import net.minecraft.inventory.IInventory;
import net.minecraft.util.ResourceLocation;

import buildcraft.BuildCraftCore;
import buildcraft.api.filler.FillerManager;
import buildcraft.api.statements.IStatement;
import buildcraft.api.statements.IStatementParameter;
import buildcraft.api.statements.StatementMouseClick;
import buildcraft.builders.TileFiller;
import buildcraft.core.builders.patterns.FillerPattern;
import buildcraft.core.lib.gui.AdvancedSlot;
import buildcraft.core.lib.gui.GuiAdvancedInterface;
import buildcraft.core.lib.gui.GuiTools;
import buildcraft.core.lib.gui.StatementParameterSlot;
import buildcraft.core.lib.gui.StatementSlot;
import buildcraft.core.lib.gui.buttons.ButtonTextureSet;
import buildcraft.core.lib.gui.buttons.GuiBetterButton;
import buildcraft.core.lib.gui.buttons.IButtonTextureSet;
import buildcraft.core.lib.gui.buttons.StandardButtonTextureSets;
import buildcraft.core.lib.network.command.CommandWriter;
import buildcraft.core.lib.network.command.PacketCommand;
import buildcraft.core.lib.utils.StringUtils;

public class GuiFiller extends GuiAdvancedInterface {
	class FillerParameterSlot extends StatementParameterSlot {
		public FillerParameterSlot(int x, int y, int slot) {
			super(instance, x, y, slot, fakeStatementSlot);
		}

		@Override
		public IStatementParameter getParameter() {
			if (slot >= instance.filler.patternParameters.length) {
				return null;
			} else {
				return instance.filler.patternParameters[slot];
			}
		}

		@Override
		public void setParameter(IStatementParameter param, boolean notifyServer) {

		}
	}

	private static final ResourceLocation TEXTURE = new ResourceLocation("buildcraftbuilders:textures/gui/filler.png");
	private static final IButtonTextureSet EXCAVATE_OFF = new ButtonTextureSet(240, -16, 16, 16, TEXTURE);
	private static final IButtonTextureSet EXCAVATE_ON = new ButtonTextureSet(224, -16, 16, 16, TEXTURE);
	private final IInventory playerInventory;
	private final TileFiller filler;
	private final GuiFiller instance;
	private final StatementSlot fakeStatementSlot;

	public GuiFiller(IInventory playerInventory, TileFiller filler) {
		super(new ContainerFiller(playerInventory, filler), filler, TEXTURE);
		this.playerInventory = playerInventory;
		this.filler = filler;
		this.instance = this;
		this.fakeStatementSlot = new StatementSlot(instance, -1, -1, 0) {
			@Override
			public IStatement getStatement() {
				return instance.filler.currentPattern;
			}
		};
		xSize = 175;
		ySize = 240;
	}

	private IButtonTextureSet getExcavateTexture() {
		return filler.isExcavate() ? EXCAVATE_ON : EXCAVATE_OFF;
	}

	@Override
	public void initGui() {
		super.initGui();
		buttonList.clear();

		buttonList.add(new GuiBetterButton(0, guiLeft + 38 - 18, guiTop + 30, 10,
				StandardButtonTextureSets.LEFT_BUTTON, ""));
		buttonList.add(new GuiBetterButton(1, guiLeft + 38 + 16 + 8, guiTop + 30, 10,
				StandardButtonTextureSets.RIGHT_BUTTON, ""));
		buttonList.add(new GuiBetterButton(2, guiLeft + 150, guiTop + 30, 16,
				getExcavateTexture(), ""));

		slots.clear();
		for (int i = 0; i < 4; i++) {
			slots.add(new FillerParameterSlot(77 + (i * 18), 30, i));
		}
	}

	@Override
	protected void actionPerformed(GuiButton button) {
		super.actionPerformed(button);

		if (button.id == 0) {
			filler.currentPattern = (FillerPattern) FillerManager.registry.getPreviousPattern(filler.currentPattern);
		} else if (button.id == 1) {
			filler.currentPattern = (FillerPattern) FillerManager.registry.getNextPattern(filler.currentPattern);
		} else if (button.id == 2) {
			filler.setExcavate(!filler.isExcavate());

			buttonList.set(2, new GuiBetterButton(2, guiLeft + 150, guiTop + 30, 16,
					getExcavateTexture(), ""));

			BuildCraftCore.instance.sendToServer(new PacketCommand(filler, "setFlags", new CommandWriter() {
				public void write(ByteBuf data) {
					data.writeBoolean(filler.isExcavate());
				}
			}));
		}

		filler.rpcSetPatternFromString(filler.currentPattern.getUniqueTag());
	}

	@Override
	protected void mouseClicked(int x, int y, int k) {
		super.mouseClicked(x, y, k);

		AdvancedSlot slot = getSlotAtLocation(x, y);

		if (slot != null) {
			int i  = ((FillerParameterSlot) slot).slot;
			if (i < filler.patternParameters.length) {
				if (filler.patternParameters[i] != null) {
					filler.patternParameters[i].onClick(filler, filler.currentPattern, mc.thePlayer.inventory.getItemStack(),
							new StatementMouseClick(k, isShiftKeyDown()));
				} else {
					filler.patternParameters[i] = filler.currentPattern.createParameter(i);
				}
				filler.rpcSetParameter(i, filler.patternParameters[i]);
			}
		}
	}

	@Override
	protected void drawGuiContainerBackgroundLayer(float f, int mx, int my) {
		super.drawGuiContainerBackgroundLayer(f, mx, my);
		drawBackgroundSlots();
	}

	@Override
	protected void drawGuiContainerForegroundLayer(int mx, int my) {
		super.drawGuiContainerForegroundLayer(mx, my);

		String title = StringUtils.localize("tile.fillerBlock.name");
		fontRendererObj.drawString(title, getCenteredOffset(title), 6, 0x404040);
		fontRendererObj.drawString(StringUtils.localize("gui.filling.resources"), 8, 74, 0x404040);
		fontRendererObj.drawString(StringUtils.localize("gui.inventory"), 8, 142, 0x404040);
		GuiTools.drawCenteredString(fontRendererObj, filler.currentPattern.getDescription(), 56);

		drawTooltipForSlotAt(mx, my);
	}
}

<code block>

package buildcraft.api.robots;

import net.minecraft.tileentity.TileEntity;

import buildcraft.api.core.BlockIndex;

public class ResourceIdRequest extends ResourceId {

	public ResourceIdRequest() {

	}

	public ResourceIdRequest(TileEntity tile, int i) {
		index = new BlockIndex(tile);
		localId = i;
	}

}

<code block>

package buildcraft.api.robots;

import net.minecraft.item.ItemStack;
import net.minecraft.tileentity.TileEntity;

public class StackRequest {
	public ItemStack stack;
	public int index;
	public TileEntity requester;
	public DockingStation station;
}

<code block>

package buildcraft.api.robots;

import net.minecraft.item.ItemStack;


public interface IRequestProvider {

	int getNumberOfRequests();


	StackRequest getAvailableRequest(int i);


	boolean takeRequest(int i, EntityRobotBase robot);


	ItemStack provideItemsForRequest(int i, ItemStack stack);
}

<code block>

package buildcraft.api.robots;

import net.minecraft.nbt.NBTTagCompound;
import net.minecraftforge.common.util.ForgeDirection;

import buildcraft.api.core.BlockIndex;

public abstract class ResourceId {

	public BlockIndex index = new BlockIndex();
	public ForgeDirection side = ForgeDirection.UNKNOWN;
	public int localId = 0;

	protected ResourceId() {
	}

	@Override
	public boolean equals(Object obj) {
		if (obj == null || obj.getClass() != getClass()) {
			return false;
		}

		ResourceId compareId = (ResourceId) obj;

		return index.equals(compareId.index)
				&& side == compareId.side
				&& localId == compareId.localId;
	}

	@Override
	public int hashCode() {
		return (((index != null ? index.hashCode() : 0) * 37) + (side != null ? side.ordinal() : 0) * 37) + localId;
	}

	public void writeToNBT(NBTTagCompound nbt) {
		NBTTagCompound indexNBT = new NBTTagCompound();
		index.writeTo(indexNBT);
		nbt.setTag("index", indexNBT);
		nbt.setByte("side", (byte) side.ordinal());
		nbt.setInteger("localId", localId);
		nbt.setString("resourceName", RobotManager.getResourceIdName(getClass()));
	}

	protected void readFromNBT(NBTTagCompound nbt) {
		index = new BlockIndex(nbt.getCompoundTag("index"));
		side = ForgeDirection.values()[nbt.getByte("side")];
		localId = nbt.getInteger("localId");
	}

	public static ResourceId load(NBTTagCompound nbt) {
		try {
			Class cls = null;
			if (nbt.hasKey("class")) {

				cls = RobotManager.getResourceIdByLegacyClassName(nbt.getString("class"));
			} else {
				cls = RobotManager.getResourceIdByName(nbt.getString("resourceName"));
			}

			ResourceId id = (ResourceId) cls.newInstance();
			id.readFromNBT(nbt);

			return id;
		} catch (Throwable e) {
			e.printStackTrace();
		}

		return null;
	}

	public void taken(long robotId) {

	}

	public void released(long robotId) {

	}
}

<code block>

package buildcraft.api.robots;

import net.minecraft.tileentity.TileEntity;

import buildcraft.api.core.BlockIndex;

public class ResourceIdBlock extends ResourceId {

	public ResourceIdBlock() {

	}

	public ResourceIdBlock(int x, int y, int z) {
		index = new BlockIndex(x, y, z);
	}

	public ResourceIdBlock(BlockIndex iIndex) {
		index = iIndex;
	}

	public ResourceIdBlock(TileEntity tile) {
		index = new BlockIndex(tile);
	}

}

<code block>
package buildcraft.robotics;

import net.minecraft.inventory.IInventory;
import net.minecraft.item.ItemStack;
import net.minecraft.tileentity.TileEntity;
import net.minecraftforge.common.util.ForgeDirection;
import net.minecraftforge.fluids.IFluidHandler;

import buildcraft.api.core.BlockIndex;
import buildcraft.api.core.EnumColor;
import buildcraft.api.robots.DockingStation;
import buildcraft.api.robots.EntityRobotBase;
import buildcraft.api.robots.IRequestProvider;
import buildcraft.api.robots.RobotManager;
import buildcraft.api.statements.StatementSlot;
import buildcraft.api.transport.IInjectable;
import buildcraft.api.transport.IPipeTile;
import buildcraft.transport.Pipe;
import buildcraft.transport.PipeTransportItems;
import buildcraft.transport.TravelingItem;
import buildcraft.transport.gates.ActionIterator;
import buildcraft.transport.pipes.PipeFluidsWood;
import buildcraft.transport.pipes.PipeItemsWood;

public class DockingStationPipe extends DockingStation {

	private IInjectable injectablePipe = new IInjectable() {
		@Override
		public boolean canInjectItems(ForgeDirection from) {
			return true;
		}

		@Override
		public int injectItem(ItemStack stack, boolean doAdd, ForgeDirection from, EnumColor color) {
			if (doAdd) {
				float cx = x() + 0.5F + 0.2F * side().offsetX;
				float cy = y() + 0.5F + 0.2F * side().offsetY;
				float cz = z() + 0.5F + 0.2F * side().offsetZ;
				TravelingItem item = TravelingItem.make(cx, cy, cz, stack);
				if (item.isCorrupted()) {
					return 0;
				}

				((PipeTransportItems) ((Pipe) getPipe().getPipe()).transport)
						.injectItem(item, from);
			}
			return stack.stackSize;
		}
	};

	private IPipeTile pipe;

	public DockingStationPipe() {

	}

	public DockingStationPipe(IPipeTile iPipe, ForgeDirection side) {
		super(new BlockIndex(iPipe.x(), iPipe.y(), iPipe.z()), side);
		pipe = iPipe;
		world = iPipe.getWorld();
	}

	public IPipeTile getPipe() {
		if (pipe == null) {
			TileEntity tile = world.getTileEntity(x(), y(), z());
			if (tile instanceof IPipeTile) {
				pipe = (IPipeTile) tile;
			}
		}

		if (pipe == null || ((TileEntity) pipe).isInvalid()) {

			RobotManager.registryProvider.getRegistry(world).removeStation(this);
			pipe = null;
		}

		return pipe;
	}

	@Override
	public Iterable<StatementSlot> getActiveActions() {
		return new ActionIterator(getPipe().getPipe());
	}

	@Override
	public IInjectable getItemOutput() {
		if (getPipe().getPipeType() != IPipeTile.PipeType.ITEM) {
			return null;
		}

		return injectablePipe;
	}

	@Override
	public IInventory getItemInput() {
		if (getPipe().getPipeType() != IPipeTile.PipeType.ITEM) {
			return null;
		}

		if (!(getPipe().getPipe() instanceof PipeItemsWood)) {
			return null;
		}

		int meta = ((TileEntity) getPipe()).getBlockMetadata();
		ForgeDirection dir = ForgeDirection.getOrientation(meta);

		TileEntity connectedTile = getPipe().getWorld().getTileEntity(x() + dir.offsetX,
				y() + dir.offsetY, z() + dir.offsetZ);
		if (connectedTile instanceof IInventory) {
			return (IInventory) connectedTile;
		}

		return null;
	}

	@Override
	public IFluidHandler getFluidInput() {
		if (getPipe().getPipeType() != IPipeTile.PipeType.FLUID) {
			return null;
		}

		if (!(getPipe().getPipe() instanceof PipeFluidsWood)) {
			return null;
		}

		int meta = ((TileEntity) getPipe()).getBlockMetadata();
		ForgeDirection dir = ForgeDirection.getOrientation(meta);

		TileEntity connectedTile = getPipe().getWorld().getTileEntity(x() + dir.offsetX,
				y() + dir.offsetY, z() + dir.offsetZ);
		if (connectedTile instanceof IFluidHandler) {
			return (IFluidHandler) connectedTile;
		}

		return null;
	}

	@Override
	public IFluidHandler getFluidOutput() {
		if (getPipe().getPipeType() != IPipeTile.PipeType.FLUID) {
			return null;
		}

		return (IFluidHandler) ((Pipe) getPipe().getPipe()).transport;
	}

	@Override
	public boolean providesPower() {
		return getPipe().getPipeType() == IPipeTile.PipeType.POWER;
	}

	@Override
	public IRequestProvider getRequestProvider() {
		for (ForgeDirection dir : ForgeDirection.VALID_DIRECTIONS) {
			TileEntity nearbyTile = getPipe().getWorld().getTileEntity(x() + dir.offsetX,
					y() + dir.offsetY, z() + dir.offsetZ);
			if (nearbyTile instanceof IRequestProvider) {
				return (IRequestProvider) nearbyTile;
			}
		}
		return null;
	}

	@Override
	public boolean isInitialized() {
		if (getPipe() == null || getPipe().getPipe() == null) {
			return false;
		}
		return ((Pipe) getPipe().getPipe()).isInitialized();
	}

	@Override
	public boolean take(EntityRobotBase robot) {
		boolean result = super.take(robot);
		if (result) {
			getPipe().scheduleRenderUpdate();
		}
		return result;
	}

	@Override
	public boolean takeAsMain(EntityRobotBase robot) {
		boolean result = super.takeAsMain(robot);
		if (result) {
			getPipe().scheduleRenderUpdate();
		}
		return result;
	}

	@Override
	public void unsafeRelease(EntityRobotBase robot) {
		super.unsafeRelease(robot);
		if (robotTaking() == null) {
			getPipe().scheduleRenderUpdate();
		}
	}

	@Override
	public void onChunkUnload() {
		pipe = null;
	}
}

<code block>

package buildcraft.robotics;

import io.netty.buffer.ByteBuf;

import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.inventory.IInventory;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import cpw.mods.fml.relauncher.Side;

import buildcraft.BuildCraftCore;
import buildcraft.api.robots.EntityRobotBase;
import buildcraft.api.robots.IRequestProvider;
import buildcraft.api.robots.ResourceIdRequest;
import buildcraft.api.robots.RobotManager;
import buildcraft.api.robots.StackRequest;
import buildcraft.core.lib.block.TileBuildCraft;
import buildcraft.core.lib.inventory.SimpleInventory;
import buildcraft.core.lib.inventory.StackHelper;
import buildcraft.core.lib.network.command.CommandWriter;
import buildcraft.core.lib.network.command.ICommandReceiver;
import buildcraft.core.lib.network.command.PacketCommand;
import buildcraft.core.lib.utils.NetworkUtils;

public class TileRequester extends TileBuildCraft implements IInventory, IRequestProvider, ICommandReceiver {
	public static final int NB_ITEMS = 20;

	private SimpleInventory inv = new SimpleInventory(NB_ITEMS, "items", 64);
	private SimpleInventory requests = new SimpleInventory(NB_ITEMS, "requests", 64);

	public TileRequester() {

	}

	public void setRequest(final int index, final ItemStack stack) {
		if (worldObj.isRemote) {
			BuildCraftCore.instance.sendToServer(new PacketCommand(this, "setRequest", new CommandWriter() {
				public void write(ByteBuf data) {
					data.writeByte(index);
					NetworkUtils.writeStack(data, stack);
				}
			}));
		} else {
			requests.setInventorySlotContents(index, stack);
		}
	}

	@Override
	public void receiveCommand(String command, Side side, Object sender, ByteBuf stream) {
		if (side.isServer() && "setRequest".equals(command)) {
			setRequest(stream.readUnsignedByte(), NetworkUtils.readStack(stream));
		}
	}

	public ItemStack getRequest(int index) {
		return requests.getStackInSlot(index);
	}

	@Override
	public int getSizeInventory() {
		return inv.getSizeInventory();
	}

	@Override
	public ItemStack getStackInSlot(int slotId) {
		return inv.getStackInSlot(slotId);
	}

	@Override
	public ItemStack decrStackSize(int slotId, int count) {
		return inv.decrStackSize(slotId, count);
	}

	@Override
	public ItemStack getStackInSlotOnClosing(int slotId) {
		return inv.getStackInSlotOnClosing(slotId);
	}

	@Override
	public void setInventorySlotContents(int slotId, ItemStack itemStack) {
		inv.setInventorySlotContents(slotId, itemStack);
	}

	@Override
	public String getInventoryName() {
		return inv.getInventoryName();
	}

	@Override
	public boolean hasCustomInventoryName() {
		return inv.hasCustomInventoryName();
	}

	@Override
	public int getInventoryStackLimit() {
		return inv.getInventoryStackLimit();
	}

	@Override
	public boolean isUseableByPlayer(EntityPlayer entityPlayer) {
		return inv.isUseableByPlayer(entityPlayer);
	}

	@Override
	public void openInventory() {
		inv.openInventory();
	}

	@Override
	public void closeInventory() {
		inv.closeInventory();
	}

	@Override
	public boolean isItemValidForSlot(int i, ItemStack itemStack) {
		if (requests.getStackInSlot(i) == null) {
			return false;
		} else if (!StackHelper.isMatchingItemOrList(requests.getStackInSlot(i), itemStack)) {
			return false;
		} else {
			return inv.isItemValidForSlot(i, itemStack);
		}
	}

	@Override
	public void writeToNBT(NBTTagCompound nbt) {
		super.writeToNBT(nbt);

		NBTTagCompound invNBT = new NBTTagCompound();
		inv.writeToNBT(invNBT);
		nbt.setTag("inv", invNBT);

		NBTTagCompound reqNBT = new NBTTagCompound();
		requests.writeToNBT(reqNBT);
		nbt.setTag("req", reqNBT);
	}

	@Override
	public void readFromNBT(NBTTagCompound nbt) {
		super.readFromNBT(nbt);

		inv.readFromNBT(nbt.getCompoundTag("inv"));
		requests.readFromNBT(nbt.getCompoundTag("req"));
	}

	public boolean isFulfilled(int i) {
		if (requests.getStackInSlot(i) == null) {
			return true;
		} else if (inv.getStackInSlot(i) == null) {
			return false;
		} else {
			return StackHelper.isMatchingItemOrList(requests.getStackInSlot(i), inv.getStackInSlot(i))
					&& inv.getStackInSlot(i).stackSize >= requests.getStackInSlot(i).stackSize;
		}
	}

	@Override
	public int getNumberOfRequests() {
		return NB_ITEMS;
	}

	@Override
	public StackRequest getAvailableRequest(int i) {
		if (requests.getStackInSlot(i) == null) {
			return null;
		} else if (isFulfilled(i)) {
			return null;
		} else if (RobotManager.registryProvider.getRegistry(worldObj).isTaken(new ResourceIdRequest(this, i))) {
			return null;
		} else {
			StackRequest r = new StackRequest();

			r.index = i;
			r.stack = requests.getStackInSlot(i);
			r.requester = this;

			return r;
		}
	}

	@Override
	public boolean takeRequest(int i, EntityRobotBase robot) {
		if (requests.getStackInSlot(i) == null) {
			return false;
		} else if (isFulfilled(i)) {
			return false;
		} else {
			return RobotManager.registryProvider.getRegistry(worldObj).take(new ResourceIdRequest(this, i), robot);
		}
	}

	@Override
	public ItemStack provideItemsForRequest(int i, ItemStack stack) {
		ItemStack existingStack = inv.getStackInSlot(i);

		if (requests.getStackInSlot(i) == null) {
			return stack;
		} else if (existingStack == null) {
			int maxQty = requests.getStackInSlot(i).stackSize;

			if (stack.stackSize <= maxQty) {
				inv.setInventorySlotContents(i, stack);

				return null;
			} else {
				ItemStack newStack = stack.copy();
				newStack.stackSize = maxQty;
				stack.stackSize -= maxQty;

				inv.setInventorySlotContents(i, newStack);

				return stack;
			}
		} else if (!StackHelper.isMatchingItemOrList(stack, existingStack)) {
			return stack;
		} else if (existingStack == null || StackHelper.isMatchingItemOrList(stack, requests.getStackInSlot(i))) {
			int maxQty = requests.getStackInSlot(i).stackSize;

			if (existingStack.stackSize + stack.stackSize <= maxQty) {
				existingStack.stackSize += stack.stackSize;
				return null;
			} else {
				stack.stackSize -= maxQty - existingStack.stackSize;
				existingStack.stackSize = maxQty;
				return stack;
			}
		} else {
			return stack;
		}
	}
}

<code block>

package buildcraft.robotics;

import java.security.InvalidParameterException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagList;
import net.minecraft.util.LongHashMap;
import net.minecraft.world.World;
import net.minecraft.world.WorldSavedData;
import cpw.mods.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.common.util.Constants;
import net.minecraftforge.common.util.ForgeDirection;
import net.minecraftforge.event.world.ChunkEvent;

import buildcraft.api.core.BCLog;
import buildcraft.api.robots.DockingStation;
import buildcraft.api.robots.EntityRobotBase;
import buildcraft.api.robots.IRobotRegistry;
import buildcraft.api.robots.ResourceId;
import buildcraft.api.robots.RobotManager;

public class RobotRegistry extends WorldSavedData implements IRobotRegistry {

	protected World world;
	protected final HashMap<StationIndex, DockingStation> stations = new HashMap<StationIndex, DockingStation>();

	private long nextRobotID = Long.MIN_VALUE;

	private final LongHashMap robotsLoaded = new LongHashMap();
	private final HashSet<EntityRobot> robotsLoadedSet = new HashSet<EntityRobot>();
	private final HashMap<ResourceId, Long> resourcesTaken = new HashMap<ResourceId, Long>();
	private final LongHashMap resourcesTakenByRobot = new LongHashMap();
	private final LongHashMap stationsTakenByRobot = new LongHashMap();

	public RobotRegistry(String id) {
		super(id);
	}

	@Override
	public long getNextRobotId() {
		long result = nextRobotID;

		nextRobotID = nextRobotID + 1;

		return result;
	}

	@Override
	public void registerRobot(EntityRobotBase robot) {
		markDirty();

		if (robot.getRobotId() == EntityRobotBase.NULL_ROBOT_ID) {
			((EntityRobot) robot).setUniqueRobotId(getNextRobotId());
		}
		if (robotsLoaded.containsItem(robot.getRobotId())) {
			BCLog.logger.warn("Robot with id %d was not unregistered properly", robot.getRobotId());
		}

		addRobotLoaded((EntityRobot) robot);
	}

	private HashSet<ResourceId> getResourcesTakenByRobot(long robotId) {
		return (HashSet<ResourceId>) resourcesTakenByRobot.getValueByKey(robotId);
	}

	private HashSet<StationIndex> getStationsTakenByRobot(long robotId) {
		return (HashSet<StationIndex>) stationsTakenByRobot.getValueByKey(robotId);
	}


	private void addRobotLoaded(EntityRobot robot) {
		robotsLoaded.add(robot.getRobotId(), robot);
		robotsLoadedSet.add(robot);
	}

	private void removeRobotLoaded(EntityRobot robot) {
		robotsLoaded.remove(robot.getRobotId());
		robotsLoadedSet.remove(robot);
	}

	@Override
	public void killRobot(EntityRobotBase robot) {
		markDirty();

		releaseResources(robot, true);
		removeRobotLoaded((EntityRobot) robot);
	}

	@Override
	public void unloadRobot(EntityRobotBase robot) {
		markDirty();

		releaseResources(robot, false, true);
		removeRobotLoaded((EntityRobot) robot);
	}

	@Override
	public EntityRobot getLoadedRobot(long id) {
		if (robotsLoaded.containsItem(id)) {
			return (EntityRobot) robotsLoaded.getValueByKey(id);
		} else {
			return null;
		}
	}

	@Override
	public synchronized boolean isTaken(ResourceId resourceId) {
		return robotIdTaking(resourceId) != EntityRobotBase.NULL_ROBOT_ID;
	}

	@Override
	public synchronized long robotIdTaking(ResourceId resourceId) {
		if (!resourcesTaken.containsKey(resourceId)) {
			return EntityRobotBase.NULL_ROBOT_ID;
		}

		long robotId = resourcesTaken.get(resourceId);

		if (robotsLoaded.containsItem(robotId) && !((EntityRobot) robotsLoaded.getValueByKey(robotId)).isDead) {
			return robotId;
		} else {


			release(resourceId);
			return EntityRobotBase.NULL_ROBOT_ID;
		}
	}

	@Override
	public synchronized EntityRobot robotTaking(ResourceId resourceId) {
		long robotId = robotIdTaking(resourceId);

		if (robotId == EntityRobotBase.NULL_ROBOT_ID || !robotsLoaded.containsItem(robotId)) {
			return null;
		} else {
			return (EntityRobot) robotsLoaded.getValueByKey(robotId);
		}
	}

	@Override
	public synchronized boolean take(ResourceId resourceId, EntityRobotBase robot) {
		markDirty();

		return take(resourceId, robot.getRobotId());
	}

	@Override
	public synchronized boolean take(ResourceId resourceId, long robotId) {
		if (resourceId == null) {
			return false;
		}

		markDirty();

		if (!resourcesTaken.containsKey(resourceId)) {
			resourcesTaken.put(resourceId, robotId);

			if (!resourcesTakenByRobot.containsItem(robotId)) {
				resourcesTakenByRobot.add(robotId, new HashSet<ResourceId>());
			}

			getResourcesTakenByRobot(robotId).add(resourceId);

			resourceId.taken(robotId);

			return true;
		} else {
			return false;
		}
	}

	@Override
	public synchronized void release(ResourceId resourceId) {
		if (resourceId == null) {
			return;
		}

		markDirty();

		if (resourcesTaken.containsKey(resourceId)) {
			long robotId = resourcesTaken.get(resourceId);

			getResourcesTakenByRobot(robotId).remove(resourceId);
			resourcesTaken.remove(resourceId);
			resourceId.released(robotId);
		}
	}

	@Override
	public synchronized void releaseResources(EntityRobotBase robot) {
		releaseResources(robot, false);
	}

	private synchronized void releaseResources(EntityRobotBase robot, boolean forceAll) {
		releaseResources(robot, forceAll, false);
	}

	private synchronized void releaseResources(EntityRobotBase robot, boolean forceAll, boolean resetEntities) {
		markDirty();

		if (resourcesTakenByRobot.containsItem(robot.getRobotId())) {
			HashSet<ResourceId> resourceSet = (HashSet<ResourceId>) getResourcesTakenByRobot(robot.getRobotId())
					.clone();

			for (ResourceId id : resourceSet) {
				release(id);
			}

			resourcesTakenByRobot.remove(robot.getRobotId());
		}

		if (stationsTakenByRobot.containsItem(robot.getRobotId())) {
			HashSet<StationIndex> stationSet = (HashSet<StationIndex>) getStationsTakenByRobot(robot.getRobotId())
					.clone();

			for (StationIndex s : stationSet) {
				DockingStation d = stations.get(s);

				if (d != null) {
					if (!d.canRelease()) {
						if (forceAll) {
							d.unsafeRelease(robot);
						} else if (resetEntities && d.robotIdTaking() == robot.getRobotId()) {
							d.invalidateRobotTakingEntity();
						}
					} else {
						d.unsafeRelease(robot);
					}
				}
			}

			if (forceAll) {
				stationsTakenByRobot.remove(robot.getRobotId());
			}
		}
	}

	@Override
	public synchronized DockingStation getStation(int x, int y, int z, ForgeDirection side) {
		StationIndex index = new StationIndex(side, x, y, z);

		if (stations.containsKey(index)) {
			return stations.get(index);
		} else {
			return null;
		}
	}

	@Override
	public synchronized Collection<DockingStation> getStations() {
		return stations.values();
	}

	@Override
	public synchronized void registerStation(DockingStation station) {
		markDirty();

		StationIndex index = new StationIndex(station);

		if (stations.containsKey(index)) {
			throw new InvalidParameterException("Station " + index + " already registered");
		} else {
			stations.put(index, station);
		}
	}

	@Override
	public synchronized void removeStation(DockingStation station) {
		markDirty();

		StationIndex index = new StationIndex(station);

		if (stations.containsKey(index)) {
			if (station.robotTaking() != null) {
				if (!station.isMainStation()) {
					station.robotTaking().undock();
				} else {
					station.robotTaking().setMainStation(null);
				}
			} else if (station.robotIdTaking() != EntityRobotBase.NULL_ROBOT_ID) {
				if (stationsTakenByRobot.containsItem(station.robotIdTaking())) {
					getStationsTakenByRobot(station.robotIdTaking()).remove(index);
				}
			}

			stations.remove(index);
		}
	}

	@Override
	public synchronized void take(DockingStation station, long robotId) {
		if (!stationsTakenByRobot.containsItem(robotId)) {
			stationsTakenByRobot.add(robotId, new HashSet<StationIndex>());
		}

		getStationsTakenByRobot(robotId).add(new StationIndex(station));
	}

	@Override
	public synchronized void release(DockingStation station, long robotId) {
		if (stationsTakenByRobot.containsItem(robotId)) {
			getStationsTakenByRobot(robotId).remove(new StationIndex(station));
		}
	}

	@Override
	public synchronized void writeToNBT(NBTTagCompound nbt) {
		nbt.setLong("nextRobotID", nextRobotID);

		NBTTagList resourceList = new NBTTagList();

		for (Map.Entry<ResourceId, Long> e : resourcesTaken.entrySet()) {
			NBTTagCompound cpt = new NBTTagCompound();
			NBTTagCompound resourceId = new NBTTagCompound();
			e.getKey().writeToNBT(resourceId);
			cpt.setTag("resourceId", resourceId);
			cpt.setLong("robotId", e.getValue());

			resourceList.appendTag(cpt);
		}

		nbt.setTag("resourceList", resourceList);

		NBTTagList stationList = new NBTTagList();

		for (Map.Entry<StationIndex, DockingStation> e : stations.entrySet()) {
			NBTTagCompound cpt = new NBTTagCompound();
			e.getValue().writeToNBT(cpt);
			cpt.setString("stationType", RobotManager.getDockingStationName(e.getValue().getClass()));
			stationList.appendTag(cpt);
		}

		nbt.setTag("stationList", stationList);
	}

	@Override
	public synchronized void readFromNBT(NBTTagCompound nbt) {
		nextRobotID = nbt.getLong("nextRobotID");

		NBTTagList resourceList = nbt.getTagList("resourceList", Constants.NBT.TAG_COMPOUND);

		for (int i = 0; i < resourceList.tagCount(); ++i) {
			NBTTagCompound cpt = resourceList.getCompoundTagAt(i);
			ResourceId resourceId = ResourceId.load(cpt.getCompoundTag("resourceId"));
			long robotId = cpt.getLong("robotId");

			take(resourceId, robotId);
		}

		NBTTagList stationList = nbt.getTagList("stationList", Constants.NBT.TAG_COMPOUND);

		for (int i = 0; i < stationList.tagCount(); ++i) {
			NBTTagCompound cpt = stationList.getCompoundTagAt(i);

			Class<? extends DockingStation> cls;

			if (!cpt.hasKey("stationType")) {
				cls = DockingStationPipe.class;
			} else {
				cls = RobotManager.getDockingStationByName(cpt.getString("stationType"));
				if (cls == null) {
					BCLog.logger.error("Could not load docking station of type "
							+ nbt.getString("stationType"));
					continue;
				}
			}

			try {
				DockingStation station = cls.newInstance();
				station.readFromNBT(cpt);

				registerStation(station);

				if (station.linkedId() != EntityRobotBase.NULL_ROBOT_ID) {
					take(station, station.linkedId());
				}
			} catch (Exception e) {
				BCLog.logger.error("Could not load docking station", e);
			}
		}
	}

	@SubscribeEvent
	public void onChunkUnload(ChunkEvent.Unload e) {
		if (e.world == this.world) {
			for (EntityRobot robot : new ArrayList<EntityRobot>(robotsLoadedSet)) {
				if (!e.world.loadedEntityList.contains(robot)) {
					robot.onChunkUnload();
				}
			}
			for (DockingStation station : new ArrayList<DockingStation>(stations.values())) {
				if (!world.blockExists(station.x(), station.y(), station.z())) {
					station.onChunkUnload();
				}
			}
		}
	}


	@Override
	public void registryMarkDirty() {
		markDirty();
	}
}

<code block>

package buildcraft.robotics.boards;

import java.util.ArrayList;

import net.minecraft.item.ItemStack;

import buildcraft.api.boards.RedstoneBoardRobot;
import buildcraft.api.boards.RedstoneBoardRobotNBT;
import buildcraft.api.robots.AIRobot;
import buildcraft.api.robots.EntityRobotBase;
import buildcraft.api.robots.StackRequest;
import buildcraft.core.lib.inventory.StackHelper;
import buildcraft.core.lib.inventory.filters.IStackFilter;
import buildcraft.robotics.ai.AIRobotDeliverRequested;
import buildcraft.robotics.ai.AIRobotDisposeItems;
import buildcraft.robotics.ai.AIRobotGotoSleep;
import buildcraft.robotics.ai.AIRobotGotoStationAndLoad;
import buildcraft.robotics.ai.AIRobotSearchStackRequest;
import buildcraft.robotics.statements.ActionRobotFilter;

public class BoardRobotDelivery extends RedstoneBoardRobot {

	private ArrayList<ItemStack> deliveryBlacklist = new ArrayList<ItemStack>();

	private StackRequest currentRequest = null;

	public BoardRobotDelivery(EntityRobotBase iRobot) {
		super(iRobot);
	}

	@Override
	public RedstoneBoardRobotNBT getNBTHandler() {
		return BCBoardNBT.REGISTRY.get("delivery");
	}

	@Override
	public void update() {
		if (robot.containsItems()) {



			startDelegateAI(new AIRobotDisposeItems(robot));
			return;
		}

		if (currentRequest == null) {
			startDelegateAI(new AIRobotSearchStackRequest(robot, ActionRobotFilter.getGateFilter(robot
					.getLinkedStation()), deliveryBlacklist));
		} else {
			startDelegateAI(new AIRobotGotoStationAndLoad(robot, new ReqFilter(), 1));
		}
	}

	@Override
	public void delegateAIEnded(AIRobot ai) {
		if (ai instanceof AIRobotSearchStackRequest) {
			if (!ai.success()) {
				deliveryBlacklist.clear();
				startDelegateAI(new AIRobotGotoSleep(robot));
			} else {
				currentRequest = ((AIRobotSearchStackRequest) ai).request;

				if (!currentRequest.station.take(robot)) {
					currentRequest = null;
				}
			}
		} else if (ai instanceof AIRobotGotoStationAndLoad) {
			if (!ai.success()) {
				deliveryBlacklist.add(currentRequest.stack);
				robot.releaseResources();
				currentRequest = null;
			} else {
				startDelegateAI(new AIRobotDeliverRequested(robot, currentRequest));
			}
		} else if (ai instanceof AIRobotDeliverRequested) {
			robot.releaseResources();
			currentRequest = null;
		}
	}

	private class ReqFilter implements IStackFilter {

		@Override
		public boolean matches(ItemStack stack) {
			if (currentRequest == null) {
				return false;
			} else {
				return StackHelper.isMatchingItemOrList(stack, currentRequest.stack);
			}
		}
	}
}

<code block>

package buildcraft.robotics.ai;

import net.minecraft.item.ItemStack;
import net.minecraftforge.common.util.ForgeDirection;

import buildcraft.api.core.IInvSlot;
import buildcraft.api.robots.AIRobot;
import buildcraft.api.robots.DockingStation;
import buildcraft.api.robots.EntityRobotBase;
import buildcraft.api.transport.IInjectable;
import buildcraft.core.lib.inventory.InventoryIterator;
import buildcraft.core.lib.inventory.filters.ArrayStackOrListFilter;
import buildcraft.robotics.statements.ActionRobotFilter;
import buildcraft.robotics.statements.ActionStationInputItems;

public class AIRobotUnload extends AIRobot {

	private int waitedCycles = 0;

	public AIRobotUnload(EntityRobotBase iRobot) {
		super(iRobot);
	}

	@Override
	public void update() {
		waitedCycles++;

		if (waitedCycles > 40) {
			if (unload(robot, robot.getDockingStation(), true)) {
				waitedCycles = 0;
			} else {
				setSuccess(!robot.containsItems());
				terminate();
			}
		}
	}

	public static boolean unload(EntityRobotBase robot, DockingStation station, boolean doUnload) {
		if (station == null) {
			return false;
		}

		IInjectable output = station.getItemOutput();
		if (output == null) {
			return false;
		}

		ForgeDirection injectSide = station.side().getOpposite();
		if (!output.canInjectItems(injectSide)) {
			return false;
		}

		for (IInvSlot robotSlot : InventoryIterator.getIterable(robot, ForgeDirection.UNKNOWN)) {
			if (robotSlot.getStackInSlot() == null) {
				continue;
			}

			if (!ActionRobotFilter
					.canInteractWithItem(station, new ArrayStackOrListFilter(robotSlot.getStackInSlot()),
							ActionStationInputItems.class)) {
				return false;
			}

			ItemStack stack = robotSlot.getStackInSlot();
			int used = output.injectItem(stack, doUnload, injectSide, null);

			if (used > 0) {
				if (doUnload) {
					robotSlot.decreaseStackInSlot(used);
				}
				return true;
			}
		}

		return false;
	}

	@Override
	public int getEnergyCost() {
		return 10;
	}
}

<code block>

package buildcraft.robotics.ai;

import java.util.Collection;

import net.minecraft.item.ItemStack;

import buildcraft.api.robots.AIRobot;
import buildcraft.api.robots.DockingStation;
import buildcraft.api.robots.EntityRobotBase;
import buildcraft.api.robots.IRequestProvider;
import buildcraft.api.robots.StackRequest;
import buildcraft.api.statements.IStatementParameter;
import buildcraft.api.statements.StatementParameterItemStack;
import buildcraft.api.statements.StatementSlot;
import buildcraft.core.lib.inventory.StackHelper;
import buildcraft.core.lib.inventory.filters.IStackFilter;
import buildcraft.robotics.IStationFilter;
import buildcraft.robotics.statements.ActionRobotFilter;
import buildcraft.robotics.statements.ActionStationRequestItems;
import buildcraft.robotics.statements.ActionStationRequestItemsMachine;

public class AIRobotSearchStackRequest extends AIRobot {

	public StackRequest request = null;

	private Collection<ItemStack> blackList;

	private IStackFilter filter;

	public AIRobotSearchStackRequest(EntityRobotBase iRobot) {
		super(iRobot);
	}

	public AIRobotSearchStackRequest(EntityRobotBase iRobot, IStackFilter iFilter, Collection<ItemStack> iBlackList) {
		this(iRobot);

		blackList = iBlackList;
		filter = iFilter;
	}

	@Override
	public void start() {
		startDelegateAI(new AIRobotSearchStation(robot, new StationProviderFilter(), robot.getZoneToWork()));
	}

	@Override
	public void delegateAIEnded(AIRobot ai) {
		if (ai instanceof AIRobotSearchStation) {
			if (!ai.success()) {
				terminate();
			} else {
				request = getOrderFromRequestingAction(((AIRobotSearchStation) ai).targetStation);

				if (request == null) {
					request = getOrderFromRequestingStation(((AIRobotSearchStation) ai).targetStation, true);
				}

				terminate();
			}
		}
	}

	@Override
	public boolean success() {
		return request != null;
	}

	private boolean isBlacklisted(ItemStack stack) {
		for (ItemStack black : blackList) {
			if (StackHelper.isMatchingItem(stack, black)) {
				return true;
			}
		}

		return false;
	}

	private StackRequest getOrderFromRequestingStation(DockingStation station, boolean take) {
		if (!ActionRobotFilter.canInteractWithItem(station, filter, ActionStationRequestItemsMachine.class)) {
			return null;
		}

		IRequestProvider provider = station.getRequestProvider();
		if (provider == null) {
			return null;
		}

		for (int i = 0; i < provider.getNumberOfRequests(); ++i) {
			StackRequest requestFound = provider.getAvailableRequest(i);

			if (requestFound != null
					&& !isBlacklisted(requestFound.stack)
					&& filter.matches(requestFound.stack)) {
				requestFound.station = station;

				if (take) {
					if (provider.takeRequest(i, robot)) {
						return requestFound;
					}
				} else {
					return requestFound;
				}
			}
		}

		return null;
	}

	private StackRequest getOrderFromRequestingAction(DockingStation station) {
		for (StatementSlot s : station.getActiveActions()) {
			if (s.statement instanceof ActionStationRequestItems) {
				for (IStatementParameter p : s.parameters) {
					StatementParameterItemStack param = (StatementParameterItemStack) p;

					if (param != null && !isBlacklisted(param.getItemStack())) {
						StackRequest req = new StackRequest();
						req.station = station;
						req.stack = param.getItemStack();

						return req;
					}
				}
			}
		}

		return null;
	}

	private class StationProviderFilter implements IStationFilter {

		@Override
		public boolean matches(DockingStation station) {
			return getOrderFromRequestingAction(station) != null
					|| getOrderFromRequestingStation(station, false) != null;
		}
	}

}

<code block>

package buildcraft.robotics.ai;

import net.minecraft.item.ItemStack;

import buildcraft.api.core.IInvSlot;
import buildcraft.api.robots.AIRobot;
import buildcraft.api.robots.EntityRobotBase;
import buildcraft.api.robots.IRequestProvider;
import buildcraft.api.robots.StackRequest;
import buildcraft.core.lib.inventory.InvUtils;
import buildcraft.core.lib.inventory.filters.ArrayStackOrListFilter;

public class AIRobotDeliverRequested extends AIRobot {

	private StackRequest requested;
	private boolean delivered = false;

	public AIRobotDeliverRequested(EntityRobotBase iRobot) {
		super(iRobot);
	}

	public AIRobotDeliverRequested(EntityRobotBase robot, StackRequest request) {
		this(robot);

		requested = request;
	}

	@Override
	public void start() {
		startDelegateAI(new AIRobotGotoStation(robot, requested.station));
	}

	@Override
	public void delegateAIEnded(AIRobot ai) {
		if (ai instanceof AIRobotGotoStation) {
			if (!ai.success()) {
				terminate();
				return;
			}

			IInvSlot slot = InvUtils.getItem(robot, new ArrayStackOrListFilter(requested.stack));

			if (slot == null) {
				terminate();
				return;
			}

			if (requested.requester != null) {
				ItemStack newStack = ((IRequestProvider)
					requested.requester).provideItemsForRequest(requested.index,
							slot.getStackInSlot().copy());

				if (newStack == null || newStack.stackSize != slot.getStackInSlot().stackSize) {
					delivered = true;
					slot.setStackInSlot(newStack);
				}

				terminate();
			} else {
				startDelegateAI(new AIRobotUnload(robot));
				return;
			}
		} else if (ai instanceof AIRobotUnload) {
			delivered = ai.success();
			terminate();
		}
	}


	@Override
	public boolean success() {
		return delivered;
	}
}

<code block>

package buildcraft.robotics.gui;

import io.netty.buffer.ByteBuf;

import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.inventory.IInventory;
import net.minecraft.inventory.Slot;
import net.minecraft.item.ItemStack;
import cpw.mods.fml.relauncher.Side;

import buildcraft.BuildCraftCore;
import buildcraft.core.lib.gui.BuildCraftContainer;
import buildcraft.core.lib.network.command.CommandWriter;
import buildcraft.core.lib.network.command.ICommandReceiver;
import buildcraft.core.lib.network.command.PacketCommand;
import buildcraft.core.lib.utils.NetworkUtils;
import buildcraft.robotics.TileRequester;

public class ContainerRequester extends BuildCraftContainer implements ICommandReceiver {

	public GuiRequester gui;

	public ItemStack[] requests = new ItemStack[TileRequester.NB_ITEMS];

	private TileRequester requester;

	public ContainerRequester(IInventory playerInventory, TileRequester iRequester) {
		super(iRequester.getSizeInventory());

		requester = iRequester;

		for (int x = 0; x < 4; ++x) {
			for (int y = 0; y < 5; ++y) {
				addSlotToContainer(new Slot(iRequester, x * 5 + y, 117 + x * 18, 7 + y * 18));
			}
		}


		for (int l = 0; l < 3; l++) {
			for (int k1 = 0; k1 < 9; k1++) {
				addSlotToContainer(new Slot(playerInventory, k1 + l * 9 + 9, 19 + k1 * 18, 101 + l * 18));
			}
		}

		for (int i1 = 0; i1 < 9; i1++) {
			addSlotToContainer(new Slot(playerInventory, i1, 19 + i1 * 18, 159));
		}
	}

	@Override
	public boolean canInteractWith(EntityPlayer player) {
		return true;
	}

	public void getRequestList() {
		BuildCraftCore.instance.sendToServer(new PacketCommand(this, "getRequestList", null));
	}

	@Override
	public void receiveCommand(String command, Side side, Object sender, ByteBuf stream) {
		if (side.isServer() && "getRequestList".equals(command)) {
			final ItemStack[] stacks = new ItemStack[TileRequester.NB_ITEMS];

			for (int i = 0; i < TileRequester.NB_ITEMS; ++i) {
				stacks[i] = requester.getRequest(i);
			}

			BuildCraftCore.instance.sendToPlayer((EntityPlayer) sender, new PacketCommand(this, "receiveRequestList",
					new CommandWriter() {
				public void write(ByteBuf data) {
					for (ItemStack s : stacks) {
						NetworkUtils.writeStack(data, s);
					}
				}
			}));
		} else if (side.isClient() && "receiveRequestList".equals(command)) {
			requests = new ItemStack[TileRequester.NB_ITEMS];
			for (int i = 0; i < TileRequester.NB_ITEMS; i++) {
				requests[i] = NetworkUtils.readStack(stream);
			}
		}
	}
}

<code block>

package buildcraft.builders;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import io.netty.buffer.ByteBuf;

import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagList;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.AxisAlignedBB;
import net.minecraft.world.WorldSettings.GameType;
import cpw.mods.fml.relauncher.Side;
import net.minecraftforge.common.util.Constants;
import net.minecraftforge.common.util.ForgeDirection;
import net.minecraftforge.fluids.Fluid;
import net.minecraftforge.fluids.FluidContainerRegistry;
import net.minecraftforge.fluids.FluidStack;
import net.minecraftforge.fluids.FluidTankInfo;
import net.minecraftforge.fluids.IFluidHandler;

import buildcraft.BuildCraftBuilders;
import buildcraft.BuildCraftCore;
import buildcraft.api.core.BCLog;
import buildcraft.api.core.BlockIndex;
import buildcraft.api.core.IInvSlot;
import buildcraft.api.core.IPathProvider;
import buildcraft.api.core.Position;
import buildcraft.api.robots.EntityRobotBase;
import buildcraft.api.robots.IRequestProvider;
import buildcraft.api.robots.ResourceIdRequest;
import buildcraft.api.robots.RobotManager;
import buildcraft.api.robots.StackRequest;
import buildcraft.api.tiles.IControllable;
import buildcraft.api.tiles.IHasWork;
import buildcraft.builders.blueprints.RecursiveBlueprintBuilder;
import buildcraft.core.Box;
import buildcraft.core.Box.Kind;
import buildcraft.core.LaserData;
import buildcraft.core.TilePathMarker;
import buildcraft.core.blueprints.Blueprint;
import buildcraft.core.blueprints.BlueprintBase;
import buildcraft.core.blueprints.BptBuilderBase;
import buildcraft.core.blueprints.BptBuilderBlueprint;
import buildcraft.core.blueprints.BptBuilderTemplate;
import buildcraft.core.blueprints.RequirementItemStack;
import buildcraft.core.builders.TileAbstractBuilder;
import buildcraft.core.lib.fluids.Tank;
import buildcraft.core.lib.fluids.TankManager;
import buildcraft.core.lib.inventory.ITransactor;
import buildcraft.core.lib.inventory.InvUtils;
import buildcraft.core.lib.inventory.InventoryIterator;
import buildcraft.core.lib.inventory.SimpleInventory;
import buildcraft.core.lib.inventory.StackHelper;
import buildcraft.core.lib.inventory.Transactor;
import buildcraft.core.lib.network.Packet;
import buildcraft.core.lib.network.command.CommandWriter;
import buildcraft.core.lib.network.command.PacketCommand;
import buildcraft.core.lib.utils.NetworkUtils;

public class TileBuilder extends TileAbstractBuilder implements IHasWork, IFluidHandler, IRequestProvider, IControllable {

	private static int POWER_ACTIVATION = 500;

	public Box box = new Box();
	public PathIterator currentPathIterator;
	public Tank[] fluidTanks = new Tank[] {
			new Tank("fluid1", FluidContainerRegistry.BUCKET_VOLUME * 8, this),
			new Tank("fluid2", FluidContainerRegistry.BUCKET_VOLUME * 8, this),
			new Tank("fluid3", FluidContainerRegistry.BUCKET_VOLUME * 8, this),
			new Tank("fluid4", FluidContainerRegistry.BUCKET_VOLUME * 8, this)
	};
	public TankManager<Tank> fluidTank = new TankManager<Tank>(fluidTanks);

	private SimpleInventory inv = new SimpleInventory(28, "Builder", 64);
	private BptBuilderBase currentBuilder;
	private RecursiveBlueprintBuilder recursiveBuilder;
	private List<BlockIndex> path;
	private ArrayList<RequirementItemStack> requiredToBuild;
	private NBTTagCompound initNBT = null;
	private boolean done = true;
	private boolean isBuilding = false;

	private class PathIterator {

		public Iterator<BlockIndex> currentIterator;
		public double cx, cy, cz;
		public float ix, iy, iz;
		public BlockIndex to;
		public double lastDistance;
		AxisAlignedBB oldBoundingBox = null;
		ForgeDirection o = null;

		public PathIterator(BlockIndex from, Iterator<BlockIndex> it, ForgeDirection initialDir) {
			this.to = it.next();

			currentIterator = it;

			double dx = to.x - from.x;
			double dy = to.y - from.y;
			double dz = to.z - from.z;

			double size = Math.sqrt(dx * dx + dy * dy + dz * dz);

			cx = dx / size / 10;
			cy = dy / size / 10;
			cz = dz / size / 10;

			ix = from.x;
			iy = from.y;
			iz = from.z;

			lastDistance = (ix - to.x) * (ix - to.x) + (iy - to.y)
					* (iy - to.y) + (iz - to.z) * (iz - to.z);

			if (dx == 0 && dz == 0) {
				o = initialDir;
			} else if (Math.abs(dx) > Math.abs(dz)) {
				if (dx > 0) {
					o = ForgeDirection.EAST;
				} else {
					o = ForgeDirection.WEST;
				}
			} else {
				if (dz > 0) {
					o = ForgeDirection.SOUTH;
				} else {
					o = ForgeDirection.NORTH;
				}
			}
		}


		public BptBuilderBase next() {
			while (true) {
				BptBuilderBase bpt;

				int newX = Math.round(ix);
				int newY = Math.round(iy);
				int newZ = Math.round(iz);

				bpt = instanciateBluePrintBuilder(newX, newY, newZ, o);

				if (bpt == null) {
					return null;
				}

				AxisAlignedBB boundingBox = bpt.getBoundingBox();

				if (oldBoundingBox == null || !collision(oldBoundingBox, boundingBox)) {
					oldBoundingBox = boundingBox;
					return bpt;
				}

				ix += cx;
				iy += cy;
				iz += cz;

				double distance = (ix - to.x) * (ix - to.x) + (iy - to.y)
						* (iy - to.y) + (iz - to.z) * (iz - to.z);

				if (distance > lastDistance) {
					return null;
				} else {
					lastDistance = distance;
				}
			}
		}

		public PathIterator iterate() {
			if (currentIterator.hasNext()) {
				PathIterator next = new PathIterator(to, currentIterator, o);
				next.oldBoundingBox = oldBoundingBox;

				return next;
			} else {
				return null;
			}
		}

		public boolean collision(AxisAlignedBB left, AxisAlignedBB right) {
			if (left.maxX < right.minX || left.minX > right.maxX) {
				return false;
			}
			if (left.maxY < right.minY || left.minY > right.maxY) {
				return false;
			}
			if (left.maxZ < right.minZ || left.minZ > right.maxZ) {
				return false;
			}
			return true;
		}
	}

	public TileBuilder() {
		super();

		box.kind = Kind.STRIPES;
	}

	@Override
	public void initialize() {
		super.initialize();

		if (worldObj.isRemote) {
			return;
		}


		if (initNBT != null) {
			iterateBpt(true);

			if (initNBT.hasKey("iterator")) {
				BlockIndex expectedTo = new BlockIndex(initNBT.getCompoundTag("iterator"));

				while (!done && currentBuilder != null && currentPathIterator != null) {
					BlockIndex bi = new BlockIndex((int) currentPathIterator.ix,
							(int) currentPathIterator.iy, (int) currentPathIterator.iz);

					if (bi.equals(expectedTo)) {
						break;
					}

					iterateBpt(true);
				}
			}

			if (currentBuilder != null) {
				currentBuilder.loadBuildStateToNBT(
						initNBT.getCompoundTag("builderState"), this);
			}

			initNBT = null;
		}

		box.kind = Kind.STRIPES;

		for (int x = xCoord - 1; x <= xCoord + 1; ++x) {
			for (int y = yCoord - 1; y <= yCoord + 1; ++y) {
				for (int z = zCoord - 1; z <= zCoord + 1; ++z) {
					TileEntity tile = worldObj.getTileEntity(x, y, z);

					if (tile instanceof IPathProvider) {
						path = ((IPathProvider) tile).getPath();



						if (tile instanceof TilePathMarker) {
							for (BlockIndex b : path) {
								BuildCraftCore.pathMarkerBlock.dropBlockAsItem(
										worldObj, b.x, b.y, b.z,
										0, 0);

								worldObj.setBlockToAir(b.x, b.y, b.z);
							}
						}

						break;
					}
				}
			}
		}

		if (path != null && pathLasers.size() == 0) {
			createLasersForPath();

			sendNetworkUpdate();
		}

		iterateBpt(false);
	}

	public void createLasersForPath() {
		pathLasers = new LinkedList<LaserData>();
		BlockIndex previous = null;

		for (BlockIndex b : path) {
			if (previous != null) {
				LaserData laser = new LaserData(new Position(previous.x + 0.5,
						previous.y + 0.5, previous.z + 0.5), new Position(
						b.x + 0.5, b.y + 0.5, b.z + 0.5));

				pathLasers.add(laser);
			}

			previous = b;
		}
	}

	public BlueprintBase instanciateBlueprint() {
		BlueprintBase bpt;

		try {
			bpt = ItemBlueprint.loadBlueprint(getStackInSlot(0));
		} catch (Throwable t) {
			t.printStackTrace();
			return null;
		}

		return bpt;
	}

	@Deprecated
	public BptBuilderBase instanciateBluePrintBuilder(int x, int y, int z, ForgeDirection o) {
		BlueprintBase bpt = instanciateBlueprint();
        if (bpt == null) {
            return null;
        }

		bpt = bpt.adjustToWorld(worldObj, x, y, z, o);

		if (bpt != null) {
			if (getStackInSlot(0).getItem() instanceof ItemBlueprintStandard) {
				return new BptBuilderBlueprint((Blueprint) bpt, worldObj, x, y, z);
			} else if (getStackInSlot(0).getItem() instanceof ItemBlueprintTemplate) {
				return new BptBuilderTemplate(bpt, worldObj, x, y, z);
			}
		}
		return null;
	}

	public void iterateBpt(boolean forceIterate) {
		if (getStackInSlot(0) == null || !(getStackInSlot(0).getItem() instanceof ItemBlueprint)) {
			if (box.isInitialized()) {
				if (currentBuilder != null) {
					currentBuilder = null;
				}

				if (box.isInitialized()) {
					box.reset();
				}

				if (currentPathIterator != null) {
					currentPathIterator = null;
				}

				updateRequirements();

				sendNetworkUpdate();

				return;
			}
		}

		if (currentBuilder == null || (currentBuilder.isDone(this) || forceIterate)) {
			if (path != null && path.size() > 1) {
				if (currentPathIterator == null) {
					Iterator<BlockIndex> it = path.iterator();
					BlockIndex start = it.next();
					currentPathIterator = new PathIterator(start, it,
							ForgeDirection.values()[worldObj.getBlockMetadata(
									xCoord, yCoord, zCoord)].getOpposite());
				}

				if (currentBuilder != null && currentBuilder.isDone(this)) {
					currentBuilder.postProcessing(worldObj);
				}

				currentBuilder = currentPathIterator.next();

				if (currentBuilder != null) {
					box.reset();
					box.initialize(currentBuilder);
					sendNetworkUpdate();
				}

				if (currentBuilder == null) {
					currentPathIterator = currentPathIterator.iterate();
				}

				if (currentPathIterator == null) {
					done = true;
				} else {
					done = false;
				}

				updateRequirements();
			} else {
				if (currentBuilder != null && currentBuilder.isDone(this)) {
					currentBuilder.postProcessing(worldObj);
					currentBuilder = recursiveBuilder.nextBuilder();

					updateRequirements();
				} else {
					BlueprintBase bpt = instanciateBlueprint();

					if (bpt != null) {
						recursiveBuilder = new RecursiveBlueprintBuilder(bpt, worldObj, xCoord, yCoord, zCoord,
								ForgeDirection.values()[worldObj.getBlockMetadata(xCoord, yCoord, zCoord)].getOpposite());

						currentBuilder = recursiveBuilder.nextBuilder();

						updateRequirements();
					}
				}

				if (currentBuilder == null) {
					done = true;
				} else {
					box.initialize(currentBuilder);
					sendNetworkUpdate();
					done = false;
				}
			}
		}

		if (done && getStackInSlot(0) != null) {
			boolean dropBlueprint = true;
			for (int i = 1; i < getSizeInventory(); ++i) {
				if (getStackInSlot(i) == null) {
					setInventorySlotContents(i, getStackInSlot(0));
					dropBlueprint = false;
					break;
				}
			}
			if (dropBlueprint) {
				InvUtils.dropItems(getWorldObj(), getStackInSlot(0), xCoord, yCoord, zCoord);
			}

			setInventorySlotContents(0, null);
			box.reset();
		}
	}

	@Override
	public int getSizeInventory() {
		return inv.getSizeInventory();
	}

	@Override
	public ItemStack getStackInSlot(int i) {
		return inv.getStackInSlot(i);
	}

	@Override
	public ItemStack decrStackSize(int i, int j) {
		ItemStack result = inv.decrStackSize(i, j);

		if (!worldObj.isRemote) {
			if (i == 0) {
				BuildCraftCore.instance.sendToWorld(new PacketCommand(this, "clearItemRequirements", null), worldObj);
				iterateBpt(false);
			}
		}

		return result;
	}

	@Override
	public void setInventorySlotContents(int i, ItemStack itemstack) {
		inv.setInventorySlotContents(i, itemstack);

		if (!worldObj.isRemote) {
			if (i == 0) {
				iterateBpt(false);
				done = false;
			}
		}
	}

	@Override
	public ItemStack getStackInSlotOnClosing(int slot) {
		return inv.getStackInSlotOnClosing(slot);
	}

	@Override
	public String getInventoryName() {
		return "Builder";
	}

	@Override
	public int getInventoryStackLimit() {
		return 64;
	}

	@Override
	public boolean isUseableByPlayer(EntityPlayer entityplayer) {
		return worldObj.getTileEntity(xCoord, yCoord, zCoord) == this;
	}

	@Override
	public void readFromNBT(NBTTagCompound nbttagcompound) {
		super.readFromNBT(nbttagcompound);

		inv.readFromNBT(nbttagcompound);

		if (nbttagcompound.hasKey("box")) {
			box.initialize(nbttagcompound.getCompoundTag("box"));
		}

		if (nbttagcompound.hasKey("path")) {
			path = new LinkedList<BlockIndex>();
			NBTTagList list = nbttagcompound.getTagList("path",
					Constants.NBT.TAG_COMPOUND);

			for (int i = 0; i < list.tagCount(); ++i) {
				path.add(new BlockIndex(list.getCompoundTagAt(i)));
			}
		}

		done = nbttagcompound.getBoolean("done");
		fluidTank.readFromNBT(nbttagcompound);


		initNBT = (NBTTagCompound) nbttagcompound.getCompoundTag("bptBuilder").copy();
	}

	@Override
	public void writeToNBT(NBTTagCompound nbttagcompound) {
		super.writeToNBT(nbttagcompound);

		inv.writeToNBT(nbttagcompound);

		if (box.isInitialized()) {
			NBTTagCompound boxStore = new NBTTagCompound();
			box.writeToNBT(boxStore);
			nbttagcompound.setTag("box", boxStore);
		}

		if (path != null) {
			NBTTagList list = new NBTTagList();

			for (BlockIndex i : path) {
				NBTTagCompound c = new NBTTagCompound();
				i.writeTo(c);
				list.appendTag(c);
			}

			nbttagcompound.setTag("path", list);
		}

		nbttagcompound.setBoolean("done", done);
		fluidTank.writeToNBT(nbttagcompound);

		NBTTagCompound bptNBT = new NBTTagCompound();

		if (currentBuilder != null) {
			NBTTagCompound builderCpt = new NBTTagCompound();
			currentBuilder.saveBuildStateToNBT(builderCpt, this);
			bptNBT.setTag("builderState", builderCpt);
		}

		if (currentPathIterator != null) {
			NBTTagCompound iteratorNBT = new NBTTagCompound();
			new BlockIndex((int) currentPathIterator.ix,
					(int) currentPathIterator.iy, (int) currentPathIterator.iz)
					.writeTo(iteratorNBT);
			bptNBT.setTag ("iterator", iteratorNBT);
		}

		nbttagcompound.setTag("bptBuilder", bptNBT);
	}

	@Override
	public void invalidate() {
		super.invalidate();
		destroy();
	}

	@Override
	public void openInventory() {
	}

	@Override
	public void closeInventory() {
	}

	@Override
	public void updateEntity() {
		super.updateEntity();

		if (worldObj.isRemote) {
			return;
		}

		if ((currentBuilder == null || currentBuilder.isDone(this))
				&& box.isInitialized()) {
			box.reset();

			sendNetworkUpdate();

			return;
		}

		iterateBpt(false);

		if (mode != Mode.Off) {
			if (getWorldObj().getWorldInfo().getGameType() == GameType.CREATIVE) {
				build();
			} else if (getBattery().getEnergyStored() > POWER_ACTIVATION) {
				build();
			}
		}

		if (!isBuilding && this.isBuildingBlueprint()) {
			updateRequirements();
		}
		isBuilding = this.isBuildingBlueprint();

		if (done) {
			return;
		} else if (getBattery().getEnergyStored() < 25) {
			return;
		}
	}

	@Override
	public boolean hasWork() {
		return !done;
	}

	public boolean isBuildingBlueprint() {
		return getStackInSlot(0) != null && getStackInSlot(0).getItem() instanceof ItemBlueprint;
	}

	public List<RequirementItemStack> getNeededItems() {
		return requiredToBuild;
	}

	@Override
	public void receiveCommand(String command, Side side, Object sender, ByteBuf stream) {
		super.receiveCommand(command, side, sender, stream);
		if (side.isClient()) {
			if ("clearItemRequirements".equals(command)) {
				requiredToBuild = null;
			} else if ("setItemRequirements".equals(command)) {
				int size = stream.readUnsignedMedium();
				requiredToBuild = new ArrayList<RequirementItemStack>();
				for (int i = 0; i < size; i++) {
					int itemId = stream.readUnsignedShort();
					int itemDamage = stream.readShort();
					int stackSize = stream.readUnsignedMedium();
					boolean hasCompound = stackSize >= 0x800000;

					ItemStack stack = new ItemStack(Item.getItemById(itemId), 1, itemDamage);
					if (hasCompound) {
						stack.setTagCompound(NetworkUtils.readNBT(stream));
					}

					if (stack.getItem() != null) {
						requiredToBuild.add(new RequirementItemStack(stack, stackSize & 0x7FFFFF));
					} else {
						BCLog.logger.error("Corrupt ItemStack in TileBuilder.receiveCommand! This should not happen! (ID " + itemId + ", damage " + itemDamage + ")");
					}
				}
			}
		} else if (side.isServer()) {
			EntityPlayer player = (EntityPlayer) sender;
			if ("eraseFluidTank".equals(command)) {
				int id = stream.readInt();
				if (id < 0 || id >= fluidTanks.length) {
					return;
				}
				if (isUseableByPlayer(player) && player.getDistanceSq(xCoord, yCoord, zCoord) <= 64) {
					fluidTanks[id].setFluid(null);
					sendNetworkUpdate();
				}
			}
		}
	}

	private Packet getItemRequirementsPacket(final List<RequirementItemStack> items) {
		if (items != null) {
			return new PacketCommand(this, "setItemRequirements", new CommandWriter() {
				public void write(ByteBuf data) {
					data.writeMedium(items.size());
					for (RequirementItemStack rb : items) {
						data.writeShort(Item.getIdFromItem(rb.stack.getItem()));
						data.writeShort(rb.stack.getItemDamage());
						data.writeMedium((rb.stack.hasTagCompound() ? 0x800000 : 0x000000) | Math.min(0x7FFFFF, rb.size));
						if (rb.stack.hasTagCompound()) {
							NetworkUtils.writeNBT(data, rb.stack.getTagCompound());
						}
					}
				}
			});
		} else {
			return new PacketCommand(this, "clearItemRequirements", null);
		}
	}

	@Override
	public boolean isBuildingMaterialSlot(int i) {
		return i != 0;
	}

	@Override
	public boolean hasCustomInventoryName() {
		return false;
	}

	@Override
	public boolean isItemValidForSlot(int slot, ItemStack stack) {
		if (slot == 0) {
			return stack.getItem() instanceof ItemBlueprint;
		} else {
			return true;
		}
	}

	@Override
	public Box getBox() {
		return box;
	}

	@Override
	public AxisAlignedBB getRenderBoundingBox() {
		Box renderBox = new Box (this).extendToEncompass(box);

		for (LaserData l : pathLasers) {
			renderBox = renderBox.extendToEncompass(l.head);
			renderBox = renderBox.extendToEncompass(l.tail);
		}

		return renderBox.expand(50).getBoundingBox();
	}

	public void build () {
		if (currentBuilder != null) {
			if (currentBuilder.buildNextSlot(worldObj, this, xCoord, yCoord, zCoord)) {
				updateRequirements();
			}
		}
	}

	public void updateRequirements() {
		List<RequirementItemStack> reqCopy = null;
		if (currentBuilder instanceof BptBuilderBlueprint) {
			currentBuilder.initialize();
			reqCopy = ((BptBuilderBlueprint) currentBuilder).neededItems;
		}

		for (EntityPlayer p : guiWatchers) {
			BuildCraftCore.instance.sendToPlayer(p, getItemRequirementsPacket(reqCopy));
		}
	}
	
	public void updateRequirements(EntityPlayer caller) {
		List<RequirementItemStack> reqCopy = null;
		if (currentBuilder instanceof BptBuilderBlueprint) {
			currentBuilder.initialize();
			reqCopy = ((BptBuilderBlueprint) currentBuilder).neededItems;
		}

		BuildCraftCore.instance.sendToPlayer(caller, getItemRequirementsPacket(reqCopy));
	}

	public BptBuilderBase getBlueprint () {
		if (currentBuilder != null) {
			return currentBuilder;
		} else {
			return null;
		}
	}

	@Override
	public boolean canDrain(ForgeDirection from, Fluid fluid) {
		return false;
	}

	@Override
	public FluidStack drain(ForgeDirection from, FluidStack resource, boolean doDrain) {
		return null;
	}

	@Override
	public FluidStack drain(ForgeDirection from, int maxDrain, boolean doDrain) {
		return null;
	}

	@Override
	public boolean drainBuild(FluidStack fluidStack, boolean realDrain) {
		for (Tank tank : fluidTanks) {
			if (tank.getFluidType() == fluidStack.getFluid()) {
				return tank.getFluidAmount() >= fluidStack.amount && tank.drain(fluidStack.amount, realDrain).amount > 0;
			}
		}
		return false;
	}

	@Override
	public int fill(ForgeDirection from, FluidStack resource, boolean doFill) {
		Fluid fluid = resource.getFluid();
		Tank emptyTank = null;
		for (Tank tank : fluidTanks) {
			Fluid type = tank.getFluidType();
			if (type == fluid) {
				int used = tank.fill(resource, doFill);
				if (used > 0 && doFill) {
					sendNetworkUpdate();
				}
				return used;
			} else if (emptyTank == null && tank.isEmpty()) {
				emptyTank = tank;
			}
		}
		if (emptyTank != null) {
			int used = emptyTank.fill(resource, doFill);
			if (used > 0 && doFill) {
				sendNetworkUpdate();
			}
			return used;
		}
		return 0;
	}

	@Override
	public boolean canFill(ForgeDirection from, Fluid fluid) {
		boolean emptyAvailable = false;
		for (Tank tank : fluidTanks) {
			Fluid type = tank.getFluidType();
			if (type == fluid) {
				return !tank.isFull();
			} else if (!emptyAvailable) {
				emptyAvailable = tank.isEmpty();
			}
		}
		return emptyAvailable;
	}

	@Override
	public FluidTankInfo[] getTankInfo(ForgeDirection from) {
		return fluidTank.getTankInfo(from);
	}

	@Override
	public int getNumberOfRequests() {
		if (currentBuilder == null) {
			return 0;
		} else if (!(currentBuilder instanceof BptBuilderBlueprint)) {
			return 0;
		} else {
			BptBuilderBlueprint bpt = (BptBuilderBlueprint) currentBuilder;

			return bpt.neededItems.size();
		}
	}

	@Override
	public StackRequest getAvailableRequest(int i) {
		if (currentBuilder == null) {
			return null;
		} else if (!(currentBuilder instanceof BptBuilderBlueprint)) {
			return null;
		} else {
			BptBuilderBlueprint bpt = (BptBuilderBlueprint) currentBuilder;

			if (bpt.neededItems.size() <= i) {
				return null;
			}

			RequirementItemStack requirement = bpt.neededItems.get(i);

			int qty = quantityMissing(requirement.stack, requirement.size);

			if (qty <= 0) {
				return null;
			}

			StackRequest request = new StackRequest();

			request.index = i;
			request.requester = this;
			request.stack = requirement.stack;

			return request;
		}
	}

	@Override
	public boolean takeRequest(int i, EntityRobotBase robot) {
		if (currentBuilder == null) {
			return false;
		} else if (!(currentBuilder instanceof BptBuilderBlueprint)) {
			return false;
		} else {
			return RobotManager.registryProvider.getRegistry(worldObj).take(new ResourceIdRequest(this, i), robot);
		}
	}

	@Override
	public ItemStack provideItemsForRequest(int i, ItemStack stack) {
		if (currentBuilder == null) {
			return stack;
		} else if (!(currentBuilder instanceof BptBuilderBlueprint)) {
			return stack;
		} else {
			BptBuilderBlueprint bpt = (BptBuilderBlueprint) currentBuilder;

			if (bpt.neededItems.size() <= i) {
				return stack;
			}

			RequirementItemStack requirement = bpt.neededItems.get(i);

			int qty = quantityMissing(requirement.stack, requirement.size);

			if (qty <= 0) {
				return stack;
			}

			ItemStack toAdd = stack.copy();

			if (qty < toAdd.stackSize) {
				toAdd.stackSize = qty;
			}

			ITransactor t = Transactor.getTransactorFor(this);
			ItemStack added = t.add(toAdd, ForgeDirection.UNKNOWN, true);

			if (added.stackSize >= stack.stackSize) {
				return null;
			} else {
				stack.stackSize -= added.stackSize;
				return stack;
			}
		}
	}

	private int quantityMissing(ItemStack requirement, int amount) {
		int left = amount <= 0 ? requirement.stackSize : amount;

		for (IInvSlot slot : InventoryIterator.getIterable(this)) {
			if (slot.getStackInSlot() != null) {
				if (StackHelper.isMatchingItem(requirement, slot.getStackInSlot())) {
					if (slot.getStackInSlot().stackSize >= left) {
						return 0;
					} else {
						left -= slot.getStackInSlot().stackSize;
					}
				}
			}
		}

		return left;
	}

	@Override
	public boolean acceptsControlMode(Mode mode) {
		return mode == Mode.Off || mode == Mode.On;
	}

	@Override
	public void writeData(ByteBuf stream) {
		super.writeData(stream);
		box.writeData(stream);
		fluidTank.writeData(stream);
	}

	@Override
	public void readData(ByteBuf stream) {
		super.readData(stream);
		box.readData(stream);
		fluidTank.readData(stream);
	}
}

<code block>

package buildcraft.api.robots;

import org.apache.commons.lang3.builder.HashCodeBuilder;

import net.minecraft.nbt.NBTTagCompound;

import net.minecraftforge.common.util.ForgeDirection;

import buildcraft.api.core.BlockIndex;

public class ResourceIdRequest extends ResourceId {

	private BlockIndex index;
	private ForgeDirection side;
	private int slot;

	public ResourceIdRequest(DockingStation station, int slot) {
		index = station.index();
		side = station.side();
		this.slot = slot;
	}

	@Override
	public boolean equals(Object obj) {
		if (obj == null || obj.getClass() != getClass()) {
			return false;
		}

		ResourceIdRequest compareId = (ResourceIdRequest) obj;

		return index.equals(compareId.index) && side.equals(compareId.side) && slot == compareId.slot;
	}

	@Override
	public int hashCode() {
		return new HashCodeBuilder().append(index.hashCode()).append(side.hashCode()).append(slot).build();
	}

	@Override
	public void writeToNBT(NBTTagCompound nbt) {
		super.writeToNBT(nbt);
		NBTTagCompound indexNBT = new NBTTagCompound();
		index.writeTo(indexNBT);
		nbt.setTag("index", indexNBT);
		nbt.setByte("side", (byte) side.ordinal());
		nbt.setInteger("localId", slot);
	}

	@Override
	protected void readFromNBT(NBTTagCompound nbt) {
		super.readFromNBT(nbt);
		index = new BlockIndex(nbt.getCompoundTag("index"));
		side = ForgeDirection.getOrientation(nbt.getByte("side"));
		slot = nbt.getInteger("localId");
	}
}

<code block>

package buildcraft.api.robots;

import net.minecraft.item.ItemStack;


public interface IRequestProvider {

	int getRequestsCount();


	ItemStack getRequest(int slot);


	ItemStack offerItem(int slot, ItemStack stack);
}

<code block>

package buildcraft.api.robots;

import net.minecraft.nbt.NBTTagCompound;

public abstract class ResourceId {

	protected ResourceId() {
	}

	public void writeToNBT(NBTTagCompound nbt) {
		nbt.setString("resourceName", RobotManager.getResourceIdName(getClass()));
	}

	protected void readFromNBT(NBTTagCompound nbt) {
	}

	public static ResourceId load(NBTTagCompound nbt) {
		try {
			Class cls = null;
			if (nbt.hasKey("class")) {

				cls = RobotManager.getResourceIdByLegacyClassName(nbt.getString("class"));
			} else {
				cls = RobotManager.getResourceIdByName(nbt.getString("resourceName"));
			}

			ResourceId id = (ResourceId) cls.newInstance();
			id.readFromNBT(nbt);

			return id;
		} catch (Throwable e) {
			e.printStackTrace();
		}

		return null;
	}
}

<code block>

package buildcraft.api.robots;

import org.apache.commons.lang3.builder.HashCodeBuilder;

import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.tileentity.TileEntity;

import net.minecraftforge.common.util.ForgeDirection;

import buildcraft.api.core.BlockIndex;

public class ResourceIdBlock extends ResourceId {

	public BlockIndex index = new BlockIndex();
	public ForgeDirection side = ForgeDirection.UNKNOWN;

	public ResourceIdBlock() {

	}

	public ResourceIdBlock(int x, int y, int z) {
		index = new BlockIndex(x, y, z);
	}

	public ResourceIdBlock(BlockIndex iIndex) {
		index = iIndex;
	}

	public ResourceIdBlock(TileEntity tile) {
		index = new BlockIndex(tile);
	}

	@Override
	public boolean equals(Object obj) {
		if (obj == null || obj.getClass() != getClass()) {
			return false;
		}

		ResourceIdBlock compareId = (ResourceIdBlock) obj;

		return index.equals(compareId.index) && side == compareId.side;
	}

	@Override
	public int hashCode() {
		return new HashCodeBuilder().append(index.hashCode()).append(side != null ? side.ordinal() : 0).build();
	}

	@Override
	public void writeToNBT(NBTTagCompound nbt) {
		super.writeToNBT(nbt);
		NBTTagCompound indexNBT = new NBTTagCompound();
		index.writeTo(indexNBT);
		nbt.setTag("index", indexNBT);
		nbt.setByte("side", (byte) side.ordinal());
	}

	@Override
	protected void readFromNBT(NBTTagCompound nbt) {
		super.readFromNBT(nbt);
		index = new BlockIndex(nbt.getCompoundTag("index"));
		side = ForgeDirection.values()[nbt.getByte("side")];
	}
}

<code block>

package buildcraft.robotics;

import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.world.World;

import net.minecraftforge.common.util.ForgeDirection;

import buildcraft.api.core.BlockIndex;
import buildcraft.api.robots.DockingStation;
import buildcraft.api.robots.IRequestProvider;
import buildcraft.api.robots.IRobotRegistry;
import buildcraft.api.robots.ResourceId;
import buildcraft.api.robots.ResourceIdRequest;
import buildcraft.api.robots.RobotManager;

public class StackRequest {
	private IRequestProvider requester;

	private int slot;

	private ItemStack stack;

	private DockingStation station;
	private BlockIndex stationIndex;
	private ForgeDirection stationSide;

	public StackRequest(IRequestProvider requester, int slot, ItemStack stack) {
		this.requester = requester;
		this.slot = slot;
		this.stack = stack;
		this.station = null;
	}

	private StackRequest(int slot, ItemStack stack, BlockIndex stationIndex, ForgeDirection stationSide) {
		requester = null;
		this.slot = slot;
		this.stack = stack;
		station = null;
		this.stationIndex = stationIndex;
		this.stationSide = stationSide;
	}

	public IRequestProvider getRequester(World world) {
		if (requester == null) {
			requester = getStation(world).getRequestProvider();
		}
		return requester;
	}

	public int getSlot() {
		return slot;
	}

	public ItemStack getStack() {
		return stack;
	}

	public DockingStation getStation(World world) {
		if (station == null) {
			IRobotRegistry robotRegistry = RobotManager.registryProvider.getRegistry(world);
			station = robotRegistry.getStation(stationIndex.x, stationIndex.y, stationIndex.z, stationSide);
		}
		return station;
	}

	public void setStation(DockingStation station) {
		this.station = station;
		this.stationIndex = station.index();
		this.stationSide = station.side();
	}

	public void writeToNBT(NBTTagCompound nbt) {
		nbt.setInteger("slot", slot);

		NBTTagCompound stackNBT = new NBTTagCompound();
		stack.writeToNBT(stackNBT);
		nbt.setTag("stack", stackNBT);

		NBTTagCompound stationIndexNBT = new NBTTagCompound();
		station.index().writeTo(stationIndexNBT);
		nbt.setTag("stationIndex", stationIndexNBT);
		nbt.setByte("stationSide", (byte) station.side().ordinal());
	}

	public static StackRequest loadFromNBT(NBTTagCompound nbt) {
		int slot = nbt.getInteger("slot");

		ItemStack stack = ItemStack.loadItemStackFromNBT(nbt.getCompoundTag("stack"));

		BlockIndex stationIndex = new BlockIndex(nbt.getCompoundTag("stationIndex"));
		ForgeDirection stationSide = ForgeDirection.values()[nbt.getByte("stationSide")];

		return new StackRequest(slot, stack, stationIndex, stationSide);
	}

	public ResourceId getResourceId(World world) {
		return new ResourceIdRequest(getStation(world), slot);
	}
}

<code block>
package buildcraft.robotics;

import java.util.List;

import net.minecraft.inventory.IInventory;
import net.minecraft.item.ItemStack;
import net.minecraft.tileentity.TileEntity;

import net.minecraftforge.common.util.ForgeDirection;
import net.minecraftforge.fluids.IFluidHandler;

import buildcraft.BuildCraftRobotics;
import buildcraft.api.core.BlockIndex;
import buildcraft.api.core.EnumColor;
import buildcraft.api.gates.IGate;
import buildcraft.api.robots.DockingStation;
import buildcraft.api.robots.EntityRobotBase;
import buildcraft.api.robots.IRequestProvider;
import buildcraft.api.robots.RobotManager;
import buildcraft.api.statements.IStatement;
import buildcraft.api.statements.StatementSlot;
import buildcraft.api.transport.IInjectable;
import buildcraft.api.transport.IPipeTile;
import buildcraft.transport.Pipe;
import buildcraft.transport.PipeTransportItems;
import buildcraft.transport.TravelingItem;
import buildcraft.transport.gates.ActionIterator;
import buildcraft.transport.pipes.PipeFluidsWood;
import buildcraft.transport.pipes.PipeItemsWood;

public class DockingStationPipe extends DockingStation implements IRequestProvider {

	private IInjectable injectablePipe = new IInjectable() {
		@Override
		public boolean canInjectItems(ForgeDirection from) {
			return true;
		}

		@Override
		public int injectItem(ItemStack stack, boolean doAdd, ForgeDirection from, EnumColor color) {
			if (doAdd) {
				float cx = x() + 0.5F + 0.2F * side().offsetX;
				float cy = y() + 0.5F + 0.2F * side().offsetY;
				float cz = z() + 0.5F + 0.2F * side().offsetZ;
				TravelingItem item = TravelingItem.make(cx, cy, cz, stack);
				if (item.isCorrupted()) {
					return 0;
				}

				((PipeTransportItems) ((Pipe) getPipe().getPipe()).transport)
						.injectItem(item, from);
			}
			return stack.stackSize;
		}
	};

	private IPipeTile pipe;

	public DockingStationPipe() {

	}

	public DockingStationPipe(IPipeTile iPipe, ForgeDirection side) {
		super(new BlockIndex(iPipe.x(), iPipe.y(), iPipe.z()), side);
		pipe = iPipe;
		world = iPipe.getWorld();
	}

	public IPipeTile getPipe() {
		if (pipe == null) {
			TileEntity tile = world.getTileEntity(x(), y(), z());
			if (tile instanceof IPipeTile) {
				pipe = (IPipeTile) tile;
			}
		}

		if (pipe == null || ((TileEntity) pipe).isInvalid()) {

			RobotManager.registryProvider.getRegistry(world).removeStation(this);
			pipe = null;
		}

		return pipe;
	}

	@Override
	public Iterable<StatementSlot> getActiveActions() {
		return new ActionIterator(getPipe().getPipe());
	}

	@Override
	public IInjectable getItemOutput() {
		if (getPipe().getPipeType() != IPipeTile.PipeType.ITEM) {
			return null;
		}

		return injectablePipe;
	}

	@Override
	public IInventory getItemInput() {
		if (getPipe().getPipeType() != IPipeTile.PipeType.ITEM) {
			return null;
		}

		if (!(getPipe().getPipe() instanceof PipeItemsWood)) {
			return null;
		}

		int meta = ((TileEntity) getPipe()).getBlockMetadata();
		ForgeDirection dir = ForgeDirection.getOrientation(meta);

		TileEntity connectedTile = getPipe().getWorld().getTileEntity(x() + dir.offsetX,
				y() + dir.offsetY, z() + dir.offsetZ);
		if (connectedTile instanceof IInventory) {
			return (IInventory) connectedTile;
		}

		return null;
	}

	@Override
	public IFluidHandler getFluidInput() {
		if (getPipe().getPipeType() != IPipeTile.PipeType.FLUID) {
			return null;
		}

		if (!(getPipe().getPipe() instanceof PipeFluidsWood)) {
			return null;
		}

		int meta = ((TileEntity) getPipe()).getBlockMetadata();
		ForgeDirection dir = ForgeDirection.getOrientation(meta);

		TileEntity connectedTile = getPipe().getWorld().getTileEntity(x() + dir.offsetX,
				y() + dir.offsetY, z() + dir.offsetZ);
		if (connectedTile instanceof IFluidHandler) {
			return (IFluidHandler) connectedTile;
		}

		return null;
	}

	@Override
	public IFluidHandler getFluidOutput() {
		if (getPipe().getPipeType() != IPipeTile.PipeType.FLUID) {
			return null;
		}

		return (IFluidHandler) ((Pipe) getPipe().getPipe()).transport;
	}

	@Override
	public boolean providesPower() {
		return getPipe().getPipeType() == IPipeTile.PipeType.POWER;
	}

	@Override
	public IRequestProvider getRequestProvider() {
		for (ForgeDirection dir : ForgeDirection.VALID_DIRECTIONS) {
			TileEntity nearbyTile = getPipe().getWorld().getTileEntity(x() + dir.offsetX,
					y() + dir.offsetY, z() + dir.offsetZ);
			if (nearbyTile instanceof IRequestProvider) {
				return (IRequestProvider) nearbyTile;
			}
		}
		return this;
	}

	@Override
	public boolean isInitialized() {
		if (getPipe() == null || getPipe().getPipe() == null) {
			return false;
		}
		return ((Pipe) getPipe().getPipe()).isInitialized();
	}

	@Override
	public boolean take(EntityRobotBase robot) {
		boolean result = super.take(robot);
		if (result) {
			getPipe().scheduleRenderUpdate();
		}
		return result;
	}

	@Override
	public boolean takeAsMain(EntityRobotBase robot) {
		boolean result = super.takeAsMain(robot);
		if (result) {
			getPipe().scheduleRenderUpdate();
		}
		return result;
	}

	@Override
	public void unsafeRelease(EntityRobotBase robot) {
		super.unsafeRelease(robot);
		if (robotTaking() == null) {
			getPipe().scheduleRenderUpdate();
		}
	}

	@Override
	public void onChunkUnload() {
		pipe = null;
	}

	@Override
	public int getRequestsCount() {
		return 127;
	}

	@Override
	public ItemStack getRequest(int slot) {
		ForgeDirection side = ForgeDirection.getOrientation((slot & 0x70) >> 4);
		int action = (slot & 0xc) >> 2;
		int param = slot & 0x3;
		IGate gate = getPipe().getPipe().getGate(side);
		if (gate == null) {
			return null;
		}

		List<IStatement> actions = gate.getActions();
		if (actions.size() <= action) {
			return null;
		}

		if (actions.get(action) != BuildCraftRobotics.actionStationRequestItems) {
			return null;
		}

		List<StatementSlot> activeActions = gate.getActiveActions();

		StatementSlot slotStmt = null;
		for (StatementSlot stmt : activeActions) {
			if (stmt.statement == actions.get(action)) {
				slotStmt = stmt;
				break;
			}
		}
		if (slotStmt == null) {
			return null;
		}
		if (slotStmt.parameters.length <= param) {
			return null;
		}

		if (slotStmt.parameters[param] == null) {
			return null;
		}

		return slotStmt.parameters[param].getItemStack();
	}

	@Override
	public ItemStack offerItem(int slot, ItemStack stack) {
		int consumed = injectablePipe.injectItem(stack, true, side.getOpposite(), null);
		if (stack.stackSize > consumed) {
			ItemStack newStack = stack.copy();
			newStack.stackSize -= consumed;
			return newStack;
		}
		return null;
	}
}

<code block>

package buildcraft.robotics;

import io.netty.buffer.ByteBuf;

import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.inventory.IInventory;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;

import cpw.mods.fml.relauncher.Side;

import buildcraft.BuildCraftCore;
import buildcraft.api.robots.IRequestProvider;
import buildcraft.core.lib.block.TileBuildCraft;
import buildcraft.core.lib.inventory.SimpleInventory;
import buildcraft.core.lib.inventory.StackHelper;
import buildcraft.core.lib.network.command.CommandWriter;
import buildcraft.core.lib.network.command.ICommandReceiver;
import buildcraft.core.lib.network.command.PacketCommand;
import buildcraft.core.lib.utils.NetworkUtils;

public class TileRequester extends TileBuildCraft implements IInventory, IRequestProvider, ICommandReceiver {
	public static final int NB_ITEMS = 20;

	private SimpleInventory inv = new SimpleInventory(NB_ITEMS, "items", 64);
	private SimpleInventory requests = new SimpleInventory(NB_ITEMS, "requests", 64);

	public TileRequester() {

	}

	public void setRequest(final int index, final ItemStack stack) {
		if (worldObj.isRemote) {
			BuildCraftCore.instance.sendToServer(new PacketCommand(this, "setRequest", new CommandWriter() {
				public void write(ByteBuf data) {
					data.writeByte(index);
					NetworkUtils.writeStack(data, stack);
				}
			}));
		} else {
			requests.setInventorySlotContents(index, stack);
		}
	}

	@Override
	public void receiveCommand(String command, Side side, Object sender, ByteBuf stream) {
		if (side.isServer() && "setRequest".equals(command)) {
			setRequest(stream.readUnsignedByte(), NetworkUtils.readStack(stream));
		}
	}

	public ItemStack getRequestTemplate(int index) {
		return requests.getStackInSlot(index);
	}

	@Override
	public int getSizeInventory() {
		return inv.getSizeInventory();
	}

	@Override
	public ItemStack getStackInSlot(int slotId) {
		return inv.getStackInSlot(slotId);
	}

	@Override
	public ItemStack decrStackSize(int slotId, int count) {
		return inv.decrStackSize(slotId, count);
	}

	@Override
	public ItemStack getStackInSlotOnClosing(int slotId) {
		return inv.getStackInSlotOnClosing(slotId);
	}

	@Override
	public void setInventorySlotContents(int slotId, ItemStack itemStack) {
		inv.setInventorySlotContents(slotId, itemStack);
	}

	@Override
	public String getInventoryName() {
		return inv.getInventoryName();
	}

	@Override
	public boolean hasCustomInventoryName() {
		return inv.hasCustomInventoryName();
	}

	@Override
	public int getInventoryStackLimit() {
		return inv.getInventoryStackLimit();
	}

	@Override
	public boolean isUseableByPlayer(EntityPlayer entityPlayer) {
		return inv.isUseableByPlayer(entityPlayer);
	}

	@Override
	public void openInventory() {
		inv.openInventory();
	}

	@Override
	public void closeInventory() {
		inv.closeInventory();
	}

	@Override
	public boolean isItemValidForSlot(int i, ItemStack itemStack) {
		if (requests.getStackInSlot(i) == null) {
			return false;
		} else if (!StackHelper.isMatchingItemOrList(requests.getStackInSlot(i), itemStack)) {
			return false;
		} else {
			return inv.isItemValidForSlot(i, itemStack);
		}
	}

	@Override
	public void writeToNBT(NBTTagCompound nbt) {
		super.writeToNBT(nbt);

		NBTTagCompound invNBT = new NBTTagCompound();
		inv.writeToNBT(invNBT);
		nbt.setTag("inv", invNBT);

		NBTTagCompound reqNBT = new NBTTagCompound();
		requests.writeToNBT(reqNBT);
		nbt.setTag("req", reqNBT);
	}

	@Override
	public void readFromNBT(NBTTagCompound nbt) {
		super.readFromNBT(nbt);

		inv.readFromNBT(nbt.getCompoundTag("inv"));
		requests.readFromNBT(nbt.getCompoundTag("req"));
	}

	public boolean isFulfilled(int i) {
		if (requests.getStackInSlot(i) == null) {
			return true;
		} else if (inv.getStackInSlot(i) == null) {
			return false;
		} else {
			return StackHelper.isMatchingItemOrList(requests.getStackInSlot(i), inv.getStackInSlot(i))
					&& inv.getStackInSlot(i).stackSize >= requests.getStackInSlot(i).stackSize;
		}
	}

	@Override
	public int getRequestsCount() {
		return NB_ITEMS;
	}

	@Override
	public ItemStack getRequest(int i) {
		if (requests.getStackInSlot(i) == null) {
			return null;
		} else if (isFulfilled(i)) {
			return null;
		} else {
			ItemStack request = requests.getStackInSlot(i).copy();

			ItemStack existingStack = inv.getStackInSlot(i);
			if (existingStack == null) {
				return request;
			}

			if (!StackHelper.isMatchingItemOrList(request, existingStack)) {
				return null;
			}

			request.stackSize -= existingStack.stackSize;
			if (request.stackSize <= 0) {
				return null;
			}

			return request;
		}
	}

	@Override
	public ItemStack offerItem(int i, ItemStack stack) {
		ItemStack existingStack = inv.getStackInSlot(i);

		if (requests.getStackInSlot(i) == null) {
			return stack;
		} else if (existingStack == null) {
			if (!StackHelper.isMatchingItemOrList(stack, requests.getStackInSlot(i))) {
				return stack;
			}

			int maxQty = requests.getStackInSlot(i).stackSize;

			if (stack.stackSize <= maxQty) {
				inv.setInventorySlotContents(i, stack);

				return null;
			} else {
				ItemStack newStack = stack.copy();
				newStack.stackSize = maxQty;
				stack.stackSize -= maxQty;

				inv.setInventorySlotContents(i, newStack);

				return stack;
			}
		} else if (!StackHelper.isMatchingItemOrList(stack, existingStack)) {
			return stack;
		} else if (StackHelper.isMatchingItemOrList(stack, requests.getStackInSlot(i))) {
			int maxQty = requests.getStackInSlot(i).stackSize;

			if (existingStack.stackSize + stack.stackSize <= maxQty) {
				existingStack.stackSize += stack.stackSize;
				return null;
			} else {
				stack.stackSize -= maxQty - existingStack.stackSize;
				existingStack.stackSize = maxQty;
				return stack;
			}
		} else {
			return stack;
		}
	}
}

<code block>

package buildcraft.robotics;

import java.security.InvalidParameterException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;

import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagList;
import net.minecraft.util.LongHashMap;
import net.minecraft.world.World;
import net.minecraft.world.WorldSavedData;

import cpw.mods.fml.common.eventhandler.SubscribeEvent;

import net.minecraftforge.common.util.Constants;
import net.minecraftforge.common.util.ForgeDirection;
import net.minecraftforge.event.world.ChunkEvent;

import buildcraft.api.core.BCLog;
import buildcraft.api.robots.DockingStation;
import buildcraft.api.robots.EntityRobotBase;
import buildcraft.api.robots.IRobotRegistry;
import buildcraft.api.robots.ResourceId;
import buildcraft.api.robots.RobotManager;

public class RobotRegistry extends WorldSavedData implements IRobotRegistry {

	protected World world;
	protected final HashMap<StationIndex, DockingStation> stations = new HashMap<StationIndex, DockingStation>();

	private long nextRobotID = Long.MIN_VALUE;

	private final LongHashMap robotsLoaded = new LongHashMap();
	private final HashSet<EntityRobot> robotsLoadedSet = new HashSet<EntityRobot>();
	private final HashMap<ResourceId, Long> resourcesTaken = new HashMap<ResourceId, Long>();
	private final LongHashMap resourcesTakenByRobot = new LongHashMap();
	private final LongHashMap stationsTakenByRobot = new LongHashMap();

	public RobotRegistry(String id) {
		super(id);
	}

	@Override
	public long getNextRobotId() {
		long result = nextRobotID;

		nextRobotID = nextRobotID + 1;

		return result;
	}

	@Override
	public void registerRobot(EntityRobotBase robot) {
		markDirty();

		if (robot.getRobotId() == EntityRobotBase.NULL_ROBOT_ID) {
			((EntityRobot) robot).setUniqueRobotId(getNextRobotId());
		}
		if (robotsLoaded.containsItem(robot.getRobotId())) {
			BCLog.logger.warn("Robot with id %d was not unregistered properly", robot.getRobotId());
		}

		addRobotLoaded((EntityRobot) robot);
	}

	private HashSet<ResourceId> getResourcesTakenByRobot(long robotId) {
		return (HashSet<ResourceId>) resourcesTakenByRobot.getValueByKey(robotId);
	}

	private HashSet<StationIndex> getStationsTakenByRobot(long robotId) {
		return (HashSet<StationIndex>) stationsTakenByRobot.getValueByKey(robotId);
	}


	private void addRobotLoaded(EntityRobot robot) {
		robotsLoaded.add(robot.getRobotId(), robot);
		robotsLoadedSet.add(robot);
	}

	private void removeRobotLoaded(EntityRobot robot) {
		robotsLoaded.remove(robot.getRobotId());
		robotsLoadedSet.remove(robot);
	}

	@Override
	public void killRobot(EntityRobotBase robot) {
		markDirty();

		releaseResources(robot, true);
		removeRobotLoaded((EntityRobot) robot);
	}

	@Override
	public void unloadRobot(EntityRobotBase robot) {
		markDirty();

		releaseResources(robot, false, true);
		removeRobotLoaded((EntityRobot) robot);
	}

	@Override
	public EntityRobot getLoadedRobot(long id) {
		if (robotsLoaded.containsItem(id)) {
			return (EntityRobot) robotsLoaded.getValueByKey(id);
		} else {
			return null;
		}
	}

	@Override
	public synchronized boolean isTaken(ResourceId resourceId) {
		return robotIdTaking(resourceId) != EntityRobotBase.NULL_ROBOT_ID;
	}

	@Override
	public synchronized long robotIdTaking(ResourceId resourceId) {
		if (!resourcesTaken.containsKey(resourceId)) {
			return EntityRobotBase.NULL_ROBOT_ID;
		}

		long robotId = resourcesTaken.get(resourceId);

		if (robotsLoaded.containsItem(robotId) && !((EntityRobot) robotsLoaded.getValueByKey(robotId)).isDead) {
			return robotId;
		} else {


			release(resourceId);
			return EntityRobotBase.NULL_ROBOT_ID;
		}
	}

	@Override
	public synchronized EntityRobot robotTaking(ResourceId resourceId) {
		long robotId = robotIdTaking(resourceId);

		if (robotId == EntityRobotBase.NULL_ROBOT_ID || !robotsLoaded.containsItem(robotId)) {
			return null;
		} else {
			return (EntityRobot) robotsLoaded.getValueByKey(robotId);
		}
	}

	@Override
	public synchronized boolean take(ResourceId resourceId, EntityRobotBase robot) {
		markDirty();

		return take(resourceId, robot.getRobotId());
	}

	@Override
	public synchronized boolean take(ResourceId resourceId, long robotId) {
		if (resourceId == null) {
			return false;
		}

		markDirty();

		if (!resourcesTaken.containsKey(resourceId)) {
			resourcesTaken.put(resourceId, robotId);

			if (!resourcesTakenByRobot.containsItem(robotId)) {
				resourcesTakenByRobot.add(robotId, new HashSet<ResourceId>());
			}

			getResourcesTakenByRobot(robotId).add(resourceId);

			return true;
		} else {
			return false;
		}
	}

	@Override
	public synchronized void release(ResourceId resourceId) {
		if (resourceId == null) {
			return;
		}

		markDirty();

		if (resourcesTaken.containsKey(resourceId)) {
			long robotId = resourcesTaken.get(resourceId);

			getResourcesTakenByRobot(robotId).remove(resourceId);
			resourcesTaken.remove(resourceId);
		}
	}

	@Override
	public synchronized void releaseResources(EntityRobotBase robot) {
		releaseResources(robot, false);
	}

	private synchronized void releaseResources(EntityRobotBase robot, boolean forceAll) {
		releaseResources(robot, forceAll, false);
	}

	private synchronized void releaseResources(EntityRobotBase robot, boolean forceAll, boolean resetEntities) {
		markDirty();

		if (resourcesTakenByRobot.containsItem(robot.getRobotId())) {
			HashSet<ResourceId> resourceSet = (HashSet<ResourceId>) getResourcesTakenByRobot(robot.getRobotId())
					.clone();

			for (ResourceId id : resourceSet) {
				release(id);
			}

			resourcesTakenByRobot.remove(robot.getRobotId());
		}

		if (stationsTakenByRobot.containsItem(robot.getRobotId())) {
			HashSet<StationIndex> stationSet = (HashSet<StationIndex>) getStationsTakenByRobot(robot.getRobotId())
					.clone();

			for (StationIndex s : stationSet) {
				DockingStation d = stations.get(s);

				if (d != null) {
					if (!d.canRelease()) {
						if (forceAll) {
							d.unsafeRelease(robot);
						} else if (resetEntities && d.robotIdTaking() == robot.getRobotId()) {
							d.invalidateRobotTakingEntity();
						}
					} else {
						d.unsafeRelease(robot);
					}
				}
			}

			if (forceAll) {
				stationsTakenByRobot.remove(robot.getRobotId());
			}
		}
	}

	@Override
	public synchronized DockingStation getStation(int x, int y, int z, ForgeDirection side) {
		StationIndex index = new StationIndex(side, x, y, z);

		if (stations.containsKey(index)) {
			return stations.get(index);
		} else {
			return null;
		}
	}

	@Override
	public synchronized Collection<DockingStation> getStations() {
		return stations.values();
	}

	@Override
	public synchronized void registerStation(DockingStation station) {
		markDirty();

		StationIndex index = new StationIndex(station);

		if (stations.containsKey(index)) {
			throw new InvalidParameterException("Station " + index + " already registered");
		} else {
			stations.put(index, station);
		}
	}

	@Override
	public synchronized void removeStation(DockingStation station) {
		markDirty();

		StationIndex index = new StationIndex(station);

		if (stations.containsKey(index)) {
			if (station.robotTaking() != null) {
				if (!station.isMainStation()) {
					station.robotTaking().undock();
				} else {
					station.robotTaking().setMainStation(null);
				}
			} else if (station.robotIdTaking() != EntityRobotBase.NULL_ROBOT_ID) {
				if (stationsTakenByRobot.containsItem(station.robotIdTaking())) {
					getStationsTakenByRobot(station.robotIdTaking()).remove(index);
				}
			}

			stations.remove(index);
		}
	}

	@Override
	public synchronized void take(DockingStation station, long robotId) {
		if (!stationsTakenByRobot.containsItem(robotId)) {
			stationsTakenByRobot.add(robotId, new HashSet<StationIndex>());
		}

		getStationsTakenByRobot(robotId).add(new StationIndex(station));
	}

	@Override
	public synchronized void release(DockingStation station, long robotId) {
		if (stationsTakenByRobot.containsItem(robotId)) {
			getStationsTakenByRobot(robotId).remove(new StationIndex(station));
		}
	}

	@Override
	public synchronized void writeToNBT(NBTTagCompound nbt) {
		nbt.setLong("nextRobotID", nextRobotID);

		NBTTagList resourceList = new NBTTagList();

		for (Map.Entry<ResourceId, Long> e : resourcesTaken.entrySet()) {
			NBTTagCompound cpt = new NBTTagCompound();
			NBTTagCompound resourceId = new NBTTagCompound();
			e.getKey().writeToNBT(resourceId);
			cpt.setTag("resourceId", resourceId);
			cpt.setLong("robotId", e.getValue());

			resourceList.appendTag(cpt);
		}

		nbt.setTag("resourceList", resourceList);

		NBTTagList stationList = new NBTTagList();

		for (Map.Entry<StationIndex, DockingStation> e : stations.entrySet()) {
			NBTTagCompound cpt = new NBTTagCompound();
			e.getValue().writeToNBT(cpt);
			cpt.setString("stationType", RobotManager.getDockingStationName(e.getValue().getClass()));
			stationList.appendTag(cpt);
		}

		nbt.setTag("stationList", stationList);
	}

	@Override
	public synchronized void readFromNBT(NBTTagCompound nbt) {
		nextRobotID = nbt.getLong("nextRobotID");

		NBTTagList resourceList = nbt.getTagList("resourceList", Constants.NBT.TAG_COMPOUND);

		for (int i = 0; i < resourceList.tagCount(); ++i) {
			NBTTagCompound cpt = resourceList.getCompoundTagAt(i);
			ResourceId resourceId = ResourceId.load(cpt.getCompoundTag("resourceId"));
			long robotId = cpt.getLong("robotId");

			take(resourceId, robotId);
		}

		NBTTagList stationList = nbt.getTagList("stationList", Constants.NBT.TAG_COMPOUND);

		for (int i = 0; i < stationList.tagCount(); ++i) {
			NBTTagCompound cpt = stationList.getCompoundTagAt(i);

			Class<? extends DockingStation> cls;

			if (!cpt.hasKey("stationType")) {
				cls = DockingStationPipe.class;
			} else {
				cls = RobotManager.getDockingStationByName(cpt.getString("stationType"));
				if (cls == null) {
					BCLog.logger.error("Could not load docking station of type "
							+ nbt.getString("stationType"));
					continue;
				}
			}

			try {
				DockingStation station = cls.newInstance();
				station.readFromNBT(cpt);

				registerStation(station);

				if (station.linkedId() != EntityRobotBase.NULL_ROBOT_ID) {
					take(station, station.linkedId());
				}
			} catch (Exception e) {
				BCLog.logger.error("Could not load docking station", e);
			}
		}
	}

	@SubscribeEvent
	public void onChunkUnload(ChunkEvent.Unload e) {
		if (e.world == this.world) {
			for (EntityRobot robot : new ArrayList<EntityRobot>(robotsLoadedSet)) {
				if (!e.world.loadedEntityList.contains(robot)) {
					robot.onChunkUnload();
				}
			}
			for (DockingStation station : new ArrayList<DockingStation>(stations.values())) {
				if (!world.blockExists(station.x(), station.y(), station.z())) {
					station.onChunkUnload();
				}
			}
		}
	}


	@Override
	public void registryMarkDirty() {
		markDirty();
	}
}

<code block>

package buildcraft.robotics.boards;

import java.util.ArrayList;

import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;

import buildcraft.api.boards.RedstoneBoardRobot;
import buildcraft.api.boards.RedstoneBoardRobotNBT;
import buildcraft.api.robots.AIRobot;
import buildcraft.api.robots.EntityRobotBase;
import buildcraft.core.lib.inventory.StackHelper;
import buildcraft.core.lib.inventory.filters.IStackFilter;
import buildcraft.robotics.StackRequest;
import buildcraft.robotics.ai.AIRobotDeliverRequested;
import buildcraft.robotics.ai.AIRobotDisposeItems;
import buildcraft.robotics.ai.AIRobotGotoSleep;
import buildcraft.robotics.ai.AIRobotGotoStationAndLoad;
import buildcraft.robotics.ai.AIRobotSearchStackRequest;
import buildcraft.robotics.statements.ActionRobotFilter;

public class BoardRobotDelivery extends RedstoneBoardRobot {

	private ArrayList<ItemStack> deliveryBlacklist = new ArrayList<ItemStack>();

	private StackRequest currentRequest = null;

	public BoardRobotDelivery(EntityRobotBase iRobot) {
		super(iRobot);
	}

	@Override
	public RedstoneBoardRobotNBT getNBTHandler() {
		return BCBoardNBT.REGISTRY.get("delivery");
	}

	@Override
	public void update() {
		if (robot.containsItems()) {
			startDelegateAI(new AIRobotDisposeItems(robot));
			return;
		}

		if (currentRequest == null) {
			startDelegateAI(new AIRobotSearchStackRequest(robot, ActionRobotFilter.getGateFilter(robot
					.getLinkedStation()), deliveryBlacklist));
		} else {
			startDelegateAI(new AIRobotGotoStationAndLoad(robot, new IStackFilter() {
				@Override
				public boolean matches(ItemStack stack) {
					return currentRequest != null && StackHelper.isMatchingItemOrList(stack, currentRequest.getStack());
				}
			}, currentRequest.getStack().stackSize));
		}
	}

	@Override
	public void delegateAIEnded(AIRobot ai) {
		if (ai instanceof AIRobotSearchStackRequest) {
			if (!ai.success()) {
				deliveryBlacklist.clear();
				startDelegateAI(new AIRobotGotoSleep(robot));
			} else {
				currentRequest = ((AIRobotSearchStackRequest) ai).request;

				if (!currentRequest.getStation(robot.worldObj).take(robot)) {
					releaseCurrentRequest();
				}
			}
		} else if (ai instanceof AIRobotGotoStationAndLoad) {
			if (!ai.success()) {
				deliveryBlacklist.add(currentRequest.getStack());
				releaseCurrentRequest();
			} else {
				startDelegateAI(new AIRobotDeliverRequested(robot, currentRequest));
			}
		} else if (ai instanceof AIRobotDeliverRequested) {
			releaseCurrentRequest();
		}
	}

	private void releaseCurrentRequest() {
		if (currentRequest != null) {
			robot.getRegistry().release(currentRequest.getResourceId(robot.worldObj));
			currentRequest.getStation(robot.worldObj).release(robot);
			currentRequest = null;
		}
	}

	@Override
	public boolean canLoadFromNBT() {
		return true;
	}

	@Override
	public void writeSelfToNBT(NBTTagCompound nbt) {
		super.writeSelfToNBT(nbt);

		if (currentRequest != null) {
			NBTTagCompound requestNBT = new NBTTagCompound();
			currentRequest.writeToNBT(requestNBT);
			nbt.setTag("currentRequest", requestNBT);
		}
	}

	@Override
	public void loadSelfFromNBT(NBTTagCompound nbt) {
		super.loadSelfFromNBT(nbt);
		if (nbt.hasKey("currentRequest")) {
			currentRequest = StackRequest.loadFromNBT(nbt.getCompoundTag("currentRequest"));
		}
	}
}

<code block>

package buildcraft.robotics.ai;

import net.minecraft.item.ItemStack;

import net.minecraftforge.common.util.ForgeDirection;

import buildcraft.api.core.IInvSlot;
import buildcraft.api.robots.AIRobot;
import buildcraft.api.robots.DockingStation;
import buildcraft.api.robots.EntityRobotBase;
import buildcraft.api.transport.IInjectable;
import buildcraft.core.lib.inventory.InventoryIterator;
import buildcraft.core.lib.inventory.filters.ArrayStackOrListFilter;
import buildcraft.robotics.statements.ActionRobotFilter;
import buildcraft.robotics.statements.ActionStationAcceptItems;

public class AIRobotUnload extends AIRobot {

	private int waitedCycles = 0;

	public AIRobotUnload(EntityRobotBase iRobot) {
		super(iRobot);
	}

	@Override
	public void update() {
		waitedCycles++;

		if (waitedCycles > 40) {
			if (unload(robot, robot.getDockingStation(), true)) {
				waitedCycles = 0;
			} else {
				setSuccess(!robot.containsItems());
				terminate();
			}
		}
	}

	public static boolean unload(EntityRobotBase robot, DockingStation station, boolean doUnload) {
		if (station == null) {
			return false;
		}

		IInjectable output = station.getItemOutput();
		if (output == null) {
			return false;
		}

		ForgeDirection injectSide = station.side().getOpposite();
		if (!output.canInjectItems(injectSide)) {
			return false;
		}

		for (IInvSlot robotSlot : InventoryIterator.getIterable(robot, ForgeDirection.UNKNOWN)) {
			if (robotSlot.getStackInSlot() == null) {
				continue;
			}

			if (!ActionRobotFilter
					.canInteractWithItem(station, new ArrayStackOrListFilter(robotSlot.getStackInSlot()),
							ActionStationAcceptItems.class)) {
				return false;
			}

			ItemStack stack = robotSlot.getStackInSlot();
			int used = output.injectItem(stack, doUnload, injectSide, null);

			if (used > 0) {
				if (doUnload) {
					robotSlot.decreaseStackInSlot(used);
				}
				return true;
			}
		}

		return false;
	}

	@Override
	public int getEnergyCost() {
		return 10;
	}
}

<code block>

package buildcraft.robotics.ai;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import net.minecraft.item.ItemStack;

import buildcraft.api.robots.AIRobot;
import buildcraft.api.robots.DockingStation;
import buildcraft.api.robots.EntityRobotBase;
import buildcraft.api.robots.IRequestProvider;
import buildcraft.core.lib.inventory.StackHelper;
import buildcraft.core.lib.inventory.filters.IStackFilter;
import buildcraft.robotics.IStationFilter;
import buildcraft.robotics.StackRequest;

public class AIRobotSearchStackRequest extends AIRobot {

	public StackRequest request = null;
	public DockingStation station = null;

	private Collection<ItemStack> blackList;

	private IStackFilter filter;

	public AIRobotSearchStackRequest(EntityRobotBase iRobot) {
		super(iRobot);
	}

	public AIRobotSearchStackRequest(EntityRobotBase iRobot, IStackFilter iFilter, Collection<ItemStack> iBlackList) {
		this(iRobot);

		blackList = iBlackList;
		filter = iFilter;
	}

	@Override
	public void start() {
		startDelegateAI(new AIRobotSearchStation(robot, new StationProviderFilter(), robot.getZoneToWork()));
	}

	@Override
	public void delegateAIEnded(AIRobot ai) {
		if (ai instanceof AIRobotSearchStation) {
			if (!ai.success()) {
				terminate();
			} else {





				request = getOrderFromRequestingStation(((AIRobotSearchStation) ai).targetStation, true);


				terminate();
			}
		}
	}

	@Override
	public boolean success() {
		return request != null;
	}

	private boolean isBlacklisted(ItemStack stack) {
		for (ItemStack black : blackList) {
			if (StackHelper.isMatchingItem(stack, black)) {
				return true;
			}
		}

		return false;
	}

	private StackRequest getOrderFromRequestingStation(DockingStation station, boolean take) {

		for (StackRequest req : getAvailableRequests(station)) {
			if (!isBlacklisted(req.getStack()) && filter.matches(req.getStack())) {
				req.setStation(station);
				if (take) {
					if (robot.getRegistry().take(req.getResourceId(robot.worldObj), robot)) {
						return req;
					}
				} else {
					return req;
				}
			}
		}

		return null;
	}

	private Collection<StackRequest> getAvailableRequests(DockingStation station) {
		List<StackRequest> result = new ArrayList<StackRequest>();

		IRequestProvider provider = station.getRequestProvider();
		if (provider == null) {
			return result;
		}

		for (int i = 0; i < provider.getRequestsCount(); i++) {
			if (provider.getRequest(i) == null) {
				continue;
			}
			StackRequest req = new StackRequest(provider, i, provider.getRequest(i));
			req.setStation(station);
			if (!robot.getRegistry().isTaken(req.getResourceId(robot.worldObj))) {
				result.add(req);
			}
		}
		return result;
	}

	private class StationProviderFilter implements IStationFilter {

		@Override
		public boolean matches(DockingStation station) {
			return getOrderFromRequestingStation(station, false) != null;
		}
	}

}

<code block>

package buildcraft.robotics.ai;

import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;

import buildcraft.api.core.IInvSlot;
import buildcraft.api.robots.AIRobot;
import buildcraft.api.robots.EntityRobotBase;
import buildcraft.api.robots.IRequestProvider;
import buildcraft.core.lib.inventory.InvUtils;
import buildcraft.core.lib.inventory.filters.ArrayStackOrListFilter;
import buildcraft.robotics.StackRequest;

public class AIRobotDeliverRequested extends AIRobot {

	private StackRequest requested;
	private boolean delivered = false;

	public AIRobotDeliverRequested(EntityRobotBase iRobot) {
		super(iRobot);
	}

	public AIRobotDeliverRequested(EntityRobotBase robot, StackRequest request) {
		this(robot);

		requested = request;
	}

	@Override
	public void start() {
		startDelegateAI(new AIRobotGotoStation(robot, requested.getStation(robot.worldObj)));
	}

	@Override
	public void delegateAIEnded(AIRobot ai) {
		if (ai instanceof AIRobotGotoStation) {
			if (!ai.success()) {
				setSuccess(false);
				terminate();
				return;
			}

			IInvSlot slot = InvUtils.getItem(robot, new ArrayStackOrListFilter(requested.getStack()));

			if (slot == null) {
				setSuccess(false);
				terminate();
				return;
			}

			IRequestProvider requester = requested.getRequester(robot.worldObj);
			if (requester == null) {
				setSuccess(false);
				terminate();
				return;
			}
			ItemStack newStack = requester.offerItem(requested.getSlot(), slot.getStackInSlot().copy());

			if (newStack == null || newStack.stackSize != slot.getStackInSlot().stackSize) {
				slot.setStackInSlot(newStack);
			}
			terminate();
		}
	}

	@Override
	public boolean success() {
		return delivered;
	}

	@Override
	public boolean canLoadFromNBT() {
		return true;
	}

	@Override
	public void writeSelfToNBT(NBTTagCompound nbt) {
		super.writeSelfToNBT(nbt);

		if (requested != null) {
			NBTTagCompound requestNBT = new NBTTagCompound();
			requested.writeToNBT(requestNBT);
			nbt.setTag("currentRequest", requestNBT);
		}
	}

	@Override
	public void loadSelfFromNBT(NBTTagCompound nbt) {
		super.loadSelfFromNBT(nbt);
		if (nbt.hasKey("currentRequest")) {
			requested = StackRequest.loadFromNBT(nbt.getCompoundTag("currentRequest"));
		}
	}
}

<code block>

package buildcraft.robotics.gui;

import io.netty.buffer.ByteBuf;

import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.inventory.IInventory;
import net.minecraft.inventory.Slot;
import net.minecraft.item.ItemStack;
import cpw.mods.fml.relauncher.Side;

import buildcraft.BuildCraftCore;
import buildcraft.core.lib.gui.BuildCraftContainer;
import buildcraft.core.lib.network.command.CommandWriter;
import buildcraft.core.lib.network.command.ICommandReceiver;
import buildcraft.core.lib.network.command.PacketCommand;
import buildcraft.core.lib.utils.NetworkUtils;
import buildcraft.robotics.TileRequester;

public class ContainerRequester extends BuildCraftContainer implements ICommandReceiver {

	public GuiRequester gui;

	public ItemStack[] requests = new ItemStack[TileRequester.NB_ITEMS];

	private TileRequester requester;

	public ContainerRequester(IInventory playerInventory, TileRequester iRequester) {
		super(iRequester.getSizeInventory());

		requester = iRequester;

		for (int x = 0; x < 4; ++x) {
			for (int y = 0; y < 5; ++y) {
				addSlotToContainer(new Slot(iRequester, x * 5 + y, 117 + x * 18, 7 + y * 18));
			}
		}


		for (int l = 0; l < 3; l++) {
			for (int k1 = 0; k1 < 9; k1++) {
				addSlotToContainer(new Slot(playerInventory, k1 + l * 9 + 9, 19 + k1 * 18, 101 + l * 18));
			}
		}

		for (int i1 = 0; i1 < 9; i1++) {
			addSlotToContainer(new Slot(playerInventory, i1, 19 + i1 * 18, 159));
		}
	}

	@Override
	public boolean canInteractWith(EntityPlayer player) {
		return true;
	}

	public void getRequestList() {
		BuildCraftCore.instance.sendToServer(new PacketCommand(this, "getRequestList", null));
	}

	@Override
	public void receiveCommand(String command, Side side, Object sender, ByteBuf stream) {
		if (side.isServer() && "getRequestList".equals(command)) {
			final ItemStack[] stacks = new ItemStack[TileRequester.NB_ITEMS];

			for (int i = 0; i < TileRequester.NB_ITEMS; ++i) {
				stacks[i] = requester.getRequestTemplate(i);
			}

			BuildCraftCore.instance.sendToPlayer((EntityPlayer) sender, new PacketCommand(this, "receiveRequestList",
					new CommandWriter() {
				public void write(ByteBuf data) {
					for (ItemStack s : stacks) {
						NetworkUtils.writeStack(data, s);
					}
				}
			}));
		} else if (side.isClient() && "receiveRequestList".equals(command)) {
			requests = new ItemStack[TileRequester.NB_ITEMS];
			for (int i = 0; i < TileRequester.NB_ITEMS; i++) {
				requests[i] = NetworkUtils.readStack(stream);
			}
		}
	}
}

<code block>

package buildcraft.builders;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import io.netty.buffer.ByteBuf;

import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagList;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.AxisAlignedBB;
import net.minecraft.world.WorldSettings.GameType;

import cpw.mods.fml.relauncher.Side;

import net.minecraftforge.common.util.Constants;
import net.minecraftforge.common.util.ForgeDirection;
import net.minecraftforge.fluids.Fluid;
import net.minecraftforge.fluids.FluidContainerRegistry;
import net.minecraftforge.fluids.FluidStack;
import net.minecraftforge.fluids.FluidTankInfo;
import net.minecraftforge.fluids.IFluidHandler;

import buildcraft.BuildCraftCore;
import buildcraft.api.core.BCLog;
import buildcraft.api.core.BlockIndex;
import buildcraft.api.core.IInvSlot;
import buildcraft.api.core.IPathProvider;
import buildcraft.api.core.Position;
import buildcraft.api.robots.IRequestProvider;
import buildcraft.api.tiles.IControllable;
import buildcraft.api.tiles.IHasWork;
import buildcraft.builders.blueprints.RecursiveBlueprintBuilder;
import buildcraft.core.Box;
import buildcraft.core.Box.Kind;
import buildcraft.core.LaserData;
import buildcraft.core.TilePathMarker;
import buildcraft.core.blueprints.Blueprint;
import buildcraft.core.blueprints.BlueprintBase;
import buildcraft.core.blueprints.BptBuilderBase;
import buildcraft.core.blueprints.BptBuilderBlueprint;
import buildcraft.core.blueprints.BptBuilderTemplate;
import buildcraft.core.blueprints.RequirementItemStack;
import buildcraft.core.builders.TileAbstractBuilder;
import buildcraft.core.lib.fluids.Tank;
import buildcraft.core.lib.fluids.TankManager;
import buildcraft.core.lib.inventory.ITransactor;
import buildcraft.core.lib.inventory.InvUtils;
import buildcraft.core.lib.inventory.InventoryIterator;
import buildcraft.core.lib.inventory.SimpleInventory;
import buildcraft.core.lib.inventory.StackHelper;
import buildcraft.core.lib.inventory.Transactor;
import buildcraft.core.lib.network.Packet;
import buildcraft.core.lib.network.command.CommandWriter;
import buildcraft.core.lib.network.command.PacketCommand;
import buildcraft.core.lib.utils.NetworkUtils;

public class TileBuilder extends TileAbstractBuilder implements IHasWork, IFluidHandler, IRequestProvider, IControllable {

	private static int POWER_ACTIVATION = 500;

	public Box box = new Box();
	public PathIterator currentPathIterator;
	public Tank[] fluidTanks = new Tank[] {
			new Tank("fluid1", FluidContainerRegistry.BUCKET_VOLUME * 8, this),
			new Tank("fluid2", FluidContainerRegistry.BUCKET_VOLUME * 8, this),
			new Tank("fluid3", FluidContainerRegistry.BUCKET_VOLUME * 8, this),
			new Tank("fluid4", FluidContainerRegistry.BUCKET_VOLUME * 8, this)
	};
	public TankManager<Tank> fluidTank = new TankManager<Tank>(fluidTanks);

	private SimpleInventory inv = new SimpleInventory(28, "Builder", 64);
	private BptBuilderBase currentBuilder;
	private RecursiveBlueprintBuilder recursiveBuilder;
	private List<BlockIndex> path;
	private ArrayList<RequirementItemStack> requiredToBuild;
	private NBTTagCompound initNBT = null;
	private boolean done = true;
	private boolean isBuilding = false;

	private class PathIterator {

		public Iterator<BlockIndex> currentIterator;
		public double cx, cy, cz;
		public float ix, iy, iz;
		public BlockIndex to;
		public double lastDistance;
		AxisAlignedBB oldBoundingBox = null;
		ForgeDirection o = null;

		public PathIterator(BlockIndex from, Iterator<BlockIndex> it, ForgeDirection initialDir) {
			this.to = it.next();

			currentIterator = it;

			double dx = to.x - from.x;
			double dy = to.y - from.y;
			double dz = to.z - from.z;

			double size = Math.sqrt(dx * dx + dy * dy + dz * dz);

			cx = dx / size / 10;
			cy = dy / size / 10;
			cz = dz / size / 10;

			ix = from.x;
			iy = from.y;
			iz = from.z;

			lastDistance = (ix - to.x) * (ix - to.x) + (iy - to.y)
					* (iy - to.y) + (iz - to.z) * (iz - to.z);

			if (dx == 0 && dz == 0) {
				o = initialDir;
			} else if (Math.abs(dx) > Math.abs(dz)) {
				if (dx > 0) {
					o = ForgeDirection.EAST;
				} else {
					o = ForgeDirection.WEST;
				}
			} else {
				if (dz > 0) {
					o = ForgeDirection.SOUTH;
				} else {
					o = ForgeDirection.NORTH;
				}
			}
		}


		public BptBuilderBase next() {
			while (true) {
				BptBuilderBase bpt;

				int newX = Math.round(ix);
				int newY = Math.round(iy);
				int newZ = Math.round(iz);

				bpt = instanciateBluePrintBuilder(newX, newY, newZ, o);

				if (bpt == null) {
					return null;
				}

				AxisAlignedBB boundingBox = bpt.getBoundingBox();

				if (oldBoundingBox == null || !collision(oldBoundingBox, boundingBox)) {
					oldBoundingBox = boundingBox;
					return bpt;
				}

				ix += cx;
				iy += cy;
				iz += cz;

				double distance = (ix - to.x) * (ix - to.x) + (iy - to.y)
						* (iy - to.y) + (iz - to.z) * (iz - to.z);

				if (distance > lastDistance) {
					return null;
				} else {
					lastDistance = distance;
				}
			}
		}

		public PathIterator iterate() {
			if (currentIterator.hasNext()) {
				PathIterator next = new PathIterator(to, currentIterator, o);
				next.oldBoundingBox = oldBoundingBox;

				return next;
			} else {
				return null;
			}
		}

		public boolean collision(AxisAlignedBB left, AxisAlignedBB right) {
			if (left.maxX < right.minX || left.minX > right.maxX) {
				return false;
			}
			if (left.maxY < right.minY || left.minY > right.maxY) {
				return false;
			}
			if (left.maxZ < right.minZ || left.minZ > right.maxZ) {
				return false;
			}
			return true;
		}
	}

	public TileBuilder() {
		super();

		box.kind = Kind.STRIPES;
	}

	@Override
	public void initialize() {
		super.initialize();

		if (worldObj.isRemote) {
			return;
		}


		if (initNBT != null) {
			iterateBpt(true);

			if (initNBT.hasKey("iterator")) {
				BlockIndex expectedTo = new BlockIndex(initNBT.getCompoundTag("iterator"));

				while (!done && currentBuilder != null && currentPathIterator != null) {
					BlockIndex bi = new BlockIndex((int) currentPathIterator.ix,
							(int) currentPathIterator.iy, (int) currentPathIterator.iz);

					if (bi.equals(expectedTo)) {
						break;
					}

					iterateBpt(true);
				}
			}

			if (currentBuilder != null) {
				currentBuilder.loadBuildStateToNBT(
						initNBT.getCompoundTag("builderState"), this);
			}

			initNBT = null;
		}

		box.kind = Kind.STRIPES;

		for (int x = xCoord - 1; x <= xCoord + 1; ++x) {
			for (int y = yCoord - 1; y <= yCoord + 1; ++y) {
				for (int z = zCoord - 1; z <= zCoord + 1; ++z) {
					TileEntity tile = worldObj.getTileEntity(x, y, z);

					if (tile instanceof IPathProvider) {
						path = ((IPathProvider) tile).getPath();



						if (tile instanceof TilePathMarker) {
							for (BlockIndex b : path) {
								BuildCraftCore.pathMarkerBlock.dropBlockAsItem(
										worldObj, b.x, b.y, b.z,
										0, 0);

								worldObj.setBlockToAir(b.x, b.y, b.z);
							}
						}

						break;
					}
				}
			}
		}

		if (path != null && pathLasers.size() == 0) {
			createLasersForPath();

			sendNetworkUpdate();
		}

		iterateBpt(false);
	}

	public void createLasersForPath() {
		pathLasers = new LinkedList<LaserData>();
		BlockIndex previous = null;

		for (BlockIndex b : path) {
			if (previous != null) {
				LaserData laser = new LaserData(new Position(previous.x + 0.5,
						previous.y + 0.5, previous.z + 0.5), new Position(
						b.x + 0.5, b.y + 0.5, b.z + 0.5));

				pathLasers.add(laser);
			}

			previous = b;
		}
	}

	public BlueprintBase instanciateBlueprint() {
		BlueprintBase bpt;

		try {
			bpt = ItemBlueprint.loadBlueprint(getStackInSlot(0));
		} catch (Throwable t) {
			t.printStackTrace();
			return null;
		}

		return bpt;
	}

	@Deprecated
	public BptBuilderBase instanciateBluePrintBuilder(int x, int y, int z, ForgeDirection o) {
		BlueprintBase bpt = instanciateBlueprint();
        if (bpt == null) {
            return null;
        }

		bpt = bpt.adjustToWorld(worldObj, x, y, z, o);

		if (bpt != null) {
			if (getStackInSlot(0).getItem() instanceof ItemBlueprintStandard) {
				return new BptBuilderBlueprint((Blueprint) bpt, worldObj, x, y, z);
			} else if (getStackInSlot(0).getItem() instanceof ItemBlueprintTemplate) {
				return new BptBuilderTemplate(bpt, worldObj, x, y, z);
			}
		}
		return null;
	}

	public void iterateBpt(boolean forceIterate) {
		if (getStackInSlot(0) == null || !(getStackInSlot(0).getItem() instanceof ItemBlueprint)) {
			if (box.isInitialized()) {
				if (currentBuilder != null) {
					currentBuilder = null;
				}

				if (box.isInitialized()) {
					box.reset();
				}

				if (currentPathIterator != null) {
					currentPathIterator = null;
				}

				updateRequirements();

				sendNetworkUpdate();

				return;
			}
		}

		if (currentBuilder == null || (currentBuilder.isDone(this) || forceIterate)) {
			if (path != null && path.size() > 1) {
				if (currentPathIterator == null) {
					Iterator<BlockIndex> it = path.iterator();
					BlockIndex start = it.next();
					currentPathIterator = new PathIterator(start, it,
							ForgeDirection.values()[worldObj.getBlockMetadata(
									xCoord, yCoord, zCoord)].getOpposite());
				}

				if (currentBuilder != null && currentBuilder.isDone(this)) {
					currentBuilder.postProcessing(worldObj);
				}

				currentBuilder = currentPathIterator.next();

				if (currentBuilder != null) {
					box.reset();
					box.initialize(currentBuilder);
					sendNetworkUpdate();
				}

				if (currentBuilder == null) {
					currentPathIterator = currentPathIterator.iterate();
				}

				if (currentPathIterator == null) {
					done = true;
				} else {
					done = false;
				}

				updateRequirements();
			} else {
				if (currentBuilder != null && currentBuilder.isDone(this)) {
					currentBuilder.postProcessing(worldObj);
					currentBuilder = recursiveBuilder.nextBuilder();

					updateRequirements();
				} else {
					BlueprintBase bpt = instanciateBlueprint();

					if (bpt != null) {
						recursiveBuilder = new RecursiveBlueprintBuilder(bpt, worldObj, xCoord, yCoord, zCoord,
								ForgeDirection.values()[worldObj.getBlockMetadata(xCoord, yCoord, zCoord)].getOpposite());

						currentBuilder = recursiveBuilder.nextBuilder();

						updateRequirements();
					}
				}

				if (currentBuilder == null) {
					done = true;
				} else {
					box.initialize(currentBuilder);
					sendNetworkUpdate();
					done = false;
				}
			}
		}

		if (done && getStackInSlot(0) != null) {
			boolean dropBlueprint = true;
			for (int i = 1; i < getSizeInventory(); ++i) {
				if (getStackInSlot(i) == null) {
					setInventorySlotContents(i, getStackInSlot(0));
					dropBlueprint = false;
					break;
				}
			}
			if (dropBlueprint) {
				InvUtils.dropItems(getWorldObj(), getStackInSlot(0), xCoord, yCoord, zCoord);
			}

			setInventorySlotContents(0, null);
			box.reset();
		}
	}

	@Override
	public int getSizeInventory() {
		return inv.getSizeInventory();
	}

	@Override
	public ItemStack getStackInSlot(int i) {
		return inv.getStackInSlot(i);
	}

	@Override
	public ItemStack decrStackSize(int i, int j) {
		ItemStack result = inv.decrStackSize(i, j);

		if (!worldObj.isRemote) {
			if (i == 0) {
				BuildCraftCore.instance.sendToWorld(new PacketCommand(this, "clearItemRequirements", null), worldObj);
				iterateBpt(false);
			}
		}

		return result;
	}

	@Override
	public void setInventorySlotContents(int i, ItemStack itemstack) {
		inv.setInventorySlotContents(i, itemstack);

		if (!worldObj.isRemote) {
			if (i == 0) {
				iterateBpt(false);
				done = false;
			}
		}
	}

	@Override
	public ItemStack getStackInSlotOnClosing(int slot) {
		return inv.getStackInSlotOnClosing(slot);
	}

	@Override
	public String getInventoryName() {
		return "Builder";
	}

	@Override
	public int getInventoryStackLimit() {
		return 64;
	}

	@Override
	public boolean isUseableByPlayer(EntityPlayer entityplayer) {
		return worldObj.getTileEntity(xCoord, yCoord, zCoord) == this;
	}

	@Override
	public void readFromNBT(NBTTagCompound nbttagcompound) {
		super.readFromNBT(nbttagcompound);

		inv.readFromNBT(nbttagcompound);

		if (nbttagcompound.hasKey("box")) {
			box.initialize(nbttagcompound.getCompoundTag("box"));
		}

		if (nbttagcompound.hasKey("path")) {
			path = new LinkedList<BlockIndex>();
			NBTTagList list = nbttagcompound.getTagList("path",
					Constants.NBT.TAG_COMPOUND);

			for (int i = 0; i < list.tagCount(); ++i) {
				path.add(new BlockIndex(list.getCompoundTagAt(i)));
			}
		}

		done = nbttagcompound.getBoolean("done");
		fluidTank.readFromNBT(nbttagcompound);


		initNBT = (NBTTagCompound) nbttagcompound.getCompoundTag("bptBuilder").copy();
	}

	@Override
	public void writeToNBT(NBTTagCompound nbttagcompound) {
		super.writeToNBT(nbttagcompound);

		inv.writeToNBT(nbttagcompound);

		if (box.isInitialized()) {
			NBTTagCompound boxStore = new NBTTagCompound();
			box.writeToNBT(boxStore);
			nbttagcompound.setTag("box", boxStore);
		}

		if (path != null) {
			NBTTagList list = new NBTTagList();

			for (BlockIndex i : path) {
				NBTTagCompound c = new NBTTagCompound();
				i.writeTo(c);
				list.appendTag(c);
			}

			nbttagcompound.setTag("path", list);
		}

		nbttagcompound.setBoolean("done", done);
		fluidTank.writeToNBT(nbttagcompound);

		NBTTagCompound bptNBT = new NBTTagCompound();

		if (currentBuilder != null) {
			NBTTagCompound builderCpt = new NBTTagCompound();
			currentBuilder.saveBuildStateToNBT(builderCpt, this);
			bptNBT.setTag("builderState", builderCpt);
		}

		if (currentPathIterator != null) {
			NBTTagCompound iteratorNBT = new NBTTagCompound();
			new BlockIndex((int) currentPathIterator.ix,
					(int) currentPathIterator.iy, (int) currentPathIterator.iz)
					.writeTo(iteratorNBT);
			bptNBT.setTag ("iterator", iteratorNBT);
		}

		nbttagcompound.setTag("bptBuilder", bptNBT);
	}

	@Override
	public void invalidate() {
		super.invalidate();
		destroy();
	}

	@Override
	public void openInventory() {
	}

	@Override
	public void closeInventory() {
	}

	@Override
	public void updateEntity() {
		super.updateEntity();

		if (worldObj.isRemote) {
			return;
		}

		if ((currentBuilder == null || currentBuilder.isDone(this))
				&& box.isInitialized()) {
			box.reset();

			sendNetworkUpdate();

			return;
		}

		iterateBpt(false);

		if (mode != Mode.Off) {
			if (getWorldObj().getWorldInfo().getGameType() == GameType.CREATIVE) {
				build();
			} else if (getBattery().getEnergyStored() > POWER_ACTIVATION) {
				build();
			}
		}

		if (!isBuilding && this.isBuildingBlueprint()) {
			updateRequirements();
		}
		isBuilding = this.isBuildingBlueprint();

		if (done) {
			return;
		} else if (getBattery().getEnergyStored() < 25) {
			return;
		}
	}

	@Override
	public boolean hasWork() {
		return !done;
	}

	public boolean isBuildingBlueprint() {
		return getStackInSlot(0) != null && getStackInSlot(0).getItem() instanceof ItemBlueprint;
	}

	public List<RequirementItemStack> getNeededItems() {
		return requiredToBuild;
	}

	@Override
	public void receiveCommand(String command, Side side, Object sender, ByteBuf stream) {
		super.receiveCommand(command, side, sender, stream);
		if (side.isClient()) {
			if ("clearItemRequirements".equals(command)) {
				requiredToBuild = null;
			} else if ("setItemRequirements".equals(command)) {
				int size = stream.readUnsignedMedium();
				requiredToBuild = new ArrayList<RequirementItemStack>();
				for (int i = 0; i < size; i++) {
					int itemId = stream.readUnsignedShort();
					int itemDamage = stream.readShort();
					int stackSize = stream.readUnsignedMedium();
					boolean hasCompound = stackSize >= 0x800000;

					ItemStack stack = new ItemStack(Item.getItemById(itemId), 1, itemDamage);
					if (hasCompound) {
						stack.setTagCompound(NetworkUtils.readNBT(stream));
					}

					if (stack.getItem() != null) {
						requiredToBuild.add(new RequirementItemStack(stack, stackSize & 0x7FFFFF));
					} else {
						BCLog.logger.error("Corrupt ItemStack in TileBuilder.receiveCommand! This should not happen! (ID " + itemId + ", damage " + itemDamage + ")");
					}
				}
			}
		} else if (side.isServer()) {
			EntityPlayer player = (EntityPlayer) sender;
			if ("eraseFluidTank".equals(command)) {
				int id = stream.readInt();
				if (id < 0 || id >= fluidTanks.length) {
					return;
				}
				if (isUseableByPlayer(player) && player.getDistanceSq(xCoord, yCoord, zCoord) <= 64) {
					fluidTanks[id].setFluid(null);
					sendNetworkUpdate();
				}
			}
		}
	}

	private Packet getItemRequirementsPacket(final List<RequirementItemStack> items) {
		if (items != null) {
			return new PacketCommand(this, "setItemRequirements", new CommandWriter() {
				public void write(ByteBuf data) {
					data.writeMedium(items.size());
					for (RequirementItemStack rb : items) {
						data.writeShort(Item.getIdFromItem(rb.stack.getItem()));
						data.writeShort(rb.stack.getItemDamage());
						data.writeMedium((rb.stack.hasTagCompound() ? 0x800000 : 0x000000) | Math.min(0x7FFFFF, rb.size));
						if (rb.stack.hasTagCompound()) {
							NetworkUtils.writeNBT(data, rb.stack.getTagCompound());
						}
					}
				}
			});
		} else {
			return new PacketCommand(this, "clearItemRequirements", null);
		}
	}

	@Override
	public boolean isBuildingMaterialSlot(int i) {
		return i != 0;
	}

	@Override
	public boolean hasCustomInventoryName() {
		return false;
	}

	@Override
	public boolean isItemValidForSlot(int slot, ItemStack stack) {
		if (slot == 0) {
			return stack.getItem() instanceof ItemBlueprint;
		} else {
			return true;
		}
	}

	@Override
	public Box getBox() {
		return box;
	}

	@Override
	public AxisAlignedBB getRenderBoundingBox() {
		Box renderBox = new Box (this).extendToEncompass(box);

		for (LaserData l : pathLasers) {
			renderBox = renderBox.extendToEncompass(l.head);
			renderBox = renderBox.extendToEncompass(l.tail);
		}

		return renderBox.expand(50).getBoundingBox();
	}

	public void build () {
		if (currentBuilder != null) {
			if (currentBuilder.buildNextSlot(worldObj, this, xCoord, yCoord, zCoord)) {
				updateRequirements();
			}
		}
	}

	public void updateRequirements() {
		List<RequirementItemStack> reqCopy = null;
		if (currentBuilder instanceof BptBuilderBlueprint) {
			currentBuilder.initialize();
			reqCopy = ((BptBuilderBlueprint) currentBuilder).neededItems;
		}

		for (EntityPlayer p : guiWatchers) {
			BuildCraftCore.instance.sendToPlayer(p, getItemRequirementsPacket(reqCopy));
		}
	}
	
	public void updateRequirements(EntityPlayer caller) {
		List<RequirementItemStack> reqCopy = null;
		if (currentBuilder instanceof BptBuilderBlueprint) {
			currentBuilder.initialize();
			reqCopy = ((BptBuilderBlueprint) currentBuilder).neededItems;
		}

		BuildCraftCore.instance.sendToPlayer(caller, getItemRequirementsPacket(reqCopy));
	}

	public BptBuilderBase getBlueprint () {
		if (currentBuilder != null) {
			return currentBuilder;
		} else {
			return null;
		}
	}

	@Override
	public boolean canDrain(ForgeDirection from, Fluid fluid) {
		return false;
	}

	@Override
	public FluidStack drain(ForgeDirection from, FluidStack resource, boolean doDrain) {
		return null;
	}

	@Override
	public FluidStack drain(ForgeDirection from, int maxDrain, boolean doDrain) {
		return null;
	}

	@Override
	public boolean drainBuild(FluidStack fluidStack, boolean realDrain) {
		for (Tank tank : fluidTanks) {
			if (tank.getFluidType() == fluidStack.getFluid()) {
				return tank.getFluidAmount() >= fluidStack.amount && tank.drain(fluidStack.amount, realDrain).amount > 0;
			}
		}
		return false;
	}

	@Override
	public int fill(ForgeDirection from, FluidStack resource, boolean doFill) {
		Fluid fluid = resource.getFluid();
		Tank emptyTank = null;
		for (Tank tank : fluidTanks) {
			Fluid type = tank.getFluidType();
			if (type == fluid) {
				int used = tank.fill(resource, doFill);
				if (used > 0 && doFill) {
					sendNetworkUpdate();
				}
				return used;
			} else if (emptyTank == null && tank.isEmpty()) {
				emptyTank = tank;
			}
		}
		if (emptyTank != null) {
			int used = emptyTank.fill(resource, doFill);
			if (used > 0 && doFill) {
				sendNetworkUpdate();
			}
			return used;
		}
		return 0;
	}

	@Override
	public boolean canFill(ForgeDirection from, Fluid fluid) {
		boolean emptyAvailable = false;
		for (Tank tank : fluidTanks) {
			Fluid type = tank.getFluidType();
			if (type == fluid) {
				return !tank.isFull();
			} else if (!emptyAvailable) {
				emptyAvailable = tank.isEmpty();
			}
		}
		return emptyAvailable;
	}

	@Override
	public FluidTankInfo[] getTankInfo(ForgeDirection from) {
		return fluidTank.getTankInfo(from);
	}

	@Override
	public int getRequestsCount() {
		if (currentBuilder == null) {
			return 0;
		} else if (!(currentBuilder instanceof BptBuilderBlueprint)) {
			return 0;
		} else {
			BptBuilderBlueprint bpt = (BptBuilderBlueprint) currentBuilder;

			return bpt.neededItems.size();
		}
	}

	@Override
	public ItemStack getRequest(int slot) {
		if (currentBuilder == null) {
			return null;
		} else if (!(currentBuilder instanceof BptBuilderBlueprint)) {
			return null;
		} else {
			BptBuilderBlueprint bpt = (BptBuilderBlueprint) currentBuilder;

			if (bpt.neededItems.size() <= slot) {
				return null;
			}

			RequirementItemStack requirement = bpt.neededItems.get(slot);

			int qty = quantityMissing(requirement.stack, requirement.size);

			if (qty <= 0) {
				return null;
			}
			ItemStack requestStack = requirement.stack.copy();
			requestStack.stackSize = qty;
			return requestStack;
		}
	}

	@Override
	public ItemStack offerItem(int slot, ItemStack stack) {
		if (currentBuilder == null) {
			return stack;
		} else if (!(currentBuilder instanceof BptBuilderBlueprint)) {
			return stack;
		} else {
			BptBuilderBlueprint bpt = (BptBuilderBlueprint) currentBuilder;

			if (bpt.neededItems.size() <= slot) {
				return stack;
			}

			RequirementItemStack requirement = bpt.neededItems.get(slot);

			int qty = quantityMissing(requirement.stack, requirement.size);

			if (qty <= 0) {
				return stack;
			}

			ItemStack toAdd = stack.copy();

			if (qty < toAdd.stackSize) {
				toAdd.stackSize = qty;
			}

			ITransactor t = Transactor.getTransactorFor(this);
			ItemStack added = t.add(toAdd, ForgeDirection.UNKNOWN, true);

			if (added.stackSize >= stack.stackSize) {
				return null;
			} else {
				stack.stackSize -= added.stackSize;
				return stack;
			}
		}
	}

	private int quantityMissing(ItemStack requirement, int amount) {
		int left = amount <= 0 ? requirement.stackSize : amount;

		for (IInvSlot slot : InventoryIterator.getIterable(this)) {
			if (slot.getStackInSlot() != null) {
				if (StackHelper.isMatchingItem(requirement, slot.getStackInSlot())) {
					if (slot.getStackInSlot().stackSize >= left) {
						return 0;
					} else {
						left -= slot.getStackInSlot().stackSize;
					}
				}
			}
		}

		return left;
	}

	@Override
	public boolean acceptsControlMode(Mode mode) {
		return mode == Mode.Off || mode == Mode.On;
	}

	@Override
	public void writeData(ByteBuf stream) {
		super.writeData(stream);
		box.writeData(stream);
		fluidTank.writeData(stream);
	}

	@Override
	public void readData(ByteBuf stream) {
		super.readData(stream);
		box.readData(stream);
		fluidTank.readData(stream);
	}
}
