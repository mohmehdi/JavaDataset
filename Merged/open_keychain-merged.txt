

package org.sufficientlysecure.keychain.util.tor;

import org.sufficientlysecure.keychain.Constants;
import org.sufficientlysecure.keychain.util.Log;

import java.io.BufferedReader;
import java.io.File;
import java.io.InputStreamReader;
import java.net.URLEncoder;
import java.util.StringTokenizer;


public class TorServiceUtils {
    
    public final static String SHELL_CMD_PS = "ps";
    public final static String SHELL_CMD_PIDOF = "pidof";

    public static int findProcessId(String command) {
        int procId = -1;

        try {
            procId = findProcessIdWithPidOf(command);

            if (procId == -1) {
                procId = findProcessIdWithPS(command);
            }
        } catch (Exception e) {
            try {
                procId = findProcessIdWithPS(command);
            } catch (Exception e2) {
                Log.e(Constants.TAG, "Unable to get proc id for command: " + URLEncoder.encode(command), e2);
            }
        }

        return procId;
    }

    
    public static int findProcessIdWithPidOf(String command) throws Exception {

        int procId = -1;
        Runtime r = Runtime.getRuntime();
        Process procPs;

        String baseName = new File(command).getName();
        
        procPs = r.exec(new String[]{
                SHELL_CMD_PIDOF, baseName
        });
        

        BufferedReader reader = new BufferedReader(new InputStreamReader(procPs.getInputStream()));
        String line;

        while ((line = reader.readLine()) != null) {

            try {
                
                procId = Integer.parseInt(line.trim());
                break;
            } catch (NumberFormatException e) {
                Log.e("TorServiceUtils", "unable to parse process pid: " + line, e);
            }
        }

        return procId;
    }

    
    public static int findProcessIdWithPS(String command) throws Exception {
        int procId = -1;
        Runtime r = Runtime.getRuntime();
        Process procPs;

        procPs = r.exec(SHELL_CMD_PS);

        BufferedReader reader = new BufferedReader(new InputStreamReader(procPs.getInputStream()));
        String line;
        while ((line = reader.readLine()) != null) {
            if (line.contains(' ' + command)) {

                StringTokenizer st = new StringTokenizer(line, " ");
                st.nextToken(); 

                procId = Integer.parseInt(st.nextToken().trim());

                break;
            }
        }

        return procId;
    }
}

<code block>


package org.sufficientlysecure.keychain.util.tor;

import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.os.Handler;
import android.os.Message;
import android.os.Messenger;
import android.support.v4.app.DialogFragment;
import android.support.v4.app.FragmentActivity;

import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.ui.dialog.InstallDialogFragment;
import org.sufficientlysecure.keychain.ui.dialog.OrbotStartDialogFragment;
import org.sufficientlysecure.keychain.ui.dialog.PreferenceInstallDialogFragment;
import org.sufficientlysecure.keychain.util.Preferences;


public class OrbotHelper {

    public final static String ORBOT_PACKAGE_NAME = "org.torproject.android";
    public final static String TOR_BIN_PATH = "/data/data/org.torproject.android/app_bin/tor";

    public final static String ACTION_START_TOR = "org.torproject.android.START_TOR";

    public static boolean isOrbotRunning() {
        int procId = TorServiceUtils.findProcessId(TOR_BIN_PATH);

        return (procId != -1);
    }

    public static boolean isOrbotInstalled(Context context) {
        return isAppInstalled(ORBOT_PACKAGE_NAME, context);
    }

    private static boolean isAppInstalled(String uri, Context context) {
        PackageManager pm = context.getPackageManager();

        boolean installed;
        try {
            pm.getPackageInfo(uri, PackageManager.GET_ACTIVITIES);
            installed = true;
        } catch (PackageManager.NameNotFoundException e) {
            installed = false;
        }
        return installed;
    }

    
    public static android.app.DialogFragment getPreferenceInstallDialogFragment() {
        return PreferenceInstallDialogFragment.newInstance(R.string.orbot_install_dialog_title,
                R.string.orbot_install_dialog_content, ORBOT_PACKAGE_NAME);
    }

    public static DialogFragment getInstallDialogFragment() {
        return InstallDialogFragment.newInstance(R.string.orbot_install_dialog_title,
                R.string.orbot_install_dialog_content, ORBOT_PACKAGE_NAME);
    }

    public static DialogFragment getInstallDialogFragmentWithThirdButton(Messenger messenger, int middleButton) {
        return InstallDialogFragment.newInstance(messenger, R.string.orbot_install_dialog_title,
                R.string.orbot_install_dialog_content, ORBOT_PACKAGE_NAME, middleButton, true);
    }

    public static DialogFragment getOrbotStartDialogFragment(Messenger messenger, int middleButton) {
        return OrbotStartDialogFragment.newInstance(messenger, R.string.orbot_start_dialog_title, R.string
                        .orbot_start_dialog_content,
                middleButton);
    }

    public static Intent getOrbotStartIntent() {
        Intent intent = new Intent(ACTION_START_TOR);
        intent.setPackage(ORBOT_PACKAGE_NAME);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        return intent;
    }

    
    public static boolean isOrbotInRequiredState(int middleButton, final Runnable middleButtonRunnable,
                                                 Preferences.ProxyPrefs proxyPrefs, FragmentActivity fragmentActivity) {
        Handler ignoreTorHandler = new Handler() {
            @Override
            public void handleMessage(Message msg) {
                
                middleButtonRunnable.run();
            }
        };

        if (!proxyPrefs.torEnabled) {
            return true;
        }

        if (!OrbotHelper.isOrbotInstalled(fragmentActivity)) {

            OrbotHelper.getInstallDialogFragmentWithThirdButton(
                    new Messenger(ignoreTorHandler),
                    R.string.orbot_install_dialog_ignore_tor
            ).show(fragmentActivity.getSupportFragmentManager(), "OrbotHelperOrbotInstallDialog");

            return false;
        } else if (!OrbotHelper.isOrbotRunning()) {

            OrbotHelper.getOrbotStartDialogFragment(new Messenger(ignoreTorHandler),
                    R.string.orbot_install_dialog_ignore_tor)
                    .show(fragmentActivity.getSupportFragmentManager(), "OrbotHelperOrbotStartDialog");

            return false;
        } else {
            return true;
        }
    }
}

<code block>


package org.sufficientlysecure.keychain.ui;

import android.annotation.TargetApi;
import android.app.ProgressDialog;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.net.Uri;
import android.nfc.NdefMessage;
import android.nfc.NfcAdapter;
import android.os.Build;
import android.os.Bundle;
import android.os.Message;
import android.os.Messenger;
import android.os.Parcelable;
import android.support.v4.app.FragmentActivity;
import android.widget.Toast;

import com.google.zxing.integration.android.IntentIntegrator;
import com.google.zxing.integration.android.IntentResult;

import org.sufficientlysecure.keychain.Constants;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.intents.OpenKeychainIntents;
import org.sufficientlysecure.keychain.keyimport.ParcelableKeyRing;
import org.sufficientlysecure.keychain.operations.results.ImportKeyResult;
import org.sufficientlysecure.keychain.operations.results.OperationResult;
import org.sufficientlysecure.keychain.operations.results.OperationResult.LogType;
import org.sufficientlysecure.keychain.operations.results.SingletonResult;
import org.sufficientlysecure.keychain.service.KeychainService;
import org.sufficientlysecure.keychain.service.ServiceProgressHandler;
import org.sufficientlysecure.keychain.util.IntentIntegratorSupportV4;
import org.sufficientlysecure.keychain.util.Log;
import org.sufficientlysecure.keychain.util.ParcelableProxy;
import org.sufficientlysecure.keychain.util.Preferences;
import org.sufficientlysecure.keychain.util.tor.OrbotHelper;

import java.util.ArrayList;
import java.util.Locale;


public class ImportKeysProxyActivity extends FragmentActivity {

    public static final String ACTION_QR_CODE_API = OpenKeychainIntents.IMPORT_KEY_FROM_QR_CODE;
    
    public static final String ACTION_SCAN_WITH_RESULT = Constants.INTENT_PREFIX + "SCAN_QR_CODE_WITH_RESULT";
    public static final String ACTION_SCAN_IMPORT = Constants.INTENT_PREFIX + "SCAN_QR_CODE_IMPORT";

    public static final String EXTRA_FINGERPRINT = "fingerprint";

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        

        handleActions(getIntent());
    }

    protected void handleActions(Intent intent) {
        String action = intent.getAction();
        Uri dataUri = intent.getData();
        String scheme = intent.getScheme();

        if (scheme != null && scheme.toLowerCase(Locale.ENGLISH).equals(Constants.FINGERPRINT_SCHEME)) {
            

            processScannedContent(dataUri);
        } else if (ACTION_SCAN_WITH_RESULT.equals(action)
                || ACTION_SCAN_IMPORT.equals(action) || ACTION_QR_CODE_API.equals(action)) {
            IntentIntegrator integrator = new IntentIntegrator(this);
            integrator.setDesiredBarcodeFormats(IntentIntegrator.QR_CODE_TYPES)
                    .setPrompt(getString(R.string.import_qr_code_text))
                    .setResultDisplayDuration(0);
            integrator.setOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
            integrator.initiateScan();
        } else if (NfcAdapter.ACTION_NDEF_DISCOVERED.equals(getIntent().getAction())) {
            
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
                handleActionNdefDiscovered(getIntent());
            } else {
                Log.e(Constants.TAG, "Android Beam not supported by Android < 4.1");
                finish();
            }
        } else {
            Log.e(Constants.TAG, "No valid scheme or action given!");
            finish();
        }
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (requestCode == IntentIntegratorSupportV4.REQUEST_CODE) {
            IntentResult scanResult = IntentIntegratorSupportV4.parseActivityResult(requestCode,
                    resultCode, data);

            if (scanResult == null || scanResult.getFormatName() == null) {
                Log.e(Constants.TAG, "scanResult or formatName null! Should not happen!");
                finish();
                return;
            }

            String scannedContent = scanResult.getContents();
            processScannedContent(scannedContent);

            return;
        }
        
        if (data != null && data.hasExtra(OperationResult.EXTRA_RESULT)) {
            returnResult(data);
        } else {
            super.onActivityResult(requestCode, resultCode, data);
            finish();
        }
    }

    private void processScannedContent(String content) {
        Uri uri = Uri.parse(content);
        processScannedContent(uri);
    }

    private void processScannedContent(Uri uri) {
        String action = getIntent().getAction();

        Log.d(Constants.TAG, "scanned: " + uri);

        
        if (uri == null || uri.getScheme() == null ||
                !uri.getScheme().toLowerCase(Locale.ENGLISH).equals(Constants.FINGERPRINT_SCHEME)) {
            SingletonResult result = new SingletonResult(
                    SingletonResult.RESULT_ERROR, LogType.MSG_WRONG_QR_CODE);
            Intent intent = new Intent();
            intent.putExtra(SingletonResult.EXTRA_RESULT, result);
            returnResult(intent);
            return;
        }
        final String fingerprint = uri.getEncodedSchemeSpecificPart().toLowerCase(Locale.ENGLISH);
        if (!fingerprint.matches("[a-fA-F0-9]{40}")) {
            SingletonResult result = new SingletonResult(
                    SingletonResult.RESULT_ERROR, LogType.MSG_WRONG_QR_CODE_FP);
            Intent intent = new Intent();
            intent.putExtra(SingletonResult.EXTRA_RESULT, result);
            returnResult(intent);
            return;
        }

        if (ACTION_SCAN_WITH_RESULT.equals(action)) {
            Intent result = new Intent();
            result.putExtra(EXTRA_FINGERPRINT, fingerprint);
            setResult(RESULT_OK, result);
            finish();
        } else {
            final Preferences.ProxyPrefs proxyPrefs = Preferences.getPreferences(this).getProxyPrefs();
            Runnable ignoreTor = new Runnable() {
                @Override
                public void run() {
                    importKeys(fingerprint, new ParcelableProxy(null, -1, null));
                }
            };

            if (OrbotHelper.isOrbotInRequiredState(R.string.orbot_ignore_tor, ignoreTor, proxyPrefs,
                    this)) {
                importKeys(fingerprint, proxyPrefs.parcelableProxy);
            }
        }

    }

    public void returnResult(Intent data) {
        String action = getIntent().getAction();

        if (ACTION_QR_CODE_API.equals(action)) {
            
            OperationResult result = data.getParcelableExtra(OperationResult.EXTRA_RESULT);
            String str = getString(result.getLog().getLast().mType.getMsgId());
            Toast.makeText(this, str, Toast.LENGTH_LONG).show();
            finish();
        } else {
            setResult(RESULT_OK, data);
            finish();
        }
    }

    public void importKeys(byte[] keyringData, ParcelableProxy parcelableProxy) {
        ParcelableKeyRing keyEntry = new ParcelableKeyRing(keyringData);
        ArrayList<ParcelableKeyRing> selectedEntries = new ArrayList<>();
        selectedEntries.add(keyEntry);

        startImportService(selectedEntries, parcelableProxy);
    }

    public void importKeys(String fingerprint, ParcelableProxy parcelableProxy) {
        ParcelableKeyRing keyEntry = new ParcelableKeyRing(fingerprint, null, null);
        ArrayList<ParcelableKeyRing> selectedEntries = new ArrayList<>();
        selectedEntries.add(keyEntry);

        startImportService(selectedEntries, parcelableProxy);
    }

    private void startImportService(ArrayList<ParcelableKeyRing> keyRings, ParcelableProxy parcelableProxy) {

        
        ServiceProgressHandler serviceHandler = new ServiceProgressHandler(this) {
            @Override
            public void handleMessage(Message message) {
                
                super.handleMessage(message);

                if (message.arg1 == MessageStatus.OKAY.ordinal()) {
                    
                    Bundle returnData = message.getData();
                    if (returnData == null) {
                        finish();
                        return;
                    }
                    final ImportKeyResult result =
                            returnData.getParcelable(OperationResult.EXTRA_RESULT);
                    if (result == null) {
                        Log.e(Constants.TAG, "result == null");
                        finish();
                        return;
                    }

                    if (!result.success()) {
                        
                        Intent data = new Intent();
                        data.putExtras(returnData);
                        returnResult(data);
                        return;
                    }

                    Intent certifyIntent = new Intent(ImportKeysProxyActivity.this,
                            CertifyKeyActivity.class);
                    certifyIntent.putExtra(CertifyKeyActivity.EXTRA_RESULT, result);
                    certifyIntent.putExtra(CertifyKeyActivity.EXTRA_KEY_IDS,
                            result.getImportedMasterKeyIds());
                    startActivityForResult(certifyIntent, 0);
                }
            }
        };

        
        Bundle data = new Bundle();

        
        {
            Preferences prefs = Preferences.getPreferences(this);
            Preferences.CloudSearchPrefs cloudPrefs =
                    new Preferences.CloudSearchPrefs(true, true, prefs.getPreferredKeyserver());
            data.putString(KeychainService.IMPORT_KEY_SERVER, cloudPrefs.keyserver);
        }

        data.putParcelableArrayList(KeychainService.IMPORT_KEY_LIST, keyRings);

        data.putParcelable(KeychainService.EXTRA_PARCELABLE_PROXY, parcelableProxy);

        
        Intent intent = new Intent(this, KeychainService.class);
        intent.setAction(KeychainService.ACTION_IMPORT_KEYRING);
        intent.putExtra(KeychainService.EXTRA_DATA, data);

        
        Messenger messenger = new Messenger(serviceHandler);
        intent.putExtra(KeychainService.EXTRA_MESSENGER, messenger);

        
        serviceHandler.showProgressDialog(
                getString(R.string.progress_importing),
                ProgressDialog.STYLE_HORIZONTAL, true);

        
        startService(intent);
    }

    
    @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
    void handleActionNdefDiscovered(Intent intent) {
        Parcelable[] rawMsgs = intent.getParcelableArrayExtra(NfcAdapter.EXTRA_NDEF_MESSAGES);
        
        NdefMessage msg = (NdefMessage) rawMsgs[0];
        
        final byte[] receivedKeyringBytes = msg.getRecords()[0].getPayload();
        final Preferences.ProxyPrefs proxyPrefs = Preferences.getPreferences(this)
                .getProxyPrefs();
        Runnable ignoreTor = new Runnable() {
            @Override
            public void run() {
                importKeys(receivedKeyringBytes, new ParcelableProxy(null, -1, null));
            }
        };

        if (OrbotHelper.isOrbotInRequiredState(R.string.orbot_ignore_tor, ignoreTor, proxyPrefs, this)) {
            importKeys(receivedKeyringBytes, proxyPrefs.parcelableProxy);
        }
    }

}

<code block>


package org.sufficientlysecure.keychain.ui;

import java.util.ArrayList;

import android.content.Intent;
import android.database.Cursor;
import android.net.Uri;
import android.os.Bundle;
import android.os.Message;
import android.os.Messenger;
import android.support.v4.app.LoaderManager;
import android.support.v4.content.CursorLoader;
import android.support.v4.content.Loader;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.TextView;

import org.openintents.openpgp.OpenPgpSignatureResult;
import org.sufficientlysecure.keychain.Constants;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.keyimport.ParcelableKeyRing;
import org.sufficientlysecure.keychain.operations.results.DecryptVerifyResult;
import org.sufficientlysecure.keychain.operations.results.ImportKeyResult;
import org.sufficientlysecure.keychain.operations.results.OperationResult;
import org.sufficientlysecure.keychain.pgp.KeyRing;
import org.sufficientlysecure.keychain.pgp.PgpDecryptVerifyInputParcel;
import org.sufficientlysecure.keychain.pgp.exception.PgpKeyNotFoundException;
import org.sufficientlysecure.keychain.provider.KeychainContract;
import org.sufficientlysecure.keychain.provider.KeychainContract.KeyRings;
import org.sufficientlysecure.keychain.provider.ProviderHelper;
import org.sufficientlysecure.keychain.service.KeychainService;
import org.sufficientlysecure.keychain.service.ServiceProgressHandler;
import org.sufficientlysecure.keychain.ui.base.CachingCryptoOperationFragment;
import org.sufficientlysecure.keychain.ui.util.KeyFormattingUtils;
import org.sufficientlysecure.keychain.ui.util.KeyFormattingUtils.State;
import org.sufficientlysecure.keychain.ui.util.Notify;
import org.sufficientlysecure.keychain.ui.util.Notify.Style;
import org.sufficientlysecure.keychain.util.ParcelableProxy;
import org.sufficientlysecure.keychain.util.Preferences;
import org.sufficientlysecure.keychain.util.tor.OrbotHelper;

public abstract class DecryptFragment
        extends CachingCryptoOperationFragment<PgpDecryptVerifyInputParcel, DecryptVerifyResult>
        implements LoaderManager.LoaderCallbacks<Cursor> {

    public static final int LOADER_ID_UNIFIED = 0;
    public static final String ARG_DECRYPT_VERIFY_RESULT = "decrypt_verify_result";

    protected LinearLayout mResultLayout;
    protected ImageView mEncryptionIcon;
    protected TextView mEncryptionText;
    protected ImageView mSignatureIcon;
    protected TextView mSignatureText;
    protected View mSignatureLayout;
    protected TextView mSignatureName;
    protected TextView mSignatureEmail;
    protected TextView mSignatureAction;

    private LinearLayout mContentLayout;
    private LinearLayout mErrorOverlayLayout;

    private OpenPgpSignatureResult mSignatureResult;
    private DecryptVerifyResult mDecryptVerifyResult;

    @Override
    public void onViewCreated(View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        
        mResultLayout = (LinearLayout) getActivity().findViewById(R.id.result_main_layout);
        mResultLayout.setVisibility(View.GONE);
        mEncryptionIcon = (ImageView) getActivity().findViewById(R.id.result_encryption_icon);
        mEncryptionText = (TextView) getActivity().findViewById(R.id.result_encryption_text);
        mSignatureIcon = (ImageView) getActivity().findViewById(R.id.result_signature_icon);
        mSignatureText = (TextView) getActivity().findViewById(R.id.result_signature_text);
        mSignatureLayout = getActivity().findViewById(R.id.result_signature_layout);
        mSignatureName = (TextView) getActivity().findViewById(R.id.result_signature_name);
        mSignatureEmail = (TextView) getActivity().findViewById(R.id.result_signature_email);
        mSignatureAction = (TextView) getActivity().findViewById(R.id.result_signature_action);

        
        mContentLayout = (LinearLayout) view.findViewById(R.id.decrypt_content);
        mErrorOverlayLayout = (LinearLayout) view.findViewById(R.id.decrypt_error_overlay);
        Button vErrorOverlayButton = (Button) view.findViewById(R.id.decrypt_error_overlay_button);
        vErrorOverlayButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                mErrorOverlayLayout.setVisibility(View.GONE);
                mContentLayout.setVisibility(View.VISIBLE);
            }
        });
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);

        outState.putParcelable(ARG_DECRYPT_VERIFY_RESULT, mDecryptVerifyResult);
    }

    @Override
    public void onViewStateRestored(Bundle savedInstanceState) {
        super.onViewStateRestored(savedInstanceState);

        if (savedInstanceState == null) {
            return;
        }

        DecryptVerifyResult result = savedInstanceState.getParcelable(ARG_DECRYPT_VERIFY_RESULT);
        if (result != null) {
            loadVerifyResult(result);
        }
    }

    private void lookupUnknownKey(long unknownKeyId, ParcelableProxy parcelableProxy) {

        
        ServiceProgressHandler serviceHandler = new ServiceProgressHandler(getActivity()) {
            @Override
            public void handleMessage(Message message) {
                
                super.handleMessage(message);

                if (message.arg1 == MessageStatus.OKAY.ordinal()) {
                    
                    Bundle returnData = message.getData();

                    if (returnData == null) {
                        return;
                    }

                    final ImportKeyResult result =
                            returnData.getParcelable(OperationResult.EXTRA_RESULT);

                    result.createNotify(getActivity()).show();

                    getLoaderManager().restartLoader(LOADER_ID_UNIFIED, null, DecryptFragment.this);
                }
            }
        };

        
        Bundle data = new Bundle();

        
        {
            Preferences prefs = Preferences.getPreferences(getActivity());
            Preferences.CloudSearchPrefs cloudPrefs =
                    new Preferences.CloudSearchPrefs(true, true, prefs.getPreferredKeyserver());
            data.putString(KeychainService.IMPORT_KEY_SERVER, cloudPrefs.keyserver);
        }

        {
            ParcelableKeyRing keyEntry = new ParcelableKeyRing(null,
                    KeyFormattingUtils.convertKeyIdToHex(unknownKeyId), null);
            ArrayList<ParcelableKeyRing> selectedEntries = new ArrayList<>();
            selectedEntries.add(keyEntry);

            data.putParcelableArrayList(KeychainService.IMPORT_KEY_LIST, selectedEntries);
        }

        data.putParcelable(KeychainService.EXTRA_PARCELABLE_PROXY, parcelableProxy);

        
        Intent intent = new Intent(getActivity(), KeychainService.class);
        intent.setAction(KeychainService.ACTION_IMPORT_KEYRING);
        intent.putExtra(KeychainService.EXTRA_DATA, data);

        
        Messenger messenger = new Messenger(serviceHandler);
        intent.putExtra(KeychainService.EXTRA_MESSENGER, messenger);

        getActivity().startService(intent);
    }

    private void showKey(long keyId) {
        try {

            Intent viewKeyIntent = new Intent(getActivity(), ViewKeyActivity.class);
            long masterKeyId = new ProviderHelper(getActivity()).getCachedPublicKeyRing(
                    KeyRings.buildUnifiedKeyRingsFindBySubkeyUri(keyId)
            ).getMasterKeyId();
            viewKeyIntent.setData(KeyRings.buildGenericKeyRingUri(masterKeyId));
            startActivity(viewKeyIntent);

        } catch (PgpKeyNotFoundException e) {
            Notify.create(getActivity(), R.string.error_key_not_found, Style.ERROR);
        }
    }

    
    protected void loadVerifyResult(DecryptVerifyResult decryptVerifyResult) {

        mDecryptVerifyResult = decryptVerifyResult;
        mSignatureResult = decryptVerifyResult.getSignatureResult();

        mResultLayout.setVisibility(View.VISIBLE);

        
        if (mSignatureResult == null) {

            setSignatureLayoutVisibility(View.GONE);

            mSignatureText.setText(R.string.decrypt_result_no_signature);
            KeyFormattingUtils.setStatusImage(getActivity(), mSignatureIcon, mSignatureText, State.NOT_SIGNED);
            mEncryptionText.setText(R.string.decrypt_result_encrypted);
            KeyFormattingUtils.setStatusImage(getActivity(), mEncryptionIcon, mEncryptionText, State.ENCRYPTED);

            getLoaderManager().destroyLoader(LOADER_ID_UNIFIED);

            mErrorOverlayLayout.setVisibility(View.GONE);
            mContentLayout.setVisibility(View.VISIBLE);

            onVerifyLoaded(true);

            return;
        }

        if (mSignatureResult.isSignatureOnly()) {
            mEncryptionText.setText(R.string.decrypt_result_not_encrypted);
            KeyFormattingUtils.setStatusImage(getActivity(), mEncryptionIcon, mEncryptionText, State.NOT_ENCRYPTED);
        } else {
            mEncryptionText.setText(R.string.decrypt_result_encrypted);
            KeyFormattingUtils.setStatusImage(getActivity(), mEncryptionIcon, mEncryptionText, State.ENCRYPTED);
        }

        getLoaderManager().restartLoader(LOADER_ID_UNIFIED, null, this);
    }

    private void setSignatureLayoutVisibility(int visibility) {
        mSignatureLayout.setVisibility(visibility);
    }

    private void setShowAction(final long signatureKeyId) {
        mSignatureAction.setText(R.string.decrypt_result_action_show);
        mSignatureAction.setCompoundDrawablesWithIntrinsicBounds(0, 0, R.drawable.ic_vpn_key_grey_24dp, 0);
        mSignatureLayout.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                showKey(signatureKeyId);
            }
        });
    }

    
    static final String[] UNIFIED_PROJECTION = new String[]{
            KeychainContract.KeyRings._ID,
            KeychainContract.KeyRings.MASTER_KEY_ID,
            KeychainContract.KeyRings.USER_ID,
            KeychainContract.KeyRings.VERIFIED,
            KeychainContract.KeyRings.HAS_ANY_SECRET,
    };

    @SuppressWarnings("unused")
    static final int INDEX_MASTER_KEY_ID = 1;
    static final int INDEX_USER_ID = 2;
    static final int INDEX_VERIFIED = 3;
    static final int INDEX_HAS_ANY_SECRET = 4;

    @Override
    public Loader<Cursor> onCreateLoader(int id, Bundle args) {
        if (id != LOADER_ID_UNIFIED) {
            return null;
        }

        Uri baseUri = KeychainContract.KeyRings.buildUnifiedKeyRingsFindBySubkeyUri(
                mSignatureResult.getKeyId());
        return new CursorLoader(getActivity(), baseUri, UNIFIED_PROJECTION, null, null, null);
    }

    @Override
    public void onLoadFinished(Loader<Cursor> loader, Cursor data) {

        if (loader.getId() != LOADER_ID_UNIFIED) {
            return;
        }

        
        if (data.getCount() == 0 || !data.moveToFirst()) {
            showUnknownKeyStatus();
            return;
        }

        long signatureKeyId = mSignatureResult.getKeyId();

        String userId = data.getString(INDEX_USER_ID);
        KeyRing.UserId userIdSplit = KeyRing.splitUserId(userId);
        if (userIdSplit.name != null) {
            mSignatureName.setText(userIdSplit.name);
        } else {
            mSignatureName.setText(R.string.user_id_no_name);
        }
        if (userIdSplit.email != null) {
            mSignatureEmail.setText(userIdSplit.email);
        } else {
            mSignatureEmail.setText(KeyFormattingUtils.beautifyKeyIdWithPrefix(
                    getActivity(), mSignatureResult.getKeyId()));
        }

        
        
        boolean isRevoked = mSignatureResult.getStatus() == OpenPgpSignatureResult.SIGNATURE_KEY_REVOKED;
        boolean isExpired = mSignatureResult.getStatus() == OpenPgpSignatureResult.SIGNATURE_KEY_EXPIRED;
        boolean isVerified = data.getInt(INDEX_VERIFIED) > 0;
        boolean isYours = data.getInt(INDEX_HAS_ANY_SECRET) != 0;

        if (isRevoked) {
            mSignatureText.setText(R.string.decrypt_result_signature_revoked_key);
            KeyFormattingUtils.setStatusImage(getActivity(), mSignatureIcon, mSignatureText, State.REVOKED);

            setSignatureLayoutVisibility(View.VISIBLE);
            setShowAction(signatureKeyId);

            mErrorOverlayLayout.setVisibility(View.VISIBLE);
            mContentLayout.setVisibility(View.GONE);

            onVerifyLoaded(false);

        } else if (isExpired) {
            mSignatureText.setText(R.string.decrypt_result_signature_expired_key);
            KeyFormattingUtils.setStatusImage(getActivity(), mSignatureIcon, mSignatureText, State.EXPIRED);

            setSignatureLayoutVisibility(View.VISIBLE);
            setShowAction(signatureKeyId);

            mErrorOverlayLayout.setVisibility(View.GONE);
            mContentLayout.setVisibility(View.VISIBLE);

            onVerifyLoaded(true);

        } else if (isYours) {

            mSignatureText.setText(R.string.decrypt_result_signature_secret);
            KeyFormattingUtils.setStatusImage(getActivity(), mSignatureIcon, mSignatureText, State.VERIFIED);

            setSignatureLayoutVisibility(View.VISIBLE);
            setShowAction(signatureKeyId);

            mErrorOverlayLayout.setVisibility(View.GONE);
            mContentLayout.setVisibility(View.VISIBLE);

            onVerifyLoaded(true);

        } else if (isVerified) {
            mSignatureText.setText(R.string.decrypt_result_signature_certified);
            KeyFormattingUtils.setStatusImage(getActivity(), mSignatureIcon, mSignatureText, State.VERIFIED);

            setSignatureLayoutVisibility(View.VISIBLE);
            setShowAction(signatureKeyId);

            mErrorOverlayLayout.setVisibility(View.GONE);
            mContentLayout.setVisibility(View.VISIBLE);

            onVerifyLoaded(true);

        } else {
            mSignatureText.setText(R.string.decrypt_result_signature_uncertified);
            KeyFormattingUtils.setStatusImage(getActivity(), mSignatureIcon, mSignatureText, State.UNVERIFIED);

            setSignatureLayoutVisibility(View.VISIBLE);
            setShowAction(signatureKeyId);

            mErrorOverlayLayout.setVisibility(View.GONE);
            mContentLayout.setVisibility(View.VISIBLE);

            onVerifyLoaded(true);
        }

    }

    @Override
    public void onLoaderReset(Loader<Cursor> loader) {

        if (loader.getId() != LOADER_ID_UNIFIED) {
            return;
        }

        setSignatureLayoutVisibility(View.GONE);
    }

    private void showUnknownKeyStatus() {

        final long signatureKeyId = mSignatureResult.getKeyId();

        int result = mSignatureResult.getStatus();
        if (result != OpenPgpSignatureResult.SIGNATURE_KEY_MISSING
                && result != OpenPgpSignatureResult.SIGNATURE_ERROR) {
            Log.e(Constants.TAG, "got missing status for non-missing key, shouldn't happen!");
        }

        String userId = mSignatureResult.getPrimaryUserId();
        KeyRing.UserId userIdSplit = KeyRing.splitUserId(userId);
        if (userIdSplit.name != null) {
            mSignatureName.setText(userIdSplit.name);
        } else {
            mSignatureName.setText(R.string.user_id_no_name);
        }
        if (userIdSplit.email != null) {
            mSignatureEmail.setText(userIdSplit.email);
        } else {
            mSignatureEmail.setText(KeyFormattingUtils.beautifyKeyIdWithPrefix(
                    getActivity(), mSignatureResult.getKeyId()));
        }

        switch (mSignatureResult.getStatus()) {

            case OpenPgpSignatureResult.SIGNATURE_KEY_MISSING: {
                mSignatureText.setText(R.string.decrypt_result_signature_missing_key);
                KeyFormattingUtils.setStatusImage(getActivity(), mSignatureIcon, mSignatureText, State.UNKNOWN_KEY);

                setSignatureLayoutVisibility(View.VISIBLE);
                mSignatureAction.setText(R.string.decrypt_result_action_Lookup);
                mSignatureAction
                        .setCompoundDrawablesWithIntrinsicBounds(0, 0, R.drawable.ic_file_download_grey_24dp, 0);
                mSignatureLayout.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        final Preferences.ProxyPrefs proxyPrefs = Preferences.getPreferences(getActivity())
                                .getProxyPrefs();
                        Runnable ignoreTor = new Runnable() {
                            @Override
                            public void run() {
                                lookupUnknownKey(signatureKeyId, new ParcelableProxy(null, -1, null));
                            }
                        };

                        if (OrbotHelper.isOrbotInRequiredState(R.string.orbot_ignore_tor, ignoreTor, proxyPrefs,
                                getActivity())) {
                            lookupUnknownKey(signatureKeyId, proxyPrefs.parcelableProxy);
                        }
                    }
                });

                mErrorOverlayLayout.setVisibility(View.GONE);
                mContentLayout.setVisibility(View.VISIBLE);

                onVerifyLoaded(true);

                break;
            }

            case OpenPgpSignatureResult.SIGNATURE_ERROR: {
                mSignatureText.setText(R.string.decrypt_result_invalid_signature);
                KeyFormattingUtils.setStatusImage(getActivity(), mSignatureIcon, mSignatureText, State.INVALID);

                setSignatureLayoutVisibility(View.GONE);

                mErrorOverlayLayout.setVisibility(View.VISIBLE);
                mContentLayout.setVisibility(View.GONE);

                onVerifyLoaded(false);
                break;
            }

        }

    }

    protected abstract void onVerifyLoaded(boolean hideErrorOverlay);

}

<code block>


package org.sufficientlysecure.keychain.ui;

import android.animation.ArgbEvaluator;
import android.animation.ObjectAnimator;
import android.annotation.SuppressLint;
import android.app.Activity;
import android.app.ActivityOptions;
import android.content.Intent;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.os.Messenger;
import android.provider.ContactsContract;
import android.support.v4.app.ActivityCompat;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.LoaderManager;
import android.support.v4.content.CursorLoader;
import android.support.v4.content.Loader;
import android.support.v7.widget.CardView;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.animation.AlphaAnimation;
import android.view.animation.Animation;
import android.view.animation.Animation.AnimationListener;
import android.view.animation.AnimationUtils;
import android.widget.ImageButton;
import android.widget.ImageView;
import android.widget.RelativeLayout;
import android.widget.TextView;
import android.widget.Toast;
import com.getbase.floatingactionbutton.FloatingActionButton;
import org.sufficientlysecure.keychain.Constants;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.keyimport.ParcelableKeyRing;
import org.sufficientlysecure.keychain.operations.results.CertifyResult;
import org.sufficientlysecure.keychain.operations.results.ImportKeyResult;
import org.sufficientlysecure.keychain.operations.results.OperationResult;
import org.sufficientlysecure.keychain.pgp.KeyRing;
import org.sufficientlysecure.keychain.pgp.exception.PgpKeyNotFoundException;
import org.sufficientlysecure.keychain.provider.CachedPublicKeyRing;
import org.sufficientlysecure.keychain.provider.KeychainContract;
import org.sufficientlysecure.keychain.provider.KeychainContract.KeyRings;
import org.sufficientlysecure.keychain.provider.ProviderHelper;
import org.sufficientlysecure.keychain.service.KeychainService;
import org.sufficientlysecure.keychain.service.ServiceProgressHandler;
import org.sufficientlysecure.keychain.service.ServiceProgressHandler.MessageStatus;
import org.sufficientlysecure.keychain.service.PassphraseCacheService;
import org.sufficientlysecure.keychain.ui.base.BaseNfcActivity;
import org.sufficientlysecure.keychain.ui.dialog.DeleteKeyDialogFragment;
import org.sufficientlysecure.keychain.ui.util.FormattingUtils;
import org.sufficientlysecure.keychain.ui.util.KeyFormattingUtils;
import org.sufficientlysecure.keychain.ui.util.KeyFormattingUtils.State;
import org.sufficientlysecure.keychain.ui.util.Notify;
import org.sufficientlysecure.keychain.ui.util.Notify.ActionListener;
import org.sufficientlysecure.keychain.ui.util.Notify.Style;
import org.sufficientlysecure.keychain.ui.util.QrCodeUtils;
import org.sufficientlysecure.keychain.util.ContactHelper;
import org.sufficientlysecure.keychain.util.ExportHelper;
import org.sufficientlysecure.keychain.util.Log;
import org.sufficientlysecure.keychain.util.NfcHelper;
import org.sufficientlysecure.keychain.util.ParcelableProxy;
import org.sufficientlysecure.keychain.util.Preferences;
import org.sufficientlysecure.keychain.util.tor.OrbotHelper;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;

public class ViewKeyActivity extends BaseNfcActivity implements
        LoaderManager.LoaderCallbacks<Cursor> {

    public static final String EXTRA_NFC_USER_ID = "nfc_user_id";
    public static final String EXTRA_NFC_AID = "nfc_aid";
    public static final String EXTRA_NFC_FINGERPRINTS = "nfc_fingerprints";

    static final int REQUEST_QR_FINGERPRINT = 1;
    static final int REQUEST_DELETE = 2;
    static final int REQUEST_EXPORT = 3;
    public static final String EXTRA_DISPLAY_RESULT = "display_result";

    ExportHelper mExportHelper;
    ProviderHelper mProviderHelper;

    protected Uri mDataUri;

    private TextView mName;
    private TextView mStatusText;
    private ImageView mStatusImage;
    private RelativeLayout mBigToolbar;

    private ImageButton mActionEncryptFile;
    private ImageButton mActionEncryptText;
    private ImageButton mActionNfc;
    private FloatingActionButton mFab;
    private ImageView mPhoto;
    private ImageView mQrCode;
    private CardView mQrCodeLayout;

    private String mQrCodeLoaded;

    
    private NfcHelper mNfcHelper;

    private static final int LOADER_ID_UNIFIED = 0;

    private boolean mIsSecret = false;
    private boolean mHasEncrypt = false;
    private boolean mIsVerified = false;
    private boolean mIsRevoked = false;
    private boolean mIsExpired = false;

    private boolean mShowYubikeyAfterCreation = false;

    private MenuItem mRefreshItem;
    private boolean mIsRefreshing;
    private Animation mRotate, mRotateSpin;
    private View mRefresh;
    private String mFingerprint;
    private long mMasterKeyId;

    @SuppressLint("InflateParams")
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        mExportHelper = new ExportHelper(this);
        mProviderHelper = new ProviderHelper(this);

        setTitle(null);

        mName = (TextView) findViewById(R.id.view_key_name);
        mStatusText = (TextView) findViewById(R.id.view_key_status);
        mStatusImage = (ImageView) findViewById(R.id.view_key_status_image);
        mBigToolbar = (RelativeLayout) findViewById(R.id.toolbar_big);

        mActionEncryptFile = (ImageButton) findViewById(R.id.view_key_action_encrypt_files);
        mActionEncryptText = (ImageButton) findViewById(R.id.view_key_action_encrypt_text);
        mActionNfc = (ImageButton) findViewById(R.id.view_key_action_nfc);
        mFab = (FloatingActionButton) findViewById(R.id.fab);
        mPhoto = (ImageView) findViewById(R.id.view_key_photo);
        mQrCode = (ImageView) findViewById(R.id.view_key_qr_code);
        mQrCodeLayout = (CardView) findViewById(R.id.view_key_qr_code_layout);

        mRotateSpin = AnimationUtils.loadAnimation(this, R.anim.rotate_spin);
        mRotateSpin.setAnimationListener(new AnimationListener() {
            @Override
            public void onAnimationStart(Animation animation) {

            }

            @Override
            public void onAnimationEnd(Animation animation) {
                mRefreshItem.getActionView().clearAnimation();
                mRefreshItem.setActionView(null);
                mRefreshItem.setEnabled(true);

                
                supportInvalidateOptionsMenu();
            }

            @Override
            public void onAnimationRepeat(Animation animation) {

            }
        });
        mRotate = AnimationUtils.loadAnimation(this, R.anim.rotate);
        mRotate.setRepeatCount(Animation.INFINITE);
        mRotate.setAnimationListener(new Animation.AnimationListener() {
            @Override
            public void onAnimationStart(Animation animation) {

            }

            @Override
            public void onAnimationEnd(Animation animation) {

            }

            @Override
            public void onAnimationRepeat(Animation animation) {
                if (!mIsRefreshing) {
                    mRefreshItem.getActionView().clearAnimation();
                    mRefreshItem.getActionView().startAnimation(mRotateSpin);
                }
            }
        });
        mRefresh = getLayoutInflater().inflate(R.layout.indeterminate_progress, null);

        mDataUri = getIntent().getData();
        if (mDataUri == null) {
            Log.e(Constants.TAG, "Data missing. Should be uri of key!");
            finish();
            return;
        }
        if (mDataUri.getHost().equals(ContactsContract.AUTHORITY)) {
            mDataUri = ContactHelper.dataUriFromContactUri(this, mDataUri);
            if (mDataUri == null) {
                Log.e(Constants.TAG, "Contact Data missing. Should be uri of key!");
                Toast.makeText(this, R.string.error_contacts_key_id_missing, Toast.LENGTH_LONG).show();
                finish();
                return;
            }
        }

        Log.i(Constants.TAG, "mDataUri: " + mDataUri);

        mActionEncryptFile.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                encrypt(mDataUri, false);
            }
        });
        mActionEncryptText.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                encrypt(mDataUri, true);
            }
        });

        mFab.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                if (mIsSecret) {
                    startSafeSlinger(mDataUri);
                } else {
                    scanQrCode();
                }
            }
        });

        mQrCodeLayout.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                showQrCodeDialog();
            }
        });

        mActionNfc.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                mNfcHelper.invokeNfcBeam();
            }
        });

        
        
        getSupportLoaderManager().initLoader(LOADER_ID_UNIFIED, null, this);

        mNfcHelper = new NfcHelper(this, mProviderHelper);
        mNfcHelper.initNfc(mDataUri);

        if (savedInstanceState == null && getIntent().hasExtra(EXTRA_DISPLAY_RESULT)) {
            OperationResult result = getIntent().getParcelableExtra(EXTRA_DISPLAY_RESULT);
            result.createNotify(this).show();
        }

        
        if (savedInstanceState != null) {
            return;
        }

        FragmentManager manager = getSupportFragmentManager();
        
        final ViewKeyFragment frag = ViewKeyFragment.newInstance(mDataUri);
        manager.beginTransaction()
                .replace(R.id.view_key_fragment, frag)
                .commit();

        
        
        mShowYubikeyAfterCreation = true;

    }

    @Override
    protected void initLayout() {
        setContentView(R.layout.view_key_activity);
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        super.onCreateOptionsMenu(menu);
        getMenuInflater().inflate(R.menu.key_view, menu);
        mRefreshItem = menu.findItem(R.id.menu_key_view_refresh);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home: {
                Intent homeIntent = new Intent(this, MainActivity.class);
                homeIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
                startActivity(homeIntent);
                return true;
            }
            case R.id.menu_key_view_export_file: {
                try {
                    if (PassphraseCacheService.getCachedPassphrase(this, mMasterKeyId, mMasterKeyId) != null) {
                        exportToFile(mDataUri, mExportHelper, mProviderHelper);
                        return true;
                    }

                    startPassphraseActivity(REQUEST_EXPORT);
                } catch (PassphraseCacheService.KeyNotFoundException e) {
                    
                    exportToFile(mDataUri, mExportHelper, mProviderHelper);
                }
                return true;
            }
            case R.id.menu_key_view_delete: {
                try {
                    if (PassphraseCacheService.getCachedPassphrase(this, mMasterKeyId, mMasterKeyId) != null) {
                        deleteKey();
                        return true;
                    }

                    startPassphraseActivity(REQUEST_DELETE);
                } catch (PassphraseCacheService.KeyNotFoundException e) {
                    
                    deleteKey();
                }
                return true;
            }
            case R.id.menu_key_view_advanced: {
                Intent advancedIntent = new Intent(this, ViewKeyAdvActivity.class);
                advancedIntent.setData(mDataUri);
                startActivity(advancedIntent);
                return true;
            }
            case R.id.menu_key_view_refresh: {
                try {
                    final Preferences.ProxyPrefs proxyPrefs = Preferences.getPreferences(this).getProxyPrefs();
                    Runnable ignoreTor = new Runnable() {
                        @Override
                        public void run() {
                            try {
                                updateFromKeyserver(mDataUri, mProviderHelper, new ParcelableProxy(null, -1, null));
                            } catch (ProviderHelper.NotFoundException e) {
                                Notify.create(ViewKeyActivity.this, R.string.error_key_not_found, Notify.Style.ERROR)
                                        .show();
                            }
                        }
                    };

                    if (OrbotHelper.isOrbotInRequiredState(R.string.orbot_ignore_tor, ignoreTor, proxyPrefs, this)) {
                        updateFromKeyserver(mDataUri, mProviderHelper, proxyPrefs.parcelableProxy);
                    }
                } catch (ProviderHelper.NotFoundException e) {
                    Notify.create(this, R.string.error_key_not_found, Notify.Style.ERROR).show();
                }
                return true;
            }
            case R.id.menu_key_view_edit: {
                editKey(mDataUri);
                return true;
            }
            case R.id.menu_key_view_certify_fingerprint: {
                certifyFingeprint(mDataUri);
                return true;
            }
        }
        return super.onOptionsItemSelected(item);
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        MenuItem editKey = menu.findItem(R.id.menu_key_view_edit);
        editKey.setVisible(mIsSecret);
        MenuItem certifyFingerprint = menu.findItem(R.id.menu_key_view_certify_fingerprint);
        certifyFingerprint.setVisible(!mIsSecret && !mIsVerified && !mIsExpired && !mIsRevoked);

        return true;
    }


    private void scanQrCode() {
        Intent scanQrCode = new Intent(this, ImportKeysProxyActivity.class);
        scanQrCode.setAction(ImportKeysProxyActivity.ACTION_SCAN_WITH_RESULT);
        startActivityForResult(scanQrCode, REQUEST_QR_FINGERPRINT);
    }

    private void certifyFingeprint(Uri dataUri) {
        Intent intent = new Intent(this, CertifyFingerprintActivity.class);
        intent.setData(dataUri);

        startCertifyIntent(intent);
    }

    private void certifyImmediate() {
        Intent intent = new Intent(this, CertifyKeyActivity.class);
        intent.putExtra(CertifyKeyActivity.EXTRA_KEY_IDS, new long[]{mMasterKeyId});

        startCertifyIntent(intent);
    }

    private void startCertifyIntent(Intent intent) {
        
        ServiceProgressHandler saveHandler = new ServiceProgressHandler(this) {
            @Override
            public void handleMessage(Message message) {
                
                super.handleMessage(message);

                if (message.arg1 == MessageStatus.OKAY.ordinal()) {
                    Bundle data = message.getData();
                    CertifyResult result = data.getParcelable(CertifyResult.EXTRA_RESULT);

                    result.createNotify(ViewKeyActivity.this).show();
                }
            }
        };
        
        Messenger messenger = new Messenger(saveHandler);
        intent.putExtra(KeychainService.EXTRA_MESSENGER, messenger);

        startActivityForResult(intent, 0);
    }

    private void showQrCodeDialog() {
        Intent qrCodeIntent = new Intent(this, QrCodeViewActivity.class);

        
        
        Bundle opts = null;
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            ActivityOptions options = ActivityOptions
                    .makeSceneTransitionAnimation(this, mQrCodeLayout, "qr_code");
            opts = options.toBundle();
        }

        qrCodeIntent.setData(mDataUri);
        ActivityCompat.startActivity(this, qrCodeIntent, opts);
    }

    private void startPassphraseActivity(int requestCode) {
        Intent intent = new Intent(this, PassphraseDialogActivity.class);
        intent.putExtra(PassphraseDialogActivity.EXTRA_SUBKEY_ID, mMasterKeyId);
        startActivityForResult(intent, requestCode);
    }

    private void exportToFile(Uri dataUri, ExportHelper exportHelper, ProviderHelper providerHelper) {
        try {
            Uri baseUri = KeychainContract.KeyRings.buildUnifiedKeyRingUri(dataUri);

            HashMap<String, Object> data = providerHelper.getGenericData(
                    baseUri,
                    new String[]{KeychainContract.Keys.MASTER_KEY_ID, KeychainContract.KeyRings.HAS_SECRET},
                    new int[]{ProviderHelper.FIELD_TYPE_INTEGER, ProviderHelper.FIELD_TYPE_INTEGER});

            exportHelper.showExportKeysDialog(
                    new long[]{(Long) data.get(KeychainContract.KeyRings.MASTER_KEY_ID)},
                    Constants.Path.APP_DIR_FILE, ((Long) data.get(KeychainContract.KeyRings.HAS_SECRET) != 0)
            );
        } catch (ProviderHelper.NotFoundException e) {
            Notify.create(this, R.string.error_key_not_found, Notify.Style.ERROR).show();
            Log.e(Constants.TAG, "Key not found", e);
        }
    }

    private void deleteKey() {
        
        Handler returnHandler = new Handler() {
            @Override
            public void handleMessage(Message message) {
                if (message.arg1 == MessageStatus.OKAY.ordinal()) {
                    setResult(RESULT_CANCELED);
                    finish();
                }
            }
        };

        
        Messenger messenger = new Messenger(returnHandler);
        DeleteKeyDialogFragment deleteKeyDialog = DeleteKeyDialogFragment.newInstance(messenger,
                new long[]{mMasterKeyId});
        deleteKeyDialog.show(getSupportFragmentManager(), "deleteKeyDialog");
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (requestCode == REQUEST_QR_FINGERPRINT && resultCode == Activity.RESULT_OK) {

            
            if (data.hasExtra(OperationResult.EXTRA_RESULT)) {
                OperationResult result = data.getParcelableExtra(OperationResult.EXTRA_RESULT);
                result.createNotify(this).show();
                return;
            }

            String fp = data.getStringExtra(ImportKeysProxyActivity.EXTRA_FINGERPRINT);
            if (fp == null) {
                Notify.create(this, "Error scanning fingerprint!",
                        Notify.LENGTH_LONG, Notify.Style.ERROR).show();
                return;
            }
            if (mFingerprint.equalsIgnoreCase(fp)) {
                certifyImmediate();
            } else {
                Notify.create(this, "Fingerprints did not match!",
                        Notify.LENGTH_LONG, Notify.Style.ERROR).show();
            }

            return;
        }

        if (requestCode == REQUEST_DELETE && resultCode == Activity.RESULT_OK) {
            deleteKey();
        }

        if (requestCode == REQUEST_EXPORT && resultCode == Activity.RESULT_OK) {
            exportToFile(mDataUri, mExportHelper, mProviderHelper);
        }

        if (data != null && data.hasExtra(OperationResult.EXTRA_RESULT)) {
            OperationResult result = data.getParcelableExtra(OperationResult.EXTRA_RESULT);
            result.createNotify(this).show();
        } else {
            super.onActivityResult(requestCode, resultCode, data);
        }
    }

    @Override
    protected void onNfcPerform() throws IOException {

        final byte[] nfcFingerprints = nfcGetFingerprints();
        final String nfcUserId = nfcGetUserId();
        final byte[] nfcAid = nfcGetAid();

        long yubiKeyId = KeyFormattingUtils.getKeyIdFromFingerprint(nfcFingerprints);

        try {

            
            CachedPublicKeyRing ring = mProviderHelper.getCachedPublicKeyRing(
                    KeyRings.buildUnifiedKeyRingsFindBySubkeyUri(yubiKeyId));
            byte[] candidateFp = ring.getFingerprint();

            
            if (KeyFormattingUtils.convertFingerprintToHex(candidateFp).equals(mFingerprint)) {
                showYubiKeyFragment(nfcFingerprints, nfcUserId, nfcAid);
                return;
            }

            
            final long masterKeyId = KeyFormattingUtils.getKeyIdFromFingerprint(candidateFp);
            Notify.create(this, R.string.snack_yubi_other, Notify.LENGTH_LONG,
                    Style.WARN, new ActionListener() {
                        @Override
                        public void onAction() {
                            Intent intent = new Intent(
                                    ViewKeyActivity.this, ViewKeyActivity.class);
                            intent.setData(KeyRings.buildGenericKeyRingUri(masterKeyId));
                            intent.putExtra(ViewKeyActivity.EXTRA_NFC_AID, nfcAid);
                            intent.putExtra(ViewKeyActivity.EXTRA_NFC_USER_ID, nfcUserId);
                            intent.putExtra(ViewKeyActivity.EXTRA_NFC_FINGERPRINTS, nfcFingerprints);
                            startActivity(intent);
                            finish();
                        }
                    }, R.string.snack_yubikey_view).show();

            
        } catch (PgpKeyNotFoundException e) {
            Notify.create(this, R.string.snack_yubi_other, Notify.LENGTH_LONG,
                    Style.WARN, new ActionListener() {
                        @Override
                        public void onAction() {
                            Intent intent = new Intent(
                                    ViewKeyActivity.this, CreateKeyActivity.class);
                            intent.putExtra(ViewKeyActivity.EXTRA_NFC_AID, nfcAid);
                            intent.putExtra(ViewKeyActivity.EXTRA_NFC_USER_ID, nfcUserId);
                            intent.putExtra(ViewKeyActivity.EXTRA_NFC_FINGERPRINTS, nfcFingerprints);
                            startActivity(intent);
                            finish();
                        }
                    }, R.string.snack_yubikey_import).show();
        }

    }

    public void showYubiKeyFragment(
            final byte[] nfcFingerprints, final String nfcUserId, final byte[] nfcAid) {

        new Handler().post(new Runnable() {
            @Override
            public void run() {
                ViewKeyYubiKeyFragment frag = ViewKeyYubiKeyFragment.newInstance(
                        mMasterKeyId, nfcFingerprints, nfcUserId, nfcAid);

                FragmentManager manager = getSupportFragmentManager();

                manager.popBackStack("yubikey", FragmentManager.POP_BACK_STACK_INCLUSIVE);
                manager.beginTransaction()
                        .addToBackStack("yubikey")
                        .replace(R.id.view_key_fragment, frag)
                                
                        .commitAllowingStateLoss();
            }
        });

    }

    private void encrypt(Uri dataUri, boolean text) {
        
        if (!mHasEncrypt) {
            Notify.create(this, R.string.error_no_encrypt_subkey, Notify.Style.ERROR).show();
            return;
        }
        try {
            long keyId = new ProviderHelper(this)
                    .getCachedPublicKeyRing(dataUri)
                    .extractOrGetMasterKeyId();
            long[] encryptionKeyIds = new long[]{keyId};
            Intent intent;
            if (text) {
                intent = new Intent(this, EncryptTextActivity.class);
                intent.setAction(EncryptTextActivity.ACTION_ENCRYPT_TEXT);
                intent.putExtra(EncryptTextActivity.EXTRA_ENCRYPTION_KEY_IDS, encryptionKeyIds);
            } else {
                intent = new Intent(this, EncryptFilesActivity.class);
                intent.setAction(EncryptFilesActivity.ACTION_ENCRYPT_DATA);
                intent.putExtra(EncryptFilesActivity.EXTRA_ENCRYPTION_KEY_IDS, encryptionKeyIds);
            }
            
            startActivityForResult(intent, 0);
        } catch (PgpKeyNotFoundException e) {
            Log.e(Constants.TAG, "key not found!", e);
        }
    }

    private void updateFromKeyserver(Uri dataUri, ProviderHelper providerHelper, ParcelableProxy parcelableProxy)
            throws ProviderHelper.NotFoundException {

        mIsRefreshing = true;
        mRefreshItem.setEnabled(false);
        mRefreshItem.setActionView(mRefresh);
        mRefresh.startAnimation(mRotate);

        byte[] blob = (byte[]) providerHelper.getGenericData(
                KeychainContract.KeyRings.buildUnifiedKeyRingUri(dataUri),
                KeychainContract.Keys.FINGERPRINT, ProviderHelper.FIELD_TYPE_BLOB);
        String fingerprint = KeyFormattingUtils.convertFingerprintToHex(blob);

        ParcelableKeyRing keyEntry = new ParcelableKeyRing(fingerprint, null, null);
        ArrayList<ParcelableKeyRing> entries = new ArrayList<>();
        entries.add(keyEntry);

        
        ServiceProgressHandler serviceHandler = new ServiceProgressHandler(this) {
            @Override
            public void handleMessage(Message message) {
                
                super.handleMessage(message);

                if (message.arg1 == MessageStatus.OKAY.ordinal()) {
                    
                    Bundle returnData = message.getData();

                    mIsRefreshing = false;

                    if (returnData == null) {
                        finish();
                        return;
                    }
                    final ImportKeyResult result =
                            returnData.getParcelable(OperationResult.EXTRA_RESULT);
                    result.createNotify(ViewKeyActivity.this).show();
                }
            }
        };

        
        Bundle data = new Bundle();

        
        {
            Preferences prefs = Preferences.getPreferences(this);
            Preferences.CloudSearchPrefs cloudPrefs =
                    new Preferences.CloudSearchPrefs(true, true, prefs.getPreferredKeyserver());
            data.putString(KeychainService.IMPORT_KEY_SERVER, cloudPrefs.keyserver);
        }

        data.putParcelableArrayList(KeychainService.IMPORT_KEY_LIST, entries);

        data.putParcelable(KeychainService.EXTRA_PARCELABLE_PROXY, parcelableProxy);

        
        Intent intent = new Intent(this, KeychainService.class);
        intent.setAction(KeychainService.ACTION_IMPORT_KEYRING);
        intent.putExtra(KeychainService.EXTRA_DATA, data);

        
        Messenger messenger = new Messenger(serviceHandler);
        intent.putExtra(KeychainService.EXTRA_MESSENGER, messenger);

        
        startService(intent);

    }

    private void editKey(Uri dataUri) {
        Intent editIntent = new Intent(this, EditKeyActivity.class);
        editIntent.setData(KeychainContract.KeyRingData.buildSecretKeyRingUri(dataUri));
        startActivityForResult(editIntent, 0);
    }

    private void startSafeSlinger(Uri dataUri) {
        long keyId = 0;
        try {
            keyId = new ProviderHelper(this)
                    .getCachedPublicKeyRing(dataUri)
                    .extractOrGetMasterKeyId();
        } catch (PgpKeyNotFoundException e) {
            Log.e(Constants.TAG, "key not found!", e);
        }
        Intent safeSlingerIntent = new Intent(this, SafeSlingerActivity.class);
        safeSlingerIntent.putExtra(SafeSlingerActivity.EXTRA_MASTER_KEY_ID, keyId);
        startActivityForResult(safeSlingerIntent, 0);
    }

    
    private void loadQrCode(final String fingerprint) {
        AsyncTask<Void, Void, Bitmap> loadTask =
                new AsyncTask<Void, Void, Bitmap>() {
                    protected Bitmap doInBackground(Void... unused) {
                        Uri uri = new Uri.Builder()
                                .scheme(Constants.FINGERPRINT_SCHEME)
                                .opaquePart(fingerprint)
                                .build();
                        
                        return QrCodeUtils.getQRCodeBitmap(uri, 0);
                    }

                    protected void onPostExecute(Bitmap qrCode) {
                        mQrCodeLoaded = fingerprint;
                        
                        
                        Bitmap scaled = Bitmap.createScaledBitmap(qrCode,
                                mQrCode.getHeight(), mQrCode.getHeight(),
                                false);
                        mQrCode.setImageBitmap(scaled);

                        
                        AlphaAnimation anim = new AlphaAnimation(0.0f, 1.0f);
                        anim.setDuration(200);
                        mQrCode.startAnimation(anim);
                    }
                };

        loadTask.execute();
    }


    
    static final String[] PROJECTION = new String[]{
            KeychainContract.KeyRings._ID,
            KeychainContract.KeyRings.MASTER_KEY_ID,
            KeychainContract.KeyRings.USER_ID,
            KeychainContract.KeyRings.IS_REVOKED,
            KeychainContract.KeyRings.IS_EXPIRED,
            KeychainContract.KeyRings.VERIFIED,
            KeychainContract.KeyRings.HAS_ANY_SECRET,
            KeychainContract.KeyRings.FINGERPRINT,
            KeychainContract.KeyRings.HAS_ENCRYPT
    };

    static final int INDEX_MASTER_KEY_ID = 1;
    static final int INDEX_USER_ID = 2;
    static final int INDEX_IS_REVOKED = 3;
    static final int INDEX_IS_EXPIRED = 4;
    static final int INDEX_VERIFIED = 5;
    static final int INDEX_HAS_ANY_SECRET = 6;
    static final int INDEX_FINGERPRINT = 7;
    static final int INDEX_HAS_ENCRYPT = 8;

    @Override
    public Loader<Cursor> onCreateLoader(int id, Bundle args) {
        switch (id) {
            case LOADER_ID_UNIFIED: {
                Uri baseUri = KeychainContract.KeyRings.buildUnifiedKeyRingUri(mDataUri);
                return new CursorLoader(this, baseUri, PROJECTION, null, null, null);
            }

            default:
                return null;
        }
    }

    int mPreviousColor = 0;

    @Override
    public void onLoadFinished(Loader<Cursor> loader, Cursor data) {
        
        
        if (data.getCount() == 0) {
            return;
        }
        
        
        switch (loader.getId()) {
            case LOADER_ID_UNIFIED: {

                if (data.moveToFirst()) {
                    
                    KeyRing.UserId mainUserId = KeyRing.splitUserId(data.getString(INDEX_USER_ID));
                    if (mainUserId.name != null) {
                        mName.setText(mainUserId.name);
                    } else {
                        mName.setText(R.string.user_id_no_name);
                    }

                    mMasterKeyId = data.getLong(INDEX_MASTER_KEY_ID);
                    mFingerprint = KeyFormattingUtils.convertFingerprintToHex(data.getBlob(INDEX_FINGERPRINT));

                    
                    if (mShowYubikeyAfterCreation && getIntent().hasExtra(EXTRA_NFC_AID)) {
                        mShowYubikeyAfterCreation = false;
                        Intent intent = getIntent();
                        byte[] nfcFingerprints = intent.getByteArrayExtra(EXTRA_NFC_FINGERPRINTS);
                        String nfcUserId = intent.getStringExtra(EXTRA_NFC_USER_ID);
                        byte[] nfcAid = intent.getByteArrayExtra(EXTRA_NFC_AID);
                        showYubiKeyFragment(nfcFingerprints, nfcUserId, nfcAid);
                    }

                    mIsSecret = data.getInt(INDEX_HAS_ANY_SECRET) != 0;
                    mHasEncrypt = data.getInt(INDEX_HAS_ENCRYPT) != 0;
                    mIsRevoked = data.getInt(INDEX_IS_REVOKED) > 0;
                    mIsExpired = data.getInt(INDEX_IS_EXPIRED) != 0;
                    mIsVerified = data.getInt(INDEX_VERIFIED) > 0;

                    
                    if (!mRotate.hasStarted() && !mRotateSpin.hasStarted()) {
                        
                        supportInvalidateOptionsMenu();
                        
                    }

                    AsyncTask<Long, Void, Bitmap> photoTask =
                            new AsyncTask<Long, Void, Bitmap>() {
                                protected Bitmap doInBackground(Long... mMasterKeyId) {
                                    return ContactHelper.loadPhotoByMasterKeyId(getContentResolver(),
                                            mMasterKeyId[0], true);
                                }

                                protected void onPostExecute(Bitmap photo) {
                                    mPhoto.setImageBitmap(photo);
                                    mPhoto.setVisibility(View.VISIBLE);
                                }
                            };

                    
                    int color;
                    if (mIsRevoked) {
                        mStatusText.setText(R.string.view_key_revoked);
                        mStatusImage.setVisibility(View.VISIBLE);
                        KeyFormattingUtils.setStatusImage(this, mStatusImage, mStatusText,
                                State.REVOKED, R.color.icons, true);
                        color = getResources().getColor(R.color.android_red_light);

                        mActionEncryptFile.setVisibility(View.GONE);
                        mActionEncryptText.setVisibility(View.GONE);
                        mActionNfc.setVisibility(View.GONE);
                        mFab.setVisibility(View.GONE);
                        mQrCodeLayout.setVisibility(View.GONE);
                    } else if (mIsExpired) {
                        if (mIsSecret) {
                            mStatusText.setText(R.string.view_key_expired_secret);
                        } else {
                            mStatusText.setText(R.string.view_key_expired);
                        }
                        mStatusImage.setVisibility(View.VISIBLE);
                        KeyFormattingUtils.setStatusImage(this, mStatusImage, mStatusText,
                                State.EXPIRED, R.color.icons, true);
                        color = getResources().getColor(R.color.android_red_light);

                        mActionEncryptFile.setVisibility(View.GONE);
                        mActionEncryptText.setVisibility(View.GONE);
                        mActionNfc.setVisibility(View.GONE);
                        mFab.setVisibility(View.GONE);
                        mQrCodeLayout.setVisibility(View.GONE);
                    } else if (mIsSecret) {
                        mStatusText.setText(R.string.view_key_my_key);
                        mStatusImage.setVisibility(View.GONE);
                        color = getResources().getColor(R.color.primary);
                        
                        if (!mFingerprint.equals(mQrCodeLoaded)) {
                            loadQrCode(mFingerprint);
                        }
                        photoTask.execute(mMasterKeyId);
                        mQrCodeLayout.setVisibility(View.VISIBLE);

                        
                        RelativeLayout.LayoutParams nameParams = (RelativeLayout.LayoutParams)
                                mName.getLayoutParams();
                        
                        nameParams.setMargins(FormattingUtils.dpToPx(this, 48), 0, 0, 0);
                        if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
                            nameParams.setMarginEnd(0);
                        }
                        nameParams.addRule(RelativeLayout.LEFT_OF, R.id.view_key_qr_code_layout);
                        mName.setLayoutParams(nameParams);

                        RelativeLayout.LayoutParams statusParams = (RelativeLayout.LayoutParams)
                                mStatusText.getLayoutParams();
                        statusParams.setMargins(FormattingUtils.dpToPx(this, 48), 0, 0, 0);
                        if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
                            statusParams.setMarginEnd(0);
                        }
                        statusParams.addRule(RelativeLayout.LEFT_OF, R.id.view_key_qr_code_layout);
                        mStatusText.setLayoutParams(statusParams);

                        mActionEncryptFile.setVisibility(View.VISIBLE);
                        mActionEncryptText.setVisibility(View.VISIBLE);

                        
                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                            mActionNfc.setVisibility(View.VISIBLE);
                        } else {
                            mActionNfc.setVisibility(View.GONE);
                        }
                        mFab.setVisibility(View.VISIBLE);
                        mFab.setIconDrawable(getResources().getDrawable(R.drawable.ic_repeat_white_24dp));
                    } else {
                        mActionEncryptFile.setVisibility(View.VISIBLE);
                        mActionEncryptText.setVisibility(View.VISIBLE);
                        mQrCodeLayout.setVisibility(View.GONE);
                        mActionNfc.setVisibility(View.GONE);

                        if (mIsVerified) {
                            mStatusText.setText(R.string.view_key_verified);
                            mStatusImage.setVisibility(View.VISIBLE);
                            KeyFormattingUtils.setStatusImage(this, mStatusImage, mStatusText,
                                    State.VERIFIED, R.color.icons, true);
                            color = getResources().getColor(R.color.primary);
                            photoTask.execute(mMasterKeyId);

                            mFab.setVisibility(View.GONE);
                        } else {
                            mStatusText.setText(R.string.view_key_unverified);
                            mStatusImage.setVisibility(View.VISIBLE);
                            KeyFormattingUtils.setStatusImage(this, mStatusImage, mStatusText,
                                    State.UNVERIFIED, R.color.icons, true);
                            color = getResources().getColor(R.color.android_orange_light);

                            mFab.setVisibility(View.VISIBLE);
                        }
                    }

                    if (mPreviousColor == 0 || mPreviousColor == color) {
                        mStatusBar.setBackgroundColor(color);
                        mBigToolbar.setBackgroundColor(color);
                        mPreviousColor = color;
                    } else {
                        ObjectAnimator colorFade1 =
                                ObjectAnimator.ofObject(mStatusBar, "backgroundColor",
                                        new ArgbEvaluator(), mPreviousColor, color);
                        ObjectAnimator colorFade2 =
                                ObjectAnimator.ofObject(mBigToolbar, "backgroundColor",
                                        new ArgbEvaluator(), mPreviousColor, color);

                        colorFade1.setDuration(1200);
                        colorFade2.setDuration(1200);
                        colorFade1.start();
                        colorFade2.start();
                        mPreviousColor = color;
                    }

                    
                    mStatusImage.setAlpha(80);

                    break;
                }
            }
        }
    }

    @Override
    public void onLoaderReset(Loader<Cursor> loader) {

    }
}
<code block>


package org.sufficientlysecure.keychain.ui;

import android.app.Activity;
import android.content.Intent;
import android.database.Cursor;
import android.database.MatrixCursor;
import android.graphics.PorterDuff;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.os.Messenger;
import android.os.Parcel;
import android.support.v4.app.LoaderManager;
import android.support.v4.content.CursorLoader;
import android.support.v4.content.Loader;
import android.view.LayoutInflater;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.CheckBox;
import android.widget.ImageView;
import android.widget.ListView;

import org.sufficientlysecure.keychain.Constants;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.operations.results.CertifyResult;
import org.sufficientlysecure.keychain.operations.results.OperationResult;
import org.sufficientlysecure.keychain.pgp.KeyRing;
import org.sufficientlysecure.keychain.pgp.exception.PgpKeyNotFoundException;
import org.sufficientlysecure.keychain.provider.CachedPublicKeyRing;
import org.sufficientlysecure.keychain.provider.KeychainContract.UserPackets;
import org.sufficientlysecure.keychain.provider.KeychainDatabase.Tables;
import org.sufficientlysecure.keychain.provider.ProviderHelper;
import org.sufficientlysecure.keychain.service.CertifyActionsParcel;
import org.sufficientlysecure.keychain.service.CertifyActionsParcel.CertifyAction;
import org.sufficientlysecure.keychain.ui.adapter.MultiUserIdsAdapter;
import org.sufficientlysecure.keychain.ui.base.CachingCryptoOperationFragment;
import org.sufficientlysecure.keychain.ui.util.Notify;
import org.sufficientlysecure.keychain.ui.widget.CertifyKeySpinner;
import org.sufficientlysecure.keychain.util.Log;
import org.sufficientlysecure.keychain.util.Preferences;
import org.sufficientlysecure.keychain.util.tor.OrbotHelper;

import java.util.ArrayList;

public class CertifyKeyFragment
        extends CachingCryptoOperationFragment<CertifyActionsParcel, CertifyResult>
        implements LoaderManager.LoaderCallbacks<Cursor> {

    public static final String ARG_CHECK_STATES = "check_states";

    private CheckBox mUploadKeyCheckbox;
    ListView mUserIds;

    private CertifyKeySpinner mCertifyKeySpinner;

    private long[] mPubMasterKeyIds;

    public static final String[] USER_IDS_PROJECTION = new String[]{
            UserPackets._ID,
            UserPackets.MASTER_KEY_ID,
            UserPackets.USER_ID,
            UserPackets.IS_PRIMARY,
            UserPackets.IS_REVOKED
    };
    private static final int INDEX_MASTER_KEY_ID = 1;
    private static final int INDEX_USER_ID = 2;
    private static final int INDEX_IS_PRIMARY = 3;
    private static final int INDEX_IS_REVOKED = 4;

    private MultiUserIdsAdapter mUserIdsAdapter;
    private Preferences.ProxyPrefs mProxyPrefs;

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        mProxyPrefs = Preferences.getPreferences(getActivity()).getProxyPrefs();

        mPubMasterKeyIds = getActivity().getIntent().getLongArrayExtra(CertifyKeyActivity.EXTRA_KEY_IDS);
        if (mPubMasterKeyIds == null) {
            Log.e(Constants.TAG, "List of key ids to certify missing!");
            getActivity().finish();
            return;
        }

        ArrayList<Boolean> checkedStates;
        if (savedInstanceState != null) {
            checkedStates = (ArrayList<Boolean>) savedInstanceState.getSerializable(ARG_CHECK_STATES);
            
        } else {
            checkedStates = null;

            
            long certifyKeyId = getActivity().getIntent()
                    .getLongExtra(CertifyKeyActivity.EXTRA_CERTIFY_KEY_ID, Constants.key.none);
            if (certifyKeyId != Constants.key.none) {
                try {
                    CachedPublicKeyRing key = (new ProviderHelper(getActivity())).getCachedPublicKeyRing(certifyKeyId);
                    if (key.canCertify()) {
                        mCertifyKeySpinner.setPreSelectedKeyId(certifyKeyId);
                    }
                } catch (PgpKeyNotFoundException e) {
                    Log.e(Constants.TAG, "certify certify check failed", e);
                }
            }

        }

        mUserIdsAdapter = new MultiUserIdsAdapter(getActivity(), null, 0, checkedStates);
        mUserIds.setAdapter(mUserIdsAdapter);
        mUserIds.setDividerHeight(0);

        getLoaderManager().initLoader(0, null, this);

        OperationResult result = getActivity().getIntent().getParcelableExtra(CertifyKeyActivity.EXTRA_RESULT);
        if (result != null) {
            
            result.createNotify(getActivity()).show();
        }
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);

        ArrayList<Boolean> states = mUserIdsAdapter.getCheckStates();
        
        outState.putSerializable(ARG_CHECK_STATES, states);
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup superContainer, Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.certify_key_fragment, null);

        mCertifyKeySpinner = (CertifyKeySpinner) view.findViewById(R.id.certify_key_spinner);
        mUploadKeyCheckbox = (CheckBox) view.findViewById(R.id.sign_key_upload_checkbox);
        mUserIds = (ListView) view.findViewById(R.id.view_key_user_ids);

        
        ImageView vActionCertifyImage =
                (ImageView) view.findViewById(R.id.certify_key_action_certify_image);
        vActionCertifyImage.setColorFilter(getResources().getColor(R.color.tertiary_text_light),
                PorterDuff.Mode.SRC_IN);

        View vCertifyButton = view.findViewById(R.id.certify_key_certify_button);
        vCertifyButton.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                long selectedKeyId = mCertifyKeySpinner.getSelectedKeyId();
                if (selectedKeyId == Constants.key.none) {
                    Notify.create(getActivity(), getString(R.string.select_key_to_certify),
                            Notify.Style.ERROR).show();
                } else {

                    if (mUploadKeyCheckbox.isChecked() && mProxyPrefs.torEnabled) {
                        Handler ignoreTorHandler = new Handler() {
                            @Override
                            public void handleMessage(Message msg) {
                                mProxyPrefs = new Preferences.ProxyPrefs(false, false, null, -1, null);
                                cryptoOperation();
                            }
                        };
                        if (!OrbotHelper.isOrbotInstalled(getActivity())) {
                            OrbotHelper.getInstallDialogFragmentWithThirdButton(new Messenger(ignoreTorHandler),
                                    R.string.orbot_install_dialog_ignore_tor).show(getActivity()
                                    .getSupportFragmentManager(), "installOrbot");
                        } else if (!OrbotHelper.isOrbotRunning()) {
                            OrbotHelper.getOrbotStartDialogFragment(new Messenger(ignoreTorHandler),
                                    R.string.orbot_install_dialog_ignore_tor).show(getActivity()
                                    .getSupportFragmentManager(), "startOrbot");
                        } else {
                            cryptoOperation();
                        }
                    }
                }
            }
        });

        
        if (Constants.DEBUG) {
            mUploadKeyCheckbox.setChecked(false);
        }

        return view;
    }

    @Override
    public Loader<Cursor> onCreateLoader(int id, Bundle args) {
        Uri uri = UserPackets.buildUserIdsUri();

        String selection, ids[];
        {
            
            ids = new String[mPubMasterKeyIds.length];
            StringBuilder placeholders = new StringBuilder("?");
            for (int i = 0; i < mPubMasterKeyIds.length; i++) {
                ids[i] = Long.toString(mPubMasterKeyIds[i]);
                if (i != 0) {
                    placeholders.append(",?");
                }
            }
            
            selection = UserPackets.IS_REVOKED + " = 0" + " AND "
                    + Tables.USER_PACKETS + "." + UserPackets.MASTER_KEY_ID
                    + " IN (" + placeholders + ")";
        }

        return new CursorLoader(getActivity(), uri,
                USER_IDS_PROJECTION, selection, ids,
                Tables.USER_PACKETS + "." + UserPackets.MASTER_KEY_ID + " ASC"
                        + ", " + Tables.USER_PACKETS + "." + UserPackets.USER_ID + " ASC"
        );
    }

    @Override
    public void onLoadFinished(Loader<Cursor> loader, Cursor data) {

        MatrixCursor matrix = new MatrixCursor(new String[]{
                "_id", "user_data", "grouped"
        }) {
            @Override
            public byte[] getBlob(int column) {
                return super.getBlob(column);
            }
        };
        data.moveToFirst();

        long lastMasterKeyId = 0;
        String lastName = "";
        ArrayList<String> uids = new ArrayList<>();

        boolean header = true;

        
        while (!data.isAfterLast()) {
            long masterKeyId = data.getLong(INDEX_MASTER_KEY_ID);
            String userId = data.getString(INDEX_USER_ID);
            KeyRing.UserId pieces = KeyRing.splitUserId(userId);

            

            boolean grouped = masterKeyId == lastMasterKeyId;
            boolean subGrouped = data.isFirst() || grouped && lastName.equals(pieces.name);
            
            lastName = pieces.name;

            Log.d(Constants.TAG, Long.toString(masterKeyId, 16) + (grouped ? "grouped" : "not grouped"));

            if (!subGrouped) {
                

                Parcel p = Parcel.obtain();
                p.writeStringList(uids);
                byte[] d = p.marshall();
                p.recycle();

                matrix.addRow(new Object[]{
                        lastMasterKeyId, d, header ? 1 : 0
                });
                
                header = false;

                
                uids.clear();

            }

            
            uids.add(userId);
            lastMasterKeyId = masterKeyId;

            
            if (!grouped) {
                header = true;
            }

            
            data.moveToNext();

        }

        
        if (!uids.isEmpty()) {

            Parcel p = Parcel.obtain();
            p.writeStringList(uids);
            byte[] d = p.marshall();
            p.recycle();

            matrix.addRow(new Object[]{
                    lastMasterKeyId, d, header ? 1 : 0
            });

        }

        mUserIdsAdapter.swapCursor(matrix);
    }

    @Override
    public void onLoaderReset(Loader<Cursor> loader) {
        mUserIdsAdapter.swapCursor(null);
    }

    @Override
    protected CertifyActionsParcel createOperationInput() {

        
        ArrayList<CertifyAction> certifyActions = mUserIdsAdapter.getSelectedCertifyActions();
        if (certifyActions.isEmpty()) {
            Notify.create(getActivity(), "No identities selected!",
                    Notify.Style.ERROR).show();
            return null;
        }

        long selectedKeyId = mCertifyKeySpinner.getSelectedKeyId();

        
        CertifyActionsParcel actionsParcel = new CertifyActionsParcel(selectedKeyId);
        actionsParcel.mCertifyActions.addAll(certifyActions);

        if (mUploadKeyCheckbox.isChecked()) {
            actionsParcel.keyServerUri = Preferences.getPreferences(getActivity()).getPreferredKeyserver();
            actionsParcel.parcelableProxy = mProxyPrefs.parcelableProxy;
        }

        
        cacheActionsParcel(actionsParcel);

        return actionsParcel;
    }

    @Override
    protected void onCryptoOperationSuccess(CertifyResult result) {
        Intent intent = new Intent();
        intent.putExtra(CertifyResult.EXTRA_RESULT, result);
        getActivity().setResult(Activity.RESULT_OK, intent);
        getActivity().finish();
    }

    @Override
    protected void onCryptoOperationCancelled() {
        super.onCryptoOperationCancelled();
    }

}

<code block>


package org.sufficientlysecure.keychain.ui;

import android.app.ProgressDialog;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.os.Message;
import android.os.Messenger;
import android.support.v4.app.Fragment;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;

import org.sufficientlysecure.keychain.Constants;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.intents.OpenKeychainIntents;
import org.sufficientlysecure.keychain.keyimport.ImportKeysListEntry;
import org.sufficientlysecure.keychain.keyimport.ParcelableKeyRing;
import org.sufficientlysecure.keychain.operations.results.ImportKeyResult;
import org.sufficientlysecure.keychain.operations.results.OperationResult;
import org.sufficientlysecure.keychain.service.KeychainService;
import org.sufficientlysecure.keychain.ui.base.BaseNfcActivity;
import org.sufficientlysecure.keychain.service.ServiceProgressHandler;
import org.sufficientlysecure.keychain.ui.util.KeyFormattingUtils;
import org.sufficientlysecure.keychain.ui.util.Notify;
import org.sufficientlysecure.keychain.util.Log;
import org.sufficientlysecure.keychain.util.ParcelableFileCache;
import org.sufficientlysecure.keychain.util.ParcelableFileCache.IteratorWithSize;
import org.sufficientlysecure.keychain.util.Preferences;
import org.sufficientlysecure.keychain.util.tor.OrbotHelper;

import java.io.IOException;
import java.util.ArrayList;

public class ImportKeysActivity extends BaseNfcActivity {

    public static final String ACTION_IMPORT_KEY = OpenKeychainIntents.IMPORT_KEY;
    public static final String ACTION_IMPORT_KEY_FROM_KEYSERVER = OpenKeychainIntents.IMPORT_KEY_FROM_KEYSERVER;
    public static final String ACTION_IMPORT_KEY_FROM_KEYSERVER_AND_RETURN_RESULT =
            Constants.INTENT_PREFIX + "IMPORT_KEY_FROM_KEY_SERVER_AND_RETURN_RESULT";
    public static final String ACTION_IMPORT_KEY_FROM_KEYSERVER_AND_RETURN_TO_SERVICE = Constants.INTENT_PREFIX
            + "IMPORT_KEY_FROM_KEY_SERVER_AND_RETURN";
    public static final String ACTION_IMPORT_KEY_FROM_FILE_AND_RETURN = Constants.INTENT_PREFIX
            + "IMPORT_KEY_FROM_FILE_AND_RETURN";

    
    public static final String ACTION_IMPORT_KEY_FROM_FILE = Constants.INTENT_PREFIX
            + "IMPORT_KEY_FROM_FILE";
    public static final String ACTION_SEARCH_KEYSERVER_FROM_URL = Constants.INTENT_PREFIX
            + "SEARCH_KEYSERVER_FROM_URL";
    public static final String EXTRA_RESULT = "result";

    
    public static final String EXTRA_KEY_BYTES = OpenKeychainIntents.IMPORT_EXTRA_KEY_EXTRA_KEY_BYTES;

    
    public static final String EXTRA_QUERY = OpenKeychainIntents.IMPORT_KEY_FROM_KEYSERVER_EXTRA_QUERY;
    public static final String EXTRA_KEY_ID = Constants.EXTRA_PREFIX + "EXTRA_KEY_ID";
    public static final String EXTRA_FINGERPRINT = OpenKeychainIntents.IMPORT_KEY_FROM_KEYSERVER_EXTRA_FINGERPRINT;

    
    public static final String EXTRA_PENDING_INTENT_DATA = "data";
    private Intent mPendingIntentData;

    
    private ImportKeysListFragment mListFragment;
    private Fragment mTopFragment;
    private View mImportButton;

    private Preferences.ProxyPrefs mProxyPrefs;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        mProxyPrefs = Preferences.getPreferences(this).getProxyPrefs();

        mImportButton = findViewById(R.id.import_import);
        mImportButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                importKeys();
            }
        });

        handleActions(savedInstanceState, getIntent());
    }

    @Override
    protected void initLayout() {
        setContentView(R.layout.import_keys_activity);
    }

    protected void handleActions(Bundle savedInstanceState, Intent intent) {
        String action = intent.getAction();
        Bundle extras = intent.getExtras();
        Uri dataUri = intent.getData();
        String scheme = intent.getScheme();

        if (extras == null) {
            extras = new Bundle();
        }

        if (action == null) {
            startCloudFragment(savedInstanceState, null, false, null);
            startListFragment(savedInstanceState, null, null, null, null);
            return;
        }

        if (Intent.ACTION_VIEW.equals(action)) {
            if (scheme.equals("http") || scheme.equals("https")) {
                action = ACTION_SEARCH_KEYSERVER_FROM_URL;
            } else {
                
                
                action = ACTION_IMPORT_KEY;
            }
        }

        switch (action) {
            case ACTION_IMPORT_KEY: {
                
                startFileFragment(savedInstanceState);

                if (dataUri != null) {
                    
                    startListFragment(savedInstanceState, null, dataUri, null, null);
                } else if (extras.containsKey(EXTRA_KEY_BYTES)) {
                    byte[] importData = extras.getByteArray(EXTRA_KEY_BYTES);

                    
                    startListFragment(savedInstanceState, importData, null, null, null);
                }
                break;
            }
            case ACTION_IMPORT_KEY_FROM_KEYSERVER:
            case ACTION_IMPORT_KEY_FROM_KEYSERVER_AND_RETURN_TO_SERVICE:
            case ACTION_IMPORT_KEY_FROM_KEYSERVER_AND_RETURN_RESULT: {

                
                if (extras.containsKey(EXTRA_PENDING_INTENT_DATA)) {
                    mPendingIntentData = extras.getParcelable(EXTRA_PENDING_INTENT_DATA);
                }
                if (extras.containsKey(EXTRA_QUERY) || extras.containsKey(EXTRA_KEY_ID)) {
                    

                    String query = null;
                    if (extras.containsKey(EXTRA_QUERY)) {
                        query = extras.getString(EXTRA_QUERY);
                    } else if (extras.containsKey(EXTRA_KEY_ID)) {
                        long keyId = extras.getLong(EXTRA_KEY_ID, 0);
                        if (keyId != 0) {
                            query = KeyFormattingUtils.convertKeyIdToHex(keyId);
                        }
                    }

                    if (query != null && query.length() > 0) {
                        
                        startCloudFragment(savedInstanceState, query, false, null);

                        
                        startListFragment(savedInstanceState, null, null, query, null);
                    } else {
                        Log.e(Constants.TAG, "Query is empty!");
                        return;
                    }
                } else if (extras.containsKey(EXTRA_FINGERPRINT)) {
                    

                    String fingerprint = extras.getString(EXTRA_FINGERPRINT);
                    if (isFingerprintValid(fingerprint)) {
                        String query = "0x" + fingerprint;

                        
                        startCloudFragment(savedInstanceState, query, true, null);

                        
                        startListFragment(savedInstanceState, null, null, query, null);
                    }
                } else {
                    Log.e(Constants.TAG,
                            "IMPORT_KEY_FROM_KEYSERVER action needs to contain the 'query', 'key_id', or " +
                                    "'fingerprint' extra!"
                    );
                    return;
                }
                break;
            }
            case ACTION_IMPORT_KEY_FROM_FILE: {
                
                startFileFragment(savedInstanceState);

                
                startListFragment(savedInstanceState, null, null, null, null);
                break;
            }
            case ACTION_SEARCH_KEYSERVER_FROM_URL: {
                
                String query = dataUri.getQueryParameter("search");
                String keyserver = dataUri.getAuthority();
                
                if (query == null) {
                    Notify.create(this, R.string.import_url_warn_no_search_parameter, Notify.LENGTH_INDEFINITE,
                            Notify.Style.WARN).show(mTopFragment);
                    
                    startCloudFragment(savedInstanceState, null, false, keyserver);
                    
                    
                    
                    startListFragment(savedInstanceState, null, null, null, null);
                } else {
                    
                    startCloudFragment(savedInstanceState, query, false, keyserver);
                    
                    startListFragment(savedInstanceState, null, null, query, keyserver);
                }
                break;
            }
            case ACTION_IMPORT_KEY_FROM_FILE_AND_RETURN: {
                
                startFileFragment(savedInstanceState);

                
                startListFragment(savedInstanceState, null, null, null, null);
                break;
            }
            default: {
                startCloudFragment(savedInstanceState, null, false, null);
                startListFragment(savedInstanceState, null, null, null, null);
                break;
            }
        }
    }


    
    private void startListFragment(Bundle savedInstanceState, byte[] bytes, Uri dataUri,
                                   String serverQuery, String keyserver) {
        
        
        
        if (mListFragment != null) {
            return;
        }

        mListFragment = ImportKeysListFragment.newInstance(bytes, dataUri, serverQuery, false,
                keyserver);

        
        
        getSupportFragmentManager().beginTransaction()
                .replace(R.id.import_keys_list_container, mListFragment)
                .commitAllowingStateLoss();
        
        getSupportFragmentManager().executePendingTransactions();
    }

    private void startFileFragment(Bundle savedInstanceState) {
        
        
        
        if (mTopFragment != null) {
            return;
        }

        
        mTopFragment = ImportKeysFileFragment.newInstance();

        
        
        getSupportFragmentManager().beginTransaction()
                .replace(R.id.import_keys_top_container, mTopFragment)
                .commitAllowingStateLoss();
        
        getSupportFragmentManager().executePendingTransactions();
    }

    

    private void startCloudFragment(Bundle savedInstanceState, String query, boolean disableQueryEdit, String
            keyserver) {
        
        
        
        if (mTopFragment != null) {
            return;
        }

        
        mTopFragment = ImportKeysCloudFragment.newInstance(query, disableQueryEdit, keyserver);

        
        
        getSupportFragmentManager().beginTransaction()
                .replace(R.id.import_keys_top_container, mTopFragment)
                .commitAllowingStateLoss();
        
        getSupportFragmentManager().executePendingTransactions();
    }

    private boolean isFingerprintValid(String fingerprint) {
        if (fingerprint == null || fingerprint.length() < 40) {
            Notify.create(this, R.string.import_qr_code_too_short_fingerprint, Notify.Style.ERROR)
                    .show((ViewGroup) findViewById(R.id.import_snackbar));
            return false;
        } else {
            return true;
        }
    }

    public void loadCallback(final ImportKeysListFragment.LoaderState loaderState) {
        if (loaderState instanceof ImportKeysListFragment.CloudLoaderState) {
            
            
            Runnable ignoreTor = new Runnable() {
                @Override
                public void run() {
                    
                    mProxyPrefs = new Preferences.ProxyPrefs(false, false, null, -1, null);
                    mListFragment.loadNew(loaderState, mProxyPrefs.parcelableProxy);
                }
            };
            if (OrbotHelper.isOrbotInRequiredState(R.string.orbot_ignore_tor, ignoreTor, mProxyPrefs, this)) {
                mListFragment.loadNew(loaderState, mProxyPrefs.parcelableProxy);
            }
        } else if (loaderState instanceof ImportKeysListFragment.BytesLoaderState) { 
            mListFragment.loadNew(loaderState, mProxyPrefs.parcelableProxy);
        }
    }

    private void handleMessage(Message message) {
        if (message.arg1 == ServiceProgressHandler.MessageStatus.OKAY.ordinal()) {
            
            Bundle returnData = message.getData();
            if (returnData == null) {
                return;
            }
            final ImportKeyResult result =
                    returnData.getParcelable(OperationResult.EXTRA_RESULT);
            if (result == null) {
                Log.e(Constants.TAG, "result == null");
                return;
            }

            if (ACTION_IMPORT_KEY_FROM_KEYSERVER_AND_RETURN_RESULT.equals(getIntent().getAction())
                    || ACTION_IMPORT_KEY_FROM_FILE_AND_RETURN.equals(getIntent().getAction())) {
                Intent intent = new Intent();
                intent.putExtra(ImportKeyResult.EXTRA_RESULT, result);
                ImportKeysActivity.this.setResult(RESULT_OK, intent);
                ImportKeysActivity.this.finish();
                return;
            }
            if (ACTION_IMPORT_KEY_FROM_KEYSERVER_AND_RETURN_TO_SERVICE.equals(getIntent().getAction())) {
                ImportKeysActivity.this.setResult(RESULT_OK, mPendingIntentData);
                ImportKeysActivity.this.finish();
                return;
            }

            result.createNotify(ImportKeysActivity.this)
                    .show((ViewGroup) findViewById(R.id.import_snackbar));
        }
    }

    
    public void importKeys() {

        if (mListFragment.getSelectedEntries().size() == 0) {
            Notify.create(this, R.string.error_nothing_import_selected, Notify.Style.ERROR)
                    .show((ViewGroup) findViewById(R.id.import_snackbar));
            return;
        }

        ServiceProgressHandler serviceHandler = new ServiceProgressHandler(this) {
            @Override
            public void handleMessage(Message message) {
                
                super.handleMessage(message);

                ImportKeysActivity.this.handleMessage(message);
            }
        };

        
        Intent intent = new Intent(this, KeychainService.class);

        intent.setAction(KeychainService.ACTION_IMPORT_KEYRING);

        
        Bundle data = new Bundle();

        ImportKeysListFragment.LoaderState ls = mListFragment.getLoaderState();
        if (ls instanceof ImportKeysListFragment.BytesLoaderState) {
            Log.d(Constants.TAG, "importKeys started");

            
            IteratorWithSize<ParcelableKeyRing> selectedEntries = mListFragment.getSelectedData();

            
            
            
            try {
                
                
                ParcelableFileCache<ParcelableKeyRing> cache =
                        new ParcelableFileCache<>(this, "key_import.pcl");
                cache.writeCache(selectedEntries);

                intent.putExtra(KeychainService.EXTRA_DATA, data);

                
                Messenger messenger = new Messenger(serviceHandler);
                intent.putExtra(KeychainService.EXTRA_MESSENGER, messenger);

                
                serviceHandler.showProgressDialog(
                        getString(R.string.progress_importing),
                        ProgressDialog.STYLE_HORIZONTAL,
                        true
                );

                
                startService(intent);
            } catch (IOException e) {
                Log.e(Constants.TAG, "Problem writing cache file", e);
                Notify.create(this, "Problem writing cache file!", Notify.Style.ERROR)
                        .show((ViewGroup) findViewById(R.id.import_snackbar));
            }
        } else if (ls instanceof ImportKeysListFragment.CloudLoaderState) {
            ImportKeysListFragment.CloudLoaderState sls = (ImportKeysListFragment.CloudLoaderState) ls;

            data.putString(KeychainService.IMPORT_KEY_SERVER, sls.mCloudPrefs.keyserver);

            data.putParcelable(KeychainService.EXTRA_PARCELABLE_PROXY, mProxyPrefs.parcelableProxy);

            
            ArrayList<ParcelableKeyRing> keys = new ArrayList<>();
            {
                
                ArrayList<ImportKeysListEntry> entries = mListFragment.getSelectedEntries();
                for (ImportKeysListEntry entry : entries) {
                    keys.add(new ParcelableKeyRing(
                                    entry.getFingerprintHex(), entry.getKeyIdHex(), entry.getExtraData())
                    );
                }
            }
            data.putParcelableArrayList(KeychainService.IMPORT_KEY_LIST, keys);

            intent.putExtra(KeychainService.EXTRA_DATA, data);

            
            Messenger messenger = new Messenger(serviceHandler);
            intent.putExtra(KeychainService.EXTRA_MESSENGER, messenger);

            
            serviceHandler.showProgressDialog(
                    getString(R.string.progress_importing),
                    ProgressDialog.STYLE_HORIZONTAL, true
            );

            
            startService(intent);
        }
    }

    @Override
    protected void onNfcPerform() throws IOException {
        
        super.onNfcPerform();
        
        finish();
    }
}

<code block>


package org.sufficientlysecure.keychain.ui;

import android.annotation.TargetApi;
import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.os.Build;
import android.os.Bundle;
import android.preference.CheckBoxPreference;
import android.preference.EditTextPreference;
import android.preference.ListPreference;
import android.preference.Preference;
import android.preference.PreferenceActivity;
import android.preference.PreferenceFragment;
import android.preference.PreferenceScreen;
import android.support.v7.widget.Toolbar;
import android.text.TextUtils;
import android.view.View;
import android.view.ViewGroup;
import android.widget.LinearLayout;

import org.spongycastle.bcpg.CompressionAlgorithmTags;
import org.sufficientlysecure.keychain.Constants;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.ui.util.Notify;
import org.sufficientlysecure.keychain.ui.widget.IntegerListPreference;
import org.sufficientlysecure.keychain.util.Log;
import org.sufficientlysecure.keychain.util.Preferences;
import org.sufficientlysecure.keychain.util.tor.OrbotHelper;

import java.util.List;

public class SettingsActivity extends PreferenceActivity {

    public static final String ACTION_PREFS_CLOUD = "org.sufficientlysecure.keychain.ui.PREFS_CLOUD";
    public static final String ACTION_PREFS_ADV = "org.sufficientlysecure.keychain.ui.PREFS_ADV";
    public static final String ACTION_PREFS_PROXY = "org.sufficientlysecure.keychain.ui.PREFS_PROXY";

    public static final int REQUEST_CODE_KEYSERVER_PREF = 0x00007005;

    private PreferenceScreen mKeyServerPreference = null;
    private static Preferences sPreferences;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        sPreferences = Preferences.getPreferences(this);
        super.onCreate(savedInstanceState);

        setupToolbar();

        String action = getIntent().getAction();
        if (action == null) return;

        switch (action) {
            case ACTION_PREFS_CLOUD: {
                addPreferencesFromResource(R.xml.cloud_search_prefs);

                mKeyServerPreference = (PreferenceScreen) findPreference(Constants.Pref.KEY_SERVERS);
                mKeyServerPreference.setSummary(keyserverSummary(this));
                mKeyServerPreference
                        .setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {
                            public boolean onPreferenceClick(Preference preference) {
                                Intent intent = new Intent(SettingsActivity.this,
                                        SettingsKeyServerActivity.class);
                                intent.putExtra(SettingsKeyServerActivity.EXTRA_KEY_SERVERS,
                                        sPreferences.getKeyServers());
                                startActivityForResult(intent, REQUEST_CODE_KEYSERVER_PREF);
                                return false;
                            }
                        });
                initializeSearchKeyserver(
                        (CheckBoxPreference) findPreference(Constants.Pref.SEARCH_KEYSERVER)
                );
                initializeSearchKeybase(
                        (CheckBoxPreference) findPreference(Constants.Pref.SEARCH_KEYBASE)
                );

                break;
            }

            case ACTION_PREFS_ADV: {
                addPreferencesFromResource(R.xml.adv_preferences);

                initializePassphraseCacheSubs(
                        (CheckBoxPreference) findPreference(Constants.Pref.PASSPHRASE_CACHE_SUBS));

                initializePassphraseCacheTtl(
                        (IntegerListPreference) findPreference(Constants.Pref.PASSPHRASE_CACHE_TTL));

                int[] valueIds = new int[]{
                        CompressionAlgorithmTags.UNCOMPRESSED,
                        CompressionAlgorithmTags.ZIP,
                        CompressionAlgorithmTags.ZLIB,
                        CompressionAlgorithmTags.BZIP2,
                };
                String[] entries = new String[]{
                        getString(R.string.choice_none) + " (" + getString(R.string.compression_fast) + ")",
                        "ZIP (" + getString(R.string.compression_fast) + ")",
                        "ZLIB (" + getString(R.string.compression_fast) + ")",
                        "BZIP2 (" + getString(R.string.compression_very_slow) + ")",};
                String[] values = new String[valueIds.length];
                for (int i = 0; i < values.length; ++i) {
                    values[i] = "" + valueIds[i];
                }

                initializeUseDefaultYubiKeyPin(
                        (CheckBoxPreference) findPreference(Constants.Pref.USE_DEFAULT_YUBIKEY_PIN));

                initializeUseNumKeypadForYubiKeyPin(
                        (CheckBoxPreference) findPreference(Constants.Pref.USE_NUMKEYPAD_FOR_YUBIKEY_PIN));

                break;
            }

            case ACTION_PREFS_PROXY: {
                new ProxyPrefsFragment.Initializer(this).initialize();

                break;
            }
        }
    }

    
    private void setupToolbar() {
        ViewGroup root = (ViewGroup) findViewById(android.R.id.content);
        LinearLayout content = (LinearLayout) root.getChildAt(0);
        LinearLayout toolbarContainer = (LinearLayout) View.inflate(this, R.layout.preference_toolbar_activity, null);

        root.removeAllViews();
        toolbarContainer.addView(content);
        root.addView(toolbarContainer);

        Toolbar toolbar = (Toolbar) toolbarContainer.findViewById(R.id.toolbar);
        toolbar.setTitle(R.string.title_preferences);
        toolbar.setNavigationIcon(getResources().getDrawable(R.drawable.ic_arrow_back_white_24dp));
        toolbar.setNavigationOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                
                finish();
            }
        });
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        switch (requestCode) {
            case REQUEST_CODE_KEYSERVER_PREF: {
                if (resultCode == RESULT_CANCELED || data == null) {
                    return;
                }
                String servers[] = data
                        .getStringArrayExtra(SettingsKeyServerActivity.EXTRA_KEY_SERVERS);
                sPreferences.setKeyServers(servers);
                mKeyServerPreference.setSummary(keyserverSummary(this));
                break;
            }

            default: {
                super.onActivityResult(requestCode, resultCode, data);
                break;
            }
        }
    }

    @Override
    public void onBuildHeaders(List<Header> target) {
        super.onBuildHeaders(target);
        loadHeadersFromResource(R.xml.preference_headers, target);
    }

    
    public static class CloudSearchPrefsFragment extends PreferenceFragment {

        private PreferenceScreen mKeyServerPreference = null;

        @Override
        public void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);

            
            addPreferencesFromResource(R.xml.cloud_search_prefs);

            mKeyServerPreference = (PreferenceScreen) findPreference(Constants.Pref.KEY_SERVERS);
            mKeyServerPreference.setSummary(keyserverSummary(getActivity()));

            mKeyServerPreference
                    .setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {
                        public boolean onPreferenceClick(Preference preference) {
                            Intent intent = new Intent(getActivity(),
                                    SettingsKeyServerActivity.class);
                            intent.putExtra(SettingsKeyServerActivity.EXTRA_KEY_SERVERS,
                                    sPreferences.getKeyServers());
                            startActivityForResult(intent, REQUEST_CODE_KEYSERVER_PREF);
                            return false;
                        }
                    });
            initializeSearchKeyserver(
                    (CheckBoxPreference) findPreference(Constants.Pref.SEARCH_KEYSERVER)
            );
            initializeSearchKeybase(
                    (CheckBoxPreference) findPreference(Constants.Pref.SEARCH_KEYBASE)
            );
        }

        @Override
        public void onActivityResult(int requestCode, int resultCode, Intent data) {
            switch (requestCode) {
                case REQUEST_CODE_KEYSERVER_PREF: {
                    if (resultCode == RESULT_CANCELED || data == null) {
                        return;
                    }
                    String servers[] = data
                            .getStringArrayExtra(SettingsKeyServerActivity.EXTRA_KEY_SERVERS);
                    sPreferences.setKeyServers(servers);
                    mKeyServerPreference.setSummary(keyserverSummary(getActivity()));
                    break;
                }

                default: {
                    super.onActivityResult(requestCode, resultCode, data);
                    break;
                }
            }
        }
    }

    
    public static class AdvancedPrefsFragment extends PreferenceFragment {

        @Override
        public void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);

            
            addPreferencesFromResource(R.xml.adv_preferences);

            initializePassphraseCacheSubs(
                    (CheckBoxPreference) findPreference(Constants.Pref.PASSPHRASE_CACHE_SUBS));

            initializePassphraseCacheTtl(
                    (IntegerListPreference) findPreference(Constants.Pref.PASSPHRASE_CACHE_TTL));

            int[] valueIds = new int[]{
                    CompressionAlgorithmTags.UNCOMPRESSED,
                    CompressionAlgorithmTags.ZIP,
                    CompressionAlgorithmTags.ZLIB,
                    CompressionAlgorithmTags.BZIP2,
            };

            String[] entries = new String[]{
                    getString(R.string.choice_none) + " (" + getString(R.string.compression_fast) + ")",
                    "ZIP (" + getString(R.string.compression_fast) + ")",
                    "ZLIB (" + getString(R.string.compression_fast) + ")",
                    "BZIP2 (" + getString(R.string.compression_very_slow) + ")",
            };

            String[] values = new String[valueIds.length];
            for (int i = 0; i < values.length; ++i) {
                values[i] = "" + valueIds[i];
            }

            initializeUseDefaultYubiKeyPin(
                    (CheckBoxPreference) findPreference(Constants.Pref.USE_DEFAULT_YUBIKEY_PIN));

            initializeUseNumKeypadForYubiKeyPin(
                    (CheckBoxPreference) findPreference(Constants.Pref.USE_NUMKEYPAD_FOR_YUBIKEY_PIN));
        }
    }

    public static class ProxyPrefsFragment extends PreferenceFragment {

        @Override
        public void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);

            new Initializer(this).initialize();

        }

        public static class Initializer {
            private CheckBoxPreference mUseTor;
            private CheckBoxPreference mUseNormalProxy;
            private EditTextPreference mProxyHost;
            private EditTextPreference mProxyPort;
            private ListPreference mProxyType;
            private PreferenceActivity mActivity;
            private PreferenceFragment mFragment;

            public Initializer(PreferenceFragment fragment) {
                mFragment = fragment;
            }

            public Initializer(PreferenceActivity activity) {
                mActivity = activity;
            }

            public Preference automaticallyFindPreference(String key) {
                if (mFragment != null) {
                    return mFragment.findPreference(key);
                } else {
                    return mActivity.findPreference(key);
                }
            }

            public void initialize() {
                
                
                if (mFragment != null) {
                    Preferences.setPreferenceManagerFileAndMode(mFragment.getPreferenceManager());
                    
                    mFragment.addPreferencesFromResource(R.xml.proxy_prefs);
                } else {
                    Preferences.setPreferenceManagerFileAndMode(mActivity.getPreferenceManager());
                    
                    mActivity.addPreferencesFromResource(R.xml.proxy_prefs);
                }

                mUseTor = (CheckBoxPreference) automaticallyFindPreference(Constants.Pref.USE_TOR_PROXY);
                mUseNormalProxy = (CheckBoxPreference) automaticallyFindPreference(Constants.Pref.USE_NORMAL_PROXY);
                mProxyHost = (EditTextPreference) automaticallyFindPreference(Constants.Pref.PROXY_HOST);
                mProxyPort = (EditTextPreference) automaticallyFindPreference(Constants.Pref.PROXY_PORT);
                mProxyType = (ListPreference) automaticallyFindPreference(Constants.Pref.PROXY_TYPE);
                initializeUseTorPref();
                initializeUseNormalProxyPref();
                initializeEditTextPreferences();
                initializeProxyTypePreference();

                if (mUseTor.isChecked()) disableNormalProxyPrefs();
                else if (mUseNormalProxy.isChecked()) disableUseTorPrefs();
            }

            private void initializeUseTorPref() {
                mUseTor.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
                    @Override
                    public boolean onPreferenceChange(Preference preference, Object newValue) {
                        Activity activity = mFragment != null ? mFragment.getActivity() : mActivity;
                        if ((Boolean) newValue) {
                            boolean installed = OrbotHelper.isOrbotInstalled(activity);
                            if (!installed) {
                                Log.d(Constants.TAG, "Prompting to install Tor");
                                OrbotHelper.getPreferenceInstallDialogFragment().show(activity.getFragmentManager(),
                                        "installDialog");
                                
                                return false;
                            } else {
                                disableNormalProxyPrefs();
                                
                                return true;
                            }
                        } else {
                            
                            enableNormalProxyPrefs();
                            return true;
                        }
                    }
                });
            }

            private void initializeUseNormalProxyPref() {
                mUseNormalProxy.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
                    @Override
                    public boolean onPreferenceChange(Preference preference, Object newValue) {
                        if ((Boolean) newValue) {
                            disableUseTorPrefs();
                        } else {
                            enableUseTorPrefs();
                        }
                        return true;
                    }
                });
            }

            private void initializeEditTextPreferences() {
                mProxyHost.setSummary(mProxyHost.getText());
                mProxyPort.setSummary(mProxyPort.getText());

                mProxyHost.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
                    @Override
                    public boolean onPreferenceChange(Preference preference, Object newValue) {
                        Activity activity = mFragment != null ? mFragment.getActivity() : mActivity;
                        if (TextUtils.isEmpty((String) newValue)) {
                            Notify.create(
                                    activity,
                                    R.string.pref_proxy_host_err_invalid,
                                    Notify.Style.ERROR
                            ).show();
                            return false;
                        } else {
                            mProxyHost.setSummary((CharSequence) newValue);
                            return true;
                        }
                    }
                });

                mProxyPort.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
                    @Override
                    public boolean onPreferenceChange(Preference preference, Object newValue) {
                        Activity activity = mFragment != null ? mFragment.getActivity() : mActivity;
                        try {
                            int port = Integer.parseInt((String) newValue);
                            if (port < 0 || port > 65535) {
                                Notify.create(
                                        activity,
                                        R.string.pref_proxy_port_err_invalid,
                                        Notify.Style.ERROR
                                ).show();
                                return false;
                            }
                            
                            mProxyPort.setSummary("" + port);
                            return true;
                        } catch (NumberFormatException e) {
                            Notify.create(
                                    activity,
                                    R.string.pref_proxy_port_err_invalid,
                                    Notify.Style.ERROR
                            ).show();
                            return false;
                        }
                    }
                });
            }

            private void initializeProxyTypePreference() {
                mProxyType.setSummary(mProxyType.getEntry());

                mProxyType.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
                    @Override
                    public boolean onPreferenceChange(Preference preference, Object newValue) {
                        CharSequence entry = mProxyType.getEntries()[mProxyType.findIndexOfValue((String) newValue)];
                        mProxyType.setSummary(entry);
                        return true;
                    }
                });
            }

            private void disableNormalProxyPrefs() {
                mUseNormalProxy.setChecked(false);
                mUseNormalProxy.setEnabled(false);
                mProxyHost.setEnabled(false);
                mProxyPort.setEnabled(false);
                mProxyType.setEnabled(false);
            }

            private void enableNormalProxyPrefs() {
                mUseNormalProxy.setEnabled(true);
                mProxyHost.setEnabled(true);
                mProxyPort.setEnabled(true);
                mProxyType.setEnabled(true);
            }

            private void disableUseTorPrefs() {
                mUseTor.setChecked(false);
                mUseTor.setEnabled(false);
            }

            private void enableUseTorPrefs() {
                mUseTor.setEnabled(true);
            }
        }

    }

    @TargetApi(Build.VERSION_CODES.KITKAT)
    protected boolean isValidFragment(String fragmentName) {
        return AdvancedPrefsFragment.class.getName().equals(fragmentName)
                || CloudSearchPrefsFragment.class.getName().equals(fragmentName)
                || ProxyPrefsFragment.class.getName().equals(fragmentName)
                || super.isValidFragment(fragmentName);
    }

    private static void initializePassphraseCacheSubs(final CheckBoxPreference mPassphraseCacheSubs) {
        mPassphraseCacheSubs.setChecked(sPreferences.getPassphraseCacheSubs());
        mPassphraseCacheSubs.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                mPassphraseCacheSubs.setChecked((Boolean) newValue);
                sPreferences.setPassphraseCacheSubs((Boolean) newValue);
                return false;
            }
        });
    }

    private static void initializePassphraseCacheTtl(final IntegerListPreference mPassphraseCacheTtl) {
        mPassphraseCacheTtl.setValue("" + sPreferences.getPassphraseCacheTtl());
        mPassphraseCacheTtl.setSummary(mPassphraseCacheTtl.getEntry());
        mPassphraseCacheTtl
                .setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
                    public boolean onPreferenceChange(Preference preference, Object newValue) {
                        mPassphraseCacheTtl.setValue(newValue.toString());
                        mPassphraseCacheTtl.setSummary(mPassphraseCacheTtl.getEntry());
                        sPreferences.setPassphraseCacheTtl(Integer.parseInt(newValue.toString()));
                        return false;
                    }
                });
    }

    private static void initializeSearchKeyserver(final CheckBoxPreference mSearchKeyserver) {
        Preferences.CloudSearchPrefs prefs = sPreferences.getCloudSearchPrefs();
        mSearchKeyserver.setChecked(prefs.searchKeyserver);
        mSearchKeyserver.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            @Override
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                mSearchKeyserver.setChecked((Boolean) newValue);
                sPreferences.setSearchKeyserver((Boolean) newValue);
                return false;
            }
        });
    }

    private static void initializeSearchKeybase(final CheckBoxPreference mSearchKeybase) {
        Preferences.CloudSearchPrefs prefs = sPreferences.getCloudSearchPrefs();
        mSearchKeybase.setChecked(prefs.searchKeybase);
        mSearchKeybase.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            @Override
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                mSearchKeybase.setChecked((Boolean) newValue);
                sPreferences.setSearchKeybase((Boolean) newValue);
                return false;
            }
        });
    }

    public static String keyserverSummary(Context context) {
        String[] servers = sPreferences.getKeyServers();
        String serverSummary = context.getResources().getQuantityString(
                R.plurals.n_keyservers, servers.length, servers.length);
        return serverSummary + "; " + context.getString(R.string.label_preferred) + ": " + sPreferences
                .getPreferredKeyserver();
    }

    private static void initializeUseDefaultYubiKeyPin(final CheckBoxPreference mUseDefaultYubiKeyPin) {
        mUseDefaultYubiKeyPin.setChecked(sPreferences.useDefaultYubiKeyPin());
        mUseDefaultYubiKeyPin.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                mUseDefaultYubiKeyPin.setChecked((Boolean) newValue);
                sPreferences.setUseDefaultYubiKeyPin((Boolean) newValue);
                return false;
            }
        });
    }

    private static void initializeUseNumKeypadForYubiKeyPin(final CheckBoxPreference mUseNumKeypadForYubiKeyPin) {
        mUseNumKeypadForYubiKeyPin.setChecked(sPreferences.useNumKeypadForYubiKeyPin());
        mUseNumKeypadForYubiKeyPin.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                mUseNumKeypadForYubiKeyPin.setChecked((Boolean) newValue);
                sPreferences.setUseNumKeypadForYubiKeyPin((Boolean) newValue);
                return false;
            }
        });
    }
}

<code block>


package org.sufficientlysecure.keychain.ui;

import android.app.ProgressDialog;
import android.content.Intent;
import android.database.Cursor;
import android.graphics.Typeface;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Message;
import android.os.Messenger;
import android.support.v4.app.LoaderManager;
import android.support.v4.content.CursorLoader;
import android.support.v4.content.Loader;
import android.text.SpannableStringBuilder;
import android.text.Spanned;
import android.text.method.LinkMovementMethod;
import android.text.style.ClickableSpan;
import android.text.style.StyleSpan;
import android.text.style.URLSpan;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TableLayout;
import android.widget.TableRow;
import android.widget.TextView;

import com.textuality.keybase.lib.KeybaseException;
import com.textuality.keybase.lib.Proof;
import com.textuality.keybase.lib.User;

import org.sufficientlysecure.keychain.Constants;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.provider.KeychainContract.KeyRings;
import org.sufficientlysecure.keychain.service.KeychainService;
import org.sufficientlysecure.keychain.service.ServiceProgressHandler;
import org.sufficientlysecure.keychain.ui.util.KeyFormattingUtils;
import org.sufficientlysecure.keychain.util.Log;
import org.sufficientlysecure.keychain.util.ParcelableProxy;
import org.sufficientlysecure.keychain.util.Preferences;
import org.sufficientlysecure.keychain.util.tor.OrbotHelper;

import java.util.ArrayList;
import java.util.Hashtable;
import java.util.List;

public class ViewKeyTrustFragment extends LoaderFragment implements
        LoaderManager.LoaderCallbacks<Cursor> {

    public static final String ARG_DATA_URI = "uri";

    private View mStartSearch;
    private TextView mTrustReadout;
    private TextView mReportHeader;
    private TableLayout mProofListing;
    private LayoutInflater mInflater;
    private View mProofVerifyHeader;
    private TextView mProofVerifyDetail;

    private static final int LOADER_ID_DATABASE = 1;

    
    private Uri mDataUri;

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup superContainer, Bundle savedInstanceState) {
        View root = super.onCreateView(inflater, superContainer, savedInstanceState);
        View view = inflater.inflate(R.layout.view_key_adv_keybase_fragment, getContainer());
        mInflater = inflater;

        mTrustReadout = (TextView) view.findViewById(R.id.view_key_trust_readout);
        mStartSearch = view.findViewById(R.id.view_key_trust_search_cloud);
        mStartSearch.setEnabled(false);
        mReportHeader = (TextView) view.findViewById(R.id.view_key_trust_cloud_narrative);
        mProofListing = (TableLayout) view.findViewById(R.id.view_key_proof_list);
        mProofVerifyHeader = view.findViewById(R.id.view_key_proof_verify_header);
        mProofVerifyDetail = (TextView) view.findViewById(R.id.view_key_proof_verify_detail);
        mReportHeader.setVisibility(View.GONE);
        mProofListing.setVisibility(View.GONE);
        mProofVerifyHeader.setVisibility(View.GONE);
        mProofVerifyDetail.setVisibility(View.GONE);

        return root;
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        Uri dataUri = getArguments().getParcelable(ARG_DATA_URI);
        if (dataUri == null) {
            Log.e(Constants.TAG, "Data missing. Should be Uri of key!");
            getActivity().finish();
            return;
        }
        mDataUri = dataUri;

        
        getLoaderManager().initLoader(LOADER_ID_DATABASE, null, this);
    }

    static final String[] TRUST_PROJECTION = new String[]{
            KeyRings._ID, KeyRings.FINGERPRINT, KeyRings.IS_REVOKED, KeyRings.IS_EXPIRED,
            KeyRings.HAS_ANY_SECRET, KeyRings.VERIFIED
    };
    static final int INDEX_TRUST_FINGERPRINT = 1;
    static final int INDEX_TRUST_IS_REVOKED = 2;
    static final int INDEX_TRUST_IS_EXPIRED = 3;
    static final int INDEX_UNIFIED_HAS_ANY_SECRET = 4;
    static final int INDEX_VERIFIED = 5;

    public Loader<Cursor> onCreateLoader(int id, Bundle args) {
        setContentShown(false);

        switch (id) {
            case LOADER_ID_DATABASE: {
                Uri baseUri = KeyRings.buildUnifiedKeyRingUri(mDataUri);
                return new CursorLoader(getActivity(), baseUri, TRUST_PROJECTION, null, null, null);
            }
            
            default:
                return null;
        }
    }

    public void onLoadFinished(Loader<Cursor> loader, Cursor data) {
        
        
        if (data.getCount() == 0) {
            return;
        }

        boolean nothingSpecial = true;
        StringBuilder message = new StringBuilder();

        
        
        if (data.moveToFirst()) {

            if (data.getInt(INDEX_UNIFIED_HAS_ANY_SECRET) != 0) {
                message.append(getString(R.string.key_trust_it_is_yours)).append("\n");
                nothingSpecial = false;
            } else if (data.getInt(INDEX_VERIFIED) != 0) {
                message.append(getString(R.string.key_trust_already_verified)).append("\n");
                nothingSpecial = false;
            }

            
            if (data.getInt(INDEX_TRUST_IS_REVOKED) != 0) {
                message.append(getString(R.string.key_trust_revoked)).
                        append(getString(R.string.key_trust_old_keys));

                nothingSpecial = false;
            } else {
                if (data.getInt(INDEX_TRUST_IS_EXPIRED) != 0) {

                    
                    message.append(getString(R.string.key_trust_expired)).
                            append(getString(R.string.key_trust_old_keys));

                    nothingSpecial = false;
                }
            }

            if (nothingSpecial) {
                message.append(getString(R.string.key_trust_maybe));
            }

            final byte[] fp = data.getBlob(INDEX_TRUST_FINGERPRINT);
            final String fingerprint = KeyFormattingUtils.convertFingerprintToHex(fp);
            if (fingerprint != null) {

                mStartSearch.setEnabled(true);
                mStartSearch.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View view) {
                        final Preferences.ProxyPrefs proxyPrefs = Preferences.getPreferences(getActivity())
                                .getProxyPrefs();

                        Runnable ignoreTor = new Runnable() {
                            @Override
                            public void run() {
                                mStartSearch.setEnabled(false);
                                new DescribeKey(proxyPrefs.parcelableProxy).execute(fingerprint);
                            }
                        };

                        if (OrbotHelper.isOrbotInRequiredState(R.string.orbot_ignore_tor, ignoreTor, proxyPrefs,
                                getActivity())) {
                            mStartSearch.setEnabled(false);
                            new DescribeKey(proxyPrefs.parcelableProxy).execute(fingerprint);
                        }
                    }
                });
            }
        }

        mTrustReadout.setText(message);
        setContentShown(true);
    }

    
    public void onLoaderReset(Loader<Cursor> loader) {
        
    }

    class ResultPage {
        String mHeader;
        final List<CharSequence> mProofs;

        public ResultPage(String header, List<CharSequence> proofs) {
            mHeader = header;
            mProofs = proofs;
        }
    }

    
    
    private class DescribeKey extends AsyncTask<String, Void, ResultPage> {
        ParcelableProxy mParcelableProxy;

        public DescribeKey(ParcelableProxy parcelableProxy) {
            mParcelableProxy = parcelableProxy;
        }

        @Override
        protected ResultPage doInBackground(String... args) {
            String fingerprint = args[0];

            final ArrayList<CharSequence> proofList = new ArrayList<CharSequence>();
            final Hashtable<Integer, ArrayList<Proof>> proofs = new Hashtable<Integer, ArrayList<Proof>>();
            try {
                User keybaseUser = User.findByFingerprint(fingerprint, mParcelableProxy.getProxy());
                for (Proof proof : keybaseUser.getProofs()) {
                    Integer proofType = proof.getType();
                    appendIfOK(proofs, proofType, proof);
                }

                
                for (Integer proofType : proofs.keySet()) {
                    Proof[] x = {};
                    Proof[] proofsFor = proofs.get(proofType).toArray(x);
                    if (proofsFor.length > 0) {
                        SpannableStringBuilder ssb = new SpannableStringBuilder();
                        ssb.append(getProofNarrative(proofType)).append(" ");

                        int i = 0;
                        while (i < proofsFor.length - 1) {
                            appendProofLinks(ssb, fingerprint, proofsFor[i]);
                            ssb.append(", ");
                            i++;
                        }
                        appendProofLinks(ssb, fingerprint, proofsFor[i]);
                        proofList.add(ssb);
                    }
                }

            } catch (KeybaseException ignored) {
            }

            return new ResultPage(getString(R.string.key_trust_results_prefix), proofList);
        }

        private SpannableStringBuilder appendProofLinks(SpannableStringBuilder ssb, final String fingerprint, final
        Proof proof) throws KeybaseException {
            int startAt = ssb.length();
            String handle = proof.getHandle();
            ssb.append(handle);
            ssb.setSpan(new URLSpan(proof.getServiceUrl()), startAt, startAt + handle.length(), Spanned
                    .SPAN_EXCLUSIVE_EXCLUSIVE);
            if (haveProofFor(proof.getType())) {
                ssb.append("\u00a0[");
                startAt = ssb.length();
                String verify = getString(R.string.keybase_verify);
                ssb.append(verify);
                ClickableSpan clicker = new ClickableSpan() {
                    @Override
                    public void onClick(View view) {
                        final Preferences.ProxyPrefs proxyPrefs = Preferences.getPreferences(getActivity())
                                .getProxyPrefs();

                        Runnable ignoreTor = new Runnable() {
                            @Override
                            public void run() {
                                mStartSearch.setEnabled(false);
                                verify(proof, fingerprint, new ParcelableProxy(null, -1, null));
                            }
                        };

                        if (OrbotHelper.isOrbotInRequiredState(R.string.orbot_ignore_tor, ignoreTor, proxyPrefs,
                                getActivity())) {
                            mStartSearch.setEnabled(false);
                            verify(proof, fingerprint, mParcelableProxy);
                        }
                    }
                };
                ssb.setSpan(clicker, startAt, startAt + verify.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
                ssb.append("]");
            }
            return ssb;
        }

        @Override
        protected void onPostExecute(ResultPage result) {
            super.onPostExecute(result);
            if (result.mProofs.isEmpty()) {
                result.mHeader = getActivity().getString(R.string.key_trust_no_cloud_evidence);
            }

            mStartSearch.setVisibility(View.GONE);
            mReportHeader.setVisibility(View.VISIBLE);
            mProofListing.setVisibility(View.VISIBLE);
            mReportHeader.setText(result.mHeader);

            int rowNumber = 1;
            for (CharSequence s : result.mProofs) {
                TableRow row = (TableRow) mInflater.inflate(R.layout.view_key_adv_keybase_proof, null);
                TextView number = (TextView) row.findViewById(R.id.proof_number);
                TextView text = (TextView) row.findViewById(R.id.proof_text);
                number.setText(Integer.toString(rowNumber++) + ". ");
                text.setText(s);
                text.setMovementMethod(LinkMovementMethod.getInstance());
                mProofListing.addView(row);
            }

            
        }
    }

    private String getProofNarrative(int proofType) {
        int stringIndex;
        switch (proofType) {
            case Proof.PROOF_TYPE_TWITTER:
                stringIndex = R.string.keybase_narrative_twitter;
                break;
            case Proof.PROOF_TYPE_GITHUB:
                stringIndex = R.string.keybase_narrative_github;
                break;
            case Proof.PROOF_TYPE_DNS:
                stringIndex = R.string.keybase_narrative_dns;
                break;
            case Proof.PROOF_TYPE_WEB_SITE:
                stringIndex = R.string.keybase_narrative_web_site;
                break;
            case Proof.PROOF_TYPE_HACKERNEWS:
                stringIndex = R.string.keybase_narrative_hackernews;
                break;
            case Proof.PROOF_TYPE_COINBASE:
                stringIndex = R.string.keybase_narrative_coinbase;
                break;
            case Proof.PROOF_TYPE_REDDIT:
                stringIndex = R.string.keybase_narrative_reddit;
                break;
            default:
                stringIndex = R.string.keybase_narrative_unknown;
        }
        return getActivity().getString(stringIndex);
    }

    private void appendIfOK(Hashtable<Integer, ArrayList<Proof>> table, Integer proofType, Proof proof) throws
            KeybaseException {
        ArrayList<Proof> list = table.get(proofType);
        if (list == null) {
            list = new ArrayList<Proof>();
            table.put(proofType, list);
        }
        list.add(proof);
    }

    
    private boolean haveProofFor(int proofType) {
        switch (proofType) {
            case Proof.PROOF_TYPE_TWITTER:
                return true;
            case Proof.PROOF_TYPE_GITHUB:
                return true;
            case Proof.PROOF_TYPE_DNS:
                return true;
            case Proof.PROOF_TYPE_WEB_SITE:
                return true;
            case Proof.PROOF_TYPE_HACKERNEWS:
                return true;
            case Proof.PROOF_TYPE_COINBASE:
                return true;
            case Proof.PROOF_TYPE_REDDIT:
                return true;
            default:
                return false;
        }
    }

    private void verify(final Proof proof, final String fingerprint, ParcelableProxy parcelableProxy) {
        Intent intent = new Intent(getActivity(), KeychainService.class);
        Bundle data = new Bundle();
        intent.setAction(KeychainService.ACTION_VERIFY_KEYBASE_PROOF);

        data.putString(KeychainService.KEYBASE_PROOF, proof.toString());
        data.putString(KeychainService.KEYBASE_REQUIRED_FINGERPRINT, fingerprint);

        data.putParcelable(KeychainService.EXTRA_PARCELABLE_PROXY, parcelableProxy);

        intent.putExtra(KeychainService.EXTRA_DATA, data);

        mProofVerifyDetail.setVisibility(View.GONE);

        
        ServiceProgressHandler handler = new ServiceProgressHandler(getActivity()) {
            @Override
            public void handleMessage(Message message) {
                
                super.handleMessage(message);

                if (message.arg1 == MessageStatus.OKAY.ordinal()) {
                    Bundle returnData = message.getData();
                    String msg = returnData.getString(ServiceProgressHandler.DATA_MESSAGE);
                    SpannableStringBuilder ssb = new SpannableStringBuilder();

                    if ((msg != null) && msg.equals("OK")) {

                        
                        String proofUrl = returnData.getString(ServiceProgressHandler.KEYBASE_PROOF_URL);
                        String presenceUrl = returnData.getString(ServiceProgressHandler.KEYBASE_PRESENCE_URL);
                        String presenceLabel = returnData.getString(ServiceProgressHandler.KEYBASE_PRESENCE_LABEL);

                        String proofLabel;
                        switch (proof.getType()) {
                            case Proof.PROOF_TYPE_TWITTER:
                                proofLabel = getString(R.string.keybase_twitter_proof);
                                break;
                            case Proof.PROOF_TYPE_DNS:
                                proofLabel = getString(R.string.keybase_dns_proof);
                                break;
                            case Proof.PROOF_TYPE_WEB_SITE:
                                proofLabel = getString(R.string.keybase_web_site_proof);
                                break;
                            case Proof.PROOF_TYPE_GITHUB:
                                proofLabel = getString(R.string.keybase_github_proof);
                                break;
                            case Proof.PROOF_TYPE_REDDIT:
                                proofLabel = getString(R.string.keybase_reddit_proof);
                                break;
                            default:
                                proofLabel = getString(R.string.keybase_a_post);
                                break;
                        }

                        ssb.append(getString(R.string.keybase_proof_succeeded));
                        StyleSpan bold = new StyleSpan(Typeface.BOLD);
                        ssb.setSpan(bold, 0, ssb.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
                        ssb.append("\n\n");
                        int length = ssb.length();
                        ssb.append(proofLabel);
                        if (proofUrl != null) {
                            URLSpan postLink = new URLSpan(proofUrl);
                            ssb.setSpan(postLink, length, length + proofLabel.length(), Spanned
                                    .SPAN_EXCLUSIVE_EXCLUSIVE);
                        }
                        if (Proof.PROOF_TYPE_DNS == proof.getType()) {
                            ssb.append(" ").append(getString(R.string.keybase_for_the_domain)).append(" ");
                        } else {
                            ssb.append(" ").append(getString(R.string.keybase_fetched_from)).append(" ");
                        }
                        length = ssb.length();
                        URLSpan presenceLink = new URLSpan(presenceUrl);
                        ssb.append(presenceLabel);
                        ssb.setSpan(presenceLink, length, length + presenceLabel.length(), Spanned
                                .SPAN_EXCLUSIVE_EXCLUSIVE);
                        if (Proof.PROOF_TYPE_REDDIT == proof.getType()) {
                            ssb.append(", ").
                                    append(getString(R.string.keybase_reddit_attribution)).
                                    append(" ").append(proof.getHandle()).append("?, ");
                        }
                        ssb.append(" ").append(getString(R.string.keybase_contained_signature));
                    } else {
                        
                        msg = returnData.getString(ServiceProgressHandler.DATA_ERROR);
                        ssb.append(getString(R.string.keybase_proof_failure));
                        if (msg == null) {
                            msg = getString(R.string.keybase_unknown_proof_failure);
                        }
                        StyleSpan bold = new StyleSpan(Typeface.BOLD);
                        ssb.setSpan(bold, 0, ssb.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
                        ssb.append("\n\n").append(msg);
                    }
                    mProofVerifyHeader.setVisibility(View.VISIBLE);
                    mProofVerifyDetail.setVisibility(View.VISIBLE);
                    mProofVerifyDetail.setMovementMethod(LinkMovementMethod.getInstance());
                    mProofVerifyDetail.setText(ssb);
                }
            }
        };

        
        Messenger messenger = new Messenger(handler);
        intent.putExtra(KeychainService.EXTRA_MESSENGER, messenger);

        
        handler.showProgressDialog(
                getString(R.string.progress_verifying_signature),
                ProgressDialog.STYLE_HORIZONTAL, false
        );

        
        getActivity().startService(intent);
    }
}

<code block>


package org.sufficientlysecure.keychain.ui;

import android.app.ProgressDialog;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.os.Message;
import android.os.Messenger;
import android.support.v4.app.NavUtils;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.ArrayAdapter;
import android.widget.Spinner;
import android.widget.Toast;

import org.sufficientlysecure.keychain.Constants;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.provider.KeychainContract;
import org.sufficientlysecure.keychain.provider.KeychainContract.KeyRings;
import org.sufficientlysecure.keychain.service.KeychainService;
import org.sufficientlysecure.keychain.ui.base.BaseActivity;
import org.sufficientlysecure.keychain.service.ServiceProgressHandler;
import org.sufficientlysecure.keychain.util.Log;
import org.sufficientlysecure.keychain.util.ParcelableProxy;
import org.sufficientlysecure.keychain.util.Preferences;
import org.sufficientlysecure.keychain.util.tor.OrbotHelper;


public class UploadKeyActivity extends BaseActivity {
    private View mUploadButton;
    private Spinner mKeyServerSpinner;

    private Uri mDataUri;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        mUploadButton = findViewById(R.id.upload_key_action_upload);
        mKeyServerSpinner = (Spinner) findViewById(R.id.upload_key_keyserver);

        ArrayAdapter<String> adapter = new ArrayAdapter<>(this,
                android.R.layout.simple_spinner_item, Preferences.getPreferences(this)
                .getKeyServers()
        );
        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        mKeyServerSpinner.setAdapter(adapter);
        if (adapter.getCount() > 0) {
            mKeyServerSpinner.setSelection(0);
        } else {
            mUploadButton.setEnabled(false);
        }

        mUploadButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                final Preferences.ProxyPrefs proxyPrefs = Preferences.getPreferences(UploadKeyActivity.this)
                        .getProxyPrefs();
                Runnable ignoreTor = new Runnable() {
                    @Override
                    public void run() {
                        uploadKey(proxyPrefs.parcelableProxy);
                    }
                };

                if (OrbotHelper.isOrbotInRequiredState(R.string.orbot_ignore_tor, ignoreTor, proxyPrefs,
                        UploadKeyActivity.this)) {
                    uploadKey(proxyPrefs.parcelableProxy);
                }
            }
        });

        mDataUri = getIntent().getData();
        if (mDataUri == null) {
            Log.e(Constants.TAG, "Intent data missing. Should be Uri of key!");
            finish();
            return;
        }
    }

    @Override
    protected void initLayout() {
        setContentView(R.layout.upload_key_activity);
    }

    private void uploadKey(ParcelableProxy parcelableProxy) {
        
        Intent intent = new Intent(this, KeychainService.class);

        intent.setAction(KeychainService.ACTION_UPLOAD_KEYRING);

        
        Uri blobUri = KeyRings.buildUnifiedKeyRingUri(mDataUri);
        intent.setData(blobUri);

        
        Bundle data = new Bundle();

        String server = (String) mKeyServerSpinner.getSelectedItem();
        data.putString(KeychainService.UPLOAD_KEY_SERVER, server);

        intent.putExtra(KeychainService.EXTRA_DATA, data);
        intent.putExtra(KeychainService.EXTRA_PARCELABLE_PROXY, parcelableProxy);

        
        ServiceProgressHandler saveHandler = new ServiceProgressHandler(this) {
            @Override
            public void handleMessage(Message message) {
                
                super.handleMessage(message);

                if (message.arg1 == MessageStatus.OKAY.ordinal()) {

                    Toast.makeText(UploadKeyActivity.this, R.string.msg_crt_upload_success,
                            Toast.LENGTH_SHORT).show();
                    finish();
                }
            }
        };

        
        Messenger messenger = new Messenger(saveHandler);
        intent.putExtra(KeychainService.EXTRA_MESSENGER, messenger);

        
        saveHandler.showProgressDialog(
                getString(R.string.progress_uploading),
                ProgressDialog.STYLE_HORIZONTAL, false);

        
        startService(intent);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home: {
                Intent viewIntent = NavUtils.getParentActivityIntent(this);
                viewIntent.setData(KeychainContract.KeyRings.buildGenericKeyRingUri(mDataUri));
                NavUtils.navigateUpTo(this, viewIntent);
                return true;
            }
        }
        return super.onOptionsItemSelected(item);
    }
}

<code block>


package org.sufficientlysecure.keychain.ui;

import android.animation.ObjectAnimator;
import android.annotation.TargetApi;
import android.app.Activity;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.Intent;
import android.database.Cursor;
import android.graphics.Color;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.os.Messenger;
import android.support.v4.app.LoaderManager;
import android.support.v4.content.CursorLoader;
import android.support.v4.content.Loader;
import android.support.v4.view.MenuItemCompat;
import android.support.v7.widget.SearchView;
import android.view.ActionMode;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.AbsListView.MultiChoiceModeListener;
import android.widget.AdapterView;
import android.widget.ListView;
import android.widget.TextView;

import com.getbase.floatingactionbutton.FloatingActionButton;
import com.getbase.floatingactionbutton.FloatingActionsMenu;

import org.sufficientlysecure.keychain.Constants;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.keyimport.ParcelableKeyRing;
import org.sufficientlysecure.keychain.operations.results.ConsolidateResult;
import org.sufficientlysecure.keychain.operations.results.DeleteResult;
import org.sufficientlysecure.keychain.operations.results.ImportKeyResult;
import org.sufficientlysecure.keychain.operations.results.OperationResult;
import org.sufficientlysecure.keychain.provider.KeychainContract;
import org.sufficientlysecure.keychain.provider.KeychainContract.KeyRings;
import org.sufficientlysecure.keychain.provider.KeychainDatabase;
import org.sufficientlysecure.keychain.provider.ProviderHelper;
import org.sufficientlysecure.keychain.service.KeychainService;
import org.sufficientlysecure.keychain.service.ServiceProgressHandler;
import org.sufficientlysecure.keychain.service.PassphraseCacheService;
import org.sufficientlysecure.keychain.ui.dialog.DeleteKeyDialogFragment;
import org.sufficientlysecure.keychain.ui.util.KeyFormattingUtils;
import org.sufficientlysecure.keychain.ui.adapter.KeyAdapter;
import org.sufficientlysecure.keychain.ui.util.Notify;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;

import org.sufficientlysecure.keychain.util.ExportHelper;
import org.sufficientlysecure.keychain.util.FabContainer;
import org.sufficientlysecure.keychain.util.Log;
import org.sufficientlysecure.keychain.util.ParcelableProxy;
import org.sufficientlysecure.keychain.util.Preferences;
import org.sufficientlysecure.keychain.util.tor.OrbotHelper;
import se.emilsjolander.stickylistheaders.StickyListHeadersAdapter;
import se.emilsjolander.stickylistheaders.StickyListHeadersListView;


public class KeyListFragment extends LoaderFragment
        implements SearchView.OnQueryTextListener, AdapterView.OnItemClickListener,
        LoaderManager.LoaderCallbacks<Cursor>, FabContainer {

    static final int REQUEST_REPEAT_PASSPHRASE = 1;
    static final int REQUEST_ACTION = 2;

    ExportHelper mExportHelper;

    private KeyListAdapter mAdapter;
    private StickyListHeadersListView mStickyList;

    
    private ActionMode mActionMode = null;

    private String mQuery;

    private FloatingActionsMenu mFab;

    
    private ArrayList<Long> mIdsForRepeatAskPassphrase;
    
    private int mIndex;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        mExportHelper = new ExportHelper(getActivity());
    }

    
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup superContainer, Bundle savedInstanceState) {
        View root = super.onCreateView(inflater, superContainer, savedInstanceState);
        View view = inflater.inflate(R.layout.key_list_fragment, getContainer());

        mStickyList = (StickyListHeadersListView) view.findViewById(R.id.key_list_list);
        mStickyList.setOnItemClickListener(this);

        mFab = (FloatingActionsMenu) view.findViewById(R.id.fab_main);

        FloatingActionButton fabQrCode = (FloatingActionButton) view.findViewById(R.id.fab_add_qr_code);
        FloatingActionButton fabCloud = (FloatingActionButton) view.findViewById(R.id.fab_add_cloud);
        FloatingActionButton fabFile = (FloatingActionButton) view.findViewById(R.id.fab_add_file);

        fabQrCode.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                mFab.collapse();
                scanQrCode();
            }
        });
        fabCloud.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                mFab.collapse();
                searchCloud();
            }
        });
        fabFile.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                mFab.collapse();
                importFile();
            }
        });


        return root;
    }

    
    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        
        getActivity().setTitle(R.string.app_name);

        mStickyList.setOnItemClickListener(this);
        mStickyList.setAreHeadersSticky(true);
        mStickyList.setDrawingListUnderStickyHeader(false);
        mStickyList.setFastScrollEnabled(true);

        
        
        View footer = new View(getActivity());

        int spacing = (int) android.util.TypedValue.applyDimension(
                android.util.TypedValue.COMPLEX_UNIT_DIP, 72, getResources().getDisplayMetrics()
        );

        android.widget.AbsListView.LayoutParams params = new android.widget.AbsListView.LayoutParams(
                android.widget.AbsListView.LayoutParams.MATCH_PARENT,
                spacing
        );

        footer.setLayoutParams(params);
        mStickyList.addFooterView(footer, null, false);

        
        mStickyList.setFastScrollAlwaysVisible(true);

        mStickyList.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE_MODAL);
        mStickyList.getWrappedList().setMultiChoiceModeListener(new MultiChoiceModeListener() {

            @Override
            public boolean onCreateActionMode(ActionMode mode, Menu menu) {
                android.view.MenuInflater inflater = getActivity().getMenuInflater();
                inflater.inflate(R.menu.key_list_multi, menu);
                mActionMode = mode;
                return true;
            }

            @Override
            public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
                return false;
            }

            @Override
            public boolean onActionItemClicked(ActionMode mode, MenuItem item) {

                
                long[] ids;

                switch (item.getItemId()) {
                    case R.id.menu_key_list_multi_encrypt: {
                        ids = mAdapter.getCurrentSelectedMasterKeyIds();
                        encrypt(mode, ids);
                        break;
                    }
                    case R.id.menu_key_list_multi_delete: {
                        ids = mAdapter.getCurrentSelectedMasterKeyIds();
                        showDeleteKeyDialog(mode, ids, mAdapter.isAnySecretSelected());
                        break;
                    }
                    case R.id.menu_key_list_multi_export: {
                        ids = mAdapter.getCurrentSelectedMasterKeyIds();
                        showMultiExportDialog(ids);
                        break;
                    }
                    case R.id.menu_key_list_multi_select_all: {
                        
                        for (int i = 0; i < mAdapter.getCount(); i++) {
                            mStickyList.setItemChecked(i, true);
                        }
                        break;
                    }
                }
                return true;
            }

            @Override
            public void onDestroyActionMode(ActionMode mode) {
                mActionMode = null;
                mAdapter.clearSelection();
            }

            @Override
            public void onItemCheckedStateChanged(ActionMode mode, int position, long id,
                                                  boolean checked) {
                if (checked) {
                    mAdapter.setNewSelection(position, true);
                } else {
                    mAdapter.removeSelection(position);
                }
                int count = mStickyList.getCheckedItemCount();
                String keysSelected = getResources().getQuantityString(
                        R.plurals.key_list_selected_keys, count, count);
                mode.setTitle(keysSelected);
            }

        });

        
        setHasOptionsMenu(true);

        
        setContentShown(false);

        
        mAdapter = new KeyListAdapter(getActivity(), null, 0);
        mStickyList.setAdapter(mAdapter);

        
        
        getLoaderManager().initLoader(0, null, this);
    }

    static final String ORDER =
            KeyRings.HAS_ANY_SECRET + " DESC, UPPER(" + KeyRings.USER_ID + ") ASC";


    @Override
    public Loader<Cursor> onCreateLoader(int id, Bundle args) {
        
        
        Uri baseUri = KeyRings.buildUnifiedKeyRingsUri();
        String where = null;
        String whereArgs[] = null;
        if (mQuery != null) {
            String[] words = mQuery.trim().split("\\s+");
            whereArgs = new String[words.length];
            for (int i = 0; i < words.length; ++i) {
                if (where == null) {
                    where = "";
                } else {
                    where += " AND ";
                }
                where += KeyRings.USER_ID + " LIKE ?";
                whereArgs[i] = "%" + words[i] + "%";
            }
        }

        
        
        return new CursorLoader(getActivity(), baseUri,
                KeyListAdapter.PROJECTION, where, whereArgs, ORDER);
    }

    @Override
    public void onLoadFinished(Loader<Cursor> loader, Cursor data) {
        
        
        mAdapter.setSearchQuery(mQuery);
        mAdapter.swapCursor(data);

        mStickyList.setAdapter(mAdapter);

        
        mStickyList.setEmptyView(getActivity().findViewById(R.id.key_list_empty));

        
        if (mActionMode != null) {
            mActionMode.finish();
        }

        
        if (isResumed()) {
            setContentShown(true);
        } else {
            setContentShownNoAnimation(true);
        }
    }

    @Override
    public void onLoaderReset(Loader<Cursor> loader) {
        
        
        
        mAdapter.swapCursor(null);
    }

    
    @Override
    public void onItemClick(AdapterView<?> adapterView, View view, int position, long id) {
        Intent viewIntent = new Intent(getActivity(), ViewKeyActivity.class);
        viewIntent.setData(
                KeyRings.buildGenericKeyRingUri(mAdapter.getMasterKeyId(position)));
        startActivity(viewIntent);
    }

    protected void encrypt(ActionMode mode, long[] masterKeyIds) {
        Intent intent = new Intent(getActivity(), EncryptFilesActivity.class);
        intent.setAction(EncryptFilesActivity.ACTION_ENCRYPT_DATA);
        intent.putExtra(EncryptFilesActivity.EXTRA_ENCRYPTION_KEY_IDS, masterKeyIds);
        
        startActivityForResult(intent, REQUEST_ACTION);

        mode.finish();
    }

    
    public void showDeleteKeyDialog(final ActionMode mode, long[] masterKeyIds, boolean hasSecret) {
        
        if (hasSecret && masterKeyIds.length > 1) {
            Notify.create(getActivity(), R.string.secret_cannot_multiple,
                    Notify.Style.ERROR).show();
            return;
        }

        
        Handler returnHandler = new Handler() {
            @Override
            public void handleMessage(Message message) {
                if (message.arg1 == DeleteKeyDialogFragment.MESSAGE_OKAY) {
                    Bundle data = message.getData();
                    if (data != null) {
                        DeleteResult result = data.getParcelable(DeleteResult.EXTRA_RESULT);
                        if (result != null) {
                            result.createNotify(getActivity()).show();
                        }
                    }
                    mode.finish();
                }
            }
        };

        
        Messenger messenger = new Messenger(returnHandler);

        DeleteKeyDialogFragment deleteKeyDialog = DeleteKeyDialogFragment.newInstance(messenger,
                masterKeyIds);

        deleteKeyDialog.show(getActivity().getSupportFragmentManager(), "deleteKeyDialog");
    }


    @Override
    public void onCreateOptionsMenu(final Menu menu, final MenuInflater inflater) {
        inflater.inflate(R.menu.key_list, menu);

        if (Constants.DEBUG) {
            menu.findItem(R.id.menu_key_list_debug_cons).setVisible(true);
            menu.findItem(R.id.menu_key_list_debug_read).setVisible(true);
            menu.findItem(R.id.menu_key_list_debug_write).setVisible(true);
            menu.findItem(R.id.menu_key_list_debug_first_time).setVisible(true);
        }

        
        MenuItem searchItem = menu.findItem(R.id.menu_key_list_search);

        SearchView searchView = (SearchView) MenuItemCompat.getActionView(searchItem);

        
        searchView.setOnQueryTextListener(this);

        
        MenuItemCompat.setOnActionExpandListener(searchItem, new MenuItemCompat.OnActionExpandListener() {
            @Override
            public boolean onMenuItemActionExpand(MenuItem item) {

                
                
                return true;
            }

            @Override
            public boolean onMenuItemActionCollapse(MenuItem item) {
                mQuery = null;
                getLoaderManager().restartLoader(0, null, KeyListFragment.this);

                
                
                return true;
            }
        });

        super.onCreateOptionsMenu(menu, inflater);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {

            case R.id.menu_key_list_create:
                createKey();
                return true;

            case R.id.menu_key_list_export:
                mExportHelper.showExportKeysDialog(null, Constants.Path.APP_DIR_FILE, true);
                return true;

            case R.id.menu_key_list_update_all_keys:
                final Preferences.ProxyPrefs proxyPrefs = Preferences.getPreferences(getActivity())
                        .getProxyPrefs();
                Runnable ignoreTor = new Runnable() {
                    @Override
                    public void run() {
                        updateAllKeys(new ParcelableProxy(null, -1, null));
                    }
                };

                if (OrbotHelper.isOrbotInRequiredState(R.string.orbot_ignore_tor, ignoreTor, proxyPrefs,
                        getActivity())) {
                    updateAllKeys(proxyPrefs.parcelableProxy);
                }
                return true;

            case R.id.menu_key_list_debug_cons:
                consolidate();
                return true;

            case R.id.menu_key_list_debug_read:
                try {
                    KeychainDatabase.debugBackup(getActivity(), true);
                    Notify.create(getActivity(), "Restored debug_backup.db", Notify.Style.OK).show();
                    getActivity().getContentResolver().notifyChange(KeychainContract.KeyRings.CONTENT_URI, null);
                } catch (IOException e) {
                    Log.e(Constants.TAG, "IO Error", e);
                    Notify.create(getActivity(), "IO Error " + e.getMessage(), Notify.Style.ERROR).show();
                }
                return true;

            case R.id.menu_key_list_debug_write:
                try {
                    KeychainDatabase.debugBackup(getActivity(), false);
                    Notify.create(getActivity(), "Backup to debug_backup.db completed", Notify.Style.OK).show();
                } catch (IOException e) {
                    Log.e(Constants.TAG, "IO Error", e);
                    Notify.create(getActivity(), "IO Error: " + e.getMessage(), Notify.Style.ERROR).show();
                }
                return true;

            case R.id.menu_key_list_debug_first_time:
                Preferences prefs = Preferences.getPreferences(getActivity());
                prefs.setFirstTime(true);
                Intent intent = new Intent(getActivity(), CreateKeyActivity.class);
                intent.putExtra(CreateKeyActivity.EXTRA_FIRST_TIME, true);
                startActivity(intent);
                getActivity().finish();
                return true;

            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    public boolean onQueryTextSubmit(String s) {
        return true;
    }

    @Override
    public boolean onQueryTextChange(String s) {
        Log.d(Constants.TAG, "onQueryTextChange s:" + s);
        
        
        
        
        
        
        String tmp = (mQuery == null) ? "" : mQuery;
        if (!s.equals(tmp)) {
            mQuery = s;
            getLoaderManager().restartLoader(0, null, this);
        }
        return true;
    }

    private void searchCloud() {
        Intent importIntent = new Intent(getActivity(), ImportKeysActivity.class);
        importIntent.putExtra(ImportKeysActivity.EXTRA_QUERY, (String) null); 
        startActivity(importIntent);
    }

    private void scanQrCode() {
        Intent scanQrCode = new Intent(getActivity(), ImportKeysProxyActivity.class);
        scanQrCode.setAction(ImportKeysProxyActivity.ACTION_SCAN_IMPORT);
        startActivityForResult(scanQrCode, REQUEST_ACTION);
    }

    private void importFile() {
        Intent intentImportExisting = new Intent(getActivity(), ImportKeysActivity.class);
        intentImportExisting.setAction(ImportKeysActivity.ACTION_IMPORT_KEY_FROM_FILE_AND_RETURN);
        startActivityForResult(intentImportExisting, REQUEST_ACTION);
    }

    private void createKey() {
        Intent intent = new Intent(getActivity(), CreateKeyActivity.class);
        startActivityForResult(intent, REQUEST_ACTION);
    }

    private void updateAllKeys(ParcelableProxy parcelableProxy) {
        Context context = getActivity();

        ProviderHelper providerHelper = new ProviderHelper(context);

        Cursor cursor = providerHelper.getContentResolver().query(
                KeyRings.buildUnifiedKeyRingsUri(), new String[]{
                        KeyRings.FINGERPRINT
                }, null, null, null
        );

        ArrayList<ParcelableKeyRing> keyList = new ArrayList<>();

        while (cursor.moveToNext()) {
            byte[] blob = cursor.getBlob(0);
            String fingerprint = KeyFormattingUtils.convertFingerprintToHex(blob);
            ParcelableKeyRing keyEntry = new ParcelableKeyRing(fingerprint, null, null);
            keyList.add(keyEntry);
        }

        ServiceProgressHandler serviceHandler = new ServiceProgressHandler(getActivity()) {
            @Override
            public void handleMessage(Message message) {
                
                super.handleMessage(message);

                if (message.arg1 == MessageStatus.OKAY.ordinal()) {
                    
                    Bundle returnData = message.getData();
                    if (returnData == null) {
                        return;
                    }
                    final ImportKeyResult result =
                            returnData.getParcelable(OperationResult.EXTRA_RESULT);
                    if (result == null) {
                        Log.e(Constants.TAG, "result == null");
                        return;
                    }

                    result.createNotify(getActivity()).show();
                }
            }
        };

        
        Intent intent = new Intent(getActivity(), KeychainService.class);
        intent.setAction(KeychainService.ACTION_IMPORT_KEYRING);

        
        Bundle data = new Bundle();

        
        {
            Preferences prefs = Preferences.getPreferences(getActivity());
            Preferences.CloudSearchPrefs cloudPrefs =
                    new Preferences.CloudSearchPrefs(true, true, prefs.getPreferredKeyserver());
            data.putString(KeychainService.IMPORT_KEY_SERVER, cloudPrefs.keyserver);
        }

        data.putParcelableArrayList(KeychainService.IMPORT_KEY_LIST, keyList);

        data.putParcelable(KeychainService.EXTRA_PARCELABLE_PROXY, parcelableProxy);

        intent.putExtra(KeychainService.EXTRA_DATA, data);

        
        Messenger messenger = new Messenger(serviceHandler);
        intent.putExtra(KeychainService.EXTRA_MESSENGER, messenger);

        
        serviceHandler.showProgressDialog(
                getString(R.string.progress_updating),
                ProgressDialog.STYLE_HORIZONTAL, true);

        
        getActivity().startService(intent);
    }

    private void consolidate() {
        
        ServiceProgressHandler saveHandler = new ServiceProgressHandler(getActivity()) {
            @Override
            public void handleMessage(Message message) {
                
                super.handleMessage(message);

                if (message.arg1 == MessageStatus.OKAY.ordinal()) {
                    
                    Bundle returnData = message.getData();
                    if (returnData == null) {
                        return;
                    }
                    final ConsolidateResult result =
                            returnData.getParcelable(OperationResult.EXTRA_RESULT);
                    if (result == null) {
                        return;
                    }

                    result.createNotify(getActivity()).show();
                }
            }
        };

        
        Intent intent = new Intent(getActivity(), KeychainService.class);

        intent.setAction(KeychainService.ACTION_CONSOLIDATE);

        
        Bundle data = new Bundle();

        intent.putExtra(KeychainService.EXTRA_DATA, data);

        
        Messenger messenger = new Messenger(saveHandler);
        intent.putExtra(KeychainService.EXTRA_MESSENGER, messenger);

        
        saveHandler.showProgressDialog(
                getString(R.string.progress_importing),
                ProgressDialog.STYLE_HORIZONTAL, false);

        
        getActivity().startService(intent);
    }

    private void showMultiExportDialog(long[] masterKeyIds) {
        mIdsForRepeatAskPassphrase = new ArrayList<>();
        for (long id : masterKeyIds) {
            try {
                if (PassphraseCacheService.getCachedPassphrase(
                        getActivity(), id, id) == null) {
                    mIdsForRepeatAskPassphrase.add(id);
                }
            } catch (PassphraseCacheService.KeyNotFoundException e) {
                
                
            }
        }
        mIndex = 0;
        if (mIdsForRepeatAskPassphrase.size() != 0) {
            startPassphraseActivity();
            return;
        }
        long[] idsForMultiExport = new long[mIdsForRepeatAskPassphrase.size()];
        for (int i = 0; i < mIdsForRepeatAskPassphrase.size(); ++i) {
            idsForMultiExport[i] = mIdsForRepeatAskPassphrase.get(i);
        }
        mExportHelper.showExportKeysDialog(idsForMultiExport,
                Constants.Path.APP_DIR_FILE,
                mAdapter.isAnySecretSelected());
    }

    private void startPassphraseActivity() {
        Intent intent = new Intent(getActivity(), PassphraseDialogActivity.class);
        long masterKeyId = mIdsForRepeatAskPassphrase.get(mIndex++);
        intent.putExtra(PassphraseDialogActivity.EXTRA_SUBKEY_ID, masterKeyId);
        startActivityForResult(intent, REQUEST_REPEAT_PASSPHRASE);
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (requestCode == REQUEST_REPEAT_PASSPHRASE) {
            if (resultCode != Activity.RESULT_OK) {
                return;
            }
            if (mIndex < mIdsForRepeatAskPassphrase.size()) {
                startPassphraseActivity();
                return;
            }
            long[] idsForMultiExport = new long[mIdsForRepeatAskPassphrase.size()];
            for (int i = 0; i < mIdsForRepeatAskPassphrase.size(); ++i) {
                idsForMultiExport[i] = mIdsForRepeatAskPassphrase.get(i);
            }
            mExportHelper.showExportKeysDialog(idsForMultiExport,
                    Constants.Path.APP_DIR_FILE,
                    mAdapter.isAnySecretSelected());
        }

        if (requestCode == REQUEST_ACTION) {
            
            if (data != null && data.hasExtra(OperationResult.EXTRA_RESULT)) {
                OperationResult result = data.getParcelableExtra(OperationResult.EXTRA_RESULT);
                result.createNotify(getActivity()).show();
            } else {
                super.onActivityResult(requestCode, resultCode, data);
            }
        }
    }

    @Override
    public void fabMoveUp(int height) {
        ObjectAnimator anim = ObjectAnimator.ofFloat(mFab, "translationY", 0, -height);
        
        anim.setDuration(270);
        anim.start();
    }

    @Override
    public void fabRestorePosition() {
        ObjectAnimator anim = ObjectAnimator.ofFloat(mFab, "translationY", 0);
        
        anim.setStartDelay(70);
        anim.setDuration(300);
        anim.start();
    }

    public class KeyListAdapter extends KeyAdapter implements StickyListHeadersAdapter {

        private HashMap<Integer, Boolean> mSelection = new HashMap<>();

        public KeyListAdapter(Context context, Cursor c, int flags) {
            super(context, c, flags);
        }

        @Override
        public View newView(Context context, Cursor cursor, ViewGroup parent) {
            View view = super.newView(context, cursor, parent);

            final KeyItemViewHolder holder = (KeyItemViewHolder) view.getTag();

            holder.mSlinger.setVisibility(View.VISIBLE);
            holder.mSlingerButton.setOnClickListener(new OnClickListener() {
                @Override
                public void onClick(View v) {
                    if (holder.mMasterKeyId != null) {
                        Intent safeSlingerIntent = new Intent(mContext, SafeSlingerActivity.class);
                        safeSlingerIntent.putExtra(SafeSlingerActivity.EXTRA_MASTER_KEY_ID, holder.mMasterKeyId);
                        startActivityForResult(safeSlingerIntent, REQUEST_ACTION);
                    }
                }
            });

            return view;
        }

        @Override
        public View getView(int position, View convertView, ViewGroup parent) {
            
            View v = super.getView(position, convertView, parent);

            if (mSelection.get(position) != null) {
                
                v.setBackgroundColor(parent.getResources().getColor(R.color.emphasis));
            } else {
                
                v.setBackgroundColor(Color.TRANSPARENT);
            }

            return v;
        }

        private class HeaderViewHolder {
            TextView mText;
            TextView mCount;
        }

        
        @Override
        public View getHeaderView(int position, View convertView, ViewGroup parent) {
            HeaderViewHolder holder;
            if (convertView == null) {
                holder = new HeaderViewHolder();
                convertView = mInflater.inflate(R.layout.key_list_header, parent, false);
                holder.mText = (TextView) convertView.findViewById(R.id.stickylist_header_text);
                holder.mCount = (TextView) convertView.findViewById(R.id.contacts_num);
                convertView.setTag(holder);
            } else {
                holder = (HeaderViewHolder) convertView.getTag();
            }

            if (!mDataValid) {
                
                Log.d(Constants.TAG, "getHeaderView: No data available at this point!");
                return convertView;
            }

            if (!mCursor.moveToPosition(position)) {
                throw new IllegalStateException("couldn't move cursor to position " + position);
            }

            if (mCursor.getInt(INDEX_HAS_ANY_SECRET) != 0) {
                { 
                    int num = mCursor.getCount();
                    String contactsTotal = mContext.getResources().getQuantityString(R.plurals.n_keys, num, num);
                    holder.mCount.setText(contactsTotal);
                    holder.mCount.setVisibility(View.VISIBLE);
                }

                holder.mText.setText(convertView.getResources().getString(R.string.my_keys));
                return convertView;
            }

            
            String userId = mCursor.getString(INDEX_USER_ID);
            String headerText = convertView.getResources().getString(R.string.user_id_no_name);
            if (userId != null && userId.length() > 0) {
                headerText = "" + userId.charAt(0);
            }
            holder.mText.setText(headerText);
            holder.mCount.setVisibility(View.GONE);
            return convertView;
        }

        
        @Override
        public long getHeaderId(int position) {
            if (!mDataValid) {
                
                Log.d(Constants.TAG, "getHeaderView: No data available at this point!");
                return -1;
            }

            if (!mCursor.moveToPosition(position)) {
                throw new IllegalStateException("couldn't move cursor to position " + position);
            }

            
            if (mCursor.getInt(INDEX_HAS_ANY_SECRET) != 0) {
                return 1L;
            }
            
            String userId = mCursor.getString(INDEX_USER_ID);
            if (userId != null && userId.length() > 0) {
                return Character.toUpperCase(userId.charAt(0));
            } else {
                return Long.MAX_VALUE;
            }
        }

        
        public void setNewSelection(int position, boolean value) {
            mSelection.put(position, value);
            notifyDataSetChanged();
        }

        public boolean isAnySecretSelected() {
            for (int pos : mSelection.keySet()) {
                if (isSecretAvailable(pos))
                    return true;
            }
            return false;
        }

        public long[] getCurrentSelectedMasterKeyIds() {
            long[] ids = new long[mSelection.size()];
            int i = 0;
            
            for (int pos : mSelection.keySet()) {
                ids[i++] = getMasterKeyId(pos);
            }
            return ids;
        }

        public void removeSelection(int position) {
            mSelection.remove(position);
            notifyDataSetChanged();
        }

        public void clearSelection() {
            mSelection.clear();
            notifyDataSetChanged();
        }

    }

}

<code block>


package org.sufficientlysecure.keychain.ui;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.ArrayList;

import android.app.Activity;
import android.app.ProgressDialog;
import android.content.Intent;
import android.os.Bundle;
import android.os.Message;
import android.os.Messenger;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.TextView;

import org.spongycastle.util.encoders.Hex;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.keyimport.ParcelableKeyRing;
import org.sufficientlysecure.keychain.operations.results.DecryptVerifyResult;
import org.sufficientlysecure.keychain.operations.results.ImportKeyResult;
import org.sufficientlysecure.keychain.provider.KeychainContract.KeyRings;
import org.sufficientlysecure.keychain.service.KeychainService;
import org.sufficientlysecure.keychain.service.ServiceProgressHandler;
import org.sufficientlysecure.keychain.ui.CreateKeyActivity.FragAction;
import org.sufficientlysecure.keychain.ui.CreateKeyActivity.NfcListenerFragment;
import org.sufficientlysecure.keychain.ui.util.KeyFormattingUtils;
import org.sufficientlysecure.keychain.util.ParcelableProxy;
import org.sufficientlysecure.keychain.util.Preferences;
import org.sufficientlysecure.keychain.util.tor.OrbotHelper;


public class CreateKeyYubiKeyImportFragment extends Fragment implements NfcListenerFragment {

    private static final String ARG_FINGERPRINT = "fingerprint";
    public static final String ARG_AID = "aid";
    public static final String ARG_USER_ID = "user_ids";

    CreateKeyActivity mCreateKeyActivity;

    private byte[] mNfcFingerprints;
    private byte[] mNfcAid;
    private String mNfcUserId;
    private String mNfcFingerprint;
    private ImportKeysListFragment mListFragment;
    private TextView vSerNo;
    private TextView vUserId;

    public static Fragment createInstance(byte[] scannedFingerprints, byte[] nfcAid, String userId) {

        CreateKeyYubiKeyImportFragment frag = new CreateKeyYubiKeyImportFragment();

        Bundle args = new Bundle();
        args.putByteArray(ARG_FINGERPRINT, scannedFingerprints);
        args.putByteArray(ARG_AID, nfcAid);
        args.putString(ARG_USER_ID, userId);
        frag.setArguments(args);

        return frag;
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        Bundle args = savedInstanceState != null ? savedInstanceState : getArguments();

        mNfcFingerprints = args.getByteArray(ARG_FINGERPRINT);
        mNfcAid = args.getByteArray(ARG_AID);
        mNfcUserId = args.getString(ARG_USER_ID);

        byte[] fp = new byte[20];
        ByteBuffer.wrap(fp).put(mNfcFingerprints, 0, 20);
        mNfcFingerprint = KeyFormattingUtils.convertFingerprintToHex(fp);

    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.create_yubikey_import_fragment, container, false);

        vSerNo = (TextView) view.findViewById(R.id.yubikey_serno);
        vUserId = (TextView) view.findViewById(R.id.yubikey_userid);

        {
            View mBackButton = view.findViewById(R.id.create_key_back_button);
            mBackButton.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    if (getFragmentManager().getBackStackEntryCount() == 0) {
                        getActivity().setResult(Activity.RESULT_CANCELED);
                        getActivity().finish();
                    } else {
                        mCreateKeyActivity.loadFragment(null, FragAction.TO_LEFT);
                    }
                }
            });

            View mNextButton = view.findViewById(R.id.create_key_next_button);
            mNextButton.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {

                    final Preferences.ProxyPrefs proxyPrefs = Preferences.getPreferences(getActivity()).getProxyPrefs();
                    Runnable ignoreTor = new Runnable() {
                        @Override
                        public void run() {
                            importKey(new ParcelableProxy(null, -1, null));
                        }
                    };

                    if (OrbotHelper.isOrbotInRequiredState(R.string.orbot_ignore_tor, ignoreTor, proxyPrefs,
                            getActivity())) {
                        importKey(proxyPrefs.parcelableProxy);
                    }
                }
            });
        }

        mListFragment = ImportKeysListFragment.newInstance(null, null,
                "0x" + mNfcFingerprint, true, null);

        view.findViewById(R.id.button_search).setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                final Preferences.ProxyPrefs proxyPrefs = Preferences.getPreferences(getActivity()).getProxyPrefs();
                Runnable ignoreTor = new Runnable() {
                    @Override
                    public void run() {
                        refreshSearch(new ParcelableProxy(null, -1, null));
                    }
                };

                if (OrbotHelper.isOrbotInRequiredState(R.string.orbot_ignore_tor, ignoreTor, proxyPrefs,
                        getActivity())) {
                    refreshSearch(proxyPrefs.parcelableProxy);
                }
            }
        });

        setData();

        getFragmentManager().beginTransaction()
                .replace(R.id.yubikey_import_fragment, mListFragment, "yubikey_import")
                .commit();

        return view;
    }

    @Override
    public void onSaveInstanceState(Bundle args) {
        super.onSaveInstanceState(args);

        args.putByteArray(ARG_FINGERPRINT, mNfcFingerprints);
        args.putByteArray(ARG_AID, mNfcAid);
        args.putString(ARG_USER_ID, mNfcUserId);
    }

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);
        mCreateKeyActivity = (CreateKeyActivity) getActivity();
    }

    public void setData() {
        String serno = Hex.toHexString(mNfcAid, 10, 4);
        vSerNo.setText(getString(R.string.yubikey_serno, serno));

        if (!mNfcUserId.isEmpty()) {
            vUserId.setText(getString(R.string.yubikey_key_holder, mNfcUserId));
        } else {
            vUserId.setText(getString(R.string.yubikey_key_holder_not_set));
        }
    }

    public void refreshSearch(ParcelableProxy parcelableProxy) {
        
        mListFragment.loadNew(new ImportKeysListFragment.CloudLoaderState("0x" + mNfcFingerprint,
                Preferences.getPreferences(getActivity()).getCloudSearchPrefs()), parcelableProxy);
    }

    public void importKey(ParcelableProxy parcelableProxy) {

        
        ServiceProgressHandler saveHandler = new ServiceProgressHandler(getActivity()) {
            @Override
            public void handleMessage(Message message) {
                
                super.handleMessage(message);

                if (message.arg1 == MessageStatus.OKAY.ordinal()) {
                    
                    Bundle returnData = message.getData();

                    ImportKeyResult result =
                            returnData.getParcelable(DecryptVerifyResult.EXTRA_RESULT);

                    long[] masterKeyIds = result.getImportedMasterKeyIds();

                    

                    if (!result.success() || masterKeyIds.length == 0) {
                        result.createNotify(getActivity()).show();
                        return;
                    }

                    Intent intent = new Intent(getActivity(), ViewKeyActivity.class);
                    
                    
                    intent.setData(KeyRings.buildGenericKeyRingUri(masterKeyIds[0]));
                    intent.putExtra(ViewKeyActivity.EXTRA_DISPLAY_RESULT, result);
                    intent.putExtra(ViewKeyActivity.EXTRA_NFC_AID, mNfcAid);
                    intent.putExtra(ViewKeyActivity.EXTRA_NFC_USER_ID, mNfcUserId);
                    intent.putExtra(ViewKeyActivity.EXTRA_NFC_FINGERPRINTS, mNfcFingerprints);
                    startActivity(intent);
                    getActivity().finish();

                }

            }
        };

        
        Intent intent = new Intent(getActivity(), KeychainService.class);

        
        Bundle data = new Bundle();

        intent.setAction(KeychainService.ACTION_IMPORT_KEYRING);

        ArrayList<ParcelableKeyRing> keyList = new ArrayList<>();
        keyList.add(new ParcelableKeyRing(mNfcFingerprint, null, null));
        data.putParcelableArrayList(KeychainService.IMPORT_KEY_LIST, keyList);

        {
            Preferences prefs = Preferences.getPreferences(getActivity());
            Preferences.CloudSearchPrefs cloudPrefs =
                    new Preferences.CloudSearchPrefs(true, true, prefs.getPreferredKeyserver());
            data.putString(KeychainService.IMPORT_KEY_SERVER, cloudPrefs.keyserver);
        }

        data.putParcelable(KeychainService.EXTRA_PARCELABLE_PROXY, parcelableProxy);

        intent.putExtra(KeychainService.EXTRA_DATA, data);

        
        Messenger messenger = new Messenger(saveHandler);
        intent.putExtra(KeychainService.EXTRA_MESSENGER, messenger);

        saveHandler.showProgressDialog(
                getString(R.string.progress_importing),
                ProgressDialog.STYLE_HORIZONTAL, false
        );

        
        getActivity().startService(intent);

    }

    @Override
    public void onNfcPerform() throws IOException {

        mNfcFingerprints = mCreateKeyActivity.nfcGetFingerprints();
        mNfcAid = mCreateKeyActivity.nfcGetAid();
        mNfcUserId = mCreateKeyActivity.nfcGetUserId();

        byte[] fp = new byte[20];
        ByteBuffer.wrap(fp).put(mNfcFingerprints, 0, 20);
        mNfcFingerprint = KeyFormattingUtils.convertFingerprintToHex(fp);

        setData();

        Preferences.ProxyPrefs proxyPrefs = Preferences.getPreferences(getActivity()).getProxyPrefs();
        Runnable ignoreTor = new Runnable() {
            @Override
            public void run() {
                refreshSearch(new ParcelableProxy(null, -1, null));
            }
        };

        if (OrbotHelper.isOrbotInRequiredState(R.string.orbot_ignore_tor, ignoreTor, proxyPrefs,
                getActivity())) {
            refreshSearch(proxyPrefs.parcelableProxy);
        }

    }
}

<code block>


package org.sufficientlysecure.keychain.ui.dialog;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Message;
import android.os.Messenger;
import android.os.RemoteException;
import android.support.v4.app.DialogFragment;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.View;
import android.view.inputmethod.EditorInfo;
import android.view.inputmethod.InputMethodManager;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.TextView;
import android.widget.TextView.OnEditorActionListener;

import com.squareup.okhttp.OkHttpClient;
import com.squareup.okhttp.Request;
import org.sufficientlysecure.keychain.Constants;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.keyimport.HkpKeyserver;
import org.sufficientlysecure.keychain.util.Log;
import org.sufficientlysecure.keychain.util.Preferences;
import org.sufficientlysecure.keychain.util.TlsHelper;
import org.sufficientlysecure.keychain.util.tor.OrbotHelper;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.Proxy;
import java.net.URI;
import java.net.URISyntaxException;

public class AddKeyserverDialogFragment extends DialogFragment implements OnEditorActionListener {
    private static final String ARG_MESSENGER = "messenger";

    public static final int MESSAGE_OKAY = 1;
    public static final int MESSAGE_VERIFICATION_FAILED = 2;

    public static final String MESSAGE_KEYSERVER = "new_keyserver";
    public static final String MESSAGE_VERIFIED = "verified";
    public static final String MESSAGE_FAILURE_REASON = "failure_reason";

    private Messenger mMessenger;
    private EditText mKeyserverEditText;
    private CheckBox mVerifyKeyserverCheckBox;

    public static enum FailureReason {
        INVALID_URL,
        CONNECTION_FAILED
    }

    ;

    
    public static AddKeyserverDialogFragment newInstance(Messenger messenger) {
        AddKeyserverDialogFragment frag = new AddKeyserverDialogFragment();
        Bundle args = new Bundle();
        args.putParcelable(ARG_MESSENGER, messenger);

        frag.setArguments(args);

        return frag;
    }

    
    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
        final Activity activity = getActivity();

        mMessenger = getArguments().getParcelable(ARG_MESSENGER);

        CustomAlertDialogBuilder alert = new CustomAlertDialogBuilder(activity);

        alert.setTitle(R.string.add_keyserver_dialog_title);

        LayoutInflater inflater = activity.getLayoutInflater();
        View view = inflater.inflate(R.layout.add_keyserver_dialog, null);
        alert.setView(view);

        mKeyserverEditText = (EditText) view.findViewById(R.id.keyserver_url_edit_text);
        mVerifyKeyserverCheckBox = (CheckBox) view.findViewById(R.id.verify_keyserver_checkbox);

        
        
        alert.setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int id) {
                
                
                
            }
        });

        alert.setNegativeButton(android.R.string.cancel, new DialogInterface.OnClickListener() {

            @Override
            public void onClick(DialogInterface dialog, int id) {
                dismiss();
            }
        });

        
        
        
        
        
        mKeyserverEditText.setOnFocusChangeListener(new View.OnFocusChangeListener() {
            @Override
            public void onFocusChange(View v, boolean hasFocus) {
                mKeyserverEditText.post(new Runnable() {
                    @Override
                    public void run() {
                        InputMethodManager imm = (InputMethodManager) getActivity()
                                .getSystemService(Context.INPUT_METHOD_SERVICE);
                        imm.showSoftInput(mKeyserverEditText, InputMethodManager.SHOW_IMPLICIT);
                    }
                });
            }
        });
        mKeyserverEditText.requestFocus();

        mKeyserverEditText.setImeActionLabel(getString(android.R.string.ok),
                EditorInfo.IME_ACTION_DONE);
        mKeyserverEditText.setOnEditorActionListener(this);

        return alert.show();
    }

    @Override
    public void onStart() {
        super.onStart();
        AlertDialog addKeyserverDialog = (AlertDialog) getDialog();
        if (addKeyserverDialog != null) {
            Button positiveButton = addKeyserverDialog.getButton(Dialog.BUTTON_POSITIVE);
            positiveButton.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    final String keyserverUrl = mKeyserverEditText.getText().toString();
                    if (mVerifyKeyserverCheckBox.isChecked()) {
                        final Preferences.ProxyPrefs proxyPrefs = Preferences.getPreferences(getActivity())
                                .getProxyPrefs();
                        Runnable ignoreTor = new Runnable() {
                            @Override
                            public void run() {
                                verifyConnection(keyserverUrl, null);
                            }
                        };

                        if (OrbotHelper.isOrbotInRequiredState(R.string.orbot_ignore_tor, ignoreTor, proxyPrefs,
                                getActivity())) {
                            verifyConnection(keyserverUrl, proxyPrefs.parcelableProxy.getProxy());
                        }
                    } else {
                        dismiss();
                        
                        addKeyserver(keyserverUrl, false);
                    }
                }
            });
        }
    }

    public void addKeyserver(String keyserver, boolean verified) {
        dismiss();
        Bundle data = new Bundle();
        data.putString(MESSAGE_KEYSERVER, keyserver);
        data.putBoolean(MESSAGE_VERIFIED, verified);

        sendMessageToHandler(MESSAGE_OKAY, data);
    }

    public void verificationFailed(FailureReason reason) {
        Bundle data = new Bundle();
        data.putSerializable(MESSAGE_FAILURE_REASON, reason);

        sendMessageToHandler(MESSAGE_VERIFICATION_FAILED, data);
    }

    public void verifyConnection(String keyserver, final Proxy proxy) {

        new AsyncTask<String, Void, FailureReason>() {
            ProgressDialog mProgressDialog;
            String mKeyserver;

            @Override
            protected void onPreExecute() {
                mProgressDialog = new ProgressDialog(getActivity());
                mProgressDialog.setMessage(getString(R.string.progress_verifying_keyserver_url));
                mProgressDialog.setCancelable(false);
                mProgressDialog.show();
            }

            @Override
            protected FailureReason doInBackground(String... keyservers) {
                mKeyserver = keyservers[0];
                FailureReason reason = null;
                try {
                    
                    Uri keyserverUri = Uri.parse(mKeyserver);
                    String scheme = keyserverUri.getScheme();
                    String schemeSpecificPart = keyserverUri.getSchemeSpecificPart();
                    String fragment = keyserverUri.getFragment();
                    if (scheme == null) throw new MalformedURLException();
                    if (scheme.equalsIgnoreCase("hkps")) scheme = "https";
                    else if (scheme.equalsIgnoreCase("hkp")) scheme = "http";
                    URI newKeyserver = new URI(scheme, schemeSpecificPart, fragment);

                    Log.d("Converted URL", newKeyserver.toString());

                    OkHttpClient client = HkpKeyserver.getClient(newKeyserver.toURL(), proxy);
                    TlsHelper.pinCertificateIfNecessary(client, newKeyserver.toURL());
                    client.newCall(new Request.Builder().url(newKeyserver.toURL()).build()).execute();
                } catch (TlsHelper.TlsHelperException e) {
                    reason = FailureReason.CONNECTION_FAILED;
                } catch (MalformedURLException e) {
                    Log.w(Constants.TAG, "Invalid keyserver URL entered by user.");
                    reason = FailureReason.INVALID_URL;
                } catch (URISyntaxException e) {
                    Log.w(Constants.TAG, "Invalid keyserver URL entered by user.");
                    reason = FailureReason.INVALID_URL;
                } catch (IOException e) {
                    Log.w(Constants.TAG, "Could not connect to entered keyserver url");
                    reason = FailureReason.CONNECTION_FAILED;
                }
                return reason;
            }

            @Override
            protected void onPostExecute(FailureReason failureReason) {
                mProgressDialog.dismiss();
                if (failureReason == null) {
                    addKeyserver(mKeyserver, true);
                } else {
                    verificationFailed(failureReason);
                }
            }
        }.execute(keyserver);
    }

    @Override
    public void onDismiss(DialogInterface dialog) {
        super.onDismiss(dialog);

        
        hideKeyboard();
    }

    private void hideKeyboard() {
        if (getActivity() == null) {
            return;
        }
        InputMethodManager inputManager = (InputMethodManager) getActivity()
                .getSystemService(Context.INPUT_METHOD_SERVICE);

        
        View v = getActivity().getCurrentFocus();
        if (v == null)
            return;

        inputManager.hideSoftInputFromWindow(v.getWindowToken(), 0);
    }

    
    @Override
    public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
        if (EditorInfo.IME_ACTION_DONE == actionId) {
            AlertDialog dialog = ((AlertDialog) getDialog());
            Button bt = dialog.getButton(AlertDialog.BUTTON_POSITIVE);

            bt.performClick();
            return true;
        }
        return false;
    }

    
    private void sendMessageToHandler(Integer what, Bundle data) {
        Message msg = Message.obtain();
        msg.what = what;
        if (data != null) {
            msg.setData(data);
        }

        try {
            mMessenger.send(msg);
        } catch (RemoteException e) {
            Log.w(Constants.TAG, "Exception sending message, Is handler present?", e);
        } catch (NullPointerException e) {
            Log.w(Constants.TAG, "Messenger is null!", e);
        }
    }
}

<code block>



package org.sufficientlysecure.keychain.ui.dialog;

import android.app.Dialog;
import android.content.DialogInterface;
import android.os.Bundle;
import android.os.Message;
import android.os.Messenger;
import android.os.RemoteException;
import android.support.v4.app.DialogFragment;

import org.sufficientlysecure.keychain.Constants;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.util.Log;
import org.sufficientlysecure.keychain.util.tor.OrbotHelper;


public class OrbotStartDialogFragment extends DialogFragment {
    private static final String ARG_MESSENGER = "messenger";
    private static final String ARG_TITLE = "title";
    private static final String ARG_MESSAGE = "message";
    private static final String ARG_MIDDLE_BUTTON = "middleButton";

    public static final int MESSAGE_MIDDLE_BUTTON = 1;

    public static OrbotStartDialogFragment newInstance(Messenger messenger, int title, int message, int middleButton) {
        Bundle args = new Bundle();
        args.putParcelable(ARG_MESSENGER, messenger);
        args.putInt(ARG_TITLE, title);
        args.putInt(ARG_MESSAGE, message);
        args.putInt(ARG_MIDDLE_BUTTON, middleButton);

        OrbotStartDialogFragment fragment = new OrbotStartDialogFragment();
        fragment.setArguments(args);

        return fragment;
    }

    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {

        final Messenger messenger = getArguments().getParcelable(ARG_MESSENGER);
        int title = getArguments().getInt(ARG_TITLE);
        final int message = getArguments().getInt(ARG_MESSAGE);
        int middleButton = getArguments().getInt(ARG_MIDDLE_BUTTON);

        CustomAlertDialogBuilder builder = new CustomAlertDialogBuilder(getActivity());
        builder.setTitle(title).setMessage(message);

        builder.setNegativeButton(R.string.orbot_start_dialog_cancel, new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {

            }
        });

        builder.setPositiveButton(R.string.orbot_start_dialog_start, new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                getActivity().startActivityForResult(OrbotHelper.getOrbotStartIntent(), 1);
            }
        });

        builder.setNeutralButton(middleButton, new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                Message msg = new Message();
                msg.what = MESSAGE_MIDDLE_BUTTON;
                try {
                    messenger.send(msg);
                } catch (RemoteException e) {
                    Log.w(Constants.TAG, "Exception sending message, Is handler present?", e);
                } catch (NullPointerException e) {
                    Log.w(Constants.TAG, "Messenger is null!", e);
                }
            }
        });

        return builder.show();
    }
}

<code block>


package org.sufficientlysecure.keychain.util.orbot;

import android.util.Log;

import java.io.BufferedReader;
import java.io.File;
import java.io.InputStreamReader;
import java.net.URLEncoder;
import java.util.StringTokenizer;



public class TorServiceUtils {

    private final static String TAG = "TorUtils";
    
    public final static String SHELL_CMD_PS = "ps";
    public final static String SHELL_CMD_PIDOF = "pidof";

    public static int findProcessId(String command) {
        int procId = -1;

        try {
            procId = findProcessIdWithPidOf(command);

            if (procId == -1)
                procId = findProcessIdWithPS(command);
        } catch (Exception e) {
            try {
                procId = findProcessIdWithPS(command);
            } catch (Exception e2) {
                Log.e(TAG, "Unable to get proc id for command: " + URLEncoder.encode(command), e2);
            }
        }

        return procId;
    }

    
    public static int findProcessIdWithPidOf(String command) throws Exception {

        int procId = -1;

        Runtime r = Runtime.getRuntime();

        Process procPs = null;

        String baseName = new File(command).getName();
        
        procPs = r.exec(new String[]{
                SHELL_CMD_PIDOF, baseName
        });
        

        BufferedReader reader = new BufferedReader(new InputStreamReader(procPs.getInputStream()));
        String line = null;

        while ((line = reader.readLine()) != null) {

            try {
                
                procId = Integer.parseInt(line.trim());
                break;
            } catch (NumberFormatException e) {
                Log.e("TorServiceUtils", "unable to parse process pid: " + line, e);
            }
        }

        return procId;

    }

    
    public static int findProcessIdWithPS(String command) throws Exception {

        int procId = -1;

        Runtime r = Runtime.getRuntime();

        Process procPs = null;

        procPs = r.exec(SHELL_CMD_PS);

        BufferedReader reader = new BufferedReader(new InputStreamReader(procPs.getInputStream()));
        String line = null;

        while ((line = reader.readLine()) != null) {
            if (line.indexOf(' ' + command) != -1) {

                StringTokenizer st = new StringTokenizer(line, " ");
                st.nextToken(); 

                procId = Integer.parseInt(st.nextToken().trim());

                break;
            }
        }

        return procId;

    }
}

<code block>


package org.sufficientlysecure.keychain.util.orbot;

import android.app.Activity;
import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.os.Handler;
import android.os.Message;
import android.os.Messenger;
import android.support.v4.app.DialogFragment;
import android.support.v4.app.FragmentActivity;
import android.support.v4.app.FragmentManager;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.ui.dialog.InstallDialogFragment;
import org.sufficientlysecure.keychain.ui.dialog.OrbotStartDialogFragment;
import org.sufficientlysecure.keychain.ui.dialog.PreferenceInstallDialogFragment;
import org.sufficientlysecure.keychain.util.Preferences;


public class OrbotHelper {

    public final static String ORBOT_PACKAGE_NAME = "org.torproject.android";
    public final static String TOR_BIN_PATH = "/data/data/org.torproject.android/app_bin/tor";

    public final static String ACTION_START_TOR = "org.torproject.android.START_TOR";

    public static boolean isOrbotRunning() {
        int procId = TorServiceUtils.findProcessId(TOR_BIN_PATH);

        return (procId != -1);
    }

    public static boolean isOrbotInstalled(Context context) {
        return isAppInstalled(ORBOT_PACKAGE_NAME, context);
    }

    private static boolean isAppInstalled(String uri, Context context) {
        PackageManager pm = context.getPackageManager();
        boolean installed = false;
        try {
            pm.getPackageInfo(uri, PackageManager.GET_ACTIVITIES);
            installed = true;
        } catch (PackageManager.NameNotFoundException e) {
            installed = false;
        }
        return installed;
    }

    
    public static android.app.DialogFragment getPreferenceInstallDialogFragment() {
        return PreferenceInstallDialogFragment.newInstance(R.string.orbot_install_dialog_title,
                R.string.orbot_install_dialog_content, ORBOT_PACKAGE_NAME);
    }

    public static DialogFragment getInstallDialogFragment() {
        return InstallDialogFragment.newInstance(R.string.orbot_install_dialog_title,
                R.string.orbot_install_dialog_content, ORBOT_PACKAGE_NAME);
    }

    public static DialogFragment getInstallDialogFragmentWithThirdButton(Messenger messenger, int middleButton) {
        return InstallDialogFragment.newInstance(messenger, R.string.orbot_install_dialog_title,
                R.string.orbot_install_dialog_content, ORBOT_PACKAGE_NAME, middleButton, true);
    }

    public static DialogFragment getOrbotStartDialogFragment(Messenger messenger, int middleButton) {
        return OrbotStartDialogFragment.newInstance(messenger, R.string.orbot_start_dialog_title, R.string
                        .orbot_start_dialog_content,
                middleButton);
    }

    public static Intent getOrbotStartIntent() {
        Intent intent = new Intent(ACTION_START_TOR);
        intent.setPackage(ORBOT_PACKAGE_NAME);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        return intent;
    }

    
    public static boolean isOrbotInRequiredState(int middleButton, final Runnable middleButtonRunnable,
                                                 Preferences.ProxyPrefs proxyPrefs, FragmentActivity fragmentActivity) {
        Handler ignoreTorHandler = new Handler() {
            @Override
            public void handleMessage(Message msg) {
                
                middleButtonRunnable.run();
            }
        };

        if (!proxyPrefs.torEnabled) {
            return true;
        }

        if (!OrbotHelper.isOrbotInstalled(fragmentActivity)) {

            OrbotHelper.getInstallDialogFragmentWithThirdButton(
                    new Messenger(ignoreTorHandler),
                    R.string.orbot_install_dialog_ignore_tor
            ).show(fragmentActivity.getSupportFragmentManager(), "OrbotHelperOrbotInstallDialog");

            return false;
        } else if (!OrbotHelper.isOrbotRunning()) {

            OrbotHelper.getOrbotStartDialogFragment(new Messenger(ignoreTorHandler),
                    R.string.orbot_install_dialog_ignore_tor)
                    .show(fragmentActivity.getSupportFragmentManager(), "OrbotHelperOrbotStartDialog");

            return false;
        } else {
            return true;
        }
    }
}

<code block>


package org.sufficientlysecure.keychain.ui;

import android.annotation.TargetApi;
import android.app.ProgressDialog;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.net.Uri;
import android.nfc.NdefMessage;
import android.nfc.NfcAdapter;
import android.os.Build;
import android.os.Bundle;
import android.os.Message;
import android.os.Messenger;
import android.os.Parcelable;
import android.support.v4.app.FragmentActivity;
import android.widget.Toast;

import com.google.zxing.integration.android.IntentIntegrator;
import com.google.zxing.integration.android.IntentResult;

import org.sufficientlysecure.keychain.Constants;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.intents.OpenKeychainIntents;
import org.sufficientlysecure.keychain.keyimport.ParcelableKeyRing;
import org.sufficientlysecure.keychain.operations.results.ImportKeyResult;
import org.sufficientlysecure.keychain.operations.results.OperationResult;
import org.sufficientlysecure.keychain.operations.results.OperationResult.LogType;
import org.sufficientlysecure.keychain.operations.results.SingletonResult;
import org.sufficientlysecure.keychain.service.KeychainService;
import org.sufficientlysecure.keychain.service.ServiceProgressHandler;
import org.sufficientlysecure.keychain.util.IntentIntegratorSupportV4;
import org.sufficientlysecure.keychain.util.Log;
import org.sufficientlysecure.keychain.util.ParcelableProxy;
import org.sufficientlysecure.keychain.util.Preferences;
import org.sufficientlysecure.keychain.util.orbot.OrbotHelper;

import java.util.ArrayList;
import java.util.Locale;


public class ImportKeysProxyActivity extends FragmentActivity {

    public static final String ACTION_QR_CODE_API = OpenKeychainIntents.IMPORT_KEY_FROM_QR_CODE;
    
    public static final String ACTION_SCAN_WITH_RESULT = Constants.INTENT_PREFIX + "SCAN_QR_CODE_WITH_RESULT";
    public static final String ACTION_SCAN_IMPORT = Constants.INTENT_PREFIX + "SCAN_QR_CODE_IMPORT";

    public static final String EXTRA_FINGERPRINT = "fingerprint";

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        

        handleActions(getIntent());
    }

    protected void handleActions(Intent intent) {
        String action = intent.getAction();
        Uri dataUri = intent.getData();
        String scheme = intent.getScheme();

        if (scheme != null && scheme.toLowerCase(Locale.ENGLISH).equals(Constants.FINGERPRINT_SCHEME)) {
            

            processScannedContent(dataUri);
        } else if (ACTION_SCAN_WITH_RESULT.equals(action)
                || ACTION_SCAN_IMPORT.equals(action) || ACTION_QR_CODE_API.equals(action)) {
            IntentIntegrator integrator = new IntentIntegrator(this);
            integrator.setDesiredBarcodeFormats(IntentIntegrator.QR_CODE_TYPES)
                    .setPrompt(getString(R.string.import_qr_code_text))
                    .setResultDisplayDuration(0);
            integrator.setOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
            integrator.initiateScan();
        } else if (NfcAdapter.ACTION_NDEF_DISCOVERED.equals(getIntent().getAction())) {
            
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
                handleActionNdefDiscovered(getIntent());
            } else {
                Log.e(Constants.TAG, "Android Beam not supported by Android < 4.1");
                finish();
            }
        } else {
            Log.e(Constants.TAG, "No valid scheme or action given!");
            finish();
        }
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (requestCode == IntentIntegratorSupportV4.REQUEST_CODE) {
            IntentResult scanResult = IntentIntegratorSupportV4.parseActivityResult(requestCode,
                    resultCode, data);

            if (scanResult == null || scanResult.getFormatName() == null) {
                Log.e(Constants.TAG, "scanResult or formatName null! Should not happen!");
                finish();
                return;
            }

            String scannedContent = scanResult.getContents();
            processScannedContent(scannedContent);

            return;
        }
        
        if (data != null && data.hasExtra(OperationResult.EXTRA_RESULT)) {
            returnResult(data);
        } else {
            super.onActivityResult(requestCode, resultCode, data);
            finish();
        }
    }

    private void processScannedContent(String content) {
        Uri uri = Uri.parse(content);
        processScannedContent(uri);
    }

    private void processScannedContent(Uri uri) {
        String action = getIntent().getAction();

        Log.d(Constants.TAG, "scanned: " + uri);

        
        if (uri == null || uri.getScheme() == null ||
                !uri.getScheme().toLowerCase(Locale.ENGLISH).equals(Constants.FINGERPRINT_SCHEME)) {
            SingletonResult result = new SingletonResult(
                    SingletonResult.RESULT_ERROR, LogType.MSG_WRONG_QR_CODE);
            Intent intent = new Intent();
            intent.putExtra(SingletonResult.EXTRA_RESULT, result);
            returnResult(intent);
            return;
        }
        final String fingerprint = uri.getEncodedSchemeSpecificPart().toLowerCase(Locale.ENGLISH);
        if (!fingerprint.matches("[a-fA-F0-9]{40}")) {
            SingletonResult result = new SingletonResult(
                    SingletonResult.RESULT_ERROR, LogType.MSG_WRONG_QR_CODE_FP);
            Intent intent = new Intent();
            intent.putExtra(SingletonResult.EXTRA_RESULT, result);
            returnResult(intent);
            return;
        }

        if (ACTION_SCAN_WITH_RESULT.equals(action)) {
            Intent result = new Intent();
            result.putExtra(EXTRA_FINGERPRINT, fingerprint);
            setResult(RESULT_OK, result);
            finish();
        } else {
            final Preferences.ProxyPrefs proxyPrefs = Preferences.getPreferences(this).getProxyPrefs();
            Runnable ignoreTor = new Runnable() {
                @Override
                public void run() {
                    importKeys(fingerprint, new ParcelableProxy(null, -1, null));
                }
            };

            if (OrbotHelper.isOrbotInRequiredState(R.string.orbot_ignore_tor, ignoreTor, proxyPrefs,
                    this)) {
                importKeys(fingerprint, proxyPrefs.parcelableProxy);
            }
        }

    }

    public void returnResult(Intent data) {
        String action = getIntent().getAction();

        if (ACTION_QR_CODE_API.equals(action)) {
            
            OperationResult result = data.getParcelableExtra(OperationResult.EXTRA_RESULT);
            String str = getString(result.getLog().getLast().mType.getMsgId());
            Toast.makeText(this, str, Toast.LENGTH_LONG).show();
            finish();
        } else {
            setResult(RESULT_OK, data);
            finish();
        }
    }

    public void importKeys(byte[] keyringData, ParcelableProxy parcelableProxy) {
        ParcelableKeyRing keyEntry = new ParcelableKeyRing(keyringData);
        ArrayList<ParcelableKeyRing> selectedEntries = new ArrayList<>();
        selectedEntries.add(keyEntry);

        startImportService(selectedEntries, parcelableProxy);
    }

    public void importKeys(String fingerprint, ParcelableProxy parcelableProxy) {
        ParcelableKeyRing keyEntry = new ParcelableKeyRing(fingerprint, null, null);
        ArrayList<ParcelableKeyRing> selectedEntries = new ArrayList<>();
        selectedEntries.add(keyEntry);

        startImportService(selectedEntries, parcelableProxy);
    }

    private void startImportService(ArrayList<ParcelableKeyRing> keyRings, ParcelableProxy parcelableProxy) {

        
        ServiceProgressHandler serviceHandler = new ServiceProgressHandler(this) {
            @Override
            public void handleMessage(Message message) {
                
                super.handleMessage(message);

                if (message.arg1 == MessageStatus.OKAY.ordinal()) {
                    
                    Bundle returnData = message.getData();
                    if (returnData == null) {
                        finish();
                        return;
                    }
                    final ImportKeyResult result =
                            returnData.getParcelable(OperationResult.EXTRA_RESULT);
                    if (result == null) {
                        Log.e(Constants.TAG, "result == null");
                        finish();
                        return;
                    }

                    if (!result.success()) {
                        
                        Intent data = new Intent();
                        data.putExtras(returnData);
                        returnResult(data);
                        return;
                    }

                    Intent certifyIntent = new Intent(ImportKeysProxyActivity.this,
                            CertifyKeyActivity.class);
                    certifyIntent.putExtra(CertifyKeyActivity.EXTRA_RESULT, result);
                    certifyIntent.putExtra(CertifyKeyActivity.EXTRA_KEY_IDS,
                            result.getImportedMasterKeyIds());
                    startActivityForResult(certifyIntent, 0);
                }
            }
        };

        
        Bundle data = new Bundle();

        
        {
            Preferences prefs = Preferences.getPreferences(this);
            Preferences.CloudSearchPrefs cloudPrefs =
                    new Preferences.CloudSearchPrefs(true, true, prefs.getPreferredKeyserver());
            data.putString(KeychainService.IMPORT_KEY_SERVER, cloudPrefs.keyserver);
        }

        data.putParcelableArrayList(KeychainService.IMPORT_KEY_LIST, keyRings);

        data.putParcelable(KeychainService.EXTRA_PARCELABLE_PROXY, parcelableProxy);

        
        Intent intent = new Intent(this, KeychainService.class);
        intent.setAction(KeychainService.ACTION_IMPORT_KEYRING);
        intent.putExtra(KeychainService.EXTRA_DATA, data);

        
        Messenger messenger = new Messenger(serviceHandler);
        intent.putExtra(KeychainService.EXTRA_MESSENGER, messenger);

        
        serviceHandler.showProgressDialog(
                getString(R.string.progress_importing),
                ProgressDialog.STYLE_HORIZONTAL, true);

        
        startService(intent);
    }

    
    @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
    void handleActionNdefDiscovered(Intent intent) {
        Parcelable[] rawMsgs = intent.getParcelableArrayExtra(NfcAdapter.EXTRA_NDEF_MESSAGES);
        
        NdefMessage msg = (NdefMessage) rawMsgs[0];
        
        final byte[] receivedKeyringBytes = msg.getRecords()[0].getPayload();
        final Preferences.ProxyPrefs proxyPrefs = Preferences.getPreferences(this)
                .getProxyPrefs();
        Runnable ignoreTor = new Runnable() {
            @Override
            public void run() {
                importKeys(receivedKeyringBytes, new ParcelableProxy(null, -1, null));
            }
        };

        if (OrbotHelper.isOrbotInRequiredState(R.string.orbot_ignore_tor, ignoreTor, proxyPrefs, this)) {
            importKeys(receivedKeyringBytes, proxyPrefs.parcelableProxy);
        }
    }

}

<code block>


package org.sufficientlysecure.keychain.ui;

import java.util.ArrayList;

import android.content.Intent;
import android.database.Cursor;
import android.net.Uri;
import android.os.Bundle;
import android.os.Message;
import android.os.Messenger;
import android.support.v4.app.LoaderManager;
import android.support.v4.content.CursorLoader;
import android.support.v4.content.Loader;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.TextView;

import org.openintents.openpgp.OpenPgpSignatureResult;
import org.sufficientlysecure.keychain.Constants;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.keyimport.ParcelableKeyRing;
import org.sufficientlysecure.keychain.operations.results.DecryptVerifyResult;
import org.sufficientlysecure.keychain.operations.results.ImportKeyResult;
import org.sufficientlysecure.keychain.operations.results.OperationResult;
import org.sufficientlysecure.keychain.pgp.KeyRing;
import org.sufficientlysecure.keychain.pgp.PgpDecryptVerifyInputParcel;
import org.sufficientlysecure.keychain.pgp.exception.PgpKeyNotFoundException;
import org.sufficientlysecure.keychain.provider.KeychainContract;
import org.sufficientlysecure.keychain.provider.KeychainContract.KeyRings;
import org.sufficientlysecure.keychain.provider.ProviderHelper;
import org.sufficientlysecure.keychain.service.KeychainService;
import org.sufficientlysecure.keychain.service.ServiceProgressHandler;
import org.sufficientlysecure.keychain.ui.base.CachingCryptoOperationFragment;
import org.sufficientlysecure.keychain.ui.base.CryptoOperationFragment;
import org.sufficientlysecure.keychain.ui.util.KeyFormattingUtils;
import org.sufficientlysecure.keychain.ui.util.KeyFormattingUtils.State;
import org.sufficientlysecure.keychain.ui.util.Notify;
import org.sufficientlysecure.keychain.ui.util.Notify.Style;
import org.sufficientlysecure.keychain.util.ParcelableProxy;
import org.sufficientlysecure.keychain.util.Preferences;
import org.sufficientlysecure.keychain.util.orbot.OrbotHelper;

public abstract class DecryptFragment
        extends CachingCryptoOperationFragment<PgpDecryptVerifyInputParcel, DecryptVerifyResult>
        implements LoaderManager.LoaderCallbacks<Cursor> {

    public static final int LOADER_ID_UNIFIED = 0;
    public static final String ARG_DECRYPT_VERIFY_RESULT = "decrypt_verify_result";

    protected LinearLayout mResultLayout;
    protected ImageView mEncryptionIcon;
    protected TextView mEncryptionText;
    protected ImageView mSignatureIcon;
    protected TextView mSignatureText;
    protected View mSignatureLayout;
    protected TextView mSignatureName;
    protected TextView mSignatureEmail;
    protected TextView mSignatureAction;

    private LinearLayout mContentLayout;
    private LinearLayout mErrorOverlayLayout;

    private OpenPgpSignatureResult mSignatureResult;
    private DecryptVerifyResult mDecryptVerifyResult;

    @Override
    public void onViewCreated(View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        
        mResultLayout = (LinearLayout) getActivity().findViewById(R.id.result_main_layout);
        mResultLayout.setVisibility(View.GONE);
        mEncryptionIcon = (ImageView) getActivity().findViewById(R.id.result_encryption_icon);
        mEncryptionText = (TextView) getActivity().findViewById(R.id.result_encryption_text);
        mSignatureIcon = (ImageView) getActivity().findViewById(R.id.result_signature_icon);
        mSignatureText = (TextView) getActivity().findViewById(R.id.result_signature_text);
        mSignatureLayout = getActivity().findViewById(R.id.result_signature_layout);
        mSignatureName = (TextView) getActivity().findViewById(R.id.result_signature_name);
        mSignatureEmail = (TextView) getActivity().findViewById(R.id.result_signature_email);
        mSignatureAction = (TextView) getActivity().findViewById(R.id.result_signature_action);

        
        mContentLayout = (LinearLayout) view.findViewById(R.id.decrypt_content);
        mErrorOverlayLayout = (LinearLayout) view.findViewById(R.id.decrypt_error_overlay);
        Button vErrorOverlayButton = (Button) view.findViewById(R.id.decrypt_error_overlay_button);
        vErrorOverlayButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                mErrorOverlayLayout.setVisibility(View.GONE);
                mContentLayout.setVisibility(View.VISIBLE);
            }
        });
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);

        outState.putParcelable(ARG_DECRYPT_VERIFY_RESULT, mDecryptVerifyResult);
    }

    @Override
    public void onViewStateRestored(Bundle savedInstanceState) {
        super.onViewStateRestored(savedInstanceState);

        if (savedInstanceState == null) {
            return;
        }

        DecryptVerifyResult result = savedInstanceState.getParcelable(ARG_DECRYPT_VERIFY_RESULT);
        if (result != null) {
            loadVerifyResult(result);
        }
    }

    private void lookupUnknownKey(long unknownKeyId, ParcelableProxy parcelableProxy) {

        
        ServiceProgressHandler serviceHandler = new ServiceProgressHandler(getActivity()) {
            @Override
            public void handleMessage(Message message) {
                
                super.handleMessage(message);

                if (message.arg1 == MessageStatus.OKAY.ordinal()) {
                    
                    Bundle returnData = message.getData();

                    if (returnData == null) {
                        return;
                    }

                    final ImportKeyResult result =
                            returnData.getParcelable(OperationResult.EXTRA_RESULT);

                    result.createNotify(getActivity()).show();

                    getLoaderManager().restartLoader(LOADER_ID_UNIFIED, null, DecryptFragment.this);
                }
            }
        };

        
        Bundle data = new Bundle();

        
        {
            Preferences prefs = Preferences.getPreferences(getActivity());
            Preferences.CloudSearchPrefs cloudPrefs =
                    new Preferences.CloudSearchPrefs(true, true, prefs.getPreferredKeyserver());
            data.putString(KeychainService.IMPORT_KEY_SERVER, cloudPrefs.keyserver);
        }

        {
            ParcelableKeyRing keyEntry = new ParcelableKeyRing(null,
                    KeyFormattingUtils.convertKeyIdToHex(unknownKeyId), null);
            ArrayList<ParcelableKeyRing> selectedEntries = new ArrayList<>();
            selectedEntries.add(keyEntry);

            data.putParcelableArrayList(KeychainService.IMPORT_KEY_LIST, selectedEntries);
        }

        data.putParcelable(KeychainService.EXTRA_PARCELABLE_PROXY, parcelableProxy);

        
        Intent intent = new Intent(getActivity(), KeychainService.class);
        intent.setAction(KeychainService.ACTION_IMPORT_KEYRING);
        intent.putExtra(KeychainService.EXTRA_DATA, data);

        
        Messenger messenger = new Messenger(serviceHandler);
        intent.putExtra(KeychainService.EXTRA_MESSENGER, messenger);

        getActivity().startService(intent);
    }

    private void showKey(long keyId) {
        try {

            Intent viewKeyIntent = new Intent(getActivity(), ViewKeyActivity.class);
            long masterKeyId = new ProviderHelper(getActivity()).getCachedPublicKeyRing(
                    KeyRings.buildUnifiedKeyRingsFindBySubkeyUri(keyId)
            ).getMasterKeyId();
            viewKeyIntent.setData(KeyRings.buildGenericKeyRingUri(masterKeyId));
            startActivity(viewKeyIntent);

        } catch (PgpKeyNotFoundException e) {
            Notify.create(getActivity(), R.string.error_key_not_found, Style.ERROR);
        }
    }

    
    protected void loadVerifyResult(DecryptVerifyResult decryptVerifyResult) {

        mDecryptVerifyResult = decryptVerifyResult;
        mSignatureResult = decryptVerifyResult.getSignatureResult();

        mResultLayout.setVisibility(View.VISIBLE);

        
        if (mSignatureResult == null) {

            setSignatureLayoutVisibility(View.GONE);

            mSignatureText.setText(R.string.decrypt_result_no_signature);
            KeyFormattingUtils.setStatusImage(getActivity(), mSignatureIcon, mSignatureText, State.NOT_SIGNED);
            mEncryptionText.setText(R.string.decrypt_result_encrypted);
            KeyFormattingUtils.setStatusImage(getActivity(), mEncryptionIcon, mEncryptionText, State.ENCRYPTED);

            getLoaderManager().destroyLoader(LOADER_ID_UNIFIED);

            mErrorOverlayLayout.setVisibility(View.GONE);
            mContentLayout.setVisibility(View.VISIBLE);

            onVerifyLoaded(true);

            return;
        }

        if (mSignatureResult.isSignatureOnly()) {
            mEncryptionText.setText(R.string.decrypt_result_not_encrypted);
            KeyFormattingUtils.setStatusImage(getActivity(), mEncryptionIcon, mEncryptionText, State.NOT_ENCRYPTED);
        } else {
            mEncryptionText.setText(R.string.decrypt_result_encrypted);
            KeyFormattingUtils.setStatusImage(getActivity(), mEncryptionIcon, mEncryptionText, State.ENCRYPTED);
        }

        getLoaderManager().restartLoader(LOADER_ID_UNIFIED, null, this);
    }

    private void setSignatureLayoutVisibility(int visibility) {
        mSignatureLayout.setVisibility(visibility);
    }

    private void setShowAction(final long signatureKeyId) {
        mSignatureAction.setText(R.string.decrypt_result_action_show);
        mSignatureAction.setCompoundDrawablesWithIntrinsicBounds(0, 0, R.drawable.ic_vpn_key_grey_24dp, 0);
        mSignatureLayout.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                showKey(signatureKeyId);
            }
        });
    }

    
    static final String[] UNIFIED_PROJECTION = new String[]{
            KeychainContract.KeyRings._ID,
            KeychainContract.KeyRings.MASTER_KEY_ID,
            KeychainContract.KeyRings.USER_ID,
            KeychainContract.KeyRings.VERIFIED,
            KeychainContract.KeyRings.HAS_ANY_SECRET,
    };

    @SuppressWarnings("unused")
    static final int INDEX_MASTER_KEY_ID = 1;
    static final int INDEX_USER_ID = 2;
    static final int INDEX_VERIFIED = 3;
    static final int INDEX_HAS_ANY_SECRET = 4;

    @Override
    public Loader<Cursor> onCreateLoader(int id, Bundle args) {
        if (id != LOADER_ID_UNIFIED) {
            return null;
        }

        Uri baseUri = KeychainContract.KeyRings.buildUnifiedKeyRingsFindBySubkeyUri(
                mSignatureResult.getKeyId());
        return new CursorLoader(getActivity(), baseUri, UNIFIED_PROJECTION, null, null, null);
    }

    @Override
    public void onLoadFinished(Loader<Cursor> loader, Cursor data) {

        if (loader.getId() != LOADER_ID_UNIFIED) {
            return;
        }

        
        if (data.getCount() == 0 || !data.moveToFirst()) {
            showUnknownKeyStatus();
            return;
        }

        long signatureKeyId = mSignatureResult.getKeyId();

        String userId = data.getString(INDEX_USER_ID);
        KeyRing.UserId userIdSplit = KeyRing.splitUserId(userId);
        if (userIdSplit.name != null) {
            mSignatureName.setText(userIdSplit.name);
        } else {
            mSignatureName.setText(R.string.user_id_no_name);
        }
        if (userIdSplit.email != null) {
            mSignatureEmail.setText(userIdSplit.email);
        } else {
            mSignatureEmail.setText(KeyFormattingUtils.beautifyKeyIdWithPrefix(
                    getActivity(), mSignatureResult.getKeyId()));
        }

        
        
        boolean isRevoked = mSignatureResult.getStatus() == OpenPgpSignatureResult.SIGNATURE_KEY_REVOKED;
        boolean isExpired = mSignatureResult.getStatus() == OpenPgpSignatureResult.SIGNATURE_KEY_EXPIRED;
        boolean isVerified = data.getInt(INDEX_VERIFIED) > 0;
        boolean isYours = data.getInt(INDEX_HAS_ANY_SECRET) != 0;

        if (isRevoked) {
            mSignatureText.setText(R.string.decrypt_result_signature_revoked_key);
            KeyFormattingUtils.setStatusImage(getActivity(), mSignatureIcon, mSignatureText, State.REVOKED);

            setSignatureLayoutVisibility(View.VISIBLE);
            setShowAction(signatureKeyId);

            mErrorOverlayLayout.setVisibility(View.VISIBLE);
            mContentLayout.setVisibility(View.GONE);

            onVerifyLoaded(false);

        } else if (isExpired) {
            mSignatureText.setText(R.string.decrypt_result_signature_expired_key);
            KeyFormattingUtils.setStatusImage(getActivity(), mSignatureIcon, mSignatureText, State.EXPIRED);

            setSignatureLayoutVisibility(View.VISIBLE);
            setShowAction(signatureKeyId);

            mErrorOverlayLayout.setVisibility(View.GONE);
            mContentLayout.setVisibility(View.VISIBLE);

            onVerifyLoaded(true);

        } else if (isYours) {

            mSignatureText.setText(R.string.decrypt_result_signature_secret);
            KeyFormattingUtils.setStatusImage(getActivity(), mSignatureIcon, mSignatureText, State.VERIFIED);

            setSignatureLayoutVisibility(View.VISIBLE);
            setShowAction(signatureKeyId);

            mErrorOverlayLayout.setVisibility(View.GONE);
            mContentLayout.setVisibility(View.VISIBLE);

            onVerifyLoaded(true);

        } else if (isVerified) {
            mSignatureText.setText(R.string.decrypt_result_signature_certified);
            KeyFormattingUtils.setStatusImage(getActivity(), mSignatureIcon, mSignatureText, State.VERIFIED);

            setSignatureLayoutVisibility(View.VISIBLE);
            setShowAction(signatureKeyId);

            mErrorOverlayLayout.setVisibility(View.GONE);
            mContentLayout.setVisibility(View.VISIBLE);

            onVerifyLoaded(true);

        } else {
            mSignatureText.setText(R.string.decrypt_result_signature_uncertified);
            KeyFormattingUtils.setStatusImage(getActivity(), mSignatureIcon, mSignatureText, State.UNVERIFIED);

            setSignatureLayoutVisibility(View.VISIBLE);
            setShowAction(signatureKeyId);

            mErrorOverlayLayout.setVisibility(View.GONE);
            mContentLayout.setVisibility(View.VISIBLE);

            onVerifyLoaded(true);
        }

    }

    @Override
    public void onLoaderReset(Loader<Cursor> loader) {

        if (loader.getId() != LOADER_ID_UNIFIED) {
            return;
        }

        setSignatureLayoutVisibility(View.GONE);
    }

    private void showUnknownKeyStatus() {

        final long signatureKeyId = mSignatureResult.getKeyId();

        int result = mSignatureResult.getStatus();
        if (result != OpenPgpSignatureResult.SIGNATURE_KEY_MISSING
                && result != OpenPgpSignatureResult.SIGNATURE_ERROR) {
            Log.e(Constants.TAG, "got missing status for non-missing key, shouldn't happen!");
        }

        String userId = mSignatureResult.getPrimaryUserId();
        KeyRing.UserId userIdSplit = KeyRing.splitUserId(userId);
        if (userIdSplit.name != null) {
            mSignatureName.setText(userIdSplit.name);
        } else {
            mSignatureName.setText(R.string.user_id_no_name);
        }
        if (userIdSplit.email != null) {
            mSignatureEmail.setText(userIdSplit.email);
        } else {
            mSignatureEmail.setText(KeyFormattingUtils.beautifyKeyIdWithPrefix(
                    getActivity(), mSignatureResult.getKeyId()));
        }

        switch (mSignatureResult.getStatus()) {

            case OpenPgpSignatureResult.SIGNATURE_KEY_MISSING: {
                mSignatureText.setText(R.string.decrypt_result_signature_missing_key);
                KeyFormattingUtils.setStatusImage(getActivity(), mSignatureIcon, mSignatureText, State.UNKNOWN_KEY);

                setSignatureLayoutVisibility(View.VISIBLE);
                mSignatureAction.setText(R.string.decrypt_result_action_Lookup);
                mSignatureAction
                        .setCompoundDrawablesWithIntrinsicBounds(0, 0, R.drawable.ic_file_download_grey_24dp, 0);
                mSignatureLayout.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        final Preferences.ProxyPrefs proxyPrefs = Preferences.getPreferences(getActivity())
                                .getProxyPrefs();
                        Runnable ignoreTor = new Runnable() {
                            @Override
                            public void run() {
                                lookupUnknownKey(signatureKeyId, new ParcelableProxy(null, -1, null));
                            }
                        };

                        if (OrbotHelper.isOrbotInRequiredState(R.string.orbot_ignore_tor, ignoreTor, proxyPrefs,
                                getActivity())) {
                            lookupUnknownKey(signatureKeyId, proxyPrefs.parcelableProxy);
                        }
                    }
                });

                mErrorOverlayLayout.setVisibility(View.GONE);
                mContentLayout.setVisibility(View.VISIBLE);

                onVerifyLoaded(true);

                break;
            }

            case OpenPgpSignatureResult.SIGNATURE_ERROR: {
                mSignatureText.setText(R.string.decrypt_result_invalid_signature);
                KeyFormattingUtils.setStatusImage(getActivity(), mSignatureIcon, mSignatureText, State.INVALID);

                setSignatureLayoutVisibility(View.GONE);

                mErrorOverlayLayout.setVisibility(View.VISIBLE);
                mContentLayout.setVisibility(View.GONE);

                onVerifyLoaded(false);
                break;
            }

        }

    }

    protected abstract void onVerifyLoaded(boolean hideErrorOverlay);

}

<code block>


package org.sufficientlysecure.keychain.ui;

import android.animation.ArgbEvaluator;
import android.animation.ObjectAnimator;
import android.annotation.SuppressLint;
import android.app.Activity;
import android.app.ActivityOptions;
import android.content.Intent;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.os.Messenger;
import android.provider.ContactsContract;
import android.support.v4.app.ActivityCompat;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.LoaderManager;
import android.support.v4.content.CursorLoader;
import android.support.v4.content.Loader;
import android.support.v7.widget.CardView;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.animation.AlphaAnimation;
import android.view.animation.Animation;
import android.view.animation.Animation.AnimationListener;
import android.view.animation.AnimationUtils;
import android.widget.ImageButton;
import android.widget.ImageView;
import android.widget.RelativeLayout;
import android.widget.TextView;
import android.widget.Toast;
import com.getbase.floatingactionbutton.FloatingActionButton;
import org.sufficientlysecure.keychain.Constants;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.keyimport.ParcelableKeyRing;
import org.sufficientlysecure.keychain.operations.results.CertifyResult;
import org.sufficientlysecure.keychain.operations.results.ImportKeyResult;
import org.sufficientlysecure.keychain.operations.results.OperationResult;
import org.sufficientlysecure.keychain.pgp.KeyRing;
import org.sufficientlysecure.keychain.pgp.exception.PgpKeyNotFoundException;
import org.sufficientlysecure.keychain.provider.CachedPublicKeyRing;
import org.sufficientlysecure.keychain.provider.KeychainContract;
import org.sufficientlysecure.keychain.provider.KeychainContract.KeyRings;
import org.sufficientlysecure.keychain.provider.ProviderHelper;
import org.sufficientlysecure.keychain.service.KeychainService;
import org.sufficientlysecure.keychain.service.ServiceProgressHandler;
import org.sufficientlysecure.keychain.service.ServiceProgressHandler.MessageStatus;
import org.sufficientlysecure.keychain.service.PassphraseCacheService;
import org.sufficientlysecure.keychain.ui.base.BaseNfcActivity;
import org.sufficientlysecure.keychain.ui.dialog.DeleteKeyDialogFragment;
import org.sufficientlysecure.keychain.ui.util.FormattingUtils;
import org.sufficientlysecure.keychain.ui.util.KeyFormattingUtils;
import org.sufficientlysecure.keychain.ui.util.KeyFormattingUtils.State;
import org.sufficientlysecure.keychain.ui.util.Notify;
import org.sufficientlysecure.keychain.ui.util.Notify.ActionListener;
import org.sufficientlysecure.keychain.ui.util.Notify.Style;
import org.sufficientlysecure.keychain.ui.util.QrCodeUtils;
import org.sufficientlysecure.keychain.util.ContactHelper;
import org.sufficientlysecure.keychain.util.ExportHelper;
import org.sufficientlysecure.keychain.util.Log;
import org.sufficientlysecure.keychain.util.NfcHelper;
import org.sufficientlysecure.keychain.util.ParcelableProxy;
import org.sufficientlysecure.keychain.util.Preferences;
import org.sufficientlysecure.keychain.util.orbot.OrbotHelper;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;

public class ViewKeyActivity extends BaseNfcActivity implements
        LoaderManager.LoaderCallbacks<Cursor> {

    public static final String EXTRA_NFC_USER_ID = "nfc_user_id";
    public static final String EXTRA_NFC_AID = "nfc_aid";
    public static final String EXTRA_NFC_FINGERPRINTS = "nfc_fingerprints";

    static final int REQUEST_QR_FINGERPRINT = 1;
    static final int REQUEST_DELETE = 2;
    static final int REQUEST_EXPORT = 3;
    public static final String EXTRA_DISPLAY_RESULT = "display_result";

    ExportHelper mExportHelper;
    ProviderHelper mProviderHelper;

    protected Uri mDataUri;

    private TextView mName;
    private TextView mStatusText;
    private ImageView mStatusImage;
    private RelativeLayout mBigToolbar;

    private ImageButton mActionEncryptFile;
    private ImageButton mActionEncryptText;
    private ImageButton mActionNfc;
    private FloatingActionButton mFab;
    private ImageView mPhoto;
    private ImageView mQrCode;
    private CardView mQrCodeLayout;

    private String mQrCodeLoaded;

    
    private NfcHelper mNfcHelper;

    private static final int LOADER_ID_UNIFIED = 0;

    private boolean mIsSecret = false;
    private boolean mHasEncrypt = false;
    private boolean mIsVerified = false;
    private boolean mIsRevoked = false;
    private boolean mIsExpired = false;

    private boolean mShowYubikeyAfterCreation = false;

    private MenuItem mRefreshItem;
    private boolean mIsRefreshing;
    private Animation mRotate, mRotateSpin;
    private View mRefresh;
    private String mFingerprint;
    private long mMasterKeyId;

    @SuppressLint("InflateParams")
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        mExportHelper = new ExportHelper(this);
        mProviderHelper = new ProviderHelper(this);

        setTitle(null);

        mName = (TextView) findViewById(R.id.view_key_name);
        mStatusText = (TextView) findViewById(R.id.view_key_status);
        mStatusImage = (ImageView) findViewById(R.id.view_key_status_image);
        mBigToolbar = (RelativeLayout) findViewById(R.id.toolbar_big);

        mActionEncryptFile = (ImageButton) findViewById(R.id.view_key_action_encrypt_files);
        mActionEncryptText = (ImageButton) findViewById(R.id.view_key_action_encrypt_text);
        mActionNfc = (ImageButton) findViewById(R.id.view_key_action_nfc);
        mFab = (FloatingActionButton) findViewById(R.id.fab);
        mPhoto = (ImageView) findViewById(R.id.view_key_photo);
        mQrCode = (ImageView) findViewById(R.id.view_key_qr_code);
        mQrCodeLayout = (CardView) findViewById(R.id.view_key_qr_code_layout);

        mRotateSpin = AnimationUtils.loadAnimation(this, R.anim.rotate_spin);
        mRotateSpin.setAnimationListener(new AnimationListener() {
            @Override
            public void onAnimationStart(Animation animation) {

            }

            @Override
            public void onAnimationEnd(Animation animation) {
                mRefreshItem.getActionView().clearAnimation();
                mRefreshItem.setActionView(null);
                mRefreshItem.setEnabled(true);

                
                supportInvalidateOptionsMenu();
            }

            @Override
            public void onAnimationRepeat(Animation animation) {

            }
        });
        mRotate = AnimationUtils.loadAnimation(this, R.anim.rotate);
        mRotate.setRepeatCount(Animation.INFINITE);
        mRotate.setAnimationListener(new Animation.AnimationListener() {
            @Override
            public void onAnimationStart(Animation animation) {

            }

            @Override
            public void onAnimationEnd(Animation animation) {

            }

            @Override
            public void onAnimationRepeat(Animation animation) {
                if (!mIsRefreshing) {
                    mRefreshItem.getActionView().clearAnimation();
                    mRefreshItem.getActionView().startAnimation(mRotateSpin);
                }
            }
        });
        mRefresh = getLayoutInflater().inflate(R.layout.indeterminate_progress, null);

        mDataUri = getIntent().getData();
        if (mDataUri == null) {
            Log.e(Constants.TAG, "Data missing. Should be uri of key!");
            finish();
            return;
        }
        if (mDataUri.getHost().equals(ContactsContract.AUTHORITY)) {
            mDataUri = ContactHelper.dataUriFromContactUri(this, mDataUri);
            if (mDataUri == null) {
                Log.e(Constants.TAG, "Contact Data missing. Should be uri of key!");
                Toast.makeText(this, R.string.error_contacts_key_id_missing, Toast.LENGTH_LONG).show();
                finish();
                return;
            }
        }

        Log.i(Constants.TAG, "mDataUri: " + mDataUri);

        mActionEncryptFile.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                encrypt(mDataUri, false);
            }
        });
        mActionEncryptText.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                encrypt(mDataUri, true);
            }
        });

        mFab.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                if (mIsSecret) {
                    startSafeSlinger(mDataUri);
                } else {
                    scanQrCode();
                }
            }
        });

        mQrCodeLayout.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                showQrCodeDialog();
            }
        });

        mActionNfc.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                mNfcHelper.invokeNfcBeam();
            }
        });

        
        
        getSupportLoaderManager().initLoader(LOADER_ID_UNIFIED, null, this);

        mNfcHelper = new NfcHelper(this, mProviderHelper);
        mNfcHelper.initNfc(mDataUri);

        if (savedInstanceState == null && getIntent().hasExtra(EXTRA_DISPLAY_RESULT)) {
            OperationResult result = getIntent().getParcelableExtra(EXTRA_DISPLAY_RESULT);
            result.createNotify(this).show();
        }

        
        if (savedInstanceState != null) {
            return;
        }

        FragmentManager manager = getSupportFragmentManager();
        
        final ViewKeyFragment frag = ViewKeyFragment.newInstance(mDataUri);
        manager.beginTransaction()
                .replace(R.id.view_key_fragment, frag)
                .commit();

        
        
        mShowYubikeyAfterCreation = true;

    }

    @Override
    protected void initLayout() {
        setContentView(R.layout.view_key_activity);
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        super.onCreateOptionsMenu(menu);
        getMenuInflater().inflate(R.menu.key_view, menu);
        mRefreshItem = menu.findItem(R.id.menu_key_view_refresh);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home: {
                Intent homeIntent = new Intent(this, MainActivity.class);
                homeIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
                startActivity(homeIntent);
                return true;
            }
            case R.id.menu_key_view_export_file: {
                try {
                    if (PassphraseCacheService.getCachedPassphrase(this, mMasterKeyId, mMasterKeyId) != null) {
                        exportToFile(mDataUri, mExportHelper, mProviderHelper);
                        return true;
                    }

                    startPassphraseActivity(REQUEST_EXPORT);
                } catch (PassphraseCacheService.KeyNotFoundException e) {
                    
                    exportToFile(mDataUri, mExportHelper, mProviderHelper);
                }
                return true;
            }
            case R.id.menu_key_view_delete: {
                try {
                    if (PassphraseCacheService.getCachedPassphrase(this, mMasterKeyId, mMasterKeyId) != null) {
                        deleteKey();
                        return true;
                    }

                    startPassphraseActivity(REQUEST_DELETE);
                } catch (PassphraseCacheService.KeyNotFoundException e) {
                    
                    deleteKey();
                }
                return true;
            }
            case R.id.menu_key_view_advanced: {
                Intent advancedIntent = new Intent(this, ViewKeyAdvActivity.class);
                advancedIntent.setData(mDataUri);
                startActivity(advancedIntent);
                return true;
            }
            case R.id.menu_key_view_refresh: {
                try {
                    final Preferences.ProxyPrefs proxyPrefs = Preferences.getPreferences(this).getProxyPrefs();
                    Runnable ignoreTor = new Runnable() {
                        @Override
                        public void run() {
                            try {
                                updateFromKeyserver(mDataUri, mProviderHelper, new ParcelableProxy(null, -1, null));
                            } catch (ProviderHelper.NotFoundException e) {
                                Notify.create(ViewKeyActivity.this, R.string.error_key_not_found, Notify.Style.ERROR)
                                        .show();
                            }
                        }
                    };

                    if (OrbotHelper.isOrbotInRequiredState(R.string.orbot_ignore_tor, ignoreTor, proxyPrefs, this)) {
                        updateFromKeyserver(mDataUri, mProviderHelper, proxyPrefs.parcelableProxy);
                    }
                } catch (ProviderHelper.NotFoundException e) {
                    Notify.create(this, R.string.error_key_not_found, Notify.Style.ERROR).show();
                }
                return true;
            }
            case R.id.menu_key_view_edit: {
                editKey(mDataUri);
                return true;
            }
            case R.id.menu_key_view_certify_fingerprint: {
                certifyFingeprint(mDataUri);
                return true;
            }
        }
        return super.onOptionsItemSelected(item);
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        MenuItem editKey = menu.findItem(R.id.menu_key_view_edit);
        editKey.setVisible(mIsSecret);
        MenuItem certifyFingerprint = menu.findItem(R.id.menu_key_view_certify_fingerprint);
        certifyFingerprint.setVisible(!mIsSecret && !mIsVerified && !mIsExpired && !mIsRevoked);

        return true;
    }


    private void scanQrCode() {
        Intent scanQrCode = new Intent(this, ImportKeysProxyActivity.class);
        scanQrCode.setAction(ImportKeysProxyActivity.ACTION_SCAN_WITH_RESULT);
        startActivityForResult(scanQrCode, REQUEST_QR_FINGERPRINT);
    }

    private void certifyFingeprint(Uri dataUri) {
        Intent intent = new Intent(this, CertifyFingerprintActivity.class);
        intent.setData(dataUri);

        startCertifyIntent(intent);
    }

    private void certifyImmediate() {
        Intent intent = new Intent(this, CertifyKeyActivity.class);
        intent.putExtra(CertifyKeyActivity.EXTRA_KEY_IDS, new long[]{mMasterKeyId});

        startCertifyIntent(intent);
    }

    private void startCertifyIntent(Intent intent) {
        
        ServiceProgressHandler saveHandler = new ServiceProgressHandler(this) {
            @Override
            public void handleMessage(Message message) {
                
                super.handleMessage(message);

                if (message.arg1 == MessageStatus.OKAY.ordinal()) {
                    Bundle data = message.getData();
                    CertifyResult result = data.getParcelable(CertifyResult.EXTRA_RESULT);

                    result.createNotify(ViewKeyActivity.this).show();
                }
            }
        };
        
        Messenger messenger = new Messenger(saveHandler);
        intent.putExtra(KeychainService.EXTRA_MESSENGER, messenger);

        startActivityForResult(intent, 0);
    }

    private void showQrCodeDialog() {
        Intent qrCodeIntent = new Intent(this, QrCodeViewActivity.class);

        
        
        Bundle opts = null;
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            ActivityOptions options = ActivityOptions
                    .makeSceneTransitionAnimation(this, mQrCodeLayout, "qr_code");
            opts = options.toBundle();
        }

        qrCodeIntent.setData(mDataUri);
        ActivityCompat.startActivity(this, qrCodeIntent, opts);
    }

    private void startPassphraseActivity(int requestCode) {
        Intent intent = new Intent(this, PassphraseDialogActivity.class);
        intent.putExtra(PassphraseDialogActivity.EXTRA_SUBKEY_ID, mMasterKeyId);
        startActivityForResult(intent, requestCode);
    }

    private void exportToFile(Uri dataUri, ExportHelper exportHelper, ProviderHelper providerHelper) {
        try {
            Uri baseUri = KeychainContract.KeyRings.buildUnifiedKeyRingUri(dataUri);

            HashMap<String, Object> data = providerHelper.getGenericData(
                    baseUri,
                    new String[]{KeychainContract.Keys.MASTER_KEY_ID, KeychainContract.KeyRings.HAS_SECRET},
                    new int[]{ProviderHelper.FIELD_TYPE_INTEGER, ProviderHelper.FIELD_TYPE_INTEGER});

            exportHelper.showExportKeysDialog(
                    new long[]{(Long) data.get(KeychainContract.KeyRings.MASTER_KEY_ID)},
                    Constants.Path.APP_DIR_FILE, ((Long) data.get(KeychainContract.KeyRings.HAS_SECRET) != 0)
            );
        } catch (ProviderHelper.NotFoundException e) {
            Notify.create(this, R.string.error_key_not_found, Notify.Style.ERROR).show();
            Log.e(Constants.TAG, "Key not found", e);
        }
    }

    private void deleteKey() {
        
        Handler returnHandler = new Handler() {
            @Override
            public void handleMessage(Message message) {
                if (message.arg1 == MessageStatus.OKAY.ordinal()) {
                    setResult(RESULT_CANCELED);
                    finish();
                }
            }
        };

        
        Messenger messenger = new Messenger(returnHandler);
        DeleteKeyDialogFragment deleteKeyDialog = DeleteKeyDialogFragment.newInstance(messenger,
                new long[]{mMasterKeyId});
        deleteKeyDialog.show(getSupportFragmentManager(), "deleteKeyDialog");
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (requestCode == REQUEST_QR_FINGERPRINT && resultCode == Activity.RESULT_OK) {

            
            if (data.hasExtra(OperationResult.EXTRA_RESULT)) {
                OperationResult result = data.getParcelableExtra(OperationResult.EXTRA_RESULT);
                result.createNotify(this).show();
                return;
            }

            String fp = data.getStringExtra(ImportKeysProxyActivity.EXTRA_FINGERPRINT);
            if (fp == null) {
                Notify.create(this, "Error scanning fingerprint!",
                        Notify.LENGTH_LONG, Notify.Style.ERROR).show();
                return;
            }
            if (mFingerprint.equalsIgnoreCase(fp)) {
                certifyImmediate();
            } else {
                Notify.create(this, "Fingerprints did not match!",
                        Notify.LENGTH_LONG, Notify.Style.ERROR).show();
            }

            return;
        }

        if (requestCode == REQUEST_DELETE && resultCode == Activity.RESULT_OK) {
            deleteKey();
        }

        if (requestCode == REQUEST_EXPORT && resultCode == Activity.RESULT_OK) {
            exportToFile(mDataUri, mExportHelper, mProviderHelper);
        }

        if (data != null && data.hasExtra(OperationResult.EXTRA_RESULT)) {
            OperationResult result = data.getParcelableExtra(OperationResult.EXTRA_RESULT);
            result.createNotify(this).show();
        } else {
            super.onActivityResult(requestCode, resultCode, data);
        }
    }

    @Override
    protected void onNfcPerform() throws IOException {

        final byte[] nfcFingerprints = nfcGetFingerprints();
        final String nfcUserId = nfcGetUserId();
        final byte[] nfcAid = nfcGetAid();

        long yubiKeyId = KeyFormattingUtils.getKeyIdFromFingerprint(nfcFingerprints);

        try {

            
            CachedPublicKeyRing ring = mProviderHelper.getCachedPublicKeyRing(
                    KeyRings.buildUnifiedKeyRingsFindBySubkeyUri(yubiKeyId));
            byte[] candidateFp = ring.getFingerprint();

            
            if (KeyFormattingUtils.convertFingerprintToHex(candidateFp).equals(mFingerprint)) {
                showYubiKeyFragment(nfcFingerprints, nfcUserId, nfcAid);
                return;
            }

            
            final long masterKeyId = KeyFormattingUtils.getKeyIdFromFingerprint(candidateFp);
            Notify.create(this, R.string.snack_yubi_other, Notify.LENGTH_LONG,
                    Style.WARN, new ActionListener() {
                        @Override
                        public void onAction() {
                            Intent intent = new Intent(
                                    ViewKeyActivity.this, ViewKeyActivity.class);
                            intent.setData(KeyRings.buildGenericKeyRingUri(masterKeyId));
                            intent.putExtra(ViewKeyActivity.EXTRA_NFC_AID, nfcAid);
                            intent.putExtra(ViewKeyActivity.EXTRA_NFC_USER_ID, nfcUserId);
                            intent.putExtra(ViewKeyActivity.EXTRA_NFC_FINGERPRINTS, nfcFingerprints);
                            startActivity(intent);
                            finish();
                        }
                    }, R.string.snack_yubikey_view).show();

            
        } catch (PgpKeyNotFoundException e) {
            Notify.create(this, R.string.snack_yubi_other, Notify.LENGTH_LONG,
                    Style.WARN, new ActionListener() {
                        @Override
                        public void onAction() {
                            Intent intent = new Intent(
                                    ViewKeyActivity.this, CreateKeyActivity.class);
                            intent.putExtra(ViewKeyActivity.EXTRA_NFC_AID, nfcAid);
                            intent.putExtra(ViewKeyActivity.EXTRA_NFC_USER_ID, nfcUserId);
                            intent.putExtra(ViewKeyActivity.EXTRA_NFC_FINGERPRINTS, nfcFingerprints);
                            startActivity(intent);
                            finish();
                        }
                    }, R.string.snack_yubikey_import).show();
        }

    }

    public void showYubiKeyFragment(
            final byte[] nfcFingerprints, final String nfcUserId, final byte[] nfcAid) {

        new Handler().post(new Runnable() {
            @Override
            public void run() {
                ViewKeyYubiKeyFragment frag = ViewKeyYubiKeyFragment.newInstance(
                        mMasterKeyId, nfcFingerprints, nfcUserId, nfcAid);

                FragmentManager manager = getSupportFragmentManager();

                manager.popBackStack("yubikey", FragmentManager.POP_BACK_STACK_INCLUSIVE);
                manager.beginTransaction()
                        .addToBackStack("yubikey")
                        .replace(R.id.view_key_fragment, frag)
                                
                        .commitAllowingStateLoss();
            }
        });

    }

    private void encrypt(Uri dataUri, boolean text) {
        
        if (!mHasEncrypt) {
            Notify.create(this, R.string.error_no_encrypt_subkey, Notify.Style.ERROR).show();
            return;
        }
        try {
            long keyId = new ProviderHelper(this)
                    .getCachedPublicKeyRing(dataUri)
                    .extractOrGetMasterKeyId();
            long[] encryptionKeyIds = new long[]{keyId};
            Intent intent;
            if (text) {
                intent = new Intent(this, EncryptTextActivity.class);
                intent.setAction(EncryptTextActivity.ACTION_ENCRYPT_TEXT);
                intent.putExtra(EncryptTextActivity.EXTRA_ENCRYPTION_KEY_IDS, encryptionKeyIds);
            } else {
                intent = new Intent(this, EncryptFilesActivity.class);
                intent.setAction(EncryptFilesActivity.ACTION_ENCRYPT_DATA);
                intent.putExtra(EncryptFilesActivity.EXTRA_ENCRYPTION_KEY_IDS, encryptionKeyIds);
            }
            
            startActivityForResult(intent, 0);
        } catch (PgpKeyNotFoundException e) {
            Log.e(Constants.TAG, "key not found!", e);
        }
    }

    private void updateFromKeyserver(Uri dataUri, ProviderHelper providerHelper, ParcelableProxy parcelableProxy)
            throws ProviderHelper.NotFoundException {

        mIsRefreshing = true;
        mRefreshItem.setEnabled(false);
        mRefreshItem.setActionView(mRefresh);
        mRefresh.startAnimation(mRotate);

        byte[] blob = (byte[]) providerHelper.getGenericData(
                KeychainContract.KeyRings.buildUnifiedKeyRingUri(dataUri),
                KeychainContract.Keys.FINGERPRINT, ProviderHelper.FIELD_TYPE_BLOB);
        String fingerprint = KeyFormattingUtils.convertFingerprintToHex(blob);

        ParcelableKeyRing keyEntry = new ParcelableKeyRing(fingerprint, null, null);
        ArrayList<ParcelableKeyRing> entries = new ArrayList<>();
        entries.add(keyEntry);

        
        ServiceProgressHandler serviceHandler = new ServiceProgressHandler(this) {
            @Override
            public void handleMessage(Message message) {
                
                super.handleMessage(message);

                if (message.arg1 == MessageStatus.OKAY.ordinal()) {
                    
                    Bundle returnData = message.getData();

                    mIsRefreshing = false;

                    if (returnData == null) {
                        finish();
                        return;
                    }
                    final ImportKeyResult result =
                            returnData.getParcelable(OperationResult.EXTRA_RESULT);
                    result.createNotify(ViewKeyActivity.this).show();
                }
            }
        };

        
        Bundle data = new Bundle();

        
        {
            Preferences prefs = Preferences.getPreferences(this);
            Preferences.CloudSearchPrefs cloudPrefs =
                    new Preferences.CloudSearchPrefs(true, true, prefs.getPreferredKeyserver());
            data.putString(KeychainService.IMPORT_KEY_SERVER, cloudPrefs.keyserver);
        }

        data.putParcelableArrayList(KeychainService.IMPORT_KEY_LIST, entries);

        data.putParcelable(KeychainService.EXTRA_PARCELABLE_PROXY, parcelableProxy);

        
        Intent intent = new Intent(this, KeychainService.class);
        intent.setAction(KeychainService.ACTION_IMPORT_KEYRING);
        intent.putExtra(KeychainService.EXTRA_DATA, data);

        
        Messenger messenger = new Messenger(serviceHandler);
        intent.putExtra(KeychainService.EXTRA_MESSENGER, messenger);

        
        startService(intent);

    }

    private void editKey(Uri dataUri) {
        Intent editIntent = new Intent(this, EditKeyActivity.class);
        editIntent.setData(KeychainContract.KeyRingData.buildSecretKeyRingUri(dataUri));
        startActivityForResult(editIntent, 0);
    }

    private void startSafeSlinger(Uri dataUri) {
        long keyId = 0;
        try {
            keyId = new ProviderHelper(this)
                    .getCachedPublicKeyRing(dataUri)
                    .extractOrGetMasterKeyId();
        } catch (PgpKeyNotFoundException e) {
            Log.e(Constants.TAG, "key not found!", e);
        }
        Intent safeSlingerIntent = new Intent(this, SafeSlingerActivity.class);
        safeSlingerIntent.putExtra(SafeSlingerActivity.EXTRA_MASTER_KEY_ID, keyId);
        startActivityForResult(safeSlingerIntent, 0);
    }

    
    private void loadQrCode(final String fingerprint) {
        AsyncTask<Void, Void, Bitmap> loadTask =
                new AsyncTask<Void, Void, Bitmap>() {
                    protected Bitmap doInBackground(Void... unused) {
                        Uri uri = new Uri.Builder()
                                .scheme(Constants.FINGERPRINT_SCHEME)
                                .opaquePart(fingerprint)
                                .build();
                        
                        return QrCodeUtils.getQRCodeBitmap(uri, 0);
                    }

                    protected void onPostExecute(Bitmap qrCode) {
                        mQrCodeLoaded = fingerprint;
                        
                        
                        Bitmap scaled = Bitmap.createScaledBitmap(qrCode,
                                mQrCode.getHeight(), mQrCode.getHeight(),
                                false);
                        mQrCode.setImageBitmap(scaled);

                        
                        AlphaAnimation anim = new AlphaAnimation(0.0f, 1.0f);
                        anim.setDuration(200);
                        mQrCode.startAnimation(anim);
                    }
                };

        loadTask.execute();
    }


    
    static final String[] PROJECTION = new String[]{
            KeychainContract.KeyRings._ID,
            KeychainContract.KeyRings.MASTER_KEY_ID,
            KeychainContract.KeyRings.USER_ID,
            KeychainContract.KeyRings.IS_REVOKED,
            KeychainContract.KeyRings.IS_EXPIRED,
            KeychainContract.KeyRings.VERIFIED,
            KeychainContract.KeyRings.HAS_ANY_SECRET,
            KeychainContract.KeyRings.FINGERPRINT,
            KeychainContract.KeyRings.HAS_ENCRYPT
    };

    static final int INDEX_MASTER_KEY_ID = 1;
    static final int INDEX_USER_ID = 2;
    static final int INDEX_IS_REVOKED = 3;
    static final int INDEX_IS_EXPIRED = 4;
    static final int INDEX_VERIFIED = 5;
    static final int INDEX_HAS_ANY_SECRET = 6;
    static final int INDEX_FINGERPRINT = 7;
    static final int INDEX_HAS_ENCRYPT = 8;

    @Override
    public Loader<Cursor> onCreateLoader(int id, Bundle args) {
        switch (id) {
            case LOADER_ID_UNIFIED: {
                Uri baseUri = KeychainContract.KeyRings.buildUnifiedKeyRingUri(mDataUri);
                return new CursorLoader(this, baseUri, PROJECTION, null, null, null);
            }

            default:
                return null;
        }
    }

    int mPreviousColor = 0;

    @Override
    public void onLoadFinished(Loader<Cursor> loader, Cursor data) {
        
        
        if (data.getCount() == 0) {
            return;
        }
        
        
        switch (loader.getId()) {
            case LOADER_ID_UNIFIED: {

                if (data.moveToFirst()) {
                    
                    KeyRing.UserId mainUserId = KeyRing.splitUserId(data.getString(INDEX_USER_ID));
                    if (mainUserId.name != null) {
                        mName.setText(mainUserId.name);
                    } else {
                        mName.setText(R.string.user_id_no_name);
                    }

                    mMasterKeyId = data.getLong(INDEX_MASTER_KEY_ID);
                    mFingerprint = KeyFormattingUtils.convertFingerprintToHex(data.getBlob(INDEX_FINGERPRINT));

                    
                    if (mShowYubikeyAfterCreation && getIntent().hasExtra(EXTRA_NFC_AID)) {
                        mShowYubikeyAfterCreation = false;
                        Intent intent = getIntent();
                        byte[] nfcFingerprints = intent.getByteArrayExtra(EXTRA_NFC_FINGERPRINTS);
                        String nfcUserId = intent.getStringExtra(EXTRA_NFC_USER_ID);
                        byte[] nfcAid = intent.getByteArrayExtra(EXTRA_NFC_AID);
                        showYubiKeyFragment(nfcFingerprints, nfcUserId, nfcAid);
                    }

                    mIsSecret = data.getInt(INDEX_HAS_ANY_SECRET) != 0;
                    mHasEncrypt = data.getInt(INDEX_HAS_ENCRYPT) != 0;
                    mIsRevoked = data.getInt(INDEX_IS_REVOKED) > 0;
                    mIsExpired = data.getInt(INDEX_IS_EXPIRED) != 0;
                    mIsVerified = data.getInt(INDEX_VERIFIED) > 0;

                    
                    if (!mRotate.hasStarted() && !mRotateSpin.hasStarted()) {
                        
                        supportInvalidateOptionsMenu();
                        
                    }

                    AsyncTask<Long, Void, Bitmap> photoTask =
                            new AsyncTask<Long, Void, Bitmap>() {
                                protected Bitmap doInBackground(Long... mMasterKeyId) {
                                    return ContactHelper.loadPhotoByMasterKeyId(getContentResolver(),
                                            mMasterKeyId[0], true);
                                }

                                protected void onPostExecute(Bitmap photo) {
                                    mPhoto.setImageBitmap(photo);
                                    mPhoto.setVisibility(View.VISIBLE);
                                }
                            };

                    
                    int color;
                    if (mIsRevoked) {
                        mStatusText.setText(R.string.view_key_revoked);
                        mStatusImage.setVisibility(View.VISIBLE);
                        KeyFormattingUtils.setStatusImage(this, mStatusImage, mStatusText,
                                State.REVOKED, R.color.icons, true);
                        color = getResources().getColor(R.color.android_red_light);

                        mActionEncryptFile.setVisibility(View.GONE);
                        mActionEncryptText.setVisibility(View.GONE);
                        mActionNfc.setVisibility(View.GONE);
                        mFab.setVisibility(View.GONE);
                        mQrCodeLayout.setVisibility(View.GONE);
                    } else if (mIsExpired) {
                        if (mIsSecret) {
                            mStatusText.setText(R.string.view_key_expired_secret);
                        } else {
                            mStatusText.setText(R.string.view_key_expired);
                        }
                        mStatusImage.setVisibility(View.VISIBLE);
                        KeyFormattingUtils.setStatusImage(this, mStatusImage, mStatusText,
                                State.EXPIRED, R.color.icons, true);
                        color = getResources().getColor(R.color.android_red_light);

                        mActionEncryptFile.setVisibility(View.GONE);
                        mActionEncryptText.setVisibility(View.GONE);
                        mActionNfc.setVisibility(View.GONE);
                        mFab.setVisibility(View.GONE);
                        mQrCodeLayout.setVisibility(View.GONE);
                    } else if (mIsSecret) {
                        mStatusText.setText(R.string.view_key_my_key);
                        mStatusImage.setVisibility(View.GONE);
                        color = getResources().getColor(R.color.primary);
                        
                        if (!mFingerprint.equals(mQrCodeLoaded)) {
                            loadQrCode(mFingerprint);
                        }
                        photoTask.execute(mMasterKeyId);
                        mQrCodeLayout.setVisibility(View.VISIBLE);

                        
                        RelativeLayout.LayoutParams nameParams = (RelativeLayout.LayoutParams)
                                mName.getLayoutParams();
                        
                        nameParams.setMargins(FormattingUtils.dpToPx(this, 48), 0, 0, 0);
                        if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
                            nameParams.setMarginEnd(0);
                        }
                        nameParams.addRule(RelativeLayout.LEFT_OF, R.id.view_key_qr_code_layout);
                        mName.setLayoutParams(nameParams);

                        RelativeLayout.LayoutParams statusParams = (RelativeLayout.LayoutParams)
                                mStatusText.getLayoutParams();
                        statusParams.setMargins(FormattingUtils.dpToPx(this, 48), 0, 0, 0);
                        if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
                            statusParams.setMarginEnd(0);
                        }
                        statusParams.addRule(RelativeLayout.LEFT_OF, R.id.view_key_qr_code_layout);
                        mStatusText.setLayoutParams(statusParams);

                        mActionEncryptFile.setVisibility(View.VISIBLE);
                        mActionEncryptText.setVisibility(View.VISIBLE);

                        
                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                            mActionNfc.setVisibility(View.VISIBLE);
                        } else {
                            mActionNfc.setVisibility(View.GONE);
                        }
                        mFab.setVisibility(View.VISIBLE);
                        mFab.setIconDrawable(getResources().getDrawable(R.drawable.ic_repeat_white_24dp));
                    } else {
                        mActionEncryptFile.setVisibility(View.VISIBLE);
                        mActionEncryptText.setVisibility(View.VISIBLE);
                        mQrCodeLayout.setVisibility(View.GONE);
                        mActionNfc.setVisibility(View.GONE);

                        if (mIsVerified) {
                            mStatusText.setText(R.string.view_key_verified);
                            mStatusImage.setVisibility(View.VISIBLE);
                            KeyFormattingUtils.setStatusImage(this, mStatusImage, mStatusText,
                                    State.VERIFIED, R.color.icons, true);
                            color = getResources().getColor(R.color.primary);
                            photoTask.execute(mMasterKeyId);

                            mFab.setVisibility(View.GONE);
                        } else {
                            mStatusText.setText(R.string.view_key_unverified);
                            mStatusImage.setVisibility(View.VISIBLE);
                            KeyFormattingUtils.setStatusImage(this, mStatusImage, mStatusText,
                                    State.UNVERIFIED, R.color.icons, true);
                            color = getResources().getColor(R.color.android_orange_light);

                            mFab.setVisibility(View.VISIBLE);
                        }
                    }

                    if (mPreviousColor == 0 || mPreviousColor == color) {
                        mStatusBar.setBackgroundColor(color);
                        mBigToolbar.setBackgroundColor(color);
                        mPreviousColor = color;
                    } else {
                        ObjectAnimator colorFade1 =
                                ObjectAnimator.ofObject(mStatusBar, "backgroundColor",
                                        new ArgbEvaluator(), mPreviousColor, color);
                        ObjectAnimator colorFade2 =
                                ObjectAnimator.ofObject(mBigToolbar, "backgroundColor",
                                        new ArgbEvaluator(), mPreviousColor, color);

                        colorFade1.setDuration(1200);
                        colorFade2.setDuration(1200);
                        colorFade1.start();
                        colorFade2.start();
                        mPreviousColor = color;
                    }

                    
                    mStatusImage.setAlpha(80);

                    break;
                }
            }
        }
    }

    @Override
    public void onLoaderReset(Loader<Cursor> loader) {

    }
}
<code block>


package org.sufficientlysecure.keychain.ui;

import android.app.Activity;
import android.app.ProgressDialog;
import android.content.Intent;
import android.database.Cursor;
import android.database.MatrixCursor;
import android.graphics.PorterDuff;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.os.Messenger;
import android.os.Parcel;
import android.support.v4.app.LoaderManager;
import android.support.v4.content.CursorLoader;
import android.support.v4.content.Loader;
import android.view.LayoutInflater;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.CheckBox;
import android.widget.ImageView;
import android.widget.ListView;

import org.sufficientlysecure.keychain.Constants;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.operations.results.CertifyResult;
import org.sufficientlysecure.keychain.operations.results.OperationResult;
import org.sufficientlysecure.keychain.pgp.KeyRing;
import org.sufficientlysecure.keychain.pgp.exception.PgpKeyNotFoundException;
import org.sufficientlysecure.keychain.provider.CachedPublicKeyRing;
import org.sufficientlysecure.keychain.provider.KeychainContract.UserPackets;
import org.sufficientlysecure.keychain.provider.KeychainDatabase.Tables;
import org.sufficientlysecure.keychain.provider.ProviderHelper;
import org.sufficientlysecure.keychain.service.CertifyActionsParcel;
import org.sufficientlysecure.keychain.service.CertifyActionsParcel.CertifyAction;
import org.sufficientlysecure.keychain.service.KeychainService;
import org.sufficientlysecure.keychain.service.ServiceProgressHandler;
import org.sufficientlysecure.keychain.service.input.CryptoInputParcel;
import org.sufficientlysecure.keychain.ui.adapter.MultiUserIdsAdapter;
import org.sufficientlysecure.keychain.ui.base.CachingCryptoOperationFragment;
import org.sufficientlysecure.keychain.ui.util.Notify;
import org.sufficientlysecure.keychain.ui.widget.CertifyKeySpinner;
import org.sufficientlysecure.keychain.util.Log;
import org.sufficientlysecure.keychain.util.Preferences;
import org.sufficientlysecure.keychain.util.orbot.OrbotHelper;

import java.util.ArrayList;

public class CertifyKeyFragment
        extends CachingCryptoOperationFragment<CertifyActionsParcel, CertifyResult>
        implements LoaderManager.LoaderCallbacks<Cursor> {

    public static final String ARG_CHECK_STATES = "check_states";

    private CheckBox mUploadKeyCheckbox;
    ListView mUserIds;

    private CertifyKeySpinner mCertifyKeySpinner;

    private long[] mPubMasterKeyIds;

    public static final String[] USER_IDS_PROJECTION = new String[]{
            UserPackets._ID,
            UserPackets.MASTER_KEY_ID,
            UserPackets.USER_ID,
            UserPackets.IS_PRIMARY,
            UserPackets.IS_REVOKED
    };
    private static final int INDEX_MASTER_KEY_ID = 1;
    private static final int INDEX_USER_ID = 2;
    private static final int INDEX_IS_PRIMARY = 3;
    private static final int INDEX_IS_REVOKED = 4;

    private MultiUserIdsAdapter mUserIdsAdapter;
    private Preferences.ProxyPrefs mProxyPrefs;

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        mProxyPrefs = Preferences.getPreferences(getActivity()).getProxyPrefs();

        mPubMasterKeyIds = getActivity().getIntent().getLongArrayExtra(CertifyKeyActivity.EXTRA_KEY_IDS);
        if (mPubMasterKeyIds == null) {
            Log.e(Constants.TAG, "List of key ids to certify missing!");
            getActivity().finish();
            return;
        }

        ArrayList<Boolean> checkedStates;
        if (savedInstanceState != null) {
            checkedStates = (ArrayList<Boolean>) savedInstanceState.getSerializable(ARG_CHECK_STATES);
            
        } else {
            checkedStates = null;

            
            long certifyKeyId = getActivity().getIntent()
                    .getLongExtra(CertifyKeyActivity.EXTRA_CERTIFY_KEY_ID, Constants.key.none);
            if (certifyKeyId != Constants.key.none) {
                try {
                    CachedPublicKeyRing key = (new ProviderHelper(getActivity())).getCachedPublicKeyRing(certifyKeyId);
                    if (key.canCertify()) {
                        mCertifyKeySpinner.setPreSelectedKeyId(certifyKeyId);
                    }
                } catch (PgpKeyNotFoundException e) {
                    Log.e(Constants.TAG, "certify certify check failed", e);
                }
            }

        }

        mUserIdsAdapter = new MultiUserIdsAdapter(getActivity(), null, 0, checkedStates);
        mUserIds.setAdapter(mUserIdsAdapter);
        mUserIds.setDividerHeight(0);

        getLoaderManager().initLoader(0, null, this);

        OperationResult result = getActivity().getIntent().getParcelableExtra(CertifyKeyActivity.EXTRA_RESULT);
        if (result != null) {
            
            result.createNotify(getActivity()).show();
        }
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);

        ArrayList<Boolean> states = mUserIdsAdapter.getCheckStates();
        
        outState.putSerializable(ARG_CHECK_STATES, states);
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup superContainer, Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.certify_key_fragment, null);

        mCertifyKeySpinner = (CertifyKeySpinner) view.findViewById(R.id.certify_key_spinner);
        mUploadKeyCheckbox = (CheckBox) view.findViewById(R.id.sign_key_upload_checkbox);
        mUserIds = (ListView) view.findViewById(R.id.view_key_user_ids);

        
        ImageView vActionCertifyImage =
                (ImageView) view.findViewById(R.id.certify_key_action_certify_image);
        vActionCertifyImage.setColorFilter(getResources().getColor(R.color.tertiary_text_light),
                PorterDuff.Mode.SRC_IN);

        View vCertifyButton = view.findViewById(R.id.certify_key_certify_button);
        vCertifyButton.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                long selectedKeyId = mCertifyKeySpinner.getSelectedKeyId();
                if (selectedKeyId == Constants.key.none) {
                    Notify.create(getActivity(), getString(R.string.select_key_to_certify),
                            Notify.Style.ERROR).show();
                } else {

                    if (mUploadKeyCheckbox.isChecked() && mProxyPrefs.torEnabled) {
                        Handler ignoreTorHandler = new Handler() {
                            @Override
                            public void handleMessage(Message msg) {
                                mProxyPrefs = new Preferences.ProxyPrefs(false, false, null, -1, null);
                                cryptoOperation();
                            }
                        };
                        if (!OrbotHelper.isOrbotInstalled(getActivity())) {
                            OrbotHelper.getInstallDialogFragmentWithThirdButton(new Messenger(ignoreTorHandler),
                                    R.string.orbot_install_dialog_ignore_tor).show(getActivity()
                                    .getSupportFragmentManager(), "installOrbot");
                        } else if (!OrbotHelper.isOrbotRunning()) {
                            OrbotHelper.getOrbotStartDialogFragment(new Messenger(ignoreTorHandler),
                                    R.string.orbot_install_dialog_ignore_tor).show(getActivity()
                                    .getSupportFragmentManager(), "startOrbot");
                        } else {
                            cryptoOperation();
                        }
                    }
                }
            }
        });

        
        if (Constants.DEBUG) {
            mUploadKeyCheckbox.setChecked(false);
        }

        return view;
    }

    @Override
    public Loader<Cursor> onCreateLoader(int id, Bundle args) {
        Uri uri = UserPackets.buildUserIdsUri();

        String selection, ids[];
        {
            
            ids = new String[mPubMasterKeyIds.length];
            StringBuilder placeholders = new StringBuilder("?");
            for (int i = 0; i < mPubMasterKeyIds.length; i++) {
                ids[i] = Long.toString(mPubMasterKeyIds[i]);
                if (i != 0) {
                    placeholders.append(",?");
                }
            }
            
            selection = UserPackets.IS_REVOKED + " = 0" + " AND "
                    + Tables.USER_PACKETS + "." + UserPackets.MASTER_KEY_ID
                    + " IN (" + placeholders + ")";
        }

        return new CursorLoader(getActivity(), uri,
                USER_IDS_PROJECTION, selection, ids,
                Tables.USER_PACKETS + "." + UserPackets.MASTER_KEY_ID + " ASC"
                        + ", " + Tables.USER_PACKETS + "." + UserPackets.USER_ID + " ASC"
        );
    }

    @Override
    public void onLoadFinished(Loader<Cursor> loader, Cursor data) {

        MatrixCursor matrix = new MatrixCursor(new String[]{
                "_id", "user_data", "grouped"
        }) {
            @Override
            public byte[] getBlob(int column) {
                return super.getBlob(column);
            }
        };
        data.moveToFirst();

        long lastMasterKeyId = 0;
        String lastName = "";
        ArrayList<String> uids = new ArrayList<>();

        boolean header = true;

        
        while (!data.isAfterLast()) {
            long masterKeyId = data.getLong(INDEX_MASTER_KEY_ID);
            String userId = data.getString(INDEX_USER_ID);
            KeyRing.UserId pieces = KeyRing.splitUserId(userId);

            

            boolean grouped = masterKeyId == lastMasterKeyId;
            boolean subGrouped = data.isFirst() || grouped && lastName.equals(pieces.name);
            
            lastName = pieces.name;

            Log.d(Constants.TAG, Long.toString(masterKeyId, 16) + (grouped ? "grouped" : "not grouped"));

            if (!subGrouped) {
                

                Parcel p = Parcel.obtain();
                p.writeStringList(uids);
                byte[] d = p.marshall();
                p.recycle();

                matrix.addRow(new Object[]{
                        lastMasterKeyId, d, header ? 1 : 0
                });
                
                header = false;

                
                uids.clear();

            }

            
            uids.add(userId);
            lastMasterKeyId = masterKeyId;

            
            if (!grouped) {
                header = true;
            }

            
            data.moveToNext();

        }

        
        if (!uids.isEmpty()) {

            Parcel p = Parcel.obtain();
            p.writeStringList(uids);
            byte[] d = p.marshall();
            p.recycle();

            matrix.addRow(new Object[]{
                    lastMasterKeyId, d, header ? 1 : 0
            });

        }

        mUserIdsAdapter.swapCursor(matrix);
    }

    @Override
    public void onLoaderReset(Loader<Cursor> loader) {
        mUserIdsAdapter.swapCursor(null);
    }

    @Override
    protected CertifyActionsParcel createOperationInput() {

        
        ArrayList<CertifyAction> certifyActions = mUserIdsAdapter.getSelectedCertifyActions();
        if (certifyActions.isEmpty()) {
            Notify.create(getActivity(), "No identities selected!",
                    Notify.Style.ERROR).show();
            return null;
        }

        long selectedKeyId = mCertifyKeySpinner.getSelectedKeyId();

        
        CertifyActionsParcel actionsParcel = new CertifyActionsParcel(selectedKeyId);
        actionsParcel.mCertifyActions.addAll(certifyActions);

        if (mUploadKeyCheckbox.isChecked()) {
            actionsParcel.keyServerUri = Preferences.getPreferences(getActivity()).getPreferredKeyserver();
            actionsParcel.parcelableProxy = mProxyPrefs.parcelableProxy;
        }

        
        cacheActionsParcel(actionsParcel);

        return actionsParcel;
    }

    @Override
    protected void onCryptoOperationSuccess(CertifyResult result) {
        Intent intent = new Intent();
        intent.putExtra(CertifyResult.EXTRA_RESULT, result);
        getActivity().setResult(Activity.RESULT_OK, intent);
        getActivity().finish();
    }

    @Override
    protected void onCryptoOperationCancelled() {
        super.onCryptoOperationCancelled();
    }

}

<code block>


package org.sufficientlysecure.keychain.ui;

import android.app.ProgressDialog;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.os.Message;
import android.os.Messenger;
import android.support.v4.app.Fragment;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;

import org.sufficientlysecure.keychain.Constants;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.intents.OpenKeychainIntents;
import org.sufficientlysecure.keychain.keyimport.ImportKeysListEntry;
import org.sufficientlysecure.keychain.keyimport.ParcelableKeyRing;
import org.sufficientlysecure.keychain.operations.results.ImportKeyResult;
import org.sufficientlysecure.keychain.operations.results.OperationResult;
import org.sufficientlysecure.keychain.service.KeychainService;
import org.sufficientlysecure.keychain.ui.base.BaseNfcActivity;
import org.sufficientlysecure.keychain.service.ServiceProgressHandler;
import org.sufficientlysecure.keychain.ui.util.KeyFormattingUtils;
import org.sufficientlysecure.keychain.ui.util.Notify;
import org.sufficientlysecure.keychain.util.Log;
import org.sufficientlysecure.keychain.util.ParcelableFileCache;
import org.sufficientlysecure.keychain.util.ParcelableFileCache.IteratorWithSize;
import org.sufficientlysecure.keychain.util.Preferences;
import org.sufficientlysecure.keychain.util.orbot.OrbotHelper;

import java.io.IOException;
import java.util.ArrayList;

public class ImportKeysActivity extends BaseNfcActivity {

    public static final String ACTION_IMPORT_KEY = OpenKeychainIntents.IMPORT_KEY;
    public static final String ACTION_IMPORT_KEY_FROM_KEYSERVER = OpenKeychainIntents.IMPORT_KEY_FROM_KEYSERVER;
    public static final String ACTION_IMPORT_KEY_FROM_KEYSERVER_AND_RETURN_RESULT =
            Constants.INTENT_PREFIX + "IMPORT_KEY_FROM_KEY_SERVER_AND_RETURN_RESULT";
    public static final String ACTION_IMPORT_KEY_FROM_KEYSERVER_AND_RETURN_TO_SERVICE = Constants.INTENT_PREFIX
            + "IMPORT_KEY_FROM_KEY_SERVER_AND_RETURN";
    public static final String ACTION_IMPORT_KEY_FROM_FILE_AND_RETURN = Constants.INTENT_PREFIX
            + "IMPORT_KEY_FROM_FILE_AND_RETURN";

    
    public static final String ACTION_IMPORT_KEY_FROM_FILE = Constants.INTENT_PREFIX
            + "IMPORT_KEY_FROM_FILE";
    public static final String ACTION_SEARCH_KEYSERVER_FROM_URL = Constants.INTENT_PREFIX
            + "SEARCH_KEYSERVER_FROM_URL";
    public static final String EXTRA_RESULT = "result";

    
    public static final String EXTRA_KEY_BYTES = OpenKeychainIntents.IMPORT_EXTRA_KEY_EXTRA_KEY_BYTES;

    
    public static final String EXTRA_QUERY = OpenKeychainIntents.IMPORT_KEY_FROM_KEYSERVER_EXTRA_QUERY;
    public static final String EXTRA_KEY_ID = Constants.EXTRA_PREFIX + "EXTRA_KEY_ID";
    public static final String EXTRA_FINGERPRINT = OpenKeychainIntents.IMPORT_KEY_FROM_KEYSERVER_EXTRA_FINGERPRINT;

    
    public static final String EXTRA_PENDING_INTENT_DATA = "data";
    private Intent mPendingIntentData;

    
    private ImportKeysListFragment mListFragment;
    private Fragment mTopFragment;
    private View mImportButton;

    private Preferences.ProxyPrefs mProxyPrefs;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        mProxyPrefs = Preferences.getPreferences(this).getProxyPrefs();

        mImportButton = findViewById(R.id.import_import);
        mImportButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                importKeys();
            }
        });

        handleActions(savedInstanceState, getIntent());
    }

    @Override
    protected void initLayout() {
        setContentView(R.layout.import_keys_activity);
    }

    protected void handleActions(Bundle savedInstanceState, Intent intent) {
        String action = intent.getAction();
        Bundle extras = intent.getExtras();
        Uri dataUri = intent.getData();
        String scheme = intent.getScheme();

        if (extras == null) {
            extras = new Bundle();
        }

        if (action == null) {
            startCloudFragment(savedInstanceState, null, false, null);
            startListFragment(savedInstanceState, null, null, null, null);
            return;
        }

        if (Intent.ACTION_VIEW.equals(action)) {
            if (scheme.equals("http") || scheme.equals("https")) {
                action = ACTION_SEARCH_KEYSERVER_FROM_URL;
            } else {
                
                
                action = ACTION_IMPORT_KEY;
            }
        }

        switch (action) {
            case ACTION_IMPORT_KEY: {
                
                startFileFragment(savedInstanceState);

                if (dataUri != null) {
                    
                    startListFragment(savedInstanceState, null, dataUri, null, null);
                } else if (extras.containsKey(EXTRA_KEY_BYTES)) {
                    byte[] importData = extras.getByteArray(EXTRA_KEY_BYTES);

                    
                    startListFragment(savedInstanceState, importData, null, null, null);
                }
                break;
            }
            case ACTION_IMPORT_KEY_FROM_KEYSERVER:
            case ACTION_IMPORT_KEY_FROM_KEYSERVER_AND_RETURN_TO_SERVICE:
            case ACTION_IMPORT_KEY_FROM_KEYSERVER_AND_RETURN_RESULT: {

                
                if (extras.containsKey(EXTRA_PENDING_INTENT_DATA)) {
                    mPendingIntentData = extras.getParcelable(EXTRA_PENDING_INTENT_DATA);
                }
                if (extras.containsKey(EXTRA_QUERY) || extras.containsKey(EXTRA_KEY_ID)) {
                    

                    String query = null;
                    if (extras.containsKey(EXTRA_QUERY)) {
                        query = extras.getString(EXTRA_QUERY);
                    } else if (extras.containsKey(EXTRA_KEY_ID)) {
                        long keyId = extras.getLong(EXTRA_KEY_ID, 0);
                        if (keyId != 0) {
                            query = KeyFormattingUtils.convertKeyIdToHex(keyId);
                        }
                    }

                    if (query != null && query.length() > 0) {
                        
                        startCloudFragment(savedInstanceState, query, false, null);

                        
                        startListFragment(savedInstanceState, null, null, query, null);
                    } else {
                        Log.e(Constants.TAG, "Query is empty!");
                        return;
                    }
                } else if (extras.containsKey(EXTRA_FINGERPRINT)) {
                    

                    String fingerprint = extras.getString(EXTRA_FINGERPRINT);
                    if (isFingerprintValid(fingerprint)) {
                        String query = "0x" + fingerprint;

                        
                        startCloudFragment(savedInstanceState, query, true, null);

                        
                        startListFragment(savedInstanceState, null, null, query, null);
                    }
                } else {
                    Log.e(Constants.TAG,
                            "IMPORT_KEY_FROM_KEYSERVER action needs to contain the 'query', 'key_id', or " +
                                    "'fingerprint' extra!"
                    );
                    return;
                }
                break;
            }
            case ACTION_IMPORT_KEY_FROM_FILE: {
                
                startFileFragment(savedInstanceState);

                
                startListFragment(savedInstanceState, null, null, null, null);
                break;
            }
            case ACTION_SEARCH_KEYSERVER_FROM_URL: {
                
                String query = dataUri.getQueryParameter("search");
                String keyserver = dataUri.getAuthority();
                
                if (query == null) {
                    Notify.create(this, R.string.import_url_warn_no_search_parameter, Notify.LENGTH_INDEFINITE,
                            Notify.Style.WARN).show(mTopFragment);
                    
                    startCloudFragment(savedInstanceState, null, false, keyserver);
                    
                    
                    
                    startListFragment(savedInstanceState, null, null, null, null);
                } else {
                    
                    startCloudFragment(savedInstanceState, query, false, keyserver);
                    
                    startListFragment(savedInstanceState, null, null, query, keyserver);
                }
                break;
            }
            case ACTION_IMPORT_KEY_FROM_FILE_AND_RETURN: {
                
                startFileFragment(savedInstanceState);

                
                startListFragment(savedInstanceState, null, null, null, null);
                break;
            }
            default: {
                startCloudFragment(savedInstanceState, null, false, null);
                startListFragment(savedInstanceState, null, null, null, null);
                break;
            }
        }
    }


    
    private void startListFragment(Bundle savedInstanceState, byte[] bytes, Uri dataUri,
                                   String serverQuery, String keyserver) {
        
        
        
        if (mListFragment != null) {
            return;
        }

        mListFragment = ImportKeysListFragment.newInstance(bytes, dataUri, serverQuery, false,
                keyserver);

        
        
        getSupportFragmentManager().beginTransaction()
                .replace(R.id.import_keys_list_container, mListFragment)
                .commitAllowingStateLoss();
        
        getSupportFragmentManager().executePendingTransactions();
    }

    private void startFileFragment(Bundle savedInstanceState) {
        
        
        
        if (mTopFragment != null) {
            return;
        }

        
        mTopFragment = ImportKeysFileFragment.newInstance();

        
        
        getSupportFragmentManager().beginTransaction()
                .replace(R.id.import_keys_top_container, mTopFragment)
                .commitAllowingStateLoss();
        
        getSupportFragmentManager().executePendingTransactions();
    }

    

    private void startCloudFragment(Bundle savedInstanceState, String query, boolean disableQueryEdit, String
            keyserver) {
        
        
        
        if (mTopFragment != null) {
            return;
        }

        
        mTopFragment = ImportKeysCloudFragment.newInstance(query, disableQueryEdit, keyserver);

        
        
        getSupportFragmentManager().beginTransaction()
                .replace(R.id.import_keys_top_container, mTopFragment)
                .commitAllowingStateLoss();
        
        getSupportFragmentManager().executePendingTransactions();
    }

    private boolean isFingerprintValid(String fingerprint) {
        if (fingerprint == null || fingerprint.length() < 40) {
            Notify.create(this, R.string.import_qr_code_too_short_fingerprint, Notify.Style.ERROR)
                    .show((ViewGroup) findViewById(R.id.import_snackbar));
            return false;
        } else {
            return true;
        }
    }

    public void loadCallback(final ImportKeysListFragment.LoaderState loaderState) {
        if (loaderState instanceof ImportKeysListFragment.CloudLoaderState) {
            
            
            Runnable ignoreTor = new Runnable() {
                @Override
                public void run() {
                    
                    mProxyPrefs = new Preferences.ProxyPrefs(false, false, null, -1, null);
                    mListFragment.loadNew(loaderState, mProxyPrefs.parcelableProxy);
                }
            };
            if (OrbotHelper.isOrbotInRequiredState(R.string.orbot_ignore_tor, ignoreTor, mProxyPrefs, this)) {
                mListFragment.loadNew(loaderState, mProxyPrefs.parcelableProxy);
            }
        } else if (loaderState instanceof ImportKeysListFragment.BytesLoaderState) { 
            mListFragment.loadNew(loaderState, mProxyPrefs.parcelableProxy);
        }
    }

    private void handleMessage(Message message) {
        if (message.arg1 == ServiceProgressHandler.MessageStatus.OKAY.ordinal()) {
            
            Bundle returnData = message.getData();
            if (returnData == null) {
                return;
            }
            final ImportKeyResult result =
                    returnData.getParcelable(OperationResult.EXTRA_RESULT);
            if (result == null) {
                Log.e(Constants.TAG, "result == null");
                return;
            }

            if (ACTION_IMPORT_KEY_FROM_KEYSERVER_AND_RETURN_RESULT.equals(getIntent().getAction())
                    || ACTION_IMPORT_KEY_FROM_FILE_AND_RETURN.equals(getIntent().getAction())) {
                Intent intent = new Intent();
                intent.putExtra(ImportKeyResult.EXTRA_RESULT, result);
                ImportKeysActivity.this.setResult(RESULT_OK, intent);
                ImportKeysActivity.this.finish();
                return;
            }
            if (ACTION_IMPORT_KEY_FROM_KEYSERVER_AND_RETURN_TO_SERVICE.equals(getIntent().getAction())) {
                ImportKeysActivity.this.setResult(RESULT_OK, mPendingIntentData);
                ImportKeysActivity.this.finish();
                return;
            }

            result.createNotify(ImportKeysActivity.this)
                    .show((ViewGroup) findViewById(R.id.import_snackbar));
        }
    }

    
    public void importKeys() {

        if (mListFragment.getSelectedEntries().size() == 0) {
            Notify.create(this, R.string.error_nothing_import_selected, Notify.Style.ERROR)
                    .show((ViewGroup) findViewById(R.id.import_snackbar));
            return;
        }

        ServiceProgressHandler serviceHandler = new ServiceProgressHandler(this) {
            @Override
            public void handleMessage(Message message) {
                
                super.handleMessage(message);

                ImportKeysActivity.this.handleMessage(message);
            }
        };

        
        Intent intent = new Intent(this, KeychainService.class);

        intent.setAction(KeychainService.ACTION_IMPORT_KEYRING);

        
        Bundle data = new Bundle();

        ImportKeysListFragment.LoaderState ls = mListFragment.getLoaderState();
        if (ls instanceof ImportKeysListFragment.BytesLoaderState) {
            Log.d(Constants.TAG, "importKeys started");

            
            IteratorWithSize<ParcelableKeyRing> selectedEntries = mListFragment.getSelectedData();

            
            
            
            try {
                
                
                ParcelableFileCache<ParcelableKeyRing> cache =
                        new ParcelableFileCache<>(this, "key_import.pcl");
                cache.writeCache(selectedEntries);

                intent.putExtra(KeychainService.EXTRA_DATA, data);

                
                Messenger messenger = new Messenger(serviceHandler);
                intent.putExtra(KeychainService.EXTRA_MESSENGER, messenger);

                
                serviceHandler.showProgressDialog(
                        getString(R.string.progress_importing),
                        ProgressDialog.STYLE_HORIZONTAL,
                        true
                );

                
                startService(intent);
            } catch (IOException e) {
                Log.e(Constants.TAG, "Problem writing cache file", e);
                Notify.create(this, "Problem writing cache file!", Notify.Style.ERROR)
                        .show((ViewGroup) findViewById(R.id.import_snackbar));
            }
        } else if (ls instanceof ImportKeysListFragment.CloudLoaderState) {
            ImportKeysListFragment.CloudLoaderState sls = (ImportKeysListFragment.CloudLoaderState) ls;

            data.putString(KeychainService.IMPORT_KEY_SERVER, sls.mCloudPrefs.keyserver);

            data.putParcelable(KeychainService.EXTRA_PARCELABLE_PROXY, mProxyPrefs.parcelableProxy);

            
            ArrayList<ParcelableKeyRing> keys = new ArrayList<>();
            {
                
                ArrayList<ImportKeysListEntry> entries = mListFragment.getSelectedEntries();
                for (ImportKeysListEntry entry : entries) {
                    keys.add(new ParcelableKeyRing(
                                    entry.getFingerprintHex(), entry.getKeyIdHex(), entry.getExtraData())
                    );
                }
            }
            data.putParcelableArrayList(KeychainService.IMPORT_KEY_LIST, keys);

            intent.putExtra(KeychainService.EXTRA_DATA, data);

            
            Messenger messenger = new Messenger(serviceHandler);
            intent.putExtra(KeychainService.EXTRA_MESSENGER, messenger);

            
            serviceHandler.showProgressDialog(
                    getString(R.string.progress_importing),
                    ProgressDialog.STYLE_HORIZONTAL, true
            );

            
            startService(intent);
        }
    }

    @Override
    protected void onNfcPerform() throws IOException {
        
        super.onNfcPerform();
        
        finish();
    }
}

<code block>


package org.sufficientlysecure.keychain.ui;

import android.annotation.TargetApi;
import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.os.Build;
import android.os.Bundle;
import android.preference.CheckBoxPreference;
import android.preference.EditTextPreference;
import android.preference.ListPreference;
import android.preference.Preference;
import android.preference.PreferenceActivity;
import android.preference.PreferenceFragment;
import android.preference.PreferenceScreen;
import android.support.v7.widget.Toolbar;
import android.text.TextUtils;
import android.view.View;
import android.view.ViewGroup;
import android.widget.LinearLayout;

import org.spongycastle.bcpg.CompressionAlgorithmTags;
import org.sufficientlysecure.keychain.Constants;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.ui.util.Notify;
import org.sufficientlysecure.keychain.ui.widget.IntegerListPreference;
import org.sufficientlysecure.keychain.util.Log;
import org.sufficientlysecure.keychain.util.Preferences;
import org.sufficientlysecure.keychain.util.orbot.OrbotHelper;

import java.util.List;

public class SettingsActivity extends PreferenceActivity {

    public static final String ACTION_PREFS_CLOUD = "org.sufficientlysecure.keychain.ui.PREFS_CLOUD";
    public static final String ACTION_PREFS_ADV = "org.sufficientlysecure.keychain.ui.PREFS_ADV";
    public static final String ACTION_PREFS_PROXY = "org.sufficientlysecure.keychain.ui.PREFS_PROXY";

    public static final int REQUEST_CODE_KEYSERVER_PREF = 0x00007005;

    private PreferenceScreen mKeyServerPreference = null;
    private static Preferences sPreferences;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        sPreferences = Preferences.getPreferences(this);
        super.onCreate(savedInstanceState);

        setupToolbar();

        String action = getIntent().getAction();
        if (action == null) return;

        switch (action) {
            case ACTION_PREFS_CLOUD: {
                addPreferencesFromResource(R.xml.cloud_search_prefs);

                mKeyServerPreference = (PreferenceScreen) findPreference(Constants.Pref.KEY_SERVERS);
                mKeyServerPreference.setSummary(keyserverSummary(this));
                mKeyServerPreference
                        .setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {
                            public boolean onPreferenceClick(Preference preference) {
                                Intent intent = new Intent(SettingsActivity.this,
                                        SettingsKeyServerActivity.class);
                                intent.putExtra(SettingsKeyServerActivity.EXTRA_KEY_SERVERS,
                                        sPreferences.getKeyServers());
                                startActivityForResult(intent, REQUEST_CODE_KEYSERVER_PREF);
                                return false;
                            }
                        });
                initializeSearchKeyserver(
                        (CheckBoxPreference) findPreference(Constants.Pref.SEARCH_KEYSERVER)
                );
                initializeSearchKeybase(
                        (CheckBoxPreference) findPreference(Constants.Pref.SEARCH_KEYBASE)
                );

                break;
            }

            case ACTION_PREFS_ADV: {
                addPreferencesFromResource(R.xml.adv_preferences);

                initializePassphraseCacheSubs(
                        (CheckBoxPreference) findPreference(Constants.Pref.PASSPHRASE_CACHE_SUBS));

                initializePassphraseCacheTtl(
                        (IntegerListPreference) findPreference(Constants.Pref.PASSPHRASE_CACHE_TTL));

                int[] valueIds = new int[]{
                        CompressionAlgorithmTags.UNCOMPRESSED,
                        CompressionAlgorithmTags.ZIP,
                        CompressionAlgorithmTags.ZLIB,
                        CompressionAlgorithmTags.BZIP2,
                };
                String[] entries = new String[]{
                        getString(R.string.choice_none) + " (" + getString(R.string.compression_fast) + ")",
                        "ZIP (" + getString(R.string.compression_fast) + ")",
                        "ZLIB (" + getString(R.string.compression_fast) + ")",
                        "BZIP2 (" + getString(R.string.compression_very_slow) + ")",};
                String[] values = new String[valueIds.length];
                for (int i = 0; i < values.length; ++i) {
                    values[i] = "" + valueIds[i];
                }

                initializeUseDefaultYubiKeyPin(
                        (CheckBoxPreference) findPreference(Constants.Pref.USE_DEFAULT_YUBIKEY_PIN));

                initializeUseNumKeypadForYubiKeyPin(
                        (CheckBoxPreference) findPreference(Constants.Pref.USE_NUMKEYPAD_FOR_YUBIKEY_PIN));

                break;
            }

            case ACTION_PREFS_PROXY: {
                new ProxyPrefsFragment.Initializer(this).initialize();

                break;
            }
        }
    }

    
    private void setupToolbar() {
        ViewGroup root = (ViewGroup) findViewById(android.R.id.content);
        LinearLayout content = (LinearLayout) root.getChildAt(0);
        LinearLayout toolbarContainer = (LinearLayout) View.inflate(this, R.layout.preference_toolbar_activity, null);

        root.removeAllViews();
        toolbarContainer.addView(content);
        root.addView(toolbarContainer);

        Toolbar toolbar = (Toolbar) toolbarContainer.findViewById(R.id.toolbar);
        toolbar.setTitle(R.string.title_preferences);
        toolbar.setNavigationIcon(getResources().getDrawable(R.drawable.ic_arrow_back_white_24dp));
        toolbar.setNavigationOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                
                finish();
            }
        });
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        switch (requestCode) {
            case REQUEST_CODE_KEYSERVER_PREF: {
                if (resultCode == RESULT_CANCELED || data == null) {
                    return;
                }
                String servers[] = data
                        .getStringArrayExtra(SettingsKeyServerActivity.EXTRA_KEY_SERVERS);
                sPreferences.setKeyServers(servers);
                mKeyServerPreference.setSummary(keyserverSummary(this));
                break;
            }

            default: {
                super.onActivityResult(requestCode, resultCode, data);
                break;
            }
        }
    }

    @Override
    public void onBuildHeaders(List<Header> target) {
        super.onBuildHeaders(target);
        loadHeadersFromResource(R.xml.preference_headers, target);
    }

    
    public static class CloudSearchPrefsFragment extends PreferenceFragment {

        private PreferenceScreen mKeyServerPreference = null;

        @Override
        public void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);

            
            addPreferencesFromResource(R.xml.cloud_search_prefs);

            mKeyServerPreference = (PreferenceScreen) findPreference(Constants.Pref.KEY_SERVERS);
            mKeyServerPreference.setSummary(keyserverSummary(getActivity()));

            mKeyServerPreference
                    .setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {
                        public boolean onPreferenceClick(Preference preference) {
                            Intent intent = new Intent(getActivity(),
                                    SettingsKeyServerActivity.class);
                            intent.putExtra(SettingsKeyServerActivity.EXTRA_KEY_SERVERS,
                                    sPreferences.getKeyServers());
                            startActivityForResult(intent, REQUEST_CODE_KEYSERVER_PREF);
                            return false;
                        }
                    });
            initializeSearchKeyserver(
                    (CheckBoxPreference) findPreference(Constants.Pref.SEARCH_KEYSERVER)
            );
            initializeSearchKeybase(
                    (CheckBoxPreference) findPreference(Constants.Pref.SEARCH_KEYBASE)
            );
        }

        @Override
        public void onActivityResult(int requestCode, int resultCode, Intent data) {
            switch (requestCode) {
                case REQUEST_CODE_KEYSERVER_PREF: {
                    if (resultCode == RESULT_CANCELED || data == null) {
                        return;
                    }
                    String servers[] = data
                            .getStringArrayExtra(SettingsKeyServerActivity.EXTRA_KEY_SERVERS);
                    sPreferences.setKeyServers(servers);
                    mKeyServerPreference.setSummary(keyserverSummary(getActivity()));
                    break;
                }

                default: {
                    super.onActivityResult(requestCode, resultCode, data);
                    break;
                }
            }
        }
    }

    
    public static class AdvancedPrefsFragment extends PreferenceFragment {

        @Override
        public void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);

            
            addPreferencesFromResource(R.xml.adv_preferences);

            initializePassphraseCacheSubs(
                    (CheckBoxPreference) findPreference(Constants.Pref.PASSPHRASE_CACHE_SUBS));

            initializePassphraseCacheTtl(
                    (IntegerListPreference) findPreference(Constants.Pref.PASSPHRASE_CACHE_TTL));

            int[] valueIds = new int[]{
                    CompressionAlgorithmTags.UNCOMPRESSED,
                    CompressionAlgorithmTags.ZIP,
                    CompressionAlgorithmTags.ZLIB,
                    CompressionAlgorithmTags.BZIP2,
            };

            String[] entries = new String[]{
                    getString(R.string.choice_none) + " (" + getString(R.string.compression_fast) + ")",
                    "ZIP (" + getString(R.string.compression_fast) + ")",
                    "ZLIB (" + getString(R.string.compression_fast) + ")",
                    "BZIP2 (" + getString(R.string.compression_very_slow) + ")",
            };

            String[] values = new String[valueIds.length];
            for (int i = 0; i < values.length; ++i) {
                values[i] = "" + valueIds[i];
            }

            initializeUseDefaultYubiKeyPin(
                    (CheckBoxPreference) findPreference(Constants.Pref.USE_DEFAULT_YUBIKEY_PIN));

            initializeUseNumKeypadForYubiKeyPin(
                    (CheckBoxPreference) findPreference(Constants.Pref.USE_NUMKEYPAD_FOR_YUBIKEY_PIN));
        }
    }

    public static class ProxyPrefsFragment extends PreferenceFragment {

        @Override
        public void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);

            new Initializer(this).initialize();

        }

        public static class Initializer {
            private CheckBoxPreference mUseTor;
            private CheckBoxPreference mUseNormalProxy;
            private EditTextPreference mProxyHost;
            private EditTextPreference mProxyPort;
            private ListPreference mProxyType;
            private PreferenceActivity mActivity;
            private PreferenceFragment mFragment;

            public Initializer(PreferenceFragment fragment) {
                mFragment = fragment;
            }

            public Initializer(PreferenceActivity activity) {
                mActivity = activity;
            }

            public Preference automaticallyFindPreference(String key) {
                if (mFragment != null) {
                    return mFragment.findPreference(key);
                } else {
                    return mActivity.findPreference(key);
                }
            }

            public void initialize() {
                
                
                if (mFragment != null) {
                    Preferences.setPreferenceManagerFileAndMode(mFragment.getPreferenceManager());
                    
                    mFragment.addPreferencesFromResource(R.xml.proxy_prefs);
                } else {
                    Preferences.setPreferenceManagerFileAndMode(mActivity.getPreferenceManager());
                    
                    mActivity.addPreferencesFromResource(R.xml.proxy_prefs);
                }

                mUseTor = (CheckBoxPreference) automaticallyFindPreference(Constants.Pref.USE_TOR_PROXY);
                mUseNormalProxy = (CheckBoxPreference) automaticallyFindPreference(Constants.Pref.USE_NORMAL_PROXY);
                mProxyHost = (EditTextPreference) automaticallyFindPreference(Constants.Pref.PROXY_HOST);
                mProxyPort = (EditTextPreference) automaticallyFindPreference(Constants.Pref.PROXY_PORT);
                mProxyType = (ListPreference) automaticallyFindPreference(Constants.Pref.PROXY_TYPE);
                initializeUseTorPref();
                initializeUseNormalProxyPref();
                initializeEditTextPreferences();
                initializeProxyTypePreference();

                if (mUseTor.isChecked()) disableNormalProxyPrefs();
                else if (mUseNormalProxy.isChecked()) disableUseTorPrefs();
            }

            private void initializeUseTorPref() {
                mUseTor.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
                    @Override
                    public boolean onPreferenceChange(Preference preference, Object newValue) {
                        Activity activity = mFragment != null ? mFragment.getActivity() : mActivity;
                        if ((Boolean) newValue) {
                            boolean installed = OrbotHelper.isOrbotInstalled(activity);
                            if (!installed) {
                                Log.d(Constants.TAG, "Prompting to install Tor");
                                OrbotHelper.getPreferenceInstallDialogFragment().show(activity.getFragmentManager(),
                                        "installDialog");
                                
                                return false;
                            } else {
                                disableNormalProxyPrefs();
                                
                                return true;
                            }
                        } else {
                            
                            enableNormalProxyPrefs();
                            return true;
                        }
                    }
                });
            }

            private void initializeUseNormalProxyPref() {
                mUseNormalProxy.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
                    @Override
                    public boolean onPreferenceChange(Preference preference, Object newValue) {
                        if ((Boolean) newValue) {
                            disableUseTorPrefs();
                        } else {
                            enableUseTorPrefs();
                        }
                        return true;
                    }
                });
            }

            private void initializeEditTextPreferences() {
                mProxyHost.setSummary(mProxyHost.getText());
                mProxyPort.setSummary(mProxyPort.getText());

                mProxyHost.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
                    @Override
                    public boolean onPreferenceChange(Preference preference, Object newValue) {
                        Activity activity = mFragment != null ? mFragment.getActivity() : mActivity;
                        if (TextUtils.isEmpty((String) newValue)) {
                            Notify.create(
                                    activity,
                                    R.string.pref_proxy_host_err_invalid,
                                    Notify.Style.ERROR
                            ).show();
                            return false;
                        } else {
                            mProxyHost.setSummary((CharSequence) newValue);
                            return true;
                        }
                    }
                });

                mProxyPort.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
                    @Override
                    public boolean onPreferenceChange(Preference preference, Object newValue) {
                        Activity activity = mFragment != null ? mFragment.getActivity() : mActivity;
                        try {
                            int port = Integer.parseInt((String) newValue);
                            if (port < 0 || port > 65535) {
                                Notify.create(
                                        activity,
                                        R.string.pref_proxy_port_err_invalid,
                                        Notify.Style.ERROR
                                ).show();
                                return false;
                            }
                            
                            mProxyPort.setSummary("" + port);
                            return true;
                        } catch (NumberFormatException e) {
                            Notify.create(
                                    activity,
                                    R.string.pref_proxy_port_err_invalid,
                                    Notify.Style.ERROR
                            ).show();
                            return false;
                        }
                    }
                });
            }

            private void initializeProxyTypePreference() {
                mProxyType.setSummary(mProxyType.getEntry());

                mProxyType.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
                    @Override
                    public boolean onPreferenceChange(Preference preference, Object newValue) {
                        CharSequence entry = mProxyType.getEntries()[mProxyType.findIndexOfValue((String) newValue)];
                        mProxyType.setSummary(entry);
                        return true;
                    }
                });
            }

            private void disableNormalProxyPrefs() {
                mUseNormalProxy.setChecked(false);
                mUseNormalProxy.setEnabled(false);
                mProxyHost.setEnabled(false);
                mProxyPort.setEnabled(false);
                mProxyType.setEnabled(false);
            }

            private void enableNormalProxyPrefs() {
                mUseNormalProxy.setEnabled(true);
                mProxyHost.setEnabled(true);
                mProxyPort.setEnabled(true);
                mProxyType.setEnabled(true);
            }

            private void disableUseTorPrefs() {
                mUseTor.setChecked(false);
                mUseTor.setEnabled(false);
            }

            private void enableUseTorPrefs() {
                mUseTor.setEnabled(true);
            }
        }

    }

    @TargetApi(Build.VERSION_CODES.KITKAT)
    protected boolean isValidFragment(String fragmentName) {
        return AdvancedPrefsFragment.class.getName().equals(fragmentName)
                || CloudSearchPrefsFragment.class.getName().equals(fragmentName)
                || ProxyPrefsFragment.class.getName().equals(fragmentName)
                || super.isValidFragment(fragmentName);
    }

    private static void initializePassphraseCacheSubs(final CheckBoxPreference mPassphraseCacheSubs) {
        mPassphraseCacheSubs.setChecked(sPreferences.getPassphraseCacheSubs());
        mPassphraseCacheSubs.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                mPassphraseCacheSubs.setChecked((Boolean) newValue);
                sPreferences.setPassphraseCacheSubs((Boolean) newValue);
                return false;
            }
        });
    }

    private static void initializePassphraseCacheTtl(final IntegerListPreference mPassphraseCacheTtl) {
        mPassphraseCacheTtl.setValue("" + sPreferences.getPassphraseCacheTtl());
        mPassphraseCacheTtl.setSummary(mPassphraseCacheTtl.getEntry());
        mPassphraseCacheTtl
                .setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
                    public boolean onPreferenceChange(Preference preference, Object newValue) {
                        mPassphraseCacheTtl.setValue(newValue.toString());
                        mPassphraseCacheTtl.setSummary(mPassphraseCacheTtl.getEntry());
                        sPreferences.setPassphraseCacheTtl(Integer.parseInt(newValue.toString()));
                        return false;
                    }
                });
    }

    private static void initializeSearchKeyserver(final CheckBoxPreference mSearchKeyserver) {
        Preferences.CloudSearchPrefs prefs = sPreferences.getCloudSearchPrefs();
        mSearchKeyserver.setChecked(prefs.searchKeyserver);
        mSearchKeyserver.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            @Override
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                mSearchKeyserver.setChecked((Boolean) newValue);
                sPreferences.setSearchKeyserver((Boolean) newValue);
                return false;
            }
        });
    }

    private static void initializeSearchKeybase(final CheckBoxPreference mSearchKeybase) {
        Preferences.CloudSearchPrefs prefs = sPreferences.getCloudSearchPrefs();
        mSearchKeybase.setChecked(prefs.searchKeybase);
        mSearchKeybase.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            @Override
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                mSearchKeybase.setChecked((Boolean) newValue);
                sPreferences.setSearchKeybase((Boolean) newValue);
                return false;
            }
        });
    }

    public static String keyserverSummary(Context context) {
        String[] servers = sPreferences.getKeyServers();
        String serverSummary = context.getResources().getQuantityString(
                R.plurals.n_keyservers, servers.length, servers.length);
        return serverSummary + "; " + context.getString(R.string.label_preferred) + ": " + sPreferences
                .getPreferredKeyserver();
    }

    private static void initializeUseDefaultYubiKeyPin(final CheckBoxPreference mUseDefaultYubiKeyPin) {
        mUseDefaultYubiKeyPin.setChecked(sPreferences.useDefaultYubiKeyPin());
        mUseDefaultYubiKeyPin.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                mUseDefaultYubiKeyPin.setChecked((Boolean) newValue);
                sPreferences.setUseDefaultYubiKeyPin((Boolean) newValue);
                return false;
            }
        });
    }

    private static void initializeUseNumKeypadForYubiKeyPin(final CheckBoxPreference mUseNumKeypadForYubiKeyPin) {
        mUseNumKeypadForYubiKeyPin.setChecked(sPreferences.useNumKeypadForYubiKeyPin());
        mUseNumKeypadForYubiKeyPin.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                mUseNumKeypadForYubiKeyPin.setChecked((Boolean) newValue);
                sPreferences.setUseNumKeypadForYubiKeyPin((Boolean) newValue);
                return false;
            }
        });
    }
}

<code block>


package org.sufficientlysecure.keychain.ui;

import android.app.ProgressDialog;
import android.content.Intent;
import android.database.Cursor;
import android.graphics.Typeface;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Message;
import android.os.Messenger;
import android.support.v4.app.LoaderManager;
import android.support.v4.content.CursorLoader;
import android.support.v4.content.Loader;
import android.text.SpannableStringBuilder;
import android.text.Spanned;
import android.text.method.LinkMovementMethod;
import android.text.style.ClickableSpan;
import android.text.style.StyleSpan;
import android.text.style.URLSpan;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TableLayout;
import android.widget.TableRow;
import android.widget.TextView;

import com.textuality.keybase.lib.KeybaseException;
import com.textuality.keybase.lib.Proof;
import com.textuality.keybase.lib.User;

import org.sufficientlysecure.keychain.Constants;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.provider.KeychainContract.KeyRings;
import org.sufficientlysecure.keychain.service.KeychainService;
import org.sufficientlysecure.keychain.service.ServiceProgressHandler;
import org.sufficientlysecure.keychain.ui.util.KeyFormattingUtils;
import org.sufficientlysecure.keychain.util.Log;
import org.sufficientlysecure.keychain.util.ParcelableProxy;
import org.sufficientlysecure.keychain.util.Preferences;
import org.sufficientlysecure.keychain.util.orbot.OrbotHelper;

import java.util.ArrayList;
import java.util.Hashtable;
import java.util.List;

public class ViewKeyTrustFragment extends LoaderFragment implements
        LoaderManager.LoaderCallbacks<Cursor> {

    public static final String ARG_DATA_URI = "uri";

    private View mStartSearch;
    private TextView mTrustReadout;
    private TextView mReportHeader;
    private TableLayout mProofListing;
    private LayoutInflater mInflater;
    private View mProofVerifyHeader;
    private TextView mProofVerifyDetail;

    private static final int LOADER_ID_DATABASE = 1;

    
    private Uri mDataUri;

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup superContainer, Bundle savedInstanceState) {
        View root = super.onCreateView(inflater, superContainer, savedInstanceState);
        View view = inflater.inflate(R.layout.view_key_adv_keybase_fragment, getContainer());
        mInflater = inflater;

        mTrustReadout = (TextView) view.findViewById(R.id.view_key_trust_readout);
        mStartSearch = view.findViewById(R.id.view_key_trust_search_cloud);
        mStartSearch.setEnabled(false);
        mReportHeader = (TextView) view.findViewById(R.id.view_key_trust_cloud_narrative);
        mProofListing = (TableLayout) view.findViewById(R.id.view_key_proof_list);
        mProofVerifyHeader = view.findViewById(R.id.view_key_proof_verify_header);
        mProofVerifyDetail = (TextView) view.findViewById(R.id.view_key_proof_verify_detail);
        mReportHeader.setVisibility(View.GONE);
        mProofListing.setVisibility(View.GONE);
        mProofVerifyHeader.setVisibility(View.GONE);
        mProofVerifyDetail.setVisibility(View.GONE);

        return root;
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        Uri dataUri = getArguments().getParcelable(ARG_DATA_URI);
        if (dataUri == null) {
            Log.e(Constants.TAG, "Data missing. Should be Uri of key!");
            getActivity().finish();
            return;
        }
        mDataUri = dataUri;

        
        getLoaderManager().initLoader(LOADER_ID_DATABASE, null, this);
    }

    static final String[] TRUST_PROJECTION = new String[]{
            KeyRings._ID, KeyRings.FINGERPRINT, KeyRings.IS_REVOKED, KeyRings.IS_EXPIRED,
            KeyRings.HAS_ANY_SECRET, KeyRings.VERIFIED
    };
    static final int INDEX_TRUST_FINGERPRINT = 1;
    static final int INDEX_TRUST_IS_REVOKED = 2;
    static final int INDEX_TRUST_IS_EXPIRED = 3;
    static final int INDEX_UNIFIED_HAS_ANY_SECRET = 4;
    static final int INDEX_VERIFIED = 5;

    public Loader<Cursor> onCreateLoader(int id, Bundle args) {
        setContentShown(false);

        switch (id) {
            case LOADER_ID_DATABASE: {
                Uri baseUri = KeyRings.buildUnifiedKeyRingUri(mDataUri);
                return new CursorLoader(getActivity(), baseUri, TRUST_PROJECTION, null, null, null);
            }
            
            default:
                return null;
        }
    }

    public void onLoadFinished(Loader<Cursor> loader, Cursor data) {
        
        
        if (data.getCount() == 0) {
            return;
        }

        boolean nothingSpecial = true;
        StringBuilder message = new StringBuilder();

        
        
        if (data.moveToFirst()) {

            if (data.getInt(INDEX_UNIFIED_HAS_ANY_SECRET) != 0) {
                message.append(getString(R.string.key_trust_it_is_yours)).append("\n");
                nothingSpecial = false;
            } else if (data.getInt(INDEX_VERIFIED) != 0) {
                message.append(getString(R.string.key_trust_already_verified)).append("\n");
                nothingSpecial = false;
            }

            
            if (data.getInt(INDEX_TRUST_IS_REVOKED) != 0) {
                message.append(getString(R.string.key_trust_revoked)).
                        append(getString(R.string.key_trust_old_keys));

                nothingSpecial = false;
            } else {
                if (data.getInt(INDEX_TRUST_IS_EXPIRED) != 0) {

                    
                    message.append(getString(R.string.key_trust_expired)).
                            append(getString(R.string.key_trust_old_keys));

                    nothingSpecial = false;
                }
            }

            if (nothingSpecial) {
                message.append(getString(R.string.key_trust_maybe));
            }

            final byte[] fp = data.getBlob(INDEX_TRUST_FINGERPRINT);
            final String fingerprint = KeyFormattingUtils.convertFingerprintToHex(fp);
            if (fingerprint != null) {

                mStartSearch.setEnabled(true);
                mStartSearch.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View view) {
                        final Preferences.ProxyPrefs proxyPrefs = Preferences.getPreferences(getActivity())
                                .getProxyPrefs();

                        Runnable ignoreTor = new Runnable() {
                            @Override
                            public void run() {
                                mStartSearch.setEnabled(false);
                                new DescribeKey(proxyPrefs.parcelableProxy).execute(fingerprint);
                            }
                        };

                        if (OrbotHelper.isOrbotInRequiredState(R.string.orbot_ignore_tor, ignoreTor, proxyPrefs,
                                getActivity())) {
                            mStartSearch.setEnabled(false);
                            new DescribeKey(proxyPrefs.parcelableProxy).execute(fingerprint);
                        }
                    }
                });
            }
        }

        mTrustReadout.setText(message);
        setContentShown(true);
    }

    
    public void onLoaderReset(Loader<Cursor> loader) {
        
    }

    class ResultPage {
        String mHeader;
        final List<CharSequence> mProofs;

        public ResultPage(String header, List<CharSequence> proofs) {
            mHeader = header;
            mProofs = proofs;
        }
    }

    
    
    private class DescribeKey extends AsyncTask<String, Void, ResultPage> {
        ParcelableProxy mParcelableProxy;

        public DescribeKey(ParcelableProxy parcelableProxy) {
            mParcelableProxy = parcelableProxy;
        }

        @Override
        protected ResultPage doInBackground(String... args) {
            String fingerprint = args[0];

            final ArrayList<CharSequence> proofList = new ArrayList<CharSequence>();
            final Hashtable<Integer, ArrayList<Proof>> proofs = new Hashtable<Integer, ArrayList<Proof>>();
            try {
                User keybaseUser = User.findByFingerprint(fingerprint, mParcelableProxy.getProxy());
                for (Proof proof : keybaseUser.getProofs()) {
                    Integer proofType = proof.getType();
                    appendIfOK(proofs, proofType, proof);
                }

                
                for (Integer proofType : proofs.keySet()) {
                    Proof[] x = {};
                    Proof[] proofsFor = proofs.get(proofType).toArray(x);
                    if (proofsFor.length > 0) {
                        SpannableStringBuilder ssb = new SpannableStringBuilder();
                        ssb.append(getProofNarrative(proofType)).append(" ");

                        int i = 0;
                        while (i < proofsFor.length - 1) {
                            appendProofLinks(ssb, fingerprint, proofsFor[i]);
                            ssb.append(", ");
                            i++;
                        }
                        appendProofLinks(ssb, fingerprint, proofsFor[i]);
                        proofList.add(ssb);
                    }
                }

            } catch (KeybaseException ignored) {
            }

            return new ResultPage(getString(R.string.key_trust_results_prefix), proofList);
        }

        private SpannableStringBuilder appendProofLinks(SpannableStringBuilder ssb, final String fingerprint, final
        Proof proof) throws KeybaseException {
            int startAt = ssb.length();
            String handle = proof.getHandle();
            ssb.append(handle);
            ssb.setSpan(new URLSpan(proof.getServiceUrl()), startAt, startAt + handle.length(), Spanned
                    .SPAN_EXCLUSIVE_EXCLUSIVE);
            if (haveProofFor(proof.getType())) {
                ssb.append("\u00a0[");
                startAt = ssb.length();
                String verify = getString(R.string.keybase_verify);
                ssb.append(verify);
                ClickableSpan clicker = new ClickableSpan() {
                    @Override
                    public void onClick(View view) {
                        final Preferences.ProxyPrefs proxyPrefs = Preferences.getPreferences(getActivity())
                                .getProxyPrefs();

                        Runnable ignoreTor = new Runnable() {
                            @Override
                            public void run() {
                                mStartSearch.setEnabled(false);
                                verify(proof, fingerprint, new ParcelableProxy(null, -1, null));
                            }
                        };

                        if (OrbotHelper.isOrbotInRequiredState(R.string.orbot_ignore_tor, ignoreTor, proxyPrefs,
                                getActivity())) {
                            mStartSearch.setEnabled(false);
                            verify(proof, fingerprint, mParcelableProxy);
                        }
                    }
                };
                ssb.setSpan(clicker, startAt, startAt + verify.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
                ssb.append("]");
            }
            return ssb;
        }

        @Override
        protected void onPostExecute(ResultPage result) {
            super.onPostExecute(result);
            if (result.mProofs.isEmpty()) {
                result.mHeader = getActivity().getString(R.string.key_trust_no_cloud_evidence);
            }

            mStartSearch.setVisibility(View.GONE);
            mReportHeader.setVisibility(View.VISIBLE);
            mProofListing.setVisibility(View.VISIBLE);
            mReportHeader.setText(result.mHeader);

            int rowNumber = 1;
            for (CharSequence s : result.mProofs) {
                TableRow row = (TableRow) mInflater.inflate(R.layout.view_key_adv_keybase_proof, null);
                TextView number = (TextView) row.findViewById(R.id.proof_number);
                TextView text = (TextView) row.findViewById(R.id.proof_text);
                number.setText(Integer.toString(rowNumber++) + ". ");
                text.setText(s);
                text.setMovementMethod(LinkMovementMethod.getInstance());
                mProofListing.addView(row);
            }

            
        }
    }

    private String getProofNarrative(int proofType) {
        int stringIndex;
        switch (proofType) {
            case Proof.PROOF_TYPE_TWITTER:
                stringIndex = R.string.keybase_narrative_twitter;
                break;
            case Proof.PROOF_TYPE_GITHUB:
                stringIndex = R.string.keybase_narrative_github;
                break;
            case Proof.PROOF_TYPE_DNS:
                stringIndex = R.string.keybase_narrative_dns;
                break;
            case Proof.PROOF_TYPE_WEB_SITE:
                stringIndex = R.string.keybase_narrative_web_site;
                break;
            case Proof.PROOF_TYPE_HACKERNEWS:
                stringIndex = R.string.keybase_narrative_hackernews;
                break;
            case Proof.PROOF_TYPE_COINBASE:
                stringIndex = R.string.keybase_narrative_coinbase;
                break;
            case Proof.PROOF_TYPE_REDDIT:
                stringIndex = R.string.keybase_narrative_reddit;
                break;
            default:
                stringIndex = R.string.keybase_narrative_unknown;
        }
        return getActivity().getString(stringIndex);
    }

    private void appendIfOK(Hashtable<Integer, ArrayList<Proof>> table, Integer proofType, Proof proof) throws
            KeybaseException {
        ArrayList<Proof> list = table.get(proofType);
        if (list == null) {
            list = new ArrayList<Proof>();
            table.put(proofType, list);
        }
        list.add(proof);
    }

    
    private boolean haveProofFor(int proofType) {
        switch (proofType) {
            case Proof.PROOF_TYPE_TWITTER:
                return true;
            case Proof.PROOF_TYPE_GITHUB:
                return true;
            case Proof.PROOF_TYPE_DNS:
                return true;
            case Proof.PROOF_TYPE_WEB_SITE:
                return true;
            case Proof.PROOF_TYPE_HACKERNEWS:
                return true;
            case Proof.PROOF_TYPE_COINBASE:
                return true;
            case Proof.PROOF_TYPE_REDDIT:
                return true;
            default:
                return false;
        }
    }

    private void verify(final Proof proof, final String fingerprint, ParcelableProxy parcelableProxy) {
        Intent intent = new Intent(getActivity(), KeychainService.class);
        Bundle data = new Bundle();
        intent.setAction(KeychainService.ACTION_VERIFY_KEYBASE_PROOF);

        data.putString(KeychainService.KEYBASE_PROOF, proof.toString());
        data.putString(KeychainService.KEYBASE_REQUIRED_FINGERPRINT, fingerprint);

        data.putParcelable(KeychainService.EXTRA_PARCELABLE_PROXY, parcelableProxy);

        intent.putExtra(KeychainService.EXTRA_DATA, data);

        mProofVerifyDetail.setVisibility(View.GONE);

        
        ServiceProgressHandler handler = new ServiceProgressHandler(getActivity()) {
            @Override
            public void handleMessage(Message message) {
                
                super.handleMessage(message);

                if (message.arg1 == MessageStatus.OKAY.ordinal()) {
                    Bundle returnData = message.getData();
                    String msg = returnData.getString(ServiceProgressHandler.DATA_MESSAGE);
                    SpannableStringBuilder ssb = new SpannableStringBuilder();

                    if ((msg != null) && msg.equals("OK")) {

                        
                        String proofUrl = returnData.getString(ServiceProgressHandler.KEYBASE_PROOF_URL);
                        String presenceUrl = returnData.getString(ServiceProgressHandler.KEYBASE_PRESENCE_URL);
                        String presenceLabel = returnData.getString(ServiceProgressHandler.KEYBASE_PRESENCE_LABEL);

                        String proofLabel;
                        switch (proof.getType()) {
                            case Proof.PROOF_TYPE_TWITTER:
                                proofLabel = getString(R.string.keybase_twitter_proof);
                                break;
                            case Proof.PROOF_TYPE_DNS:
                                proofLabel = getString(R.string.keybase_dns_proof);
                                break;
                            case Proof.PROOF_TYPE_WEB_SITE:
                                proofLabel = getString(R.string.keybase_web_site_proof);
                                break;
                            case Proof.PROOF_TYPE_GITHUB:
                                proofLabel = getString(R.string.keybase_github_proof);
                                break;
                            case Proof.PROOF_TYPE_REDDIT:
                                proofLabel = getString(R.string.keybase_reddit_proof);
                                break;
                            default:
                                proofLabel = getString(R.string.keybase_a_post);
                                break;
                        }

                        ssb.append(getString(R.string.keybase_proof_succeeded));
                        StyleSpan bold = new StyleSpan(Typeface.BOLD);
                        ssb.setSpan(bold, 0, ssb.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
                        ssb.append("\n\n");
                        int length = ssb.length();
                        ssb.append(proofLabel);
                        if (proofUrl != null) {
                            URLSpan postLink = new URLSpan(proofUrl);
                            ssb.setSpan(postLink, length, length + proofLabel.length(), Spanned
                                    .SPAN_EXCLUSIVE_EXCLUSIVE);
                        }
                        if (Proof.PROOF_TYPE_DNS == proof.getType()) {
                            ssb.append(" ").append(getString(R.string.keybase_for_the_domain)).append(" ");
                        } else {
                            ssb.append(" ").append(getString(R.string.keybase_fetched_from)).append(" ");
                        }
                        length = ssb.length();
                        URLSpan presenceLink = new URLSpan(presenceUrl);
                        ssb.append(presenceLabel);
                        ssb.setSpan(presenceLink, length, length + presenceLabel.length(), Spanned
                                .SPAN_EXCLUSIVE_EXCLUSIVE);
                        if (Proof.PROOF_TYPE_REDDIT == proof.getType()) {
                            ssb.append(", ").
                                    append(getString(R.string.keybase_reddit_attribution)).
                                    append(" ").append(proof.getHandle()).append("?, ");
                        }
                        ssb.append(" ").append(getString(R.string.keybase_contained_signature));
                    } else {
                        
                        msg = returnData.getString(ServiceProgressHandler.DATA_ERROR);
                        ssb.append(getString(R.string.keybase_proof_failure));
                        if (msg == null) {
                            msg = getString(R.string.keybase_unknown_proof_failure);
                        }
                        StyleSpan bold = new StyleSpan(Typeface.BOLD);
                        ssb.setSpan(bold, 0, ssb.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
                        ssb.append("\n\n").append(msg);
                    }
                    mProofVerifyHeader.setVisibility(View.VISIBLE);
                    mProofVerifyDetail.setVisibility(View.VISIBLE);
                    mProofVerifyDetail.setMovementMethod(LinkMovementMethod.getInstance());
                    mProofVerifyDetail.setText(ssb);
                }
            }
        };

        
        Messenger messenger = new Messenger(handler);
        intent.putExtra(KeychainService.EXTRA_MESSENGER, messenger);

        
        handler.showProgressDialog(
                getString(R.string.progress_verifying_signature),
                ProgressDialog.STYLE_HORIZONTAL, false
        );

        
        getActivity().startService(intent);
    }
}

<code block>


package org.sufficientlysecure.keychain.ui;

import android.app.ProgressDialog;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.os.Message;
import android.os.Messenger;
import android.support.v4.app.NavUtils;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.ArrayAdapter;
import android.widget.Spinner;
import android.widget.Toast;

import org.sufficientlysecure.keychain.Constants;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.provider.KeychainContract;
import org.sufficientlysecure.keychain.provider.KeychainContract.KeyRings;
import org.sufficientlysecure.keychain.service.KeychainService;
import org.sufficientlysecure.keychain.ui.base.BaseActivity;
import org.sufficientlysecure.keychain.service.ServiceProgressHandler;
import org.sufficientlysecure.keychain.util.Log;
import org.sufficientlysecure.keychain.util.ParcelableProxy;
import org.sufficientlysecure.keychain.util.Preferences;
import org.sufficientlysecure.keychain.util.orbot.OrbotHelper;


public class UploadKeyActivity extends BaseActivity {
    private View mUploadButton;
    private Spinner mKeyServerSpinner;

    private Uri mDataUri;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        mUploadButton = findViewById(R.id.upload_key_action_upload);
        mKeyServerSpinner = (Spinner) findViewById(R.id.upload_key_keyserver);

        ArrayAdapter<String> adapter = new ArrayAdapter<>(this,
                android.R.layout.simple_spinner_item, Preferences.getPreferences(this)
                .getKeyServers()
        );
        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        mKeyServerSpinner.setAdapter(adapter);
        if (adapter.getCount() > 0) {
            mKeyServerSpinner.setSelection(0);
        } else {
            mUploadButton.setEnabled(false);
        }

        mUploadButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                final Preferences.ProxyPrefs proxyPrefs = Preferences.getPreferences(UploadKeyActivity.this)
                        .getProxyPrefs();
                Runnable ignoreTor = new Runnable() {
                    @Override
                    public void run() {
                        uploadKey(proxyPrefs.parcelableProxy);
                    }
                };

                if (OrbotHelper.isOrbotInRequiredState(R.string.orbot_ignore_tor, ignoreTor, proxyPrefs,
                        UploadKeyActivity.this)) {
                    uploadKey(proxyPrefs.parcelableProxy);
                }
            }
        });

        mDataUri = getIntent().getData();
        if (mDataUri == null) {
            Log.e(Constants.TAG, "Intent data missing. Should be Uri of key!");
            finish();
            return;
        }
    }

    @Override
    protected void initLayout() {
        setContentView(R.layout.upload_key_activity);
    }

    private void uploadKey(ParcelableProxy parcelableProxy) {
        
        Intent intent = new Intent(this, KeychainService.class);

        intent.setAction(KeychainService.ACTION_UPLOAD_KEYRING);

        
        Uri blobUri = KeyRings.buildUnifiedKeyRingUri(mDataUri);
        intent.setData(blobUri);

        
        Bundle data = new Bundle();

        String server = (String) mKeyServerSpinner.getSelectedItem();
        data.putString(KeychainService.UPLOAD_KEY_SERVER, server);

        intent.putExtra(KeychainService.EXTRA_DATA, data);
        intent.putExtra(KeychainService.EXTRA_PARCELABLE_PROXY, parcelableProxy);

        
        ServiceProgressHandler saveHandler = new ServiceProgressHandler(this) {
            @Override
            public void handleMessage(Message message) {
                
                super.handleMessage(message);

                if (message.arg1 == MessageStatus.OKAY.ordinal()) {

                    Toast.makeText(UploadKeyActivity.this, R.string.msg_crt_upload_success,
                            Toast.LENGTH_SHORT).show();
                    finish();
                }
            }
        };

        
        Messenger messenger = new Messenger(saveHandler);
        intent.putExtra(KeychainService.EXTRA_MESSENGER, messenger);

        
        saveHandler.showProgressDialog(
                getString(R.string.progress_uploading),
                ProgressDialog.STYLE_HORIZONTAL, false);

        
        startService(intent);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home: {
                Intent viewIntent = NavUtils.getParentActivityIntent(this);
                viewIntent.setData(KeychainContract.KeyRings.buildGenericKeyRingUri(mDataUri));
                NavUtils.navigateUpTo(this, viewIntent);
                return true;
            }
        }
        return super.onOptionsItemSelected(item);
    }
}

<code block>


package org.sufficientlysecure.keychain.ui;

import android.animation.ObjectAnimator;
import android.annotation.TargetApi;
import android.app.Activity;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.Intent;
import android.database.Cursor;
import android.graphics.Color;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.os.Messenger;
import android.support.v4.app.LoaderManager;
import android.support.v4.content.CursorLoader;
import android.support.v4.content.Loader;
import android.support.v4.view.MenuItemCompat;
import android.support.v7.widget.SearchView;
import android.view.ActionMode;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.AbsListView.MultiChoiceModeListener;
import android.widget.AdapterView;
import android.widget.ListView;
import android.widget.TextView;

import com.getbase.floatingactionbutton.FloatingActionButton;
import com.getbase.floatingactionbutton.FloatingActionsMenu;

import org.sufficientlysecure.keychain.Constants;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.keyimport.ParcelableKeyRing;
import org.sufficientlysecure.keychain.operations.results.ConsolidateResult;
import org.sufficientlysecure.keychain.operations.results.DeleteResult;
import org.sufficientlysecure.keychain.operations.results.ImportKeyResult;
import org.sufficientlysecure.keychain.operations.results.OperationResult;
import org.sufficientlysecure.keychain.provider.KeychainContract;
import org.sufficientlysecure.keychain.provider.KeychainContract.KeyRings;
import org.sufficientlysecure.keychain.provider.KeychainDatabase;
import org.sufficientlysecure.keychain.provider.ProviderHelper;
import org.sufficientlysecure.keychain.service.KeychainService;
import org.sufficientlysecure.keychain.service.ServiceProgressHandler;
import org.sufficientlysecure.keychain.service.PassphraseCacheService;
import org.sufficientlysecure.keychain.ui.dialog.DeleteKeyDialogFragment;
import org.sufficientlysecure.keychain.ui.util.KeyFormattingUtils;
import org.sufficientlysecure.keychain.ui.adapter.KeyAdapter;
import org.sufficientlysecure.keychain.ui.util.Notify;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;

import org.sufficientlysecure.keychain.util.ExportHelper;
import org.sufficientlysecure.keychain.util.FabContainer;
import org.sufficientlysecure.keychain.util.Log;
import org.sufficientlysecure.keychain.util.ParcelableProxy;
import org.sufficientlysecure.keychain.util.Preferences;
import org.sufficientlysecure.keychain.util.orbot.OrbotHelper;
import se.emilsjolander.stickylistheaders.StickyListHeadersAdapter;
import se.emilsjolander.stickylistheaders.StickyListHeadersListView;


public class KeyListFragment extends LoaderFragment
        implements SearchView.OnQueryTextListener, AdapterView.OnItemClickListener,
        LoaderManager.LoaderCallbacks<Cursor>, FabContainer {

    static final int REQUEST_REPEAT_PASSPHRASE = 1;
    static final int REQUEST_ACTION = 2;

    ExportHelper mExportHelper;

    private KeyListAdapter mAdapter;
    private StickyListHeadersListView mStickyList;

    
    private ActionMode mActionMode = null;

    private String mQuery;

    private FloatingActionsMenu mFab;

    
    private ArrayList<Long> mIdsForRepeatAskPassphrase;
    
    private int mIndex;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        mExportHelper = new ExportHelper(getActivity());
    }

    
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup superContainer, Bundle savedInstanceState) {
        View root = super.onCreateView(inflater, superContainer, savedInstanceState);
        View view = inflater.inflate(R.layout.key_list_fragment, getContainer());

        mStickyList = (StickyListHeadersListView) view.findViewById(R.id.key_list_list);
        mStickyList.setOnItemClickListener(this);

        mFab = (FloatingActionsMenu) view.findViewById(R.id.fab_main);

        FloatingActionButton fabQrCode = (FloatingActionButton) view.findViewById(R.id.fab_add_qr_code);
        FloatingActionButton fabCloud = (FloatingActionButton) view.findViewById(R.id.fab_add_cloud);
        FloatingActionButton fabFile = (FloatingActionButton) view.findViewById(R.id.fab_add_file);

        fabQrCode.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                mFab.collapse();
                scanQrCode();
            }
        });
        fabCloud.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                mFab.collapse();
                searchCloud();
            }
        });
        fabFile.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                mFab.collapse();
                importFile();
            }
        });


        return root;
    }

    
    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        
        getActivity().setTitle(R.string.app_name);

        mStickyList.setOnItemClickListener(this);
        mStickyList.setAreHeadersSticky(true);
        mStickyList.setDrawingListUnderStickyHeader(false);
        mStickyList.setFastScrollEnabled(true);

        
        
        View footer = new View(getActivity());

        int spacing = (int) android.util.TypedValue.applyDimension(
                android.util.TypedValue.COMPLEX_UNIT_DIP, 72, getResources().getDisplayMetrics()
        );

        android.widget.AbsListView.LayoutParams params = new android.widget.AbsListView.LayoutParams(
                android.widget.AbsListView.LayoutParams.MATCH_PARENT,
                spacing
        );

        footer.setLayoutParams(params);
        mStickyList.addFooterView(footer, null, false);

        
        mStickyList.setFastScrollAlwaysVisible(true);

        mStickyList.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE_MODAL);
        mStickyList.getWrappedList().setMultiChoiceModeListener(new MultiChoiceModeListener() {

            @Override
            public boolean onCreateActionMode(ActionMode mode, Menu menu) {
                android.view.MenuInflater inflater = getActivity().getMenuInflater();
                inflater.inflate(R.menu.key_list_multi, menu);
                mActionMode = mode;
                return true;
            }

            @Override
            public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
                return false;
            }

            @Override
            public boolean onActionItemClicked(ActionMode mode, MenuItem item) {

                
                long[] ids;

                switch (item.getItemId()) {
                    case R.id.menu_key_list_multi_encrypt: {
                        ids = mAdapter.getCurrentSelectedMasterKeyIds();
                        encrypt(mode, ids);
                        break;
                    }
                    case R.id.menu_key_list_multi_delete: {
                        ids = mAdapter.getCurrentSelectedMasterKeyIds();
                        showDeleteKeyDialog(mode, ids, mAdapter.isAnySecretSelected());
                        break;
                    }
                    case R.id.menu_key_list_multi_export: {
                        ids = mAdapter.getCurrentSelectedMasterKeyIds();
                        showMultiExportDialog(ids);
                        break;
                    }
                    case R.id.menu_key_list_multi_select_all: {
                        
                        for (int i = 0; i < mAdapter.getCount(); i++) {
                            mStickyList.setItemChecked(i, true);
                        }
                        break;
                    }
                }
                return true;
            }

            @Override
            public void onDestroyActionMode(ActionMode mode) {
                mActionMode = null;
                mAdapter.clearSelection();
            }

            @Override
            public void onItemCheckedStateChanged(ActionMode mode, int position, long id,
                                                  boolean checked) {
                if (checked) {
                    mAdapter.setNewSelection(position, true);
                } else {
                    mAdapter.removeSelection(position);
                }
                int count = mStickyList.getCheckedItemCount();
                String keysSelected = getResources().getQuantityString(
                        R.plurals.key_list_selected_keys, count, count);
                mode.setTitle(keysSelected);
            }

        });

        
        setHasOptionsMenu(true);

        
        setContentShown(false);

        
        mAdapter = new KeyListAdapter(getActivity(), null, 0);
        mStickyList.setAdapter(mAdapter);

        
        
        getLoaderManager().initLoader(0, null, this);
    }

    static final String ORDER =
            KeyRings.HAS_ANY_SECRET + " DESC, UPPER(" + KeyRings.USER_ID + ") ASC";


    @Override
    public Loader<Cursor> onCreateLoader(int id, Bundle args) {
        
        
        Uri baseUri = KeyRings.buildUnifiedKeyRingsUri();
        String where = null;
        String whereArgs[] = null;
        if (mQuery != null) {
            String[] words = mQuery.trim().split("\\s+");
            whereArgs = new String[words.length];
            for (int i = 0; i < words.length; ++i) {
                if (where == null) {
                    where = "";
                } else {
                    where += " AND ";
                }
                where += KeyRings.USER_ID + " LIKE ?";
                whereArgs[i] = "%" + words[i] + "%";
            }
        }

        
        
        return new CursorLoader(getActivity(), baseUri,
                KeyListAdapter.PROJECTION, where, whereArgs, ORDER);
    }

    @Override
    public void onLoadFinished(Loader<Cursor> loader, Cursor data) {
        
        
        mAdapter.setSearchQuery(mQuery);
        mAdapter.swapCursor(data);

        mStickyList.setAdapter(mAdapter);

        
        mStickyList.setEmptyView(getActivity().findViewById(R.id.key_list_empty));

        
        if (mActionMode != null) {
            mActionMode.finish();
        }

        
        if (isResumed()) {
            setContentShown(true);
        } else {
            setContentShownNoAnimation(true);
        }
    }

    @Override
    public void onLoaderReset(Loader<Cursor> loader) {
        
        
        
        mAdapter.swapCursor(null);
    }

    
    @Override
    public void onItemClick(AdapterView<?> adapterView, View view, int position, long id) {
        Intent viewIntent = new Intent(getActivity(), ViewKeyActivity.class);
        viewIntent.setData(
                KeyRings.buildGenericKeyRingUri(mAdapter.getMasterKeyId(position)));
        startActivity(viewIntent);
    }

    protected void encrypt(ActionMode mode, long[] masterKeyIds) {
        Intent intent = new Intent(getActivity(), EncryptFilesActivity.class);
        intent.setAction(EncryptFilesActivity.ACTION_ENCRYPT_DATA);
        intent.putExtra(EncryptFilesActivity.EXTRA_ENCRYPTION_KEY_IDS, masterKeyIds);
        
        startActivityForResult(intent, REQUEST_ACTION);

        mode.finish();
    }

    
    public void showDeleteKeyDialog(final ActionMode mode, long[] masterKeyIds, boolean hasSecret) {
        
        if (hasSecret && masterKeyIds.length > 1) {
            Notify.create(getActivity(), R.string.secret_cannot_multiple,
                    Notify.Style.ERROR).show();
            return;
        }

        
        Handler returnHandler = new Handler() {
            @Override
            public void handleMessage(Message message) {
                if (message.arg1 == DeleteKeyDialogFragment.MESSAGE_OKAY) {
                    Bundle data = message.getData();
                    if (data != null) {
                        DeleteResult result = data.getParcelable(DeleteResult.EXTRA_RESULT);
                        if (result != null) {
                            result.createNotify(getActivity()).show();
                        }
                    }
                    mode.finish();
                }
            }
        };

        
        Messenger messenger = new Messenger(returnHandler);

        DeleteKeyDialogFragment deleteKeyDialog = DeleteKeyDialogFragment.newInstance(messenger,
                masterKeyIds);

        deleteKeyDialog.show(getActivity().getSupportFragmentManager(), "deleteKeyDialog");
    }


    @Override
    public void onCreateOptionsMenu(final Menu menu, final MenuInflater inflater) {
        inflater.inflate(R.menu.key_list, menu);

        if (Constants.DEBUG) {
            menu.findItem(R.id.menu_key_list_debug_cons).setVisible(true);
            menu.findItem(R.id.menu_key_list_debug_read).setVisible(true);
            menu.findItem(R.id.menu_key_list_debug_write).setVisible(true);
            menu.findItem(R.id.menu_key_list_debug_first_time).setVisible(true);
        }

        
        MenuItem searchItem = menu.findItem(R.id.menu_key_list_search);

        SearchView searchView = (SearchView) MenuItemCompat.getActionView(searchItem);

        
        searchView.setOnQueryTextListener(this);

        
        MenuItemCompat.setOnActionExpandListener(searchItem, new MenuItemCompat.OnActionExpandListener() {
            @Override
            public boolean onMenuItemActionExpand(MenuItem item) {

                
                
                return true;
            }

            @Override
            public boolean onMenuItemActionCollapse(MenuItem item) {
                mQuery = null;
                getLoaderManager().restartLoader(0, null, KeyListFragment.this);

                
                
                return true;
            }
        });

        super.onCreateOptionsMenu(menu, inflater);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {

            case R.id.menu_key_list_create:
                createKey();
                return true;

            case R.id.menu_key_list_export:
                mExportHelper.showExportKeysDialog(null, Constants.Path.APP_DIR_FILE, true);
                return true;

            case R.id.menu_key_list_update_all_keys:
                final Preferences.ProxyPrefs proxyPrefs = Preferences.getPreferences(getActivity())
                        .getProxyPrefs();
                Runnable ignoreTor = new Runnable() {
                    @Override
                    public void run() {
                        updateAllKeys(new ParcelableProxy(null, -1, null));
                    }
                };

                if (OrbotHelper.isOrbotInRequiredState(R.string.orbot_ignore_tor, ignoreTor, proxyPrefs,
                        getActivity())) {
                    updateAllKeys(proxyPrefs.parcelableProxy);
                }
                return true;

            case R.id.menu_key_list_debug_cons:
                consolidate();
                return true;

            case R.id.menu_key_list_debug_read:
                try {
                    KeychainDatabase.debugBackup(getActivity(), true);
                    Notify.create(getActivity(), "Restored debug_backup.db", Notify.Style.OK).show();
                    getActivity().getContentResolver().notifyChange(KeychainContract.KeyRings.CONTENT_URI, null);
                } catch (IOException e) {
                    Log.e(Constants.TAG, "IO Error", e);
                    Notify.create(getActivity(), "IO Error " + e.getMessage(), Notify.Style.ERROR).show();
                }
                return true;

            case R.id.menu_key_list_debug_write:
                try {
                    KeychainDatabase.debugBackup(getActivity(), false);
                    Notify.create(getActivity(), "Backup to debug_backup.db completed", Notify.Style.OK).show();
                } catch (IOException e) {
                    Log.e(Constants.TAG, "IO Error", e);
                    Notify.create(getActivity(), "IO Error: " + e.getMessage(), Notify.Style.ERROR).show();
                }
                return true;

            case R.id.menu_key_list_debug_first_time:
                Preferences prefs = Preferences.getPreferences(getActivity());
                prefs.setFirstTime(true);
                Intent intent = new Intent(getActivity(), CreateKeyActivity.class);
                intent.putExtra(CreateKeyActivity.EXTRA_FIRST_TIME, true);
                startActivity(intent);
                getActivity().finish();
                return true;

            default:
                return super.onOptionsItemSelected(item);
        }
    }

    @Override
    public boolean onQueryTextSubmit(String s) {
        return true;
    }

    @Override
    public boolean onQueryTextChange(String s) {
        Log.d(Constants.TAG, "onQueryTextChange s:" + s);
        
        
        
        
        
        
        String tmp = (mQuery == null) ? "" : mQuery;
        if (!s.equals(tmp)) {
            mQuery = s;
            getLoaderManager().restartLoader(0, null, this);
        }
        return true;
    }

    private void searchCloud() {
        Intent importIntent = new Intent(getActivity(), ImportKeysActivity.class);
        importIntent.putExtra(ImportKeysActivity.EXTRA_QUERY, (String) null); 
        startActivity(importIntent);
    }

    private void scanQrCode() {
        Intent scanQrCode = new Intent(getActivity(), ImportKeysProxyActivity.class);
        scanQrCode.setAction(ImportKeysProxyActivity.ACTION_SCAN_IMPORT);
        startActivityForResult(scanQrCode, REQUEST_ACTION);
    }

    private void importFile() {
        Intent intentImportExisting = new Intent(getActivity(), ImportKeysActivity.class);
        intentImportExisting.setAction(ImportKeysActivity.ACTION_IMPORT_KEY_FROM_FILE_AND_RETURN);
        startActivityForResult(intentImportExisting, REQUEST_ACTION);
    }

    private void createKey() {
        Intent intent = new Intent(getActivity(), CreateKeyActivity.class);
        startActivityForResult(intent, REQUEST_ACTION);
    }

    private void updateAllKeys(ParcelableProxy parcelableProxy) {
        Context context = getActivity();

        ProviderHelper providerHelper = new ProviderHelper(context);

        Cursor cursor = providerHelper.getContentResolver().query(
                KeyRings.buildUnifiedKeyRingsUri(), new String[]{
                        KeyRings.FINGERPRINT
                }, null, null, null
        );

        ArrayList<ParcelableKeyRing> keyList = new ArrayList<>();

        while (cursor.moveToNext()) {
            byte[] blob = cursor.getBlob(0);
            String fingerprint = KeyFormattingUtils.convertFingerprintToHex(blob);
            ParcelableKeyRing keyEntry = new ParcelableKeyRing(fingerprint, null, null);
            keyList.add(keyEntry);
        }

        ServiceProgressHandler serviceHandler = new ServiceProgressHandler(getActivity()) {
            @Override
            public void handleMessage(Message message) {
                
                super.handleMessage(message);

                if (message.arg1 == MessageStatus.OKAY.ordinal()) {
                    
                    Bundle returnData = message.getData();
                    if (returnData == null) {
                        return;
                    }
                    final ImportKeyResult result =
                            returnData.getParcelable(OperationResult.EXTRA_RESULT);
                    if (result == null) {
                        Log.e(Constants.TAG, "result == null");
                        return;
                    }

                    result.createNotify(getActivity()).show();
                }
            }
        };

        
        Intent intent = new Intent(getActivity(), KeychainService.class);
        intent.setAction(KeychainService.ACTION_IMPORT_KEYRING);

        
        Bundle data = new Bundle();

        
        {
            Preferences prefs = Preferences.getPreferences(getActivity());
            Preferences.CloudSearchPrefs cloudPrefs =
                    new Preferences.CloudSearchPrefs(true, true, prefs.getPreferredKeyserver());
            data.putString(KeychainService.IMPORT_KEY_SERVER, cloudPrefs.keyserver);
        }

        data.putParcelableArrayList(KeychainService.IMPORT_KEY_LIST, keyList);

        data.putParcelable(KeychainService.EXTRA_PARCELABLE_PROXY, parcelableProxy);

        intent.putExtra(KeychainService.EXTRA_DATA, data);

        
        Messenger messenger = new Messenger(serviceHandler);
        intent.putExtra(KeychainService.EXTRA_MESSENGER, messenger);

        
        serviceHandler.showProgressDialog(
                getString(R.string.progress_updating),
                ProgressDialog.STYLE_HORIZONTAL, true);

        
        getActivity().startService(intent);
    }

    private void consolidate() {
        
        ServiceProgressHandler saveHandler = new ServiceProgressHandler(getActivity()) {
            @Override
            public void handleMessage(Message message) {
                
                super.handleMessage(message);

                if (message.arg1 == MessageStatus.OKAY.ordinal()) {
                    
                    Bundle returnData = message.getData();
                    if (returnData == null) {
                        return;
                    }
                    final ConsolidateResult result =
                            returnData.getParcelable(OperationResult.EXTRA_RESULT);
                    if (result == null) {
                        return;
                    }

                    result.createNotify(getActivity()).show();
                }
            }
        };

        
        Intent intent = new Intent(getActivity(), KeychainService.class);

        intent.setAction(KeychainService.ACTION_CONSOLIDATE);

        
        Bundle data = new Bundle();

        intent.putExtra(KeychainService.EXTRA_DATA, data);

        
        Messenger messenger = new Messenger(saveHandler);
        intent.putExtra(KeychainService.EXTRA_MESSENGER, messenger);

        
        saveHandler.showProgressDialog(
                getString(R.string.progress_importing),
                ProgressDialog.STYLE_HORIZONTAL, false);

        
        getActivity().startService(intent);
    }

    private void showMultiExportDialog(long[] masterKeyIds) {
        mIdsForRepeatAskPassphrase = new ArrayList<>();
        for (long id : masterKeyIds) {
            try {
                if (PassphraseCacheService.getCachedPassphrase(
                        getActivity(), id, id) == null) {
                    mIdsForRepeatAskPassphrase.add(id);
                }
            } catch (PassphraseCacheService.KeyNotFoundException e) {
                
                
            }
        }
        mIndex = 0;
        if (mIdsForRepeatAskPassphrase.size() != 0) {
            startPassphraseActivity();
            return;
        }
        long[] idsForMultiExport = new long[mIdsForRepeatAskPassphrase.size()];
        for (int i = 0; i < mIdsForRepeatAskPassphrase.size(); ++i) {
            idsForMultiExport[i] = mIdsForRepeatAskPassphrase.get(i);
        }
        mExportHelper.showExportKeysDialog(idsForMultiExport,
                Constants.Path.APP_DIR_FILE,
                mAdapter.isAnySecretSelected());
    }

    private void startPassphraseActivity() {
        Intent intent = new Intent(getActivity(), PassphraseDialogActivity.class);
        long masterKeyId = mIdsForRepeatAskPassphrase.get(mIndex++);
        intent.putExtra(PassphraseDialogActivity.EXTRA_SUBKEY_ID, masterKeyId);
        startActivityForResult(intent, REQUEST_REPEAT_PASSPHRASE);
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (requestCode == REQUEST_REPEAT_PASSPHRASE) {
            if (resultCode != Activity.RESULT_OK) {
                return;
            }
            if (mIndex < mIdsForRepeatAskPassphrase.size()) {
                startPassphraseActivity();
                return;
            }
            long[] idsForMultiExport = new long[mIdsForRepeatAskPassphrase.size()];
            for (int i = 0; i < mIdsForRepeatAskPassphrase.size(); ++i) {
                idsForMultiExport[i] = mIdsForRepeatAskPassphrase.get(i);
            }
            mExportHelper.showExportKeysDialog(idsForMultiExport,
                    Constants.Path.APP_DIR_FILE,
                    mAdapter.isAnySecretSelected());
        }

        if (requestCode == REQUEST_ACTION) {
            
            if (data != null && data.hasExtra(OperationResult.EXTRA_RESULT)) {
                OperationResult result = data.getParcelableExtra(OperationResult.EXTRA_RESULT);
                result.createNotify(getActivity()).show();
            } else {
                super.onActivityResult(requestCode, resultCode, data);
            }
        }
    }

    @Override
    public void fabMoveUp(int height) {
        ObjectAnimator anim = ObjectAnimator.ofFloat(mFab, "translationY", 0, -height);
        
        anim.setDuration(270);
        anim.start();
    }

    @Override
    public void fabRestorePosition() {
        ObjectAnimator anim = ObjectAnimator.ofFloat(mFab, "translationY", 0);
        
        anim.setStartDelay(70);
        anim.setDuration(300);
        anim.start();
    }

    public class KeyListAdapter extends KeyAdapter implements StickyListHeadersAdapter {

        private HashMap<Integer, Boolean> mSelection = new HashMap<>();

        public KeyListAdapter(Context context, Cursor c, int flags) {
            super(context, c, flags);
        }

        @Override
        public View newView(Context context, Cursor cursor, ViewGroup parent) {
            View view = super.newView(context, cursor, parent);

            final KeyItemViewHolder holder = (KeyItemViewHolder) view.getTag();

            holder.mSlinger.setVisibility(View.VISIBLE);
            holder.mSlingerButton.setOnClickListener(new OnClickListener() {
                @Override
                public void onClick(View v) {
                    if (holder.mMasterKeyId != null) {
                        Intent safeSlingerIntent = new Intent(mContext, SafeSlingerActivity.class);
                        safeSlingerIntent.putExtra(SafeSlingerActivity.EXTRA_MASTER_KEY_ID, holder.mMasterKeyId);
                        startActivityForResult(safeSlingerIntent, REQUEST_ACTION);
                    }
                }
            });

            return view;
        }

        @Override
        public View getView(int position, View convertView, ViewGroup parent) {
            
            View v = super.getView(position, convertView, parent);

            if (mSelection.get(position) != null) {
                
                v.setBackgroundColor(parent.getResources().getColor(R.color.emphasis));
            } else {
                
                v.setBackgroundColor(Color.TRANSPARENT);
            }

            return v;
        }

        private class HeaderViewHolder {
            TextView mText;
            TextView mCount;
        }

        
        @Override
        public View getHeaderView(int position, View convertView, ViewGroup parent) {
            HeaderViewHolder holder;
            if (convertView == null) {
                holder = new HeaderViewHolder();
                convertView = mInflater.inflate(R.layout.key_list_header, parent, false);
                holder.mText = (TextView) convertView.findViewById(R.id.stickylist_header_text);
                holder.mCount = (TextView) convertView.findViewById(R.id.contacts_num);
                convertView.setTag(holder);
            } else {
                holder = (HeaderViewHolder) convertView.getTag();
            }

            if (!mDataValid) {
                
                Log.d(Constants.TAG, "getHeaderView: No data available at this point!");
                return convertView;
            }

            if (!mCursor.moveToPosition(position)) {
                throw new IllegalStateException("couldn't move cursor to position " + position);
            }

            if (mCursor.getInt(INDEX_HAS_ANY_SECRET) != 0) {
                { 
                    int num = mCursor.getCount();
                    String contactsTotal = mContext.getResources().getQuantityString(R.plurals.n_keys, num, num);
                    holder.mCount.setText(contactsTotal);
                    holder.mCount.setVisibility(View.VISIBLE);
                }

                holder.mText.setText(convertView.getResources().getString(R.string.my_keys));
                return convertView;
            }

            
            String userId = mCursor.getString(INDEX_USER_ID);
            String headerText = convertView.getResources().getString(R.string.user_id_no_name);
            if (userId != null && userId.length() > 0) {
                headerText = "" + userId.charAt(0);
            }
            holder.mText.setText(headerText);
            holder.mCount.setVisibility(View.GONE);
            return convertView;
        }

        
        @Override
        public long getHeaderId(int position) {
            if (!mDataValid) {
                
                Log.d(Constants.TAG, "getHeaderView: No data available at this point!");
                return -1;
            }

            if (!mCursor.moveToPosition(position)) {
                throw new IllegalStateException("couldn't move cursor to position " + position);
            }

            
            if (mCursor.getInt(INDEX_HAS_ANY_SECRET) != 0) {
                return 1L;
            }
            
            String userId = mCursor.getString(INDEX_USER_ID);
            if (userId != null && userId.length() > 0) {
                return Character.toUpperCase(userId.charAt(0));
            } else {
                return Long.MAX_VALUE;
            }
        }

        
        public void setNewSelection(int position, boolean value) {
            mSelection.put(position, value);
            notifyDataSetChanged();
        }

        public boolean isAnySecretSelected() {
            for (int pos : mSelection.keySet()) {
                if (isSecretAvailable(pos))
                    return true;
            }
            return false;
        }

        public long[] getCurrentSelectedMasterKeyIds() {
            long[] ids = new long[mSelection.size()];
            int i = 0;
            
            for (int pos : mSelection.keySet()) {
                ids[i++] = getMasterKeyId(pos);
            }
            return ids;
        }

        public void removeSelection(int position) {
            mSelection.remove(position);
            notifyDataSetChanged();
        }

        public void clearSelection() {
            mSelection.clear();
            notifyDataSetChanged();
        }

    }

}

<code block>


package org.sufficientlysecure.keychain.ui;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.ArrayList;

import android.app.Activity;
import android.app.ProgressDialog;
import android.content.Intent;
import android.os.Bundle;
import android.os.Message;
import android.os.Messenger;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.TextView;

import org.spongycastle.util.encoders.Hex;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.keyimport.ParcelableKeyRing;
import org.sufficientlysecure.keychain.operations.results.DecryptVerifyResult;
import org.sufficientlysecure.keychain.operations.results.ImportKeyResult;
import org.sufficientlysecure.keychain.provider.KeychainContract.KeyRings;
import org.sufficientlysecure.keychain.service.KeychainService;
import org.sufficientlysecure.keychain.service.ServiceProgressHandler;
import org.sufficientlysecure.keychain.ui.CreateKeyActivity.FragAction;
import org.sufficientlysecure.keychain.ui.CreateKeyActivity.NfcListenerFragment;
import org.sufficientlysecure.keychain.ui.util.KeyFormattingUtils;
import org.sufficientlysecure.keychain.util.ParcelableProxy;
import org.sufficientlysecure.keychain.util.Preferences;
import org.sufficientlysecure.keychain.util.orbot.OrbotHelper;


public class CreateKeyYubiKeyImportFragment extends Fragment implements NfcListenerFragment {

    private static final String ARG_FINGERPRINT = "fingerprint";
    public static final String ARG_AID = "aid";
    public static final String ARG_USER_ID = "user_ids";

    CreateKeyActivity mCreateKeyActivity;

    private byte[] mNfcFingerprints;
    private byte[] mNfcAid;
    private String mNfcUserId;
    private String mNfcFingerprint;
    private ImportKeysListFragment mListFragment;
    private TextView vSerNo;
    private TextView vUserId;

    public static Fragment createInstance(byte[] scannedFingerprints, byte[] nfcAid, String userId) {

        CreateKeyYubiKeyImportFragment frag = new CreateKeyYubiKeyImportFragment();

        Bundle args = new Bundle();
        args.putByteArray(ARG_FINGERPRINT, scannedFingerprints);
        args.putByteArray(ARG_AID, nfcAid);
        args.putString(ARG_USER_ID, userId);
        frag.setArguments(args);

        return frag;
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        Bundle args = savedInstanceState != null ? savedInstanceState : getArguments();

        mNfcFingerprints = args.getByteArray(ARG_FINGERPRINT);
        mNfcAid = args.getByteArray(ARG_AID);
        mNfcUserId = args.getString(ARG_USER_ID);

        byte[] fp = new byte[20];
        ByteBuffer.wrap(fp).put(mNfcFingerprints, 0, 20);
        mNfcFingerprint = KeyFormattingUtils.convertFingerprintToHex(fp);

    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.create_yubikey_import_fragment, container, false);

        vSerNo = (TextView) view.findViewById(R.id.yubikey_serno);
        vUserId = (TextView) view.findViewById(R.id.yubikey_userid);

        {
            View mBackButton = view.findViewById(R.id.create_key_back_button);
            mBackButton.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    if (getFragmentManager().getBackStackEntryCount() == 0) {
                        getActivity().setResult(Activity.RESULT_CANCELED);
                        getActivity().finish();
                    } else {
                        mCreateKeyActivity.loadFragment(null, FragAction.TO_LEFT);
                    }
                }
            });

            View mNextButton = view.findViewById(R.id.create_key_next_button);
            mNextButton.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {

                    final Preferences.ProxyPrefs proxyPrefs = Preferences.getPreferences(getActivity()).getProxyPrefs();
                    Runnable ignoreTor = new Runnable() {
                        @Override
                        public void run() {
                            importKey(new ParcelableProxy(null, -1, null));
                        }
                    };

                    if (OrbotHelper.isOrbotInRequiredState(R.string.orbot_ignore_tor, ignoreTor, proxyPrefs,
                            getActivity())) {
                        importKey(proxyPrefs.parcelableProxy);
                    }
                }
            });
        }

        mListFragment = ImportKeysListFragment.newInstance(null, null,
                "0x" + mNfcFingerprint, true, null);

        view.findViewById(R.id.button_search).setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                final Preferences.ProxyPrefs proxyPrefs = Preferences.getPreferences(getActivity()).getProxyPrefs();
                Runnable ignoreTor = new Runnable() {
                    @Override
                    public void run() {
                        refreshSearch(new ParcelableProxy(null, -1, null));
                    }
                };

                if (OrbotHelper.isOrbotInRequiredState(R.string.orbot_ignore_tor, ignoreTor, proxyPrefs,
                        getActivity())) {
                    refreshSearch(proxyPrefs.parcelableProxy);
                }
            }
        });

        setData();

        getFragmentManager().beginTransaction()
                .replace(R.id.yubikey_import_fragment, mListFragment, "yubikey_import")
                .commit();

        return view;
    }

    @Override
    public void onSaveInstanceState(Bundle args) {
        super.onSaveInstanceState(args);

        args.putByteArray(ARG_FINGERPRINT, mNfcFingerprints);
        args.putByteArray(ARG_AID, mNfcAid);
        args.putString(ARG_USER_ID, mNfcUserId);
    }

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);
        mCreateKeyActivity = (CreateKeyActivity) getActivity();
    }

    public void setData() {
        String serno = Hex.toHexString(mNfcAid, 10, 4);
        vSerNo.setText(getString(R.string.yubikey_serno, serno));

        if (!mNfcUserId.isEmpty()) {
            vUserId.setText(getString(R.string.yubikey_key_holder, mNfcUserId));
        } else {
            vUserId.setText(getString(R.string.yubikey_key_holder_not_set));
        }
    }

    public void refreshSearch(ParcelableProxy parcelableProxy) {
        
        mListFragment.loadNew(new ImportKeysListFragment.CloudLoaderState("0x" + mNfcFingerprint,
                Preferences.getPreferences(getActivity()).getCloudSearchPrefs()), parcelableProxy);
    }

    public void importKey(ParcelableProxy parcelableProxy) {

        
        ServiceProgressHandler saveHandler = new ServiceProgressHandler(getActivity()) {
            @Override
            public void handleMessage(Message message) {
                
                super.handleMessage(message);

                if (message.arg1 == MessageStatus.OKAY.ordinal()) {
                    
                    Bundle returnData = message.getData();

                    ImportKeyResult result =
                            returnData.getParcelable(DecryptVerifyResult.EXTRA_RESULT);

                    long[] masterKeyIds = result.getImportedMasterKeyIds();

                    

                    if (!result.success() || masterKeyIds.length == 0) {
                        result.createNotify(getActivity()).show();
                        return;
                    }

                    Intent intent = new Intent(getActivity(), ViewKeyActivity.class);
                    
                    
                    intent.setData(KeyRings.buildGenericKeyRingUri(masterKeyIds[0]));
                    intent.putExtra(ViewKeyActivity.EXTRA_DISPLAY_RESULT, result);
                    intent.putExtra(ViewKeyActivity.EXTRA_NFC_AID, mNfcAid);
                    intent.putExtra(ViewKeyActivity.EXTRA_NFC_USER_ID, mNfcUserId);
                    intent.putExtra(ViewKeyActivity.EXTRA_NFC_FINGERPRINTS, mNfcFingerprints);
                    startActivity(intent);
                    getActivity().finish();

                }

            }
        };

        
        Intent intent = new Intent(getActivity(), KeychainService.class);

        
        Bundle data = new Bundle();

        intent.setAction(KeychainService.ACTION_IMPORT_KEYRING);

        ArrayList<ParcelableKeyRing> keyList = new ArrayList<>();
        keyList.add(new ParcelableKeyRing(mNfcFingerprint, null, null));
        data.putParcelableArrayList(KeychainService.IMPORT_KEY_LIST, keyList);

        {
            Preferences prefs = Preferences.getPreferences(getActivity());
            Preferences.CloudSearchPrefs cloudPrefs =
                    new Preferences.CloudSearchPrefs(true, true, prefs.getPreferredKeyserver());
            data.putString(KeychainService.IMPORT_KEY_SERVER, cloudPrefs.keyserver);
        }

        data.putParcelable(KeychainService.EXTRA_PARCELABLE_PROXY, parcelableProxy);

        intent.putExtra(KeychainService.EXTRA_DATA, data);

        
        Messenger messenger = new Messenger(saveHandler);
        intent.putExtra(KeychainService.EXTRA_MESSENGER, messenger);

        saveHandler.showProgressDialog(
                getString(R.string.progress_importing),
                ProgressDialog.STYLE_HORIZONTAL, false
        );

        
        getActivity().startService(intent);

    }

    @Override
    public void onNfcPerform() throws IOException {

        mNfcFingerprints = mCreateKeyActivity.nfcGetFingerprints();
        mNfcAid = mCreateKeyActivity.nfcGetAid();
        mNfcUserId = mCreateKeyActivity.nfcGetUserId();

        byte[] fp = new byte[20];
        ByteBuffer.wrap(fp).put(mNfcFingerprints, 0, 20);
        mNfcFingerprint = KeyFormattingUtils.convertFingerprintToHex(fp);

        setData();

        Preferences.ProxyPrefs proxyPrefs = Preferences.getPreferences(getActivity()).getProxyPrefs();
        Runnable ignoreTor = new Runnable() {
            @Override
            public void run() {
                refreshSearch(new ParcelableProxy(null, -1, null));
            }
        };

        if (OrbotHelper.isOrbotInRequiredState(R.string.orbot_ignore_tor, ignoreTor, proxyPrefs,
                getActivity())) {
            refreshSearch(proxyPrefs.parcelableProxy);
        }

    }
}

<code block>


package org.sufficientlysecure.keychain.ui.dialog;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Message;
import android.os.Messenger;
import android.os.RemoteException;
import android.support.v4.app.DialogFragment;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.View;
import android.view.inputmethod.EditorInfo;
import android.view.inputmethod.InputMethodManager;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.TextView;
import android.widget.TextView.OnEditorActionListener;

import com.squareup.okhttp.OkHttpClient;
import com.squareup.okhttp.Request;
import org.sufficientlysecure.keychain.Constants;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.keyimport.HkpKeyserver;
import org.sufficientlysecure.keychain.util.Log;
import org.sufficientlysecure.keychain.util.Preferences;
import org.sufficientlysecure.keychain.util.TlsHelper;
import org.sufficientlysecure.keychain.util.orbot.OrbotHelper;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.Proxy;
import java.net.URI;
import java.net.URISyntaxException;

public class AddKeyserverDialogFragment extends DialogFragment implements OnEditorActionListener {
    private static final String ARG_MESSENGER = "messenger";

    public static final int MESSAGE_OKAY = 1;
    public static final int MESSAGE_VERIFICATION_FAILED = 2;

    public static final String MESSAGE_KEYSERVER = "new_keyserver";
    public static final String MESSAGE_VERIFIED = "verified";
    public static final String MESSAGE_FAILURE_REASON = "failure_reason";

    private Messenger mMessenger;
    private EditText mKeyserverEditText;
    private CheckBox mVerifyKeyserverCheckBox;

    public static enum FailureReason {
        INVALID_URL,
        CONNECTION_FAILED
    }

    ;

    
    public static AddKeyserverDialogFragment newInstance(Messenger messenger) {
        AddKeyserverDialogFragment frag = new AddKeyserverDialogFragment();
        Bundle args = new Bundle();
        args.putParcelable(ARG_MESSENGER, messenger);

        frag.setArguments(args);

        return frag;
    }

    
    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
        final Activity activity = getActivity();

        mMessenger = getArguments().getParcelable(ARG_MESSENGER);

        CustomAlertDialogBuilder alert = new CustomAlertDialogBuilder(activity);

        alert.setTitle(R.string.add_keyserver_dialog_title);

        LayoutInflater inflater = activity.getLayoutInflater();
        View view = inflater.inflate(R.layout.add_keyserver_dialog, null);
        alert.setView(view);

        mKeyserverEditText = (EditText) view.findViewById(R.id.keyserver_url_edit_text);
        mVerifyKeyserverCheckBox = (CheckBox) view.findViewById(R.id.verify_keyserver_checkbox);

        
        
        alert.setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int id) {
                
                
                
            }
        });

        alert.setNegativeButton(android.R.string.cancel, new DialogInterface.OnClickListener() {

            @Override
            public void onClick(DialogInterface dialog, int id) {
                dismiss();
            }
        });

        
        
        
        
        
        mKeyserverEditText.setOnFocusChangeListener(new View.OnFocusChangeListener() {
            @Override
            public void onFocusChange(View v, boolean hasFocus) {
                mKeyserverEditText.post(new Runnable() {
                    @Override
                    public void run() {
                        InputMethodManager imm = (InputMethodManager) getActivity()
                                .getSystemService(Context.INPUT_METHOD_SERVICE);
                        imm.showSoftInput(mKeyserverEditText, InputMethodManager.SHOW_IMPLICIT);
                    }
                });
            }
        });
        mKeyserverEditText.requestFocus();

        mKeyserverEditText.setImeActionLabel(getString(android.R.string.ok),
                EditorInfo.IME_ACTION_DONE);
        mKeyserverEditText.setOnEditorActionListener(this);

        return alert.show();
    }

    @Override
    public void onStart() {
        super.onStart();
        AlertDialog addKeyserverDialog = (AlertDialog) getDialog();
        if (addKeyserverDialog != null) {
            Button positiveButton = addKeyserverDialog.getButton(Dialog.BUTTON_POSITIVE);
            positiveButton.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    final String keyserverUrl = mKeyserverEditText.getText().toString();
                    if (mVerifyKeyserverCheckBox.isChecked()) {
                        final Preferences.ProxyPrefs proxyPrefs = Preferences.getPreferences(getActivity())
                                .getProxyPrefs();
                        Runnable ignoreTor = new Runnable() {
                            @Override
                            public void run() {
                                verifyConnection(keyserverUrl, null);
                            }
                        };

                        if (OrbotHelper.isOrbotInRequiredState(R.string.orbot_ignore_tor, ignoreTor, proxyPrefs,
                                getActivity())) {
                            verifyConnection(keyserverUrl, proxyPrefs.parcelableProxy.getProxy());
                        }
                    } else {
                        dismiss();
                        
                        addKeyserver(keyserverUrl, false);
                    }
                }
            });
        }
    }

    public void addKeyserver(String keyserver, boolean verified) {
        dismiss();
        Bundle data = new Bundle();
        data.putString(MESSAGE_KEYSERVER, keyserver);
        data.putBoolean(MESSAGE_VERIFIED, verified);

        sendMessageToHandler(MESSAGE_OKAY, data);
    }

    public void verificationFailed(FailureReason reason) {
        Bundle data = new Bundle();
        data.putSerializable(MESSAGE_FAILURE_REASON, reason);

        sendMessageToHandler(MESSAGE_VERIFICATION_FAILED, data);
    }

    public void verifyConnection(String keyserver, final Proxy proxy) {

        new AsyncTask<String, Void, FailureReason>() {
            ProgressDialog mProgressDialog;
            String mKeyserver;

            @Override
            protected void onPreExecute() {
                mProgressDialog = new ProgressDialog(getActivity());
                mProgressDialog.setMessage(getString(R.string.progress_verifying_keyserver_url));
                mProgressDialog.setCancelable(false);
                mProgressDialog.show();
            }

            @Override
            protected FailureReason doInBackground(String... keyservers) {
                mKeyserver = keyservers[0];
                FailureReason reason = null;
                try {
                    
                    Uri keyserverUri = Uri.parse(mKeyserver);
                    String scheme = keyserverUri.getScheme();
                    String schemeSpecificPart = keyserverUri.getSchemeSpecificPart();
                    String fragment = keyserverUri.getFragment();
                    if (scheme == null) throw new MalformedURLException();
                    if (scheme.equalsIgnoreCase("hkps")) scheme = "https";
                    else if (scheme.equalsIgnoreCase("hkp")) scheme = "http";
                    URI newKeyserver = new URI(scheme, schemeSpecificPart, fragment);

                    Log.d("Converted URL", newKeyserver.toString());

                    OkHttpClient client = HkpKeyserver.getClient(newKeyserver.toURL(), proxy);
                    TlsHelper.pinCertificateIfNecessary(client, newKeyserver.toURL());
                    client.newCall(new Request.Builder().url(newKeyserver.toURL()).build()).execute();
                } catch (TlsHelper.TlsHelperException e) {
                    reason = FailureReason.CONNECTION_FAILED;
                } catch (MalformedURLException e) {
                    Log.w(Constants.TAG, "Invalid keyserver URL entered by user.");
                    reason = FailureReason.INVALID_URL;
                } catch (URISyntaxException e) {
                    Log.w(Constants.TAG, "Invalid keyserver URL entered by user.");
                    reason = FailureReason.INVALID_URL;
                } catch (IOException e) {
                    Log.w(Constants.TAG, "Could not connect to entered keyserver url");
                    reason = FailureReason.CONNECTION_FAILED;
                }
                return reason;
            }

            @Override
            protected void onPostExecute(FailureReason failureReason) {
                mProgressDialog.dismiss();
                if (failureReason == null) {
                    addKeyserver(mKeyserver, true);
                } else {
                    verificationFailed(failureReason);
                }
            }
        }.execute(keyserver);
    }

    @Override
    public void onDismiss(DialogInterface dialog) {
        super.onDismiss(dialog);

        
        hideKeyboard();
    }

    private void hideKeyboard() {
        if (getActivity() == null) {
            return;
        }
        InputMethodManager inputManager = (InputMethodManager) getActivity()
                .getSystemService(Context.INPUT_METHOD_SERVICE);

        
        View v = getActivity().getCurrentFocus();
        if (v == null)
            return;

        inputManager.hideSoftInputFromWindow(v.getWindowToken(), 0);
    }

    
    @Override
    public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
        if (EditorInfo.IME_ACTION_DONE == actionId) {
            AlertDialog dialog = ((AlertDialog) getDialog());
            Button bt = dialog.getButton(AlertDialog.BUTTON_POSITIVE);

            bt.performClick();
            return true;
        }
        return false;
    }

    
    private void sendMessageToHandler(Integer what, Bundle data) {
        Message msg = Message.obtain();
        msg.what = what;
        if (data != null) {
            msg.setData(data);
        }

        try {
            mMessenger.send(msg);
        } catch (RemoteException e) {
            Log.w(Constants.TAG, "Exception sending message, Is handler present?", e);
        } catch (NullPointerException e) {
            Log.w(Constants.TAG, "Messenger is null!", e);
        }
    }
}

<code block>



package org.sufficientlysecure.keychain.ui.dialog;

import android.app.Dialog;
import android.content.DialogInterface;
import android.os.Bundle;
import android.os.Message;
import android.os.Messenger;
import android.os.RemoteException;
import android.support.v4.app.DialogFragment;

import org.sufficientlysecure.keychain.Constants;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.util.Log;
import org.sufficientlysecure.keychain.util.orbot.OrbotHelper;


public class OrbotStartDialogFragment extends DialogFragment {
    private static final String ARG_MESSENGER = "messenger";
    private static final String ARG_TITLE = "title";
    private static final String ARG_MESSAGE = "message";
    private static final String ARG_MIDDLE_BUTTON = "middleButton";

    public static final int MESSAGE_MIDDLE_BUTTON = 1;

    public static OrbotStartDialogFragment newInstance(Messenger messenger, int title, int message, int middleButton) {
        Bundle args = new Bundle();
        args.putParcelable(ARG_MESSENGER, messenger);
        args.putInt(ARG_TITLE, title);
        args.putInt(ARG_MESSAGE, message);
        args.putInt(ARG_MIDDLE_BUTTON, middleButton);

        OrbotStartDialogFragment fragment = new OrbotStartDialogFragment();
        fragment.setArguments(args);

        return fragment;
    }

    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {

        final Messenger messenger = getArguments().getParcelable(ARG_MESSENGER);
        int title = getArguments().getInt(ARG_TITLE);
        final int message = getArguments().getInt(ARG_MESSAGE);
        int middleButton = getArguments().getInt(ARG_MIDDLE_BUTTON);

        CustomAlertDialogBuilder builder = new CustomAlertDialogBuilder(getActivity());
        builder.setTitle(title).setMessage(message);

        builder.setNegativeButton(R.string.orbot_start_dialog_cancel, new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {

            }
        });

        builder.setPositiveButton(R.string.orbot_start_dialog_start, new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                getActivity().startActivityForResult(OrbotHelper.getOrbotStartIntent(), 1);
            }
        });

        builder.setNeutralButton(middleButton, new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                Message msg = new Message();
                msg.what = MESSAGE_MIDDLE_BUTTON;
                try {
                    messenger.send(msg);
                } catch (RemoteException e) {
                    Log.w(Constants.TAG, "Exception sending message, Is handler present?", e);
                } catch (NullPointerException e) {
                    Log.w(Constants.TAG, "Messenger is null!", e);
                }
            }
        });

        return builder.show();
    }
}

<code block>


package org.sufficientlysecure.keychain.ui;

import java.util.ArrayList;

import android.app.Activity;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentTransaction;
import android.view.View;
import android.widget.Toast;

import org.sufficientlysecure.keychain.Constants;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.intents.OpenKeychainIntents;
import org.sufficientlysecure.keychain.ui.base.BaseActivity;


public class DecryptFilesActivity extends BaseActivity {

    
    public static final String ACTION_DECRYPT_DATA = OpenKeychainIntents.DECRYPT_DATA;

    
    public static final String ACTION_DECRYPT_DATA_OPEN = Constants.INTENT_PREFIX + "DECRYPT_DATA_OPEN";

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setFullScreenDialogClose(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                setResult(Activity.RESULT_CANCELED);
                finish();
            }
        }, false);

        
        handleActions(savedInstanceState, getIntent());
    }

    @Override
    protected void initLayout() {
        setContentView(R.layout.decrypt_files_activity);
    }

    
    private void handleActions(Bundle savedInstanceState, Intent intent) {

        
        if (savedInstanceState != null) {
            return;
        }

        ArrayList<Uri> uris = new ArrayList<>();

        String action = intent.getAction();

        switch (action) {
            case Intent.ACTION_SEND: {
                
                
                
                action = ACTION_DECRYPT_DATA;
                uris.add(intent.<Uri>getParcelableExtra(Intent.EXTRA_STREAM));
                break;
            }

            case Intent.ACTION_SEND_MULTIPLE: {
                action = ACTION_DECRYPT_DATA;
                uris.addAll(intent.<Uri>getParcelableArrayListExtra(Intent.EXTRA_STREAM));
                break;
            }

            case Intent.ACTION_VIEW:
                
                action = ACTION_DECRYPT_DATA;

                
            default:
                uris.add(intent.getData());

        }

        if (ACTION_DECRYPT_DATA.equals(action)) {
            
            if (uris.isEmpty()) {
                Toast.makeText(this, "No data to decrypt!", Toast.LENGTH_LONG).show();
                setResult(Activity.RESULT_CANCELED);
                finish();
            }
            displayListFragment(uris);
            return;
        }

        boolean showOpenDialog = ACTION_DECRYPT_DATA_OPEN.equals(action);
        displayInputFragment(showOpenDialog);

    }

    public void displayInputFragment(boolean showOpenDialog) {
        DecryptFilesInputFragment frag = DecryptFilesInputFragment.newInstance(showOpenDialog);

        
        
        getSupportFragmentManager().beginTransaction()
                .replace(R.id.decrypt_files_fragment_container, frag)
                .commit();
    }

    public void displayListFragment(ArrayList<Uri> inputUris) {

        DecryptFilesListFragment frag = DecryptFilesListFragment.newInstance(inputUris);

        FragmentManager fragMan = getSupportFragmentManager();

        FragmentTransaction trans = fragMan.beginTransaction();
        trans.replace(R.id.decrypt_files_fragment_container, frag);

        
        if (fragMan.getFragments() != null && !fragMan.getFragments().isEmpty()) {
            trans.addToBackStack("list");
        }

        trans.commit();

    }

}

<code block>


package org.sufficientlysecure.keychain.ui;

import java.util.ArrayList;

import android.app.Activity;
import android.content.Intent;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.ui.util.Notify;
import org.sufficientlysecure.keychain.util.FileHelper;

public class DecryptFilesInputFragment extends Fragment {
    public static final String ARG_URI = "uri";
    public static final String ARG_OPEN_DIRECTLY = "open_directly";

    private static final int REQUEST_CODE_INPUT = 0x00007003;

    private TextView mFilename;
    private View mDecryptButton;

    private Uri mInputUri = null;

    public static DecryptFilesInputFragment newInstance(boolean openDirectly) {
        DecryptFilesInputFragment frag = new DecryptFilesInputFragment();

        Bundle args = new Bundle();
        args.putBoolean(ARG_OPEN_DIRECTLY, openDirectly);

        frag.setArguments(args);

        return frag;
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.decrypt_files_input_fragment, container, false);

        
        getActivity().findViewById(R.id.result_main_layout).setVisibility(View.GONE);

        mFilename = (TextView) view.findViewById(R.id.decrypt_files_filename);
        mDecryptButton = view.findViewById(R.id.decrypt_files_action_decrypt);
        view.findViewById(R.id.decrypt_files_browse).setOnClickListener(new View.OnClickListener() {
            public void onClick(View v) {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
                    FileHelper.openDocument(DecryptFilesInputFragment.this, "**",
                            REQUEST_CODE_INPUT);
                }
            }
        });
        mDecryptButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                decryptAction();
            }
        });

        return view;
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);

        outState.putParcelable(ARG_URI, mInputUri);
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        Bundle state = savedInstanceState != null ? savedInstanceState : getArguments();
        setInputUri(state.<Uri>getParcelable(ARG_URI));

        
        if (state.getBoolean(ARG_OPEN_DIRECTLY, false)) {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
                FileHelper.openDocument(DecryptFilesInputFragment.this, "**", REQUEST_CODE_INPUT);
            }
        }
    }

    private void setInputUri(Uri inputUri) {
        if (inputUri == null) {
            mInputUri = null;
            mFilename.setText("");
            return;
        }

        mInputUri = inputUri;
        mFilename.setText(FileHelper.getFilename(getActivity(), mInputUri));
    }

    private void decryptAction() {
        if (mInputUri == null) {
            Notify.create(getActivity(), R.string.no_file_selected, Notify.Style.ERROR).show();
            return;
        }

        DecryptFilesActivity activity = (DecryptFilesActivity) getActivity();

        ArrayList<Uri> uris = new ArrayList<>();
        uris.add(mInputUri);
        activity.displayListFragment(uris);
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (requestCode != REQUEST_CODE_INPUT) {
            return;
        }

        if (resultCode == Activity.RESULT_OK && data != null) {
            setInputUri(data.getData());
        }
    }

}

<code block>


package org.sufficientlysecure.keychain.ui;


import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ResolveInfo;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.support.v7.widget.DefaultItemAnimator;
import android.support.v7.widget.LinearLayoutManager;
import android.support.v7.widget.RecyclerView;
import android.view.ContextMenu;
import android.view.ContextMenu.ContextMenuInfo;
import android.view.LayoutInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.PopupMenu;
import android.widget.PopupMenu.OnDismissListener;
import android.widget.PopupMenu.OnMenuItemClickListener;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.ViewAnimator;

import org.openintents.openpgp.OpenPgpMetadata;
import org.openintents.openpgp.OpenPgpSignatureResult;
import org.sufficientlysecure.keychain.Constants;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.operations.results.DecryptVerifyResult;
import org.sufficientlysecure.keychain.pgp.PgpDecryptVerifyInputParcel;
import org.sufficientlysecure.keychain.provider.KeychainContract.KeyRings;
import org.sufficientlysecure.keychain.provider.TemporaryStorageProvider;

import org.sufficientlysecure.keychain.service.input.CryptoInputParcel;
import org.sufficientlysecure.keychain.ui.util.KeyFormattingUtils.StatusHolder;
import org.sufficientlysecure.keychain.ui.DecryptFilesListFragment.DecryptFilesAdapter.ViewModel;
import org.sufficientlysecure.keychain.ui.adapter.SpacesItemDecoration;
import org.sufficientlysecure.keychain.ui.base.CryptoOperationFragment;
import org.sufficientlysecure.keychain.ui.util.FormattingUtils;
import org.sufficientlysecure.keychain.ui.util.KeyFormattingUtils;
import org.sufficientlysecure.keychain.ui.util.Notify;
import org.sufficientlysecure.keychain.ui.util.Notify.Style;
import org.sufficientlysecure.keychain.util.FileHelper;
import org.sufficientlysecure.keychain.util.Log;

public class DecryptFilesListFragment
        extends CryptoOperationFragment<PgpDecryptVerifyInputParcel,DecryptVerifyResult>
        implements OnMenuItemClickListener {
    public static final String ARG_URIS = "uris";

    private static final int REQUEST_CODE_OUTPUT = 0x00007007;

    private ArrayList<Uri> mInputUris;
    private HashMap<Uri, Uri> mOutputUris;
    private ArrayList<Uri> mPendingInputUris;

    private Uri mCurrentInputUri;

    private DecryptFilesAdapter mAdapter;

    
    public static DecryptFilesListFragment newInstance(ArrayList<Uri> uris) {
        DecryptFilesListFragment frag = new DecryptFilesListFragment();

        Bundle args = new Bundle();
        args.putParcelableArrayList(ARG_URIS, uris);
        frag.setArguments(args);

        return frag;
    }

    
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.decrypt_files_list_fragment, container, false);

        RecyclerView vFilesList = (RecyclerView) view.findViewById(R.id.decrypted_files_list);

        vFilesList.addItemDecoration(new SpacesItemDecoration(
                FormattingUtils.dpToPx(getActivity(), 4)));
        vFilesList.setHasFixedSize(true);
        vFilesList.setLayoutManager(new LinearLayoutManager(getActivity()));
        vFilesList.setItemAnimator(new DefaultItemAnimator());

        mAdapter = new DecryptFilesAdapter(getActivity(), this);
        vFilesList.setAdapter(mAdapter);

        return view;
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);

        outState.putParcelableArrayList(ARG_URIS, mInputUris);
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        displayInputUris(getArguments().<Uri>getParcelableArrayList(ARG_URIS));
    }

    private String removeEncryptedAppend(String name) {
        if (name.endsWith(Constants.FILE_EXTENSION_ASC)
                || name.endsWith(Constants.FILE_EXTENSION_PGP_MAIN)
                || name.endsWith(Constants.FILE_EXTENSION_PGP_ALTERNATE)) {
            return name.substring(0, name.length() - 4);
        }
        return name;
    }

    private void askForOutputFilename(Uri inputUri, String originalFilename, String mimeType) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.KITKAT) {
            File file = new File(inputUri.getPath());
            File parentDir = file.exists() ? file.getParentFile() : Constants.Path.APP_DIR;
            File targetFile = new File(parentDir, originalFilename);
            FileHelper.saveFile(this, getString(R.string.title_decrypt_to_file),
                    getString(R.string.specify_file_to_decrypt_to), targetFile, REQUEST_CODE_OUTPUT);
        } else {
            FileHelper.saveDocument(this, mimeType, originalFilename, REQUEST_CODE_OUTPUT);
        }
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        switch (requestCode) {
            case REQUEST_CODE_OUTPUT: {
                
                if (resultCode == Activity.RESULT_OK && data != null) {
                    Uri saveUri = data.getData();
                    Uri outputUri = mOutputUris.get(mCurrentInputUri);
                    

                    mCurrentInputUri = null;
                }
                return;
            }

            default: {
                super.onActivityResult(requestCode, resultCode, data);
            }
        }
    }

    private void displayInputUris(ArrayList<Uri> uris) {
        mInputUris = uris;
        mOutputUris = new HashMap<>(uris.size());
        for (Uri uri : uris) {
            mAdapter.add(uri);
            mOutputUris.put(uri, TemporaryStorageProvider.createFile(getActivity()));
        }

        mPendingInputUris = uris;

        cryptoOperation();
    }

    @Override
    protected void cryptoOperation(CryptoInputParcel cryptoInput) {
        super.cryptoOperation(cryptoInput, false);
    }

    @Override
    protected boolean onCryptoSetProgress(String msg, int progress, int max) {
        mAdapter.setProgress(mCurrentInputUri, progress, max, msg);
        return true;
    }

    @Override
    protected void dismissProgress() {
        
    }

    @Override
    protected void onCryptoOperationError(DecryptVerifyResult result) {
        final Uri uri = mCurrentInputUri;
        mCurrentInputUri = null;

        mAdapter.addResult(uri, result, null, null, null);

        cryptoOperation();
    }

    @Override
    protected void onCryptoOperationSuccess(DecryptVerifyResult result) {
        final Uri uri = mCurrentInputUri;
        mCurrentInputUri = null;

        Drawable icon = null;
        OnClickListener onFileClick = null, onKeyClick = null;

        if (result.getDecryptMetadata() != null && result.getDecryptMetadata().getMimeType() != null) {
            icon = loadIcon(result.getDecryptMetadata().getMimeType());
        }

        OpenPgpSignatureResult sigResult = result.getSignatureResult();
        if (sigResult != null) {
            final long keyId = sigResult.getKeyId();
            if (sigResult.getStatus() != OpenPgpSignatureResult.SIGNATURE_KEY_MISSING) {
                onKeyClick = new OnClickListener() {
                    @Override
                    public void onClick(View view) {
                        Activity activity = getActivity();
                        if (activity == null) {
                            return;
                        }
                        Intent intent = new Intent(activity, ViewKeyActivity.class);
                        intent.setData(KeyRings.buildUnifiedKeyRingUri(keyId));
                        activity.startActivity(intent);
                    }
                };
            }
        }

        if (result.success() && result.getDecryptMetadata() != null) {
            final OpenPgpMetadata metadata = result.getDecryptMetadata();
            onFileClick = new OnClickListener() {
                @Override
                public void onClick(View view) {
                    Activity activity = getActivity();
                    if (activity == null || mCurrentInputUri != null) {
                        return;
                    }

                    Uri outputUri = mOutputUris.get(uri);
                    Intent intent = new Intent();
                    intent.setDataAndType(outputUri, metadata.getMimeType());
                    activity.startActivity(intent);
                }
            };
        }

        mAdapter.addResult(uri, result, icon, onFileClick, onKeyClick);

        cryptoOperation();

    }

    @Override
    protected PgpDecryptVerifyInputParcel createOperationInput() {

        if (mCurrentInputUri == null) {
            if (mPendingInputUris.isEmpty()) {
                
                return null;
            }

            mCurrentInputUri = mPendingInputUris.remove(0);
        }

        Uri currentOutputUri = mOutputUris.get(mCurrentInputUri);
        Log.d(Constants.TAG, "mInputUri=" + mCurrentInputUri + ", mOutputUri=" + currentOutputUri);

        return new PgpDecryptVerifyInputParcel(mCurrentInputUri, currentOutputUri)
                .setAllowSymmetricDecryption(true);

    }

    @Override
    public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {
        super.onCreateContextMenu(menu, v, menuInfo);
    }

    @Override
    public boolean onMenuItemClick(MenuItem menuItem) {
        if (mAdapter.mMenuClickedModel == null || !mAdapter.mMenuClickedModel.hasResult()) {
            return false;
        }
        Activity activity = getActivity();
        if (activity == null) {
            return false;
        }

        ViewModel model = mAdapter.mMenuClickedModel;
        DecryptVerifyResult result = model.mResult;
        switch (menuItem.getItemId()) {
            case R.id.view_log:
                Intent intent = new Intent(activity, LogDisplayActivity.class);
                intent.putExtra(LogDisplayFragment.EXTRA_RESULT, result);
                activity.startActivity(intent);
                return true;
            case R.id.decrypt_save:
                OpenPgpMetadata metadata = result.getDecryptMetadata();
                if (metadata == null) {
                    return true;
                }
                mCurrentInputUri = model.mInputUri;
                askForOutputFilename(model.mInputUri, metadata.getFilename(), metadata.getMimeType());
                return true;
            case R.id.decrypt_delete:
                Notify.create(activity, "decrypt/delete not yet implemented", Style.ERROR).show(this);
                return true;
        }
        return false;
    }

    public static class DecryptFilesAdapter extends RecyclerView.Adapter<ViewHolder> {
        private Context mContext;
        private ArrayList<ViewModel> mDataset;
        private OnMenuItemClickListener mMenuItemClickListener;
        private ViewModel mMenuClickedModel;

        public class ViewModel {
            Context mContext;
            Uri mInputUri;
            DecryptVerifyResult mResult;
            Drawable mIcon;

            OnClickListener mOnFileClickListener;
            OnClickListener mOnKeyClickListener;

            int mProgress, mMax;
            String mProgressMsg;

            ViewModel(Context context, Uri uri) {
                mContext = context;
                mInputUri = uri;
                mProgress = 0;
                mMax = 100;
            }

            void addResult(DecryptVerifyResult result) {
                mResult = result;
            }

            void addIcon(Drawable icon) {
                mIcon = icon;
            }

            void setOnClickListeners(OnClickListener onFileClick, OnClickListener onKeyClick) {
                mOnFileClickListener = onFileClick;
                mOnKeyClickListener = onKeyClick;
            }

            boolean hasResult() {
                return mResult != null;
            }

            void setProgress(int progress, int max, String msg) {
                if (msg != null) {
                    mProgressMsg = msg;
                }
                mProgress = progress;
                mMax = max;
            }

            
            @Override
            public boolean equals(Object o) {
                if (this == o) return true;
                if (o == null || getClass() != o.getClass()) return false;
                ViewModel viewModel = (ViewModel) o;
                return !(mResult != null ? !mResult.equals(viewModel.mResult)
                        : viewModel.mResult != null);
            }

            
            @Override
            public int hashCode() {
                return mResult != null ? mResult.hashCode() : 0;
            }

            @Override
            public String toString() {
                return mResult.toString();
            }
        }

        
        public DecryptFilesAdapter(Context context, OnMenuItemClickListener menuItemClickListener) {
            mContext = context;
            mMenuItemClickListener = menuItemClickListener;
            mDataset = new ArrayList<>();
        }

        
        @Override
        public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
            
            View v = LayoutInflater.from(parent.getContext())
                    .inflate(R.layout.decrypt_list_entry, parent, false);
            return new ViewHolder(v);
        }

        
        @Override
        public void onBindViewHolder(ViewHolder holder, final int position) {
            
            
            final ViewModel model = mDataset.get(position);

            if (model.hasResult()) {
                if (holder.vAnimator.getDisplayedChild() != 1) {
                    holder.vAnimator.setDisplayedChild(1);
                }

                KeyFormattingUtils.setStatus(mContext, holder, model.mResult);

                OpenPgpMetadata metadata = model.mResult.getDecryptMetadata();
                holder.vFilename.setText(metadata.getFilename());

                long size = metadata.getOriginalSize();
                if (size == -1 || size == 0) {
                    holder.vFilesize.setText("");
                } else {
                    holder.vFilesize.setText(FileHelper.readableFileSize(size));
                }

                
                if (model.mIcon != null) {
                    holder.vThumbnail.setImageDrawable(model.mIcon);
                } else {
                    holder.vThumbnail.setImageResource(R.drawable.ic_doc_generic_am);
                }

                holder.vFile.setOnClickListener(model.mOnFileClickListener);
                holder.vSignatureLayout.setOnClickListener(model.mOnKeyClickListener);

                holder.vContextMenu.setTag(model);
                holder.vContextMenu.setOnClickListener(new OnClickListener() {
                    @Override
                    public void onClick(View view) {
                        mMenuClickedModel = model;
                        PopupMenu menu = new PopupMenu(mContext, view);
                        menu.inflate(R.menu.decrypt_item_context_menu);
                        menu.setOnMenuItemClickListener(mMenuItemClickListener);
                        menu.setOnDismissListener(new OnDismissListener() {
                            @Override
                            public void onDismiss(PopupMenu popupMenu) {
                                mMenuClickedModel = null;
                            }
                        });
                        menu.show();
                    }
                });

            } else {
                if (holder.vAnimator.getDisplayedChild() != 0) {
                    holder.vAnimator.setDisplayedChild(0);
                }

                holder.vProgress.setProgress(model.mProgress);
                holder.vProgress.setMax(model.mMax);
                holder.vProgressMsg.setText(model.mProgressMsg);
            }

        }

        
        @Override
        public int getItemCount() {
            return mDataset.size();
        }

        public void add(Uri uri) {
            ViewModel newModel = new ViewModel(mContext, uri);
            mDataset.add(newModel);
            notifyItemInserted(mDataset.size());
        }

        public void setProgress(Uri uri, int progress, int max, String msg) {
            ViewModel newModel = new ViewModel(mContext, uri);
            int pos = mDataset.indexOf(newModel);
            mDataset.get(pos).setProgress(progress, max, msg);
            notifyItemChanged(pos);
        }

        public void addResult(Uri uri, DecryptVerifyResult result, Drawable icon,
                OnClickListener onFileClick, OnClickListener onKeyClick) {

            ViewModel model = new ViewModel(mContext, uri);
            int pos = mDataset.indexOf(model);
            model = mDataset.get(pos);

            model.addResult(result);
            if (icon != null) {
                model.addIcon(icon);
            }
            model.setOnClickListeners(onFileClick, onKeyClick);

            notifyItemChanged(pos);
        }

    }


    
    
    
    public static class ViewHolder extends RecyclerView.ViewHolder implements StatusHolder {
        public ViewAnimator vAnimator;

        public ProgressBar vProgress;
        public TextView vProgressMsg;

        public View vFile;
        public TextView vFilename;
        public TextView vFilesize;
        public ImageView vThumbnail;

        public ImageView vEncStatusIcon;
        public TextView vEncStatusText;

        public ImageView vSigStatusIcon;
        public TextView vSigStatusText;
        public View vSignatureLayout;
        public TextView vSignatureName;
        public TextView vSignatureMail;
        public TextView vSignatureAction;

        public View vContextMenu;

        public ViewHolder(View itemView) {
            super(itemView);

            vAnimator = (ViewAnimator) itemView.findViewById(R.id.view_animator);

            vProgress = (ProgressBar) itemView.findViewById(R.id.progress);
            vProgressMsg = (TextView) itemView.findViewById(R.id.progress_msg);

            vFile = itemView.findViewById(R.id.file);
            vFilename = (TextView) itemView.findViewById(R.id.filename);
            vFilesize = (TextView) itemView.findViewById(R.id.filesize);
            vThumbnail = (ImageView) itemView.findViewById(R.id.thumbnail);

            vEncStatusIcon = (ImageView) itemView.findViewById(R.id.result_encryption_icon);
            vEncStatusText = (TextView) itemView.findViewById(R.id.result_encryption_text);

            vSigStatusIcon = (ImageView) itemView.findViewById(R.id.result_signature_icon);
            vSigStatusText = (TextView) itemView.findViewById(R.id.result_signature_text);
            vSignatureLayout = itemView.findViewById(R.id.result_signature_layout);
            vSignatureName = (TextView) itemView.findViewById(R.id.result_signature_name);
            vSignatureMail= (TextView) itemView.findViewById(R.id.result_signature_email);
            vSignatureAction = (TextView) itemView.findViewById(R.id.result_signature_action);

            vContextMenu = itemView.findViewById(R.id.context_menu);

        }

        @Override
        public ImageView getEncryptionStatusIcon() {
            return vEncStatusIcon;
        }

        @Override
        public TextView getEncryptionStatusText() {
            return vEncStatusText;
        }

        @Override
        public ImageView getSignatureStatusIcon() {
            return vSigStatusIcon;
        }

        @Override
        public TextView getSignatureStatusText() {
            return vSigStatusText;
        }

        @Override
        public View getSignatureLayout() {
            return vSignatureLayout;
        }

        @Override
        public TextView getSignatureAction() {
            return vSignatureAction;
        }

        @Override
        public TextView getSignatureUserName() {
            return vSignatureName;
        }

        @Override
        public TextView getSignatureUserEmail() {
            return vSignatureMail;
        }

        @Override
        public boolean hasEncrypt() {
            return true;
        }
    }

    private Drawable loadIcon(String mimeType) {
        final Intent intent = new Intent(Intent.ACTION_VIEW);
        intent.setType(mimeType);

        final List<ResolveInfo> matches = getActivity()
                .getPackageManager().queryIntentActivities(intent, 0);
        
        for (ResolveInfo match : matches) {
            return match.loadIcon(getActivity().getPackageManager());
        }
        return null;

    }

}

<code block>


package org.sufficientlysecure.keychain.ui.base;

import android.app.Activity;
import android.app.ProgressDialog;
import android.content.Intent;
import android.os.Bundle;
import android.os.Message;
import android.os.Messenger;
import android.os.Parcelable;
import android.support.v4.app.Fragment;

import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.operations.results.InputPendingResult;
import org.sufficientlysecure.keychain.operations.results.OperationResult;
import org.sufficientlysecure.keychain.service.KeychainNewService;
import org.sufficientlysecure.keychain.service.KeychainService;
import org.sufficientlysecure.keychain.service.ServiceProgressHandler;
import org.sufficientlysecure.keychain.service.input.CryptoInputParcel;
import org.sufficientlysecure.keychain.service.input.RequiredInputParcel;
import org.sufficientlysecure.keychain.ui.NfcOperationActivity;
import org.sufficientlysecure.keychain.ui.PassphraseDialogActivity;
import org.sufficientlysecure.keychain.ui.dialog.ProgressDialogFragment;



public abstract class CryptoOperationFragment <T extends Parcelable, S extends OperationResult>
        extends Fragment {

    public static final int REQUEST_CODE_PASSPHRASE = 0x00008001;
    public static final int REQUEST_CODE_NFC = 0x00008002;

    private void initiateInputActivity(RequiredInputParcel requiredInput) {

        switch (requiredInput.mType) {
            case NFC_KEYTOCARD:
            case NFC_DECRYPT:
            case NFC_SIGN: {
                Intent intent = new Intent(getActivity(), NfcOperationActivity.class);
                intent.putExtra(NfcOperationActivity.EXTRA_REQUIRED_INPUT, requiredInput);
                startActivityForResult(intent, REQUEST_CODE_NFC);
                return;
            }

            case PASSPHRASE:
            case PASSPHRASE_SYMMETRIC: {
                Intent intent = new Intent(getActivity(), PassphraseDialogActivity.class);
                intent.putExtra(PassphraseDialogActivity.EXTRA_REQUIRED_INPUT, requiredInput);
                startActivityForResult(intent, REQUEST_CODE_PASSPHRASE);
                return;
            }
        }

        throw new RuntimeException("Unhandled pending result!");
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (resultCode == Activity.RESULT_CANCELED) {
            onCryptoOperationCancelled();
            return;
        }

        switch (requestCode) {
            case REQUEST_CODE_PASSPHRASE: {
                if (resultCode == Activity.RESULT_OK && data != null) {
                    CryptoInputParcel cryptoInput =
                            data.getParcelableExtra(PassphraseDialogActivity.RESULT_CRYPTO_INPUT);
                    cryptoOperation(cryptoInput);
                    return;
                }
                break;
            }

            case REQUEST_CODE_NFC: {
                if (resultCode == Activity.RESULT_OK && data != null) {
                    CryptoInputParcel cryptoInput =
                            data.getParcelableExtra(NfcOperationActivity.RESULT_DATA);
                    cryptoOperation(cryptoInput);
                    return;
                }
                break;
            }

            default: {
                super.onActivityResult(requestCode, resultCode, data);
            }
        }
    }

    protected void dismissProgress() {

        ProgressDialogFragment progressDialogFragment =
                (ProgressDialogFragment) getFragmentManager().findFragmentByTag("progressDialog");

        if (progressDialogFragment == null) {
            return;
        }

        progressDialogFragment.dismissAllowingStateLoss();

    }

    protected abstract T createOperationInput();

    protected void cryptoOperation(CryptoInputParcel cryptoInput) {
        cryptoOperation(cryptoInput, true);
    }

    protected void cryptoOperation() {
        cryptoOperation(new CryptoInputParcel());
    }

    protected void cryptoOperation(CryptoInputParcel cryptoInput, boolean showProgress) {

        T operationInput = createOperationInput();
        if (operationInput == null) {
            return;
        }

        
        Intent intent = new Intent(getActivity(), KeychainNewService.class);

        intent.putExtra(KeychainNewService.EXTRA_OPERATION_INPUT, operationInput);
        intent.putExtra(KeychainNewService.EXTRA_CRYPTO_INPUT, cryptoInput);

        ServiceProgressHandler saveHandler = new ServiceProgressHandler(getActivity()) {
            @Override
            public void handleMessage(Message message) {
                
                super.handleMessage(message);

                if (message.arg1 == MessageStatus.OKAY.ordinal()) {

                    
                    Bundle returnData = message.getData();
                    if (returnData == null) {
                        return;
                    }

                    final OperationResult result =
                            returnData.getParcelable(OperationResult.EXTRA_RESULT);

                    onHandleResult(result);
                }
            }

            @Override
            protected void onSetProgress(String msg, int progress, int max) {
                
                if ( ! onCryptoSetProgress(msg, progress, max)) {
                    super.onSetProgress(msg, progress, max);
                }
            }
        };

        
        Messenger messenger = new Messenger(saveHandler);
        intent.putExtra(KeychainService.EXTRA_MESSENGER, messenger);

        if (showProgress) {
            saveHandler.showProgressDialog(
                    getString(R.string.progress_building_key),
                    ProgressDialog.STYLE_HORIZONTAL, false);
        }

        getActivity().startService(intent);

    }

    protected void onCryptoOperationResult(S result) {
        if (result.success()) {
            onCryptoOperationSuccess(result);
        } else {
            onCryptoOperationError(result);
        }
    }

    abstract protected void onCryptoOperationSuccess(S result);

    protected void onCryptoOperationError(S result) {
        result.createNotify(getActivity()).show();
    }

    protected void onCryptoOperationCancelled() {
    }

    public void onHandleResult(OperationResult result) {

        if (result instanceof InputPendingResult) {
            InputPendingResult pendingResult = (InputPendingResult) result;
            if (pendingResult.isPending()) {
                RequiredInputParcel requiredInput = pendingResult.getRequiredInputParcel();
                initiateInputActivity(requiredInput);
                return;
            }
        }

        dismissProgress();

        try {
            
            onCryptoOperationResult((S) result);
        } catch (ClassCastException e) {
            throw new AssertionError("bad return class ("
                    + result.getClass().getSimpleName() + "), this is a programming error!");
        }

    }

    protected boolean onCryptoSetProgress(String msg, int progress, int max) {
        return false;
    }

}

<code block>


package org.sufficientlysecure.keychain.ui;

import java.util.ArrayList;

import android.app.Activity;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.view.View;
import android.widget.Toast;

import org.sufficientlysecure.keychain.Constants;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.intents.OpenKeychainIntents;
import org.sufficientlysecure.keychain.ui.base.BaseActivity;


public class DecryptFilesActivity extends BaseActivity {

    
    public static final String ACTION_DECRYPT_DATA = OpenKeychainIntents.DECRYPT_DATA;

    
    public static final String ACTION_DECRYPT_DATA_OPEN = Constants.INTENT_PREFIX + "DECRYPT_DATA_OPEN";

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setFullScreenDialogClose(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                setResult(Activity.RESULT_CANCELED);
                finish();
            }
        }, false);

        
        handleActions(savedInstanceState, getIntent());
    }

    @Override
    protected void initLayout() {
        setContentView(R.layout.decrypt_files_activity);
    }

    
    private void handleActions(Bundle savedInstanceState, Intent intent) {
        String action = intent.getAction();
        String type = intent.getType();
        Uri uri = intent.getData();

        if (Intent.ACTION_SEND.equals(action) && type != null) {
            
            
            
            uri = intent.getParcelableExtra(Intent.EXTRA_STREAM);
            action = ACTION_DECRYPT_DATA;
        } else if (Intent.ACTION_VIEW.equals(action)) {
            

            
            action = ACTION_DECRYPT_DATA;
        }

        
        if (savedInstanceState != null) {
            return;
        }

        
        if (ACTION_DECRYPT_DATA.equals(action) && uri == null) {
            Toast.makeText(this, "No data to decrypt!", Toast.LENGTH_LONG).show();
            setResult(Activity.RESULT_CANCELED);
            finish();
        }

        boolean showOpenDialog = ACTION_DECRYPT_DATA_OPEN.equals(action);
        DecryptFilesInputFragment frag = DecryptFilesInputFragment.newInstance(uri, showOpenDialog);

        
        
        getSupportFragmentManager().beginTransaction()
                .replace(R.id.decrypt_files_fragment_container, frag)
                .commit();

    }

    public void displayListFragment(Uri inputUri) {

        ArrayList<Uri> uris = new ArrayList<>();
        uris.add(inputUri);
        DecryptFilesListFragment frag = DecryptFilesListFragment.newInstance(uris);

        getSupportFragmentManager().beginTransaction()
                .replace(R.id.decrypt_files_fragment_container, frag)
                .addToBackStack("list")
                .commit();

    }

}

<code block>


package org.sufficientlysecure.keychain.ui;

import android.app.Activity;
import android.content.Intent;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.ui.util.Notify;
import org.sufficientlysecure.keychain.util.FileHelper;

public class DecryptFilesInputFragment extends Fragment {
    public static final String ARG_URI = "uri";
    public static final String ARG_OPEN_DIRECTLY = "open_directly";

    private static final int REQUEST_CODE_INPUT = 0x00007003;

    private TextView mFilename;
    private View mDecryptButton;

    private Uri mInputUri = null;

    public static DecryptFilesInputFragment newInstance(Uri uri, boolean openDirectly) {
        DecryptFilesInputFragment frag = new DecryptFilesInputFragment();

        Bundle args = new Bundle();
        args.putParcelable(ARG_URI, uri);
        args.putBoolean(ARG_OPEN_DIRECTLY, openDirectly);

        frag.setArguments(args);

        return frag;
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.decrypt_files_input_fragment, container, false);

        
        getActivity().findViewById(R.id.result_main_layout).setVisibility(View.GONE);

        mFilename = (TextView) view.findViewById(R.id.decrypt_files_filename);
        mDecryptButton = view.findViewById(R.id.decrypt_files_action_decrypt);
        view.findViewById(R.id.decrypt_files_browse).setOnClickListener(new View.OnClickListener() {
            public void onClick(View v) {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
                    FileHelper.openDocument(DecryptFilesInputFragment.this, "**",
                            REQUEST_CODE_INPUT);
                }
            }
        });
        mDecryptButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                decryptAction();
            }
        });

        return view;
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);

        outState.putParcelable(ARG_URI, mInputUri);
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        Bundle state = savedInstanceState != null ? savedInstanceState : getArguments();
        setInputUri(state.<Uri>getParcelable(ARG_URI));

        
        if (state.getBoolean(ARG_OPEN_DIRECTLY, false)) {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
                FileHelper.openDocument(DecryptFilesInputFragment.this, "**", REQUEST_CODE_INPUT);
            }
        }
    }

    private void setInputUri(Uri inputUri) {
        if (inputUri == null) {
            mInputUri = null;
            mFilename.setText("");
            return;
        }

        mInputUri = inputUri;
        mFilename.setText(FileHelper.getFilename(getActivity(), mInputUri));
    }

    private void decryptAction() {
        if (mInputUri == null) {
            Notify.create(getActivity(), R.string.no_file_selected, Notify.Style.ERROR).show();
            return;
        }

        DecryptFilesActivity activity = (DecryptFilesActivity) getActivity();
        activity.displayListFragment(mInputUri);
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (requestCode != REQUEST_CODE_INPUT) {
            return;
        }

        if (resultCode == Activity.RESULT_OK && data != null) {
            setInputUri(data.getData());
        }
    }

}

<code block>


package org.sufficientlysecure.keychain.ui;


import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ResolveInfo;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.support.v7.widget.DefaultItemAnimator;
import android.support.v7.widget.LinearLayoutManager;
import android.support.v7.widget.RecyclerView;
import android.view.ContextMenu;
import android.view.ContextMenu.ContextMenuInfo;
import android.view.LayoutInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.PopupMenu;
import android.widget.PopupMenu.OnDismissListener;
import android.widget.PopupMenu.OnMenuItemClickListener;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.ViewAnimator;

import org.openintents.openpgp.OpenPgpMetadata;
import org.openintents.openpgp.OpenPgpSignatureResult;
import org.sufficientlysecure.keychain.Constants;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.operations.results.DecryptVerifyResult;
import org.sufficientlysecure.keychain.pgp.PgpDecryptVerifyInputParcel;
import org.sufficientlysecure.keychain.provider.KeychainContract.KeyRings;
import org.sufficientlysecure.keychain.provider.TemporaryStorageProvider;

import org.sufficientlysecure.keychain.ui.util.KeyFormattingUtils.StatusHolder;
import org.sufficientlysecure.keychain.ui.DecryptFilesListFragment.DecryptFilesAdapter.ViewModel;
import org.sufficientlysecure.keychain.ui.adapter.SpacesItemDecoration;
import org.sufficientlysecure.keychain.ui.base.CryptoOperationFragment;
import org.sufficientlysecure.keychain.ui.util.FormattingUtils;
import org.sufficientlysecure.keychain.ui.util.KeyFormattingUtils;
import org.sufficientlysecure.keychain.ui.util.Notify;
import org.sufficientlysecure.keychain.ui.util.Notify.Style;
import org.sufficientlysecure.keychain.util.FileHelper;
import org.sufficientlysecure.keychain.util.Log;

public class DecryptFilesListFragment
        extends CryptoOperationFragment<PgpDecryptVerifyInputParcel,DecryptVerifyResult>
        implements OnMenuItemClickListener {
    public static final String ARG_URIS = "uris";

    private static final int REQUEST_CODE_OUTPUT = 0x00007007;

    private ArrayList<Uri> mInputUris;
    private HashMap<Uri, Uri> mOutputUris;
    private ArrayList<Uri> mPendingInputUris;

    private Uri mCurrentInputUri;

    private DecryptFilesAdapter mAdapter;

    
    public static DecryptFilesListFragment newInstance(ArrayList<Uri> uris) {
        DecryptFilesListFragment frag = new DecryptFilesListFragment();

        Bundle args = new Bundle();
        args.putParcelableArrayList(ARG_URIS, uris);
        frag.setArguments(args);

        return frag;
    }

    
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.decrypt_files_list_fragment, container, false);

        RecyclerView vFilesList = (RecyclerView) view.findViewById(R.id.decrypted_files_list);

        vFilesList.addItemDecoration(new SpacesItemDecoration(
                FormattingUtils.dpToPx(getActivity(), 4)));
        vFilesList.setHasFixedSize(true);
        vFilesList.setLayoutManager(new LinearLayoutManager(getActivity()));
        vFilesList.setItemAnimator(new DefaultItemAnimator());

        mAdapter = new DecryptFilesAdapter(getActivity(), this);
        vFilesList.setAdapter(mAdapter);

        return view;
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);

        outState.putParcelableArrayList(ARG_URIS, mInputUris);
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        displayInputUris(getArguments().<Uri>getParcelableArrayList(ARG_URIS));
    }

    private String removeEncryptedAppend(String name) {
        if (name.endsWith(Constants.FILE_EXTENSION_ASC)
                || name.endsWith(Constants.FILE_EXTENSION_PGP_MAIN)
                || name.endsWith(Constants.FILE_EXTENSION_PGP_ALTERNATE)) {
            return name.substring(0, name.length() - 4);
        }
        return name;
    }

    private void askForOutputFilename(Uri inputUri, String originalFilename, String mimeType) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.KITKAT) {
            File file = new File(inputUri.getPath());
            File parentDir = file.exists() ? file.getParentFile() : Constants.Path.APP_DIR;
            File targetFile = new File(parentDir, originalFilename);
            FileHelper.saveFile(this, getString(R.string.title_decrypt_to_file),
                    getString(R.string.specify_file_to_decrypt_to), targetFile, REQUEST_CODE_OUTPUT);
        } else {
            FileHelper.saveDocument(this, mimeType, originalFilename, REQUEST_CODE_OUTPUT);
        }
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        switch (requestCode) {
            case REQUEST_CODE_OUTPUT: {
                
                if (resultCode == Activity.RESULT_OK && data != null) {
                    Uri saveUri = data.getData();
                    Uri outputUri = mOutputUris.get(mCurrentInputUri);
                    

                    mCurrentInputUri = null;
                }
                return;
            }

            default: {
                super.onActivityResult(requestCode, resultCode, data);
            }
        }
    }

    private void displayInputUris(ArrayList<Uri> uris) {
        mInputUris = uris;
        mOutputUris = new HashMap<>(uris.size());
        for (Uri uri : uris) {
            mAdapter.add(uri);
            mOutputUris.put(uri, TemporaryStorageProvider.createFile(getActivity()));
        }

        mPendingInputUris = uris;

        cryptoOperation();
    }

    @Override
    protected boolean onCryptoSetProgress(String msg, int progress, int max) {
        mAdapter.setProgress(mCurrentInputUri, progress, max, msg);
        return true;
    }

    @Override
    protected void dismissProgress() {
        
    }

    @Override
    protected void onCryptoOperationError(DecryptVerifyResult result) {
        final Uri uri = mCurrentInputUri;
        mCurrentInputUri = null;

        mAdapter.addResult(uri, result, null, null, null);
    }

    @Override
    protected void onCryptoOperationSuccess(DecryptVerifyResult result) {
        final Uri uri = mCurrentInputUri;
        mCurrentInputUri = null;

        Drawable icon = null;
        OnClickListener onFileClick = null, onKeyClick = null;

        if (result.getDecryptMetadata() != null && result.getDecryptMetadata().getMimeType() != null) {
            icon = loadIcon(result.getDecryptMetadata().getMimeType());
        }

        OpenPgpSignatureResult sigResult = result.getSignatureResult();
        if (sigResult != null) {
            final long keyId = sigResult.getKeyId();
            if (sigResult.getStatus() != OpenPgpSignatureResult.SIGNATURE_KEY_MISSING) {
                onKeyClick = new OnClickListener() {
                    @Override
                    public void onClick(View view) {
                        Activity activity = getActivity();
                        if (activity == null) {
                            return;
                        }
                        Intent intent = new Intent(activity, ViewKeyActivity.class);
                        intent.setData(KeyRings.buildUnifiedKeyRingUri(keyId));
                        activity.startActivity(intent);
                    }
                };
            }
        }

        if (result.success() && result.getDecryptMetadata() != null) {
            final OpenPgpMetadata metadata = result.getDecryptMetadata();
            onFileClick = new OnClickListener() {
                @Override
                public void onClick(View view) {
                    Activity activity = getActivity();
                    if (activity == null || mCurrentInputUri != null) {
                        return;
                    }

                    Uri outputUri = mOutputUris.get(uri);
                    Intent intent = new Intent();
                    intent.setDataAndType(outputUri, metadata.getMimeType());
                    activity.startActivity(intent);
                }
            };
        }

        mAdapter.addResult(uri, result, icon, onFileClick, onKeyClick);

    }

    @Override
    protected PgpDecryptVerifyInputParcel createOperationInput() {

        if (mCurrentInputUri == null) {
            if (mPendingInputUris.isEmpty()) {
                
                return null;
            }

            mCurrentInputUri = mPendingInputUris.remove(0);
        }

        Uri currentOutputUri = mOutputUris.get(mCurrentInputUri);
        Log.d(Constants.TAG, "mInputUri=" + mCurrentInputUri + ", mOutputUri=" + currentOutputUri);

        return new PgpDecryptVerifyInputParcel(mCurrentInputUri, currentOutputUri)
                .setAllowSymmetricDecryption(true);

    }

    @Override
    public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {
        super.onCreateContextMenu(menu, v, menuInfo);
    }

    @Override
    public boolean onMenuItemClick(MenuItem menuItem) {
        if (mAdapter.mMenuClickedModel == null || !mAdapter.mMenuClickedModel.hasResult()) {
            return false;
        }
        Activity activity = getActivity();
        if (activity == null) {
            return false;
        }

        ViewModel model = mAdapter.mMenuClickedModel;
        DecryptVerifyResult result = model.mResult;
        switch (menuItem.getItemId()) {
            case R.id.view_log:
                Intent intent = new Intent(activity, LogDisplayActivity.class);
                intent.putExtra(LogDisplayFragment.EXTRA_RESULT, result);
                activity.startActivity(intent);
                return true;
            case R.id.decrypt_save:
                OpenPgpMetadata metadata = result.getDecryptMetadata();
                if (metadata == null) {
                    return true;
                }
                mCurrentInputUri = model.mInputUri;
                askForOutputFilename(model.mInputUri, metadata.getFilename(), metadata.getMimeType());
                return true;
            case R.id.decrypt_delete:
                Notify.create(activity, "decrypt/delete not yet implemented", Style.ERROR).show(this);
                return true;
        }
        return false;
    }

    public static class DecryptFilesAdapter extends RecyclerView.Adapter<ViewHolder> {
        private Context mContext;
        private ArrayList<ViewModel> mDataset;
        private OnMenuItemClickListener mMenuItemClickListener;
        private ViewModel mMenuClickedModel;

        public class ViewModel {
            Context mContext;
            Uri mInputUri;
            DecryptVerifyResult mResult;
            Drawable mIcon;

            OnClickListener mOnFileClickListener;
            OnClickListener mOnKeyClickListener;

            int mProgress, mMax;
            String mProgressMsg;

            ViewModel(Context context, Uri uri) {
                mContext = context;
                mInputUri = uri;
                mProgress = 0;
                mMax = 100;
            }

            void addResult(DecryptVerifyResult result) {
                mResult = result;
            }

            void addIcon(Drawable icon) {
                mIcon = icon;
            }

            void setOnClickListeners(OnClickListener onFileClick, OnClickListener onKeyClick) {
                mOnFileClickListener = onFileClick;
                mOnKeyClickListener = onKeyClick;
            }

            boolean hasResult() {
                return mResult != null;
            }

            void setProgress(int progress, int max, String msg) {
                if (msg != null) {
                    mProgressMsg = msg;
                }
                mProgress = progress;
                mMax = max;
            }

            
            @Override
            public boolean equals(Object o) {
                if (this == o) return true;
                if (o == null || getClass() != o.getClass()) return false;
                ViewModel viewModel = (ViewModel) o;
                return !(mResult != null ? !mResult.equals(viewModel.mResult)
                        : viewModel.mResult != null);
            }

            
            @Override
            public int hashCode() {
                return mResult != null ? mResult.hashCode() : 0;
            }

            @Override
            public String toString() {
                return mResult.toString();
            }
        }

        
        public DecryptFilesAdapter(Context context, OnMenuItemClickListener menuItemClickListener) {
            mContext = context;
            mMenuItemClickListener = menuItemClickListener;
            mDataset = new ArrayList<>();
        }

        
        @Override
        public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
            
            View v = LayoutInflater.from(parent.getContext())
                    .inflate(R.layout.decrypt_list_entry, parent, false);
            return new ViewHolder(v);
        }

        
        @Override
        public void onBindViewHolder(ViewHolder holder, final int position) {
            
            
            final ViewModel model = mDataset.get(position);

            if (model.hasResult()) {
                if (holder.vAnimator.getDisplayedChild() != 1) {
                    holder.vAnimator.setDisplayedChild(1);
                }

                KeyFormattingUtils.setStatus(mContext, holder, model.mResult);

                OpenPgpMetadata metadata = model.mResult.getDecryptMetadata();
                holder.vFilename.setText(metadata.getFilename());

                long size = metadata.getOriginalSize();
                if (size == -1 || size == 0) {
                    holder.vFilesize.setText("");
                } else {
                    holder.vFilesize.setText(FileHelper.readableFileSize(size));
                }

                
                if (model.mIcon != null) {
                    holder.vThumbnail.setImageDrawable(model.mIcon);
                } else {
                    holder.vThumbnail.setImageResource(R.drawable.ic_doc_generic_am);
                }

                holder.vFile.setOnClickListener(model.mOnFileClickListener);
                holder.vSignatureLayout.setOnClickListener(model.mOnKeyClickListener);

                holder.vContextMenu.setTag(model);
                holder.vContextMenu.setOnClickListener(new OnClickListener() {
                    @Override
                    public void onClick(View view) {
                        mMenuClickedModel = model;
                        PopupMenu menu = new PopupMenu(mContext, view);
                        menu.inflate(R.menu.decrypt_item_context_menu);
                        menu.setOnMenuItemClickListener(mMenuItemClickListener);
                        menu.setOnDismissListener(new OnDismissListener() {
                            @Override
                            public void onDismiss(PopupMenu popupMenu) {
                                mMenuClickedModel = null;
                            }
                        });
                        menu.show();
                    }
                });

            } else {
                if (holder.vAnimator.getDisplayedChild() != 0) {
                    holder.vAnimator.setDisplayedChild(0);
                }

                holder.vProgress.setProgress(model.mProgress);
                holder.vProgress.setMax(model.mMax);
                holder.vProgressMsg.setText(model.mProgressMsg);
            }

        }

        
        @Override
        public int getItemCount() {
            return mDataset.size();
        }

        public void add(Uri uri) {
            ViewModel newModel = new ViewModel(mContext, uri);
            mDataset.add(newModel);
            notifyItemInserted(mDataset.size());
        }

        public void setProgress(Uri uri, int progress, int max, String msg) {
            ViewModel newModel = new ViewModel(mContext, uri);
            int pos = mDataset.indexOf(newModel);
            mDataset.get(pos).setProgress(progress, max, msg);
            notifyItemChanged(pos);
        }

        public void addResult(Uri uri, DecryptVerifyResult result, Drawable icon,
                OnClickListener onFileClick, OnClickListener onKeyClick) {

            ViewModel model = new ViewModel(mContext, uri);
            int pos = mDataset.indexOf(model);
            model = mDataset.get(pos);

            model.addResult(result);
            if (icon != null) {
                model.addIcon(icon);
            }
            model.setOnClickListeners(onFileClick, onKeyClick);

            notifyItemChanged(pos);
        }

    }


    
    
    
    public static class ViewHolder extends RecyclerView.ViewHolder implements StatusHolder {
        public ViewAnimator vAnimator;

        public ProgressBar vProgress;
        public TextView vProgressMsg;

        public View vFile;
        public TextView vFilename;
        public TextView vFilesize;
        public ImageView vThumbnail;

        public ImageView vEncStatusIcon;
        public TextView vEncStatusText;

        public ImageView vSigStatusIcon;
        public TextView vSigStatusText;
        public View vSignatureLayout;
        public TextView vSignatureName;
        public TextView vSignatureMail;
        public TextView vSignatureAction;

        public View vContextMenu;

        public ViewHolder(View itemView) {
            super(itemView);

            vAnimator = (ViewAnimator) itemView.findViewById(R.id.view_animator);

            vProgress = (ProgressBar) itemView.findViewById(R.id.progress);
            vProgressMsg = (TextView) itemView.findViewById(R.id.progress_msg);

            vFile = itemView.findViewById(R.id.file);
            vFilename = (TextView) itemView.findViewById(R.id.filename);
            vFilesize = (TextView) itemView.findViewById(R.id.filesize);
            vThumbnail = (ImageView) itemView.findViewById(R.id.thumbnail);

            vEncStatusIcon = (ImageView) itemView.findViewById(R.id.result_encryption_icon);
            vEncStatusText = (TextView) itemView.findViewById(R.id.result_encryption_text);

            vSigStatusIcon = (ImageView) itemView.findViewById(R.id.result_signature_icon);
            vSigStatusText = (TextView) itemView.findViewById(R.id.result_signature_text);
            vSignatureLayout = itemView.findViewById(R.id.result_signature_layout);
            vSignatureName = (TextView) itemView.findViewById(R.id.result_signature_name);
            vSignatureMail= (TextView) itemView.findViewById(R.id.result_signature_email);
            vSignatureAction = (TextView) itemView.findViewById(R.id.result_signature_action);

            vContextMenu = itemView.findViewById(R.id.context_menu);

        }

        @Override
        public ImageView getEncryptionStatusIcon() {
            return vEncStatusIcon;
        }

        @Override
        public TextView getEncryptionStatusText() {
            return vEncStatusText;
        }

        @Override
        public ImageView getSignatureStatusIcon() {
            return vSigStatusIcon;
        }

        @Override
        public TextView getSignatureStatusText() {
            return vSigStatusText;
        }

        @Override
        public View getSignatureLayout() {
            return vSignatureLayout;
        }

        @Override
        public TextView getSignatureAction() {
            return vSignatureAction;
        }

        @Override
        public TextView getSignatureUserName() {
            return vSignatureName;
        }

        @Override
        public TextView getSignatureUserEmail() {
            return vSignatureMail;
        }

        @Override
        public boolean hasEncrypt() {
            return true;
        }
    }

    private Drawable loadIcon(String mimeType) {
        final Intent intent = new Intent(Intent.ACTION_VIEW);
        intent.setType(mimeType);

        final List<ResolveInfo> matches = getActivity()
                .getPackageManager().queryIntentActivities(intent, 0);
        
        for (ResolveInfo match : matches) {
            return match.loadIcon(getActivity().getPackageManager());
        }
        return null;

    }

}

<code block>


package org.sufficientlysecure.keychain.ui.base;

import android.app.Activity;
import android.app.ProgressDialog;
import android.content.Intent;
import android.os.Bundle;
import android.os.Message;
import android.os.Messenger;
import android.os.Parcelable;
import android.support.v4.app.Fragment;

import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.operations.results.InputPendingResult;
import org.sufficientlysecure.keychain.operations.results.OperationResult;
import org.sufficientlysecure.keychain.service.KeychainNewService;
import org.sufficientlysecure.keychain.service.KeychainService;
import org.sufficientlysecure.keychain.service.ServiceProgressHandler;
import org.sufficientlysecure.keychain.service.input.CryptoInputParcel;
import org.sufficientlysecure.keychain.service.input.RequiredInputParcel;
import org.sufficientlysecure.keychain.ui.NfcOperationActivity;
import org.sufficientlysecure.keychain.ui.PassphraseDialogActivity;
import org.sufficientlysecure.keychain.ui.dialog.ProgressDialogFragment;



public abstract class CryptoOperationFragment <T extends Parcelable, S extends OperationResult>
        extends Fragment {

    public static final int REQUEST_CODE_PASSPHRASE = 0x00008001;
    public static final int REQUEST_CODE_NFC = 0x00008002;

    private void initiateInputActivity(RequiredInputParcel requiredInput) {

        switch (requiredInput.mType) {
            case NFC_KEYTOCARD:
            case NFC_DECRYPT:
            case NFC_SIGN: {
                Intent intent = new Intent(getActivity(), NfcOperationActivity.class);
                intent.putExtra(NfcOperationActivity.EXTRA_REQUIRED_INPUT, requiredInput);
                startActivityForResult(intent, REQUEST_CODE_NFC);
                return;
            }

            case PASSPHRASE:
            case PASSPHRASE_SYMMETRIC: {
                Intent intent = new Intent(getActivity(), PassphraseDialogActivity.class);
                intent.putExtra(PassphraseDialogActivity.EXTRA_REQUIRED_INPUT, requiredInput);
                startActivityForResult(intent, REQUEST_CODE_PASSPHRASE);
                return;
            }
        }

        throw new RuntimeException("Unhandled pending result!");
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (resultCode == Activity.RESULT_CANCELED) {
            onCryptoOperationCancelled();
            return;
        }

        switch (requestCode) {
            case REQUEST_CODE_PASSPHRASE: {
                if (resultCode == Activity.RESULT_OK && data != null) {
                    CryptoInputParcel cryptoInput =
                            data.getParcelableExtra(PassphraseDialogActivity.RESULT_CRYPTO_INPUT);
                    cryptoOperation(cryptoInput);
                    return;
                }
                break;
            }

            case REQUEST_CODE_NFC: {
                if (resultCode == Activity.RESULT_OK && data != null) {
                    CryptoInputParcel cryptoInput =
                            data.getParcelableExtra(NfcOperationActivity.RESULT_DATA);
                    cryptoOperation(cryptoInput);
                    return;
                }
                break;
            }

            default: {
                super.onActivityResult(requestCode, resultCode, data);
            }
        }
    }

    protected void dismissProgress() {

        ProgressDialogFragment progressDialogFragment =
                (ProgressDialogFragment) getFragmentManager().findFragmentByTag("progressDialog");

        if (progressDialogFragment == null) {
            return;
        }

        progressDialogFragment.dismissAllowingStateLoss();

    }

    protected abstract T createOperationInput();

    protected void cryptoOperation(CryptoInputParcel cryptoInput) {

        T operationInput = createOperationInput();
        if (operationInput == null) {
            return;
        }

        
        Intent intent = new Intent(getActivity(), KeychainNewService.class);

        intent.putExtra(KeychainNewService.EXTRA_OPERATION_INPUT, operationInput);
        intent.putExtra(KeychainNewService.EXTRA_CRYPTO_INPUT, cryptoInput);

        ServiceProgressHandler saveHandler = new ServiceProgressHandler(getActivity()) {
            @Override
            public void handleMessage(Message message) {
                
                super.handleMessage(message);

                if (message.arg1 == MessageStatus.OKAY.ordinal()) {

                    
                    Bundle returnData = message.getData();
                    if (returnData == null) {
                        return;
                    }

                    final OperationResult result =
                            returnData.getParcelable(OperationResult.EXTRA_RESULT);

                    onHandleResult(result);
                }
            }

            @Override
            protected void onSetProgress(String msg, int progress, int max) {
                
                if ( ! onCryptoSetProgress(msg, progress, max)) {
                    super.onSetProgress(msg, progress, max);
                }
            }
        };

        
        Messenger messenger = new Messenger(saveHandler);
        intent.putExtra(KeychainService.EXTRA_MESSENGER, messenger);

        saveHandler.showProgressDialog(
                getString(R.string.progress_building_key),
                ProgressDialog.STYLE_HORIZONTAL, false);

        getActivity().startService(intent);

    }

    protected void cryptoOperation() {
        cryptoOperation(new CryptoInputParcel());
    }

    protected void onCryptoOperationResult(S result) {
        if (result.success()) {
            onCryptoOperationSuccess(result);
        } else {
            onCryptoOperationError(result);
        }
    }

    abstract protected void onCryptoOperationSuccess(S result);

    protected void onCryptoOperationError(S result) {
        result.createNotify(getActivity()).show();
    }

    protected void onCryptoOperationCancelled() {
    }

    public void onHandleResult(OperationResult result) {

        if (result instanceof InputPendingResult) {
            InputPendingResult pendingResult = (InputPendingResult) result;
            if (pendingResult.isPending()) {
                RequiredInputParcel requiredInput = pendingResult.getRequiredInputParcel();
                initiateInputActivity(requiredInput);
                return;
            }
        }

        dismissProgress();

        try {
            
            onCryptoOperationResult((S) result);
        } catch (ClassCastException e) {
            throw new AssertionError("bad return class ("
                    + result.getClass().getSimpleName() + "), this is a programming error!");
        }

    }

    protected boolean onCryptoSetProgress(String msg, int progress, int max) {
        return false;
    }

}

<code block>


package org.sufficientlysecure.keychain.util;

import android.os.Parcel;
import android.os.Parcelable;

import java.net.InetSocketAddress;
import java.net.Proxy;


public class ParcelableProxy implements Parcelable {
    private String mProxyHost;
    private int mProxyPort;
    private int mProxyType;

    private final int TYPE_HTTP = 1;
    private final int TYPE_SOCKS = 2;

    public ParcelableProxy(String hostName, int port, Proxy.Type type) {
        mProxyHost = hostName;

        if (hostName == null) return; 

        mProxyPort = port;

        switch (type) {
            case HTTP: {
                mProxyType = TYPE_HTTP;
                break;
            }
            case SOCKS: {
                mProxyType = TYPE_SOCKS;
                break;
            }
        }
    }

    public Proxy getProxy() {
        if (mProxyHost == null) return null;

        Proxy.Type type = null;
        switch (mProxyType) {
            case TYPE_HTTP:
                type = Proxy.Type.HTTP;
                break;
            case TYPE_SOCKS:
                type = Proxy.Type.SOCKS;
                break;
        }
        return new Proxy(type, new InetSocketAddress(mProxyHost, mProxyPort));
    }

    public static ParcelableProxy getForNoProxy() {
        return new ParcelableProxy(null, -1, null);
    }

    protected ParcelableProxy(Parcel in) {
        mProxyHost = in.readString();
        mProxyPort = in.readInt();
        mProxyType = in.readInt();
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeString(mProxyHost);
        dest.writeInt(mProxyPort);
        dest.writeInt(mProxyType);
    }

    @SuppressWarnings("unused")
    public static final Parcelable.Creator<ParcelableProxy> CREATOR = new Parcelable.Creator<ParcelableProxy>() {
        @Override
        public ParcelableProxy createFromParcel(Parcel in) {
            return new ParcelableProxy(in);
        }

        @Override
        public ParcelableProxy[] newArray(int size) {
            return new ParcelableProxy[size];
        }
    };
}

<code block>


package org.sufficientlysecure.keychain.util.orbot;

import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.os.Handler;
import android.os.Message;
import android.os.Messenger;
import android.support.v4.app.DialogFragment;
import android.support.v4.app.FragmentActivity;

import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.ui.dialog.SupportInstallDialogFragment;
import org.sufficientlysecure.keychain.ui.dialog.OrbotStartDialogFragment;
import org.sufficientlysecure.keychain.ui.dialog.PreferenceInstallDialogFragment;
import org.sufficientlysecure.keychain.util.Preferences;


public class OrbotHelper {

    public final static String ORBOT_PACKAGE_NAME = "org.torproject.android";
    public final static String TOR_BIN_PATH = "/data/data/org.torproject.android/app_bin/tor";

    public final static String ACTION_START_TOR = "org.torproject.android.START_TOR";

    public static boolean isOrbotRunning() {
        int procId = TorServiceUtils.findProcessId(TOR_BIN_PATH);

        return (procId != -1);
    }

    public static boolean isOrbotInstalled(Context context) {
        return isAppInstalled(ORBOT_PACKAGE_NAME, context);
    }

    public static boolean isOrbotInstalledAndRunning(Context context) {
        return isOrbotRunning() && isOrbotInstalled(context);
    }

    private static boolean isAppInstalled(String uri, Context context) {
        PackageManager pm = context.getPackageManager();

        boolean installed;
        try {
            pm.getPackageInfo(uri, PackageManager.GET_ACTIVITIES);
            installed = true;
        } catch (PackageManager.NameNotFoundException e) {
            installed = false;
        }
        return installed;
    }

    
    public static android.app.DialogFragment getPreferenceInstallDialogFragment() {
        return PreferenceInstallDialogFragment.newInstance(R.string.orbot_install_dialog_title,
                R.string.orbot_install_dialog_content, ORBOT_PACKAGE_NAME);
    }

    public static DialogFragment getInstallDialogFragment() {
        return SupportInstallDialogFragment.newInstance(R.string.orbot_install_dialog_title,
                R.string.orbot_install_dialog_content, ORBOT_PACKAGE_NAME);
    }

    public static DialogFragment getInstallDialogFragmentWithThirdButton(Messenger messenger, int middleButton) {
        return SupportInstallDialogFragment.newInstance(messenger, R.string.orbot_install_dialog_title,
                R.string.orbot_install_dialog_content, ORBOT_PACKAGE_NAME, middleButton, true);
    }

    public static DialogFragment getOrbotStartDialogFragment(Messenger messenger, int middleButton) {
        return OrbotStartDialogFragment.newInstance(messenger, R.string.orbot_start_dialog_title, R.string
                        .orbot_start_dialog_content,
                middleButton);
    }

    public static Intent getOrbotStartIntent() {
        Intent intent = new Intent(ACTION_START_TOR);
        intent.setPackage(ORBOT_PACKAGE_NAME);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        return intent;
    }

    
    public static boolean isOrbotInRequiredState(int middleButton, final Runnable middleButtonRunnable,
                                                 Preferences.ProxyPrefs proxyPrefs, FragmentActivity fragmentActivity) {

        if (!proxyPrefs.torEnabled) {
            return true;
        } else {
            return isOrbotInRequiredState(middleButton, middleButtonRunnable, fragmentActivity);
        }

    }

    
    public static boolean isOrbotInRequiredState(int middleButton, final Runnable middleButtonRunnable,
                                                 FragmentActivity fragmentActivity) {
        Handler ignoreTorHandler = new Handler() {
            @Override
            public void handleMessage(Message msg) {
                
                middleButtonRunnable.run();
            }
        };

        if (!OrbotHelper.isOrbotInstalled(fragmentActivity)) {

            OrbotHelper.getInstallDialogFragmentWithThirdButton(
                    new Messenger(ignoreTorHandler),
                    middleButton
            ).show(fragmentActivity.getSupportFragmentManager(), "OrbotHelperOrbotInstallDialog");

            return false;
        } else if (!OrbotHelper.isOrbotRunning()) {

            OrbotHelper.getOrbotStartDialogFragment(new Messenger(ignoreTorHandler),
                    middleButton)
                    .show(fragmentActivity.getSupportFragmentManager(), "OrbotHelperOrbotStartDialog");

            return false;
        } else {
            return true;
        }
    }
}

<code block>


package org.sufficientlysecure.keychain.util.operation;

import android.support.v4.app.FragmentActivity;
import org.sufficientlysecure.keychain.keyimport.ParcelableKeyRing;
import org.sufficientlysecure.keychain.operations.results.ImportKeyResult;
import org.sufficientlysecure.keychain.service.ImportKeyringParcel;

import java.util.ArrayList;

public abstract class ImportOperationHelper extends OperationHelper<ImportKeyringParcel, ImportKeyResult> {
    private ArrayList<ParcelableKeyRing> mKeyList;
    private String mKeyserver;

    public ImportOperationHelper(FragmentActivity activity, int progressMessageString,
                                 ArrayList<ParcelableKeyRing> keyList, String keyserver) {
        super(activity, progressMessageString);
        mKeyList = keyList;
        mKeyserver = keyserver;
    }
    @Override
    public ImportKeyringParcel createOperationInput() {
        return new ImportKeyringParcel(mKeyList, mKeyserver);
    }
}

<code block>


package org.sufficientlysecure.keychain.util.operation;

import android.app.Activity;
import android.app.ProgressDialog;
import android.content.Intent;
import android.os.Bundle;
import android.os.Message;
import android.os.Messenger;
import android.os.Parcelable;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentActivity;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.operations.results.InputPendingResult;
import org.sufficientlysecure.keychain.operations.results.OperationResult;
import org.sufficientlysecure.keychain.service.KeychainNewService;
import org.sufficientlysecure.keychain.service.KeychainService;
import org.sufficientlysecure.keychain.service.ServiceProgressHandler;
import org.sufficientlysecure.keychain.service.input.CryptoInputParcel;
import org.sufficientlysecure.keychain.service.input.RequiredInputParcel;
import org.sufficientlysecure.keychain.ui.NfcOperationActivity;
import org.sufficientlysecure.keychain.ui.OrbotRequiredDialogActivity;
import org.sufficientlysecure.keychain.ui.PassphraseDialogActivity;
import org.sufficientlysecure.keychain.ui.dialog.ProgressDialogFragment;
import org.sufficientlysecure.keychain.util.Log;
import org.sufficientlysecure.keychain.util.ParcelableProxy;


public abstract class OperationHelper<T extends Parcelable, S extends OperationResult> {
    public static final int REQUEST_CODE_PASSPHRASE = 0x00008001;
    public static final int REQUEST_CODE_NFC = 0x00008002;
    public static final int REQUEST_ENABLE_ORBOT = 0x00008004;

    private int mProgressMessageString;

    private FragmentActivity mActivity;
    private Fragment mFragment;

    private boolean mUseFragment;

    
    public OperationHelper(FragmentActivity activity, int progressMessageString) {
        mActivity = activity;
        mUseFragment = false;
        mProgressMessageString = progressMessageString;
    }

    
    public OperationHelper(Fragment fragment, int progressMessageString) {
        mFragment = fragment;
        mActivity = fragment.getActivity();
        mUseFragment = true;
        mProgressMessageString = progressMessageString;
    }

    private void initiateInputActivity(RequiredInputParcel requiredInput) {

        Log.d("PHILIP", "Initating input " + requiredInput.mType);
        switch (requiredInput.mType) {
            case NFC_KEYTOCARD:
            case NFC_DECRYPT:
            case NFC_SIGN: {
                Intent intent = new Intent(mActivity, NfcOperationActivity.class);
                intent.putExtra(NfcOperationActivity.EXTRA_REQUIRED_INPUT, requiredInput);
                if (mUseFragment) {
                    mFragment.startActivityForResult(intent, REQUEST_CODE_NFC);
                } else {
                    mActivity.startActivityForResult(intent, REQUEST_CODE_NFC);
                }
                return;
            }

            case PASSPHRASE:
            case PASSPHRASE_SYMMETRIC: {
                Intent intent = new Intent(mActivity, PassphraseDialogActivity.class);
                intent.putExtra(PassphraseDialogActivity.EXTRA_REQUIRED_INPUT, requiredInput);
                if (mUseFragment) {
                    mFragment.startActivityForResult(intent, REQUEST_CODE_PASSPHRASE);
                } else {
                    mActivity.startActivityForResult(intent, REQUEST_CODE_PASSPHRASE);
                }
                return;
            }

            case ENABLE_ORBOT: {
                Intent intent = new Intent(mActivity, OrbotRequiredDialogActivity.class);
                if (mUseFragment) {
                    mFragment.startActivityForResult(intent, REQUEST_ENABLE_ORBOT);
                } else {
                    mActivity.startActivityForResult(intent, REQUEST_ENABLE_ORBOT);
                }
                return;
            }
        }

        throw new RuntimeException("Unhandled pending result!");
    }

    
    public boolean handleActivityResult(int requestCode, int resultCode, Intent data) {
        Log.d("PHILIP", "received activity result in OperationHelper");
        if (resultCode == Activity.RESULT_CANCELED) {
            onCryptoOperationCancelled();
            return true;
        }

        switch (requestCode) {
            case REQUEST_CODE_PASSPHRASE: {
                if (resultCode == Activity.RESULT_OK && data != null) {
                    CryptoInputParcel cryptoInput =
                            data.getParcelableExtra(PassphraseDialogActivity.RESULT_CRYPTO_INPUT);
                    cryptoOperation(cryptoInput);
                    return true;
                }
                break;
            }

            case REQUEST_CODE_NFC: {
                if (resultCode == Activity.RESULT_OK && data != null) {
                    CryptoInputParcel cryptoInput =
                            data.getParcelableExtra(NfcOperationActivity.RESULT_DATA);
                    cryptoOperation(cryptoInput);
                    return true;
                }
                break;
            }

            case REQUEST_ENABLE_ORBOT: {
                if (resultCode == Activity.RESULT_OK && data != null) {
                    if (data.getBooleanExtra(OrbotRequiredDialogActivity.RESULT_IGNORE_TOR, false)) {
                        cryptoOperation(new CryptoInputParcel(ParcelableProxy.getForNoProxy()));
                    }
                    return true;
                }
                break;
            }

            default: {
                return false;
            }
        }
        return true;
    }

    protected void dismissProgress() {
        ProgressDialogFragment progressDialogFragment =
                (ProgressDialogFragment) mActivity.getSupportFragmentManager().findFragmentByTag("progressDialog");

        if (progressDialogFragment == null) {
            return;
        }

        progressDialogFragment.dismissAllowingStateLoss();

    }

    public abstract T createOperationInput();

    public void cryptoOperation(CryptoInputParcel cryptoInput) {

        T operationInput = createOperationInput();
        if (operationInput == null) {
            return;
        }

        
        Intent intent = new Intent(mActivity, KeychainNewService.class);

        intent.putExtra(KeychainNewService.EXTRA_OPERATION_INPUT, operationInput);
        intent.putExtra(KeychainNewService.EXTRA_CRYPTO_INPUT, cryptoInput);

        ServiceProgressHandler saveHandler = new ServiceProgressHandler(mActivity) {
            @Override
            public void handleMessage(Message message) {
                
                super.handleMessage(message);

                if (message.arg1 == MessageStatus.OKAY.ordinal()) {

                    
                    Bundle returnData = message.getData();
                    if (returnData == null) {
                        return;
                    }

                    final OperationResult result =
                            returnData.getParcelable(OperationResult.EXTRA_RESULT);

                    onHandleResult(result);
                }
            }
        };

        saveHandler.showProgressDialog(
                mActivity.getString(mProgressMessageString),
                ProgressDialog.STYLE_HORIZONTAL, false);

        
        Messenger messenger = new Messenger(saveHandler);
        intent.putExtra(KeychainService.EXTRA_MESSENGER, messenger);

        mActivity.startService(intent);

    }

    public void cryptoOperation() {
        cryptoOperation(new CryptoInputParcel());
    }

    protected void onCryptoOperationResult(S result) {
        Log.d("PHILIP", "cryptoResult " + result.success());
        if (result.success()) {
            onCryptoOperationSuccess(result);
        } else {
            onCryptoOperationError(result);
        }
    }

    abstract protected void onCryptoOperationSuccess(S result);

    protected void onCryptoOperationError(S result) {
        result.createNotify(mActivity).show();
    }

    protected void onCryptoOperationCancelled() {
    }

    public void onHandleResult(OperationResult result) {
        Log.d("PHILIP", "Handling result in OperationHelper");

        if (result instanceof InputPendingResult) {
            Log.d("PHILIP", "is pending result");
            InputPendingResult pendingResult = (InputPendingResult) result;
            if (pendingResult.isPending()) {

                Log.d("PHILIP", "Is pending");
                RequiredInputParcel requiredInput = pendingResult.getRequiredInputParcel();
                initiateInputActivity(requiredInput);
                return;
            }
        }

        dismissProgress();

        try {
            
            onCryptoOperationResult((S) result);
        } catch (ClassCastException e) {
            throw new AssertionError("bad return class ("
                    + result.getClass().getSimpleName() + "), this is a programming error!");
        }

    }
}

<code block>


package org.sufficientlysecure.keychain.ui;

import android.app.Activity;
import android.content.Intent;
import android.database.Cursor;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.os.Messenger;
import android.support.v4.app.LoaderManager;
import android.support.v4.content.CursorLoader;
import android.support.v4.content.Loader;
import android.view.LayoutInflater;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.ListView;

import org.sufficientlysecure.keychain.Constants;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.compatibility.DialogFragmentWorkaround;
import org.sufficientlysecure.keychain.operations.results.OperationResult;
import org.sufficientlysecure.keychain.operations.results.OperationResult.LogType;
import org.sufficientlysecure.keychain.operations.results.SingletonResult;
import org.sufficientlysecure.keychain.pgp.CanonicalizedSecretKey.SecretKeyType;
import org.sufficientlysecure.keychain.pgp.KeyRing;
import org.sufficientlysecure.keychain.pgp.exception.PgpKeyNotFoundException;
import org.sufficientlysecure.keychain.provider.CachedPublicKeyRing;
import org.sufficientlysecure.keychain.provider.KeychainContract;
import org.sufficientlysecure.keychain.provider.KeychainContract.UserPackets;
import org.sufficientlysecure.keychain.provider.ProviderHelper;
import org.sufficientlysecure.keychain.provider.ProviderHelper.NotFoundException;
import org.sufficientlysecure.keychain.service.SaveKeyringParcel;
import org.sufficientlysecure.keychain.service.SaveKeyringParcel.ChangeUnlockParcel;
import org.sufficientlysecure.keychain.service.SaveKeyringParcel.SubkeyChange;
import org.sufficientlysecure.keychain.service.input.CryptoInputParcel;
import org.sufficientlysecure.keychain.ui.adapter.SubkeysAdapter;
import org.sufficientlysecure.keychain.ui.adapter.SubkeysAddedAdapter;
import org.sufficientlysecure.keychain.ui.adapter.UserIdsAdapter;
import org.sufficientlysecure.keychain.ui.adapter.UserIdsAddedAdapter;
import org.sufficientlysecure.keychain.ui.base.NewCryptoOperationFragment;
import org.sufficientlysecure.keychain.ui.dialog.AddSubkeyDialogFragment;
import org.sufficientlysecure.keychain.ui.dialog.AddUserIdDialogFragment;
import org.sufficientlysecure.keychain.ui.dialog.EditSubkeyDialogFragment;
import org.sufficientlysecure.keychain.ui.dialog.EditSubkeyExpiryDialogFragment;
import org.sufficientlysecure.keychain.ui.dialog.EditUserIdDialogFragment;
import org.sufficientlysecure.keychain.ui.dialog.SetPassphraseDialogFragment;
import org.sufficientlysecure.keychain.ui.util.Notify;
import org.sufficientlysecure.keychain.util.Log;
import org.sufficientlysecure.keychain.util.Passphrase;
import org.sufficientlysecure.keychain.util.operation.OperationHelper;

public class EditKeyFragment extends NewCryptoOperationFragment<SaveKeyringParcel, OperationResult>
        implements LoaderManager.LoaderCallbacks<Cursor> {

    public static final String ARG_DATA_URI = "uri";
    public static final String ARG_SAVE_KEYRING_PARCEL = "save_keyring_parcel";

    private ListView mUserIdsList;
    private ListView mSubkeysList;
    private ListView mUserIdsAddedList;
    private ListView mSubkeysAddedList;
    private View mChangePassphrase;
    private View mAddUserId;
    private View mAddSubkey;

    private static final int LOADER_ID_USER_IDS = 0;
    private static final int LOADER_ID_SUBKEYS = 1;

    
    private UserIdsAdapter mUserIdsAdapter;
    private SubkeysAdapter mSubkeysAdapter;

    
    private UserIdsAddedAdapter mUserIdsAddedAdapter;
    private SubkeysAddedAdapter mSubkeysAddedAdapter;

    private Uri mDataUri;

    private SaveKeyringParcel mSaveKeyringParcel;

    private String mPrimaryUserId;

    
    public static EditKeyFragment newInstance(Uri dataUri) {
        EditKeyFragment frag = new EditKeyFragment();

        Bundle args = new Bundle();
        args.putParcelable(ARG_DATA_URI, dataUri);

        frag.setArguments(args);

        return frag;
    }

    public static EditKeyFragment newInstance(SaveKeyringParcel saveKeyringParcel) {
        EditKeyFragment frag = new EditKeyFragment();

        Bundle args = new Bundle();
        args.putParcelable(ARG_SAVE_KEYRING_PARCEL, saveKeyringParcel);

        frag.setArguments(args);

        return frag;
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup superContainer, Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.edit_key_fragment, null);

        mUserIdsList = (ListView) view.findViewById(R.id.edit_key_user_ids);
        mSubkeysList = (ListView) view.findViewById(R.id.edit_key_keys);
        mUserIdsAddedList = (ListView) view.findViewById(R.id.edit_key_user_ids_added);
        mSubkeysAddedList = (ListView) view.findViewById(R.id.edit_key_subkeys_added);
        mChangePassphrase = view.findViewById(R.id.edit_key_action_change_passphrase);
        mAddUserId = view.findViewById(R.id.edit_key_action_add_user_id);
        mAddSubkey = view.findViewById(R.id.edit_key_action_add_key);

        return view;
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        super.setOperationHelper(
                new OperationHelper<SaveKeyringParcel, OperationResult>(this, R.string.progress_building_key) {

                    @Override
                    public SaveKeyringParcel createOperationInput() {
                        Log.d("PHILIP", "edit key creating operation input " + mSaveKeyringParcel);
                        return mSaveKeyringParcel;
                    }

                    @Override
                    protected void onCryptoOperationSuccess(OperationResult result) {
                        Log.d("PHILIP", "edit key success");
                        
                        Intent intent = new Intent();
                        intent.putExtra(OperationResult.EXTRA_RESULT, result);
                        getActivity().setResult(EditKeyActivity.RESULT_OK, intent);
                        getActivity().finish();
                    }
                }
        );

        ((EditKeyActivity) getActivity()).setFullScreenDialogDoneClose(
                R.string.btn_save,
                new OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        
                        if (mDataUri == null) {
                            returnKeyringParcel();
                        } else {
                            cryptoOperation(new CryptoInputParcel());
                        }
                    }
                }, new OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        getActivity().setResult(Activity.RESULT_CANCELED);
                        getActivity().finish();
                    }
                });

        Uri dataUri = getArguments().getParcelable(ARG_DATA_URI);
        SaveKeyringParcel saveKeyringParcel = getArguments().getParcelable(ARG_SAVE_KEYRING_PARCEL);
        if (dataUri == null && saveKeyringParcel == null) {
            Log.e(Constants.TAG, "Either a key Uri or ARG_SAVE_KEYRING_PARCEL is required!");
            getActivity().finish();
            return;
        }

        initView();
        if (dataUri != null) {
            loadData(dataUri);
        } else {
            loadSaveKeyringParcel(saveKeyringParcel);
        }
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        Log.e("PHILIP","Frament onActivityResult");
        super.onActivityResult(requestCode, resultCode, data);
    }

    private void loadSaveKeyringParcel(SaveKeyringParcel saveKeyringParcel) {
        mSaveKeyringParcel = saveKeyringParcel;
        mPrimaryUserId = saveKeyringParcel.mChangePrimaryUserId;

        mUserIdsAddedAdapter = new UserIdsAddedAdapter(getActivity(), mSaveKeyringParcel.mAddUserIds, true);
        mUserIdsAddedList.setAdapter(mUserIdsAddedAdapter);

        mSubkeysAddedAdapter = new SubkeysAddedAdapter(getActivity(), mSaveKeyringParcel.mAddSubKeys, true);
        mSubkeysAddedList.setAdapter(mSubkeysAddedAdapter);
    }

    private void loadData(Uri dataUri) {
        mDataUri = dataUri;

        Log.i(Constants.TAG, "mDataUri: " + mDataUri.toString());

        
        try {
            Uri secretUri = KeychainContract.KeyRings.buildUnifiedKeyRingUri(mDataUri);
            CachedPublicKeyRing keyRing =
                    new ProviderHelper(getActivity()).getCachedPublicKeyRing(secretUri);
            long masterKeyId = keyRing.getMasterKeyId();

            
            switch (keyRing.getSecretKeyType(masterKeyId)) {
                case GNU_DUMMY:
                    finishWithError(LogType.MSG_EK_ERROR_DUMMY);
                    return;
            }

            mSaveKeyringParcel = new SaveKeyringParcel(masterKeyId, keyRing.getFingerprint());
            mPrimaryUserId = keyRing.getPrimaryUserIdWithFallback();

        } catch (PgpKeyNotFoundException | NotFoundException e) {
            finishWithError(LogType.MSG_EK_ERROR_NOT_FOUND);
            return;
        }

        
        
        getLoaderManager().initLoader(LOADER_ID_USER_IDS, null, EditKeyFragment.this);
        getLoaderManager().initLoader(LOADER_ID_SUBKEYS, null, EditKeyFragment.this);

        mUserIdsAdapter = new UserIdsAdapter(getActivity(), null, 0, mSaveKeyringParcel);
        mUserIdsList.setAdapter(mUserIdsAdapter);

        
        mUserIdsAddedAdapter = new UserIdsAddedAdapter(getActivity(), mSaveKeyringParcel.mAddUserIds, false);
        mUserIdsAddedList.setAdapter(mUserIdsAddedAdapter);

        mSubkeysAdapter = new SubkeysAdapter(getActivity(), null, 0, mSaveKeyringParcel);
        mSubkeysList.setAdapter(mSubkeysAdapter);

        mSubkeysAddedAdapter = new SubkeysAddedAdapter(getActivity(), mSaveKeyringParcel.mAddSubKeys, false);
        mSubkeysAddedList.setAdapter(mSubkeysAddedAdapter);
    }

    private void initView() {
        mChangePassphrase.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                changePassphrase();
            }
        });

        mAddUserId.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                addUserId();
            }
        });

        mAddSubkey.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                addSubkey();
            }
        });

        mSubkeysList.setOnItemClickListener(new AdapterView.OnItemClickListener() {
            @Override
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                editSubkey(position);
            }
        });

        mUserIdsList.setOnItemClickListener(new AdapterView.OnItemClickListener() {
            @Override
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                editUserId(position);
            }
        });
    }

    public Loader<Cursor> onCreateLoader(int id, Bundle args) {

        switch (id) {
            case LOADER_ID_USER_IDS: {
                Uri baseUri = UserPackets.buildUserIdsUri(mDataUri);
                return new CursorLoader(getActivity(), baseUri,
                        UserIdsAdapter.USER_IDS_PROJECTION, null, null, null);
            }

            case LOADER_ID_SUBKEYS: {
                Uri baseUri = KeychainContract.Keys.buildKeysUri(mDataUri);
                return new CursorLoader(getActivity(), baseUri,
                        SubkeysAdapter.SUBKEYS_PROJECTION, null, null, null);
            }

            default:
                return null;
        }
    }

    public void onLoadFinished(Loader<Cursor> loader, Cursor data) {
        
        
        switch (loader.getId()) {
            case LOADER_ID_USER_IDS:
                mUserIdsAdapter.swapCursor(data);
                break;

            case LOADER_ID_SUBKEYS:
                mSubkeysAdapter.swapCursor(data);
                break;

        }
    }

    
    public void onLoaderReset(Loader<Cursor> loader) {
        switch (loader.getId()) {
            case LOADER_ID_USER_IDS:
                mUserIdsAdapter.swapCursor(null);
                break;
            case LOADER_ID_SUBKEYS:
                mSubkeysAdapter.swapCursor(null);
                break;
        }
    }

    private void changePassphrase() {



        
        Handler returnHandler = new Handler() {
            @Override
            public void handleMessage(Message message) {
                if (message.what == SetPassphraseDialogFragment.MESSAGE_OKAY) {
                    Bundle data = message.getData();

                    
                    mSaveKeyringParcel.mNewUnlock = new ChangeUnlockParcel(
                            (Passphrase) data.getParcelable(SetPassphraseDialogFragment.MESSAGE_NEW_PASSPHRASE),
                            null
                    );
                }
            }
        };

        
        Messenger messenger = new Messenger(returnHandler);

        SetPassphraseDialogFragment setPassphraseDialog = SetPassphraseDialogFragment.newInstance(
                messenger, R.string.title_change_passphrase);

        setPassphraseDialog.show(getActivity().getSupportFragmentManager(), "setPassphraseDialog");
    }

    private void editUserId(final int position) {
        final String userId = mUserIdsAdapter.getUserId(position);
        final boolean isRevoked = mUserIdsAdapter.getIsRevoked(position);
        final boolean isRevokedPending = mUserIdsAdapter.getIsRevokedPending(position);

        Handler returnHandler = new Handler() {
            @Override
            public void handleMessage(Message message) {
                switch (message.what) {
                    case EditUserIdDialogFragment.MESSAGE_CHANGE_PRIMARY_USER_ID:
                        
                        if (mSaveKeyringParcel.mChangePrimaryUserId != null
                                && mSaveKeyringParcel.mChangePrimaryUserId.equals(userId)) {
                            mSaveKeyringParcel.mChangePrimaryUserId = null;
                        } else {
                            mSaveKeyringParcel.mChangePrimaryUserId = userId;
                        }
                        break;
                    case EditUserIdDialogFragment.MESSAGE_REVOKE:
                        
                        if (mSaveKeyringParcel.mRevokeUserIds.contains(userId)) {
                            mSaveKeyringParcel.mRevokeUserIds.remove(userId);
                        } else {
                            mSaveKeyringParcel.mRevokeUserIds.add(userId);
                            
                            if (mSaveKeyringParcel.mChangePrimaryUserId != null
                                    && mSaveKeyringParcel.mChangePrimaryUserId.equals(userId)) {
                                mSaveKeyringParcel.mChangePrimaryUserId = null;
                            }
                        }
                        break;
                }
                getLoaderManager().getLoader(LOADER_ID_USER_IDS).forceLoad();
            }
        };

        
        final Messenger messenger = new Messenger(returnHandler);

        DialogFragmentWorkaround.INTERFACE.runnableRunDelayed(new Runnable() {
            public void run() {
                EditUserIdDialogFragment dialogFragment =
                        EditUserIdDialogFragment.newInstance(messenger, isRevoked, isRevokedPending);
                dialogFragment.show(getActivity().getSupportFragmentManager(), "editUserIdDialog");
            }
        });
    }

    private void editSubkey(final int position) {
        final long keyId = mSubkeysAdapter.getKeyId(position);

        Handler returnHandler = new Handler() {
            @Override
            public void handleMessage(Message message) {
                switch (message.what) {
                    case EditSubkeyDialogFragment.MESSAGE_CHANGE_EXPIRY:
                        editSubkeyExpiry(position);
                        break;
                    case EditSubkeyDialogFragment.MESSAGE_REVOKE:
                        
                        if (mSaveKeyringParcel.mRevokeSubKeys.contains(keyId)) {
                            mSaveKeyringParcel.mRevokeSubKeys.remove(keyId);
                        } else {
                            mSaveKeyringParcel.mRevokeSubKeys.add(keyId);
                        }
                        break;
                    case EditSubkeyDialogFragment.MESSAGE_STRIP: {
                        SecretKeyType secretKeyType = mSubkeysAdapter.getSecretKeyType(position);
                        if (secretKeyType == SecretKeyType.GNU_DUMMY) {
                            
                            break;
                        }

                        SubkeyChange change = mSaveKeyringParcel.getSubkeyChange(keyId);
                        if (change == null) {
                            mSaveKeyringParcel.mChangeSubKeys.add(new SubkeyChange(keyId, true, false));
                            break;
                        }
                        
                        change.mDummyStrip = !change.mDummyStrip;
                        if (change.mDummyStrip && change.mMoveKeyToCard) {
                            
                            change.mMoveKeyToCard = false;
                        }
                        break;
                    }
                    case EditSubkeyDialogFragment.MESSAGE_KEYTOCARD: {
                        Activity activity = EditKeyFragment.this.getActivity();
                        SecretKeyType secretKeyType = mSubkeysAdapter.getSecretKeyType(position);
                        if (secretKeyType == SecretKeyType.DIVERT_TO_CARD ||
                            secretKeyType == SecretKeyType.GNU_DUMMY) {
                            Notify.create(activity, R.string.edit_key_error_bad_nfc_stripped, Notify.Style.ERROR)
                                    .show((ViewGroup) activity.findViewById(R.id.import_snackbar));
                            break;
                        }
                        int algorithm = mSubkeysAdapter.getAlgorithm(position);
                        
                        if (algorithm != 1 && algorithm != 2 && algorithm != 3) {
                            Notify.create(activity, R.string.edit_key_error_bad_nfc_algo, Notify.Style.ERROR)
                                    .show((ViewGroup) activity.findViewById(R.id.import_snackbar));
                            break;
                        }
                        if (mSubkeysAdapter.getKeySize(position) != 2048) {
                            Notify.create(activity, R.string.edit_key_error_bad_nfc_size, Notify.Style.ERROR)
                                    .show((ViewGroup) activity.findViewById(R.id.import_snackbar));
                            break;
                        }


                        SubkeyChange change;
                        change = mSaveKeyringParcel.getSubkeyChange(keyId);
                        if (change == null) {
                            mSaveKeyringParcel.mChangeSubKeys.add(
                                    new SubkeyChange(keyId, false, true)
                            );
                            break;
                        }
                        
                        change.mMoveKeyToCard = !change.mMoveKeyToCard;
                        if (change.mMoveKeyToCard && change.mDummyStrip) {
                            
                            change.mDummyStrip = false;
                        }
                        break;
                    }
                }
                getLoaderManager().getLoader(LOADER_ID_SUBKEYS).forceLoad();
            }
        };

        
        final Messenger messenger = new Messenger(returnHandler);

        DialogFragmentWorkaround.INTERFACE.runnableRunDelayed(new Runnable() {
            public void run() {
                EditSubkeyDialogFragment dialogFragment =
                        EditSubkeyDialogFragment.newInstance(messenger);

                dialogFragment.show(getActivity().getSupportFragmentManager(), "editSubkeyDialog");
            }
        });
    }

    private void editSubkeyExpiry(final int position) {
        final long keyId = mSubkeysAdapter.getKeyId(position);
        final Long creationDate = mSubkeysAdapter.getCreationDate(position);
        final Long expiryDate = mSubkeysAdapter.getExpiryDate(position);

        Handler returnHandler = new Handler() {
            @Override
            public void handleMessage(Message message) {
                switch (message.what) {
                    case EditSubkeyExpiryDialogFragment.MESSAGE_NEW_EXPIRY:
                        mSaveKeyringParcel.getOrCreateSubkeyChange(keyId).mExpiry =
                                (Long) message.getData().getSerializable(
                                        EditSubkeyExpiryDialogFragment.MESSAGE_DATA_EXPIRY);
                        break;
                }
                getLoaderManager().getLoader(LOADER_ID_SUBKEYS).forceLoad();
            }
        };

        
        final Messenger messenger = new Messenger(returnHandler);

        DialogFragmentWorkaround.INTERFACE.runnableRunDelayed(new Runnable() {
            public void run() {
                EditSubkeyExpiryDialogFragment dialogFragment =
                        EditSubkeyExpiryDialogFragment.newInstance(messenger, creationDate, expiryDate);

                dialogFragment.show(getActivity().getSupportFragmentManager(), "editSubkeyExpiryDialog");
            }
        });
    }

    private void addUserId() {
        Handler returnHandler = new Handler() {
            @Override
            public void handleMessage(Message message) {
                if (message.what == SetPassphraseDialogFragment.MESSAGE_OKAY) {
                    Bundle data = message.getData();

                    
                    mUserIdsAddedAdapter.add(data
                            .getString(AddUserIdDialogFragment.MESSAGE_DATA_USER_ID));
                }
            }
        };

        
        Messenger messenger = new Messenger(returnHandler);

        
        String predefinedName = KeyRing.splitUserId(mPrimaryUserId).name;
        AddUserIdDialogFragment addUserIdDialog = AddUserIdDialogFragment.newInstance(messenger,
                predefinedName);

        addUserIdDialog.show(getActivity().getSupportFragmentManager(), "addUserIdDialog");
    }

    private void addSubkey() {
        boolean willBeMasterKey;
        if (mSubkeysAdapter != null) {
            willBeMasterKey = mSubkeysAdapter.getCount() == 0 && mSubkeysAddedAdapter.getCount() == 0;
        } else {
            willBeMasterKey = mSubkeysAddedAdapter.getCount() == 0;
        }

        AddSubkeyDialogFragment addSubkeyDialogFragment =
                AddSubkeyDialogFragment.newInstance(willBeMasterKey);
        addSubkeyDialogFragment
                .setOnAlgorithmSelectedListener(
                        new AddSubkeyDialogFragment.OnAlgorithmSelectedListener() {
                            @Override
                            public void onAlgorithmSelected(SaveKeyringParcel.SubkeyAdd newSubkey) {
                                mSubkeysAddedAdapter.add(newSubkey);
                            }
                        }
                );
        addSubkeyDialogFragment.show(getActivity().getSupportFragmentManager(), "addSubkeyDialog");
    }

    protected void returnKeyringParcel() {
        if (mSaveKeyringParcel.mAddUserIds.size() == 0) {
            Notify.create(getActivity(), R.string.edit_key_error_add_identity, Notify.Style.ERROR).show();
            return;
        }
        if (mSaveKeyringParcel.mAddSubKeys.size() == 0) {
            Notify.create(getActivity(), R.string.edit_key_error_add_subkey, Notify.Style.ERROR).show();
            return;
        }

        
        mSaveKeyringParcel.mChangePrimaryUserId = mSaveKeyringParcel.mAddUserIds.get(0);

        Intent returnIntent = new Intent();
        returnIntent.putExtra(EditKeyActivity.EXTRA_SAVE_KEYRING_PARCEL, mSaveKeyringParcel);
        getActivity().setResult(Activity.RESULT_OK, returnIntent);
        getActivity().finish();
    }

    
    void finishWithError(LogType reason) {
        
        Intent intent = new Intent();
        intent.putExtra(OperationResult.EXTRA_RESULT,
                new SingletonResult(SingletonResult.RESULT_ERROR, reason));

        
        getActivity().setResult(EditKeyActivity.RESULT_OK, intent);
        getActivity().finish();
    }
}

<code block>


package org.sufficientlysecure.keychain.ui;

import android.app.ProgressDialog;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.os.Message;
import android.os.Messenger;
import android.support.v4.app.Fragment;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;

import org.sufficientlysecure.keychain.Constants;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.intents.OpenKeychainIntents;
import org.sufficientlysecure.keychain.keyimport.ImportKeysListEntry;
import org.sufficientlysecure.keychain.keyimport.ParcelableKeyRing;
import org.sufficientlysecure.keychain.operations.results.ImportKeyResult;
import org.sufficientlysecure.keychain.operations.results.OperationResult;
import org.sufficientlysecure.keychain.service.ImportKeyringParcel;
import org.sufficientlysecure.keychain.service.KeychainNewService;
import org.sufficientlysecure.keychain.service.KeychainService;
import org.sufficientlysecure.keychain.service.input.CryptoInputParcel;
import org.sufficientlysecure.keychain.ui.base.BaseNfcActivity;
import org.sufficientlysecure.keychain.service.ServiceProgressHandler;
import org.sufficientlysecure.keychain.ui.util.KeyFormattingUtils;
import org.sufficientlysecure.keychain.ui.util.Notify;
import org.sufficientlysecure.keychain.util.Log;
import org.sufficientlysecure.keychain.util.ParcelableFileCache;
import org.sufficientlysecure.keychain.util.ParcelableFileCache.IteratorWithSize;
import org.sufficientlysecure.keychain.util.Preferences;
import org.sufficientlysecure.keychain.util.operation.ImportOperationHelper;
import org.sufficientlysecure.keychain.util.operation.OperationHelper;
import org.sufficientlysecure.keychain.util.orbot.OrbotHelper;

import java.io.IOException;
import java.util.ArrayList;

public class ImportKeysActivity extends BaseNfcActivity {

    public static final String ACTION_IMPORT_KEY = OpenKeychainIntents.IMPORT_KEY;
    public static final String ACTION_IMPORT_KEY_FROM_KEYSERVER = OpenKeychainIntents.IMPORT_KEY_FROM_KEYSERVER;
    public static final String ACTION_IMPORT_KEY_FROM_KEYSERVER_AND_RETURN_RESULT =
            Constants.INTENT_PREFIX + "IMPORT_KEY_FROM_KEY_SERVER_AND_RETURN_RESULT";
    public static final String ACTION_IMPORT_KEY_FROM_KEYSERVER_AND_RETURN_TO_SERVICE = Constants.INTENT_PREFIX
            + "IMPORT_KEY_FROM_KEY_SERVER_AND_RETURN";
    public static final String ACTION_IMPORT_KEY_FROM_FILE_AND_RETURN = Constants.INTENT_PREFIX
            + "IMPORT_KEY_FROM_FILE_AND_RETURN";

    
    public static final String ACTION_IMPORT_KEY_FROM_FILE = Constants.INTENT_PREFIX
            + "IMPORT_KEY_FROM_FILE";
    public static final String ACTION_SEARCH_KEYSERVER_FROM_URL = Constants.INTENT_PREFIX
            + "SEARCH_KEYSERVER_FROM_URL";
    public static final String EXTRA_RESULT = "result";

    
    public static final String EXTRA_KEY_BYTES = OpenKeychainIntents.IMPORT_EXTRA_KEY_EXTRA_KEY_BYTES;

    
    public static final String EXTRA_QUERY = OpenKeychainIntents.IMPORT_KEY_FROM_KEYSERVER_EXTRA_QUERY;
    public static final String EXTRA_KEY_ID = Constants.EXTRA_PREFIX + "EXTRA_KEY_ID";
    public static final String EXTRA_FINGERPRINT = OpenKeychainIntents.IMPORT_KEY_FROM_KEYSERVER_EXTRA_FINGERPRINT;

    
    public static final String EXTRA_PENDING_INTENT_DATA = "data";
    private Intent mPendingIntentData;

    
    private ImportKeysListFragment mListFragment;
    private Fragment mTopFragment;
    private View mImportButton;

    private Preferences.ProxyPrefs mProxyPrefs; 

    private OperationHelper mImportOperationHelper;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        mImportButton = findViewById(R.id.import_import);
        mImportButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                importKeys();
            }
        });

        handleActions(savedInstanceState, getIntent());
    }

    @Override
    protected void initLayout() {
        setContentView(R.layout.import_keys_activity);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (mImportOperationHelper != null) mImportOperationHelper.handleActivityResult(requestCode, resultCode, data);
        super.onActivityResult(requestCode, resultCode, data);
    }

    protected void handleActions(Bundle savedInstanceState, Intent intent) {
        String action = intent.getAction();
        Bundle extras = intent.getExtras();
        Uri dataUri = intent.getData();
        String scheme = intent.getScheme();

        if (extras == null) {
            extras = new Bundle();
        }

        if (action == null) {
            startCloudFragment(savedInstanceState, null, false, null);
            startListFragment(savedInstanceState, null, null, null, null);
            return;
        }

        if (Intent.ACTION_VIEW.equals(action)) {
            if (scheme.equals("http") || scheme.equals("https")) {
                action = ACTION_SEARCH_KEYSERVER_FROM_URL;
            } else {
                
                
                action = ACTION_IMPORT_KEY;
            }
        }

        switch (action) {
            case ACTION_IMPORT_KEY: {
                
                startFileFragment(savedInstanceState);

                if (dataUri != null) {
                    
                    startListFragment(savedInstanceState, null, dataUri, null, null);
                } else if (extras.containsKey(EXTRA_KEY_BYTES)) {
                    byte[] importData = extras.getByteArray(EXTRA_KEY_BYTES);

                    
                    startListFragment(savedInstanceState, importData, null, null, null);
                }
                break;
            }
            case ACTION_IMPORT_KEY_FROM_KEYSERVER:
            case ACTION_IMPORT_KEY_FROM_KEYSERVER_AND_RETURN_TO_SERVICE:
            case ACTION_IMPORT_KEY_FROM_KEYSERVER_AND_RETURN_RESULT: {

                
                if (extras.containsKey(EXTRA_PENDING_INTENT_DATA)) {
                    mPendingIntentData = extras.getParcelable(EXTRA_PENDING_INTENT_DATA);
                }
                if (extras.containsKey(EXTRA_QUERY) || extras.containsKey(EXTRA_KEY_ID)) {
                    

                    String query = null;
                    if (extras.containsKey(EXTRA_QUERY)) {
                        query = extras.getString(EXTRA_QUERY);
                    } else if (extras.containsKey(EXTRA_KEY_ID)) {
                        long keyId = extras.getLong(EXTRA_KEY_ID, 0);
                        if (keyId != 0) {
                            query = KeyFormattingUtils.convertKeyIdToHex(keyId);
                        }
                    }

                    if (query != null && query.length() > 0) {
                        
                        startCloudFragment(savedInstanceState, query, false, null);

                        
                        startListFragment(savedInstanceState, null, null, query, null);
                    } else {
                        Log.e(Constants.TAG, "Query is empty!");
                        return;
                    }
                } else if (extras.containsKey(EXTRA_FINGERPRINT)) {
                    

                    String fingerprint = extras.getString(EXTRA_FINGERPRINT);
                    if (isFingerprintValid(fingerprint)) {
                        String query = "0x" + fingerprint;

                        
                        startCloudFragment(savedInstanceState, query, true, null);

                        
                        startListFragment(savedInstanceState, null, null, query, null);
                    }
                } else {
                    Log.e(Constants.TAG,
                            "IMPORT_KEY_FROM_KEYSERVER action needs to contain the 'query', 'key_id', or " +
                                    "'fingerprint' extra!"
                    );
                    return;
                }
                break;
            }
            case ACTION_IMPORT_KEY_FROM_FILE: {
                
                startFileFragment(savedInstanceState);

                
                startListFragment(savedInstanceState, null, null, null, null);
                break;
            }
            case ACTION_SEARCH_KEYSERVER_FROM_URL: {
                
                String query = dataUri.getQueryParameter("search");
                String keyserver = dataUri.getAuthority();
                
                if (query == null) {
                    Notify.create(this, R.string.import_url_warn_no_search_parameter, Notify.LENGTH_INDEFINITE,
                            Notify.Style.WARN).show(mTopFragment);
                    
                    startCloudFragment(savedInstanceState, null, false, keyserver);
                    
                    
                    
                    startListFragment(savedInstanceState, null, null, null, null);
                } else {
                    
                    startCloudFragment(savedInstanceState, query, false, keyserver);
                    
                    startListFragment(savedInstanceState, null, null, query, keyserver);
                }
                break;
            }
            case ACTION_IMPORT_KEY_FROM_FILE_AND_RETURN: {
                
                startFileFragment(savedInstanceState);

                
                startListFragment(savedInstanceState, null, null, null, null);
                break;
            }
            default: {
                startCloudFragment(savedInstanceState, null, false, null);
                startListFragment(savedInstanceState, null, null, null, null);
                break;
            }
        }
    }


    
    private void startListFragment(Bundle savedInstanceState, byte[] bytes, Uri dataUri,
                                   String serverQuery, String keyserver) {
        
        
        
        if (mListFragment != null) {
            return;
        }

        mListFragment = ImportKeysListFragment.newInstance(bytes, dataUri, serverQuery, false,
                keyserver);

        
        
        getSupportFragmentManager().beginTransaction()
                .replace(R.id.import_keys_list_container, mListFragment)
                .commitAllowingStateLoss();
        
        getSupportFragmentManager().executePendingTransactions();
    }

    private void startFileFragment(Bundle savedInstanceState) {
        
        
        
        if (mTopFragment != null) {
            return;
        }

        
        mTopFragment = ImportKeysFileFragment.newInstance();

        
        
        getSupportFragmentManager().beginTransaction()
                .replace(R.id.import_keys_top_container, mTopFragment)
                .commitAllowingStateLoss();
        
        getSupportFragmentManager().executePendingTransactions();
    }

    

    private void startCloudFragment(Bundle savedInstanceState, String query, boolean disableQueryEdit, String
            keyserver) {
        
        
        
        if (mTopFragment != null) {
            return;
        }

        
        mTopFragment = ImportKeysCloudFragment.newInstance(query, disableQueryEdit, keyserver);

        
        
        getSupportFragmentManager().beginTransaction()
                .replace(R.id.import_keys_top_container, mTopFragment)
                .commitAllowingStateLoss();
        
        getSupportFragmentManager().executePendingTransactions();
    }

    private boolean isFingerprintValid(String fingerprint) {
        if (fingerprint == null || fingerprint.length() < 40) {
            Notify.create(this, R.string.import_qr_code_too_short_fingerprint, Notify.Style.ERROR)
                    .show((ViewGroup) findViewById(R.id.import_snackbar));
            return false;
        } else {
            return true;
        }
    }

    public void loadCallback(final ImportKeysListFragment.LoaderState loaderState) {
        if (loaderState instanceof ImportKeysListFragment.CloudLoaderState) {
            Preferences.ProxyPrefs proxyPrefs =
                    mProxyPrefs == null ? Preferences.getPreferences(this).getProxyPrefs() : mProxyPrefs;
            
            
            Runnable ignoreTor = new Runnable() {
                @Override
                public void run() {
                    
                    mProxyPrefs = new Preferences.ProxyPrefs(false, false, null, -1, null);
                    mListFragment.loadNew(loaderState, mProxyPrefs.parcelableProxy);
                }
            };
            if (OrbotHelper.isOrbotInRequiredState(R.string.orbot_ignore_tor, ignoreTor, proxyPrefs, this)) {
                mListFragment.loadNew(loaderState, proxyPrefs.parcelableProxy);
            }
        } else if (loaderState instanceof ImportKeysListFragment.BytesLoaderState) { 
            mListFragment.loadNew(loaderState, mProxyPrefs.parcelableProxy);
        }
    }

    private void handleResult(ImportKeyResult result) {
            if (result == null) {
                Log.e(Constants.TAG, "result == null");
                return;
            }

            if (ACTION_IMPORT_KEY_FROM_KEYSERVER_AND_RETURN_RESULT.equals(getIntent().getAction())
                    || ACTION_IMPORT_KEY_FROM_FILE_AND_RETURN.equals(getIntent().getAction())) {
                Intent intent = new Intent();
                intent.putExtra(ImportKeyResult.EXTRA_RESULT, result);
                ImportKeysActivity.this.setResult(RESULT_OK, intent);
                ImportKeysActivity.this.finish();
                return;
            }
            if (ACTION_IMPORT_KEY_FROM_KEYSERVER_AND_RETURN_TO_SERVICE.equals(getIntent().getAction())) {
                ImportKeysActivity.this.setResult(RESULT_OK, mPendingIntentData);
                ImportKeysActivity.this.finish();
                return;
            }

            result.createNotify(ImportKeysActivity.this)
                    .show((ViewGroup) findViewById(R.id.import_snackbar));
    }

    
    public void importKeys() {

        if (mListFragment.getSelectedEntries().size() == 0) {
            Notify.create(this, R.string.error_nothing_import_selected, Notify.Style.ERROR)
                    .show((ViewGroup) findViewById(R.id.import_snackbar));
            return;
        }

        ArrayList<ParcelableKeyRing> keyList = null;
        String keyserver = null;
        CryptoInputParcel cryptoInput = new CryptoInputParcel();

        ImportKeysListFragment.LoaderState ls = mListFragment.getLoaderState();
        if (ls instanceof ImportKeysListFragment.BytesLoaderState) {
            Log.d(Constants.TAG, "importKeys started");

            
            IteratorWithSize<ParcelableKeyRing> selectedEntries = mListFragment.getSelectedData();

            
            
            
            try {
                
                
                ParcelableFileCache<ParcelableKeyRing> cache =
                        new ParcelableFileCache<>(this, "key_import.pcl");
                cache.writeCache(selectedEntries);

            } catch (IOException e) {
                Log.e(Constants.TAG, "Problem writing cache file", e);
                Notify.create(this, "Problem writing cache file!", Notify.Style.ERROR)
                        .show((ViewGroup) findViewById(R.id.import_snackbar));
            }
        } else if (ls instanceof ImportKeysListFragment.CloudLoaderState) {
            ImportKeysListFragment.CloudLoaderState sls = (ImportKeysListFragment.CloudLoaderState) ls;

            
            keyList = new ArrayList<>();
            {
                
                ArrayList<ImportKeysListEntry> entries = mListFragment.getSelectedEntries();
                for (ImportKeysListEntry entry : entries) {
                    keyList.add(new ParcelableKeyRing(
                                    entry.getFingerprintHex(), entry.getKeyIdHex(), entry.getExtraData())
                    );
                }
            }

            keyserver = sls.mCloudPrefs.keyserver;

            if (mProxyPrefs != null) { 
                cryptoInput = new CryptoInputParcel(mProxyPrefs.parcelableProxy);
            }
        }

        mImportOperationHelper = new ImportOperationHelper(this, R.string.progress_importing, keyList, keyserver) {
            @Override
            protected void onCryptoOperationSuccess(ImportKeyResult result) {
                handleResult(result);
            }
        };

        mImportOperationHelper.cryptoOperation(cryptoInput);
    }

    @Override
    protected void onNfcPerform() throws IOException {
        
        super.onNfcPerform();
        
        finish();
    }
}

<code block>


package org.sufficientlysecure.keychain.ui;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Handler;
import android.os.Messenger;
import android.support.v4.app.DialogFragment;
import android.support.v4.app.FragmentActivity;
import android.text.InputType;
import android.text.method.PasswordTransformationMethod;
import android.view.*;
import android.view.inputmethod.EditorInfo;
import android.view.inputmethod.InputMethodManager;
import android.widget.Button;
import android.widget.EditText;
import android.widget.TextView;
import android.widget.Toast;
import org.sufficientlysecure.keychain.Constants;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.compatibility.DialogFragmentWorkaround;
import org.sufficientlysecure.keychain.pgp.CanonicalizedSecretKey;
import org.sufficientlysecure.keychain.pgp.CanonicalizedSecretKeyRing;
import org.sufficientlysecure.keychain.pgp.KeyRing;
import org.sufficientlysecure.keychain.pgp.exception.PgpGeneralException;
import org.sufficientlysecure.keychain.pgp.exception.PgpKeyNotFoundException;
import org.sufficientlysecure.keychain.provider.CachedPublicKeyRing;
import org.sufficientlysecure.keychain.provider.KeychainContract;
import org.sufficientlysecure.keychain.provider.ProviderHelper;
import org.sufficientlysecure.keychain.remote.CryptoInputParcelCacheService;
import org.sufficientlysecure.keychain.service.PassphraseCacheService;
import org.sufficientlysecure.keychain.service.input.CryptoInputParcel;
import org.sufficientlysecure.keychain.service.input.RequiredInputParcel;
import org.sufficientlysecure.keychain.ui.dialog.CustomAlertDialogBuilder;
import org.sufficientlysecure.keychain.ui.dialog.OrbotStartDialogFragment;
import org.sufficientlysecure.keychain.util.Log;
import org.sufficientlysecure.keychain.util.Passphrase;
import org.sufficientlysecure.keychain.util.Preferences;
import org.sufficientlysecure.keychain.util.orbot.OrbotHelper;


public class OrbotRequiredDialogActivity extends FragmentActivity {

    public static final String RESULT_IGNORE_TOR = "result_ignore_tor";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        showDialog();
    }

    
    public void showDialog() {
        DialogFragmentWorkaround.INTERFACE.runnableRunDelayed(new Runnable() {
            public void run() {
                Runnable ignoreTor = new Runnable() {
                    @Override
                    public void run() {
                        Intent intent = new Intent();
                        intent.putExtra(RESULT_IGNORE_TOR, true);
                        setResult(RESULT_OK, intent);
                        finish();
                    }
                };
                if (OrbotHelper.isOrbotInRequiredState(R.string.orbot_ignore_tor, ignoreTor,
                        OrbotRequiredDialogActivity.this)) {
                    
                    Intent intent = new Intent();
                    intent.putExtra(RESULT_IGNORE_TOR, true);
                    setResult(RESULT_OK, intent);
                    finish();
                }
            }
        });
    }
}

<code block>



package org.sufficientlysecure.keychain.ui.dialog;

import android.app.Activity;
import android.app.Dialog;
import android.content.DialogInterface;
import android.os.Bundle;
import android.os.Message;
import android.os.Messenger;
import android.os.RemoteException;
import android.support.v4.app.DialogFragment;

import android.view.ContextThemeWrapper;
import org.sufficientlysecure.keychain.Constants;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.util.Log;
import org.sufficientlysecure.keychain.util.orbot.OrbotHelper;


public class OrbotStartDialogFragment extends DialogFragment {
    private static final String ARG_MESSENGER = "messenger";
    private static final String ARG_TITLE = "title";
    private static final String ARG_MESSAGE = "message";
    private static final String ARG_MIDDLE_BUTTON = "middleButton";

    public static final int MESSAGE_MIDDLE_BUTTON = 1;

    public static OrbotStartDialogFragment newInstance(Messenger messenger, int title, int message, int middleButton) {
        Bundle args = new Bundle();
        args.putParcelable(ARG_MESSENGER, messenger);
        args.putInt(ARG_TITLE, title);
        args.putInt(ARG_MESSAGE, message);
        args.putInt(ARG_MIDDLE_BUTTON, middleButton);

        OrbotStartDialogFragment fragment = new OrbotStartDialogFragment();
        fragment.setArguments(args);

        return fragment;
    }

    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {

        final Messenger messenger = getArguments().getParcelable(ARG_MESSENGER);
        int title = getArguments().getInt(ARG_TITLE);
        final int message = getArguments().getInt(ARG_MESSAGE);
        int middleButton = getArguments().getInt(ARG_MIDDLE_BUTTON);
        final Activity activity = getActivity();

        
        
        ContextThemeWrapper theme = new ContextThemeWrapper(activity,
                R.style.Theme_AppCompat_Light_Dialog);

        CustomAlertDialogBuilder builder = new CustomAlertDialogBuilder(theme);
        builder.setTitle(title).setMessage(message);

        builder.setNegativeButton(R.string.orbot_start_dialog_cancel, new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {

            }
        });

        builder.setPositiveButton(R.string.orbot_start_dialog_start, new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                getActivity().startActivityForResult(OrbotHelper.getOrbotStartIntent(), 1);
            }
        });

        builder.setNeutralButton(middleButton, new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                Message msg = new Message();
                msg.what = MESSAGE_MIDDLE_BUTTON;
                try {
                    messenger.send(msg);
                } catch (RemoteException e) {
                    Log.w(Constants.TAG, "Exception sending message, Is handler present?", e);
                } catch (NullPointerException e) {
                    Log.w(Constants.TAG, "Messenger is null!", e);
                }
            }
        });

        return builder.show();
    }
}

<code block>


package org.sufficientlysecure.keychain.util;

import android.os.Parcel;
import android.os.Parcelable;

import java.net.InetSocketAddress;
import java.net.Proxy;


public class ParcelableProxy implements Parcelable {
    private String mProxyHost;
    private int mProxyPort;
    private int mProxyType;

    private final int TYPE_HTTP = 1;
    private final int TYPE_SOCKS = 2;

    public ParcelableProxy(String hostName, int port, Proxy.Type type) {
        mProxyHost = hostName;

        if (hostName == null) return; 

        mProxyPort = port;

        switch (type) {
            case HTTP: {
                mProxyType = TYPE_HTTP;
                break;
            }
            case SOCKS: {
                mProxyType = TYPE_SOCKS;
                break;
            }
        }
    }

    public Proxy getProxy() {
        if (mProxyHost == null) return null;

        Proxy.Type type = null;
        switch (mProxyType) {
            case TYPE_HTTP:
                type = Proxy.Type.HTTP;
                break;
            case TYPE_SOCKS:
                type = Proxy.Type.SOCKS;
                break;
        }
        return new Proxy(type, new InetSocketAddress(mProxyHost, mProxyPort));
    }

    protected ParcelableProxy(Parcel in) {
        mProxyHost = in.readString();
        mProxyPort = in.readInt();
        mProxyType = in.readInt();
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeString(mProxyHost);
        dest.writeInt(mProxyPort);
        dest.writeInt(mProxyType);
    }

    @SuppressWarnings("unused")
    public static final Parcelable.Creator<ParcelableProxy> CREATOR = new Parcelable.Creator<ParcelableProxy>() {
        @Override
        public ParcelableProxy createFromParcel(Parcel in) {
            return new ParcelableProxy(in);
        }

        @Override
        public ParcelableProxy[] newArray(int size) {
            return new ParcelableProxy[size];
        }
    };
}

<code block>


package org.sufficientlysecure.keychain.util.orbot;

import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.os.Handler;
import android.os.Message;
import android.os.Messenger;
import android.support.v4.app.DialogFragment;
import android.support.v4.app.FragmentActivity;

import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.ui.dialog.SupportInstallDialogFragment;
import org.sufficientlysecure.keychain.ui.dialog.OrbotStartDialogFragment;
import org.sufficientlysecure.keychain.ui.dialog.PreferenceInstallDialogFragment;
import org.sufficientlysecure.keychain.util.Preferences;


public class OrbotHelper {

    public final static String ORBOT_PACKAGE_NAME = "org.torproject.android";
    public final static String TOR_BIN_PATH = "/data/data/org.torproject.android/app_bin/tor";

    public final static String ACTION_START_TOR = "org.torproject.android.START_TOR";

    public static boolean isOrbotRunning() {
        int procId = TorServiceUtils.findProcessId(TOR_BIN_PATH);

        return (procId != -1);
    }

    public static boolean isOrbotInstalled(Context context) {
        return isAppInstalled(ORBOT_PACKAGE_NAME, context);
    }

    public static boolean isOrbotInstalledAndRunning(Context context) {
        return isOrbotRunning() && isOrbotInstalled(context);
    }

    private static boolean isAppInstalled(String uri, Context context) {
        PackageManager pm = context.getPackageManager();

        boolean installed;
        try {
            pm.getPackageInfo(uri, PackageManager.GET_ACTIVITIES);
            installed = true;
        } catch (PackageManager.NameNotFoundException e) {
            installed = false;
        }
        return installed;
    }

    
    public static android.app.DialogFragment getPreferenceInstallDialogFragment() {
        return PreferenceInstallDialogFragment.newInstance(R.string.orbot_install_dialog_title,
                R.string.orbot_install_dialog_content, ORBOT_PACKAGE_NAME);
    }

    public static DialogFragment getInstallDialogFragment() {
        return SupportInstallDialogFragment.newInstance(R.string.orbot_install_dialog_title,
                R.string.orbot_install_dialog_content, ORBOT_PACKAGE_NAME);
    }

    public static DialogFragment getInstallDialogFragmentWithThirdButton(Messenger messenger, int middleButton) {
        return SupportInstallDialogFragment.newInstance(messenger, R.string.orbot_install_dialog_title,
                R.string.orbot_install_dialog_content, ORBOT_PACKAGE_NAME, middleButton, true);
    }

    public static DialogFragment getOrbotStartDialogFragment(Messenger messenger, int middleButton) {
        return OrbotStartDialogFragment.newInstance(messenger, R.string.orbot_start_dialog_title, R.string
                        .orbot_start_dialog_content,
                middleButton);
    }

    public static Intent getOrbotStartIntent() {
        Intent intent = new Intent(ACTION_START_TOR);
        intent.setPackage(ORBOT_PACKAGE_NAME);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        return intent;
    }

    
    public static boolean isOrbotInRequiredState(int middleButton, final Runnable middleButtonRunnable,
                                                 Preferences.ProxyPrefs proxyPrefs, FragmentActivity fragmentActivity) {
        Handler ignoreTorHandler = new Handler() {
            @Override
            public void handleMessage(Message msg) {
                
                middleButtonRunnable.run();
            }
        };

        if (!proxyPrefs.torEnabled) {
            return true;
        }

        if (!OrbotHelper.isOrbotInstalled(fragmentActivity)) {

            OrbotHelper.getInstallDialogFragmentWithThirdButton(
                    new Messenger(ignoreTorHandler),
                    middleButton
            ).show(fragmentActivity.getSupportFragmentManager(), "OrbotHelperOrbotInstallDialog");

            return false;
        } else if (!OrbotHelper.isOrbotRunning()) {

            OrbotHelper.getOrbotStartDialogFragment(new Messenger(ignoreTorHandler),
                    middleButton)
                    .show(fragmentActivity.getSupportFragmentManager(), "OrbotHelperOrbotStartDialog");

            return false;
        } else {
            return true;
        }
    }

    
    public static Intent getRequiredIntent(Context context) {
        if (!isOrbotInstalled(context)) {

        }
        if (!isOrbotRunning()) {

        }
        return null;
    }
}

<code block>


package org.sufficientlysecure.keychain.util.operation;

import android.support.v4.app.FragmentActivity;
import org.sufficientlysecure.keychain.keyimport.ParcelableKeyRing;
import org.sufficientlysecure.keychain.operations.results.ImportKeyResult;
import org.sufficientlysecure.keychain.service.ImportKeyringParcel;

import java.util.ArrayList;

public abstract class ImportOperationHelper extends OperationHelper<ImportKeyringParcel, ImportKeyResult> {
    private ArrayList<ParcelableKeyRing> mKeyList;
    private String mKeyserver;

    public ImportOperationHelper(FragmentActivity activity, ArrayList<ParcelableKeyRing> keyList, String keyserver) {
        super(activity);
        mKeyList = keyList;
        mKeyserver = keyserver;
    }
    @Override
    public ImportKeyringParcel createOperationInput() {
        return new ImportKeyringParcel(mKeyList, mKeyserver);
    }
}

<code block>


package org.sufficientlysecure.keychain.util.operation;

import android.app.Activity;
import android.app.ProgressDialog;
import android.content.Intent;
import android.os.Bundle;
import android.os.Message;
import android.os.Messenger;
import android.os.Parcelable;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentActivity;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.operations.results.InputPendingResult;
import org.sufficientlysecure.keychain.operations.results.OperationResult;
import org.sufficientlysecure.keychain.service.KeychainNewService;
import org.sufficientlysecure.keychain.service.KeychainService;
import org.sufficientlysecure.keychain.service.ServiceProgressHandler;
import org.sufficientlysecure.keychain.service.input.CryptoInputParcel;
import org.sufficientlysecure.keychain.service.input.RequiredInputParcel;
import org.sufficientlysecure.keychain.ui.NfcOperationActivity;
import org.sufficientlysecure.keychain.ui.OrbotRequiredDialogActivity;
import org.sufficientlysecure.keychain.ui.PassphraseDialogActivity;
import org.sufficientlysecure.keychain.ui.dialog.ProgressDialogFragment;
import org.sufficientlysecure.keychain.util.Log;


public abstract class OperationHelper<T extends Parcelable, S extends OperationResult> {
    public static final int REQUEST_CODE_PASSPHRASE = 0x00008001;
    public static final int REQUEST_CODE_NFC = 0x00008002;
    public static final int REQUEST_ENABLE_ORBOT = 0x00008004;

    private FragmentActivity mActivity;
    private Fragment mFragment;

    private boolean mUseFragment;

    
    public OperationHelper(FragmentActivity activity) {
        mActivity = activity;
        mUseFragment = false;
    }

    
    public OperationHelper(Fragment fragment) {
        mFragment = fragment;
        mActivity = fragment.getActivity();
        mUseFragment = true;
    }

    private void initiateInputActivity(RequiredInputParcel requiredInput) {

        Log.d("PHILIP", "Initating input " + requiredInput.mType);
        switch (requiredInput.mType) {
            case NFC_KEYTOCARD:
            case NFC_DECRYPT:
            case NFC_SIGN: {
                Intent intent = new Intent(mActivity, NfcOperationActivity.class);
                intent.putExtra(NfcOperationActivity.EXTRA_REQUIRED_INPUT, requiredInput);
                if (mUseFragment) {
                    mFragment.startActivityForResult(intent, REQUEST_CODE_NFC);
                } else {
                    mActivity.startActivityForResult(intent, REQUEST_CODE_NFC);
                }
                return;
            }

            case PASSPHRASE:
            case PASSPHRASE_SYMMETRIC: {
                Intent intent = new Intent(mActivity, PassphraseDialogActivity.class);
                intent.putExtra(PassphraseDialogActivity.EXTRA_REQUIRED_INPUT, requiredInput);
                if (mUseFragment) {
                    mFragment.startActivityForResult(intent, REQUEST_CODE_PASSPHRASE);
                } else {
                    mActivity.startActivityForResult(intent, REQUEST_CODE_PASSPHRASE);
                }
                return;
            }

            case ENABLE_ORBOT: {
                Intent intent = new Intent(mActivity, OrbotRequiredDialogActivity.class);
                if (mUseFragment) {
                    mFragment.startActivityForResult(intent, REQUEST_ENABLE_ORBOT);
                } else {
                    mActivity.startActivityForResult(intent, REQUEST_ENABLE_ORBOT);
                }
                return;
            }
        }

        throw new RuntimeException("Unhandled pending result!");
    }

    
    public boolean handleActivityResult(int requestCode, int resultCode, Intent data) {
        Log.d("PHILIP", "received activity result in OperationHelper");
        if (resultCode == Activity.RESULT_CANCELED) {
            onCryptoOperationCancelled();
            return true;
        }

        switch (requestCode) {
            case REQUEST_CODE_PASSPHRASE: {
                if (resultCode == Activity.RESULT_OK && data != null) {
                    CryptoInputParcel cryptoInput =
                            data.getParcelableExtra(PassphraseDialogActivity.RESULT_CRYPTO_INPUT);
                    cryptoOperation(cryptoInput);
                    return true;
                }
                break;
            }

            case REQUEST_CODE_NFC: {
                if (resultCode == Activity.RESULT_OK && data != null) {
                    CryptoInputParcel cryptoInput =
                            data.getParcelableExtra(NfcOperationActivity.RESULT_DATA);
                    cryptoOperation(cryptoInput);
                    return true;
                }
                break;
            }

            case REQUEST_ENABLE_ORBOT: {
                if (resultCode == Activity.RESULT_OK && data != null) {
                    if (data.getBooleanExtra(OrbotRequiredDialogActivity.RESULT_IGNORE_TOR, false)) {
                        cryptoOperation(new CryptoInputParcel());
                    }
                    return true;
                }
                break;
            }

            default: {
                return false;
            }
        }
        return true;
    }

    protected void dismissProgress() {
        ProgressDialogFragment progressDialogFragment =
                (ProgressDialogFragment) mActivity.getSupportFragmentManager().findFragmentByTag("progressDialog");

        if (progressDialogFragment == null) {
            return;
        }

        progressDialogFragment.dismissAllowingStateLoss();

    }

    public abstract T createOperationInput();

    public void cryptoOperation(CryptoInputParcel cryptoInput) {

        T operationInput = createOperationInput();
        if (operationInput == null) {
            return;
        }

        
        Intent intent = new Intent(mActivity, KeychainNewService.class);

        intent.putExtra(KeychainNewService.EXTRA_OPERATION_INPUT, operationInput);
        intent.putExtra(KeychainNewService.EXTRA_CRYPTO_INPUT, cryptoInput);

        ServiceProgressHandler saveHandler = new ServiceProgressHandler(mActivity) {
            @Override
            public void handleMessage(Message message) {
                
                super.handleMessage(message);

                if (message.arg1 == MessageStatus.OKAY.ordinal()) {

                    
                    Bundle returnData = message.getData();
                    if (returnData == null) {
                        return;
                    }

                    final OperationResult result =
                            returnData.getParcelable(OperationResult.EXTRA_RESULT);

                    onHandleResult(result);
                }
            }
        };

        
        Messenger messenger = new Messenger(saveHandler);
        intent.putExtra(KeychainService.EXTRA_MESSENGER, messenger);

        saveHandler.showProgressDialog(
                mActivity.getString(R.string.progress_building_key),
                ProgressDialog.STYLE_HORIZONTAL, false);

        mActivity.startService(intent);

    }

    public void cryptoOperation() {
        cryptoOperation(new CryptoInputParcel());
    }

    protected void onCryptoOperationResult(S result) {
        Log.d("PHILIP", "cryptoResult " + result.success());
        if (result.success()) {
            onCryptoOperationSuccess(result);
        } else {
            onCryptoOperationError(result);
        }
    }

    abstract protected void onCryptoOperationSuccess(S result);

    protected void onCryptoOperationError(S result) {
        result.createNotify(mActivity).show();
    }

    protected void onCryptoOperationCancelled() {
    }

    public void onHandleResult(OperationResult result) {
        Log.d("PHILIP", "Handling result in OperationHelper");

        if (result instanceof InputPendingResult) {
            Log.d("PHILIP", "is pending result");
            InputPendingResult pendingResult = (InputPendingResult) result;
            if (pendingResult.isPending()) {

                Log.d("PHILIP", "Is pending");
                RequiredInputParcel requiredInput = pendingResult.getRequiredInputParcel();
                initiateInputActivity(requiredInput);
                return;
            }
        }

        dismissProgress();

        try {
            
            onCryptoOperationResult((S) result);
        } catch (ClassCastException e) {
            throw new AssertionError("bad return class ("
                    + result.getClass().getSimpleName() + "), this is a programming error!");
        }

    }
}

<code block>


package org.sufficientlysecure.keychain.ui;

import android.app.Activity;
import android.content.Intent;
import android.database.Cursor;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.os.Messenger;
import android.support.v4.app.LoaderManager;
import android.support.v4.content.CursorLoader;
import android.support.v4.content.Loader;
import android.view.LayoutInflater;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.ListView;

import org.sufficientlysecure.keychain.Constants;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.compatibility.DialogFragmentWorkaround;
import org.sufficientlysecure.keychain.operations.results.OperationResult;
import org.sufficientlysecure.keychain.operations.results.OperationResult.LogType;
import org.sufficientlysecure.keychain.operations.results.SingletonResult;
import org.sufficientlysecure.keychain.pgp.CanonicalizedSecretKey.SecretKeyType;
import org.sufficientlysecure.keychain.pgp.KeyRing;
import org.sufficientlysecure.keychain.pgp.exception.PgpKeyNotFoundException;
import org.sufficientlysecure.keychain.provider.CachedPublicKeyRing;
import org.sufficientlysecure.keychain.provider.KeychainContract;
import org.sufficientlysecure.keychain.provider.KeychainContract.UserPackets;
import org.sufficientlysecure.keychain.provider.ProviderHelper;
import org.sufficientlysecure.keychain.provider.ProviderHelper.NotFoundException;
import org.sufficientlysecure.keychain.service.SaveKeyringParcel;
import org.sufficientlysecure.keychain.service.SaveKeyringParcel.ChangeUnlockParcel;
import org.sufficientlysecure.keychain.service.SaveKeyringParcel.SubkeyChange;
import org.sufficientlysecure.keychain.service.input.CryptoInputParcel;
import org.sufficientlysecure.keychain.ui.adapter.SubkeysAdapter;
import org.sufficientlysecure.keychain.ui.adapter.SubkeysAddedAdapter;
import org.sufficientlysecure.keychain.ui.adapter.UserIdsAdapter;
import org.sufficientlysecure.keychain.ui.adapter.UserIdsAddedAdapter;
import org.sufficientlysecure.keychain.ui.base.NewCryptoOperationFragment;
import org.sufficientlysecure.keychain.ui.dialog.AddSubkeyDialogFragment;
import org.sufficientlysecure.keychain.ui.dialog.AddUserIdDialogFragment;
import org.sufficientlysecure.keychain.ui.dialog.EditSubkeyDialogFragment;
import org.sufficientlysecure.keychain.ui.dialog.EditSubkeyExpiryDialogFragment;
import org.sufficientlysecure.keychain.ui.dialog.EditUserIdDialogFragment;
import org.sufficientlysecure.keychain.ui.dialog.SetPassphraseDialogFragment;
import org.sufficientlysecure.keychain.ui.util.Notify;
import org.sufficientlysecure.keychain.util.Log;
import org.sufficientlysecure.keychain.util.Passphrase;
import org.sufficientlysecure.keychain.util.operation.OperationHelper;

public class EditKeyFragment extends NewCryptoOperationFragment<SaveKeyringParcel, OperationResult>
        implements LoaderManager.LoaderCallbacks<Cursor> {

    public static final String ARG_DATA_URI = "uri";
    public static final String ARG_SAVE_KEYRING_PARCEL = "save_keyring_parcel";

    private ListView mUserIdsList;
    private ListView mSubkeysList;
    private ListView mUserIdsAddedList;
    private ListView mSubkeysAddedList;
    private View mChangePassphrase;
    private View mAddUserId;
    private View mAddSubkey;

    private static final int LOADER_ID_USER_IDS = 0;
    private static final int LOADER_ID_SUBKEYS = 1;

    
    private UserIdsAdapter mUserIdsAdapter;
    private SubkeysAdapter mSubkeysAdapter;

    
    private UserIdsAddedAdapter mUserIdsAddedAdapter;
    private SubkeysAddedAdapter mSubkeysAddedAdapter;

    private Uri mDataUri;

    private SaveKeyringParcel mSaveKeyringParcel;

    private String mPrimaryUserId;

    
    public static EditKeyFragment newInstance(Uri dataUri) {
        EditKeyFragment frag = new EditKeyFragment();

        Bundle args = new Bundle();
        args.putParcelable(ARG_DATA_URI, dataUri);

        frag.setArguments(args);

        return frag;
    }

    public static EditKeyFragment newInstance(SaveKeyringParcel saveKeyringParcel) {
        EditKeyFragment frag = new EditKeyFragment();

        Bundle args = new Bundle();
        args.putParcelable(ARG_SAVE_KEYRING_PARCEL, saveKeyringParcel);

        frag.setArguments(args);

        return frag;
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup superContainer, Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.edit_key_fragment, null);

        mUserIdsList = (ListView) view.findViewById(R.id.edit_key_user_ids);
        mSubkeysList = (ListView) view.findViewById(R.id.edit_key_keys);
        mUserIdsAddedList = (ListView) view.findViewById(R.id.edit_key_user_ids_added);
        mSubkeysAddedList = (ListView) view.findViewById(R.id.edit_key_subkeys_added);
        mChangePassphrase = view.findViewById(R.id.edit_key_action_change_passphrase);
        mAddUserId = view.findViewById(R.id.edit_key_action_add_user_id);
        mAddSubkey = view.findViewById(R.id.edit_key_action_add_key);

        return view;
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        super.setOperationHelper(
                new OperationHelper<SaveKeyringParcel, OperationResult>(this) {

                    @Override
                    public SaveKeyringParcel createOperationInput() {
                        Log.d("PHILIP", "edit key creating operation input " + mSaveKeyringParcel);
                        return mSaveKeyringParcel;
                    }

                    @Override
                    protected void onCryptoOperationSuccess(OperationResult result) {
                        Log.d("PHILIP", "edit key success");
                        
                        Intent intent = new Intent();
                        intent.putExtra(OperationResult.EXTRA_RESULT, result);
                        getActivity().setResult(EditKeyActivity.RESULT_OK, intent);
                        getActivity().finish();
                    }
                }
        );

        ((EditKeyActivity) getActivity()).setFullScreenDialogDoneClose(
                R.string.btn_save,
                new OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        
                        if (mDataUri == null) {
                            returnKeyringParcel();
                        } else {
                            cryptoOperation(new CryptoInputParcel());
                        }
                    }
                }, new OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        getActivity().setResult(Activity.RESULT_CANCELED);
                        getActivity().finish();
                    }
                });

        Uri dataUri = getArguments().getParcelable(ARG_DATA_URI);
        SaveKeyringParcel saveKeyringParcel = getArguments().getParcelable(ARG_SAVE_KEYRING_PARCEL);
        if (dataUri == null && saveKeyringParcel == null) {
            Log.e(Constants.TAG, "Either a key Uri or ARG_SAVE_KEYRING_PARCEL is required!");
            getActivity().finish();
            return;
        }

        initView();
        if (dataUri != null) {
            loadData(dataUri);
        } else {
            loadSaveKeyringParcel(saveKeyringParcel);
        }
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        Log.e("PHILIP","Frament onActivityResult");
        super.onActivityResult(requestCode, resultCode, data);
    }

    private void loadSaveKeyringParcel(SaveKeyringParcel saveKeyringParcel) {
        mSaveKeyringParcel = saveKeyringParcel;
        mPrimaryUserId = saveKeyringParcel.mChangePrimaryUserId;

        mUserIdsAddedAdapter = new UserIdsAddedAdapter(getActivity(), mSaveKeyringParcel.mAddUserIds, true);
        mUserIdsAddedList.setAdapter(mUserIdsAddedAdapter);

        mSubkeysAddedAdapter = new SubkeysAddedAdapter(getActivity(), mSaveKeyringParcel.mAddSubKeys, true);
        mSubkeysAddedList.setAdapter(mSubkeysAddedAdapter);
    }

    private void loadData(Uri dataUri) {
        mDataUri = dataUri;

        Log.i(Constants.TAG, "mDataUri: " + mDataUri.toString());

        
        try {
            Uri secretUri = KeychainContract.KeyRings.buildUnifiedKeyRingUri(mDataUri);
            CachedPublicKeyRing keyRing =
                    new ProviderHelper(getActivity()).getCachedPublicKeyRing(secretUri);
            long masterKeyId = keyRing.getMasterKeyId();

            
            switch (keyRing.getSecretKeyType(masterKeyId)) {
                case GNU_DUMMY:
                    finishWithError(LogType.MSG_EK_ERROR_DUMMY);
                    return;
            }

            mSaveKeyringParcel = new SaveKeyringParcel(masterKeyId, keyRing.getFingerprint());
            mPrimaryUserId = keyRing.getPrimaryUserIdWithFallback();

        } catch (PgpKeyNotFoundException | NotFoundException e) {
            finishWithError(LogType.MSG_EK_ERROR_NOT_FOUND);
            return;
        }

        
        
        getLoaderManager().initLoader(LOADER_ID_USER_IDS, null, EditKeyFragment.this);
        getLoaderManager().initLoader(LOADER_ID_SUBKEYS, null, EditKeyFragment.this);

        mUserIdsAdapter = new UserIdsAdapter(getActivity(), null, 0, mSaveKeyringParcel);
        mUserIdsList.setAdapter(mUserIdsAdapter);

        
        mUserIdsAddedAdapter = new UserIdsAddedAdapter(getActivity(), mSaveKeyringParcel.mAddUserIds, false);
        mUserIdsAddedList.setAdapter(mUserIdsAddedAdapter);

        mSubkeysAdapter = new SubkeysAdapter(getActivity(), null, 0, mSaveKeyringParcel);
        mSubkeysList.setAdapter(mSubkeysAdapter);

        mSubkeysAddedAdapter = new SubkeysAddedAdapter(getActivity(), mSaveKeyringParcel.mAddSubKeys, false);
        mSubkeysAddedList.setAdapter(mSubkeysAddedAdapter);
    }

    private void initView() {
        mChangePassphrase.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                changePassphrase();
            }
        });

        mAddUserId.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                addUserId();
            }
        });

        mAddSubkey.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                addSubkey();
            }
        });

        mSubkeysList.setOnItemClickListener(new AdapterView.OnItemClickListener() {
            @Override
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                editSubkey(position);
            }
        });

        mUserIdsList.setOnItemClickListener(new AdapterView.OnItemClickListener() {
            @Override
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                editUserId(position);
            }
        });
    }

    public Loader<Cursor> onCreateLoader(int id, Bundle args) {

        switch (id) {
            case LOADER_ID_USER_IDS: {
                Uri baseUri = UserPackets.buildUserIdsUri(mDataUri);
                return new CursorLoader(getActivity(), baseUri,
                        UserIdsAdapter.USER_IDS_PROJECTION, null, null, null);
            }

            case LOADER_ID_SUBKEYS: {
                Uri baseUri = KeychainContract.Keys.buildKeysUri(mDataUri);
                return new CursorLoader(getActivity(), baseUri,
                        SubkeysAdapter.SUBKEYS_PROJECTION, null, null, null);
            }

            default:
                return null;
        }
    }

    public void onLoadFinished(Loader<Cursor> loader, Cursor data) {
        
        
        switch (loader.getId()) {
            case LOADER_ID_USER_IDS:
                mUserIdsAdapter.swapCursor(data);
                break;

            case LOADER_ID_SUBKEYS:
                mSubkeysAdapter.swapCursor(data);
                break;

        }
    }

    
    public void onLoaderReset(Loader<Cursor> loader) {
        switch (loader.getId()) {
            case LOADER_ID_USER_IDS:
                mUserIdsAdapter.swapCursor(null);
                break;
            case LOADER_ID_SUBKEYS:
                mSubkeysAdapter.swapCursor(null);
                break;
        }
    }

    private void changePassphrase() {



        
        Handler returnHandler = new Handler() {
            @Override
            public void handleMessage(Message message) {
                if (message.what == SetPassphraseDialogFragment.MESSAGE_OKAY) {
                    Bundle data = message.getData();

                    
                    mSaveKeyringParcel.mNewUnlock = new ChangeUnlockParcel(
                            (Passphrase) data.getParcelable(SetPassphraseDialogFragment.MESSAGE_NEW_PASSPHRASE),
                            null
                    );
                }
            }
        };

        
        Messenger messenger = new Messenger(returnHandler);

        SetPassphraseDialogFragment setPassphraseDialog = SetPassphraseDialogFragment.newInstance(
                messenger, R.string.title_change_passphrase);

        setPassphraseDialog.show(getActivity().getSupportFragmentManager(), "setPassphraseDialog");
    }

    private void editUserId(final int position) {
        final String userId = mUserIdsAdapter.getUserId(position);
        final boolean isRevoked = mUserIdsAdapter.getIsRevoked(position);
        final boolean isRevokedPending = mUserIdsAdapter.getIsRevokedPending(position);

        Handler returnHandler = new Handler() {
            @Override
            public void handleMessage(Message message) {
                switch (message.what) {
                    case EditUserIdDialogFragment.MESSAGE_CHANGE_PRIMARY_USER_ID:
                        
                        if (mSaveKeyringParcel.mChangePrimaryUserId != null
                                && mSaveKeyringParcel.mChangePrimaryUserId.equals(userId)) {
                            mSaveKeyringParcel.mChangePrimaryUserId = null;
                        } else {
                            mSaveKeyringParcel.mChangePrimaryUserId = userId;
                        }
                        break;
                    case EditUserIdDialogFragment.MESSAGE_REVOKE:
                        
                        if (mSaveKeyringParcel.mRevokeUserIds.contains(userId)) {
                            mSaveKeyringParcel.mRevokeUserIds.remove(userId);
                        } else {
                            mSaveKeyringParcel.mRevokeUserIds.add(userId);
                            
                            if (mSaveKeyringParcel.mChangePrimaryUserId != null
                                    && mSaveKeyringParcel.mChangePrimaryUserId.equals(userId)) {
                                mSaveKeyringParcel.mChangePrimaryUserId = null;
                            }
                        }
                        break;
                }
                getLoaderManager().getLoader(LOADER_ID_USER_IDS).forceLoad();
            }
        };

        
        final Messenger messenger = new Messenger(returnHandler);

        DialogFragmentWorkaround.INTERFACE.runnableRunDelayed(new Runnable() {
            public void run() {
                EditUserIdDialogFragment dialogFragment =
                        EditUserIdDialogFragment.newInstance(messenger, isRevoked, isRevokedPending);
                dialogFragment.show(getActivity().getSupportFragmentManager(), "editUserIdDialog");
            }
        });
    }

    private void editSubkey(final int position) {
        final long keyId = mSubkeysAdapter.getKeyId(position);

        Handler returnHandler = new Handler() {
            @Override
            public void handleMessage(Message message) {
                switch (message.what) {
                    case EditSubkeyDialogFragment.MESSAGE_CHANGE_EXPIRY:
                        editSubkeyExpiry(position);
                        break;
                    case EditSubkeyDialogFragment.MESSAGE_REVOKE:
                        
                        if (mSaveKeyringParcel.mRevokeSubKeys.contains(keyId)) {
                            mSaveKeyringParcel.mRevokeSubKeys.remove(keyId);
                        } else {
                            mSaveKeyringParcel.mRevokeSubKeys.add(keyId);
                        }
                        break;
                    case EditSubkeyDialogFragment.MESSAGE_STRIP: {
                        SecretKeyType secretKeyType = mSubkeysAdapter.getSecretKeyType(position);
                        if (secretKeyType == SecretKeyType.GNU_DUMMY) {
                            
                            break;
                        }

                        SubkeyChange change = mSaveKeyringParcel.getSubkeyChange(keyId);
                        if (change == null) {
                            mSaveKeyringParcel.mChangeSubKeys.add(new SubkeyChange(keyId, true, false));
                            break;
                        }
                        
                        change.mDummyStrip = !change.mDummyStrip;
                        if (change.mDummyStrip && change.mMoveKeyToCard) {
                            
                            change.mMoveKeyToCard = false;
                        }
                        break;
                    }
                    case EditSubkeyDialogFragment.MESSAGE_KEYTOCARD: {
                        Activity activity = EditKeyFragment.this.getActivity();
                        SecretKeyType secretKeyType = mSubkeysAdapter.getSecretKeyType(position);
                        if (secretKeyType == SecretKeyType.DIVERT_TO_CARD ||
                            secretKeyType == SecretKeyType.GNU_DUMMY) {
                            Notify.create(activity, R.string.edit_key_error_bad_nfc_stripped, Notify.Style.ERROR)
                                    .show((ViewGroup) activity.findViewById(R.id.import_snackbar));
                            break;
                        }
                        int algorithm = mSubkeysAdapter.getAlgorithm(position);
                        
                        if (algorithm != 1 && algorithm != 2 && algorithm != 3) {
                            Notify.create(activity, R.string.edit_key_error_bad_nfc_algo, Notify.Style.ERROR)
                                    .show((ViewGroup) activity.findViewById(R.id.import_snackbar));
                            break;
                        }
                        if (mSubkeysAdapter.getKeySize(position) != 2048) {
                            Notify.create(activity, R.string.edit_key_error_bad_nfc_size, Notify.Style.ERROR)
                                    .show((ViewGroup) activity.findViewById(R.id.import_snackbar));
                            break;
                        }


                        SubkeyChange change;
                        change = mSaveKeyringParcel.getSubkeyChange(keyId);
                        if (change == null) {
                            mSaveKeyringParcel.mChangeSubKeys.add(
                                    new SubkeyChange(keyId, false, true)
                            );
                            break;
                        }
                        
                        change.mMoveKeyToCard = !change.mMoveKeyToCard;
                        if (change.mMoveKeyToCard && change.mDummyStrip) {
                            
                            change.mDummyStrip = false;
                        }
                        break;
                    }
                }
                getLoaderManager().getLoader(LOADER_ID_SUBKEYS).forceLoad();
            }
        };

        
        final Messenger messenger = new Messenger(returnHandler);

        DialogFragmentWorkaround.INTERFACE.runnableRunDelayed(new Runnable() {
            public void run() {
                EditSubkeyDialogFragment dialogFragment =
                        EditSubkeyDialogFragment.newInstance(messenger);

                dialogFragment.show(getActivity().getSupportFragmentManager(), "editSubkeyDialog");
            }
        });
    }

    private void editSubkeyExpiry(final int position) {
        final long keyId = mSubkeysAdapter.getKeyId(position);
        final Long creationDate = mSubkeysAdapter.getCreationDate(position);
        final Long expiryDate = mSubkeysAdapter.getExpiryDate(position);

        Handler returnHandler = new Handler() {
            @Override
            public void handleMessage(Message message) {
                switch (message.what) {
                    case EditSubkeyExpiryDialogFragment.MESSAGE_NEW_EXPIRY:
                        mSaveKeyringParcel.getOrCreateSubkeyChange(keyId).mExpiry =
                                (Long) message.getData().getSerializable(
                                        EditSubkeyExpiryDialogFragment.MESSAGE_DATA_EXPIRY);
                        break;
                }
                getLoaderManager().getLoader(LOADER_ID_SUBKEYS).forceLoad();
            }
        };

        
        final Messenger messenger = new Messenger(returnHandler);

        DialogFragmentWorkaround.INTERFACE.runnableRunDelayed(new Runnable() {
            public void run() {
                EditSubkeyExpiryDialogFragment dialogFragment =
                        EditSubkeyExpiryDialogFragment.newInstance(messenger, creationDate, expiryDate);

                dialogFragment.show(getActivity().getSupportFragmentManager(), "editSubkeyExpiryDialog");
            }
        });
    }

    private void addUserId() {
        Handler returnHandler = new Handler() {
            @Override
            public void handleMessage(Message message) {
                if (message.what == SetPassphraseDialogFragment.MESSAGE_OKAY) {
                    Bundle data = message.getData();

                    
                    mUserIdsAddedAdapter.add(data
                            .getString(AddUserIdDialogFragment.MESSAGE_DATA_USER_ID));
                }
            }
        };

        
        Messenger messenger = new Messenger(returnHandler);

        
        String predefinedName = KeyRing.splitUserId(mPrimaryUserId).name;
        AddUserIdDialogFragment addUserIdDialog = AddUserIdDialogFragment.newInstance(messenger,
                predefinedName);

        addUserIdDialog.show(getActivity().getSupportFragmentManager(), "addUserIdDialog");
    }

    private void addSubkey() {
        boolean willBeMasterKey;
        if (mSubkeysAdapter != null) {
            willBeMasterKey = mSubkeysAdapter.getCount() == 0 && mSubkeysAddedAdapter.getCount() == 0;
        } else {
            willBeMasterKey = mSubkeysAddedAdapter.getCount() == 0;
        }

        AddSubkeyDialogFragment addSubkeyDialogFragment =
                AddSubkeyDialogFragment.newInstance(willBeMasterKey);
        addSubkeyDialogFragment
                .setOnAlgorithmSelectedListener(
                        new AddSubkeyDialogFragment.OnAlgorithmSelectedListener() {
                            @Override
                            public void onAlgorithmSelected(SaveKeyringParcel.SubkeyAdd newSubkey) {
                                mSubkeysAddedAdapter.add(newSubkey);
                            }
                        }
                );
        addSubkeyDialogFragment.show(getActivity().getSupportFragmentManager(), "addSubkeyDialog");
    }

    protected void returnKeyringParcel() {
        if (mSaveKeyringParcel.mAddUserIds.size() == 0) {
            Notify.create(getActivity(), R.string.edit_key_error_add_identity, Notify.Style.ERROR).show();
            return;
        }
        if (mSaveKeyringParcel.mAddSubKeys.size() == 0) {
            Notify.create(getActivity(), R.string.edit_key_error_add_subkey, Notify.Style.ERROR).show();
            return;
        }

        
        mSaveKeyringParcel.mChangePrimaryUserId = mSaveKeyringParcel.mAddUserIds.get(0);

        Intent returnIntent = new Intent();
        returnIntent.putExtra(EditKeyActivity.EXTRA_SAVE_KEYRING_PARCEL, mSaveKeyringParcel);
        getActivity().setResult(Activity.RESULT_OK, returnIntent);
        getActivity().finish();
    }

    
    void finishWithError(LogType reason) {
        
        Intent intent = new Intent();
        intent.putExtra(OperationResult.EXTRA_RESULT,
                new SingletonResult(SingletonResult.RESULT_ERROR, reason));

        
        getActivity().setResult(EditKeyActivity.RESULT_OK, intent);
        getActivity().finish();
    }
}

<code block>


package org.sufficientlysecure.keychain.ui;

import android.app.ProgressDialog;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.os.Message;
import android.os.Messenger;
import android.support.v4.app.Fragment;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;

import org.sufficientlysecure.keychain.Constants;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.intents.OpenKeychainIntents;
import org.sufficientlysecure.keychain.keyimport.ImportKeysListEntry;
import org.sufficientlysecure.keychain.keyimport.ParcelableKeyRing;
import org.sufficientlysecure.keychain.operations.results.ImportKeyResult;
import org.sufficientlysecure.keychain.operations.results.OperationResult;
import org.sufficientlysecure.keychain.service.ImportKeyringParcel;
import org.sufficientlysecure.keychain.service.KeychainNewService;
import org.sufficientlysecure.keychain.service.KeychainService;
import org.sufficientlysecure.keychain.service.input.CryptoInputParcel;
import org.sufficientlysecure.keychain.ui.base.BaseNfcActivity;
import org.sufficientlysecure.keychain.service.ServiceProgressHandler;
import org.sufficientlysecure.keychain.ui.util.KeyFormattingUtils;
import org.sufficientlysecure.keychain.ui.util.Notify;
import org.sufficientlysecure.keychain.util.Log;
import org.sufficientlysecure.keychain.util.ParcelableFileCache;
import org.sufficientlysecure.keychain.util.ParcelableFileCache.IteratorWithSize;
import org.sufficientlysecure.keychain.util.Preferences;
import org.sufficientlysecure.keychain.util.orbot.OrbotHelper;

import java.io.IOException;
import java.util.ArrayList;

public class ImportKeysActivity extends BaseNfcActivity {

    public static final String ACTION_IMPORT_KEY = OpenKeychainIntents.IMPORT_KEY;
    public static final String ACTION_IMPORT_KEY_FROM_KEYSERVER = OpenKeychainIntents.IMPORT_KEY_FROM_KEYSERVER;
    public static final String ACTION_IMPORT_KEY_FROM_KEYSERVER_AND_RETURN_RESULT =
            Constants.INTENT_PREFIX + "IMPORT_KEY_FROM_KEY_SERVER_AND_RETURN_RESULT";
    public static final String ACTION_IMPORT_KEY_FROM_KEYSERVER_AND_RETURN_TO_SERVICE = Constants.INTENT_PREFIX
            + "IMPORT_KEY_FROM_KEY_SERVER_AND_RETURN";
    public static final String ACTION_IMPORT_KEY_FROM_FILE_AND_RETURN = Constants.INTENT_PREFIX
            + "IMPORT_KEY_FROM_FILE_AND_RETURN";

    
    public static final String ACTION_IMPORT_KEY_FROM_FILE = Constants.INTENT_PREFIX
            + "IMPORT_KEY_FROM_FILE";
    public static final String ACTION_SEARCH_KEYSERVER_FROM_URL = Constants.INTENT_PREFIX
            + "SEARCH_KEYSERVER_FROM_URL";
    public static final String EXTRA_RESULT = "result";

    
    public static final String EXTRA_KEY_BYTES = OpenKeychainIntents.IMPORT_EXTRA_KEY_EXTRA_KEY_BYTES;

    
    public static final String EXTRA_QUERY = OpenKeychainIntents.IMPORT_KEY_FROM_KEYSERVER_EXTRA_QUERY;
    public static final String EXTRA_KEY_ID = Constants.EXTRA_PREFIX + "EXTRA_KEY_ID";
    public static final String EXTRA_FINGERPRINT = OpenKeychainIntents.IMPORT_KEY_FROM_KEYSERVER_EXTRA_FINGERPRINT;

    
    public static final String EXTRA_PENDING_INTENT_DATA = "data";
    private Intent mPendingIntentData;

    
    private ImportKeysListFragment mListFragment;
    private Fragment mTopFragment;
    private View mImportButton;

    private Preferences.ProxyPrefs mProxyPrefs;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        mProxyPrefs = Preferences.getPreferences(this).getProxyPrefs();

        mImportButton = findViewById(R.id.import_import);
        mImportButton.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                importKeys();
            }
        });

        handleActions(savedInstanceState, getIntent());
    }

    @Override
    protected void initLayout() {
        setContentView(R.layout.import_keys_activity);
    }

    protected void handleActions(Bundle savedInstanceState, Intent intent) {
        String action = intent.getAction();
        Bundle extras = intent.getExtras();
        Uri dataUri = intent.getData();
        String scheme = intent.getScheme();

        if (extras == null) {
            extras = new Bundle();
        }

        if (action == null) {
            startCloudFragment(savedInstanceState, null, false, null);
            startListFragment(savedInstanceState, null, null, null, null);
            return;
        }

        if (Intent.ACTION_VIEW.equals(action)) {
            if (scheme.equals("http") || scheme.equals("https")) {
                action = ACTION_SEARCH_KEYSERVER_FROM_URL;
            } else {
                
                
                action = ACTION_IMPORT_KEY;
            }
        }

        switch (action) {
            case ACTION_IMPORT_KEY: {
                
                startFileFragment(savedInstanceState);

                if (dataUri != null) {
                    
                    startListFragment(savedInstanceState, null, dataUri, null, null);
                } else if (extras.containsKey(EXTRA_KEY_BYTES)) {
                    byte[] importData = extras.getByteArray(EXTRA_KEY_BYTES);

                    
                    startListFragment(savedInstanceState, importData, null, null, null);
                }
                break;
            }
            case ACTION_IMPORT_KEY_FROM_KEYSERVER:
            case ACTION_IMPORT_KEY_FROM_KEYSERVER_AND_RETURN_TO_SERVICE:
            case ACTION_IMPORT_KEY_FROM_KEYSERVER_AND_RETURN_RESULT: {

                
                if (extras.containsKey(EXTRA_PENDING_INTENT_DATA)) {
                    mPendingIntentData = extras.getParcelable(EXTRA_PENDING_INTENT_DATA);
                }
                if (extras.containsKey(EXTRA_QUERY) || extras.containsKey(EXTRA_KEY_ID)) {
                    

                    String query = null;
                    if (extras.containsKey(EXTRA_QUERY)) {
                        query = extras.getString(EXTRA_QUERY);
                    } else if (extras.containsKey(EXTRA_KEY_ID)) {
                        long keyId = extras.getLong(EXTRA_KEY_ID, 0);
                        if (keyId != 0) {
                            query = KeyFormattingUtils.convertKeyIdToHex(keyId);
                        }
                    }

                    if (query != null && query.length() > 0) {
                        
                        startCloudFragment(savedInstanceState, query, false, null);

                        
                        startListFragment(savedInstanceState, null, null, query, null);
                    } else {
                        Log.e(Constants.TAG, "Query is empty!");
                        return;
                    }
                } else if (extras.containsKey(EXTRA_FINGERPRINT)) {
                    

                    String fingerprint = extras.getString(EXTRA_FINGERPRINT);
                    if (isFingerprintValid(fingerprint)) {
                        String query = "0x" + fingerprint;

                        
                        startCloudFragment(savedInstanceState, query, true, null);

                        
                        startListFragment(savedInstanceState, null, null, query, null);
                    }
                } else {
                    Log.e(Constants.TAG,
                            "IMPORT_KEY_FROM_KEYSERVER action needs to contain the 'query', 'key_id', or " +
                                    "'fingerprint' extra!"
                    );
                    return;
                }
                break;
            }
            case ACTION_IMPORT_KEY_FROM_FILE: {
                
                startFileFragment(savedInstanceState);

                
                startListFragment(savedInstanceState, null, null, null, null);
                break;
            }
            case ACTION_SEARCH_KEYSERVER_FROM_URL: {
                
                String query = dataUri.getQueryParameter("search");
                String keyserver = dataUri.getAuthority();
                
                if (query == null) {
                    Notify.create(this, R.string.import_url_warn_no_search_parameter, Notify.LENGTH_INDEFINITE,
                            Notify.Style.WARN).show(mTopFragment);
                    
                    startCloudFragment(savedInstanceState, null, false, keyserver);
                    
                    
                    
                    startListFragment(savedInstanceState, null, null, null, null);
                } else {
                    
                    startCloudFragment(savedInstanceState, query, false, keyserver);
                    
                    startListFragment(savedInstanceState, null, null, query, keyserver);
                }
                break;
            }
            case ACTION_IMPORT_KEY_FROM_FILE_AND_RETURN: {
                
                startFileFragment(savedInstanceState);

                
                startListFragment(savedInstanceState, null, null, null, null);
                break;
            }
            default: {
                startCloudFragment(savedInstanceState, null, false, null);
                startListFragment(savedInstanceState, null, null, null, null);
                break;
            }
        }
    }


    
    private void startListFragment(Bundle savedInstanceState, byte[] bytes, Uri dataUri,
                                   String serverQuery, String keyserver) {
        
        
        
        if (mListFragment != null) {
            return;
        }

        mListFragment = ImportKeysListFragment.newInstance(bytes, dataUri, serverQuery, false,
                keyserver);

        
        
        getSupportFragmentManager().beginTransaction()
                .replace(R.id.import_keys_list_container, mListFragment)
                .commitAllowingStateLoss();
        
        getSupportFragmentManager().executePendingTransactions();
    }

    private void startFileFragment(Bundle savedInstanceState) {
        
        
        
        if (mTopFragment != null) {
            return;
        }

        
        mTopFragment = ImportKeysFileFragment.newInstance();

        
        
        getSupportFragmentManager().beginTransaction()
                .replace(R.id.import_keys_top_container, mTopFragment)
                .commitAllowingStateLoss();
        
        getSupportFragmentManager().executePendingTransactions();
    }

    

    private void startCloudFragment(Bundle savedInstanceState, String query, boolean disableQueryEdit, String
            keyserver) {
        
        
        
        if (mTopFragment != null) {
            return;
        }

        
        mTopFragment = ImportKeysCloudFragment.newInstance(query, disableQueryEdit, keyserver);

        
        
        getSupportFragmentManager().beginTransaction()
                .replace(R.id.import_keys_top_container, mTopFragment)
                .commitAllowingStateLoss();
        
        getSupportFragmentManager().executePendingTransactions();
    }

    private boolean isFingerprintValid(String fingerprint) {
        if (fingerprint == null || fingerprint.length() < 40) {
            Notify.create(this, R.string.import_qr_code_too_short_fingerprint, Notify.Style.ERROR)
                    .show((ViewGroup) findViewById(R.id.import_snackbar));
            return false;
        } else {
            return true;
        }
    }

    public void loadCallback(final ImportKeysListFragment.LoaderState loaderState) {
        if (loaderState instanceof ImportKeysListFragment.CloudLoaderState) {
            
            
            Runnable ignoreTor = new Runnable() {
                @Override
                public void run() {
                    
                    mProxyPrefs = new Preferences.ProxyPrefs(false, false, null, -1, null);
                    mListFragment.loadNew(loaderState, mProxyPrefs.parcelableProxy);
                }
            };
            if (OrbotHelper.isOrbotInRequiredState(R.string.orbot_ignore_tor, ignoreTor, mProxyPrefs, this)) {
                mListFragment.loadNew(loaderState, mProxyPrefs.parcelableProxy);
            }
        } else if (loaderState instanceof ImportKeysListFragment.BytesLoaderState) { 
            mListFragment.loadNew(loaderState, mProxyPrefs.parcelableProxy);
        }
    }

    private void handleMessage(Message message) {
        if (message.arg1 == ServiceProgressHandler.MessageStatus.OKAY.ordinal()) {
            
            Bundle returnData = message.getData();
            if (returnData == null) {
                return;
            }
            final ImportKeyResult result = returnData.getParcelable(OperationResult.EXTRA_RESULT);
            if (result == null) {
                Log.e(Constants.TAG, "result == null");
                return;
            }

            if (ACTION_IMPORT_KEY_FROM_KEYSERVER_AND_RETURN_RESULT.equals(getIntent().getAction())
                    || ACTION_IMPORT_KEY_FROM_FILE_AND_RETURN.equals(getIntent().getAction())) {
                Intent intent = new Intent();
                intent.putExtra(ImportKeyResult.EXTRA_RESULT, result);
                ImportKeysActivity.this.setResult(RESULT_OK, intent);
                ImportKeysActivity.this.finish();
                return;
            }
            if (ACTION_IMPORT_KEY_FROM_KEYSERVER_AND_RETURN_TO_SERVICE.equals(getIntent().getAction())) {
                ImportKeysActivity.this.setResult(RESULT_OK, mPendingIntentData);
                ImportKeysActivity.this.finish();
                return;
            }

            result.createNotify(ImportKeysActivity.this)
                    .show((ViewGroup) findViewById(R.id.import_snackbar));
        }
    }

    
    public void importKeys() {

        if (mListFragment.getSelectedEntries().size() == 0) {
            Notify.create(this, R.string.error_nothing_import_selected, Notify.Style.ERROR)
                    .show((ViewGroup) findViewById(R.id.import_snackbar));
            return;
        }

        ServiceProgressHandler serviceHandler = new ServiceProgressHandler(this) {
            @Override
            public void handleMessage(Message message) {
                
                super.handleMessage(message);

                ImportKeysActivity.this.handleMessage(message);
            }
        };

        
        Intent intent = new Intent(this, KeychainNewService.class);
        ImportKeyringParcel operationInput = null;
        CryptoInputParcel cryptoInput = null;

        ImportKeysListFragment.LoaderState ls = mListFragment.getLoaderState();
        if (ls instanceof ImportKeysListFragment.BytesLoaderState) {
            Log.d(Constants.TAG, "importKeys started");

            
            IteratorWithSize<ParcelableKeyRing> selectedEntries = mListFragment.getSelectedData();

            
            
            
            try {
                
                
                ParcelableFileCache<ParcelableKeyRing> cache =
                        new ParcelableFileCache<>(this, "key_import.pcl");
                cache.writeCache(selectedEntries);

                operationInput = new ImportKeyringParcel(null, null);
                cryptoInput = new CryptoInputParcel();

            } catch (IOException e) {
                Log.e(Constants.TAG, "Problem writing cache file", e);
                Notify.create(this, "Problem writing cache file!", Notify.Style.ERROR)
                        .show((ViewGroup) findViewById(R.id.import_snackbar));
            }
        } else if (ls instanceof ImportKeysListFragment.CloudLoaderState) {
            ImportKeysListFragment.CloudLoaderState sls = (ImportKeysListFragment.CloudLoaderState) ls;

            
            ArrayList<ParcelableKeyRing> keys = new ArrayList<>();
            {
                
                ArrayList<ImportKeysListEntry> entries = mListFragment.getSelectedEntries();
                for (ImportKeysListEntry entry : entries) {
                    keys.add(new ParcelableKeyRing(
                                    entry.getFingerprintHex(), entry.getKeyIdHex(), entry.getExtraData())
                    );
                }
            }

            operationInput = new ImportKeyringParcel(keys, sls.mCloudPrefs.keyserver);
            if (mProxyPrefs != null) { 
                cryptoInput = new CryptoInputParcel(mProxyPrefs.parcelableProxy);
            } else {
                cryptoInput = new CryptoInputParcel();
            }
        }

        intent.putExtra(KeychainNewService.EXTRA_OPERATION_INPUT, operationInput);
        intent.putExtra(KeychainNewService.EXTRA_CRYPTO_INPUT, cryptoInput);

        
        Messenger messenger = new Messenger(serviceHandler);
        intent.putExtra(KeychainService.EXTRA_MESSENGER, messenger);

        
        serviceHandler.showProgressDialog(
                getString(R.string.progress_importing),
                ProgressDialog.STYLE_HORIZONTAL, true
        );

        
        startService(intent);
    }

    @Override
    protected void onNfcPerform() throws IOException {
        
        super.onNfcPerform();
        
        finish();
    }
}

<code block>


package org.sufficientlysecure.keychain.ui;

import android.content.Intent;
import android.os.Bundle;
import android.support.v4.app.FragmentActivity;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.util.Preferences;
import org.sufficientlysecure.keychain.util.orbot.OrbotHelper;


public class OrbotRequiredDialogActivity extends FragmentActivity {

    public final static String RESULT_IGNORE_TOR = "ignore_tor";

    @Override
    public void onCreate(Bundle savedInstanceState) {
        Runnable ignoreTor = new Runnable() {
            @Override
            public void run() {
                Intent data = new Intent();
                data.putExtra(RESULT_IGNORE_TOR, true);
                setResult(RESULT_OK, data);
            }
        };

        if (OrbotHelper.isOrbotInRequiredState(R.string.orbot_ignore_tor, ignoreTor,
                Preferences.getPreferences(this).getProxyPrefs(), this)) {
            Intent data = new Intent();
            data.putExtra(RESULT_IGNORE_TOR, false);
            setResult(RESULT_OK, data);
        }
    }
}

<code block>



package org.sufficientlysecure.keychain.ui.dialog;

import android.app.Dialog;
import android.content.DialogInterface;
import android.os.Bundle;
import android.os.Message;
import android.os.Messenger;
import android.os.RemoteException;
import android.support.v4.app.DialogFragment;

import org.sufficientlysecure.keychain.Constants;
import org.sufficientlysecure.keychain.R;
import org.sufficientlysecure.keychain.util.Log;
import org.sufficientlysecure.keychain.util.orbot.OrbotHelper;


public class OrbotStartDialogFragment extends DialogFragment {
    private static final String ARG_MESSENGER = "messenger";
    private static final String ARG_TITLE = "title";
    private static final String ARG_MESSAGE = "message";
    private static final String ARG_MIDDLE_BUTTON = "middleButton";

    public static final int MESSAGE_MIDDLE_BUTTON = 1;

    public static OrbotStartDialogFragment newInstance(Messenger messenger, int title, int message, int middleButton) {
        Bundle args = new Bundle();
        args.putParcelable(ARG_MESSENGER, messenger);
        args.putInt(ARG_TITLE, title);
        args.putInt(ARG_MESSAGE, message);
        args.putInt(ARG_MIDDLE_BUTTON, middleButton);

        OrbotStartDialogFragment fragment = new OrbotStartDialogFragment();
        fragment.setArguments(args);

        return fragment;
    }

    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {

        final Messenger messenger = getArguments().getParcelable(ARG_MESSENGER);
        int title = getArguments().getInt(ARG_TITLE);
        final int message = getArguments().getInt(ARG_MESSAGE);
        int middleButton = getArguments().getInt(ARG_MIDDLE_BUTTON);

        CustomAlertDialogBuilder builder = new CustomAlertDialogBuilder(getActivity());
        builder.setTitle(title).setMessage(message);

        builder.setNegativeButton(R.string.orbot_start_dialog_cancel, new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {

            }
        });

        builder.setPositiveButton(R.string.orbot_start_dialog_start, new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                getActivity().startActivityForResult(OrbotHelper.getOrbotStartIntent(), 1);
            }
        });

        builder.setNeutralButton(middleButton, new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                Message msg = new Message();
                msg.what = MESSAGE_MIDDLE_BUTTON;
                try {
                    messenger.send(msg);
                } catch (RemoteException e) {
                    Log.w(Constants.TAG, "Exception sending message, Is handler present?", e);
                } catch (NullPointerException e) {
                    Log.w(Constants.TAG, "Messenger is null!", e);
                }
            }
        });

        return builder.show();
    }
}
