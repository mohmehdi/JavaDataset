
package org.openhab.binding.insteonplm;


import java.util.Collection;
import java.util.Dictionary;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.ConcurrentHashMap;

import org.openhab.binding.insteonplm.internal.device.DeviceFeature;
import org.openhab.binding.insteonplm.internal.device.DeviceFeatureListener;
import org.openhab.binding.insteonplm.internal.device.DeviceType;
import org.openhab.binding.insteonplm.internal.device.DeviceTypeLoader;
import org.openhab.binding.insteonplm.internal.device.InsteonAddress;
import org.openhab.binding.insteonplm.internal.device.InsteonDevice;
import org.openhab.binding.insteonplm.internal.device.InsteonDevice.DeviceStatus;
import org.openhab.binding.insteonplm.internal.device.RequestQueueManager;
import org.openhab.binding.insteonplm.internal.driver.Driver;
import org.openhab.binding.insteonplm.internal.driver.DriverListener;
import org.openhab.binding.insteonplm.internal.driver.ModemDBEntry;
import org.openhab.binding.insteonplm.internal.driver.Poller;
import org.openhab.binding.insteonplm.internal.message.FieldException;
import org.openhab.binding.insteonplm.internal.message.Msg;
import org.openhab.binding.insteonplm.internal.message.MsgListener;
import org.openhab.core.binding.AbstractActiveBinding;
import org.openhab.core.binding.BindingProvider;
import org.openhab.core.types.Command;
import org.osgi.service.cm.ConfigurationException;
import org.osgi.service.cm.ManagedService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;




public class InsteonPLMActiveBinding
	extends AbstractActiveBinding<InsteonPLMBindingProvider>
	implements ManagedService {
	private static final Logger logger = LoggerFactory.getLogger(InsteonPLMActiveBinding.class);

	private Driver					m_driver			= null;
	private ConcurrentHashMap<InsteonAddress, InsteonDevice>  m_devices = null; 
	private HashMap<String, String> m_config			= new HashMap<String, String>();
	private PortListener			m_portListener 		= new PortListener();
	private long					m_devicePollInterval 	= 300000L;
	private long					m_deadDeviceTimeout 	= -1L;
	private long					m_refreshInterval		= 600000L;
	private int						m_messagesReceived		= 0;
	private boolean					m_isActive		  		= false; 
	private boolean					m_hasInitialItemConfig	= false;
	private int						m_x10HouseUnit			= -1;


	public InsteonPLMActiveBinding() {
		m_driver	= new Driver();
		m_devices 	= new ConcurrentHashMap<InsteonAddress, InsteonDevice>();
	}



	@Override
	public void internalReceiveCommand(String itemName, Command command) {
		logger.info("Item: {} got command {}", itemName, command);

		if(!(isProperlyConfigured() && m_isActive)) {
			logger.debug("not ready to handle commands yet, returning.");
			return;
		}
		boolean commandHandled = false;
		for (InsteonPLMBindingProvider provider : providers) {
			if (provider.providesBindingFor(itemName)) {
				commandHandled = true;
				InsteonPLMBindingConfig c = provider.getInsteonPLMBindingConfig(itemName);
				if (c == null) {
					logger.warn("could not find config for item {}", itemName);
				} else {
					sendCommand(c, command);
				}
			}
		}
		
		if (!commandHandled)
			logger.warn("No converter found for item = {}, command = {}, ignoring.",
						itemName, command.toString());
	}


	@Override
	public void activate() {
		logger.debug("activating binding");
		if (isProperlyConfigured() && !m_isActive) {
			initialize();
		}
		m_isActive = true;
	}
	

	@Override
	public void deactivate() {
		logger.debug("deactivating binding!");
		shutdown();
		m_isActive = false;
	}



	@Override
	protected String getName() {
		return "InsteonPLM";
	}
	

	@Override
	protected void execute() {
		logDeviceStatistics();
	}


	@Override
	protected long getRefreshInterval() {
		return m_refreshInterval;
	}
	

	@Override
	public void bindingChanged(BindingProvider provider, String itemName) {
		super.bindingChanged(provider, itemName);
		m_hasInitialItemConfig = true; 
		InsteonPLMBindingConfig c =
					((InsteonPLMBindingProvider)provider).getInsteonPLMBindingConfig(itemName);
		logger.debug("item {} binding changed: {}", String.format("%-30s", itemName), c);
		if (c == null) {



			removeFeatureListener(itemName);
		} else {
			InsteonDevice dev = getDevice(c.getAddress());
			if (dev == null) {
				dev = makeNewDevice(c);
			}
			addFeatureListener(dev, itemName, c);
		}
	}

	@Override
	public void updated(Dictionary<String, ?> config) throws ConfigurationException {
		HashMap<String, String> newConfig = new HashMap<String, String>();
		if (config == null) {
			logger.debug("seems like our configuration has been erased, will reset everything!");
		} else {

			for (Enumeration<String> e = config.keys(); e.hasMoreElements();) {
				String key   = e.nextElement();
				String value = config.get(key).toString();
				newConfig.put(key, value);
			}
		}
		
		if (newConfig.entrySet().equals(m_config.entrySet())) {
			logger.debug("config has not changed, done.");
			return;
		}
		m_config = newConfig;


		if (m_isActive) {
			if (isProperlyConfigured()) {
				logger.debug("global binding config has changed, resetting.");
				shutdown();
			} else {
				logger.debug("global binding config has arrived.");
			}
		}
		long deadDeviceCount = 10;
		if (m_config.containsKey("refresh")) {
			m_refreshInterval = Integer.parseInt(m_config.get("refresh"));
			logger.info("refresh interval set to {}s", m_refreshInterval / 1000);
		}
		if (m_config.containsKey("device_dead_count")) {
			deadDeviceCount = s_parseLong(m_config.get("device_dead_count"), 2L, 100000L);
			logger.info("device_dead_count set to {} per config file", deadDeviceCount);
		}
		if (m_config.containsKey("poll_interval")) {
			m_devicePollInterval = s_parseLong(m_config.get("poll_interval"), 5000L, 3600000L);
			logger.info("poll interval set to {} per config file", m_devicePollInterval);
		}
		if (m_config.containsKey("more_devices")) {
			String fileName = m_config.get("more_devices");
			try {
				DeviceTypeLoader.s_instance().loadDeviceTypesXML(fileName);
				logger.info("read additional device definitions from {}", fileName);
			} catch (Exception e) {
				logger.error("error reading additional devices from {}", fileName, e);
			}
		}
		if (m_config.containsKey("more_features")) {
			String fileName = m_config.get("more_features");
			logger.info("reading additional feature templates from {}", fileName);
			DeviceFeature.s_readFeatureTemplates(fileName);
		}
 		
		m_deadDeviceTimeout = m_devicePollInterval * deadDeviceCount;
		logger.info("dead device timeout set to {}s", m_deadDeviceTimeout / 1000);
		logger.debug("configuration update complete!");
		setProperlyConfigured(true);
		if (m_isActive) {
			initialize();
		}
		if (!m_hasInitialItemConfig) triggerBindingChangedCalls();
		return;
	}

	public InsteonDevice getDevice(InsteonAddress aAddr) {
		InsteonDevice dev = (aAddr == null) ? null : m_devices.get(aAddr);
		return (dev);
	}
	


	private void triggerBindingChangedCalls() {
		for (InsteonPLMBindingProvider provider : providers) {
			Collection<String> items = provider.getItemNames();
			for (Iterator<String> item = items.iterator(); item.hasNext();) {
				String itemName = item.next();
				bindingChanged(provider, itemName);
			}
        }
	}
	

	private void initialize() {
		logger.debug("initializing...");
		
		HashSet<String> ports = new HashSet<String>();


		for (Map.Entry<String, String> e : m_config.entrySet()) {
			String name = e.getKey();
			String port  = e.getValue();
			if (ports.contains(port)) {
				logger.warn("port {} {} already in use, check config!", name, port);
				continue;
			}
			logger.info("config: {} -> {}", name, port);
			if (name.startsWith("port_")) {
				m_driver.addPort(name,  port);
				m_driver.addMsgListener(m_portListener, port);
			}
		}
		logger.debug("setting driver listener");
		m_driver.setDriverListener(m_portListener);
		logger.debug("starting {} ports", m_driver.getNumberOfPorts());
		m_driver.startAllPorts();
		logger.debug("ports started");
		switch (m_driver.getNumberOfPorts()) {
		case 0:
			logger.error("initialization complete, but found no ports!");
			break;
		case 1:
			logger.debug("initialization complete, found 1 port!");
			break;
		default:
			logger.warn("initialization complete, found {} ports.",
					m_driver.getNumberOfPorts());
			break;
		}
	}
	

	private void shutdown() {
		logger.debug("shutting down binding");
		m_driver.stopAllPorts();
		m_devices.clear();
		RequestQueueManager.s_destroyInstance();
		Poller.s_instance().stop();
	}
	

	private void sendCommand(InsteonPLMBindingConfig c, Command command) {
		InsteonDevice dev = getDevice(c.getAddress());
		if (dev == null) {
			logger.warn("no device found with insteon address {}", c.getAddress());
			return;
		}
		dev.processCommand(m_driver, c, command);
	}


	private void removeFeatureListener(String aItem) {
		for (Iterator<Entry<InsteonAddress, InsteonDevice>> it = m_devices.entrySet().iterator();
				it.hasNext(); ) {
			InsteonDevice dev = it.next().getValue();
			boolean removedListener = dev.removeFeatureListener(aItem);
			if (removedListener) {
				logger.trace("removed feature listener {} from dev {}", aItem, dev);
			}
			if (!dev.hasAnyListeners()) {
				Poller.s_instance().stopPolling(dev);
				it.remove();
				logger.trace("removing unreferenced {}", dev);
				if (m_devices.isEmpty()) {
					logger.debug("all devices removed!", dev);
				}
			}
		}
	}
	

	private InsteonDevice makeNewDevice(InsteonPLMBindingConfig aConfig) {
		String prodKey = aConfig.getProductKey();
		DeviceType dt = DeviceTypeLoader.s_instance().getDeviceType(prodKey);
		if (dt == null) {
			logger.error("unknown product key: {} for config: {}." +
					" Add definition to xml file and try again", prodKey, aConfig);
			return null;
		}
		InsteonDevice dev =	InsteonDevice.s_makeDevice(dt);
		dev.setAddress(aConfig.getAddress());
		dev.setDriver(m_driver);
		dev.addPort(m_driver.getDefaultPort());
		if (!dev.hasValidPollingInterval()) {
			dev.setPollInterval(m_devicePollInterval);
		}
		if (m_driver.isModemDBComplete() && dev.getStatus() != DeviceStatus.POLLING) {
			int ndev = checkIfInModemDatabase(dev);
			if (dev.hasModemDBEntry()) {
				dev.setStatus(DeviceStatus.POLLING);
				Poller.s_instance().startPolling(dev, ndev);
			}
		}
		m_devices.put(aConfig.getAddress(), dev);
		return (dev);
	}
	

	private int checkIfInModemDatabase(InsteonDevice dev) {
		InsteonAddress addr = dev.getAddress();
		HashMap<InsteonAddress, ModemDBEntry> dbes = m_driver.lockModemDBEntries();
		if (dbes.containsKey(addr)) {
			if (!dev.hasModemDBEntry()) {
				logger.info("device {} found in the modem database!", addr);
				dev.setHasModemDBEntry(true);
			}
		} else {
			if (m_driver.isModemDBComplete() && !addr.isX10()) {
				logger.warn("device {} not found in the modem database. Did you forget to link?", addr);
			}
		}
		int ndev = dbes.size();
		m_driver.unlockModemDBEntries();
		return ndev;
	}

	private void addFeatureListener(InsteonDevice aDev, String aItemName,
				InsteonPLMBindingConfig aConfig) {
		if (aDev == null) {
			return;
		}
		DeviceFeature f = aDev.getFeature(aConfig.getFeature());
		if (f == null) {
			logger.error("item {} references unknown feature: {}, item disabled!", aItemName, aConfig.getFeature());
			return;
		}
		DeviceFeatureListener fl = new DeviceFeatureListener(this, aItemName, eventPublisher);
		fl.setParameters(aConfig.getParameters());
		f.addListener(fl);	
	}


	private class PortListener implements MsgListener, DriverListener {

		@Override
		public void msg(Msg msg, String fromPort) {
			if (msg.isEcho() || msg.isPureNack()) return;
			m_messagesReceived++;
			logger.debug("got msg: {}", msg);
			if (msg.isX10()) {
				handleX10Message(msg, fromPort);
			} else {
				handleInsteonMessage(msg, fromPort);
			}
			
		}

		@Override
		public void driverCompletelyInitialized() {
			HashMap<InsteonAddress, ModemDBEntry> dbes = m_driver.lockModemDBEntries();
			logger.info("modem database has {} entries!", dbes.size());
			if (dbes.isEmpty()) {
				logger.warn("the modem link database is empty!");
			}
			for (InsteonAddress k : dbes.keySet()) {
				logger.debug("modem db entry: {}", k);
			}
			for (InsteonDevice dev : m_devices.values()) {
				InsteonAddress a = dev.getAddress();
				if (!dbes.containsKey(a)) {
					if (!a.isX10())
						logger.warn("device {} not found in the modem database. Did you forget to link?", a);
				} else {
					if (!dev.hasModemDBEntry()) {
						logger.info("device {}     found in the modem database!", a);
						dev.setHasModemDBEntry(true);
					}
					if (dev.getStatus() != DeviceStatus.POLLING) {
						Poller.s_instance().startPolling(dev, dbes.size());
					}
				}
			}
			m_driver.unlockModemDBEntries();
		}
		private void handleInsteonMessage(Msg msg, String fromPort) {
			InsteonAddress toAddr = msg.getAddr("toAddress");
			if (!msg.isBroadcast() && !m_driver.isMsgForUs(toAddr)) {

				return;
			}
			InsteonAddress fromAddr = msg.getAddr("fromAddress");
			if (fromAddr == null) {
				logger.debug("invalid fromAddress, ignoring msg {}", msg);
				return;
			}
			handleMessage(fromPort, fromAddr, msg);
		}

		private void handleX10Message(Msg msg, String fromPort) {
			try {
				int x10Flag	= msg.getByte("X10Flag") & 0xff;
				int rawX10	= msg.getByte("rawX10") & 0xff;
				if (x10Flag == 0x80) { 
					if (m_x10HouseUnit != -1) {
						InsteonAddress fromAddr = new InsteonAddress((byte)m_x10HouseUnit);
						handleMessage(fromPort, fromAddr, msg);
					}
				} else if (x10Flag == 0) {

					m_x10HouseUnit = rawX10 & 0xFF; 
				}
			} catch (FieldException e) {
				logger.error("got bad X10 message: {}", msg, e);
				return;
			}
		}
		private void handleMessage(String fromPort, InsteonAddress fromAddr, Msg msg) {
			InsteonDevice  dev = getDevice(fromAddr);
			if (dev == null) {
				logger.debug("dropping message from unknown device with address {}", fromAddr);
			} else {
				dev.handleMessage(fromPort, msg);
			}
		}
	}
	
	private void logDeviceStatistics() {
		logger.info(String.format("devices: %3d configured, %3d polling, msgs received: %5d",
				m_devices.size(), Poller.s_instance().getSizeOfQueue(), m_messagesReceived));
		m_messagesReceived = 0;
		for (InsteonDevice dev : m_devices.values()) {
			if (dev.isModem()) continue;
			if (m_deadDeviceTimeout > 0 &&
					dev.getPollOverDueTime() > m_deadDeviceTimeout) {
				logger.info("device {} has not responded to polls for {} sec", dev.toString(),
						dev.getPollOverDueTime() / 3600);
			}
		}
	}

	private static long s_parseLong(String pi, long min, long max) {
		long t = Long.parseLong(pi);
		t = Math.max(t, min);
		t = Math.min(t, max);
		return t;
	}
}
<code block>

package org.openhab.binding.insteonplm.internal.driver;
import java.io.IOException;
import java.util.HashMap;
import java.util.concurrent.locks.ReentrantLock;

import org.openhab.binding.insteonplm.internal.device.InsteonAddress;
import org.openhab.binding.insteonplm.internal.message.Msg;
import org.openhab.binding.insteonplm.internal.message.MsgListener;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class Driver {
	private static final Logger logger = LoggerFactory.getLogger(Driver.class);


	private HashMap<String, Port> m_ports = new HashMap<String, Port>();
	private DriverListener m_listener = null; 
	private HashMap<InsteonAddress, ModemDBEntry> m_modemDBEntries = new HashMap<InsteonAddress, ModemDBEntry>();
	private ReentrantLock m_modemDBEntriesLock = new ReentrantLock();

	public void setDriverListener(DriverListener listener) {
		m_listener = listener;
	}
	public boolean isReady() {
		for (Port p : m_ports.values()) {
			if (!p.isRunning()) return false;
		}
		return true;
	}
	public HashMap<InsteonAddress, ModemDBEntry> lockModemDBEntries() {
		m_modemDBEntriesLock.lock();
		return m_modemDBEntries;
	}
	public void unlockModemDBEntries() {
		m_modemDBEntriesLock.unlock();
	}

	public void addPort(String name, String port) {
		if (m_ports.keySet().contains(port)) {
			logger.warn("ignored attempt to add duplicate port: {} {}", name, port);
		} else {
			m_ports.put(port, new Port(port, this));
			logger.debug("added new port: {} {}", name, port);
		}
	}

	public void addMsgListener(MsgListener listener, String port) {
		if (m_ports.keySet().contains(port)) {
			m_ports.get(port).addListener(listener);
		} else {
			logger.error("referencing unknown port {}!", port);
		}
	}
	
	public void startAllPorts() {
		for (Port p : m_ports.values()) { p.start(); }
	}
	
	public void stopAllPorts() {
		for (Port p : m_ports.values()) { p.stop(); }
	}


	public void writeMessage(String port, Msg m) throws IOException {
		Port p = getPort(port);
		if (p == null) {
			logger.error("cannot write to unknown port {}", port);
			throw new IOException();
		}
		p.writeMessage(m);
	}
	
	public String getDefaultPort() {
		return (m_ports.isEmpty() ? null : m_ports.keySet().iterator().next());
	}
	
	public int getNumberOfPorts() {
		int n = 0;
		for (Port p : m_ports.values()) {
			if (p.isRunning()) n++;
		}
		return n;
	}
	
	public boolean isMsgForUs(InsteonAddress toAddr) {
		if (toAddr == null) return false;
		for (Port p : m_ports.values()) {
			if (p.getAddress().equals(toAddr)) return true;
		}
		return false;
	}

	public Port getPort(String port) {
		if (port.equalsIgnoreCase("DEFAULT")) {
			if (m_ports.isEmpty()) {
				logger.error("no default port found!");
				return null;
			}
			return m_ports.values().iterator().next();
		}
		if (!m_ports.containsKey(port)) {
			logger.error("no port of name {} found!", port);
			return null;
		}
		return m_ports.get(port);
	}
	
	public void modemDBComplete(Port port) {

		if (!isModemDBComplete()) return;

		m_listener.driverCompletelyInitialized();
	}

	public boolean isModemDBComplete() {

		for (Port p : m_ports.values()) {
			if (!p.isModemDBComplete()) {
				return false;
			}
		}
		return true;
	}
}

<code block>

package org.openhab.binding.insteonplm.internal.driver;

import java.io.IOException;
import java.util.ArrayList;
import java.util.concurrent.LinkedBlockingQueue;

import org.openhab.binding.insteonplm.internal.device.ModemDBBuilder;
import org.openhab.binding.insteonplm.internal.device.DeviceType;
import org.openhab.binding.insteonplm.internal.device.DeviceTypeLoader;
import org.openhab.binding.insteonplm.internal.device.InsteonAddress;
import org.openhab.binding.insteonplm.internal.device.InsteonDevice;
import org.openhab.binding.insteonplm.internal.message.FieldException;
import org.openhab.binding.insteonplm.internal.message.Msg;
import org.openhab.binding.insteonplm.internal.message.MsgFactory;
import org.openhab.binding.insteonplm.internal.message.MsgListener;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class Port {
	private static final Logger logger = LoggerFactory.getLogger(Port.class);


	enum ReplyType {
		GOT_ACK,
		WAITING_FOR_ACK,
		GOT_NACK
	}

	private IOStream		m_ioStream	= null;
	private	String			m_devName	= "INVALID";
	private	String			m_logName	= "INVALID";
	private Modem			m_modem		= null;
	private IOStreamReader	m_reader	= null;
	private	IOStreamWriter	m_writer	= null;
	private	final int		m_readSize	= 1024; 
	private	Thread			m_readThread  = null;
	private	Thread			m_writeThread = null;
	private	boolean			m_running	  = false;
	private boolean			m_modemDBComplete = false;
	private MsgFactory		m_msgFactory = new MsgFactory();
	private Driver			m_driver	 = null;
	private ArrayList<MsgListener>	 m_listeners = new ArrayList<MsgListener>();
	private LinkedBlockingQueue<Msg> m_writeQueue = new LinkedBlockingQueue<Msg>();


	public Port(String devName, Driver d) {
		m_devName	= devName;
		m_driver	= d;
		m_logName	= devName;
		m_modem		= new Modem();
		addListener(m_modem);
		m_ioStream 	= IOStream.s_create(devName);
		m_reader	= new IOStreamReader();
		m_writer	= new IOStreamWriter();
	}

	public synchronized boolean isModemDBComplete() { return (m_modemDBComplete); }
	public boolean 			isRunning() 	{ return m_running; }
	public InsteonAddress	getAddress()	{ return m_modem.getAddress(); }
	public String			getDeviceName()	{ return m_devName; }
	public Driver			getDriver()		{ return m_driver; }

	
	public void addListener (MsgListener l) {
		synchronized(m_listeners) {
			if (!m_listeners.contains(l)) m_listeners.add(l);
		}
	}
	
	public void removeListener(MsgListener l) {
		synchronized(m_listeners) {
			if (m_listeners.remove(l)) {

			}
		}
	}


	public void start() {
		logger.debug("starting port {}", m_logName);
		if (m_running) {
			logger.debug("port {} already running, not started again", m_logName);
		}
		if (!m_ioStream.open()) {
			logger.debug("failed to open port {}", m_logName);
			return;
		}
		m_readThread	= new Thread(m_reader);
		m_writeThread	= new Thread(m_writer);
		m_readThread.setName(m_logName + " Reader");
		m_writeThread.setName(m_logName + " Writer");
		m_readThread.start();
		m_writeThread.start();
		m_modem.initialize();
		ModemDBBuilder mdbb = new ModemDBBuilder(this);
		mdbb.start(); 
		m_running = true;
	}


	public void stop() {
		if (!m_running) {
			logger.debug("port {} not running, no need to stop it", m_logName);
			return;
		}
		if (m_readThread != null) m_readThread.interrupt();
		if (m_writeThread != null) m_writeThread.interrupt();
		logger.debug("waiting for read thread to exit for port {}",
				m_logName);
		try {
			if (m_readThread != null) m_readThread.join();
		} catch (InterruptedException e) {
			logger.debug("got interrupted waiting for read thread to exit.");
		}
		logger.debug("waiting for write thread to exit for port {}",
				m_logName);
		try {
			if (m_writeThread != null) m_writeThread.join();
		} catch (InterruptedException e) {
			logger.debug("got interrupted waiting for write thread to exit.");
		}
		logger.debug("all threads for port {} stopped.", m_logName);
		m_ioStream.close();
		m_running = false;
		synchronized (m_listeners) {
			m_listeners.clear();
		}
	}

	public void writeMessage(Msg m) throws IOException {
		if (m == null) {
			logger.error("trying to write null message!");
			throw new IOException("trying to write null message!");
		}
		if (m.getData() == null) {
			logger.error("trying to write message without data!");
			throw new IOException("trying to write message without data!");
		}
		try {
			m_writeQueue.add(m);
			logger.trace("enqueued msg: {}", m);
		} catch (IllegalStateException e) {
			logger.error("cannot write message {}, write queue is full!", m);
		}
		
	}


	public void modemDBComplete() {
		synchronized (this) {
			m_modemDBComplete = true;
		}
		m_driver.modemDBComplete(this);
	}


	class IOStreamReader implements Runnable {
		
		private ReplyType	m_reply = ReplyType.GOT_ACK;
		private	Object		m_replyLock = new Object();

		public	Object getRequestReplyLock() { return m_replyLock; }

		@Override
		public void run() {
			logger.debug("starting reader...");
			byte[] buffer = new byte[2 * m_readSize];
			for (int len = -1; (len = m_ioStream.read(buffer, 0, m_readSize)) > 0;) {
				m_msgFactory.addData(buffer, len);
				processMessages();
			}
		}
		
		private void processMessages() {
			try {

				for (Msg m = m_msgFactory.processData(); m != null;
						m = m_msgFactory.processData()) {
						toAllListeners(m);
						notifyWriter(m);
				}
			} catch (IOException e) {


				logger.warn("bad data received: {}", e.toString());
				synchronized (getRequestReplyLock()) {
					if (m_reply == ReplyType.WAITING_FOR_ACK) {
						logger.warn("got bad data back, must assume message was acked.");
						m_reply = ReplyType.GOT_ACK;
						getRequestReplyLock().notify();
					}
				}
			}
		}

		private void notifyWriter(Msg msg) {
			synchronized (getRequestReplyLock()) {
				if (m_reply == ReplyType.WAITING_FOR_ACK) {
					if (!msg.isUnsolicited()) {
						m_reply = (msg.isPureNack() ? ReplyType.GOT_NACK : ReplyType.GOT_ACK);
						logger.trace("signaling receipt of ack: {}", (m_reply == ReplyType.GOT_ACK));
						getRequestReplyLock().notify();
					} else if (msg.isPureNack()){
						m_reply = ReplyType.GOT_NACK;
						logger.trace("signaling receipt of pure nack");
						getRequestReplyLock().notify();
					} else {
						logger.trace("got unsolicited message");
					}
				}
			}
		}

		@SuppressWarnings("unchecked")
		private void toAllListeners(Msg msg) {





			ArrayList<MsgListener> tempList = null;
			synchronized(m_listeners) {
				tempList= (ArrayList<MsgListener>) m_listeners.clone();
			}
			for (MsgListener l : tempList) {
				l.msg(msg, m_devName); 
			}
		}
		

		public boolean waitForReply() {
			m_reply = ReplyType.WAITING_FOR_ACK;
			while (m_reply == ReplyType.WAITING_FOR_ACK) {
				try {
					logger.trace("writer waiting for ack.");
					getRequestReplyLock().wait();
					logger.trace("writer got ack: {}", (m_reply == ReplyType.GOT_ACK));
				} catch (InterruptedException e) {

				}
			}
			return (m_reply == ReplyType.GOT_NACK);
		}
	}

	class IOStreamWriter implements Runnable {
		private static final int WAIT_TIME = 200; 
		@Override
		public void run() {
			logger.debug("starting writer...");
			while(true) {
				try {

					logger.trace("writer checking message queue");
					Msg msg = m_writeQueue.take();
					if (msg.getData() == null) {
						logger.error("found null message in write queue!");
					} else {
						logger.debug("writing ({}): {}", msg.getQuietTime(), msg);




						synchronized (m_reader.getRequestReplyLock()) {
							m_ioStream.write(msg.getData());
							while (m_reader.waitForReply()) {
								Thread.sleep(WAIT_TIME);
								logger.trace("retransmitting msg: {}", msg);
								m_ioStream.write(msg.getData());
							}
							
						}

						if (msg.getQuietTime() > 0) {
							Thread.sleep(msg.getQuietTime());
						}
					}
				} catch (InterruptedException e) {
					logger.error("got interrupted exception in write thread:", e);
				} catch (Exception e) {
					logger.error("got exception in write thread:", e);
				}
			}
		}
	}

	class Modem implements MsgListener {
		private InsteonDevice m_device = null;
		InsteonAddress getAddress() { return (m_device == null) ? new InsteonAddress() : (m_device.getAddress()); }
		InsteonDevice getDevice() { return m_device; }
		@Override
		public void msg(Msg msg, String fromPort) {
			try {
				if (msg.isPureNack()) return;
				if (msg.getByte("Cmd") == 0x60) {

					InsteonAddress a = new InsteonAddress(msg.getAddress("IMAddress"));
					String prodKey = "0x000045";
					DeviceType dt = DeviceTypeLoader.s_instance().getDeviceType(prodKey);
					if (dt == null) {
						logger.error("unknown modem product key: {} for modem: {}.", prodKey, a);
					} else {
						m_device =	InsteonDevice.s_makeDevice(dt);
						m_device.setAddress(a);
						m_device.setProductKey(prodKey);
						m_device.setDriver(m_driver);
						m_device.setIsModem(true);
						m_device.addPort(fromPort);
						logger.debug("found modem {} in device_types: {}", a, m_device.toString());
					}

					removeListener(this);
				}
			} catch (FieldException e) {
				logger.error("error parsing im info reply field: ", e);
			}
		}
		public void initialize() {
			try {
				Msg m = Msg.s_makeMessage("GetIMInfo");
				writeMessage(m);
			} catch (IOException e) {
				logger.error("modem init failed!", e);
			}
		}
	}
}

<code block>

package org.openhab.binding.insteonplm.internal.message;

import java.io.IOException;

import org.openhab.binding.insteonplm.internal.utils.Utils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class MsgFactory {
	private static final Logger logger = LoggerFactory.getLogger(MsgFactory.class);


	private final static int	MAX_MSG_LEN = 4096;
	private byte[] 				m_buf = new byte[MAX_MSG_LEN];
	private int					m_end = 0;	
	

	public MsgFactory() {
	}
	

	public void addData(byte [] data, int len) {
		if (len + m_end > MAX_MSG_LEN) {
			logger.error("warn: truncating excessively long message!");
			len = MAX_MSG_LEN - m_end;
		}

		System.arraycopy(data, 0, m_buf, m_end, len);
		m_end += len;

		logger.trace("read buffer: len {} data: {}", m_end, Utils.getHexString(m_buf, m_end));
	}

	public Msg processData() throws IOException {

		if (m_end > 0 && m_buf[0] == 0x15) {
			logger.trace("got pure nack!");
			removeFromBuffer(1);
			try {
				Msg m = Msg.s_makeMessage("PureNACK");
				return m;
			} catch (IOException e) {
				return null;
			}
		}

		if (m_end > 0 && m_buf[0] != 0x02) {
			logger.error("incoming message does not start with 0x02, searching for start");
			drainBuffer();
			throw new IOException("message does not start with 0x02!");
		}



		int msgLen = -1;
		boolean isExtended = false;
		if (m_end > 1) {

			int headerLength = Msg.s_getHeaderLength(m_buf[1]);
			isExtended = Msg.s_isExtended(m_buf, m_end, headerLength);
			logger.trace("header length expected: {} extended: {}", headerLength, isExtended);
			if (headerLength < 0) {
				String cmdCode = Utils.getHexByte(m_buf[1]);
				logger.debug("got unknown command code {}, draining!", cmdCode);

				removeFromBuffer(1); 
				drainBuffer(); 
				msgLen = -1; 
				throw new IOException("got unknown command code: " + cmdCode);
			} else if (headerLength >= 2) {
				if (m_end >= headerLength) {

					msgLen = Msg.s_getMessageLength(m_buf[1], isExtended);
				}
			} else { 
				logger.error("invalid header length, internal error!");
				msgLen = -1;
			}
		}
		logger.trace("msgLen expected: {}", msgLen);
		Msg msg = null;
		if (msgLen > 0 && m_end >= msgLen) {
			msg = Msg.s_createMessage(m_buf, msgLen, isExtended);
			removeFromBuffer(msgLen);
		}
		logger.trace("keeping buffer len {} data: {}", m_end, Utils.getHexString(m_buf, m_end));
		return msg;
	}
	
	private void drainBuffer() {
		while (m_end > 0 && m_buf[0] != 0x02) {
			removeFromBuffer(1);
		}
	}
	
	private void removeFromBuffer(int len) {
		if (len > m_end) len = m_end;
		System.arraycopy(m_buf, len, m_buf, 0, m_end + 1 - len);
		m_end -= len;
	}
}

<code block>

package org.openhab.binding.insteonplm.internal.device;

import java.io.IOException;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.GregorianCalendar;
import java.util.HashMap;

import org.openhab.binding.insteonplm.internal.device.DeviceFeatureListener.StateChangeType;
import org.openhab.binding.insteonplm.internal.device.GroupMessageStateMachine.GroupMessage;
import org.openhab.binding.insteonplm.internal.message.FieldException;
import org.openhab.binding.insteonplm.internal.message.Msg;
import org.openhab.binding.insteonplm.internal.message.MsgType;
import org.openhab.binding.insteonplm.internal.utils.Utils;
import org.openhab.core.library.types.DateTimeType;
import org.openhab.core.library.types.DecimalType;
import org.openhab.core.library.types.OnOffType;
import org.openhab.core.library.types.OpenClosedType;
import org.openhab.core.library.types.PercentType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;



public abstract class MessageHandler {
	private static final Logger logger = LoggerFactory.getLogger(MessageHandler.class);
	
	DeviceFeature				m_feature	 	= null;
	HashMap<String, String> 	m_parameters	= new HashMap<String, String>();
	HashMap<Integer, GroupMessageStateMachine>	m_groupState = new HashMap<Integer, GroupMessageStateMachine>();

	MessageHandler(DeviceFeature p) {
		m_feature = p;
	}

	public abstract void handleMessage(int group, byte cmd1, Msg msg,
			DeviceFeature feature, String fromPort);
	

	public void sendExtendedQuery(DeviceFeature f, byte aCmd1, byte aCmd2) {
		InsteonDevice d = f.getDevice();
		try {
			Msg m = d.makeExtendedMessage((byte)0x1f, aCmd1, aCmd2);
			m.setQuietTime(500L);
			d.enqueueMessage(m, f);
		} catch (IOException e) {
			logger.warn("i/o problem sending query message to device {}", d.getAddress());
		} catch (FieldException e) {
			logger.warn("field exception sending query message to device {}", d.getAddress());
		}
	}

	public int getGroup() {
		return (getIntParameter("group", -1));
	}

	protected int getIntParameter(String key, int def) {
		try {
			if (m_parameters.get(key) != null) {
				return Integer.parseInt(m_parameters.get(key));
			}
		} catch (NumberFormatException e) {
			logger.error("malformed int parameter in message handler: {}", key);
		}
		return def;
	}

	protected boolean isMybutton(Msg msg, DeviceFeature f) {
		int myButton = getIntParameter("button", -1);



		if (myButton == -1) return true;
		
		int button = getButtonInfo(msg, f);
		return button != -1 && myButton == button;
	}

	protected boolean isDuplicate(Msg msg) {
		boolean isDuplicate = false;
		try {
			MsgType t = MsgType.s_fromValue(msg.getByte("messageFlags"));
			int hops = msg.getHopsLeft();
			if (t == MsgType.ALL_LINK_BROADCAST) {
				int group = (int) (msg.getAddress("toAddress").getLowByte() & 0xff);
				byte cmd1 = msg.getByte("command1");



				GroupMessage gm = (cmd1 == 0x06) ? GroupMessage.SUCCESS :
										GroupMessage.BCAST;
				isDuplicate = !updateGroupState(group, hops, gm);
			} else if (t == MsgType.ALL_LINK_CLEANUP) {


				int group = (int)(msg.getByte("command2") & 0xff);
				isDuplicate = !updateGroupState(group, hops,
								GroupMessage.CLEAN);
			}
		} catch (IllegalArgumentException e) {
			logger.error("cannot parse msg: {}", msg, e);			
		} catch (FieldException e) {
			logger.error("cannot parse msg: {}", msg, e);
		}
		return (isDuplicate);
	}

	private boolean updateGroupState(int group, int hops, GroupMessage a) {
		GroupMessageStateMachine m = m_groupState.get(new Integer(group));
		if (m == null) {
			m = new GroupMessageStateMachine();
			m_groupState.put(new Integer(group), m);
		}
		logger.debug("updating group state for {} to {}", group, a);
		return (m.action(a, hops));
	}
	

	static protected int getButtonInfo(Msg msg, DeviceFeature f) {


		try {
			int bclean = (int) (msg.getByte("command2") & 0xff);
			int bbcast = (int) (msg.getAddress("toAddress").getLowByte() & 0xff);
			int button = msg.isCleanup() ? bclean : bbcast;
			logger.trace("{} button: {} bclean: {} bbcast: {}",
					f.getDevice().getAddress(), button, bclean, bbcast);
			return button;
		}  catch (FieldException e) {
			logger.error("field exception while parsing msg {}: ", msg, e);
		}
		return -1;
	}
	

	protected String nm() {
		return (this.getClass().getSimpleName());
	}
	

	public void setParameters(HashMap<String, String> hm) { m_parameters = hm; }
	
	





	
	public static class DefaultMsgHandler extends MessageHandler {
		DefaultMsgHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
					DeviceFeature f, String fromPort) {
			logger.debug("{} drop unimpl message {}: {}", nm(), Utils.getHexByte(cmd1), msg);
		}
	}

	public static class NoOpMsgHandler extends MessageHandler {
		NoOpMsgHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			logger.debug("{} ignore msg {}: {}", nm(), Utils.getHexByte(cmd1), msg);
		}
	}

	public static class LightOnDimmerHandler extends MessageHandler {
		LightOnDimmerHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			if (isDuplicate(msg) || !isMybutton(msg, f)) {
				return;
			}
			InsteonAddress a = f.getDevice().getAddress();
			if (msg.isAckOfDirect()) {
				logger.error("{}: device {}: ignoring ack of direct.", nm(), a);
			} else {
				logger.info("{}: device {} was turned on. Sending poll request to get actual level", nm(), a);
				m_feature.publish(PercentType.HUNDRED, StateChangeType.ALWAYS);



				Msg m = f.makePollMsg();
				if (m != null)	f.getDevice().enqueueDelayedMessage(m, f, 1000);
			}
		}
	}

	public static class LightOnSwitchHandler extends MessageHandler {
		LightOnSwitchHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			if (!isDuplicate(msg) && isMybutton(msg, f)) {
				logger.info("{}: device {} was switched on.", nm(),
								f.getDevice().getAddress());
				f.publish(OnOffType.ON, StateChangeType.ALWAYS);
			} else {
				logger.debug("ignored message: {} or {}", isDuplicate(msg), isMybutton(msg,f));
			}
		}
	}

	public static class LightOffDimmerHandler extends MessageHandler {
		LightOffDimmerHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			if (!isDuplicate(msg) && isMybutton(msg, f)) {
				logger.info("{}: device {} was turned off.", nm(),
						f.getDevice().getAddress());
				f.publish(PercentType.ZERO, StateChangeType.ALWAYS);
			}
		}
	}

	public static class LightOffSwitchHandler extends MessageHandler {
		LightOffSwitchHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			if (!isDuplicate(msg) && isMybutton(msg, f)) {
				logger.info("{}: device {} was switched off.", nm(),
						f.getDevice().getAddress());
				f.publish(OnOffType.OFF, StateChangeType.ALWAYS);
			}
		}
	}



	public static class SwitchRequestReplyHandler extends  MessageHandler {
		SwitchRequestReplyHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			try {
				InsteonAddress a = f.getDevice().getAddress();
				int cmd2	= (int) (msg.getByte("command2") & 0xff);
				int button	= this.getIntParameter("button", -1);
				if (button < 0) {
					handleNoButtons(cmd2, a, msg);
				} else {
					boolean isOn = isLEDLit(cmd2, button);
					logger.info("{}: dev {} button {} switched to {}", nm(),
													a, button, isOn ? "ON" : "OFF");
					m_feature.publish(isOn ? OnOffType.ON : OnOffType.OFF, StateChangeType.CHANGED);
				}
			} catch (FieldException e) {
				logger.error("{} error parsing {}: ", nm(), msg, e);
			}
		}

		void handleNoButtons(int cmd2, InsteonAddress a, Msg msg) {
			if (cmd2 == 0) {
				logger.info("{}: set device {} to OFF", nm(), a);
				m_feature.publish(OnOffType.OFF, StateChangeType.CHANGED);
			} else if (cmd2 == 0xff) {
				logger.info("{}: set device {} to ON", nm(), a);
				m_feature.publish(OnOffType.ON, StateChangeType.CHANGED);
			} else {
				logger.warn("{}: {} ignoring unexpected cmd2 in msg: {}",
							nm(), a, msg);
			}	
		}

		private boolean isLEDLit(int cmd, int button) {
			boolean isSet = (cmd & (0x1 << (button-1))) != 0;
			logger.trace("cmd: {} button {}", Integer.toBinaryString(cmd), button);
			logger.trace("msk: {} isSet: {}", Integer.toBinaryString(0x1 << (button-1)), isSet);
			return (isSet);
		}
	}


	public static class DimmerRequestReplyHandler extends  MessageHandler {
		DimmerRequestReplyHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			InsteonDevice dev = f.getDevice();
			try {
				int cmd2 = (int) (msg.getByte("command2") & 0xff);
				if (cmd2 == 0xfe) {

					cmd2 = 0xff;
				}

				if (cmd2 == 0) {
					logger.info("{}: set device {} to level 0", nm(),
							dev.getAddress());
					m_feature.publish(PercentType.ZERO, StateChangeType.CHANGED);
				} else if (cmd2 == 0xff) {
					logger.info("{}: set device {} to level 100", nm(),
							dev.getAddress());
					m_feature.publish(PercentType.HUNDRED, StateChangeType.CHANGED);
				} else {
					int level = cmd2*100/255;
					if (level == 0) level = 1;
					logger.info("{}: set device {} to level {}", nm(),
							dev.getAddress(), level);
					m_feature.publish(new PercentType(level), StateChangeType.CHANGED);
				}
			} catch (FieldException e) {
				logger.error("{}: error parsing {}: ", nm(), msg, e);
			}
		}
	}

	public static class StopManualChangeHandler extends MessageHandler {
		StopManualChangeHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			Msg m = f.makePollMsg();
			if (m != null)	f.getDevice().enqueueMessage(m, f);
		}
	}

	public static class InfoRequestReplyHandler extends MessageHandler {
		InfoRequestReplyHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			InsteonDevice dev = f.getDevice();
			if (!msg.isExtended()) {
				logger.warn("{} device {} expected extended msg as info reply, got {}",
						nm(), dev.getAddress(), msg);
				return;
			}
			try {
				int cmd2 = (int) (msg.getByte("command2") & 0xff);
				switch (cmd2) {
				case 0x00: 
					int prodKey = msg.getInt24("userData2", "userData3", "userData4");
					int devCat  = msg.getByte("userData5");
					int subCat  = msg.getByte("userData6");
					logger.info("{} {} got product data: cat: {} subcat: {} key: {} ",
							nm(), dev.getAddress(), devCat, subCat,	Utils.getHexString(prodKey));
					break;
				case 0x02: 
					logger.info("{} {} got text str {} ", nm(), dev.getAddress(), msg);
					break;
				default:
					logger.warn("{} unknown cmd2 = {} in info reply message {}", nm(), cmd2, msg);
					break;
				}
			} catch (FieldException e) {
				logger.error("error parsing {}: ", msg, e);
			}
		}
	}

	public static class MotionSensorDataReplyHandler extends MessageHandler {
		MotionSensorDataReplyHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			InsteonDevice dev = f.getDevice();
			if (!msg.isExtended()) {
				logger.trace("{} device {} ignoring non-extended msg {}", nm(), dev.getAddress(), msg);
				return;
			}
			try {
				int cmd2 = (int) (msg.getByte("command2") & 0xff);
				switch (cmd2) {
				case 0x00: 
					int batteryLevel = msg.getByte("userData12") & 0xff;
					int lightLevel = msg.getByte("userData11") & 0xff;
					logger.debug("{}: {} got light level: {}, battery level: {}",
								nm(), dev.getAddress(), lightLevel, batteryLevel);
					m_feature.publish(new DecimalType(lightLevel), StateChangeType.CHANGED, "field", "light_level");
					m_feature.publish(new DecimalType(batteryLevel), StateChangeType.CHANGED, "field", "battery_level");
					break;
				default:
					logger.warn("unknown cmd2 = {} in info reply message {}", cmd2, msg);
					break;
				}
			} catch (FieldException e) {
				logger.error("error parsing {}: ", msg, e);
			}
		}
	}
	
	public static class HiddenDoorSensorDataReplyHandler extends MessageHandler {
		HiddenDoorSensorDataReplyHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			InsteonDevice dev = f.getDevice();
			if (!msg.isExtended()) {
				logger.trace("{} device {} ignoring non-extended msg {}", nm(), dev.getAddress(), msg);
				return;
			}
			try {
				int cmd2 = (int) (msg.getByte("command2") & 0xff);
				switch (cmd2) {
				case 0x00: 
					int batteryLevel = msg.getByte("userData4") & 0xff;
					int batteryWatermark = msg.getByte("userData7") & 0xff;
					logger.debug("{}: {} got light level: {}, battery level: {}",
								nm(), dev.getAddress(), batteryWatermark, batteryLevel);
					m_feature.publish(new DecimalType(batteryWatermark), StateChangeType.CHANGED, "field", "battery_watermark_level");
					m_feature.publish(new DecimalType(batteryLevel), StateChangeType.CHANGED, "field", "battery_level");
					break;
				default:
					logger.warn("unknown cmd2 = {} in info reply message {}", cmd2, msg);
					break;
				}
			} catch (FieldException e) {
				logger.error("error parsing {}: ", msg, e);
			}
		}
	}

	public static class PowerMeterUpdateHandler extends MessageHandler {
		PowerMeterUpdateHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			if (msg.isExtended()) {
				try {

					int b7	= msg.getByte("userData7")	& 0xff;
					int b8	= msg.getByte("userData8")	& 0xff;
					int watts = (b7 << 8) | b8;
					if (watts > 32767) {
						watts -= 65535;
					}

					int b9	= msg.getByte("userData9")	& 0xff;
					int b10	= msg.getByte("userData10")	& 0xff;
					int b11	= msg.getByte("userData11")	& 0xff;
					int b12	= msg.getByte("userData12")	& 0xff;
					BigDecimal kwh = BigDecimal.ZERO;
					if (b9 < 254) {
						int e = (b9 << 24) | (b10 << 16) | (b11 << 8) | b12;
						kwh = new BigDecimal(e * 65535.0 / (1000 * 60 * 60 * 60)).setScale(4, RoundingMode.HALF_UP);
					}

					logger.debug("{}:{} watts: {} kwh: {} ", nm(), f.getDevice().getAddress(), watts, kwh);
					m_feature.publish(new DecimalType(kwh), StateChangeType.CHANGED, "field", "kwh");
					m_feature.publish(new DecimalType(watts), StateChangeType.CHANGED, "field", "watts");
				} catch (FieldException e) {
					logger.error("error parsing {}: ", msg, e);
				}
			}
		}
	}
	
	public static class PowerMeterResetHandler extends MessageHandler {
		PowerMeterResetHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			InsteonDevice dev = f.getDevice();
			logger.info("{}: power meter {} was reset", nm(), dev.getAddress());


			Msg m = f.makePollMsg();
			if (m != null)	f.getDevice().enqueueMessage(m, f);
		}
	}
	
	public static class LastTimeHandler extends MessageHandler {
		LastTimeHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1a, Msg msg,
				DeviceFeature f, String fromPort) {
			GregorianCalendar calendar = new GregorianCalendar();
			calendar.setTimeInMillis(System.currentTimeMillis());
			DateTimeType t = new DateTimeType(calendar);
			m_feature.publish(t, StateChangeType.ALWAYS);
		}
	}

	public static class ContactRequestReplyHandler extends MessageHandler {
		ContactRequestReplyHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1a, Msg msg,
				DeviceFeature f, String fromPort) {
			byte cmd  = 0x00;
			byte cmd2 = 0x00;
			try {
				cmd = msg.getByte("Cmd");
				cmd2 = msg.getByte("command2");
			} catch (FieldException e) {
				logger.debug("{} no cmd found, dropping msg {}", nm(), msg);
				return;
			}
			if (msg.isAckOfDirect() && (f.getQueryStatus() == DeviceFeature.QueryStatus.QUERY_PENDING)
					&& cmd == 0x50) {
				OpenClosedType oc = (cmd2 == 0) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;
				logger.info("{}: set contact {} to: {}", nm(), f.getDevice().getAddress(), oc);
				m_feature.publish(oc, StateChangeType.CHANGED);
			}
		}
	}

	public static class ClosedContactHandler extends MessageHandler {
		ClosedContactHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			m_feature.publish(OpenClosedType.CLOSED, StateChangeType.ALWAYS);
		}
	}

	public static class OpenedContactHandler extends MessageHandler {
		OpenedContactHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			m_feature.publish(OpenClosedType.OPEN, StateChangeType.ALWAYS);
		}
	}

	public static class OpenedOrClosedContactHandler extends MessageHandler {
		OpenedOrClosedContactHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			if (cmd1 != 0x11) return;
			try {
				byte cmd2 = msg.getByte("command2");
				switch (cmd2) {
				case 0x02:
					m_feature.publish(OpenClosedType.CLOSED, StateChangeType.CHANGED);
					break;
				case 0x01:
					m_feature.publish(OpenClosedType.OPEN, StateChangeType.CHANGED);
					break;
				default: 
					break;
				}
			} catch (FieldException e) {
				logger.debug("{} no cmd2 found, dropping msg {}", nm(), msg);
				return;
			}

		}
	}

	public static class ClosedSleepingContactHandler extends MessageHandler {
		ClosedSleepingContactHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			m_feature.publish(OpenClosedType.CLOSED, StateChangeType.ALWAYS);
			sendExtendedQuery(f, (byte)0x2e, (byte) 00);
		}
	}

	public static class OpenedSleepingContactHandler extends MessageHandler {
		OpenedSleepingContactHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			m_feature.publish(OpenClosedType.OPEN, StateChangeType.ALWAYS);
			sendExtendedQuery(f, (byte)0x2e, (byte) 00);
		}
	}

	public static class X10OnHandler extends  MessageHandler {
		X10OnHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			InsteonAddress a = f.getDevice().getAddress();
			logger.info("{}: set X10 device {} to ON", nm(), a);
			m_feature.publish(OnOffType.ON, StateChangeType.ALWAYS);
		}
	}
	public static class X10OffHandler extends  MessageHandler {
		X10OffHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			InsteonAddress a = f.getDevice().getAddress();
			logger.info("{}: set X10 device {} to OFF", nm(), a);
			m_feature.publish(OnOffType.OFF, StateChangeType.ALWAYS);
		}
	}
	public static class X10BrightHandler extends  MessageHandler {
		X10BrightHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			InsteonAddress a = f.getDevice().getAddress();
			logger.debug("{}: ignoring brighten message for device {}", nm(), a);
		}
	}
	public static class X10DimHandler extends  MessageHandler {
		X10DimHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			InsteonAddress a = f.getDevice().getAddress();
			logger.debug("{}: ignoring dim message for device {}", nm(), a);
		}
	}
	public static class X10OpenHandler extends  MessageHandler {
		X10OpenHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			InsteonAddress a = f.getDevice().getAddress();
			logger.info("{}: set X10 device {} to OPEN", nm(), a);
			m_feature.publish(OpenClosedType.OPEN, StateChangeType.ALWAYS);
		}
	}
	public static class X10ClosedHandler extends  MessageHandler {
		X10ClosedHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			InsteonAddress a = f.getDevice().getAddress();
			logger.info("{}: set X10 device {} to CLOSED", nm(), a);
			m_feature.publish(OpenClosedType.CLOSED, StateChangeType.ALWAYS);
		}
	}


	public static class ThermostatSetPointMsgHandler extends  MessageHandler {
		ThermostatSetPointMsgHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			InsteonDevice dev = f.getDevice();
			try {
				if (msg.isExtended()) {
					logger.info("{}: received msg for feature {}", nm(), f.getName());
					int level = ((f.getName()).equals("ThermostatCoolSetPoint")) ? (int)(msg.getByte("userData7") & 0xff) : (int)(msg.getByte("userData8") & 0xff);
					logger.info("{}: got SetPoint from {} of value: {}", nm(), dev.getAddress(), level);
					f.publish(new DecimalType(level), StateChangeType.CHANGED);
				} else {
					logger.info("{}: received msg for feature {}", nm(), f.getName());
					int cmd2 = (int) (msg.getByte("command2") & 0xff);
					int level = cmd2/2;
					logger.info("{}: got SETPOINT from {} of value: {}", nm(), dev.getAddress(), level);
					f.publish(new DecimalType(level), StateChangeType.CHANGED);
				}
			} catch (FieldException e) {
				logger.debug("{} no cmd2 found, dropping msg {}", nm(), msg);
				return;
			}
		}
	}


	public static class ThermostatTemperatureRequestReplyHandler extends  MessageHandler {
		ThermostatTemperatureRequestReplyHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			InsteonDevice dev = f.getDevice();
			try {
				int cmd2 = (int) (msg.getByte("command2") & 0xff);
				int level = cmd2/2;
				logger.info("{}: got TEMPERATURE from {} of value: {}", nm(), dev.getAddress(), level);
				logger.info("{}: set device {} to level {}", nm(), dev.getAddress(), level);
				f.publish(new DecimalType(level), StateChangeType.CHANGED);
			} catch (FieldException e) {
				logger.debug("{} no cmd2 found, dropping msg {}", nm(), msg);
				return;
			}
		}
	}	
		

	public static class ThermostatHumidityRequestReplyHandler extends  MessageHandler {
		ThermostatHumidityRequestReplyHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			InsteonDevice dev = f.getDevice();
			try {
				int cmd2 = (int) msg.getByte("command2");
				logger.info("{}: got HUMIDITY from {} of value: {}", nm(), dev.getAddress(), cmd2);
				logger.info("{}: set device {} to level {}", nm(), dev.getAddress(), cmd2);
				f.publish(new PercentType(cmd2), StateChangeType.CHANGED);
			} catch (FieldException e) {
				logger.debug("{} no cmd2 found, dropping msg {}", nm(), msg);
				return;
			}
		}
	}
	

	public static class ThermostatModeControlReplyHandler extends  MessageHandler {
		ThermostatModeControlReplyHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			InsteonDevice dev = f.getDevice();
			try {

				byte cmd2 = msg.getByte("command2");
				switch (cmd2) {
				case 0x04:
					logger.info("{}: set device {} to {}", nm(),
							dev.getAddress(), "HEAT");
					f.publish(new DecimalType(2), StateChangeType.CHANGED);
					break;
				case 0x05:
					logger.info("{}: set device {} to {}", nm(),
							dev.getAddress(), "COOL");
					f.publish(new DecimalType(1), StateChangeType.CHANGED);
					break;
				case 0x06:
					logger.info("{}: set device {} to {}", nm(),
							dev.getAddress(), "AUTO");
					f.publish(new DecimalType(3), StateChangeType.CHANGED);
					break;
				default: 
					break;
				}
			} catch (FieldException e) {
				logger.debug("{} no cmd2 found, dropping msg {}", nm(), msg);
				return;
			}
		}
	}


	public static class ThermostatFanControlReplyHandler extends  MessageHandler {
		ThermostatFanControlReplyHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			InsteonDevice dev = f.getDevice();
			try {

				byte cmd2 = msg.getByte("command2");
				switch (cmd2) {
				case 0x07:
					logger.info("{}: set device {} to {}", nm(),
							dev.getAddress(), "ON");
					f.publish(new DecimalType(2), StateChangeType.CHANGED);
					break;
				case 0x08:
					logger.info("{}: set device {} to {}", nm(),
							dev.getAddress(), "AUTO");
					f.publish(new DecimalType(3), StateChangeType.CHANGED);
					break;	
				case 0x09:
					logger.info("{}: set device {} to {}", nm(),
							dev.getAddress(), "OFF");
					f.publish(new DecimalType(1), StateChangeType.CHANGED);
					break;	
				default: 
					break;
				}
			} catch (FieldException e) {
				logger.debug("{} no cmd2 found, dropping msg {}", nm(), msg);
				return;
			}
		}
	}


	public static class ThermostatMasterControlReplyHandler extends  MessageHandler {
		ThermostatMasterControlReplyHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			try {

				byte cmd2 = msg.getByte("userData3");
				switch (cmd2) {
				case 0x00:
					logger.info("{}: set PRIMARY Thermostat to MASTER", nm());
					f.publish(new DecimalType(1), StateChangeType.CHANGED);
					break;
				case 0x01:
					logger.info("{}: set SECONDARY Thermostat to MASTER", nm());
					f.publish(new DecimalType(2), StateChangeType.CHANGED);
					break;	
				case 0x02:
					logger.info("{}: set TERTIARY Thermostat to MASTER", nm());
					f.publish(new DecimalType(3), StateChangeType.CHANGED);
					break;	
				default: 
					break;
				}
			} catch (FieldException e) {
				logger.debug("{} no cmd2 found, dropping msg {}", nm(), msg);
				return;
			}
		}
	}
	

	public static <T extends MessageHandler> T s_makeHandler(String name, HashMap<String, String> params, DeviceFeature f) {
		String cname = MessageHandler.class.getName() + "$" + name;
		try {
			Class<?> c = Class.forName(cname);
			@SuppressWarnings("unchecked")
			Class<? extends T> dc = (Class <? extends T>) c;
			T mh = dc.getDeclaredConstructor(DeviceFeature.class).newInstance(f);
			mh.setParameters(params);
			return mh;
		} catch (Exception e) {
			logger.error("error trying to create message handler: {}", name, e);
		}
		return null;
	}
}

<code block>

package org.openhab.binding.insteonplm.internal.device;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map.Entry;

import org.openhab.binding.insteonplm.internal.driver.ModemDBEntry;
import org.openhab.binding.insteonplm.internal.driver.Port;
import org.openhab.binding.insteonplm.internal.message.FieldException;
import org.openhab.binding.insteonplm.internal.message.Msg;
import org.openhab.binding.insteonplm.internal.message.MsgListener;
import org.openhab.binding.insteonplm.internal.utils.Utils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class ModemDBBuilder implements MsgListener {
	private static final Logger logger = LoggerFactory.getLogger(ModemDBBuilder.class);
	
	Port m_port = null;
	
	public ModemDBBuilder(Port port) {
		m_port = port;
	}
	
	public void start() {
		m_port.addListener(this);
		logger.debug("querying port for first link record");
		try {
			m_port.writeMessage(Msg.s_makeMessage("GetFirstALLLinkRecord"));
		} catch (IOException e) {
			logger.error("cannot query for link messages", e);
		}
	}
	

	@Override
	public void msg(Msg msg, String fromPort) {
		if (msg.isPureNack()) return;
		try {
			if (msg.getByte("Cmd") == 0x69 ||
						msg.getByte("Cmd") == 0x6a) {



				if (msg.getByte("ACK/NACK") == 0x15) {
					logger.debug("got all link records.");
					done();
				}
			} else if (msg.getByte("Cmd") == 0x57) {

				updateModemDB(msg);
				m_port.writeMessage(Msg.s_makeMessage("GetNextALLLinkRecord"));
			}
		} catch (FieldException e) {
			logger.debug("bad field handling link records {}", e);
		} catch (IOException e) {
			logger.debug("got IO exception handling link records {}", e);
		} catch (IllegalStateException e) {
			logger.debug("got exception requesting link records {}", e);
		}
	}
	
	private void done() {
		logModemDB();
		m_port.removeListener(this);
		m_port.modemDBComplete();
	}
	
	private void logModemDB() {
		try {
			logger.debug("MDB ------- start of modem link records ------------------");
			HashMap<InsteonAddress, ModemDBEntry> dbes = m_port.getDriver().lockModemDBEntries();
			for (Entry<InsteonAddress, ModemDBEntry> db : dbes.entrySet()) {
				ArrayList<Msg> lrs = db.getValue().getLinkRecords();
				for (Msg m: lrs) {
					int recordFlags = m.getByte("RecordFlags") & 0xff;
					String ms = ((recordFlags & (0x1 << 6)) != 0) ? "CTRL" : "RESP";
					logger.debug("MDB {}: {} group: {} data1: {} data2: {} data3: {}",
								db.getKey(), ms, toHex(m.getByte("ALLLinkGroup")),
									toHex(m.getByte("LinkData1")), toHex(m.getByte("LinkData2")),
											toHex(m.getByte("LinkData2")));
				}
				logger.debug("MDB -----");
			}
			logger.debug("MDB ---------------- end of modem link records -----------");
		} catch (FieldException e) {
			logger.error("cannot access field:", e);
		} finally {
			m_port.getDriver().unlockModemDBEntries();
		}
	}
	
	public static String toHex(byte b) {
		return Utils.getHexString(b);
	}
	
	private void updateModemDB(Msg m) 	{
		try {
			HashMap<InsteonAddress, ModemDBEntry> dbes = m_port.getDriver().lockModemDBEntries();
			InsteonAddress linkAddr = m.getAddress("LinkAddr");
			ModemDBEntry dbe = dbes.get(linkAddr);
			if (dbe == null) {
				dbe = new ModemDBEntry(linkAddr);
				dbes.put(linkAddr, dbe);
			}
			dbe.setPort(m_port);
			dbe.addLinkRecord(m);
		} catch (FieldException e) {
			logger.error("cannot access field:", e);
		} finally {
			m_port.getDriver().unlockModemDBEntries();
		}
	}
}

<code block>

package org.openhab.binding.insteonplm;


import java.util.Collection;
import java.util.Dictionary;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.ConcurrentHashMap;

import org.openhab.binding.insteonplm.internal.device.DeviceFeature;
import org.openhab.binding.insteonplm.internal.device.DeviceFeatureListener;
import org.openhab.binding.insteonplm.internal.device.DeviceType;
import org.openhab.binding.insteonplm.internal.device.DeviceTypeLoader;
import org.openhab.binding.insteonplm.internal.device.InsteonAddress;
import org.openhab.binding.insteonplm.internal.device.InsteonDevice;
import org.openhab.binding.insteonplm.internal.device.InsteonDevice.DeviceStatus;
import org.openhab.binding.insteonplm.internal.device.RequestQueueManager;
import org.openhab.binding.insteonplm.internal.driver.Driver;
import org.openhab.binding.insteonplm.internal.driver.DriverListener;
import org.openhab.binding.insteonplm.internal.driver.ModemDBEntry;
import org.openhab.binding.insteonplm.internal.driver.Poller;
import org.openhab.binding.insteonplm.internal.message.FieldException;
import org.openhab.binding.insteonplm.internal.message.Msg;
import org.openhab.binding.insteonplm.internal.message.MsgListener;
import org.openhab.core.binding.AbstractActiveBinding;
import org.openhab.core.binding.BindingProvider;
import org.openhab.core.types.Command;
import org.osgi.service.cm.ConfigurationException;
import org.osgi.service.cm.ManagedService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;




public class InsteonPLMActiveBinding
	extends AbstractActiveBinding<InsteonPLMBindingProvider>
	implements ManagedService {
	private static final Logger logger = LoggerFactory.getLogger(InsteonPLMActiveBinding.class);

	private Driver					m_driver			= null;
	private ConcurrentHashMap<InsteonAddress, InsteonDevice>  m_devices = null; 
	private HashMap<String, String> m_config			= new HashMap<String, String>();
	private PortListener			m_portListener 		= new PortListener();
	private long					m_devicePollInterval 	= 300000L;	
	private long					m_deadDeviceTimeout 	= -1L;
	private long					m_refreshInterval		= 600000L;	
	private int						m_messagesReceived		= 0;
	private boolean					m_isActive		  		= false; 
	private boolean					m_hasInitialItemConfig	= false;
	private int						m_x10HouseUnit			= -1;


	public InsteonPLMActiveBinding() {
		m_driver	= new Driver();
		m_devices 	= new ConcurrentHashMap<InsteonAddress, InsteonDevice>();
	}



	@Override
	public void internalReceiveCommand(String itemName, Command command) {
		logger.info("Item: {} got command {}", itemName, command);

		if(!(isProperlyConfigured() && m_isActive)) {
			logger.debug("not ready to handle commands yet, returning.");
			return;
		}
		boolean commandHandled = false;
		for (InsteonPLMBindingProvider provider : providers) {
			if (provider.providesBindingFor(itemName)) {
				commandHandled = true;
				InsteonPLMBindingConfig c = provider.getInsteonPLMBindingConfig(itemName);
				if (c == null) {
					logger.warn("could not find config for item {}", itemName);
				} else {
					sendCommand(c, command);
				}
			}
		}
		
		if (!commandHandled)
			logger.warn("No converter found for item = {}, command = {}, ignoring.",
						itemName, command.toString());
	}


	@Override
	public void activate() {
		logger.debug("activating binding");
		if (isProperlyConfigured() && !m_isActive) {
			initialize();
		}
		m_isActive = true;
	}
	

	@Override
	public void deactivate() {
		logger.debug("deactivating binding!");
		shutdown();
		m_isActive = false;
	}



	@Override
	protected String getName() {
		return "InsteonPLM";
	}
	

	@Override
	protected void execute() {
		logDeviceStatistics();
	}


	@Override
	protected long getRefreshInterval() {
		return m_refreshInterval;
	}
	

	@Override
	public void bindingChanged(BindingProvider provider, String itemName) {
		super.bindingChanged(provider, itemName);
		m_hasInitialItemConfig = true; 
		InsteonPLMBindingConfig c =
					((InsteonPLMBindingProvider)provider).getInsteonPLMBindingConfig(itemName);
		logger.debug("item {} binding changed: {}", String.format("%-30s", itemName), c);
		if (c == null) {



			removeFeatureListener(itemName);
		} else {
			InsteonDevice dev = getDevice(c.getAddress());
			if (dev == null) {
				dev = makeNewDevice(c);
			}
			addFeatureListener(dev, itemName, c);
		}
	}

	@Override
	public void updated(Dictionary<String, ?> config) throws ConfigurationException {
		HashMap<String, String> newConfig = new HashMap<String, String>();
		if (config == null) {
			logger.debug("seems like our configuration has been erased, will reset everything!");
		} else {

			for (Enumeration<String> e = config.keys(); e.hasMoreElements();) {
				String key   = e.nextElement();
				String value = config.get(key).toString();
				newConfig.put(key, value);
			}
		}
		
		if (newConfig.entrySet().equals(m_config.entrySet())) {
			logger.debug("config has not changed, done.");
			return;
		}
		m_config = newConfig;


		if (m_isActive) {
			if (isProperlyConfigured()) {
				logger.debug("global binding config has changed, resetting.");
				shutdown();
			} else {
				logger.debug("global binding config has arrived.");
			}
		}
		processBindingConfiguration();
		logger.debug("configuration update complete!");
		setProperlyConfigured(true);
		if (m_isActive) {
			initialize();
		}
		if (!m_hasInitialItemConfig) triggerBindingChangedCalls();
		return;
	}

	private void processBindingConfiguration() {
		if (m_config.containsKey("refresh")) {
			m_refreshInterval = Integer.parseInt(m_config.get("refresh"));
			logger.info("refresh interval set to {}s", m_refreshInterval / 1000);
		}
		long deadDeviceCount = 10;
		if (m_config.containsKey("device_dead_count")) {
			deadDeviceCount = s_parseLong(m_config.get("device_dead_count"), 2L, 100000L);
			logger.info("device_dead_count set to {} per config file", deadDeviceCount);
		}
		if (m_config.containsKey("poll_interval")) {
			m_devicePollInterval = s_parseLong(m_config.get("poll_interval"), 5000L, 3600000L);
			logger.info("poll interval set to {} per config file", m_devicePollInterval);
		}
		if (m_config.containsKey("more_devices")) {
			String fileName = m_config.get("more_devices");
			try {
				DeviceTypeLoader.s_instance().loadDeviceTypesXML(fileName);
				logger.info("read additional device definitions from {}", fileName);
			} catch (Exception e) {
				logger.error("error reading additional devices from {}", fileName, e);
			}
		}
		if (m_config.containsKey("modem_db_retry_timeout")) {
			int timeout = Integer.parseInt(m_config.get("modem_db_retry_timeout"));
			m_driver.setModemDBRetryTimeout(timeout);
			logger.info("setting modem db retry timeout to {}s", timeout / 1000);
		}

		if (m_config.containsKey("more_features")) {
			String fileName = m_config.get("more_features");
			logger.info("reading additional feature templates from {}", fileName);
			DeviceFeature.s_readFeatureTemplates(fileName);
		}
		m_deadDeviceTimeout = m_devicePollInterval * deadDeviceCount;
		logger.info("dead device timeout set to {}s", m_deadDeviceTimeout / 1000);
 		
	}
	

	public InsteonDevice getDevice(InsteonAddress aAddr) {
		InsteonDevice dev = (aAddr == null) ? null : m_devices.get(aAddr);
		return (dev);
	}
	


	private void triggerBindingChangedCalls() {
		for (InsteonPLMBindingProvider provider : providers) {
			Collection<String> items = provider.getItemNames();
			for (Iterator<String> item = items.iterator(); item.hasNext();) {
				String itemName = item.next();
				bindingChanged(provider, itemName);
			}
        }
	}
	

	private void initialize() {
		logger.debug("initializing...");
		
		HashSet<String> ports = new HashSet<String>();


		for (Map.Entry<String, String> e : m_config.entrySet()) {
			String name = e.getKey();
			String port  = e.getValue();
			if (ports.contains(port)) {
				logger.warn("port {} {} already in use, check config!", name, port);
				continue;
			}
			logger.info("config: {} -> {}", name, port);
			if (name.startsWith("port_")) {
				m_driver.addPort(name,  port);
				m_driver.addMsgListener(m_portListener, port);
			}
		}
		logger.debug("setting driver listener");
		m_driver.setDriverListener(m_portListener);
		logger.debug("starting {} ports", m_driver.getNumberOfPorts());
		m_driver.startAllPorts();
		logger.debug("ports started");
		switch (m_driver.getNumberOfPorts()) {
		case 0:
			logger.error("initialization complete, but found no ports!");
			break;
		case 1:
			logger.debug("initialization complete, found 1 port!");
			break;
		default:
			logger.warn("initialization complete, found {} ports.",
					m_driver.getNumberOfPorts());
			break;
		}
	}
	

	private void shutdown() {
		logger.debug("shutting down binding");
		m_driver.stopAllPorts();
		m_devices.clear();
		RequestQueueManager.s_destroyInstance();
		Poller.s_instance().stop();
	}
	

	private void sendCommand(InsteonPLMBindingConfig c, Command command) {
		InsteonDevice dev = getDevice(c.getAddress());
		if (dev == null) {
			logger.warn("no device found with insteon address {}", c.getAddress());
			return;
		}
		dev.processCommand(m_driver, c, command);
	}


	private void removeFeatureListener(String aItem) {
		for (Iterator<Entry<InsteonAddress, InsteonDevice>> it = m_devices.entrySet().iterator();
				it.hasNext(); ) {
			InsteonDevice dev = it.next().getValue();
			boolean removedListener = dev.removeFeatureListener(aItem);
			if (removedListener) {
				logger.trace("removed feature listener {} from dev {}", aItem, dev);
			}
			if (!dev.hasAnyListeners()) {
				Poller.s_instance().stopPolling(dev);
				it.remove();
				logger.trace("removing unreferenced {}", dev);
				if (m_devices.isEmpty()) {
					logger.debug("all devices removed!", dev);
				}
			}
		}
	}
	

	private InsteonDevice makeNewDevice(InsteonPLMBindingConfig aConfig) {
		String prodKey = aConfig.getProductKey();
		DeviceType dt = DeviceTypeLoader.s_instance().getDeviceType(prodKey);
		if (dt == null) {
			logger.error("unknown product key: {} for config: {}." +
					" Add definition to xml file and try again", prodKey, aConfig);
			return null;
		}
		InsteonDevice dev =	InsteonDevice.s_makeDevice(dt);
		dev.setAddress(aConfig.getAddress());
		dev.setDriver(m_driver);
		dev.addPort(m_driver.getDefaultPort());
		if (!dev.hasValidPollingInterval()) {
			dev.setPollInterval(m_devicePollInterval);
		}
		if (m_driver.isModemDBComplete() && dev.getStatus() != DeviceStatus.POLLING) {
			int ndev = checkIfInModemDatabase(dev);
			if (dev.hasModemDBEntry()) {
				dev.setStatus(DeviceStatus.POLLING);
				Poller.s_instance().startPolling(dev, ndev);
			}
		}
		m_devices.put(aConfig.getAddress(), dev);
		return (dev);
	}
	

	private int checkIfInModemDatabase(InsteonDevice dev) {
		InsteonAddress addr = dev.getAddress();
		HashMap<InsteonAddress, ModemDBEntry> dbes = m_driver.lockModemDBEntries();
		if (dbes.containsKey(addr)) {
			if (!dev.hasModemDBEntry()) {
				logger.info("device {} found in the modem database!", addr);
				dev.setHasModemDBEntry(true);
			}
		} else {
			if (m_driver.isModemDBComplete() && !addr.isX10()) {
				logger.warn("device {} not found in the modem database. Did you forget to link?", addr);
			}
		}
		int ndev = dbes.size();
		m_driver.unlockModemDBEntries();
		return ndev;
	}

	private void addFeatureListener(InsteonDevice aDev, String aItemName,
				InsteonPLMBindingConfig aConfig) {
		if (aDev == null) {
			return;
		}
		DeviceFeature f = aDev.getFeature(aConfig.getFeature());
		if (f == null) {
			logger.error("item {} references unknown feature: {}, item disabled!", aItemName, aConfig.getFeature());
			return;
		}
		DeviceFeatureListener fl = new DeviceFeatureListener(this, aItemName, eventPublisher);
		fl.setParameters(aConfig.getParameters());
		f.addListener(fl);	
	}


	private class PortListener implements MsgListener, DriverListener {

		@Override
		public void msg(Msg msg, String fromPort) {
			if (msg.isEcho() || msg.isPureNack()) return;
			m_messagesReceived++;
			logger.debug("got msg: {}", msg);
			if (msg.isX10()) {
				handleX10Message(msg, fromPort);
			} else {
				handleInsteonMessage(msg, fromPort);
			}
			
		}

		@Override
		public void driverCompletelyInitialized() {
			HashMap<InsteonAddress, ModemDBEntry> dbes = m_driver.lockModemDBEntries();
			logger.info("modem database has {} entries!", dbes.size());
			if (dbes.isEmpty()) {
				logger.warn("the modem link database is empty!");
			}
			for (InsteonAddress k : dbes.keySet()) {
				logger.debug("modem db entry: {}", k);
			}
			for (InsteonDevice dev : m_devices.values()) {
				InsteonAddress a = dev.getAddress();
				if (!dbes.containsKey(a)) {
					if (!a.isX10())
						logger.warn("device {} not found in the modem database. Did you forget to link?", a);
				} else {
					if (!dev.hasModemDBEntry()) {
						logger.info("device {}     found in the modem database!", a);
						dev.setHasModemDBEntry(true);
					}
					if (dev.getStatus() != DeviceStatus.POLLING) {
						Poller.s_instance().startPolling(dev, dbes.size());
					}
				}
			}
			m_driver.unlockModemDBEntries();
		}
		private void handleInsteonMessage(Msg msg, String fromPort) {
			InsteonAddress toAddr = msg.getAddr("toAddress");
			if (!msg.isBroadcast() && !m_driver.isMsgForUs(toAddr)) {

				return;
			}
			InsteonAddress fromAddr = msg.getAddr("fromAddress");
			if (fromAddr == null) {
				logger.debug("invalid fromAddress, ignoring msg {}", msg);
				return;
			}
			handleMessage(fromPort, fromAddr, msg);
		}

		private void handleX10Message(Msg msg, String fromPort) {
			try {
				int x10Flag	= msg.getByte("X10Flag") & 0xff;
				int rawX10	= msg.getByte("rawX10") & 0xff;
				if (x10Flag == 0x80) { 
					if (m_x10HouseUnit != -1) {
						InsteonAddress fromAddr = new InsteonAddress((byte)m_x10HouseUnit);
						handleMessage(fromPort, fromAddr, msg);
					}
				} else if (x10Flag == 0) {

					m_x10HouseUnit = rawX10 & 0xFF; 
				}
			} catch (FieldException e) {
				logger.error("got bad X10 message: {}", msg, e);
				return;
			}
		}
		private void handleMessage(String fromPort, InsteonAddress fromAddr, Msg msg) {
			InsteonDevice  dev = getDevice(fromAddr);
			if (dev == null) {
				logger.debug("dropping message from unknown device with address {}", fromAddr);
			} else {
				dev.handleMessage(fromPort, msg);
			}
		}
	}
	
	private void logDeviceStatistics() {
		logger.info(String.format("devices: %3d configured, %3d polling, msgs received: %5d",
				m_devices.size(), Poller.s_instance().getSizeOfQueue(), m_messagesReceived));
		m_messagesReceived = 0;
		for (InsteonDevice dev : m_devices.values()) {
			if (dev.isModem()) continue;
			if (m_deadDeviceTimeout > 0 &&
					dev.getPollOverDueTime() > m_deadDeviceTimeout) {
				logger.info("device {} has not responded to polls for {} sec", dev.toString(),
						dev.getPollOverDueTime() / 3600);
			}
		}
	}

	private static long s_parseLong(String pi, long min, long max) {
		long t = Long.parseLong(pi);
		t = Math.max(t, min);
		t = Math.min(t, max);
		return t;
	}
}
<code block>

package org.openhab.binding.insteonplm.internal.driver;
import java.io.IOException;
import java.util.HashMap;
import java.util.concurrent.locks.ReentrantLock;

import org.openhab.binding.insteonplm.internal.device.InsteonAddress;
import org.openhab.binding.insteonplm.internal.message.Msg;
import org.openhab.binding.insteonplm.internal.message.MsgListener;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class Driver {
	private static final Logger logger = LoggerFactory.getLogger(Driver.class);


	private HashMap<String, Port> m_ports = new HashMap<String, Port>();
	private DriverListener m_listener = null; 
	private HashMap<InsteonAddress, ModemDBEntry> m_modemDBEntries = new HashMap<InsteonAddress, ModemDBEntry>();
	private ReentrantLock m_modemDBEntriesLock = new ReentrantLock();
	private int	m_modemDBRetryTimeout	= 30000;	

	public void setDriverListener(DriverListener listener) {
		m_listener = listener;
	}

	public void setModemDBRetryTimeout(int timeout) {
		m_modemDBRetryTimeout = timeout;
		for (Port p : m_ports.values()) {
			p.setModemDBRetryTimeout(m_modemDBRetryTimeout);
		}
	}

	public boolean isReady() {
		for (Port p : m_ports.values()) {
			if (!p.isRunning()) return false;
		}
		return true;
	}
	public HashMap<InsteonAddress, ModemDBEntry> lockModemDBEntries() {
		m_modemDBEntriesLock.lock();
		return m_modemDBEntries;
	}
	public void unlockModemDBEntries() {
		m_modemDBEntriesLock.unlock();
	}

	public void addPort(String name, String port) {
		if (m_ports.keySet().contains(port)) {
			logger.warn("ignored attempt to add duplicate port: {} {}", name, port);
		} else {
			Port p = new Port(port, this);
			p.setModemDBRetryTimeout(m_modemDBRetryTimeout);
			m_ports.put(port, p);
			logger.debug("added new port: {} {}", name, port);
		}
	}

	public void addMsgListener(MsgListener listener, String port) {
		if (m_ports.keySet().contains(port)) {
			m_ports.get(port).addListener(listener);
		} else {
			logger.error("referencing unknown port {}!", port);
		}
	}
	
	public void startAllPorts() {
		for (Port p : m_ports.values()) { p.start(); }
	}
	
	public void stopAllPorts() {
		for (Port p : m_ports.values()) { p.stop(); }
	}


	public void writeMessage(String port, Msg m) throws IOException {
		Port p = getPort(port);
		if (p == null) {
			logger.error("cannot write to unknown port {}", port);
			throw new IOException();
		}
		p.writeMessage(m);
	}
	
	public String getDefaultPort() {
		return (m_ports.isEmpty() ? null : m_ports.keySet().iterator().next());
	}
	
	public int getNumberOfPorts() {
		int n = 0;
		for (Port p : m_ports.values()) {
			if (p.isRunning()) n++;
		}
		return n;
	}
	
	public boolean isMsgForUs(InsteonAddress toAddr) {
		if (toAddr == null) return false;
		for (Port p : m_ports.values()) {
			if (p.getAddress().equals(toAddr)) return true;
		}
		return false;
	}

	public Port getPort(String port) {
		if (port.equalsIgnoreCase("DEFAULT")) {
			if (m_ports.isEmpty()) {
				logger.error("no default port found!");
				return null;
			}
			return m_ports.values().iterator().next();
		}
		if (!m_ports.containsKey(port)) {
			logger.error("no port of name {} found!", port);
			return null;
		}
		return m_ports.get(port);
	}
	
	public void modemDBComplete(Port port) {

		if (!isModemDBComplete()) return;

		m_listener.driverCompletelyInitialized();
	}

	public boolean isModemDBComplete() {

		for (Port p : m_ports.values()) {
			if (!p.isModemDBComplete()) {
				return false;
			}
		}
		return true;
	}
}

<code block>

package org.openhab.binding.insteonplm.internal.driver;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Random;
import java.util.concurrent.LinkedBlockingQueue;

import org.openhab.binding.insteonplm.internal.device.ModemDBBuilder;
import org.openhab.binding.insteonplm.internal.device.DeviceType;
import org.openhab.binding.insteonplm.internal.device.DeviceTypeLoader;
import org.openhab.binding.insteonplm.internal.device.InsteonAddress;
import org.openhab.binding.insteonplm.internal.device.InsteonDevice;
import org.openhab.binding.insteonplm.internal.message.FieldException;
import org.openhab.binding.insteonplm.internal.message.Msg;
import org.openhab.binding.insteonplm.internal.message.MsgFactory;
import org.openhab.binding.insteonplm.internal.message.MsgListener;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class Port {
	private static final Logger logger = LoggerFactory.getLogger(Port.class);


	enum ReplyType {
		GOT_ACK,
		WAITING_FOR_ACK,
		GOT_NACK
	}

	private IOStream		m_ioStream	= null;
	private	String			m_devName	= "INVALID";
	private	String			m_logName	= "INVALID";
	private Modem			m_modem		= null;
	private IOStreamReader	m_reader	= null;
	private	IOStreamWriter	m_writer	= null;
	private	final int		m_readSize	= 1024; 
	private	Thread			m_readThread  = null;
	private	Thread			m_writeThread = null;
	private	boolean			m_running	  = false;
	private boolean			m_modemDBComplete = false;
	private MsgFactory		m_msgFactory = new MsgFactory();
	private Driver			m_driver	 = null;
	private ModemDBBuilder	m_mdbb 		 = null;
	private ArrayList<MsgListener>	 m_listeners = new ArrayList<MsgListener>();
	private LinkedBlockingQueue<Msg> m_writeQueue = new LinkedBlockingQueue<Msg>();


	public Port(String devName, Driver d) {
		m_devName	= devName;
		m_driver	= d;
		m_logName	= devName;
		m_modem		= new Modem();
		addListener(m_modem);
		m_ioStream 	= IOStream.s_create(devName);
		m_reader	= new IOStreamReader();
		m_writer	= new IOStreamWriter();
		m_mdbb 		= new ModemDBBuilder(this);
	}

	public synchronized boolean isModemDBComplete() { return (m_modemDBComplete); }
	public boolean 			isRunning() 	{ return m_running; }
	public InsteonAddress	getAddress()	{ return m_modem.getAddress(); }
	public String			getDeviceName()	{ return m_devName; }
	public Driver			getDriver()		{ return m_driver; }


	public void setModemDBRetryTimeout(int timeout) {
		m_mdbb.setRetryTimeout(timeout);
	}

	public void addListener (MsgListener l) {
		synchronized(m_listeners) {
			if (!m_listeners.contains(l)) m_listeners.add(l);
		}
	}
	
	public void removeListener(MsgListener l) {
		synchronized(m_listeners) {
			if (m_listeners.remove(l)) {

			}
		}
	}


	public void clearModemDB() {
		logger.debug("clearing modem db!");
		HashMap<InsteonAddress, ModemDBEntry> dbes = getDriver().lockModemDBEntries();
		dbes.clear();
		getDriver().unlockModemDBEntries();
	}
	

	public void start() {
		logger.debug("starting port {}", m_logName);
		if (m_running) {
			logger.debug("port {} already running, not started again", m_logName);
		}
		if (!m_ioStream.open()) {
			logger.debug("failed to open port {}", m_logName);
			return;
		}
		m_readThread	= new Thread(m_reader);
		m_writeThread	= new Thread(m_writer);
		m_readThread.setName(m_logName + " Reader");
		m_writeThread.setName(m_logName + " Writer");
		m_readThread.start();
		m_writeThread.start();
		m_modem.initialize();
		m_mdbb.start(); 
		m_running = true;
	}


	public void stop() {
		if (!m_running) {
			logger.debug("port {} not running, no need to stop it", m_logName);
			return;
		}
		if (m_mdbb != null) {
			m_mdbb = null;
		}
		if (m_readThread != null) m_readThread.interrupt();
		if (m_writeThread != null) m_writeThread.interrupt();
		logger.debug("waiting for read thread to exit for port {}",
				m_logName);
		try {
			if (m_readThread != null) m_readThread.join();
		} catch (InterruptedException e) {
			logger.debug("got interrupted waiting for read thread to exit.");
		}
		logger.debug("waiting for write thread to exit for port {}",
				m_logName);
		try {
			if (m_writeThread != null) m_writeThread.join();
		} catch (InterruptedException e) {
			logger.debug("got interrupted waiting for write thread to exit.");
		}
		logger.debug("all threads for port {} stopped.", m_logName);
		m_ioStream.close();
		m_running = false;
		synchronized (m_listeners) {
			m_listeners.clear();
		}
	}

	public void writeMessage(Msg m) throws IOException {
		if (m == null) {
			logger.error("trying to write null message!");
			throw new IOException("trying to write null message!");
		}
		if (m.getData() == null) {
			logger.error("trying to write message without data!");
			throw new IOException("trying to write message without data!");
		}
		try {
			m_writeQueue.add(m);
			logger.trace("enqueued msg: {}", m);
		} catch (IllegalStateException e) {
			logger.error("cannot write message {}, write queue is full!", m);
		}
		
	}


	public void modemDBComplete() {
		synchronized (this) {
			m_modemDBComplete = true;
		}
		m_driver.modemDBComplete(this);
	}


	class IOStreamReader implements Runnable {
		
		private ReplyType	m_reply = ReplyType.GOT_ACK;
		private	Object		m_replyLock = new Object();
		private	boolean		m_dropRandomBytes = false; 

		public	Object getRequestReplyLock() { return m_replyLock; }

		@Override
		public void run() {
			logger.debug("starting reader...");
			byte[] buffer = new byte[2 * m_readSize];
			Random rng	  = new Random();
			for (int len = -1; (len = m_ioStream.read(buffer, 0, m_readSize)) > 0;) {
				if (m_dropRandomBytes && rng.nextInt(100) < 20) {
					len = dropBytes(buffer, len);
				}
				m_msgFactory.addData(buffer, len);
				processMessages();
			}
			logger.error("reader thread exiting!");
		}
		private void processMessages() {
			try {

				for (Msg m = m_msgFactory.processData(); m != null;
						m = m_msgFactory.processData()) {
						toAllListeners(m);
						notifyWriter(m);
				}
			} catch (IOException e) {


				logger.warn("bad data received: {}", e.getMessage());
				synchronized (getRequestReplyLock()) {
					if (m_reply == ReplyType.WAITING_FOR_ACK) {
						logger.warn("got bad data back, must assume message was acked.");
						m_reply = ReplyType.GOT_ACK;
						getRequestReplyLock().notify();
					}
				}
			}
		}

		private void notifyWriter(Msg msg) {
			synchronized (getRequestReplyLock()) {
				if (m_reply == ReplyType.WAITING_FOR_ACK) {
					if (!msg.isUnsolicited()) {
						m_reply = (msg.isPureNack() ? ReplyType.GOT_NACK : ReplyType.GOT_ACK);
						logger.trace("signaling receipt of ack: {}", (m_reply == ReplyType.GOT_ACK));
						getRequestReplyLock().notify();
					} else if (msg.isPureNack()){
						m_reply = ReplyType.GOT_NACK;
						logger.trace("signaling receipt of pure nack");
						getRequestReplyLock().notify();
					} else {
						logger.trace("got unsolicited message");
					}
				}
			}
		}


		private int dropBytes(byte [] buffer, int len) {
			final int DROP_RATE = 2; 
			Random rng	  = new Random();
			ArrayList<Byte> l = new ArrayList<Byte>();
			for (int i = 0; i < len; i++) {
				if (rng.nextInt(100) >= DROP_RATE) {
					l.add(new Byte(buffer[i]));
				}
			}
			for (int i = 0; i < l.size(); i++) {
				buffer[i] = l.get(i);
			}
			return (l.size());
		}

		@SuppressWarnings("unchecked")
		private void toAllListeners(Msg msg) {





			ArrayList<MsgListener> tempList = null;
			synchronized(m_listeners) {
				tempList= (ArrayList<MsgListener>) m_listeners.clone();
			}
			for (MsgListener l : tempList) {
				l.msg(msg, m_devName); 
			}
		}
		

		public boolean waitForReply() {
			m_reply = ReplyType.WAITING_FOR_ACK;
			while (m_reply == ReplyType.WAITING_FOR_ACK) {
				try {
					logger.trace("writer waiting for ack.");





					getRequestReplyLock().wait(30000); 
					if (m_reply == ReplyType.WAITING_FOR_ACK) { 
						logger.trace("writer timeout expired, asking for retransmit!");
						m_reply = ReplyType.GOT_NACK;
						break;
					} else {
						logger.trace("writer got ack: {}", (m_reply == ReplyType.GOT_ACK));
					}
				} catch (InterruptedException e) {

				}
			}
			return (m_reply == ReplyType.GOT_NACK);
		}
	}

	class IOStreamWriter implements Runnable {
		private static final int WAIT_TIME = 200; 
		@Override
		public void run() {
			logger.debug("starting writer...");
			while(true) {
				try {

					logger.trace("writer checking message queue");
					Msg msg = m_writeQueue.take();
					if (msg.getData() == null) {
						logger.error("found null message in write queue!");
					} else {
						logger.debug("writing ({}): {}", msg.getQuietTime(), msg);




						synchronized (m_reader.getRequestReplyLock()) {
							m_ioStream.write(msg.getData());
							while (m_reader.waitForReply()) {
								Thread.sleep(WAIT_TIME);
								logger.trace("retransmitting msg: {}", msg);
								m_ioStream.write(msg.getData());
							}
							
						}

						if (msg.getQuietTime() > 0) {
							Thread.sleep(msg.getQuietTime());
						}
					}
				} catch (InterruptedException e) {
					logger.error("got interrupted exception in write thread:", e);
				} catch (Exception e) {
					logger.error("got exception in write thread:", e);
				}
			}
		}
	}

	class Modem implements MsgListener {
		private InsteonDevice m_device = null;
		InsteonAddress getAddress() { return (m_device == null) ? new InsteonAddress() : (m_device.getAddress()); }
		InsteonDevice getDevice() { return m_device; }
		@Override
		public void msg(Msg msg, String fromPort) {
			try {
				if (msg.isPureNack()) return;
				if (msg.getByte("Cmd") == 0x60) {

					InsteonAddress a = new InsteonAddress(msg.getAddress("IMAddress"));
					String prodKey = "0x000045";
					DeviceType dt = DeviceTypeLoader.s_instance().getDeviceType(prodKey);
					if (dt == null) {
						logger.error("unknown modem product key: {} for modem: {}.", prodKey, a);
					} else {
						m_device =	InsteonDevice.s_makeDevice(dt);
						m_device.setAddress(a);
						m_device.setProductKey(prodKey);
						m_device.setDriver(m_driver);
						m_device.setIsModem(true);
						m_device.addPort(fromPort);
						logger.debug("found modem {} in device_types: {}", a, m_device.toString());
					}

					removeListener(this);
				}
			} catch (FieldException e) {
				logger.error("error parsing im info reply field: ", e);
			}
		}
		public void initialize() {
			try {
				Msg m = Msg.s_makeMessage("GetIMInfo");
				writeMessage(m);
			} catch (IOException e) {
				logger.error("modem init failed!", e);
			}
		}
	}
}

<code block>

package org.openhab.binding.insteonplm.internal.message;

import java.io.IOException;

import org.openhab.binding.insteonplm.internal.utils.Utils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class MsgFactory {
	private static final Logger logger = LoggerFactory.getLogger(MsgFactory.class);


	private final static int	MAX_MSG_LEN = 4096;
	private byte[] 				m_buf = new byte[MAX_MSG_LEN];
	private int					m_end = 0;	
	

	public MsgFactory() {
	}
	

	public void addData(byte [] data, int len) {
		if (len + m_end > MAX_MSG_LEN) {
			logger.error("warn: truncating excessively long message!");
			len = MAX_MSG_LEN - m_end;
		}

		System.arraycopy(data, 0, m_buf, m_end, len);
		m_end += len;

		logger.trace("read buffer: len {} data: {}", m_end, Utils.getHexString(m_buf, m_end));
	}

	public Msg processData() throws IOException {

		if (m_end > 0 && m_buf[0] == 0x15) {
			logger.trace("got pure nack!");
			removeFromBuffer(1);
			try {
				Msg m = Msg.s_makeMessage("PureNACK");
				return m;
			} catch (IOException e) {
				return null;
			}
		}

		if (m_end > 0 && m_buf[0] != 0x02) {
			bail("incoming message does not start with 0x02");
		}



		int msgLen = -1;
		boolean isExtended = false;
		if (m_end > 1) {

			int headerLength = Msg.s_getHeaderLength(m_buf[1]);
			isExtended = Msg.s_isExtended(m_buf, m_end, headerLength);
			logger.trace("header length expected: {} extended: {}", headerLength, isExtended);
			if (headerLength < 0) {
				removeFromBuffer(1); 
				bail("got unknown command code " + Utils.getHexByte(m_buf[1]));
			} else if (headerLength >= 2) {
				if (m_end >= headerLength) {

					msgLen = Msg.s_getMessageLength(m_buf[1], isExtended);
					if (msgLen < 0) {

						removeFromBuffer(1);
						bail("unknown command code/ext flag: " + Utils.getHexByte(m_buf[1]));
					}
				}
			} else { 
				logger.error("invalid header length, internal error!");
				msgLen = -1;
			}
		}
		logger.trace("msgLen expected: {}", msgLen);
		Msg msg = null;
		if (msgLen > 0 && m_end >= msgLen) {
			msg = Msg.s_createMessage(m_buf, msgLen, isExtended);
			removeFromBuffer(msgLen);
		}
		logger.trace("keeping buffer len {} data: {}", m_end, Utils.getHexString(m_buf, m_end));
		return msg;
	}
	
	private void bail(String txt) throws IOException {
		drainBuffer(); 
		logger.warn(txt);
		throw new IOException(txt);
	}
	
	private void drainBuffer() {
		while (m_end > 0 && m_buf[0] != 0x02) {
			removeFromBuffer(1);
		}
	}
	
	private void removeFromBuffer(int len) {
		if (len > m_end) len = m_end;
		System.arraycopy(m_buf, len, m_buf, 0, m_end + 1 - len);
		m_end -= len;
	}
}

<code block>

package org.openhab.binding.insteonplm.internal.device;

import java.io.IOException;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.GregorianCalendar;
import java.util.HashMap;

import org.openhab.binding.insteonplm.internal.device.DeviceFeatureListener.StateChangeType;
import org.openhab.binding.insteonplm.internal.device.GroupMessageStateMachine.GroupMessage;
import org.openhab.binding.insteonplm.internal.message.FieldException;
import org.openhab.binding.insteonplm.internal.message.Msg;
import org.openhab.binding.insteonplm.internal.message.MsgType;
import org.openhab.binding.insteonplm.internal.utils.Utils;
import org.openhab.core.library.types.DateTimeType;
import org.openhab.core.library.types.DecimalType;
import org.openhab.core.library.types.OnOffType;
import org.openhab.core.library.types.OpenClosedType;
import org.openhab.core.library.types.PercentType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;



public abstract class MessageHandler {
	private static final Logger logger = LoggerFactory.getLogger(MessageHandler.class);
	
	DeviceFeature				m_feature	 	= null;
	HashMap<String, String> 	m_parameters	= new HashMap<String, String>();
	HashMap<Integer, GroupMessageStateMachine>	m_groupState = new HashMap<Integer, GroupMessageStateMachine>();

	MessageHandler(DeviceFeature p) {
		m_feature = p;
	}

	public abstract void handleMessage(int group, byte cmd1, Msg msg,
			DeviceFeature feature, String fromPort);
	

	public void sendExtendedQuery(DeviceFeature f, byte aCmd1, byte aCmd2) {
		InsteonDevice d = f.getDevice();
		try {
			Msg m = d.makeExtendedMessage((byte)0x1f, aCmd1, aCmd2);
			m.setQuietTime(500L);
			d.enqueueMessage(m, f);
		} catch (IOException e) {
			logger.warn("i/o problem sending query message to device {}", d.getAddress());
		} catch (FieldException e) {
			logger.warn("field exception sending query message to device {}", d.getAddress());
		}
	}

	public int getGroup() {
		return (getIntParameter("group", -1));
	}

	protected int getIntParameter(String key, int def) {
		try {
			if (m_parameters.get(key) != null) {
				return Integer.parseInt(m_parameters.get(key));
			}
		} catch (NumberFormatException e) {
			logger.error("malformed int parameter in message handler: {}", key);
		}
		return def;
	}

	protected boolean isMybutton(Msg msg, DeviceFeature f) {
		int myButton = getIntParameter("button", -1);



		if (myButton == -1) return true;
		
		int button = getButtonInfo(msg, f);
		return button != -1 && myButton == button;
	}

	protected boolean isDuplicate(Msg msg) {
		boolean isDuplicate = false;
		try {
			MsgType t = MsgType.s_fromValue(msg.getByte("messageFlags"));
			int hops = msg.getHopsLeft();
			if (t == MsgType.ALL_LINK_BROADCAST) {
				int group = (int) (msg.getAddress("toAddress").getLowByte() & 0xff);
				byte cmd1 = msg.getByte("command1");



				GroupMessage gm = (cmd1 == 0x06) ? GroupMessage.SUCCESS :
										GroupMessage.BCAST;
				isDuplicate = !updateGroupState(group, hops, gm);
			} else if (t == MsgType.ALL_LINK_CLEANUP) {


				int group = (int)(msg.getByte("command2") & 0xff);
				isDuplicate = !updateGroupState(group, hops,
								GroupMessage.CLEAN);
			}
		} catch (IllegalArgumentException e) {
			logger.error("cannot parse msg: {}", msg, e);			
		} catch (FieldException e) {
			logger.error("cannot parse msg: {}", msg, e);
		}
		return (isDuplicate);
	}

	private boolean updateGroupState(int group, int hops, GroupMessage a) {
		GroupMessageStateMachine m = m_groupState.get(new Integer(group));
		if (m == null) {
			m = new GroupMessageStateMachine();
			m_groupState.put(new Integer(group), m);
		}
		logger.debug("updating group state for {} to {}", group, a);
		return (m.action(a, hops));
	}
	

	static protected int getButtonInfo(Msg msg, DeviceFeature f) {


		try {
			int bclean = (int) (msg.getByte("command2") & 0xff);
			int bbcast = (int) (msg.getAddress("toAddress").getLowByte() & 0xff);
			int button = msg.isCleanup() ? bclean : bbcast;
			logger.trace("{} button: {} bclean: {} bbcast: {}",
					f.getDevice().getAddress(), button, bclean, bbcast);
			return button;
		}  catch (FieldException e) {
			logger.error("field exception while parsing msg {}: ", msg, e);
		}
		return -1;
	}
	

	protected String nm() {
		return (this.getClass().getSimpleName());
	}
	

	public void setParameters(HashMap<String, String> hm) { m_parameters = hm; }
	
	





	
	public static class DefaultMsgHandler extends MessageHandler {
		DefaultMsgHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
					DeviceFeature f, String fromPort) {
			logger.debug("{} drop unimpl message {}: {}", nm(), Utils.getHexByte(cmd1), msg);
		}
	}

	public static class NoOpMsgHandler extends MessageHandler {
		NoOpMsgHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			logger.debug("{} ignore msg {}: {}", nm(), Utils.getHexByte(cmd1), msg);
		}
	}

	public static class LightOnDimmerHandler extends MessageHandler {
		LightOnDimmerHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			if (isDuplicate(msg) || !isMybutton(msg, f)) {
				return;
			}
			InsteonAddress a = f.getDevice().getAddress();
			if (msg.isAckOfDirect()) {
				logger.error("{}: device {}: ignoring ack of direct.", nm(), a);
			} else {
				logger.info("{}: device {} was turned on. Sending poll request to get actual level", nm(), a);
				m_feature.publish(PercentType.HUNDRED, StateChangeType.ALWAYS);



				Msg m = f.makePollMsg();
				if (m != null)	f.getDevice().enqueueDelayedMessage(m, f, 1000);
			}
		}
	}

	public static class LightOnSwitchHandler extends MessageHandler {
		LightOnSwitchHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			if (!isDuplicate(msg) && isMybutton(msg, f)) {
				logger.info("{}: device {} was switched on.", nm(),
								f.getDevice().getAddress());
				f.publish(OnOffType.ON, StateChangeType.ALWAYS);
			} else {
				logger.debug("ignored message: {} or {}", isDuplicate(msg), isMybutton(msg,f));
			}
		}
	}

	public static class LightOffDimmerHandler extends MessageHandler {
		LightOffDimmerHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			if (!isDuplicate(msg) && isMybutton(msg, f)) {
				logger.info("{}: device {} was turned off.", nm(),
						f.getDevice().getAddress());
				f.publish(PercentType.ZERO, StateChangeType.ALWAYS);
			}
		}
	}

	public static class LightOffSwitchHandler extends MessageHandler {
		LightOffSwitchHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			if (!isDuplicate(msg) && isMybutton(msg, f)) {
				logger.info("{}: device {} was switched off.", nm(),
						f.getDevice().getAddress());
				f.publish(OnOffType.OFF, StateChangeType.ALWAYS);
			}
		}
	}



	public static class SwitchRequestReplyHandler extends  MessageHandler {
		SwitchRequestReplyHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			try {
				InsteonAddress a = f.getDevice().getAddress();
				int cmd2	= (int) (msg.getByte("command2") & 0xff);
				int button	= this.getIntParameter("button", -1);
				if (button < 0) {
					handleNoButtons(cmd2, a, msg);
				} else {
					boolean isOn = isLEDLit(cmd2, button);
					logger.info("{}: dev {} button {} switched to {}", nm(),
													a, button, isOn ? "ON" : "OFF");
					m_feature.publish(isOn ? OnOffType.ON : OnOffType.OFF, StateChangeType.CHANGED);
				}
			} catch (FieldException e) {
				logger.error("{} error parsing {}: ", nm(), msg, e);
			}
		}

		void handleNoButtons(int cmd2, InsteonAddress a, Msg msg) {
			if (cmd2 == 0) {
				logger.info("{}: set device {} to OFF", nm(), a);
				m_feature.publish(OnOffType.OFF, StateChangeType.CHANGED);
			} else if (cmd2 == 0xff) {
				logger.info("{}: set device {} to ON", nm(), a);
				m_feature.publish(OnOffType.ON, StateChangeType.CHANGED);
			} else {
				logger.warn("{}: {} ignoring unexpected cmd2 in msg: {}",
							nm(), a, msg);
			}	
		}

		private boolean isLEDLit(int cmd, int button) {
			boolean isSet = (cmd & (0x1 << (button-1))) != 0;
			logger.trace("cmd: {} button {}", Integer.toBinaryString(cmd), button);
			logger.trace("msk: {} isSet: {}", Integer.toBinaryString(0x1 << (button-1)), isSet);
			return (isSet);
		}
	}


	public static class DimmerRequestReplyHandler extends  MessageHandler {
		DimmerRequestReplyHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			InsteonDevice dev = f.getDevice();
			try {
				int cmd2 = (int) (msg.getByte("command2") & 0xff);
				if (cmd2 == 0xfe) {

					cmd2 = 0xff;
				}

				if (cmd2 == 0) {
					logger.info("{}: set device {} to level 0", nm(),
							dev.getAddress());
					m_feature.publish(PercentType.ZERO, StateChangeType.CHANGED);
				} else if (cmd2 == 0xff) {
					logger.info("{}: set device {} to level 100", nm(),
							dev.getAddress());
					m_feature.publish(PercentType.HUNDRED, StateChangeType.CHANGED);
				} else {
					int level = cmd2*100/255;
					if (level == 0) level = 1;
					logger.info("{}: set device {} to level {}", nm(),
							dev.getAddress(), level);
					m_feature.publish(new PercentType(level), StateChangeType.CHANGED);
				}
			} catch (FieldException e) {
				logger.error("{}: error parsing {}: ", nm(), msg, e);
			}
		}
	}

	public static class StopManualChangeHandler extends MessageHandler {
		StopManualChangeHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			Msg m = f.makePollMsg();
			if (m != null)	f.getDevice().enqueueMessage(m, f);
		}
	}

	public static class InfoRequestReplyHandler extends MessageHandler {
		InfoRequestReplyHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			InsteonDevice dev = f.getDevice();
			if (!msg.isExtended()) {
				logger.warn("{} device {} expected extended msg as info reply, got {}",
						nm(), dev.getAddress(), msg);
				return;
			}
			try {
				int cmd2 = (int) (msg.getByte("command2") & 0xff);
				switch (cmd2) {
				case 0x00: 
					int prodKey = msg.getInt24("userData2", "userData3", "userData4");
					int devCat  = msg.getByte("userData5");
					int subCat  = msg.getByte("userData6");
					logger.info("{} {} got product data: cat: {} subcat: {} key: {} ",
							nm(), dev.getAddress(), devCat, subCat,	Utils.getHexString(prodKey));
					break;
				case 0x02: 
					logger.info("{} {} got text str {} ", nm(), dev.getAddress(), msg);
					break;
				default:
					logger.warn("{} unknown cmd2 = {} in info reply message {}", nm(), cmd2, msg);
					break;
				}
			} catch (FieldException e) {
				logger.error("error parsing {}: ", msg, e);
			}
		}
	}

	public static class MotionSensorDataReplyHandler extends MessageHandler {
		MotionSensorDataReplyHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			InsteonDevice dev = f.getDevice();
			if (!msg.isExtended()) {
				logger.trace("{} device {} ignoring non-extended msg {}", nm(), dev.getAddress(), msg);
				return;
			}
			try {
				int cmd2 = (int) (msg.getByte("command2") & 0xff);
				switch (cmd2) {
				case 0x00: 
					int batteryLevel = msg.getByte("userData12") & 0xff;
					int lightLevel = msg.getByte("userData11") & 0xff;
					logger.debug("{}: {} got light level: {}, battery level: {}",
								nm(), dev.getAddress(), lightLevel, batteryLevel);
					m_feature.publish(new DecimalType(lightLevel), StateChangeType.CHANGED, "field", "light_level");
					m_feature.publish(new DecimalType(batteryLevel), StateChangeType.CHANGED, "field", "battery_level");
					break;
				default:
					logger.warn("unknown cmd2 = {} in info reply message {}", cmd2, msg);
					break;
				}
			} catch (FieldException e) {
				logger.error("error parsing {}: ", msg, e);
			}
		}
	}
	
	public static class HiddenDoorSensorDataReplyHandler extends MessageHandler {
		HiddenDoorSensorDataReplyHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			InsteonDevice dev = f.getDevice();
			if (!msg.isExtended()) {
				logger.trace("{} device {} ignoring non-extended msg {}", nm(), dev.getAddress(), msg);
				return;
			}
			try {
				int cmd2 = (int) (msg.getByte("command2") & 0xff);
				switch (cmd2) {
				case 0x00: 
					int batteryLevel = msg.getByte("userData4") & 0xff;
					int batteryWatermark = msg.getByte("userData7") & 0xff;
					logger.debug("{}: {} got light level: {}, battery level: {}",
								nm(), dev.getAddress(), batteryWatermark, batteryLevel);
					m_feature.publish(new DecimalType(batteryWatermark), StateChangeType.CHANGED, "field", "battery_watermark_level");
					m_feature.publish(new DecimalType(batteryLevel), StateChangeType.CHANGED, "field", "battery_level");
					break;
				default:
					logger.warn("unknown cmd2 = {} in info reply message {}", cmd2, msg);
					break;
				}
			} catch (FieldException e) {
				logger.error("error parsing {}: ", msg, e);
			}
		}
	}

	public static class PowerMeterUpdateHandler extends MessageHandler {
		PowerMeterUpdateHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			if (msg.isExtended()) {
				try {

					int b7	= msg.getByte("userData7")	& 0xff;
					int b8	= msg.getByte("userData8")	& 0xff;
					int watts = (b7 << 8) | b8;
					if (watts > 32767) {
						watts -= 65535;
					}

					int b9	= msg.getByte("userData9")	& 0xff;
					int b10	= msg.getByte("userData10")	& 0xff;
					int b11	= msg.getByte("userData11")	& 0xff;
					int b12	= msg.getByte("userData12")	& 0xff;
					BigDecimal kwh = BigDecimal.ZERO;
					if (b9 < 254) {
						int e = (b9 << 24) | (b10 << 16) | (b11 << 8) | b12;
						kwh = new BigDecimal(e * 65535.0 / (1000 * 60 * 60 * 60)).setScale(4, RoundingMode.HALF_UP);
					}

					logger.debug("{}:{} watts: {} kwh: {} ", nm(), f.getDevice().getAddress(), watts, kwh);
					m_feature.publish(new DecimalType(kwh), StateChangeType.CHANGED, "field", "kwh");
					m_feature.publish(new DecimalType(watts), StateChangeType.CHANGED, "field", "watts");
				} catch (FieldException e) {
					logger.error("error parsing {}: ", msg, e);
				}
			}
		}
	}
	
	public static class PowerMeterResetHandler extends MessageHandler {
		PowerMeterResetHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			InsteonDevice dev = f.getDevice();
			logger.info("{}: power meter {} was reset", nm(), dev.getAddress());


			Msg m = f.makePollMsg();
			if (m != null)	f.getDevice().enqueueMessage(m, f);
		}
	}
	
	public static class LastTimeHandler extends MessageHandler {
		LastTimeHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1a, Msg msg,
				DeviceFeature f, String fromPort) {
			GregorianCalendar calendar = new GregorianCalendar();
			calendar.setTimeInMillis(System.currentTimeMillis());
			DateTimeType t = new DateTimeType(calendar);
			m_feature.publish(t, StateChangeType.ALWAYS);
		}
	}

	public static class ContactRequestReplyHandler extends MessageHandler {
		ContactRequestReplyHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1a, Msg msg,
				DeviceFeature f, String fromPort) {
			byte cmd  = 0x00;
			byte cmd2 = 0x00;
			try {
				cmd = msg.getByte("Cmd");
				cmd2 = msg.getByte("command2");
			} catch (FieldException e) {
				logger.debug("{} no cmd found, dropping msg {}", nm(), msg);
				return;
			}
			if (msg.isAckOfDirect() && (f.getQueryStatus() == DeviceFeature.QueryStatus.QUERY_PENDING)
					&& cmd == 0x50) {
				OpenClosedType oc = (cmd2 == 0) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;
				logger.info("{}: set contact {} to: {}", nm(), f.getDevice().getAddress(), oc);
				m_feature.publish(oc, StateChangeType.CHANGED);
			}
		}
	}

	public static class ClosedContactHandler extends MessageHandler {
		ClosedContactHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			m_feature.publish(OpenClosedType.CLOSED, StateChangeType.ALWAYS);
		}
	}

	public static class OpenedContactHandler extends MessageHandler {
		OpenedContactHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			m_feature.publish(OpenClosedType.OPEN, StateChangeType.ALWAYS);
		}
	}

	public static class OpenedOrClosedContactHandler extends MessageHandler {
		OpenedOrClosedContactHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			if (cmd1 != 0x11) return;
			try {
				byte cmd2 = msg.getByte("command2");
				switch (cmd2) {
				case 0x02:
					m_feature.publish(OpenClosedType.CLOSED, StateChangeType.CHANGED);
					break;
				case 0x01:
					m_feature.publish(OpenClosedType.OPEN, StateChangeType.CHANGED);
					break;
				default: 
					break;
				}
			} catch (FieldException e) {
				logger.debug("{} no cmd2 found, dropping msg {}", nm(), msg);
				return;
			}

		}
	}

	public static class ClosedSleepingContactHandler extends MessageHandler {
		ClosedSleepingContactHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			m_feature.publish(OpenClosedType.CLOSED, StateChangeType.ALWAYS);
			sendExtendedQuery(f, (byte)0x2e, (byte) 00);
		}
	}

	public static class OpenedSleepingContactHandler extends MessageHandler {
		OpenedSleepingContactHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			m_feature.publish(OpenClosedType.OPEN, StateChangeType.ALWAYS);
			sendExtendedQuery(f, (byte)0x2e, (byte) 00);
		}
	}

	public static class X10OnHandler extends  MessageHandler {
		X10OnHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			InsteonAddress a = f.getDevice().getAddress();
			logger.info("{}: set X10 device {} to ON", nm(), a);
			m_feature.publish(OnOffType.ON, StateChangeType.ALWAYS);
		}
	}
	public static class X10OffHandler extends  MessageHandler {
		X10OffHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			InsteonAddress a = f.getDevice().getAddress();
			logger.info("{}: set X10 device {} to OFF", nm(), a);
			m_feature.publish(OnOffType.OFF, StateChangeType.ALWAYS);
		}
	}
	public static class X10BrightHandler extends  MessageHandler {
		X10BrightHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			InsteonAddress a = f.getDevice().getAddress();
			logger.debug("{}: ignoring brighten message for device {}", nm(), a);
		}
	}
	public static class X10DimHandler extends  MessageHandler {
		X10DimHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			InsteonAddress a = f.getDevice().getAddress();
			logger.debug("{}: ignoring dim message for device {}", nm(), a);
		}
	}
	public static class X10OpenHandler extends  MessageHandler {
		X10OpenHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			InsteonAddress a = f.getDevice().getAddress();
			logger.info("{}: set X10 device {} to OPEN", nm(), a);
			m_feature.publish(OpenClosedType.OPEN, StateChangeType.ALWAYS);
		}
	}
	public static class X10ClosedHandler extends  MessageHandler {
		X10ClosedHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			InsteonAddress a = f.getDevice().getAddress();
			logger.info("{}: set X10 device {} to CLOSED", nm(), a);
			m_feature.publish(OpenClosedType.CLOSED, StateChangeType.ALWAYS);
		}
	}


	public static class ThermostatSetPointMsgHandler extends  MessageHandler {
		ThermostatSetPointMsgHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			InsteonDevice dev = f.getDevice();
			try {
				if (msg.isExtended()) {
					logger.info("{}: received msg for feature {}", nm(), f.getName());
					int level = ((f.getName()).equals("ThermostatCoolSetPoint")) ? (int)(msg.getByte("userData7") & 0xff) : (int)(msg.getByte("userData8") & 0xff);
					logger.info("{}: got SetPoint from {} of value: {}", nm(), dev.getAddress(), level);
					f.publish(new DecimalType(level), StateChangeType.CHANGED);
				} else {
					logger.info("{}: received msg for feature {}", nm(), f.getName());
					int cmd2 = (int) (msg.getByte("command2") & 0xff);
					int level = cmd2/2;
					logger.info("{}: got SETPOINT from {} of value: {}", nm(), dev.getAddress(), level);
					f.publish(new DecimalType(level), StateChangeType.CHANGED);
				}
			} catch (FieldException e) {
				logger.debug("{} no cmd2 found, dropping msg {}", nm(), msg);
				return;
			}
		}
	}


	public static class ThermostatTemperatureRequestReplyHandler extends  MessageHandler {
		ThermostatTemperatureRequestReplyHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			InsteonDevice dev = f.getDevice();
			try {
				int cmd1Msg = (int) (msg.getByte("command1") & 0xff);
				if (cmd1Msg != 0x6a) {
					logger.warn("{}: ignoring bad TEMPERATURE reply from {}", nm(), dev.getAddress());
					return;
				}
				int cmd2 = (int) (msg.getByte("command2") & 0xff);
				int level = cmd2/2;
				logger.info("{}: got TEMPERATURE from {} of value: {}", nm(), dev.getAddress(), level);
				logger.info("{}: set device {} to level {}", nm(), dev.getAddress(), level);
				f.publish(new DecimalType(level), StateChangeType.CHANGED);
			} catch (FieldException e) {
				logger.debug("{} no cmd2 found, dropping msg {}", nm(), msg);
				return;
			}
		}
	}	
		

	public static class ThermostatHumidityRequestReplyHandler extends  MessageHandler {
		ThermostatHumidityRequestReplyHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			InsteonDevice dev = f.getDevice();
			try {
				int cmd1Msg = (int) (msg.getByte("command1") & 0xff);
				if (cmd1Msg != 0x6a) {
					logger.warn("{}: ignoring bad HUMIDITY reply from {}", nm(), dev.getAddress());
					return;
				}
				int cmd2 = (int) msg.getByte("command2");
				logger.info("{}: got HUMIDITY from {} of value: {}", nm(), dev.getAddress(), cmd2);
				logger.info("{}: set device {} to level {}", nm(), dev.getAddress(), cmd2);
				f.publish(new PercentType(cmd2), StateChangeType.CHANGED);
			} catch (FieldException e) {
				logger.debug("{} no cmd2 found, dropping msg {}", nm(), msg);
				return;
			}
		}
	}
	

	public static class ThermostatModeControlReplyHandler extends  MessageHandler {
		ThermostatModeControlReplyHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			InsteonDevice dev = f.getDevice();
			try {

				byte cmd2 = msg.getByte("command2");
				switch (cmd2) {
				case 0x04:
					logger.info("{}: set device {} to {}", nm(),
							dev.getAddress(), "HEAT");
					f.publish(new DecimalType(2), StateChangeType.CHANGED);
					break;
				case 0x05:
					logger.info("{}: set device {} to {}", nm(),
							dev.getAddress(), "COOL");
					f.publish(new DecimalType(1), StateChangeType.CHANGED);
					break;
				case 0x06:
					logger.info("{}: set device {} to {}", nm(),
							dev.getAddress(), "AUTO");
					f.publish(new DecimalType(3), StateChangeType.CHANGED);
					break;
				default: 
					break;
				}
			} catch (FieldException e) {
				logger.debug("{} no cmd2 found, dropping msg {}", nm(), msg);
				return;
			}
		}
	}


	public static class ThermostatFanControlReplyHandler extends  MessageHandler {
		ThermostatFanControlReplyHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			InsteonDevice dev = f.getDevice();
			try {

				byte cmd2 = msg.getByte("command2");
				switch (cmd2) {
				case 0x07:
					logger.info("{}: set device {} to {}", nm(),
							dev.getAddress(), "ON");
					f.publish(new DecimalType(2), StateChangeType.CHANGED);
					break;
				case 0x08:
					logger.info("{}: set device {} to {}", nm(),
							dev.getAddress(), "AUTO");
					f.publish(new DecimalType(3), StateChangeType.CHANGED);
					break;	
				case 0x09:
					logger.info("{}: set device {} to {}", nm(),
							dev.getAddress(), "OFF");
					f.publish(new DecimalType(1), StateChangeType.CHANGED);
					break;	
				default: 
					break;
				}
			} catch (FieldException e) {
				logger.debug("{} no cmd2 found, dropping msg {}", nm(), msg);
				return;
			}
		}
	}


	public static class ThermostatMasterControlReplyHandler extends  MessageHandler {
		ThermostatMasterControlReplyHandler(DeviceFeature p) { super(p); }
		@Override
		public void handleMessage(int group, byte cmd1, Msg msg,
				DeviceFeature f, String fromPort) {
			try {

				byte cmd2 = msg.getByte("userData3");
				switch (cmd2) {
				case 0x00:
					logger.info("{}: set PRIMARY Thermostat to MASTER", nm());
					f.publish(new DecimalType(1), StateChangeType.CHANGED);
					break;
				case 0x01:
					logger.info("{}: set SECONDARY Thermostat to MASTER", nm());
					f.publish(new DecimalType(2), StateChangeType.CHANGED);
					break;	
				case 0x02:
					logger.info("{}: set TERTIARY Thermostat to MASTER", nm());
					f.publish(new DecimalType(3), StateChangeType.CHANGED);
					break;	
				default: 
					break;
				}
			} catch (FieldException e) {
				logger.debug("{} no cmd2 found, dropping msg {}", nm(), msg);
				return;
			}
		}
	}
	

	public static <T extends MessageHandler> T s_makeHandler(String name, HashMap<String, String> params, DeviceFeature f) {
		String cname = MessageHandler.class.getName() + "$" + name;
		try {
			Class<?> c = Class.forName(cname);
			@SuppressWarnings("unchecked")
			Class<? extends T> dc = (Class <? extends T>) c;
			T mh = dc.getDeclaredConstructor(DeviceFeature.class).newInstance(f);
			mh.setParameters(params);
			return mh;
		} catch (Exception e) {
			logger.error("error trying to create message handler: {}", name, e);
		}
		return null;
	}
}

<code block>

package org.openhab.binding.insteonplm.internal.device;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map.Entry;

import org.openhab.binding.insteonplm.internal.driver.ModemDBEntry;
import org.openhab.binding.insteonplm.internal.driver.Port;
import org.openhab.binding.insteonplm.internal.message.FieldException;
import org.openhab.binding.insteonplm.internal.message.Msg;
import org.openhab.binding.insteonplm.internal.message.MsgListener;
import org.openhab.binding.insteonplm.internal.utils.Utils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class ModemDBBuilder implements MsgListener, Runnable {
	private static final Logger logger = LoggerFactory.getLogger(ModemDBBuilder.class);
	private boolean	m_isComplete 	= false;
	private Port	m_port 			= null;
	private	Thread	m_writeThread	= null;
	private int		m_timeoutMillis = 30000;

	public ModemDBBuilder(Port port) {
		m_port = port;
	}
	
	public void setRetryTimeout(int timeout) {
		m_timeoutMillis = timeout;
	}

	public void start() {
		m_port.addListener(this);
		m_writeThread	= new Thread(this);
		m_writeThread.setName("DBBuilder");
		m_writeThread.start();
		logger.debug("querying port for first link record");
	}

	public void startDownload() {
		logger.trace("starting modem database download");
		m_port.clearModemDB();
		getFirstLinkRecord();
	}
	
	public synchronized boolean isComplete() { return (m_isComplete); }


	@Override
	public void run() {
		logger.trace("starting modem db builder thread");
		while (!isComplete()) {
			startDownload();
			try {
				Thread.sleep(m_timeoutMillis); 
			} catch (InterruptedException e) {
				logger.warn("modem db builder thread interrupted");
				break;
			}
			if (!isComplete()) {
				logger.warn("modem database download unsuccessful, restarting!");
			}
		}
		logger.trace("exiting modem db builder thread");
	}

	private void getFirstLinkRecord() {
		try {
			m_port.writeMessage(Msg.s_makeMessage("GetFirstALLLinkRecord"));
		} catch (IOException e) {
			logger.error("error sending link record query ", e);
		}
		
	}
	

	@Override
	public void msg(Msg msg, String fromPort) {
		if (msg.isPureNack()) return;
		try {
			if (msg.getByte("Cmd") == 0x69 ||
						msg.getByte("Cmd") == 0x6a) {



				if (msg.getByte("ACK/NACK") == 0x15) {
					logger.debug("got all link records.");
					done();
				}
			} else if (msg.getByte("Cmd") == 0x57) {

				updateModemDB(msg);
				m_port.writeMessage(Msg.s_makeMessage("GetNextALLLinkRecord"));
			}
		} catch (FieldException e) {
			logger.debug("bad field handling link records {}", e);
		} catch (IOException e) {
			logger.debug("got IO exception handling link records {}", e);
		} catch (IllegalStateException e) {
			logger.debug("got exception requesting link records {}", e);
		}
	}
	
	private synchronized void done() {
		m_isComplete = true;
		logModemDB();
		m_port.removeListener(this);
		m_port.modemDBComplete();
	}
	
	private void logModemDB() {
		try {
			logger.debug("MDB ------- start of modem link records ------------------");
			HashMap<InsteonAddress, ModemDBEntry> dbes = m_port.getDriver().lockModemDBEntries();
			for (Entry<InsteonAddress, ModemDBEntry> db : dbes.entrySet()) {
				ArrayList<Msg> lrs = db.getValue().getLinkRecords();
				for (Msg m: lrs) {
					int recordFlags = m.getByte("RecordFlags") & 0xff;
					String ms = ((recordFlags & (0x1 << 6)) != 0) ? "CTRL" : "RESP";
					logger.debug("MDB {}: {} group: {} data1: {} data2: {} data3: {}",
								db.getKey(), ms, toHex(m.getByte("ALLLinkGroup")),
									toHex(m.getByte("LinkData1")), toHex(m.getByte("LinkData2")),
											toHex(m.getByte("LinkData2")));
				}
				logger.debug("MDB -----");
			}
			logger.debug("MDB ---------------- end of modem link records -----------");
		} catch (FieldException e) {
			logger.error("cannot access field:", e);
		} finally {
			m_port.getDriver().unlockModemDBEntries();
		}
	}
	
	public static String toHex(byte b) {
		return Utils.getHexString(b);
	}
	
	private void updateModemDB(Msg m) 	{
		try {
			HashMap<InsteonAddress, ModemDBEntry> dbes = m_port.getDriver().lockModemDBEntries();
			InsteonAddress linkAddr = m.getAddress("LinkAddr");
			ModemDBEntry dbe = dbes.get(linkAddr);
			if (dbe == null) {
				dbe = new ModemDBEntry(linkAddr);
				dbes.put(linkAddr, dbe);
			}
			dbe.setPort(m_port);
			dbe.addLinkRecord(m);
		} catch (FieldException e) {
			logger.error("cannot access field:", e);
		} finally {
			m_port.getDriver().unlockModemDBEntries();
		}
	}
}

<code block>

package org.openhab.core.jsr223.internal.engine.scriptmanager;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.List;

import javax.script.Invocable;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;

import org.openhab.core.jsr223.internal.engine.RuleExecutionRunnable;
import org.openhab.core.jsr223.internal.shared.ChangedEventTrigger;
import org.openhab.core.jsr223.internal.shared.CommandEventTrigger;
import org.openhab.core.jsr223.internal.shared.Event;
import org.openhab.core.jsr223.internal.shared.EventTrigger;
import org.openhab.core.jsr223.internal.shared.Openhab;
import org.openhab.core.jsr223.internal.shared.Rule;
import org.openhab.core.jsr223.internal.shared.RuleSet;
import org.openhab.core.jsr223.internal.shared.ShutdownTrigger;
import org.openhab.core.jsr223.internal.shared.StartupTrigger;
import org.openhab.core.jsr223.internal.shared.TimerTrigger;
import org.openhab.core.jsr223.internal.shared.TriggerType;
import org.openhab.core.library.types.DateTimeType;
import org.openhab.core.library.types.DecimalType;
import org.openhab.core.library.types.HSBType;
import org.openhab.core.library.types.IncreaseDecreaseType;
import org.openhab.core.library.types.OnOffType;
import org.openhab.core.library.types.OpenClosedType;
import org.openhab.core.library.types.PercentType;
import org.openhab.core.library.types.PointType;
import org.openhab.core.library.types.StopMoveType;
import org.openhab.core.library.types.StringType;
import org.openhab.core.library.types.UpDownType;
import org.openhab.core.types.Command;
import org.openhab.core.types.State;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class Script {
	static private final Logger logger = LoggerFactory.getLogger(Script.class);
	ArrayList<Rule> rules = new ArrayList<Rule>();
	private ScriptManager scriptManager;
	private ScriptEngine engine;
	private String fileName;

	public Script(ScriptManager scriptManager, File file) throws FileNotFoundException, ScriptException, NoSuchMethodException {
		this.scriptManager = scriptManager;
		this.fileName = file.getName();
		loadScript(file);
	}

	public void loadScript(File file) throws FileNotFoundException, ScriptException, NoSuchMethodException {
		logger.info("Loading Script " + file.getName());
		String extension = getFileExtension(file);

		ScriptEngineManager factory = new ScriptEngineManager();

		engine = factory.getEngineByExtension(extension);
		if (engine != null) {
			initializeSciptGlobals();
			engine.eval(new FileReader(file));

			Invocable inv = (Invocable) engine;
			RuleSet ruleSet = (RuleSet) inv.invokeFunction("getRules");

			rules.addAll(ruleSet.getRules());
		}
	}

	private void initializeSciptGlobals() {
		engine.put("RuleSet", RuleSet.class);
		engine.put("Rule", Rule.class);
		engine.put("State", State.class);
		engine.put("Command", Command.class);
		engine.put("ChangedEventTrigger", ChangedEventTrigger.class);
		engine.put("CommandEventTrigger", CommandEventTrigger.class);
		engine.put("Event", Event.class);
		engine.put("EventTrigger", EventTrigger.class);
		engine.put("ShutdownTrigger", ShutdownTrigger.class);
		engine.put("StartupTrigger", StartupTrigger.class);
		engine.put("TimerTrigger", TimerTrigger.class);
		engine.put("TriggerType", TriggerType.class);
		engine.put("ItemRegistry", scriptManager.getItemRegistry());
		engine.put("DateTime", org.joda.time.DateTime.class);
		engine.put("oh", Openhab.class);


		engine.put("DateTimeType", DateTimeType.class);
		engine.put("DecimalType", DecimalType.class);
		engine.put("HSBType", HSBType.class);
		engine.put("IncreaseDecreaseType", IncreaseDecreaseType.class);
		engine.put("OnOffType", OnOffType.class);
		engine.put("OpenClosedType", OpenClosedType.class);
		engine.put("PercentType", PercentType.class);
		engine.put("PointType", PointType.class);
		engine.put("StopMoveType", StopMoveType.class);
		engine.put("UpDownType", UpDownType.class);
		engine.put("StringType", StringType.class);
	}

	private String getFileExtension(File file) {
		String extension = null;
		if (file.getName().contains(".")) {
			String name = file.getName();
			extension = name.substring(name.lastIndexOf('.') + 1, name.length());
		}
		return extension;
	}

	public List<Rule> getRules() {
		return this.rules;
	}

	public void executeRule(Rule rule, Event event) {
		Thread t = new Thread(new RuleExecutionRunnable(rule, event));
		t.start();
	}

	public String getFileName() {
		return fileName;
	}
}

<code block>

package org.openhab.core.jsr223.internal.engine.scriptmanager;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;

import javax.script.ScriptEngineFactory;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;

import org.openhab.config.core.ConfigDispatcher;
import org.openhab.core.items.ItemRegistry;
import org.openhab.core.jsr223.internal.engine.RuleTriggerManager;
import org.openhab.core.jsr223.internal.shared.Event;
import org.openhab.core.jsr223.internal.shared.EventTrigger;
import org.openhab.core.jsr223.internal.shared.Rule;
import org.openhab.core.jsr223.internal.shared.StartupTrigger;
import org.openhab.core.jsr223.internal.shared.TriggerType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class ScriptManager {
	static private final Logger logger = LoggerFactory.getLogger(ScriptManager.class);

	public HashMap<String, Script> scripts = new HashMap<String, Script>();
	public HashMap<Rule, Script> ruleMap = new HashMap<Rule, Script>();

	private ItemRegistry itemRegistry;

	private RuleTriggerManager triggerManager;

	private Thread scriptUpdateWatcher;

	private static ScriptManager instance;

	public ScriptManager(RuleTriggerManager triggerManager, ItemRegistry itemRegistry) {
		this.triggerManager = triggerManager;
		instance = this;
		logger.info("Available engines:");
		for (ScriptEngineFactory f : new ScriptEngineManager().getEngineFactories()) {
			logger.info(f.getEngineName());
		}

		this.setItemRegistry(itemRegistry);

		File folder = getFolder("scripts");

		if (folder.exists() && folder.isDirectory()) {
			loadScripts(folder);

			scriptUpdateWatcher = new Thread(new ScriptUpdateWatcher(this, folder));
			scriptUpdateWatcher.start();
		} else {
			logger.warn("Script directory: jsr_scripts missing, no scripts will be added!");
		}
	}

	public void loadScripts(File folder) {
		for (File file : folder.listFiles()) {
			loadScript(file);
		}
	}

	private Script loadScript(File file) {
		Script script = null;
		try {
			script = new Script(this, file);
			scripts.put(file.getName(), script);
			List<Rule> newRules = script.getRules();
			for (Rule rule : newRules) {
				ruleMap.put(rule, script);
			}


			triggerManager.addRuleModel(newRules);

		} catch(NoSuchMethodException e) {
			logger.error("Script file misses mandotary function: getRules()", e);
		} catch (FileNotFoundException e) {
			logger.error("script file not found", e);
		} catch (ScriptException e) {
			logger.error("script exception", e);
		} catch (Exception e) {
			logger.error("unknown exception", e);
		}

		return script;
	}

	public static ScriptManager getInstance() {
		return instance;
	}

	public Collection<Rule> getAllRules() {
		return ruleMap.keySet();
	}

	public ItemRegistry getItemRegistry() {
		return itemRegistry;
	}

	public void setItemRegistry(ItemRegistry itemRegistry) {
		this.itemRegistry = itemRegistry;
	}

	public synchronized void executeRules(Rule[] rules, org.openhab.core.jsr223.internal.shared.Event event) {
		for (Rule rule : rules) {
			ruleMap.get(rule).executeRule(rule, event);
		}
	}

	public synchronized void executeRules(Iterable<Rule> rules, org.openhab.core.jsr223.internal.shared.Event event) {
		for (Rule rule : rules) {
			ruleMap.get(rule).executeRule(rule, event);
		}
	}


	private File getFolder(String foldername) {
		File folder = new File(ConfigDispatcher.getConfigFolder() + File.separator + foldername);
		return folder;
	}

	public Script getScript(Rule rule) {
		return ruleMap.get(rule);
	}

	public void scriptsChanged(List<File> addedScripts, List<File> removedScripts, List<File> modifiedScripts) {

		for (File scriptFile : removedScripts) {
			removeScript(scriptFile.getName());
		}

		for (File scriptFile : addedScripts) {
			Script script = loadScript(scriptFile);
			runStartupRules(script);
		}

		for (File scriptFile : modifiedScripts) {
			removeScript(scriptFile.getName());
			Script script = loadScript(scriptFile);
			runStartupRules(script);
		}
	}

	private void runStartupRules(Script script) {
		if (script != null) {
			ArrayList<Rule> toTrigger = new ArrayList<Rule>();
			for (Rule rule : script.getRules()) {
				for (EventTrigger trigger : rule.getEventTrigger()) {
					if (trigger instanceof StartupTrigger) {
						toTrigger.add(rule);
						break;
					}
				}
			}
			if (toTrigger.size() > 0)
				executeRules(toTrigger, new Event(TriggerType.STARTUP, null, null, null, null));
		}
	}

	private void removeScript(String scriptName) {
		if(scripts.containsKey(scriptName)) {
			Script script = scripts.remove(scriptName);

			List<Rule> allRules = script.getRules();

			triggerManager.removeRuleModel(allRules);
			for (Rule rule : allRules) {
				ruleMap.remove(rule);
			}
		}
	}

}

<code block>

package org.openhab.core.jsr223.internal.engine.scriptmanager;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.List;

import javax.script.Invocable;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.lang.StringUtils;
import org.joda.time.DateTime;
import org.openhab.core.jsr223.internal.engine.RuleExecutionRunnable;
import org.openhab.core.jsr223.internal.shared.ChangedEventTrigger;
import org.openhab.core.jsr223.internal.shared.CommandEventTrigger;
import org.openhab.core.jsr223.internal.shared.Event;
import org.openhab.core.jsr223.internal.shared.EventTrigger;
import org.openhab.core.jsr223.internal.shared.Openhab;
import org.openhab.core.jsr223.internal.shared.Rule;
import org.openhab.core.jsr223.internal.shared.RuleSet;
import org.openhab.core.jsr223.internal.shared.ShutdownTrigger;
import org.openhab.core.jsr223.internal.shared.StartupTrigger;
import org.openhab.core.jsr223.internal.shared.TimerTrigger;
import org.openhab.core.jsr223.internal.shared.TriggerType;
import org.openhab.core.library.types.DateTimeType;
import org.openhab.core.library.types.DecimalType;
import org.openhab.core.library.types.HSBType;
import org.openhab.core.library.types.IncreaseDecreaseType;
import org.openhab.core.library.types.OnOffType;
import org.openhab.core.library.types.OpenClosedType;
import org.openhab.core.library.types.PercentType;
import org.openhab.core.library.types.PointType;
import org.openhab.core.library.types.StopMoveType;
import org.openhab.core.library.types.StringType;
import org.openhab.core.library.types.UpDownType;
import org.openhab.core.persistence.extensions.PersistenceExtensions;
import org.openhab.core.types.Command;
import org.openhab.core.types.State;
import org.openhab.library.tel.types.CallType;
import org.openhab.model.script.actions.BusEvent;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class Script{
	static private final Logger logger = LoggerFactory.getLogger(Script.class);
	ArrayList<Rule> rules = new ArrayList<Rule>();
	private ScriptManager scriptManager;
	private ScriptEngine engine = null;
	private String fileName;

	public Script(ScriptManager scriptManager, File file) throws FileNotFoundException, ScriptException, NoSuchMethodException {
		this.scriptManager = scriptManager;
		this.fileName = file.getName();
		loadScript(file);
	}
	

	public void loadScript(File file) throws FileNotFoundException, ScriptException, NoSuchMethodException {
		logger.info("Loading Script " + file.getName());
		String extension = getFileExtension(file);
		ScriptEngineManager factory = new ScriptEngineManager();
		engine = factory.getEngineByExtension(extension);
		if (engine != null) {
			logger.info("EngineName: " + engine.getFactory().getEngineName());
			initializeSciptGlobals();
			engine.eval(new FileReader(file));
			Invocable inv = (Invocable) engine;
			RuleSet ruleSet = (RuleSet) inv.invokeFunction("getRules");
			rules.addAll(ruleSet.getRules());
		}
	}

	private void initializeSciptGlobals() {
		if(engine.getFactory().getEngineName().toLowerCase().endsWith("nashorn")){
			initializeNashornGlobals();
		}else{
			initializeGeneralGlobals();
		}
	}
	

	private void initializeNashornGlobals() {
		if( !Script.class.getClassLoader().getParent().toString().contains("ExtClassLoader") ){				
			logger.warn("Found wrong classloader: To prevent Class loading Problems use this directive in start.sh/-.bat: -Dorg.osgi.framework.bundle.parent=ext");
		}
		try {
			
			logger.info("initializeSciptGlobals for : " + engine.getFactory().getEngineName());			
			engine.put("ItemRegistry", 		scriptManager.getItemRegistry());
			engine.put("ir", 				scriptManager.getItemRegistry());
			engine.eval("var shared = org.openhab.core.jsr223.internal.shared,\n"
				+"RuleSet 				= Java.type('org.openhab.core.jsr223.internal.shared.RuleSet'),\n"
				+"Rule 					= Java.type('org.openhab.core.jsr223.internal.shared.Rule'),\n"
				+"ChangedEventTrigger 	= Java.type('org.openhab.core.jsr223.internal.shared.ChangedEventTrigger'),\n"
				+"CommandEventTrigger 	= Java.type('org.openhab.core.jsr223.internal.shared.CommandEventTrigger'),\n"
				+"Event 				= Java.type('org.openhab.core.jsr223.internal.shared.Event'),\n"
				+"EventTrigger			= Java.type('org.openhab.core.jsr223.internal.shared.EventTrigger'),\n"
				+"ShutdownTrigger 		= Java.type('org.openhab.core.jsr223.internal.shared.ShutdownTrigger'),\n"
				+"StartupTrigger 		= Java.type('org.openhab.core.jsr223.internal.shared.StartupTrigger'),\n"
				+"TimerTrigger 			= Java.type('org.openhab.core.jsr223.internal.shared.TimerTrigger'),\n"
				+"TriggerType 			= Java.type('org.openhab.core.jsr223.internal.shared.TriggerType'),\n"
				+"PersistenceExtensions	= Java.type('org.openhab.core.persistence.extensions.PersistenceExtensions'),\n"
				+"pe					= Java.type('org.openhab.core.persistence.extensions.PersistenceExtensions'),\n"
				+"oh 					= Java.type('org.openhab.core.jsr223.internal.shared.Openhab'),\n"
				+"State 				= Java.type('org.openhab.core.types.State'),\n"
				+"Command 				= Java.type('org.openhab.core.types.Command'),\n"
				+"DateTime 				= Java.type('org.joda.time.DateTime'),\n"
				+"StringUtils 			= Java.type('org.apache.commons.lang.StringUtils'),\n"
				+"URLEncoder 			= Java.type('java.net.URLEncoder'),\n"

				+"CallType 				= Java.type('org.openhab.library.tel.types.CallType'),\n"
				+"DateTimeType 			= Java.type('org.openhab.core.library.types.DateTimeType'),\n"
				+"DecimalType 			= Java.type('org.openhab.core.library.types.DecimalType'),\n"
				+"HSBType 				= Java.type('org.openhab.core.library.types.HSBType'),\n"
				+"IncreaseDecreaseType 	= Java.type('org.openhab.core.library.types.IncreaseDecreaseType'),\n"
				+"OnOffType 			= Java.type('org.openhab.core.library.types.OnOffType'),\n"
				+"OpenClosedType 		= Java.type('org.openhab.core.library.types.OpenClosedType'),\n"
				+"PercentType 			= Java.type('org.openhab.core.library.types.PercentType'),\n"
				+"PointType 			= Java.type('org.openhab.core.library.types.PointType'),\n"
				+"StopMoveType 			= Java.type('org.openhab.core.library.types.StopMoveType'),\n"
				+"UpDownType 			= Java.type('org.openhab.core.library.types.UpDownType'),\n"
				+"StringType 			= Java.type('org.openhab.core.library.types.StringType'),\n"
				



				+"BusEvent 				= Java.type('org.openhab.model.script.actions.BusEvent'),\n"
				+"be 					= Java.type('org.openhab.model.script.actions.BusEvent'),\n"
				
				+"transform 			= oh.getAction('Transformation').static.transform,\n"
				

				+"getItem 				= ItemRegistry.getItem,\n"
				+"postUpdate 			= BusEvent.postUpdate,\n"
				+"sendCommand 			= BusEvent.sendCommand,\n"
				

				+"FileUtils 			= Java.type('org.apache.commons.io.FileUtils'),\n"
				+"FilenameUtils			= Java.type('org.apache.commons.io.FilenameUtils'),\n"
				+"File 					= Java.type('java.io.File'),\n"
				
				+"ohEngine				= 'javascript';\n"
				



			);
			
		} catch (ScriptException e) {
			logger.error("ScriptException in initializeSciptGlobals while importing default-classes: ", e);
		}
	}
	
	private void initializeGeneralGlobals() {
		engine.put("RuleSet", 				RuleSet.class);
		engine.put("Rule", 					Rule.class);
		engine.put("ChangedEventTrigger", 	ChangedEventTrigger.class);
		engine.put("CommandEventTrigger", 	CommandEventTrigger.class);
		engine.put("Event", 				Event.class);
		engine.put("EventTrigger", 			EventTrigger.class);
		engine.put("ShutdownTrigger", 		ShutdownTrigger.class);
		engine.put("StartupTrigger", 		StartupTrigger.class);
		engine.put("TimerTrigger", 			TimerTrigger.class);
		engine.put("TriggerType", 			TriggerType.class);
		engine.put("BusEvent", 				BusEvent.class);
		engine.put("be", 					BusEvent.class);
		engine.put("PersistenceExtensions", PersistenceExtensions.class);
		engine.put("pe", 					PersistenceExtensions.class);
		engine.put("oh", 					Openhab.class);
		engine.put("State", 				State.class);
		engine.put("Command", 				Command.class);
		engine.put("ItemRegistry", 			scriptManager.getItemRegistry());
		engine.put("ir", 					scriptManager.getItemRegistry());
		engine.put("DateTime", 				DateTime.class);
		engine.put("StringUtils", 			StringUtils.class);
		engine.put("URLEncoder", 			URLEncoder.class);	
		engine.put("FileUtils", 			FileUtils.class);	
		engine.put("FilenameUtils", 		FilenameUtils.class);	
		engine.put("File", 					File.class);			


		engine.put("CallType", 				CallType.class);
		engine.put("DateTimeType", 			DateTimeType.class);
		engine.put("DecimalType", 			DecimalType.class);
		engine.put("HSBType", 				HSBType.class);
		engine.put("IncreaseDecreaseType", 	IncreaseDecreaseType.class);
		engine.put("OnOffType", 			OnOffType.class);
		engine.put("OpenClosedType", 		OpenClosedType.class);
		engine.put("PercentType", 			PercentType.class);
		engine.put("PointType", 			PointType.class);
		engine.put("StopMoveType", 			StopMoveType.class);
		engine.put("UpDownType", 			UpDownType.class);
		engine.put("StringType", 			StringType.class);
	}

	private String getFileExtension(File file) {
		String extension = null;
		if (file.getName().contains(".")) {
			String name = file.getName();
			extension = name.substring(name.lastIndexOf('.') + 1, name.length());
		}
		return extension;
	}

	public List<Rule> getRules() {
		return this.rules;
	}

	public void executeRule(Rule rule, Event event) {
		Thread t = new Thread(new RuleExecutionRunnable(rule, event));
		t.start();
	}

	public String getFileName() {
		return fileName;
	}

	public ScriptEngine getEngine() {
		return engine;
	}

}

<code block>

package org.openhab.core.jsr223.internal.engine.scriptmanager;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;

import javax.script.ScriptEngineFactory;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;

import org.openhab.config.core.ConfigDispatcher;
import org.openhab.core.items.ItemRegistry;
import org.openhab.core.jsr223.internal.engine.RuleTriggerManager;
import org.openhab.core.jsr223.internal.shared.Event;
import org.openhab.core.jsr223.internal.shared.EventTrigger;
import org.openhab.core.jsr223.internal.shared.Rule;
import org.openhab.core.jsr223.internal.shared.StartupTrigger;
import org.openhab.core.jsr223.internal.shared.TriggerType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class ScriptManager {
	static private final Logger logger = LoggerFactory.getLogger(ScriptManager.class);

	public HashMap<String, Script> scripts = new HashMap<String, Script>();
	public HashMap<Rule, Script> ruleMap = new HashMap<Rule, Script>();

	private ItemRegistry itemRegistry;

	private RuleTriggerManager triggerManager;

	private Thread scriptUpdateWatcher;

	private static ScriptManager instance;

	public ScriptManager(RuleTriggerManager triggerManager, ItemRegistry itemRegistry) {
		this.triggerManager = triggerManager;
		instance = this;
		logger.info("Available engines:");
		for (ScriptEngineFactory f : new ScriptEngineManager().getEngineFactories()) {
			logger.info(f.getEngineName());
		}

		this.setItemRegistry(itemRegistry);

		File folder = getFolder("scripts");

		if (folder.exists() && folder.isDirectory()) {
			loadScripts(folder);

			scriptUpdateWatcher = new Thread(new ScriptUpdateWatcher(this, folder));
			scriptUpdateWatcher.start();
		} else {
			logger.warn("Script directory: jsr_scripts missing, no scripts will be added!");
		}
	}

	public void loadScripts(File folder) {
		for (File file : folder.listFiles()) {
			loadScript(file);
		}
	}

	private Script loadScript(File file) {
		Script script = null;
		try {

			if(!file.isFile() || file.getName().startsWith(".") || getFileExtension(file) == null){
				return null;
			}
			script = new Script(this, file);
			if(script.getEngine() == null){
				logger.warn("No Engine found for File: {}", file.getName());
				return null;
			}else{
				logger.info("Engine found for File: {}", file.getName());
				scripts.put(file.getName(), script);
				List<Rule> newRules = script.getRules();
				for (Rule rule : newRules) {
					ruleMap.put(rule, script);
				}


				triggerManager.addRuleModel(newRules);
			}

		} catch(NoSuchMethodException e) {
			logger.error("Script file misses mandotary function: getRules()", e);
		} catch (FileNotFoundException e) {
			logger.error("script file not found", e);
		} catch (ScriptException e) {
			logger.error("script exception", e);
		} catch (Exception e) {
			logger.error("unknown exception", e);
		}

		return script;
	}

	public static ScriptManager getInstance() {
		return instance;
	}

	public Collection<Rule> getAllRules() {
		return ruleMap.keySet();
	}

	public ItemRegistry getItemRegistry() {
		return itemRegistry;
	}

	public void setItemRegistry(ItemRegistry itemRegistry) {
		this.itemRegistry = itemRegistry;
	}

	public synchronized void executeRules(Rule[] rules, org.openhab.core.jsr223.internal.shared.Event event) {
		for (Rule rule : rules) {
			ruleMap.get(rule).executeRule(rule, event);
		}
	}

	public synchronized void executeRules(Iterable<Rule> rules, org.openhab.core.jsr223.internal.shared.Event event) {
		for (Rule rule : rules) {
			ruleMap.get(rule).executeRule(rule, event);
		}
	}


	private File getFolder(String foldername) {
		File folder = new File(ConfigDispatcher.getConfigFolder() + File.separator + foldername);
		return folder;
	}

	public Script getScript(Rule rule) {
		return ruleMap.get(rule);
	}

	private String getFileExtension(File file) {
		String extension = null;
		if (file.getName().contains(".")) {
			String name = file.getName();
			extension = name.substring(name.lastIndexOf('.') + 1, name.length());
		}
		return extension;
	}

	public void scriptsChanged(List<File> addedScripts, List<File> removedScripts, List<File> modifiedScripts) {

		for (File scriptFile : removedScripts) {
			removeScript(scriptFile.getName());
		}

		for (File scriptFile : addedScripts) {
			Script script = loadScript(scriptFile);
			runStartupRules(script);
		}

		for (File scriptFile : modifiedScripts) {
			removeScript(scriptFile.getName());
			Script script = loadScript(scriptFile);
			runStartupRules(script);
		}
	}

	private void runStartupRules(Script script) {
		if (script != null) {
			ArrayList<Rule> toTrigger = new ArrayList<Rule>();
			for (Rule rule : script.getRules()) {
				for (EventTrigger trigger : rule.getEventTrigger()) {
					if (trigger instanceof StartupTrigger) {
						toTrigger.add(rule);
						break;
					}
				}
			}
			if (toTrigger.size() > 0)
				executeRules(toTrigger, new Event(TriggerType.STARTUP, null, null, null, null));
		}
	}

	private void removeScript(String scriptName) {
		if(scripts.containsKey(scriptName)) {
			Script script = scripts.remove(scriptName);

			List<Rule> allRules = script.getRules();

			triggerManager.removeRuleModel(allRules);
			for (Rule rule : allRules) {
				ruleMap.remove(rule);
			}
		}
	}

}

<code block>

package org.openhab.core.library.types;

import static org.junit.Assert.assertEquals;

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Collection;
import java.util.Locale;
import java.util.Map;
import java.util.HashMap;
import java.util.Arrays;
import java.util.TimeZone;

import org.junit.After;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameters;


@RunWith(Parameterized.class)
public class DateTimeTypeTest {
	
	private SimpleDateFormat dateFormatter = new SimpleDateFormat(DateTimeType.DATE_PATTERN);


	public static class ParameterSet {

		public final TimeZone defaultTimeZone;

		public final Map<String, Integer> inputTimeMap;

		public final TimeZone inputTimeZone;

		public final String inputTimeString;

		public final String expectedResult;


		public ParameterSet(TimeZone defaultTimeZone,
				Map<String, Integer> inputTimeMap, TimeZone inputTimeZone,
				String expectedResult) {
			this.defaultTimeZone = defaultTimeZone;
			this.inputTimeMap = inputTimeMap;
			this.inputTimeZone = inputTimeZone;
			this.inputTimeString = null;
			this.expectedResult = expectedResult;
		}
		

		public ParameterSet(TimeZone defaultTimeZone, String inputTimeString,
				String expectedResult) {
			this.defaultTimeZone = defaultTimeZone;
			this.inputTimeMap = null;
			this.inputTimeZone = null;
			this.inputTimeString = inputTimeString;
			this.expectedResult = expectedResult;
		}

	}


	@Parameters
	public static Collection<Object[]> parameters() {

		Map<String, Integer> inputTimeMap = new HashMap<String,Integer>();
		inputTimeMap.put("year", 2014);
		inputTimeMap.put("month", 2);
		inputTimeMap.put("date", 30);
		inputTimeMap.put("hourOfDay", 4);
		inputTimeMap.put("minute", 58);
		inputTimeMap.put("second", 47);

		return Arrays.asList(new Object[][] {
			{ new ParameterSet(TimeZone.getTimeZone("UTC")  , inputTimeMap, TimeZone.getTimeZone("UTC")   , "2014-03-30T04:58:47") },
			{ new ParameterSet(TimeZone.getTimeZone("UTC")  , inputTimeMap, TimeZone.getTimeZone("CET")   , "2014-03-30T02:58:47") },
			{ new ParameterSet(TimeZone.getTimeZone("UTC")  , "2014-03-30T04:58:47UTS"                    , "2014-03-30T04:58:47") },
			{ new ParameterSet(TimeZone.getTimeZone("CET")  , inputTimeMap, TimeZone.getTimeZone("UTC")   , "2014-03-30T04:58:47") },
			{ new ParameterSet(TimeZone.getTimeZone("CET")  , inputTimeMap, TimeZone.getTimeZone("CET")   , "2014-03-30T02:58:47") },
			{ new ParameterSet(TimeZone.getTimeZone("CET")  , "2014-03-30T04:58:47UTS"                    , "2014-03-30T04:58:47") },
			{ new ParameterSet(TimeZone.getTimeZone("GMT+2"), inputTimeMap, TimeZone.getTimeZone("GMT+3") , "2014-03-30T01:58:47") },
			{ new ParameterSet(TimeZone.getTimeZone("GMT-2"), inputTimeMap, TimeZone.getTimeZone("GMT+3") , "2014-03-30T01:58:47") },
			{ new ParameterSet(TimeZone.getTimeZone("GMT-2"), inputTimeMap, TimeZone.getTimeZone("GMT-3") , "2014-03-30T07:58:47") },
		});
	}

	private ParameterSet parameterSet;


	public DateTimeTypeTest(ParameterSet parameterSet) {
		this.parameterSet = parameterSet;
	}

	@After
	public void afterTest() {
		System.out.println("");
	}

	@Test
	public void createDate() {
		String inputTimeString;
		

		TimeZone.setDefault(parameterSet.defaultTimeZone);

		if (parameterSet.inputTimeString == null) {
			final Calendar calendar = Calendar.getInstance(parameterSet.inputTimeZone);
			calendar.set(parameterSet.inputTimeMap.get("year"), parameterSet.inputTimeMap.get("month"), parameterSet.inputTimeMap.get("date"), parameterSet.inputTimeMap.get("hourOfDay"), parameterSet.inputTimeMap.get("minute"), parameterSet.inputTimeMap.get("second"));
			inputTimeString = dateFormatter.format(calendar.getTime());
		} else {
			inputTimeString = parameterSet.inputTimeString;
		}
		DateTimeType dt = DateTimeType.valueOf(inputTimeString);
		

		System.out.println("createDate (Default TimeZone: " + parameterSet.defaultTimeZone.getDisplayName(false, TimeZone.SHORT, Locale.ROOT) + "):");
		if (parameterSet.inputTimeZone == null) {
			System.out.println("\tInput: " + inputTimeString);
		} else {
			System.out.println("\tInput: " + inputTimeString+parameterSet.inputTimeZone.getDisplayName(false, TimeZone.SHORT, Locale.ROOT));
		}
		System.out.println("\tExpected: " + parameterSet.expectedResult);
		System.out.println("\tResult  : " + dt.toString());

		assertEquals(parameterSet.expectedResult, dt.toString());
	}
}

<code block>

package org.openhab.core.library.types;

import static org.junit.Assert.assertEquals;

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Collection;
import java.util.Locale;
import java.util.Map;
import java.util.HashMap;
import java.util.Arrays;
import java.util.TimeZone;

import org.junit.After;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameters;


@RunWith(Parameterized.class)
public class DateTimeTypeTest {
	

	public static class ParameterSet {

		public final TimeZone defaultTimeZone;

		public final Map<String, Integer> inputTimeMap;

		public final TimeZone inputTimeZone;

		public final String inputTimeString;

		public final String expectedResult;


		public ParameterSet(TimeZone defaultTimeZone, Map<String, Integer> inputTimeMap, TimeZone inputTimeZone, String expectedResult) {
			this.defaultTimeZone = defaultTimeZone;
			this.inputTimeMap = inputTimeMap;
			this.inputTimeZone = inputTimeZone;
			this.inputTimeString = null;
			this.expectedResult = expectedResult;
		}
		

		public ParameterSet(TimeZone defaultTimeZone, String inputTimeString, String expectedResult) {
			this.defaultTimeZone = defaultTimeZone;
			this.inputTimeMap = null;
			this.inputTimeZone = null;
			this.inputTimeString = inputTimeString;
			this.expectedResult = expectedResult;
		}

	}


	@Parameters
	public static Collection<Object[]> parameters() {

		return Arrays.asList(new Object[][] {
			{ new ParameterSet(TimeZone.getTimeZone("UTC")  , initTimeMap(), TimeZone.getTimeZone("UTC")   , "2014-03-30T10:58:47") },
			{ new ParameterSet(TimeZone.getTimeZone("UTC")  , initTimeMap(), TimeZone.getTimeZone("CET")   , "2014-03-30T08:58:47") },
			{ new ParameterSet(TimeZone.getTimeZone("UTC")  , "2014-03-30T10:58:47UTS"                    , "2014-03-30T10:58:47") },
			{ new ParameterSet(TimeZone.getTimeZone("CET")  , initTimeMap(), TimeZone.getTimeZone("UTC")   , "2014-03-30T12:58:47") },
			{ new ParameterSet(TimeZone.getTimeZone("CET")  , initTimeMap(), TimeZone.getTimeZone("CET")   , "2014-03-30T10:58:47") },
			{ new ParameterSet(TimeZone.getTimeZone("CET")  , "2014-03-30T10:58:47UTS"                    , "2014-03-30T10:58:47") },
			
			{ new ParameterSet(TimeZone.getTimeZone("GMT"),   initTimeMap(), TimeZone.getTimeZone("GMT")   , "2014-03-30T10:58:47") },
			{ new ParameterSet(TimeZone.getTimeZone("GMT+2"), initTimeMap(), TimeZone.getTimeZone("GML") , "2014-03-30T12:58:47") },
			{ new ParameterSet(TimeZone.getTimeZone("GMT-2"), initTimeMap(), TimeZone.getTimeZone("GMT+3") , "2014-03-30T05:58:47") },
			{ new ParameterSet(TimeZone.getTimeZone("GMT-2"), initTimeMap(), TimeZone.getTimeZone("GMT-4") , "2014-03-30T12:58:47") },
		});
	}

	private static Map<String, Integer> initTimeMap() {
		Map<String, Integer> inputTimeMap = new HashMap<String,Integer>();
		inputTimeMap.put("year", 2014);
		inputTimeMap.put("month", 2);
		inputTimeMap.put("date", 30);
		inputTimeMap.put("hourOfDay", 10);
		inputTimeMap.put("minute", 58);
		inputTimeMap.put("second", 47);
		return inputTimeMap;
	}

	private ParameterSet parameterSet;


	public DateTimeTypeTest(ParameterSet parameterSet) {
		this.parameterSet = parameterSet;
	}

	@After
	public void afterTest() {
		System.out.println("");
	}

	@Test
	public void createDate() {
		String inputTimeString;
		

		TimeZone.setDefault(parameterSet.defaultTimeZone);
		

		if (parameterSet.inputTimeString == null) {
			final Calendar calendar = Calendar.getInstance(parameterSet.inputTimeZone);
			calendar.set(parameterSet.inputTimeMap.get("year"), parameterSet.inputTimeMap.get("month"), parameterSet.inputTimeMap.get("date"), parameterSet.inputTimeMap.get("hourOfDay"), parameterSet.inputTimeMap.get("minute"), parameterSet.inputTimeMap.get("second"));
			
			inputTimeString = new SimpleDateFormat(DateTimeType.DATE_PATTERN).format(calendar.getTime());
		} else {
			inputTimeString = parameterSet.inputTimeString;
		}
		
		DateTimeType dt = DateTimeType.valueOf(inputTimeString);
		

		System.out.println("createDate (Default TimeZone: expected=" + parameterSet.defaultTimeZone.getDisplayName(false, TimeZone.SHORT, Locale.ROOT) + "|current="+TimeZone.getDefault().getDisplayName()+"):");
		if (parameterSet.inputTimeZone == null) {
			System.out.println("\tInput: " + inputTimeString);
		} else {
			System.out.println("\tInput: " + inputTimeString+parameterSet.inputTimeZone.getDisplayName(false, TimeZone.SHORT, Locale.ROOT));
		}
		System.out.println("\tExpected: " + parameterSet.expectedResult);
		System.out.println("\tResult  : " + dt.toString());
		

		assertEquals(parameterSet.expectedResult, dt.toString());
	}
}
