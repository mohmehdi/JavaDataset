

package com.vaadin.ui;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.jsoup.nodes.Attributes;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;

import com.vaadin.event.LayoutEvents.LayoutClickEvent;
import com.vaadin.event.LayoutEvents.LayoutClickListener;
import com.vaadin.event.LayoutEvents.LayoutClickNotifier;
import com.vaadin.server.PaintException;
import com.vaadin.server.PaintTarget;
import com.vaadin.shared.Connector;
import com.vaadin.shared.EventId;
import com.vaadin.shared.MouseEventDetails;
import com.vaadin.shared.ui.MarginInfo;
import com.vaadin.shared.ui.gridlayout.GridLayoutServerRpc;
import com.vaadin.shared.ui.gridlayout.GridLayoutState;
import com.vaadin.shared.ui.gridlayout.GridLayoutState.ChildComponentData;
import com.vaadin.ui.declarative.DesignAttributeHandler;
import com.vaadin.ui.declarative.DesignContext;


@SuppressWarnings("serial")
public class GridLayout extends AbstractLayout implements
        Layout.AlignmentHandler, Layout.SpacingHandler, Layout.MarginHandler,
        LayoutClickNotifier, LegacyComponent {

    private GridLayoutServerRpc rpc = new GridLayoutServerRpc() {

        @Override
        public void layoutClick(MouseEventDetails mouseDetails,
                Connector clickedConnector) {
            fireEvent(LayoutClickEvent.createEvent(GridLayout.this,
                    mouseDetails, clickedConnector));

        }
    };

    private int cursorX = 0;


    private int cursorY = 0;

    private final LinkedList<Component> components = new LinkedList<Component>();

    private Map<Integer, Float> columnExpandRatio = new HashMap<Integer, Float>();
    private Map<Integer, Float> rowExpandRatio = new HashMap<Integer, Float>();
    private Alignment defaultComponentAlignment = Alignment.TOP_LEFT;


    public GridLayout(int columns, int rows) {
        setColumns(columns);
        setRows(rows);
        registerRpc(rpc);
    }


    public GridLayout() {
        this(1, 1);
    }


    public GridLayout(int columns, int rows, Component... children) {
        this(columns, rows);
        addComponents(children);
    }

    @Override
    protected GridLayoutState getState() {
        return (GridLayoutState) super.getState();
    }

    @Override
    protected GridLayoutState getState(boolean markAsDirty) {
        return (GridLayoutState) super.getState(markAsDirty);
    }


    public void addComponent(Component component, int column1, int row1,
            int column2, int row2) throws OverlapsException,
            OutOfBoundsException {

        if (component == null) {
            throw new NullPointerException("Component must not be null");
        }


        if (components.contains(component)) {
            throw new IllegalArgumentException(
                    "Component is already in the container");
        }


        final Area area = new Area(component, column1, row1, column2, row2);


        if (column2 < column1 || row2 < row1) {
            throw new IllegalArgumentException(
                    "Illegal coordinates for the component");
        }
        if (column1 < 0 || row1 < 0 || column2 >= getColumns()
                || row2 >= getRows()) {
            throw new OutOfBoundsException(area);
        }


        checkExistingOverlaps(area);




        final Iterator<Component> i = components.iterator();
        final Map<Connector, ChildComponentData> childDataMap = getState().childData;
        int index = 0;
        boolean done = false;
        while (!done && i.hasNext()) {
            final ChildComponentData existingArea = childDataMap.get(i.next());
            if ((existingArea.row1 >= row1 && existingArea.column1 > column1)
                    || existingArea.row1 > row1) {
                components.add(index, component);
                done = true;
            }
            index++;
        }
        if (!done) {
            components.addLast(component);
        }

        childDataMap.put(component, area.childData);


        try {
            super.addComponent(component);
        } catch (IllegalArgumentException e) {
            childDataMap.remove(component);
            components.remove(component);
            throw e;
        }



        if (cursorX >= column1 && cursorX <= column2 && cursorY >= row1
                && cursorY <= row2) {

            cursorX = column2 + 1; 
            if (cursorX >= getColumns()) {

                cursorX = 0; 

                cursorY = (column1 == 0 ? row2 : row1) + 1;
            } else {
                cursorY = row1;
            }
        }
    }


    private void checkExistingOverlaps(Area area) throws OverlapsException {
        for (Entry<Connector, ChildComponentData> entry : getState().childData
                .entrySet()) {
            if (componentsOverlap(entry.getValue(), area.childData)) {

                throw new OverlapsException(new Area(entry.getValue(),
                        (Component) entry.getKey()));
            }
        }
    }


    public void addComponent(Component component, int column, int row)
            throws OverlapsException, OutOfBoundsException {
        this.addComponent(component, column, row, column, row);
    }


    public void newLine() {
        cursorX = 0;
        cursorY++;
    }


    public void space() {
        cursorX++;
        if (cursorX >= getColumns()) {
            cursorX = 0;
            cursorY++;
        }
    }


    @Override
    public void addComponent(Component component) {
        if (component == null) {
            throw new IllegalArgumentException("Component must not be null");
        }


        Area area;
        boolean done = false;
        while (!done) {
            try {
                area = new Area(component, cursorX, cursorY, cursorX, cursorY);
                checkExistingOverlaps(area);
                done = true;
            } catch (final OverlapsException e) {
                space();
            }
        }


        if (cursorX >= getColumns()) {
            setColumns(cursorX + 1);
        }
        if (cursorY >= getRows()) {
            setRows(cursorY + 1);
        }

        addComponent(component, cursorX, cursorY);
    }


    @Override
    public void removeComponent(Component component) {


        if (component == null || !components.contains(component)) {
            return;
        }

        getState().childData.remove(component);
        components.remove(component);
        super.removeComponent(component);
    }


    public void removeComponent(int column, int row) {


        for (final Iterator<Component> i = components.iterator(); i.hasNext();) {
            final Component component = i.next();
            final ChildComponentData childData = getState().childData
                    .get(component);
            if (childData.column1 == column && childData.row1 == row) {
                removeComponent(component);
                return;
            }
        }
    }


    @Override
    public Iterator<Component> iterator() {
        return Collections.unmodifiableCollection(components).iterator();
    }


    @Override
    public int getComponentCount() {
        return components.size();
    }

    @Override
    public void changeVariables(Object source, Map<String, Object> variables) {

    }


    @Override
    public void paintContent(PaintTarget target) throws PaintException {
        final Integer[] columnExpandRatioArray = new Integer[getColumns()];
        final Integer[] rowExpandRatioArray = new Integer[getRows()];

        int realColExpandRatioSum = 0;
        float colSum = getExpandRatioSum(columnExpandRatio);
        if (colSum == 0) {


            float equalSize = 1 / (float) getColumns();
            int myRatio = Math.round(equalSize * 1000);
            for (int i = 0; i < getColumns(); i++) {
                columnExpandRatioArray[i] = myRatio;
            }
            realColExpandRatioSum = myRatio * getColumns();
        } else {
            for (int i = 0; i < getColumns(); i++) {
                int myRatio = Math
                        .round((getColumnExpandRatio(i) / colSum) * 1000);
                columnExpandRatioArray[i] = myRatio;
                realColExpandRatioSum += myRatio;
            }
        }

        int realRowExpandRatioSum = 0;
        float rowSum = getExpandRatioSum(rowExpandRatio);
        if (rowSum == 0) {

            float equalSize = 1 / (float) getRows();
            int myRatio = Math.round(equalSize * 1000);
            for (int i = 0; i < getRows(); i++) {
                rowExpandRatioArray[i] = myRatio;
            }
            realRowExpandRatioSum = myRatio * getRows();
        } else {
            for (int cury = 0; cury < getRows(); cury++) {
                int myRatio = Math
                        .round((getRowExpandRatio(cury) / rowSum) * 1000);
                rowExpandRatioArray[cury] = myRatio;
                realRowExpandRatioSum += myRatio;
            }
        }


        if (rowExpandRatioArray.length > 0) {
            rowExpandRatioArray[0] -= realRowExpandRatioSum - 1000;
        }
        if (columnExpandRatioArray.length > 0) {
            columnExpandRatioArray[0] -= realColExpandRatioSum - 1000;
        }
        target.addAttribute("colExpand", columnExpandRatioArray);
        target.addAttribute("rowExpand", rowExpandRatioArray);

    }

    private float getExpandRatioSum(Map<Integer, Float> ratioMap) {
        float sum = 0;
        for (Iterator<Entry<Integer, Float>> iterator = ratioMap.entrySet()
                .iterator(); iterator.hasNext();) {
            sum += iterator.next().getValue();
        }
        return sum;
    }


    @Override
    public Alignment getComponentAlignment(Component childComponent) {
        ChildComponentData childComponentData = getState(false).childData
                .get(childComponent);
        if (childComponentData == null) {
            throw new IllegalArgumentException(
                    "The given component is not a child of this layout");
        } else {
            return new Alignment(childComponentData.alignment);
        }
    }


    public class Area implements Serializable {
        private final ChildComponentData childData;
        private final Component component;


        public Area(Component component, int column1, int row1, int column2,
                int row2) {
            this.component = component;
            childData = new ChildComponentData();
            childData.alignment = getDefaultComponentAlignment().getBitMask();
            childData.column1 = column1;
            childData.row1 = row1;
            childData.column2 = column2;
            childData.row2 = row2;
        }

        public Area(ChildComponentData childData, Component component) {
            this.childData = childData;
            this.component = component;
        }


        public boolean overlaps(Area other) {
            return componentsOverlap(childData, other.childData);
        }


        public Component getComponent() {
            return component;
        }


        public int getColumn1() {
            return childData.column1;
        }


        public int getColumn2() {
            return childData.column2;
        }


        public int getRow1() {
            return childData.row1;
        }


        public int getRow2() {
            return childData.row2;
        }

    }

    private static boolean componentsOverlap(ChildComponentData a,
            ChildComponentData b) {
        return a.column1 <= b.column2 && a.row1 <= b.row2
                && a.column2 >= b.column1 && a.row2 >= b.row1;
    }


    public class OverlapsException extends java.lang.RuntimeException {

        private final Area existingArea;


        public OverlapsException(Area existingArea) {
            this.existingArea = existingArea;
        }

        @Override
        public String getMessage() {
            StringBuilder sb = new StringBuilder();
            Component component = existingArea.getComponent();
            sb.append(component);
            sb.append("( type = ");
            sb.append(component.getClass().getName());
            if (component.getCaption() != null) {
                sb.append(", caption = \"");
                sb.append(component.getCaption());
                sb.append("\"");
            }
            sb.append(")");
            sb.append(" is already added to ");
            sb.append(existingArea.childData.column1);
            sb.append(",");
            sb.append(existingArea.childData.column1);
            sb.append(",");
            sb.append(existingArea.childData.row1);
            sb.append(",");
            sb.append(existingArea.childData.row2);
            sb.append("(column1, column2, row1, row2).");

            return sb.toString();
        }


        public Area getArea() {
            return existingArea;
        }
    }


    public class OutOfBoundsException extends java.lang.RuntimeException {

        private final Area areaOutOfBounds;


        public OutOfBoundsException(Area areaOutOfBounds) {
            this.areaOutOfBounds = areaOutOfBounds;
        }


        public Area getArea() {
            return areaOutOfBounds;
        }
    }


    public void setColumns(int columns) {


        if (columns < 1) {
            throw new IllegalArgumentException(
                    "The number of columns and rows in the grid must be at least 1");
        }


        if (getColumns() == columns) {
            return;
        }


        if (getColumns() > columns) {
            for (Entry<Connector, ChildComponentData> entry : getState().childData
                    .entrySet()) {
                if (entry.getValue().column2 >= columns) {
                    throw new OutOfBoundsException(new Area(entry.getValue(),
                            (Component) entry.getKey()));
                }
            }
        }


        if (columns < getColumns()) {
            for (int i = columns - 1; i < getColumns(); i++) {
                columnExpandRatio.remove(i);
                getState().explicitColRatios.remove(i);
            }
        }

        getState().columns = columns;
    }


    public int getColumns() {
        return getState(false).columns;
    }


    public void setRows(int rows) {


        if (rows < 1) {
            throw new IllegalArgumentException(
                    "The number of columns and rows in the grid must be at least 1");
        }


        if (getRows() == rows) {
            return;
        }


        if (getRows() > rows) {
            for (Entry<Connector, ChildComponentData> entry : getState().childData
                    .entrySet()) {
                if (entry.getValue().row2 >= rows) {
                    throw new OutOfBoundsException(new Area(entry.getValue(),
                            (Component) entry.getKey()));
                }
            }
        }


        getState().rows = rows;
    }


    public int getRows() {
        return getState(false).rows;
    }


    public int getCursorX() {
        return cursorX;
    }


    public void setCursorX(int cursorX) {
        this.cursorX = cursorX;
    }


    public int getCursorY() {
        return cursorY;
    }


    public void setCursorY(int cursorY) {
        this.cursorY = cursorY;
    }


    @Override
    public void replaceComponent(Component oldComponent, Component newComponent) {


        ChildComponentData oldLocation = getState().childData.get(oldComponent);
        ChildComponentData newLocation = getState().childData.get(newComponent);

        if (oldLocation == null) {
            addComponent(newComponent);
        } else if (newLocation == null) {
            removeComponent(oldComponent);
            addComponent(newComponent, oldLocation.column1, oldLocation.row1,
                    oldLocation.column2, oldLocation.row2);
        } else {
            int oldAlignment = oldLocation.alignment;
            oldLocation.alignment = newLocation.alignment;
            newLocation.alignment = oldAlignment;

            getState().childData.put(newComponent, oldLocation);
            getState().childData.put(oldComponent, newLocation);
        }
    }


    @Override
    public void removeAllComponents() {
        super.removeAllComponents();
        cursorX = 0;
        cursorY = 0;
    }

    @Override
    public void setComponentAlignment(Component childComponent,
            Alignment alignment) {
        ChildComponentData childComponentData = getState().childData
                .get(childComponent);
        if (childComponentData == null) {
            throw new IllegalArgumentException(
                    "Component must be added to layout before using setComponentAlignment()");
        } else {
            if (alignment == null) {
                childComponentData.alignment = GridLayoutState.ALIGNMENT_DEFAULT
                        .getBitMask();
            } else {
                childComponentData.alignment = alignment.getBitMask();
            }
        }
    }


    @Override
    public void setSpacing(boolean spacing) {
        getState().spacing = spacing;
    }


    @Override
    public boolean isSpacing() {
        return getState(false).spacing;
    }


    public void insertRow(int row) {
        if (row > getRows()) {
            throw new IllegalArgumentException("Cannot insert row at " + row
                    + " in a gridlayout with height " + getRows());
        }

        for (ChildComponentData existingArea : getState().childData.values()) {

            if (existingArea.row2 >= row) {
                existingArea.row2++;


                if (existingArea.row1 >= row) {
                    existingArea.row1++;
                }

            }
        }

        if (cursorY >= row) {
            cursorY++;
        }

        setRows(getRows() + 1);
        markAsDirty();
    }


    public void removeRow(int row) {
        if (row >= getRows()) {
            throw new IllegalArgumentException("Cannot delete row " + row
                    + " from a gridlayout with height " + getRows());
        }


        for (int col = 0; col < getColumns(); col++) {
            removeComponent(col, row);
        }


        for (ChildComponentData existingArea : getState().childData.values()) {
            if (existingArea.row2 >= row) {
                existingArea.row2--;

                if (existingArea.row1 > row) {
                    existingArea.row1--;
                }
            }
        }

        if (getRows() == 1) {

            cursorX = 0;
            cursorY = 0;
        } else {
            setRows(getRows() - 1);
            if (cursorY > row) {
                cursorY--;
            }
        }

        markAsDirty();

    }


    public void setColumnExpandRatio(int columnIndex, float ratio) {
        columnExpandRatio.put(columnIndex, ratio);
        getState().explicitColRatios.add(columnIndex);
        markAsDirty();
    }


    public float getColumnExpandRatio(int columnIndex) {
        Float r = columnExpandRatio.get(columnIndex);
        return r == null ? 0 : r.floatValue();
    }


    public void setRowExpandRatio(int rowIndex, float ratio) {
        rowExpandRatio.put(rowIndex, ratio);
        getState().explicitRowRatios.add(rowIndex);
        markAsDirty();
    }


    public float getRowExpandRatio(int rowIndex) {
        Float r = rowExpandRatio.get(rowIndex);
        return r == null ? 0 : r.floatValue();
    }


    public Component getComponent(int x, int y) {
        for (Entry<Connector, ChildComponentData> entry : getState(false).childData
                .entrySet()) {
            ChildComponentData childData = entry.getValue();
            if (childData.column1 <= x && x <= childData.column2
                    && childData.row1 <= y && y <= childData.row2) {
                return (Component) entry.getKey();
            }
        }
        return null;
    }


    public Area getComponentArea(Component component) {
        ChildComponentData childComponentData = getState(false).childData
                .get(component);
        if (childComponentData == null) {
            return null;
        } else {
            return new Area(childComponentData, component);
        }
    }

    @Override
    public void addLayoutClickListener(LayoutClickListener listener) {
        addListener(EventId.LAYOUT_CLICK_EVENT_IDENTIFIER,
                LayoutClickEvent.class, listener,
                LayoutClickListener.clickMethod);
    }


    @Override
    @Deprecated
    public void addListener(LayoutClickListener listener) {
        addLayoutClickListener(listener);
    }

    @Override
    public void removeLayoutClickListener(LayoutClickListener listener) {
        removeListener(EventId.LAYOUT_CLICK_EVENT_IDENTIFIER,
                LayoutClickEvent.class, listener);
    }


    @Override
    @Deprecated
    public void removeListener(LayoutClickListener listener) {
        removeLayoutClickListener(listener);
    }


    @Override
    public void setMargin(boolean enabled) {
        setMargin(new MarginInfo(enabled));
    }


    @Override
    public void setMargin(MarginInfo marginInfo) {
        getState().marginsBitmask = marginInfo.getBitMask();
    }


    @Override
    public MarginInfo getMargin() {
        return new MarginInfo(getState(false).marginsBitmask);
    }


    @Override
    public Alignment getDefaultComponentAlignment() {
        return defaultComponentAlignment;
    }


    @Override
    public void setDefaultComponentAlignment(Alignment defaultAlignment) {
        defaultComponentAlignment = defaultAlignment;
    }


    public void setHideEmptyRowsAndColumns(boolean hideEmptyRowsAndColumns) {
        getState().hideEmptyRowsAndColumns = hideEmptyRowsAndColumns;
    }


    public boolean isHideEmptyRowsAndColumns() {
        return getState(false).hideEmptyRowsAndColumns;
    }


    @Override
    public void readDesign(Element design, DesignContext designContext) {
        super.readDesign(design, designContext);


        Elements rowElements = design.getElementsByTag("row");
        List<Map<Integer, Component>> rows = new ArrayList<Map<Integer, Component>>();
        for (int i = 0; i < rowElements.size(); ++i) {
            rows.add(new HashMap<Integer, Component>());
        }
        setRows(Math.max(rows.size(), 1));

        List<Integer> columnExpandRatios = new ArrayList<Integer>();
        for (int row = 0; row < rowElements.size(); ++row) {
            Element rowElement = rowElements.get(row);


            if (rowElement.hasAttr("expand")) {
                int expand = DesignAttributeHandler.readAttribute("expand",
                        rowElement.attributes(), int.class);
                setRowExpandRatio(row, expand);
            }

            Elements cols = rowElement.children();


            int skippedColumns = 0;

            for (int column = 0; column < cols.size(); ++column) {
                while (rows.get(row).containsKey(column + skippedColumns)) {

                    skippedColumns++;
                }

                Element col = cols.get(column);
                Component child = null;

                if (col.children().size() > 0) {
                    child = designContext.readDesign(col.child(0));


                } 


                Attributes attr = col.attributes();
                int colspan = DesignAttributeHandler.readAttribute("colspan",
                        attr, 1, int.class);
                int rowspan = DesignAttributeHandler.readAttribute("rowspan",
                        attr, 1, int.class);

                for (int rowIndex = row; rowIndex < row + rowspan; ++rowIndex) {
                    for (int colIndex = column; colIndex < column + colspan; ++colIndex) {
                        if (rowIndex == rows.size()) {

                            rows.add(new HashMap<Integer, Component>());
                        }
                        rows.get(rowIndex)
                                .put(colIndex + skippedColumns, child);
                    }
                }


                if (row == 0) {
                    if (col.hasAttr("expand")) {
                        for (String expand : col.attr("expand").split(",")) {
                            columnExpandRatios.add(Integer.parseInt(expand));
                        }
                    } else {
                        for (int c = 0; c < colspan; ++c) {
                            columnExpandRatios.add(0);
                        }
                    }
                }

                skippedColumns += (colspan - 1);
            }
        }


        int colMax = 0;
        for (Map<Integer, Component> cols : rows) {
            if (colMax < cols.size()) {
                colMax = cols.size();
            }
        }
        setColumns(Math.max(colMax, 1));

        for (int i = 0; i < columnExpandRatios.size(); ++i) {
            setColumnExpandRatio(i, columnExpandRatios.get(i));
        }


        Set<Component> visited = new HashSet<Component>();


        visited.add(null);

        for (int i = 0; i < rows.size(); ++i) {
            Map<Integer, Component> row = rows.get(i);
            for (int j = 0; j < colMax; ++j) {
                Component child = row.get(j);
                if (visited.contains(child)) {

                    continue;
                }
                visited.add(child);


                int colspan = 0;
                while (j + colspan + 1 < row.size()
                        && row.get(j + colspan + 1) == child) {
                    ++colspan;
                }

                int rowspan = 0;
                while (i + rowspan + 1 < rows.size()
                        && rows.get(i + rowspan + 1).get(j) == child) {
                    ++rowspan;
                }


                addComponent(child, j, i, j + colspan, i + rowspan);
            }
        }

        setCursorY(getRows());
        setCursorX(0);
    }

    @Override
    public void writeDesign(Element design, DesignContext designContext) {
        super.writeDesign(design, designContext);

        GridLayout def = designContext.getDefaultInstance(this);
        if (components.isEmpty()
                || !designContext.shouldWriteChildren(this, def)) {
            return;
        }

        final Map<Connector, ChildComponentData> childData = getState().childData;


        Component[][] componentMap = new Component[getState().rows][getState().columns];
        final Component dummyComponent = new Label("");

        for (Component component : components) {
            ChildComponentData coords = childData.get(component);
            for (int row = coords.row1; row <= coords.row2; ++row) {
                for (int col = coords.column1; col <= coords.column2; ++col) {
                    componentMap[row][col] = component;
                }
            }
        }


        Set<Connector> visited = new HashSet<Connector>();


        visited.add(dummyComponent);

        for (int i = 0; i < componentMap.length; ++i) {
            Element row = design.appendElement("row");


            DesignAttributeHandler.writeAttribute("expand", row.attributes(),
                    (int) getRowExpandRatio(i), 0, int.class);

            int colspan = 1;
            Element col;
            for (int j = 0; j < componentMap[i].length; ++j) {
                Component child = componentMap[i][j];
                if (child != null) {
                    if (visited.contains(child)) {

                        continue;
                    }
                    visited.add(child);

                    Element childElement = designContext.createElement(child);
                    col = row.appendElement("column");


                    ChildComponentData coords = childData.get(child);

                    Alignment alignment = getComponentAlignment(child);
                    if (alignment.isMiddle()) {
                        childElement.attr(":middle", "");
                    } else if (alignment.isBottom()) {
                        childElement.attr(":bottom", "");
                    }
                    if (alignment.isCenter()) {
                        childElement.attr(":center", "");
                    } else if (alignment.isRight()) {
                        childElement.attr(":right", "");
                    }

                    col.appendChild(childElement);
                    if (coords.row1 != coords.row2) {
                        col.attr("rowspan", ""
                                + (1 + coords.row2 - coords.row1));
                    }

                    colspan = 1 + coords.column2 - coords.column1;
                    if (colspan > 1) {
                        col.attr("colspan", "" + colspan);
                    }

                } else {
                    boolean hasExpands = false;
                    if (i == 0
                            && lastComponentOnRow(componentMap[i], j, visited)) {


                        for (int c = j; c < componentMap[i].length; ++c) {
                            if ((int) getColumnExpandRatio(c) > 0) {
                                hasExpands = true;
                            }
                        }
                    }

                    if (lastComponentOnRow(componentMap[i], j, visited)
                            && !hasExpands) {
                        continue;
                    }


                    col = row.appendElement("column");


                    while (j + colspan < componentMap[i].length
                            && componentMap[i][j + colspan] == child) {
                        ++colspan;
                    }

                    int rowspan = getRowSpan(componentMap, i, j, colspan, child);
                    if (colspan > 1) {
                        col.attr("colspan", "" + colspan);
                    }
                    if (rowspan > 1) {
                        col.attr("rowspan", "" + rowspan);
                    }
                    for (int x = 0; x < rowspan; ++x) {
                        for (int y = 0; y < colspan; ++y) {

                            componentMap[i + x][j + y] = dummyComponent;
                        }
                    }
                }


                if (i == 0) {

                    String expands = "";
                    boolean expandRatios = false;
                    for (int c = 0; c < colspan; ++c) {
                        int colExpand = (int) getColumnExpandRatio(j + c);
                        if (colExpand > 0) {
                            expandRatios = true;
                        }
                        expands += (c > 0 ? "," : "") + colExpand;
                    }
                    if (expandRatios) {
                        col.attr("expand", expands);
                    }
                }

                j += colspan - 1;
            }
        }
    }

    private int getRowSpan(Component[][] compMap, int i, int j, int colspan,
            Component child) {
        int rowspan = 1;
        while (i + rowspan < compMap.length && compMap[i + rowspan][j] == child) {
            for (int k = 0; k < colspan; ++k) {
                if (compMap[i + rowspan][j + k] != child) {
                    return rowspan;
                }
            }
            rowspan++;
        }
        return rowspan;
    }

    private boolean lastComponentOnRow(Component[] componentArray, int j,
            Set<Connector> visited) {
        while ((++j) < componentArray.length) {
            Component child = componentArray[j];
            if (child != null && !visited.contains(child)) {
                return false;
            }
        }
        return true;
    }

    @Override
    protected Collection<String> getCustomAttributes() {
        Collection<String> result = super.getCustomAttributes();
        result.add("cursor-x");
        result.add("cursor-y");
        result.add("rows");
        result.add("columns");
        return result;
    }
}
<code block>

package com.vaadin.ui;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

import com.vaadin.server.Sizeable.Unit;

public class GridLayoutExpandRatioTest {

    private GridLayout gridLayout;

    @Test
    public void testColExpandRatioIsForgotten() {
        gridLayout = new GridLayout(4, 1);
        gridLayout.setWidth(100, Unit.PERCENTAGE);
        gridLayout.setSpacing(true);

        addComponents(true);

        gridLayout.setColumnExpandRatio(1, 1);
        gridLayout.setColumnExpandRatio(3, 1);

        assertTrue(gridLayout.getColumnExpandRatio(0) == 0);
        assertTrue(gridLayout.getColumnExpandRatio(1) == 1);
        assertTrue(gridLayout.getColumnExpandRatio(2) == 0);
        assertTrue(gridLayout.getColumnExpandRatio(3) == 1);
        assertFalse(gridLayout.getState().explicitColRatios.contains(0));
        assertTrue(gridLayout.getState().explicitColRatios.contains(1));
        assertFalse(gridLayout.getState().explicitColRatios.contains(2));
        assertTrue(gridLayout.getState().explicitColRatios.contains(3));

        remove();

        assertTrue(gridLayout.getColumnExpandRatio(0) == 0);
        assertTrue(gridLayout.getColumnExpandRatio(1) == 1);
        assertTrue(gridLayout.getColumnExpandRatio(2) == 0);
        assertTrue(gridLayout.getColumnExpandRatio(3) == 0);
        assertFalse(gridLayout.getState().explicitColRatios.contains(0));
        assertTrue(gridLayout.getState().explicitColRatios.contains(1));
        assertFalse(gridLayout.getState().explicitColRatios.contains(2));
        assertFalse(gridLayout.getState().explicitColRatios.contains(3));

    }

    private void remove() {
        gridLayout.removeAllComponents();
        gridLayout.setColumns(3);
        addComponents(false);
    }

    private void addComponents(boolean includeLastOne) {
        gridLayout.addComponent(label("{1}"));
        gridLayout.addComponent(label("{2}"));
        gridLayout.addComponent(label("{3}"));
        if (includeLastOne) {
            gridLayout.addComponent(label("{4}"));
        }
    }

    private Label label(String content) {
        Label label = new Label(content);
        label.setSizeUndefined();
        return label;
    }
}

<code block>


package com.vaadin.ui;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.jsoup.nodes.Attributes;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;

import com.vaadin.event.LayoutEvents.LayoutClickEvent;
import com.vaadin.event.LayoutEvents.LayoutClickListener;
import com.vaadin.event.LayoutEvents.LayoutClickNotifier;
import com.vaadin.server.PaintException;
import com.vaadin.server.PaintTarget;
import com.vaadin.shared.Connector;
import com.vaadin.shared.EventId;
import com.vaadin.shared.MouseEventDetails;
import com.vaadin.shared.ui.MarginInfo;
import com.vaadin.shared.ui.gridlayout.GridLayoutServerRpc;
import com.vaadin.shared.ui.gridlayout.GridLayoutState;
import com.vaadin.shared.ui.gridlayout.GridLayoutState.ChildComponentData;
import com.vaadin.ui.declarative.DesignAttributeHandler;
import com.vaadin.ui.declarative.DesignContext;


@SuppressWarnings("serial")
public class GridLayout extends AbstractLayout implements
        Layout.AlignmentHandler, Layout.SpacingHandler, Layout.MarginHandler,
        LayoutClickNotifier, LegacyComponent {

    private GridLayoutServerRpc rpc = new GridLayoutServerRpc() {

        @Override
        public void layoutClick(MouseEventDetails mouseDetails,
                Connector clickedConnector) {
            fireEvent(LayoutClickEvent.createEvent(GridLayout.this,
                    mouseDetails, clickedConnector));

        }
    };

    private int cursorX = 0;


    private int cursorY = 0;

    private final LinkedList<Component> components = new LinkedList<Component>();

    private Map<Integer, Float> columnExpandRatio = new HashMap<Integer, Float>();
    private Map<Integer, Float> rowExpandRatio = new HashMap<Integer, Float>();
    private Alignment defaultComponentAlignment = Alignment.TOP_LEFT;


    public GridLayout(int columns, int rows) {
        setColumns(columns);
        setRows(rows);
        registerRpc(rpc);
    }


    public GridLayout() {
        this(1, 1);
    }


    public GridLayout(int columns, int rows, Component... children) {
        this(columns, rows);
        addComponents(children);
    }

    @Override
    protected GridLayoutState getState() {
        return (GridLayoutState) super.getState();
    }

    @Override
    protected GridLayoutState getState(boolean markAsDirty) {
        return (GridLayoutState) super.getState(markAsDirty);
    }


    public void addComponent(Component component, int column1, int row1,
            int column2, int row2) throws OverlapsException,
            OutOfBoundsException {

        if (component == null) {
            throw new NullPointerException("Component must not be null");
        }


        if (components.contains(component)) {
            throw new IllegalArgumentException(
                    "Component is already in the container");
        }


        final Area area = new Area(component, column1, row1, column2, row2);


        if (column2 < column1 || row2 < row1) {
            throw new IllegalArgumentException(
                    "Illegal coordinates for the component");
        }
        if (column1 < 0 || row1 < 0 || column2 >= getColumns()
                || row2 >= getRows()) {
            throw new OutOfBoundsException(area);
        }


        checkExistingOverlaps(area);




        final Iterator<Component> i = components.iterator();
        final Map<Connector, ChildComponentData> childDataMap = getState().childData;
        int index = 0;
        boolean done = false;
        while (!done && i.hasNext()) {
            final ChildComponentData existingArea = childDataMap.get(i.next());
            if ((existingArea.row1 >= row1 && existingArea.column1 > column1)
                    || existingArea.row1 > row1) {
                components.add(index, component);
                done = true;
            }
            index++;
        }
        if (!done) {
            components.addLast(component);
        }

        childDataMap.put(component, area.childData);


        try {
            super.addComponent(component);
        } catch (IllegalArgumentException e) {
            childDataMap.remove(component);
            components.remove(component);
            throw e;
        }



        if (cursorX >= column1 && cursorX <= column2 && cursorY >= row1
                && cursorY <= row2) {

            cursorX = column2 + 1; 
            if (cursorX >= getColumns()) {

                cursorX = 0; 

                cursorY = (column1 == 0 ? row2 : row1) + 1;
            } else {
                cursorY = row1;
            }
        }
    }


    private void checkExistingOverlaps(Area area) throws OverlapsException {
        for (Entry<Connector, ChildComponentData> entry : getState().childData
                .entrySet()) {
            if (componentsOverlap(entry.getValue(), area.childData)) {

                throw new OverlapsException(new Area(entry.getValue(),
                        (Component) entry.getKey()));
            }
        }
    }


    public void addComponent(Component component, int column, int row)
            throws OverlapsException, OutOfBoundsException {
        this.addComponent(component, column, row, column, row);
    }


    public void newLine() {
        cursorX = 0;
        cursorY++;
    }


    public void space() {
        cursorX++;
        if (cursorX >= getColumns()) {
            cursorX = 0;
            cursorY++;
        }
    }


    @Override
    public void addComponent(Component component) {
        if (component == null) {
            throw new IllegalArgumentException("Component must not be null");
        }


        Area area;
        boolean done = false;
        while (!done) {
            try {
                area = new Area(component, cursorX, cursorY, cursorX, cursorY);
                checkExistingOverlaps(area);
                done = true;
            } catch (final OverlapsException e) {
                space();
            }
        }


        if (cursorX >= getColumns()) {
            setColumns(cursorX + 1);
        }
        if (cursorY >= getRows()) {
            setRows(cursorY + 1);
        }

        addComponent(component, cursorX, cursorY);
    }


    @Override
    public void removeComponent(Component component) {


        if (component == null || !components.contains(component)) {
            return;
        }

        getState().childData.remove(component);
        components.remove(component);
        super.removeComponent(component);
    }


    public void removeComponent(int column, int row) {


        for (final Iterator<Component> i = components.iterator(); i.hasNext();) {
            final Component component = i.next();
            final ChildComponentData childData = getState().childData
                    .get(component);
            if (childData.column1 == column && childData.row1 == row) {
                removeComponent(component);
                return;
            }
        }
    }


    @Override
    public Iterator<Component> iterator() {
        return Collections.unmodifiableCollection(components).iterator();
    }


    @Override
    public int getComponentCount() {
        return components.size();
    }

    @Override
    public void changeVariables(Object source, Map<String, Object> variables) {

    }


    @Override
    public void paintContent(PaintTarget target) throws PaintException {
        final Integer[] columnExpandRatioArray = new Integer[getColumns()];
        final Integer[] rowExpandRatioArray = new Integer[getRows()];

        int realColExpandRatioSum = 0;
        float colSum = getExpandRatioSum(columnExpandRatio);
        if (colSum == 0) {


            float equalSize = 1 / (float) getColumns();
            int myRatio = Math.round(equalSize * 1000);
            for (int i = 0; i < getColumns(); i++) {
                columnExpandRatioArray[i] = myRatio;
            }
            realColExpandRatioSum = myRatio * getColumns();
        } else {
            for (int i = 0; i < getColumns(); i++) {
                int myRatio = Math
                        .round((getColumnExpandRatio(i) / colSum) * 1000);
                columnExpandRatioArray[i] = myRatio;
                realColExpandRatioSum += myRatio;
            }
        }

        int realRowExpandRatioSum = 0;
        float rowSum = getExpandRatioSum(rowExpandRatio);
        if (rowSum == 0) {

            float equalSize = 1 / (float) getRows();
            int myRatio = Math.round(equalSize * 1000);
            for (int i = 0; i < getRows(); i++) {
                rowExpandRatioArray[i] = myRatio;
            }
            realRowExpandRatioSum = myRatio * getRows();
        } else {
            for (int cury = 0; cury < getRows(); cury++) {
                int myRatio = Math
                        .round((getRowExpandRatio(cury) / rowSum) * 1000);
                rowExpandRatioArray[cury] = myRatio;
                realRowExpandRatioSum += myRatio;
            }
        }


        if (rowExpandRatioArray.length > 0) {
            rowExpandRatioArray[0] -= realRowExpandRatioSum - 1000;
        }
        if (columnExpandRatioArray.length > 0) {
            columnExpandRatioArray[0] -= realColExpandRatioSum - 1000;
        }
        target.addAttribute("colExpand", columnExpandRatioArray);
        target.addAttribute("rowExpand", rowExpandRatioArray);

    }

    private float getExpandRatioSum(Map<Integer, Float> ratioMap) {
        float sum = 0;
        for (Iterator<Entry<Integer, Float>> iterator = ratioMap.entrySet()
                .iterator(); iterator.hasNext();) {
            sum += iterator.next().getValue();
        }
        return sum;
    }


    @Override
    public Alignment getComponentAlignment(Component childComponent) {
        ChildComponentData childComponentData = getState(false).childData
                .get(childComponent);
        if (childComponentData == null) {
            throw new IllegalArgumentException(
                    "The given component is not a child of this layout");
        } else {
            return new Alignment(childComponentData.alignment);
        }
    }


    public class Area implements Serializable {
        private final ChildComponentData childData;
        private final Component component;


        public Area(Component component, int column1, int row1, int column2,
                int row2) {
            this.component = component;
            childData = new ChildComponentData();
            childData.alignment = getDefaultComponentAlignment().getBitMask();
            childData.column1 = column1;
            childData.row1 = row1;
            childData.column2 = column2;
            childData.row2 = row2;
        }

        public Area(ChildComponentData childData, Component component) {
            this.childData = childData;
            this.component = component;
        }


        public boolean overlaps(Area other) {
            return componentsOverlap(childData, other.childData);
        }


        public Component getComponent() {
            return component;
        }


        public int getColumn1() {
            return childData.column1;
        }


        public int getColumn2() {
            return childData.column2;
        }


        public int getRow1() {
            return childData.row1;
        }


        public int getRow2() {
            return childData.row2;
        }

    }

    private static boolean componentsOverlap(ChildComponentData a,
            ChildComponentData b) {
        return a.column1 <= b.column2 && a.row1 <= b.row2
                && a.column2 >= b.column1 && a.row2 >= b.row1;
    }


    public class OverlapsException extends java.lang.RuntimeException {

        private final Area existingArea;


        public OverlapsException(Area existingArea) {
            this.existingArea = existingArea;
        }

        @Override
        public String getMessage() {
            StringBuilder sb = new StringBuilder();
            Component component = existingArea.getComponent();
            sb.append(component);
            sb.append("( type = ");
            sb.append(component.getClass().getName());
            if (component.getCaption() != null) {
                sb.append(", caption = \"");
                sb.append(component.getCaption());
                sb.append("\"");
            }
            sb.append(")");
            sb.append(" is already added to ");
            sb.append(existingArea.childData.column1);
            sb.append(",");
            sb.append(existingArea.childData.column1);
            sb.append(",");
            sb.append(existingArea.childData.row1);
            sb.append(",");
            sb.append(existingArea.childData.row2);
            sb.append("(column1, column2, row1, row2).");

            return sb.toString();
        }


        public Area getArea() {
            return existingArea;
        }
    }


    public class OutOfBoundsException extends java.lang.RuntimeException {

        private final Area areaOutOfBounds;


        public OutOfBoundsException(Area areaOutOfBounds) {
            this.areaOutOfBounds = areaOutOfBounds;
        }


        public Area getArea() {
            return areaOutOfBounds;
        }
    }


    public void setColumns(int columns) {


        if (columns < 1) {
            throw new IllegalArgumentException(
                    "The number of columns and rows in the grid must be at least 1");
        }


        if (getColumns() == columns) {
            return;
        }


        if (getColumns() > columns) {
            for (Entry<Connector, ChildComponentData> entry : getState().childData
                    .entrySet()) {
                if (entry.getValue().column2 >= columns) {
                    throw new OutOfBoundsException(new Area(entry.getValue(),
                            (Component) entry.getKey()));
                }
            }
        }


        if (columns < getColumns()) {
            for (int i = columns - 1; i < getColumns(); i++) {
                columnExpandRatio.remove(i);
                getState().explicitColRatios.remove(i);
            }
        }

        getState().columns = columns;
    }


    public int getColumns() {
        return getState(false).columns;
    }


    public void setRows(int rows) {


        if (rows < 1) {
            throw new IllegalArgumentException(
                    "The number of columns and rows in the grid must be at least 1");
        }


        if (getRows() == rows) {
            return;
        }


        if (getRows() > rows) {
            for (Entry<Connector, ChildComponentData> entry : getState().childData
                    .entrySet()) {
                if (entry.getValue().row2 >= rows) {
                    throw new OutOfBoundsException(new Area(entry.getValue(),
                            (Component) entry.getKey()));
                }
            }
        }

        if (rows < getRows()) {
            for (int i = rows - 1; i < getRows(); i++) {
                rowExpandRatio.remove(i);
                getState().explicitRowRatios.remove(i);
            }
        }

        getState().rows = rows;
    }


    public int getRows() {
        return getState(false).rows;
    }


    public int getCursorX() {
        return cursorX;
    }


    public void setCursorX(int cursorX) {
        this.cursorX = cursorX;
    }


    public int getCursorY() {
        return cursorY;
    }


    public void setCursorY(int cursorY) {
        this.cursorY = cursorY;
    }


    @Override
    public void replaceComponent(Component oldComponent, Component newComponent) {


        ChildComponentData oldLocation = getState().childData.get(oldComponent);
        ChildComponentData newLocation = getState().childData.get(newComponent);

        if (oldLocation == null) {
            addComponent(newComponent);
        } else if (newLocation == null) {
            removeComponent(oldComponent);
            addComponent(newComponent, oldLocation.column1, oldLocation.row1,
                    oldLocation.column2, oldLocation.row2);
        } else {
            int oldAlignment = oldLocation.alignment;
            oldLocation.alignment = newLocation.alignment;
            newLocation.alignment = oldAlignment;

            getState().childData.put(newComponent, oldLocation);
            getState().childData.put(oldComponent, newLocation);
        }
    }


    @Override
    public void removeAllComponents() {
        super.removeAllComponents();
        cursorX = 0;
        cursorY = 0;
    }

    @Override
    public void setComponentAlignment(Component childComponent,
            Alignment alignment) {
        ChildComponentData childComponentData = getState().childData
                .get(childComponent);
        if (childComponentData == null) {
            throw new IllegalArgumentException(
                    "Component must be added to layout before using setComponentAlignment()");
        } else {
            if (alignment == null) {
                childComponentData.alignment = GridLayoutState.ALIGNMENT_DEFAULT
                        .getBitMask();
            } else {
                childComponentData.alignment = alignment.getBitMask();
            }
        }
    }


    @Override
    public void setSpacing(boolean spacing) {
        getState().spacing = spacing;
    }


    @Override
    public boolean isSpacing() {
        return getState(false).spacing;
    }


    public void insertRow(int row) {
        if (row > getRows()) {
            throw new IllegalArgumentException("Cannot insert row at " + row
                    + " in a gridlayout with height " + getRows());
        }

        for (ChildComponentData existingArea : getState().childData.values()) {

            if (existingArea.row2 >= row) {
                existingArea.row2++;


                if (existingArea.row1 >= row) {
                    existingArea.row1++;
                }

            }
        }

        if (cursorY >= row) {
            cursorY++;
        }

        setRows(getRows() + 1);
        markAsDirty();
    }


    public void removeRow(int row) {
        if (row >= getRows()) {
            throw new IllegalArgumentException("Cannot delete row " + row
                    + " from a gridlayout with height " + getRows());
        }


        for (int col = 0; col < getColumns(); col++) {
            removeComponent(col, row);
        }


        for (ChildComponentData existingArea : getState().childData.values()) {
            if (existingArea.row2 >= row) {
                existingArea.row2--;

                if (existingArea.row1 > row) {
                    existingArea.row1--;
                }
            }
        }

        if (getRows() == 1) {

            cursorX = 0;
            cursorY = 0;
        } else {
            setRows(getRows() - 1);
            if (cursorY > row) {
                cursorY--;
            }
        }

        markAsDirty();

    }


    public void setColumnExpandRatio(int columnIndex, float ratio) {
        columnExpandRatio.put(columnIndex, ratio);
        getState().explicitColRatios.add(columnIndex);
        markAsDirty();
    }


    public float getColumnExpandRatio(int columnIndex) {
        Float r = columnExpandRatio.get(columnIndex);
        return r == null ? 0 : r.floatValue();
    }


    public void setRowExpandRatio(int rowIndex, float ratio) {
        rowExpandRatio.put(rowIndex, ratio);
        getState().explicitRowRatios.add(rowIndex);
        markAsDirty();
    }


    public float getRowExpandRatio(int rowIndex) {
        Float r = rowExpandRatio.get(rowIndex);
        return r == null ? 0 : r.floatValue();
    }


    public Component getComponent(int x, int y) {
        for (Entry<Connector, ChildComponentData> entry : getState(false).childData
                .entrySet()) {
            ChildComponentData childData = entry.getValue();
            if (childData.column1 <= x && x <= childData.column2
                    && childData.row1 <= y && y <= childData.row2) {
                return (Component) entry.getKey();
            }
        }
        return null;
    }


    public Area getComponentArea(Component component) {
        ChildComponentData childComponentData = getState(false).childData
                .get(component);
        if (childComponentData == null) {
            return null;
        } else {
            return new Area(childComponentData, component);
        }
    }

    @Override
    public void addLayoutClickListener(LayoutClickListener listener) {
        addListener(EventId.LAYOUT_CLICK_EVENT_IDENTIFIER,
                LayoutClickEvent.class, listener,
                LayoutClickListener.clickMethod);
    }


    @Override
    @Deprecated
    public void addListener(LayoutClickListener listener) {
        addLayoutClickListener(listener);
    }

    @Override
    public void removeLayoutClickListener(LayoutClickListener listener) {
        removeListener(EventId.LAYOUT_CLICK_EVENT_IDENTIFIER,
                LayoutClickEvent.class, listener);
    }


    @Override
    @Deprecated
    public void removeListener(LayoutClickListener listener) {
        removeLayoutClickListener(listener);
    }


    @Override
    public void setMargin(boolean enabled) {
        setMargin(new MarginInfo(enabled));
    }


    @Override
    public void setMargin(MarginInfo marginInfo) {
        getState().marginsBitmask = marginInfo.getBitMask();
    }


    @Override
    public MarginInfo getMargin() {
        return new MarginInfo(getState(false).marginsBitmask);
    }


    @Override
    public Alignment getDefaultComponentAlignment() {
        return defaultComponentAlignment;
    }


    @Override
    public void setDefaultComponentAlignment(Alignment defaultAlignment) {
        defaultComponentAlignment = defaultAlignment;
    }


    public void setHideEmptyRowsAndColumns(boolean hideEmptyRowsAndColumns) {
        getState().hideEmptyRowsAndColumns = hideEmptyRowsAndColumns;
    }


    public boolean isHideEmptyRowsAndColumns() {
        return getState(false).hideEmptyRowsAndColumns;
    }


    @Override
    public void readDesign(Element design, DesignContext designContext) {
        super.readDesign(design, designContext);


        Elements rowElements = design.getElementsByTag("row");
        List<Map<Integer, Component>> rows = new ArrayList<Map<Integer, Component>>();
        for (int i = 0; i < rowElements.size(); ++i) {
            rows.add(new HashMap<Integer, Component>());
        }
        setRows(Math.max(rows.size(), 1));

        List<Integer> columnExpandRatios = new ArrayList<Integer>();
        for (int row = 0; row < rowElements.size(); ++row) {
            Element rowElement = rowElements.get(row);


            if (rowElement.hasAttr("expand")) {
                int expand = DesignAttributeHandler.readAttribute("expand",
                        rowElement.attributes(), int.class);
                setRowExpandRatio(row, expand);
            }

            Elements cols = rowElement.children();


            int skippedColumns = 0;

            for (int column = 0; column < cols.size(); ++column) {
                while (rows.get(row).containsKey(column + skippedColumns)) {

                    skippedColumns++;
                }

                Element col = cols.get(column);
                Component child = null;

                if (col.children().size() > 0) {
                    child = designContext.readDesign(col.child(0));


                } 


                Attributes attr = col.attributes();
                int colspan = DesignAttributeHandler.readAttribute("colspan",
                        attr, 1, int.class);
                int rowspan = DesignAttributeHandler.readAttribute("rowspan",
                        attr, 1, int.class);

                for (int rowIndex = row; rowIndex < row + rowspan; ++rowIndex) {
                    for (int colIndex = column; colIndex < column + colspan; ++colIndex) {
                        if (rowIndex == rows.size()) {

                            rows.add(new HashMap<Integer, Component>());
                        }
                        rows.get(rowIndex)
                                .put(colIndex + skippedColumns, child);
                    }
                }


                if (row == 0) {
                    if (col.hasAttr("expand")) {
                        for (String expand : col.attr("expand").split(",")) {
                            columnExpandRatios.add(Integer.parseInt(expand));
                        }
                    } else {
                        for (int c = 0; c < colspan; ++c) {
                            columnExpandRatios.add(0);
                        }
                    }
                }

                skippedColumns += (colspan - 1);
            }
        }


        int colMax = 0;
        for (Map<Integer, Component> cols : rows) {
            if (colMax < cols.size()) {
                colMax = cols.size();
            }
        }
        setColumns(Math.max(colMax, 1));

        for (int i = 0; i < columnExpandRatios.size(); ++i) {
            setColumnExpandRatio(i, columnExpandRatios.get(i));
        }


        Set<Component> visited = new HashSet<Component>();


        visited.add(null);

        for (int i = 0; i < rows.size(); ++i) {
            Map<Integer, Component> row = rows.get(i);
            for (int j = 0; j < colMax; ++j) {
                Component child = row.get(j);
                if (visited.contains(child)) {

                    continue;
                }
                visited.add(child);


                int colspan = 0;
                while (j + colspan + 1 < row.size()
                        && row.get(j + colspan + 1) == child) {
                    ++colspan;
                }

                int rowspan = 0;
                while (i + rowspan + 1 < rows.size()
                        && rows.get(i + rowspan + 1).get(j) == child) {
                    ++rowspan;
                }


                addComponent(child, j, i, j + colspan, i + rowspan);
            }
        }

        setCursorY(getRows());
        setCursorX(0);
    }

    @Override
    public void writeDesign(Element design, DesignContext designContext) {
        super.writeDesign(design, designContext);

        GridLayout def = designContext.getDefaultInstance(this);
        if (components.isEmpty()
                || !designContext.shouldWriteChildren(this, def)) {
            return;
        }

        final Map<Connector, ChildComponentData> childData = getState().childData;


        Component[][] componentMap = new Component[getState().rows][getState().columns];
        final Component dummyComponent = new Label("");

        for (Component component : components) {
            ChildComponentData coords = childData.get(component);
            for (int row = coords.row1; row <= coords.row2; ++row) {
                for (int col = coords.column1; col <= coords.column2; ++col) {
                    componentMap[row][col] = component;
                }
            }
        }


        Set<Connector> visited = new HashSet<Connector>();


        visited.add(dummyComponent);

        for (int i = 0; i < componentMap.length; ++i) {
            Element row = design.appendElement("row");


            DesignAttributeHandler.writeAttribute("expand", row.attributes(),
                    (int) getRowExpandRatio(i), 0, int.class);

            int colspan = 1;
            Element col;
            for (int j = 0; j < componentMap[i].length; ++j) {
                Component child = componentMap[i][j];
                if (child != null) {
                    if (visited.contains(child)) {

                        continue;
                    }
                    visited.add(child);

                    Element childElement = designContext.createElement(child);
                    col = row.appendElement("column");


                    ChildComponentData coords = childData.get(child);

                    Alignment alignment = getComponentAlignment(child);
                    if (alignment.isMiddle()) {
                        childElement.attr(":middle", "");
                    } else if (alignment.isBottom()) {
                        childElement.attr(":bottom", "");
                    }
                    if (alignment.isCenter()) {
                        childElement.attr(":center", "");
                    } else if (alignment.isRight()) {
                        childElement.attr(":right", "");
                    }

                    col.appendChild(childElement);
                    if (coords.row1 != coords.row2) {
                        col.attr("rowspan", ""
                                + (1 + coords.row2 - coords.row1));
                    }

                    colspan = 1 + coords.column2 - coords.column1;
                    if (colspan > 1) {
                        col.attr("colspan", "" + colspan);
                    }

                } else {
                    boolean hasExpands = false;
                    if (i == 0
                            && lastComponentOnRow(componentMap[i], j, visited)) {


                        for (int c = j; c < componentMap[i].length; ++c) {
                            if ((int) getColumnExpandRatio(c) > 0) {
                                hasExpands = true;
                            }
                        }
                    }

                    if (lastComponentOnRow(componentMap[i], j, visited)
                            && !hasExpands) {
                        continue;
                    }


                    col = row.appendElement("column");


                    while (j + colspan < componentMap[i].length
                            && componentMap[i][j + colspan] == child) {
                        ++colspan;
                    }

                    int rowspan = getRowSpan(componentMap, i, j, colspan, child);
                    if (colspan > 1) {
                        col.attr("colspan", "" + colspan);
                    }
                    if (rowspan > 1) {
                        col.attr("rowspan", "" + rowspan);
                    }
                    for (int x = 0; x < rowspan; ++x) {
                        for (int y = 0; y < colspan; ++y) {

                            componentMap[i + x][j + y] = dummyComponent;
                        }
                    }
                }


                if (i == 0) {

                    String expands = "";
                    boolean expandRatios = false;
                    for (int c = 0; c < colspan; ++c) {
                        int colExpand = (int) getColumnExpandRatio(j + c);
                        if (colExpand > 0) {
                            expandRatios = true;
                        }
                        expands += (c > 0 ? "," : "") + colExpand;
                    }
                    if (expandRatios) {
                        col.attr("expand", expands);
                    }
                }

                j += colspan - 1;
            }
        }
    }

    private int getRowSpan(Component[][] compMap, int i, int j, int colspan,
            Component child) {
        int rowspan = 1;
        while (i + rowspan < compMap.length && compMap[i + rowspan][j] == child) {
            for (int k = 0; k < colspan; ++k) {
                if (compMap[i + rowspan][j + k] != child) {
                    return rowspan;
                }
            }
            rowspan++;
        }
        return rowspan;
    }

    private boolean lastComponentOnRow(Component[] componentArray, int j,
            Set<Connector> visited) {
        while ((++j) < componentArray.length) {
            Component child = componentArray[j];
            if (child != null && !visited.contains(child)) {
                return false;
            }
        }
        return true;
    }

    @Override
    protected Collection<String> getCustomAttributes() {
        Collection<String> result = super.getCustomAttributes();
        result.add("cursor-x");
        result.add("cursor-y");
        result.add("rows");
        result.add("columns");
        return result;
    }
}
<code block>

package com.vaadin.ui;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

import com.vaadin.server.Sizeable.Unit;

public class GridLayoutExpandRatioTest {

    private GridLayout gridLayout;

    @Test
    public void testColExpandRatioIsForgotten() {
        gridLayout = new GridLayout(4, 1);
        gridLayout.setWidth(100, Unit.PERCENTAGE);
        gridLayout.setSizeFull();
        gridLayout.setSpacing(true);

        addComponents(true);

        gridLayout.setColumnExpandRatio(1, 1);
        gridLayout.setColumnExpandRatio(3, 1);

        assertTrue(gridLayout.getColumnExpandRatio(0) == 0);
        assertTrue(gridLayout.getColumnExpandRatio(1) == 1);
        assertTrue(gridLayout.getColumnExpandRatio(2) == 0);
        assertTrue(gridLayout.getColumnExpandRatio(3) == 1);
        assertFalse(gridLayout.getState().explicitColRatios.contains(0));
        assertTrue(gridLayout.getState().explicitColRatios.contains(1));
        assertFalse(gridLayout.getState().explicitColRatios.contains(2));
        assertTrue(gridLayout.getState().explicitColRatios.contains(3));

        gridLayout.removeAllComponents();
        gridLayout.setColumns(3);
        addComponents(false);

        assertTrue(gridLayout.getColumnExpandRatio(0) == 0);
        assertTrue(gridLayout.getColumnExpandRatio(1) == 1);
        assertTrue(gridLayout.getColumnExpandRatio(2) == 0);
        assertTrue(gridLayout.getColumnExpandRatio(3) == 0);
        assertFalse(gridLayout.getState().explicitColRatios.contains(0));
        assertTrue(gridLayout.getState().explicitColRatios.contains(1));
        assertFalse(gridLayout.getState().explicitColRatios.contains(2));
        assertFalse(gridLayout.getState().explicitColRatios.contains(3));
    }

    @Test
    public void testRowExpandRatioIsForgotten() {
        gridLayout = new GridLayout(1, 4);
        gridLayout.setWidth(100, Unit.PERCENTAGE);
        gridLayout.setSizeFull();
        gridLayout.setSpacing(true);

        addComponents(true);

        gridLayout.setRowExpandRatio(1, 1);
        gridLayout.setRowExpandRatio(3, 1);

        assertTrue(gridLayout.getRowExpandRatio(0) == 0);
        assertTrue(gridLayout.getRowExpandRatio(1) == 1);
        assertTrue(gridLayout.getRowExpandRatio(2) == 0);
        assertTrue(gridLayout.getRowExpandRatio(3) == 1);
        assertFalse(gridLayout.getState().explicitRowRatios.contains(0));
        assertTrue(gridLayout.getState().explicitRowRatios.contains(1));
        assertFalse(gridLayout.getState().explicitRowRatios.contains(2));
        assertTrue(gridLayout.getState().explicitRowRatios.contains(3));

        gridLayout.removeAllComponents();
        gridLayout.setRows(3);
        addComponents(false);

        assertTrue(gridLayout.getRowExpandRatio(0) == 0);
        assertTrue(gridLayout.getRowExpandRatio(1) == 1);
        assertTrue(gridLayout.getRowExpandRatio(2) == 0);
        assertTrue(gridLayout.getRowExpandRatio(3) == 0);
        assertFalse(gridLayout.getState().explicitRowRatios.contains(0));
        assertTrue(gridLayout.getState().explicitRowRatios.contains(1));
        assertFalse(gridLayout.getState().explicitRowRatios.contains(2));
        assertFalse(gridLayout.getState().explicitRowRatios.contains(3));
    }

    private void addComponents(boolean includeLastOne) {
        gridLayout.addComponent(label("{1}"));
        gridLayout.addComponent(label("{2}"));
        gridLayout.addComponent(label("{3}"));
        if (includeLastOne) {
            gridLayout.addComponent(label("{4}"));
        }
    }

    private Label label(String content) {
        Label label = new Label(content);
        label.setSizeUndefined();
        return label;
    }
}

<code block>

package com.vaadin.tests.components.grid;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;
import org.openqa.selenium.Keys;
import org.openqa.selenium.interactions.Actions;

import com.vaadin.testbench.elements.GridElement;
import com.vaadin.testbench.elements.GridElement.GridCellElement;
import com.vaadin.testbench.elements.NotificationElement;
import com.vaadin.testbench.elements.PasswordFieldElement;
import com.vaadin.testbench.parallel.TestCategory;
import com.vaadin.tests.tb3.MultiBrowserTest;

@TestCategory("grid")
public class GridEditorUITest extends MultiBrowserTest {

    @Test
    public void testEditor() {
        setDebug(true);
        openTestURL();

        assertFalse("Sanity check",
                isElementPresent(PasswordFieldElement.class));

        openEditor(5);
        new Actions(getDriver()).sendKeys(Keys.ESCAPE).perform();

        openEditor(10);

        assertTrue("Edtor should be opened with a password field",
                isElementPresent(PasswordFieldElement.class));

        assertFalse("Notification was present",
                isElementPresent(NotificationElement.class));
    }

    private void openEditor(int rowIndex) {
        GridElement grid = $(GridElement.class).first();

        GridCellElement cell = grid.getCell(rowIndex, 1);

        new Actions(driver).moveToElement(cell).doubleClick().build().perform();
    }

}

<code block>

package com.vaadin.tests.components.grid;

import com.vaadin.server.VaadinRequest;
import com.vaadin.tests.components.AbstractTestUI;
import com.vaadin.tests.util.PersonContainer;
import com.vaadin.ui.Grid;
import com.vaadin.ui.PasswordField;
import com.vaadin.ui.TextField;

public class GridEditorUI extends AbstractTestUI {

    @Override
    protected void setup(VaadinRequest request) {
        PersonContainer container = PersonContainer.createWithTestData();

        Grid grid = new Grid(container);


        grid.removeColumn("address");

        grid.setEditorEnabled(true);

        grid.getColumn("firstName").setEditorField(new PasswordField());

        TextField lastNameField = (TextField) grid.getColumn("lastName")
                .getEditorField();
        lastNameField.setMaxLength(50);

        grid.getColumn("phoneNumber").getEditorField().setReadOnly(true);

        addComponent(grid);
    }

}

<code block>

package com.vaadin.tests.components.grid.basicfeatures.client;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import java.util.List;

import org.junit.Before;
import org.junit.Test;
import org.openqa.selenium.By;
import org.openqa.selenium.Keys;
import org.openqa.selenium.NoSuchElementException;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.interactions.Actions;

import com.vaadin.shared.ui.grid.GridConstants;
import com.vaadin.testbench.elements.GridElement.GridCellElement;
import com.vaadin.testbench.elements.GridElement.GridEditorElement;
import com.vaadin.testbench.parallel.BrowserUtil;
import com.vaadin.tests.components.grid.basicfeatures.GridBasicClientFeaturesTest;
import com.vaadin.tests.components.grid.basicfeatures.GridBasicFeatures;

public class GridEditorClientTest extends GridBasicClientFeaturesTest {

    private static final String[] EDIT_ROW_100 = new String[] { "Component",
            "Editor", "Edit row 100" };
    private static final String[] EDIT_ROW_5 = new String[] { "Component",
            "Editor", "Edit row 5" };

    @Before
    public void setUp() {
        openTestURL();
        selectMenuPath("Component", "Editor", "Enabled");
    }

    @Test
    public void testProgrammaticOpeningClosing() {
        selectMenuPath(EDIT_ROW_5);
        assertNotNull(getEditor());

        selectMenuPath("Component", "Editor", "Cancel edit");
        assertNull(getEditor());
        assertEquals("Row 5 edit cancelled",
                findElement(By.className("grid-editor-log")).getText());
    }

    @Test
    public void testProgrammaticOpeningWithScroll() {
        selectMenuPath(EDIT_ROW_100);
        assertNotNull(getEditor());
    }

    @Test(expected = NoSuchElementException.class)
    public void testVerticalScrollLocking() {
        selectMenuPath(EDIT_ROW_5);
        getGridElement().getCell(200, 0);
    }

    @Test
    public void testMouseOpeningClosing() {

        getGridElement().getCell(4, 0).doubleClick();
        assertNotNull(getEditor());

        getCancelButton().click();
        assertNull(getEditor());


        selectMenuPath("Component", "Editor", "Enabled");

        getGridElement().getCell(4, 0).doubleClick();
        assertNull(getEditor());
    }

    @Test
    public void testKeyboardOpeningClosing() {

        getGridElement().getCell(4, 0).click();

        new Actions(getDriver()).sendKeys(Keys.ENTER).perform();

        assertNotNull(getEditor());

        new Actions(getDriver()).sendKeys(Keys.ESCAPE).perform();
        assertNull(getEditor());
        assertEquals("Row 4 edit cancelled",
                findElement(By.className("grid-editor-log")).getText());


        selectMenuPath("Component", "Editor", "Enabled");

        getGridElement().getCell(5, 0).click();
        new Actions(getDriver()).sendKeys(Keys.ENTER).perform();
        assertNull(getEditor());
    }

    @Test
    public void testWidgetBinding() throws Exception {
        selectMenuPath(EDIT_ROW_100);
        WebElement editor = getEditor();

        List<WebElement> widgets = editor.findElements(By
                .className("gwt-TextBox"));

        assertEquals(GridBasicFeatures.EDITABLE_COLUMNS, widgets.size());

        assertEquals("(100, 0)", widgets.get(0).getAttribute("value"));
        assertEquals("(100, 1)", widgets.get(1).getAttribute("value"));
        assertEquals("(100, 2)", widgets.get(2).getAttribute("value"));

        assertEquals("100", widgets.get(6).getAttribute("value"));
        assertEquals("<b>100</b>", widgets.get(8).getAttribute("value"));
    }

    @Test
    public void testWithSelectionColumn() throws Exception {
        selectMenuPath("Component", "State", "Selection mode", "multi");
        selectMenuPath(EDIT_ROW_5);

        WebElement editorCells = findElement(By
                .className("v-grid-editor-cells"));
        List<WebElement> selectorDivs = editorCells.findElements(By
                .cssSelector("div"));

        assertTrue("selector column cell should've been empty", selectorDivs
                .get(0).getAttribute("innerHTML").isEmpty());
        assertFalse("normal column cell shoul've had contents", selectorDivs
                .get(1).getAttribute("innerHTML").isEmpty());
    }

    @Test
    public void testSave() {
        selectMenuPath(EDIT_ROW_100);

        WebElement textField = getEditor().findElements(
                By.className("gwt-TextBox")).get(0);

        textField.clear();
        textField.sendKeys("Changed");

        WebElement saveButton = getEditor().findElement(
                By.className("v-grid-editor-save"));

        saveButton.click();

        assertEquals("Changed", getGridElement().getCell(100, 0).getText());
    }

    @Test
    public void testProgrammaticSave() {
        selectMenuPath(EDIT_ROW_100);

        WebElement textField = getEditor().findElements(
                By.className("gwt-TextBox")).get(0);

        textField.clear();
        textField.sendKeys("Changed");

        selectMenuPath("Component", "Editor", "Save");

        assertEquals("Changed", getGridElement().getCell(100, 0).getText());
    }

    @Test
    public void testCaptionChange() {
        selectMenuPath(EDIT_ROW_5);
        assertEquals("Save button caption should've been \""
                + GridConstants.DEFAULT_SAVE_CAPTION + "\" to begin with",
                GridConstants.DEFAULT_SAVE_CAPTION, getSaveButton().getText());
        assertEquals("Cancel button caption should've been \""
                + GridConstants.DEFAULT_CANCEL_CAPTION + "\" to begin with",
                GridConstants.DEFAULT_CANCEL_CAPTION, getCancelButton()
                        .getText());

        selectMenuPath("Component", "Editor", "Change Save Caption");
        assertNotEquals(
                "Save button caption should've changed while editor is open",
                GridConstants.DEFAULT_SAVE_CAPTION, getSaveButton().getText());

        getCancelButton().click();

        selectMenuPath("Component", "Editor", "Change Cancel Caption");
        selectMenuPath(EDIT_ROW_5);
        assertNotEquals(
                "Cancel button caption should've changed while editor is closed",
                GridConstants.DEFAULT_CANCEL_CAPTION, getCancelButton()
                        .getText());
    }

    @Test
    public void testUneditableColumn() {
        selectMenuPath("Component", "Editor", "Edit row 5");

        assertFalse("Uneditable column should not have an editor widget",
                getGridElement().getEditor().isEditable(3));
    }

    @Test
    public void testErrorField() {
        selectMenuPath(EDIT_ROW_5);

        GridEditorElement editor = getGridElement().getEditor();

        assertTrue("No errors should be present",
                editor.findElements(By.className("error")).isEmpty());
        assertEquals("No error message should be present", null,
                editor.getErrorMessage());

        selectMenuPath("Component", "Editor", "Toggle second editor error");
        getSaveButton().click();

        assertEquals("Unexpected amount of error fields", 1, editor
                .findElements(By.className("error")).size());
        assertEquals(
                "Unexpedted error message",
                "Syntethic fail of editor in column 2. "
                        + "This message is so long that it doesn't fit into its box",
                editor.getErrorMessage());
    }

    @Test
    public void testFocusOnMouseOpen() {

        GridCellElement cell = getGridElement().getCell(4, 2);

        cell.doubleClick();

        WebElement focused = getFocusedElement();

        assertEquals("", "input", focused.getTagName());
        assertEquals("", cell.getText(), focused.getAttribute("value"));
    }

    @Test
    public void testFocusOnKeyboardOpen() {

        GridCellElement cell = getGridElement().getCell(4, 2);

        cell.click();
        new Actions(getDriver()).sendKeys(Keys.ENTER).perform();

        WebElement focused = getFocusedElement();

        assertEquals("", "input", focused.getTagName());
        assertEquals("", cell.getText(), focused.getAttribute("value"));
    }

    @Test
    public void testNoFocusOnProgrammaticOpen() {

        selectMenuPath(EDIT_ROW_5);

        WebElement focused = getFocusedElement();

        if (BrowserUtil.isIE8(getDesiredCapabilities())) {
            assertEquals("Focus should be in html", "html",
                    focused.getTagName());
        } else if (BrowserUtil.isIE(getDesiredCapabilities())) {
            assertEquals("Focus should be nowhere", null, focused);
        } else {

            assertEquals("Focus should be in body", "body",
                    focused.getTagName());
        }
    }

    protected WebElement getSaveButton() {
        return getEditor().findElement(By.className("v-grid-editor-save"));
    }

    protected WebElement getCancelButton() {
        return getEditor().findElement(By.className("v-grid-editor-cancel"));
    }
}

<code block>

package com.vaadin.tests.components.grid.basicfeatures.server;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import java.util.List;

import org.junit.Before;
import org.junit.Test;
import org.openqa.selenium.By;
import org.openqa.selenium.Keys;
import org.openqa.selenium.NoSuchElementException;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.interactions.Actions;

import com.vaadin.shared.ui.grid.GridConstants;
import com.vaadin.testbench.elements.GridElement.GridCellElement;
import com.vaadin.testbench.elements.GridElement.GridEditorElement;
import com.vaadin.testbench.elements.NotificationElement;
import com.vaadin.tests.components.grid.basicfeatures.GridBasicFeatures;
import com.vaadin.tests.components.grid.basicfeatures.GridBasicFeaturesTest;

public class GridEditorTest extends GridBasicFeaturesTest {

    private static final String[] EDIT_ITEM_5 = new String[] { "Component",
            "Editor", "Edit item 5" };
    private static final String[] EDIT_ITEM_100 = new String[] { "Component",
            "Editor", "Edit item 100" };
    private static final String[] TOGGLE_EDIT_ENABLED = new String[] {
            "Component", "Editor", "Enabled" };

    @Before
    public void setUp() {
        setDebug(true);
        openTestURL();
        selectMenuPath(TOGGLE_EDIT_ENABLED);
    }

    @Test
    public void testProgrammaticOpeningClosing() {
        selectMenuPath(EDIT_ITEM_5);
        assertEditorOpen();

        selectMenuPath("Component", "Editor", "Cancel edit");
        assertEditorClosed();
    }

    @Test
    public void testProgrammaticOpeningWhenDisabled() {
        selectMenuPath(TOGGLE_EDIT_ENABLED);
        selectMenuPath(EDIT_ITEM_5);
        assertEditorClosed();
        boolean thrown = logContainsText("Exception occured, java.lang.IllegalStateException");
        assertTrue("IllegalStateException thrown", thrown);
    }

    @Test
    public void testDisablingWhileOpen() {
        selectMenuPath(EDIT_ITEM_5);
        selectMenuPath(TOGGLE_EDIT_ENABLED);
        assertEditorOpen();
        boolean thrown = logContainsText("Exception occured, java.lang.IllegalStateException");
        assertTrue("IllegalStateException thrown", thrown);
    }

    @Test
    public void testProgrammaticOpeningWithScroll() {
        selectMenuPath(EDIT_ITEM_100);
        assertEditorOpen();
    }

    @Test(expected = NoSuchElementException.class)
    public void testVerticalScrollLocking() {
        selectMenuPath(EDIT_ITEM_5);
        getGridElement().getCell(200, 0);
    }

    @Test
    public void testMouseOpeningClosing() {

        getGridElement().getCell(4, 0).doubleClick();
        assertEditorOpen();

        getCancelButton().click();
        assertEditorClosed();

        selectMenuPath(TOGGLE_EDIT_ENABLED);
        getGridElement().getCell(4, 0).doubleClick();
        assertEditorClosed();
    }

    @Test
    public void testKeyboardOpeningClosing() {

        getGridElement().getCell(4, 0).click();
        assertEditorClosed();

        new Actions(getDriver()).sendKeys(Keys.ENTER).perform();
        assertEditorOpen();

        new Actions(getDriver()).sendKeys(Keys.ESCAPE).perform();
        assertEditorClosed();


        selectMenuPath(TOGGLE_EDIT_ENABLED);
        getGridElement().getCell(5, 0).click();
        new Actions(getDriver()).sendKeys(Keys.ENTER).perform();
        assertEditorClosed();
    }

    @Test
    public void testComponentBinding() {
        selectMenuPath(EDIT_ITEM_100);

        List<WebElement> widgets = getEditorWidgets();
        assertEquals("Number of widgets", GridBasicFeatures.EDITABLE_COLUMNS,
                widgets.size());

        assertEquals("(100, 0)", widgets.get(0).getAttribute("value"));
        assertEquals("(100, 1)", widgets.get(1).getAttribute("value"));
        assertEquals("(100, 2)", widgets.get(2).getAttribute("value"));
        assertEquals("<b>100</b>", widgets.get(8).getAttribute("value"));
    }

    @Test
    public void testSave() {
        selectMenuPath(EDIT_ITEM_100);

        WebElement textField = getEditorWidgets().get(0);

        textField.click();

        textField.sendKeys(" changed");

        WebElement saveButton = getEditor().findElement(
                By.className("v-grid-editor-save"));

        saveButton.click();

        assertEquals("(100, 0) changed", getGridElement().getCell(100, 0)
                .getText());
    }

    @Test
    public void testProgrammaticSave() {
        selectMenuPath(EDIT_ITEM_100);

        WebElement textField = getEditorWidgets().get(0);

        textField.click();

        textField.sendKeys(" changed");

        selectMenuPath("Component", "Editor", "Save");

        assertEquals("(100, 0) changed", getGridElement().getCell(100, 0)
                .getText());
    }

    @Test
    public void testCaptionChange() {
        selectMenuPath(EDIT_ITEM_5);
        assertEquals("Save button caption should've been \""
                + GridConstants.DEFAULT_SAVE_CAPTION + "\" to begin with",
                GridConstants.DEFAULT_SAVE_CAPTION, getSaveButton().getText());
        assertEquals("Cancel button caption should've been \""
                + GridConstants.DEFAULT_CANCEL_CAPTION + "\" to begin with",
                GridConstants.DEFAULT_CANCEL_CAPTION, getCancelButton()
                        .getText());

        selectMenuPath("Component", "Editor", "Change save caption");
        assertNotEquals(
                "Save button caption should've changed while editor is open",
                GridConstants.DEFAULT_SAVE_CAPTION, getSaveButton().getText());

        getCancelButton().click();

        selectMenuPath("Component", "Editor", "Change cancel caption");
        selectMenuPath(EDIT_ITEM_5);
        assertNotEquals(
                "Cancel button caption should've changed while editor is closed",
                GridConstants.DEFAULT_CANCEL_CAPTION, getCancelButton()
                        .getText());
    }

    private void assertEditorOpen() {
        assertNotNull("Editor is supposed to be open", getEditor());
        assertEquals("Unexpected number of widgets",
                GridBasicFeatures.EDITABLE_COLUMNS, getEditorWidgets().size());
    }

    private void assertEditorClosed() {
        assertNull("Editor is supposed to be closed", getEditor());
    }

    private List<WebElement> getEditorWidgets() {
        assertNotNull(getEditor());
        return getEditor().findElements(By.className("v-textfield"));

    }

    @Test
    public void testInvalidEdition() {
        selectMenuPath(EDIT_ITEM_5);
        assertFalse(logContainsText("Exception occured, java.lang.IllegalStateException"));

        GridEditorElement editor = getGridElement().getEditor();

        assertFalse(
                "Field 7 should not have been marked with an error before error",
                editor.isFieldErrorMarked(7));

        WebElement intField = editor.getField(7);
        intField.clear();
        intField.sendKeys("banana phone");
        editor.save();

        assertEquals("Column 7: Could not convert value to Integer",
                editor.getErrorMessage());
        assertTrue("Field 7 should have been marked with an error after error",
                editor.isFieldErrorMarked(7));
        editor.cancel();

        selectMenuPath(EDIT_ITEM_100);
        assertFalse("Exception should not exist",
                isElementPresent(NotificationElement.class));
        assertEquals("There should be no editor error message", null,
                getGridElement().getEditor().getErrorMessage());
    }

    @Test
    public void testNoScrollAfterProgrammaticOpen() {
        int originalScrollPos = getGridVerticalScrollPos();

        selectMenuPath(EDIT_ITEM_5);

        scrollGridVerticallyTo(100);
        assertEquals("Grid shouldn't scroll vertically while editing",
                originalScrollPos, getGridVerticalScrollPos());
    }

    @Test
    public void testNoScrollAfterMouseOpen() {
        int originalScrollPos = getGridVerticalScrollPos();

        GridCellElement cell_5_0 = getGridElement().getCell(5, 0);
        new Actions(getDriver()).doubleClick(cell_5_0).perform();

        scrollGridVerticallyTo(100);
        assertEquals("Grid shouldn't scroll vertically while editing",
                originalScrollPos, getGridVerticalScrollPos());
    }

    @Test
    public void testNoScrollAfterKeyboardOpen() {
        int originalScrollPos = getGridVerticalScrollPos();

        GridCellElement cell_5_0 = getGridElement().getCell(5, 0);
        cell_5_0.click();
        new Actions(getDriver()).sendKeys(Keys.ENTER).perform();

        scrollGridVerticallyTo(100);
        assertEquals("Grid shouldn't scroll vertically while editing",
                originalScrollPos, getGridVerticalScrollPos());
    }

    @Test
    public void testEditorInDisabledGrid() {
        int originalScrollPos = getGridVerticalScrollPos();

        selectMenuPath(EDIT_ITEM_5);
        assertEditorOpen();

        selectMenuPath("Component", "State", "Enabled");
        assertEditorOpen();

        GridEditorElement editor = getGridElement().getEditor();
        editor.save();
        assertEditorOpen();

        editor.cancel();
        assertEditorOpen();

        selectMenuPath("Component", "State", "Enabled");

        scrollGridVerticallyTo(100);
        assertEquals("Grid shouldn't scroll vertically while editing",
                originalScrollPos, getGridVerticalScrollPos());
    }

    @Test
    public void testFocusOnMouseOpen() {

        GridCellElement cell = getGridElement().getCell(4, 2);

        cell.doubleClick();

        WebElement focused = getFocusedElement();

        assertEquals("", "input", focused.getTagName());
        assertEquals("", cell.getText(), focused.getAttribute("value"));
    }

    @Test
    public void testFocusOnKeyboardOpen() {

        GridCellElement cell = getGridElement().getCell(4, 2);

        cell.click();
        new Actions(getDriver()).sendKeys(Keys.ENTER).perform();

        WebElement focused = getFocusedElement();

        assertEquals("", "input", focused.getTagName());
        assertEquals("", cell.getText(), focused.getAttribute("value"));
    }

    @Test
    public void testNoFocusOnProgrammaticOpen() {

        selectMenuPath(EDIT_ITEM_5);

        WebElement focused = getFocusedElement();

        assertEquals("Focus should remain in the menu", "menu",
                focused.getAttribute("id"));
    }

    @Override
    protected WebElement getFocusedElement() {
        return (WebElement) executeScript("return document.activeElement;");
    }

    @Test
    public void testUneditableColumn() {
        selectMenuPath(EDIT_ITEM_5);
        assertEditorOpen();

        GridEditorElement editor = getGridElement().getEditor();
        assertFalse("Uneditable column should not have an editor widget",
                editor.isEditable(3));
        assertEquals(
                "Not editable cell did not contain correct classname",
                "not-editable",
                editor.findElement(By.className("v-grid-editor-cells"))
                        .findElements(By.xpath("./div")).get(3)
                        .getAttribute("class"));

    }

    private WebElement getSaveButton() {
        return getDriver().findElement(By.className("v-grid-editor-save"));
    }

    private WebElement getCancelButton() {
        return getDriver().findElement(By.className("v-grid-editor-cancel"));
    }
}

<code block>

package com.vaadin.client.widgets;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.google.gwt.core.client.Duration;
import com.google.gwt.core.client.Scheduler;
import com.google.gwt.core.client.Scheduler.ScheduledCommand;
import com.google.gwt.core.shared.GWT;
import com.google.gwt.dom.client.BrowserEvents;
import com.google.gwt.dom.client.DivElement;
import com.google.gwt.dom.client.Element;
import com.google.gwt.dom.client.EventTarget;
import com.google.gwt.dom.client.NativeEvent;
import com.google.gwt.dom.client.Node;
import com.google.gwt.dom.client.Style;
import com.google.gwt.dom.client.Style.Unit;
import com.google.gwt.dom.client.TableCellElement;
import com.google.gwt.dom.client.TableRowElement;
import com.google.gwt.dom.client.TableSectionElement;
import com.google.gwt.dom.client.Touch;
import com.google.gwt.event.dom.client.ClickEvent;
import com.google.gwt.event.dom.client.ClickHandler;
import com.google.gwt.event.dom.client.KeyCodes;
import com.google.gwt.event.dom.client.KeyDownEvent;
import com.google.gwt.event.dom.client.KeyDownHandler;
import com.google.gwt.event.dom.client.KeyEvent;
import com.google.gwt.event.dom.client.MouseEvent;
import com.google.gwt.event.logical.shared.ValueChangeEvent;
import com.google.gwt.event.logical.shared.ValueChangeHandler;
import com.google.gwt.event.shared.HandlerRegistration;
import com.google.gwt.touch.client.Point;
import com.google.gwt.user.client.DOM;
import com.google.gwt.user.client.Event;
import com.google.gwt.user.client.Event.NativePreviewEvent;
import com.google.gwt.user.client.Event.NativePreviewHandler;
import com.google.gwt.user.client.Timer;
import com.google.gwt.user.client.ui.Button;
import com.google.gwt.user.client.ui.CheckBox;
import com.google.gwt.user.client.ui.Composite;
import com.google.gwt.user.client.ui.FlowPanel;
import com.google.gwt.user.client.ui.HasEnabled;
import com.google.gwt.user.client.ui.HasWidgets;
import com.google.gwt.user.client.ui.MenuBar;
import com.google.gwt.user.client.ui.MenuItem;
import com.google.gwt.user.client.ui.ResizeComposite;
import com.google.gwt.user.client.ui.Widget;
import com.vaadin.client.BrowserInfo;
import com.vaadin.client.DeferredWorker;
import com.vaadin.client.Focusable;
import com.vaadin.client.WidgetUtil;
import com.vaadin.client.data.DataChangeHandler;
import com.vaadin.client.data.DataSource;
import com.vaadin.client.renderers.ComplexRenderer;
import com.vaadin.client.renderers.Renderer;
import com.vaadin.client.renderers.WidgetRenderer;
import com.vaadin.client.ui.FocusUtil;
import com.vaadin.client.ui.SubPartAware;
import com.vaadin.client.ui.dd.DragAndDropHandler;
import com.vaadin.client.widget.escalator.Cell;
import com.vaadin.client.widget.escalator.ColumnConfiguration;
import com.vaadin.client.widget.escalator.EscalatorUpdater;
import com.vaadin.client.widget.escalator.FlyweightCell;
import com.vaadin.client.widget.escalator.Row;
import com.vaadin.client.widget.escalator.RowContainer;
import com.vaadin.client.widget.escalator.RowVisibilityChangeEvent;
import com.vaadin.client.widget.escalator.RowVisibilityChangeHandler;
import com.vaadin.client.widget.escalator.ScrollbarBundle.Direction;
import com.vaadin.client.widget.escalator.Spacer;
import com.vaadin.client.widget.escalator.SpacerUpdater;
import com.vaadin.client.widget.grid.AutoScroller;
import com.vaadin.client.widget.grid.AutoScroller.AutoScrollerCallback;
import com.vaadin.client.widget.grid.AutoScroller.ScrollAxis;
import com.vaadin.client.widget.grid.CellReference;
import com.vaadin.client.widget.grid.CellStyleGenerator;
import com.vaadin.client.widget.grid.DataAvailableEvent;
import com.vaadin.client.widget.grid.DataAvailableHandler;
import com.vaadin.client.widget.grid.DetailsGenerator;
import com.vaadin.client.widget.grid.EditorHandler;
import com.vaadin.client.widget.grid.EditorHandler.EditorRequest;
import com.vaadin.client.widget.grid.EventCellReference;
import com.vaadin.client.widget.grid.RendererCellReference;
import com.vaadin.client.widget.grid.RowReference;
import com.vaadin.client.widget.grid.RowStyleGenerator;
import com.vaadin.client.widget.grid.events.AbstractGridKeyEventHandler;
import com.vaadin.client.widget.grid.events.AbstractGridMouseEventHandler;
import com.vaadin.client.widget.grid.events.BodyClickHandler;
import com.vaadin.client.widget.grid.events.BodyDoubleClickHandler;
import com.vaadin.client.widget.grid.events.BodyKeyDownHandler;
import com.vaadin.client.widget.grid.events.BodyKeyPressHandler;
import com.vaadin.client.widget.grid.events.BodyKeyUpHandler;
import com.vaadin.client.widget.grid.events.ColumnReorderEvent;
import com.vaadin.client.widget.grid.events.ColumnReorderHandler;
import com.vaadin.client.widget.grid.events.ColumnVisibilityChangeEvent;
import com.vaadin.client.widget.grid.events.ColumnVisibilityChangeHandler;
import com.vaadin.client.widget.grid.events.FooterClickHandler;
import com.vaadin.client.widget.grid.events.FooterDoubleClickHandler;
import com.vaadin.client.widget.grid.events.FooterKeyDownHandler;
import com.vaadin.client.widget.grid.events.FooterKeyPressHandler;
import com.vaadin.client.widget.grid.events.FooterKeyUpHandler;
import com.vaadin.client.widget.grid.events.GridClickEvent;
import com.vaadin.client.widget.grid.events.GridDoubleClickEvent;
import com.vaadin.client.widget.grid.events.GridKeyDownEvent;
import com.vaadin.client.widget.grid.events.GridKeyPressEvent;
import com.vaadin.client.widget.grid.events.GridKeyUpEvent;
import com.vaadin.client.widget.grid.events.HeaderClickHandler;
import com.vaadin.client.widget.grid.events.HeaderDoubleClickHandler;
import com.vaadin.client.widget.grid.events.HeaderKeyDownHandler;
import com.vaadin.client.widget.grid.events.HeaderKeyPressHandler;
import com.vaadin.client.widget.grid.events.HeaderKeyUpHandler;
import com.vaadin.client.widget.grid.events.ScrollEvent;
import com.vaadin.client.widget.grid.events.ScrollHandler;
import com.vaadin.client.widget.grid.events.SelectAllEvent;
import com.vaadin.client.widget.grid.events.SelectAllHandler;
import com.vaadin.client.widget.grid.selection.HasSelectionHandlers;
import com.vaadin.client.widget.grid.selection.SelectionEvent;
import com.vaadin.client.widget.grid.selection.SelectionHandler;
import com.vaadin.client.widget.grid.selection.SelectionModel;
import com.vaadin.client.widget.grid.selection.SelectionModel.Multi;
import com.vaadin.client.widget.grid.selection.SelectionModelMulti;
import com.vaadin.client.widget.grid.selection.SelectionModelNone;
import com.vaadin.client.widget.grid.selection.SelectionModelSingle;
import com.vaadin.client.widget.grid.sort.Sort;
import com.vaadin.client.widget.grid.sort.SortEvent;
import com.vaadin.client.widget.grid.sort.SortHandler;
import com.vaadin.client.widget.grid.sort.SortOrder;
import com.vaadin.client.widgets.Escalator.AbstractRowContainer;
import com.vaadin.client.widgets.Escalator.SubPartArguments;
import com.vaadin.client.widgets.Grid.Editor.State;
import com.vaadin.client.widgets.Grid.StaticSection.StaticCell;
import com.vaadin.client.widgets.Grid.StaticSection.StaticRow;
import com.vaadin.shared.data.sort.SortDirection;
import com.vaadin.shared.ui.grid.GridConstants;
import com.vaadin.shared.ui.grid.GridStaticCellType;
import com.vaadin.shared.ui.grid.HeightMode;
import com.vaadin.shared.ui.grid.Range;
import com.vaadin.shared.ui.grid.ScrollDestination;
import com.vaadin.shared.util.SharedUtil;


public class Grid<T> extends ResizeComposite implements
        HasSelectionHandlers<T>, SubPartAware, DeferredWorker, HasWidgets,
        HasEnabled {


    public enum Section {
        HEADER, BODY, FOOTER
    }


    public abstract static class StaticSection<ROWTYPE extends StaticSection.StaticRow<?>> {


        public static class StaticCell {

            private Object content = null;

            private int colspan = 1;

            private StaticSection<?> section;

            private GridStaticCellType type = GridStaticCellType.TEXT;

            private String styleName = null;


            public void setText(String text) {
                this.content = text;
                this.type = GridStaticCellType.TEXT;
                section.requestSectionRefresh();
            }


            public String getText() {
                if (type != GridStaticCellType.TEXT) {
                    throw new IllegalStateException(
                            "Cannot fetch Text from a cell with type " + type);
                }
                return (String) content;
            }

            protected StaticSection<?> getSection() {
                assert section != null;
                return section;
            }

            protected void setSection(StaticSection<?> section) {
                this.section = section;
            }


            public int getColspan() {
                return colspan;
            }


            public void setColspan(int colspan) {
                if (colspan < 1) {
                    throw new IllegalArgumentException(
                            "Colspan cannot be less than 1");
                }

                this.colspan = colspan;
                section.requestSectionRefresh();
            }


            public String getHtml() {
                if (type != GridStaticCellType.HTML) {
                    throw new IllegalStateException(
                            "Cannot fetch HTML from a cell with type " + type);
                }
                return (String) content;
            }


            public void setHtml(String html) {
                this.content = html;
                this.type = GridStaticCellType.HTML;
                section.requestSectionRefresh();
            }


            public Widget getWidget() {
                if (type != GridStaticCellType.WIDGET) {
                    throw new IllegalStateException(
                            "Cannot fetch Widget from a cell with type " + type);
                }
                return (Widget) content;
            }


            public void setWidget(Widget widget) {
                this.content = widget;
                this.type = GridStaticCellType.WIDGET;
                section.requestSectionRefresh();
            }


            public GridStaticCellType getType() {
                return type;
            }


            public String getStyleName() {
                return styleName;
            }


            public void setStyleName(String styleName) {
                this.styleName = styleName;
                section.requestSectionRefresh();

            }

        }


        public abstract static class StaticRow<CELLTYPE extends StaticCell> {

            private Map<Column<?, ?>, CELLTYPE> cells = new HashMap<Column<?, ?>, CELLTYPE>();

            private StaticSection<?> section;


            private Map<Set<Column<?, ?>>, CELLTYPE> cellGroups = new HashMap<Set<Column<?, ?>>, CELLTYPE>();


            private String styleName = null;


            public CELLTYPE getCell(Column<?, ?> column) {
                Set<Column<?, ?>> cellGroup = getCellGroupForColumn(column);
                if (cellGroup != null) {
                    return cellGroups.get(cellGroup);
                }
                return cells.get(column);
            }


            public boolean hasSpannedCells() {
                return !cellGroups.isEmpty();
            }


            public CELLTYPE join(Column<?, ?>... columns) {
                if (columns.length <= 1) {
                    throw new IllegalArgumentException(
                            "You can't merge less than 2 columns together.");
                }

                HashSet<Column<?, ?>> columnGroup = new HashSet<Column<?, ?>>();


                for (Column<?, ?> column : columns) {
                    if (!cells.containsKey(column)) {
                        throw new IllegalArgumentException(
                                "Given column does not exists on row " + column);
                    } else if (getCellGroupForColumn(column) != null) {
                        throw new IllegalStateException(
                                "Column is already in a group.");
                    }
                    columnGroup.add(column);
                }

                CELLTYPE joinedCell = createCell();
                cellGroups.put(columnGroup, joinedCell);
                joinedCell.setSection(getSection());

                calculateColspans();

                return joinedCell;
            }


            public CELLTYPE join(CELLTYPE... cells) {
                if (cells.length <= 1) {
                    throw new IllegalArgumentException(
                            "You can't merge less than 2 cells together.");
                }

                Column<?, ?>[] columns = new Column<?, ?>[cells.length];

                int j = 0;
                for (Column<?, ?> column : this.cells.keySet()) {
                    CELLTYPE cell = this.cells.get(column);
                    if (!this.cells.containsValue(cells[j])) {
                        throw new IllegalArgumentException(
                                "Given cell does not exists on row");
                    } else if (cell.equals(cells[j])) {
                        columns[j++] = column;
                        if (j == cells.length) {
                            break;
                        }
                    }
                }

                return join(columns);
            }

            private Set<Column<?, ?>> getCellGroupForColumn(Column<?, ?> column) {
                for (Set<Column<?, ?>> group : cellGroups.keySet()) {
                    if (group.contains(column)) {
                        return group;
                    }
                }
                return null;
            }

            void calculateColspans() {

                for (CELLTYPE cell : this.cells.values()) {
                    cell.setColspan(1);
                }

                for (Set<Column<?, ?>> group : cellGroups.keySet()) {
                    if (!checkMergedCellIsContinuous(group)) {

                        cellGroups.get(group).setColspan(1);
                    } else {
                        int colSpan = 0;
                        for (Column<?, ?> column : group) {
                            if (!column.isHidden()) {
                                colSpan++;
                            }
                        }

                        cellGroups.get(group).setColspan(Math.max(1, colSpan));
                    }
                }

            }

            private boolean checkMergedCellIsContinuous(
                    Set<Column<?, ?>> mergedCell) {

                final List<Column<?, ?>> columnOrder = new ArrayList<Column<?, ?>>(
                        section.grid.getColumns());

                if (!columnOrder.containsAll(mergedCell)) {
                    return false;
                }

                for (int i = 0; i < columnOrder.size(); ++i) {
                    if (!mergedCell.contains(columnOrder.get(i))) {
                        continue;
                    }

                    for (int j = 1; j < mergedCell.size(); ++j) {
                        if (!mergedCell.contains(columnOrder.get(i + j))) {
                            return false;
                        }
                    }
                    return true;
                }
                return false;
            }

            protected void addCell(Column<?, ?> column) {
                CELLTYPE cell = createCell();
                cell.setSection(getSection());
                cells.put(column, cell);
            }

            protected void removeCell(Column<?, ?> column) {
                cells.remove(column);
            }

            protected abstract CELLTYPE createCell();

            protected StaticSection<?> getSection() {
                return section;
            }

            protected void setSection(StaticSection<?> section) {
                this.section = section;
            }


            public String getStyleName() {
                return styleName;
            }


            public void setStyleName(String styleName) {
                this.styleName = styleName;
                section.requestSectionRefresh();
            }
        }

        private Grid<?> grid;

        private List<ROWTYPE> rows = new ArrayList<ROWTYPE>();

        private boolean visible = true;


        protected abstract ROWTYPE createRow();


        protected abstract void requestSectionRefresh();


        public void setVisible(boolean visible) {
            this.visible = visible;
            requestSectionRefresh();
        }


        public boolean isVisible() {
            return visible;
        }


        public ROWTYPE addRowAt(int index) {
            ROWTYPE row = createRow();
            row.setSection(this);
            for (int i = 0; i < getGrid().getColumnCount(); ++i) {
                row.addCell(grid.getColumn(i));
            }
            rows.add(index, row);

            requestSectionRefresh();
            return row;
        }


        public ROWTYPE prependRow() {
            return addRowAt(0);
        }


        public ROWTYPE appendRow() {
            return addRowAt(rows.size());
        }


        public void removeRow(int index) {
            rows.remove(index);
            requestSectionRefresh();
        }


        public void removeRow(ROWTYPE row) {
            try {
                removeRow(rows.indexOf(row));
            } catch (IndexOutOfBoundsException e) {
                throw new IllegalArgumentException(
                        "Section does not contain the given row");
            }
        }


        public ROWTYPE getRow(int index) {
            try {
                return rows.get(index);
            } catch (IndexOutOfBoundsException e) {
                throw new IllegalArgumentException("Row with index " + index
                        + " does not exist");
            }
        }


        public int getRowCount() {
            return rows.size();
        }

        protected List<ROWTYPE> getRows() {
            return rows;
        }

        protected int getVisibleRowCount() {
            return isVisible() ? getRowCount() : 0;
        }

        protected void addColumn(Column<?, ?> column) {
            for (ROWTYPE row : rows) {
                row.addCell(column);
            }
        }

        protected void removeColumn(Column<?, ?> column) {
            for (ROWTYPE row : rows) {
                row.removeCell(column);
            }
        }

        protected void setGrid(Grid<?> grid) {
            this.grid = grid;
        }

        protected Grid<?> getGrid() {
            assert grid != null;
            return grid;
        }

        protected void updateColSpans() {
            for (ROWTYPE row : rows) {
                if (row.hasSpannedCells()) {
                    row.calculateColspans();
                }
            }
        }
    }


    protected static class Header extends StaticSection<HeaderRow> {
        private HeaderRow defaultRow;

        private boolean markAsDirty = false;

        @Override
        public void removeRow(int index) {
            HeaderRow removedRow = getRow(index);
            super.removeRow(index);
            if (removedRow == defaultRow) {
                setDefaultRow(null);
            }
        }


        public void setDefaultRow(HeaderRow row) {
            if (row == defaultRow) {
                return;
            }
            if (row != null && !getRows().contains(row)) {
                throw new IllegalArgumentException(
                        "Cannot set a default row that does not exist in the container");
            }
            if (defaultRow != null) {
                defaultRow.setDefault(false);
            }
            if (row != null) {
                row.setDefault(true);
            }

            defaultRow = row;
            requestSectionRefresh();
        }


        public HeaderRow getDefaultRow() {
            return defaultRow;
        }

        @Override
        protected HeaderRow createRow() {
            return new HeaderRow();
        }

        @Override
        protected void requestSectionRefresh() {
            markAsDirty = true;


            Scheduler.get().scheduleFinally(new Scheduler.ScheduledCommand() {

                @Override
                public void execute() {
                    if (markAsDirty) {
                        markAsDirty = false;
                        getGrid().refreshHeader();
                    }
                }
            });
        }


        public Collection<String> getConsumedEvents() {
            return Arrays.asList(BrowserEvents.TOUCHSTART,
                    BrowserEvents.TOUCHMOVE, BrowserEvents.TOUCHEND,
                    BrowserEvents.TOUCHCANCEL, BrowserEvents.CLICK);
        }

        @Override
        protected void addColumn(Column<?, ?> column) {
            super.addColumn(column);


            if (defaultRow != null) {
                column.setDefaultHeaderContent(defaultRow.getCell(column));
            }
        }
    }


    public static class HeaderRow extends StaticSection.StaticRow<HeaderCell> {

        private boolean isDefault = false;

        protected void setDefault(boolean isDefault) {
            this.isDefault = isDefault;
            if (isDefault) {
                for (Column<?, ?> column : getSection().grid.getColumns()) {
                    column.setDefaultHeaderContent(getCell(column));
                }
            }
        }

        public boolean isDefault() {
            return isDefault;
        }

        @Override
        protected HeaderCell createCell() {
            return new HeaderCell();
        }
    }


    public static class HeaderCell extends StaticSection.StaticCell {
    }


    protected static class Footer extends StaticSection<FooterRow> {
        private boolean markAsDirty = false;

        @Override
        protected FooterRow createRow() {
            return new FooterRow();
        }

        @Override
        protected void requestSectionRefresh() {
            markAsDirty = true;


            Scheduler.get().scheduleFinally(new Scheduler.ScheduledCommand() {

                @Override
                public void execute() {
                    if (markAsDirty) {
                        markAsDirty = false;
                        getGrid().refreshFooter();
                    }
                }
            });
        }
    }


    public static class FooterCell extends StaticSection.StaticCell {
    }


    public static class FooterRow extends StaticSection.StaticRow<FooterCell> {

        @Override
        protected FooterCell createCell() {
            return new FooterCell();
        }
    }

    private static class EditorRequestImpl<T> implements EditorRequest<T> {


        public static interface RequestCallback<T> {

            public void onSuccess(EditorRequest<T> request);


            public void onError(EditorRequest<T> request);
        }

        private Grid<T> grid;
        private int rowIndex;
        private RequestCallback<T> callback;
        private boolean completed = false;

        public EditorRequestImpl(Grid<T> grid, int rowIndex,
                RequestCallback<T> callback) {
            this.grid = grid;
            this.rowIndex = rowIndex;
            this.callback = callback;
        }

        @Override
        public int getRowIndex() {
            return rowIndex;
        }

        @Override
        public T getRow() {
            return grid.getDataSource().getRow(rowIndex);
        }

        @Override
        public Grid<T> getGrid() {
            return grid;
        }

        @Override
        public Widget getWidget(Grid.Column<?, T> column) {
            Widget w = grid.getEditorWidget(column);
            assert w != null;
            return w;
        }

        private void complete(String errorMessage,
                Collection<Column<?, T>> errorColumns) {
            if (completed) {
                throw new IllegalStateException(
                        "An EditorRequest must be completed exactly once");
            }
            completed = true;

            grid.getEditor().setErrorMessage(errorMessage);

            grid.getEditor().clearEditorColumnErrors();
            if (errorColumns != null) {
                for (Column<?, T> column : errorColumns) {
                    grid.getEditor().setEditorColumnError(column, true);
                }
            }
        }

        @Override
        public void success() {
            complete(null, null);
            if (callback != null) {
                callback.onSuccess(this);
            }
        }

        @Override
        public void failure(String errorMessage,
                Collection<Grid.Column<?, T>> errorColumns) {
            complete(errorMessage, errorColumns);
            if (callback != null) {
                callback.onError(this);
            }
        }

        @Override
        public boolean isCompleted() {
            return completed;
        }
    }


    protected static class Editor<T> {

        public static final int KEYCODE_SHOW = KeyCodes.KEY_ENTER;
        public static final int KEYCODE_HIDE = KeyCodes.KEY_ESCAPE;

        private static final String ERROR_CLASS_NAME = "error";
        private static final String NOT_EDITABLE_CLASS_NAME = "not-editable";

        protected enum State {
            INACTIVE, ACTIVATING, BINDING, ACTIVE, SAVING
        }

        private Grid<T> grid;
        private EditorHandler<T> handler;

        private DivElement editorOverlay = DivElement.as(DOM.createDiv());
        private DivElement cellWrapper = DivElement.as(DOM.createDiv());
        private DivElement messageAndButtonsWrapper = DivElement.as(DOM
                .createDiv());

        private DivElement messageWrapper = DivElement.as(DOM.createDiv());
        private DivElement buttonsWrapper = DivElement.as(DOM.createDiv());



        private DivElement message = DivElement.as(DOM.createDiv());

        private Map<Column<?, T>, Widget> columnToWidget = new HashMap<Column<?, T>, Widget>();

        private boolean enabled = false;
        private State state = State.INACTIVE;
        private int rowIndex = -1;
        private int columnIndex = -1;
        private String styleName = null;

        private HandlerRegistration scrollHandler;

        private final Button saveButton;
        private final Button cancelButton;

        private static final int SAVE_TIMEOUT_MS = 5000;
        private final Timer saveTimeout = new Timer() {
            @Override
            public void run() {
                getLogger().warning(
                        "Editor save action is taking longer than expected ("
                                + SAVE_TIMEOUT_MS + "ms). Does your "
                                + EditorHandler.class.getSimpleName()
                                + " remember to call success() or fail()?");
            }
        };

        private final EditorRequestImpl.RequestCallback<T> saveRequestCallback = new EditorRequestImpl.RequestCallback<T>() {
            @Override
            public void onSuccess(EditorRequest<T> request) {
                if (state == State.SAVING) {
                    cleanup();
                    cancel();
                }
            }

            @Override
            public void onError(EditorRequest<T> request) {
                if (state == State.SAVING) {
                    cleanup();


                    getLogger().warning(
                            "An error occurred when trying to save the "
                                    + "modified row");
                }
            }

            private void cleanup() {
                state = State.ACTIVE;
                setButtonsEnabled(true);
                saveTimeout.cancel();
            }
        };

        private static final int BIND_TIMEOUT_MS = 5000;
        private final Timer bindTimeout = new Timer() {
            @Override
            public void run() {
                getLogger().warning(
                        "Editor bind action is taking longer than expected ("
                                + BIND_TIMEOUT_MS + "ms). Does your "
                                + EditorHandler.class.getSimpleName()
                                + " remember to call success() or fail()?");
            }
        };
        private final EditorRequestImpl.RequestCallback<T> bindRequestCallback = new EditorRequestImpl.RequestCallback<T>() {
            @Override
            public void onSuccess(EditorRequest<T> request) {
                if (state == State.BINDING) {
                    state = State.ACTIVE;
                    bindTimeout.cancel();

                    assert rowIndex == request.getRowIndex() : "Request row index "
                            + request.getRowIndex()
                            + " did not match the saved row index " + rowIndex;

                    showOverlay();
                }
            }

            @Override
            public void onError(EditorRequest<T> request) {
                if (state == State.BINDING) {
                    state = State.INACTIVE;
                    bindTimeout.cancel();


                    getLogger().warning(
                            "An error occurred while trying to show the "
                                    + "Grid editor");
                    grid.getEscalator().setScrollLocked(Direction.VERTICAL,
                            false);
                    updateSelectionCheckboxesAsNeeded(true);
                }
            }
        };


        private final Set<Column<?, T>> columnErrors = new HashSet<Grid.Column<?, T>>();

        public Editor() {
            saveButton = new Button();
            saveButton.setText(GridConstants.DEFAULT_SAVE_CAPTION);
            saveButton.addClickHandler(new ClickHandler() {
                @Override
                public void onClick(ClickEvent event) {
                    save();
                }
            });

            cancelButton = new Button();
            cancelButton.setText(GridConstants.DEFAULT_CANCEL_CAPTION);
            cancelButton.addClickHandler(new ClickHandler() {
                @Override
                public void onClick(ClickEvent event) {
                    cancel();
                }
            });
        }

        public void setErrorMessage(String errorMessage) {
            if (errorMessage == null) {
                message.removeFromParent();
            } else {
                message.setInnerText(errorMessage);
                if (message.getParentElement() == null) {
                    messageWrapper.appendChild(message);
                }
            }
        }

        public int getRow() {
            return rowIndex;
        }


        public void editRow(int rowIndex) {
            editRow(rowIndex, -1);
        }


        public void editRow(int rowIndex, int columnIndex) {
            if (!enabled) {
                throw new IllegalStateException(
                        "Cannot edit row: editor is not enabled");
            }
            if (state != State.INACTIVE) {
                throw new IllegalStateException(
                        "Cannot edit row: editor already in edit mode");
            }

            this.rowIndex = rowIndex;
            this.columnIndex = columnIndex;

            state = State.ACTIVATING;

            if (grid.getEscalator().getVisibleRowRange().contains(rowIndex)) {
                show();
            } else {
                grid.scrollToRow(rowIndex, ScrollDestination.MIDDLE);
            }
        }


        public void cancel() {
            if (!enabled) {
                throw new IllegalStateException(
                        "Cannot cancel edit: editor is not enabled");
            }
            if (state == State.INACTIVE) {
                throw new IllegalStateException(
                        "Cannot cancel edit: editor is not in edit mode");
            }
            hideOverlay();
            grid.getEscalator().setScrollLocked(Direction.VERTICAL, false);

            EditorRequest<T> request = new EditorRequestImpl<T>(grid, rowIndex,
                    null);
            handler.cancel(request);
            state = State.INACTIVE;
            updateSelectionCheckboxesAsNeeded(true);
        }

        private void updateSelectionCheckboxesAsNeeded(boolean isEnabled) {
            if (grid.getSelectionModel() instanceof Multi) {
                grid.refreshBody();
                CheckBox checkBox = (CheckBox) grid.getDefaultHeaderRow()
                        .getCell(grid.selectionColumn).getWidget();
                checkBox.setEnabled(isEnabled);
            }
        }


        public void save() {
            if (!enabled) {
                throw new IllegalStateException(
                        "Cannot save: editor is not enabled");
            }
            if (state != State.ACTIVE) {
                throw new IllegalStateException(
                        "Cannot save: editor is not in edit mode");
            }

            state = State.SAVING;
            setButtonsEnabled(false);
            saveTimeout.schedule(SAVE_TIMEOUT_MS);
            EditorRequest<T> request = new EditorRequestImpl<T>(grid, rowIndex,
                    saveRequestCallback);
            handler.save(request);
            updateSelectionCheckboxesAsNeeded(true);
        }


        public EditorHandler<T> getHandler() {
            return handler;
        }


        public void setHandler(EditorHandler<T> rowHandler) {
            if (state != State.INACTIVE) {
                throw new IllegalStateException(
                        "Cannot set EditorHandler: editor is currently in edit mode");
            }
            handler = rowHandler;
        }

        public boolean isEnabled() {
            return enabled;
        }


        public void setEnabled(boolean enabled) {
            if (enabled == false && state != State.INACTIVE) {
                throw new IllegalStateException(
                        "Cannot disable: editor is in edit mode");
            } else if (enabled == true && getHandler() == null) {
                throw new IllegalStateException(
                        "Cannot enable: EditorHandler not set");
            }
            this.enabled = enabled;
        }

        protected void show() {
            if (state == State.ACTIVATING) {
                state = State.BINDING;
                bindTimeout.schedule(BIND_TIMEOUT_MS);
                EditorRequest<T> request = new EditorRequestImpl<T>(grid,
                        rowIndex, bindRequestCallback);
                handler.bind(request);
                grid.getEscalator().setScrollLocked(Direction.VERTICAL, true);
                updateSelectionCheckboxesAsNeeded(false);
            }
        }

        protected void setGrid(final Grid<T> grid) {
            assert grid != null : "Grid cannot be null";
            assert this.grid == null : "Can only attach editor to Grid once";

            this.grid = grid;

            grid.addDataAvailableHandler(new DataAvailableHandler() {
                @Override
                public void onDataAvailable(DataAvailableEvent event) {
                    if (event.getAvailableRows().contains(rowIndex)) {
                        show();
                    }
                }
            });
        }

        protected State getState() {
            return state;
        }

        protected void setState(State state) {
            this.state = state;
        }


        protected Widget getWidget(Column<?, T> column) {
            return columnToWidget.get(column);
        }


        @Deprecated
        protected void showOverlay(TableRowElement unused) {
            showOverlay();
        }


        protected void showOverlay() {

            DivElement gridElement = DivElement.as(grid.getElement());

            TableRowElement tr = grid.getEscalator().getBody()
                    .getRowElement(rowIndex);

            scrollHandler = grid.addScrollHandler(new ScrollHandler() {
                @Override
                public void onScroll(ScrollEvent event) {
                    updateHorizontalScrollPosition();
                }
            });

            gridElement.appendChild(editorOverlay);
            editorOverlay.appendChild(cellWrapper);
            editorOverlay.appendChild(messageAndButtonsWrapper);

            for (int i = 0; i < tr.getCells().getLength(); i++) {
                Element cell = createCell(tr.getCells().getItem(i));

                cellWrapper.appendChild(cell);

                Column<?, T> column = grid.getVisibleColumn(i);
                if (column.isEditable()) {
                    Widget editor = getHandler().getWidget(column);

                    if (editor != null) {
                        columnToWidget.put(column, editor);
                        attachWidget(editor, cell);
                    }

                    if (i == columnIndex) {
                        if (editor instanceof Focusable) {
                            ((Focusable) editor).focus();
                        } else if (editor instanceof com.google.gwt.user.client.ui.Focusable) {
                            ((com.google.gwt.user.client.ui.Focusable) editor)
                                    .setFocus(true);
                        }
                    }
                } else {
                    cell.addClassName(NOT_EDITABLE_CLASS_NAME);
                }
            }


            if (!messageAndButtonsWrapper.isOrHasChild(messageWrapper)) {
                messageAndButtonsWrapper.appendChild(messageWrapper);
                messageAndButtonsWrapper.appendChild(buttonsWrapper);
            }

            attachWidget(saveButton, buttonsWrapper);
            attachWidget(cancelButton, buttonsWrapper);

            updateHorizontalScrollPosition();

            AbstractRowContainer body = (AbstractRowContainer) grid
                    .getEscalator().getBody();
            double rowTop = body.getRowTop(tr);

            int bodyTop = body.getElement().getAbsoluteTop();
            int gridTop = gridElement.getAbsoluteTop();
            double overlayTop = rowTop + bodyTop - gridTop;

            if (buttonsShouldBeRenderedBelow(tr)) {

                editorOverlay.getStyle().setTop(overlayTop, Unit.PX);
                editorOverlay.getStyle().clearBottom();
            } else {



                editorOverlay.insertFirst(messageAndButtonsWrapper);
                int gridHeight = grid.getElement().getOffsetHeight();
                editorOverlay.getStyle()
                        .setBottom(
                                gridHeight - overlayTop - tr.getOffsetHeight(),
                                Unit.PX);
                editorOverlay.getStyle().clearTop();
            }


            editorOverlay.getStyle().setWidth(grid.escalator.getInnerWidth(),
                    Unit.PX);
        }

        private boolean buttonsShouldBeRenderedBelow(TableRowElement tr) {
            TableSectionElement tfoot = grid.escalator.getFooter().getElement();
            double tfootPageTop = WidgetUtil.getBoundingClientRect(tfoot)
                    .getTop();
            double trPageBottom = WidgetUtil.getBoundingClientRect(tr)
                    .getBottom();
            int messageAndButtonsHeight = messageAndButtonsWrapper
                    .getOffsetHeight();
            double bottomOfButtons = trPageBottom + messageAndButtonsHeight;
            return bottomOfButtons < tfootPageTop;
        }

        protected void hideOverlay() {
            for (Widget w : columnToWidget.values()) {
                setParent(w, null);
            }
            columnToWidget.clear();

            detachWidget(saveButton);
            detachWidget(cancelButton);

            editorOverlay.removeAllChildren();
            cellWrapper.removeAllChildren();
            editorOverlay.removeFromParent();

            scrollHandler.removeHandler();

            clearEditorColumnErrors();
        }

        protected void setStylePrimaryName(String primaryName) {
            if (styleName != null) {
                editorOverlay.removeClassName(styleName);

                cellWrapper.removeClassName(styleName + "-cells");
                messageAndButtonsWrapper.removeClassName(styleName + "-footer");

                messageWrapper.removeClassName(styleName + "-message");
                buttonsWrapper.removeClassName(styleName + "-buttons");

                saveButton.removeStyleName(styleName + "-save");
                cancelButton.removeStyleName(styleName + "-cancel");
            }
            styleName = primaryName + "-editor";
            editorOverlay.setClassName(styleName);

            cellWrapper.setClassName(styleName + "-cells");
            messageAndButtonsWrapper.setClassName(styleName + "-footer");

            messageWrapper.setClassName(styleName + "-message");
            buttonsWrapper.setClassName(styleName + "-buttons");

            saveButton.setStyleName(styleName + "-save");
            cancelButton.setStyleName(styleName + "-cancel");
        }


        protected Element createCell(TableCellElement td) {
            DivElement cell = DivElement.as(DOM.createDiv());
            double width = WidgetUtil
                    .getRequiredWidthBoundingClientRectDouble(td);
            double height = WidgetUtil
                    .getRequiredHeightBoundingClientRectDouble(td);
            setBounds(cell, td.getOffsetLeft(), td.getOffsetTop(), width,
                    height);
            return cell;
        }

        private void attachWidget(Widget w, Element parent) {
            parent.appendChild(w.getElement());
            setParent(w, grid);
        }

        private void detachWidget(Widget w) {
            setParent(w, null);
            w.getElement().removeFromParent();
        }

        private static void setBounds(Element e, double left, double top,
                double width, double height) {
            Style style = e.getStyle();
            style.setLeft(left, Unit.PX);
            style.setTop(top, Unit.PX);
            style.setWidth(width, Unit.PX);
            style.setHeight(height, Unit.PX);
        }

        private void updateHorizontalScrollPosition() {
            double scrollLeft = grid.getScrollLeft();
            cellWrapper.getStyle().setLeft(-scrollLeft, Unit.PX);
        }

        protected void setGridEnabled(boolean enabled) {


            setButtonsEnabled(enabled);
        }

        private void setButtonsEnabled(boolean enabled) {
            saveButton.setEnabled(enabled);
            cancelButton.setEnabled(enabled);
        }

        public void setSaveCaption(String saveCaption)
                throws IllegalArgumentException {
            if (saveCaption == null) {
                throw new IllegalArgumentException(
                        "Save caption cannot be null");
            }
            saveButton.setText(saveCaption);
        }

        public String getSaveCaption() {
            return saveButton.getText();
        }

        public void setCancelCaption(String cancelCaption)
                throws IllegalArgumentException {
            if (cancelCaption == null) {
                throw new IllegalArgumentException(
                        "Cancel caption cannot be null");
            }
            cancelButton.setText(cancelCaption);
        }

        public String getCancelCaption() {
            return cancelButton.getText();
        }

        public void setEditorColumnError(Column<?, T> column, boolean hasError) {
            if (state != State.ACTIVE && state != State.SAVING) {
                throw new IllegalStateException("Cannot set cell error "
                        + "status: editor is neither active nor saving.");
            }

            if (isEditorColumnError(column) == hasError) {
                return;
            }

            Element editorCell = getWidget(column).getElement()
                    .getParentElement();
            if (hasError) {
                editorCell.addClassName(ERROR_CLASS_NAME);
                columnErrors.add(column);
            } else {
                editorCell.removeClassName(ERROR_CLASS_NAME);
                columnErrors.remove(column);
            }
        }

        public void clearEditorColumnErrors() {


            Element e = editorOverlay.getFirstChildElement();
            while (e != null) {
                e.removeClassName(ERROR_CLASS_NAME);
                e = e.getNextSiblingElement();
            }

            columnErrors.clear();
        }

        public boolean isEditorColumnError(Column<?, T> column) {
            return columnErrors.contains(column);
        }
    }

    public static abstract class AbstractGridKeyEvent<HANDLER extends AbstractGridKeyEventHandler>
            extends KeyEvent<HANDLER> {

        private Grid<?> grid;
        private final Type<HANDLER> associatedType = new Type<HANDLER>(
                getBrowserEventType(), this);
        private final CellReference<?> targetCell;

        public AbstractGridKeyEvent(Grid<?> grid, CellReference<?> targetCell) {
            this.grid = grid;
            this.targetCell = targetCell;
        }

        protected abstract String getBrowserEventType();


        public Grid<?> getGrid() {
            return grid;
        }


        public CellReference<?> getFocusedCell() {
            return targetCell;
        }

        @Override
        protected void dispatch(HANDLER handler) {
            EventTarget target = getNativeEvent().getEventTarget();
            if (Element.is(target)
                    && !grid.isElementInChildWidget(Element.as(target))) {

                Section section = Section.FOOTER;
                final RowContainer container = grid.cellFocusHandler.containerWithFocus;
                if (container == grid.escalator.getHeader()) {
                    section = Section.HEADER;
                } else if (container == grid.escalator.getBody()) {
                    section = Section.BODY;
                }

                doDispatch(handler, section);
            }
        }

        protected abstract void doDispatch(HANDLER handler, Section section);

        @Override
        public Type<HANDLER> getAssociatedType() {
            return associatedType;
        }
    }

    public static abstract class AbstractGridMouseEvent<HANDLER extends AbstractGridMouseEventHandler>
            extends MouseEvent<HANDLER> {

        private Grid<?> grid;
        private final CellReference<?> targetCell;
        private final Type<HANDLER> associatedType = new Type<HANDLER>(
                getBrowserEventType(), this);

        public AbstractGridMouseEvent(Grid<?> grid, CellReference<?> targetCell) {
            this.grid = grid;
            this.targetCell = targetCell;
        }

        protected abstract String getBrowserEventType();


        public Grid<?> getGrid() {
            return grid;
        }


        public CellReference<?> getTargetCell() {
            return targetCell;
        }

        @Override
        protected void dispatch(HANDLER handler) {
            EventTarget target = getNativeEvent().getEventTarget();
            if (!Element.is(target)) {

                return;
            }

            Element targetElement = Element.as(target);
            if (grid.isElementInChildWidget(targetElement)) {

                return;
            }

            final RowContainer container = grid.escalator
                    .findRowContainer(targetElement);
            if (container == null) {

                return;
            }

            Section section = Section.FOOTER;
            if (container == grid.escalator.getHeader()) {
                section = Section.HEADER;
            } else if (container == grid.escalator.getBody()) {
                section = Section.BODY;
            }

            doDispatch(handler, section);
        }

        protected abstract void doDispatch(HANDLER handler, Section section);

        @Override
        public Type<HANDLER> getAssociatedType() {
            return associatedType;
        }
    }

    private static final String CUSTOM_STYLE_PROPERTY_NAME = "customStyle";


    private static final double DETAILS_ROW_INITIAL_HEIGHT = 50;

    private EventCellReference<T> eventCell = new EventCellReference<T>(this);
    private GridKeyDownEvent keyDown = new GridKeyDownEvent(this, eventCell);
    private GridKeyUpEvent keyUp = new GridKeyUpEvent(this, eventCell);
    private GridKeyPressEvent keyPress = new GridKeyPressEvent(this, eventCell);
    private GridClickEvent clickEvent = new GridClickEvent(this, eventCell);
    private GridDoubleClickEvent doubleClickEvent = new GridDoubleClickEvent(
            this, eventCell);

    private class CellFocusHandler {

        private RowContainer containerWithFocus = escalator.getBody();
        private int rowWithFocus = 0;
        private Range cellFocusRange = Range.withLength(0, 1);
        private int lastFocusedBodyRow = 0;
        private int lastFocusedHeaderRow = 0;
        private int lastFocusedFooterRow = 0;
        private TableCellElement cellWithFocusStyle = null;
        private TableRowElement rowWithFocusStyle = null;

        public CellFocusHandler() {
            sinkEvents(getNavigationEvents());
        }

        private Cell getFocusedCell() {
            return new Cell(rowWithFocus, cellFocusRange.getStart(),
                    cellWithFocusStyle);
        }


        public void updateFocusedCellStyle(FlyweightCell cell,
                RowContainer cellContainer) {
            int cellRow = cell.getRow();
            int cellColumn = cell.getColumn();
            int colSpan = cell.getColSpan();
            boolean columnHasFocus = Range.withLength(cellColumn, colSpan)
                    .intersects(cellFocusRange);

            if (cellContainer == containerWithFocus) {

                if (cellRow == rowWithFocus && columnHasFocus) {
                    if (cellWithFocusStyle != cell.getElement()) {

                        if (cellWithFocusStyle != null) {

                            setStyleName(cellWithFocusStyle,
                                    cellFocusStyleName, false);
                        }
                        cellWithFocusStyle = cell.getElement();


                        setStyleName(cellWithFocusStyle, cellFocusStyleName,
                                true);
                    }
                } else if (cellWithFocusStyle == cell.getElement()) {


                    setStyleName(cellWithFocusStyle, cellFocusStyleName, false);
                    cellWithFocusStyle = null;
                }
            }
        }


        public void updateFocusedRowStyle(Row row) {
            if (rowWithFocus == row.getRow()
                    && containerWithFocus == escalator.getBody()) {
                if (row.getElement() != rowWithFocusStyle) {

                    if (rowWithFocusStyle != null) {
                        setStyleName(rowWithFocusStyle, rowFocusStyleName,
                                false);
                    }
                    rowWithFocusStyle = row.getElement();
                    setStyleName(rowWithFocusStyle, rowFocusStyleName, true);
                }
            } else if (rowWithFocusStyle == row.getElement()
                    || (containerWithFocus != escalator.getBody() && rowWithFocusStyle != null)) {

                setStyleName(rowWithFocusStyle, rowFocusStyleName, false);
                rowWithFocusStyle = null;
            }
        }


        private void setCellFocus(int rowIndex, int columnIndexDOM,
                RowContainer container) {
            if (rowIndex == rowWithFocus
                    && cellFocusRange.contains(columnIndexDOM)
                    && container == this.containerWithFocus) {
                refreshRow(rowWithFocus);
                return;
            }

            int oldRow = rowWithFocus;
            rowWithFocus = rowIndex;
            Range oldRange = cellFocusRange;

            if (container == escalator.getBody()) {
                scrollToRow(rowWithFocus);
                cellFocusRange = Range.withLength(columnIndexDOM, 1);
            } else {
                int i = 0;
                Element cell = container.getRowElement(rowWithFocus)
                        .getFirstChildElement();
                do {
                    int colSpan = cell
                            .getPropertyInt(FlyweightCell.COLSPAN_ATTR);
                    Range cellRange = Range.withLength(i, colSpan);
                    if (cellRange.contains(columnIndexDOM)) {
                        cellFocusRange = cellRange;
                        break;
                    }
                    cell = cell.getNextSiblingElement();
                    ++i;
                } while (cell != null);
            }
            int columnIndex = getColumns().indexOf(
                    getVisibleColumn(columnIndexDOM));
            if (columnIndex >= escalator.getColumnConfiguration()
                    .getFrozenColumnCount()) {
                escalator.scrollToColumn(columnIndexDOM, ScrollDestination.ANY,
                        10);
            }

            if (this.containerWithFocus == container) {
                if (oldRange.equals(cellFocusRange) && oldRow != rowWithFocus) {
                    refreshRow(oldRow);
                } else {
                    refreshHeader();
                    refreshFooter();
                }
            } else {
                RowContainer oldContainer = this.containerWithFocus;
                this.containerWithFocus = container;

                if (oldContainer == escalator.getBody()) {
                    lastFocusedBodyRow = oldRow;
                } else if (oldContainer == escalator.getHeader()) {
                    lastFocusedHeaderRow = oldRow;
                } else {
                    lastFocusedFooterRow = oldRow;
                }

                if (!oldRange.equals(cellFocusRange)) {
                    refreshHeader();
                    refreshFooter();
                    if (oldContainer == escalator.getBody()) {
                        oldContainer.refreshRows(oldRow, 1);
                    }
                } else {
                    oldContainer.refreshRows(oldRow, 1);
                }
            }
            refreshRow(rowWithFocus);
        }


        public void setCellFocus(CellReference<T> cell) {
            setCellFocus(cell.getRowIndex(), cell.getColumnIndexDOM(),
                    escalator.findRowContainer(cell.getElement()));
        }


        public Collection<String> getNavigationEvents() {
            return Arrays.asList(BrowserEvents.KEYDOWN, BrowserEvents.CLICK);
        }


        public void handleNavigationEvent(Event event, CellReference<T> cell) {
            if (event.getType().equals(BrowserEvents.CLICK)) {
                setCellFocus(cell);

                getElement().focus();
            } else if (event.getType().equals(BrowserEvents.KEYDOWN)) {
                int newRow = rowWithFocus;
                RowContainer newContainer = containerWithFocus;
                int newColumn = cellFocusRange.getStart();

                switch (event.getKeyCode()) {
                case KeyCodes.KEY_DOWN:
                    ++newRow;
                    break;
                case KeyCodes.KEY_UP:
                    --newRow;
                    break;
                case KeyCodes.KEY_RIGHT:
                    if (cellFocusRange.getEnd() >= getVisibleColumns().size()) {
                        return;
                    }
                    newColumn = cellFocusRange.getEnd();
                    break;
                case KeyCodes.KEY_LEFT:
                    if (newColumn == 0) {
                        return;
                    }
                    --newColumn;
                    break;
                case KeyCodes.KEY_TAB:
                    if (event.getShiftKey()) {
                        newContainer = getPreviousContainer(containerWithFocus);
                    } else {
                        newContainer = getNextContainer(containerWithFocus);
                    }

                    if (newContainer == containerWithFocus) {
                        return;
                    }
                    break;
                case KeyCodes.KEY_HOME:
                    if (newContainer.getRowCount() > 0) {
                        newRow = 0;
                    }
                    break;
                case KeyCodes.KEY_END:
                    if (newContainer.getRowCount() > 0) {
                        newRow = newContainer.getRowCount() - 1;
                    }
                    break;
                case KeyCodes.KEY_PAGEDOWN:
                case KeyCodes.KEY_PAGEUP:
                    if (newContainer.getRowCount() > 0) {
                        boolean down = event.getKeyCode() == KeyCodes.KEY_PAGEDOWN;





                        int firstVisible = getFirstVisibleRowIndex();
                        int lastVisible = getLastVisibleRowIndex();
                        if (newRow < firstVisible || newRow > lastVisible) {
                            newRow = down ? lastVisible : firstVisible;
                        }



                        int moveFocusBy = Math.max(1, lastVisible
                                - firstVisible - 1);
                        moveFocusBy *= down ? 1 : -1;
                        newRow += moveFocusBy;
                        newRow = Math.max(0, Math.min(
                                newContainer.getRowCount() - 1, newRow));
                    }
                    break;
                default:
                    return;
                }

                if (newContainer != containerWithFocus) {
                    if (newContainer == escalator.getBody()) {
                        newRow = lastFocusedBodyRow;
                    } else if (newContainer == escalator.getHeader()) {
                        newRow = lastFocusedHeaderRow;
                    } else {
                        newRow = lastFocusedFooterRow;
                    }
                } else if (newRow < 0) {
                    newContainer = getPreviousContainer(newContainer);

                    if (newContainer == containerWithFocus) {
                        newRow = 0;
                    } else if (newContainer == escalator.getBody()) {
                        newRow = getLastVisibleRowIndex();
                    } else {
                        newRow = newContainer.getRowCount() - 1;
                    }
                } else if (newRow >= containerWithFocus.getRowCount()) {
                    newContainer = getNextContainer(newContainer);

                    if (newContainer == containerWithFocus) {
                        newRow = containerWithFocus.getRowCount() - 1;
                    } else if (newContainer == escalator.getBody()) {
                        newRow = getFirstVisibleRowIndex();
                    } else {
                        newRow = 0;
                    }
                }

                if (newContainer.getRowCount() == 0) {

                    return;
                }

                event.preventDefault();
                event.stopPropagation();

                setCellFocus(newRow, newColumn, newContainer);
            }

        }

        private RowContainer getPreviousContainer(RowContainer current) {
            if (current == escalator.getFooter()) {
                current = escalator.getBody();
            } else if (current == escalator.getBody()) {
                current = escalator.getHeader();
            } else {
                return current;
            }

            if (current.getRowCount() == 0) {
                return getPreviousContainer(current);
            }
            return current;
        }

        private RowContainer getNextContainer(RowContainer current) {
            if (current == escalator.getHeader()) {
                current = escalator.getBody();
            } else if (current == escalator.getBody()) {
                current = escalator.getFooter();
            } else {
                return current;
            }

            if (current.getRowCount() == 0) {
                return getNextContainer(current);
            }
            return current;
        }

        private void refreshRow(int row) {
            containerWithFocus.refreshRows(row, 1);
        }


        public void offsetRangeBy(int offset) {
            cellFocusRange = cellFocusRange.offsetBy(offset);
        }


        public void rowsAddedToBody(Range added) {
            boolean bodyHasFocus = (containerWithFocus == escalator.getBody());
            boolean insertionIsAboveFocusedCell = (added.getStart() <= rowWithFocus);
            if (bodyHasFocus && insertionIsAboveFocusedCell) {
                rowWithFocus += added.length();
                rowWithFocus = Math.min(rowWithFocus, escalator.getBody()
                        .getRowCount() - 1);
                refreshRow(rowWithFocus);
            }
        }


        public void rowsRemovedFromBody(Range removed) {
            if (containerWithFocus != escalator.getBody()) {
                return;
            } else if (!removed.contains(rowWithFocus)) {
                if (removed.getStart() > rowWithFocus) {
                    return;
                }
                rowWithFocus = rowWithFocus - removed.length();
            } else {
                if (containerWithFocus.getRowCount() > removed.getEnd()) {
                    rowWithFocus = removed.getStart();
                } else if (removed.getStart() > 0) {
                    rowWithFocus = removed.getStart() - 1;
                } else {
                    if (escalator.getHeader().getRowCount() > 0) {
                        rowWithFocus = Math.min(lastFocusedHeaderRow, escalator
                                .getHeader().getRowCount() - 1);
                        containerWithFocus = escalator.getHeader();
                    } else if (escalator.getFooter().getRowCount() > 0) {
                        rowWithFocus = Math.min(lastFocusedFooterRow, escalator
                                .getFooter().getRowCount() - 1);
                        containerWithFocus = escalator.getFooter();
                    }
                }
            }
            refreshRow(rowWithFocus);
        }
    }

    public final class SelectionColumn extends Column<Boolean, T> {

        private boolean initDone = false;
        private boolean selected = false;

        SelectionColumn(final Renderer<Boolean> selectColumnRenderer) {
            super(selectColumnRenderer);
        }

        void initDone() {
            setWidth(-1);

            setEditable(false);

            initDone = true;
        }

        @Override
        protected void setDefaultHeaderContent(HeaderCell selectionCell) {

            final SelectionModel.Multi<T> model = (Multi<T>) getSelectionModel();
            final CheckBox checkBox = GWT.create(CheckBox.class);
            checkBox.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

                @Override
                public void onValueChange(ValueChangeEvent<Boolean> event) {
                    if (event.getValue()) {
                        fireEvent(new SelectAllEvent<T>(model));
                        selected = true;
                    } else {
                        model.deselectAll();
                        selected = false;
                    }
                }
            });
            checkBox.setValue(selected);
            selectionCell.setWidget(checkBox);

            addHeaderKeyUpHandler(new HeaderKeyUpHandler() {
                @Override
                public void onKeyUp(GridKeyUpEvent event) {
                    if (event.getNativeKeyCode() != KeyCodes.KEY_SPACE) {
                        return;
                    }
                    HeaderRow targetHeaderRow = getHeader().getRow(
                            event.getFocusedCell().getRowIndex());
                    if (!targetHeaderRow.isDefault()) {
                        return;
                    }
                    if (event.getFocusedCell().getColumn() == SelectionColumn.this) {


                        checkBox.setValue(!checkBox.getValue(), true);
                    }
                }
            });
        }

        @Override
        public Column<Boolean, T> setWidth(double pixels) {
            if (pixels != getWidth() && initDone) {
                throw new UnsupportedOperationException("The selection "
                        + "column cannot be modified after init");
            } else {
                super.setWidth(pixels);
            }

            return this;
        }

        @Override
        public Boolean getValue(T row) {
            return Boolean.valueOf(isSelected(row));
        }

        @Override
        public Column<Boolean, T> setExpandRatio(int ratio) {
            throw new UnsupportedOperationException(
                    "can't change the expand ratio of the selection column");
        }

        @Override
        public int getExpandRatio() {
            return 0;
        }

        @Override
        public Column<Boolean, T> setMaximumWidth(double pixels) {
            throw new UnsupportedOperationException(
                    "can't change the maximum width of the selection column");
        }

        @Override
        public double getMaximumWidth() {
            return -1;
        }

        @Override
        public Column<Boolean, T> setMinimumWidth(double pixels) {
            throw new UnsupportedOperationException(
                    "can't change the minimum width of the selection column");
        }

        @Override
        public double getMinimumWidth() {
            return -1;
        }

        @Override
        public Column<Boolean, T> setEditable(boolean editable) {
            if (initDone) {
                throw new UnsupportedOperationException(
                        "can't set the selection column editable");
            }
            super.setEditable(editable);
            return this;
        }

    }


    private final class UserSorter {

        private final Timer timer;
        private boolean scheduledMultisort;
        private Column<?, T> column;

        private UserSorter() {
            timer = new Timer() {

                @Override
                public void run() {
                    UserSorter.this.sort(column, scheduledMultisort);
                }
            };
        }


        public void sort(Column<?, ?> column, boolean multisort) {

            if (!columns.contains(column)) {
                throw new IllegalArgumentException(
                        "Given column is not a column in this grid. "
                                + column.toString());
            }

            if (!column.isSortable()) {
                return;
            }

            final SortOrder so = getSortOrder(column);

            if (multisort) {



                if (so != null) {
                    final int idx = sortOrder.indexOf(so);
                    sortOrder.set(idx, so.getOpposite());
                } else {


                    sortOrder.add(new SortOrder(column));
                }

            } else {





                int items = sortOrder.size();
                sortOrder.clear();
                if (so != null && items == 1) {
                    sortOrder.add(so.getOpposite());
                } else {
                    sortOrder.add(new SortOrder(column));
                }
            }



            Grid.this.sort(true);
        }


        public void sortAfterDelay(int delay, boolean multisort) {
            column = eventCell.getColumn();
            scheduledMultisort = multisort;
            timer.schedule(delay);
        }


        public boolean isDelayedSortScheduled() {
            return timer.isRunning();
        }


        public void cancelDelayedSort() {
            timer.cancel();
        }

    }


    private class AutoColumnWidthsRecalculator {
        private double lastCalculatedInnerWidth = -1;

        private final ScheduledCommand calculateCommand = new ScheduledCommand() {

            @Override
            public void execute() {
                if (!isScheduled) {

                    return;
                }

                if (header.markAsDirty || footer.markAsDirty) {
                    if (rescheduleCount < 10) {

                        Scheduler.get().scheduleFinally(this);
                        rescheduleCount++;
                    } else {

                        rescheduleCount = 0;
                        Scheduler.get().scheduleDeferred(this);
                    }
                } else if (dataIsBeingFetched) {
                    Scheduler.get().scheduleDeferred(this);
                } else {
                    calculate();
                }
                lastCalculatedInnerWidth = escalator.getInnerWidth();
            }
        };

        private int rescheduleCount = 0;
        private boolean isScheduled;


        public void schedule() {
            if (!isScheduled) {
                isScheduled = true;
                Scheduler.get().scheduleFinally(calculateCommand);
            }
        }

        private void calculate() {
            isScheduled = false;
            rescheduleCount = 0;

            assert !dataIsBeingFetched : "Trying to calculate column widths even though data is still being fetched.";

            if (columnsAreGuaranteedToBeWiderThanGrid()) {
                applyColumnWidths();
            } else {
                applyColumnWidthsWithExpansion();
            }
        }

        private boolean columnsAreGuaranteedToBeWiderThanGrid() {
            double freeSpace = escalator.getInnerWidth();
            for (Column<?, ?> column : getVisibleColumns()) {
                if (column.getWidth() >= 0) {
                    freeSpace -= column.getWidth();
                } else if (column.getMinimumWidth() >= 0) {
                    freeSpace -= column.getMinimumWidth();
                }
            }
            return freeSpace < 0;
        }

        @SuppressWarnings("boxing")
        private void applyColumnWidths() {



            Map<Integer, Double> selfWidths = new LinkedHashMap<Integer, Double>();
            List<Column<?, T>> columns = getVisibleColumns();
            for (int index = 0; index < columns.size(); index++) {
                selfWidths.put(index, columns.get(index).getWidth());
            }
            Grid.this.escalator.getColumnConfiguration().setColumnWidths(
                    selfWidths);



            Map<Integer, Double> constrainedWidths = new LinkedHashMap<Integer, Double>();
            for (int index = 0; index < columns.size(); index++) {
                Column<?, T> column = columns.get(index);

                boolean hasAutoWidth = column.getWidth() < 0;
                if (!hasAutoWidth) {
                    continue;
                }


                double actualWidth = column.getWidthActual();
                if (actualWidth < getMinWidth(column)) {
                    constrainedWidths.put(index, column.getMinimumWidth());
                } else if (actualWidth > getMaxWidth(column)) {
                    constrainedWidths.put(index, column.getMaximumWidth());
                }
            }
            Grid.this.escalator.getColumnConfiguration().setColumnWidths(
                    constrainedWidths);
        }

        private void applyColumnWidthsWithExpansion() {
            boolean defaultExpandRatios = true;
            int totalRatios = 0;
            double reservedPixels = 0;
            final Set<Column<?, T>> columnsToExpand = new HashSet<Column<?, T>>();
            List<Column<?, T>> nonFixedColumns = new ArrayList<Column<?, T>>();
            Map<Integer, Double> columnSizes = new HashMap<Integer, Double>();
            final List<Column<?, T>> visibleColumns = getVisibleColumns();


            for (Column<?, T> column : visibleColumns) {
                final double widthAsIs = column.getWidth();
                final boolean isFixedWidth = widthAsIs >= 0;
                final double widthFixed = Math.max(widthAsIs,
                        column.getMinimumWidth());
                defaultExpandRatios = defaultExpandRatios
                        && (column.getExpandRatio() == -1 || column == selectionColumn);

                if (isFixedWidth) {
                    columnSizes.put(visibleColumns.indexOf(column), widthFixed);
                    reservedPixels += widthFixed;
                } else {
                    nonFixedColumns.add(column);
                    columnSizes.put(visibleColumns.indexOf(column), -1.0d);
                }
            }

            setColumnSizes(columnSizes);

            for (Column<?, T> column : nonFixedColumns) {
                final int expandRatio = (defaultExpandRatios ? 1 : column
                        .getExpandRatio());
                final double newWidth = column.getWidthActual();
                final double maxWidth = getMaxWidth(column);
                boolean shouldExpand = newWidth < maxWidth && expandRatio > 0
                        && column != selectionColumn;
                if (shouldExpand) {
                    totalRatios += expandRatio;
                    columnsToExpand.add(column);
                }
                reservedPixels += newWidth;
                columnSizes.put(visibleColumns.indexOf(column), newWidth);
            }


            double pixelsToDistribute = escalator.getInnerWidth()
                    - reservedPixels;
            if (pixelsToDistribute <= 0 || totalRatios <= 0) {
                return;
            }


            boolean aColumnHasMaxedOut;
            do {
                aColumnHasMaxedOut = false;
                final double widthPerRatio = pixelsToDistribute / totalRatios;
                final Iterator<Column<?, T>> i = columnsToExpand.iterator();
                while (i.hasNext()) {
                    final Column<?, T> column = i.next();
                    final int expandRatio = getExpandRatio(column,
                            defaultExpandRatios);
                    final int columnIndex = visibleColumns.indexOf(column);
                    final double autoWidth = columnSizes.get(columnIndex);
                    final double maxWidth = getMaxWidth(column);
                    double expandedWidth = autoWidth + widthPerRatio
                            * expandRatio;

                    if (maxWidth <= expandedWidth) {
                        i.remove();
                        totalRatios -= expandRatio;
                        aColumnHasMaxedOut = true;
                        pixelsToDistribute -= maxWidth - autoWidth;
                        columnSizes.put(columnIndex, maxWidth);
                    }
                }
            } while (aColumnHasMaxedOut);

            if (totalRatios <= 0 && columnsToExpand.isEmpty()) {
                setColumnSizes(columnSizes);
                return;
            }
            assert pixelsToDistribute > 0 : "We've run out of pixels to distribute ("
                    + pixelsToDistribute
                    + "px to "
                    + totalRatios
                    + " ratios between " + columnsToExpand.size() + " columns)";
            assert totalRatios > 0 && !columnsToExpand.isEmpty() : "Bookkeeping out of sync. Ratios: "
                    + totalRatios + " Columns: " + columnsToExpand.size();


            final double widthPerRatio;
            int leftOver = 0;
            if (BrowserInfo.get().isIE8() || BrowserInfo.get().isIE9()
                    || BrowserInfo.getBrowserString().contains("PhantomJS")) {


                widthPerRatio = (int) (pixelsToDistribute / totalRatios);
                leftOver = (int) (pixelsToDistribute - widthPerRatio
                        * totalRatios);
            } else {
                widthPerRatio = pixelsToDistribute / totalRatios;
            }
            for (Column<?, T> column : columnsToExpand) {
                final int expandRatio = getExpandRatio(column,
                        defaultExpandRatios);
                final int columnIndex = visibleColumns.indexOf(column);
                final double autoWidth = columnSizes.get(columnIndex);
                double totalWidth = autoWidth + widthPerRatio * expandRatio;
                if (leftOver > 0) {
                    totalWidth += 1;
                    leftOver--;
                }
                columnSizes.put(columnIndex, totalWidth);

                totalRatios -= expandRatio;
            }
            assert totalRatios == 0 : "Bookkeeping error: there were still some ratios left undistributed: "
                    + totalRatios;


            boolean minWidthsCausedReflows;
            do {
                minWidthsCausedReflows = false;


                double pixelsToRemoveFromOtherColumns = 0;
                for (Column<?, T> column : visibleColumns) {


                    double minWidth = getMinWidth(column);
                    final int columnIndex = visibleColumns.indexOf(column);
                    double currentWidth = columnSizes.get(columnIndex);
                    boolean hasAutoWidth = column.getWidth() < 0;
                    if (hasAutoWidth && currentWidth < minWidth) {
                        columnSizes.put(columnIndex, minWidth);
                        pixelsToRemoveFromOtherColumns += (minWidth - currentWidth);
                        minWidthsCausedReflows = true;


                        columnsToExpand.remove(column);
                    }
                }


                totalRatios = 0;
                for (Column<?, ?> column : columnsToExpand) {
                    totalRatios += getExpandRatio(column, defaultExpandRatios);
                }
                final double pixelsToRemovePerRatio = pixelsToRemoveFromOtherColumns
                        / totalRatios;
                for (Column<?, T> column : columnsToExpand) {
                    final double pixelsToRemove = pixelsToRemovePerRatio
                            * getExpandRatio(column, defaultExpandRatios);
                    int colIndex = visibleColumns.indexOf(column);
                    columnSizes.put(colIndex, columnSizes.get(colIndex)
                            - pixelsToRemove);
                }

            } while (minWidthsCausedReflows);


            setColumnSizes(columnSizes);
        }

        private void setColumnSizes(Map<Integer, Double> columnSizes) {

            escalator.getColumnConfiguration().setColumnWidths(columnSizes);
        }

        private int getExpandRatio(Column<?, ?> column,
                boolean defaultExpandRatios) {
            int expandRatio = column.getExpandRatio();
            if (expandRatio > 0) {
                return expandRatio;
            } else if (expandRatio < 0) {
                assert defaultExpandRatios : "No columns should've expanded";
                return 1;
            } else {
                assert false : "this method should've not been called at all if expandRatio is 0";
                return 0;
            }
        }


        private double getMaxWidth(Column<?, ?> column) {
            double maxWidth = column.getMaximumWidth();
            if (maxWidth >= 0) {
                return maxWidth;
            } else {
                return Double.MAX_VALUE;
            }
        }


        private double getMinWidth(Column<?, ?> column) {
            double minWidth = column.getMinimumWidth();
            if (minWidth >= 0) {
                return minWidth;
            } else {
                return Double.MIN_VALUE;
            }
        }


        public boolean isScheduled() {
            return isScheduled;
        }
    }

    private class GridSpacerUpdater implements SpacerUpdater {

        private static final String STRIPE_CLASSNAME = "stripe";

        private final Map<Element, Widget> elementToWidgetMap = new HashMap<Element, Widget>();

        @Override
        public void init(Spacer spacer) {
            initTheming(spacer);

            int rowIndex = spacer.getRow();

            Widget detailsWidget = null;
            try {
                detailsWidget = detailsGenerator.getDetails(rowIndex);
            } catch (Throwable e) {
                getLogger().log(
                        Level.SEVERE,
                        "Exception while generating details for row "
                                + rowIndex, e);
            }

            final double spacerHeight;
            Element spacerElement = spacer.getElement();
            if (detailsWidget == null) {
                spacerElement.removeAllChildren();
                spacerHeight = DETAILS_ROW_INITIAL_HEIGHT;
            } else {
                Element element = detailsWidget.getElement();
                spacerElement.appendChild(element);
                setParent(detailsWidget, Grid.this);
                Widget previousWidget = elementToWidgetMap.put(element,
                        detailsWidget);

                assert previousWidget == null : "Overwrote a pre-existing widget on row "
                        + rowIndex + " without proper removal first.";


                double requiredHeightBoundingClientRectDouble = WidgetUtil
                        .getRequiredHeightBoundingClientRectDouble(element);
                double borderTopAndBottomHeight = WidgetUtil
                        .getBorderTopAndBottomThickness(spacerElement);
                double measuredHeight = requiredHeightBoundingClientRectDouble
                        + borderTopAndBottomHeight;
                assert getElement().isOrHasChild(spacerElement) : "The spacer element wasn't in the DOM during measurement, but was assumed to be.";
                spacerHeight = measuredHeight;
            }

            escalator.getBody().setSpacer(rowIndex, spacerHeight);
        }

        @Override
        public void destroy(Spacer spacer) {
            Element spacerElement = spacer.getElement();

            assert getElement().isOrHasChild(spacerElement) : "Trying "
                    + "to destroy a spacer that is not connected to this "
                    + "Grid's DOM. (row: " + spacer.getRow() + ", element: "
                    + spacerElement + ")";

            Widget detailsWidget = elementToWidgetMap.remove(spacerElement
                    .getFirstChildElement());

            if (detailsWidget != null) {


                assert spacerElement.getFirstChild() != null : "The "
                        + "details row to destroy did not contain a widget - "
                        + "probably removed by something else without "
                        + "permission? (row: " + spacer.getRow()
                        + ", element: " + spacerElement + ")";

                setParent(detailsWidget, null);
                spacerElement.removeAllChildren();
            }
        }

        private void initTheming(Spacer spacer) {
            Element spacerRoot = spacer.getElement();

            if (spacer.getRow() % 2 == 1) {
                spacerRoot.getParentElement().addClassName(STRIPE_CLASSNAME);
            } else {
                spacerRoot.getParentElement().removeClassName(STRIPE_CLASSNAME);
            }
        }

    }


    private static class Sidebar extends Composite {

        private final ClickHandler openCloseButtonHandler = new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                if (!isOpen()) {
                    open();
                } else {
                    close();
                }
            }
        };

        private final FlowPanel rootContainer;

        private final FlowPanel content;

        private final MenuBar menuBar;

        private final Button openCloseButton;

        private final Grid<?> grid;

        private NativePreviewHandler clickOutsideToCloseHandler = new NativePreviewHandler() {

            @Override
            public void onPreviewNativeEvent(NativePreviewEvent event) {
                if (event.getTypeInt() != Event.ONMOUSEDOWN) {
                    return;
                }


                EventTarget clickTarget = event.getNativeEvent()
                        .getEventTarget();
                if (!rootContainer.getElement().isOrHasChild(
                        Element.as(clickTarget))) {
                    close();
                }
            }
        };

        private HandlerRegistration clickOutsideToCloseHandlerRegistration;

        private Sidebar(Grid<?> grid) {
            this.grid = grid;

            rootContainer = new FlowPanel();
            initWidget(rootContainer);

            openCloseButton = new Button();
            openCloseButton.addClickHandler(openCloseButtonHandler);

            rootContainer.add(openCloseButton);

            content = new FlowPanel() {
                @Override
                public boolean remove(Widget w) {

                    boolean removed = super.remove(w);
                    if (removed) {
                        updateVisibility();
                    }

                    return removed;
                }
            };

            menuBar = new MenuBar(true) {

                @Override
                public MenuItem insertItem(MenuItem item, int beforeIndex)
                        throws IndexOutOfBoundsException {
                    if (getParent() == null) {
                        content.insert(this, 0);
                        updateVisibility();
                    }
                    return super.insertItem(item, beforeIndex);
                }

                @Override
                public void removeItem(MenuItem item) {
                    super.removeItem(item);
                    if (getItems().isEmpty()) {
                        menuBar.removeFromParent();
                    }
                }

                @Override
                public void onBrowserEvent(Event event) {



                    if (event.getTypeInt() == Event.ONKEYDOWN
                            && event.getKeyCode() == KeyCodes.KEY_ENTER) {
                        final MenuItem item = getSelectedItem();
                        super.onBrowserEvent(event);
                        Scheduler.get().scheduleDeferred(
                                new ScheduledCommand() {

                                    @Override
                                    public void execute() {
                                        selectItem(item);
                                        focus();
                                    }
                                });

                    } else {
                        super.onBrowserEvent(event);
                    }
                }

            };
            KeyDownHandler keyDownHandler = new KeyDownHandler() {

                @Override
                public void onKeyDown(KeyDownEvent event) {
                    if (event.getNativeKeyCode() == KeyCodes.KEY_ESCAPE) {
                        close();
                    }
                }
            };
            openCloseButton.addDomHandler(keyDownHandler,
                    KeyDownEvent.getType());
            menuBar.addDomHandler(keyDownHandler, KeyDownEvent.getType());
        }


        public void open() {
            if (!isOpen() && isInDOM()) {
                addStyleName("open");
                removeStyleName("closed");
                rootContainer.add(content);
                clickOutsideToCloseHandlerRegistration = Event
                        .addNativePreviewHandler(clickOutsideToCloseHandler);
            }
            openCloseButton.setHeight("");
        }


        public void close() {
            if (isOpen()) {
                removeStyleName("open");
                addStyleName("closed");
                content.removeFromParent();

                setHeightToHeaderCellHeight();
                if (clickOutsideToCloseHandlerRegistration != null) {
                    clickOutsideToCloseHandlerRegistration.removeHandler();
                    clickOutsideToCloseHandlerRegistration = null;
                }
            }
        }


        public boolean isOpen() {
            return content.getParent() == rootContainer;
        }


        public void add(Widget widget) {
            content.add(widget);
            updateVisibility();
        }


        public void remove(Widget widget) {
            content.remove(widget);

        }


        public void insert(Widget widget, int beforeIndex) {
            content.insert(widget, beforeIndex);
            updateVisibility();
        }

        @Override
        public void setStylePrimaryName(String styleName) {
            super.setStylePrimaryName(styleName);
            content.setStylePrimaryName(styleName + "-content");
            openCloseButton.setStylePrimaryName(styleName + "-button");
            if (isOpen()) {
                addStyleName("open");
                removeStyleName("closed");
            } else {
                removeStyleName("open");
                addStyleName("closed");
            }
        }

        private void setHeightToHeaderCellHeight() {
            RowContainer header = grid.escalator.getHeader();
            if (header.getRowCount() == 0
                    || !header.getRowElement(0).hasChildNodes()) {
                getLogger()
                        .info("No header cell available when calculating sidebar button height");
                openCloseButton.setHeight(header.getDefaultRowHeight() + "px");

                return;
            }

            Element firstHeaderCell = header.getRowElement(0)
                    .getFirstChildElement();
            double height = WidgetUtil
                    .getRequiredHeightBoundingClientRectDouble(firstHeaderCell)
                    - (WidgetUtil.measureVerticalBorder(getElement()) / 2);
            openCloseButton.setHeight(height + "px");
        }

        private void updateVisibility() {
            final boolean hasWidgets = content.getWidgetCount() > 0;
            final boolean isVisible = isInDOM();
            if (isVisible && !hasWidgets) {
                Grid.setParent(this, null);
                getElement().removeFromParent();
            } else if (!isVisible && hasWidgets) {
                close();
                grid.getElement().appendChild(getElement());
                Grid.setParent(this, grid);

                setHeightToHeaderCellHeight();
            }
        }

        private boolean isInDOM() {
            return getParent() != null;
        }

        @Override
        protected void onAttach() {
            super.onAttach();


            Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                @Override
                public void execute() {
                    setHeightToHeaderCellHeight();
                }
            });
        }
    }


    private final class ColumnHider {


        private HashMap<Column<?, T>, MenuItem> columnToHidingToggleMap = new HashMap<Grid.Column<?, T>, MenuItem>();


        private boolean hidingColumn;

        private void updateColumnHidable(final Column<?, T> column) {
            if (column.isHidable()) {
                MenuItem toggle = columnToHidingToggleMap.get(column);
                if (toggle == null) {
                    toggle = createToggle(column);
                }
                toggle.setStyleName("hidden", column.isHidden());
            } else if (columnToHidingToggleMap.containsKey(column)) {
                sidebar.menuBar.removeItem((columnToHidingToggleMap
                        .remove(column)));
            }
            updateTogglesOrder();
        }

        private MenuItem createToggle(final Column<?, T> column) {
            MenuItem toggle = new MenuItem(createHTML(column), true,
                    new ScheduledCommand() {

                        @Override
                        public void execute() {
                            hidingColumn = true;
                            column.setHidden(!column.isHidden(), true);
                            hidingColumn = false;
                        }
                    });
            toggle.addStyleName("column-hiding-toggle");
            columnToHidingToggleMap.put(column, toggle);
            return toggle;
        }

        private String createHTML(Column<?, T> column) {
            final StringBuffer buf = new StringBuffer();
            buf.append("<span class=\"");
            if (column.isHidden()) {
                buf.append("v-off");
            } else {
                buf.append("v-on");
            }
            buf.append("\"><div>");
            String caption = column.getHidingToggleCaption();
            if (caption == null) {
                caption = column.headerCaption;
            }
            buf.append(caption);
            buf.append("</div></span>");

            return buf.toString();
        }

        private void updateTogglesOrder() {
            if (!hidingColumn) {
                int lastIndex = 0;
                for (Column<?, T> column : getColumns()) {
                    if (column.isHidable()) {
                        final MenuItem menuItem = columnToHidingToggleMap
                                .get(column);
                        sidebar.menuBar.removeItem(menuItem);
                        sidebar.menuBar.insertItem(menuItem, lastIndex++);
                    }
                }
            }
        }

        private void updateHidingToggle(Column<?, T> column) {
            if (column.isHidable()) {
                MenuItem toggle = columnToHidingToggleMap.get(column);
                toggle.setHTML(createHTML(column));
                toggle.setStyleName("hidden", column.isHidden());
            } 
        }

        private void removeColumnHidingToggle(Column<?, T> column) {
            sidebar.menuBar.removeItem(columnToHidingToggleMap.get(column));
        }

    }


    private Escalator escalator = GWT.create(Escalator.class);

    private final Header header = GWT.create(Header.class);

    private final Footer footer = GWT.create(Footer.class);

    private final Sidebar sidebar = new Sidebar(this);


    private List<Column<?, T>> columns = new ArrayList<Column<?, T>>();


    private DataSource<T> dataSource;


    private Range currentDataAvailable = Range.withLength(0, 0);


    private int frozenColumnCount = 0;


    private List<SortOrder> sortOrder = new ArrayList<SortOrder>();

    private Renderer<Boolean> selectColumnRenderer = null;

    private SelectionColumn selectionColumn;

    private String rowStripeStyleName;
    private String rowHasDataStyleName;
    private String rowSelectedStyleName;
    private String cellFocusStyleName;
    private String rowFocusStyleName;


    private SelectionModel<T> selectionModel;

    protected final CellFocusHandler cellFocusHandler;

    private final UserSorter sorter = new UserSorter();

    private final Editor<T> editor = GWT.create(Editor.class);

    private boolean dataIsBeingFetched = false;


    private Cell cellOnPrevMouseDown;


    private final AutoColumnWidthsRecalculator autoColumnWidthsRecalculator = new AutoColumnWidthsRecalculator();

    private boolean enabled = true;
    private double lastTouchEventTime = 0;
    private int lastTouchEventX = -1;
    private int lastTouchEventY = -1;
    private int lastTouchEventRow = -1;

    private DetailsGenerator detailsGenerator = DetailsGenerator.NULL;
    private GridSpacerUpdater gridSpacerUpdater = new GridSpacerUpdater();

    private Set<Integer> visibleDetails = new HashSet<Integer>();

    private boolean columnReorderingAllowed;

    private ColumnHider columnHider = new ColumnHider();

    private DragAndDropHandler dndHandler = new DragAndDropHandler();

    private AutoScroller autoScroller = new AutoScroller(this);

    private DragAndDropHandler.DragAndDropCallback headerCellDndCallback = new DragAndDropHandler.DragAndDropCallback() {

        private final AutoScrollerCallback autoScrollerCallback = new AutoScrollerCallback() {

            @Override
            public void onAutoScroll(int scrollDiff) {
                autoScrollX = scrollDiff;
                onDragUpdate(null);
            }

            @Override
            public void onAutoScrollReachedMin() {

                autoScrollX = 0;
                updateDragDropMarker(clientX);
            }

            @Override
            public void onAutoScrollReachedMax() {

                autoScrollX = 0;
                updateDragDropMarker(clientX);
            }
        };

        private Element table;
        private Element tableHeader;

        private Element dropMarker;

        private Element dragElement;

        private int latestColumnDropIndex;

        private final TreeMap<Double, Integer> possibleDropPositions = new TreeMap<Double, Integer>();

        private HandlerRegistration columnSortPreventRegistration;

        private int clientX;


        private int autoScrollX;


        private int focusedColumnIndex;


        private double dropMarkerWidthOffset;

        private void initHeaderDragElementDOM() {
            if (table == null) {
                tableHeader = DOM.createTHead();
                dropMarker = DOM.createDiv();
                tableHeader.appendChild(dropMarker);
                table = DOM.createTable();
                table.appendChild(tableHeader);
                table.setClassName("header-drag-table");
            }


            tableHeader.setClassName(escalator.getHeader().getElement()
                    .getClassName());
            dropMarker.setClassName(getStylePrimaryName() + "-drop-marker");
            int topOffset = 0;
            for (int i = 0; i < eventCell.getRowIndex(); i++) {
                topOffset += escalator.getHeader().getRowElement(i)
                        .getFirstChildElement().getOffsetHeight();
            }
            tableHeader.getStyle().setTop(topOffset, Unit.PX);

            getElement().appendChild(table);

            dropMarkerWidthOffset = WidgetUtil
                    .getRequiredWidthBoundingClientRectDouble(dropMarker) / 2;
        }

        @Override
        public void onDragUpdate(NativePreviewEvent event) {
            if (event != null) {
                clientX = WidgetUtil.getTouchOrMouseClientX(event
                        .getNativeEvent());
                autoScrollX = 0;
            }
            resolveDragElementHorizontalPosition(clientX);
            updateDragDropMarker(clientX);
        }

        private void updateDragDropMarker(final int clientX) {
            final double scrollLeft = getScrollLeft();
            final double cursorXCoordinate = clientX
                    - escalator.getHeader().getElement().getAbsoluteLeft();
            final Entry<Double, Integer> cellEdgeOnRight = possibleDropPositions
                    .ceilingEntry(cursorXCoordinate);
            final Entry<Double, Integer> cellEdgeOnLeft = possibleDropPositions
                    .floorEntry(cursorXCoordinate);
            final double diffToRightEdge = cellEdgeOnRight == null ? Double.MAX_VALUE
                    : cellEdgeOnRight.getKey() - cursorXCoordinate;
            final double diffToLeftEdge = cellEdgeOnLeft == null ? Double.MAX_VALUE
                    : cursorXCoordinate - cellEdgeOnLeft.getKey();

            double dropMarkerLeft = 0 - scrollLeft;
            if (diffToRightEdge > diffToLeftEdge) {
                latestColumnDropIndex = cellEdgeOnLeft.getValue();
                dropMarkerLeft += cellEdgeOnLeft.getKey();
            } else {
                latestColumnDropIndex = cellEdgeOnRight.getValue();
                dropMarkerLeft += cellEdgeOnRight.getKey();
            }

            dropMarkerLeft += autoScrollX;

            final double frozenColumnsWidth = getFrozenColumnsWidth();
            final double rightBoundaryForDrag = getSidebarBoundaryComparedTo(dropMarkerLeft);
            final int visibleColumns = getVisibleColumns().size();




            if (latestColumnDropIndex == visibleColumns
                    && rightBoundaryForDrag < dropMarkerLeft
                    && dropMarkerLeft <= escalator.getInnerWidth()) {
                dropMarkerLeft = rightBoundaryForDrag - dropMarkerWidthOffset;
            }


            else if (dropMarkerLeft < frozenColumnsWidth
                    || dropMarkerLeft > Math.min(rightBoundaryForDrag,
                            escalator.getInnerWidth()) || dropMarkerLeft < 0) {
                dropMarkerLeft = -10000000;
            }
            dropMarker.getStyle().setLeft(dropMarkerLeft, Unit.PX);
        }

        private void resolveDragElementHorizontalPosition(final int clientX) {
            double left = clientX - table.getAbsoluteLeft();



            final Double leftBound = possibleDropPositions.firstKey();
            final Double rightBound = possibleDropPositions.lastKey();
            final double scrollLeft = getScrollLeft();
            if (left + scrollLeft < leftBound) {
                left = leftBound - scrollLeft + autoScrollX;
            } else if (left + scrollLeft > rightBound) {
                left = rightBound - scrollLeft + autoScrollX;
            }


            final double sidebarBoundary = getSidebarBoundaryComparedTo(left);
            final double gridBoundary = escalator.getInnerWidth();
            final double rightBoundary = Math
                    .min(sidebarBoundary, gridBoundary);


            final int frozenColumnsWidth = (int) getFrozenColumnsWidth();

            left = Math.max(frozenColumnsWidth, Math.min(left, rightBoundary));

            left -= dragElement.getClientWidth() / 2;
            dragElement.getStyle().setLeft(left, Unit.PX);
        }

        private boolean isSidebarOnDraggedRow() {
            return eventCell.getRowIndex() == 0 && getSidebar().isInDOM()
                    && !getSidebar().isOpen();
        }


        private double getSidebarBoundaryComparedTo(double left) {
            if (isSidebarOnDraggedRow()) {
                double absoluteLeft = left + getElement().getAbsoluteLeft();
                double sidebarLeft = getSidebar().getElement()
                        .getAbsoluteLeft();
                double diff = absoluteLeft - sidebarLeft;

                if (diff > 0) {
                    return left - diff;
                }
            }
            return Double.MAX_VALUE;
        }

        @Override
        public boolean onDragStart(NativeEvent startingEvent) {
            calculatePossibleDropPositions();

            if (possibleDropPositions.isEmpty()) {
                return false;
            }

            initHeaderDragElementDOM();

            dragElement = DOM.clone(eventCell.getElement(), true);
            dragElement.getStyle().clearWidth();
            dropMarker.getStyle().setProperty("height",
                    dragElement.getStyle().getHeight());
            tableHeader.appendChild(dragElement);

            eventCell.getElement().addClassName("dragged");

            dragElement.addClassName("dragged-column-header");


            autoScroller.setScrollArea(60);
            autoScroller.start(startingEvent, ScrollAxis.HORIZONTAL,
                    autoScrollerCallback);
            return true;
        }

        @Override
        public void onDragEnd() {
            table.removeFromParent();
            dragElement.removeFromParent();
            eventCell.getElement().removeClassName("dragged");
        }

        @Override
        public void onDrop() {
            final int draggedColumnIndex = eventCell.getColumnIndex();
            final int colspan = header.getRow(eventCell.getRowIndex())
                    .getCell(eventCell.getColumn()).getColspan();
            if (latestColumnDropIndex != draggedColumnIndex
                    && latestColumnDropIndex != (draggedColumnIndex + colspan)) {
                List<Column<?, T>> columns = getColumns();
                List<Column<?, T>> reordered = new ArrayList<Column<?, T>>();
                if (draggedColumnIndex < latestColumnDropIndex) {
                    reordered.addAll(columns.subList(0, draggedColumnIndex));
                    reordered.addAll(columns.subList(draggedColumnIndex
                            + colspan, latestColumnDropIndex));
                    reordered.addAll(columns.subList(draggedColumnIndex,
                            draggedColumnIndex + colspan));
                    reordered.addAll(columns.subList(latestColumnDropIndex,
                            columns.size()));
                } else {
                    reordered.addAll(columns.subList(0, latestColumnDropIndex));
                    reordered.addAll(columns.subList(draggedColumnIndex,
                            draggedColumnIndex + colspan));
                    reordered.addAll(columns.subList(latestColumnDropIndex,
                            draggedColumnIndex));
                    reordered.addAll(columns.subList(draggedColumnIndex
                            + colspan, columns.size()));
                }
                reordered.remove(selectionColumn); 



                Cell focusedCell = cellFocusHandler.getFocusedCell();
                if (focusedCell != null) {

                    focusedColumnIndex = getColumns().indexOf(
                            getVisibleColumn(focusedCell.getColumn()));
                }

                Column<?, T>[] array = reordered.toArray(new Column[reordered
                        .size()]);
                setColumnOrder(array);
                transferCellFocusOnDrop();
            } 
        }

        private void transferCellFocusOnDrop() {
            final Cell focusedCell = cellFocusHandler.getFocusedCell();
            if (focusedCell != null) {
                final int focusedColumnIndexDOM = focusedCell.getColumn();
                final int focusedRowIndex = focusedCell.getRow();
                final int draggedColumnIndex = eventCell.getColumnIndex();

                final RowContainer rowContainer = escalator
                        .findRowContainer(focusedCell.getElement());
                if (focusedColumnIndex == draggedColumnIndex) {

                    int adjustedDropIndex = latestColumnDropIndex > draggedColumnIndex ? latestColumnDropIndex - 1
                            : latestColumnDropIndex;

                    adjustedDropIndex = getVisibleColumns().indexOf(
                            getColumn(adjustedDropIndex));
                    cellFocusHandler.setCellFocus(focusedRowIndex,
                            adjustedDropIndex, rowContainer);
                } else if (latestColumnDropIndex <= focusedColumnIndex
                        && draggedColumnIndex > focusedColumnIndex) {
                    cellFocusHandler.setCellFocus(focusedRowIndex,
                            focusedColumnIndexDOM + 1, rowContainer);
                } else if (latestColumnDropIndex > focusedColumnIndex
                        && draggedColumnIndex < focusedColumnIndex) {
                    cellFocusHandler.setCellFocus(focusedRowIndex,
                            focusedColumnIndexDOM - 1, rowContainer);
                }
            }
        }

        @Override
        public void onDragCancel() {


            if (columnSortPreventRegistration == null) {
                columnSortPreventRegistration = Event
                        .addNativePreviewHandler(new NativePreviewHandler() {

                            @Override
                            public void onPreviewNativeEvent(
                                    NativePreviewEvent event) {
                                if (event.getTypeInt() == Event.ONCLICK) {
                                    event.cancel();
                                    event.getNativeEvent().preventDefault();
                                    columnSortPreventRegistration
                                            .removeHandler();
                                    columnSortPreventRegistration = null;
                                }
                            }
                        });
            }
            autoScroller.stop();
        }

        private double getFrozenColumnsWidth() {
            double value = getMultiSelectColumnWidth();
            for (int i = 0; i < getFrozenColumnCount(); i++) {
                value += getColumn(i).getWidthActual();
            }
            return value;
        }

        private double getMultiSelectColumnWidth() {
            if (getSelectionModel().getSelectionColumnRenderer() != null) {


                return escalator.getHeader().getElement()
                        .getFirstChildElement().getFirstChildElement()
                        .getOffsetWidth();
            }
            return 0.0;
        }


        private int getSelectionAndFrozenColumnCount() {


            if (getSelectionModel().getSelectionColumnRenderer() != null) {
                return Math.max(0, getFrozenColumnCount()) + 1;
            } else {
                return Math.max(0, getFrozenColumnCount());
            }
        }

        @SuppressWarnings("boxing")
        private void calculatePossibleDropPositions() {
            possibleDropPositions.clear();

            final int draggedColumnIndex = eventCell.getColumnIndex();
            final StaticRow<?> draggedCellRow = header.getRow(eventCell
                    .getRowIndex());
            final int draggedColumnRightIndex = draggedColumnIndex
                    + draggedCellRow.getCell(eventCell.getColumn())
                            .getColspan();
            final int frozenColumns = getSelectionAndFrozenColumnCount();
            final Range draggedCellRange = Range.between(draggedColumnIndex,
                    draggedColumnRightIndex);

            int leftBound = -1;
            int rightBound = getColumnCount() + 1;

            final HashSet<Integer> unavailableColumnDropIndices = new HashSet<Integer>();
            final List<StaticRow<?>> rows = new ArrayList<StaticRow<?>>();
            rows.addAll(header.getRows());
            rows.addAll(footer.getRows());
            for (StaticRow<?> row : rows) {
                if (!row.hasSpannedCells()) {
                    continue;
                }
                final boolean isDraggedCellRow = row.equals(draggedCellRow);
                for (int cellColumnIndex = frozenColumns; cellColumnIndex < getColumnCount(); cellColumnIndex++) {
                    StaticCell cell = row.getCell(getColumn(cellColumnIndex));
                    int colspan = cell.getColspan();
                    if (colspan <= 1) {
                        continue;
                    }
                    final int cellColumnRightIndex = cellColumnIndex + colspan;
                    final Range cellRange = Range.between(cellColumnIndex,
                            cellColumnRightIndex);
                    final boolean intersects = draggedCellRange
                            .intersects(cellRange);
                    if (intersects && !isDraggedCellRow) {


                        if (cellRange.isSubsetOf(draggedCellRange)) {
                            cellColumnIndex = cellColumnRightIndex - 1;
                            continue;
                        }

                        if (!draggedCellRange.isSubsetOf(cellRange)) {
                            return;
                        }


                        if (cellColumnIndex <= draggedColumnIndex
                                && cellColumnIndex > leftBound) {
                            leftBound = cellColumnIndex;
                        }
                        if (cellColumnRightIndex < rightBound) {
                            rightBound = cellColumnRightIndex;
                        }
                        cellColumnIndex = cellColumnRightIndex - 1;
                    }

                    else { 

                        while (colspan > 1) {
                            cellColumnIndex++;
                            colspan--;
                            unavailableColumnDropIndices.add(cellColumnIndex);
                        }
                    }
                }
            }

            if (leftBound == (rightBound - 1)) {
                return;
            }

            double position = getFrozenColumnsWidth();

            for (int i = frozenColumns; i < getColumnCount(); i++) {
                Column<?, T> column = getColumn(i);
                if (!unavailableColumnDropIndices.contains(i)
                        && !column.isHidden()) {
                    if (leftBound != -1) {
                        if (i >= leftBound && i <= rightBound) {
                            possibleDropPositions.put(position, i);
                        }
                    } else {
                        possibleDropPositions.put(position, i);
                    }
                }
                position += column.getWidthActual();
            }

            if (leftBound == -1) {

                possibleDropPositions.put(position, getColumnCount());
            }
        }

    };


    public enum SelectionMode {


        SINGLE {

            @Override
            protected <T> SelectionModel<T> createModel() {
                return GWT.create(SelectionModelSingle.class);
            }
        },


        MULTI {

            @Override
            protected <T> SelectionModel<T> createModel() {
                return GWT.create(SelectionModelMulti.class);
            }
        },


        NONE {

            @Override
            protected <T> SelectionModel<T> createModel() {
                return GWT.create(SelectionModelNone.class);
            }
        };

        protected abstract <T> SelectionModel<T> createModel();
    }


    public static abstract class Column<C, T> {


        private final class DefaultTextRenderer implements Renderer<Object> {
            boolean warned = false;
            private final String DEFAULT_RENDERER_WARNING = "This column uses a dummy default TextRenderer. "
                    + "A more suitable renderer should be set using the setRenderer() method.";

            @Override
            public void render(RendererCellReference cell, Object data) {
                if (!warned && !(data instanceof String)) {
                    getLogger().warning(
                            Column.this.toString() + ": "
                                    + DEFAULT_RENDERER_WARNING);
                    warned = true;
                }

                final String text;
                if (data == null) {
                    text = "";
                } else {
                    text = data.toString();
                }

                cell.getElement().setInnerText(text);
            }
        }


        private Grid<T> grid;


        private double widthUser = GridConstants.DEFAULT_COLUMN_WIDTH_PX;


        private Renderer<? super C> bodyRenderer;

        private boolean sortable = false;

        private boolean editable = true;

        private boolean hidden = false;

        private boolean hidable = false;

        private String headerCaption = "";

        private String hidingToggleCaption = null;

        private double minimumWidthPx = GridConstants.DEFAULT_MIN_WIDTH;
        private double maximumWidthPx = GridConstants.DEFAULT_MAX_WIDTH;
        private int expandRatio = GridConstants.DEFAULT_EXPAND_RATIO;


        public Column() {
            setRenderer(new DefaultTextRenderer());
        }


        public Column(String caption) throws IllegalArgumentException {
            this();
            setHeaderCaption(caption);
        }


        public Column(Renderer<? super C> renderer)
                throws IllegalArgumentException {
            setRenderer(renderer);
        }


        public Column(String caption, Renderer<? super C> renderer)
                throws IllegalArgumentException {
            this(renderer);
            setHeaderCaption(caption);
        }


        private void setGrid(Grid<T> grid) {
            if (this.grid != null && grid != null) {

                throw new IllegalStateException("Column already is attached "
                        + "to a grid. Remove the column first from the grid "
                        + "and then add it. (in: " + toString() + ")");
            }

            if (this.grid != null) {
                this.grid.recalculateColumnWidths();
            }
            this.grid = grid;
            if (this.grid != null) {
                this.grid.recalculateColumnWidths();
            }
        }


        public Column<C, T> setHeaderCaption(String caption) {
            if (caption == null) {
                throw new IllegalArgumentException("Caption cannot be null.");
            }

            if (!this.headerCaption.equals(caption)) {
                this.headerCaption = caption;
                if (grid != null) {
                    updateHeader();
                }
            }

            return this;
        }

        private void updateHeader() {
            HeaderRow row = grid.getHeader().getDefaultRow();
            if (row != null) {
                row.getCell(this).setText(headerCaption);
                if (isHidable()) {
                    grid.columnHider.updateHidingToggle(this);
                }
            }
        }


        public abstract C getValue(T row);


        public Renderer<? super C> getRenderer() {
            return bodyRenderer;
        }


        public Column<C, T> setRenderer(Renderer<? super C> renderer)
                throws IllegalArgumentException {
            if (renderer == null) {
                throw new IllegalArgumentException("Renderer cannot be null.");
            }

            if (renderer != bodyRenderer) {
                bodyRenderer = renderer;

                if (grid != null) {
                    grid.refreshBody();
                }
            }
            return this;
        }


        public Column<C, T> setWidth(double pixels) {
            if (!WidgetUtil.pixelValuesEqual(widthUser, pixels)) {
                widthUser = pixels;
                if (!isHidden()) {
                    scheduleColumnWidthRecalculator();
                }
            }
            return this;
        }

        void doSetWidth(double pixels) {
            assert !isHidden() : "applying width for a hidden column";
            if (grid != null) {
                int index = grid.getVisibleColumns().indexOf(this);
                ColumnConfiguration conf = grid.escalator
                        .getColumnConfiguration();
                conf.setColumnWidth(index, pixels);
            }
        }


        public double getWidth() {
            return widthUser;
        }


        public double getWidthActual() {
            if (isHidden()) {
                return 0;
            }
            return grid.escalator.getColumnConfiguration()
                    .getColumnWidthActual(
                            grid.getVisibleColumns().indexOf(this));
        }

        void reapplyWidth() {
            scheduleColumnWidthRecalculator();
        }


        public Column<C, T> setSortable(boolean sortable) {
            if (this.sortable != sortable) {
                this.sortable = sortable;
                if (grid != null) {
                    grid.refreshHeader();
                }
            }

            return this;
        }


        public boolean isSortable() {
            return sortable;
        }


        public void setHidden(boolean hidden) {
            setHidden(hidden, false);
        }

        private void setHidden(boolean hidden, boolean userOriginated) {
            if (this.hidden != hidden) {
                if (hidden) {
                    grid.escalator.getColumnConfiguration().removeColumns(
                            grid.getVisibleColumns().indexOf(this), 1);
                    this.hidden = hidden;
                } else {
                    this.hidden = hidden;

                    final int columnIndex = grid.getVisibleColumns().indexOf(
                            this);
                    grid.escalator.getColumnConfiguration().insertColumns(
                            columnIndex, 1);




                    int gridFrozenColumns = grid.getFrozenColumnCount();
                    int escalatorFrozenColumns = grid.escalator
                            .getColumnConfiguration().getFrozenColumnCount();
                    if (gridFrozenColumns > escalatorFrozenColumns
                            && escalatorFrozenColumns == columnIndex) {
                        grid.escalator.getColumnConfiguration()
                                .setFrozenColumnCount(++escalatorFrozenColumns);
                    }
                }
                grid.columnHider.updateHidingToggle(this);
                grid.header.updateColSpans();
                grid.footer.updateColSpans();
                scheduleColumnWidthRecalculator();
                this.grid.fireEvent(new ColumnVisibilityChangeEvent<T>(this,
                        hidden, userOriginated));
            }
        }


        public boolean isHidden() {
            return hidden;
        }


        public void setHidable(boolean hidable) {
            if (this.hidable != hidable) {
                this.hidable = hidable;
                grid.columnHider.updateColumnHidable(this);
            }
        }


        public boolean isHidable() {
            return hidable;
        }


        public void setHidingToggleCaption(String hidingToggleCaption) {
            this.hidingToggleCaption = hidingToggleCaption;
            if (isHidable()) {
                grid.columnHider.updateHidingToggle(this);
            }
        }


        public String getHidingToggleCaption() {
            return hidingToggleCaption;
        }

        @Override
        public String toString() {
            String details = "";

            if (headerCaption != null && !headerCaption.isEmpty()) {
                details += "header:\"" + headerCaption + "\" ";
            } else {
                details += "header:empty ";
            }

            if (grid != null) {
                int index = grid.getColumns().indexOf(this);
                if (index != -1) {
                    details += "attached:#" + index + " ";
                } else {
                    details += "attached:unindexed ";
                }
            } else {
                details += "detached ";
            }

            details += "sortable:" + sortable + " ";

            return getClass().getSimpleName() + "[" + details.trim() + "]";
        }


        public Column<C, T> setMinimumWidth(double pixels) {
            final double maxwidth = getMaximumWidth();
            if (pixels >= 0 && pixels > maxwidth && maxwidth >= 0) {
                throw new IllegalArgumentException("New minimum width ("
                        + pixels + ") was greater than maximum width ("
                        + maxwidth + ")");
            }

            if (minimumWidthPx != pixels) {
                minimumWidthPx = pixels;
                scheduleColumnWidthRecalculator();
            }
            return this;
        }


        public Column<C, T> setMaximumWidth(double pixels) {
            final double minwidth = getMinimumWidth();
            if (pixels >= 0 && pixels < minwidth && minwidth >= 0) {
                throw new IllegalArgumentException("New maximum width ("
                        + pixels + ") was less than minimum width (" + minwidth
                        + ")");
            }

            if (maximumWidthPx != pixels) {
                maximumWidthPx = pixels;
                scheduleColumnWidthRecalculator();
            }
            return this;
        }


        public Column<C, T> setExpandRatio(int ratio) {
            if (expandRatio != ratio) {
                expandRatio = ratio;
                scheduleColumnWidthRecalculator();
            }
            return this;
        }


        public Column<C, T> clearExpandRatio() {
            return setExpandRatio(-1);
        }


        public double getMinimumWidth() {
            return minimumWidthPx;
        }


        public double getMaximumWidth() {
            return maximumWidthPx;
        }


        public int getExpandRatio() {
            return expandRatio;
        }


        public Column<C, T> setEditable(boolean editable) {
            if (editable != this.editable && grid.isEditorActive()) {
                throw new IllegalStateException(
                        "Cannot change column editable status while the editor is active");
            }
            this.editable = editable;
            return this;
        }


        public boolean isEditable() {
            return editable;
        }

        private void scheduleColumnWidthRecalculator() {
            if (grid != null) {
                grid.recalculateColumnWidths();
            } else {

            }
        }


        protected void setDefaultHeaderContent(HeaderCell cell) {
            cell.setText(headerCaption);
        }
    }

    protected class BodyUpdater implements EscalatorUpdater {

        @Override
        public void preAttach(Row row, Iterable<FlyweightCell> cellsToAttach) {
            int rowIndex = row.getRow();
            rowReference.set(rowIndex, getDataSource().getRow(rowIndex),
                    row.getElement());
            for (FlyweightCell cell : cellsToAttach) {
                Renderer<?> renderer = findRenderer(cell);
                if (renderer instanceof ComplexRenderer) {
                    try {
                        Column<?, T> column = getVisibleColumn(cell.getColumn());
                        rendererCellReference.set(cell,
                                getColumns().indexOf(column), column);
                        ((ComplexRenderer<?>) renderer)
                                .init(rendererCellReference);
                    } catch (RuntimeException e) {
                        getLogger().log(
                                Level.SEVERE,
                                "Error initing cell in column "
                                        + cell.getColumn(), e);
                    }
                }
            }
        }

        @Override
        public void postAttach(Row row, Iterable<FlyweightCell> attachedCells) {
            for (FlyweightCell cell : attachedCells) {
                Renderer<?> renderer = findRenderer(cell);
                if (renderer instanceof WidgetRenderer) {
                    try {
                        WidgetRenderer<?, ?> widgetRenderer = (WidgetRenderer<?, ?>) renderer;

                        Widget widget = widgetRenderer.createWidget();
                        assert widget != null : "WidgetRenderer.createWidget() returned null. It should return a widget.";
                        assert widget.getParent() == null : "WidgetRenderer.createWidget() returned a widget which already is attached.";
                        assert cell.getElement().getChildCount() == 0 : "Cell content should be empty when adding Widget";


                        cell.getElement().appendChild(widget.getElement());


                        setParent(widget, Grid.this);
                    } catch (RuntimeException e) {
                        getLogger().log(
                                Level.SEVERE,
                                "Error attaching child widget in column "
                                        + cell.getColumn(), e);
                    }
                }
            }
        }

        @Override
        public void update(Row row, Iterable<FlyweightCell> cellsToUpdate) {
            int rowIndex = row.getRow();
            TableRowElement rowElement = row.getElement();
            T rowData = dataSource.getRow(rowIndex);

            boolean hasData = rowData != null;




            boolean usedToHaveData = rowElement
                    .hasClassName(rowHasDataStyleName);

            if (usedToHaveData != hasData) {
                setStyleName(rowElement, rowHasDataStyleName, hasData);
            }

            boolean isEvenIndex = (row.getRow() % 2 == 0);
            setStyleName(rowElement, rowStripeStyleName, !isEvenIndex);

            rowReference.set(rowIndex, rowData, rowElement);

            if (hasData) {
                setStyleName(rowElement, rowSelectedStyleName,
                        isSelected(rowData));

                if (rowStyleGenerator != null) {
                    try {
                        String rowStylename = rowStyleGenerator
                                .getStyle(rowReference);
                        setCustomStyleName(rowElement, rowStylename);
                    } catch (RuntimeException e) {
                        getLogger().log(
                                Level.SEVERE,
                                "Error generating styles for row "
                                        + row.getRow(), e);
                    }
                } else {

                    setCustomStyleName(rowElement, null);
                }
            } else if (usedToHaveData) {
                setStyleName(rowElement, rowSelectedStyleName, false);

                setCustomStyleName(rowElement, null);
            }

            cellFocusHandler.updateFocusedRowStyle(row);

            for (FlyweightCell cell : cellsToUpdate) {
                Column<?, T> column = getVisibleColumn(cell.getColumn());
                final int columnIndex = getColumns().indexOf(column);

                assert column != null : "Column was not found from cell ("
                        + cell.getColumn() + "," + cell.getRow() + ")";

                cellFocusHandler.updateFocusedCellStyle(cell,
                        escalator.getBody());

                if (hasData && cellStyleGenerator != null) {
                    try {
                        cellReference
                                .set(cell.getColumn(), columnIndex, column);
                        String generatedStyle = cellStyleGenerator
                                .getStyle(cellReference);
                        setCustomStyleName(cell.getElement(), generatedStyle);
                    } catch (RuntimeException e) {
                        getLogger().log(
                                Level.SEVERE,
                                "Error generating style for cell in column "
                                        + cell.getColumn(), e);
                    }
                } else if (hasData || usedToHaveData) {
                    setCustomStyleName(cell.getElement(), null);
                }

                Renderer renderer = column.getRenderer();

                try {
                    rendererCellReference.set(cell, columnIndex, column);
                    if (renderer instanceof ComplexRenderer) {

                        ComplexRenderer clxRenderer = (ComplexRenderer) renderer;
                        if (hasData) {
                            if (!usedToHaveData) {

                                clxRenderer.setContentVisible(
                                        rendererCellReference, true);
                            }

                            Object value = column.getValue(rowData);
                            clxRenderer.render(rendererCellReference, value);

                        } else {

                            clxRenderer.setContentVisible(
                                    rendererCellReference, false);
                        }

                    } else if (hasData) {

                        Object value = column.getValue(rowData);
                        renderer.render(rendererCellReference, value);

                    } else {

                        cell.getElement().removeAllChildren();
                    }
                } catch (RuntimeException e) {
                    getLogger().log(
                            Level.SEVERE,
                            "Error rendering cell in column "
                                    + cell.getColumn(), e);
                }
            }
        }

        @Override
        public void preDetach(Row row, Iterable<FlyweightCell> cellsToDetach) {
            for (FlyweightCell cell : cellsToDetach) {
                Renderer renderer = findRenderer(cell);
                if (renderer instanceof WidgetRenderer) {
                    try {
                        Widget w = WidgetUtil.findWidget(cell.getElement()
                                .getFirstChildElement(), Widget.class);
                        if (w != null) {


                            setParent(w, null);


                            cell.getElement().removeChild(w.getElement());
                        }
                    } catch (RuntimeException e) {
                        getLogger().log(
                                Level.SEVERE,
                                "Error detaching widget in column "
                                        + cell.getColumn(), e);
                    }
                }
            }
        }

        @Override
        public void postDetach(Row row, Iterable<FlyweightCell> detachedCells) {
            int rowIndex = row.getRow();


            rowReference.set(rowIndex, null, row.getElement());
            for (FlyweightCell cell : detachedCells) {
                Renderer renderer = findRenderer(cell);
                if (renderer instanceof ComplexRenderer) {
                    try {
                        Column<?, T> column = getVisibleColumn(cell.getColumn());
                        rendererCellReference.set(cell,
                                getColumns().indexOf(column), column);
                        ((ComplexRenderer) renderer)
                                .destroy(rendererCellReference);
                    } catch (RuntimeException e) {
                        getLogger().log(
                                Level.SEVERE,
                                "Error destroying cell in column "
                                        + cell.getColumn(), e);
                    }
                }
            }
        }
    }

    protected class StaticSectionUpdater implements EscalatorUpdater {

        private StaticSection<?> section;
        private RowContainer container;

        public StaticSectionUpdater(StaticSection<?> section,
                RowContainer container) {
            super();
            this.section = section;
            this.container = container;
        }

        @Override
        public void update(Row row, Iterable<FlyweightCell> cellsToUpdate) {
            StaticSection.StaticRow<?> staticRow = section.getRow(row.getRow());
            final List<Column<?, T>> columns = getVisibleColumns();

            setCustomStyleName(row.getElement(), staticRow.getStyleName());

            for (FlyweightCell cell : cellsToUpdate) {
                final StaticSection.StaticCell metadata = staticRow
                        .getCell(columns.get(cell.getColumn()));


                if (staticRow instanceof HeaderRow) {
                    addSortingIndicatorsToHeaderRow((HeaderRow) staticRow, cell);
                }


                cell.setColSpan(metadata.getColspan());

                TableCellElement element = cell.getElement();
                switch (metadata.getType()) {
                case TEXT:
                    element.setInnerText(metadata.getText());
                    break;
                case HTML:
                    element.setInnerHTML(metadata.getHtml());
                    break;
                case WIDGET:
                    preDetach(row, Arrays.asList(cell));
                    element.setInnerHTML("");
                    postAttach(row, Arrays.asList(cell));
                    break;
                }

                setCustomStyleName(element, metadata.getStyleName());

                cellFocusHandler.updateFocusedCellStyle(cell, container);
            }
        }

        private void addSortingIndicatorsToHeaderRow(HeaderRow headerRow,
                FlyweightCell cell) {

            cleanup(cell);

            Column<?, ?> column = getVisibleColumn(cell.getColumn());
            SortOrder sortingOrder = getSortOrder(column);
            if (!headerRow.isDefault() || !column.isSortable()
                    || sortingOrder == null) {


                return;
            }

            Element cellElement = cell.getElement();

            if (SortDirection.ASCENDING == sortingOrder.getDirection()) {
                cellElement.addClassName("sort-asc");
            } else {
                cellElement.addClassName("sort-desc");
            }

            int sortIndex = Grid.this.getSortOrder().indexOf(sortingOrder);
            if (sortIndex > -1 && Grid.this.getSortOrder().size() > 1) {


                cellElement.setAttribute("sort-order",
                        String.valueOf(sortIndex + 1));
            }
        }


        private SortOrder getSortOrder(Column<?, ?> column) {
            for (SortOrder order : Grid.this.getSortOrder()) {
                if (order.getColumn() == column) {
                    return order;
                }
            }
            return null;
        }

        private void cleanup(FlyweightCell cell) {
            Element cellElement = cell.getElement();
            cellElement.removeAttribute("sort-order");
            cellElement.removeClassName("sort-desc");
            cellElement.removeClassName("sort-asc");
        }

        @Override
        public void preAttach(Row row, Iterable<FlyweightCell> cellsToAttach) {
        }

        @Override
        public void postAttach(Row row, Iterable<FlyweightCell> attachedCells) {
            StaticSection.StaticRow<?> gridRow = section.getRow(row.getRow());
            List<Column<?, T>> columns = getVisibleColumns();

            for (FlyweightCell cell : attachedCells) {
                StaticSection.StaticCell metadata = gridRow.getCell(columns
                        .get(cell.getColumn()));

                if (GridStaticCellType.WIDGET.equals(metadata.getType())) {
                    final Widget widget = metadata.getWidget();
                    final Element cellElement = cell.getElement();

                    if (!widget.isAttached()) {


                        cellElement.appendChild(widget.getElement());


                        setParent(widget, Grid.this);
                    }
                }
            }
        }

        @Override
        public void preDetach(Row row, Iterable<FlyweightCell> cellsToDetach) {
            if (section.getRowCount() > row.getRow()) {
                StaticSection.StaticRow<?> gridRow = section.getRow(row
                        .getRow());
                List<Column<?, T>> columns = getVisibleColumns();
                for (FlyweightCell cell : cellsToDetach) {
                    StaticSection.StaticCell metadata = gridRow.getCell(columns
                            .get(cell.getColumn()));

                    if (GridStaticCellType.WIDGET.equals(metadata.getType())
                            && metadata.getWidget().isAttached()) {

                        Widget widget = metadata.getWidget();


                        setParent(widget, null);


                        widget.getElement().removeFromParent();
                    }
                }
            }
        }

        @Override
        public void postDetach(Row row, Iterable<FlyweightCell> detachedCells) {
        }
    };


    public Grid() {
        initWidget(escalator);
        getElement().setTabIndex(0);
        cellFocusHandler = new CellFocusHandler();

        setStylePrimaryName("v-grid");

        escalator.getHeader().setEscalatorUpdater(createHeaderUpdater());
        escalator.getBody().setEscalatorUpdater(createBodyUpdater());
        escalator.getFooter().setEscalatorUpdater(createFooterUpdater());

        header.setGrid(this);
        HeaderRow defaultRow = header.appendRow();
        header.setDefaultRow(defaultRow);

        footer.setGrid(this);

        editor.setGrid(this);

        setSelectionMode(SelectionMode.SINGLE);

        escalator.getBody().setSpacerUpdater(gridSpacerUpdater);

        escalator.addScrollHandler(new ScrollHandler() {
            @Override
            public void onScroll(ScrollEvent event) {
                fireEvent(new ScrollEvent());
            }
        });

        escalator
                .addRowVisibilityChangeHandler(new RowVisibilityChangeHandler() {
                    @Override
                    public void onRowVisibilityChange(
                            RowVisibilityChangeEvent event) {
                        if (dataSource != null && dataSource.size() != 0) {
                            dataIsBeingFetched = true;
                            dataSource.ensureAvailability(
                                    event.getFirstVisibleRow(),
                                    event.getVisibleRowCount());
                        }
                    }
                });



        addSelectionHandler(new SelectionHandler<T>() {

            @Override
            public void onSelect(SelectionEvent<T> event) {
                refreshBody();
            }
        });


        sinkEvents(getHeader().getConsumedEvents());
        sinkEvents(Arrays.asList(BrowserEvents.KEYDOWN, BrowserEvents.KEYUP,
                BrowserEvents.KEYPRESS, BrowserEvents.DBLCLICK,
                BrowserEvents.MOUSEDOWN));


        addHeaderKeyUpHandler(new HeaderKeyUpHandler() {
            @Override
            public void onKeyUp(GridKeyUpEvent event) {
                if (event.getNativeKeyCode() != KeyCodes.KEY_ENTER) {
                    return;
                }
                if (getHeader().getRow(event.getFocusedCell().getRowIndex())
                        .isDefault()) {

                    sorter.sort(event.getFocusedCell().getColumn(),
                            event.isShiftKeyDown());
                }
            }
        });

        addDataAvailableHandler(new DataAvailableHandler() {
            @Override
            public void onDataAvailable(DataAvailableEvent event) {
                dataIsBeingFetched = false;
            }
        });
    }

    @Override
    public boolean isEnabled() {
        return enabled;
    }

    @Override
    public void setEnabled(boolean enabled) {
        if (enabled == this.enabled) {
            return;
        }

        this.enabled = enabled;
        getElement().setTabIndex(enabled ? 0 : -1);


        boolean editorOpen = editor.getState() != State.INACTIVE;
        if (editorOpen) {
            editor.setGridEnabled(enabled);
        }

        getEscalator().setScrollLocked(Direction.VERTICAL,
                !enabled || editorOpen);
        getEscalator().setScrollLocked(Direction.HORIZONTAL, !enabled);
    }

    @Override
    public void setStylePrimaryName(String style) {
        super.setStylePrimaryName(style);
        escalator.setStylePrimaryName(style);
        editor.setStylePrimaryName(style);
        sidebar.setStylePrimaryName(style + "-sidebar");
        sidebar.addStyleName("v-contextmenu");

        String rowStyle = getStylePrimaryName() + "-row";
        rowHasDataStyleName = rowStyle + "-has-data";
        rowSelectedStyleName = rowStyle + "-selected";
        rowStripeStyleName = rowStyle + "-stripe";

        cellFocusStyleName = getStylePrimaryName() + "-cell-focused";
        rowFocusStyleName = getStylePrimaryName() + "-row-focused";

        if (isAttached()) {
            refreshHeader();
            refreshBody();
            refreshFooter();
        }
    }


    protected EscalatorUpdater createHeaderUpdater() {
        return new StaticSectionUpdater(header, escalator.getHeader());
    }


    protected EscalatorUpdater createBodyUpdater() {
        return new BodyUpdater();
    }


    protected EscalatorUpdater createFooterUpdater() {
        return new StaticSectionUpdater(footer, escalator.getFooter());
    }


    private void refreshRowContainer(RowContainer rows, StaticSection<?> section) {


        int rowDiff = section.getVisibleRowCount() - rows.getRowCount();
        if (rowDiff > 0) {
            rows.insertRows(0, rowDiff);
        } else if (rowDiff < 0) {
            rows.removeRows(0, -rowDiff);
        }


        if (rows.getRowCount() > 0) {
            rows.refreshRows(0, rows.getRowCount());
        }
    }


    void refreshHeader() {
        refreshRowContainer(escalator.getHeader(), header);
    }


    private void refreshBody() {
        escalator.getBody().refreshRows(0, escalator.getBody().getRowCount());
    }


    void refreshFooter() {
        refreshRowContainer(escalator.getFooter(), footer);
    }


    public void addColumns(Column<?, T>... columns) {
        int count = getColumnCount();
        for (Column<?, T> column : columns) {
            addColumn(column, count++);
        }
    }


    public <C extends Column<?, T>> C addColumn(C column) {
        addColumn(column, getColumnCount());
        return column;
    }


    public <C extends Column<?, T>> C addColumn(C column, int index) {
        if (column == selectionColumn) {
            throw new IllegalArgumentException("The selection column many "
                    + "not be added manually");
        } else if (selectionColumn != null && index == 0) {
            throw new IllegalStateException("A column cannot be inserted "
                    + "before the selection column");
        }

        addColumnSkipSelectionColumnCheck(column, index);
        return column;
    }

    private void addColumnSkipSelectionColumnCheck(Column<?, T> column,
            int index) {

        columns.add(index, column);

        header.addColumn(column);
        footer.addColumn(column);


        ((Column<?, T>) column).setGrid(this);



        if (!column.isHidden()) {
            int escalatorIndex = index;
            for (int existingColumn = 0; existingColumn < index; existingColumn++) {
                if (getColumn(existingColumn).isHidden()) {
                    escalatorIndex--;
                }
            }
            escalator.getColumnConfiguration().insertColumns(escalatorIndex, 1);
        }


        column.reapplyWidth();


        Set<String> events = new HashSet<String>();
        events.addAll(getConsumedEventsForRenderer(column.getRenderer()));

        if (column.isHidable()) {
            columnHider.updateColumnHidable(column);
        }

        sinkEvents(events);
    }

    private void sinkEvents(Collection<String> events) {
        assert events != null;

        int eventsToSink = 0;
        for (String typeName : events) {
            int typeInt = Event.getTypeInt(typeName);
            if (typeInt < 0) {

                sinkBitlessEvent(typeName);
            } else {
                eventsToSink |= typeInt;
            }
        }

        if (eventsToSink > 0) {
            sinkEvents(eventsToSink);
        }
    }

    private Renderer<?> findRenderer(FlyweightCell cell) {
        Column<?, T> column = getVisibleColumn(cell.getColumn());
        assert column != null : "Could not find column at index:"
                + cell.getColumn();
        return column.getRenderer();
    }


    public void removeColumn(Column<?, T> column) {
        if (column != null && column.equals(selectionColumn)) {
            throw new IllegalArgumentException(
                    "The selection column may not be removed manually.");
        }

        removeColumnSkipSelectionColumnCheck(column);
    }

    private void removeColumnSkipSelectionColumnCheck(Column<?, T> column) {
        int columnIndex = columns.indexOf(column);


        escalator.getColumnConfiguration().removeColumns(
                getVisibleColumns().indexOf(column), 1);

        updateFrozenColumns();

        header.removeColumn(column);
        footer.removeColumn(column);


        ((Column<?, T>) column).setGrid(null);

        columns.remove(columnIndex);

        if (column.isHidable()) {
            columnHider.removeColumnHidingToggle(column);
        }
    }


    public int getColumnCount() {
        return columns.size();
    }


    public List<Column<?, T>> getColumns() {
        return Collections
                .unmodifiableList(new ArrayList<Column<?, T>>(columns));
    }


    public List<Column<?, T>> getVisibleColumns() {
        ArrayList<Column<?, T>> visible = new ArrayList<Column<?, T>>();
        for (Column<?, T> c : columns) {
            if (!c.isHidden()) {
                visible.add(c);
            }
        }
        return Collections.unmodifiableList(visible);
    }


    public Column<?, T> getColumn(int index) throws IllegalArgumentException {
        if (index < 0 || index >= columns.size()) {
            throw new IllegalStateException("Column not found.");
        }
        return columns.get(index);
    }

    private Column<?, T> getVisibleColumn(int index)
            throws IllegalArgumentException {
        List<Column<?, T>> visibleColumns = getVisibleColumns();
        if (index < 0 || index >= visibleColumns.size()) {
            throw new IllegalStateException("Column not found.");
        }
        return visibleColumns.get(index);
    }


    protected Header getHeader() {
        return header;
    }


    public HeaderRow getHeaderRow(int rowIndex) {
        return header.getRow(rowIndex);
    }


    public HeaderRow addHeaderRowAt(int index) {
        return header.addRowAt(index);
    }


    public HeaderRow appendHeaderRow() {
        return header.appendRow();
    }


    public HeaderRow getDefaultHeaderRow() {
        return header.getDefaultRow();
    }


    public int getHeaderRowCount() {
        return header.getRowCount();
    }


    public HeaderRow prependHeaderRow() {
        return header.prependRow();
    }


    public void removeHeaderRow(HeaderRow row) {
        header.removeRow(row);
    }


    public void removeHeaderRow(int rowIndex) {
        header.removeRow(rowIndex);
    }


    public void setDefaultHeaderRow(HeaderRow row) {
        header.setDefaultRow(row);
    }


    public void setHeaderVisible(boolean visible) {
        header.setVisible(visible);
    }


    public boolean isHeaderVisible() {
        return header.isVisible();
    }




    protected Footer getFooter() {
        return footer;
    }


    public FooterRow getFooterRow(int rowIndex) {
        return footer.getRow(rowIndex);
    }


    public FooterRow addFooterRowAt(int index) {
        return footer.addRowAt(index);
    }


    public FooterRow appendFooterRow() {
        return footer.appendRow();
    }


    public int getFooterRowCount() {
        return footer.getRowCount();
    }


    public FooterRow prependFooterRow() {
        return footer.prependRow();
    }


    public void removeFooterRow(FooterRow row) {
        footer.removeRow(row);
    }


    public void removeFooterRow(int rowIndex) {
        footer.removeRow(rowIndex);
    }


    public void setFooterVisible(boolean visible) {
        footer.setVisible(visible);
    }


    public boolean isFooterVisible() {
        return footer.isVisible();
    }

    protected Editor<T> getEditor() {
        return editor;
    }

    protected Escalator getEscalator() {
        return escalator;
    }


    @Override
    public void setHeight(String height) {
        escalator.setHeight(height);
    }

    @Override
    public void setWidth(String width) {
        escalator.setWidth(width);
    }


    public void setDataSource(final DataSource<T> dataSource)
            throws IllegalArgumentException {
        if (dataSource == null) {
            throw new IllegalArgumentException("dataSource can't be null.");
        }

        selectionModel.reset();

        if (this.dataSource != null) {
            this.dataSource.setDataChangeHandler(null);
        }

        this.dataSource = dataSource;
        dataSource.setDataChangeHandler(new DataChangeHandler() {
            @Override
            public void dataUpdated(int firstIndex, int numberOfItems) {
                escalator.getBody().refreshRows(firstIndex, numberOfItems);
            }

            @Override
            public void dataRemoved(int firstIndex, int numberOfItems) {
                escalator.getBody().removeRows(firstIndex, numberOfItems);
                Range removed = Range.withLength(firstIndex, numberOfItems);
                cellFocusHandler.rowsRemovedFromBody(removed);
            }

            @Override
            public void dataAdded(int firstIndex, int numberOfItems) {
                escalator.getBody().insertRows(firstIndex, numberOfItems);
                Range added = Range.withLength(firstIndex, numberOfItems);
                cellFocusHandler.rowsAddedToBody(added);
            }

            @Override
            public void dataAvailable(int firstIndex, int numberOfItems) {
                currentDataAvailable = Range.withLength(firstIndex,
                        numberOfItems);
                fireEvent(new DataAvailableEvent(currentDataAvailable));
            }

            @Override
            public void resetDataAndSize(int newSize) {
                RowContainer body = escalator.getBody();
                int oldSize = body.getRowCount();


                Set<Integer> oldDetails = new HashSet<Integer>(visibleDetails);
                for (int i : oldDetails) {
                    setDetailsVisible(i, false);
                }

                if (newSize > oldSize) {
                    body.insertRows(oldSize, newSize - oldSize);
                    cellFocusHandler.rowsAddedToBody(Range.withLength(oldSize,
                            newSize - oldSize));
                } else if (newSize < oldSize) {
                    body.removeRows(newSize, oldSize - newSize);
                    cellFocusHandler.rowsRemovedFromBody(Range.withLength(
                            newSize, oldSize - newSize));
                }

                if (newSize > 0) {
                    dataIsBeingFetched = true;
                    Range visibleRowRange = escalator.getVisibleRowRange();
                    dataSource.ensureAvailability(visibleRowRange.getStart(),
                            visibleRowRange.length());
                } else {


                    dataAvailable(0, 0);
                }

                assert body.getRowCount() == newSize;
            }
        });

        int previousRowCount = escalator.getBody().getRowCount();
        if (previousRowCount != 0) {
            escalator.getBody().removeRows(0, previousRowCount);
        }

        setEscalatorSizeFromDataSource();
    }

    private void setEscalatorSizeFromDataSource() {
        assert escalator.getBody().getRowCount() == 0;

        int size = dataSource.size();
        if (size == -1 && isAttached()) {


            size = getEscalator().getMaxVisibleRowCount();
        }
        if (size > 0) {
            escalator.getBody().insertRows(0, size);
        }
    }


    public DataSource<T> getDataSource() {
        return dataSource;
    }


    public void setFrozenColumnCount(int numberOfColumns) {
        if (numberOfColumns < -1 || numberOfColumns > getColumnCount()) {
            throw new IllegalArgumentException(
                    "count must be between -1 and the current number of columns ("
                            + getColumnCount() + ")");
        }

        frozenColumnCount = numberOfColumns;
        updateFrozenColumns();
    }

    private void updateFrozenColumns() {
        int numberOfColumns = frozenColumnCount;



        for (int i = 0; i < frozenColumnCount; i++) {
            if (getColumn(i).isHidden()) {
                numberOfColumns--;
            }
        }

        if (numberOfColumns == -1) {
            numberOfColumns = 0;
        } else if (selectionColumn != null) {
            numberOfColumns++;
        }

        escalator.getColumnConfiguration()
                .setFrozenColumnCount(numberOfColumns);
    }


    public int getFrozenColumnCount() {
        return frozenColumnCount;
    }

    public HandlerRegistration addRowVisibilityChangeHandler(
            RowVisibilityChangeHandler handler) {

        return escalator.addRowVisibilityChangeHandler(handler);
    }


    public void scrollToRow(int rowIndex) throws IllegalArgumentException {
        scrollToRow(rowIndex, ScrollDestination.ANY,
                GridConstants.DEFAULT_PADDING);
    }


    public void scrollToRow(int rowIndex, ScrollDestination destination)
            throws IllegalArgumentException {
        scrollToRow(rowIndex, destination,
                destination == ScrollDestination.MIDDLE ? 0
                        : GridConstants.DEFAULT_PADDING);
    }


    private void scrollToRow(int rowIndex, ScrollDestination destination,
            int paddingPx) throws IllegalArgumentException {
        int maxsize = escalator.getBody().getRowCount() - 1;

        if (rowIndex < 0) {
            throw new IllegalArgumentException("Row index (" + rowIndex
                    + ") is below zero!");
        }

        if (rowIndex > maxsize) {
            throw new IllegalArgumentException("Row index (" + rowIndex
                    + ") is above maximum (" + maxsize + ")!");
        }

        escalator.scrollToRowAndSpacer(rowIndex, destination, paddingPx);
    }


    public void scrollToStart() {
        scrollToRow(0, ScrollDestination.START);
    }


    public void scrollToEnd() {
        scrollToRow(escalator.getBody().getRowCount() - 1,
                ScrollDestination.END);
    }


    public void setScrollTop(double px) {
        escalator.setScrollTop(px);
    }


    public double getScrollTop() {
        return escalator.getScrollTop();
    }


    public void setScrollLeft(double px) {
        escalator.setScrollLeft(px);
    }


    public double getScrollLeft() {
        return escalator.getScrollLeft();
    }


    public double getScrollHeight() {
        return escalator.getScrollHeight();
    }


    public double getScrollWidth() {
        return escalator.getScrollWidth();
    }

    private static final Logger getLogger() {
        return Logger.getLogger(Grid.class.getName());
    }


    public void setHeightByRows(double rows) throws IllegalArgumentException {
        escalator.setHeightByRows(rows);
    }


    public double getHeightByRows() {
        return escalator.getHeightByRows();
    }


    public void setHeightMode(HeightMode heightMode) {


        escalator.setHeightMode(heightMode);
    }


    public HeightMode getHeightMode() {
        return escalator.getHeightMode();
    }

    private Set<String> getConsumedEventsForRenderer(Renderer<?> renderer) {
        Set<String> events = new HashSet<String>();
        if (renderer instanceof ComplexRenderer) {
            Collection<String> consumedEvents = ((ComplexRenderer<?>) renderer)
                    .getConsumedEvents();
            if (consumedEvents != null) {
                events.addAll(consumedEvents);
            }
        }
        return events;
    }

    @Override
    public void onBrowserEvent(Event event) {
        if (!isEnabled()) {
            return;
        }

        EventTarget target = event.getEventTarget();

        if (!Element.is(target) || isOrContainsInSpacer(Element.as(target))) {
            return;
        }

        Element e = Element.as(target);
        RowContainer container = escalator.findRowContainer(e);
        Cell cell;

        String eventType = event.getType();
        if (container == null) {
            if (eventType.equals(BrowserEvents.KEYDOWN)
                    || eventType.equals(BrowserEvents.KEYUP)
                    || eventType.equals(BrowserEvents.KEYPRESS)) {
                cell = cellFocusHandler.getFocusedCell();
                container = cellFocusHandler.containerWithFocus;
            } else {

                return;
            }
        } else {
            cell = container.getCell(e);
            if (eventType.equals(BrowserEvents.MOUSEDOWN)) {
                cellOnPrevMouseDown = cell;
            } else if (cell == null && eventType.equals(BrowserEvents.CLICK)) {

                cell = cellOnPrevMouseDown;
            }
        }

        assert cell != null : "received " + eventType
                + "-event with a null cell target";
        eventCell.set(cell, getSectionFromContainer(container));


        if (handleEditorEvent(event, container)) {
            return;
        }


        super.onBrowserEvent(event);

        if (!isElementInChildWidget(e)) {

            if (handleHeaderCellDragStartEvent(event, container)) {
                return;
            }


            if (handleHeaderDefaultRowEvent(event, container)) {
                return;
            }

            if (handleRendererEvent(event, container)) {
                return;
            }

            if (handleCellFocusEvent(event, container)) {
                return;
            }
        }
    }

    private Section getSectionFromContainer(RowContainer container) {
        assert container != null : "RowContainer should not be null";

        if (container == escalator.getBody()) {
            return Section.BODY;
        } else if (container == escalator.getFooter()) {
            return Section.FOOTER;
        } else if (container == escalator.getHeader()) {
            return Section.HEADER;
        }
        assert false : "RowContainer was not header, footer or body.";
        return null;
    }

    private boolean isOrContainsInSpacer(Node node) {
        Node n = node;
        while (n != null && n != getElement()) {
            boolean isElement = Element.is(n);
            if (isElement) {
                String className = Element.as(n).getClassName();
                if (className.contains(getStylePrimaryName() + "-spacer")) {
                    return true;
                }
            }
            n = n.getParentNode();
        }
        return false;
    }

    private boolean isElementInChildWidget(Element e) {
        Widget w = WidgetUtil.findWidget(e, null);

        if (w == this) {
            return false;
        }


        while (w != null && w != this) {
            w = w.getParent();
        }
        return w != null;
    }

    private boolean handleEditorEvent(Event event, RowContainer container) {

        final boolean closeEvent = event.getTypeInt() == Event.ONKEYDOWN
                && event.getKeyCode() == Editor.KEYCODE_HIDE;

        double now = Duration.currentTimeMillis();
        int currentX = WidgetUtil.getTouchOrMouseClientX(event);
        int currentY = WidgetUtil.getTouchOrMouseClientY(event);

        final boolean validTouchOpenEvent = event.getTypeInt() == Event.ONTOUCHEND
                && now - lastTouchEventTime < 500
                && lastTouchEventRow == eventCell.getRowIndex()
                && Math.abs(lastTouchEventX - currentX) < 20
                && Math.abs(lastTouchEventY - currentY) < 20;

        final boolean openEvent = event.getTypeInt() == Event.ONDBLCLICK
                || (event.getTypeInt() == Event.ONKEYDOWN && event.getKeyCode() == Editor.KEYCODE_SHOW)
                || validTouchOpenEvent;

        if (event.getTypeInt() == Event.ONTOUCHSTART) {
            lastTouchEventX = currentX;
            lastTouchEventY = currentY;
        }

        if (event.getTypeInt() == Event.ONTOUCHEND) {
            lastTouchEventTime = now;
            lastTouchEventRow = eventCell.getRowIndex();
        }

        if (editor.getState() != Editor.State.INACTIVE) {
            if (closeEvent) {
                editor.cancel();
                FocusUtil.setFocus(this, true);
            }
            return true;
        }

        if (container == escalator.getBody() && editor.isEnabled() && openEvent) {
            editor.editRow(eventCell.getRowIndex(),
                    eventCell.getColumnIndexDOM());
            event.preventDefault();
            return true;
        }

        return false;
    }

    private boolean handleRendererEvent(Event event, RowContainer container) {

        if (container == escalator.getBody()) {
            Column<?, T> gridColumn = eventCell.getColumn();
            boolean enterKey = event.getType().equals(BrowserEvents.KEYDOWN)
                    && event.getKeyCode() == KeyCodes.KEY_ENTER;
            boolean doubleClick = event.getType()
                    .equals(BrowserEvents.DBLCLICK);

            if (gridColumn.getRenderer() instanceof ComplexRenderer) {
                ComplexRenderer<?> cplxRenderer = (ComplexRenderer<?>) gridColumn
                        .getRenderer();
                if (cplxRenderer.getConsumedEvents().contains(event.getType())) {
                    if (cplxRenderer.onBrowserEvent(eventCell, event)) {
                        return true;
                    }
                }


                if ((enterKey || doubleClick)
                        && cplxRenderer.onActivate(eventCell)) {
                    return true;
                }
            }
        }
        return false;
    }

    private boolean handleCellFocusEvent(Event event, RowContainer container) {
        Collection<String> navigation = cellFocusHandler.getNavigationEvents();
        if (navigation.contains(event.getType())) {
            cellFocusHandler.handleNavigationEvent(event, eventCell);
        }
        return false;
    }

    private boolean handleHeaderCellDragStartEvent(Event event,
            RowContainer container) {
        if (!isColumnReorderingAllowed()) {
            return false;
        }
        if (container != escalator.getHeader()) {
            return false;
        }
        if (eventCell.getColumnIndex() < escalator.getColumnConfiguration()
                .getFrozenColumnCount()) {
            return false;
        }

        if (event.getTypeInt() == Event.ONMOUSEDOWN
                && event.getButton() == NativeEvent.BUTTON_LEFT
                || event.getTypeInt() == Event.ONTOUCHSTART) {
            dndHandler.onDragStartOnDraggableElement(event,
                    headerCellDndCallback);
            event.preventDefault();
            event.stopPropagation();
            return true;
        }
        return false;
    }

    private Point rowEventTouchStartingPoint;
    private CellStyleGenerator<T> cellStyleGenerator;
    private RowStyleGenerator<T> rowStyleGenerator;
    private RowReference<T> rowReference = new RowReference<T>(this);
    private CellReference<T> cellReference = new CellReference<T>(rowReference);
    private RendererCellReference rendererCellReference = new RendererCellReference(
            (RowReference<Object>) rowReference);

    private boolean handleHeaderDefaultRowEvent(Event event,
            RowContainer container) {
        if (container != escalator.getHeader()) {
            return false;
        }
        if (!getHeader().getRow(eventCell.getRowIndex()).isDefault()) {
            return false;
        }
        if (!eventCell.getColumn().isSortable()) {

            return false;
        }

        if (BrowserEvents.MOUSEDOWN.equals(event.getType())
                && event.getShiftKey()) {

            event.preventDefault();
        }

        if (BrowserEvents.TOUCHSTART.equals(event.getType())) {
            if (event.getTouches().length() > 1) {
                return false;
            }

            event.preventDefault();

            Touch touch = event.getChangedTouches().get(0);
            rowEventTouchStartingPoint = new Point(touch.getClientX(),
                    touch.getClientY());

            sorter.sortAfterDelay(GridConstants.LONG_TAP_DELAY, true);

            return true;

        } else if (BrowserEvents.TOUCHMOVE.equals(event.getType())) {
            if (event.getTouches().length() > 1) {
                return false;
            }

            event.preventDefault();

            Touch touch = event.getChangedTouches().get(0);
            double diffX = Math.abs(touch.getClientX()
                    - rowEventTouchStartingPoint.getX());
            double diffY = Math.abs(touch.getClientY()
                    - rowEventTouchStartingPoint.getY());



            if (diffX > GridConstants.LONG_TAP_THRESHOLD
                    || diffY > GridConstants.LONG_TAP_THRESHOLD) {
                sorter.cancelDelayedSort();
            }

            return true;

        } else if (BrowserEvents.TOUCHEND.equals(event.getType())) {
            if (event.getTouches().length() > 1) {
                return false;
            }

            if (sorter.isDelayedSortScheduled()) {

                sorter.cancelDelayedSort();
                sorter.sort(eventCell.getColumn(), false);
            }

            return true;

        } else if (BrowserEvents.TOUCHCANCEL.equals(event.getType())) {
            if (event.getTouches().length() > 1) {
                return false;
            }

            sorter.cancelDelayedSort();

            return true;

        } else if (BrowserEvents.CLICK.equals(event.getType())) {

            sorter.sort(eventCell.getColumn(), event.getShiftKey());


            return false;
        } else {
            return false;
        }
    }

    @Override
    @SuppressWarnings("deprecation")
    public com.google.gwt.user.client.Element getSubPartElement(String subPart) {


        Element escalatorElement = escalator.getSubPartElement(subPart
                .replaceFirst("^details\\[", "spacer["));

        if (escalatorElement != null) {
            return DOM.asOld(escalatorElement);
        }

        SubPartArguments args = SubPartArguments.create(subPart);

        Element editor = getSubPartElementEditor(args);
        if (editor != null) {
            return DOM.asOld(editor);
        }

        return null;
    }

    private Element getSubPartElementEditor(SubPartArguments args) {

        if (!args.getType().equalsIgnoreCase("editor")
                || editor.getState() != State.ACTIVE) {
            return null;
        }

        if (args.getIndicesLength() == 0) {
            return editor.editorOverlay;
        } else if (args.getIndicesLength() == 1
                && args.getIndex(0) < columns.size()) {
            escalator
                    .scrollToColumn(args.getIndex(0), ScrollDestination.ANY, 0);
            return editor.getWidget(columns.get(args.getIndex(0))).getElement();
        }

        return null;
    }

    @Override
    @SuppressWarnings("deprecation")
    public String getSubPartName(com.google.gwt.user.client.Element subElement) {

        String escalatorStructureName = escalator.getSubPartName(subElement);
        if (escalatorStructureName != null) {
            return escalatorStructureName.replaceFirst("^spacer", "details");
        }

        String editorName = getSubPartNameEditor(subElement);
        if (editorName != null) {
            return editorName;
        }

        return null;
    }

    private String getSubPartNameEditor(Element subElement) {

        if (editor.getState() != State.ACTIVE
                || !editor.editorOverlay.isOrHasChild(subElement)) {
            return null;
        }

        int i = 0;
        for (Column<?, T> column : columns) {
            if (editor.getWidget(column).getElement().isOrHasChild(subElement)) {
                return "editor[" + i + "]";
            }
            ++i;
        }

        return "editor";
    }

    private void setSelectColumnRenderer(
            final Renderer<Boolean> selectColumnRenderer) {
        if (this.selectColumnRenderer == selectColumnRenderer) {
            return;
        }

        if (this.selectColumnRenderer != null) {
            if (this.selectColumnRenderer instanceof ComplexRenderer) {

                ((ComplexRenderer<?>) this.selectColumnRenderer).destroy();
            }



            Column<?, T> colToRemove = selectionColumn;
            selectionColumn = null;
            removeColumnSkipSelectionColumnCheck(colToRemove);
            cellFocusHandler.offsetRangeBy(-1);
        }

        this.selectColumnRenderer = selectColumnRenderer;

        if (selectColumnRenderer != null) {
            cellFocusHandler.offsetRangeBy(1);
            selectionColumn = new SelectionColumn(selectColumnRenderer);

            addColumnSkipSelectionColumnCheck(selectionColumn, 0);
            selectionColumn.initDone();
        } else {
            selectionColumn = null;
            refreshBody();
        }

        updateFrozenColumns();
    }


    public void setSelectionModel(SelectionModel<T> selectionModel) {

        if (selectionModel == null) {
            throw new IllegalArgumentException("Selection model can't be null");
        }

        if (this.selectionModel != null) {

            this.selectionModel.setGrid(null);
        }

        this.selectionModel = selectionModel;
        selectionModel.setGrid(this);
        setSelectColumnRenderer(this.selectionModel
                .getSelectionColumnRenderer());


        refreshBody();
    }


    public SelectionModel<T> getSelectionModel() {
        return selectionModel;
    }


    public void setSelectionMode(SelectionMode mode) {
        SelectionModel<T> model = mode.createModel();
        setSelectionModel(model);
    }


    public boolean isSelected(T row) {
        return selectionModel.isSelected(row);
    }


    @SuppressWarnings("unchecked")
    public boolean select(T row) {
        if (selectionModel instanceof SelectionModel.Single<?>) {
            return ((SelectionModel.Single<T>) selectionModel).select(row);
        } else if (selectionModel instanceof SelectionModel.Multi<?>) {
            return ((SelectionModel.Multi<T>) selectionModel).select(row);
        } else {
            throw new IllegalStateException("Unsupported selection model");
        }
    }


    @SuppressWarnings("unchecked")
    public boolean deselect(T row) {
        if (selectionModel instanceof SelectionModel.Single<?>) {
            return ((SelectionModel.Single<T>) selectionModel).deselect(row);
        } else if (selectionModel instanceof SelectionModel.Multi<?>) {
            return ((SelectionModel.Multi<T>) selectionModel).deselect(row);
        } else {
            throw new IllegalStateException("Unsupported selection model");
        }
    }


    public T getSelectedRow() {
        if (selectionModel instanceof SelectionModel.Single<?>) {
            return ((SelectionModel.Single<T>) selectionModel).getSelectedRow();
        } else {
            throw new IllegalStateException(
                    "Unsupported selection model; can not get single selected row");
        }
    }


    public Collection<T> getSelectedRows() {
        return selectionModel.getSelectedRows();
    }

    @Override
    public HandlerRegistration addSelectionHandler(
            final SelectionHandler<T> handler) {
        return addHandler(handler, SelectionEvent.getType());
    }


    public void sort(Sort s) {
        setSortOrder(s.build());
    }


    public <C> void sort(Column<C, T> column) {
        sort(column, SortDirection.ASCENDING);
    }


    public <C> void sort(Column<C, T> column, SortDirection direction) {
        sort(Sort.by(column, direction));
    }


    public void setSortOrder(List<SortOrder> order) {
        setSortOrder(order, false);
    }

    private void setSortOrder(List<SortOrder> order, boolean userOriginated) {
        if (order != sortOrder) {
            sortOrder.clear();
            if (order != null) {
                sortOrder.addAll(order);
            }
        }
        sort(userOriginated);
    }


    public List<SortOrder> getSortOrder() {
        return Collections.unmodifiableList(sortOrder);
    }


    private SortOrder getSortOrder(Column<?, ?> column) {
        for (SortOrder order : getSortOrder()) {
            if (order.getColumn() == column) {
                return order;
            }
        }
        return null;
    }


    public HandlerRegistration addSortHandler(SortHandler<T> handler) {
        return addHandler(handler, SortEvent.getType());
    }


    public HandlerRegistration addSelectAllHandler(SelectAllHandler<T> handler) {
        return addHandler(handler, SelectAllEvent.getType());
    }


    public HandlerRegistration addDataAvailableHandler(
            final DataAvailableHandler handler) {

        Scheduler.get().scheduleFinally(new ScheduledCommand() {
            @Override
            public void execute() {
                if (!dataIsBeingFetched) {
                    handler.onDataAvailable(new DataAvailableEvent(
                            currentDataAvailable));
                }
            }
        });
        return addHandler(handler, DataAvailableEvent.TYPE);
    }


    public HandlerRegistration addBodyKeyDownHandler(BodyKeyDownHandler handler) {
        return addHandler(handler, keyDown.getAssociatedType());
    }


    public HandlerRegistration addBodyKeyUpHandler(BodyKeyUpHandler handler) {
        return addHandler(handler, keyUp.getAssociatedType());
    }


    public HandlerRegistration addBodyKeyPressHandler(
            BodyKeyPressHandler handler) {
        return addHandler(handler, keyPress.getAssociatedType());
    }


    public HandlerRegistration addHeaderKeyDownHandler(
            HeaderKeyDownHandler handler) {
        return addHandler(handler, keyDown.getAssociatedType());
    }


    public HandlerRegistration addHeaderKeyUpHandler(HeaderKeyUpHandler handler) {
        return addHandler(handler, keyUp.getAssociatedType());
    }


    public HandlerRegistration addHeaderKeyPressHandler(
            HeaderKeyPressHandler handler) {
        return addHandler(handler, keyPress.getAssociatedType());
    }


    public HandlerRegistration addFooterKeyDownHandler(
            FooterKeyDownHandler handler) {
        return addHandler(handler, keyDown.getAssociatedType());
    }


    public HandlerRegistration addFooterKeyUpHandler(FooterKeyUpHandler handler) {
        return addHandler(handler, keyUp.getAssociatedType());
    }


    public HandlerRegistration addFooterKeyPressHandler(
            FooterKeyPressHandler handler) {
        return addHandler(handler, keyPress.getAssociatedType());
    }


    public HandlerRegistration addBodyClickHandler(BodyClickHandler handler) {
        return addHandler(handler, clickEvent.getAssociatedType());
    }


    public HandlerRegistration addHeaderClickHandler(HeaderClickHandler handler) {
        return addHandler(handler, clickEvent.getAssociatedType());
    }


    public HandlerRegistration addFooterClickHandler(FooterClickHandler handler) {
        return addHandler(handler, clickEvent.getAssociatedType());
    }


    public HandlerRegistration addBodyDoubleClickHandler(
            BodyDoubleClickHandler handler) {
        return addHandler(handler, doubleClickEvent.getAssociatedType());
    }


    public HandlerRegistration addHeaderDoubleClickHandler(
            HeaderDoubleClickHandler handler) {
        return addHandler(handler, doubleClickEvent.getAssociatedType());
    }


    public HandlerRegistration addFooterDoubleClickHandler(
            FooterDoubleClickHandler handler) {
        return addHandler(handler, doubleClickEvent.getAssociatedType());
    }


    public HandlerRegistration addColumnReorderHandler(
            ColumnReorderHandler<T> handler) {
        return addHandler(handler, ColumnReorderEvent.getType());
    }


    public HandlerRegistration addColumnVisibilityChangeHandler(
            ColumnVisibilityChangeHandler<T> handler) {
        return addHandler(handler, ColumnVisibilityChangeEvent.getType());
    }


    private void sort(boolean userOriginated) {
        refreshHeader();
        fireEvent(new SortEvent<T>(this,
                Collections.unmodifiableList(sortOrder), userOriginated));
    }

    private int getLastVisibleRowIndex() {
        int lastRowIndex = escalator.getVisibleRowRange().getEnd();
        int footerTop = escalator.getFooter().getElement().getAbsoluteTop();
        Element lastRow;

        do {
            lastRow = escalator.getBody().getRowElement(--lastRowIndex);
        } while (lastRow.getAbsoluteTop() > footerTop);

        return lastRowIndex;
    }

    private int getFirstVisibleRowIndex() {
        int firstRowIndex = escalator.getVisibleRowRange().getStart();
        int headerBottom = escalator.getHeader().getElement()
                .getAbsoluteBottom();
        Element firstRow = escalator.getBody().getRowElement(firstRowIndex);

        while (firstRow.getAbsoluteBottom() < headerBottom) {
            firstRow = escalator.getBody().getRowElement(++firstRowIndex);
        }

        return firstRowIndex;
    }


    public HandlerRegistration addScrollHandler(ScrollHandler handler) {
        return addHandler(handler, ScrollEvent.TYPE);
    }

    @Override
    public boolean isWorkPending() {
        return escalator.isWorkPending() || dataIsBeingFetched
                || autoColumnWidthsRecalculator.isScheduled();
    }


    public boolean isColumnReorderingAllowed() {
        return columnReorderingAllowed;
    }


    public void setColumnReorderingAllowed(boolean columnReorderingAllowed) {
        this.columnReorderingAllowed = columnReorderingAllowed;
    }


    public void setColumnOrder(Column<?, T>... orderedColumns) {
        ColumnConfiguration conf = getEscalator().getColumnConfiguration();


        conf.removeColumns(0, conf.getColumnCount());

        List<Column<?, T>> newOrder = new ArrayList<Column<?, T>>();
        if (selectionColumn != null) {
            newOrder.add(selectionColumn);
        }

        int i = 0;
        for (Column<?, T> column : orderedColumns) {
            if (columns.contains(column)) {
                newOrder.add(column);
                ++i;
            } else {
                throw new IllegalArgumentException("Given column at index " + i
                        + " does not exist in Grid");
            }
        }

        if (columns.size() != newOrder.size()) {
            columns.removeAll(newOrder);
            newOrder.addAll(columns);
        }
        columns = newOrder;

        List<Column<?, T>> visibleColumns = getVisibleColumns();


        conf.insertColumns(0, visibleColumns.size());


        updateFrozenColumns();


        for (Column<?, T> column : columns) {
            column.reapplyWidth();
        }


        for (HeaderRow row : header.getRows()) {
            row.calculateColspans();
        }
        for (FooterRow row : footer.getRows()) {
            row.calculateColspans();
        }

        columnHider.updateTogglesOrder();

        fireEvent(new ColumnReorderEvent<T>());
    }


    public void setCellStyleGenerator(CellStyleGenerator<T> cellStyleGenerator) {
        this.cellStyleGenerator = cellStyleGenerator;
        refreshBody();
    }


    public CellStyleGenerator<T> getCellStyleGenerator() {
        return cellStyleGenerator;
    }


    public void setRowStyleGenerator(RowStyleGenerator<T> rowStyleGenerator) {
        this.rowStyleGenerator = rowStyleGenerator;
        refreshBody();
    }


    public RowStyleGenerator<T> getRowStyleGenerator() {
        return rowStyleGenerator;
    }

    private static void setCustomStyleName(Element element, String styleName) {
        assert element != null;

        String oldStyleName = element
                .getPropertyString(CUSTOM_STYLE_PROPERTY_NAME);

        if (!SharedUtil.equals(oldStyleName, styleName)) {
            if (oldStyleName != null) {
                element.removeClassName(oldStyleName);
            }
            if (styleName != null) {
                element.addClassName(styleName);
            }
            element.setPropertyString(CUSTOM_STYLE_PROPERTY_NAME, styleName);
        }

    }


    public void editRow(int rowIndex) {
        editor.editRow(rowIndex);
    }


    public boolean isEditorActive() {
        return editor.getState() != State.INACTIVE;
    }


    public void saveEditor() {
        editor.save();
    }


    public void cancelEditor() {
        editor.cancel();
    }


    public EditorHandler<T> getEditorHandler() {
        return editor.getHandler();
    }


    public void setEditorHandler(EditorHandler<T> handler) {
        editor.setHandler(handler);
    }


    public boolean isEditorEnabled() {
        return editor.isEnabled();
    }


    public void setEditorEnabled(boolean enabled) {
        editor.setEnabled(enabled);
    }


    public Widget getEditorWidget(Column<?, T> column) {
        return editor.getWidget(column);
    }


    public void setEditorSaveCaption(String saveCaption)
            throws IllegalArgumentException {
        editor.setSaveCaption(saveCaption);
    }


    public String getEditorSaveCaption() {
        return editor.getSaveCaption();
    }


    public void setEditorCancelCaption(String cancelCaption)
            throws IllegalArgumentException {
        editor.setCancelCaption(cancelCaption);
    }


    public String getEditorCancelCaption() {
        return editor.getCancelCaption();
    }

    @Override
    protected void onAttach() {
        super.onAttach();

        if (getEscalator().getBody().getRowCount() == 0 && dataSource != null) {
            setEscalatorSizeFromDataSource();
        }
    }

    @Override
    protected void onDetach() {
        Set<Integer> details = new HashSet<Integer>(visibleDetails);
        for (int row : details) {
            setDetailsVisible(row, false);
        }

        super.onDetach();
    }

    @Override
    public void onResize() {
        super.onResize();

        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                if (escalator.getInnerWidth() != autoColumnWidthsRecalculator.lastCalculatedInnerWidth) {
                    recalculateColumnWidths();
                }
            }
        });
    }


    @Override
    @Deprecated
    public void add(Widget w) {
        throw new UnsupportedOperationException(
                "Cannot add widgets to Grid with this method");
    }


    @Override
    @Deprecated
    public void clear() {
        throw new UnsupportedOperationException(
                "Cannot clear widgets from Grid this way");
    }


    @Override
    @Deprecated
    public Iterator<Widget> iterator() {
        throw new UnsupportedOperationException(
                "Cannot iterate through widgets in Grid this way");
    }


    @Override
    @Deprecated
    public boolean remove(Widget w) {

        return false;
    }


    private static native final void setParent(Widget widget, Grid<?> parent)
;

    private static native final void onAttach(Widget widget)
;

    private static native final void onDetach(Widget widget)
;

    @Override
    protected void doAttachChildren() {
        if (getSidebar().getParent() == this) {
            onAttach(getSidebar());
        }
    }

    @Override
    protected void doDetachChildren() {
        if (getSidebar().getParent() == this) {
            onDetach(getSidebar());
        }
    }


    public void resetSizesFromDom() {
        getEscalator().resetSizesFromDom();
    }


    public void setDetailsGenerator(DetailsGenerator detailsGenerator)
            throws IllegalArgumentException {

        if (detailsGenerator == null) {
            throw new IllegalArgumentException(
                    "Details generator may not be null");
        }

        this.detailsGenerator = detailsGenerator;


        escalator.getBody().setSpacerUpdater(gridSpacerUpdater);
    }


    public DetailsGenerator getDetailsGenerator() {
        return detailsGenerator;
    }


    public void setDetailsVisible(int rowIndex, boolean visible) {
        Integer rowIndexInteger = Integer.valueOf(rowIndex);



        boolean isVisible = isDetailsVisible(rowIndex);
        if (visible && !isVisible) {
            escalator.getBody().setSpacer(rowIndex, DETAILS_ROW_INITIAL_HEIGHT);
            visibleDetails.add(rowIndexInteger);
        }

        else if (!visible && isVisible) {
            escalator.getBody().setSpacer(rowIndex, -1);
            visibleDetails.remove(rowIndexInteger);
        }
    }


    public boolean isDetailsVisible(int rowIndex) {
        return visibleDetails.contains(Integer.valueOf(rowIndex));
    }


    public void recalculateColumnWidths() {
        autoColumnWidthsRecalculator.schedule();
    }


    private Sidebar getSidebar() {
        return sidebar;
    }


    public MenuBar getSidebarMenu() {
        return sidebar.menuBar;
    }


    public boolean isSidebarOpen() {
        return sidebar.isOpen();
    }


    public void setSidebarOpen(boolean sidebarOpen) {
        if (sidebarOpen) {
            sidebar.open();
        } else {
            sidebar.close();
        }
    }


    public EventCellReference<T> getEventCell() {
        return eventCell;
    }
}

<code block>

package com.vaadin.tests.components.grid;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;
import org.openqa.selenium.Keys;
import org.openqa.selenium.interactions.Actions;

import com.vaadin.testbench.elements.GridElement;
import com.vaadin.testbench.elements.GridElement.GridCellElement;
import com.vaadin.testbench.elements.NotificationElement;
import com.vaadin.testbench.elements.PasswordFieldElement;
import com.vaadin.testbench.parallel.TestCategory;
import com.vaadin.tests.tb3.MultiBrowserTest;

@TestCategory("grid")
public class GridEditorUITest extends MultiBrowserTest {

    @Test
    public void testEditor() {
        setDebug(true);
        openTestURL();

        assertFalse("Sanity check",
                isElementPresent(PasswordFieldElement.class));

        openEditor(5);
        new Actions(getDriver()).sendKeys(Keys.ESCAPE).perform();

        openEditor(10);

        assertTrue("Editor should be opened with a password field",
                isElementPresent(PasswordFieldElement.class));

        assertFalse("Notification was present",
                isElementPresent(NotificationElement.class));
    }

    private void openEditor(int rowIndex) {
        GridElement grid = $(GridElement.class).first();

        GridCellElement cell = grid.getCell(rowIndex, 1);

        new Actions(driver).moveToElement(cell).doubleClick().build().perform();
    }

}

<code block>

package com.vaadin.tests.components.grid;

import com.vaadin.server.VaadinRequest;
import com.vaadin.tests.components.AbstractTestUI;
import com.vaadin.tests.util.PersonContainer;
import com.vaadin.ui.Grid;
import com.vaadin.ui.PasswordField;
import com.vaadin.ui.TextField;

public class GridEditorUI extends AbstractTestUI {

    @Override
    protected void setup(VaadinRequest request) {
        PersonContainer container = PersonContainer.createWithTestData();

        addComponent(createGrid(container));
    }

    protected Grid createGrid(PersonContainer container) {
        Grid grid = new Grid(container);


        grid.removeColumn("address");

        grid.setEditorEnabled(true);

        grid.getColumn("firstName").setEditorField(new PasswordField());

        TextField lastNameField = (TextField) grid.getColumn("lastName")
                .getEditorField();
        lastNameField.setMaxLength(50);

        grid.getColumn("phoneNumber").getEditorField().setReadOnly(true);

        return grid;
    }

}

<code block>

package com.vaadin.tests.components.grid;

import com.vaadin.tests.util.PersonContainer;
import com.vaadin.ui.Grid;

public class GridEditorFrozenColumnsUI extends GridEditorUI {

    @Override
    protected Grid createGrid(PersonContainer container) {
        Grid grid = super.createGrid(container);

        grid.setFrozenColumnCount(2);

        grid.setWidth("600px");

        return grid;
    }

    @Override
    protected Integer getTicketNumber() {
        return 16727;
    }

    @Override
    protected String getTestDescription() {
        return "Frozen columns should also freeze cells in editor.";
    }
}

<code block>

package com.vaadin.tests.components.grid;

import java.io.IOException;

import org.junit.Test;
import org.openqa.selenium.By;
import org.openqa.selenium.JavascriptExecutor;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.interactions.Actions;

import com.vaadin.testbench.elements.GridElement;
import com.vaadin.testbench.elements.GridElement.GridCellElement;
import com.vaadin.testbench.parallel.TestCategory;
import com.vaadin.tests.tb3.MultiBrowserTest;

@TestCategory("grid")
public class GridEditorFrozenColumnsUITest extends MultiBrowserTest {

    @Test
    public void testEditorWithFrozenColumns() throws IOException {
        openTestURL();

        openEditor(10);

        compareScreen("noscroll");

        scrollGridHorizontallyTo(100);

        compareScreen("scrolled");
    }

    private void openEditor(int rowIndex) {
        GridElement grid = $(GridElement.class).first();

        GridCellElement cell = grid.getCell(rowIndex, 1);

        new Actions(driver).moveToElement(cell).doubleClick().build().perform();
    }

    private void scrollGridHorizontallyTo(double px) {
        executeScript("arguments[0].scrollLeft = " + px,
                getGridHorizontalScrollbar());
    }

    private Object executeScript(String script, WebElement element) {
        final WebDriver driver = getDriver();
        if (driver instanceof JavascriptExecutor) {
            final JavascriptExecutor je = (JavascriptExecutor) driver;
            return je.executeScript(script, element);
        } else {
            throw new IllegalStateException("current driver "
                    + getDriver().getClass().getName() + " is not a "
                    + JavascriptExecutor.class.getSimpleName());
        }
    }

    private WebElement getGridHorizontalScrollbar() {
        return getDriver()
                .findElement(
                        By.xpath("//div[contains(@class, \"v-grid-scroller-horizontal\")]"));
    }
}

<code block>

package com.vaadin.tests.components.grid.basicfeatures.client;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import java.util.List;

import org.junit.Before;
import org.junit.Test;
import org.openqa.selenium.By;
import org.openqa.selenium.Keys;
import org.openqa.selenium.NoSuchElementException;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.interactions.Actions;

import com.vaadin.shared.ui.grid.GridConstants;
import com.vaadin.testbench.elements.GridElement.GridCellElement;
import com.vaadin.testbench.elements.GridElement.GridEditorElement;
import com.vaadin.testbench.parallel.BrowserUtil;
import com.vaadin.tests.components.grid.basicfeatures.GridBasicClientFeaturesTest;
import com.vaadin.tests.components.grid.basicfeatures.GridBasicFeatures;

public class GridEditorClientTest extends GridBasicClientFeaturesTest {

    private static final String[] EDIT_ROW_100 = new String[] { "Component",
            "Editor", "Edit row 100" };
    private static final String[] EDIT_ROW_5 = new String[] { "Component",
            "Editor", "Edit row 5" };

    @Before
    public void setUp() {
        openTestURL();
        selectMenuPath("Component", "Editor", "Enabled");
    }

    @Test
    public void testProgrammaticOpeningClosing() {
        selectMenuPath(EDIT_ROW_5);
        assertNotNull(getEditor());

        selectMenuPath("Component", "Editor", "Cancel edit");
        assertNull(getEditor());
        assertEquals("Row 5 edit cancelled",
                findElement(By.className("grid-editor-log")).getText());
    }

    @Test
    public void testProgrammaticOpeningWithScroll() {
        selectMenuPath(EDIT_ROW_100);
        assertNotNull(getEditor());
    }

    @Test(expected = NoSuchElementException.class)
    public void testVerticalScrollLocking() {
        selectMenuPath(EDIT_ROW_5);
        getGridElement().getCell(200, 0);
    }

    @Test
    public void testMouseOpeningClosing() {

        getGridElement().getCell(4, 0).doubleClick();
        assertNotNull(getEditor());

        getCancelButton().click();
        assertNull(getEditor());


        selectMenuPath("Component", "Editor", "Enabled");

        getGridElement().getCell(4, 0).doubleClick();
        assertNull(getEditor());
    }

    @Test
    public void testKeyboardOpeningClosing() {

        getGridElement().getCell(4, 0).click();

        new Actions(getDriver()).sendKeys(Keys.ENTER).perform();

        assertNotNull(getEditor());

        new Actions(getDriver()).sendKeys(Keys.ESCAPE).perform();
        assertNull(getEditor());
        assertEquals("Row 4 edit cancelled",
                findElement(By.className("grid-editor-log")).getText());


        selectMenuPath("Component", "Editor", "Enabled");

        getGridElement().getCell(5, 0).click();
        new Actions(getDriver()).sendKeys(Keys.ENTER).perform();
        assertNull(getEditor());
    }

    @Test
    public void testWidgetBinding() throws Exception {
        selectMenuPath(EDIT_ROW_100);
        WebElement editor = getEditor();

        List<WebElement> widgets = editor.findElements(By
                .className("gwt-TextBox"));

        assertEquals(GridBasicFeatures.EDITABLE_COLUMNS, widgets.size());

        assertEquals("(100, 0)", widgets.get(0).getAttribute("value"));
        assertEquals("(100, 1)", widgets.get(1).getAttribute("value"));
        assertEquals("(100, 2)", widgets.get(2).getAttribute("value"));

        assertEquals("100", widgets.get(6).getAttribute("value"));
        assertEquals("<b>100</b>", widgets.get(8).getAttribute("value"));
    }

    @Test
    public void testWithSelectionColumn() throws Exception {
        selectMenuPath("Component", "State", "Selection mode", "multi");
        selectMenuPath("Component", "State", "Frozen column count",
                "-1 columns");
        selectMenuPath(EDIT_ROW_5);

        WebElement editorCells = findElements(
                By.className("v-grid-editor-cells")).get(1);
        List<WebElement> selectorDivs = editorCells.findElements(By
                .cssSelector("div"));

        assertTrue("selector column cell should've been empty", selectorDivs
                .get(0).getAttribute("innerHTML").isEmpty());
        assertFalse("normal column cell shoul've had contents", selectorDivs
                .get(1).getAttribute("innerHTML").isEmpty());
    }

    @Test
    public void testSave() {
        selectMenuPath(EDIT_ROW_100);

        WebElement textField = getEditor().findElements(
                By.className("gwt-TextBox")).get(0);

        textField.clear();
        textField.sendKeys("Changed");

        WebElement saveButton = getEditor().findElement(
                By.className("v-grid-editor-save"));

        saveButton.click();

        assertEquals("Changed", getGridElement().getCell(100, 0).getText());
    }

    @Test
    public void testProgrammaticSave() {
        selectMenuPath(EDIT_ROW_100);

        WebElement textField = getEditor().findElements(
                By.className("gwt-TextBox")).get(0);

        textField.clear();
        textField.sendKeys("Changed");

        selectMenuPath("Component", "Editor", "Save");

        assertEquals("Changed", getGridElement().getCell(100, 0).getText());
    }

    @Test
    public void testCaptionChange() {
        selectMenuPath(EDIT_ROW_5);
        assertEquals("Save button caption should've been \""
                + GridConstants.DEFAULT_SAVE_CAPTION + "\" to begin with",
                GridConstants.DEFAULT_SAVE_CAPTION, getSaveButton().getText());
        assertEquals("Cancel button caption should've been \""
                + GridConstants.DEFAULT_CANCEL_CAPTION + "\" to begin with",
                GridConstants.DEFAULT_CANCEL_CAPTION, getCancelButton()
                        .getText());

        selectMenuPath("Component", "Editor", "Change Save Caption");
        assertNotEquals(
                "Save button caption should've changed while editor is open",
                GridConstants.DEFAULT_SAVE_CAPTION, getSaveButton().getText());

        getCancelButton().click();

        selectMenuPath("Component", "Editor", "Change Cancel Caption");
        selectMenuPath(EDIT_ROW_5);
        assertNotEquals(
                "Cancel button caption should've changed while editor is closed",
                GridConstants.DEFAULT_CANCEL_CAPTION, getCancelButton()
                        .getText());
    }

    @Test
    public void testUneditableColumn() {
        selectMenuPath("Component", "Editor", "Edit row 5");

        assertFalse("Uneditable column should not have an editor widget",
                getGridElement().getEditor().isEditable(3));
    }

    @Test
    public void testErrorField() {
        selectMenuPath(EDIT_ROW_5);

        GridEditorElement editor = getGridElement().getEditor();

        assertTrue("No errors should be present",
                editor.findElements(By.className("error")).isEmpty());
        assertEquals("No error message should be present", null,
                editor.getErrorMessage());

        selectMenuPath("Component", "Editor", "Toggle second editor error");
        getSaveButton().click();

        assertEquals("Unexpected amount of error fields", 1, editor
                .findElements(By.className("error")).size());
        assertEquals(
                "Unexpedted error message",
                "Syntethic fail of editor in column 2. "
                        + "This message is so long that it doesn't fit into its box",
                editor.getErrorMessage());
    }

    @Test
    public void testFocusOnMouseOpen() {

        GridCellElement cell = getGridElement().getCell(4, 2);

        cell.doubleClick();

        WebElement focused = getFocusedElement();

        assertEquals("", "input", focused.getTagName());
        assertEquals("", cell.getText(), focused.getAttribute("value"));
    }

    @Test
    public void testFocusOnKeyboardOpen() {

        GridCellElement cell = getGridElement().getCell(4, 2);

        cell.click();
        new Actions(getDriver()).sendKeys(Keys.ENTER).perform();

        WebElement focused = getFocusedElement();

        assertEquals("", "input", focused.getTagName());
        assertEquals("", cell.getText(), focused.getAttribute("value"));
    }

    @Test
    public void testNoFocusOnProgrammaticOpen() {

        selectMenuPath(EDIT_ROW_5);

        WebElement focused = getFocusedElement();

        if (BrowserUtil.isIE8(getDesiredCapabilities())) {
            assertEquals("Focus should be in html", "html",
                    focused.getTagName());
        } else if (BrowserUtil.isIE(getDesiredCapabilities())) {
            assertEquals("Focus should be nowhere", null, focused);
        } else {

            assertEquals("Focus should be in body", "body",
                    focused.getTagName());
        }
    }

    protected WebElement getSaveButton() {
        return getEditor().findElement(By.className("v-grid-editor-save"));
    }

    protected WebElement getCancelButton() {
        return getEditor().findElement(By.className("v-grid-editor-cancel"));
    }
}

<code block>

package com.vaadin.tests.components.grid.basicfeatures.server;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import java.util.List;

import org.junit.Before;
import org.junit.Test;
import org.openqa.selenium.By;
import org.openqa.selenium.Keys;
import org.openqa.selenium.NoSuchElementException;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.interactions.Actions;

import com.vaadin.shared.ui.grid.GridConstants;
import com.vaadin.testbench.elements.GridElement.GridCellElement;
import com.vaadin.testbench.elements.GridElement.GridEditorElement;
import com.vaadin.testbench.elements.NotificationElement;
import com.vaadin.tests.components.grid.basicfeatures.GridBasicFeatures;
import com.vaadin.tests.components.grid.basicfeatures.GridBasicFeaturesTest;

public class GridEditorTest extends GridBasicFeaturesTest {

    private static final String[] EDIT_ITEM_5 = new String[] { "Component",
            "Editor", "Edit item 5" };
    private static final String[] EDIT_ITEM_100 = new String[] { "Component",
            "Editor", "Edit item 100" };
    private static final String[] TOGGLE_EDIT_ENABLED = new String[] {
            "Component", "Editor", "Enabled" };

    @Before
    public void setUp() {
        setDebug(true);
        openTestURL();
        selectMenuPath(TOGGLE_EDIT_ENABLED);
    }

    @Test
    public void testProgrammaticOpeningClosing() {
        selectMenuPath(EDIT_ITEM_5);
        assertEditorOpen();

        selectMenuPath("Component", "Editor", "Cancel edit");
        assertEditorClosed();
    }

    @Test
    public void testProgrammaticOpeningWhenDisabled() {
        selectMenuPath(TOGGLE_EDIT_ENABLED);
        selectMenuPath(EDIT_ITEM_5);
        assertEditorClosed();
        boolean thrown = logContainsText("Exception occured, java.lang.IllegalStateException");
        assertTrue("IllegalStateException thrown", thrown);
    }

    @Test
    public void testDisablingWhileOpen() {
        selectMenuPath(EDIT_ITEM_5);
        selectMenuPath(TOGGLE_EDIT_ENABLED);
        assertEditorOpen();
        boolean thrown = logContainsText("Exception occured, java.lang.IllegalStateException");
        assertTrue("IllegalStateException thrown", thrown);
    }

    @Test
    public void testProgrammaticOpeningWithScroll() {
        selectMenuPath(EDIT_ITEM_100);
        assertEditorOpen();
    }

    @Test(expected = NoSuchElementException.class)
    public void testVerticalScrollLocking() {
        selectMenuPath(EDIT_ITEM_5);
        getGridElement().getCell(200, 0);
    }

    @Test
    public void testMouseOpeningClosing() {

        getGridElement().getCell(4, 0).doubleClick();
        assertEditorOpen();

        getCancelButton().click();
        assertEditorClosed();

        selectMenuPath(TOGGLE_EDIT_ENABLED);
        getGridElement().getCell(4, 0).doubleClick();
        assertEditorClosed();
    }

    @Test
    public void testKeyboardOpeningClosing() {

        getGridElement().getCell(4, 0).click();
        assertEditorClosed();

        new Actions(getDriver()).sendKeys(Keys.ENTER).perform();
        assertEditorOpen();

        new Actions(getDriver()).sendKeys(Keys.ESCAPE).perform();
        assertEditorClosed();


        selectMenuPath(TOGGLE_EDIT_ENABLED);
        getGridElement().getCell(5, 0).click();
        new Actions(getDriver()).sendKeys(Keys.ENTER).perform();
        assertEditorClosed();
    }

    @Test
    public void testComponentBinding() {
        selectMenuPath(EDIT_ITEM_100);

        List<WebElement> widgets = getEditorWidgets();
        assertEquals("Number of widgets", GridBasicFeatures.EDITABLE_COLUMNS,
                widgets.size());

        assertEquals("(100, 0)", widgets.get(0).getAttribute("value"));
        assertEquals("(100, 1)", widgets.get(1).getAttribute("value"));
        assertEquals("(100, 2)", widgets.get(2).getAttribute("value"));
        assertEquals("<b>100</b>", widgets.get(8).getAttribute("value"));
    }

    @Test
    public void testSave() {
        selectMenuPath(EDIT_ITEM_100);

        WebElement textField = getEditorWidgets().get(0);

        textField.click();

        textField.sendKeys(" changed");

        WebElement saveButton = getEditor().findElement(
                By.className("v-grid-editor-save"));

        saveButton.click();

        assertEquals("(100, 0) changed", getGridElement().getCell(100, 0)
                .getText());
    }

    @Test
    public void testProgrammaticSave() {
        selectMenuPath(EDIT_ITEM_100);

        WebElement textField = getEditorWidgets().get(0);

        textField.click();

        textField.sendKeys(" changed");

        selectMenuPath("Component", "Editor", "Save");

        assertEquals("(100, 0) changed", getGridElement().getCell(100, 0)
                .getText());
    }

    @Test
    public void testCaptionChange() {
        selectMenuPath(EDIT_ITEM_5);
        assertEquals("Save button caption should've been \""
                + GridConstants.DEFAULT_SAVE_CAPTION + "\" to begin with",
                GridConstants.DEFAULT_SAVE_CAPTION, getSaveButton().getText());
        assertEquals("Cancel button caption should've been \""
                + GridConstants.DEFAULT_CANCEL_CAPTION + "\" to begin with",
                GridConstants.DEFAULT_CANCEL_CAPTION, getCancelButton()
                        .getText());

        selectMenuPath("Component", "Editor", "Change save caption");
        assertNotEquals(
                "Save button caption should've changed while editor is open",
                GridConstants.DEFAULT_SAVE_CAPTION, getSaveButton().getText());

        getCancelButton().click();

        selectMenuPath("Component", "Editor", "Change cancel caption");
        selectMenuPath(EDIT_ITEM_5);
        assertNotEquals(
                "Cancel button caption should've changed while editor is closed",
                GridConstants.DEFAULT_CANCEL_CAPTION, getCancelButton()
                        .getText());
    }

    private void assertEditorOpen() {
        assertNotNull("Editor is supposed to be open", getEditor());
        assertEquals("Unexpected number of widgets",
                GridBasicFeatures.EDITABLE_COLUMNS, getEditorWidgets().size());
    }

    private void assertEditorClosed() {
        assertNull("Editor is supposed to be closed", getEditor());
    }

    private List<WebElement> getEditorWidgets() {
        assertNotNull(getEditor());
        return getEditor().findElements(By.className("v-textfield"));

    }

    @Test
    public void testInvalidEdition() {
        selectMenuPath(EDIT_ITEM_5);
        assertFalse(logContainsText("Exception occured, java.lang.IllegalStateException"));

        GridEditorElement editor = getGridElement().getEditor();

        assertFalse(
                "Field 7 should not have been marked with an error before error",
                editor.isFieldErrorMarked(7));

        WebElement intField = editor.getField(7);
        intField.clear();
        intField.sendKeys("banana phone");
        editor.save();

        assertEquals("Column 7: Could not convert value to Integer",
                editor.getErrorMessage());
        assertTrue("Field 7 should have been marked with an error after error",
                editor.isFieldErrorMarked(7));
        editor.cancel();

        selectMenuPath(EDIT_ITEM_100);
        assertFalse("Exception should not exist",
                isElementPresent(NotificationElement.class));
        assertEquals("There should be no editor error message", null,
                getGridElement().getEditor().getErrorMessage());
    }

    @Test
    public void testNoScrollAfterProgrammaticOpen() {
        int originalScrollPos = getGridVerticalScrollPos();

        selectMenuPath(EDIT_ITEM_5);

        scrollGridVerticallyTo(100);
        assertEquals("Grid shouldn't scroll vertically while editing",
                originalScrollPos, getGridVerticalScrollPos());
    }

    @Test
    public void testNoScrollAfterMouseOpen() {
        int originalScrollPos = getGridVerticalScrollPos();

        GridCellElement cell_5_0 = getGridElement().getCell(5, 0);
        new Actions(getDriver()).doubleClick(cell_5_0).perform();

        scrollGridVerticallyTo(100);
        assertEquals("Grid shouldn't scroll vertically while editing",
                originalScrollPos, getGridVerticalScrollPos());
    }

    @Test
    public void testNoScrollAfterKeyboardOpen() {
        int originalScrollPos = getGridVerticalScrollPos();

        GridCellElement cell_5_0 = getGridElement().getCell(5, 0);
        cell_5_0.click();
        new Actions(getDriver()).sendKeys(Keys.ENTER).perform();

        scrollGridVerticallyTo(100);
        assertEquals("Grid shouldn't scroll vertically while editing",
                originalScrollPos, getGridVerticalScrollPos());
    }

    @Test
    public void testEditorInDisabledGrid() {
        int originalScrollPos = getGridVerticalScrollPos();

        selectMenuPath(EDIT_ITEM_5);
        assertEditorOpen();

        selectMenuPath("Component", "State", "Enabled");
        assertEditorOpen();

        GridEditorElement editor = getGridElement().getEditor();
        editor.save();
        assertEditorOpen();

        editor.cancel();
        assertEditorOpen();

        selectMenuPath("Component", "State", "Enabled");

        scrollGridVerticallyTo(100);
        assertEquals("Grid shouldn't scroll vertically while editing",
                originalScrollPos, getGridVerticalScrollPos());
    }

    @Test
    public void testFocusOnMouseOpen() {

        GridCellElement cell = getGridElement().getCell(4, 2);

        cell.doubleClick();

        WebElement focused = getFocusedElement();

        assertEquals("", "input", focused.getTagName());
        assertEquals("", cell.getText(), focused.getAttribute("value"));
    }

    @Test
    public void testFocusOnKeyboardOpen() {

        GridCellElement cell = getGridElement().getCell(4, 2);

        cell.click();
        new Actions(getDriver()).sendKeys(Keys.ENTER).perform();

        WebElement focused = getFocusedElement();

        assertEquals("", "input", focused.getTagName());
        assertEquals("", cell.getText(), focused.getAttribute("value"));
    }

    @Test
    public void testNoFocusOnProgrammaticOpen() {

        selectMenuPath(EDIT_ITEM_5);

        WebElement focused = getFocusedElement();

        assertEquals("Focus should remain in the menu", "menu",
                focused.getAttribute("id"));
    }

    @Override
    protected WebElement getFocusedElement() {
        return (WebElement) executeScript("return document.activeElement;");
    }

    @Test
    public void testUneditableColumn() {
        selectMenuPath(EDIT_ITEM_5);
        assertEditorOpen();

        GridEditorElement editor = getGridElement().getEditor();
        assertFalse("Uneditable column should not have an editor widget",
                editor.isEditable(3));
        assertEquals(
                "Not editable cell did not contain correct classname",
                "not-editable",
                editor.findElements(By.className("v-grid-editor-cells")).get(1)
                        .findElements(By.xpath("./div")).get(3)
                        .getAttribute("class"));

    }

    private WebElement getSaveButton() {
        return getDriver().findElement(By.className("v-grid-editor-save"));
    }

    private WebElement getCancelButton() {
        return getDriver().findElement(By.className("v-grid-editor-cancel"));
    }
}

<code block>

package com.vaadin.client.widgets;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.google.gwt.core.client.Duration;
import com.google.gwt.core.client.Scheduler;
import com.google.gwt.core.client.Scheduler.ScheduledCommand;
import com.google.gwt.core.shared.GWT;
import com.google.gwt.dom.client.BrowserEvents;
import com.google.gwt.dom.client.DivElement;
import com.google.gwt.dom.client.Element;
import com.google.gwt.dom.client.EventTarget;
import com.google.gwt.dom.client.NativeEvent;
import com.google.gwt.dom.client.Node;
import com.google.gwt.dom.client.Style;
import com.google.gwt.dom.client.Style.Unit;
import com.google.gwt.dom.client.TableCellElement;
import com.google.gwt.dom.client.TableRowElement;
import com.google.gwt.dom.client.TableSectionElement;
import com.google.gwt.dom.client.Touch;
import com.google.gwt.event.dom.client.ClickEvent;
import com.google.gwt.event.dom.client.ClickHandler;
import com.google.gwt.event.dom.client.KeyCodes;
import com.google.gwt.event.dom.client.KeyDownEvent;
import com.google.gwt.event.dom.client.KeyDownHandler;
import com.google.gwt.event.dom.client.KeyEvent;
import com.google.gwt.event.dom.client.MouseEvent;
import com.google.gwt.event.logical.shared.ValueChangeEvent;
import com.google.gwt.event.logical.shared.ValueChangeHandler;
import com.google.gwt.event.shared.HandlerRegistration;
import com.google.gwt.touch.client.Point;
import com.google.gwt.user.client.DOM;
import com.google.gwt.user.client.Event;
import com.google.gwt.user.client.Event.NativePreviewEvent;
import com.google.gwt.user.client.Event.NativePreviewHandler;
import com.google.gwt.user.client.Timer;
import com.google.gwt.user.client.ui.Button;
import com.google.gwt.user.client.ui.CheckBox;
import com.google.gwt.user.client.ui.Composite;
import com.google.gwt.user.client.ui.FlowPanel;
import com.google.gwt.user.client.ui.HasEnabled;
import com.google.gwt.user.client.ui.HasWidgets;
import com.google.gwt.user.client.ui.MenuBar;
import com.google.gwt.user.client.ui.MenuItem;
import com.google.gwt.user.client.ui.ResizeComposite;
import com.google.gwt.user.client.ui.Widget;
import com.vaadin.client.BrowserInfo;
import com.vaadin.client.DeferredWorker;
import com.vaadin.client.Focusable;
import com.vaadin.client.WidgetUtil;
import com.vaadin.client.data.DataChangeHandler;
import com.vaadin.client.data.DataSource;
import com.vaadin.client.renderers.ComplexRenderer;
import com.vaadin.client.renderers.Renderer;
import com.vaadin.client.renderers.WidgetRenderer;
import com.vaadin.client.ui.FocusUtil;
import com.vaadin.client.ui.SubPartAware;
import com.vaadin.client.ui.dd.DragAndDropHandler;
import com.vaadin.client.widget.escalator.Cell;
import com.vaadin.client.widget.escalator.ColumnConfiguration;
import com.vaadin.client.widget.escalator.EscalatorUpdater;
import com.vaadin.client.widget.escalator.FlyweightCell;
import com.vaadin.client.widget.escalator.Row;
import com.vaadin.client.widget.escalator.RowContainer;
import com.vaadin.client.widget.escalator.RowVisibilityChangeEvent;
import com.vaadin.client.widget.escalator.RowVisibilityChangeHandler;
import com.vaadin.client.widget.escalator.ScrollbarBundle.Direction;
import com.vaadin.client.widget.escalator.Spacer;
import com.vaadin.client.widget.escalator.SpacerUpdater;
import com.vaadin.client.widget.grid.AutoScroller;
import com.vaadin.client.widget.grid.AutoScroller.AutoScrollerCallback;
import com.vaadin.client.widget.grid.AutoScroller.ScrollAxis;
import com.vaadin.client.widget.grid.CellReference;
import com.vaadin.client.widget.grid.CellStyleGenerator;
import com.vaadin.client.widget.grid.DataAvailableEvent;
import com.vaadin.client.widget.grid.DataAvailableHandler;
import com.vaadin.client.widget.grid.DetailsGenerator;
import com.vaadin.client.widget.grid.EditorHandler;
import com.vaadin.client.widget.grid.EditorHandler.EditorRequest;
import com.vaadin.client.widget.grid.EventCellReference;
import com.vaadin.client.widget.grid.RendererCellReference;
import com.vaadin.client.widget.grid.RowReference;
import com.vaadin.client.widget.grid.RowStyleGenerator;
import com.vaadin.client.widget.grid.events.AbstractGridKeyEventHandler;
import com.vaadin.client.widget.grid.events.AbstractGridMouseEventHandler;
import com.vaadin.client.widget.grid.events.BodyClickHandler;
import com.vaadin.client.widget.grid.events.BodyDoubleClickHandler;
import com.vaadin.client.widget.grid.events.BodyKeyDownHandler;
import com.vaadin.client.widget.grid.events.BodyKeyPressHandler;
import com.vaadin.client.widget.grid.events.BodyKeyUpHandler;
import com.vaadin.client.widget.grid.events.ColumnReorderEvent;
import com.vaadin.client.widget.grid.events.ColumnReorderHandler;
import com.vaadin.client.widget.grid.events.ColumnVisibilityChangeEvent;
import com.vaadin.client.widget.grid.events.ColumnVisibilityChangeHandler;
import com.vaadin.client.widget.grid.events.FooterClickHandler;
import com.vaadin.client.widget.grid.events.FooterDoubleClickHandler;
import com.vaadin.client.widget.grid.events.FooterKeyDownHandler;
import com.vaadin.client.widget.grid.events.FooterKeyPressHandler;
import com.vaadin.client.widget.grid.events.FooterKeyUpHandler;
import com.vaadin.client.widget.grid.events.GridClickEvent;
import com.vaadin.client.widget.grid.events.GridDoubleClickEvent;
import com.vaadin.client.widget.grid.events.GridKeyDownEvent;
import com.vaadin.client.widget.grid.events.GridKeyPressEvent;
import com.vaadin.client.widget.grid.events.GridKeyUpEvent;
import com.vaadin.client.widget.grid.events.HeaderClickHandler;
import com.vaadin.client.widget.grid.events.HeaderDoubleClickHandler;
import com.vaadin.client.widget.grid.events.HeaderKeyDownHandler;
import com.vaadin.client.widget.grid.events.HeaderKeyPressHandler;
import com.vaadin.client.widget.grid.events.HeaderKeyUpHandler;
import com.vaadin.client.widget.grid.events.ScrollEvent;
import com.vaadin.client.widget.grid.events.ScrollHandler;
import com.vaadin.client.widget.grid.events.SelectAllEvent;
import com.vaadin.client.widget.grid.events.SelectAllHandler;
import com.vaadin.client.widget.grid.selection.HasSelectionHandlers;
import com.vaadin.client.widget.grid.selection.SelectionEvent;
import com.vaadin.client.widget.grid.selection.SelectionHandler;
import com.vaadin.client.widget.grid.selection.SelectionModel;
import com.vaadin.client.widget.grid.selection.SelectionModel.Multi;
import com.vaadin.client.widget.grid.selection.SelectionModelMulti;
import com.vaadin.client.widget.grid.selection.SelectionModelNone;
import com.vaadin.client.widget.grid.selection.SelectionModelSingle;
import com.vaadin.client.widget.grid.sort.Sort;
import com.vaadin.client.widget.grid.sort.SortEvent;
import com.vaadin.client.widget.grid.sort.SortHandler;
import com.vaadin.client.widget.grid.sort.SortOrder;
import com.vaadin.client.widgets.Escalator.AbstractRowContainer;
import com.vaadin.client.widgets.Escalator.SubPartArguments;
import com.vaadin.client.widgets.Grid.Editor.State;
import com.vaadin.client.widgets.Grid.StaticSection.StaticCell;
import com.vaadin.client.widgets.Grid.StaticSection.StaticRow;
import com.vaadin.shared.data.sort.SortDirection;
import com.vaadin.shared.ui.grid.GridConstants;
import com.vaadin.shared.ui.grid.GridStaticCellType;
import com.vaadin.shared.ui.grid.HeightMode;
import com.vaadin.shared.ui.grid.Range;
import com.vaadin.shared.ui.grid.ScrollDestination;
import com.vaadin.shared.util.SharedUtil;


public class Grid<T> extends ResizeComposite implements
        HasSelectionHandlers<T>, SubPartAware, DeferredWorker, HasWidgets,
        HasEnabled {


    public enum Section {
        HEADER, BODY, FOOTER
    }


    public abstract static class StaticSection<ROWTYPE extends StaticSection.StaticRow<?>> {


        public static class StaticCell {

            private Object content = null;

            private int colspan = 1;

            private StaticSection<?> section;

            private GridStaticCellType type = GridStaticCellType.TEXT;

            private String styleName = null;


            public void setText(String text) {
                this.content = text;
                this.type = GridStaticCellType.TEXT;
                section.requestSectionRefresh();
            }


            public String getText() {
                if (type != GridStaticCellType.TEXT) {
                    throw new IllegalStateException(
                            "Cannot fetch Text from a cell with type " + type);
                }
                return (String) content;
            }

            protected StaticSection<?> getSection() {
                assert section != null;
                return section;
            }

            protected void setSection(StaticSection<?> section) {
                this.section = section;
            }


            public int getColspan() {
                return colspan;
            }


            public void setColspan(int colspan) {
                if (colspan < 1) {
                    throw new IllegalArgumentException(
                            "Colspan cannot be less than 1");
                }

                this.colspan = colspan;
                section.requestSectionRefresh();
            }


            public String getHtml() {
                if (type != GridStaticCellType.HTML) {
                    throw new IllegalStateException(
                            "Cannot fetch HTML from a cell with type " + type);
                }
                return (String) content;
            }


            public void setHtml(String html) {
                this.content = html;
                this.type = GridStaticCellType.HTML;
                section.requestSectionRefresh();
            }


            public Widget getWidget() {
                if (type != GridStaticCellType.WIDGET) {
                    throw new IllegalStateException(
                            "Cannot fetch Widget from a cell with type " + type);
                }
                return (Widget) content;
            }


            public void setWidget(Widget widget) {
                this.content = widget;
                this.type = GridStaticCellType.WIDGET;
                section.requestSectionRefresh();
            }


            public GridStaticCellType getType() {
                return type;
            }


            public String getStyleName() {
                return styleName;
            }


            public void setStyleName(String styleName) {
                this.styleName = styleName;
                section.requestSectionRefresh();

            }

        }


        public abstract static class StaticRow<CELLTYPE extends StaticCell> {

            private Map<Column<?, ?>, CELLTYPE> cells = new HashMap<Column<?, ?>, CELLTYPE>();

            private StaticSection<?> section;


            private Map<Set<Column<?, ?>>, CELLTYPE> cellGroups = new HashMap<Set<Column<?, ?>>, CELLTYPE>();


            private String styleName = null;


            public CELLTYPE getCell(Column<?, ?> column) {
                Set<Column<?, ?>> cellGroup = getCellGroupForColumn(column);
                if (cellGroup != null) {
                    return cellGroups.get(cellGroup);
                }
                return cells.get(column);
            }


            public boolean hasSpannedCells() {
                return !cellGroups.isEmpty();
            }


            public CELLTYPE join(Column<?, ?>... columns) {
                if (columns.length <= 1) {
                    throw new IllegalArgumentException(
                            "You can't merge less than 2 columns together.");
                }

                HashSet<Column<?, ?>> columnGroup = new HashSet<Column<?, ?>>();


                for (Column<?, ?> column : columns) {
                    if (!cells.containsKey(column)) {
                        throw new IllegalArgumentException(
                                "Given column does not exists on row " + column);
                    } else if (getCellGroupForColumn(column) != null) {
                        throw new IllegalStateException(
                                "Column is already in a group.");
                    }
                    columnGroup.add(column);
                }

                CELLTYPE joinedCell = createCell();
                cellGroups.put(columnGroup, joinedCell);
                joinedCell.setSection(getSection());

                calculateColspans();

                return joinedCell;
            }


            public CELLTYPE join(CELLTYPE... cells) {
                if (cells.length <= 1) {
                    throw new IllegalArgumentException(
                            "You can't merge less than 2 cells together.");
                }

                Column<?, ?>[] columns = new Column<?, ?>[cells.length];

                int j = 0;
                for (Column<?, ?> column : this.cells.keySet()) {
                    CELLTYPE cell = this.cells.get(column);
                    if (!this.cells.containsValue(cells[j])) {
                        throw new IllegalArgumentException(
                                "Given cell does not exists on row");
                    } else if (cell.equals(cells[j])) {
                        columns[j++] = column;
                        if (j == cells.length) {
                            break;
                        }
                    }
                }

                return join(columns);
            }

            private Set<Column<?, ?>> getCellGroupForColumn(Column<?, ?> column) {
                for (Set<Column<?, ?>> group : cellGroups.keySet()) {
                    if (group.contains(column)) {
                        return group;
                    }
                }
                return null;
            }

            void calculateColspans() {

                for (CELLTYPE cell : this.cells.values()) {
                    cell.setColspan(1);
                }

                for (Set<Column<?, ?>> group : cellGroups.keySet()) {
                    if (!checkMergedCellIsContinuous(group)) {

                        cellGroups.get(group).setColspan(1);
                    } else {
                        int colSpan = 0;
                        for (Column<?, ?> column : group) {
                            if (!column.isHidden()) {
                                colSpan++;
                            }
                        }

                        cellGroups.get(group).setColspan(Math.max(1, colSpan));
                    }
                }

            }

            private boolean checkMergedCellIsContinuous(
                    Set<Column<?, ?>> mergedCell) {

                final List<Column<?, ?>> columnOrder = new ArrayList<Column<?, ?>>(
                        section.grid.getColumns());

                if (!columnOrder.containsAll(mergedCell)) {
                    return false;
                }

                for (int i = 0; i < columnOrder.size(); ++i) {
                    if (!mergedCell.contains(columnOrder.get(i))) {
                        continue;
                    }

                    for (int j = 1; j < mergedCell.size(); ++j) {
                        if (!mergedCell.contains(columnOrder.get(i + j))) {
                            return false;
                        }
                    }
                    return true;
                }
                return false;
            }

            protected void addCell(Column<?, ?> column) {
                CELLTYPE cell = createCell();
                cell.setSection(getSection());
                cells.put(column, cell);
            }

            protected void removeCell(Column<?, ?> column) {
                cells.remove(column);
            }

            protected abstract CELLTYPE createCell();

            protected StaticSection<?> getSection() {
                return section;
            }

            protected void setSection(StaticSection<?> section) {
                this.section = section;
            }


            public String getStyleName() {
                return styleName;
            }


            public void setStyleName(String styleName) {
                this.styleName = styleName;
                section.requestSectionRefresh();
            }
        }

        private Grid<?> grid;

        private List<ROWTYPE> rows = new ArrayList<ROWTYPE>();

        private boolean visible = true;


        protected abstract ROWTYPE createRow();


        protected abstract void requestSectionRefresh();


        public void setVisible(boolean visible) {
            this.visible = visible;
            requestSectionRefresh();
        }


        public boolean isVisible() {
            return visible;
        }


        public ROWTYPE addRowAt(int index) {
            ROWTYPE row = createRow();
            row.setSection(this);
            for (int i = 0; i < getGrid().getColumnCount(); ++i) {
                row.addCell(grid.getColumn(i));
            }
            rows.add(index, row);

            requestSectionRefresh();
            return row;
        }


        public ROWTYPE prependRow() {
            return addRowAt(0);
        }


        public ROWTYPE appendRow() {
            return addRowAt(rows.size());
        }


        public void removeRow(int index) {
            rows.remove(index);
            requestSectionRefresh();
        }


        public void removeRow(ROWTYPE row) {
            try {
                removeRow(rows.indexOf(row));
            } catch (IndexOutOfBoundsException e) {
                throw new IllegalArgumentException(
                        "Section does not contain the given row");
            }
        }


        public ROWTYPE getRow(int index) {
            try {
                return rows.get(index);
            } catch (IndexOutOfBoundsException e) {
                throw new IllegalArgumentException("Row with index " + index
                        + " does not exist");
            }
        }


        public int getRowCount() {
            return rows.size();
        }

        protected List<ROWTYPE> getRows() {
            return rows;
        }

        protected int getVisibleRowCount() {
            return isVisible() ? getRowCount() : 0;
        }

        protected void addColumn(Column<?, ?> column) {
            for (ROWTYPE row : rows) {
                row.addCell(column);
            }
        }

        protected void removeColumn(Column<?, ?> column) {
            for (ROWTYPE row : rows) {
                row.removeCell(column);
            }
        }

        protected void setGrid(Grid<?> grid) {
            this.grid = grid;
        }

        protected Grid<?> getGrid() {
            assert grid != null;
            return grid;
        }

        protected void updateColSpans() {
            for (ROWTYPE row : rows) {
                if (row.hasSpannedCells()) {
                    row.calculateColspans();
                }
            }
        }
    }


    protected static class Header extends StaticSection<HeaderRow> {
        private HeaderRow defaultRow;

        private boolean markAsDirty = false;

        @Override
        public void removeRow(int index) {
            HeaderRow removedRow = getRow(index);
            super.removeRow(index);
            if (removedRow == defaultRow) {
                setDefaultRow(null);
            }
        }


        public void setDefaultRow(HeaderRow row) {
            if (row == defaultRow) {
                return;
            }
            if (row != null && !getRows().contains(row)) {
                throw new IllegalArgumentException(
                        "Cannot set a default row that does not exist in the container");
            }
            if (defaultRow != null) {
                defaultRow.setDefault(false);
            }
            if (row != null) {
                row.setDefault(true);
            }

            defaultRow = row;
            requestSectionRefresh();
        }


        public HeaderRow getDefaultRow() {
            return defaultRow;
        }

        @Override
        protected HeaderRow createRow() {
            return new HeaderRow();
        }

        @Override
        protected void requestSectionRefresh() {
            markAsDirty = true;


            Scheduler.get().scheduleFinally(new Scheduler.ScheduledCommand() {

                @Override
                public void execute() {
                    if (markAsDirty) {
                        markAsDirty = false;
                        getGrid().refreshHeader();
                    }
                }
            });
        }


        public Collection<String> getConsumedEvents() {
            return Arrays.asList(BrowserEvents.TOUCHSTART,
                    BrowserEvents.TOUCHMOVE, BrowserEvents.TOUCHEND,
                    BrowserEvents.TOUCHCANCEL, BrowserEvents.CLICK);
        }

        @Override
        protected void addColumn(Column<?, ?> column) {
            super.addColumn(column);


            if (defaultRow != null) {
                column.setDefaultHeaderContent(defaultRow.getCell(column));
            }
        }
    }


    public static class HeaderRow extends StaticSection.StaticRow<HeaderCell> {

        private boolean isDefault = false;

        protected void setDefault(boolean isDefault) {
            this.isDefault = isDefault;
            if (isDefault) {
                for (Column<?, ?> column : getSection().grid.getColumns()) {
                    column.setDefaultHeaderContent(getCell(column));
                }
            }
        }

        public boolean isDefault() {
            return isDefault;
        }

        @Override
        protected HeaderCell createCell() {
            return new HeaderCell();
        }
    }


    public static class HeaderCell extends StaticSection.StaticCell {
    }


    protected static class Footer extends StaticSection<FooterRow> {
        private boolean markAsDirty = false;

        @Override
        protected FooterRow createRow() {
            return new FooterRow();
        }

        @Override
        protected void requestSectionRefresh() {
            markAsDirty = true;


            Scheduler.get().scheduleFinally(new Scheduler.ScheduledCommand() {

                @Override
                public void execute() {
                    if (markAsDirty) {
                        markAsDirty = false;
                        getGrid().refreshFooter();
                    }
                }
            });
        }
    }


    public static class FooterCell extends StaticSection.StaticCell {
    }


    public static class FooterRow extends StaticSection.StaticRow<FooterCell> {

        @Override
        protected FooterCell createCell() {
            return new FooterCell();
        }
    }

    private static class EditorRequestImpl<T> implements EditorRequest<T> {


        public static interface RequestCallback<T> {

            public void onSuccess(EditorRequest<T> request);


            public void onError(EditorRequest<T> request);
        }

        private Grid<T> grid;
        private int rowIndex;
        private RequestCallback<T> callback;
        private boolean completed = false;

        public EditorRequestImpl(Grid<T> grid, int rowIndex,
                RequestCallback<T> callback) {
            this.grid = grid;
            this.rowIndex = rowIndex;
            this.callback = callback;
        }

        @Override
        public int getRowIndex() {
            return rowIndex;
        }

        @Override
        public T getRow() {
            return grid.getDataSource().getRow(rowIndex);
        }

        @Override
        public Grid<T> getGrid() {
            return grid;
        }

        @Override
        public Widget getWidget(Grid.Column<?, T> column) {
            Widget w = grid.getEditorWidget(column);
            assert w != null;
            return w;
        }

        private void complete(String errorMessage,
                Collection<Column<?, T>> errorColumns) {
            if (completed) {
                throw new IllegalStateException(
                        "An EditorRequest must be completed exactly once");
            }
            completed = true;

            grid.getEditor().setErrorMessage(errorMessage);

            grid.getEditor().clearEditorColumnErrors();
            if (errorColumns != null) {
                for (Column<?, T> column : errorColumns) {
                    grid.getEditor().setEditorColumnError(column, true);
                }
            }
        }

        @Override
        public void success() {
            complete(null, null);
            if (callback != null) {
                callback.onSuccess(this);
            }
        }

        @Override
        public void failure(String errorMessage,
                Collection<Grid.Column<?, T>> errorColumns) {
            complete(errorMessage, errorColumns);
            if (callback != null) {
                callback.onError(this);
            }
        }

        @Override
        public boolean isCompleted() {
            return completed;
        }
    }


    protected static class Editor<T> {

        public static final int KEYCODE_SHOW = KeyCodes.KEY_ENTER;
        public static final int KEYCODE_HIDE = KeyCodes.KEY_ESCAPE;

        private static final String ERROR_CLASS_NAME = "error";
        private static final String NOT_EDITABLE_CLASS_NAME = "not-editable";

        protected enum State {
            INACTIVE, ACTIVATING, BINDING, ACTIVE, SAVING
        }

        private Grid<T> grid;
        private EditorHandler<T> handler;

        private DivElement editorOverlay = DivElement.as(DOM.createDiv());
        private DivElement cellWrapper = DivElement.as(DOM.createDiv());
        private DivElement frozenCellWrapper = DivElement.as(DOM.createDiv());

        private DivElement messageAndButtonsWrapper = DivElement.as(DOM
                .createDiv());

        private DivElement messageWrapper = DivElement.as(DOM.createDiv());
        private DivElement buttonsWrapper = DivElement.as(DOM.createDiv());



        private DivElement message = DivElement.as(DOM.createDiv());

        private Map<Column<?, T>, Widget> columnToWidget = new HashMap<Column<?, T>, Widget>();

        private boolean enabled = false;
        private State state = State.INACTIVE;
        private int rowIndex = -1;
        private int columnIndex = -1;
        private String styleName = null;

        private HandlerRegistration scrollHandler;

        private final Button saveButton;
        private final Button cancelButton;

        private static final int SAVE_TIMEOUT_MS = 5000;
        private final Timer saveTimeout = new Timer() {
            @Override
            public void run() {
                getLogger().warning(
                        "Editor save action is taking longer than expected ("
                                + SAVE_TIMEOUT_MS + "ms). Does your "
                                + EditorHandler.class.getSimpleName()
                                + " remember to call success() or fail()?");
            }
        };

        private final EditorRequestImpl.RequestCallback<T> saveRequestCallback = new EditorRequestImpl.RequestCallback<T>() {
            @Override
            public void onSuccess(EditorRequest<T> request) {
                if (state == State.SAVING) {
                    cleanup();
                    cancel();
                }
            }

            @Override
            public void onError(EditorRequest<T> request) {
                if (state == State.SAVING) {
                    cleanup();


                    getLogger().warning(
                            "An error occurred when trying to save the "
                                    + "modified row");
                }
            }

            private void cleanup() {
                state = State.ACTIVE;
                setButtonsEnabled(true);
                saveTimeout.cancel();
            }
        };

        private static final int BIND_TIMEOUT_MS = 5000;
        private final Timer bindTimeout = new Timer() {
            @Override
            public void run() {
                getLogger().warning(
                        "Editor bind action is taking longer than expected ("
                                + BIND_TIMEOUT_MS + "ms). Does your "
                                + EditorHandler.class.getSimpleName()
                                + " remember to call success() or fail()?");
            }
        };
        private final EditorRequestImpl.RequestCallback<T> bindRequestCallback = new EditorRequestImpl.RequestCallback<T>() {
            @Override
            public void onSuccess(EditorRequest<T> request) {
                if (state == State.BINDING) {
                    state = State.ACTIVE;
                    bindTimeout.cancel();

                    assert rowIndex == request.getRowIndex() : "Request row index "
                            + request.getRowIndex()
                            + " did not match the saved row index " + rowIndex;

                    showOverlay();
                }
            }

            @Override
            public void onError(EditorRequest<T> request) {
                if (state == State.BINDING) {
                    state = State.INACTIVE;
                    bindTimeout.cancel();


                    getLogger().warning(
                            "An error occurred while trying to show the "
                                    + "Grid editor");
                    grid.getEscalator().setScrollLocked(Direction.VERTICAL,
                            false);
                    updateSelectionCheckboxesAsNeeded(true);
                }
            }
        };


        private final Set<Column<?, T>> columnErrors = new HashSet<Grid.Column<?, T>>();

        public Editor() {
            saveButton = new Button();
            saveButton.setText(GridConstants.DEFAULT_SAVE_CAPTION);
            saveButton.addClickHandler(new ClickHandler() {
                @Override
                public void onClick(ClickEvent event) {
                    save();
                }
            });

            cancelButton = new Button();
            cancelButton.setText(GridConstants.DEFAULT_CANCEL_CAPTION);
            cancelButton.addClickHandler(new ClickHandler() {
                @Override
                public void onClick(ClickEvent event) {
                    cancel();
                }
            });
        }

        public void setErrorMessage(String errorMessage) {
            if (errorMessage == null) {
                message.removeFromParent();
            } else {
                message.setInnerText(errorMessage);
                if (message.getParentElement() == null) {
                    messageWrapper.appendChild(message);
                }
            }
        }

        public int getRow() {
            return rowIndex;
        }


        public void editRow(int rowIndex) {
            editRow(rowIndex, -1);
        }


        public void editRow(int rowIndex, int columnIndex) {
            if (!enabled) {
                throw new IllegalStateException(
                        "Cannot edit row: editor is not enabled");
            }
            if (state != State.INACTIVE) {
                throw new IllegalStateException(
                        "Cannot edit row: editor already in edit mode");
            }

            this.rowIndex = rowIndex;
            this.columnIndex = columnIndex;

            state = State.ACTIVATING;

            if (grid.getEscalator().getVisibleRowRange().contains(rowIndex)) {
                show();
            } else {
                grid.scrollToRow(rowIndex, ScrollDestination.MIDDLE);
            }
        }


        public void cancel() {
            if (!enabled) {
                throw new IllegalStateException(
                        "Cannot cancel edit: editor is not enabled");
            }
            if (state == State.INACTIVE) {
                throw new IllegalStateException(
                        "Cannot cancel edit: editor is not in edit mode");
            }
            hideOverlay();
            grid.getEscalator().setScrollLocked(Direction.VERTICAL, false);

            EditorRequest<T> request = new EditorRequestImpl<T>(grid, rowIndex,
                    null);
            handler.cancel(request);
            state = State.INACTIVE;
            updateSelectionCheckboxesAsNeeded(true);
        }

        private void updateSelectionCheckboxesAsNeeded(boolean isEnabled) {
            if (grid.getSelectionModel() instanceof Multi) {
                grid.refreshBody();
                CheckBox checkBox = (CheckBox) grid.getDefaultHeaderRow()
                        .getCell(grid.selectionColumn).getWidget();
                checkBox.setEnabled(isEnabled);
            }
        }


        public void save() {
            if (!enabled) {
                throw new IllegalStateException(
                        "Cannot save: editor is not enabled");
            }
            if (state != State.ACTIVE) {
                throw new IllegalStateException(
                        "Cannot save: editor is not in edit mode");
            }

            state = State.SAVING;
            setButtonsEnabled(false);
            saveTimeout.schedule(SAVE_TIMEOUT_MS);
            EditorRequest<T> request = new EditorRequestImpl<T>(grid, rowIndex,
                    saveRequestCallback);
            handler.save(request);
            updateSelectionCheckboxesAsNeeded(true);
        }


        public EditorHandler<T> getHandler() {
            return handler;
        }


        public void setHandler(EditorHandler<T> rowHandler) {
            if (state != State.INACTIVE) {
                throw new IllegalStateException(
                        "Cannot set EditorHandler: editor is currently in edit mode");
            }
            handler = rowHandler;
        }

        public boolean isEnabled() {
            return enabled;
        }


        public void setEnabled(boolean enabled) {
            if (enabled == false && state != State.INACTIVE) {
                throw new IllegalStateException(
                        "Cannot disable: editor is in edit mode");
            } else if (enabled == true && getHandler() == null) {
                throw new IllegalStateException(
                        "Cannot enable: EditorHandler not set");
            }
            this.enabled = enabled;
        }

        protected void show() {
            if (state == State.ACTIVATING) {
                state = State.BINDING;
                bindTimeout.schedule(BIND_TIMEOUT_MS);
                EditorRequest<T> request = new EditorRequestImpl<T>(grid,
                        rowIndex, bindRequestCallback);
                handler.bind(request);
                grid.getEscalator().setScrollLocked(Direction.VERTICAL, true);
                updateSelectionCheckboxesAsNeeded(false);
            }
        }

        protected void setGrid(final Grid<T> grid) {
            assert grid != null : "Grid cannot be null";
            assert this.grid == null : "Can only attach editor to Grid once";

            this.grid = grid;

            grid.addDataAvailableHandler(new DataAvailableHandler() {
                @Override
                public void onDataAvailable(DataAvailableEvent event) {
                    if (event.getAvailableRows().contains(rowIndex)) {
                        show();
                    }
                }
            });
        }

        protected State getState() {
            return state;
        }

        protected void setState(State state) {
            this.state = state;
        }


        protected Widget getWidget(Column<?, T> column) {
            return columnToWidget.get(column);
        }


        @Deprecated
        protected void showOverlay(TableRowElement unused) {
            showOverlay();
        }


        protected void showOverlay() {

            DivElement gridElement = DivElement.as(grid.getElement());

            TableRowElement tr = grid.getEscalator().getBody()
                    .getRowElement(rowIndex);

            scrollHandler = grid.addScrollHandler(new ScrollHandler() {
                @Override
                public void onScroll(ScrollEvent event) {
                    updateHorizontalScrollPosition();
                }
            });

            gridElement.appendChild(editorOverlay);
            editorOverlay.appendChild(frozenCellWrapper);
            editorOverlay.appendChild(cellWrapper);
            editorOverlay.appendChild(messageAndButtonsWrapper);

            int frozenColumns = grid.getVisibleFrozenColumnCount();
            double frozenColumnsWidth = 0;
            double cellHeight = 0;

            for (int i = 0; i < tr.getCells().getLength(); i++) {
                Element cell = createCell(tr.getCells().getItem(i));
                cellHeight = Math.max(cellHeight, WidgetUtil
                        .getRequiredHeightBoundingClientRectDouble(tr
                                .getCells().getItem(i)));

                Column<?, T> column = grid.getVisibleColumn(i);

                if (i < frozenColumns) {
                    frozenCellWrapper.appendChild(cell);
                    frozenColumnsWidth += WidgetUtil
                            .getRequiredWidthBoundingClientRectDouble(tr
                                    .getCells().getItem(i));
                } else {
                    cellWrapper.appendChild(cell);
                }

                if (column.isEditable()) {
                    Widget editor = getHandler().getWidget(column);

                    if (editor != null) {
                        columnToWidget.put(column, editor);
                        attachWidget(editor, cell);
                    }

                    if (i == columnIndex) {
                        if (editor instanceof Focusable) {
                            ((Focusable) editor).focus();
                        } else if (editor instanceof com.google.gwt.user.client.ui.Focusable) {
                            ((com.google.gwt.user.client.ui.Focusable) editor)
                                    .setFocus(true);
                        }
                    }
                } else {
                    cell.addClassName(NOT_EDITABLE_CLASS_NAME);
                }
            }

            setBounds(frozenCellWrapper, 0, 0, frozenColumnsWidth, 0);
            setBounds(cellWrapper, frozenColumnsWidth, 0, tr.getOffsetWidth()
                    - frozenColumnsWidth, cellHeight);


            if (!messageAndButtonsWrapper.isOrHasChild(messageWrapper)) {
                messageAndButtonsWrapper.appendChild(messageWrapper);
                messageAndButtonsWrapper.appendChild(buttonsWrapper);
            }

            attachWidget(saveButton, buttonsWrapper);
            attachWidget(cancelButton, buttonsWrapper);

            updateHorizontalScrollPosition();

            AbstractRowContainer body = (AbstractRowContainer) grid
                    .getEscalator().getBody();
            double rowTop = body.getRowTop(tr);

            int bodyTop = body.getElement().getAbsoluteTop();
            int gridTop = gridElement.getAbsoluteTop();
            double overlayTop = rowTop + bodyTop - gridTop;

            if (buttonsShouldBeRenderedBelow(tr)) {

                editorOverlay.getStyle().setTop(overlayTop, Unit.PX);
                editorOverlay.getStyle().clearBottom();
            } else {



                editorOverlay.insertFirst(messageAndButtonsWrapper);
                int gridHeight = grid.getElement().getOffsetHeight();
                editorOverlay.getStyle()
                        .setBottom(
                                gridHeight - overlayTop - tr.getOffsetHeight(),
                                Unit.PX);
                editorOverlay.getStyle().clearTop();
            }


            editorOverlay.getStyle().setWidth(grid.escalator.getInnerWidth(),
                    Unit.PX);
        }

        private boolean buttonsShouldBeRenderedBelow(TableRowElement tr) {
            TableSectionElement tfoot = grid.escalator.getFooter().getElement();
            double tfootPageTop = WidgetUtil.getBoundingClientRect(tfoot)
                    .getTop();
            double trPageBottom = WidgetUtil.getBoundingClientRect(tr)
                    .getBottom();
            int messageAndButtonsHeight = messageAndButtonsWrapper
                    .getOffsetHeight();
            double bottomOfButtons = trPageBottom + messageAndButtonsHeight;
            return bottomOfButtons < tfootPageTop;
        }

        protected void hideOverlay() {
            for (Widget w : columnToWidget.values()) {
                setParent(w, null);
            }
            columnToWidget.clear();

            detachWidget(saveButton);
            detachWidget(cancelButton);

            editorOverlay.removeAllChildren();
            cellWrapper.removeAllChildren();
            frozenCellWrapper.removeAllChildren();
            editorOverlay.removeFromParent();

            scrollHandler.removeHandler();

            clearEditorColumnErrors();
        }

        protected void setStylePrimaryName(String primaryName) {
            if (styleName != null) {
                editorOverlay.removeClassName(styleName);

                cellWrapper.removeClassName(styleName + "-cells");
                frozenCellWrapper.removeClassName(styleName + "-cells");
                messageAndButtonsWrapper.removeClassName(styleName + "-footer");

                messageWrapper.removeClassName(styleName + "-message");
                buttonsWrapper.removeClassName(styleName + "-buttons");

                saveButton.removeStyleName(styleName + "-save");
                cancelButton.removeStyleName(styleName + "-cancel");
            }
            styleName = primaryName + "-editor";
            editorOverlay.setClassName(styleName);

            cellWrapper.setClassName(styleName + "-cells");
            frozenCellWrapper.setClassName(styleName + "-cells frozen");
            messageAndButtonsWrapper.setClassName(styleName + "-footer");

            messageWrapper.setClassName(styleName + "-message");
            buttonsWrapper.setClassName(styleName + "-buttons");

            saveButton.setStyleName(styleName + "-save");
            cancelButton.setStyleName(styleName + "-cancel");
        }


        protected Element createCell(TableCellElement td) {
            DivElement cell = DivElement.as(DOM.createDiv());
            double width = WidgetUtil
                    .getRequiredWidthBoundingClientRectDouble(td);
            double height = WidgetUtil
                    .getRequiredHeightBoundingClientRectDouble(td);
            setBounds(cell, td.getOffsetLeft(), td.getOffsetTop(), width,
                    height);
            return cell;
        }

        private void attachWidget(Widget w, Element parent) {
            parent.appendChild(w.getElement());
            setParent(w, grid);
        }

        private void detachWidget(Widget w) {
            setParent(w, null);
            w.getElement().removeFromParent();
        }

        private static void setBounds(Element e, double left, double top,
                double width, double height) {
            Style style = e.getStyle();
            style.setLeft(left, Unit.PX);
            style.setTop(top, Unit.PX);
            style.setWidth(width, Unit.PX);
            style.setHeight(height, Unit.PX);
        }

        private void updateHorizontalScrollPosition() {
            double scrollLeft = grid.getScrollLeft();
            cellWrapper.getStyle().setLeft(
                    frozenCellWrapper.getOffsetWidth() - scrollLeft, Unit.PX);
        }

        protected void setGridEnabled(boolean enabled) {


            setButtonsEnabled(enabled);
        }

        private void setButtonsEnabled(boolean enabled) {
            saveButton.setEnabled(enabled);
            cancelButton.setEnabled(enabled);
        }

        public void setSaveCaption(String saveCaption)
                throws IllegalArgumentException {
            if (saveCaption == null) {
                throw new IllegalArgumentException(
                        "Save caption cannot be null");
            }
            saveButton.setText(saveCaption);
        }

        public String getSaveCaption() {
            return saveButton.getText();
        }

        public void setCancelCaption(String cancelCaption)
                throws IllegalArgumentException {
            if (cancelCaption == null) {
                throw new IllegalArgumentException(
                        "Cancel caption cannot be null");
            }
            cancelButton.setText(cancelCaption);
        }

        public String getCancelCaption() {
            return cancelButton.getText();
        }

        public void setEditorColumnError(Column<?, T> column, boolean hasError) {
            if (state != State.ACTIVE && state != State.SAVING) {
                throw new IllegalStateException("Cannot set cell error "
                        + "status: editor is neither active nor saving.");
            }

            if (isEditorColumnError(column) == hasError) {
                return;
            }

            Element editorCell = getWidget(column).getElement()
                    .getParentElement();
            if (hasError) {
                editorCell.addClassName(ERROR_CLASS_NAME);
                columnErrors.add(column);
            } else {
                editorCell.removeClassName(ERROR_CLASS_NAME);
                columnErrors.remove(column);
            }
        }

        public void clearEditorColumnErrors() {


            Element e = editorOverlay.getFirstChildElement();
            while (e != null) {
                e.removeClassName(ERROR_CLASS_NAME);
                e = e.getNextSiblingElement();
            }

            columnErrors.clear();
        }

        public boolean isEditorColumnError(Column<?, T> column) {
            return columnErrors.contains(column);
        }
    }

    public static abstract class AbstractGridKeyEvent<HANDLER extends AbstractGridKeyEventHandler>
            extends KeyEvent<HANDLER> {

        private Grid<?> grid;
        private final Type<HANDLER> associatedType = new Type<HANDLER>(
                getBrowserEventType(), this);
        private final CellReference<?> targetCell;

        public AbstractGridKeyEvent(Grid<?> grid, CellReference<?> targetCell) {
            this.grid = grid;
            this.targetCell = targetCell;
        }

        protected abstract String getBrowserEventType();


        public Grid<?> getGrid() {
            return grid;
        }


        public CellReference<?> getFocusedCell() {
            return targetCell;
        }

        @Override
        protected void dispatch(HANDLER handler) {
            EventTarget target = getNativeEvent().getEventTarget();
            if (Element.is(target)
                    && !grid.isElementInChildWidget(Element.as(target))) {

                Section section = Section.FOOTER;
                final RowContainer container = grid.cellFocusHandler.containerWithFocus;
                if (container == grid.escalator.getHeader()) {
                    section = Section.HEADER;
                } else if (container == grid.escalator.getBody()) {
                    section = Section.BODY;
                }

                doDispatch(handler, section);
            }
        }

        protected abstract void doDispatch(HANDLER handler, Section section);

        @Override
        public Type<HANDLER> getAssociatedType() {
            return associatedType;
        }
    }

    public static abstract class AbstractGridMouseEvent<HANDLER extends AbstractGridMouseEventHandler>
            extends MouseEvent<HANDLER> {

        private Grid<?> grid;
        private final CellReference<?> targetCell;
        private final Type<HANDLER> associatedType = new Type<HANDLER>(
                getBrowserEventType(), this);

        public AbstractGridMouseEvent(Grid<?> grid, CellReference<?> targetCell) {
            this.grid = grid;
            this.targetCell = targetCell;
        }

        protected abstract String getBrowserEventType();


        public Grid<?> getGrid() {
            return grid;
        }


        public CellReference<?> getTargetCell() {
            return targetCell;
        }

        @Override
        protected void dispatch(HANDLER handler) {
            EventTarget target = getNativeEvent().getEventTarget();
            if (!Element.is(target)) {

                return;
            }

            Element targetElement = Element.as(target);
            if (grid.isElementInChildWidget(targetElement)) {

                return;
            }

            final RowContainer container = grid.escalator
                    .findRowContainer(targetElement);
            if (container == null) {

                return;
            }

            Section section = Section.FOOTER;
            if (container == grid.escalator.getHeader()) {
                section = Section.HEADER;
            } else if (container == grid.escalator.getBody()) {
                section = Section.BODY;
            }

            doDispatch(handler, section);
        }

        protected abstract void doDispatch(HANDLER handler, Section section);

        @Override
        public Type<HANDLER> getAssociatedType() {
            return associatedType;
        }
    }

    private static final String CUSTOM_STYLE_PROPERTY_NAME = "customStyle";


    private static final double DETAILS_ROW_INITIAL_HEIGHT = 50;

    private EventCellReference<T> eventCell = new EventCellReference<T>(this);
    private GridKeyDownEvent keyDown = new GridKeyDownEvent(this, eventCell);
    private GridKeyUpEvent keyUp = new GridKeyUpEvent(this, eventCell);
    private GridKeyPressEvent keyPress = new GridKeyPressEvent(this, eventCell);
    private GridClickEvent clickEvent = new GridClickEvent(this, eventCell);
    private GridDoubleClickEvent doubleClickEvent = new GridDoubleClickEvent(
            this, eventCell);

    private class CellFocusHandler {

        private RowContainer containerWithFocus = escalator.getBody();
        private int rowWithFocus = 0;
        private Range cellFocusRange = Range.withLength(0, 1);
        private int lastFocusedBodyRow = 0;
        private int lastFocusedHeaderRow = 0;
        private int lastFocusedFooterRow = 0;
        private TableCellElement cellWithFocusStyle = null;
        private TableRowElement rowWithFocusStyle = null;

        public CellFocusHandler() {
            sinkEvents(getNavigationEvents());
        }

        private Cell getFocusedCell() {
            return new Cell(rowWithFocus, cellFocusRange.getStart(),
                    cellWithFocusStyle);
        }


        public void updateFocusedCellStyle(FlyweightCell cell,
                RowContainer cellContainer) {
            int cellRow = cell.getRow();
            int cellColumn = cell.getColumn();
            int colSpan = cell.getColSpan();
            boolean columnHasFocus = Range.withLength(cellColumn, colSpan)
                    .intersects(cellFocusRange);

            if (cellContainer == containerWithFocus) {

                if (cellRow == rowWithFocus && columnHasFocus) {
                    if (cellWithFocusStyle != cell.getElement()) {

                        if (cellWithFocusStyle != null) {

                            setStyleName(cellWithFocusStyle,
                                    cellFocusStyleName, false);
                        }
                        cellWithFocusStyle = cell.getElement();


                        setStyleName(cellWithFocusStyle, cellFocusStyleName,
                                true);
                    }
                } else if (cellWithFocusStyle == cell.getElement()) {


                    setStyleName(cellWithFocusStyle, cellFocusStyleName, false);
                    cellWithFocusStyle = null;
                }
            }
        }


        public void updateFocusedRowStyle(Row row) {
            if (rowWithFocus == row.getRow()
                    && containerWithFocus == escalator.getBody()) {
                if (row.getElement() != rowWithFocusStyle) {

                    if (rowWithFocusStyle != null) {
                        setStyleName(rowWithFocusStyle, rowFocusStyleName,
                                false);
                    }
                    rowWithFocusStyle = row.getElement();
                    setStyleName(rowWithFocusStyle, rowFocusStyleName, true);
                }
            } else if (rowWithFocusStyle == row.getElement()
                    || (containerWithFocus != escalator.getBody() && rowWithFocusStyle != null)) {

                setStyleName(rowWithFocusStyle, rowFocusStyleName, false);
                rowWithFocusStyle = null;
            }
        }


        private void setCellFocus(int rowIndex, int columnIndexDOM,
                RowContainer container) {
            if (rowIndex == rowWithFocus
                    && cellFocusRange.contains(columnIndexDOM)
                    && container == this.containerWithFocus) {
                refreshRow(rowWithFocus);
                return;
            }

            int oldRow = rowWithFocus;
            rowWithFocus = rowIndex;
            Range oldRange = cellFocusRange;

            if (container == escalator.getBody()) {
                scrollToRow(rowWithFocus);
                cellFocusRange = Range.withLength(columnIndexDOM, 1);
            } else {
                int i = 0;
                Element cell = container.getRowElement(rowWithFocus)
                        .getFirstChildElement();
                do {
                    int colSpan = cell
                            .getPropertyInt(FlyweightCell.COLSPAN_ATTR);
                    Range cellRange = Range.withLength(i, colSpan);
                    if (cellRange.contains(columnIndexDOM)) {
                        cellFocusRange = cellRange;
                        break;
                    }
                    cell = cell.getNextSiblingElement();
                    ++i;
                } while (cell != null);
            }
            int columnIndex = getColumns().indexOf(
                    getVisibleColumn(columnIndexDOM));
            if (columnIndex >= escalator.getColumnConfiguration()
                    .getFrozenColumnCount()) {
                escalator.scrollToColumn(columnIndexDOM, ScrollDestination.ANY,
                        10);
            }

            if (this.containerWithFocus == container) {
                if (oldRange.equals(cellFocusRange) && oldRow != rowWithFocus) {
                    refreshRow(oldRow);
                } else {
                    refreshHeader();
                    refreshFooter();
                }
            } else {
                RowContainer oldContainer = this.containerWithFocus;
                this.containerWithFocus = container;

                if (oldContainer == escalator.getBody()) {
                    lastFocusedBodyRow = oldRow;
                } else if (oldContainer == escalator.getHeader()) {
                    lastFocusedHeaderRow = oldRow;
                } else {
                    lastFocusedFooterRow = oldRow;
                }

                if (!oldRange.equals(cellFocusRange)) {
                    refreshHeader();
                    refreshFooter();
                    if (oldContainer == escalator.getBody()) {
                        oldContainer.refreshRows(oldRow, 1);
                    }
                } else {
                    oldContainer.refreshRows(oldRow, 1);
                }
            }
            refreshRow(rowWithFocus);
        }


        public void setCellFocus(CellReference<T> cell) {
            setCellFocus(cell.getRowIndex(), cell.getColumnIndexDOM(),
                    escalator.findRowContainer(cell.getElement()));
        }


        public Collection<String> getNavigationEvents() {
            return Arrays.asList(BrowserEvents.KEYDOWN, BrowserEvents.CLICK);
        }


        public void handleNavigationEvent(Event event, CellReference<T> cell) {
            if (event.getType().equals(BrowserEvents.CLICK)) {
                setCellFocus(cell);

                getElement().focus();
            } else if (event.getType().equals(BrowserEvents.KEYDOWN)) {
                int newRow = rowWithFocus;
                RowContainer newContainer = containerWithFocus;
                int newColumn = cellFocusRange.getStart();

                switch (event.getKeyCode()) {
                case KeyCodes.KEY_DOWN:
                    ++newRow;
                    break;
                case KeyCodes.KEY_UP:
                    --newRow;
                    break;
                case KeyCodes.KEY_RIGHT:
                    if (cellFocusRange.getEnd() >= getVisibleColumns().size()) {
                        return;
                    }
                    newColumn = cellFocusRange.getEnd();
                    break;
                case KeyCodes.KEY_LEFT:
                    if (newColumn == 0) {
                        return;
                    }
                    --newColumn;
                    break;
                case KeyCodes.KEY_TAB:
                    if (event.getShiftKey()) {
                        newContainer = getPreviousContainer(containerWithFocus);
                    } else {
                        newContainer = getNextContainer(containerWithFocus);
                    }

                    if (newContainer == containerWithFocus) {
                        return;
                    }
                    break;
                case KeyCodes.KEY_HOME:
                    if (newContainer.getRowCount() > 0) {
                        newRow = 0;
                    }
                    break;
                case KeyCodes.KEY_END:
                    if (newContainer.getRowCount() > 0) {
                        newRow = newContainer.getRowCount() - 1;
                    }
                    break;
                case KeyCodes.KEY_PAGEDOWN:
                case KeyCodes.KEY_PAGEUP:
                    if (newContainer.getRowCount() > 0) {
                        boolean down = event.getKeyCode() == KeyCodes.KEY_PAGEDOWN;





                        int firstVisible = getFirstVisibleRowIndex();
                        int lastVisible = getLastVisibleRowIndex();
                        if (newRow < firstVisible || newRow > lastVisible) {
                            newRow = down ? lastVisible : firstVisible;
                        }



                        int moveFocusBy = Math.max(1, lastVisible
                                - firstVisible - 1);
                        moveFocusBy *= down ? 1 : -1;
                        newRow += moveFocusBy;
                        newRow = Math.max(0, Math.min(
                                newContainer.getRowCount() - 1, newRow));
                    }
                    break;
                default:
                    return;
                }

                if (newContainer != containerWithFocus) {
                    if (newContainer == escalator.getBody()) {
                        newRow = lastFocusedBodyRow;
                    } else if (newContainer == escalator.getHeader()) {
                        newRow = lastFocusedHeaderRow;
                    } else {
                        newRow = lastFocusedFooterRow;
                    }
                } else if (newRow < 0) {
                    newContainer = getPreviousContainer(newContainer);

                    if (newContainer == containerWithFocus) {
                        newRow = 0;
                    } else if (newContainer == escalator.getBody()) {
                        newRow = getLastVisibleRowIndex();
                    } else {
                        newRow = newContainer.getRowCount() - 1;
                    }
                } else if (newRow >= containerWithFocus.getRowCount()) {
                    newContainer = getNextContainer(newContainer);

                    if (newContainer == containerWithFocus) {
                        newRow = containerWithFocus.getRowCount() - 1;
                    } else if (newContainer == escalator.getBody()) {
                        newRow = getFirstVisibleRowIndex();
                    } else {
                        newRow = 0;
                    }
                }

                if (newContainer.getRowCount() == 0) {

                    return;
                }

                event.preventDefault();
                event.stopPropagation();

                setCellFocus(newRow, newColumn, newContainer);
            }

        }

        private RowContainer getPreviousContainer(RowContainer current) {
            if (current == escalator.getFooter()) {
                current = escalator.getBody();
            } else if (current == escalator.getBody()) {
                current = escalator.getHeader();
            } else {
                return current;
            }

            if (current.getRowCount() == 0) {
                return getPreviousContainer(current);
            }
            return current;
        }

        private RowContainer getNextContainer(RowContainer current) {
            if (current == escalator.getHeader()) {
                current = escalator.getBody();
            } else if (current == escalator.getBody()) {
                current = escalator.getFooter();
            } else {
                return current;
            }

            if (current.getRowCount() == 0) {
                return getNextContainer(current);
            }
            return current;
        }

        private void refreshRow(int row) {
            containerWithFocus.refreshRows(row, 1);
        }


        public void offsetRangeBy(int offset) {
            cellFocusRange = cellFocusRange.offsetBy(offset);
        }


        public void rowsAddedToBody(Range added) {
            boolean bodyHasFocus = (containerWithFocus == escalator.getBody());
            boolean insertionIsAboveFocusedCell = (added.getStart() <= rowWithFocus);
            if (bodyHasFocus && insertionIsAboveFocusedCell) {
                rowWithFocus += added.length();
                rowWithFocus = Math.min(rowWithFocus, escalator.getBody()
                        .getRowCount() - 1);
                refreshRow(rowWithFocus);
            }
        }


        public void rowsRemovedFromBody(Range removed) {
            if (containerWithFocus != escalator.getBody()) {
                return;
            } else if (!removed.contains(rowWithFocus)) {
                if (removed.getStart() > rowWithFocus) {
                    return;
                }
                rowWithFocus = rowWithFocus - removed.length();
            } else {
                if (containerWithFocus.getRowCount() > removed.getEnd()) {
                    rowWithFocus = removed.getStart();
                } else if (removed.getStart() > 0) {
                    rowWithFocus = removed.getStart() - 1;
                } else {
                    if (escalator.getHeader().getRowCount() > 0) {
                        rowWithFocus = Math.min(lastFocusedHeaderRow, escalator
                                .getHeader().getRowCount() - 1);
                        containerWithFocus = escalator.getHeader();
                    } else if (escalator.getFooter().getRowCount() > 0) {
                        rowWithFocus = Math.min(lastFocusedFooterRow, escalator
                                .getFooter().getRowCount() - 1);
                        containerWithFocus = escalator.getFooter();
                    }
                }
            }
            refreshRow(rowWithFocus);
        }
    }

    public final class SelectionColumn extends Column<Boolean, T> {

        private boolean initDone = false;
        private boolean selected = false;

        SelectionColumn(final Renderer<Boolean> selectColumnRenderer) {
            super(selectColumnRenderer);
        }

        void initDone() {
            setWidth(-1);

            setEditable(false);

            initDone = true;
        }

        @Override
        protected void setDefaultHeaderContent(HeaderCell selectionCell) {

            final SelectionModel.Multi<T> model = (Multi<T>) getSelectionModel();
            final CheckBox checkBox = GWT.create(CheckBox.class);
            checkBox.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

                @Override
                public void onValueChange(ValueChangeEvent<Boolean> event) {
                    if (event.getValue()) {
                        fireEvent(new SelectAllEvent<T>(model));
                        selected = true;
                    } else {
                        model.deselectAll();
                        selected = false;
                    }
                }
            });
            checkBox.setValue(selected);
            selectionCell.setWidget(checkBox);

            addHeaderKeyUpHandler(new HeaderKeyUpHandler() {
                @Override
                public void onKeyUp(GridKeyUpEvent event) {
                    if (event.getNativeKeyCode() != KeyCodes.KEY_SPACE) {
                        return;
                    }
                    HeaderRow targetHeaderRow = getHeader().getRow(
                            event.getFocusedCell().getRowIndex());
                    if (!targetHeaderRow.isDefault()) {
                        return;
                    }
                    if (event.getFocusedCell().getColumn() == SelectionColumn.this) {


                        checkBox.setValue(!checkBox.getValue(), true);
                    }
                }
            });
        }

        @Override
        public Column<Boolean, T> setWidth(double pixels) {
            if (pixels != getWidth() && initDone) {
                throw new UnsupportedOperationException("The selection "
                        + "column cannot be modified after init");
            } else {
                super.setWidth(pixels);
            }

            return this;
        }

        @Override
        public Boolean getValue(T row) {
            return Boolean.valueOf(isSelected(row));
        }

        @Override
        public Column<Boolean, T> setExpandRatio(int ratio) {
            throw new UnsupportedOperationException(
                    "can't change the expand ratio of the selection column");
        }

        @Override
        public int getExpandRatio() {
            return 0;
        }

        @Override
        public Column<Boolean, T> setMaximumWidth(double pixels) {
            throw new UnsupportedOperationException(
                    "can't change the maximum width of the selection column");
        }

        @Override
        public double getMaximumWidth() {
            return -1;
        }

        @Override
        public Column<Boolean, T> setMinimumWidth(double pixels) {
            throw new UnsupportedOperationException(
                    "can't change the minimum width of the selection column");
        }

        @Override
        public double getMinimumWidth() {
            return -1;
        }

        @Override
        public Column<Boolean, T> setEditable(boolean editable) {
            if (initDone) {
                throw new UnsupportedOperationException(
                        "can't set the selection column editable");
            }
            super.setEditable(editable);
            return this;
        }

    }


    private final class UserSorter {

        private final Timer timer;
        private boolean scheduledMultisort;
        private Column<?, T> column;

        private UserSorter() {
            timer = new Timer() {

                @Override
                public void run() {
                    UserSorter.this.sort(column, scheduledMultisort);
                }
            };
        }


        public void sort(Column<?, ?> column, boolean multisort) {

            if (!columns.contains(column)) {
                throw new IllegalArgumentException(
                        "Given column is not a column in this grid. "
                                + column.toString());
            }

            if (!column.isSortable()) {
                return;
            }

            final SortOrder so = getSortOrder(column);

            if (multisort) {



                if (so != null) {
                    final int idx = sortOrder.indexOf(so);
                    sortOrder.set(idx, so.getOpposite());
                } else {


                    sortOrder.add(new SortOrder(column));
                }

            } else {





                int items = sortOrder.size();
                sortOrder.clear();
                if (so != null && items == 1) {
                    sortOrder.add(so.getOpposite());
                } else {
                    sortOrder.add(new SortOrder(column));
                }
            }



            Grid.this.sort(true);
        }


        public void sortAfterDelay(int delay, boolean multisort) {
            column = eventCell.getColumn();
            scheduledMultisort = multisort;
            timer.schedule(delay);
        }


        public boolean isDelayedSortScheduled() {
            return timer.isRunning();
        }


        public void cancelDelayedSort() {
            timer.cancel();
        }

    }


    private class AutoColumnWidthsRecalculator {
        private double lastCalculatedInnerWidth = -1;

        private final ScheduledCommand calculateCommand = new ScheduledCommand() {

            @Override
            public void execute() {
                if (!isScheduled) {

                    return;
                }

                if (header.markAsDirty || footer.markAsDirty) {
                    if (rescheduleCount < 10) {

                        Scheduler.get().scheduleFinally(this);
                        rescheduleCount++;
                    } else {

                        rescheduleCount = 0;
                        Scheduler.get().scheduleDeferred(this);
                    }
                } else if (dataIsBeingFetched) {
                    Scheduler.get().scheduleDeferred(this);
                } else {
                    calculate();
                }
                lastCalculatedInnerWidth = escalator.getInnerWidth();
            }
        };

        private int rescheduleCount = 0;
        private boolean isScheduled;


        public void schedule() {
            if (!isScheduled) {
                isScheduled = true;
                Scheduler.get().scheduleFinally(calculateCommand);
            }
        }

        private void calculate() {
            isScheduled = false;
            rescheduleCount = 0;

            assert !dataIsBeingFetched : "Trying to calculate column widths even though data is still being fetched.";

            if (columnsAreGuaranteedToBeWiderThanGrid()) {
                applyColumnWidths();
            } else {
                applyColumnWidthsWithExpansion();
            }
        }

        private boolean columnsAreGuaranteedToBeWiderThanGrid() {
            double freeSpace = escalator.getInnerWidth();
            for (Column<?, ?> column : getVisibleColumns()) {
                if (column.getWidth() >= 0) {
                    freeSpace -= column.getWidth();
                } else if (column.getMinimumWidth() >= 0) {
                    freeSpace -= column.getMinimumWidth();
                }
            }
            return freeSpace < 0;
        }

        @SuppressWarnings("boxing")
        private void applyColumnWidths() {



            Map<Integer, Double> selfWidths = new LinkedHashMap<Integer, Double>();
            List<Column<?, T>> columns = getVisibleColumns();
            for (int index = 0; index < columns.size(); index++) {
                selfWidths.put(index, columns.get(index).getWidth());
            }
            Grid.this.escalator.getColumnConfiguration().setColumnWidths(
                    selfWidths);



            Map<Integer, Double> constrainedWidths = new LinkedHashMap<Integer, Double>();
            for (int index = 0; index < columns.size(); index++) {
                Column<?, T> column = columns.get(index);

                boolean hasAutoWidth = column.getWidth() < 0;
                if (!hasAutoWidth) {
                    continue;
                }


                double actualWidth = column.getWidthActual();
                if (actualWidth < getMinWidth(column)) {
                    constrainedWidths.put(index, column.getMinimumWidth());
                } else if (actualWidth > getMaxWidth(column)) {
                    constrainedWidths.put(index, column.getMaximumWidth());
                }
            }
            Grid.this.escalator.getColumnConfiguration().setColumnWidths(
                    constrainedWidths);
        }

        private void applyColumnWidthsWithExpansion() {
            boolean defaultExpandRatios = true;
            int totalRatios = 0;
            double reservedPixels = 0;
            final Set<Column<?, T>> columnsToExpand = new HashSet<Column<?, T>>();
            List<Column<?, T>> nonFixedColumns = new ArrayList<Column<?, T>>();
            Map<Integer, Double> columnSizes = new HashMap<Integer, Double>();
            final List<Column<?, T>> visibleColumns = getVisibleColumns();


            for (Column<?, T> column : visibleColumns) {
                final double widthAsIs = column.getWidth();
                final boolean isFixedWidth = widthAsIs >= 0;
                final double widthFixed = Math.max(widthAsIs,
                        column.getMinimumWidth());
                defaultExpandRatios = defaultExpandRatios
                        && (column.getExpandRatio() == -1 || column == selectionColumn);

                if (isFixedWidth) {
                    columnSizes.put(visibleColumns.indexOf(column), widthFixed);
                    reservedPixels += widthFixed;
                } else {
                    nonFixedColumns.add(column);
                    columnSizes.put(visibleColumns.indexOf(column), -1.0d);
                }
            }

            setColumnSizes(columnSizes);

            for (Column<?, T> column : nonFixedColumns) {
                final int expandRatio = (defaultExpandRatios ? 1 : column
                        .getExpandRatio());
                final double newWidth = column.getWidthActual();
                final double maxWidth = getMaxWidth(column);
                boolean shouldExpand = newWidth < maxWidth && expandRatio > 0
                        && column != selectionColumn;
                if (shouldExpand) {
                    totalRatios += expandRatio;
                    columnsToExpand.add(column);
                }
                reservedPixels += newWidth;
                columnSizes.put(visibleColumns.indexOf(column), newWidth);
            }


            double pixelsToDistribute = escalator.getInnerWidth()
                    - reservedPixels;
            if (pixelsToDistribute <= 0 || totalRatios <= 0) {
                return;
            }


            boolean aColumnHasMaxedOut;
            do {
                aColumnHasMaxedOut = false;
                final double widthPerRatio = pixelsToDistribute / totalRatios;
                final Iterator<Column<?, T>> i = columnsToExpand.iterator();
                while (i.hasNext()) {
                    final Column<?, T> column = i.next();
                    final int expandRatio = getExpandRatio(column,
                            defaultExpandRatios);
                    final int columnIndex = visibleColumns.indexOf(column);
                    final double autoWidth = columnSizes.get(columnIndex);
                    final double maxWidth = getMaxWidth(column);
                    double expandedWidth = autoWidth + widthPerRatio
                            * expandRatio;

                    if (maxWidth <= expandedWidth) {
                        i.remove();
                        totalRatios -= expandRatio;
                        aColumnHasMaxedOut = true;
                        pixelsToDistribute -= maxWidth - autoWidth;
                        columnSizes.put(columnIndex, maxWidth);
                    }
                }
            } while (aColumnHasMaxedOut);

            if (totalRatios <= 0 && columnsToExpand.isEmpty()) {
                setColumnSizes(columnSizes);
                return;
            }
            assert pixelsToDistribute > 0 : "We've run out of pixels to distribute ("
                    + pixelsToDistribute
                    + "px to "
                    + totalRatios
                    + " ratios between " + columnsToExpand.size() + " columns)";
            assert totalRatios > 0 && !columnsToExpand.isEmpty() : "Bookkeeping out of sync. Ratios: "
                    + totalRatios + " Columns: " + columnsToExpand.size();


            final double widthPerRatio;
            int leftOver = 0;
            if (BrowserInfo.get().isIE8() || BrowserInfo.get().isIE9()
                    || BrowserInfo.getBrowserString().contains("PhantomJS")) {


                widthPerRatio = (int) (pixelsToDistribute / totalRatios);
                leftOver = (int) (pixelsToDistribute - widthPerRatio
                        * totalRatios);
            } else {
                widthPerRatio = pixelsToDistribute / totalRatios;
            }
            for (Column<?, T> column : columnsToExpand) {
                final int expandRatio = getExpandRatio(column,
                        defaultExpandRatios);
                final int columnIndex = visibleColumns.indexOf(column);
                final double autoWidth = columnSizes.get(columnIndex);
                double totalWidth = autoWidth + widthPerRatio * expandRatio;
                if (leftOver > 0) {
                    totalWidth += 1;
                    leftOver--;
                }
                columnSizes.put(columnIndex, totalWidth);

                totalRatios -= expandRatio;
            }
            assert totalRatios == 0 : "Bookkeeping error: there were still some ratios left undistributed: "
                    + totalRatios;


            boolean minWidthsCausedReflows;
            do {
                minWidthsCausedReflows = false;


                double pixelsToRemoveFromOtherColumns = 0;
                for (Column<?, T> column : visibleColumns) {


                    double minWidth = getMinWidth(column);
                    final int columnIndex = visibleColumns.indexOf(column);
                    double currentWidth = columnSizes.get(columnIndex);
                    boolean hasAutoWidth = column.getWidth() < 0;
                    if (hasAutoWidth && currentWidth < minWidth) {
                        columnSizes.put(columnIndex, minWidth);
                        pixelsToRemoveFromOtherColumns += (minWidth - currentWidth);
                        minWidthsCausedReflows = true;


                        columnsToExpand.remove(column);
                    }
                }


                totalRatios = 0;
                for (Column<?, ?> column : columnsToExpand) {
                    totalRatios += getExpandRatio(column, defaultExpandRatios);
                }
                final double pixelsToRemovePerRatio = pixelsToRemoveFromOtherColumns
                        / totalRatios;
                for (Column<?, T> column : columnsToExpand) {
                    final double pixelsToRemove = pixelsToRemovePerRatio
                            * getExpandRatio(column, defaultExpandRatios);
                    int colIndex = visibleColumns.indexOf(column);
                    columnSizes.put(colIndex, columnSizes.get(colIndex)
                            - pixelsToRemove);
                }

            } while (minWidthsCausedReflows);


            setColumnSizes(columnSizes);
        }

        private void setColumnSizes(Map<Integer, Double> columnSizes) {

            escalator.getColumnConfiguration().setColumnWidths(columnSizes);
        }

        private int getExpandRatio(Column<?, ?> column,
                boolean defaultExpandRatios) {
            int expandRatio = column.getExpandRatio();
            if (expandRatio > 0) {
                return expandRatio;
            } else if (expandRatio < 0) {
                assert defaultExpandRatios : "No columns should've expanded";
                return 1;
            } else {
                assert false : "this method should've not been called at all if expandRatio is 0";
                return 0;
            }
        }


        private double getMaxWidth(Column<?, ?> column) {
            double maxWidth = column.getMaximumWidth();
            if (maxWidth >= 0) {
                return maxWidth;
            } else {
                return Double.MAX_VALUE;
            }
        }


        private double getMinWidth(Column<?, ?> column) {
            double minWidth = column.getMinimumWidth();
            if (minWidth >= 0) {
                return minWidth;
            } else {
                return Double.MIN_VALUE;
            }
        }


        public boolean isScheduled() {
            return isScheduled;
        }
    }

    private class GridSpacerUpdater implements SpacerUpdater {

        private static final String STRIPE_CLASSNAME = "stripe";

        private final Map<Element, Widget> elementToWidgetMap = new HashMap<Element, Widget>();

        @Override
        public void init(Spacer spacer) {
            initTheming(spacer);

            int rowIndex = spacer.getRow();

            Widget detailsWidget = null;
            try {
                detailsWidget = detailsGenerator.getDetails(rowIndex);
            } catch (Throwable e) {
                getLogger().log(
                        Level.SEVERE,
                        "Exception while generating details for row "
                                + rowIndex, e);
            }

            final double spacerHeight;
            Element spacerElement = spacer.getElement();
            if (detailsWidget == null) {
                spacerElement.removeAllChildren();
                spacerHeight = DETAILS_ROW_INITIAL_HEIGHT;
            } else {
                Element element = detailsWidget.getElement();
                spacerElement.appendChild(element);
                setParent(detailsWidget, Grid.this);
                Widget previousWidget = elementToWidgetMap.put(element,
                        detailsWidget);

                assert previousWidget == null : "Overwrote a pre-existing widget on row "
                        + rowIndex + " without proper removal first.";


                double requiredHeightBoundingClientRectDouble = WidgetUtil
                        .getRequiredHeightBoundingClientRectDouble(element);
                double borderTopAndBottomHeight = WidgetUtil
                        .getBorderTopAndBottomThickness(spacerElement);
                double measuredHeight = requiredHeightBoundingClientRectDouble
                        + borderTopAndBottomHeight;
                assert getElement().isOrHasChild(spacerElement) : "The spacer element wasn't in the DOM during measurement, but was assumed to be.";
                spacerHeight = measuredHeight;
            }

            escalator.getBody().setSpacer(rowIndex, spacerHeight);
        }

        @Override
        public void destroy(Spacer spacer) {
            Element spacerElement = spacer.getElement();

            assert getElement().isOrHasChild(spacerElement) : "Trying "
                    + "to destroy a spacer that is not connected to this "
                    + "Grid's DOM. (row: " + spacer.getRow() + ", element: "
                    + spacerElement + ")";

            Widget detailsWidget = elementToWidgetMap.remove(spacerElement
                    .getFirstChildElement());

            if (detailsWidget != null) {


                assert spacerElement.getFirstChild() != null : "The "
                        + "details row to destroy did not contain a widget - "
                        + "probably removed by something else without "
                        + "permission? (row: " + spacer.getRow()
                        + ", element: " + spacerElement + ")";

                setParent(detailsWidget, null);
                spacerElement.removeAllChildren();
            }
        }

        private void initTheming(Spacer spacer) {
            Element spacerRoot = spacer.getElement();

            if (spacer.getRow() % 2 == 1) {
                spacerRoot.getParentElement().addClassName(STRIPE_CLASSNAME);
            } else {
                spacerRoot.getParentElement().removeClassName(STRIPE_CLASSNAME);
            }
        }

    }


    private static class Sidebar extends Composite {

        private final ClickHandler openCloseButtonHandler = new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                if (!isOpen()) {
                    open();
                } else {
                    close();
                }
            }
        };

        private final FlowPanel rootContainer;

        private final FlowPanel content;

        private final MenuBar menuBar;

        private final Button openCloseButton;

        private final Grid<?> grid;

        private NativePreviewHandler clickOutsideToCloseHandler = new NativePreviewHandler() {

            @Override
            public void onPreviewNativeEvent(NativePreviewEvent event) {
                if (event.getTypeInt() != Event.ONMOUSEDOWN) {
                    return;
                }


                EventTarget clickTarget = event.getNativeEvent()
                        .getEventTarget();
                if (!rootContainer.getElement().isOrHasChild(
                        Element.as(clickTarget))) {
                    close();
                }
            }
        };

        private HandlerRegistration clickOutsideToCloseHandlerRegistration;

        private Sidebar(Grid<?> grid) {
            this.grid = grid;

            rootContainer = new FlowPanel();
            initWidget(rootContainer);

            openCloseButton = new Button();
            openCloseButton.addClickHandler(openCloseButtonHandler);

            rootContainer.add(openCloseButton);

            content = new FlowPanel() {
                @Override
                public boolean remove(Widget w) {

                    boolean removed = super.remove(w);
                    if (removed) {
                        updateVisibility();
                    }

                    return removed;
                }
            };

            menuBar = new MenuBar(true) {

                @Override
                public MenuItem insertItem(MenuItem item, int beforeIndex)
                        throws IndexOutOfBoundsException {
                    if (getParent() == null) {
                        content.insert(this, 0);
                        updateVisibility();
                    }
                    return super.insertItem(item, beforeIndex);
                }

                @Override
                public void removeItem(MenuItem item) {
                    super.removeItem(item);
                    if (getItems().isEmpty()) {
                        menuBar.removeFromParent();
                    }
                }

                @Override
                public void onBrowserEvent(Event event) {



                    if (event.getTypeInt() == Event.ONKEYDOWN
                            && event.getKeyCode() == KeyCodes.KEY_ENTER) {
                        final MenuItem item = getSelectedItem();
                        super.onBrowserEvent(event);
                        Scheduler.get().scheduleDeferred(
                                new ScheduledCommand() {

                                    @Override
                                    public void execute() {
                                        selectItem(item);
                                        focus();
                                    }
                                });

                    } else {
                        super.onBrowserEvent(event);
                    }
                }

            };
            KeyDownHandler keyDownHandler = new KeyDownHandler() {

                @Override
                public void onKeyDown(KeyDownEvent event) {
                    if (event.getNativeKeyCode() == KeyCodes.KEY_ESCAPE) {
                        close();
                    }
                }
            };
            openCloseButton.addDomHandler(keyDownHandler,
                    KeyDownEvent.getType());
            menuBar.addDomHandler(keyDownHandler, KeyDownEvent.getType());
        }


        public void open() {
            if (!isOpen() && isInDOM()) {
                addStyleName("open");
                removeStyleName("closed");
                rootContainer.add(content);
                clickOutsideToCloseHandlerRegistration = Event
                        .addNativePreviewHandler(clickOutsideToCloseHandler);
            }
            openCloseButton.setHeight("");
        }


        public void close() {
            if (isOpen()) {
                removeStyleName("open");
                addStyleName("closed");
                content.removeFromParent();

                setHeightToHeaderCellHeight();
                if (clickOutsideToCloseHandlerRegistration != null) {
                    clickOutsideToCloseHandlerRegistration.removeHandler();
                    clickOutsideToCloseHandlerRegistration = null;
                }
            }
        }


        public boolean isOpen() {
            return content.getParent() == rootContainer;
        }


        public void add(Widget widget) {
            content.add(widget);
            updateVisibility();
        }


        public void remove(Widget widget) {
            content.remove(widget);

        }


        public void insert(Widget widget, int beforeIndex) {
            content.insert(widget, beforeIndex);
            updateVisibility();
        }

        @Override
        public void setStylePrimaryName(String styleName) {
            super.setStylePrimaryName(styleName);
            content.setStylePrimaryName(styleName + "-content");
            openCloseButton.setStylePrimaryName(styleName + "-button");
            if (isOpen()) {
                addStyleName("open");
                removeStyleName("closed");
            } else {
                removeStyleName("open");
                addStyleName("closed");
            }
        }

        private void setHeightToHeaderCellHeight() {
            RowContainer header = grid.escalator.getHeader();
            if (header.getRowCount() == 0
                    || !header.getRowElement(0).hasChildNodes()) {
                getLogger()
                        .info("No header cell available when calculating sidebar button height");
                openCloseButton.setHeight(header.getDefaultRowHeight() + "px");

                return;
            }

            Element firstHeaderCell = header.getRowElement(0)
                    .getFirstChildElement();
            double height = WidgetUtil
                    .getRequiredHeightBoundingClientRectDouble(firstHeaderCell)
                    - (WidgetUtil.measureVerticalBorder(getElement()) / 2);
            openCloseButton.setHeight(height + "px");
        }

        private void updateVisibility() {
            final boolean hasWidgets = content.getWidgetCount() > 0;
            final boolean isVisible = isInDOM();
            if (isVisible && !hasWidgets) {
                Grid.setParent(this, null);
                getElement().removeFromParent();
            } else if (!isVisible && hasWidgets) {
                close();
                grid.getElement().appendChild(getElement());
                Grid.setParent(this, grid);

                setHeightToHeaderCellHeight();
            }
        }

        private boolean isInDOM() {
            return getParent() != null;
        }

        @Override
        protected void onAttach() {
            super.onAttach();


            Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                @Override
                public void execute() {
                    setHeightToHeaderCellHeight();
                }
            });
        }
    }


    private final class ColumnHider {


        private HashMap<Column<?, T>, MenuItem> columnToHidingToggleMap = new HashMap<Grid.Column<?, T>, MenuItem>();


        private boolean hidingColumn;

        private void updateColumnHidable(final Column<?, T> column) {
            if (column.isHidable()) {
                MenuItem toggle = columnToHidingToggleMap.get(column);
                if (toggle == null) {
                    toggle = createToggle(column);
                }
                toggle.setStyleName("hidden", column.isHidden());
            } else if (columnToHidingToggleMap.containsKey(column)) {
                sidebar.menuBar.removeItem((columnToHidingToggleMap
                        .remove(column)));
            }
            updateTogglesOrder();
        }

        private MenuItem createToggle(final Column<?, T> column) {
            MenuItem toggle = new MenuItem(createHTML(column), true,
                    new ScheduledCommand() {

                        @Override
                        public void execute() {
                            hidingColumn = true;
                            column.setHidden(!column.isHidden(), true);
                            hidingColumn = false;
                        }
                    });
            toggle.addStyleName("column-hiding-toggle");
            columnToHidingToggleMap.put(column, toggle);
            return toggle;
        }

        private String createHTML(Column<?, T> column) {
            final StringBuffer buf = new StringBuffer();
            buf.append("<span class=\"");
            if (column.isHidden()) {
                buf.append("v-off");
            } else {
                buf.append("v-on");
            }
            buf.append("\"><div>");
            String caption = column.getHidingToggleCaption();
            if (caption == null) {
                caption = column.headerCaption;
            }
            buf.append(caption);
            buf.append("</div></span>");

            return buf.toString();
        }

        private void updateTogglesOrder() {
            if (!hidingColumn) {
                int lastIndex = 0;
                for (Column<?, T> column : getColumns()) {
                    if (column.isHidable()) {
                        final MenuItem menuItem = columnToHidingToggleMap
                                .get(column);
                        sidebar.menuBar.removeItem(menuItem);
                        sidebar.menuBar.insertItem(menuItem, lastIndex++);
                    }
                }
            }
        }

        private void updateHidingToggle(Column<?, T> column) {
            if (column.isHidable()) {
                MenuItem toggle = columnToHidingToggleMap.get(column);
                toggle.setHTML(createHTML(column));
                toggle.setStyleName("hidden", column.isHidden());
            } 
        }

        private void removeColumnHidingToggle(Column<?, T> column) {
            sidebar.menuBar.removeItem(columnToHidingToggleMap.get(column));
        }

    }


    private Escalator escalator = GWT.create(Escalator.class);

    private final Header header = GWT.create(Header.class);

    private final Footer footer = GWT.create(Footer.class);

    private final Sidebar sidebar = new Sidebar(this);


    private List<Column<?, T>> columns = new ArrayList<Column<?, T>>();


    private DataSource<T> dataSource;


    private Range currentDataAvailable = Range.withLength(0, 0);


    private int frozenColumnCount = 0;


    private List<SortOrder> sortOrder = new ArrayList<SortOrder>();

    private Renderer<Boolean> selectColumnRenderer = null;

    private SelectionColumn selectionColumn;

    private String rowStripeStyleName;
    private String rowHasDataStyleName;
    private String rowSelectedStyleName;
    private String cellFocusStyleName;
    private String rowFocusStyleName;


    private SelectionModel<T> selectionModel;

    protected final CellFocusHandler cellFocusHandler;

    private final UserSorter sorter = new UserSorter();

    private final Editor<T> editor = GWT.create(Editor.class);

    private boolean dataIsBeingFetched = false;


    private Cell cellOnPrevMouseDown;


    private final AutoColumnWidthsRecalculator autoColumnWidthsRecalculator = new AutoColumnWidthsRecalculator();

    private boolean enabled = true;
    private double lastTouchEventTime = 0;
    private int lastTouchEventX = -1;
    private int lastTouchEventY = -1;
    private int lastTouchEventRow = -1;

    private DetailsGenerator detailsGenerator = DetailsGenerator.NULL;
    private GridSpacerUpdater gridSpacerUpdater = new GridSpacerUpdater();

    private Set<Integer> visibleDetails = new HashSet<Integer>();

    private boolean columnReorderingAllowed;

    private ColumnHider columnHider = new ColumnHider();

    private DragAndDropHandler dndHandler = new DragAndDropHandler();

    private AutoScroller autoScroller = new AutoScroller(this);

    private DragAndDropHandler.DragAndDropCallback headerCellDndCallback = new DragAndDropHandler.DragAndDropCallback() {

        private final AutoScrollerCallback autoScrollerCallback = new AutoScrollerCallback() {

            @Override
            public void onAutoScroll(int scrollDiff) {
                autoScrollX = scrollDiff;
                onDragUpdate(null);
            }

            @Override
            public void onAutoScrollReachedMin() {

                autoScrollX = 0;
                updateDragDropMarker(clientX);
            }

            @Override
            public void onAutoScrollReachedMax() {

                autoScrollX = 0;
                updateDragDropMarker(clientX);
            }
        };

        private Element table;
        private Element tableHeader;

        private Element dropMarker;

        private Element dragElement;

        private int latestColumnDropIndex;

        private final TreeMap<Double, Integer> possibleDropPositions = new TreeMap<Double, Integer>();

        private HandlerRegistration columnSortPreventRegistration;

        private int clientX;


        private int autoScrollX;


        private int focusedColumnIndex;


        private double dropMarkerWidthOffset;

        private void initHeaderDragElementDOM() {
            if (table == null) {
                tableHeader = DOM.createTHead();
                dropMarker = DOM.createDiv();
                tableHeader.appendChild(dropMarker);
                table = DOM.createTable();
                table.appendChild(tableHeader);
                table.setClassName("header-drag-table");
            }


            tableHeader.setClassName(escalator.getHeader().getElement()
                    .getClassName());
            dropMarker.setClassName(getStylePrimaryName() + "-drop-marker");
            int topOffset = 0;
            for (int i = 0; i < eventCell.getRowIndex(); i++) {
                topOffset += escalator.getHeader().getRowElement(i)
                        .getFirstChildElement().getOffsetHeight();
            }
            tableHeader.getStyle().setTop(topOffset, Unit.PX);

            getElement().appendChild(table);

            dropMarkerWidthOffset = WidgetUtil
                    .getRequiredWidthBoundingClientRectDouble(dropMarker) / 2;
        }

        @Override
        public void onDragUpdate(NativePreviewEvent event) {
            if (event != null) {
                clientX = WidgetUtil.getTouchOrMouseClientX(event
                        .getNativeEvent());
                autoScrollX = 0;
            }
            resolveDragElementHorizontalPosition(clientX);
            updateDragDropMarker(clientX);
        }

        private void updateDragDropMarker(final int clientX) {
            final double scrollLeft = getScrollLeft();
            final double cursorXCoordinate = clientX
                    - escalator.getHeader().getElement().getAbsoluteLeft();
            final Entry<Double, Integer> cellEdgeOnRight = possibleDropPositions
                    .ceilingEntry(cursorXCoordinate);
            final Entry<Double, Integer> cellEdgeOnLeft = possibleDropPositions
                    .floorEntry(cursorXCoordinate);
            final double diffToRightEdge = cellEdgeOnRight == null ? Double.MAX_VALUE
                    : cellEdgeOnRight.getKey() - cursorXCoordinate;
            final double diffToLeftEdge = cellEdgeOnLeft == null ? Double.MAX_VALUE
                    : cursorXCoordinate - cellEdgeOnLeft.getKey();

            double dropMarkerLeft = 0 - scrollLeft;
            if (diffToRightEdge > diffToLeftEdge) {
                latestColumnDropIndex = cellEdgeOnLeft.getValue();
                dropMarkerLeft += cellEdgeOnLeft.getKey();
            } else {
                latestColumnDropIndex = cellEdgeOnRight.getValue();
                dropMarkerLeft += cellEdgeOnRight.getKey();
            }

            dropMarkerLeft += autoScrollX;

            final double frozenColumnsWidth = getFrozenColumnsWidth();
            final double rightBoundaryForDrag = getSidebarBoundaryComparedTo(dropMarkerLeft);
            final int visibleColumns = getVisibleColumns().size();




            if (latestColumnDropIndex == visibleColumns
                    && rightBoundaryForDrag < dropMarkerLeft
                    && dropMarkerLeft <= escalator.getInnerWidth()) {
                dropMarkerLeft = rightBoundaryForDrag - dropMarkerWidthOffset;
            }


            else if (dropMarkerLeft < frozenColumnsWidth
                    || dropMarkerLeft > Math.min(rightBoundaryForDrag,
                            escalator.getInnerWidth()) || dropMarkerLeft < 0) {
                dropMarkerLeft = -10000000;
            }
            dropMarker.getStyle().setLeft(dropMarkerLeft, Unit.PX);
        }

        private void resolveDragElementHorizontalPosition(final int clientX) {
            double left = clientX - table.getAbsoluteLeft();



            final Double leftBound = possibleDropPositions.firstKey();
            final Double rightBound = possibleDropPositions.lastKey();
            final double scrollLeft = getScrollLeft();
            if (left + scrollLeft < leftBound) {
                left = leftBound - scrollLeft + autoScrollX;
            } else if (left + scrollLeft > rightBound) {
                left = rightBound - scrollLeft + autoScrollX;
            }


            final double sidebarBoundary = getSidebarBoundaryComparedTo(left);
            final double gridBoundary = escalator.getInnerWidth();
            final double rightBoundary = Math
                    .min(sidebarBoundary, gridBoundary);


            final int frozenColumnsWidth = (int) getFrozenColumnsWidth();

            left = Math.max(frozenColumnsWidth, Math.min(left, rightBoundary));

            left -= dragElement.getClientWidth() / 2;
            dragElement.getStyle().setLeft(left, Unit.PX);
        }

        private boolean isSidebarOnDraggedRow() {
            return eventCell.getRowIndex() == 0 && getSidebar().isInDOM()
                    && !getSidebar().isOpen();
        }


        private double getSidebarBoundaryComparedTo(double left) {
            if (isSidebarOnDraggedRow()) {
                double absoluteLeft = left + getElement().getAbsoluteLeft();
                double sidebarLeft = getSidebar().getElement()
                        .getAbsoluteLeft();
                double diff = absoluteLeft - sidebarLeft;

                if (diff > 0) {
                    return left - diff;
                }
            }
            return Double.MAX_VALUE;
        }

        @Override
        public boolean onDragStart(NativeEvent startingEvent) {
            calculatePossibleDropPositions();

            if (possibleDropPositions.isEmpty()) {
                return false;
            }

            initHeaderDragElementDOM();

            dragElement = DOM.clone(eventCell.getElement(), true);
            dragElement.getStyle().clearWidth();
            dropMarker.getStyle().setProperty("height",
                    dragElement.getStyle().getHeight());
            tableHeader.appendChild(dragElement);

            eventCell.getElement().addClassName("dragged");

            dragElement.addClassName("dragged-column-header");


            autoScroller.setScrollArea(60);
            autoScroller.start(startingEvent, ScrollAxis.HORIZONTAL,
                    autoScrollerCallback);
            return true;
        }

        @Override
        public void onDragEnd() {
            table.removeFromParent();
            dragElement.removeFromParent();
            eventCell.getElement().removeClassName("dragged");
        }

        @Override
        public void onDrop() {
            final int draggedColumnIndex = eventCell.getColumnIndex();
            final int colspan = header.getRow(eventCell.getRowIndex())
                    .getCell(eventCell.getColumn()).getColspan();
            if (latestColumnDropIndex != draggedColumnIndex
                    && latestColumnDropIndex != (draggedColumnIndex + colspan)) {
                List<Column<?, T>> columns = getColumns();
                List<Column<?, T>> reordered = new ArrayList<Column<?, T>>();
                if (draggedColumnIndex < latestColumnDropIndex) {
                    reordered.addAll(columns.subList(0, draggedColumnIndex));
                    reordered.addAll(columns.subList(draggedColumnIndex
                            + colspan, latestColumnDropIndex));
                    reordered.addAll(columns.subList(draggedColumnIndex,
                            draggedColumnIndex + colspan));
                    reordered.addAll(columns.subList(latestColumnDropIndex,
                            columns.size()));
                } else {
                    reordered.addAll(columns.subList(0, latestColumnDropIndex));
                    reordered.addAll(columns.subList(draggedColumnIndex,
                            draggedColumnIndex + colspan));
                    reordered.addAll(columns.subList(latestColumnDropIndex,
                            draggedColumnIndex));
                    reordered.addAll(columns.subList(draggedColumnIndex
                            + colspan, columns.size()));
                }
                reordered.remove(selectionColumn); 



                Cell focusedCell = cellFocusHandler.getFocusedCell();
                if (focusedCell != null) {

                    focusedColumnIndex = getColumns().indexOf(
                            getVisibleColumn(focusedCell.getColumn()));
                }

                Column<?, T>[] array = reordered.toArray(new Column[reordered
                        .size()]);
                setColumnOrder(array);
                transferCellFocusOnDrop();
            } 
        }

        private void transferCellFocusOnDrop() {
            final Cell focusedCell = cellFocusHandler.getFocusedCell();
            if (focusedCell != null) {
                final int focusedColumnIndexDOM = focusedCell.getColumn();
                final int focusedRowIndex = focusedCell.getRow();
                final int draggedColumnIndex = eventCell.getColumnIndex();

                final RowContainer rowContainer = escalator
                        .findRowContainer(focusedCell.getElement());
                if (focusedColumnIndex == draggedColumnIndex) {

                    int adjustedDropIndex = latestColumnDropIndex > draggedColumnIndex ? latestColumnDropIndex - 1
                            : latestColumnDropIndex;

                    adjustedDropIndex = getVisibleColumns().indexOf(
                            getColumn(adjustedDropIndex));
                    cellFocusHandler.setCellFocus(focusedRowIndex,
                            adjustedDropIndex, rowContainer);
                } else if (latestColumnDropIndex <= focusedColumnIndex
                        && draggedColumnIndex > focusedColumnIndex) {
                    cellFocusHandler.setCellFocus(focusedRowIndex,
                            focusedColumnIndexDOM + 1, rowContainer);
                } else if (latestColumnDropIndex > focusedColumnIndex
                        && draggedColumnIndex < focusedColumnIndex) {
                    cellFocusHandler.setCellFocus(focusedRowIndex,
                            focusedColumnIndexDOM - 1, rowContainer);
                }
            }
        }

        @Override
        public void onDragCancel() {


            if (columnSortPreventRegistration == null) {
                columnSortPreventRegistration = Event
                        .addNativePreviewHandler(new NativePreviewHandler() {

                            @Override
                            public void onPreviewNativeEvent(
                                    NativePreviewEvent event) {
                                if (event.getTypeInt() == Event.ONCLICK) {
                                    event.cancel();
                                    event.getNativeEvent().preventDefault();
                                    columnSortPreventRegistration
                                            .removeHandler();
                                    columnSortPreventRegistration = null;
                                }
                            }
                        });
            }
            autoScroller.stop();
        }

        private double getFrozenColumnsWidth() {
            double value = getMultiSelectColumnWidth();
            for (int i = 0; i < getFrozenColumnCount(); i++) {
                value += getColumn(i).getWidthActual();
            }
            return value;
        }

        private double getMultiSelectColumnWidth() {
            if (getSelectionModel().getSelectionColumnRenderer() != null) {


                return escalator.getHeader().getElement()
                        .getFirstChildElement().getFirstChildElement()
                        .getOffsetWidth();
            }
            return 0.0;
        }


        private int getSelectionAndFrozenColumnCount() {


            if (getSelectionModel().getSelectionColumnRenderer() != null) {
                return Math.max(0, getFrozenColumnCount()) + 1;
            } else {
                return Math.max(0, getFrozenColumnCount());
            }
        }

        @SuppressWarnings("boxing")
        private void calculatePossibleDropPositions() {
            possibleDropPositions.clear();

            final int draggedColumnIndex = eventCell.getColumnIndex();
            final StaticRow<?> draggedCellRow = header.getRow(eventCell
                    .getRowIndex());
            final int draggedColumnRightIndex = draggedColumnIndex
                    + draggedCellRow.getCell(eventCell.getColumn())
                            .getColspan();
            final int frozenColumns = getSelectionAndFrozenColumnCount();
            final Range draggedCellRange = Range.between(draggedColumnIndex,
                    draggedColumnRightIndex);

            int leftBound = -1;
            int rightBound = getColumnCount() + 1;

            final HashSet<Integer> unavailableColumnDropIndices = new HashSet<Integer>();
            final List<StaticRow<?>> rows = new ArrayList<StaticRow<?>>();
            rows.addAll(header.getRows());
            rows.addAll(footer.getRows());
            for (StaticRow<?> row : rows) {
                if (!row.hasSpannedCells()) {
                    continue;
                }
                final boolean isDraggedCellRow = row.equals(draggedCellRow);
                for (int cellColumnIndex = frozenColumns; cellColumnIndex < getColumnCount(); cellColumnIndex++) {
                    StaticCell cell = row.getCell(getColumn(cellColumnIndex));
                    int colspan = cell.getColspan();
                    if (colspan <= 1) {
                        continue;
                    }
                    final int cellColumnRightIndex = cellColumnIndex + colspan;
                    final Range cellRange = Range.between(cellColumnIndex,
                            cellColumnRightIndex);
                    final boolean intersects = draggedCellRange
                            .intersects(cellRange);
                    if (intersects && !isDraggedCellRow) {


                        if (cellRange.isSubsetOf(draggedCellRange)) {
                            cellColumnIndex = cellColumnRightIndex - 1;
                            continue;
                        }

                        if (!draggedCellRange.isSubsetOf(cellRange)) {
                            return;
                        }


                        if (cellColumnIndex <= draggedColumnIndex
                                && cellColumnIndex > leftBound) {
                            leftBound = cellColumnIndex;
                        }
                        if (cellColumnRightIndex < rightBound) {
                            rightBound = cellColumnRightIndex;
                        }
                        cellColumnIndex = cellColumnRightIndex - 1;
                    }

                    else { 

                        while (colspan > 1) {
                            cellColumnIndex++;
                            colspan--;
                            unavailableColumnDropIndices.add(cellColumnIndex);
                        }
                    }
                }
            }

            if (leftBound == (rightBound - 1)) {
                return;
            }

            double position = getFrozenColumnsWidth();

            for (int i = frozenColumns; i < getColumnCount(); i++) {
                Column<?, T> column = getColumn(i);
                if (!unavailableColumnDropIndices.contains(i)
                        && !column.isHidden()) {
                    if (leftBound != -1) {
                        if (i >= leftBound && i <= rightBound) {
                            possibleDropPositions.put(position, i);
                        }
                    } else {
                        possibleDropPositions.put(position, i);
                    }
                }
                position += column.getWidthActual();
            }

            if (leftBound == -1) {

                possibleDropPositions.put(position, getColumnCount());
            }
        }

    };


    public enum SelectionMode {


        SINGLE {

            @Override
            protected <T> SelectionModel<T> createModel() {
                return GWT.create(SelectionModelSingle.class);
            }
        },


        MULTI {

            @Override
            protected <T> SelectionModel<T> createModel() {
                return GWT.create(SelectionModelMulti.class);
            }
        },


        NONE {

            @Override
            protected <T> SelectionModel<T> createModel() {
                return GWT.create(SelectionModelNone.class);
            }
        };

        protected abstract <T> SelectionModel<T> createModel();
    }


    public static abstract class Column<C, T> {


        private final class DefaultTextRenderer implements Renderer<Object> {
            boolean warned = false;
            private final String DEFAULT_RENDERER_WARNING = "This column uses a dummy default TextRenderer. "
                    + "A more suitable renderer should be set using the setRenderer() method.";

            @Override
            public void render(RendererCellReference cell, Object data) {
                if (!warned && !(data instanceof String)) {
                    getLogger().warning(
                            Column.this.toString() + ": "
                                    + DEFAULT_RENDERER_WARNING);
                    warned = true;
                }

                final String text;
                if (data == null) {
                    text = "";
                } else {
                    text = data.toString();
                }

                cell.getElement().setInnerText(text);
            }
        }


        private Grid<T> grid;


        private double widthUser = GridConstants.DEFAULT_COLUMN_WIDTH_PX;


        private Renderer<? super C> bodyRenderer;

        private boolean sortable = false;

        private boolean editable = true;

        private boolean hidden = false;

        private boolean hidable = false;

        private String headerCaption = "";

        private String hidingToggleCaption = null;

        private double minimumWidthPx = GridConstants.DEFAULT_MIN_WIDTH;
        private double maximumWidthPx = GridConstants.DEFAULT_MAX_WIDTH;
        private int expandRatio = GridConstants.DEFAULT_EXPAND_RATIO;


        public Column() {
            setRenderer(new DefaultTextRenderer());
        }


        public Column(String caption) throws IllegalArgumentException {
            this();
            setHeaderCaption(caption);
        }


        public Column(Renderer<? super C> renderer)
                throws IllegalArgumentException {
            setRenderer(renderer);
        }


        public Column(String caption, Renderer<? super C> renderer)
                throws IllegalArgumentException {
            this(renderer);
            setHeaderCaption(caption);
        }


        private void setGrid(Grid<T> grid) {
            if (this.grid != null && grid != null) {

                throw new IllegalStateException("Column already is attached "
                        + "to a grid. Remove the column first from the grid "
                        + "and then add it. (in: " + toString() + ")");
            }

            if (this.grid != null) {
                this.grid.recalculateColumnWidths();
            }
            this.grid = grid;
            if (this.grid != null) {
                this.grid.recalculateColumnWidths();
            }
        }


        public Column<C, T> setHeaderCaption(String caption) {
            if (caption == null) {
                throw new IllegalArgumentException("Caption cannot be null.");
            }

            if (!this.headerCaption.equals(caption)) {
                this.headerCaption = caption;
                if (grid != null) {
                    updateHeader();
                }
            }

            return this;
        }

        private void updateHeader() {
            HeaderRow row = grid.getHeader().getDefaultRow();
            if (row != null) {
                row.getCell(this).setText(headerCaption);
                if (isHidable()) {
                    grid.columnHider.updateHidingToggle(this);
                }
            }
        }


        public abstract C getValue(T row);


        public Renderer<? super C> getRenderer() {
            return bodyRenderer;
        }


        public Column<C, T> setRenderer(Renderer<? super C> renderer)
                throws IllegalArgumentException {
            if (renderer == null) {
                throw new IllegalArgumentException("Renderer cannot be null.");
            }

            if (renderer != bodyRenderer) {
                bodyRenderer = renderer;

                if (grid != null) {
                    grid.refreshBody();
                }
            }
            return this;
        }


        public Column<C, T> setWidth(double pixels) {
            if (!WidgetUtil.pixelValuesEqual(widthUser, pixels)) {
                widthUser = pixels;
                if (!isHidden()) {
                    scheduleColumnWidthRecalculator();
                }
            }
            return this;
        }

        void doSetWidth(double pixels) {
            assert !isHidden() : "applying width for a hidden column";
            if (grid != null) {
                int index = grid.getVisibleColumns().indexOf(this);
                ColumnConfiguration conf = grid.escalator
                        .getColumnConfiguration();
                conf.setColumnWidth(index, pixels);
            }
        }


        public double getWidth() {
            return widthUser;
        }


        public double getWidthActual() {
            if (isHidden()) {
                return 0;
            }
            return grid.escalator.getColumnConfiguration()
                    .getColumnWidthActual(
                            grid.getVisibleColumns().indexOf(this));
        }

        void reapplyWidth() {
            scheduleColumnWidthRecalculator();
        }


        public Column<C, T> setSortable(boolean sortable) {
            if (this.sortable != sortable) {
                this.sortable = sortable;
                if (grid != null) {
                    grid.refreshHeader();
                }
            }

            return this;
        }


        public boolean isSortable() {
            return sortable;
        }


        public void setHidden(boolean hidden) {
            setHidden(hidden, false);
        }

        private void setHidden(boolean hidden, boolean userOriginated) {
            if (this.hidden != hidden) {
                if (hidden) {
                    grid.escalator.getColumnConfiguration().removeColumns(
                            grid.getVisibleColumns().indexOf(this), 1);
                    this.hidden = hidden;
                } else {
                    this.hidden = hidden;

                    final int columnIndex = grid.getVisibleColumns().indexOf(
                            this);
                    grid.escalator.getColumnConfiguration().insertColumns(
                            columnIndex, 1);




                    int gridFrozenColumns = grid.getFrozenColumnCount();
                    int escalatorFrozenColumns = grid.escalator
                            .getColumnConfiguration().getFrozenColumnCount();
                    if (gridFrozenColumns > escalatorFrozenColumns
                            && escalatorFrozenColumns == columnIndex) {
                        grid.escalator.getColumnConfiguration()
                                .setFrozenColumnCount(++escalatorFrozenColumns);
                    }
                }
                grid.columnHider.updateHidingToggle(this);
                grid.header.updateColSpans();
                grid.footer.updateColSpans();
                scheduleColumnWidthRecalculator();
                this.grid.fireEvent(new ColumnVisibilityChangeEvent<T>(this,
                        hidden, userOriginated));
            }
        }


        public boolean isHidden() {
            return hidden;
        }


        public void setHidable(boolean hidable) {
            if (this.hidable != hidable) {
                this.hidable = hidable;
                grid.columnHider.updateColumnHidable(this);
            }
        }


        public boolean isHidable() {
            return hidable;
        }


        public void setHidingToggleCaption(String hidingToggleCaption) {
            this.hidingToggleCaption = hidingToggleCaption;
            if (isHidable()) {
                grid.columnHider.updateHidingToggle(this);
            }
        }


        public String getHidingToggleCaption() {
            return hidingToggleCaption;
        }

        @Override
        public String toString() {
            String details = "";

            if (headerCaption != null && !headerCaption.isEmpty()) {
                details += "header:\"" + headerCaption + "\" ";
            } else {
                details += "header:empty ";
            }

            if (grid != null) {
                int index = grid.getColumns().indexOf(this);
                if (index != -1) {
                    details += "attached:#" + index + " ";
                } else {
                    details += "attached:unindexed ";
                }
            } else {
                details += "detached ";
            }

            details += "sortable:" + sortable + " ";

            return getClass().getSimpleName() + "[" + details.trim() + "]";
        }


        public Column<C, T> setMinimumWidth(double pixels) {
            final double maxwidth = getMaximumWidth();
            if (pixels >= 0 && pixels > maxwidth && maxwidth >= 0) {
                throw new IllegalArgumentException("New minimum width ("
                        + pixels + ") was greater than maximum width ("
                        + maxwidth + ")");
            }

            if (minimumWidthPx != pixels) {
                minimumWidthPx = pixels;
                scheduleColumnWidthRecalculator();
            }
            return this;
        }


        public Column<C, T> setMaximumWidth(double pixels) {
            final double minwidth = getMinimumWidth();
            if (pixels >= 0 && pixels < minwidth && minwidth >= 0) {
                throw new IllegalArgumentException("New maximum width ("
                        + pixels + ") was less than minimum width (" + minwidth
                        + ")");
            }

            if (maximumWidthPx != pixels) {
                maximumWidthPx = pixels;
                scheduleColumnWidthRecalculator();
            }
            return this;
        }


        public Column<C, T> setExpandRatio(int ratio) {
            if (expandRatio != ratio) {
                expandRatio = ratio;
                scheduleColumnWidthRecalculator();
            }
            return this;
        }


        public Column<C, T> clearExpandRatio() {
            return setExpandRatio(-1);
        }


        public double getMinimumWidth() {
            return minimumWidthPx;
        }


        public double getMaximumWidth() {
            return maximumWidthPx;
        }


        public int getExpandRatio() {
            return expandRatio;
        }


        public Column<C, T> setEditable(boolean editable) {
            if (editable != this.editable && grid.isEditorActive()) {
                throw new IllegalStateException(
                        "Cannot change column editable status while the editor is active");
            }
            this.editable = editable;
            return this;
        }


        public boolean isEditable() {
            return editable;
        }

        private void scheduleColumnWidthRecalculator() {
            if (grid != null) {
                grid.recalculateColumnWidths();
            } else {

            }
        }


        protected void setDefaultHeaderContent(HeaderCell cell) {
            cell.setText(headerCaption);
        }
    }

    protected class BodyUpdater implements EscalatorUpdater {

        @Override
        public void preAttach(Row row, Iterable<FlyweightCell> cellsToAttach) {
            int rowIndex = row.getRow();
            rowReference.set(rowIndex, getDataSource().getRow(rowIndex),
                    row.getElement());
            for (FlyweightCell cell : cellsToAttach) {
                Renderer<?> renderer = findRenderer(cell);
                if (renderer instanceof ComplexRenderer) {
                    try {
                        Column<?, T> column = getVisibleColumn(cell.getColumn());
                        rendererCellReference.set(cell,
                                getColumns().indexOf(column), column);
                        ((ComplexRenderer<?>) renderer)
                                .init(rendererCellReference);
                    } catch (RuntimeException e) {
                        getLogger().log(
                                Level.SEVERE,
                                "Error initing cell in column "
                                        + cell.getColumn(), e);
                    }
                }
            }
        }

        @Override
        public void postAttach(Row row, Iterable<FlyweightCell> attachedCells) {
            for (FlyweightCell cell : attachedCells) {
                Renderer<?> renderer = findRenderer(cell);
                if (renderer instanceof WidgetRenderer) {
                    try {
                        WidgetRenderer<?, ?> widgetRenderer = (WidgetRenderer<?, ?>) renderer;

                        Widget widget = widgetRenderer.createWidget();
                        assert widget != null : "WidgetRenderer.createWidget() returned null. It should return a widget.";
                        assert widget.getParent() == null : "WidgetRenderer.createWidget() returned a widget which already is attached.";
                        assert cell.getElement().getChildCount() == 0 : "Cell content should be empty when adding Widget";


                        cell.getElement().appendChild(widget.getElement());


                        setParent(widget, Grid.this);
                    } catch (RuntimeException e) {
                        getLogger().log(
                                Level.SEVERE,
                                "Error attaching child widget in column "
                                        + cell.getColumn(), e);
                    }
                }
            }
        }

        @Override
        public void update(Row row, Iterable<FlyweightCell> cellsToUpdate) {
            int rowIndex = row.getRow();
            TableRowElement rowElement = row.getElement();
            T rowData = dataSource.getRow(rowIndex);

            boolean hasData = rowData != null;




            boolean usedToHaveData = rowElement
                    .hasClassName(rowHasDataStyleName);

            if (usedToHaveData != hasData) {
                setStyleName(rowElement, rowHasDataStyleName, hasData);
            }

            boolean isEvenIndex = (row.getRow() % 2 == 0);
            setStyleName(rowElement, rowStripeStyleName, !isEvenIndex);

            rowReference.set(rowIndex, rowData, rowElement);

            if (hasData) {
                setStyleName(rowElement, rowSelectedStyleName,
                        isSelected(rowData));

                if (rowStyleGenerator != null) {
                    try {
                        String rowStylename = rowStyleGenerator
                                .getStyle(rowReference);
                        setCustomStyleName(rowElement, rowStylename);
                    } catch (RuntimeException e) {
                        getLogger().log(
                                Level.SEVERE,
                                "Error generating styles for row "
                                        + row.getRow(), e);
                    }
                } else {

                    setCustomStyleName(rowElement, null);
                }
            } else if (usedToHaveData) {
                setStyleName(rowElement, rowSelectedStyleName, false);

                setCustomStyleName(rowElement, null);
            }

            cellFocusHandler.updateFocusedRowStyle(row);

            for (FlyweightCell cell : cellsToUpdate) {
                Column<?, T> column = getVisibleColumn(cell.getColumn());
                final int columnIndex = getColumns().indexOf(column);

                assert column != null : "Column was not found from cell ("
                        + cell.getColumn() + "," + cell.getRow() + ")";

                cellFocusHandler.updateFocusedCellStyle(cell,
                        escalator.getBody());

                if (hasData && cellStyleGenerator != null) {
                    try {
                        cellReference
                                .set(cell.getColumn(), columnIndex, column);
                        String generatedStyle = cellStyleGenerator
                                .getStyle(cellReference);
                        setCustomStyleName(cell.getElement(), generatedStyle);
                    } catch (RuntimeException e) {
                        getLogger().log(
                                Level.SEVERE,
                                "Error generating style for cell in column "
                                        + cell.getColumn(), e);
                    }
                } else if (hasData || usedToHaveData) {
                    setCustomStyleName(cell.getElement(), null);
                }

                Renderer renderer = column.getRenderer();

                try {
                    rendererCellReference.set(cell, columnIndex, column);
                    if (renderer instanceof ComplexRenderer) {

                        ComplexRenderer clxRenderer = (ComplexRenderer) renderer;
                        if (hasData) {
                            if (!usedToHaveData) {

                                clxRenderer.setContentVisible(
                                        rendererCellReference, true);
                            }

                            Object value = column.getValue(rowData);
                            clxRenderer.render(rendererCellReference, value);

                        } else {

                            clxRenderer.setContentVisible(
                                    rendererCellReference, false);
                        }

                    } else if (hasData) {

                        Object value = column.getValue(rowData);
                        renderer.render(rendererCellReference, value);

                    } else {

                        cell.getElement().removeAllChildren();
                    }
                } catch (RuntimeException e) {
                    getLogger().log(
                            Level.SEVERE,
                            "Error rendering cell in column "
                                    + cell.getColumn(), e);
                }
            }
        }

        @Override
        public void preDetach(Row row, Iterable<FlyweightCell> cellsToDetach) {
            for (FlyweightCell cell : cellsToDetach) {
                Renderer renderer = findRenderer(cell);
                if (renderer instanceof WidgetRenderer) {
                    try {
                        Widget w = WidgetUtil.findWidget(cell.getElement()
                                .getFirstChildElement(), Widget.class);
                        if (w != null) {


                            setParent(w, null);


                            cell.getElement().removeChild(w.getElement());
                        }
                    } catch (RuntimeException e) {
                        getLogger().log(
                                Level.SEVERE,
                                "Error detaching widget in column "
                                        + cell.getColumn(), e);
                    }
                }
            }
        }

        @Override
        public void postDetach(Row row, Iterable<FlyweightCell> detachedCells) {
            int rowIndex = row.getRow();


            rowReference.set(rowIndex, null, row.getElement());
            for (FlyweightCell cell : detachedCells) {
                Renderer renderer = findRenderer(cell);
                if (renderer instanceof ComplexRenderer) {
                    try {
                        Column<?, T> column = getVisibleColumn(cell.getColumn());
                        rendererCellReference.set(cell,
                                getColumns().indexOf(column), column);
                        ((ComplexRenderer) renderer)
                                .destroy(rendererCellReference);
                    } catch (RuntimeException e) {
                        getLogger().log(
                                Level.SEVERE,
                                "Error destroying cell in column "
                                        + cell.getColumn(), e);
                    }
                }
            }
        }
    }

    protected class StaticSectionUpdater implements EscalatorUpdater {

        private StaticSection<?> section;
        private RowContainer container;

        public StaticSectionUpdater(StaticSection<?> section,
                RowContainer container) {
            super();
            this.section = section;
            this.container = container;
        }

        @Override
        public void update(Row row, Iterable<FlyweightCell> cellsToUpdate) {
            StaticSection.StaticRow<?> staticRow = section.getRow(row.getRow());
            final List<Column<?, T>> columns = getVisibleColumns();

            setCustomStyleName(row.getElement(), staticRow.getStyleName());

            for (FlyweightCell cell : cellsToUpdate) {
                final StaticSection.StaticCell metadata = staticRow
                        .getCell(columns.get(cell.getColumn()));


                if (staticRow instanceof HeaderRow) {
                    addSortingIndicatorsToHeaderRow((HeaderRow) staticRow, cell);
                }


                cell.setColSpan(metadata.getColspan());

                TableCellElement element = cell.getElement();
                switch (metadata.getType()) {
                case TEXT:
                    element.setInnerText(metadata.getText());
                    break;
                case HTML:
                    element.setInnerHTML(metadata.getHtml());
                    break;
                case WIDGET:
                    preDetach(row, Arrays.asList(cell));
                    element.setInnerHTML("");
                    postAttach(row, Arrays.asList(cell));
                    break;
                }

                setCustomStyleName(element, metadata.getStyleName());

                cellFocusHandler.updateFocusedCellStyle(cell, container);
            }
        }

        private void addSortingIndicatorsToHeaderRow(HeaderRow headerRow,
                FlyweightCell cell) {

            cleanup(cell);

            Column<?, ?> column = getVisibleColumn(cell.getColumn());
            SortOrder sortingOrder = getSortOrder(column);
            if (!headerRow.isDefault() || !column.isSortable()
                    || sortingOrder == null) {


                return;
            }

            Element cellElement = cell.getElement();

            if (SortDirection.ASCENDING == sortingOrder.getDirection()) {
                cellElement.addClassName("sort-asc");
            } else {
                cellElement.addClassName("sort-desc");
            }

            int sortIndex = Grid.this.getSortOrder().indexOf(sortingOrder);
            if (sortIndex > -1 && Grid.this.getSortOrder().size() > 1) {


                cellElement.setAttribute("sort-order",
                        String.valueOf(sortIndex + 1));
            }
        }


        private SortOrder getSortOrder(Column<?, ?> column) {
            for (SortOrder order : Grid.this.getSortOrder()) {
                if (order.getColumn() == column) {
                    return order;
                }
            }
            return null;
        }

        private void cleanup(FlyweightCell cell) {
            Element cellElement = cell.getElement();
            cellElement.removeAttribute("sort-order");
            cellElement.removeClassName("sort-desc");
            cellElement.removeClassName("sort-asc");
        }

        @Override
        public void preAttach(Row row, Iterable<FlyweightCell> cellsToAttach) {
        }

        @Override
        public void postAttach(Row row, Iterable<FlyweightCell> attachedCells) {
            StaticSection.StaticRow<?> gridRow = section.getRow(row.getRow());
            List<Column<?, T>> columns = getVisibleColumns();

            for (FlyweightCell cell : attachedCells) {
                StaticSection.StaticCell metadata = gridRow.getCell(columns
                        .get(cell.getColumn()));

                if (GridStaticCellType.WIDGET.equals(metadata.getType())) {
                    final Widget widget = metadata.getWidget();
                    final Element cellElement = cell.getElement();

                    if (!widget.isAttached()) {


                        cellElement.appendChild(widget.getElement());


                        setParent(widget, Grid.this);
                    }
                }
            }
        }

        @Override
        public void preDetach(Row row, Iterable<FlyweightCell> cellsToDetach) {
            if (section.getRowCount() > row.getRow()) {
                StaticSection.StaticRow<?> gridRow = section.getRow(row
                        .getRow());
                List<Column<?, T>> columns = getVisibleColumns();
                for (FlyweightCell cell : cellsToDetach) {
                    StaticSection.StaticCell metadata = gridRow.getCell(columns
                            .get(cell.getColumn()));

                    if (GridStaticCellType.WIDGET.equals(metadata.getType())
                            && metadata.getWidget().isAttached()) {

                        Widget widget = metadata.getWidget();


                        setParent(widget, null);


                        widget.getElement().removeFromParent();
                    }
                }
            }
        }

        @Override
        public void postDetach(Row row, Iterable<FlyweightCell> detachedCells) {
        }
    };


    public Grid() {
        initWidget(escalator);
        getElement().setTabIndex(0);
        cellFocusHandler = new CellFocusHandler();

        setStylePrimaryName("v-grid");

        escalator.getHeader().setEscalatorUpdater(createHeaderUpdater());
        escalator.getBody().setEscalatorUpdater(createBodyUpdater());
        escalator.getFooter().setEscalatorUpdater(createFooterUpdater());

        header.setGrid(this);
        HeaderRow defaultRow = header.appendRow();
        header.setDefaultRow(defaultRow);

        footer.setGrid(this);

        editor.setGrid(this);

        setSelectionMode(SelectionMode.SINGLE);

        escalator.getBody().setSpacerUpdater(gridSpacerUpdater);

        escalator.addScrollHandler(new ScrollHandler() {
            @Override
            public void onScroll(ScrollEvent event) {
                fireEvent(new ScrollEvent());
            }
        });

        escalator
                .addRowVisibilityChangeHandler(new RowVisibilityChangeHandler() {
                    @Override
                    public void onRowVisibilityChange(
                            RowVisibilityChangeEvent event) {
                        if (dataSource != null && dataSource.size() != 0) {
                            dataIsBeingFetched = true;
                            dataSource.ensureAvailability(
                                    event.getFirstVisibleRow(),
                                    event.getVisibleRowCount());
                        }
                    }
                });



        addSelectionHandler(new SelectionHandler<T>() {

            @Override
            public void onSelect(SelectionEvent<T> event) {
                refreshBody();
            }
        });


        sinkEvents(getHeader().getConsumedEvents());
        sinkEvents(Arrays.asList(BrowserEvents.KEYDOWN, BrowserEvents.KEYUP,
                BrowserEvents.KEYPRESS, BrowserEvents.DBLCLICK,
                BrowserEvents.MOUSEDOWN));


        addHeaderKeyUpHandler(new HeaderKeyUpHandler() {
            @Override
            public void onKeyUp(GridKeyUpEvent event) {
                if (event.getNativeKeyCode() != KeyCodes.KEY_ENTER) {
                    return;
                }
                if (getHeader().getRow(event.getFocusedCell().getRowIndex())
                        .isDefault()) {

                    sorter.sort(event.getFocusedCell().getColumn(),
                            event.isShiftKeyDown());
                }
            }
        });

        addDataAvailableHandler(new DataAvailableHandler() {
            @Override
            public void onDataAvailable(DataAvailableEvent event) {
                dataIsBeingFetched = false;
            }
        });
    }

    @Override
    public boolean isEnabled() {
        return enabled;
    }

    @Override
    public void setEnabled(boolean enabled) {
        if (enabled == this.enabled) {
            return;
        }

        this.enabled = enabled;
        getElement().setTabIndex(enabled ? 0 : -1);


        boolean editorOpen = editor.getState() != State.INACTIVE;
        if (editorOpen) {
            editor.setGridEnabled(enabled);
        }

        getEscalator().setScrollLocked(Direction.VERTICAL,
                !enabled || editorOpen);
        getEscalator().setScrollLocked(Direction.HORIZONTAL, !enabled);
    }

    @Override
    public void setStylePrimaryName(String style) {
        super.setStylePrimaryName(style);
        escalator.setStylePrimaryName(style);
        editor.setStylePrimaryName(style);
        sidebar.setStylePrimaryName(style + "-sidebar");
        sidebar.addStyleName("v-contextmenu");

        String rowStyle = getStylePrimaryName() + "-row";
        rowHasDataStyleName = rowStyle + "-has-data";
        rowSelectedStyleName = rowStyle + "-selected";
        rowStripeStyleName = rowStyle + "-stripe";

        cellFocusStyleName = getStylePrimaryName() + "-cell-focused";
        rowFocusStyleName = getStylePrimaryName() + "-row-focused";

        if (isAttached()) {
            refreshHeader();
            refreshBody();
            refreshFooter();
        }
    }


    protected EscalatorUpdater createHeaderUpdater() {
        return new StaticSectionUpdater(header, escalator.getHeader());
    }


    protected EscalatorUpdater createBodyUpdater() {
        return new BodyUpdater();
    }


    protected EscalatorUpdater createFooterUpdater() {
        return new StaticSectionUpdater(footer, escalator.getFooter());
    }


    private void refreshRowContainer(RowContainer rows, StaticSection<?> section) {


        int rowDiff = section.getVisibleRowCount() - rows.getRowCount();
        if (rowDiff > 0) {
            rows.insertRows(0, rowDiff);
        } else if (rowDiff < 0) {
            rows.removeRows(0, -rowDiff);
        }


        if (rows.getRowCount() > 0) {
            rows.refreshRows(0, rows.getRowCount());
        }
    }


    void refreshHeader() {
        refreshRowContainer(escalator.getHeader(), header);
    }


    private void refreshBody() {
        escalator.getBody().refreshRows(0, escalator.getBody().getRowCount());
    }


    void refreshFooter() {
        refreshRowContainer(escalator.getFooter(), footer);
    }


    public void addColumns(Column<?, T>... columns) {
        int count = getColumnCount();
        for (Column<?, T> column : columns) {
            addColumn(column, count++);
        }
    }


    public <C extends Column<?, T>> C addColumn(C column) {
        addColumn(column, getColumnCount());
        return column;
    }


    public <C extends Column<?, T>> C addColumn(C column, int index) {
        if (column == selectionColumn) {
            throw new IllegalArgumentException("The selection column many "
                    + "not be added manually");
        } else if (selectionColumn != null && index == 0) {
            throw new IllegalStateException("A column cannot be inserted "
                    + "before the selection column");
        }

        addColumnSkipSelectionColumnCheck(column, index);
        return column;
    }

    private void addColumnSkipSelectionColumnCheck(Column<?, T> column,
            int index) {

        columns.add(index, column);

        header.addColumn(column);
        footer.addColumn(column);


        ((Column<?, T>) column).setGrid(this);



        if (!column.isHidden()) {
            int escalatorIndex = index;
            for (int existingColumn = 0; existingColumn < index; existingColumn++) {
                if (getColumn(existingColumn).isHidden()) {
                    escalatorIndex--;
                }
            }
            escalator.getColumnConfiguration().insertColumns(escalatorIndex, 1);
        }


        column.reapplyWidth();


        Set<String> events = new HashSet<String>();
        events.addAll(getConsumedEventsForRenderer(column.getRenderer()));

        if (column.isHidable()) {
            columnHider.updateColumnHidable(column);
        }

        sinkEvents(events);
    }

    private void sinkEvents(Collection<String> events) {
        assert events != null;

        int eventsToSink = 0;
        for (String typeName : events) {
            int typeInt = Event.getTypeInt(typeName);
            if (typeInt < 0) {

                sinkBitlessEvent(typeName);
            } else {
                eventsToSink |= typeInt;
            }
        }

        if (eventsToSink > 0) {
            sinkEvents(eventsToSink);
        }
    }

    private Renderer<?> findRenderer(FlyweightCell cell) {
        Column<?, T> column = getVisibleColumn(cell.getColumn());
        assert column != null : "Could not find column at index:"
                + cell.getColumn();
        return column.getRenderer();
    }


    public void removeColumn(Column<?, T> column) {
        if (column != null && column.equals(selectionColumn)) {
            throw new IllegalArgumentException(
                    "The selection column may not be removed manually.");
        }

        removeColumnSkipSelectionColumnCheck(column);
    }

    private void removeColumnSkipSelectionColumnCheck(Column<?, T> column) {
        int columnIndex = columns.indexOf(column);


        escalator.getColumnConfiguration().removeColumns(
                getVisibleColumns().indexOf(column), 1);

        updateFrozenColumns();

        header.removeColumn(column);
        footer.removeColumn(column);


        ((Column<?, T>) column).setGrid(null);

        columns.remove(columnIndex);

        if (column.isHidable()) {
            columnHider.removeColumnHidingToggle(column);
        }
    }


    public int getColumnCount() {
        return columns.size();
    }


    public List<Column<?, T>> getColumns() {
        return Collections
                .unmodifiableList(new ArrayList<Column<?, T>>(columns));
    }


    public List<Column<?, T>> getVisibleColumns() {
        ArrayList<Column<?, T>> visible = new ArrayList<Column<?, T>>();
        for (Column<?, T> c : columns) {
            if (!c.isHidden()) {
                visible.add(c);
            }
        }
        return Collections.unmodifiableList(visible);
    }


    public Column<?, T> getColumn(int index) throws IllegalArgumentException {
        if (index < 0 || index >= columns.size()) {
            throw new IllegalStateException("Column not found.");
        }
        return columns.get(index);
    }

    private Column<?, T> getVisibleColumn(int index)
            throws IllegalArgumentException {
        List<Column<?, T>> visibleColumns = getVisibleColumns();
        if (index < 0 || index >= visibleColumns.size()) {
            throw new IllegalStateException("Column not found.");
        }
        return visibleColumns.get(index);
    }


    protected Header getHeader() {
        return header;
    }


    public HeaderRow getHeaderRow(int rowIndex) {
        return header.getRow(rowIndex);
    }


    public HeaderRow addHeaderRowAt(int index) {
        return header.addRowAt(index);
    }


    public HeaderRow appendHeaderRow() {
        return header.appendRow();
    }


    public HeaderRow getDefaultHeaderRow() {
        return header.getDefaultRow();
    }


    public int getHeaderRowCount() {
        return header.getRowCount();
    }


    public HeaderRow prependHeaderRow() {
        return header.prependRow();
    }


    public void removeHeaderRow(HeaderRow row) {
        header.removeRow(row);
    }


    public void removeHeaderRow(int rowIndex) {
        header.removeRow(rowIndex);
    }


    public void setDefaultHeaderRow(HeaderRow row) {
        header.setDefaultRow(row);
    }


    public void setHeaderVisible(boolean visible) {
        header.setVisible(visible);
    }


    public boolean isHeaderVisible() {
        return header.isVisible();
    }




    protected Footer getFooter() {
        return footer;
    }


    public FooterRow getFooterRow(int rowIndex) {
        return footer.getRow(rowIndex);
    }


    public FooterRow addFooterRowAt(int index) {
        return footer.addRowAt(index);
    }


    public FooterRow appendFooterRow() {
        return footer.appendRow();
    }


    public int getFooterRowCount() {
        return footer.getRowCount();
    }


    public FooterRow prependFooterRow() {
        return footer.prependRow();
    }


    public void removeFooterRow(FooterRow row) {
        footer.removeRow(row);
    }


    public void removeFooterRow(int rowIndex) {
        footer.removeRow(rowIndex);
    }


    public void setFooterVisible(boolean visible) {
        footer.setVisible(visible);
    }


    public boolean isFooterVisible() {
        return footer.isVisible();
    }

    protected Editor<T> getEditor() {
        return editor;
    }

    protected Escalator getEscalator() {
        return escalator;
    }


    @Override
    public void setHeight(String height) {
        escalator.setHeight(height);
    }

    @Override
    public void setWidth(String width) {
        escalator.setWidth(width);
    }


    public void setDataSource(final DataSource<T> dataSource)
            throws IllegalArgumentException {
        if (dataSource == null) {
            throw new IllegalArgumentException("dataSource can't be null.");
        }

        selectionModel.reset();

        if (this.dataSource != null) {
            this.dataSource.setDataChangeHandler(null);
        }

        this.dataSource = dataSource;
        dataSource.setDataChangeHandler(new DataChangeHandler() {
            @Override
            public void dataUpdated(int firstIndex, int numberOfItems) {
                escalator.getBody().refreshRows(firstIndex, numberOfItems);
            }

            @Override
            public void dataRemoved(int firstIndex, int numberOfItems) {
                escalator.getBody().removeRows(firstIndex, numberOfItems);
                Range removed = Range.withLength(firstIndex, numberOfItems);
                cellFocusHandler.rowsRemovedFromBody(removed);
            }

            @Override
            public void dataAdded(int firstIndex, int numberOfItems) {
                escalator.getBody().insertRows(firstIndex, numberOfItems);
                Range added = Range.withLength(firstIndex, numberOfItems);
                cellFocusHandler.rowsAddedToBody(added);
            }

            @Override
            public void dataAvailable(int firstIndex, int numberOfItems) {
                currentDataAvailable = Range.withLength(firstIndex,
                        numberOfItems);
                fireEvent(new DataAvailableEvent(currentDataAvailable));
            }

            @Override
            public void resetDataAndSize(int newSize) {
                RowContainer body = escalator.getBody();
                int oldSize = body.getRowCount();


                Set<Integer> oldDetails = new HashSet<Integer>(visibleDetails);
                for (int i : oldDetails) {
                    setDetailsVisible(i, false);
                }

                if (newSize > oldSize) {
                    body.insertRows(oldSize, newSize - oldSize);
                    cellFocusHandler.rowsAddedToBody(Range.withLength(oldSize,
                            newSize - oldSize));
                } else if (newSize < oldSize) {
                    body.removeRows(newSize, oldSize - newSize);
                    cellFocusHandler.rowsRemovedFromBody(Range.withLength(
                            newSize, oldSize - newSize));
                }

                if (newSize > 0) {
                    dataIsBeingFetched = true;
                    Range visibleRowRange = escalator.getVisibleRowRange();
                    dataSource.ensureAvailability(visibleRowRange.getStart(),
                            visibleRowRange.length());
                } else {


                    dataAvailable(0, 0);
                }

                assert body.getRowCount() == newSize;
            }
        });

        int previousRowCount = escalator.getBody().getRowCount();
        if (previousRowCount != 0) {
            escalator.getBody().removeRows(0, previousRowCount);
        }

        setEscalatorSizeFromDataSource();
    }

    private void setEscalatorSizeFromDataSource() {
        assert escalator.getBody().getRowCount() == 0;

        int size = dataSource.size();
        if (size == -1 && isAttached()) {


            size = getEscalator().getMaxVisibleRowCount();
        }
        if (size > 0) {
            escalator.getBody().insertRows(0, size);
        }
    }


    public DataSource<T> getDataSource() {
        return dataSource;
    }


    public void setFrozenColumnCount(int numberOfColumns) {
        if (numberOfColumns < -1 || numberOfColumns > getColumnCount()) {
            throw new IllegalArgumentException(
                    "count must be between -1 and the current number of columns ("
                            + getColumnCount() + ")");
        }

        frozenColumnCount = numberOfColumns;
        updateFrozenColumns();
    }

    private void updateFrozenColumns() {
        escalator.getColumnConfiguration().setFrozenColumnCount(
                getVisibleFrozenColumnCount());
    }

    private int getVisibleFrozenColumnCount() {
        int numberOfColumns = getFrozenColumnCount();



        for (int i = 0; i < frozenColumnCount; i++) {
            if (getColumn(i).isHidden()) {
                numberOfColumns--;
            }
        }

        if (numberOfColumns == -1) {
            numberOfColumns = 0;
        } else if (selectionColumn != null) {
            numberOfColumns++;
        }
        return numberOfColumns;
    }


    public int getFrozenColumnCount() {
        return frozenColumnCount;
    }

    public HandlerRegistration addRowVisibilityChangeHandler(
            RowVisibilityChangeHandler handler) {

        return escalator.addRowVisibilityChangeHandler(handler);
    }


    public void scrollToRow(int rowIndex) throws IllegalArgumentException {
        scrollToRow(rowIndex, ScrollDestination.ANY,
                GridConstants.DEFAULT_PADDING);
    }


    public void scrollToRow(int rowIndex, ScrollDestination destination)
            throws IllegalArgumentException {
        scrollToRow(rowIndex, destination,
                destination == ScrollDestination.MIDDLE ? 0
                        : GridConstants.DEFAULT_PADDING);
    }


    private void scrollToRow(int rowIndex, ScrollDestination destination,
            int paddingPx) throws IllegalArgumentException {
        int maxsize = escalator.getBody().getRowCount() - 1;

        if (rowIndex < 0) {
            throw new IllegalArgumentException("Row index (" + rowIndex
                    + ") is below zero!");
        }

        if (rowIndex > maxsize) {
            throw new IllegalArgumentException("Row index (" + rowIndex
                    + ") is above maximum (" + maxsize + ")!");
        }

        escalator.scrollToRowAndSpacer(rowIndex, destination, paddingPx);
    }


    public void scrollToStart() {
        scrollToRow(0, ScrollDestination.START);
    }


    public void scrollToEnd() {
        scrollToRow(escalator.getBody().getRowCount() - 1,
                ScrollDestination.END);
    }


    public void setScrollTop(double px) {
        escalator.setScrollTop(px);
    }


    public double getScrollTop() {
        return escalator.getScrollTop();
    }


    public void setScrollLeft(double px) {
        escalator.setScrollLeft(px);
    }


    public double getScrollLeft() {
        return escalator.getScrollLeft();
    }


    public double getScrollHeight() {
        return escalator.getScrollHeight();
    }


    public double getScrollWidth() {
        return escalator.getScrollWidth();
    }

    private static final Logger getLogger() {
        return Logger.getLogger(Grid.class.getName());
    }


    public void setHeightByRows(double rows) throws IllegalArgumentException {
        escalator.setHeightByRows(rows);
    }


    public double getHeightByRows() {
        return escalator.getHeightByRows();
    }


    public void setHeightMode(HeightMode heightMode) {


        escalator.setHeightMode(heightMode);
    }


    public HeightMode getHeightMode() {
        return escalator.getHeightMode();
    }

    private Set<String> getConsumedEventsForRenderer(Renderer<?> renderer) {
        Set<String> events = new HashSet<String>();
        if (renderer instanceof ComplexRenderer) {
            Collection<String> consumedEvents = ((ComplexRenderer<?>) renderer)
                    .getConsumedEvents();
            if (consumedEvents != null) {
                events.addAll(consumedEvents);
            }
        }
        return events;
    }

    @Override
    public void onBrowserEvent(Event event) {
        if (!isEnabled()) {
            return;
        }

        EventTarget target = event.getEventTarget();

        if (!Element.is(target) || isOrContainsInSpacer(Element.as(target))) {
            return;
        }

        Element e = Element.as(target);
        RowContainer container = escalator.findRowContainer(e);
        Cell cell;

        String eventType = event.getType();
        if (container == null) {
            if (eventType.equals(BrowserEvents.KEYDOWN)
                    || eventType.equals(BrowserEvents.KEYUP)
                    || eventType.equals(BrowserEvents.KEYPRESS)) {
                cell = cellFocusHandler.getFocusedCell();
                container = cellFocusHandler.containerWithFocus;
            } else {

                return;
            }
        } else {
            cell = container.getCell(e);
            if (eventType.equals(BrowserEvents.MOUSEDOWN)) {
                cellOnPrevMouseDown = cell;
            } else if (cell == null && eventType.equals(BrowserEvents.CLICK)) {

                cell = cellOnPrevMouseDown;
            }
        }

        assert cell != null : "received " + eventType
                + "-event with a null cell target";
        eventCell.set(cell, getSectionFromContainer(container));


        if (handleEditorEvent(event, container)) {
            return;
        }


        super.onBrowserEvent(event);

        if (!isElementInChildWidget(e)) {

            if (handleHeaderCellDragStartEvent(event, container)) {
                return;
            }


            if (handleHeaderDefaultRowEvent(event, container)) {
                return;
            }

            if (handleRendererEvent(event, container)) {
                return;
            }

            if (handleCellFocusEvent(event, container)) {
                return;
            }
        }
    }

    private Section getSectionFromContainer(RowContainer container) {
        assert container != null : "RowContainer should not be null";

        if (container == escalator.getBody()) {
            return Section.BODY;
        } else if (container == escalator.getFooter()) {
            return Section.FOOTER;
        } else if (container == escalator.getHeader()) {
            return Section.HEADER;
        }
        assert false : "RowContainer was not header, footer or body.";
        return null;
    }

    private boolean isOrContainsInSpacer(Node node) {
        Node n = node;
        while (n != null && n != getElement()) {
            boolean isElement = Element.is(n);
            if (isElement) {
                String className = Element.as(n).getClassName();
                if (className.contains(getStylePrimaryName() + "-spacer")) {
                    return true;
                }
            }
            n = n.getParentNode();
        }
        return false;
    }

    private boolean isElementInChildWidget(Element e) {
        Widget w = WidgetUtil.findWidget(e, null);

        if (w == this) {
            return false;
        }


        while (w != null && w != this) {
            w = w.getParent();
        }
        return w != null;
    }

    private boolean handleEditorEvent(Event event, RowContainer container) {

        final boolean closeEvent = event.getTypeInt() == Event.ONKEYDOWN
                && event.getKeyCode() == Editor.KEYCODE_HIDE;

        double now = Duration.currentTimeMillis();
        int currentX = WidgetUtil.getTouchOrMouseClientX(event);
        int currentY = WidgetUtil.getTouchOrMouseClientY(event);

        final boolean validTouchOpenEvent = event.getTypeInt() == Event.ONTOUCHEND
                && now - lastTouchEventTime < 500
                && lastTouchEventRow == eventCell.getRowIndex()
                && Math.abs(lastTouchEventX - currentX) < 20
                && Math.abs(lastTouchEventY - currentY) < 20;

        final boolean openEvent = event.getTypeInt() == Event.ONDBLCLICK
                || (event.getTypeInt() == Event.ONKEYDOWN && event.getKeyCode() == Editor.KEYCODE_SHOW)
                || validTouchOpenEvent;

        if (event.getTypeInt() == Event.ONTOUCHSTART) {
            lastTouchEventX = currentX;
            lastTouchEventY = currentY;
        }

        if (event.getTypeInt() == Event.ONTOUCHEND) {
            lastTouchEventTime = now;
            lastTouchEventRow = eventCell.getRowIndex();
        }

        if (editor.getState() != Editor.State.INACTIVE) {
            if (closeEvent) {
                editor.cancel();
                FocusUtil.setFocus(this, true);
            }
            return true;
        }

        if (container == escalator.getBody() && editor.isEnabled() && openEvent) {
            editor.editRow(eventCell.getRowIndex(),
                    eventCell.getColumnIndexDOM());
            event.preventDefault();
            return true;
        }

        return false;
    }

    private boolean handleRendererEvent(Event event, RowContainer container) {

        if (container == escalator.getBody()) {
            Column<?, T> gridColumn = eventCell.getColumn();
            boolean enterKey = event.getType().equals(BrowserEvents.KEYDOWN)
                    && event.getKeyCode() == KeyCodes.KEY_ENTER;
            boolean doubleClick = event.getType()
                    .equals(BrowserEvents.DBLCLICK);

            if (gridColumn.getRenderer() instanceof ComplexRenderer) {
                ComplexRenderer<?> cplxRenderer = (ComplexRenderer<?>) gridColumn
                        .getRenderer();
                if (cplxRenderer.getConsumedEvents().contains(event.getType())) {
                    if (cplxRenderer.onBrowserEvent(eventCell, event)) {
                        return true;
                    }
                }


                if ((enterKey || doubleClick)
                        && cplxRenderer.onActivate(eventCell)) {
                    return true;
                }
            }
        }
        return false;
    }

    private boolean handleCellFocusEvent(Event event, RowContainer container) {
        Collection<String> navigation = cellFocusHandler.getNavigationEvents();
        if (navigation.contains(event.getType())) {
            cellFocusHandler.handleNavigationEvent(event, eventCell);
        }
        return false;
    }

    private boolean handleHeaderCellDragStartEvent(Event event,
            RowContainer container) {
        if (!isColumnReorderingAllowed()) {
            return false;
        }
        if (container != escalator.getHeader()) {
            return false;
        }
        if (eventCell.getColumnIndex() < escalator.getColumnConfiguration()
                .getFrozenColumnCount()) {
            return false;
        }

        if (event.getTypeInt() == Event.ONMOUSEDOWN
                && event.getButton() == NativeEvent.BUTTON_LEFT
                || event.getTypeInt() == Event.ONTOUCHSTART) {
            dndHandler.onDragStartOnDraggableElement(event,
                    headerCellDndCallback);
            event.preventDefault();
            event.stopPropagation();
            return true;
        }
        return false;
    }

    private Point rowEventTouchStartingPoint;
    private CellStyleGenerator<T> cellStyleGenerator;
    private RowStyleGenerator<T> rowStyleGenerator;
    private RowReference<T> rowReference = new RowReference<T>(this);
    private CellReference<T> cellReference = new CellReference<T>(rowReference);
    private RendererCellReference rendererCellReference = new RendererCellReference(
            (RowReference<Object>) rowReference);

    private boolean handleHeaderDefaultRowEvent(Event event,
            RowContainer container) {
        if (container != escalator.getHeader()) {
            return false;
        }
        if (!getHeader().getRow(eventCell.getRowIndex()).isDefault()) {
            return false;
        }
        if (!eventCell.getColumn().isSortable()) {

            return false;
        }

        if (BrowserEvents.MOUSEDOWN.equals(event.getType())
                && event.getShiftKey()) {

            event.preventDefault();
        }

        if (BrowserEvents.TOUCHSTART.equals(event.getType())) {
            if (event.getTouches().length() > 1) {
                return false;
            }

            event.preventDefault();

            Touch touch = event.getChangedTouches().get(0);
            rowEventTouchStartingPoint = new Point(touch.getClientX(),
                    touch.getClientY());

            sorter.sortAfterDelay(GridConstants.LONG_TAP_DELAY, true);

            return true;

        } else if (BrowserEvents.TOUCHMOVE.equals(event.getType())) {
            if (event.getTouches().length() > 1) {
                return false;
            }

            event.preventDefault();

            Touch touch = event.getChangedTouches().get(0);
            double diffX = Math.abs(touch.getClientX()
                    - rowEventTouchStartingPoint.getX());
            double diffY = Math.abs(touch.getClientY()
                    - rowEventTouchStartingPoint.getY());



            if (diffX > GridConstants.LONG_TAP_THRESHOLD
                    || diffY > GridConstants.LONG_TAP_THRESHOLD) {
                sorter.cancelDelayedSort();
            }

            return true;

        } else if (BrowserEvents.TOUCHEND.equals(event.getType())) {
            if (event.getTouches().length() > 1) {
                return false;
            }

            if (sorter.isDelayedSortScheduled()) {

                sorter.cancelDelayedSort();
                sorter.sort(eventCell.getColumn(), false);
            }

            return true;

        } else if (BrowserEvents.TOUCHCANCEL.equals(event.getType())) {
            if (event.getTouches().length() > 1) {
                return false;
            }

            sorter.cancelDelayedSort();

            return true;

        } else if (BrowserEvents.CLICK.equals(event.getType())) {

            sorter.sort(eventCell.getColumn(), event.getShiftKey());


            return false;
        } else {
            return false;
        }
    }

    @Override
    @SuppressWarnings("deprecation")
    public com.google.gwt.user.client.Element getSubPartElement(String subPart) {


        Element escalatorElement = escalator.getSubPartElement(subPart
                .replaceFirst("^details\\[", "spacer["));

        if (escalatorElement != null) {
            return DOM.asOld(escalatorElement);
        }

        SubPartArguments args = SubPartArguments.create(subPart);

        Element editor = getSubPartElementEditor(args);
        if (editor != null) {
            return DOM.asOld(editor);
        }

        return null;
    }

    private Element getSubPartElementEditor(SubPartArguments args) {

        if (!args.getType().equalsIgnoreCase("editor")
                || editor.getState() != State.ACTIVE) {
            return null;
        }

        if (args.getIndicesLength() == 0) {
            return editor.editorOverlay;
        } else if (args.getIndicesLength() == 1
                && args.getIndex(0) < columns.size()) {
            escalator
                    .scrollToColumn(args.getIndex(0), ScrollDestination.ANY, 0);
            return editor.getWidget(columns.get(args.getIndex(0))).getElement();
        }

        return null;
    }

    @Override
    @SuppressWarnings("deprecation")
    public String getSubPartName(com.google.gwt.user.client.Element subElement) {

        String escalatorStructureName = escalator.getSubPartName(subElement);
        if (escalatorStructureName != null) {
            return escalatorStructureName.replaceFirst("^spacer", "details");
        }

        String editorName = getSubPartNameEditor(subElement);
        if (editorName != null) {
            return editorName;
        }

        return null;
    }

    private String getSubPartNameEditor(Element subElement) {

        if (editor.getState() != State.ACTIVE
                || !editor.editorOverlay.isOrHasChild(subElement)) {
            return null;
        }

        int i = 0;
        for (Column<?, T> column : columns) {
            if (editor.getWidget(column).getElement().isOrHasChild(subElement)) {
                return "editor[" + i + "]";
            }
            ++i;
        }

        return "editor";
    }

    private void setSelectColumnRenderer(
            final Renderer<Boolean> selectColumnRenderer) {
        if (this.selectColumnRenderer == selectColumnRenderer) {
            return;
        }

        if (this.selectColumnRenderer != null) {
            if (this.selectColumnRenderer instanceof ComplexRenderer) {

                ((ComplexRenderer<?>) this.selectColumnRenderer).destroy();
            }



            Column<?, T> colToRemove = selectionColumn;
            selectionColumn = null;
            removeColumnSkipSelectionColumnCheck(colToRemove);
            cellFocusHandler.offsetRangeBy(-1);
        }

        this.selectColumnRenderer = selectColumnRenderer;

        if (selectColumnRenderer != null) {
            cellFocusHandler.offsetRangeBy(1);
            selectionColumn = new SelectionColumn(selectColumnRenderer);

            addColumnSkipSelectionColumnCheck(selectionColumn, 0);
            selectionColumn.initDone();
        } else {
            selectionColumn = null;
            refreshBody();
        }

        updateFrozenColumns();
    }


    public void setSelectionModel(SelectionModel<T> selectionModel) {

        if (selectionModel == null) {
            throw new IllegalArgumentException("Selection model can't be null");
        }

        if (this.selectionModel != null) {

            this.selectionModel.setGrid(null);
        }

        this.selectionModel = selectionModel;
        selectionModel.setGrid(this);
        setSelectColumnRenderer(this.selectionModel
                .getSelectionColumnRenderer());


        refreshBody();
    }


    public SelectionModel<T> getSelectionModel() {
        return selectionModel;
    }


    public void setSelectionMode(SelectionMode mode) {
        SelectionModel<T> model = mode.createModel();
        setSelectionModel(model);
    }


    public boolean isSelected(T row) {
        return selectionModel.isSelected(row);
    }


    @SuppressWarnings("unchecked")
    public boolean select(T row) {
        if (selectionModel instanceof SelectionModel.Single<?>) {
            return ((SelectionModel.Single<T>) selectionModel).select(row);
        } else if (selectionModel instanceof SelectionModel.Multi<?>) {
            return ((SelectionModel.Multi<T>) selectionModel).select(row);
        } else {
            throw new IllegalStateException("Unsupported selection model");
        }
    }


    @SuppressWarnings("unchecked")
    public boolean deselect(T row) {
        if (selectionModel instanceof SelectionModel.Single<?>) {
            return ((SelectionModel.Single<T>) selectionModel).deselect(row);
        } else if (selectionModel instanceof SelectionModel.Multi<?>) {
            return ((SelectionModel.Multi<T>) selectionModel).deselect(row);
        } else {
            throw new IllegalStateException("Unsupported selection model");
        }
    }


    public T getSelectedRow() {
        if (selectionModel instanceof SelectionModel.Single<?>) {
            return ((SelectionModel.Single<T>) selectionModel).getSelectedRow();
        } else {
            throw new IllegalStateException(
                    "Unsupported selection model; can not get single selected row");
        }
    }


    public Collection<T> getSelectedRows() {
        return selectionModel.getSelectedRows();
    }

    @Override
    public HandlerRegistration addSelectionHandler(
            final SelectionHandler<T> handler) {
        return addHandler(handler, SelectionEvent.getType());
    }


    public void sort(Sort s) {
        setSortOrder(s.build());
    }


    public <C> void sort(Column<C, T> column) {
        sort(column, SortDirection.ASCENDING);
    }


    public <C> void sort(Column<C, T> column, SortDirection direction) {
        sort(Sort.by(column, direction));
    }


    public void setSortOrder(List<SortOrder> order) {
        setSortOrder(order, false);
    }

    private void setSortOrder(List<SortOrder> order, boolean userOriginated) {
        if (order != sortOrder) {
            sortOrder.clear();
            if (order != null) {
                sortOrder.addAll(order);
            }
        }
        sort(userOriginated);
    }


    public List<SortOrder> getSortOrder() {
        return Collections.unmodifiableList(sortOrder);
    }


    private SortOrder getSortOrder(Column<?, ?> column) {
        for (SortOrder order : getSortOrder()) {
            if (order.getColumn() == column) {
                return order;
            }
        }
        return null;
    }


    public HandlerRegistration addSortHandler(SortHandler<T> handler) {
        return addHandler(handler, SortEvent.getType());
    }


    public HandlerRegistration addSelectAllHandler(SelectAllHandler<T> handler) {
        return addHandler(handler, SelectAllEvent.getType());
    }


    public HandlerRegistration addDataAvailableHandler(
            final DataAvailableHandler handler) {

        Scheduler.get().scheduleFinally(new ScheduledCommand() {
            @Override
            public void execute() {
                if (!dataIsBeingFetched) {
                    handler.onDataAvailable(new DataAvailableEvent(
                            currentDataAvailable));
                }
            }
        });
        return addHandler(handler, DataAvailableEvent.TYPE);
    }


    public HandlerRegistration addBodyKeyDownHandler(BodyKeyDownHandler handler) {
        return addHandler(handler, keyDown.getAssociatedType());
    }


    public HandlerRegistration addBodyKeyUpHandler(BodyKeyUpHandler handler) {
        return addHandler(handler, keyUp.getAssociatedType());
    }


    public HandlerRegistration addBodyKeyPressHandler(
            BodyKeyPressHandler handler) {
        return addHandler(handler, keyPress.getAssociatedType());
    }


    public HandlerRegistration addHeaderKeyDownHandler(
            HeaderKeyDownHandler handler) {
        return addHandler(handler, keyDown.getAssociatedType());
    }


    public HandlerRegistration addHeaderKeyUpHandler(HeaderKeyUpHandler handler) {
        return addHandler(handler, keyUp.getAssociatedType());
    }


    public HandlerRegistration addHeaderKeyPressHandler(
            HeaderKeyPressHandler handler) {
        return addHandler(handler, keyPress.getAssociatedType());
    }


    public HandlerRegistration addFooterKeyDownHandler(
            FooterKeyDownHandler handler) {
        return addHandler(handler, keyDown.getAssociatedType());
    }


    public HandlerRegistration addFooterKeyUpHandler(FooterKeyUpHandler handler) {
        return addHandler(handler, keyUp.getAssociatedType());
    }


    public HandlerRegistration addFooterKeyPressHandler(
            FooterKeyPressHandler handler) {
        return addHandler(handler, keyPress.getAssociatedType());
    }


    public HandlerRegistration addBodyClickHandler(BodyClickHandler handler) {
        return addHandler(handler, clickEvent.getAssociatedType());
    }


    public HandlerRegistration addHeaderClickHandler(HeaderClickHandler handler) {
        return addHandler(handler, clickEvent.getAssociatedType());
    }


    public HandlerRegistration addFooterClickHandler(FooterClickHandler handler) {
        return addHandler(handler, clickEvent.getAssociatedType());
    }


    public HandlerRegistration addBodyDoubleClickHandler(
            BodyDoubleClickHandler handler) {
        return addHandler(handler, doubleClickEvent.getAssociatedType());
    }


    public HandlerRegistration addHeaderDoubleClickHandler(
            HeaderDoubleClickHandler handler) {
        return addHandler(handler, doubleClickEvent.getAssociatedType());
    }


    public HandlerRegistration addFooterDoubleClickHandler(
            FooterDoubleClickHandler handler) {
        return addHandler(handler, doubleClickEvent.getAssociatedType());
    }


    public HandlerRegistration addColumnReorderHandler(
            ColumnReorderHandler<T> handler) {
        return addHandler(handler, ColumnReorderEvent.getType());
    }


    public HandlerRegistration addColumnVisibilityChangeHandler(
            ColumnVisibilityChangeHandler<T> handler) {
        return addHandler(handler, ColumnVisibilityChangeEvent.getType());
    }


    private void sort(boolean userOriginated) {
        refreshHeader();
        fireEvent(new SortEvent<T>(this,
                Collections.unmodifiableList(sortOrder), userOriginated));
    }

    private int getLastVisibleRowIndex() {
        int lastRowIndex = escalator.getVisibleRowRange().getEnd();
        int footerTop = escalator.getFooter().getElement().getAbsoluteTop();
        Element lastRow;

        do {
            lastRow = escalator.getBody().getRowElement(--lastRowIndex);
        } while (lastRow.getAbsoluteTop() > footerTop);

        return lastRowIndex;
    }

    private int getFirstVisibleRowIndex() {
        int firstRowIndex = escalator.getVisibleRowRange().getStart();
        int headerBottom = escalator.getHeader().getElement()
                .getAbsoluteBottom();
        Element firstRow = escalator.getBody().getRowElement(firstRowIndex);

        while (firstRow.getAbsoluteBottom() < headerBottom) {
            firstRow = escalator.getBody().getRowElement(++firstRowIndex);
        }

        return firstRowIndex;
    }


    public HandlerRegistration addScrollHandler(ScrollHandler handler) {
        return addHandler(handler, ScrollEvent.TYPE);
    }

    @Override
    public boolean isWorkPending() {
        return escalator.isWorkPending() || dataIsBeingFetched
                || autoColumnWidthsRecalculator.isScheduled();
    }


    public boolean isColumnReorderingAllowed() {
        return columnReorderingAllowed;
    }


    public void setColumnReorderingAllowed(boolean columnReorderingAllowed) {
        this.columnReorderingAllowed = columnReorderingAllowed;
    }


    public void setColumnOrder(Column<?, T>... orderedColumns) {
        ColumnConfiguration conf = getEscalator().getColumnConfiguration();


        conf.removeColumns(0, conf.getColumnCount());

        List<Column<?, T>> newOrder = new ArrayList<Column<?, T>>();
        if (selectionColumn != null) {
            newOrder.add(selectionColumn);
        }

        int i = 0;
        for (Column<?, T> column : orderedColumns) {
            if (columns.contains(column)) {
                newOrder.add(column);
                ++i;
            } else {
                throw new IllegalArgumentException("Given column at index " + i
                        + " does not exist in Grid");
            }
        }

        if (columns.size() != newOrder.size()) {
            columns.removeAll(newOrder);
            newOrder.addAll(columns);
        }
        columns = newOrder;

        List<Column<?, T>> visibleColumns = getVisibleColumns();


        conf.insertColumns(0, visibleColumns.size());


        updateFrozenColumns();


        for (Column<?, T> column : columns) {
            column.reapplyWidth();
        }


        for (HeaderRow row : header.getRows()) {
            row.calculateColspans();
        }
        for (FooterRow row : footer.getRows()) {
            row.calculateColspans();
        }

        columnHider.updateTogglesOrder();

        fireEvent(new ColumnReorderEvent<T>());
    }


    public void setCellStyleGenerator(CellStyleGenerator<T> cellStyleGenerator) {
        this.cellStyleGenerator = cellStyleGenerator;
        refreshBody();
    }


    public CellStyleGenerator<T> getCellStyleGenerator() {
        return cellStyleGenerator;
    }


    public void setRowStyleGenerator(RowStyleGenerator<T> rowStyleGenerator) {
        this.rowStyleGenerator = rowStyleGenerator;
        refreshBody();
    }


    public RowStyleGenerator<T> getRowStyleGenerator() {
        return rowStyleGenerator;
    }

    private static void setCustomStyleName(Element element, String styleName) {
        assert element != null;

        String oldStyleName = element
                .getPropertyString(CUSTOM_STYLE_PROPERTY_NAME);

        if (!SharedUtil.equals(oldStyleName, styleName)) {
            if (oldStyleName != null) {
                element.removeClassName(oldStyleName);
            }
            if (styleName != null) {
                element.addClassName(styleName);
            }
            element.setPropertyString(CUSTOM_STYLE_PROPERTY_NAME, styleName);
        }

    }


    public void editRow(int rowIndex) {
        editor.editRow(rowIndex);
    }


    public boolean isEditorActive() {
        return editor.getState() != State.INACTIVE;
    }


    public void saveEditor() {
        editor.save();
    }


    public void cancelEditor() {
        editor.cancel();
    }


    public EditorHandler<T> getEditorHandler() {
        return editor.getHandler();
    }


    public void setEditorHandler(EditorHandler<T> handler) {
        editor.setHandler(handler);
    }


    public boolean isEditorEnabled() {
        return editor.isEnabled();
    }


    public void setEditorEnabled(boolean enabled) {
        editor.setEnabled(enabled);
    }


    public Widget getEditorWidget(Column<?, T> column) {
        return editor.getWidget(column);
    }


    public void setEditorSaveCaption(String saveCaption)
            throws IllegalArgumentException {
        editor.setSaveCaption(saveCaption);
    }


    public String getEditorSaveCaption() {
        return editor.getSaveCaption();
    }


    public void setEditorCancelCaption(String cancelCaption)
            throws IllegalArgumentException {
        editor.setCancelCaption(cancelCaption);
    }


    public String getEditorCancelCaption() {
        return editor.getCancelCaption();
    }

    @Override
    protected void onAttach() {
        super.onAttach();

        if (getEscalator().getBody().getRowCount() == 0 && dataSource != null) {
            setEscalatorSizeFromDataSource();
        }
    }

    @Override
    protected void onDetach() {
        Set<Integer> details = new HashSet<Integer>(visibleDetails);
        for (int row : details) {
            setDetailsVisible(row, false);
        }

        super.onDetach();
    }

    @Override
    public void onResize() {
        super.onResize();

        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                if (escalator.getInnerWidth() != autoColumnWidthsRecalculator.lastCalculatedInnerWidth) {
                    recalculateColumnWidths();
                }
            }
        });
    }


    @Override
    @Deprecated
    public void add(Widget w) {
        throw new UnsupportedOperationException(
                "Cannot add widgets to Grid with this method");
    }


    @Override
    @Deprecated
    public void clear() {
        throw new UnsupportedOperationException(
                "Cannot clear widgets from Grid this way");
    }


    @Override
    @Deprecated
    public Iterator<Widget> iterator() {
        throw new UnsupportedOperationException(
                "Cannot iterate through widgets in Grid this way");
    }


    @Override
    @Deprecated
    public boolean remove(Widget w) {

        return false;
    }


    private static native final void setParent(Widget widget, Grid<?> parent)
;

    private static native final void onAttach(Widget widget)
;

    private static native final void onDetach(Widget widget)
;

    @Override
    protected void doAttachChildren() {
        if (getSidebar().getParent() == this) {
            onAttach(getSidebar());
        }
    }

    @Override
    protected void doDetachChildren() {
        if (getSidebar().getParent() == this) {
            onDetach(getSidebar());
        }
    }


    public void resetSizesFromDom() {
        getEscalator().resetSizesFromDom();
    }


    public void setDetailsGenerator(DetailsGenerator detailsGenerator)
            throws IllegalArgumentException {

        if (detailsGenerator == null) {
            throw new IllegalArgumentException(
                    "Details generator may not be null");
        }

        this.detailsGenerator = detailsGenerator;


        escalator.getBody().setSpacerUpdater(gridSpacerUpdater);
    }


    public DetailsGenerator getDetailsGenerator() {
        return detailsGenerator;
    }


    public void setDetailsVisible(int rowIndex, boolean visible) {
        Integer rowIndexInteger = Integer.valueOf(rowIndex);



        boolean isVisible = isDetailsVisible(rowIndex);
        if (visible && !isVisible) {
            escalator.getBody().setSpacer(rowIndex, DETAILS_ROW_INITIAL_HEIGHT);
            visibleDetails.add(rowIndexInteger);
        }

        else if (!visible && isVisible) {
            escalator.getBody().setSpacer(rowIndex, -1);
            visibleDetails.remove(rowIndexInteger);
        }
    }


    public boolean isDetailsVisible(int rowIndex) {
        return visibleDetails.contains(Integer.valueOf(rowIndex));
    }


    public void recalculateColumnWidths() {
        autoColumnWidthsRecalculator.schedule();
    }


    private Sidebar getSidebar() {
        return sidebar;
    }


    public MenuBar getSidebarMenu() {
        return sidebar.menuBar;
    }


    public boolean isSidebarOpen() {
        return sidebar.isOpen();
    }


    public void setSidebarOpen(boolean sidebarOpen) {
        if (sidebarOpen) {
            sidebar.open();
        } else {
            sidebar.close();
        }
    }


    public EventCellReference<T> getEventCell() {
        return eventCell;
    }
}
