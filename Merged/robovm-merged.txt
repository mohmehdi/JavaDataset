
package org.robovm.compiler.config;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Reader;
import java.io.Writer;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.ServiceLoader;
import java.util.TreeMap;
import java.util.jar.Attributes;
import java.util.jar.JarFile;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.robovm.compiler.DependencyGraph;
import org.robovm.compiler.ITable;
import org.robovm.compiler.MarshalerLookup;
import org.robovm.compiler.VTable;
import org.robovm.compiler.Version;
import org.robovm.compiler.clazz.Clazz;
import org.robovm.compiler.clazz.Clazzes;
import org.robovm.compiler.clazz.Path;
import org.robovm.compiler.config.OS.Family;
import org.robovm.compiler.config.tools.Tools;
import org.robovm.compiler.llvm.DataLayout;
import org.robovm.compiler.log.Logger;
import org.robovm.compiler.plugin.CompilerPlugin;
import org.robovm.compiler.plugin.LaunchPlugin;
import org.robovm.compiler.plugin.Plugin;
import org.robovm.compiler.plugin.PluginArgument;
import org.robovm.compiler.plugin.TargetPlugin;
import org.robovm.compiler.plugin.annotation.AnnotationImplPlugin;
import org.robovm.compiler.plugin.lambda.LambdaPlugin;
import org.robovm.compiler.plugin.objc.InterfaceBuilderClassesPlugin;
import org.robovm.compiler.plugin.objc.ObjCBlockPlugin;
import org.robovm.compiler.plugin.objc.ObjCMemberPlugin;
import org.robovm.compiler.plugin.objc.ObjCProtocolProxyPlugin;
import org.robovm.compiler.target.ConsoleTarget;
import org.robovm.compiler.target.Target;
import org.robovm.compiler.target.ios.IOSTarget;
import org.robovm.compiler.target.ios.InfoPList;
import org.robovm.compiler.target.ios.ProvisioningProfile;
import org.robovm.compiler.target.ios.SigningIdentity;
import org.robovm.compiler.util.DigestUtil;
import org.robovm.compiler.util.io.RamDiskTools;
import org.simpleframework.xml.Element;
import org.simpleframework.xml.ElementList;
import org.simpleframework.xml.Root;
import org.simpleframework.xml.Serializer;
import org.simpleframework.xml.convert.Converter;
import org.simpleframework.xml.convert.Registry;
import org.simpleframework.xml.convert.RegistryStrategy;
import org.simpleframework.xml.core.Persister;
import org.simpleframework.xml.filter.PlatformFilter;
import org.simpleframework.xml.stream.Format;
import org.simpleframework.xml.stream.InputNode;
import org.simpleframework.xml.stream.OutputNode;


@Root
public class Config {

    
    private static final int MAX_FILE_NAME_LENGTH = 255;

    public enum Cacerts {
        full
    };

    public enum TreeShakerMode {
        none, conservative, aggressive
    };

    @Element(required = false)
    private File installDir = null;
    @Element(required = false)
    private String executableName = null;
    @Element(required = false)
    private String imageName = null;
    @Element(required = false)
    private Boolean useDynamicJni = null;
    @Element(required = false)
    private Boolean skipRuntimeLib = null;
    @Element(required = false)
    private File mainJar;
    @Element(required = false)
    private String mainClass;
    @Element(required = false)
    private Cacerts cacerts = null;
    @Element(required = false)
    private OS os = null;
    @Element(required = false)
    private Arch arch = null;
    @ElementList(required = false, entry = "root")
    private ArrayList<String> roots;
    @ElementList(required = false, entry = "pattern")
    private ArrayList<String> forceLinkClasses;
    @ElementList(required = false, entry = "lib")
    private ArrayList<Lib> libs;
    @ElementList(required = false, entry = "symbol")
    private ArrayList<String> exportedSymbols;
    @ElementList(required = false, entry = "symbol")
    private ArrayList<String> unhideSymbols;
    @ElementList(required = false, entry = "framework")
    private ArrayList<String> frameworks;
    @ElementList(required = false, entry = "framework")
    private ArrayList<String> weakFrameworks;
    @ElementList(required = false, entry = "path")
    private ArrayList<File> frameworkPaths;
    @ElementList(required = false, entry = "resource")
    private ArrayList<Resource> resources;
    @ElementList(required = false, entry = "classpathentry")
    private ArrayList<File> bootclasspath;
    @ElementList(required = false, entry = "classpathentry")
    private ArrayList<File> classpath;
    @ElementList(required = false, entry = "argument")
    private ArrayList<String> pluginArguments;
    @Element(required = false, name = "target")
    private String targetType;
    @Element(required = false, name = "treeShaker")
    private TreeShakerMode treeShakerMode;

    @Element(required = false)
    private String iosSdkVersion;
    @Element(required = false, name = "iosInfoPList")
    private File iosInfoPListFile = null;
    @Element(required = false)
    private File iosResourceRulesPList;
    @Element(required = false)
    private File iosEntitlementsPList;

    @Element(required = false)
    private Tools tools;

    private SigningIdentity iosSignIdentity;
    private ProvisioningProfile iosProvisioningProfile;
    private String iosDeviceType;
    private InfoPList iosInfoPList;

    private boolean iosSkipSigning = false;

    private Properties properties = new Properties();

    private Home home = null;
    private File tmpDir;
    private File cacheDir = new File(System.getProperty("user.home"), ".robovm/cache");
    private File ccBinPath = null;

    private boolean clean = false;
    private boolean debug = false;
    private boolean useDebugLibs = false;
    private boolean skipLinking = false;
    private boolean skipInstall = false;
    private boolean dumpIntermediates = false;
    private int threads = Runtime.getRuntime().availableProcessors();
    private Logger logger = Logger.NULL_LOGGER;

    

    private transient List<Plugin> plugins = new ArrayList<>();
    private transient Target target = null;
    private transient File osArchDepLibDir;
    private transient File osArchCacheDir;
    private transient Clazzes clazzes;
    private transient VTable.Cache vtableCache;
    private transient ITable.Cache itableCache;
    private transient List<Path> resourcesPaths = new ArrayList<Path>();
    private transient DataLayout dataLayout;
    private transient MarshalerLookup marshalerLookup;
    private transient Config configBeforeBuild;
    private transient DependencyGraph dependencyGraph;

    protected Config() throws IOException {
        
        this.plugins.addAll(0, Arrays.asList(
                new InterfaceBuilderClassesPlugin(),
                new ObjCProtocolProxyPlugin(),
                new ObjCMemberPlugin(),
                new ObjCBlockPlugin(),
                new AnnotationImplPlugin(),
                new LambdaPlugin()
                ));
        this.loadPluginsFromClassPath();
    }

    
    public Builder builder() throws IOException {
        return new Builder(clone(configBeforeBuild));
    }

    public Home getHome() {
        return home;
    }

    public File getInstallDir() {
        return installDir;
    }

    public String getExecutableName() {
        return executableName;
    }

    public String getImageName() {
        return imageName;
    }

    public File getExecutablePath() {
        return new File(installDir, getExecutableName());
    }

    public File getImagePath() {
        return getExecutablePath();
    }

    public File getCacheDir() {
        return osArchCacheDir;
    }

    public File getCcBinPath() {
        return ccBinPath;
    }

    public OS getOs() {
        return os;
    }

    public Arch getArch() {
        return arch;
    }

    public String getTriple() {
        return arch.getLlvmName() + "-unknown-" + os.getLlvmName();
    }

    public String getClangTriple() {
        return arch.getClangName() + "-unknown-" + os.getLlvmName();
    }

    public DataLayout getDataLayout() {
        return dataLayout;
    }

    public boolean isClean() {
        return clean;
    }

    public boolean isDebug() {
        return debug;
    }

    public boolean isUseDebugLibs() {
        return useDebugLibs;
    }

    public boolean isDumpIntermediates() {
        return dumpIntermediates;
    }

    public boolean isSkipRuntimeLib() {
        return skipRuntimeLib != null && skipRuntimeLib.booleanValue();
    }

    public boolean isSkipLinking() {
        return skipLinking;
    }

    public boolean isSkipInstall() {
        return skipInstall;
    }

    public boolean isUseDynamicJni() {
        return useDynamicJni != null && useDynamicJni.booleanValue();
    }

    public int getThreads() {
        return threads;
    }

    public File getMainJar() {
        return mainJar;
    }

    public String getMainClass() {
        return mainClass;
    }

    public Cacerts getCacerts() {
        return cacerts == null ? Cacerts.full : cacerts;
    }

    public List<Path> getResourcesPaths() {
        return resourcesPaths;
    }

    public void addResourcesPath(Path path) {
        resourcesPaths.add(path);
    }

    public DependencyGraph getDependencyGraph() {
        return dependencyGraph;
    }
    
    public File getTmpDir() {
        if (tmpDir == null) {
            try {
                tmpDir = File.createTempFile("robovm", ".tmp");
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
            tmpDir.delete();
            tmpDir.mkdirs();
        }
        return tmpDir;
    }

    public List<String> getForceLinkClasses() {
        return forceLinkClasses == null ? Collections.<String> emptyList()
                : Collections.unmodifiableList(forceLinkClasses);
    }

    public List<String> getExportedSymbols() {
        return exportedSymbols == null ? Collections.<String> emptyList()
                : Collections.unmodifiableList(exportedSymbols);
    }

    public List<String> getUnhideSymbols() {
        return unhideSymbols == null ? Collections.<String> emptyList()
                : Collections.unmodifiableList(unhideSymbols);
    }
    
    public List<Lib> getLibs() {
        return libs == null ? Collections.<Lib> emptyList()
                : Collections.unmodifiableList(libs);
    }

    public List<String> getFrameworks() {
        return frameworks == null ? Collections.<String> emptyList()
                : Collections.unmodifiableList(frameworks);
    }

    public List<String> getWeakFrameworks() {
        return weakFrameworks == null ? Collections.<String> emptyList()
                : Collections.unmodifiableList(weakFrameworks);
    }

    public List<File> getFrameworkPaths() {
        return frameworkPaths == null ? Collections.<File> emptyList()
                : Collections.unmodifiableList(frameworkPaths);
    }

    public List<Resource> getResources() {
        return resources == null ? Collections.<Resource> emptyList()
                : Collections.unmodifiableList(resources);
    }

    public File getOsArchDepLibDir() {
        return osArchDepLibDir;
    }

    public Clazzes getClazzes() {
        return clazzes;
    }

    public VTable.Cache getVTableCache() {
        return vtableCache;
    }

    public ITable.Cache getITableCache() {
        return itableCache;
    }

    public MarshalerLookup getMarshalerLookup() {
        return marshalerLookup;
    }

    public List<CompilerPlugin> getCompilerPlugins() {
        List<CompilerPlugin> compilerPlugins = new ArrayList<>();
        for (Plugin plugin : plugins) {
            if (plugin instanceof CompilerPlugin) {
                compilerPlugins.add((CompilerPlugin) plugin);
            }
        }
        return compilerPlugins;
    }

    public List<LaunchPlugin> getLaunchPlugins() {
        List<LaunchPlugin> launchPlugins = new ArrayList<>();
        for (Plugin plugin : plugins) {
            if (plugin instanceof LaunchPlugin) {
                launchPlugins.add((LaunchPlugin) plugin);
            }
        }
        return launchPlugins;
    }

    public List<TargetPlugin> getTargetPlugins() {
        List<TargetPlugin> targetPlugins = new ArrayList<>();
        for (Plugin plugin : plugins) {
            if (plugin instanceof TargetPlugin) {
                targetPlugins.add((TargetPlugin) plugin);
            }
        }
        return targetPlugins;
    }

    public List<Plugin> getPlugins() {
        return plugins;
    }

    public List<String> getPluginArguments() {
        return pluginArguments == null ? Collections.<String> emptyList()
                : Collections.unmodifiableList(pluginArguments);
    }

    public List<File> getBootclasspath() {
        return bootclasspath == null ? Collections.<File> emptyList()
                : Collections.unmodifiableList(bootclasspath);
    }

    public List<File> getClasspath() {
        return classpath == null ? Collections.<File> emptyList()
                : Collections.unmodifiableList(classpath);
    }

    public Properties getProperties() {
        return properties;
    }

    public Logger getLogger() {
        return logger;
    }

    public Target getTarget() {
        return target;
    }

    public String getTargetType() {
        return targetType;
    }

    public TreeShakerMode getTreeShakerMode() {
        return treeShakerMode == null ? TreeShakerMode.none : treeShakerMode;
    }

    public String getIosSdkVersion() {
        return iosSdkVersion;
    }

    public String getIosDeviceType() {
        return iosDeviceType;
    }

    public InfoPList getIosInfoPList() {
        if (iosInfoPList == null && iosInfoPListFile != null) {
            iosInfoPList = new InfoPList(iosInfoPListFile);
        }
        return iosInfoPList;
    }

    public File getIosResourceRulesPList() {
        return iosResourceRulesPList;
    }

    public File getIosEntitlementsPList() {
        return iosEntitlementsPList;
    }

    public SigningIdentity getIosSignIdentity() {
        return iosSignIdentity;
    }

    public ProvisioningProfile getIosProvisioningProfile() {
        return iosProvisioningProfile;
    }

    public boolean isIosSkipSigning() {
        return iosSkipSigning;
    }

    public Tools getTools() {
        return tools;
    }

    private static File makeFileRelativeTo(File dir, File f) {
        if (f.getParentFile() == null) {
            return dir;
        }
        return new File(makeFileRelativeTo(dir, f.getParentFile()), f.getName());
    }

    public String getArchiveName(Path path) {
        if (path.getFile().isFile()) {
            return path.getFile().getName();
        } else {
            return "classes" + path.getIndex() + ".jar";
        }
    }

    static String getFileName(Clazz clazz, String ext) {
        return getFileName(clazz.getInternalName(), ext, MAX_FILE_NAME_LENGTH);
    }

    static String getFileName(String internalName, String ext, int maxFileNameLength) {
        String packagePath = internalName.substring(0, internalName.lastIndexOf('/') + 1);
        String className = internalName.substring(internalName.lastIndexOf('/') + 1);
        String suffix = ext.startsWith(".") ? ext : "." + ext;

        int length = className.length() + suffix.length();
        if (length > maxFileNameLength) {
            String sha1 = DigestUtil.sha1(className);
            className = className.substring(0, Math.max(0, maxFileNameLength - suffix.length() - sha1.length())) + sha1;
        }
        return packagePath.replace('/', File.separatorChar) + className + suffix;
    }

    public File getLlFile(Clazz clazz) {
        return new File(getCacheDir(clazz.getPath()), getFileName(clazz, "class.ll"));
    }

    public File getCFile(Clazz clazz) {
        return new File(getCacheDir(clazz.getPath()), getFileName(clazz, "class.c"));
    }

    public File getBcFile(Clazz clazz) {
        return new File(getCacheDir(clazz.getPath()), getFileName(clazz, "class.bc"));
    }

    public File getSFile(Clazz clazz) {
        return new File(getCacheDir(clazz.getPath()), getFileName(clazz, "class.s"));
    }

    public File getOFile(Clazz clazz) {
        return new File(getCacheDir(clazz.getPath()), getFileName(clazz, "class.o"));
    }

    public File getLinesOFile(Clazz clazz) {
        return new File(getCacheDir(clazz.getPath()), getFileName(clazz, "class.lines.o"));
    }

    public File getLinesLlFile(Clazz clazz) {
        return new File(getCacheDir(clazz.getPath()), getFileName(clazz, "class.lines.ll"));
    }

    public File getInfoFile(Clazz clazz) {
        return new File(getCacheDir(clazz.getPath()), getFileName(clazz, "class.info"));
    }

    public File getCacheDir(Path path) {
        File srcRoot = path.getFile().getParentFile();
        String name = path.getFile().getName();
        try {
            return new File(makeFileRelativeTo(osArchCacheDir, srcRoot.getCanonicalFile()), name);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    
    public File getGeneratedClassDir(Path path) {
        File pathCacheDir = getCacheDir(path);
        return new File(pathCacheDir.getParentFile(), pathCacheDir.getName() + ".generated");
    }

    private static Map<Object, Object> getManifestAttributes(File jarFile) throws IOException {
        JarFile jf = null;
        try {
            jf = new JarFile(jarFile);
            return new HashMap<Object, Object>(jf.getManifest().getMainAttributes());
        } finally {
            jf.close();
        }
    }

    private static String getImplementationVersion(File jarFile) throws IOException {
        return (String) getManifestAttributes(jarFile).get(Attributes.Name.IMPLEMENTATION_VERSION);
    }

    private static String getMainClass(File jarFile) throws IOException {
        return (String) getManifestAttributes(jarFile).get(Attributes.Name.MAIN_CLASS);
    }

    private File extractIfNeeded(Path path) throws IOException {
        if (path.getFile().isFile()) {
            File pathCacheDir = getCacheDir(path);
            File target = new File(pathCacheDir.getParentFile(), pathCacheDir.getName() + ".extracted");

            if (!target.exists() || path.getFile().lastModified() > target.lastModified()) {
                FileUtils.deleteDirectory(target);
                target.mkdirs();
                try (ZipFile zipFile = new ZipFile(path.getFile())) {
                    Enumeration<? extends ZipEntry> entries = zipFile.entries();
                    while (entries.hasMoreElements()) {
                        ZipEntry entry = entries.nextElement();
                        if (entry.getName().startsWith("META-INF/robovm/") && !entry.isDirectory()) {
                            File f = new File(target, entry.getName());
                            f.getParentFile().mkdirs();
                            try (InputStream in = zipFile.getInputStream(entry);
                                 OutputStream out = new FileOutputStream(f)) {

                                IOUtils.copy(in, out);
                                if (entry.getTime() != -1) {
                                    f.setLastModified(entry.getTime());
                                }
                            }
                        }
                    }
                }
                target.setLastModified(path.getFile().lastModified());
            }

            return target;
        } else {
            return path.getFile();
        }
    }

    private <T> ArrayList<T> mergeLists(ArrayList<T> from, ArrayList<T> to) {
        if (from == null) {
            return to;
        }
        to = to != null ? to : new ArrayList<T>();
        for (T o : from) {
            if (!to.contains(o)) {
                to.add(o);
            }
        }
        return to;
    }

    private void mergeConfig(Config from, Config to) {
        to.exportedSymbols = mergeLists(from.exportedSymbols, to.exportedSymbols);
        to.unhideSymbols = mergeLists(from.unhideSymbols, to.unhideSymbols);
        to.forceLinkClasses = mergeLists(from.forceLinkClasses, to.forceLinkClasses);
        to.frameworkPaths = mergeLists(from.frameworkPaths, to.frameworkPaths);
        to.frameworks = mergeLists(from.frameworks, to.frameworks);
        to.libs = mergeLists(from.libs, to.libs);
        to.resources = mergeLists(from.resources, to.resources);
        to.weakFrameworks = mergeLists(from.weakFrameworks, to.weakFrameworks);
    }

    private void mergeConfigsFromClasspath() throws IOException {
        List<String> dirs = Arrays.asList(
                "META-INF/robovm/" + os + "/" + arch,
                "META-INF/robovm/" + os);

        
        

        
        Config config = new Config();
        for (Path path : clazzes.getPaths()) {
            for (String dir : dirs) {
                if (path.contains(dir + "/robovm.xml")) {
                    File configXml = new File(new File(extractIfNeeded(path), dir), "robovm.xml");
                    Builder builder = new Builder();
                    builder.read(configXml);
                    mergeConfig(builder.config, config);
                    break;
                }
            }
        }

        
        mergeConfig(this, config);

        
        this.exportedSymbols = config.exportedSymbols;
        this.unhideSymbols = config.unhideSymbols;
        this.forceLinkClasses = config.forceLinkClasses;
        this.frameworkPaths = config.frameworkPaths;
        this.frameworks = config.frameworks;
        this.libs = config.libs;
        this.resources = config.resources;
        this.weakFrameworks = config.weakFrameworks;
    }

    private static <T> List<T> toList(Iterator<T> it) {
        List<T> l = new ArrayList<T>();
        while (it.hasNext()) {
            l.add(it.next());
        }
        return l;
    }

    private void loadPluginsFromClassPath() throws IOException {
        ClassLoader classLoader = getClass().getClassLoader();
        ServiceLoader<CompilerPlugin> compilerPluginLoader = ServiceLoader.load(CompilerPlugin.class, classLoader);
        ServiceLoader<LaunchPlugin> launchPluginLoader = ServiceLoader.load(LaunchPlugin.class, classLoader);
        ServiceLoader<TargetPlugin> targetPluginLoader = ServiceLoader.load(TargetPlugin.class, classLoader);

        plugins.addAll(toList(compilerPluginLoader.iterator()));
        plugins.addAll(toList(launchPluginLoader.iterator()));
        plugins.addAll(toList(targetPluginLoader.iterator()));
    }

    private static Config clone(Config config) throws IOException {
        Config clone = new Config();
        for (Field f : Config.class.getDeclaredFields()) {
            if (!Modifier.isStatic(f.getModifiers()) && !Modifier.isTransient(f.getModifiers())) {
                f.setAccessible(true);
                try {
                    Object o = f.get(config);
                    if (o instanceof Collection && o instanceof Cloneable) {
                        
                        
                        Method m = o.getClass().getMethod("clone");
                        o = m.invoke(o);
                    }
                    f.set(clone, o);
                } catch (Throwable t) {
                    throw new Error(t);
                }
            }
        }
        return clone;
    }

    private Config build() throws IOException {
        
        
        this.configBeforeBuild = clone(this);

        if (home == null) {
            home = Home.find();
        }

        if (bootclasspath == null) {
            bootclasspath = new ArrayList<File>();
        }
        if (classpath == null) {
            classpath = new ArrayList<File>();
        }

        if (mainJar != null) {
            mainClass = getMainClass(mainJar);
            classpath.add(mainJar);
        }

        if (executableName == null && imageName != null) {
            executableName = imageName;
        }

        if (!skipLinking && executableName == null && mainClass == null) {
            throw new IllegalArgumentException("No target and no main class specified");
        }

        if (!skipLinking && classpath.isEmpty()) {
            throw new IllegalArgumentException("No classpath specified");
        }

        if (skipLinking) {
            skipInstall = true;
        }

        if (executableName == null) {
            executableName = mainClass;
        }

        if (imageName == null || !imageName.equals(executableName)) {
            imageName = executableName;
        }

        List<File> realBootclasspath = bootclasspath == null ? new ArrayList<File>() : bootclasspath;
        if (!isSkipRuntimeLib()) {
            realBootclasspath = new ArrayList<File>(bootclasspath);
            realBootclasspath.add(0, home.rtPath);
        }

        this.vtableCache = new VTable.Cache();
        this.itableCache = new ITable.Cache();
        this.marshalerLookup = new MarshalerLookup(this);

        if (!skipInstall) {
            if (installDir == null) {
                installDir = new File(".", executableName);
            }
            installDir.mkdirs();
        }

        if (targetType != null) {
            if (ConsoleTarget.TYPE.equals(targetType)) {
                target = new ConsoleTarget();
            } else if (IOSTarget.TYPE.equals(targetType)) {
                target = new IOSTarget();
            } else {
                for (TargetPlugin plugin : getTargetPlugins()) {
                    if (plugin.getTarget().getType().equals(targetType)) {
                        target = plugin.getTarget();
                        break;
                    }
                }
                if (target == null) {
                    throw new IllegalArgumentException("Unsupported target '" + targetType + "'");
                }
            }
        } else {
            
            if (os == OS.ios) {
                target = new IOSTarget();
            } else {
                target = new ConsoleTarget();
            }
        }
        target.init(this);

        os = target.getOs();
        arch = target.getArch();
        dataLayout = new DataLayout(getTriple());

        osArchDepLibDir = new File(new File(home.libVmDir, os.toString()),
                arch.toString());

        if (treeShakerMode != null && treeShakerMode != TreeShakerMode.none 
                && os.getFamily() == Family.darwin && arch == Arch.x86) {

            logger.warn("Tree shaking is not supported when building "
                    + "for OS X/iOS x86 32-bit due to a bug in Xcode's linker. No tree "
                    + "shaking will be performed. Run in 64-bit mode instead to "
                    + "use tree shaking.");
            treeShakerMode = TreeShakerMode.none;
        }
        dependencyGraph = new DependencyGraph(getTreeShakerMode());

        RamDiskTools ramDiskTools = new RamDiskTools();
        ramDiskTools.setupRamDisk(this, this.cacheDir, this.tmpDir);
        this.cacheDir = ramDiskTools.getCacheDir();
        this.tmpDir = ramDiskTools.getTmpDir();

        File osDir = new File(cacheDir, os.toString());
        File archDir = new File(osDir, arch.toString());
        osArchCacheDir = new File(archDir, debug ? "debug" : "release");
        osArchCacheDir.mkdirs();

        this.clazzes = new Clazzes(this, realBootclasspath, classpath);

        mergeConfigsFromClasspath();

        return this;
    }

    public static class Home {
        private File binDir = null;
        private File libVmDir = null;
        private File rtPath = null;
        private Map<Cacerts, File> cacertsPath = null;
        private boolean dev = false;

        public Home(File homeDir) {
            this(homeDir, true);
        }

        protected Home(File homeDir, boolean validate) {
            if (validate) {
                validate(homeDir);
            }
            binDir = new File(homeDir, "bin");
            libVmDir = new File(homeDir, "lib/vm");
            rtPath = new File(homeDir, "lib/robovm-rt.jar");
            cacertsPath = new HashMap<Cacerts, File>();
            cacertsPath.put(Cacerts.full, new File(homeDir, "lib/robovm-cacerts-full.jar"));
        }

        private Home(File devDir, File binDir, File libVmDir, File rtPath) {
            this.binDir = binDir;
            this.libVmDir = libVmDir;
            this.rtPath = rtPath;
            cacertsPath = new HashMap<Cacerts, File>();
            cacertsPath.put(Cacerts.full, new File(devDir,
                    "cacerts/full/target/robovm-cacerts-full-" + Version.getVersion() + ".jar"));
            this.dev = true;
        }

        public boolean isDev() {
            return dev;
        }

        public File getBinDir() {
            return binDir;
        }

        public File getLibVmDir() {
            return libVmDir;
        }

        public File getRtPath() {
            return rtPath;
        }

        public File getCacertsPath(Cacerts cacerts) {
            return cacertsPath.get(cacerts);
        }

        public static Home find() {
            
            
            if (System.getenv("ROBOVM_DEV_ROOT") != null) {
                File dir = new File(System.getenv("ROBOVM_DEV_ROOT"));
                return validateDevRootDir(dir);
            }
            if (System.getProperty("ROBOVM_DEV_ROOT") != null) {
                File dir = new File(System.getProperty("ROBOVM_DEV_ROOT"));
                return validateDevRootDir(dir);
            }

            if (System.getenv("ROBOVM_HOME") != null) {
                File dir = new File(System.getenv("ROBOVM_HOME"));
                return new Home(dir);
            }

            List<File> candidates = new ArrayList<File>();
            File userHome = new File(System.getProperty("user.home"));
            candidates.add(new File(userHome, "Applications/robovm"));
            candidates.add(new File(userHome, ".robovm/home"));
            candidates.add(new File("/usr/local/lib/robovm"));
            candidates.add(new File("/opt/robovm"));
            candidates.add(new File("/usr/lib/robovm"));

            for (File dir : candidates) {
                if (dir.exists()) {
                    return new Home(dir);
                }
            }

            throw new IllegalArgumentException("ROBOVM_HOME not set and no RoboVM "
                    + "installation found in " + candidates);
        }

        public static void validate(File dir) {
            String error = "Path " + dir + " is not a valid RoboVM install directory: ";
            
            
            if (!dir.exists()) {
                throw new IllegalArgumentException(error + "no such path");
            }

            if (!dir.isDirectory()) {
                throw new IllegalArgumentException(error + "not a directory");
            }

            File libDir = new File(dir, "lib");
            if (!libDir.exists() || !libDir.isDirectory()) {
                throw new IllegalArgumentException(error + "lib/ missing or invalid");
            }
            File binDir = new File(dir, "bin");
            if (!binDir.exists() || !binDir.isDirectory()) {
                throw new IllegalArgumentException(error + "bin/ missing or invalid");
            }
            File libVmDir = new File(libDir, "vm");
            if (!libVmDir.exists() || !libVmDir.isDirectory()) {
                throw new IllegalArgumentException(error + "lib/vm/ missing or invalid");
            }
            File rtJarFile = new File(libDir, "robovm-rt.jar");
            if (!rtJarFile.exists() || !rtJarFile.isFile()) {
                throw new IllegalArgumentException(error
                        + "lib/robovm-rt.jar missing or invalid");
            }

            
            
            try {
                String thisVersion = Version.getVersion();
                String thatVersion = getImplementationVersion(rtJarFile);
                if (thisVersion == null || thatVersion == null || !thisVersion.equals(thatVersion)) {
                    throw new IllegalArgumentException(error + "version mismatch (expected: "
                            + thisVersion + ", was: " + thatVersion + ")");
                }
            } catch (IOException e) {
                throw new IllegalArgumentException(error
                        + "failed to get version of rt jar", e);
            }
        }

        private static Home validateDevRootDir(File dir) {
            String error = "Path " + dir + " is not a valid RoboVM source tree: ";
            
            if (!dir.exists()) {
                throw new IllegalArgumentException(error + "no such path");
            }

            if (!dir.isDirectory()) {
                throw new IllegalArgumentException(error + "not a directory");
            }

            File vmBinariesDir = new File(dir, "vm/target/binaries");
            if (!vmBinariesDir.exists() || !vmBinariesDir.isDirectory()) {
                throw new IllegalArgumentException(error + "vm/target/binaries/ missing or invalid");
            }
            File binDir = new File(dir, "bin");
            if (!binDir.exists() || !binDir.isDirectory()) {
                throw new IllegalArgumentException(error + "bin/ missing or invalid");
            }

            String rtJarName = "robovm-rt-" + Version.getVersion() + ".jar";
            File rtJar = new File(dir, "rt/target/" + rtJarName);
            File rtClasses = new File(dir, "rt/target/classes/");
            File rtSource = rtJar;
            if (!rtJar.exists() || rtJar.isDirectory()) {
                if (!rtClasses.exists() || rtClasses.isFile()) {
                    throw new IllegalArgumentException(error
                            + "rt/target/" + rtJarName + " missing or invalid");
                } else {
                    rtSource = rtClasses;
                }
            }

            return new Home(dir, binDir, vmBinariesDir, rtSource);
        }
    }

    public static class Builder {
        final Config config;

        Builder(Config config) {
            this.config = config;
        }

        public Builder() throws IOException {
            this.config = new Config();
        }

        public Builder os(OS os) {
            config.os = os;
            return this;
        }

        public Builder arch(Arch arch) {
            config.arch = arch;
            return this;
        }

        public Builder clearClasspathEntries() {
            if (config.classpath != null) {
                config.classpath.clear();
            }
            return this;
        }

        public Builder addClasspathEntry(File f) {
            if (config.classpath == null) {
                config.classpath = new ArrayList<File>();
            }
            config.classpath.add(f);
            return this;
        }

        public Builder clearBootClasspathEntries() {
            if (config.bootclasspath != null) {
                config.bootclasspath.clear();
            }
            return this;
        }

        public Builder addBootClasspathEntry(File f) {
            if (config.bootclasspath == null) {
                config.bootclasspath = new ArrayList<File>();
            }
            config.bootclasspath.add(f);
            return this;
        }

        public Builder mainJar(File f) {
            config.mainJar = f;
            return this;
        }

        public Builder installDir(File installDir) {
            config.installDir = installDir;
            return this;
        }

        public Builder executableName(String executableName) {
            config.executableName = executableName;
            return this;
        }

        public Builder imageName(String imageName) {
            config.imageName = imageName;
            return this;
        }

        public Builder home(Home home) {
            config.home = home;
            return this;
        }

        public Builder cacheDir(File cacheDir) {
            config.cacheDir = cacheDir;
            return this;
        }

        public Builder clean(boolean b) {
            config.clean = b;
            return this;
        }

        public Builder ccBinPath(File ccBinPath) {
            config.ccBinPath = ccBinPath;
            return this;
        }

        public Builder debug(boolean b) {
            config.debug = b;
            return this;
        }

        public Builder useDebugLibs(boolean b) {
            config.useDebugLibs = b;
            return this;
        }

        public Builder dumpIntermediates(boolean b) {
            config.dumpIntermediates = b;
            return this;
        }

        public Builder skipRuntimeLib(boolean b) {
            config.skipRuntimeLib = b;
            return this;
        }

        public Builder skipLinking(boolean b) {
            config.skipLinking = b;
            return this;
        }

        public Builder skipInstall(boolean b) {
            config.skipInstall = b;
            return this;
        }

        public Builder useDynamicJni(boolean b) {
            config.useDynamicJni = b;
            return this;
        }

        public Builder threads(int threads) {
            config.threads = threads;
            return this;
        }

        public Builder mainClass(String mainClass) {
            config.mainClass = mainClass;
            return this;
        }

        public Builder tmpDir(File tmpDir) {
            config.tmpDir = tmpDir;
            return this;
        }

        public Builder logger(Logger logger) {
            config.logger = logger;
            return this;
        }

        public Builder treeShakerMode(TreeShakerMode treeShakerMode) {
            config.treeShakerMode = treeShakerMode;
            return this;
        }

        public Builder clearForceLinkClasses() {
            if (config.forceLinkClasses != null) {
                config.forceLinkClasses.clear();
            }
            return this;
        }

        public Builder addForceLinkClass(String pattern) {
            if (config.forceLinkClasses == null) {
                config.forceLinkClasses = new ArrayList<String>();
            }
            config.forceLinkClasses.add(pattern);
            return this;
        }

        public Builder clearExportedSymbols() {
            if (config.exportedSymbols != null) {
                config.exportedSymbols.clear();
            }
            return this;
        }

        public Builder addExportedSymbol(String symbol) {
            if (config.exportedSymbols == null) {
                config.exportedSymbols = new ArrayList<String>();
            }
            config.exportedSymbols.add(symbol);
            return this;
        }

        public Builder clearUnhideSymbols() {
            if (config.unhideSymbols != null) {
                config.unhideSymbols.clear();
            }
            return this;
        }

        public Builder addUnhideSymbol(String symbol) {
            if (config.unhideSymbols == null) {
                config.unhideSymbols = new ArrayList<String>();
            }
            config.unhideSymbols.add(symbol);
            return this;
        }

        public Builder clearLibs() {
            if (config.libs != null) {
                config.libs.clear();
            }
            return this;
        }

        public Builder addLib(Lib lib) {
            if (config.libs == null) {
                config.libs = new ArrayList<Lib>();
            }
            config.libs.add(lib);
            return this;
        }

        public Builder clearFrameworks() {
            if (config.frameworks != null) {
                config.frameworks.clear();
            }
            return this;
        }

        public Builder addFramework(String framework) {
            if (config.frameworks == null) {
                config.frameworks = new ArrayList<String>();
            }
            config.frameworks.add(framework);
            return this;
        }

        public Builder clearWeakFrameworks() {
            if (config.weakFrameworks != null) {
                config.weakFrameworks.clear();
            }
            return this;
        }

        public Builder addWeakFramework(String framework) {
            if (config.weakFrameworks == null) {
                config.weakFrameworks = new ArrayList<String>();
            }
            config.weakFrameworks.add(framework);
            return this;
        }

        public Builder clearFrameworkPaths() {
            if (config.frameworkPaths != null) {
                config.frameworkPaths.clear();
            }
            return this;
        }

        public Builder addFrameworkPath(File frameworkPath) {
            if (config.frameworkPaths == null) {
                config.frameworkPaths = new ArrayList<File>();
            }
            config.frameworkPaths.add(frameworkPath);
            return this;
        }

        public Builder clearResources() {
            if (config.resources != null) {
                config.resources.clear();
            }
            return this;
        }

        public Builder addResource(Resource resource) {
            if (config.resources == null) {
                config.resources = new ArrayList<Resource>();
            }
            config.resources.add(resource);
            return this;
        }

        public Builder targetType(String targetType) {
            config.targetType = targetType;
            return this;
        }

        public Builder clearProperties() {
            config.properties.clear();
            return this;
        }

        public Builder addProperties(Properties properties) {
            config.properties.putAll(properties);
            return this;
        }

        public Builder addProperties(File file) throws IOException {
            Properties props = new Properties();
            Reader reader = null;
            try {
                reader = new InputStreamReader(new FileInputStream(file), "utf-8");
                props.load(reader);
                addProperties(props);
            } finally {
                IOUtils.closeQuietly(reader);
            }
            return this;
        }

        public Builder addProperty(String name, String value) {
            config.properties.put(name, value);
            return this;
        }

        public Builder cacerts(Cacerts cacerts) {
            config.cacerts = cacerts;
            return this;
        }

        public Builder tools(Tools tools) {
            config.tools = tools;
            return this;
        }

        public Builder iosSdkVersion(String sdkVersion) {
            config.iosSdkVersion = sdkVersion;
            return this;
        }

        public Builder iosDeviceType(String deviceType) {
            config.iosDeviceType = deviceType;
            return this;
        }

        public Builder iosInfoPList(File infoPList) {
            config.iosInfoPListFile = infoPList;
            return this;
        }

        public Builder iosEntitlementsPList(File entitlementsPList) {
            config.iosEntitlementsPList = entitlementsPList;
            return this;
        }

        public Builder iosResourceRulesPList(File resourceRulesPList) {
            config.iosResourceRulesPList = resourceRulesPList;
            return this;
        }

        public Builder iosSignIdentity(SigningIdentity signIdentity) {
            config.iosSignIdentity = signIdentity;
            return this;
        }

        public Builder iosProvisioningProfile(ProvisioningProfile iosProvisioningProfile) {
            config.iosProvisioningProfile = iosProvisioningProfile;
            return this;
        }

        public Builder iosSkipSigning(boolean b) {
            config.iosSkipSigning = b;
            return this;
        }

        public Builder addCompilerPlugin(CompilerPlugin compilerPlugin) {
            config.plugins.add(compilerPlugin);
            return this;
        }

        public Builder addLaunchPlugin(LaunchPlugin plugin) {
            config.plugins.add(plugin);
            return this;
        }

        public Builder addTargetPlugin(TargetPlugin plugin) {
            config.plugins.add(plugin);
            return this;
        }

        public void addPluginArgument(String argName) {
            if (config.pluginArguments == null) {
                config.pluginArguments = new ArrayList<>();
            }
            config.pluginArguments.add(argName);
        }

        public Config build() throws IOException {
            for (CompilerPlugin plugin : config.getCompilerPlugins()) {
                plugin.beforeConfig(this, config);
            }

            return config.build();
        }

        
        public void readProjectProperties(File basedir, boolean isTest) throws IOException {
            File testPropsFile = new File(basedir, "robovm.test.properties");
            File localPropsFile = new File(basedir, "robovm.local.properties");
            File propsFile = new File(basedir, "robovm.properties");
            if (isTest && testPropsFile.exists()) {
                config.logger.debug("Loading test RoboVM config properties file: "
                        + testPropsFile.getAbsolutePath());
                addProperties(testPropsFile);
            } else {
                Properties props = new Properties();
                if (propsFile.exists()) {
                    config.logger.debug("Loading default RoboVM config properties file: "
                            + propsFile.getAbsolutePath());
                    try (Reader reader = new InputStreamReader(new FileInputStream(propsFile), "utf-8")) {
                        props.load(reader);
                    }
                }
                if (localPropsFile.exists()) {
                    config.logger.debug("Loading local RoboVM config properties file: "
                            + localPropsFile.getAbsolutePath());
                    try (Reader reader = new InputStreamReader(new FileInputStream(localPropsFile), "utf-8")) {
                        props.load(reader);
                    }
                }
                if (isTest) {
                    modifyPropertyForTest(props, "app.id");
                    modifyPropertyForTest(props, "app.name");
                    modifyPropertyForTest(props, "app.executable");
                }
                addProperties(props);
            }
        }

        private void modifyPropertyForTest(Properties props, String propName) {
            String propValue = props.getProperty(propName);
            if (propValue != null && !propValue.endsWith("Test")) {
                String newPropValue = propValue + "Test";
                config.logger.debug("Changing %s property from '%s' to '%s'", propName, propValue, newPropValue);
                props.setProperty(propName, newPropValue);
            }
        }

        
        public void readProjectConfig(File basedir, boolean isTest) throws IOException {
            File testConfigFile = new File(basedir, "robovm.test.xml");
            File configFile = new File(basedir, "robovm.xml");
            if (isTest && testConfigFile.exists()) {
                config.logger.debug("Loading test RoboVM config file: "
                        + testConfigFile.getAbsolutePath());
                read(testConfigFile);
            } else if (configFile.exists()) {
                config.logger.debug("Loading default RoboVM config file: "
                        + configFile.getAbsolutePath());
                read(configFile);
            }
        }

        public void read(File file) throws IOException {
            Reader reader = null;
            try {
                reader = new InputStreamReader(new FileInputStream(file), "utf-8");
                read(reader, file.getAbsoluteFile().getParentFile());
            } finally {
                IOUtils.closeQuietly(reader);
            }
        }

        public void read(Reader reader, File wd) throws IOException {
            try {
                Serializer serializer = createSerializer(wd);
                serializer.read(config, reader);
            } catch (IOException e) {
                throw e;
            } catch (RuntimeException e) {
                throw e;
            } catch (Exception e) {
                throw (IOException) new IOException().initCause(e);
            }
            
            
            
            if (config.roots != null && !config.roots.isEmpty()) {
                if (config.forceLinkClasses == null) {
                    config.forceLinkClasses = new ArrayList<String>();
                }
                config.forceLinkClasses.addAll(config.roots);
                config.roots = null;
            }
        }

        public void write(File file) throws IOException {
            Writer writer = null;
            try {
                writer = new OutputStreamWriter(new FileOutputStream(file), "utf-8");
                write(writer, file.getAbsoluteFile().getParentFile());
            } finally {
                IOUtils.closeQuietly(writer);
            }
        }

        public void write(Writer writer, File wd) throws IOException {
            try {
                Serializer serializer = createSerializer(wd);
                serializer.write(config, writer);
            } catch (IOException e) {
                throw e;
            } catch (RuntimeException e) {
                throw e;
            } catch (Exception e) {
                throw (IOException) new IOException().initCause(e);
            }
        }

        private Serializer createSerializer(final File wd) throws Exception {
            RelativeFileConverter fileConverter = new RelativeFileConverter(wd);

            Serializer resourceSerializer = new Persister(
                    new RegistryStrategy(new Registry().bind(File.class, fileConverter)),
                    new PlatformFilter(config.properties), new Format(2));

            Registry registry = new Registry();
            RegistryStrategy registryStrategy = new RegistryStrategy(registry);
            Serializer serializer = new Persister(registryStrategy,
                    new PlatformFilter(config.properties), new Format(2));

            registry.bind(File.class, fileConverter);
            registry.bind(Lib.class, new RelativeLibConverter(fileConverter));
            registry.bind(Resource.class, new ResourceConverter(fileConverter, resourceSerializer));

            return serializer;
        }

        
        public Map<String, PluginArgument> fetchPluginArguments() {
            Map<String, PluginArgument> args = new TreeMap<>();
            for (Plugin plugin : config.plugins) {
                for (PluginArgument arg : plugin.getArguments().getArguments()) {
                    args.put(plugin.getArguments().getPrefix() + ":" + arg.getName(), arg);
                }
            }
            return args;
        }

        public List<Plugin> getPlugins() {
            return config.getPlugins();
        }
    }

    public static final class Lib {
        private final String value;
        private final boolean force;

        public Lib(String value, boolean force) {
            this.value = value;
            this.force = force;
        }

        public String getValue() {
            return value;
        }

        public boolean isForce() {
            return force;
        }

        @Override
        public String toString() {
            return "Lib [value=" + value + ", force=" + force + "]";
        }

        @Override
        public int hashCode() {
            final int prime = 31;
            int result = 1;
            result = prime * result + (force ? 1231 : 1237);
            result = prime * result + ((value == null) ? 0 : value.hashCode());
            return result;
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (obj == null) {
                return false;
            }
            if (getClass() != obj.getClass()) {
                return false;
            }
            Lib other = (Lib) obj;
            if (force != other.force) {
                return false;
            }
            if (value == null) {
                if (other.value != null) {
                    return false;
                }
            } else if (!value.equals(other.value)) {
                return false;
            }
            return true;
        }
    }

    private static final class RelativeLibConverter implements Converter<Lib> {
        private final RelativeFileConverter fileConverter;

        public RelativeLibConverter(RelativeFileConverter fileConverter) {
            this.fileConverter = fileConverter;
        }

        @Override
        public Lib read(InputNode node) throws Exception {
            String value = node.getValue();
            if (value == null) {
                return null;
            }
            InputNode forceNode = node.getAttribute("force");
            boolean force = forceNode == null || Boolean.valueOf(forceNode.getValue());
            if (value.endsWith(".a") || value.endsWith(".o")) {
                return new Lib(fileConverter.read(value).getAbsolutePath(), force);
            } else {
                return new Lib(value, force);
            }
        }

        @Override
        public void write(OutputNode node, Lib lib) throws Exception {
            String value = lib.getValue();
            boolean force = lib.isForce();
            if (value.endsWith(".a") || value.endsWith(".o")) {
                fileConverter.write(node, new File(value));
            } else {
                node.setValue(value);
            }
            if (!force) {
                node.setAttribute("force", "false");
            }
        }
    }

    private static final class RelativeFileConverter implements Converter<File> {
        private final String wdPrefix;

        public RelativeFileConverter(File wd) {
            if (wd.isFile()) {
                wd = wd.getParentFile();
            }
            String prefix = wd.getAbsolutePath();
            if (prefix.endsWith(File.separator)) {
                prefix = prefix.substring(0, prefix.length() - 1);
            }
            wdPrefix = prefix;
        }

        File read(String value) {
            if (value == null) {
                return null;
            }
            File file = new File(value);
            if (!file.isAbsolute()) {
                file = new File(wdPrefix, value);
            }
            return file;
        }

        @Override
        public File read(InputNode node) throws Exception {
            return read(node.getValue());
        }

        @Override
        public void write(OutputNode node, File value) throws Exception {
            String path = value.getAbsolutePath();
            if (path.equals(wdPrefix)) {
                if ("directory".equals(node.getName())) {
                    
                    node.remove();
                } else {
                    node.setValue("");
                }
            } else if (path.startsWith(wdPrefix) && path.charAt(wdPrefix.length()) == File.separatorChar) {
                node.setValue(path.substring(wdPrefix.length() + 1));
            } else {
                node.setValue(path);
            }
        }
    }

    private static final class ResourceConverter implements Converter<Resource> {
        private final RelativeFileConverter fileConverter;
        private final Serializer serializer;

        public ResourceConverter(RelativeFileConverter fileConverter, Serializer serializer) {
            this.fileConverter = fileConverter;
            this.serializer = serializer;
        }

        @Override
        public Resource read(InputNode node) throws Exception {
            String value = node.getValue();
            if (value != null && value.trim().length() > 0) {
                return new Resource(fileConverter.read(value));
            }
            return serializer.read(Resource.class, node);
        }

        @Override
        public void write(OutputNode node, Resource resource) throws Exception {
            File path = resource.getPath();
            if (path != null) {
                fileConverter.write(node, path);
            } else {
                node.remove();
                serializer.write(resource, node.getParent());
            }
        }
    }
}

<code block>

package org.robovm.compiler.plugin.lambda;

import static org.objectweb.asm.Opcodes.ACC_BRIDGE;
import static org.objectweb.asm.Opcodes.ACC_FINAL;
import static org.objectweb.asm.Opcodes.ACC_PRIVATE;
import static org.objectweb.asm.Opcodes.ACC_PUBLIC;
import static org.objectweb.asm.Opcodes.ACC_STATIC;
import static org.objectweb.asm.Opcodes.ACC_SUPER;
import static org.objectweb.asm.Opcodes.ACC_SYNTHETIC;
import static org.objectweb.asm.Opcodes.ALOAD;
import static org.objectweb.asm.Opcodes.ARETURN;
import static org.objectweb.asm.Opcodes.DLOAD;
import static org.objectweb.asm.Opcodes.DRETURN;
import static org.objectweb.asm.Opcodes.DUP;
import static org.objectweb.asm.Opcodes.FLOAD;
import static org.objectweb.asm.Opcodes.FRETURN;
import static org.objectweb.asm.Opcodes.GETFIELD;
import static org.objectweb.asm.Opcodes.ILOAD;
import static org.objectweb.asm.Opcodes.INVOKEINTERFACE;
import static org.objectweb.asm.Opcodes.INVOKESPECIAL;
import static org.objectweb.asm.Opcodes.INVOKESTATIC;
import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;
import static org.objectweb.asm.Opcodes.IRETURN;
import static org.objectweb.asm.Opcodes.LLOAD;
import static org.objectweb.asm.Opcodes.LRETURN;
import static org.objectweb.asm.Opcodes.NEW;
import static org.objectweb.asm.Opcodes.PUTFIELD;
import static org.objectweb.asm.Opcodes.RETURN;

import java.util.ArrayList;
import java.util.List;

import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.commons.GeneratorAdapter;
import org.robovm.compiler.CompilerException;
import org.robovm.compiler.Types;

import soot.DoubleType;
import soot.FloatType;
import soot.LongType;
import soot.PrimType;
import soot.RefType;
import soot.SootClass;
import soot.SootMethodHandle;
import soot.SootMethodRef;
import soot.SootMethodType;
import soot.Type;
import soot.VoidType;

public class LambdaClassGenerator {
    private static int CLASS_VERSION = 51;
    private int counter = 1;

    public LambdaClass generate(SootClass caller, String invokedName, SootMethodRef invokedType,
            SootMethodType samMethodType, SootMethodHandle implMethod, SootMethodType instantiatedMethodType,
            List<Type> markerInterfaces, List<SootMethodType> bridgeMethods) {
        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES);

        String lambdaClassName = caller.getName().replace('.', '/') + "$$Lambda$" + (counter++);
        String functionalInterface = invokedType.returnType().toString().replace('.', '/');

        List<String> interfaces = new ArrayList<String>();
        interfaces.add(functionalInterface);
        for (Type markerInterface : markerInterfaces) {
            interfaces.add(markerInterface.toString().replace('.', '/'));
        }

        cw.visit(CLASS_VERSION, ACC_FINAL + ACC_SUPER + ACC_SYNTHETIC, lambdaClassName, null, "java/lang/Object",
                interfaces.toArray(new String[interfaces.size()]));

        String targetMethod = "<init>";
        createFieldsAndConstructor(lambdaClassName, cw, invokedType, samMethodType, implMethod, instantiatedMethodType);

        
        
        
        
        
        
        if (!invokedType.parameterTypes().isEmpty()) {
            targetMethod = createFactory(lambdaClassName, cw, invokedType, samMethodType, implMethod,
                    instantiatedMethodType);
        }

        
        createForwardingMethod(caller, lambdaClassName, cw, invokedName, samMethodType.getParameterTypes(),
                samMethodType.getReturnType(), invokedType.parameterTypes(), samMethodType, implMethod,
                instantiatedMethodType, false);

        
        for (SootMethodType bridgeMethod : bridgeMethods) {
            createForwardingMethod(caller, lambdaClassName, cw, invokedName, bridgeMethod.getParameterTypes(),
                    bridgeMethod.getReturnType(), invokedType.parameterTypes(), samMethodType, implMethod,
                    instantiatedMethodType, true);
        }
        cw.visitEnd();

        return new LambdaClass(lambdaClassName, cw.toByteArray(), targetMethod, invokedType.parameterTypes(),
                invokedType.returnType());
    }

    private void createForwardingMethod(SootClass caller, String lambdaClassName, ClassWriter cw, String name,
            List<Type> parameters, Type returnType, List<Type> invokedParameters, SootMethodType samMethodType,
            SootMethodHandle implMethod, SootMethodType instantiatedMethodType, boolean isBridgeMethod) {
        String descriptor = Types.getDescriptor(parameters, returnType);
        String implClassName = implMethod.getMethodRef().declaringClass().getName().replace('.', '/');
        int accessFlags = ACC_PUBLIC | (isBridgeMethod ? ACC_BRIDGE : 0);
        MethodVisitor mv = cw.visitMethod(accessFlags, name, descriptor, null, null);
        mv.visitCode();

        
        
        int invokeOpCode = INVOKESTATIC;
        boolean isInstanceMethod = false;
        switch (implMethod.getReferenceKind()) {
        case SootMethodHandle.REF_invokeInterface:
            invokeOpCode = INVOKEINTERFACE;
            isInstanceMethod = true;
            break;
        case SootMethodHandle.REF_invokeSpecial:
            invokeOpCode = INVOKESPECIAL;
            isInstanceMethod = true;
            break;
        case SootMethodHandle.REF_newInvokeSpecial:
            invokeOpCode = INVOKESPECIAL;
            break;
        case SootMethodHandle.REF_invokeStatic:
            invokeOpCode = INVOKESTATIC;
            break;
        case SootMethodHandle.REF_invokeVirtual:
            invokeOpCode = INVOKEVIRTUAL;
            isInstanceMethod = true;
            break;
        default:
            throw new CompilerException("Unknown invoke type: " + implMethod.getReferenceKind());
        }

        GeneratorAdapter caster = new GeneratorAdapter(mv, accessFlags, name, descriptor);

        
        pushArguments(caller, lambdaClassName, mv, caster, parameters, invokedParameters, implMethod,
                instantiatedMethodType, isInstanceMethod);

        
        
        
        
        
        String implDescriptor = null;
        List<Type> paramTypes = new ArrayList<Type>(implMethod.getMethodType().getParameterTypes());
        if (isInstanceMethod)
            paramTypes.remove(0);
        implDescriptor = Types.getDescriptor(paramTypes, implMethod.getMethodType().getReturnType());

        
        mv.visitMethodInsn(invokeOpCode, implClassName, implMethod.getMethodRef().name(), implDescriptor,
                invokeOpCode == INVOKEINTERFACE);

        
        createForwardingMethodReturn(mv, caster, returnType, samMethodType, implMethod, instantiatedMethodType);

        mv.visitMaxs(-1, -1);
        mv.visitEnd();
    }

    private void pushArguments(SootClass caller, String lambdaClassName, MethodVisitor mv, GeneratorAdapter caster,
            List<Type> parameters, List<Type> invokedParameters, SootMethodHandle implMethod,
            SootMethodType instantiatedMethodType, boolean isInstanceMethod) {

        
        
        if (implMethod.getReferenceKind() == SootMethodHandle.REF_newInvokeSpecial) {
            mv.visitTypeInsn(NEW, implMethod.getMethodRef().declaringClass().getName().replace('.', '/'));
            mv.visitInsn(DUP);
        }

        
        for (int i = 0; i < invokedParameters.size(); i++) {
            Object obj = invokedParameters.get(i);
            Type captureType = (Type) obj;
            mv.visitVarInsn(ALOAD, 0);
            mv.visitFieldInsn(GETFIELD, lambdaClassName, "arg$" + (i + 1), Types.getDescriptor(captureType));
        }

        
        
        
        
        
        
        boolean paramsContainReceiver = isInstanceMethod
                & !caller.getName().equals(implMethod.getMethodRef().declaringClass().getName());
        int paramsIndex = 0;
        int localIndex = 1; 
                            
        if (paramsContainReceiver && !parameters.isEmpty()) {
            Type param = parameters.get(0);
            mv.visitVarInsn(loadOpcodeForType(param), localIndex);
            localIndex += slotsForType(param);
            paramsIndex++;
        }

        int samParamsOffset = implMethod.getMethodRef().parameterTypes().size() - parameters.size()
                + (paramsContainReceiver ? 1 : 0);
        for (int i = 0; paramsIndex < parameters.size(); paramsIndex++, i++) {
            Type param = parameters.get(paramsIndex);
            mv.visitVarInsn(loadOpcodeForType(param), localIndex);
            castOrWiden(mv, caster, param, (Type) implMethod.getMethodRef().parameterTypes().get(samParamsOffset + i));
            localIndex += slotsForType(param);
        }
    }

    private void castOrWiden(MethodVisitor mv, GeneratorAdapter caster, Type actual, Type expected) {
        if (actual.equals(expected)) {
            return;
        }

        if (actual.equals(VoidType.v()) || expected.equals(VoidType.v())) {
            return;
        }

        
        if ((isPrimitiveType(actual) || isBoxedType(actual))
                && ((isPrimitiveType(expected) || isBoxedType(expected)))) {

            org.objectweb.asm.Type actualAsmType = getAsmPrimitiveType(actual);
            org.objectweb.asm.Type expectedAsmType = getAsmPrimitiveType(expected);

            
            if (isBoxedType(actual)) {
                caster.unbox(actualAsmType);
            }

            
            
            caster.cast(actualAsmType, expectedAsmType);

            
            if (isBoxedType(expected)) {
                caster.box(expectedAsmType);
            }
        } else {
            
            mv.visitTypeInsn(Opcodes.CHECKCAST, ((RefType) expected).getClassName().replace('.', '/'));
        }
    }

    private org.objectweb.asm.Type getAsmPrimitiveType(Type type) {
        if (isBoxedType(type)) {
            String className = type.toString();
            if ("java.lang.Boolean".equals(className)) {
                return org.objectweb.asm.Type.BOOLEAN_TYPE;
            } else if ("java.lang.Byte".equals(className)) {
                return org.objectweb.asm.Type.BYTE_TYPE;
            } else if ("java.lang.Character".equals(className)) {
                return org.objectweb.asm.Type.CHAR_TYPE;
            } else if ("java.lang.Short".equals(className)) {
                return org.objectweb.asm.Type.SHORT_TYPE;
            } else if ("java.lang.Integer".equals(className)) {
                return org.objectweb.asm.Type.INT_TYPE;
            } else if ("java.lang.Long".equals(className)) {
                return org.objectweb.asm.Type.LONG_TYPE;
            } else if ("java.lang.Float".equals(className)) {
                return org.objectweb.asm.Type.FLOAT_TYPE;
            } else if ("java.lang.Double".equals(className)) {
                return org.objectweb.asm.Type.DOUBLE_TYPE;
            } else {
                throw new CompilerException("Unknown primitive type " + type);
            }
        } else {
            return org.objectweb.asm.Type.getType(Types.getDescriptor(type));
        }
    }

    private boolean isPrimitiveType(Type type) {
        return type instanceof PrimType;
    }

    private boolean isBoxedType(Type type) {
        String className = type.toString();
        return "java.lang.Boolean".equals(className) || "java.lang.Byte".equals(className)
                || "java.lang.Character".equals(className) || "java.lang.Short".equals(className)
                || "java.lang.Integer".equals(className) || "java.lang.Long".equals(className)
                || "java.lang.Float".equals(className) || "java.lang.Double".equals(className);
    }

    private void createForwardingMethodReturn(MethodVisitor mv, GeneratorAdapter caster, Type returnType,
            SootMethodType samMethodType, SootMethodHandle implMethod, SootMethodType instantiatedMethodType) {
        castOrWiden(mv, caster, implMethod.getMethodRef().returnType(), instantiatedMethodType.getReturnType());
        if (returnType.equals(VoidType.v())) {
            mv.visitInsn(RETURN);
        } else if (returnType instanceof PrimType) {
            if (returnType.equals(LongType.v())) {
                mv.visitInsn(LRETURN);
            } else if (returnType.equals(FloatType.v())) {
                mv.visitInsn(FRETURN);
            } else if (returnType.equals(DoubleType.v())) {
                mv.visitInsn(DRETURN);
            } else {
                mv.visitInsn(IRETURN);
            }
        } else {
            mv.visitInsn(ARETURN);
        }
    }

    private void createFieldsAndConstructor(String lambdaClassName, ClassWriter cw, SootMethodRef invokedType,
            SootMethodType samMethodType, SootMethodHandle implMethod, SootMethodType instantiatedMethodType) {
        StringBuffer constructorDescriptor = new StringBuffer();

        
        int i = 0;
        for (Object obj : invokedType.parameterTypes()) {
            Type captureType = (Type) obj;
            String typeDesc = Types.getDescriptor(captureType);
            cw.visitField(ACC_PRIVATE + ACC_FINAL, "arg$" + (i + 1), typeDesc, null, null);
            constructorDescriptor.append(typeDesc);
            i++;
        }

        
        MethodVisitor mv = cw.visitMethod(0, "<init>", "(" + constructorDescriptor.toString() + ")V", null, null);
        mv.visitCode();

        
        mv.visitVarInsn(ALOAD, 0);
        mv.visitMethodInsn(INVOKESPECIAL, "java/lang/Object", "<init>", "()V", false);

        
        i = 0;
        int localIndex = 1; 
        for (Object obj : invokedType.parameterTypes()) {
            Type captureType = (Type) obj;

            
            mv.visitVarInsn(ALOAD, 0);

            
            mv.visitVarInsn(loadOpcodeForType(captureType), localIndex);
            localIndex += slotsForType(captureType);

            
            mv.visitFieldInsn(PUTFIELD, lambdaClassName, "arg$" + (i + 1), Types.getDescriptor(captureType));

            i++;
        }

        mv.visitInsn(RETURN);
        mv.visitMaxs(-1, -1);
        mv.visitEnd();
    }

    private String createFactory(String lambdaClassName, ClassWriter cw, SootMethodRef invokedType,
            SootMethodType samMethodType, SootMethodHandle implMethod, SootMethodType instantiatedMethodType) {
        MethodVisitor mv = cw.visitMethod(ACC_STATIC, "get$Lambda",
                Types.getDescriptor(invokedType.parameterTypes(), invokedType.returnType()), null, null);
        mv.visitCode();
        mv.visitTypeInsn(NEW, lambdaClassName);
        mv.visitInsn(DUP);
        int i = 0;
        for (Object obj : invokedType.parameterTypes()) {
            Type captureType = (Type) obj;
            mv.visitVarInsn(loadOpcodeForType(captureType), i);
            i += slotsForType(captureType);
        }
        mv.visitMethodInsn(INVOKESPECIAL, lambdaClassName, "<init>",
                Types.getDescriptor(invokedType.parameterTypes(), VoidType.v()), false);
        mv.visitInsn(ARETURN);
        mv.visitMaxs(-1, -1);
        mv.visitEnd();
        return "get$Lambda";
    }

    public int loadOpcodeForType(Type type) {
        if (type instanceof PrimType) {
            if (type.equals(LongType.v())) {
                return LLOAD;
            } else if (type.equals(FloatType.v())) {
                return FLOAD;
            } else if (type.equals(DoubleType.v())) {
                return DLOAD;
            } else {
                return ILOAD;
            }
        } else {
            return ALOAD;
        }
    }

    public int slotsForType(Type type) {
        if (type.equals(LongType.v()) || type.equals(DoubleType.v())) {
            return 2;
        } else {
            return 1;
        }
    }
}

<code block>

package org.robovm.compiler.plugin.lambda;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.apache.commons.io.FileUtils;
import org.robovm.compiler.CompilerException;
import org.robovm.compiler.ModuleBuilder;
import org.robovm.compiler.Types;
import org.robovm.compiler.clazz.Clazz;
import org.robovm.compiler.config.Config;
import org.robovm.compiler.plugin.AbstractCompilerPlugin;

import soot.Body;
import soot.Local;
import soot.Modifier;
import soot.PatchingChain;
import soot.RefType;
import soot.Scene;
import soot.SootClass;
import soot.SootField;
import soot.SootMethod;
import soot.SootMethodHandle;
import soot.SootMethodRef;
import soot.SootMethodType;
import soot.SootResolver;
import soot.Type;
import soot.Unit;
import soot.Value;
import soot.jimple.ClassConstant;
import soot.jimple.Constant;
import soot.jimple.ConstantSwitch;
import soot.jimple.DefinitionStmt;
import soot.jimple.DynamicInvokeExpr;
import soot.jimple.IntConstant;
import soot.jimple.Jimple;
import soot.jimple.NullConstant;
import soot.util.Switch;

public class LambdaPlugin extends AbstractCompilerPlugin {
    static final int BRIDGE = 0x00000040;
    static final int SYNTHETIC = 0x00001000;
    
    private static int FLAG_MARKERS = 2;
    private static int FLAG_BRIDGES = 4;

    final Map<SootClass, LambdaClassGenerator> generators = new HashMap<SootClass, LambdaClassGenerator>();

    private static boolean isLambdaBootstrapMethod(SootMethodRef methodRef) {
        return methodRef.declaringClass().getName().equals("java.lang.invoke.LambdaMetafactory")
                && (methodRef.name().equals("metafactory") || methodRef.name().equals("altMetafactory"));
    }

    @Override
    public void afterClass(Config config, Clazz clazz, ModuleBuilder moduleBuilder) throws IOException {
        synchronized (generators) {
            generators.remove(clazz.getSootClass());
        }
    }

    @Override
    public void beforeClass(Config config, Clazz clazz, ModuleBuilder moduleBuilder) throws IOException {
        SootClass sootClass = clazz.getSootClass();

        for (SootMethod method : sootClass.getMethods()) {
            transformMethod(config, clazz, sootClass, method, moduleBuilder);
        }
    }

    private void transformMethod(Config config, Clazz clazz, SootClass sootClass,
            SootMethod method, ModuleBuilder moduleBuilder) throws IOException {

        if (!method.isConcrete()) {
            return;
        }

        int tmpCounter = 0;
        Body body = method.retrieveActiveBody();
        PatchingChain<Unit> units = body.getUnits();
        for (Unit unit = units.getFirst(); unit != null; unit = body.getUnits().getSuccOf(unit)) {
            if (unit instanceof DefinitionStmt) {
                if (((DefinitionStmt) unit).getRightOp() instanceof DynamicInvokeExpr) {
                    DynamicInvokeExpr expr = (DynamicInvokeExpr) ((DefinitionStmt) unit).getRightOp();

                    if (isLambdaBootstrapMethod(expr.getBootstrapMethodRef())) {
                        LambdaClassGenerator generator = null;
                        synchronized (generators) {
                            generator = generators.get(sootClass);
                            if (generator == null) {
                                generator = new LambdaClassGenerator();
                                generators.put(sootClass, generator);
                            }
                        }

                        List<Value> bsmArgs = expr.getBootstrapArgs();
                        SootClass caller = sootClass;
                        String invokedName = expr.getMethodRef().name();
                        SootMethodRef invokedType = expr.getMethodRef();
                        SootMethodType samMethodType = (SootMethodType) bsmArgs.get(0);
                        SootMethodHandle implMethod = (SootMethodHandle) bsmArgs.get(1);
                        SootMethodType instantiatedMethodType = (SootMethodType) bsmArgs.get(2);

                        try {
                            LambdaClass callSite = null;
                            List<Type> markerInterfaces = new ArrayList<>();
                            List<SootMethodType> bridgeMethods = new ArrayList<>();
                            if (expr.getBootstrapMethodRef().name().equals("altMetafactory")) {
                                int flags = ((IntConstant) bsmArgs.get(3)).value;
                                int bsmArgsIdx = 4;
                                if ((flags & FLAG_MARKERS) > 0) {
                                    int count = ((IntConstant) bsmArgs.get(bsmArgsIdx++)).value;
                                    for (int i = 0; i < count; i++) {
                                        Object value = bsmArgs.get(bsmArgsIdx++);
                                        if (value instanceof Type) {
                                            markerInterfaces.add((Type) value);
                                        } else if (value instanceof ClassConstant) {
                                            String className = ((ClassConstant) value).getValue().replace('/', '.');
                                            markerInterfaces.add(SootResolver.v()
                                                    .resolveClass(className, SootClass.HIERARCHY).getType());
                                        }
                                    }
                                }
                                if ((flags & FLAG_BRIDGES) > 0) {
                                    int count = ((IntConstant) bsmArgs.get(bsmArgsIdx++)).value;
                                    for (int i = 0; i < count; i++) {
                                        bridgeMethods.add((SootMethodType) bsmArgs.get(bsmArgsIdx++));
                                    }
                                }
                            }
                            
                            
                            
                            
                            
                            if (bridgeMethods.size() == 0) {
                                SootClass targetType = SootResolver.v().resolveClass(
                                        invokedType.returnType().toString().replace('/', '.'), SootClass.SIGNATURES);
                                String samDescriptor = Types.getDescriptor(samMethodType.getParameterTypes(),
                                        samMethodType.getReturnType());
                                for (SootMethod targetTypeMethod : targetType.getMethods()) {
                                    boolean isBridgeMethod = targetTypeMethod.getName().equals(invokedName);
                                    isBridgeMethod &= targetTypeMethod.getName().equals(invokedName);
                                    isBridgeMethod &= targetTypeMethod.getParameterCount() == samMethodType.getParameterTypes().size();
                                    isBridgeMethod &= ((targetTypeMethod.getModifiers() & BRIDGE) != 0);
                                    isBridgeMethod &= ((targetTypeMethod.getModifiers() & SYNTHETIC) != 0);
                                    if(isBridgeMethod) {
                                        String targetTypeMethodDesc = Types.getDescriptor(targetTypeMethod);
                                        if (!targetTypeMethodDesc.equals(samDescriptor)) {
                                            bridgeMethods.add(new BridgeMethodType(targetTypeMethod.getReturnType(),
                                                    targetTypeMethod.getParameterTypes()));
                                        }
                                    }
                                }
                            }
                            
                            
                            callSite = generator.generate(caller, invokedName, invokedType, samMethodType, implMethod,
                                    instantiatedMethodType, markerInterfaces, bridgeMethods);
                            File f = clazz.getPath().getGeneratedClassFile(callSite.getLambdaClassName());
                            FileUtils.writeByteArrayToFile(f, callSite.getClassData());
                            
                            
                            
                            
                            f.setLastModified(clazz.lastModified());

                            SootClass lambdaClass = SootResolver.v()
                                    .makeClassRef(callSite.getLambdaClassName().replace('/', '.'));

                            Local l = (Local) ((DefinitionStmt) unit).getLeftOp();
                            Type samType = callSite.getTargetMethodReturnType();
                            LinkedList<Unit> newUnits = new LinkedList<>();
                            if (callSite.getTargetMethodName().equals("<init>")) {
                                
                                
                                
                                String fieldName = lambdaClass.getName()
                                        .substring(lambdaClass.getName().lastIndexOf('.') + 1);
                                SootField field = new SootField(fieldName, lambdaClass.getType(),
                                        Modifier.STATIC | Modifier.PRIVATE | Modifier.TRANSIENT
                                                | 0x1000 );
                                method.getDeclaringClass().addField(field);
                                
                                newUnits.add(
                                        Jimple.v().newAssignStmt(l, Jimple.v().newStaticFieldRef(field.makeRef())));
                                
                                newUnits.add(Jimple.v().newIfStmt(Jimple.v().newNeExpr(l, NullConstant.v()),
                                        units.getSuccOf(unit)));
                                
                                Local tmp = Jimple.v().newLocal("$tmp" + (tmpCounter++), lambdaClass.getType());
                                body.getLocals().add(tmp);
                                newUnits.add(
                                        Jimple.v().newAssignStmt(tmp, Jimple.v().newNewExpr(lambdaClass.getType())));
                                newUnits.add(Jimple.v().newInvokeStmt(Jimple.v().newSpecialInvokeExpr(tmp,
                                        Scene.v().makeConstructorRef(lambdaClass, Collections.<Type> emptyList()))));
                                
                                newUnits.add(
                                        Jimple.v().newAssignStmt(Jimple.v().newStaticFieldRef(field.makeRef()), tmp));
                                
                                newUnits.add(Jimple.v().newAssignStmt(l, tmp));
                            } else {
                                
                                
                                newUnits.add(Jimple.v().newAssignStmt(l,
                                        Jimple.v().newStaticInvokeExpr(
                                                Scene.v().makeMethodRef(lambdaClass,
                                                        callSite.getTargetMethodName(),
                                                        callSite.getTargetMethodParameters(),
                                                        samType, true),
                                                expr.getArgs())));
                            }
                            units.insertAfter(newUnits, unit);
                            units.remove(unit);
                            unit = newUnits.getLast();

                        } catch (Throwable e) {
                            
                            
                            throw new CompilerException(e);
                        }
                    }
                }
            }
        }
    }
    
    static class BridgeMethodType extends Constant implements SootMethodType {
        private static final long serialVersionUID = 1L;

        private final Type returnType;
        private final List<Type> parameterTypes;

        public BridgeMethodType(Type returnType, List<Type> parameterTypes) {
            this.returnType = returnType;
            this.parameterTypes = parameterTypes;
        }

        public Type getReturnType() {
            return returnType;
        }

        public List<Type> getParameterTypes() {
            return Collections.unmodifiableList(parameterTypes);
        }

        @Override
        public Type getType() {
            return RefType.v("java.lang.invoke.MethodType");
        }

        @Override
        public void apply(Switch sw) {
            ((ConstantSwitch) sw).defaultCase(this);
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();

            sb.append('(');
            for (Iterator<Type> it = parameterTypes.iterator(); it.hasNext();) {
                sb.append(it.next());
                if (it.hasNext()) {
                    sb.append(',');
                }
            }
            return sb.append(')').append(returnType).toString();
        }
    }
}

<code block>

package org.robovm.compiler.plugin.lambda;

import java.util.List;

import soot.Type;

public class LambdaClass {
    private final String lambdaClassName;
    private final byte[] classData;
    private final String targetMethodName;
    private final List<Type> targetMethodParameters;
    private final Type targetMethodReturnType;

    public LambdaClass(String lambdaClassName, byte[] classData, String targetMethodName,
            List<Type> targetMethodParameters, Type targetMethodReturnType) {
        this.lambdaClassName = lambdaClassName;
        this.classData = classData;
        this.targetMethodName = targetMethodName;
        this.targetMethodParameters = targetMethodParameters;
        this.targetMethodReturnType = targetMethodReturnType;
    }

    public String getLambdaClassName() {
        return lambdaClassName;
    }

    public byte[] getClassData() {
        return classData;
    }

    public String getTargetMethodName() {
        return targetMethodName;
    }

    public List<Type> getTargetMethodParameters() {
        return targetMethodParameters;
    }

    public Type getTargetMethodReturnType() {
        return targetMethodReturnType;
    }
}

<code block>

package org.robovm.compiler.config;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Reader;
import java.io.Writer;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.ServiceLoader;
import java.util.TreeMap;
import java.util.jar.Attributes;
import java.util.jar.JarFile;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.robovm.compiler.DependencyGraph;
import org.robovm.compiler.ITable;
import org.robovm.compiler.MarshalerLookup;
import org.robovm.compiler.VTable;
import org.robovm.compiler.Version;
import org.robovm.compiler.clazz.Clazz;
import org.robovm.compiler.clazz.Clazzes;
import org.robovm.compiler.clazz.Path;
import org.robovm.compiler.config.OS.Family;
import org.robovm.compiler.config.tools.Tools;
import org.robovm.compiler.llvm.DataLayout;
import org.robovm.compiler.log.Logger;
import org.robovm.compiler.plugin.CompilerPlugin;
import org.robovm.compiler.plugin.LaunchPlugin;
import org.robovm.compiler.plugin.Plugin;
import org.robovm.compiler.plugin.PluginArgument;
import org.robovm.compiler.plugin.TargetPlugin;
import org.robovm.compiler.plugin.annotation.AnnotationImplPlugin;
import org.robovm.compiler.plugin.lambda2.LambdaPlugin;
import org.robovm.compiler.plugin.objc.InterfaceBuilderClassesPlugin;
import org.robovm.compiler.plugin.objc.ObjCBlockPlugin;
import org.robovm.compiler.plugin.objc.ObjCMemberPlugin;
import org.robovm.compiler.plugin.objc.ObjCProtocolProxyPlugin;
import org.robovm.compiler.target.ConsoleTarget;
import org.robovm.compiler.target.Target;
import org.robovm.compiler.target.ios.IOSTarget;
import org.robovm.compiler.target.ios.InfoPList;
import org.robovm.compiler.target.ios.ProvisioningProfile;
import org.robovm.compiler.target.ios.SigningIdentity;
import org.robovm.compiler.util.DigestUtil;
import org.robovm.compiler.util.io.RamDiskTools;
import org.simpleframework.xml.Element;
import org.simpleframework.xml.ElementList;
import org.simpleframework.xml.Root;
import org.simpleframework.xml.Serializer;
import org.simpleframework.xml.convert.Converter;
import org.simpleframework.xml.convert.Registry;
import org.simpleframework.xml.convert.RegistryStrategy;
import org.simpleframework.xml.core.Persister;
import org.simpleframework.xml.filter.PlatformFilter;
import org.simpleframework.xml.stream.Format;
import org.simpleframework.xml.stream.InputNode;
import org.simpleframework.xml.stream.OutputNode;


@Root
public class Config {

    
    private static final int MAX_FILE_NAME_LENGTH = 255;

    public enum Cacerts {
        full
    };

    public enum TreeShakerMode {
        none, conservative, aggressive
    };

    @Element(required = false)
    private File installDir = null;
    @Element(required = false)
    private String executableName = null;
    @Element(required = false)
    private String imageName = null;
    @Element(required = false)
    private Boolean useDynamicJni = null;
    @Element(required = false)
    private Boolean skipRuntimeLib = null;
    @Element(required = false)
    private File mainJar;
    @Element(required = false)
    private String mainClass;
    @Element(required = false)
    private Cacerts cacerts = null;
    @Element(required = false)
    private OS os = null;
    @Element(required = false)
    private Arch arch = null;
    @ElementList(required = false, entry = "root")
    private ArrayList<String> roots;
    @ElementList(required = false, entry = "pattern")
    private ArrayList<String> forceLinkClasses;
    @ElementList(required = false, entry = "lib")
    private ArrayList<Lib> libs;
    @ElementList(required = false, entry = "symbol")
    private ArrayList<String> exportedSymbols;
    @ElementList(required = false, entry = "symbol")
    private ArrayList<String> unhideSymbols;
    @ElementList(required = false, entry = "framework")
    private ArrayList<String> frameworks;
    @ElementList(required = false, entry = "framework")
    private ArrayList<String> weakFrameworks;
    @ElementList(required = false, entry = "path")
    private ArrayList<File> frameworkPaths;
    @ElementList(required = false, entry = "resource")
    private ArrayList<Resource> resources;
    @ElementList(required = false, entry = "classpathentry")
    private ArrayList<File> bootclasspath;
    @ElementList(required = false, entry = "classpathentry")
    private ArrayList<File> classpath;
    @ElementList(required = false, entry = "argument")
    private ArrayList<String> pluginArguments;
    @Element(required = false, name = "target")
    private String targetType;
    @Element(required = false, name = "treeShaker")
    private TreeShakerMode treeShakerMode;

    @Element(required = false)
    private String iosSdkVersion;
    @Element(required = false, name = "iosInfoPList")
    private File iosInfoPListFile = null;
    @Element(required = false)
    private File iosResourceRulesPList;
    @Element(required = false)
    private File iosEntitlementsPList;

    @Element(required = false)
    private Tools tools;

    private SigningIdentity iosSignIdentity;
    private ProvisioningProfile iosProvisioningProfile;
    private String iosDeviceType;
    private InfoPList iosInfoPList;

    private boolean iosSkipSigning = false;

    private Properties properties = new Properties();

    private Home home = null;
    private File tmpDir;
    private File cacheDir = new File(System.getProperty("user.home"), ".robovm/cache");
    private File ccBinPath = null;

    private boolean clean = false;
    private boolean debug = false;
    private boolean useDebugLibs = false;
    private boolean skipLinking = false;
    private boolean skipInstall = false;
    private boolean dumpIntermediates = false;
    private int threads = Runtime.getRuntime().availableProcessors();
    private Logger logger = Logger.NULL_LOGGER;

    

    private transient List<Plugin> plugins = new ArrayList<>();
    private transient Target target = null;
    private transient File osArchDepLibDir;
    private transient File osArchCacheDir;
    private transient Clazzes clazzes;
    private transient VTable.Cache vtableCache;
    private transient ITable.Cache itableCache;
    private transient List<Path> resourcesPaths = new ArrayList<Path>();
    private transient DataLayout dataLayout;
    private transient MarshalerLookup marshalerLookup;
    private transient Config configBeforeBuild;
    private transient DependencyGraph dependencyGraph;

    protected Config() throws IOException {
        
        this.plugins.addAll(0, Arrays.asList(
                new InterfaceBuilderClassesPlugin(),
                new ObjCProtocolProxyPlugin(),
                new ObjCMemberPlugin(),
                new ObjCBlockPlugin(),
                new AnnotationImplPlugin(),
                new LambdaPlugin()
                ));
        this.loadPluginsFromClassPath();
    }

    
    public Builder builder() throws IOException {
        return new Builder(clone(configBeforeBuild));
    }

    public Home getHome() {
        return home;
    }

    public File getInstallDir() {
        return installDir;
    }

    public String getExecutableName() {
        return executableName;
    }

    public String getImageName() {
        return imageName;
    }

    public File getExecutablePath() {
        return new File(installDir, getExecutableName());
    }

    public File getImagePath() {
        return getExecutablePath();
    }

    public File getCacheDir() {
        return osArchCacheDir;
    }

    public File getCcBinPath() {
        return ccBinPath;
    }

    public OS getOs() {
        return os;
    }

    public Arch getArch() {
        return arch;
    }

    public String getTriple() {
        return arch.getLlvmName() + "-unknown-" + os.getLlvmName();
    }

    public String getClangTriple() {
        return arch.getClangName() + "-unknown-" + os.getLlvmName();
    }

    public DataLayout getDataLayout() {
        return dataLayout;
    }

    public boolean isClean() {
        return clean;
    }

    public boolean isDebug() {
        return debug;
    }

    public boolean isUseDebugLibs() {
        return useDebugLibs;
    }

    public boolean isDumpIntermediates() {
        return dumpIntermediates;
    }

    public boolean isSkipRuntimeLib() {
        return skipRuntimeLib != null && skipRuntimeLib.booleanValue();
    }

    public boolean isSkipLinking() {
        return skipLinking;
    }

    public boolean isSkipInstall() {
        return skipInstall;
    }

    public boolean isUseDynamicJni() {
        return useDynamicJni != null && useDynamicJni.booleanValue();
    }

    public int getThreads() {
        return threads;
    }

    public File getMainJar() {
        return mainJar;
    }

    public String getMainClass() {
        return mainClass;
    }

    public Cacerts getCacerts() {
        return cacerts == null ? Cacerts.full : cacerts;
    }

    public List<Path> getResourcesPaths() {
        return resourcesPaths;
    }

    public void addResourcesPath(Path path) {
        resourcesPaths.add(path);
    }

    public DependencyGraph getDependencyGraph() {
        return dependencyGraph;
    }
    
    public File getTmpDir() {
        if (tmpDir == null) {
            try {
                tmpDir = File.createTempFile("robovm", ".tmp");
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
            tmpDir.delete();
            tmpDir.mkdirs();
        }
        return tmpDir;
    }

    public List<String> getForceLinkClasses() {
        return forceLinkClasses == null ? Collections.<String> emptyList()
                : Collections.unmodifiableList(forceLinkClasses);
    }

    public List<String> getExportedSymbols() {
        return exportedSymbols == null ? Collections.<String> emptyList()
                : Collections.unmodifiableList(exportedSymbols);
    }

    public List<String> getUnhideSymbols() {
        return unhideSymbols == null ? Collections.<String> emptyList()
                : Collections.unmodifiableList(unhideSymbols);
    }
    
    public List<Lib> getLibs() {
        return libs == null ? Collections.<Lib> emptyList()
                : Collections.unmodifiableList(libs);
    }

    public List<String> getFrameworks() {
        return frameworks == null ? Collections.<String> emptyList()
                : Collections.unmodifiableList(frameworks);
    }

    public List<String> getWeakFrameworks() {
        return weakFrameworks == null ? Collections.<String> emptyList()
                : Collections.unmodifiableList(weakFrameworks);
    }

    public List<File> getFrameworkPaths() {
        return frameworkPaths == null ? Collections.<File> emptyList()
                : Collections.unmodifiableList(frameworkPaths);
    }

    public List<Resource> getResources() {
        return resources == null ? Collections.<Resource> emptyList()
                : Collections.unmodifiableList(resources);
    }

    public File getOsArchDepLibDir() {
        return osArchDepLibDir;
    }

    public Clazzes getClazzes() {
        return clazzes;
    }

    public VTable.Cache getVTableCache() {
        return vtableCache;
    }

    public ITable.Cache getITableCache() {
        return itableCache;
    }

    public MarshalerLookup getMarshalerLookup() {
        return marshalerLookup;
    }

    public List<CompilerPlugin> getCompilerPlugins() {
        List<CompilerPlugin> compilerPlugins = new ArrayList<>();
        for (Plugin plugin : plugins) {
            if (plugin instanceof CompilerPlugin) {
                compilerPlugins.add((CompilerPlugin) plugin);
            }
        }
        return compilerPlugins;
    }

    public List<LaunchPlugin> getLaunchPlugins() {
        List<LaunchPlugin> launchPlugins = new ArrayList<>();
        for (Plugin plugin : plugins) {
            if (plugin instanceof LaunchPlugin) {
                launchPlugins.add((LaunchPlugin) plugin);
            }
        }
        return launchPlugins;
    }

    public List<TargetPlugin> getTargetPlugins() {
        List<TargetPlugin> targetPlugins = new ArrayList<>();
        for (Plugin plugin : plugins) {
            if (plugin instanceof TargetPlugin) {
                targetPlugins.add((TargetPlugin) plugin);
            }
        }
        return targetPlugins;
    }

    public List<Plugin> getPlugins() {
        return plugins;
    }

    public List<String> getPluginArguments() {
        return pluginArguments == null ? Collections.<String> emptyList()
                : Collections.unmodifiableList(pluginArguments);
    }

    public List<File> getBootclasspath() {
        return bootclasspath == null ? Collections.<File> emptyList()
                : Collections.unmodifiableList(bootclasspath);
    }

    public List<File> getClasspath() {
        return classpath == null ? Collections.<File> emptyList()
                : Collections.unmodifiableList(classpath);
    }

    public Properties getProperties() {
        return properties;
    }

    public Logger getLogger() {
        return logger;
    }

    public Target getTarget() {
        return target;
    }

    public String getTargetType() {
        return targetType;
    }

    public TreeShakerMode getTreeShakerMode() {
        return treeShakerMode == null ? TreeShakerMode.none : treeShakerMode;
    }

    public String getIosSdkVersion() {
        return iosSdkVersion;
    }

    public String getIosDeviceType() {
        return iosDeviceType;
    }

    public InfoPList getIosInfoPList() {
        if (iosInfoPList == null && iosInfoPListFile != null) {
            iosInfoPList = new InfoPList(iosInfoPListFile);
        }
        return iosInfoPList;
    }

    public File getIosResourceRulesPList() {
        return iosResourceRulesPList;
    }

    public File getIosEntitlementsPList() {
        return iosEntitlementsPList;
    }

    public SigningIdentity getIosSignIdentity() {
        return iosSignIdentity;
    }

    public ProvisioningProfile getIosProvisioningProfile() {
        return iosProvisioningProfile;
    }

    public boolean isIosSkipSigning() {
        return iosSkipSigning;
    }

    public Tools getTools() {
        return tools;
    }

    private static File makeFileRelativeTo(File dir, File f) {
        if (f.getParentFile() == null) {
            return dir;
        }
        return new File(makeFileRelativeTo(dir, f.getParentFile()), f.getName());
    }

    public String getArchiveName(Path path) {
        if (path.getFile().isFile()) {
            return path.getFile().getName();
        } else {
            return "classes" + path.getIndex() + ".jar";
        }
    }

    static String getFileName(Clazz clazz, String ext) {
        return getFileName(clazz.getInternalName(), ext, MAX_FILE_NAME_LENGTH);
    }

    static String getFileName(String internalName, String ext, int maxFileNameLength) {
        String packagePath = internalName.substring(0, internalName.lastIndexOf('/') + 1);
        String className = internalName.substring(internalName.lastIndexOf('/') + 1);
        String suffix = ext.startsWith(".") ? ext : "." + ext;

        int length = className.length() + suffix.length();
        if (length > maxFileNameLength) {
            String sha1 = DigestUtil.sha1(className);
            className = className.substring(0, Math.max(0, maxFileNameLength - suffix.length() - sha1.length())) + sha1;
        }
        return packagePath.replace('/', File.separatorChar) + className + suffix;
    }

    public File getLlFile(Clazz clazz) {
        return new File(getCacheDir(clazz.getPath()), getFileName(clazz, "class.ll"));
    }

    public File getCFile(Clazz clazz) {
        return new File(getCacheDir(clazz.getPath()), getFileName(clazz, "class.c"));
    }

    public File getBcFile(Clazz clazz) {
        return new File(getCacheDir(clazz.getPath()), getFileName(clazz, "class.bc"));
    }

    public File getSFile(Clazz clazz) {
        return new File(getCacheDir(clazz.getPath()), getFileName(clazz, "class.s"));
    }

    public File getOFile(Clazz clazz) {
        return new File(getCacheDir(clazz.getPath()), getFileName(clazz, "class.o"));
    }

    public File getLinesOFile(Clazz clazz) {
        return new File(getCacheDir(clazz.getPath()), getFileName(clazz, "class.lines.o"));
    }

    public File getLinesLlFile(Clazz clazz) {
        return new File(getCacheDir(clazz.getPath()), getFileName(clazz, "class.lines.ll"));
    }

    public File getInfoFile(Clazz clazz) {
        return new File(getCacheDir(clazz.getPath()), getFileName(clazz, "class.info"));
    }

    public File getCacheDir(Path path) {
        File srcRoot = path.getFile().getParentFile();
        String name = path.getFile().getName();
        try {
            return new File(makeFileRelativeTo(osArchCacheDir, srcRoot.getCanonicalFile()), name);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    
    public File getGeneratedClassDir(Path path) {
        File pathCacheDir = getCacheDir(path);
        return new File(pathCacheDir.getParentFile(), pathCacheDir.getName() + ".generated");
    }

    private static Map<Object, Object> getManifestAttributes(File jarFile) throws IOException {
        JarFile jf = null;
        try {
            jf = new JarFile(jarFile);
            return new HashMap<Object, Object>(jf.getManifest().getMainAttributes());
        } finally {
            jf.close();
        }
    }

    private static String getImplementationVersion(File jarFile) throws IOException {
        return (String) getManifestAttributes(jarFile).get(Attributes.Name.IMPLEMENTATION_VERSION);
    }

    private static String getMainClass(File jarFile) throws IOException {
        return (String) getManifestAttributes(jarFile).get(Attributes.Name.MAIN_CLASS);
    }

    private File extractIfNeeded(Path path) throws IOException {
        if (path.getFile().isFile()) {
            File pathCacheDir = getCacheDir(path);
            File target = new File(pathCacheDir.getParentFile(), pathCacheDir.getName() + ".extracted");

            if (!target.exists() || path.getFile().lastModified() > target.lastModified()) {
                FileUtils.deleteDirectory(target);
                target.mkdirs();
                try (ZipFile zipFile = new ZipFile(path.getFile())) {
                    Enumeration<? extends ZipEntry> entries = zipFile.entries();
                    while (entries.hasMoreElements()) {
                        ZipEntry entry = entries.nextElement();
                        if (entry.getName().startsWith("META-INF/robovm/") && !entry.isDirectory()) {
                            File f = new File(target, entry.getName());
                            f.getParentFile().mkdirs();
                            try (InputStream in = zipFile.getInputStream(entry);
                                 OutputStream out = new FileOutputStream(f)) {

                                IOUtils.copy(in, out);
                                if (entry.getTime() != -1) {
                                    f.setLastModified(entry.getTime());
                                }
                            }
                        }
                    }
                }
                target.setLastModified(path.getFile().lastModified());
            }

            return target;
        } else {
            return path.getFile();
        }
    }

    private <T> ArrayList<T> mergeLists(ArrayList<T> from, ArrayList<T> to) {
        if (from == null) {
            return to;
        }
        to = to != null ? to : new ArrayList<T>();
        for (T o : from) {
            if (!to.contains(o)) {
                to.add(o);
            }
        }
        return to;
    }

    private void mergeConfig(Config from, Config to) {
        to.exportedSymbols = mergeLists(from.exportedSymbols, to.exportedSymbols);
        to.unhideSymbols = mergeLists(from.unhideSymbols, to.unhideSymbols);
        to.forceLinkClasses = mergeLists(from.forceLinkClasses, to.forceLinkClasses);
        to.frameworkPaths = mergeLists(from.frameworkPaths, to.frameworkPaths);
        to.frameworks = mergeLists(from.frameworks, to.frameworks);
        to.libs = mergeLists(from.libs, to.libs);
        to.resources = mergeLists(from.resources, to.resources);
        to.weakFrameworks = mergeLists(from.weakFrameworks, to.weakFrameworks);
    }

    private void mergeConfigsFromClasspath() throws IOException {
        List<String> dirs = Arrays.asList(
                "META-INF/robovm/" + os + "/" + arch,
                "META-INF/robovm/" + os);

        
        

        
        Config config = new Config();
        for (Path path : clazzes.getPaths()) {
            for (String dir : dirs) {
                if (path.contains(dir + "/robovm.xml")) {
                    File configXml = new File(new File(extractIfNeeded(path), dir), "robovm.xml");
                    Builder builder = new Builder();
                    builder.read(configXml);
                    mergeConfig(builder.config, config);
                    break;
                }
            }
        }

        
        mergeConfig(this, config);

        
        this.exportedSymbols = config.exportedSymbols;
        this.unhideSymbols = config.unhideSymbols;
        this.forceLinkClasses = config.forceLinkClasses;
        this.frameworkPaths = config.frameworkPaths;
        this.frameworks = config.frameworks;
        this.libs = config.libs;
        this.resources = config.resources;
        this.weakFrameworks = config.weakFrameworks;
    }

    private static <T> List<T> toList(Iterator<T> it) {
        List<T> l = new ArrayList<T>();
        while (it.hasNext()) {
            l.add(it.next());
        }
        return l;
    }

    private void loadPluginsFromClassPath() throws IOException {
        ClassLoader classLoader = getClass().getClassLoader();
        ServiceLoader<CompilerPlugin> compilerPluginLoader = ServiceLoader.load(CompilerPlugin.class, classLoader);
        ServiceLoader<LaunchPlugin> launchPluginLoader = ServiceLoader.load(LaunchPlugin.class, classLoader);
        ServiceLoader<TargetPlugin> targetPluginLoader = ServiceLoader.load(TargetPlugin.class, classLoader);

        plugins.addAll(toList(compilerPluginLoader.iterator()));
        plugins.addAll(toList(launchPluginLoader.iterator()));
        plugins.addAll(toList(targetPluginLoader.iterator()));
    }

    private static Config clone(Config config) throws IOException {
        Config clone = new Config();
        for (Field f : Config.class.getDeclaredFields()) {
            if (!Modifier.isStatic(f.getModifiers()) && !Modifier.isTransient(f.getModifiers())) {
                f.setAccessible(true);
                try {
                    Object o = f.get(config);
                    if (o instanceof Collection && o instanceof Cloneable) {
                        
                        
                        Method m = o.getClass().getMethod("clone");
                        o = m.invoke(o);
                    }
                    f.set(clone, o);
                } catch (Throwable t) {
                    throw new Error(t);
                }
            }
        }
        return clone;
    }

    private Config build() throws IOException {
        
        
        this.configBeforeBuild = clone(this);

        if (home == null) {
            home = Home.find();
        }

        if (bootclasspath == null) {
            bootclasspath = new ArrayList<File>();
        }
        if (classpath == null) {
            classpath = new ArrayList<File>();
        }

        if (mainJar != null) {
            mainClass = getMainClass(mainJar);
            classpath.add(mainJar);
        }

        if (executableName == null && imageName != null) {
            executableName = imageName;
        }

        if (!skipLinking && executableName == null && mainClass == null) {
            throw new IllegalArgumentException("No target and no main class specified");
        }

        if (!skipLinking && classpath.isEmpty()) {
            throw new IllegalArgumentException("No classpath specified");
        }

        if (skipLinking) {
            skipInstall = true;
        }

        if (executableName == null) {
            executableName = mainClass;
        }

        if (imageName == null || !imageName.equals(executableName)) {
            imageName = executableName;
        }

        List<File> realBootclasspath = bootclasspath == null ? new ArrayList<File>() : bootclasspath;
        if (!isSkipRuntimeLib()) {
            realBootclasspath = new ArrayList<File>(bootclasspath);
            realBootclasspath.add(0, home.rtPath);
        }

        this.vtableCache = new VTable.Cache();
        this.itableCache = new ITable.Cache();
        this.marshalerLookup = new MarshalerLookup(this);

        if (!skipInstall) {
            if (installDir == null) {
                installDir = new File(".", executableName);
            }
            installDir.mkdirs();
        }

        if (targetType != null) {
            if (ConsoleTarget.TYPE.equals(targetType)) {
                target = new ConsoleTarget();
            } else if (IOSTarget.TYPE.equals(targetType)) {
                target = new IOSTarget();
            } else {
                for (TargetPlugin plugin : getTargetPlugins()) {
                    if (plugin.getTarget().getType().equals(targetType)) {
                        target = plugin.getTarget();
                        break;
                    }
                }
                if (target == null) {
                    throw new IllegalArgumentException("Unsupported target '" + targetType + "'");
                }
            }
        } else {
            
            if (os == OS.ios) {
                target = new IOSTarget();
            } else {
                target = new ConsoleTarget();
            }
        }
        target.init(this);

        os = target.getOs();
        arch = target.getArch();
        dataLayout = new DataLayout(getTriple());

        osArchDepLibDir = new File(new File(home.libVmDir, os.toString()),
                arch.toString());

        if (treeShakerMode != null && treeShakerMode != TreeShakerMode.none 
                && os.getFamily() == Family.darwin && arch == Arch.x86) {

            logger.warn("Tree shaking is not supported when building "
                    + "for OS X/iOS x86 32-bit due to a bug in Xcode's linker. No tree "
                    + "shaking will be performed. Run in 64-bit mode instead to "
                    + "use tree shaking.");
            treeShakerMode = TreeShakerMode.none;
        }
        dependencyGraph = new DependencyGraph(getTreeShakerMode());

        RamDiskTools ramDiskTools = new RamDiskTools();
        ramDiskTools.setupRamDisk(this, this.cacheDir, this.tmpDir);
        this.cacheDir = ramDiskTools.getCacheDir();
        this.tmpDir = ramDiskTools.getTmpDir();

        File osDir = new File(cacheDir, os.toString());
        File archDir = new File(osDir, arch.toString());
        osArchCacheDir = new File(archDir, debug ? "debug" : "release");
        osArchCacheDir.mkdirs();

        this.clazzes = new Clazzes(this, realBootclasspath, classpath);

        mergeConfigsFromClasspath();

        return this;
    }

    public static class Home {
        private File binDir = null;
        private File libVmDir = null;
        private File rtPath = null;
        private Map<Cacerts, File> cacertsPath = null;
        private boolean dev = false;

        public Home(File homeDir) {
            this(homeDir, true);
        }

        protected Home(File homeDir, boolean validate) {
            if (validate) {
                validate(homeDir);
            }
            binDir = new File(homeDir, "bin");
            libVmDir = new File(homeDir, "lib/vm");
            rtPath = new File(homeDir, "lib/robovm-rt.jar");
            cacertsPath = new HashMap<Cacerts, File>();
            cacertsPath.put(Cacerts.full, new File(homeDir, "lib/robovm-cacerts-full.jar"));
        }

        private Home(File devDir, File binDir, File libVmDir, File rtPath) {
            this.binDir = binDir;
            this.libVmDir = libVmDir;
            this.rtPath = rtPath;
            cacertsPath = new HashMap<Cacerts, File>();
            cacertsPath.put(Cacerts.full, new File(devDir,
                    "cacerts/full/target/robovm-cacerts-full-" + Version.getVersion() + ".jar"));
            this.dev = true;
        }

        public boolean isDev() {
            return dev;
        }

        public File getBinDir() {
            return binDir;
        }

        public File getLibVmDir() {
            return libVmDir;
        }

        public File getRtPath() {
            return rtPath;
        }

        public File getCacertsPath(Cacerts cacerts) {
            return cacertsPath.get(cacerts);
        }

        public static Home find() {
            
            
            if (System.getenv("ROBOVM_DEV_ROOT") != null) {
                File dir = new File(System.getenv("ROBOVM_DEV_ROOT"));
                return validateDevRootDir(dir);
            }
            if (System.getProperty("ROBOVM_DEV_ROOT") != null) {
                File dir = new File(System.getProperty("ROBOVM_DEV_ROOT"));
                return validateDevRootDir(dir);
            }

            if (System.getenv("ROBOVM_HOME") != null) {
                File dir = new File(System.getenv("ROBOVM_HOME"));
                return new Home(dir);
            }

            List<File> candidates = new ArrayList<File>();
            File userHome = new File(System.getProperty("user.home"));
            candidates.add(new File(userHome, "Applications/robovm"));
            candidates.add(new File(userHome, ".robovm/home"));
            candidates.add(new File("/usr/local/lib/robovm"));
            candidates.add(new File("/opt/robovm"));
            candidates.add(new File("/usr/lib/robovm"));

            for (File dir : candidates) {
                if (dir.exists()) {
                    return new Home(dir);
                }
            }

            throw new IllegalArgumentException("ROBOVM_HOME not set and no RoboVM "
                    + "installation found in " + candidates);
        }

        public static void validate(File dir) {
            String error = "Path " + dir + " is not a valid RoboVM install directory: ";
            
            
            if (!dir.exists()) {
                throw new IllegalArgumentException(error + "no such path");
            }

            if (!dir.isDirectory()) {
                throw new IllegalArgumentException(error + "not a directory");
            }

            File libDir = new File(dir, "lib");
            if (!libDir.exists() || !libDir.isDirectory()) {
                throw new IllegalArgumentException(error + "lib/ missing or invalid");
            }
            File binDir = new File(dir, "bin");
            if (!binDir.exists() || !binDir.isDirectory()) {
                throw new IllegalArgumentException(error + "bin/ missing or invalid");
            }
            File libVmDir = new File(libDir, "vm");
            if (!libVmDir.exists() || !libVmDir.isDirectory()) {
                throw new IllegalArgumentException(error + "lib/vm/ missing or invalid");
            }
            File rtJarFile = new File(libDir, "robovm-rt.jar");
            if (!rtJarFile.exists() || !rtJarFile.isFile()) {
                throw new IllegalArgumentException(error
                        + "lib/robovm-rt.jar missing or invalid");
            }

            
            
            try {
                String thisVersion = Version.getVersion();
                String thatVersion = getImplementationVersion(rtJarFile);
                if (thisVersion == null || thatVersion == null || !thisVersion.equals(thatVersion)) {
                    throw new IllegalArgumentException(error + "version mismatch (expected: "
                            + thisVersion + ", was: " + thatVersion + ")");
                }
            } catch (IOException e) {
                throw new IllegalArgumentException(error
                        + "failed to get version of rt jar", e);
            }
        }

        private static Home validateDevRootDir(File dir) {
            String error = "Path " + dir + " is not a valid RoboVM source tree: ";
            
            if (!dir.exists()) {
                throw new IllegalArgumentException(error + "no such path");
            }

            if (!dir.isDirectory()) {
                throw new IllegalArgumentException(error + "not a directory");
            }

            File vmBinariesDir = new File(dir, "vm/target/binaries");
            if (!vmBinariesDir.exists() || !vmBinariesDir.isDirectory()) {
                throw new IllegalArgumentException(error + "vm/target/binaries/ missing or invalid");
            }
            File binDir = new File(dir, "bin");
            if (!binDir.exists() || !binDir.isDirectory()) {
                throw new IllegalArgumentException(error + "bin/ missing or invalid");
            }

            String rtJarName = "robovm-rt-" + Version.getVersion() + ".jar";
            File rtJar = new File(dir, "rt/target/" + rtJarName);
            File rtClasses = new File(dir, "rt/target/classes/");
            File rtSource = rtJar;
            if (!rtJar.exists() || rtJar.isDirectory()) {
                if (!rtClasses.exists() || rtClasses.isFile()) {
                    throw new IllegalArgumentException(error
                            + "rt/target/" + rtJarName + " missing or invalid");
                } else {
                    rtSource = rtClasses;
                }
            }

            return new Home(dir, binDir, vmBinariesDir, rtSource);
        }
    }

    public static class Builder {
        final Config config;

        Builder(Config config) {
            this.config = config;
        }

        public Builder() throws IOException {
            this.config = new Config();
        }

        public Builder os(OS os) {
            config.os = os;
            return this;
        }

        public Builder arch(Arch arch) {
            config.arch = arch;
            return this;
        }

        public Builder clearClasspathEntries() {
            if (config.classpath != null) {
                config.classpath.clear();
            }
            return this;
        }

        public Builder addClasspathEntry(File f) {
            if (config.classpath == null) {
                config.classpath = new ArrayList<File>();
            }
            config.classpath.add(f);
            return this;
        }

        public Builder clearBootClasspathEntries() {
            if (config.bootclasspath != null) {
                config.bootclasspath.clear();
            }
            return this;
        }

        public Builder addBootClasspathEntry(File f) {
            if (config.bootclasspath == null) {
                config.bootclasspath = new ArrayList<File>();
            }
            config.bootclasspath.add(f);
            return this;
        }

        public Builder mainJar(File f) {
            config.mainJar = f;
            return this;
        }

        public Builder installDir(File installDir) {
            config.installDir = installDir;
            return this;
        }

        public Builder executableName(String executableName) {
            config.executableName = executableName;
            return this;
        }

        public Builder imageName(String imageName) {
            config.imageName = imageName;
            return this;
        }

        public Builder home(Home home) {
            config.home = home;
            return this;
        }

        public Builder cacheDir(File cacheDir) {
            config.cacheDir = cacheDir;
            return this;
        }

        public Builder clean(boolean b) {
            config.clean = b;
            return this;
        }

        public Builder ccBinPath(File ccBinPath) {
            config.ccBinPath = ccBinPath;
            return this;
        }

        public Builder debug(boolean b) {
            config.debug = b;
            return this;
        }

        public Builder useDebugLibs(boolean b) {
            config.useDebugLibs = b;
            return this;
        }

        public Builder dumpIntermediates(boolean b) {
            config.dumpIntermediates = b;
            return this;
        }

        public Builder skipRuntimeLib(boolean b) {
            config.skipRuntimeLib = b;
            return this;
        }

        public Builder skipLinking(boolean b) {
            config.skipLinking = b;
            return this;
        }

        public Builder skipInstall(boolean b) {
            config.skipInstall = b;
            return this;
        }

        public Builder useDynamicJni(boolean b) {
            config.useDynamicJni = b;
            return this;
        }

        public Builder threads(int threads) {
            config.threads = threads;
            return this;
        }

        public Builder mainClass(String mainClass) {
            config.mainClass = mainClass;
            return this;
        }

        public Builder tmpDir(File tmpDir) {
            config.tmpDir = tmpDir;
            return this;
        }

        public Builder logger(Logger logger) {
            config.logger = logger;
            return this;
        }

        public Builder treeShakerMode(TreeShakerMode treeShakerMode) {
            config.treeShakerMode = treeShakerMode;
            return this;
        }

        public Builder clearForceLinkClasses() {
            if (config.forceLinkClasses != null) {
                config.forceLinkClasses.clear();
            }
            return this;
        }

        public Builder addForceLinkClass(String pattern) {
            if (config.forceLinkClasses == null) {
                config.forceLinkClasses = new ArrayList<String>();
            }
            config.forceLinkClasses.add(pattern);
            return this;
        }

        public Builder clearExportedSymbols() {
            if (config.exportedSymbols != null) {
                config.exportedSymbols.clear();
            }
            return this;
        }

        public Builder addExportedSymbol(String symbol) {
            if (config.exportedSymbols == null) {
                config.exportedSymbols = new ArrayList<String>();
            }
            config.exportedSymbols.add(symbol);
            return this;
        }

        public Builder clearUnhideSymbols() {
            if (config.unhideSymbols != null) {
                config.unhideSymbols.clear();
            }
            return this;
        }

        public Builder addUnhideSymbol(String symbol) {
            if (config.unhideSymbols == null) {
                config.unhideSymbols = new ArrayList<String>();
            }
            config.unhideSymbols.add(symbol);
            return this;
        }

        public Builder clearLibs() {
            if (config.libs != null) {
                config.libs.clear();
            }
            return this;
        }

        public Builder addLib(Lib lib) {
            if (config.libs == null) {
                config.libs = new ArrayList<Lib>();
            }
            config.libs.add(lib);
            return this;
        }

        public Builder clearFrameworks() {
            if (config.frameworks != null) {
                config.frameworks.clear();
            }
            return this;
        }

        public Builder addFramework(String framework) {
            if (config.frameworks == null) {
                config.frameworks = new ArrayList<String>();
            }
            config.frameworks.add(framework);
            return this;
        }

        public Builder clearWeakFrameworks() {
            if (config.weakFrameworks != null) {
                config.weakFrameworks.clear();
            }
            return this;
        }

        public Builder addWeakFramework(String framework) {
            if (config.weakFrameworks == null) {
                config.weakFrameworks = new ArrayList<String>();
            }
            config.weakFrameworks.add(framework);
            return this;
        }

        public Builder clearFrameworkPaths() {
            if (config.frameworkPaths != null) {
                config.frameworkPaths.clear();
            }
            return this;
        }

        public Builder addFrameworkPath(File frameworkPath) {
            if (config.frameworkPaths == null) {
                config.frameworkPaths = new ArrayList<File>();
            }
            config.frameworkPaths.add(frameworkPath);
            return this;
        }

        public Builder clearResources() {
            if (config.resources != null) {
                config.resources.clear();
            }
            return this;
        }

        public Builder addResource(Resource resource) {
            if (config.resources == null) {
                config.resources = new ArrayList<Resource>();
            }
            config.resources.add(resource);
            return this;
        }

        public Builder targetType(String targetType) {
            config.targetType = targetType;
            return this;
        }

        public Builder clearProperties() {
            config.properties.clear();
            return this;
        }

        public Builder addProperties(Properties properties) {
            config.properties.putAll(properties);
            return this;
        }

        public Builder addProperties(File file) throws IOException {
            Properties props = new Properties();
            Reader reader = null;
            try {
                reader = new InputStreamReader(new FileInputStream(file), "utf-8");
                props.load(reader);
                addProperties(props);
            } finally {
                IOUtils.closeQuietly(reader);
            }
            return this;
        }

        public Builder addProperty(String name, String value) {
            config.properties.put(name, value);
            return this;
        }

        public Builder cacerts(Cacerts cacerts) {
            config.cacerts = cacerts;
            return this;
        }

        public Builder tools(Tools tools) {
            config.tools = tools;
            return this;
        }

        public Builder iosSdkVersion(String sdkVersion) {
            config.iosSdkVersion = sdkVersion;
            return this;
        }

        public Builder iosDeviceType(String deviceType) {
            config.iosDeviceType = deviceType;
            return this;
        }

        public Builder iosInfoPList(File infoPList) {
            config.iosInfoPListFile = infoPList;
            return this;
        }

        public Builder iosEntitlementsPList(File entitlementsPList) {
            config.iosEntitlementsPList = entitlementsPList;
            return this;
        }

        public Builder iosResourceRulesPList(File resourceRulesPList) {
            config.iosResourceRulesPList = resourceRulesPList;
            return this;
        }

        public Builder iosSignIdentity(SigningIdentity signIdentity) {
            config.iosSignIdentity = signIdentity;
            return this;
        }

        public Builder iosProvisioningProfile(ProvisioningProfile iosProvisioningProfile) {
            config.iosProvisioningProfile = iosProvisioningProfile;
            return this;
        }

        public Builder iosSkipSigning(boolean b) {
            config.iosSkipSigning = b;
            return this;
        }

        public Builder addCompilerPlugin(CompilerPlugin compilerPlugin) {
            config.plugins.add(compilerPlugin);
            return this;
        }

        public Builder addLaunchPlugin(LaunchPlugin plugin) {
            config.plugins.add(plugin);
            return this;
        }

        public Builder addTargetPlugin(TargetPlugin plugin) {
            config.plugins.add(plugin);
            return this;
        }

        public void addPluginArgument(String argName) {
            if (config.pluginArguments == null) {
                config.pluginArguments = new ArrayList<>();
            }
            config.pluginArguments.add(argName);
        }

        public Config build() throws IOException {
            for (CompilerPlugin plugin : config.getCompilerPlugins()) {
                plugin.beforeConfig(this, config);
            }

            return config.build();
        }

        
        public void readProjectProperties(File basedir, boolean isTest) throws IOException {
            File testPropsFile = new File(basedir, "robovm.test.properties");
            File localPropsFile = new File(basedir, "robovm.local.properties");
            File propsFile = new File(basedir, "robovm.properties");
            if (isTest && testPropsFile.exists()) {
                config.logger.debug("Loading test RoboVM config properties file: "
                        + testPropsFile.getAbsolutePath());
                addProperties(testPropsFile);
            } else {
                Properties props = new Properties();
                if (propsFile.exists()) {
                    config.logger.debug("Loading default RoboVM config properties file: "
                            + propsFile.getAbsolutePath());
                    try (Reader reader = new InputStreamReader(new FileInputStream(propsFile), "utf-8")) {
                        props.load(reader);
                    }
                }
                if (localPropsFile.exists()) {
                    config.logger.debug("Loading local RoboVM config properties file: "
                            + localPropsFile.getAbsolutePath());
                    try (Reader reader = new InputStreamReader(new FileInputStream(localPropsFile), "utf-8")) {
                        props.load(reader);
                    }
                }
                if (isTest) {
                    modifyPropertyForTest(props, "app.id");
                    modifyPropertyForTest(props, "app.name");
                    modifyPropertyForTest(props, "app.executable");
                }
                addProperties(props);
            }
        }

        private void modifyPropertyForTest(Properties props, String propName) {
            String propValue = props.getProperty(propName);
            if (propValue != null && !propValue.endsWith("Test")) {
                String newPropValue = propValue + "Test";
                config.logger.debug("Changing %s property from '%s' to '%s'", propName, propValue, newPropValue);
                props.setProperty(propName, newPropValue);
            }
        }

        
        public void readProjectConfig(File basedir, boolean isTest) throws IOException {
            File testConfigFile = new File(basedir, "robovm.test.xml");
            File configFile = new File(basedir, "robovm.xml");
            if (isTest && testConfigFile.exists()) {
                config.logger.debug("Loading test RoboVM config file: "
                        + testConfigFile.getAbsolutePath());
                read(testConfigFile);
            } else if (configFile.exists()) {
                config.logger.debug("Loading default RoboVM config file: "
                        + configFile.getAbsolutePath());
                read(configFile);
            }
        }

        public void read(File file) throws IOException {
            Reader reader = null;
            try {
                reader = new InputStreamReader(new FileInputStream(file), "utf-8");
                read(reader, file.getAbsoluteFile().getParentFile());
            } finally {
                IOUtils.closeQuietly(reader);
            }
        }

        public void read(Reader reader, File wd) throws IOException {
            try {
                Serializer serializer = createSerializer(wd);
                serializer.read(config, reader);
            } catch (IOException e) {
                throw e;
            } catch (RuntimeException e) {
                throw e;
            } catch (Exception e) {
                throw (IOException) new IOException().initCause(e);
            }
            
            
            
            if (config.roots != null && !config.roots.isEmpty()) {
                if (config.forceLinkClasses == null) {
                    config.forceLinkClasses = new ArrayList<String>();
                }
                config.forceLinkClasses.addAll(config.roots);
                config.roots = null;
            }
        }

        public void write(File file) throws IOException {
            Writer writer = null;
            try {
                writer = new OutputStreamWriter(new FileOutputStream(file), "utf-8");
                write(writer, file.getAbsoluteFile().getParentFile());
            } finally {
                IOUtils.closeQuietly(writer);
            }
        }

        public void write(Writer writer, File wd) throws IOException {
            try {
                Serializer serializer = createSerializer(wd);
                serializer.write(config, writer);
            } catch (IOException e) {
                throw e;
            } catch (RuntimeException e) {
                throw e;
            } catch (Exception e) {
                throw (IOException) new IOException().initCause(e);
            }
        }

        private Serializer createSerializer(final File wd) throws Exception {
            RelativeFileConverter fileConverter = new RelativeFileConverter(wd);

            Serializer resourceSerializer = new Persister(
                    new RegistryStrategy(new Registry().bind(File.class, fileConverter)),
                    new PlatformFilter(config.properties), new Format(2));

            Registry registry = new Registry();
            RegistryStrategy registryStrategy = new RegistryStrategy(registry);
            Serializer serializer = new Persister(registryStrategy,
                    new PlatformFilter(config.properties), new Format(2));

            registry.bind(File.class, fileConverter);
            registry.bind(Lib.class, new RelativeLibConverter(fileConverter));
            registry.bind(Resource.class, new ResourceConverter(fileConverter, resourceSerializer));

            return serializer;
        }

        
        public Map<String, PluginArgument> fetchPluginArguments() {
            Map<String, PluginArgument> args = new TreeMap<>();
            for (Plugin plugin : config.plugins) {
                for (PluginArgument arg : plugin.getArguments().getArguments()) {
                    args.put(plugin.getArguments().getPrefix() + ":" + arg.getName(), arg);
                }
            }
            return args;
        }

        public List<Plugin> getPlugins() {
            return config.getPlugins();
        }
    }

    public static final class Lib {
        private final String value;
        private final boolean force;

        public Lib(String value, boolean force) {
            this.value = value;
            this.force = force;
        }

        public String getValue() {
            return value;
        }

        public boolean isForce() {
            return force;
        }

        @Override
        public String toString() {
            return "Lib [value=" + value + ", force=" + force + "]";
        }

        @Override
        public int hashCode() {
            final int prime = 31;
            int result = 1;
            result = prime * result + (force ? 1231 : 1237);
            result = prime * result + ((value == null) ? 0 : value.hashCode());
            return result;
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (obj == null) {
                return false;
            }
            if (getClass() != obj.getClass()) {
                return false;
            }
            Lib other = (Lib) obj;
            if (force != other.force) {
                return false;
            }
            if (value == null) {
                if (other.value != null) {
                    return false;
                }
            } else if (!value.equals(other.value)) {
                return false;
            }
            return true;
        }
    }

    private static final class RelativeLibConverter implements Converter<Lib> {
        private final RelativeFileConverter fileConverter;

        public RelativeLibConverter(RelativeFileConverter fileConverter) {
            this.fileConverter = fileConverter;
        }

        @Override
        public Lib read(InputNode node) throws Exception {
            String value = node.getValue();
            if (value == null) {
                return null;
            }
            InputNode forceNode = node.getAttribute("force");
            boolean force = forceNode == null || Boolean.valueOf(forceNode.getValue());
            if (value.endsWith(".a") || value.endsWith(".o")) {
                return new Lib(fileConverter.read(value).getAbsolutePath(), force);
            } else {
                return new Lib(value, force);
            }
        }

        @Override
        public void write(OutputNode node, Lib lib) throws Exception {
            String value = lib.getValue();
            boolean force = lib.isForce();
            if (value.endsWith(".a") || value.endsWith(".o")) {
                fileConverter.write(node, new File(value));
            } else {
                node.setValue(value);
            }
            if (!force) {
                node.setAttribute("force", "false");
            }
        }
    }

    private static final class RelativeFileConverter implements Converter<File> {
        private final String wdPrefix;

        public RelativeFileConverter(File wd) {
            if (wd.isFile()) {
                wd = wd.getParentFile();
            }
            String prefix = wd.getAbsolutePath();
            if (prefix.endsWith(File.separator)) {
                prefix = prefix.substring(0, prefix.length() - 1);
            }
            wdPrefix = prefix;
        }

        File read(String value) {
            if (value == null) {
                return null;
            }
            File file = new File(value);
            if (!file.isAbsolute()) {
                file = new File(wdPrefix, value);
            }
            return file;
        }

        @Override
        public File read(InputNode node) throws Exception {
            return read(node.getValue());
        }

        @Override
        public void write(OutputNode node, File value) throws Exception {
            String path = value.getAbsolutePath();
            if (path.equals(wdPrefix)) {
                if ("directory".equals(node.getName())) {
                    
                    node.remove();
                } else {
                    node.setValue("");
                }
            } else if (path.startsWith(wdPrefix) && path.charAt(wdPrefix.length()) == File.separatorChar) {
                node.setValue(path.substring(wdPrefix.length() + 1));
            } else {
                node.setValue(path);
            }
        }
    }

    private static final class ResourceConverter implements Converter<Resource> {
        private final RelativeFileConverter fileConverter;
        private final Serializer serializer;

        public ResourceConverter(RelativeFileConverter fileConverter, Serializer serializer) {
            this.fileConverter = fileConverter;
            this.serializer = serializer;
        }

        @Override
        public Resource read(InputNode node) throws Exception {
            String value = node.getValue();
            if (value != null && value.trim().length() > 0) {
                return new Resource(fileConverter.read(value));
            }
            return serializer.read(Resource.class, node);
        }

        @Override
        public void write(OutputNode node, Resource resource) throws Exception {
            File path = resource.getPath();
            if (path != null) {
                fileConverter.write(node, path);
            } else {
                node.remove();
                serializer.write(resource, node.getParent());
            }
        }
    }
}

<code block>

package org.robovm.compiler.plugin.lambda2;

import static org.objectweb.asm.Opcodes.ACC_BRIDGE;
import static org.objectweb.asm.Opcodes.ACC_FINAL;
import static org.objectweb.asm.Opcodes.ACC_PRIVATE;
import static org.objectweb.asm.Opcodes.ACC_PUBLIC;
import static org.objectweb.asm.Opcodes.ACC_STATIC;
import static org.objectweb.asm.Opcodes.ACC_SUPER;
import static org.objectweb.asm.Opcodes.ACC_SYNTHETIC;
import static org.objectweb.asm.Opcodes.ALOAD;
import static org.objectweb.asm.Opcodes.ARETURN;
import static org.objectweb.asm.Opcodes.DLOAD;
import static org.objectweb.asm.Opcodes.DRETURN;
import static org.objectweb.asm.Opcodes.DUP;
import static org.objectweb.asm.Opcodes.FLOAD;
import static org.objectweb.asm.Opcodes.FRETURN;
import static org.objectweb.asm.Opcodes.GETFIELD;
import static org.objectweb.asm.Opcodes.ILOAD;
import static org.objectweb.asm.Opcodes.INVOKEINTERFACE;
import static org.objectweb.asm.Opcodes.INVOKESPECIAL;
import static org.objectweb.asm.Opcodes.INVOKESTATIC;
import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;
import static org.objectweb.asm.Opcodes.IRETURN;
import static org.objectweb.asm.Opcodes.LLOAD;
import static org.objectweb.asm.Opcodes.LRETURN;
import static org.objectweb.asm.Opcodes.NEW;
import static org.objectweb.asm.Opcodes.PUTFIELD;
import static org.objectweb.asm.Opcodes.RETURN;

import java.util.ArrayList;
import java.util.List;

import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.commons.GeneratorAdapter;
import org.robovm.compiler.CompilerException;
import org.robovm.compiler.Types;

import soot.DoubleType;
import soot.FloatType;
import soot.LongType;
import soot.PrimType;
import soot.RefType;
import soot.SootClass;
import soot.SootMethodHandle;
import soot.SootMethodRef;
import soot.SootMethodType;
import soot.Type;
import soot.VoidType;

public class LambdaClassGenerator {
    private static int CLASS_VERSION = 51;
    private int counter = 1;

    public LambdaClass generate(SootClass caller, String invokedName, SootMethodRef invokedType,
            SootMethodType samMethodType, SootMethodHandle implMethod, SootMethodType instantiatedMethodType,
            List<Type> markerInterfaces, List<SootMethodType> bridgeMethods) {
        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES);

        String lambdaClassName = caller.getName().replace('.', '/') + "$$Lambda$" + (counter++);
        String functionalInterface = invokedType.returnType().toString().replace('.', '/');

        List<String> interfaces = new ArrayList<String>();
        interfaces.add(functionalInterface);
        for (Type markerInterface : markerInterfaces) {
            interfaces.add(markerInterface.toString().replace('.', '/'));
        }

        cw.visit(CLASS_VERSION, ACC_FINAL + ACC_SUPER + ACC_SYNTHETIC, lambdaClassName, null, "java/lang/Object",
                interfaces.toArray(new String[interfaces.size()]));

        String targetMethod = "<init>";
        createFieldsAndConstructor(lambdaClassName, cw, invokedType, samMethodType, implMethod, instantiatedMethodType);

        
        
        
        
        
        
        if (!invokedType.parameterTypes().isEmpty()) {
            targetMethod = createFactory(lambdaClassName, cw, invokedType, samMethodType, implMethod,
                    instantiatedMethodType);
        }

        
        createForwardingMethod(caller, lambdaClassName, cw, invokedName, samMethodType.getParameterTypes(),
                samMethodType.getReturnType(), invokedType.parameterTypes(), samMethodType, implMethod,
                instantiatedMethodType, false);

        
        for (SootMethodType bridgeMethod : bridgeMethods) {
            createForwardingMethod(caller, lambdaClassName, cw, invokedName, bridgeMethod.getParameterTypes(),
                    bridgeMethod.getReturnType(), invokedType.parameterTypes(), samMethodType, implMethod,
                    instantiatedMethodType, true);
        }
        cw.visitEnd();

        return new LambdaClass(lambdaClassName, cw.toByteArray(), targetMethod, invokedType.parameterTypes(),
                invokedType.returnType());
    }

    private void createForwardingMethod(SootClass caller, String lambdaClassName, ClassWriter cw, String name,
            List<Type> parameters, Type returnType, List<Type> invokedParameters, SootMethodType samMethodType,
            SootMethodHandle implMethod, SootMethodType instantiatedMethodType, boolean isBridgeMethod) {
        String descriptor = Types.getDescriptor(parameters, returnType);
        String implClassName = implMethod.getMethodRef().declaringClass().getName().replace('.', '/');
        int accessFlags = ACC_PUBLIC | (isBridgeMethod ? ACC_BRIDGE : 0);
        MethodVisitor mv = cw.visitMethod(accessFlags, name, descriptor, null, null);
        mv.visitCode();

        
        
        int invokeOpCode = INVOKESTATIC;
        boolean isInstanceMethod = false;
        switch (implMethod.getReferenceKind()) {
        case SootMethodHandle.REF_invokeInterface:
            invokeOpCode = INVOKEINTERFACE;
            isInstanceMethod = true;
            break;
        case SootMethodHandle.REF_invokeSpecial:
            invokeOpCode = INVOKESPECIAL;
            isInstanceMethod = true;
            break;
        case SootMethodHandle.REF_newInvokeSpecial:
            invokeOpCode = INVOKESPECIAL;
            break;
        case SootMethodHandle.REF_invokeStatic:
            invokeOpCode = INVOKESTATIC;
            break;
        case SootMethodHandle.REF_invokeVirtual:
            invokeOpCode = INVOKEVIRTUAL;
            isInstanceMethod = true;
            break;
        default:
            throw new CompilerException("Unknown invoke type: " + implMethod.getReferenceKind());
        }

        GeneratorAdapter caster = new GeneratorAdapter(mv, accessFlags, name, descriptor);

        
        pushArguments(caller, lambdaClassName, mv, caster, parameters, invokedParameters, implMethod,
                instantiatedMethodType, isInstanceMethod);

        
        
        
        
        
        String implDescriptor = null;
        List<Type> paramTypes = new ArrayList<Type>(implMethod.getMethodType().getParameterTypes());
        if (isInstanceMethod)
            paramTypes.remove(0);
        implDescriptor = Types.getDescriptor(paramTypes, implMethod.getMethodType().getReturnType());

        
        mv.visitMethodInsn(invokeOpCode, implClassName, implMethod.getMethodRef().name(), implDescriptor,
                invokeOpCode == INVOKEINTERFACE);

        
        createForwardingMethodReturn(mv, caster, returnType, samMethodType, implMethod, instantiatedMethodType);

        mv.visitMaxs(-1, -1);
        mv.visitEnd();
    }

    private void pushArguments(SootClass caller, String lambdaClassName, MethodVisitor mv, GeneratorAdapter caster,
            List<Type> parameters, List<Type> invokedParameters, SootMethodHandle implMethod,
            SootMethodType instantiatedMethodType, boolean isInstanceMethod) {

        
        
        if (implMethod.getReferenceKind() == SootMethodHandle.REF_newInvokeSpecial) {
            mv.visitTypeInsn(NEW, implMethod.getMethodRef().declaringClass().getName().replace('.', '/'));
            mv.visitInsn(DUP);
        }

        
        for (int i = 0; i < invokedParameters.size(); i++) {
            Object obj = invokedParameters.get(i);
            Type captureType = (Type) obj;
            mv.visitVarInsn(ALOAD, 0);
            mv.visitFieldInsn(GETFIELD, lambdaClassName, "arg$" + (i + 1), Types.getDescriptor(captureType));
        }

        
        
        
        
        
        
        boolean paramsContainReceiver = isInstanceMethod
                & !caller.getName().equals(implMethod.getMethodRef().declaringClass().getName());
        int paramsIndex = 0;
        int localIndex = 1; 
                            
        if (paramsContainReceiver && !parameters.isEmpty()) {
            Type param = parameters.get(0);
            mv.visitVarInsn(loadOpcodeForType(param), localIndex);
            localIndex += slotsForType(param);
            paramsIndex++;
        }

        int samParamsOffset = implMethod.getMethodRef().parameterTypes().size() - parameters.size()
                + (paramsContainReceiver ? 1 : 0);
        for (int i = 0; paramsIndex < parameters.size(); paramsIndex++, i++) {
            Type param = parameters.get(paramsIndex);
            mv.visitVarInsn(loadOpcodeForType(param), localIndex);
            castOrWiden(mv, caster, param, (Type) implMethod.getMethodRef().parameterTypes().get(samParamsOffset + i));
            localIndex += slotsForType(param);
        }
    }

    private void castOrWiden(MethodVisitor mv, GeneratorAdapter caster, Type actual, Type expected) {
        if (actual.equals(expected)) {
            return;
        }

        if (actual.equals(VoidType.v()) || expected.equals(VoidType.v())) {
            return;
        }

        
        if ((isPrimitiveType(actual) || isBoxedType(actual))
                && ((isPrimitiveType(expected) || isBoxedType(expected)))) {

            org.objectweb.asm.Type actualAsmType = getAsmPrimitiveType(actual);
            org.objectweb.asm.Type expectedAsmType = getAsmPrimitiveType(expected);

            
            if (isBoxedType(actual)) {
                caster.unbox(actualAsmType);
            }

            
            
            caster.cast(actualAsmType, expectedAsmType);

            
            if (isBoxedType(expected)) {
                caster.box(expectedAsmType);
            }
        } else {
            
            mv.visitTypeInsn(Opcodes.CHECKCAST, ((RefType) expected).getClassName().replace('.', '/'));
        }
    }

    private org.objectweb.asm.Type getAsmPrimitiveType(Type type) {
        if (isBoxedType(type)) {
            String className = type.toString();
            if ("java.lang.Boolean".equals(className)) {
                return org.objectweb.asm.Type.BOOLEAN_TYPE;
            } else if ("java.lang.Byte".equals(className)) {
                return org.objectweb.asm.Type.BYTE_TYPE;
            } else if ("java.lang.Character".equals(className)) {
                return org.objectweb.asm.Type.CHAR_TYPE;
            } else if ("java.lang.Short".equals(className)) {
                return org.objectweb.asm.Type.SHORT_TYPE;
            } else if ("java.lang.Integer".equals(className)) {
                return org.objectweb.asm.Type.INT_TYPE;
            } else if ("java.lang.Long".equals(className)) {
                return org.objectweb.asm.Type.LONG_TYPE;
            } else if ("java.lang.Float".equals(className)) {
                return org.objectweb.asm.Type.FLOAT_TYPE;
            } else if ("java.lang.Double".equals(className)) {
                return org.objectweb.asm.Type.DOUBLE_TYPE;
            } else {
                throw new CompilerException("Unknown primitive type " + type);
            }
        } else {
            return org.objectweb.asm.Type.getType(Types.getDescriptor(type));
        }
    }

    private boolean isPrimitiveType(Type type) {
        return type instanceof PrimType;
    }

    private boolean isBoxedType(Type type) {
        String className = type.toString();
        return "java.lang.Boolean".equals(className) || "java.lang.Byte".equals(className)
                || "java.lang.Character".equals(className) || "java.lang.Short".equals(className)
                || "java.lang.Integer".equals(className) || "java.lang.Long".equals(className)
                || "java.lang.Float".equals(className) || "java.lang.Double".equals(className);
    }

    private void createForwardingMethodReturn(MethodVisitor mv, GeneratorAdapter caster, Type returnType,
            SootMethodType samMethodType, SootMethodHandle implMethod, SootMethodType instantiatedMethodType) {
        castOrWiden(mv, caster, implMethod.getMethodRef().returnType(), instantiatedMethodType.getReturnType());
        if (returnType.equals(VoidType.v())) {
            mv.visitInsn(RETURN);
        } else if (returnType instanceof PrimType) {
            if (returnType.equals(LongType.v())) {
                mv.visitInsn(LRETURN);
            } else if (returnType.equals(FloatType.v())) {
                mv.visitInsn(FRETURN);
            } else if (returnType.equals(DoubleType.v())) {
                mv.visitInsn(DRETURN);
            } else {
                mv.visitInsn(IRETURN);
            }
        } else {
            mv.visitInsn(ARETURN);
        }
    }

    private void createFieldsAndConstructor(String lambdaClassName, ClassWriter cw, SootMethodRef invokedType,
            SootMethodType samMethodType, SootMethodHandle implMethod, SootMethodType instantiatedMethodType) {
        StringBuffer constructorDescriptor = new StringBuffer();

        
        int i = 0;
        for (Object obj : invokedType.parameterTypes()) {
            Type captureType = (Type) obj;
            String typeDesc = Types.getDescriptor(captureType);
            cw.visitField(ACC_PRIVATE + ACC_FINAL, "arg$" + (i + 1), typeDesc, null, null);
            constructorDescriptor.append(typeDesc);
            i++;
        }

        
        MethodVisitor mv = cw.visitMethod(0, "<init>", "(" + constructorDescriptor.toString() + ")V", null, null);
        mv.visitCode();

        
        mv.visitVarInsn(ALOAD, 0);
        mv.visitMethodInsn(INVOKESPECIAL, "java/lang/Object", "<init>", "()V", false);

        
        i = 0;
        int localIndex = 1; 
        for (Object obj : invokedType.parameterTypes()) {
            Type captureType = (Type) obj;

            
            mv.visitVarInsn(ALOAD, 0);

            
            mv.visitVarInsn(loadOpcodeForType(captureType), localIndex);
            localIndex += slotsForType(captureType);

            
            mv.visitFieldInsn(PUTFIELD, lambdaClassName, "arg$" + (i + 1), Types.getDescriptor(captureType));

            i++;
        }

        mv.visitInsn(RETURN);
        mv.visitMaxs(-1, -1);
        mv.visitEnd();
    }

    private String createFactory(String lambdaClassName, ClassWriter cw, SootMethodRef invokedType,
            SootMethodType samMethodType, SootMethodHandle implMethod, SootMethodType instantiatedMethodType) {
        MethodVisitor mv = cw.visitMethod(ACC_STATIC, "get$Lambda",
                Types.getDescriptor(invokedType.parameterTypes(), invokedType.returnType()), null, null);
        mv.visitCode();
        mv.visitTypeInsn(NEW, lambdaClassName);
        mv.visitInsn(DUP);
        int i = 0;
        for (Object obj : invokedType.parameterTypes()) {
            Type captureType = (Type) obj;
            mv.visitVarInsn(loadOpcodeForType(captureType), i);
            i += slotsForType(captureType);
        }
        mv.visitMethodInsn(INVOKESPECIAL, lambdaClassName, "<init>",
                Types.getDescriptor(invokedType.parameterTypes(), VoidType.v()), false);
        mv.visitInsn(ARETURN);
        mv.visitMaxs(-1, -1);
        mv.visitEnd();
        return "get$Lambda";
    }

    public int loadOpcodeForType(Type type) {
        if (type instanceof PrimType) {
            if (type.equals(LongType.v())) {
                return LLOAD;
            } else if (type.equals(FloatType.v())) {
                return FLOAD;
            } else if (type.equals(DoubleType.v())) {
                return DLOAD;
            } else {
                return ILOAD;
            }
        } else {
            return ALOAD;
        }
    }

    public int slotsForType(Type type) {
        if (type.equals(LongType.v()) || type.equals(DoubleType.v())) {
            return 2;
        } else {
            return 1;
        }
    }
}

<code block>

package org.robovm.compiler.plugin.lambda2;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.apache.commons.io.FileUtils;
import org.robovm.compiler.CompilerException;
import org.robovm.compiler.ModuleBuilder;
import org.robovm.compiler.Types;
import org.robovm.compiler.clazz.Clazz;
import org.robovm.compiler.config.Config;
import org.robovm.compiler.plugin.AbstractCompilerPlugin;

import soot.Body;
import soot.Local;
import soot.Modifier;
import soot.PatchingChain;
import soot.RefType;
import soot.Scene;
import soot.SootClass;
import soot.SootField;
import soot.SootMethod;
import soot.SootMethodHandle;
import soot.SootMethodRef;
import soot.SootMethodType;
import soot.SootResolver;
import soot.Type;
import soot.Unit;
import soot.Value;
import soot.jimple.ClassConstant;
import soot.jimple.Constant;
import soot.jimple.ConstantSwitch;
import soot.jimple.DefinitionStmt;
import soot.jimple.DynamicInvokeExpr;
import soot.jimple.IntConstant;
import soot.jimple.Jimple;
import soot.jimple.NullConstant;
import soot.util.Switch;

public class LambdaPlugin extends AbstractCompilerPlugin {
    static final int BRIDGE = 0x00000040;
    static final int SYNTHETIC = 0x00001000;
    
    private static int FLAG_MARKERS = 2;
    private static int FLAG_BRIDGES = 4;

    final Map<SootClass, LambdaClassGenerator> generators = new HashMap<SootClass, LambdaClassGenerator>();

    private static boolean isLambdaBootstrapMethod(SootMethodRef methodRef) {
        return methodRef.declaringClass().getName().equals("java.lang.invoke.LambdaMetafactory")
                && (methodRef.name().equals("metafactory") || methodRef.name().equals("altMetafactory"));
    }

    @Override
    public void afterClass(Config config, Clazz clazz, ModuleBuilder moduleBuilder) throws IOException {
        synchronized (generators) {
            generators.remove(clazz.getSootClass());
        }
    }

    @Override
    public void beforeClass(Config config, Clazz clazz, ModuleBuilder moduleBuilder) throws IOException {
        SootClass sootClass = clazz.getSootClass();

        for (SootMethod method : sootClass.getMethods()) {
            transformMethod(config, clazz, sootClass, method, moduleBuilder);
        }
    }

    private void transformMethod(Config config, Clazz clazz, SootClass sootClass,
            SootMethod method, ModuleBuilder moduleBuilder) throws IOException {

        if (!method.isConcrete()) {
            return;
        }

        int tmpCounter = 0;
        Body body = method.retrieveActiveBody();
        PatchingChain<Unit> units = body.getUnits();
        for (Unit unit = units.getFirst(); unit != null; unit = body.getUnits().getSuccOf(unit)) {
            if (unit instanceof DefinitionStmt) {
                if (((DefinitionStmt) unit).getRightOp() instanceof DynamicInvokeExpr) {
                    DynamicInvokeExpr expr = (DynamicInvokeExpr) ((DefinitionStmt) unit).getRightOp();

                    if (isLambdaBootstrapMethod(expr.getBootstrapMethodRef())) {
                        LambdaClassGenerator generator = null;
                        synchronized (generators) {
                            generator = generators.get(sootClass);
                            if (generator == null) {
                                generator = new LambdaClassGenerator();
                                generators.put(sootClass, generator);
                            }
                        }

                        List<Value> bsmArgs = expr.getBootstrapArgs();
                        SootClass caller = sootClass;
                        String invokedName = expr.getMethodRef().name();
                        SootMethodRef invokedType = expr.getMethodRef();
                        SootMethodType samMethodType = (SootMethodType) bsmArgs.get(0);
                        SootMethodHandle implMethod = (SootMethodHandle) bsmArgs.get(1);
                        SootMethodType instantiatedMethodType = (SootMethodType) bsmArgs.get(2);

                        try {
                            LambdaClass callSite = null;
                            List<Type> markerInterfaces = new ArrayList<>();
                            List<SootMethodType> bridgeMethods = new ArrayList<>();
                            if (expr.getBootstrapMethodRef().name().equals("altMetafactory")) {
                                int flags = ((IntConstant) bsmArgs.get(3)).value;
                                int bsmArgsIdx = 4;
                                if ((flags & FLAG_MARKERS) > 0) {
                                    int count = ((IntConstant) bsmArgs.get(bsmArgsIdx++)).value;
                                    for (int i = 0; i < count; i++) {
                                        Object value = bsmArgs.get(bsmArgsIdx++);
                                        if (value instanceof Type) {
                                            markerInterfaces.add((Type) value);
                                        } else if (value instanceof ClassConstant) {
                                            String className = ((ClassConstant) value).getValue().replace('/', '.');
                                            markerInterfaces.add(SootResolver.v()
                                                    .resolveClass(className, SootClass.HIERARCHY).getType());
                                        }
                                    }
                                }
                                if ((flags & FLAG_BRIDGES) > 0) {
                                    int count = ((IntConstant) bsmArgs.get(bsmArgsIdx++)).value;
                                    for (int i = 0; i < count; i++) {
                                        bridgeMethods.add((SootMethodType) bsmArgs.get(bsmArgsIdx++));
                                    }
                                }
                            }
                            
                            
                            
                            
                            
                            if (bridgeMethods.size() == 0) {
                                SootClass targetType = SootResolver.v().resolveClass(
                                        invokedType.returnType().toString().replace('/', '.'), SootClass.SIGNATURES);
                                String samDescriptor = Types.getDescriptor(samMethodType.getParameterTypes(),
                                        samMethodType.getReturnType());
                                for (SootMethod targetTypeMethod : targetType.getMethods()) {
                                    boolean isBridgeMethod = targetTypeMethod.getName().equals(invokedName);
                                    isBridgeMethod &= targetTypeMethod.getName().equals(invokedName);
                                    isBridgeMethod &= targetTypeMethod.getParameterCount() == samMethodType.getParameterTypes().size();
                                    isBridgeMethod &= ((targetTypeMethod.getModifiers() & BRIDGE) != 0);
                                    isBridgeMethod &= ((targetTypeMethod.getModifiers() & SYNTHETIC) != 0);
                                    if(isBridgeMethod) {
                                        String targetTypeMethodDesc = Types.getDescriptor(targetTypeMethod);
                                        if (!targetTypeMethodDesc.equals(samDescriptor)) {
                                            bridgeMethods.add(new BridgeMethodType(targetTypeMethod.getReturnType(),
                                                    targetTypeMethod.getParameterTypes()));
                                        }
                                    }
                                }
                            }
                            
                            
                            callSite = generator.generate(caller, invokedName, invokedType, samMethodType, implMethod,
                                    instantiatedMethodType, markerInterfaces, bridgeMethods);
                            File f = clazz.getPath().getGeneratedClassFile(callSite.getLambdaClassName());
                            FileUtils.writeByteArrayToFile(f, callSite.getClassData());
                            
                            
                            
                            
                            f.setLastModified(clazz.lastModified());

                            SootClass lambdaClass = SootResolver.v()
                                    .makeClassRef(callSite.getLambdaClassName().replace('/', '.'));

                            Local l = (Local) ((DefinitionStmt) unit).getLeftOp();
                            Type samType = callSite.getTargetMethodReturnType();
                            LinkedList<Unit> newUnits = new LinkedList<>();
                            if (callSite.getTargetMethodName().equals("<init>")) {
                                
                                
                                
                                String fieldName = lambdaClass.getName()
                                        .substring(lambdaClass.getName().lastIndexOf('.') + 1);
                                SootField field = new SootField(fieldName, lambdaClass.getType(),
                                        Modifier.STATIC | Modifier.PRIVATE | Modifier.TRANSIENT
                                                | 0x1000 );
                                method.getDeclaringClass().addField(field);
                                
                                newUnits.add(
                                        Jimple.v().newAssignStmt(l, Jimple.v().newStaticFieldRef(field.makeRef())));
                                
                                newUnits.add(Jimple.v().newIfStmt(Jimple.v().newNeExpr(l, NullConstant.v()),
                                        units.getSuccOf(unit)));
                                
                                Local tmp = Jimple.v().newLocal("$tmp" + (tmpCounter++), lambdaClass.getType());
                                body.getLocals().add(tmp);
                                newUnits.add(
                                        Jimple.v().newAssignStmt(tmp, Jimple.v().newNewExpr(lambdaClass.getType())));
                                newUnits.add(Jimple.v().newInvokeStmt(Jimple.v().newSpecialInvokeExpr(tmp,
                                        Scene.v().makeConstructorRef(lambdaClass, Collections.<Type> emptyList()))));
                                
                                newUnits.add(
                                        Jimple.v().newAssignStmt(Jimple.v().newStaticFieldRef(field.makeRef()), tmp));
                                
                                newUnits.add(Jimple.v().newAssignStmt(l, tmp));
                            } else {
                                
                                
                                newUnits.add(Jimple.v().newAssignStmt(l,
                                        Jimple.v().newStaticInvokeExpr(
                                                Scene.v().makeMethodRef(lambdaClass,
                                                        callSite.getTargetMethodName(),
                                                        callSite.getTargetMethodParameters(),
                                                        samType, true),
                                                expr.getArgs())));
                            }
                            units.insertAfter(newUnits, unit);
                            units.remove(unit);
                            unit = newUnits.getLast();

                        } catch (Throwable e) {
                            
                            
                            throw new CompilerException(e);
                        }
                    }
                }
            }
        }
    }
    
    static class BridgeMethodType extends Constant implements SootMethodType {
        private static final long serialVersionUID = 1L;

        private final Type returnType;
        private final List<Type> parameterTypes;

        public BridgeMethodType(Type returnType, List<Type> parameterTypes) {
            this.returnType = returnType;
            this.parameterTypes = parameterTypes;
        }

        public Type getReturnType() {
            return returnType;
        }

        public List<Type> getParameterTypes() {
            return Collections.unmodifiableList(parameterTypes);
        }

        @Override
        public Type getType() {
            return RefType.v("java.lang.invoke.MethodType");
        }

        @Override
        public void apply(Switch sw) {
            ((ConstantSwitch) sw).defaultCase(this);
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();

            sb.append('(');
            for (Iterator<Type> it = parameterTypes.iterator(); it.hasNext();) {
                sb.append(it.next());
                if (it.hasNext()) {
                    sb.append(',');
                }
            }
            return sb.append(')').append(returnType).toString();
        }
    }
}

<code block>

package org.robovm.compiler.plugin.lambda2;

import java.util.List;

import soot.Type;

public class LambdaClass {
    private final String lambdaClassName;
    private final byte[] classData;
    private final String targetMethodName;
    private final List<Type> targetMethodParameters;
    private final Type targetMethodReturnType;

    public LambdaClass(String lambdaClassName, byte[] classData, String targetMethodName,
            List<Type> targetMethodParameters, Type targetMethodReturnType) {
        this.lambdaClassName = lambdaClassName;
        this.classData = classData;
        this.targetMethodName = targetMethodName;
        this.targetMethodParameters = targetMethodParameters;
        this.targetMethodReturnType = targetMethodReturnType;
    }

    public String getLambdaClassName() {
        return lambdaClassName;
    }

    public byte[] getClassData() {
        return classData;
    }

    public String getTargetMethodName() {
        return targetMethodName;
    }

    public List<Type> getTargetMethodParameters() {
        return targetMethodParameters;
    }

    public Type getTargetMethodReturnType() {
        return targetMethodReturnType;
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO")
@Marshaler(CGImageMetadataEnumerationOptions.Marshaler.class)
public class CGImageMetadataEnumerationOptions 
    extends CFDictionaryWrapper
     {

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImageMetadataEnumerationOptions toObject(Class<CGImageMetadataEnumerationOptions> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImageMetadataEnumerationOptions(o);
        }
        @MarshalsPointer
        public static long toNative(CGImageMetadataEnumerationOptions o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImageMetadataEnumerationOptions> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImageMetadataEnumerationOptions> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(new CGImageMetadataEnumerationOptions(o.get(i, CFDictionary.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImageMetadataEnumerationOptions> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImageMetadataEnumerationOptions i : l) {
                array.add(i.getDictionary());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    CGImageMetadataEnumerationOptions(CFDictionary data) {
        super(data);
    }
    public CGImageMetadataEnumerationOptions() {}
    

    
    public boolean has(CFString key) {
        return data.containsKey(key);
    }
    public <T extends NativeObject> T get(CFString key, Class<T> type) {
        if (has(key)) {
            return data.get(key, type);
        }
        return null;
    }
    public CGImageMetadataEnumerationOptions set(CFString key, NativeObject value) {
        data.put(key, value);
        return this;
    }
    

    
    public boolean enumeratesRecursively() {
        if (has(Keys.EnumerateRecursively())) {
            CFBoolean val = get(Keys.EnumerateRecursively(), CFBoolean.class);
            return val.booleanValue();
        }
        return false;
    }
    
    public CGImageMetadataEnumerationOptions setEnumeratesRecursively(boolean enumeratesRecursively) {
        set(Keys.EnumerateRecursively(), CFBoolean.valueOf(enumeratesRecursively));
        return this;
    }
    
    
    
    @Library("ImageIO")
    public static class Keys {
        static { Bro.bind(Keys.class); }
        
        @GlobalValue(symbol="kCGImageMetadataEnumerateRecursively", optional=true)
        public static native CFString EnumerateRecursively();
    }
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO")
@Marshaler(CGImagePropertyIPTCContactInfoData.Marshaler.class)
public class CGImagePropertyIPTCContactInfoData 
    extends CFDictionaryWrapper
     {

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyIPTCContactInfoData toObject(Class<CGImagePropertyIPTCContactInfoData> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImagePropertyIPTCContactInfoData(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyIPTCContactInfoData o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImagePropertyIPTCContactInfoData> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImagePropertyIPTCContactInfoData> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(new CGImagePropertyIPTCContactInfoData(o.get(i, CFDictionary.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImagePropertyIPTCContactInfoData> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImagePropertyIPTCContactInfoData i : l) {
                array.add(i.getDictionary());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    CGImagePropertyIPTCContactInfoData(CFDictionary data) {
        super(data);
    }
    public CGImagePropertyIPTCContactInfoData() {}
    

    
    public boolean has(CGImagePropertyIPTCContactInfo key) {
        return data.containsKey(key.value());
    }
    public <T extends NativeObject> T get(CGImagePropertyIPTCContactInfo key, Class<T> type) {
        if (has(key)) {
            return data.get(key.value(), type);
        }
        return null;
    }
    public CGImagePropertyIPTCContactInfoData set(CGImagePropertyIPTCContactInfo key, NativeObject value) {
        data.put(key.value(), value);
        return this;
    }
    
    public String getString(CGImagePropertyIPTCContactInfo property) {
        if (has(property)) {
            CFString val = get(property, CFString.class);
            return val.toString();
        }
        return null;
    }
    public double getNumber(CGImagePropertyIPTCContactInfo property) {
        if (has(property)) {
            CFNumber val = get(property, CFNumber.class);
            return val.doubleValue();
        }
        return 0;
    }
    public CGImagePropertyIPTCContactInfoData set(CGImagePropertyIPTCContactInfo property, String value) {
        set(property, new CFString(value));
        return this;
    }
    public CGImagePropertyIPTCContactInfoData set(CGImagePropertyIPTCContactInfo property, double value) {
        set(property, CFNumber.valueOf(value));
        return this;
    }
    
    
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO") @StronglyLinked
@Marshaler(CGImagePropertyOpenEXR.Marshaler.class)
public class CGImagePropertyOpenEXR 
    extends GlobalValueEnumeration<CFString>
     {

    static { Bro.bind(CGImagePropertyOpenEXR.class); }

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyOpenEXR toObject(Class<CGImagePropertyOpenEXR> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImagePropertyOpenEXR.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyOpenEXR o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImagePropertyOpenEXR> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImagePropertyOpenEXR> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(CGImagePropertyOpenEXR.valueOf(o.get(i, CFString.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImagePropertyOpenEXR> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImagePropertyOpenEXR o : l) {
                array.add(o.value());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    
    
    
    private static CGImagePropertyOpenEXR[] values = new CGImagePropertyOpenEXR[] {};
    
    CGImagePropertyOpenEXR (String getterName) {
        super(Values.class, getterName);
    }
    
    public static CGImagePropertyOpenEXR valueOf(CFString value) {
        for (CGImagePropertyOpenEXR v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImagePropertyOpenEXR.class.getName());
    }
    
    
    
    @Library("ImageIO") @StronglyLinked
    public static class Values {
    	static { Bro.bind(Values.class); }

        
    
        
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO") @StronglyLinked
@Marshaler(CGImageMetadataNamespace.Marshaler.class)
public class CGImageMetadataNamespace 
    extends GlobalValueEnumeration<CFString>
     {

    static { Bro.bind(CGImageMetadataNamespace.class); }

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImageMetadataNamespace toObject(Class<CGImageMetadataNamespace> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImageMetadataNamespace.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImageMetadataNamespace o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImageMetadataNamespace> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImageMetadataNamespace> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(CGImageMetadataNamespace.valueOf(o.get(i, CFString.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImageMetadataNamespace> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImageMetadataNamespace o : l) {
                array.add(o.value());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    
    public static final CGImageMetadataNamespace Exif = new CGImageMetadataNamespace("Exif");
    
    public static final CGImageMetadataNamespace ExifAux = new CGImageMetadataNamespace("ExifAux");
    
    public static final CGImageMetadataNamespace ExifEX = new CGImageMetadataNamespace("ExifEX");
    
    public static final CGImageMetadataNamespace DublinCore = new CGImageMetadataNamespace("DublinCore");
    
    public static final CGImageMetadataNamespace IPTCCore = new CGImageMetadataNamespace("IPTCCore");
    
    public static final CGImageMetadataNamespace Photoshop = new CGImageMetadataNamespace("Photoshop");
    
    public static final CGImageMetadataNamespace TIFF = new CGImageMetadataNamespace("TIFF");
    
    public static final CGImageMetadataNamespace XMPBasic = new CGImageMetadataNamespace("XMPBasic");
    
    public static final CGImageMetadataNamespace XMPRights = new CGImageMetadataNamespace("XMPRights");
    
    
    private static CGImageMetadataNamespace[] values = new CGImageMetadataNamespace[] {Exif, ExifAux, ExifEX, DublinCore, IPTCCore, Photoshop, TIFF, XMPBasic, XMPRights};
    
    CGImageMetadataNamespace (String getterName) {
        super(Values.class, getterName);
    }
    
    public static CGImageMetadataNamespace valueOf(CFString value) {
        for (CGImageMetadataNamespace v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImageMetadataNamespace.class.getName());
    }
    
    
    
    @Library("ImageIO") @StronglyLinked
    public static class Values {
    	static { Bro.bind(Values.class); }

        
        
        @GlobalValue(symbol="kCGImageMetadataNamespaceExif", optional=true)
        public static native CFString Exif();
        
        @GlobalValue(symbol="kCGImageMetadataNamespaceExifAux", optional=true)
        public static native CFString ExifAux();
        
        @GlobalValue(symbol="kCGImageMetadataNamespaceExifEX", optional=true)
        public static native CFString ExifEX();
        
        @GlobalValue(symbol="kCGImageMetadataNamespaceDublinCore", optional=true)
        public static native CFString DublinCore();
        
        @GlobalValue(symbol="kCGImageMetadataNamespaceIPTCCore", optional=true)
        public static native CFString IPTCCore();
        
        @GlobalValue(symbol="kCGImageMetadataNamespacePhotoshop", optional=true)
        public static native CFString Photoshop();
        
        @GlobalValue(symbol="kCGImageMetadataNamespaceTIFF", optional=true)
        public static native CFString TIFF();
        
        @GlobalValue(symbol="kCGImageMetadataNamespaceXMPBasic", optional=true)
        public static native CFString XMPBasic();
        
        @GlobalValue(symbol="kCGImageMetadataNamespaceXMPRights", optional=true)
        public static native CFString XMPRights();
        
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO") @StronglyLinked
@Marshaler(CGImagePropertyJFIF.Marshaler.class)
public class CGImagePropertyJFIF 
    extends GlobalValueEnumeration<CFString>
     {

    static { Bro.bind(CGImagePropertyJFIF.class); }

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyJFIF toObject(Class<CGImagePropertyJFIF> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImagePropertyJFIF.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyJFIF o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImagePropertyJFIF> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImagePropertyJFIF> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(CGImagePropertyJFIF.valueOf(o.get(i, CFString.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImagePropertyJFIF> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImagePropertyJFIF o : l) {
                array.add(o.value());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    
    public static final CGImagePropertyJFIF Version = new CGImagePropertyJFIF("Version");
    
    public static final CGImagePropertyJFIF XDensity = new CGImagePropertyJFIF("XDensity");
    
    public static final CGImagePropertyJFIF YDensity = new CGImagePropertyJFIF("YDensity");
    
    public static final CGImagePropertyJFIF DensityUnit = new CGImagePropertyJFIF("DensityUnit");
    
    public static final CGImagePropertyJFIF IsProgressive = new CGImagePropertyJFIF("IsProgressive");
    
    
    private static CGImagePropertyJFIF[] values = new CGImagePropertyJFIF[] {Version, XDensity, YDensity, DensityUnit, IsProgressive};
    
    CGImagePropertyJFIF (String getterName) {
        super(Values.class, getterName);
    }
    
    public static CGImagePropertyJFIF valueOf(CFString value) {
        for (CGImagePropertyJFIF v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImagePropertyJFIF.class.getName());
    }
    
    
    
    @Library("ImageIO") @StronglyLinked
    public static class Values {
    	static { Bro.bind(Values.class); }

        
        
        @GlobalValue(symbol="kCGImagePropertyJFIFVersion", optional=true)
        public static native CFString Version();
        
        @GlobalValue(symbol="kCGImagePropertyJFIFXDensity", optional=true)
        public static native CFString XDensity();
        
        @GlobalValue(symbol="kCGImagePropertyJFIFYDensity", optional=true)
        public static native CFString YDensity();
        
        @GlobalValue(symbol="kCGImagePropertyJFIFDensityUnit", optional=true)
        public static native CFString DensityUnit();
        
        @GlobalValue(symbol="kCGImagePropertyJFIFIsProgressive", optional=true)
        public static native CFString IsProgressive();
        
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO") @StronglyLinked
@Marshaler(CGImagePropertyColorModel.Marshaler.class)
public class CGImagePropertyColorModel 
    extends GlobalValueEnumeration<CFString>
     {

    static { Bro.bind(CGImagePropertyColorModel.class); }

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyColorModel toObject(Class<CGImagePropertyColorModel> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImagePropertyColorModel.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyColorModel o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImagePropertyColorModel> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImagePropertyColorModel> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(CGImagePropertyColorModel.valueOf(o.get(i, CFString.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImagePropertyColorModel> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImagePropertyColorModel o : l) {
                array.add(o.value());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    
    public static final CGImagePropertyColorModel RGB = new CGImagePropertyColorModel("RGB");
    
    public static final CGImagePropertyColorModel Gray = new CGImagePropertyColorModel("Gray");
    
    public static final CGImagePropertyColorModel CMYK = new CGImagePropertyColorModel("CMYK");
    
    public static final CGImagePropertyColorModel Lab = new CGImagePropertyColorModel("Lab");
    
    
    private static CGImagePropertyColorModel[] values = new CGImagePropertyColorModel[] {RGB, Gray, CMYK, Lab};
    
    CGImagePropertyColorModel (String getterName) {
        super(Values.class, getterName);
    }
    
    public static CGImagePropertyColorModel valueOf(CFString value) {
        for (CGImagePropertyColorModel v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImagePropertyColorModel.class.getName());
    }
    
    
    
    @Library("ImageIO") @StronglyLinked
    public static class Values {
    	static { Bro.bind(Values.class); }

        
        
        @GlobalValue(symbol="kCGImagePropertyColorModelRGB", optional=true)
        public static native CFString RGB();
        
        @GlobalValue(symbol="kCGImagePropertyColorModelGray", optional=true)
        public static native CFString Gray();
        
        @GlobalValue(symbol="kCGImagePropertyColorModelCMYK", optional=true)
        public static native CFString CMYK();
        
        @GlobalValue(symbol="kCGImagePropertyColorModelLab", optional=true)
        public static native CFString Lab();
        
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO") @StronglyLinked
@Marshaler(CGImagePropertyExifAux.Marshaler.class)
public class CGImagePropertyExifAux 
    extends GlobalValueEnumeration<CFString>
     {

    static { Bro.bind(CGImagePropertyExifAux.class); }

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyExifAux toObject(Class<CGImagePropertyExifAux> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImagePropertyExifAux.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyExifAux o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImagePropertyExifAux> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImagePropertyExifAux> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(CGImagePropertyExifAux.valueOf(o.get(i, CFString.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImagePropertyExifAux> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImagePropertyExifAux o : l) {
                array.add(o.value());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    
    public static final CGImagePropertyExifAux LensInfo = new CGImagePropertyExifAux("LensInfo");
    
    public static final CGImagePropertyExifAux LensModel = new CGImagePropertyExifAux("LensModel");
    
    public static final CGImagePropertyExifAux SerialNumber = new CGImagePropertyExifAux("SerialNumber");
    
    public static final CGImagePropertyExifAux LensID = new CGImagePropertyExifAux("LensID");
    
    public static final CGImagePropertyExifAux LensSerialNumber = new CGImagePropertyExifAux("LensSerialNumber");
    
    public static final CGImagePropertyExifAux ImageNumber = new CGImagePropertyExifAux("ImageNumber");
    
    public static final CGImagePropertyExifAux FlashCompensation = new CGImagePropertyExifAux("FlashCompensation");
    
    public static final CGImagePropertyExifAux OwnerName = new CGImagePropertyExifAux("OwnerName");
    
    public static final CGImagePropertyExifAux Firmware = new CGImagePropertyExifAux("Firmware");
    
    
    private static CGImagePropertyExifAux[] values = new CGImagePropertyExifAux[] {LensInfo, LensModel, SerialNumber, LensID, LensSerialNumber, ImageNumber, FlashCompensation, OwnerName, Firmware};
    
    CGImagePropertyExifAux (String getterName) {
        super(Values.class, getterName);
    }
    
    public static CGImagePropertyExifAux valueOf(CFString value) {
        for (CGImagePropertyExifAux v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImagePropertyExifAux.class.getName());
    }
    
    
    
    @Library("ImageIO") @StronglyLinked
    public static class Values {
    	static { Bro.bind(Values.class); }

        
        
        @GlobalValue(symbol="kCGImagePropertyExifAuxLensInfo", optional=true)
        public static native CFString LensInfo();
        
        @GlobalValue(symbol="kCGImagePropertyExifAuxLensModel", optional=true)
        public static native CFString LensModel();
        
        @GlobalValue(symbol="kCGImagePropertyExifAuxSerialNumber", optional=true)
        public static native CFString SerialNumber();
        
        @GlobalValue(symbol="kCGImagePropertyExifAuxLensID", optional=true)
        public static native CFString LensID();
        
        @GlobalValue(symbol="kCGImagePropertyExifAuxLensSerialNumber", optional=true)
        public static native CFString LensSerialNumber();
        
        @GlobalValue(symbol="kCGImagePropertyExifAuxImageNumber", optional=true)
        public static native CFString ImageNumber();
        
        @GlobalValue(symbol="kCGImagePropertyExifAuxFlashCompensation", optional=true)
        public static native CFString FlashCompensation();
        
        @GlobalValue(symbol="kCGImagePropertyExifAuxOwnerName", optional=true)
        public static native CFString OwnerName();
        
        @GlobalValue(symbol="kCGImagePropertyExifAuxFirmware", optional=true)
        public static native CFString Firmware();
        
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO") @StronglyLinked
@Marshaler(CGImagePropertyCIFF.Marshaler.class)
public class CGImagePropertyCIFF 
    extends GlobalValueEnumeration<CFString>
     {

    static { Bro.bind(CGImagePropertyCIFF.class); }

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyCIFF toObject(Class<CGImagePropertyCIFF> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImagePropertyCIFF.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyCIFF o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImagePropertyCIFF> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImagePropertyCIFF> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(CGImagePropertyCIFF.valueOf(o.get(i, CFString.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImagePropertyCIFF> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImagePropertyCIFF o : l) {
                array.add(o.value());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    
    public static final CGImagePropertyCIFF Description = new CGImagePropertyCIFF("Description");
    
    public static final CGImagePropertyCIFF Firmware = new CGImagePropertyCIFF("Firmware");
    
    public static final CGImagePropertyCIFF OwnerName = new CGImagePropertyCIFF("OwnerName");
    
    public static final CGImagePropertyCIFF ImageName = new CGImagePropertyCIFF("ImageName");
    
    public static final CGImagePropertyCIFF ImageFileName = new CGImagePropertyCIFF("ImageFileName");
    
    public static final CGImagePropertyCIFF ReleaseMethod = new CGImagePropertyCIFF("ReleaseMethod");
    
    public static final CGImagePropertyCIFF ReleaseTiming = new CGImagePropertyCIFF("ReleaseTiming");
    
    public static final CGImagePropertyCIFF RecordID = new CGImagePropertyCIFF("RecordID");
    
    public static final CGImagePropertyCIFF SelfTimingTime = new CGImagePropertyCIFF("SelfTimingTime");
    
    public static final CGImagePropertyCIFF CameraSerialNumber = new CGImagePropertyCIFF("CameraSerialNumber");
    
    public static final CGImagePropertyCIFF ImageSerialNumber = new CGImagePropertyCIFF("ImageSerialNumber");
    
    public static final CGImagePropertyCIFF ContinuousDrive = new CGImagePropertyCIFF("ContinuousDrive");
    
    public static final CGImagePropertyCIFF FocusMode = new CGImagePropertyCIFF("FocusMode");
    
    public static final CGImagePropertyCIFF MeteringMode = new CGImagePropertyCIFF("MeteringMode");
    
    public static final CGImagePropertyCIFF ShootingMode = new CGImagePropertyCIFF("ShootingMode");
    
    public static final CGImagePropertyCIFF LensModel = new CGImagePropertyCIFF("LensModel");
    
    public static final CGImagePropertyCIFF LensMaxMM = new CGImagePropertyCIFF("LensMaxMM");
    
    public static final CGImagePropertyCIFF LensMinMM = new CGImagePropertyCIFF("LensMinMM");
    
    public static final CGImagePropertyCIFF WhiteBalanceIndex = new CGImagePropertyCIFF("WhiteBalanceIndex");
    
    public static final CGImagePropertyCIFF FlashExposureComp = new CGImagePropertyCIFF("FlashExposureComp");
    
    public static final CGImagePropertyCIFF MeasuredEV = new CGImagePropertyCIFF("MeasuredEV");
    
    
    private static CGImagePropertyCIFF[] values = new CGImagePropertyCIFF[] {Description, Firmware, OwnerName, ImageName, ImageFileName, ReleaseMethod, ReleaseTiming, RecordID, SelfTimingTime, CameraSerialNumber, ImageSerialNumber, ContinuousDrive, FocusMode, MeteringMode, ShootingMode, LensModel, LensMaxMM, LensMinMM, WhiteBalanceIndex, FlashExposureComp, MeasuredEV};
    
    CGImagePropertyCIFF (String getterName) {
        super(Values.class, getterName);
    }
    
    public static CGImagePropertyCIFF valueOf(CFString value) {
        for (CGImagePropertyCIFF v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImagePropertyCIFF.class.getName());
    }
    
    
    
    @Library("ImageIO") @StronglyLinked
    public static class Values {
    	static { Bro.bind(Values.class); }

        
        
        @GlobalValue(symbol="kCGImagePropertyCIFFDescription", optional=true)
        public static native CFString Description();
        
        @GlobalValue(symbol="kCGImagePropertyCIFFFirmware", optional=true)
        public static native CFString Firmware();
        
        @GlobalValue(symbol="kCGImagePropertyCIFFOwnerName", optional=true)
        public static native CFString OwnerName();
        
        @GlobalValue(symbol="kCGImagePropertyCIFFImageName", optional=true)
        public static native CFString ImageName();
        
        @GlobalValue(symbol="kCGImagePropertyCIFFImageFileName", optional=true)
        public static native CFString ImageFileName();
        
        @GlobalValue(symbol="kCGImagePropertyCIFFReleaseMethod", optional=true)
        public static native CFString ReleaseMethod();
        
        @GlobalValue(symbol="kCGImagePropertyCIFFReleaseTiming", optional=true)
        public static native CFString ReleaseTiming();
        
        @GlobalValue(symbol="kCGImagePropertyCIFFRecordID", optional=true)
        public static native CFString RecordID();
        
        @GlobalValue(symbol="kCGImagePropertyCIFFSelfTimingTime", optional=true)
        public static native CFString SelfTimingTime();
        
        @GlobalValue(symbol="kCGImagePropertyCIFFCameraSerialNumber", optional=true)
        public static native CFString CameraSerialNumber();
        
        @GlobalValue(symbol="kCGImagePropertyCIFFImageSerialNumber", optional=true)
        public static native CFString ImageSerialNumber();
        
        @GlobalValue(symbol="kCGImagePropertyCIFFContinuousDrive", optional=true)
        public static native CFString ContinuousDrive();
        
        @GlobalValue(symbol="kCGImagePropertyCIFFFocusMode", optional=true)
        public static native CFString FocusMode();
        
        @GlobalValue(symbol="kCGImagePropertyCIFFMeteringMode", optional=true)
        public static native CFString MeteringMode();
        
        @GlobalValue(symbol="kCGImagePropertyCIFFShootingMode", optional=true)
        public static native CFString ShootingMode();
        
        @GlobalValue(symbol="kCGImagePropertyCIFFLensModel", optional=true)
        public static native CFString LensModel();
        
        @GlobalValue(symbol="kCGImagePropertyCIFFLensMaxMM", optional=true)
        public static native CFString LensMaxMM();
        
        @GlobalValue(symbol="kCGImagePropertyCIFFLensMinMM", optional=true)
        public static native CFString LensMinMM();
        
        @GlobalValue(symbol="kCGImagePropertyCIFFWhiteBalanceIndex", optional=true)
        public static native CFString WhiteBalanceIndex();
        
        @GlobalValue(symbol="kCGImagePropertyCIFFFlashExposureComp", optional=true)
        public static native CFString FlashExposureComp();
        
        @GlobalValue(symbol="kCGImagePropertyCIFFMeasuredEV", optional=true)
        public static native CFString MeasuredEV();
        
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO")
@Marshaler(CGImageProperties.Marshaler.class)
public class CGImageProperties 
    extends CFDictionaryWrapper
     {

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImageProperties toObject(Class<CGImageProperties> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImageProperties(o);
        }
        @MarshalsPointer
        public static long toNative(CGImageProperties o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImageProperties> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImageProperties> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(new CGImageProperties(o.get(i, CFDictionary.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImageProperties> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImageProperties i : l) {
                array.add(i.getDictionary());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    public CGImageProperties(CFDictionary data) {
        super(data);
    }
    public CGImageProperties() {}
    

    
    public boolean has(CFString key) {
        return data.containsKey(key);
    }
    public <T extends NativeObject> T get(CFString key, Class<T> type) {
        if (has(key)) {
            return data.get(key, type);
        }
        return null;
    }
    public CGImageProperties set(CFString key, NativeObject value) {
        data.put(key, value);
        return this;
    }
    

    
    public CGImagePropertyTIFFData getTIFFData() {
        if (has(Keys.TIFFDictionary())) {
            CFDictionary val = get(Keys.TIFFDictionary(), CFDictionary.class);
            return new CGImagePropertyTIFFData(val);
        }
        return null;
    }
    
    public CGImageProperties setTIFFData(CGImagePropertyTIFFData tIFFData) {
        set(Keys.TIFFDictionary(), tIFFData.getDictionary());
        return this;
    }
    
    public CGImagePropertyGIFData getGIFData() {
        if (has(Keys.GIFDictionary())) {
            CFDictionary val = get(Keys.GIFDictionary(), CFDictionary.class);
            return new CGImagePropertyGIFData(val);
        }
        return null;
    }
    
    public CGImageProperties setGIFData(CGImagePropertyGIFData gIFData) {
        set(Keys.GIFDictionary(), gIFData.getDictionary());
        return this;
    }
    
    public CGImagePropertyJFIFData getJFIFData() {
        if (has(Keys.JFIFDictionary())) {
            CFDictionary val = get(Keys.JFIFDictionary(), CFDictionary.class);
            return new CGImagePropertyJFIFData(val);
        }
        return null;
    }
    
    public CGImageProperties setJFIFData(CGImagePropertyJFIFData jFIFData) {
        set(Keys.JFIFDictionary(), jFIFData.getDictionary());
        return this;
    }
    
    public CGImagePropertyExifData getExifData() {
        if (has(Keys.ExifDictionary())) {
            CFDictionary val = get(Keys.ExifDictionary(), CFDictionary.class);
            return new CGImagePropertyExifData(val);
        }
        return null;
    }
    
    public CGImageProperties setExifData(CGImagePropertyExifData exifData) {
        set(Keys.ExifDictionary(), exifData.getDictionary());
        return this;
    }
    
    public CGImagePropertyPNGData getPNGData() {
        if (has(Keys.PNGDictionary())) {
            CFDictionary val = get(Keys.PNGDictionary(), CFDictionary.class);
            return new CGImagePropertyPNGData(val);
        }
        return null;
    }
    
    public CGImageProperties setPNGData(CGImagePropertyPNGData pNGData) {
        set(Keys.PNGDictionary(), pNGData.getDictionary());
        return this;
    }
    
    public CGImagePropertyIPTCData getIPTCData() {
        if (has(Keys.IPTCDictionary())) {
            CFDictionary val = get(Keys.IPTCDictionary(), CFDictionary.class);
            return new CGImagePropertyIPTCData(val);
        }
        return null;
    }
    
    public CGImageProperties setIPTCData(CGImagePropertyIPTCData iPTCData) {
        set(Keys.IPTCDictionary(), iPTCData.getDictionary());
        return this;
    }
    
    public CGImagePropertyGPSData getGPSData() {
        if (has(Keys.GPSDictionary())) {
            CFDictionary val = get(Keys.GPSDictionary(), CFDictionary.class);
            return new CGImagePropertyGPSData(val);
        }
        return null;
    }
    
    public CGImageProperties setGPSData(CGImagePropertyGPSData gPSData) {
        set(Keys.GPSDictionary(), gPSData.getDictionary());
        return this;
    }
    
    public CFDictionary getRawData() {
        if (has(Keys.RawDictionary())) {
            CFDictionary val = get(Keys.RawDictionary(), CFDictionary.class);
            return val;
        }
        return null;
    }
    
    public CGImageProperties setRawData(CFDictionary rawData) {
        set(Keys.RawDictionary(), rawData);
        return this;
    }
    
    public CGImagePropertyCIFFData getCIFFData() {
        if (has(Keys.CIFFDictionary())) {
            CFDictionary val = get(Keys.CIFFDictionary(), CFDictionary.class);
            return new CGImagePropertyCIFFData(val);
        }
        return null;
    }
    
    public CGImageProperties setCIFFData(CGImagePropertyCIFFData cIFFData) {
        set(Keys.CIFFDictionary(), cIFFData.getDictionary());
        return this;
    }
    
    public CGImagePropertyCanonData getMakerCanonData() {
        if (has(Keys.MakerCanonDictionary())) {
            CFDictionary val = get(Keys.MakerCanonDictionary(), CFDictionary.class);
            return new CGImagePropertyCanonData(val);
        }
        return null;
    }
    
    public CGImageProperties setMakerCanonData(CGImagePropertyCanonData makerCanonData) {
        set(Keys.MakerCanonDictionary(), makerCanonData.getDictionary());
        return this;
    }
    
    public CGImagePropertyNikonData getMakerNikonData() {
        if (has(Keys.MakerNikonDictionary())) {
            CFDictionary val = get(Keys.MakerNikonDictionary(), CFDictionary.class);
            return new CGImagePropertyNikonData(val);
        }
        return null;
    }
    
    public CGImageProperties setMakerNikonData(CGImagePropertyNikonData makerNikonData) {
        set(Keys.MakerNikonDictionary(), makerNikonData.getDictionary());
        return this;
    }
    
    public CFDictionary getMakerMinoltaData() {
        if (has(Keys.MakerMinoltaDictionary())) {
            CFDictionary val = get(Keys.MakerMinoltaDictionary(), CFDictionary.class);
            return val;
        }
        return null;
    }
    
    public CGImageProperties setMakerMinoltaData(CFDictionary makerMinoltaData) {
        set(Keys.MakerMinoltaDictionary(), makerMinoltaData);
        return this;
    }
    
    public CFDictionary getMakerFujiData() {
        if (has(Keys.MakerFujiDictionary())) {
            CFDictionary val = get(Keys.MakerFujiDictionary(), CFDictionary.class);
            return val;
        }
        return null;
    }
    
    public CGImageProperties setMakerFujiData(CFDictionary makerFujiData) {
        set(Keys.MakerFujiDictionary(), makerFujiData);
        return this;
    }
    
    public CFDictionary getMakerOlympusData() {
        if (has(Keys.MakerOlympusDictionary())) {
            CFDictionary val = get(Keys.MakerOlympusDictionary(), CFDictionary.class);
            return val;
        }
        return null;
    }
    
    public CGImageProperties setMakerOlympusData(CFDictionary makerOlympusData) {
        set(Keys.MakerOlympusDictionary(), makerOlympusData);
        return this;
    }
    
    public CFDictionary getMakerPentaxData() {
        if (has(Keys.MakerPentaxDictionary())) {
            CFDictionary val = get(Keys.MakerPentaxDictionary(), CFDictionary.class);
            return val;
        }
        return null;
    }
    
    public CGImageProperties setMakerPentaxData(CFDictionary makerPentaxData) {
        set(Keys.MakerPentaxDictionary(), makerPentaxData);
        return this;
    }
    
    public CGImageProperty8BIMData getData() {
        if (has(Keys._8BIMDictionary())) {
            CFDictionary val = get(Keys._8BIMDictionary(), CFDictionary.class);
            return new CGImageProperty8BIMData(val);
        }
        return null;
    }
    
    public CGImageProperties set8BIMData(CGImageProperty8BIMData data) {
        set(Keys._8BIMDictionary(), data.getDictionary());
        return this;
    }
    
    public CGImagePropertyDNGData getDNGData() {
        if (has(Keys.DNGDictionary())) {
            CFDictionary val = get(Keys.DNGDictionary(), CFDictionary.class);
            return new CGImagePropertyDNGData(val);
        }
        return null;
    }
    
    public CGImageProperties setDNGData(CGImagePropertyDNGData dNGData) {
        set(Keys.DNGDictionary(), dNGData.getDictionary());
        return this;
    }
    
    public CGImagePropertyExifAuxData getExifAuxData() {
        if (has(Keys.ExifAuxDictionary())) {
            CFDictionary val = get(Keys.ExifAuxDictionary(), CFDictionary.class);
            return new CGImagePropertyExifAuxData(val);
        }
        return null;
    }
    
    public CGImageProperties setExifAuxData(CGImagePropertyExifAuxData exifAuxData) {
        set(Keys.ExifAuxDictionary(), exifAuxData.getDictionary());
        return this;
    }
    
    public long getFileSize() {
        if (has(Keys.FileSize())) {
            CFNumber val = get(Keys.FileSize(), CFNumber.class);
            return val.longValue();
        }
        return 0;
    }
    
    public CGImageProperties setFileSize(long fileSize) {
        set(Keys.FileSize(), CFNumber.valueOf(fileSize));
        return this;
    }
    
    public long getPixelHeight() {
        if (has(Keys.PixelHeight())) {
            CFNumber val = get(Keys.PixelHeight(), CFNumber.class);
            return val.longValue();
        }
        return 0;
    }
    
    public CGImageProperties setPixelHeight(long pixelHeight) {
        set(Keys.PixelHeight(), CFNumber.valueOf(pixelHeight));
        return this;
    }
    
    public long getPixelWidth() {
        if (has(Keys.PixelWidth())) {
            CFNumber val = get(Keys.PixelWidth(), CFNumber.class);
            return val.longValue();
        }
        return 0;
    }
    
    public CGImageProperties setPixelWidth(long pixelWidth) {
        set(Keys.PixelWidth(), CFNumber.valueOf(pixelWidth));
        return this;
    }
    
    public long getDPIHeight() {
        if (has(Keys.DPIHeight())) {
            CFNumber val = get(Keys.DPIHeight(), CFNumber.class);
            return val.longValue();
        }
        return 0;
    }
    
    public CGImageProperties setDPIHeight(long dPIHeight) {
        set(Keys.DPIHeight(), CFNumber.valueOf(dPIHeight));
        return this;
    }
    
    public long getDPIWidth() {
        if (has(Keys.DPIWidth())) {
            CFNumber val = get(Keys.DPIWidth(), CFNumber.class);
            return val.longValue();
        }
        return 0;
    }
    
    public CGImageProperties setDPIWidth(long dPIWidth) {
        set(Keys.DPIWidth(), CFNumber.valueOf(dPIWidth));
        return this;
    }
    
    public int getDepth() {
        if (has(Keys.Depth())) {
            CFNumber val = get(Keys.Depth(), CFNumber.class);
            return val.intValue();
        }
        return 0;
    }
    
    public CGImageProperties setDepth(int depth) {
        set(Keys.Depth(), CFNumber.valueOf(depth));
        return this;
    }
    
    public CGImagePropertyOrientation getOrientation() {
        if (has(Keys.Orientation())) {
            CFNumber val = get(Keys.Orientation(), CFNumber.class);
            return CGImagePropertyOrientation.valueOf(val.longValue());
        }
        return null;
    }
    
    public CGImageProperties setOrientation(CGImagePropertyOrientation orientation) {
        set(Keys.Orientation(), CFNumber.valueOf(orientation.value()));
        return this;
    }
    
    public boolean containsFloatingPointPixels() {
        if (has(Keys.IsFloat())) {
            CFBoolean val = get(Keys.IsFloat(), CFBoolean.class);
            return val.booleanValue();
        }
        return false;
    }
    
    public CGImageProperties setContainsFloatingPointPixels(boolean containsFloatingPointPixels) {
        set(Keys.IsFloat(), CFBoolean.valueOf(containsFloatingPointPixels));
        return this;
    }
    
    public boolean isIndexed() {
        if (has(Keys.IsIndexed())) {
            CFBoolean val = get(Keys.IsIndexed(), CFBoolean.class);
            return val.booleanValue();
        }
        return false;
    }
    
    public CGImageProperties setIsIndexed(boolean isIndexed) {
        set(Keys.IsIndexed(), CFBoolean.valueOf(isIndexed));
        return this;
    }
    
    public boolean hasAlphaChannel() {
        if (has(Keys.HasAlpha())) {
            CFBoolean val = get(Keys.HasAlpha(), CFBoolean.class);
            return val.booleanValue();
        }
        return false;
    }
    
    public CGImageProperties setHasAlphaChannel(boolean hasAlphaChannel) {
        set(Keys.HasAlpha(), CFBoolean.valueOf(hasAlphaChannel));
        return this;
    }
    
    public CGImagePropertyColorModel getColorModel() {
        if (has(Keys.ColorModel())) {
            CFString val = get(Keys.ColorModel(), CFString.class);
            return CGImagePropertyColorModel.valueOf(val);
        }
        return null;
    }
    
    public CGImageProperties setColorModel(CGImagePropertyColorModel colorModel) {
        set(Keys.ColorModel(), colorModel.value());
        return this;
    }
    
    public String getICCProfile() {
        if (has(Keys.ProfileName())) {
            CFString val = get(Keys.ProfileName(), CFString.class);
            return val.toString();
        }
        return null;
    }
    
    public CGImageProperties setICCProfile(String iCCProfile) {
        set(Keys.ProfileName(), new CFString(iCCProfile));
        return this;
    }
    
    
    
    @Library("ImageIO")
    public static class Keys {
        static { Bro.bind(Keys.class); }
        
        @GlobalValue(symbol="kCGImagePropertyTIFFDictionary", optional=true)
        public static native CFString TIFFDictionary();
        
        @GlobalValue(symbol="kCGImagePropertyGIFDictionary", optional=true)
        public static native CFString GIFDictionary();
        
        @GlobalValue(symbol="kCGImagePropertyJFIFDictionary", optional=true)
        public static native CFString JFIFDictionary();
        
        @GlobalValue(symbol="kCGImagePropertyExifDictionary", optional=true)
        public static native CFString ExifDictionary();
        
        @GlobalValue(symbol="kCGImagePropertyPNGDictionary", optional=true)
        public static native CFString PNGDictionary();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCDictionary", optional=true)
        public static native CFString IPTCDictionary();
        
        @GlobalValue(symbol="kCGImagePropertyGPSDictionary", optional=true)
        public static native CFString GPSDictionary();
        
        @GlobalValue(symbol="kCGImagePropertyRawDictionary", optional=true)
        public static native CFString RawDictionary();
        
        @GlobalValue(symbol="kCGImagePropertyCIFFDictionary", optional=true)
        public static native CFString CIFFDictionary();
        
        @GlobalValue(symbol="kCGImagePropertyMakerCanonDictionary", optional=true)
        public static native CFString MakerCanonDictionary();
        
        @GlobalValue(symbol="kCGImagePropertyMakerNikonDictionary", optional=true)
        public static native CFString MakerNikonDictionary();
        
        @GlobalValue(symbol="kCGImagePropertyMakerMinoltaDictionary", optional=true)
        public static native CFString MakerMinoltaDictionary();
        
        @GlobalValue(symbol="kCGImagePropertyMakerFujiDictionary", optional=true)
        public static native CFString MakerFujiDictionary();
        
        @GlobalValue(symbol="kCGImagePropertyMakerOlympusDictionary", optional=true)
        public static native CFString MakerOlympusDictionary();
        
        @GlobalValue(symbol="kCGImagePropertyMakerPentaxDictionary", optional=true)
        public static native CFString MakerPentaxDictionary();
        
        @GlobalValue(symbol="kCGImageProperty8BIMDictionary", optional=true)
        public static native CFString _8BIMDictionary();
        
        @GlobalValue(symbol="kCGImagePropertyDNGDictionary", optional=true)
        public static native CFString DNGDictionary();
        
        @GlobalValue(symbol="kCGImagePropertyExifAuxDictionary", optional=true)
        public static native CFString ExifAuxDictionary();
        
        @GlobalValue(symbol="kCGImagePropertyMakerAppleDictionary", optional=true)
        public static native CFString MakerAppleDictionary();
        
        @GlobalValue(symbol="kCGImagePropertyFileSize", optional=true)
        public static native CFString FileSize();
        
        @GlobalValue(symbol="kCGImagePropertyPixelHeight", optional=true)
        public static native CFString PixelHeight();
        
        @GlobalValue(symbol="kCGImagePropertyPixelWidth", optional=true)
        public static native CFString PixelWidth();
        
        @GlobalValue(symbol="kCGImagePropertyDPIHeight", optional=true)
        public static native CFString DPIHeight();
        
        @GlobalValue(symbol="kCGImagePropertyDPIWidth", optional=true)
        public static native CFString DPIWidth();
        
        @GlobalValue(symbol="kCGImagePropertyDepth", optional=true)
        public static native CFString Depth();
        
        @GlobalValue(symbol="kCGImagePropertyOrientation", optional=true)
        public static native CFString Orientation();
        
        @GlobalValue(symbol="kCGImagePropertyIsFloat", optional=true)
        public static native CFString IsFloat();
        
        @GlobalValue(symbol="kCGImagePropertyIsIndexed", optional=true)
        public static native CFString IsIndexed();
        
        @GlobalValue(symbol="kCGImagePropertyHasAlpha", optional=true)
        public static native CFString HasAlpha();
        
        @GlobalValue(symbol="kCGImagePropertyColorModel", optional=true)
        public static native CFString ColorModel();
        
        @GlobalValue(symbol="kCGImagePropertyProfileName", optional=true)
        public static native CFString ProfileName();
    }
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO")
@Marshaler(CGImagePropertyPNGData.Marshaler.class)
public class CGImagePropertyPNGData 
    extends CFDictionaryWrapper
     {

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyPNGData toObject(Class<CGImagePropertyPNGData> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImagePropertyPNGData(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyPNGData o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImagePropertyPNGData> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImagePropertyPNGData> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(new CGImagePropertyPNGData(o.get(i, CFDictionary.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImagePropertyPNGData> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImagePropertyPNGData i : l) {
                array.add(i.getDictionary());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    CGImagePropertyPNGData(CFDictionary data) {
        super(data);
    }
    public CGImagePropertyPNGData() {}
    

    
    public boolean has(CGImagePropertyPNG key) {
        return data.containsKey(key.value());
    }
    public <T extends NativeObject> T get(CGImagePropertyPNG key, Class<T> type) {
        if (has(key)) {
            return data.get(key.value(), type);
        }
        return null;
    }
    public CGImagePropertyPNGData set(CGImagePropertyPNG key, NativeObject value) {
        data.put(key.value(), value);
        return this;
    }
    
    public String getString(CGImagePropertyPNG property) {
        if (has(property)) {
            CFString val = get(property, CFString.class);
            return val.toString();
        }
        return null;
    }
    public double getNumber(CGImagePropertyPNG property) {
        if (has(property)) {
            CFNumber val = get(property, CFNumber.class);
            return val.doubleValue();
        }
        return 0;
    }
    public CGImagePropertyPNGData set(CGImagePropertyPNG property, String value) {
        set(property, new CFString(value));
        return this;
    }
    public CGImagePropertyPNGData set(CGImagePropertyPNG property, double value) {
        set(property, CFNumber.valueOf(value));
        return this;
    }
    
    
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO") @StronglyLinked
@Marshaler(CGImagePropertyIPTC.Marshaler.class)
public class CGImagePropertyIPTC 
    extends GlobalValueEnumeration<CFString>
     {

    static { Bro.bind(CGImagePropertyIPTC.class); }

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyIPTC toObject(Class<CGImagePropertyIPTC> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImagePropertyIPTC.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyIPTC o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImagePropertyIPTC> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImagePropertyIPTC> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(CGImagePropertyIPTC.valueOf(o.get(i, CFString.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImagePropertyIPTC> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImagePropertyIPTC o : l) {
                array.add(o.value());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    
    public static final CGImagePropertyIPTC ObjectTypeReference = new CGImagePropertyIPTC("ObjectTypeReference");
    
    public static final CGImagePropertyIPTC ObjectAttributeReference = new CGImagePropertyIPTC("ObjectAttributeReference");
    
    public static final CGImagePropertyIPTC ObjectName = new CGImagePropertyIPTC("ObjectName");
    
    public static final CGImagePropertyIPTC EditStatus = new CGImagePropertyIPTC("EditStatus");
    
    public static final CGImagePropertyIPTC EditorialUpdate = new CGImagePropertyIPTC("EditorialUpdate");
    
    public static final CGImagePropertyIPTC Urgency = new CGImagePropertyIPTC("Urgency");
    
    public static final CGImagePropertyIPTC SubjectReference = new CGImagePropertyIPTC("SubjectReference");
    
    public static final CGImagePropertyIPTC Category = new CGImagePropertyIPTC("Category");
    
    public static final CGImagePropertyIPTC SupplementalCategory = new CGImagePropertyIPTC("SupplementalCategory");
    
    public static final CGImagePropertyIPTC FixtureIdentifier = new CGImagePropertyIPTC("FixtureIdentifier");
    
    public static final CGImagePropertyIPTC Keywords = new CGImagePropertyIPTC("Keywords");
    
    public static final CGImagePropertyIPTC ContentLocationCode = new CGImagePropertyIPTC("ContentLocationCode");
    
    public static final CGImagePropertyIPTC ContentLocationName = new CGImagePropertyIPTC("ContentLocationName");
    
    public static final CGImagePropertyIPTC ReleaseDate = new CGImagePropertyIPTC("ReleaseDate");
    
    public static final CGImagePropertyIPTC ReleaseTime = new CGImagePropertyIPTC("ReleaseTime");
    
    public static final CGImagePropertyIPTC ExpirationDate = new CGImagePropertyIPTC("ExpirationDate");
    
    public static final CGImagePropertyIPTC ExpirationTime = new CGImagePropertyIPTC("ExpirationTime");
    
    public static final CGImagePropertyIPTC SpecialInstructions = new CGImagePropertyIPTC("SpecialInstructions");
    
    public static final CGImagePropertyIPTC ActionAdvised = new CGImagePropertyIPTC("ActionAdvised");
    
    public static final CGImagePropertyIPTC ReferenceService = new CGImagePropertyIPTC("ReferenceService");
    
    public static final CGImagePropertyIPTC ReferenceDate = new CGImagePropertyIPTC("ReferenceDate");
    
    public static final CGImagePropertyIPTC ReferenceNumber = new CGImagePropertyIPTC("ReferenceNumber");
    
    public static final CGImagePropertyIPTC DateCreated = new CGImagePropertyIPTC("DateCreated");
    
    public static final CGImagePropertyIPTC TimeCreated = new CGImagePropertyIPTC("TimeCreated");
    
    public static final CGImagePropertyIPTC DigitalCreationDate = new CGImagePropertyIPTC("DigitalCreationDate");
    
    public static final CGImagePropertyIPTC DigitalCreationTime = new CGImagePropertyIPTC("DigitalCreationTime");
    
    public static final CGImagePropertyIPTC OriginatingProgram = new CGImagePropertyIPTC("OriginatingProgram");
    
    public static final CGImagePropertyIPTC ProgramVersion = new CGImagePropertyIPTC("ProgramVersion");
    
    public static final CGImagePropertyIPTC ObjectCycle = new CGImagePropertyIPTC("ObjectCycle");
    
    public static final CGImagePropertyIPTC Byline = new CGImagePropertyIPTC("Byline");
    
    public static final CGImagePropertyIPTC BylineTitle = new CGImagePropertyIPTC("BylineTitle");
    
    public static final CGImagePropertyIPTC City = new CGImagePropertyIPTC("City");
    
    public static final CGImagePropertyIPTC SubLocation = new CGImagePropertyIPTC("SubLocation");
    
    public static final CGImagePropertyIPTC ProvinceState = new CGImagePropertyIPTC("ProvinceState");
    
    public static final CGImagePropertyIPTC CountryPrimaryLocationCode = new CGImagePropertyIPTC("CountryPrimaryLocationCode");
    
    public static final CGImagePropertyIPTC CountryPrimaryLocationName = new CGImagePropertyIPTC("CountryPrimaryLocationName");
    
    public static final CGImagePropertyIPTC OriginalTransmissionReference = new CGImagePropertyIPTC("OriginalTransmissionReference");
    
    public static final CGImagePropertyIPTC Headline = new CGImagePropertyIPTC("Headline");
    
    public static final CGImagePropertyIPTC Credit = new CGImagePropertyIPTC("Credit");
    
    public static final CGImagePropertyIPTC Source = new CGImagePropertyIPTC("Source");
    
    public static final CGImagePropertyIPTC CopyrightNotice = new CGImagePropertyIPTC("CopyrightNotice");
    
    public static final CGImagePropertyIPTC Contact = new CGImagePropertyIPTC("Contact");
    
    public static final CGImagePropertyIPTC CaptionAbstract = new CGImagePropertyIPTC("CaptionAbstract");
    
    public static final CGImagePropertyIPTC WriterEditor = new CGImagePropertyIPTC("WriterEditor");
    
    public static final CGImagePropertyIPTC ImageType = new CGImagePropertyIPTC("ImageType");
    
    public static final CGImagePropertyIPTC ImageOrientation = new CGImagePropertyIPTC("ImageOrientation");
    
    public static final CGImagePropertyIPTC LanguageIdentifier = new CGImagePropertyIPTC("LanguageIdentifier");
    
    public static final CGImagePropertyIPTC StarRating = new CGImagePropertyIPTC("StarRating");
    
    public static final CGImagePropertyIPTC CreatorContactInfo = new CGImagePropertyIPTC("CreatorContactInfo");
    
    public static final CGImagePropertyIPTC RightsUsageTerms = new CGImagePropertyIPTC("RightsUsageTerms");
    
    public static final CGImagePropertyIPTC Scene = new CGImagePropertyIPTC("Scene");
    
    
    private static CGImagePropertyIPTC[] values = new CGImagePropertyIPTC[] {ObjectTypeReference, ObjectAttributeReference, ObjectName, EditStatus, EditorialUpdate, Urgency, SubjectReference, Category, SupplementalCategory, FixtureIdentifier, Keywords, ContentLocationCode, ContentLocationName, ReleaseDate, ReleaseTime, ExpirationDate, ExpirationTime, SpecialInstructions, ActionAdvised, ReferenceService, ReferenceDate, ReferenceNumber, DateCreated, TimeCreated, DigitalCreationDate, DigitalCreationTime, OriginatingProgram, ProgramVersion, ObjectCycle, Byline, BylineTitle, City, SubLocation, ProvinceState, CountryPrimaryLocationCode, CountryPrimaryLocationName, OriginalTransmissionReference, Headline, Credit, Source, CopyrightNotice, Contact, CaptionAbstract, WriterEditor, ImageType, ImageOrientation, LanguageIdentifier, StarRating, CreatorContactInfo, RightsUsageTerms, Scene};
    
    CGImagePropertyIPTC (String getterName) {
        super(Values.class, getterName);
    }
    
    public static CGImagePropertyIPTC valueOf(CFString value) {
        for (CGImagePropertyIPTC v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImagePropertyIPTC.class.getName());
    }
    
    
    
    @Library("ImageIO") @StronglyLinked
    public static class Values {
    	static { Bro.bind(Values.class); }

        
        
        @GlobalValue(symbol="kCGImagePropertyIPTCObjectTypeReference", optional=true)
        public static native CFString ObjectTypeReference();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCObjectAttributeReference", optional=true)
        public static native CFString ObjectAttributeReference();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCObjectName", optional=true)
        public static native CFString ObjectName();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCEditStatus", optional=true)
        public static native CFString EditStatus();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCEditorialUpdate", optional=true)
        public static native CFString EditorialUpdate();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCUrgency", optional=true)
        public static native CFString Urgency();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCSubjectReference", optional=true)
        public static native CFString SubjectReference();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCCategory", optional=true)
        public static native CFString Category();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCSupplementalCategory", optional=true)
        public static native CFString SupplementalCategory();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCFixtureIdentifier", optional=true)
        public static native CFString FixtureIdentifier();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCKeywords", optional=true)
        public static native CFString Keywords();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCContentLocationCode", optional=true)
        public static native CFString ContentLocationCode();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCContentLocationName", optional=true)
        public static native CFString ContentLocationName();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCReleaseDate", optional=true)
        public static native CFString ReleaseDate();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCReleaseTime", optional=true)
        public static native CFString ReleaseTime();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCExpirationDate", optional=true)
        public static native CFString ExpirationDate();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCExpirationTime", optional=true)
        public static native CFString ExpirationTime();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCSpecialInstructions", optional=true)
        public static native CFString SpecialInstructions();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCActionAdvised", optional=true)
        public static native CFString ActionAdvised();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCReferenceService", optional=true)
        public static native CFString ReferenceService();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCReferenceDate", optional=true)
        public static native CFString ReferenceDate();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCReferenceNumber", optional=true)
        public static native CFString ReferenceNumber();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCDateCreated", optional=true)
        public static native CFString DateCreated();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCTimeCreated", optional=true)
        public static native CFString TimeCreated();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCDigitalCreationDate", optional=true)
        public static native CFString DigitalCreationDate();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCDigitalCreationTime", optional=true)
        public static native CFString DigitalCreationTime();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCOriginatingProgram", optional=true)
        public static native CFString OriginatingProgram();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCProgramVersion", optional=true)
        public static native CFString ProgramVersion();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCObjectCycle", optional=true)
        public static native CFString ObjectCycle();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCByline", optional=true)
        public static native CFString Byline();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCBylineTitle", optional=true)
        public static native CFString BylineTitle();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCCity", optional=true)
        public static native CFString City();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCSubLocation", optional=true)
        public static native CFString SubLocation();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCProvinceState", optional=true)
        public static native CFString ProvinceState();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCCountryPrimaryLocationCode", optional=true)
        public static native CFString CountryPrimaryLocationCode();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCCountryPrimaryLocationName", optional=true)
        public static native CFString CountryPrimaryLocationName();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCOriginalTransmissionReference", optional=true)
        public static native CFString OriginalTransmissionReference();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCHeadline", optional=true)
        public static native CFString Headline();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCCredit", optional=true)
        public static native CFString Credit();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCSource", optional=true)
        public static native CFString Source();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCCopyrightNotice", optional=true)
        public static native CFString CopyrightNotice();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCContact", optional=true)
        public static native CFString Contact();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCCaptionAbstract", optional=true)
        public static native CFString CaptionAbstract();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCWriterEditor", optional=true)
        public static native CFString WriterEditor();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCImageType", optional=true)
        public static native CFString ImageType();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCImageOrientation", optional=true)
        public static native CFString ImageOrientation();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCLanguageIdentifier", optional=true)
        public static native CFString LanguageIdentifier();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCStarRating", optional=true)
        public static native CFString StarRating();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCCreatorContactInfo", optional=true)
        public static native CFString CreatorContactInfo();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCRightsUsageTerms", optional=true)
        public static native CFString RightsUsageTerms();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCScene", optional=true)
        public static native CFString Scene();
        
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO")
@Marshaler(CGImagePropertyJFIFData.Marshaler.class)
public class CGImagePropertyJFIFData 
    extends CFDictionaryWrapper
     {

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyJFIFData toObject(Class<CGImagePropertyJFIFData> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImagePropertyJFIFData(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyJFIFData o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImagePropertyJFIFData> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImagePropertyJFIFData> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(new CGImagePropertyJFIFData(o.get(i, CFDictionary.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImagePropertyJFIFData> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImagePropertyJFIFData i : l) {
                array.add(i.getDictionary());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    CGImagePropertyJFIFData(CFDictionary data) {
        super(data);
    }
    public CGImagePropertyJFIFData() {}
    

    
    public boolean has(CGImagePropertyJFIF key) {
        return data.containsKey(key.value());
    }
    public <T extends NativeObject> T get(CGImagePropertyJFIF key, Class<T> type) {
        if (has(key)) {
            return data.get(key.value(), type);
        }
        return null;
    }
    public CGImagePropertyJFIFData set(CGImagePropertyJFIF key, NativeObject value) {
        data.put(key.value(), value);
        return this;
    }
    
    public String getString(CGImagePropertyJFIF property) {
        if (has(property)) {
            CFString val = get(property, CFString.class);
            return val.toString();
        }
        return null;
    }
    public double getNumber(CGImagePropertyJFIF property) {
        if (has(property)) {
            CFNumber val = get(property, CFNumber.class);
            return val.doubleValue();
        }
        return 0;
    }
    public CGImagePropertyJFIFData set(CGImagePropertyJFIF property, String value) {
        set(property, new CFString(value));
        return this;
    }
    public CGImagePropertyJFIFData set(CGImagePropertyJFIF property, double value) {
        set(property, CFNumber.valueOf(value));
        return this;
    }
    
    
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO")
@Marshaler(CGImagePropertyNikonData.Marshaler.class)
public class CGImagePropertyNikonData 
    extends CFDictionaryWrapper
     {

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyNikonData toObject(Class<CGImagePropertyNikonData> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImagePropertyNikonData(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyNikonData o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImagePropertyNikonData> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImagePropertyNikonData> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(new CGImagePropertyNikonData(o.get(i, CFDictionary.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImagePropertyNikonData> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImagePropertyNikonData i : l) {
                array.add(i.getDictionary());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    CGImagePropertyNikonData(CFDictionary data) {
        super(data);
    }
    public CGImagePropertyNikonData() {}
    

    
    public boolean has(CGImagePropertyNikon key) {
        return data.containsKey(key.value());
    }
    public <T extends NativeObject> T get(CGImagePropertyNikon key, Class<T> type) {
        if (has(key)) {
            return data.get(key.value(), type);
        }
        return null;
    }
    public CGImagePropertyNikonData set(CGImagePropertyNikon key, NativeObject value) {
        data.put(key.value(), value);
        return this;
    }
    
    public String getString(CGImagePropertyNikon property) {
        if (has(property)) {
            CFString val = get(property, CFString.class);
            return val.toString();
        }
        return null;
    }
    public double getNumber(CGImagePropertyNikon property) {
        if (has(property)) {
            CFNumber val = get(property, CFNumber.class);
            return val.doubleValue();
        }
        return 0;
    }
    public CGImagePropertyNikonData set(CGImagePropertyNikon property, String value) {
        set(property, new CFString(value));
        return this;
    }
    public CGImagePropertyNikonData set(CGImagePropertyNikon property, double value) {
        set(property, CFNumber.valueOf(value));
        return this;
    }
    
    
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO") @StronglyLinked
@Marshaler(CGImagePropertyExif.Marshaler.class)
public class CGImagePropertyExif 
    extends GlobalValueEnumeration<CFString>
     {

    static { Bro.bind(CGImagePropertyExif.class); }

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyExif toObject(Class<CGImagePropertyExif> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImagePropertyExif.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyExif o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImagePropertyExif> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImagePropertyExif> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(CGImagePropertyExif.valueOf(o.get(i, CFString.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImagePropertyExif> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImagePropertyExif o : l) {
                array.add(o.value());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    
    public static final CGImagePropertyExif ExposureTime = new CGImagePropertyExif("ExposureTime");
    
    public static final CGImagePropertyExif FNumber = new CGImagePropertyExif("FNumber");
    
    public static final CGImagePropertyExif ExposureProgram = new CGImagePropertyExif("ExposureProgram");
    
    public static final CGImagePropertyExif SpectralSensitivity = new CGImagePropertyExif("SpectralSensitivity");
    
    public static final CGImagePropertyExif ISOSpeedRatings = new CGImagePropertyExif("ISOSpeedRatings");
    
    public static final CGImagePropertyExif OECF = new CGImagePropertyExif("OECF");
    
    public static final CGImagePropertyExif SensitivityType = new CGImagePropertyExif("SensitivityType");
    
    public static final CGImagePropertyExif StandardOutputSensitivity = new CGImagePropertyExif("StandardOutputSensitivity");
    
    public static final CGImagePropertyExif RecommendedExposureIndex = new CGImagePropertyExif("RecommendedExposureIndex");
    
    public static final CGImagePropertyExif ISOSpeed = new CGImagePropertyExif("ISOSpeed");
    
    public static final CGImagePropertyExif ISOSpeedLatitudeyyy = new CGImagePropertyExif("ISOSpeedLatitudeyyy");
    
    public static final CGImagePropertyExif ISOSpeedLatitudezzz = new CGImagePropertyExif("ISOSpeedLatitudezzz");
    
    public static final CGImagePropertyExif Version = new CGImagePropertyExif("Version");
    
    public static final CGImagePropertyExif DateTimeOriginal = new CGImagePropertyExif("DateTimeOriginal");
    
    public static final CGImagePropertyExif DateTimeDigitized = new CGImagePropertyExif("DateTimeDigitized");
    
    public static final CGImagePropertyExif ComponentsConfiguration = new CGImagePropertyExif("ComponentsConfiguration");
    
    public static final CGImagePropertyExif CompressedBitsPerPixel = new CGImagePropertyExif("CompressedBitsPerPixel");
    
    public static final CGImagePropertyExif ShutterSpeedValue = new CGImagePropertyExif("ShutterSpeedValue");
    
    public static final CGImagePropertyExif ApertureValue = new CGImagePropertyExif("ApertureValue");
    
    public static final CGImagePropertyExif BrightnessValue = new CGImagePropertyExif("BrightnessValue");
    
    public static final CGImagePropertyExif ExposureBiasValue = new CGImagePropertyExif("ExposureBiasValue");
    
    public static final CGImagePropertyExif MaxApertureValue = new CGImagePropertyExif("MaxApertureValue");
    
    public static final CGImagePropertyExif SubjectDistance = new CGImagePropertyExif("SubjectDistance");
    
    public static final CGImagePropertyExif MeteringMode = new CGImagePropertyExif("MeteringMode");
    
    public static final CGImagePropertyExif LightSource = new CGImagePropertyExif("LightSource");
    
    public static final CGImagePropertyExif Flash = new CGImagePropertyExif("Flash");
    
    public static final CGImagePropertyExif FocalLength = new CGImagePropertyExif("FocalLength");
    
    public static final CGImagePropertyExif SubjectArea = new CGImagePropertyExif("SubjectArea");
    
    public static final CGImagePropertyExif MakerNote = new CGImagePropertyExif("MakerNote");
    
    public static final CGImagePropertyExif UserComment = new CGImagePropertyExif("UserComment");
    
    public static final CGImagePropertyExif SubsecTime = new CGImagePropertyExif("SubsecTime");
    
    public static final CGImagePropertyExif SubsecTimeOrginal = new CGImagePropertyExif("SubsecTimeOrginal");
    
    public static final CGImagePropertyExif SubsecTimeDigitized = new CGImagePropertyExif("SubsecTimeDigitized");
    
    public static final CGImagePropertyExif FlashPixVersion = new CGImagePropertyExif("FlashPixVersion");
    
    public static final CGImagePropertyExif ColorSpace = new CGImagePropertyExif("ColorSpace");
    
    public static final CGImagePropertyExif PixelXDimension = new CGImagePropertyExif("PixelXDimension");
    
    public static final CGImagePropertyExif PixelYDimension = new CGImagePropertyExif("PixelYDimension");
    
    public static final CGImagePropertyExif RelatedSoundFile = new CGImagePropertyExif("RelatedSoundFile");
    
    public static final CGImagePropertyExif FlashEnergy = new CGImagePropertyExif("FlashEnergy");
    
    public static final CGImagePropertyExif SpatialFrequencyResponse = new CGImagePropertyExif("SpatialFrequencyResponse");
    
    public static final CGImagePropertyExif FocalPlaneXResolution = new CGImagePropertyExif("FocalPlaneXResolution");
    
    public static final CGImagePropertyExif FocalPlaneYResolution = new CGImagePropertyExif("FocalPlaneYResolution");
    
    public static final CGImagePropertyExif FocalPlaneResolutionUnit = new CGImagePropertyExif("FocalPlaneResolutionUnit");
    
    public static final CGImagePropertyExif SubjectLocation = new CGImagePropertyExif("SubjectLocation");
    
    public static final CGImagePropertyExif ExposureIndex = new CGImagePropertyExif("ExposureIndex");
    
    public static final CGImagePropertyExif SensingMethod = new CGImagePropertyExif("SensingMethod");
    
    public static final CGImagePropertyExif FileSource = new CGImagePropertyExif("FileSource");
    
    public static final CGImagePropertyExif SceneType = new CGImagePropertyExif("SceneType");
    
    public static final CGImagePropertyExif CFAPattern = new CGImagePropertyExif("CFAPattern");
    
    public static final CGImagePropertyExif CustomRendered = new CGImagePropertyExif("CustomRendered");
    
    public static final CGImagePropertyExif ExposureMode = new CGImagePropertyExif("ExposureMode");
    
    public static final CGImagePropertyExif WhiteBalance = new CGImagePropertyExif("WhiteBalance");
    
    public static final CGImagePropertyExif DigitalZoomRatio = new CGImagePropertyExif("DigitalZoomRatio");
    
    public static final CGImagePropertyExif FocalLenIn35mmFilm = new CGImagePropertyExif("FocalLenIn35mmFilm");
    
    public static final CGImagePropertyExif SceneCaptureType = new CGImagePropertyExif("SceneCaptureType");
    
    public static final CGImagePropertyExif GainControl = new CGImagePropertyExif("GainControl");
    
    public static final CGImagePropertyExif Contrast = new CGImagePropertyExif("Contrast");
    
    public static final CGImagePropertyExif Saturation = new CGImagePropertyExif("Saturation");
    
    public static final CGImagePropertyExif Sharpness = new CGImagePropertyExif("Sharpness");
    
    public static final CGImagePropertyExif DeviceSettingDescription = new CGImagePropertyExif("DeviceSettingDescription");
    
    public static final CGImagePropertyExif SubjectDistRange = new CGImagePropertyExif("SubjectDistRange");
    
    public static final CGImagePropertyExif ImageUniqueID = new CGImagePropertyExif("ImageUniqueID");
    
    public static final CGImagePropertyExif CameraOwnerName = new CGImagePropertyExif("CameraOwnerName");
    
    public static final CGImagePropertyExif BodySerialNumber = new CGImagePropertyExif("BodySerialNumber");
    
    public static final CGImagePropertyExif LensSpecification = new CGImagePropertyExif("LensSpecification");
    
    public static final CGImagePropertyExif LensMake = new CGImagePropertyExif("LensMake");
    
    public static final CGImagePropertyExif LensModel = new CGImagePropertyExif("LensModel");
    
    public static final CGImagePropertyExif LensSerialNumber = new CGImagePropertyExif("LensSerialNumber");
    
    public static final CGImagePropertyExif Gamma = new CGImagePropertyExif("Gamma");
    
    
    private static CGImagePropertyExif[] values = new CGImagePropertyExif[] {ExposureTime, FNumber, ExposureProgram, SpectralSensitivity, ISOSpeedRatings, OECF, SensitivityType, StandardOutputSensitivity, RecommendedExposureIndex, ISOSpeed, ISOSpeedLatitudeyyy, ISOSpeedLatitudezzz, Version, DateTimeOriginal, DateTimeDigitized, ComponentsConfiguration, CompressedBitsPerPixel, ShutterSpeedValue, ApertureValue, BrightnessValue, ExposureBiasValue, MaxApertureValue, SubjectDistance, MeteringMode, LightSource, Flash, FocalLength, SubjectArea, MakerNote, UserComment, SubsecTime, SubsecTimeOrginal, SubsecTimeDigitized, FlashPixVersion, ColorSpace, PixelXDimension, PixelYDimension, RelatedSoundFile, FlashEnergy, SpatialFrequencyResponse, FocalPlaneXResolution, FocalPlaneYResolution, FocalPlaneResolutionUnit, SubjectLocation, ExposureIndex, SensingMethod, FileSource, SceneType, CFAPattern, CustomRendered, ExposureMode, WhiteBalance, DigitalZoomRatio, FocalLenIn35mmFilm, SceneCaptureType, GainControl, Contrast, Saturation, Sharpness, DeviceSettingDescription, SubjectDistRange, ImageUniqueID, CameraOwnerName, BodySerialNumber, LensSpecification, LensMake, LensModel, LensSerialNumber, Gamma};
    
    CGImagePropertyExif (String getterName) {
        super(Values.class, getterName);
    }
    
    public static CGImagePropertyExif valueOf(CFString value) {
        for (CGImagePropertyExif v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImagePropertyExif.class.getName());
    }
    
    
    
    @Library("ImageIO") @StronglyLinked
    public static class Values {
    	static { Bro.bind(Values.class); }

        
        
        @GlobalValue(symbol="kCGImagePropertyExifExposureTime", optional=true)
        public static native CFString ExposureTime();
        
        @GlobalValue(symbol="kCGImagePropertyExifFNumber", optional=true)
        public static native CFString FNumber();
        
        @GlobalValue(symbol="kCGImagePropertyExifExposureProgram", optional=true)
        public static native CFString ExposureProgram();
        
        @GlobalValue(symbol="kCGImagePropertyExifSpectralSensitivity", optional=true)
        public static native CFString SpectralSensitivity();
        
        @GlobalValue(symbol="kCGImagePropertyExifISOSpeedRatings", optional=true)
        public static native CFString ISOSpeedRatings();
        
        @GlobalValue(symbol="kCGImagePropertyExifOECF", optional=true)
        public static native CFString OECF();
        
        @GlobalValue(symbol="kCGImagePropertyExifSensitivityType", optional=true)
        public static native CFString SensitivityType();
        
        @GlobalValue(symbol="kCGImagePropertyExifStandardOutputSensitivity", optional=true)
        public static native CFString StandardOutputSensitivity();
        
        @GlobalValue(symbol="kCGImagePropertyExifRecommendedExposureIndex", optional=true)
        public static native CFString RecommendedExposureIndex();
        
        @GlobalValue(symbol="kCGImagePropertyExifISOSpeed", optional=true)
        public static native CFString ISOSpeed();
        
        @GlobalValue(symbol="kCGImagePropertyExifISOSpeedLatitudeyyy", optional=true)
        public static native CFString ISOSpeedLatitudeyyy();
        
        @GlobalValue(symbol="kCGImagePropertyExifISOSpeedLatitudezzz", optional=true)
        public static native CFString ISOSpeedLatitudezzz();
        
        @GlobalValue(symbol="kCGImagePropertyExifVersion", optional=true)
        public static native CFString Version();
        
        @GlobalValue(symbol="kCGImagePropertyExifDateTimeOriginal", optional=true)
        public static native CFString DateTimeOriginal();
        
        @GlobalValue(symbol="kCGImagePropertyExifDateTimeDigitized", optional=true)
        public static native CFString DateTimeDigitized();
        
        @GlobalValue(symbol="kCGImagePropertyExifComponentsConfiguration", optional=true)
        public static native CFString ComponentsConfiguration();
        
        @GlobalValue(symbol="kCGImagePropertyExifCompressedBitsPerPixel", optional=true)
        public static native CFString CompressedBitsPerPixel();
        
        @GlobalValue(symbol="kCGImagePropertyExifShutterSpeedValue", optional=true)
        public static native CFString ShutterSpeedValue();
        
        @GlobalValue(symbol="kCGImagePropertyExifApertureValue", optional=true)
        public static native CFString ApertureValue();
        
        @GlobalValue(symbol="kCGImagePropertyExifBrightnessValue", optional=true)
        public static native CFString BrightnessValue();
        
        @GlobalValue(symbol="kCGImagePropertyExifExposureBiasValue", optional=true)
        public static native CFString ExposureBiasValue();
        
        @GlobalValue(symbol="kCGImagePropertyExifMaxApertureValue", optional=true)
        public static native CFString MaxApertureValue();
        
        @GlobalValue(symbol="kCGImagePropertyExifSubjectDistance", optional=true)
        public static native CFString SubjectDistance();
        
        @GlobalValue(symbol="kCGImagePropertyExifMeteringMode", optional=true)
        public static native CFString MeteringMode();
        
        @GlobalValue(symbol="kCGImagePropertyExifLightSource", optional=true)
        public static native CFString LightSource();
        
        @GlobalValue(symbol="kCGImagePropertyExifFlash", optional=true)
        public static native CFString Flash();
        
        @GlobalValue(symbol="kCGImagePropertyExifFocalLength", optional=true)
        public static native CFString FocalLength();
        
        @GlobalValue(symbol="kCGImagePropertyExifSubjectArea", optional=true)
        public static native CFString SubjectArea();
        
        @GlobalValue(symbol="kCGImagePropertyExifMakerNote", optional=true)
        public static native CFString MakerNote();
        
        @GlobalValue(symbol="kCGImagePropertyExifUserComment", optional=true)
        public static native CFString UserComment();
        
        @GlobalValue(symbol="kCGImagePropertyExifSubsecTime", optional=true)
        public static native CFString SubsecTime();
        
        @GlobalValue(symbol="kCGImagePropertyExifSubsecTimeOrginal", optional=true)
        public static native CFString SubsecTimeOrginal();
        
        @GlobalValue(symbol="kCGImagePropertyExifSubsecTimeDigitized", optional=true)
        public static native CFString SubsecTimeDigitized();
        
        @GlobalValue(symbol="kCGImagePropertyExifFlashPixVersion", optional=true)
        public static native CFString FlashPixVersion();
        
        @GlobalValue(symbol="kCGImagePropertyExifColorSpace", optional=true)
        public static native CFString ColorSpace();
        
        @GlobalValue(symbol="kCGImagePropertyExifPixelXDimension", optional=true)
        public static native CFString PixelXDimension();
        
        @GlobalValue(symbol="kCGImagePropertyExifPixelYDimension", optional=true)
        public static native CFString PixelYDimension();
        
        @GlobalValue(symbol="kCGImagePropertyExifRelatedSoundFile", optional=true)
        public static native CFString RelatedSoundFile();
        
        @GlobalValue(symbol="kCGImagePropertyExifFlashEnergy", optional=true)
        public static native CFString FlashEnergy();
        
        @GlobalValue(symbol="kCGImagePropertyExifSpatialFrequencyResponse", optional=true)
        public static native CFString SpatialFrequencyResponse();
        
        @GlobalValue(symbol="kCGImagePropertyExifFocalPlaneXResolution", optional=true)
        public static native CFString FocalPlaneXResolution();
        
        @GlobalValue(symbol="kCGImagePropertyExifFocalPlaneYResolution", optional=true)
        public static native CFString FocalPlaneYResolution();
        
        @GlobalValue(symbol="kCGImagePropertyExifFocalPlaneResolutionUnit", optional=true)
        public static native CFString FocalPlaneResolutionUnit();
        
        @GlobalValue(symbol="kCGImagePropertyExifSubjectLocation", optional=true)
        public static native CFString SubjectLocation();
        
        @GlobalValue(symbol="kCGImagePropertyExifExposureIndex", optional=true)
        public static native CFString ExposureIndex();
        
        @GlobalValue(symbol="kCGImagePropertyExifSensingMethod", optional=true)
        public static native CFString SensingMethod();
        
        @GlobalValue(symbol="kCGImagePropertyExifFileSource", optional=true)
        public static native CFString FileSource();
        
        @GlobalValue(symbol="kCGImagePropertyExifSceneType", optional=true)
        public static native CFString SceneType();
        
        @GlobalValue(symbol="kCGImagePropertyExifCFAPattern", optional=true)
        public static native CFString CFAPattern();
        
        @GlobalValue(symbol="kCGImagePropertyExifCustomRendered", optional=true)
        public static native CFString CustomRendered();
        
        @GlobalValue(symbol="kCGImagePropertyExifExposureMode", optional=true)
        public static native CFString ExposureMode();
        
        @GlobalValue(symbol="kCGImagePropertyExifWhiteBalance", optional=true)
        public static native CFString WhiteBalance();
        
        @GlobalValue(symbol="kCGImagePropertyExifDigitalZoomRatio", optional=true)
        public static native CFString DigitalZoomRatio();
        
        @GlobalValue(symbol="kCGImagePropertyExifFocalLenIn35mmFilm", optional=true)
        public static native CFString FocalLenIn35mmFilm();
        
        @GlobalValue(symbol="kCGImagePropertyExifSceneCaptureType", optional=true)
        public static native CFString SceneCaptureType();
        
        @GlobalValue(symbol="kCGImagePropertyExifGainControl", optional=true)
        public static native CFString GainControl();
        
        @GlobalValue(symbol="kCGImagePropertyExifContrast", optional=true)
        public static native CFString Contrast();
        
        @GlobalValue(symbol="kCGImagePropertyExifSaturation", optional=true)
        public static native CFString Saturation();
        
        @GlobalValue(symbol="kCGImagePropertyExifSharpness", optional=true)
        public static native CFString Sharpness();
        
        @GlobalValue(symbol="kCGImagePropertyExifDeviceSettingDescription", optional=true)
        public static native CFString DeviceSettingDescription();
        
        @GlobalValue(symbol="kCGImagePropertyExifSubjectDistRange", optional=true)
        public static native CFString SubjectDistRange();
        
        @GlobalValue(symbol="kCGImagePropertyExifImageUniqueID", optional=true)
        public static native CFString ImageUniqueID();
        
        @GlobalValue(symbol="kCGImagePropertyExifCameraOwnerName", optional=true)
        public static native CFString CameraOwnerName();
        
        @GlobalValue(symbol="kCGImagePropertyExifBodySerialNumber", optional=true)
        public static native CFString BodySerialNumber();
        
        @GlobalValue(symbol="kCGImagePropertyExifLensSpecification", optional=true)
        public static native CFString LensSpecification();
        
        @GlobalValue(symbol="kCGImagePropertyExifLensMake", optional=true)
        public static native CFString LensMake();
        
        @GlobalValue(symbol="kCGImagePropertyExifLensModel", optional=true)
        public static native CFString LensModel();
        
        @GlobalValue(symbol="kCGImagePropertyExifLensSerialNumber", optional=true)
        public static native CFString LensSerialNumber();
        
        @GlobalValue(symbol="kCGImagePropertyExifGamma", optional=true)
        public static native CFString Gamma();
        
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO") @StronglyLinked
@Marshaler(CGImagePropertyPNG.Marshaler.class)
public class CGImagePropertyPNG 
    extends GlobalValueEnumeration<CFString>
     {

    static { Bro.bind(CGImagePropertyPNG.class); }

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyPNG toObject(Class<CGImagePropertyPNG> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImagePropertyPNG.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyPNG o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImagePropertyPNG> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImagePropertyPNG> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(CGImagePropertyPNG.valueOf(o.get(i, CFString.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImagePropertyPNG> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImagePropertyPNG o : l) {
                array.add(o.value());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    
    public static final CGImagePropertyPNG Gamma = new CGImagePropertyPNG("Gamma");
    
    public static final CGImagePropertyPNG InterlaceType = new CGImagePropertyPNG("InterlaceType");
    
    public static final CGImagePropertyPNG XPixelsPerMeter = new CGImagePropertyPNG("XPixelsPerMeter");
    
    public static final CGImagePropertyPNG YPixelsPerMeter = new CGImagePropertyPNG("YPixelsPerMeter");
    
    public static final CGImagePropertyPNG sRGBIntent = new CGImagePropertyPNG("sRGBIntent");
    
    public static final CGImagePropertyPNG Chromaticities = new CGImagePropertyPNG("Chromaticities");
    
    public static final CGImagePropertyPNG Author = new CGImagePropertyPNG("Author");
    
    public static final CGImagePropertyPNG Copyright = new CGImagePropertyPNG("Copyright");
    
    public static final CGImagePropertyPNG CreationTime = new CGImagePropertyPNG("CreationTime");
    
    public static final CGImagePropertyPNG Description = new CGImagePropertyPNG("Description");
    
    public static final CGImagePropertyPNG ModificationTime = new CGImagePropertyPNG("ModificationTime");
    
    public static final CGImagePropertyPNG Software = new CGImagePropertyPNG("Software");
    
    public static final CGImagePropertyPNG Title = new CGImagePropertyPNG("Title");
    
    public static final CGImagePropertyPNG LoopCount = new CGImagePropertyPNG("LoopCount");
    
    public static final CGImagePropertyPNG DelayTime = new CGImagePropertyPNG("DelayTime");
    
    public static final CGImagePropertyPNG UnclampedDelayTime = new CGImagePropertyPNG("UnclampedDelayTime");
    
    
    private static CGImagePropertyPNG[] values = new CGImagePropertyPNG[] {Gamma, InterlaceType, XPixelsPerMeter, YPixelsPerMeter, sRGBIntent, Chromaticities, Author, Copyright, CreationTime, Description, ModificationTime, Software, Title, LoopCount, DelayTime, UnclampedDelayTime};
    
    CGImagePropertyPNG (String getterName) {
        super(Values.class, getterName);
    }
    
    public static CGImagePropertyPNG valueOf(CFString value) {
        for (CGImagePropertyPNG v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImagePropertyPNG.class.getName());
    }
    
    
    
    @Library("ImageIO") @StronglyLinked
    public static class Values {
    	static { Bro.bind(Values.class); }

        
        
        @GlobalValue(symbol="kCGImagePropertyPNGGamma", optional=true)
        public static native CFString Gamma();
        
        @GlobalValue(symbol="kCGImagePropertyPNGInterlaceType", optional=true)
        public static native CFString InterlaceType();
        
        @GlobalValue(symbol="kCGImagePropertyPNGXPixelsPerMeter", optional=true)
        public static native CFString XPixelsPerMeter();
        
        @GlobalValue(symbol="kCGImagePropertyPNGYPixelsPerMeter", optional=true)
        public static native CFString YPixelsPerMeter();
        
        @GlobalValue(symbol="kCGImagePropertyPNGsRGBIntent", optional=true)
        public static native CFString sRGBIntent();
        
        @GlobalValue(symbol="kCGImagePropertyPNGChromaticities", optional=true)
        public static native CFString Chromaticities();
        
        @GlobalValue(symbol="kCGImagePropertyPNGAuthor", optional=true)
        public static native CFString Author();
        
        @GlobalValue(symbol="kCGImagePropertyPNGCopyright", optional=true)
        public static native CFString Copyright();
        
        @GlobalValue(symbol="kCGImagePropertyPNGCreationTime", optional=true)
        public static native CFString CreationTime();
        
        @GlobalValue(symbol="kCGImagePropertyPNGDescription", optional=true)
        public static native CFString Description();
        
        @GlobalValue(symbol="kCGImagePropertyPNGModificationTime", optional=true)
        public static native CFString ModificationTime();
        
        @GlobalValue(symbol="kCGImagePropertyPNGSoftware", optional=true)
        public static native CFString Software();
        
        @GlobalValue(symbol="kCGImagePropertyPNGTitle", optional=true)
        public static native CFString Title();
        
        @GlobalValue(symbol="kCGImagePropertyAPNGLoopCount", optional=true)
        public static native CFString LoopCount();
        
        @GlobalValue(symbol="kCGImagePropertyAPNGDelayTime", optional=true)
        public static native CFString DelayTime();
        
        @GlobalValue(symbol="kCGImagePropertyAPNGUnclampedDelayTime", optional=true)
        public static native CFString UnclampedDelayTime();
        
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO") @StronglyLinked
@Marshaler(CGImagePropertyCanon.Marshaler.class)
public class CGImagePropertyCanon 
    extends GlobalValueEnumeration<CFString>
     {

    static { Bro.bind(CGImagePropertyCanon.class); }

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyCanon toObject(Class<CGImagePropertyCanon> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImagePropertyCanon.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyCanon o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImagePropertyCanon> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImagePropertyCanon> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(CGImagePropertyCanon.valueOf(o.get(i, CFString.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImagePropertyCanon> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImagePropertyCanon o : l) {
                array.add(o.value());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    
    public static final CGImagePropertyCanon OwnerName = new CGImagePropertyCanon("OwnerName");
    
    public static final CGImagePropertyCanon CameraSerialNumber = new CGImagePropertyCanon("CameraSerialNumber");
    
    public static final CGImagePropertyCanon ImageSerialNumber = new CGImagePropertyCanon("ImageSerialNumber");
    
    public static final CGImagePropertyCanon FlashExposureComp = new CGImagePropertyCanon("FlashExposureComp");
    
    public static final CGImagePropertyCanon ContinuousDrive = new CGImagePropertyCanon("ContinuousDrive");
    
    public static final CGImagePropertyCanon LensModel = new CGImagePropertyCanon("LensModel");
    
    public static final CGImagePropertyCanon Firmware = new CGImagePropertyCanon("Firmware");
    
    public static final CGImagePropertyCanon AspectRatioInfo = new CGImagePropertyCanon("AspectRatioInfo");
    
    
    private static CGImagePropertyCanon[] values = new CGImagePropertyCanon[] {OwnerName, CameraSerialNumber, ImageSerialNumber, FlashExposureComp, ContinuousDrive, LensModel, Firmware, AspectRatioInfo};
    
    CGImagePropertyCanon (String getterName) {
        super(Values.class, getterName);
    }
    
    public static CGImagePropertyCanon valueOf(CFString value) {
        for (CGImagePropertyCanon v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImagePropertyCanon.class.getName());
    }
    
    
    
    @Library("ImageIO") @StronglyLinked
    public static class Values {
    	static { Bro.bind(Values.class); }

        
        
        @GlobalValue(symbol="kCGImagePropertyMakerCanonOwnerName", optional=true)
        public static native CFString OwnerName();
        
        @GlobalValue(symbol="kCGImagePropertyMakerCanonCameraSerialNumber", optional=true)
        public static native CFString CameraSerialNumber();
        
        @GlobalValue(symbol="kCGImagePropertyMakerCanonImageSerialNumber", optional=true)
        public static native CFString ImageSerialNumber();
        
        @GlobalValue(symbol="kCGImagePropertyMakerCanonFlashExposureComp", optional=true)
        public static native CFString FlashExposureComp();
        
        @GlobalValue(symbol="kCGImagePropertyMakerCanonContinuousDrive", optional=true)
        public static native CFString ContinuousDrive();
        
        @GlobalValue(symbol="kCGImagePropertyMakerCanonLensModel", optional=true)
        public static native CFString LensModel();
        
        @GlobalValue(symbol="kCGImagePropertyMakerCanonFirmware", optional=true)
        public static native CFString Firmware();
        
        @GlobalValue(symbol="kCGImagePropertyMakerCanonAspectRatioInfo", optional=true)
        public static native CFString AspectRatioInfo();
        
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO")
@Marshaler(CGImageDestinationProperties.Marshaler.class)
public class CGImageDestinationProperties 
    extends CGImageProperties
     {

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImageDestinationProperties toObject(Class<CGImageDestinationProperties> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImageDestinationProperties(o);
        }
        @MarshalsPointer
        public static long toNative(CGImageDestinationProperties o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImageDestinationProperties> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImageDestinationProperties> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(new CGImageDestinationProperties(o.get(i, CFDictionary.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImageDestinationProperties> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImageDestinationProperties i : l) {
                array.add(i.getDictionary());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    CGImageDestinationProperties(CFDictionary data) {
        super(data);
    }
    public CGImageDestinationProperties() {}
    

    
    public boolean has(CFString key) {
        return data.containsKey(key);
    }
    public <T extends NativeObject> T get(CFString key, Class<T> type) {
        if (has(key)) {
            return data.get(key, type);
        }
        return null;
    }
    public CGImageDestinationProperties set(CFString key, NativeObject value) {
        data.put(key, value);
        return this;
    }
    

    
    public double getLossyCompressionQuality() {
        if (has(Keys.LossyCompressionQuality())) {
            CFNumber val = get(Keys.LossyCompressionQuality(), CFNumber.class);
            return val.doubleValue();
        }
        return 1;
    }
    
    public CGImageDestinationProperties setLossyCompressionQuality(double lossyCompressionQuality) {
        set(Keys.LossyCompressionQuality(), CFNumber.valueOf(lossyCompressionQuality));
        return this;
    }
    
    public CGColor getBackgroundColor() {
        if (has(Keys.BackgroundColor())) {
            CGColor val = get(Keys.BackgroundColor(), CGColor.class);
            return val;
        }
        return null;
    }
    
    public CGImageDestinationProperties setBackgroundColor(CGColor backgroundColor) {
        set(Keys.BackgroundColor(), backgroundColor);
        return this;
    }
    
    public long getMaxPixelSize() {
        if (has(Keys.ImageMaxPixelSize())) {
            CFNumber val = get(Keys.ImageMaxPixelSize(), CFNumber.class);
            return val.longValue();
        }
        return 0;
    }
    
    public CGImageDestinationProperties setMaxPixelSize(long maxPixelSize) {
        set(Keys.ImageMaxPixelSize(), CFNumber.valueOf(maxPixelSize));
        return this;
    }
    
    public boolean embedsThumbnail() {
        if (has(Keys.EmbedThumbnail())) {
            CFBoolean val = get(Keys.EmbedThumbnail(), CFBoolean.class);
            return val.booleanValue();
        }
        return false;
    }
    
    public CGImageDestinationProperties setEmbedsThumbnail(boolean embedsThumbnail) {
        set(Keys.EmbedThumbnail(), CFBoolean.valueOf(embedsThumbnail));
        return this;
    }
    
    
    
    @Library("ImageIO")
    public static class Keys {
        static { Bro.bind(Keys.class); }
        
        @GlobalValue(symbol="kCGImageDestinationLossyCompressionQuality", optional=true)
        public static native CFString LossyCompressionQuality();
        
        @GlobalValue(symbol="kCGImageDestinationBackgroundColor", optional=true)
        public static native CFString BackgroundColor();
        
        @GlobalValue(symbol="kCGImageDestinationImageMaxPixelSize", optional=true)
        public static native CFString ImageMaxPixelSize();
        
        @GlobalValue(symbol="kCGImageDestinationEmbedThumbnail", optional=true)
        public static native CFString EmbedThumbnail();
    }
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO") @StronglyLinked
@Marshaler(CGImagePropertyTIFF.Marshaler.class)
public class CGImagePropertyTIFF 
    extends GlobalValueEnumeration<CFString>
     {

    static { Bro.bind(CGImagePropertyTIFF.class); }

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyTIFF toObject(Class<CGImagePropertyTIFF> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImagePropertyTIFF.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyTIFF o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImagePropertyTIFF> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImagePropertyTIFF> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(CGImagePropertyTIFF.valueOf(o.get(i, CFString.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImagePropertyTIFF> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImagePropertyTIFF o : l) {
                array.add(o.value());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    
    public static final CGImagePropertyTIFF Compression = new CGImagePropertyTIFF("Compression");
    
    public static final CGImagePropertyTIFF PhotometricInterpretation = new CGImagePropertyTIFF("PhotometricInterpretation");
    
    public static final CGImagePropertyTIFF DocumentName = new CGImagePropertyTIFF("DocumentName");
    
    public static final CGImagePropertyTIFF ImageDescription = new CGImagePropertyTIFF("ImageDescription");
    
    public static final CGImagePropertyTIFF Make = new CGImagePropertyTIFF("Make");
    
    public static final CGImagePropertyTIFF Model = new CGImagePropertyTIFF("Model");
    
    public static final CGImagePropertyTIFF Orientation = new CGImagePropertyTIFF("Orientation");
    
    public static final CGImagePropertyTIFF XResolution = new CGImagePropertyTIFF("XResolution");
    
    public static final CGImagePropertyTIFF YResolution = new CGImagePropertyTIFF("YResolution");
    
    public static final CGImagePropertyTIFF ResolutionUnit = new CGImagePropertyTIFF("ResolutionUnit");
    
    public static final CGImagePropertyTIFF Software = new CGImagePropertyTIFF("Software");
    
    public static final CGImagePropertyTIFF TransferFunction = new CGImagePropertyTIFF("TransferFunction");
    
    public static final CGImagePropertyTIFF DateTime = new CGImagePropertyTIFF("DateTime");
    
    public static final CGImagePropertyTIFF Artist = new CGImagePropertyTIFF("Artist");
    
    public static final CGImagePropertyTIFF HostComputer = new CGImagePropertyTIFF("HostComputer");
    
    public static final CGImagePropertyTIFF Copyright = new CGImagePropertyTIFF("Copyright");
    
    public static final CGImagePropertyTIFF WhitePoint = new CGImagePropertyTIFF("WhitePoint");
    
    public static final CGImagePropertyTIFF PrimaryChromaticities = new CGImagePropertyTIFF("PrimaryChromaticities");
    
    
    private static CGImagePropertyTIFF[] values = new CGImagePropertyTIFF[] {Compression, PhotometricInterpretation, DocumentName, ImageDescription, Make, Model, Orientation, XResolution, YResolution, ResolutionUnit, Software, TransferFunction, DateTime, Artist, HostComputer, Copyright, WhitePoint, PrimaryChromaticities};
    
    CGImagePropertyTIFF (String getterName) {
        super(Values.class, getterName);
    }
    
    public static CGImagePropertyTIFF valueOf(CFString value) {
        for (CGImagePropertyTIFF v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImagePropertyTIFF.class.getName());
    }
    
    
    
    @Library("ImageIO") @StronglyLinked
    public static class Values {
    	static { Bro.bind(Values.class); }

        
        
        @GlobalValue(symbol="kCGImagePropertyTIFFCompression", optional=true)
        public static native CFString Compression();
        
        @GlobalValue(symbol="kCGImagePropertyTIFFPhotometricInterpretation", optional=true)
        public static native CFString PhotometricInterpretation();
        
        @GlobalValue(symbol="kCGImagePropertyTIFFDocumentName", optional=true)
        public static native CFString DocumentName();
        
        @GlobalValue(symbol="kCGImagePropertyTIFFImageDescription", optional=true)
        public static native CFString ImageDescription();
        
        @GlobalValue(symbol="kCGImagePropertyTIFFMake", optional=true)
        public static native CFString Make();
        
        @GlobalValue(symbol="kCGImagePropertyTIFFModel", optional=true)
        public static native CFString Model();
        
        @GlobalValue(symbol="kCGImagePropertyTIFFOrientation", optional=true)
        public static native CFString Orientation();
        
        @GlobalValue(symbol="kCGImagePropertyTIFFXResolution", optional=true)
        public static native CFString XResolution();
        
        @GlobalValue(symbol="kCGImagePropertyTIFFYResolution", optional=true)
        public static native CFString YResolution();
        
        @GlobalValue(symbol="kCGImagePropertyTIFFResolutionUnit", optional=true)
        public static native CFString ResolutionUnit();
        
        @GlobalValue(symbol="kCGImagePropertyTIFFSoftware", optional=true)
        public static native CFString Software();
        
        @GlobalValue(symbol="kCGImagePropertyTIFFTransferFunction", optional=true)
        public static native CFString TransferFunction();
        
        @GlobalValue(symbol="kCGImagePropertyTIFFDateTime", optional=true)
        public static native CFString DateTime();
        
        @GlobalValue(symbol="kCGImagePropertyTIFFArtist", optional=true)
        public static native CFString Artist();
        
        @GlobalValue(symbol="kCGImagePropertyTIFFHostComputer", optional=true)
        public static native CFString HostComputer();
        
        @GlobalValue(symbol="kCGImagePropertyTIFFCopyright", optional=true)
        public static native CFString Copyright();
        
        @GlobalValue(symbol="kCGImagePropertyTIFFWhitePoint", optional=true)
        public static native CFString WhitePoint();
        
        @GlobalValue(symbol="kCGImagePropertyTIFFPrimaryChromaticities", optional=true)
        public static native CFString PrimaryChromaticities();
        
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO") @StronglyLinked
@Marshaler(CGImagePropertyDNG.Marshaler.class)
public class CGImagePropertyDNG 
    extends GlobalValueEnumeration<CFString>
     {

    static { Bro.bind(CGImagePropertyDNG.class); }

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyDNG toObject(Class<CGImagePropertyDNG> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImagePropertyDNG.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyDNG o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImagePropertyDNG> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImagePropertyDNG> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(CGImagePropertyDNG.valueOf(o.get(i, CFString.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImagePropertyDNG> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImagePropertyDNG o : l) {
                array.add(o.value());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    
    public static final CGImagePropertyDNG Version = new CGImagePropertyDNG("Version");
    
    public static final CGImagePropertyDNG BackwardVersion = new CGImagePropertyDNG("BackwardVersion");
    
    public static final CGImagePropertyDNG UniqueCameraModel = new CGImagePropertyDNG("UniqueCameraModel");
    
    public static final CGImagePropertyDNG LocalizedCameraModel = new CGImagePropertyDNG("LocalizedCameraModel");
    
    public static final CGImagePropertyDNG CameraSerialNumber = new CGImagePropertyDNG("CameraSerialNumber");
    
    public static final CGImagePropertyDNG LensInfo = new CGImagePropertyDNG("LensInfo");
    
    
    private static CGImagePropertyDNG[] values = new CGImagePropertyDNG[] {Version, BackwardVersion, UniqueCameraModel, LocalizedCameraModel, CameraSerialNumber, LensInfo};
    
    CGImagePropertyDNG (String getterName) {
        super(Values.class, getterName);
    }
    
    public static CGImagePropertyDNG valueOf(CFString value) {
        for (CGImagePropertyDNG v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImagePropertyDNG.class.getName());
    }
    
    
    
    @Library("ImageIO") @StronglyLinked
    public static class Values {
    	static { Bro.bind(Values.class); }

        
        
        @GlobalValue(symbol="kCGImagePropertyDNGVersion", optional=true)
        public static native CFString Version();
        
        @GlobalValue(symbol="kCGImagePropertyDNGBackwardVersion", optional=true)
        public static native CFString BackwardVersion();
        
        @GlobalValue(symbol="kCGImagePropertyDNGUniqueCameraModel", optional=true)
        public static native CFString UniqueCameraModel();
        
        @GlobalValue(symbol="kCGImagePropertyDNGLocalizedCameraModel", optional=true)
        public static native CFString LocalizedCameraModel();
        
        @GlobalValue(symbol="kCGImagePropertyDNGCameraSerialNumber", optional=true)
        public static native CFString CameraSerialNumber();
        
        @GlobalValue(symbol="kCGImagePropertyDNGLensInfo", optional=true)
        public static native CFString LensInfo();
        
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO")
@Marshaler(CGImagePropertyCanonData.Marshaler.class)
public class CGImagePropertyCanonData 
    extends CFDictionaryWrapper
     {

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyCanonData toObject(Class<CGImagePropertyCanonData> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImagePropertyCanonData(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyCanonData o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImagePropertyCanonData> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImagePropertyCanonData> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(new CGImagePropertyCanonData(o.get(i, CFDictionary.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImagePropertyCanonData> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImagePropertyCanonData i : l) {
                array.add(i.getDictionary());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    CGImagePropertyCanonData(CFDictionary data) {
        super(data);
    }
    public CGImagePropertyCanonData() {}
    

    
    public boolean has(CGImagePropertyCanon key) {
        return data.containsKey(key.value());
    }
    public <T extends NativeObject> T get(CGImagePropertyCanon key, Class<T> type) {
        if (has(key)) {
            return data.get(key.value(), type);
        }
        return null;
    }
    public CGImagePropertyCanonData set(CGImagePropertyCanon key, NativeObject value) {
        data.put(key.value(), value);
        return this;
    }
    
    public String getString(CGImagePropertyCanon property) {
        if (has(property)) {
            CFString val = get(property, CFString.class);
            return val.toString();
        }
        return null;
    }
    public double getNumber(CGImagePropertyCanon property) {
        if (has(property)) {
            CFNumber val = get(property, CFNumber.class);
            return val.doubleValue();
        }
        return 0;
    }
    public CGImagePropertyCanonData set(CGImagePropertyCanon property, String value) {
        set(property, new CFString(value));
        return this;
    }
    public CGImagePropertyCanonData set(CGImagePropertyCanon property, double value) {
        set(property, CFNumber.valueOf(value));
        return this;
    }
    
    
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO") @StronglyLinked
@Marshaler(CGImagePropertyGIF.Marshaler.class)
public class CGImagePropertyGIF 
    extends GlobalValueEnumeration<CFString>
     {

    static { Bro.bind(CGImagePropertyGIF.class); }

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyGIF toObject(Class<CGImagePropertyGIF> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImagePropertyGIF.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyGIF o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImagePropertyGIF> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImagePropertyGIF> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(CGImagePropertyGIF.valueOf(o.get(i, CFString.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImagePropertyGIF> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImagePropertyGIF o : l) {
                array.add(o.value());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    
    public static final CGImagePropertyGIF LoopCount = new CGImagePropertyGIF("LoopCount");
    
    public static final CGImagePropertyGIF DelayTime = new CGImagePropertyGIF("DelayTime");
    
    public static final CGImagePropertyGIF ImageColorMap = new CGImagePropertyGIF("ImageColorMap");
    
    public static final CGImagePropertyGIF HasGlobalColorMap = new CGImagePropertyGIF("HasGlobalColorMap");
    
    public static final CGImagePropertyGIF UnclampedDelayTime = new CGImagePropertyGIF("UnclampedDelayTime");
    
    
    private static CGImagePropertyGIF[] values = new CGImagePropertyGIF[] {LoopCount, DelayTime, ImageColorMap, HasGlobalColorMap, UnclampedDelayTime};
    
    CGImagePropertyGIF (String getterName) {
        super(Values.class, getterName);
    }
    
    public static CGImagePropertyGIF valueOf(CFString value) {
        for (CGImagePropertyGIF v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImagePropertyGIF.class.getName());
    }
    
    
    
    @Library("ImageIO") @StronglyLinked
    public static class Values {
    	static { Bro.bind(Values.class); }

        
        
        @GlobalValue(symbol="kCGImagePropertyGIFLoopCount", optional=true)
        public static native CFString LoopCount();
        
        @GlobalValue(symbol="kCGImagePropertyGIFDelayTime", optional=true)
        public static native CFString DelayTime();
        
        @GlobalValue(symbol="kCGImagePropertyGIFImageColorMap", optional=true)
        public static native CFString ImageColorMap();
        
        @GlobalValue(symbol="kCGImagePropertyGIFHasGlobalColorMap", optional=true)
        public static native CFString HasGlobalColorMap();
        
        @GlobalValue(symbol="kCGImagePropertyGIFUnclampedDelayTime", optional=true)
        public static native CFString UnclampedDelayTime();
        
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO") @StronglyLinked
@Marshaler(CGImageProperty8BIM.Marshaler.class)
public class CGImageProperty8BIM 
    extends GlobalValueEnumeration<CFString>
     {

    static { Bro.bind(CGImageProperty8BIM.class); }

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImageProperty8BIM toObject(Class<CGImageProperty8BIM> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImageProperty8BIM.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImageProperty8BIM o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImageProperty8BIM> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImageProperty8BIM> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(CGImageProperty8BIM.valueOf(o.get(i, CFString.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImageProperty8BIM> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImageProperty8BIM o : l) {
                array.add(o.value());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    
    public static final CGImageProperty8BIM LayerNames = new CGImageProperty8BIM("LayerNames");
    
    public static final CGImageProperty8BIM Version = new CGImageProperty8BIM("Version");
    
    
    private static CGImageProperty8BIM[] values = new CGImageProperty8BIM[] {LayerNames, Version};
    
    CGImageProperty8BIM (String getterName) {
        super(Values.class, getterName);
    }
    
    public static CGImageProperty8BIM valueOf(CFString value) {
        for (CGImageProperty8BIM v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImageProperty8BIM.class.getName());
    }
    
    
    
    @Library("ImageIO") @StronglyLinked
    public static class Values {
    	static { Bro.bind(Values.class); }

        
        
        @GlobalValue(symbol="kCGImageProperty8BIMLayerNames", optional=true)
        public static native CFString LayerNames();
        
        @GlobalValue(symbol="kCGImageProperty8BIMVersion", optional=true)
        public static native CFString Version();
        
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO")
@Marshaler(CGImageSourceOptions.Marshaler.class)
public class CGImageSourceOptions 
    extends CFDictionaryWrapper
     {

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImageSourceOptions toObject(Class<CGImageSourceOptions> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImageSourceOptions(o);
        }
        @MarshalsPointer
        public static long toNative(CGImageSourceOptions o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImageSourceOptions> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImageSourceOptions> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(new CGImageSourceOptions(o.get(i, CFDictionary.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImageSourceOptions> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImageSourceOptions i : l) {
                array.add(i.getDictionary());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    CGImageSourceOptions(CFDictionary data) {
        super(data);
    }
    public CGImageSourceOptions() {}
    

    
    public boolean has(CFString key) {
        return data.containsKey(key);
    }
    public <T extends NativeObject> T get(CFString key, Class<T> type) {
        if (has(key)) {
            return data.get(key, type);
        }
        return null;
    }
    public CGImageSourceOptions set(CFString key, NativeObject value) {
        data.put(key, value);
        return this;
    }
    

    
    public String getTypeIdentifierHint() {
        if (has(Keys.TypeIdentifierHint())) {
            CFString val = get(Keys.TypeIdentifierHint(), CFString.class);
            return val.toString();
        }
        return null;
    }
    
    public CGImageSourceOptions setTypeIdentifierHint(String typeIdentifierHint) {
        set(Keys.TypeIdentifierHint(), new CFString(typeIdentifierHint));
        return this;
    }
    
    public boolean shouldCache() {
        if (has(Keys.ShouldCache())) {
            CFBoolean val = get(Keys.ShouldCache(), CFBoolean.class);
            return val.booleanValue();
        }
        return false;
    }
    
    public CGImageSourceOptions setShouldCache(boolean shouldCache) {
        set(Keys.ShouldCache(), CFBoolean.valueOf(shouldCache));
        return this;
    }
    
    public boolean shouldCacheImmediately() {
        if (has(Keys.ShouldCacheImmediately())) {
            CFBoolean val = get(Keys.ShouldCacheImmediately(), CFBoolean.class);
            return val.booleanValue();
        }
        return false;
    }
    
    public CGImageSourceOptions setShouldCacheImmediately(boolean shouldCacheImmediately) {
        set(Keys.ShouldCacheImmediately(), CFBoolean.valueOf(shouldCacheImmediately));
        return this;
    }
    
    public boolean shouldAllowFloat() {
        if (has(Keys.ShouldAllowFloat())) {
            CFBoolean val = get(Keys.ShouldAllowFloat(), CFBoolean.class);
            return val.booleanValue();
        }
        return false;
    }
    
    public CGImageSourceOptions setShouldAllowFloat(boolean shouldAllowFloat) {
        set(Keys.ShouldAllowFloat(), CFBoolean.valueOf(shouldAllowFloat));
        return this;
    }
    
    public boolean shouldCreateThumbnailFromImageIfAbsent() {
        if (has(Keys.CreateThumbnailFromImageIfAbsent())) {
            CFBoolean val = get(Keys.CreateThumbnailFromImageIfAbsent(), CFBoolean.class);
            return val.booleanValue();
        }
        return false;
    }
    
    public CGImageSourceOptions setShouldCreateThumbnailFromImageIfAbsent(boolean shouldCreateThumbnailFromImageIfAbsent) {
        set(Keys.CreateThumbnailFromImageIfAbsent(), CFBoolean.valueOf(shouldCreateThumbnailFromImageIfAbsent));
        return this;
    }
    
    public long getThumbnailMaxPixelSize() {
        if (has(Keys.ThumbnailMaxPixelSize())) {
            CFNumber val = get(Keys.ThumbnailMaxPixelSize(), CFNumber.class);
            return val.longValue();
        }
        return 0;
    }
    
    public CGImageSourceOptions setThumbnailMaxPixelSize(long thumbnailMaxPixelSize) {
        set(Keys.ThumbnailMaxPixelSize(), CFNumber.valueOf(thumbnailMaxPixelSize));
        return this;
    }
    
    public boolean shouldCreateThumbnailWithTransform() {
        if (has(Keys.CreateThumbnailWithTransform())) {
            CFBoolean val = get(Keys.CreateThumbnailWithTransform(), CFBoolean.class);
            return val.booleanValue();
        }
        return false;
    }
    
    public CGImageSourceOptions setShouldCreateThumbnailWithTransform(boolean shouldCreateThumbnailWithTransform) {
        set(Keys.CreateThumbnailWithTransform(), CFBoolean.valueOf(shouldCreateThumbnailWithTransform));
        return this;
    }
    
    
    
    @Library("ImageIO")
    public static class Keys {
        static { Bro.bind(Keys.class); }
        
        @GlobalValue(symbol="kCGImageSourceTypeIdentifierHint", optional=true)
        public static native CFString TypeIdentifierHint();
        
        @GlobalValue(symbol="kCGImageSourceShouldCache", optional=true)
        public static native CFString ShouldCache();
        
        @GlobalValue(symbol="kCGImageSourceShouldCacheImmediately", optional=true)
        public static native CFString ShouldCacheImmediately();
        
        @GlobalValue(symbol="kCGImageSourceShouldAllowFloat", optional=true)
        public static native CFString ShouldAllowFloat();
        
        @GlobalValue(symbol="kCGImageSourceCreateThumbnailFromImageIfAbsent", optional=true)
        public static native CFString CreateThumbnailFromImageIfAbsent();
        
        @GlobalValue(symbol="kCGImageSourceCreateThumbnailFromImageAlways", optional=true)
        public static native CFString CreateThumbnailFromImageAlways();
        
        @GlobalValue(symbol="kCGImageSourceThumbnailMaxPixelSize", optional=true)
        public static native CFString ThumbnailMaxPixelSize();
        
        @GlobalValue(symbol="kCGImageSourceCreateThumbnailWithTransform", optional=true)
        public static native CFString CreateThumbnailWithTransform();
    }
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO")
@Marshaler(CGImageProperty8BIMData.Marshaler.class)
public class CGImageProperty8BIMData 
    extends CFDictionaryWrapper
     {

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImageProperty8BIMData toObject(Class<CGImageProperty8BIMData> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImageProperty8BIMData(o);
        }
        @MarshalsPointer
        public static long toNative(CGImageProperty8BIMData o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImageProperty8BIMData> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImageProperty8BIMData> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(new CGImageProperty8BIMData(o.get(i, CFDictionary.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImageProperty8BIMData> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImageProperty8BIMData i : l) {
                array.add(i.getDictionary());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    CGImageProperty8BIMData(CFDictionary data) {
        super(data);
    }
    public CGImageProperty8BIMData() {}
    

    
    public boolean has(CGImageProperty8BIM key) {
        return data.containsKey(key.value());
    }
    public <T extends NativeObject> T get(CGImageProperty8BIM key, Class<T> type) {
        if (has(key)) {
            return data.get(key.value(), type);
        }
        return null;
    }
    public CGImageProperty8BIMData set(CGImageProperty8BIM key, NativeObject value) {
        data.put(key.value(), value);
        return this;
    }
    
    public String getString(CGImageProperty8BIM property) {
        if (has(property)) {
            CFString val = get(property, CFString.class);
            return val.toString();
        }
        return null;
    }
    public double getNumber(CGImageProperty8BIM property) {
        if (has(property)) {
            CFNumber val = get(property, CFNumber.class);
            return val.doubleValue();
        }
        return 0;
    }
    public CGImageProperty8BIMData set(CGImageProperty8BIM property, String value) {
        set(property, new CFString(value));
        return this;
    }
    public CGImageProperty8BIMData set(CGImageProperty8BIM property, double value) {
        set(property, CFNumber.valueOf(value));
        return this;
    }
    
    
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO")
@Marshaler(CGImagePropertyGPSData.Marshaler.class)
public class CGImagePropertyGPSData 
    extends CFDictionaryWrapper
     {

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyGPSData toObject(Class<CGImagePropertyGPSData> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImagePropertyGPSData(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyGPSData o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImagePropertyGPSData> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImagePropertyGPSData> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(new CGImagePropertyGPSData(o.get(i, CFDictionary.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImagePropertyGPSData> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImagePropertyGPSData i : l) {
                array.add(i.getDictionary());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    CGImagePropertyGPSData(CFDictionary data) {
        super(data);
    }
    public CGImagePropertyGPSData() {}
    

    
    public boolean has(CGImagePropertyGPS key) {
        return data.containsKey(key.value());
    }
    public <T extends NativeObject> T get(CGImagePropertyGPS key, Class<T> type) {
        if (has(key)) {
            return data.get(key.value(), type);
        }
        return null;
    }
    public CGImagePropertyGPSData set(CGImagePropertyGPS key, NativeObject value) {
        data.put(key.value(), value);
        return this;
    }
    
    public String getString(CGImagePropertyGPS property) {
        if (has(property)) {
            CFString val = get(property, CFString.class);
            return val.toString();
        }
        return null;
    }
    public double getNumber(CGImagePropertyGPS property) {
        if (has(property)) {
            CFNumber val = get(property, CFNumber.class);
            return val.doubleValue();
        }
        return 0;
    }
    public CGImagePropertyGPSData set(CGImagePropertyGPS property, String value) {
        set(property, new CFString(value));
        return this;
    }
    public CGImagePropertyGPSData set(CGImagePropertyGPS property, double value) {
        set(property, CFNumber.valueOf(value));
        return this;
    }
    
    
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO")
@Marshaler(CGImagePropertyOpenEXRData.Marshaler.class)
public class CGImagePropertyOpenEXRData 
    extends CFDictionaryWrapper
     {

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyOpenEXRData toObject(Class<CGImagePropertyOpenEXRData> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImagePropertyOpenEXRData(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyOpenEXRData o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImagePropertyOpenEXRData> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImagePropertyOpenEXRData> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(new CGImagePropertyOpenEXRData(o.get(i, CFDictionary.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImagePropertyOpenEXRData> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImagePropertyOpenEXRData i : l) {
                array.add(i.getDictionary());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    CGImagePropertyOpenEXRData(CFDictionary data) {
        super(data);
    }
    public CGImagePropertyOpenEXRData() {}
    

    
    public boolean has(CGImagePropertyOpenEXR key) {
        return data.containsKey(key.value());
    }
    public <T extends NativeObject> T get(CGImagePropertyOpenEXR key, Class<T> type) {
        if (has(key)) {
            return data.get(key.value(), type);
        }
        return null;
    }
    public CGImagePropertyOpenEXRData set(CGImagePropertyOpenEXR key, NativeObject value) {
        data.put(key.value(), value);
        return this;
    }
    
    public String getString(CGImagePropertyOpenEXR property) {
        if (has(property)) {
            CFString val = get(property, CFString.class);
            return val.toString();
        }
        return null;
    }
    public double getNumber(CGImagePropertyOpenEXR property) {
        if (has(property)) {
            CFNumber val = get(property, CFNumber.class);
            return val.doubleValue();
        }
        return 0;
    }
    public CGImagePropertyOpenEXRData set(CGImagePropertyOpenEXR property, String value) {
        set(property, new CFString(value));
        return this;
    }
    public CGImagePropertyOpenEXRData set(CGImagePropertyOpenEXR property, double value) {
        set(property, CFNumber.valueOf(value));
        return this;
    }
    
    
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO") @StronglyLinked
@Marshaler(CGImageMetadataPrefix.Marshaler.class)
public class CGImageMetadataPrefix 
    extends GlobalValueEnumeration<CFString>
     {

    static { Bro.bind(CGImageMetadataPrefix.class); }

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImageMetadataPrefix toObject(Class<CGImageMetadataPrefix> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImageMetadataPrefix.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImageMetadataPrefix o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImageMetadataPrefix> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImageMetadataPrefix> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(CGImageMetadataPrefix.valueOf(o.get(i, CFString.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImageMetadataPrefix> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImageMetadataPrefix o : l) {
                array.add(o.value());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    
    public static final CGImageMetadataPrefix Exif = new CGImageMetadataPrefix("Exif");
    
    public static final CGImageMetadataPrefix ExifAux = new CGImageMetadataPrefix("ExifAux");
    
    public static final CGImageMetadataPrefix ExifEX = new CGImageMetadataPrefix("ExifEX");
    
    public static final CGImageMetadataPrefix DublinCore = new CGImageMetadataPrefix("DublinCore");
    
    public static final CGImageMetadataPrefix IPTCCore = new CGImageMetadataPrefix("IPTCCore");
    
    public static final CGImageMetadataPrefix Photoshop = new CGImageMetadataPrefix("Photoshop");
    
    public static final CGImageMetadataPrefix TIFF = new CGImageMetadataPrefix("TIFF");
    
    public static final CGImageMetadataPrefix XMPBasic = new CGImageMetadataPrefix("XMPBasic");
    
    public static final CGImageMetadataPrefix XMPRights = new CGImageMetadataPrefix("XMPRights");
    
    
    private static CGImageMetadataPrefix[] values = new CGImageMetadataPrefix[] {Exif, ExifAux, ExifEX, DublinCore, IPTCCore, Photoshop, TIFF, XMPBasic, XMPRights};
    
    CGImageMetadataPrefix (String getterName) {
        super(Values.class, getterName);
    }
    
    public static CGImageMetadataPrefix valueOf(CFString value) {
        for (CGImageMetadataPrefix v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImageMetadataPrefix.class.getName());
    }
    
    
    
    @Library("ImageIO") @StronglyLinked
    public static class Values {
    	static { Bro.bind(Values.class); }

        
        
        @GlobalValue(symbol="kCGImageMetadataPrefixExif", optional=true)
        public static native CFString Exif();
        
        @GlobalValue(symbol="kCGImageMetadataPrefixExifAux", optional=true)
        public static native CFString ExifAux();
        
        @GlobalValue(symbol="kCGImageMetadataPrefixExifEX", optional=true)
        public static native CFString ExifEX();
        
        @GlobalValue(symbol="kCGImageMetadataPrefixDublinCore", optional=true)
        public static native CFString DublinCore();
        
        @GlobalValue(symbol="kCGImageMetadataPrefixIPTCCore", optional=true)
        public static native CFString IPTCCore();
        
        @GlobalValue(symbol="kCGImageMetadataPrefixPhotoshop", optional=true)
        public static native CFString Photoshop();
        
        @GlobalValue(symbol="kCGImageMetadataPrefixTIFF", optional=true)
        public static native CFString TIFF();
        
        @GlobalValue(symbol="kCGImageMetadataPrefixXMPBasic", optional=true)
        public static native CFString XMPBasic();
        
        @GlobalValue(symbol="kCGImageMetadataPrefixXMPRights", optional=true)
        public static native CFString XMPRights();
        
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO")
@Marshaler(CGImagePropertyIPTCData.Marshaler.class)
public class CGImagePropertyIPTCData 
    extends CFDictionaryWrapper
     {

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyIPTCData toObject(Class<CGImagePropertyIPTCData> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImagePropertyIPTCData(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyIPTCData o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImagePropertyIPTCData> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImagePropertyIPTCData> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(new CGImagePropertyIPTCData(o.get(i, CFDictionary.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImagePropertyIPTCData> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImagePropertyIPTCData i : l) {
                array.add(i.getDictionary());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    CGImagePropertyIPTCData(CFDictionary data) {
        super(data);
    }
    public CGImagePropertyIPTCData() {}
    

    
    public boolean has(CGImagePropertyIPTC key) {
        return data.containsKey(key.value());
    }
    public <T extends NativeObject> T get(CGImagePropertyIPTC key, Class<T> type) {
        if (has(key)) {
            return data.get(key.value(), type);
        }
        return null;
    }
    public CGImagePropertyIPTCData set(CGImagePropertyIPTC key, NativeObject value) {
        data.put(key.value(), value);
        return this;
    }
    

    
    public CGImagePropertyIPTCContactInfoData getCreatorContactInfo() {
        if (has(CGImagePropertyIPTC.CreatorContactInfo)) {
            CFDictionary val = get(CGImagePropertyIPTC.CreatorContactInfo, CFDictionary.class);
            return new CGImagePropertyIPTCContactInfoData(val);
        }
        return null;
    }
    
    public CGImagePropertyIPTCData setCreatorContactInfo(CGImagePropertyIPTCContactInfoData creatorContactInfo) {
        set(CGImagePropertyIPTC.CreatorContactInfo, creatorContactInfo.getDictionary());
        return this;
    }
    
    public String getString(CGImagePropertyIPTC property) {
        if (has(property)) {
            CFString val = get(property, CFString.class);
            return val.toString();
        }
        return null;
    }
    public double getNumber(CGImagePropertyIPTC property) {
        if (has(property)) {
            CFNumber val = get(property, CFNumber.class);
            return val.doubleValue();
        }
        return 0;
    }
    public CGImagePropertyIPTCData set(CGImagePropertyIPTC property, String value) {
        set(property, new CFString(value));
        return this;
    }
    public CGImagePropertyIPTCData set(CGImagePropertyIPTC property, double value) {
        set(property, CFNumber.valueOf(value));
        return this;
    }
    
    
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO")
@Marshaler(CGImagePropertyExifData.Marshaler.class)
public class CGImagePropertyExifData 
    extends CFDictionaryWrapper
     {

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyExifData toObject(Class<CGImagePropertyExifData> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImagePropertyExifData(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyExifData o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImagePropertyExifData> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImagePropertyExifData> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(new CGImagePropertyExifData(o.get(i, CFDictionary.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImagePropertyExifData> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImagePropertyExifData i : l) {
                array.add(i.getDictionary());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    CGImagePropertyExifData(CFDictionary data) {
        super(data);
    }
    public CGImagePropertyExifData() {}
    

    
    public boolean has(CGImagePropertyExif key) {
        return data.containsKey(key.value());
    }
    public <T extends NativeObject> T get(CGImagePropertyExif key, Class<T> type) {
        if (has(key)) {
            return data.get(key.value(), type);
        }
        return null;
    }
    public CGImagePropertyExifData set(CGImagePropertyExif key, NativeObject value) {
        data.put(key.value(), value);
        return this;
    }
    
    public String getString(CGImagePropertyExif property) {
        if (has(property)) {
            CFString val = get(property, CFString.class);
            return val.toString();
        }
        return null;
    }
    public double getNumber(CGImagePropertyExif property) {
        if (has(property)) {
            CFNumber val = get(property, CFNumber.class);
            return val.doubleValue();
        }
        return 0;
    }
    public CGImagePropertyExifData set(CGImagePropertyExif property, String value) {
        set(property, new CFString(value));
        return this;
    }
    public CGImagePropertyExifData set(CGImagePropertyExif property, double value) {
        set(property, CFNumber.valueOf(value));
        return this;
    }
    
    
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO")
@Marshaler(CGImagePropertyGIFData.Marshaler.class)
public class CGImagePropertyGIFData 
    extends CFDictionaryWrapper
     {

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyGIFData toObject(Class<CGImagePropertyGIFData> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImagePropertyGIFData(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyGIFData o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImagePropertyGIFData> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImagePropertyGIFData> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(new CGImagePropertyGIFData(o.get(i, CFDictionary.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImagePropertyGIFData> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImagePropertyGIFData i : l) {
                array.add(i.getDictionary());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    CGImagePropertyGIFData(CFDictionary data) {
        super(data);
    }
    public CGImagePropertyGIFData() {}
    

    
    public boolean has(CGImagePropertyGIF key) {
        return data.containsKey(key.value());
    }
    public <T extends NativeObject> T get(CGImagePropertyGIF key, Class<T> type) {
        if (has(key)) {
            return data.get(key.value(), type);
        }
        return null;
    }
    public CGImagePropertyGIFData set(CGImagePropertyGIF key, NativeObject value) {
        data.put(key.value(), value);
        return this;
    }
    
    public String getString(CGImagePropertyGIF property) {
        if (has(property)) {
            CFString val = get(property, CFString.class);
            return val.toString();
        }
        return null;
    }
    public double getNumber(CGImagePropertyGIF property) {
        if (has(property)) {
            CFNumber val = get(property, CFNumber.class);
            return val.doubleValue();
        }
        return 0;
    }
    public CGImagePropertyGIFData set(CGImagePropertyGIF property, String value) {
        set(property, new CFString(value));
        return this;
    }
    public CGImagePropertyGIFData set(CGImagePropertyGIF property, double value) {
        set(property, CFNumber.valueOf(value));
        return this;
    }
    
    
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO")
@Marshaler(CGImagePropertyExifAuxData.Marshaler.class)
public class CGImagePropertyExifAuxData 
    extends CFDictionaryWrapper
     {

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyExifAuxData toObject(Class<CGImagePropertyExifAuxData> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImagePropertyExifAuxData(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyExifAuxData o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImagePropertyExifAuxData> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImagePropertyExifAuxData> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(new CGImagePropertyExifAuxData(o.get(i, CFDictionary.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImagePropertyExifAuxData> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImagePropertyExifAuxData i : l) {
                array.add(i.getDictionary());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    CGImagePropertyExifAuxData(CFDictionary data) {
        super(data);
    }
    public CGImagePropertyExifAuxData() {}
    

    
    public boolean has(CGImagePropertyExifAux key) {
        return data.containsKey(key.value());
    }
    public <T extends NativeObject> T get(CGImagePropertyExifAux key, Class<T> type) {
        if (has(key)) {
            return data.get(key.value(), type);
        }
        return null;
    }
    public CGImagePropertyExifAuxData set(CGImagePropertyExifAux key, NativeObject value) {
        data.put(key.value(), value);
        return this;
    }
    
    public String getString(CGImagePropertyExifAux property) {
        if (has(property)) {
            CFString val = get(property, CFString.class);
            return val.toString();
        }
        return null;
    }
    public double getNumber(CGImagePropertyExifAux property) {
        if (has(property)) {
            CFNumber val = get(property, CFNumber.class);
            return val.doubleValue();
        }
        return 0;
    }
    public CGImagePropertyExifAuxData set(CGImagePropertyExifAux property, String value) {
        set(property, new CFString(value));
        return this;
    }
    public CGImagePropertyExifAuxData set(CGImagePropertyExifAux property, double value) {
        set(property, CFNumber.valueOf(value));
        return this;
    }
    
    
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO") @StronglyLinked
@Marshaler(CGImagePropertyGPS.Marshaler.class)
public class CGImagePropertyGPS 
    extends GlobalValueEnumeration<CFString>
     {

    static { Bro.bind(CGImagePropertyGPS.class); }

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyGPS toObject(Class<CGImagePropertyGPS> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImagePropertyGPS.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyGPS o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImagePropertyGPS> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImagePropertyGPS> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(CGImagePropertyGPS.valueOf(o.get(i, CFString.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImagePropertyGPS> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImagePropertyGPS o : l) {
                array.add(o.value());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    
    public static final CGImagePropertyGPS Version = new CGImagePropertyGPS("Version");
    
    public static final CGImagePropertyGPS LatitudeRef = new CGImagePropertyGPS("LatitudeRef");
    
    public static final CGImagePropertyGPS Latitude = new CGImagePropertyGPS("Latitude");
    
    public static final CGImagePropertyGPS LongitudeRef = new CGImagePropertyGPS("LongitudeRef");
    
    public static final CGImagePropertyGPS Longitude = new CGImagePropertyGPS("Longitude");
    
    public static final CGImagePropertyGPS AltitudeRef = new CGImagePropertyGPS("AltitudeRef");
    
    public static final CGImagePropertyGPS Altitude = new CGImagePropertyGPS("Altitude");
    
    public static final CGImagePropertyGPS TimeStamp = new CGImagePropertyGPS("TimeStamp");
    
    public static final CGImagePropertyGPS Satellites = new CGImagePropertyGPS("Satellites");
    
    public static final CGImagePropertyGPS Status = new CGImagePropertyGPS("Status");
    
    public static final CGImagePropertyGPS MeasureMode = new CGImagePropertyGPS("MeasureMode");
    
    public static final CGImagePropertyGPS DOP = new CGImagePropertyGPS("DOP");
    
    public static final CGImagePropertyGPS SpeedRef = new CGImagePropertyGPS("SpeedRef");
    
    public static final CGImagePropertyGPS Speed = new CGImagePropertyGPS("Speed");
    
    public static final CGImagePropertyGPS TrackRef = new CGImagePropertyGPS("TrackRef");
    
    public static final CGImagePropertyGPS Track = new CGImagePropertyGPS("Track");
    
    public static final CGImagePropertyGPS ImgDirectionRef = new CGImagePropertyGPS("ImgDirectionRef");
    
    public static final CGImagePropertyGPS ImgDirection = new CGImagePropertyGPS("ImgDirection");
    
    public static final CGImagePropertyGPS MapDatum = new CGImagePropertyGPS("MapDatum");
    
    public static final CGImagePropertyGPS DestLatitudeRef = new CGImagePropertyGPS("DestLatitudeRef");
    
    public static final CGImagePropertyGPS DestLatitude = new CGImagePropertyGPS("DestLatitude");
    
    public static final CGImagePropertyGPS DestLongitudeRef = new CGImagePropertyGPS("DestLongitudeRef");
    
    public static final CGImagePropertyGPS DestLongitude = new CGImagePropertyGPS("DestLongitude");
    
    public static final CGImagePropertyGPS DestBearingRef = new CGImagePropertyGPS("DestBearingRef");
    
    public static final CGImagePropertyGPS DestBearing = new CGImagePropertyGPS("DestBearing");
    
    public static final CGImagePropertyGPS DestDistanceRef = new CGImagePropertyGPS("DestDistanceRef");
    
    public static final CGImagePropertyGPS DestDistance = new CGImagePropertyGPS("DestDistance");
    
    public static final CGImagePropertyGPS ProcessingMethod = new CGImagePropertyGPS("ProcessingMethod");
    
    public static final CGImagePropertyGPS AreaInformation = new CGImagePropertyGPS("AreaInformation");
    
    public static final CGImagePropertyGPS DateStamp = new CGImagePropertyGPS("DateStamp");
    
    public static final CGImagePropertyGPS Differental = new CGImagePropertyGPS("Differental");
    
    public static final CGImagePropertyGPS HPositioningError = new CGImagePropertyGPS("HPositioningError");
    
    
    private static CGImagePropertyGPS[] values = new CGImagePropertyGPS[] {Version, LatitudeRef, Latitude, LongitudeRef, Longitude, AltitudeRef, Altitude, TimeStamp, Satellites, Status, MeasureMode, DOP, SpeedRef, Speed, TrackRef, Track, ImgDirectionRef, ImgDirection, MapDatum, DestLatitudeRef, DestLatitude, DestLongitudeRef, DestLongitude, DestBearingRef, DestBearing, DestDistanceRef, DestDistance, ProcessingMethod, AreaInformation, DateStamp, Differental, HPositioningError};
    
    CGImagePropertyGPS (String getterName) {
        super(Values.class, getterName);
    }
    
    public static CGImagePropertyGPS valueOf(CFString value) {
        for (CGImagePropertyGPS v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImagePropertyGPS.class.getName());
    }
    
    
    
    @Library("ImageIO") @StronglyLinked
    public static class Values {
    	static { Bro.bind(Values.class); }

        
        
        @GlobalValue(symbol="kCGImagePropertyGPSVersion", optional=true)
        public static native CFString Version();
        
        @GlobalValue(symbol="kCGImagePropertyGPSLatitudeRef", optional=true)
        public static native CFString LatitudeRef();
        
        @GlobalValue(symbol="kCGImagePropertyGPSLatitude", optional=true)
        public static native CFString Latitude();
        
        @GlobalValue(symbol="kCGImagePropertyGPSLongitudeRef", optional=true)
        public static native CFString LongitudeRef();
        
        @GlobalValue(symbol="kCGImagePropertyGPSLongitude", optional=true)
        public static native CFString Longitude();
        
        @GlobalValue(symbol="kCGImagePropertyGPSAltitudeRef", optional=true)
        public static native CFString AltitudeRef();
        
        @GlobalValue(symbol="kCGImagePropertyGPSAltitude", optional=true)
        public static native CFString Altitude();
        
        @GlobalValue(symbol="kCGImagePropertyGPSTimeStamp", optional=true)
        public static native CFString TimeStamp();
        
        @GlobalValue(symbol="kCGImagePropertyGPSSatellites", optional=true)
        public static native CFString Satellites();
        
        @GlobalValue(symbol="kCGImagePropertyGPSStatus", optional=true)
        public static native CFString Status();
        
        @GlobalValue(symbol="kCGImagePropertyGPSMeasureMode", optional=true)
        public static native CFString MeasureMode();
        
        @GlobalValue(symbol="kCGImagePropertyGPSDOP", optional=true)
        public static native CFString DOP();
        
        @GlobalValue(symbol="kCGImagePropertyGPSSpeedRef", optional=true)
        public static native CFString SpeedRef();
        
        @GlobalValue(symbol="kCGImagePropertyGPSSpeed", optional=true)
        public static native CFString Speed();
        
        @GlobalValue(symbol="kCGImagePropertyGPSTrackRef", optional=true)
        public static native CFString TrackRef();
        
        @GlobalValue(symbol="kCGImagePropertyGPSTrack", optional=true)
        public static native CFString Track();
        
        @GlobalValue(symbol="kCGImagePropertyGPSImgDirectionRef", optional=true)
        public static native CFString ImgDirectionRef();
        
        @GlobalValue(symbol="kCGImagePropertyGPSImgDirection", optional=true)
        public static native CFString ImgDirection();
        
        @GlobalValue(symbol="kCGImagePropertyGPSMapDatum", optional=true)
        public static native CFString MapDatum();
        
        @GlobalValue(symbol="kCGImagePropertyGPSDestLatitudeRef", optional=true)
        public static native CFString DestLatitudeRef();
        
        @GlobalValue(symbol="kCGImagePropertyGPSDestLatitude", optional=true)
        public static native CFString DestLatitude();
        
        @GlobalValue(symbol="kCGImagePropertyGPSDestLongitudeRef", optional=true)
        public static native CFString DestLongitudeRef();
        
        @GlobalValue(symbol="kCGImagePropertyGPSDestLongitude", optional=true)
        public static native CFString DestLongitude();
        
        @GlobalValue(symbol="kCGImagePropertyGPSDestBearingRef", optional=true)
        public static native CFString DestBearingRef();
        
        @GlobalValue(symbol="kCGImagePropertyGPSDestBearing", optional=true)
        public static native CFString DestBearing();
        
        @GlobalValue(symbol="kCGImagePropertyGPSDestDistanceRef", optional=true)
        public static native CFString DestDistanceRef();
        
        @GlobalValue(symbol="kCGImagePropertyGPSDestDistance", optional=true)
        public static native CFString DestDistance();
        
        @GlobalValue(symbol="kCGImagePropertyGPSProcessingMethod", optional=true)
        public static native CFString ProcessingMethod();
        
        @GlobalValue(symbol="kCGImagePropertyGPSAreaInformation", optional=true)
        public static native CFString AreaInformation();
        
        @GlobalValue(symbol="kCGImagePropertyGPSDateStamp", optional=true)
        public static native CFString DateStamp();
        
        @GlobalValue(symbol="kCGImagePropertyGPSDifferental", optional=true)
        public static native CFString Differental();
        
        @GlobalValue(symbol="kCGImagePropertyGPSHPositioningError", optional=true)
        public static native CFString HPositioningError();
        
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO")
@Marshaler(CGImagePropertyCIFFData.Marshaler.class)
public class CGImagePropertyCIFFData 
    extends CFDictionaryWrapper
     {

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyCIFFData toObject(Class<CGImagePropertyCIFFData> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImagePropertyCIFFData(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyCIFFData o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImagePropertyCIFFData> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImagePropertyCIFFData> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(new CGImagePropertyCIFFData(o.get(i, CFDictionary.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImagePropertyCIFFData> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImagePropertyCIFFData i : l) {
                array.add(i.getDictionary());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    CGImagePropertyCIFFData(CFDictionary data) {
        super(data);
    }
    public CGImagePropertyCIFFData() {}
    

    
    public boolean has(CGImagePropertyCIFF key) {
        return data.containsKey(key.value());
    }
    public <T extends NativeObject> T get(CGImagePropertyCIFF key, Class<T> type) {
        if (has(key)) {
            return data.get(key.value(), type);
        }
        return null;
    }
    public CGImagePropertyCIFFData set(CGImagePropertyCIFF key, NativeObject value) {
        data.put(key.value(), value);
        return this;
    }
    
    public String getString(CGImagePropertyCIFF property) {
        if (has(property)) {
            CFString val = get(property, CFString.class);
            return val.toString();
        }
        return null;
    }
    public double getNumber(CGImagePropertyCIFF property) {
        if (has(property)) {
            CFNumber val = get(property, CFNumber.class);
            return val.doubleValue();
        }
        return 0;
    }
    public CGImagePropertyCIFFData set(CGImagePropertyCIFF property, String value) {
        set(property, new CFString(value));
        return this;
    }
    public CGImagePropertyCIFFData set(CGImagePropertyCIFF property, double value) {
        set(property, CFNumber.valueOf(value));
        return this;
    }
    
    
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO")
@Marshaler(CGImageDestinationCopySourceOptions.Marshaler.class)
public class CGImageDestinationCopySourceOptions 
    extends CFDictionaryWrapper
     {

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImageDestinationCopySourceOptions toObject(Class<CGImageDestinationCopySourceOptions> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImageDestinationCopySourceOptions(o);
        }
        @MarshalsPointer
        public static long toNative(CGImageDestinationCopySourceOptions o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImageDestinationCopySourceOptions> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImageDestinationCopySourceOptions> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(new CGImageDestinationCopySourceOptions(o.get(i, CFDictionary.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImageDestinationCopySourceOptions> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImageDestinationCopySourceOptions i : l) {
                array.add(i.getDictionary());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    CGImageDestinationCopySourceOptions(CFDictionary data) {
        super(data);
    }
    public CGImageDestinationCopySourceOptions() {}
    

    
    public boolean has(CFString key) {
        return data.containsKey(key);
    }
    public <T extends NativeObject> T get(CFString key, Class<T> type) {
        if (has(key)) {
            return data.get(key, type);
        }
        return null;
    }
    public CGImageDestinationCopySourceOptions set(CFString key, NativeObject value) {
        data.put(key, value);
        return this;
    }
    

    
    public CGImageMetadata getMetadata() {
        if (has(Keys.DestinationMetadata())) {
            CGImageMetadata val = get(Keys.DestinationMetadata(), CGImageMetadata.class);
            return val;
        }
        return null;
    }
    
    public CGImageDestinationCopySourceOptions setMetadata(CGImageMetadata metadata) {
        set(Keys.DestinationMetadata(), metadata);
        return this;
    }
    
    public boolean mergesMetadata() {
        if (has(Keys.DestinationMergeMetadata())) {
            CFBoolean val = get(Keys.DestinationMergeMetadata(), CFBoolean.class);
            return val.booleanValue();
        }
        return false;
    }
    
    public CGImageDestinationCopySourceOptions setMergesMetadata(boolean mergesMetadata) {
        set(Keys.DestinationMergeMetadata(), CFBoolean.valueOf(mergesMetadata));
        return this;
    }
    
    public boolean shouldExcludeXMP() {
        if (has(Keys.MetadataShouldExcludeXMP())) {
            CFBoolean val = get(Keys.MetadataShouldExcludeXMP(), CFBoolean.class);
            return val.booleanValue();
        }
        return false;
    }
    
    public CGImageDestinationCopySourceOptions setShouldExcludeXMP(boolean shouldExcludeXMP) {
        set(Keys.MetadataShouldExcludeXMP(), CFBoolean.valueOf(shouldExcludeXMP));
        return this;
    }
    
    public boolean shouldExcludeGPS() {
        if (has(Keys.MetadataShouldExcludeGPS())) {
            CFBoolean val = get(Keys.MetadataShouldExcludeGPS(), CFBoolean.class);
            return val.booleanValue();
        }
        return false;
    }
    
    public CGImageDestinationCopySourceOptions setShouldExcludeGPS(boolean shouldExcludeGPS) {
        set(Keys.MetadataShouldExcludeGPS(), CFBoolean.valueOf(shouldExcludeGPS));
        return this;
    }
    
    public String getDateTime() {
        if (has(Keys.DestinationDateTime())) {
            CFString val = get(Keys.DestinationDateTime(), CFString.class);
            return val.toString();
        }
        return null;
    }
    
    public CGImageDestinationCopySourceOptions setDateTime(String dateTime) {
        set(Keys.DestinationDateTime(), new CFString(dateTime));
        return this;
    }
    
    public CGImagePropertyOrientation getOrientation() {
        if (has(Keys.DestinationOrientation())) {
            CFNumber val = get(Keys.DestinationOrientation(), CFNumber.class);
            return CGImagePropertyOrientation.valueOf(val.longValue());
        }
        return null;
    }
    
    public CGImageDestinationCopySourceOptions setOrientation(CGImagePropertyOrientation orientation) {
        set(Keys.DestinationOrientation(), CFNumber.valueOf(orientation.value()));
        return this;
    }
    
    
    public CGImageDestinationCopySourceOptions setDateTime(NSDate dateTime) {
        set(Keys.DestinationDateTime(), dateTime);
        return this;
    }
    
    
    @Library("ImageIO")
    public static class Keys {
        static { Bro.bind(Keys.class); }
        
        @GlobalValue(symbol="kCGImageDestinationMetadata", optional=true)
        public static native CFString DestinationMetadata();
        
        @GlobalValue(symbol="kCGImageDestinationMergeMetadata", optional=true)
        public static native CFString DestinationMergeMetadata();
        
        @GlobalValue(symbol="kCGImageMetadataShouldExcludeXMP", optional=true)
        public static native CFString MetadataShouldExcludeXMP();
        
        @GlobalValue(symbol="kCGImageMetadataShouldExcludeGPS", optional=true)
        public static native CFString MetadataShouldExcludeGPS();
        
        @GlobalValue(symbol="kCGImageDestinationDateTime", optional=true)
        public static native CFString DestinationDateTime();
        
        @GlobalValue(symbol="kCGImageDestinationOrientation", optional=true)
        public static native CFString DestinationOrientation();
    }
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO") @StronglyLinked
@Marshaler(CGImagePropertyIPTCContactInfo.Marshaler.class)
public class CGImagePropertyIPTCContactInfo 
    extends GlobalValueEnumeration<CFString>
     {

    static { Bro.bind(CGImagePropertyIPTCContactInfo.class); }

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyIPTCContactInfo toObject(Class<CGImagePropertyIPTCContactInfo> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImagePropertyIPTCContactInfo.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyIPTCContactInfo o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImagePropertyIPTCContactInfo> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImagePropertyIPTCContactInfo> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(CGImagePropertyIPTCContactInfo.valueOf(o.get(i, CFString.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImagePropertyIPTCContactInfo> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImagePropertyIPTCContactInfo o : l) {
                array.add(o.value());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    
    public static final CGImagePropertyIPTCContactInfo City = new CGImagePropertyIPTCContactInfo("City");
    
    public static final CGImagePropertyIPTCContactInfo Country = new CGImagePropertyIPTCContactInfo("Country");
    
    public static final CGImagePropertyIPTCContactInfo Address = new CGImagePropertyIPTCContactInfo("Address");
    
    public static final CGImagePropertyIPTCContactInfo PostalCode = new CGImagePropertyIPTCContactInfo("PostalCode");
    
    public static final CGImagePropertyIPTCContactInfo StateProvince = new CGImagePropertyIPTCContactInfo("StateProvince");
    
    public static final CGImagePropertyIPTCContactInfo Emails = new CGImagePropertyIPTCContactInfo("Emails");
    
    public static final CGImagePropertyIPTCContactInfo Phones = new CGImagePropertyIPTCContactInfo("Phones");
    
    public static final CGImagePropertyIPTCContactInfo WebURLs = new CGImagePropertyIPTCContactInfo("WebURLs");
    
    
    private static CGImagePropertyIPTCContactInfo[] values = new CGImagePropertyIPTCContactInfo[] {City, Country, Address, PostalCode, StateProvince, Emails, Phones, WebURLs};
    
    CGImagePropertyIPTCContactInfo (String getterName) {
        super(Values.class, getterName);
    }
    
    public static CGImagePropertyIPTCContactInfo valueOf(CFString value) {
        for (CGImagePropertyIPTCContactInfo v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImagePropertyIPTCContactInfo.class.getName());
    }
    
    
    
    @Library("ImageIO") @StronglyLinked
    public static class Values {
    	static { Bro.bind(Values.class); }

        
        
        @GlobalValue(symbol="kCGImagePropertyIPTCContactInfoCity", optional=true)
        public static native CFString City();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCContactInfoCountry", optional=true)
        public static native CFString Country();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCContactInfoAddress", optional=true)
        public static native CFString Address();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCContactInfoPostalCode", optional=true)
        public static native CFString PostalCode();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCContactInfoStateProvince", optional=true)
        public static native CFString StateProvince();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCContactInfoEmails", optional=true)
        public static native CFString Emails();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCContactInfoPhones", optional=true)
        public static native CFString Phones();
        
        @GlobalValue(symbol="kCGImagePropertyIPTCContactInfoWebURLs", optional=true)
        public static native CFString WebURLs();
        
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO")
@Marshaler(CGImagePropertyTIFFData.Marshaler.class)
public class CGImagePropertyTIFFData 
    extends CFDictionaryWrapper
     {

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyTIFFData toObject(Class<CGImagePropertyTIFFData> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImagePropertyTIFFData(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyTIFFData o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImagePropertyTIFFData> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImagePropertyTIFFData> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(new CGImagePropertyTIFFData(o.get(i, CFDictionary.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImagePropertyTIFFData> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImagePropertyTIFFData i : l) {
                array.add(i.getDictionary());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    CGImagePropertyTIFFData(CFDictionary data) {
        super(data);
    }
    public CGImagePropertyTIFFData() {}
    

    
    public boolean has(CGImagePropertyTIFF key) {
        return data.containsKey(key.value());
    }
    public <T extends NativeObject> T get(CGImagePropertyTIFF key, Class<T> type) {
        if (has(key)) {
            return data.get(key.value(), type);
        }
        return null;
    }
    public CGImagePropertyTIFFData set(CGImagePropertyTIFF key, NativeObject value) {
        data.put(key.value(), value);
        return this;
    }
    
    public String getString(CGImagePropertyTIFF property) {
        if (has(property)) {
            CFString val = get(property, CFString.class);
            return val.toString();
        }
        return null;
    }
    public double getNumber(CGImagePropertyTIFF property) {
        if (has(property)) {
            CFNumber val = get(property, CFNumber.class);
            return val.doubleValue();
        }
        return 0;
    }
    public CGImagePropertyTIFFData set(CGImagePropertyTIFF property, String value) {
        set(property, new CFString(value));
        return this;
    }
    public CGImagePropertyTIFFData set(CGImagePropertyTIFF property, double value) {
        set(property, CFNumber.valueOf(value));
        return this;
    }
    
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO")
@Marshaler(CGImagePropertyDNGData.Marshaler.class)
public class CGImagePropertyDNGData 
    extends CFDictionaryWrapper
     {

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyDNGData toObject(Class<CGImagePropertyDNGData> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImagePropertyDNGData(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyDNGData o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImagePropertyDNGData> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImagePropertyDNGData> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(new CGImagePropertyDNGData(o.get(i, CFDictionary.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImagePropertyDNGData> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImagePropertyDNGData i : l) {
                array.add(i.getDictionary());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    CGImagePropertyDNGData(CFDictionary data) {
        super(data);
    }
    public CGImagePropertyDNGData() {}
    

    
    public boolean has(CGImagePropertyDNG key) {
        return data.containsKey(key.value());
    }
    public <T extends NativeObject> T get(CGImagePropertyDNG key, Class<T> type) {
        if (has(key)) {
            return data.get(key.value(), type);
        }
        return null;
    }
    public CGImagePropertyDNGData set(CGImagePropertyDNG key, NativeObject value) {
        data.put(key.value(), value);
        return this;
    }
    
    public String getString(CGImagePropertyDNG property) {
        if (has(property)) {
            CFString val = get(property, CFString.class);
            return val.toString();
        }
        return null;
    }
    public double getNumber(CGImagePropertyDNG property) {
        if (has(property)) {
            CFNumber val = get(property, CFNumber.class);
            return val.doubleValue();
        }
        return 0;
    }
    public CGImagePropertyDNGData set(CGImagePropertyDNG property, String value) {
        set(property, new CFString(value));
        return this;
    }
    public CGImagePropertyDNGData set(CGImagePropertyDNG property, double value) {
        set(property, CFNumber.valueOf(value));
        return this;
    }
    
    
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Library("ImageIO") @StronglyLinked
@Marshaler(CGImagePropertyNikon.Marshaler.class)
public class CGImagePropertyNikon 
    extends GlobalValueEnumeration<CFString>
     {

    static { Bro.bind(CGImagePropertyNikon.class); }

    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyNikon toObject(Class<CGImagePropertyNikon> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImagePropertyNikon.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyNikon o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CGImagePropertyNikon> toObject(Class<? extends CFType> cls, long handle, long flags) {
            CFArray o = (CFArray) CFType.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CGImagePropertyNikon> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(CGImagePropertyNikon.valueOf(o.get(i, CFString.class)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CGImagePropertyNikon> l, long flags) {
            if (l == null) {
                return 0L;
            }
            CFArray array = CFMutableArray.create();
            for (CGImagePropertyNikon o : l) {
                array.add(o.value());
            }
            return CFType.Marshaler.toNative(array, flags);
        }
    }
    

    
    
    public static final CGImagePropertyNikon ISOSetting = new CGImagePropertyNikon("ISOSetting");
    
    public static final CGImagePropertyNikon ColorMode = new CGImagePropertyNikon("ColorMode");
    
    public static final CGImagePropertyNikon Quality = new CGImagePropertyNikon("Quality");
    
    public static final CGImagePropertyNikon WhiteBalanceMode = new CGImagePropertyNikon("WhiteBalanceMode");
    
    public static final CGImagePropertyNikon SharpenMode = new CGImagePropertyNikon("SharpenMode");
    
    public static final CGImagePropertyNikon FocusMode = new CGImagePropertyNikon("FocusMode");
    
    public static final CGImagePropertyNikon FlashSetting = new CGImagePropertyNikon("FlashSetting");
    
    public static final CGImagePropertyNikon ISOSelection = new CGImagePropertyNikon("ISOSelection");
    
    public static final CGImagePropertyNikon FlashExposureComp = new CGImagePropertyNikon("FlashExposureComp");
    
    public static final CGImagePropertyNikon ImageAdjustment = new CGImagePropertyNikon("ImageAdjustment");
    
    public static final CGImagePropertyNikon LensAdapter = new CGImagePropertyNikon("LensAdapter");
    
    public static final CGImagePropertyNikon LensType = new CGImagePropertyNikon("LensType");
    
    public static final CGImagePropertyNikon LensInfo = new CGImagePropertyNikon("LensInfo");
    
    public static final CGImagePropertyNikon FocusDistance = new CGImagePropertyNikon("FocusDistance");
    
    public static final CGImagePropertyNikon DigitalZoom = new CGImagePropertyNikon("DigitalZoom");
    
    public static final CGImagePropertyNikon ShootingMode = new CGImagePropertyNikon("ShootingMode");
    
    public static final CGImagePropertyNikon CameraSerialNumber = new CGImagePropertyNikon("CameraSerialNumber");
    
    public static final CGImagePropertyNikon ShutterCount = new CGImagePropertyNikon("ShutterCount");
    
    
    private static CGImagePropertyNikon[] values = new CGImagePropertyNikon[] {ISOSetting, ColorMode, Quality, WhiteBalanceMode, SharpenMode, FocusMode, FlashSetting, ISOSelection, FlashExposureComp, ImageAdjustment, LensAdapter, LensType, LensInfo, FocusDistance, DigitalZoom, ShootingMode, CameraSerialNumber, ShutterCount};
    
    CGImagePropertyNikon (String getterName) {
        super(Values.class, getterName);
    }
    
    public static CGImagePropertyNikon valueOf(CFString value) {
        for (CGImagePropertyNikon v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImagePropertyNikon.class.getName());
    }
    
    
    
    @Library("ImageIO") @StronglyLinked
    public static class Values {
    	static { Bro.bind(Values.class); }

        
        
        @GlobalValue(symbol="kCGImagePropertyMakerNikonISOSetting", optional=true)
        public static native CFString ISOSetting();
        
        @GlobalValue(symbol="kCGImagePropertyMakerNikonColorMode", optional=true)
        public static native CFString ColorMode();
        
        @GlobalValue(symbol="kCGImagePropertyMakerNikonQuality", optional=true)
        public static native CFString Quality();
        
        @GlobalValue(symbol="kCGImagePropertyMakerNikonWhiteBalanceMode", optional=true)
        public static native CFString WhiteBalanceMode();
        
        @GlobalValue(symbol="kCGImagePropertyMakerNikonSharpenMode", optional=true)
        public static native CFString SharpenMode();
        
        @GlobalValue(symbol="kCGImagePropertyMakerNikonFocusMode", optional=true)
        public static native CFString FocusMode();
        
        @GlobalValue(symbol="kCGImagePropertyMakerNikonFlashSetting", optional=true)
        public static native CFString FlashSetting();
        
        @GlobalValue(symbol="kCGImagePropertyMakerNikonISOSelection", optional=true)
        public static native CFString ISOSelection();
        
        @GlobalValue(symbol="kCGImagePropertyMakerNikonFlashExposureComp", optional=true)
        public static native CFString FlashExposureComp();
        
        @GlobalValue(symbol="kCGImagePropertyMakerNikonImageAdjustment", optional=true)
        public static native CFString ImageAdjustment();
        
        @GlobalValue(symbol="kCGImagePropertyMakerNikonLensAdapter", optional=true)
        public static native CFString LensAdapter();
        
        @GlobalValue(symbol="kCGImagePropertyMakerNikonLensType", optional=true)
        public static native CFString LensType();
        
        @GlobalValue(symbol="kCGImagePropertyMakerNikonLensInfo", optional=true)
        public static native CFString LensInfo();
        
        @GlobalValue(symbol="kCGImagePropertyMakerNikonFocusDistance", optional=true)
        public static native CFString FocusDistance();
        
        @GlobalValue(symbol="kCGImagePropertyMakerNikonDigitalZoom", optional=true)
        public static native CFString DigitalZoom();
        
        @GlobalValue(symbol="kCGImagePropertyMakerNikonShootingMode", optional=true)
        public static native CFString ShootingMode();
        
        @GlobalValue(symbol="kCGImagePropertyMakerNikonCameraSerialNumber", optional=true)
        public static native CFString CameraSerialNumber();
        
        @GlobalValue(symbol="kCGImagePropertyMakerNikonShutterCount", optional=true)
        public static native CFString ShutterCount();
        
    }
}

<code block>

package org.robovm.apple.corebluetooth;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.dispatch.*;




@Library("CoreBluetooth")
@Marshaler(CBAdvertisementData.Marshaler.class)
public class CBAdvertisementData 
    extends NSDictionaryWrapper
     {

    
    public static class Marshaler {
        @MarshalsPointer
        public static CBAdvertisementData toObject(Class<CBAdvertisementData> cls, long handle, long flags) {
            NSDictionary<NSString, NSObject> o = (NSDictionary<NSString, NSObject>) NSObject.Marshaler.toObject(NSDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CBAdvertisementData(o);
        }
        @MarshalsPointer
        public static long toNative(CBAdvertisementData o, long flags) {
            if (o == null) {
                return 0L;
            }
            return NSObject.Marshaler.toNative(o.data, flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CBAdvertisementData> toObject(Class<? extends NSObject> cls, long handle, long flags) {
            NSArray<NSDictionary<NSString, NSObject>> o = (NSArray<NSDictionary<NSString, NSObject>>) NSObject.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CBAdvertisementData> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(new CBAdvertisementData(o.get(i)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CBAdvertisementData> l, long flags) {
            if (l == null) {
                return 0L;
            }
            NSArray<NSDictionary<NSString, NSObject>> array = new NSMutableArray<>();
            for (CBAdvertisementData i : l) {
                array.add(i.getDictionary());
            }
            return NSObject.Marshaler.toNative(array, flags);
        }
    }
    

    
    CBAdvertisementData(NSDictionary<NSString, NSObject> data) {
        super(data);
    }
    

    
    public boolean has(NSString key) {
        return data.containsKey(key);
    }
    public NSObject get(NSString key) {
        if (has(key)) {
            return data.get(key);
        }
        return null;
    }
    

    public String getLocalName() {
        if (has(Keys.LocalName())) {
            NSString val = (NSString) get(Keys.LocalName());
            return val.toString();
        }
        return null;
    }
    public double getTxPowerLevel() {
        if (has(Keys.TxPowerLevel())) {
            NSNumber val = (NSNumber) get(Keys.TxPowerLevel());
            return val.doubleValue();
        }
        return 0;
    }
    public NSArray getServiceUUIDs() {
        if (has(Keys.ServiceUUIDs())) {
            NSArray val = (NSArray) get(Keys.ServiceUUIDs());
            return val;
        }
        return null;
    }
    public NSData getManufacturerData() {
        if (has(Keys.ManufacturerData())) {
            NSData val = (NSData) get(Keys.ManufacturerData());
            return val;
        }
        return null;
    }
    
    public NSArray<CBUUID> getOverflowServiceUUIDs() {
        if (has(Keys.OverflowServiceUUIDs())) {
            NSArray<CBUUID> val = (NSArray<CBUUID>) get(Keys.OverflowServiceUUIDs());
            return val;
        }
        return null;
    }
    
    public boolean isConnectable() {
        if (has(Keys.IsConnectable())) {
            NSNumber val = (NSNumber) get(Keys.IsConnectable());
            return val.booleanValue();
        }
        return false;
    }
    
    public NSArray<CBUUID> getSolicitedServiceUUIDs() {
        if (has(Keys.SolicitedServiceUUIDs())) {
            NSArray<CBUUID> val = (NSArray<CBUUID>) get(Keys.SolicitedServiceUUIDs());
            return val;
        }
        return null;
    }
    
    
    
    @Library("CoreBluetooth")
    public static class Keys {
        static { Bro.bind(Keys.class); }
        @GlobalValue(symbol="CBAdvertisementDataLocalNameKey", optional=true)
        public static native NSString LocalName();
        @GlobalValue(symbol="CBAdvertisementDataTxPowerLevelKey", optional=true)
        public static native NSString TxPowerLevel();
        @GlobalValue(symbol="CBAdvertisementDataServiceUUIDsKey", optional=true)
        public static native NSString ServiceUUIDs();
        @GlobalValue(symbol="CBAdvertisementDataServiceDataKey", optional=true)
        public static native NSString ServiceData();
        @GlobalValue(symbol="CBAdvertisementDataManufacturerDataKey", optional=true)
        public static native NSString ManufacturerData();
        
        @GlobalValue(symbol="CBAdvertisementDataOverflowServiceUUIDsKey", optional=true)
        public static native NSString OverflowServiceUUIDs();
        
        @GlobalValue(symbol="CBAdvertisementDataIsConnectable", optional=true)
        public static native NSString IsConnectable();
        
        @GlobalValue(symbol="CBAdvertisementDataSolicitedServiceUUIDsKey", optional=true)
        public static native NSString SolicitedServiceUUIDs();
    }
    
}

<code block>

package org.robovm.apple.corebluetooth;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.dispatch.*;




@Library("CoreBluetooth") @StronglyLinked
@Marshaler(CBUUIDIdentifier.Marshaler.class)
public class CBUUIDIdentifier 
    extends GlobalValueEnumeration<NSString>
     {

    static { Bro.bind(CBUUIDIdentifier.class); }

    
    public static class Marshaler {
        @MarshalsPointer
        public static CBUUIDIdentifier toObject(Class<CBUUIDIdentifier> cls, long handle, long flags) {
            NSString o = (NSString) NSObject.Marshaler.toObject(NSString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CBUUIDIdentifier.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CBUUIDIdentifier o, long flags) {
            if (o == null) {
                return 0L;
            }
            return NSObject.Marshaler.toNative(o.value(), flags);
        }
    }
    public static class AsListMarshaler {
        @SuppressWarnings("unchecked")
        @MarshalsPointer
        public static List<CBUUIDIdentifier> toObject(Class<? extends NSObject> cls, long handle, long flags) {
            NSArray<NSString> o = (NSArray<NSString>) NSObject.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CBUUIDIdentifier> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(CBUUIDIdentifier.valueOf(o.get(i)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CBUUIDIdentifier> l, long flags) {
            if (l == null) {
                return 0L;
            }
            NSArray<NSString> array = new NSMutableArray<>();
            for (CBUUIDIdentifier o : l) {
                array.add(o.value());
            }
            return NSObject.Marshaler.toNative(array, flags);
        }
    }
    

    
    public static final CBUUIDIdentifier CharacteristicExtendedProperties = new CBUUIDIdentifier("CharacteristicExtendedProperties");
    public static final CBUUIDIdentifier CharacteristicUserDescription = new CBUUIDIdentifier("CharacteristicUserDescription");
    public static final CBUUIDIdentifier ClientCharacteristicConfiguration = new CBUUIDIdentifier("ClientCharacteristicConfiguration");
    public static final CBUUIDIdentifier ServerCharacteristicConfiguration = new CBUUIDIdentifier("ServerCharacteristicConfiguration");
    public static final CBUUIDIdentifier CharacteristicFormat = new CBUUIDIdentifier("CharacteristicFormat");
    public static final CBUUIDIdentifier CharacteristicAggregateFormat = new CBUUIDIdentifier("CharacteristicAggregateFormat");
    
    @Deprecated
    public static final CBUUIDIdentifier GenericAccessProfile = new CBUUIDIdentifier("GenericAccessProfile");
    
    @Deprecated
    public static final CBUUIDIdentifier GenericAttributeProfile = new CBUUIDIdentifier("GenericAttributeProfile");
    
    @Deprecated
    public static final CBUUIDIdentifier DeviceName = new CBUUIDIdentifier("DeviceName");
    
    @Deprecated
    public static final CBUUIDIdentifier Appearance = new CBUUIDIdentifier("Appearance");
    
    @Deprecated
    public static final CBUUIDIdentifier PeripheralPrivacyFlag = new CBUUIDIdentifier("PeripheralPrivacyFlag");
    
    @Deprecated
    public static final CBUUIDIdentifier ReconnectionAddress = new CBUUIDIdentifier("ReconnectionAddress");
    
    @Deprecated
    public static final CBUUIDIdentifier PeripheralPreferredConnectionParameters = new CBUUIDIdentifier("PeripheralPreferredConnectionParameters");
    
    @Deprecated
    public static final CBUUIDIdentifier ServiceChanged = new CBUUIDIdentifier("ServiceChanged");
    
    
    private static CBUUIDIdentifier[] values = new CBUUIDIdentifier[] {CharacteristicExtendedProperties, CharacteristicUserDescription, ClientCharacteristicConfiguration, ServerCharacteristicConfiguration, CharacteristicFormat, CharacteristicAggregateFormat, GenericAccessProfile, GenericAttributeProfile, DeviceName, Appearance, PeripheralPrivacyFlag, ReconnectionAddress, PeripheralPreferredConnectionParameters, ServiceChanged};
    
    CBUUIDIdentifier (String getterName) {
        super(Values.class, getterName);
    }
    
    public static CBUUIDIdentifier valueOf(NSString value) {
        for (CBUUIDIdentifier v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CBUUIDIdentifier.class.getName());
    }
    
    
    
    @Library("CoreBluetooth") @StronglyLinked
    public static class Values {
    	static { Bro.bind(Values.class); }

        
        @GlobalValue(symbol="CBUUIDCharacteristicExtendedPropertiesString", optional=true)
        public static native NSString CharacteristicExtendedProperties();
        @GlobalValue(symbol="CBUUIDCharacteristicUserDescriptionString", optional=true)
        public static native NSString CharacteristicUserDescription();
        @GlobalValue(symbol="CBUUIDClientCharacteristicConfigurationString", optional=true)
        public static native NSString ClientCharacteristicConfiguration();
        @GlobalValue(symbol="CBUUIDServerCharacteristicConfigurationString", optional=true)
        public static native NSString ServerCharacteristicConfiguration();
        @GlobalValue(symbol="CBUUIDCharacteristicFormatString", optional=true)
        public static native NSString CharacteristicFormat();
        @GlobalValue(symbol="CBUUIDCharacteristicAggregateFormatString", optional=true)
        public static native NSString CharacteristicAggregateFormat();
        
        @Deprecated
        @GlobalValue(symbol="CBUUIDGenericAccessProfileString", optional=true)
        public static native NSString GenericAccessProfile();
        
        @Deprecated
        @GlobalValue(symbol="CBUUIDGenericAttributeProfileString", optional=true)
        public static native NSString GenericAttributeProfile();
        
        @Deprecated
        @GlobalValue(symbol="CBUUIDDeviceNameString", optional=true)
        public static native NSString DeviceName();
        
        @Deprecated
        @GlobalValue(symbol="CBUUIDAppearanceString", optional=true)
        public static native NSString Appearance();
        
        @Deprecated
        @GlobalValue(symbol="CBUUIDPeripheralPrivacyFlagString", optional=true)
        public static native NSString PeripheralPrivacyFlag();
        
        @Deprecated
        @GlobalValue(symbol="CBUUIDReconnectionAddressString", optional=true)
        public static native NSString ReconnectionAddress();
        
        @Deprecated
        @GlobalValue(symbol="CBUUIDPeripheralPreferredConnectionParametersString", optional=true)
        public static native NSString PeripheralPreferredConnectionParameters();
        
        @Deprecated
        @GlobalValue(symbol="CBUUIDServiceChangedString", optional=true)
        public static native NSString ServiceChanged();
        
    }
}

<code block>

package org.robovm.apple.corebluetooth;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.dispatch.*;




@Library("CoreBluetooth")
@Marshaler(CBPeripheralManagerOptions.Marshaler.class)
public class CBPeripheralManagerOptions 
    extends NSDictionaryWrapper
     {

    
    public static class Marshaler {
        @MarshalsPointer
        public static CBPeripheralManagerOptions toObject(Class<CBPeripheralManagerOptions> cls, long handle, long flags) {
            NSDictionary<NSString, NSObject> o = (NSDictionary<NSString, NSObject>) NSObject.Marshaler.toObject(NSDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CBPeripheralManagerOptions(o);
        }
        @MarshalsPointer
        public static long toNative(CBPeripheralManagerOptions o, long flags) {
            if (o == null) {
                return 0L;
            }
            return NSObject.Marshaler.toNative(o.data, flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CBPeripheralManagerOptions> toObject(Class<? extends NSObject> cls, long handle, long flags) {
            NSArray<NSDictionary<NSString, NSObject>> o = (NSArray<NSDictionary<NSString, NSObject>>) NSObject.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CBPeripheralManagerOptions> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(new CBPeripheralManagerOptions(o.get(i)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CBPeripheralManagerOptions> l, long flags) {
            if (l == null) {
                return 0L;
            }
            NSArray<NSDictionary<NSString, NSObject>> array = new NSMutableArray<>();
            for (CBPeripheralManagerOptions i : l) {
                array.add(i.getDictionary());
            }
            return NSObject.Marshaler.toNative(array, flags);
        }
    }
    

    
    CBPeripheralManagerOptions(NSDictionary<NSString, NSObject> data) {
        super(data);
    }
    public CBPeripheralManagerOptions() {}
    

    
    public boolean has(NSString key) {
        return data.containsKey(key);
    }
    public NSObject get(NSString key) {
        if (has(key)) {
            return data.get(key);
        }
        return null;
    }
    public CBPeripheralManagerOptions set(NSString key, NSObject value) {
        data.put(key, value);
        return this;
    }
    

    
    public boolean showsPowerAlert() {
        if (has(Keys.ShowPowerAlert())) {
            NSNumber val = (NSNumber) get(Keys.ShowPowerAlert());
            return val.booleanValue();
        }
        return false;
    }
    
    public CBPeripheralManagerOptions setShowsPowerAlert(boolean showsPowerAlert) {
        set(Keys.ShowPowerAlert(), NSNumber.valueOf(showsPowerAlert));
        return this;
    }
    
    public String getRestoreIdentifier() {
        if (has(Keys.RestoreIdentifier())) {
            NSString val = (NSString) get(Keys.RestoreIdentifier());
            return val.toString();
        }
        return null;
    }
    
    public CBPeripheralManagerOptions setRestoreIdentifier(String restoreIdentifier) {
        set(Keys.RestoreIdentifier(), new NSString(restoreIdentifier));
        return this;
    }
    
    
    
    @Library("CoreBluetooth")
    public static class Keys {
        static { Bro.bind(Keys.class); }
        
        @GlobalValue(symbol="CBPeripheralManagerOptionShowPowerAlertKey", optional=true)
        public static native NSString ShowPowerAlert();
        
        @GlobalValue(symbol="CBPeripheralManagerOptionRestoreIdentifierKey", optional=true)
        public static native NSString RestoreIdentifier();
    }
    
}

<code block>

package org.robovm.apple.corebluetooth;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.dispatch.*;




@Library("CoreBluetooth")
@Marshaler(CBCentralManagerRestoredState.Marshaler.class)
public class CBCentralManagerRestoredState 
    extends NSDictionaryWrapper
     {

    
    public static class Marshaler {
        @MarshalsPointer
        public static CBCentralManagerRestoredState toObject(Class<CBCentralManagerRestoredState> cls, long handle, long flags) {
            NSDictionary<NSString, NSObject> o = (NSDictionary<NSString, NSObject>) NSObject.Marshaler.toObject(NSDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CBCentralManagerRestoredState(o);
        }
        @MarshalsPointer
        public static long toNative(CBCentralManagerRestoredState o, long flags) {
            if (o == null) {
                return 0L;
            }
            return NSObject.Marshaler.toNative(o.data, flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CBCentralManagerRestoredState> toObject(Class<? extends NSObject> cls, long handle, long flags) {
            NSArray<NSDictionary<NSString, NSObject>> o = (NSArray<NSDictionary<NSString, NSObject>>) NSObject.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CBCentralManagerRestoredState> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(new CBCentralManagerRestoredState(o.get(i)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CBCentralManagerRestoredState> l, long flags) {
            if (l == null) {
                return 0L;
            }
            NSArray<NSDictionary<NSString, NSObject>> array = new NSMutableArray<>();
            for (CBCentralManagerRestoredState i : l) {
                array.add(i.getDictionary());
            }
            return NSObject.Marshaler.toNative(array, flags);
        }
    }
    

    
    CBCentralManagerRestoredState(NSDictionary<NSString, NSObject> data) {
        super(data);
    }
    

    
    public boolean has(NSString key) {
        return data.containsKey(key);
    }
    public NSObject get(NSString key) {
        if (has(key)) {
            return data.get(key);
        }
        return null;
    }
    

    
    public NSArray<CBPeripheral> getPeripherals() {
        if (has(Keys.Peripherals())) {
            NSArray<CBPeripheral> val = (NSArray<CBPeripheral>) get(Keys.Peripherals());
            return val;
        }
        return null;
    }
    
    public NSArray<CBUUID> getScanServices() {
        if (has(Keys.ScanServices())) {
            NSArray<CBUUID> val = (NSArray<CBUUID>) get(Keys.ScanServices());
            return val;
        }
        return null;
    }
    
    public CBCentralManagerScanOptions getScanOptions() {
        if (has(Keys.ScanOptions())) {
            NSDictionary<NSString, NSObject> val = (NSDictionary<NSString, NSObject>) get(Keys.ScanOptions());
            return new CBCentralManagerScanOptions(val);
        }
        return null;
    }
    
    
    
    @Library("CoreBluetooth")
    public static class Keys {
        static { Bro.bind(Keys.class); }
        
        @GlobalValue(symbol="CBCentralManagerRestoredStatePeripheralsKey", optional=true)
        public static native NSString Peripherals();
        
        @GlobalValue(symbol="CBCentralManagerRestoredStateScanServicesKey", optional=true)
        public static native NSString ScanServices();
        
        @GlobalValue(symbol="CBCentralManagerRestoredStateScanOptionsKey", optional=true)
        public static native NSString ScanOptions();
    }
    
}

<code block>

package org.robovm.apple.corebluetooth;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.dispatch.*;





@Library("CoreBluetooth") @NativeClass
public class CBUUID 
    extends NSObject 
     {

    public static class CBUUIDPtr extends Ptr<CBUUID, CBUUIDPtr> {}
    static { ObjCRuntime.bind(CBUUID.class); }
    
    
    public CBUUID() {}
    protected CBUUID(SkipInit skipInit) { super(skipInit); }
    
    
    @Property(selector = "data")
    public native NSData getData();
    
    @Property(selector = "UUIDString")
    public native String getUUIDString();
    
    
    public static CBUUID create(CBUUIDIdentifier identifier) {
        return create(identifier.value().toString());
    }
    
    @Method(selector = "UUIDWithString:")
    public static native CBUUID create(String theString);
    @Method(selector = "UUIDWithData:")
    public static native CBUUID create(NSData theData);
    @WeaklyLinked
    @Method(selector = "UUIDWithCFUUID:")
    public static native CBUUID create(CFUUID theUUID);
    
    @Method(selector = "UUIDWithNSUUID:")
    public static native CBUUID create(NSUUID theUUID);
    
}

<code block>

package org.robovm.apple.corebluetooth;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.dispatch.*;




@Library("CoreBluetooth")
@Marshaler(CBCentralManagerOptions.Marshaler.class)
public class CBCentralManagerOptions 
    extends NSDictionaryWrapper
     {

    
    public static class Marshaler {
        @MarshalsPointer
        public static CBCentralManagerOptions toObject(Class<CBCentralManagerOptions> cls, long handle, long flags) {
            NSDictionary<NSString, NSObject> o = (NSDictionary<NSString, NSObject>) NSObject.Marshaler.toObject(NSDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CBCentralManagerOptions(o);
        }
        @MarshalsPointer
        public static long toNative(CBCentralManagerOptions o, long flags) {
            if (o == null) {
                return 0L;
            }
            return NSObject.Marshaler.toNative(o.data, flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CBCentralManagerOptions> toObject(Class<? extends NSObject> cls, long handle, long flags) {
            NSArray<NSDictionary<NSString, NSObject>> o = (NSArray<NSDictionary<NSString, NSObject>>) NSObject.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CBCentralManagerOptions> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(new CBCentralManagerOptions(o.get(i)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CBCentralManagerOptions> l, long flags) {
            if (l == null) {
                return 0L;
            }
            NSArray<NSDictionary<NSString, NSObject>> array = new NSMutableArray<>();
            for (CBCentralManagerOptions i : l) {
                array.add(i.getDictionary());
            }
            return NSObject.Marshaler.toNative(array, flags);
        }
    }
    

    
    CBCentralManagerOptions(NSDictionary<NSString, NSObject> data) {
        super(data);
    }
    public CBCentralManagerOptions() {}
    

    
    public boolean has(NSString key) {
        return data.containsKey(key);
    }
    public NSObject get(NSString key) {
        if (has(key)) {
            return data.get(key);
        }
        return null;
    }
    public CBCentralManagerOptions set(NSString key, NSObject value) {
        data.put(key, value);
        return this;
    }
    

    
    public boolean showsPowerAlert() {
        if (has(Keys.ShowPowerAlert())) {
            NSNumber val = (NSNumber) get(Keys.ShowPowerAlert());
            return val.booleanValue();
        }
        return false;
    }
    
    public CBCentralManagerOptions setShowsPowerAlert(boolean showsPowerAlert) {
        set(Keys.ShowPowerAlert(), NSNumber.valueOf(showsPowerAlert));
        return this;
    }
    
    public String getRestoreIdentifier() {
        if (has(Keys.RestoreIdentifier())) {
            NSString val = (NSString) get(Keys.RestoreIdentifier());
            return val.toString();
        }
        return null;
    }
    
    public CBCentralManagerOptions setRestoreIdentifier(String restoreIdentifier) {
        set(Keys.RestoreIdentifier(), new NSString(restoreIdentifier));
        return this;
    }
    
    
    
    @Library("CoreBluetooth")
    public static class Keys {
        static { Bro.bind(Keys.class); }
        
        @GlobalValue(symbol="CBCentralManagerOptionShowPowerAlertKey", optional=true)
        public static native NSString ShowPowerAlert();
        
        @GlobalValue(symbol="CBCentralManagerOptionRestoreIdentifierKey", optional=true)
        public static native NSString RestoreIdentifier();
    }
    
}

<code block>

package org.robovm.apple.corebluetooth;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.dispatch.*;




@Library("CoreBluetooth")
@Marshaler(CBConnectPeripheralOptions.Marshaler.class)
public class CBConnectPeripheralOptions 
    extends NSDictionaryWrapper
     {

    
    public static class Marshaler {
        @MarshalsPointer
        public static CBConnectPeripheralOptions toObject(Class<CBConnectPeripheralOptions> cls, long handle, long flags) {
            NSDictionary<NSString, NSObject> o = (NSDictionary<NSString, NSObject>) NSObject.Marshaler.toObject(NSDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CBConnectPeripheralOptions(o);
        }
        @MarshalsPointer
        public static long toNative(CBConnectPeripheralOptions o, long flags) {
            if (o == null) {
                return 0L;
            }
            return NSObject.Marshaler.toNative(o.data, flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CBConnectPeripheralOptions> toObject(Class<? extends NSObject> cls, long handle, long flags) {
            NSArray<NSDictionary<NSString, NSObject>> o = (NSArray<NSDictionary<NSString, NSObject>>) NSObject.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CBConnectPeripheralOptions> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(new CBConnectPeripheralOptions(o.get(i)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CBConnectPeripheralOptions> l, long flags) {
            if (l == null) {
                return 0L;
            }
            NSArray<NSDictionary<NSString, NSObject>> array = new NSMutableArray<>();
            for (CBConnectPeripheralOptions i : l) {
                array.add(i.getDictionary());
            }
            return NSObject.Marshaler.toNative(array, flags);
        }
    }
    

    
    CBConnectPeripheralOptions(NSDictionary<NSString, NSObject> data) {
        super(data);
    }
    public CBConnectPeripheralOptions() {}
    

    
    public boolean has(NSString key) {
        return data.containsKey(key);
    }
    public NSObject get(NSString key) {
        if (has(key)) {
            return data.get(key);
        }
        return null;
    }
    public CBConnectPeripheralOptions set(NSString key, NSObject value) {
        data.put(key, value);
        return this;
    }
    

    
    public boolean notifiesOnConnection() {
        if (has(Keys.NotifyOnConnection())) {
            NSNumber val = (NSNumber) get(Keys.NotifyOnConnection());
            return val.booleanValue();
        }
        return false;
    }
    
    public CBConnectPeripheralOptions setNotifiesOnConnection(boolean notifiesOnConnection) {
        set(Keys.NotifyOnConnection(), NSNumber.valueOf(notifiesOnConnection));
        return this;
    }
    public boolean notifiesOnDisconnection() {
        if (has(Keys.NotifyOnDisconnection())) {
            NSNumber val = (NSNumber) get(Keys.NotifyOnDisconnection());
            return val.booleanValue();
        }
        return false;
    }
    public CBConnectPeripheralOptions setNotifiesOnDisconnection(boolean notifiesOnDisconnection) {
        set(Keys.NotifyOnDisconnection(), NSNumber.valueOf(notifiesOnDisconnection));
        return this;
    }
    
    public boolean notifiesOnNotification() {
        if (has(Keys.NotifyOnNotification())) {
            NSNumber val = (NSNumber) get(Keys.NotifyOnNotification());
            return val.booleanValue();
        }
        return false;
    }
    
    public CBConnectPeripheralOptions setNotifiesOnNotification(boolean notifiesOnNotification) {
        set(Keys.NotifyOnNotification(), NSNumber.valueOf(notifiesOnNotification));
        return this;
    }
    
    
    
    @Library("CoreBluetooth")
    public static class Keys {
        static { Bro.bind(Keys.class); }
        
        @GlobalValue(symbol="CBConnectPeripheralOptionNotifyOnConnectionKey", optional=true)
        public static native NSString NotifyOnConnection();
        @GlobalValue(symbol="CBConnectPeripheralOptionNotifyOnDisconnectionKey", optional=true)
        public static native NSString NotifyOnDisconnection();
        
        @GlobalValue(symbol="CBConnectPeripheralOptionNotifyOnNotificationKey", optional=true)
        public static native NSString NotifyOnNotification();
    }
    
}

<code block>

package org.robovm.apple.corebluetooth;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.dispatch.*;




@Library("CoreBluetooth")
@Marshaler(CBCentralManagerScanOptions.Marshaler.class)
public class CBCentralManagerScanOptions 
    extends NSDictionaryWrapper
     {

    
    public static class Marshaler {
        @MarshalsPointer
        public static CBCentralManagerScanOptions toObject(Class<CBCentralManagerScanOptions> cls, long handle, long flags) {
            NSDictionary<NSString, NSObject> o = (NSDictionary<NSString, NSObject>) NSObject.Marshaler.toObject(NSDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CBCentralManagerScanOptions(o);
        }
        @MarshalsPointer
        public static long toNative(CBCentralManagerScanOptions o, long flags) {
            if (o == null) {
                return 0L;
            }
            return NSObject.Marshaler.toNative(o.data, flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CBCentralManagerScanOptions> toObject(Class<? extends NSObject> cls, long handle, long flags) {
            NSArray<NSDictionary<NSString, NSObject>> o = (NSArray<NSDictionary<NSString, NSObject>>) NSObject.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CBCentralManagerScanOptions> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(new CBCentralManagerScanOptions(o.get(i)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CBCentralManagerScanOptions> l, long flags) {
            if (l == null) {
                return 0L;
            }
            NSArray<NSDictionary<NSString, NSObject>> array = new NSMutableArray<>();
            for (CBCentralManagerScanOptions i : l) {
                array.add(i.getDictionary());
            }
            return NSObject.Marshaler.toNative(array, flags);
        }
    }
    

    
    CBCentralManagerScanOptions(NSDictionary<NSString, NSObject> data) {
        super(data);
    }
    public CBCentralManagerScanOptions() {}
    

    
    public boolean has(NSString key) {
        return data.containsKey(key);
    }
    public NSObject get(NSString key) {
        if (has(key)) {
            return data.get(key);
        }
        return null;
    }
    public CBCentralManagerScanOptions set(NSString key, NSObject value) {
        data.put(key, value);
        return this;
    }
    

    public boolean allowsDuplicates() {
        if (has(Keys.AllowDuplicates())) {
            NSNumber val = (NSNumber) get(Keys.AllowDuplicates());
            return val.booleanValue();
        }
        return false;
    }
    public CBCentralManagerScanOptions setAllowsDuplicates(boolean allowsDuplicates) {
        set(Keys.AllowDuplicates(), NSNumber.valueOf(allowsDuplicates));
        return this;
    }
    
    public NSArray<CBUUID> getSolicitedServiceUUIDs() {
        if (has(Keys.SolicitedServiceUUIDs())) {
            NSArray<CBUUID> val = (NSArray<CBUUID>) get(Keys.SolicitedServiceUUIDs());
            return val;
        }
        return null;
    }
    
    public CBCentralManagerScanOptions setSolicitedServiceUUIDs(NSArray<CBUUID> solicitedServiceUUIDs) {
        set(Keys.SolicitedServiceUUIDs(), solicitedServiceUUIDs);
        return this;
    }
    
    
    
    @Library("CoreBluetooth")
    public static class Keys {
        static { Bro.bind(Keys.class); }
        @GlobalValue(symbol="CBCentralManagerScanOptionAllowDuplicatesKey", optional=true)
        public static native NSString AllowDuplicates();
        
        @GlobalValue(symbol="CBCentralManagerScanOptionSolicitedServiceUUIDsKey", optional=true)
        public static native NSString SolicitedServiceUUIDs();
    }
    
}

<code block>

package org.robovm.apple.corebluetooth;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.dispatch.*;




@Library("CoreBluetooth")
@Marshaler(CBPeripheralManagerRestoredState.Marshaler.class)
public class CBPeripheralManagerRestoredState 
    extends NSDictionaryWrapper
     {

    
    public static class Marshaler {
        @MarshalsPointer
        public static CBPeripheralManagerRestoredState toObject(Class<CBPeripheralManagerRestoredState> cls, long handle, long flags) {
            NSDictionary<NSString, NSObject> o = (NSDictionary<NSString, NSObject>) NSObject.Marshaler.toObject(NSDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CBPeripheralManagerRestoredState(o);
        }
        @MarshalsPointer
        public static long toNative(CBPeripheralManagerRestoredState o, long flags) {
            if (o == null) {
                return 0L;
            }
            return NSObject.Marshaler.toNative(o.data, flags);
        }
    }
    public static class AsListMarshaler {
        @MarshalsPointer
        public static List<CBPeripheralManagerRestoredState> toObject(Class<? extends NSObject> cls, long handle, long flags) {
            NSArray<NSDictionary<NSString, NSObject>> o = (NSArray<NSDictionary<NSString, NSObject>>) NSObject.Marshaler.toObject(cls, handle, flags);
            if (o == null) {
                return null;
            }
            List<CBPeripheralManagerRestoredState> list = new ArrayList<>();
            for (int i = 0; i < o.size(); i++) {
                list.add(new CBPeripheralManagerRestoredState(o.get(i)));
            }
            return list;
        }
        @MarshalsPointer
        public static long toNative(List<CBPeripheralManagerRestoredState> l, long flags) {
            if (l == null) {
                return 0L;
            }
            NSArray<NSDictionary<NSString, NSObject>> array = new NSMutableArray<>();
            for (CBPeripheralManagerRestoredState i : l) {
                array.add(i.getDictionary());
            }
            return NSObject.Marshaler.toNative(array, flags);
        }
    }
    

    
    CBPeripheralManagerRestoredState(NSDictionary<NSString, NSObject> data) {
        super(data);
    }
    

    
    public boolean has(NSString key) {
        return data.containsKey(key);
    }
    public NSObject get(NSString key) {
        if (has(key)) {
            return data.get(key);
        }
        return null;
    }
    

    
    public NSArray<CBMutableService> getServices() {
        if (has(Keys.Services())) {
            NSArray<CBMutableService> val = (NSArray<CBMutableService>) get(Keys.Services());
            return val;
        }
        return null;
    }
    
    public CBAdvertisementData getAdvertisementData() {
        if (has(Keys.AdvertisementData())) {
            NSDictionary<NSString, NSObject> val = (NSDictionary<NSString, NSObject>) get(Keys.AdvertisementData());
            return new CBAdvertisementData(val);
        }
        return null;
    }
    
    
    
    @Library("CoreBluetooth")
    public static class Keys {
        static { Bro.bind(Keys.class); }
        
        @GlobalValue(symbol="CBPeripheralManagerRestoredStateServicesKey", optional=true)
        public static native NSString Services();
        
        @GlobalValue(symbol="CBPeripheralManagerRestoredStateAdvertisementDataKey", optional=true)
        public static native NSString AdvertisementData();
    }
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImageMetadataEnumerationOptions.Marshaler.class)
@Library("ImageIO")
public class CGImageMetadataEnumerationOptions 
    extends CocoaUtility 
     {

    public static class Marshaler {
        @MarshalsPointer
        public static CGImageMetadataEnumerationOptions toObject(Class<CGImageMetadataEnumerationOptions> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImageMetadataEnumerationOptions(o);
        }
        @MarshalsPointer
        public static long toNative(CGImageMetadataEnumerationOptions o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    
    
    
    private CFDictionary data;
    
    protected CGImageMetadataEnumerationOptions(CFDictionary data) {
        this.data = data;
    }
    public CGImageMetadataEnumerationOptions() {
        this.data = CFMutableDictionary.create();
    }
    static { Bro.bind(CGImageMetadataEnumerationOptions.class); }
    
    
    
    
    public CFDictionary getDictionary() {
        return data;
    }
    
    
    public boolean isEnumeratingRecursively() {
        if (data.containsKey(EnumerateRecursivelyKey())) {
            CFBoolean val = data.get(EnumerateRecursivelyKey(), CFBoolean.class);
            return val.booleanValue();
        }
        return false;
    }
    
    public CGImageMetadataEnumerationOptions setEnumerateRecursively(boolean recursive) {
        data.put(EnumerateRecursivelyKey(), CFBoolean.valueOf(recursive));
        return this;
    }
    
    
    @GlobalValue(symbol="kCGImageMetadataEnumerateRecursively", optional=true)
    protected static native CFString EnumerateRecursivelyKey();
    
    @Override
    public String toString() {
        if (data != null) return data.toString();
        return super.toString();
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;

import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImagePropertyIPTCContactInfoData.Marshaler.class)
@Library("ImageIO")
public class CGImagePropertyIPTCContactInfoData 
    extends Object 
     {
    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyIPTCContactInfoData toObject(Class<CGImagePropertyIPTCContactInfoData> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImagePropertyIPTCContactInfoData(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyIPTCContactInfoData o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }

    
    
    private CFDictionary data;
    
    protected CGImagePropertyIPTCContactInfoData(CFDictionary data) {
        this.data = data;
    }
    public CGImagePropertyIPTCContactInfoData() {
        this.data = CFMutableDictionary.create();
    }
    static { Bro.bind(CGImagePropertyIPTCContactInfoData.class); }
    
    
    
    
    public CFDictionary getDictionary() {
        return data;
    }
    
    public boolean has(CGImagePropertyIPTCContactInfo property) {
        return data.containsKey(property.value());
    }
    
    public String getString(CGImagePropertyIPTCContactInfo property) {
        if (has(property)) {
            CFString val = data.get(property.value(), CFString.class);
            return val.toString();
        }
        return null;
    }
    public double getNumber(CGImagePropertyIPTCContactInfo property) {
        if (has(property)) {
            CFNumber val = data.get(property.value(), CFNumber.class);
            return val.doubleValue();
        }
        return 0;
    }
    public CGImagePropertyIPTCContactInfoData set(CGImagePropertyIPTCContactInfo property, String value) {
        data.put(property.value(), new CFString(value));
        return this;
    }
    public CGImagePropertyIPTCContactInfoData set(CGImagePropertyIPTCContactInfo property, double value) {
        data.put(property.value(), CFNumber.valueOf(value));
        return this;
    }
    
    
    @Override
    public String toString() {
        if (data != null) return data.toString();
        return super.toString();
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImageMetadataNamespace.Marshaler.class)
@Library("ImageIO")
public class CGImageMetadataNamespace 
    extends CocoaUtility 
     {

    public static class Marshaler {
        @MarshalsPointer
        public static CGImageMetadataNamespace toObject(Class<CGImageMetadataNamespace> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImageMetadataNamespace.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImageMetadataNamespace o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }
    
    
    
    static { Bro.bind(CGImageMetadataNamespace.class); }
    
    
    public static final CGImageMetadataNamespace Exif = new CGImageMetadataNamespace("ExifValue");
    
    public static final CGImageMetadataNamespace ExifAux = new CGImageMetadataNamespace("ExifAuxValue");
    
    public static final CGImageMetadataNamespace ExifEX = new CGImageMetadataNamespace("ExifEXValue");
    
    public static final CGImageMetadataNamespace DublinCore = new CGImageMetadataNamespace("DublinCoreValue");
    
    public static final CGImageMetadataNamespace IPTCCore = new CGImageMetadataNamespace("IPTCCoreValue");
    
    public static final CGImageMetadataNamespace Photoshop = new CGImageMetadataNamespace("PhotoshopValue");
    
    public static final CGImageMetadataNamespace TIFF = new CGImageMetadataNamespace("TIFFValue");
    
    public static final CGImageMetadataNamespace XMPBasic = new CGImageMetadataNamespace("XMPBasicValue");
    
    public static final CGImageMetadataNamespace XMPRights = new CGImageMetadataNamespace("XMPRightsValue");
    
    private static CGImageMetadataNamespace[] values = new CGImageMetadataNamespace[] {Exif, ExifAux, ExifEX, DublinCore, 
        IPTCCore, Photoshop, TIFF, XMPBasic, XMPRights};
    private final LazyGlobalValue<CFString> lazyGlobalValue;
    
    private CGImageMetadataNamespace(String getterName) {
        lazyGlobalValue = new LazyGlobalValue<>(getClass(), getterName);
    }
    
    
    
    public CFString value() {
        return lazyGlobalValue.value();
    }
    
    public static CGImageMetadataNamespace valueOf(CFString value) {
        for (CGImageMetadataNamespace v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImageMetadataNamespace.class.getName());
    }
    
    
    @GlobalValue(symbol="kCGImageMetadataNamespaceExif", optional=true)
    protected static native CFString ExifValue();
    
    @GlobalValue(symbol="kCGImageMetadataNamespaceExifAux", optional=true)
    protected static native CFString ExifAuxValue();
    
    @GlobalValue(symbol="kCGImageMetadataNamespaceExifEX", optional=true)
    protected static native CFString ExifEXValue();
    
    @GlobalValue(symbol="kCGImageMetadataNamespaceDublinCore", optional=true)
    protected static native CFString DublinCoreValue();
    
    @GlobalValue(symbol="kCGImageMetadataNamespaceIPTCCore", optional=true)
    protected static native CFString IPTCCoreValue();
    
    @GlobalValue(symbol="kCGImageMetadataNamespacePhotoshop", optional=true)
    protected static native CFString PhotoshopValue();
    
    @GlobalValue(symbol="kCGImageMetadataNamespaceTIFF", optional=true)
    protected static native CFString TIFFValue();
    
    @GlobalValue(symbol="kCGImageMetadataNamespaceXMPBasic", optional=true)
    protected static native CFString XMPBasicValue();
    
    @GlobalValue(symbol="kCGImageMetadataNamespaceXMPRights", optional=true)
    protected static native CFString XMPRightsValue();
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImagePropertyJFIF.Marshaler.class)
@Library("ImageIO")
public class CGImagePropertyJFIF 
    extends CocoaUtility 
     {

    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyJFIF toObject(Class<CGImagePropertyJFIF> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImagePropertyJFIF.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyJFIF o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }
    
    
    
    static { Bro.bind(CGImagePropertyJFIF.class); }
    
    
    public static final CGImagePropertyJFIF Version = new CGImagePropertyJFIF("VersionKey");
    
    public static final CGImagePropertyJFIF XDensity = new CGImagePropertyJFIF("XDensityKey");
    
    public static final CGImagePropertyJFIF YDensity = new CGImagePropertyJFIF("YDensityKey");
    
    public static final CGImagePropertyJFIF DensityUnit = new CGImagePropertyJFIF("DensityUnitKey");
    
    public static final CGImagePropertyJFIF IsProgressive = new CGImagePropertyJFIF("IsProgressiveKey");
    
    private static CGImagePropertyJFIF[] values = new CGImagePropertyJFIF[] {Version, XDensity, YDensity, DensityUnit, IsProgressive};
    private final LazyGlobalValue<CFString> lazyGlobalValue;
    
    private CGImagePropertyJFIF(String getterName) {
        lazyGlobalValue = new LazyGlobalValue<>(getClass(), getterName);
    }
    
    
    
    public CFString value() {
        return lazyGlobalValue.value();
    }
    
    public static CGImagePropertyJFIF valueOf(CFString value) {
        for (CGImagePropertyJFIF v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImagePropertyJFIF.class.getName());
    }
    
    
    @GlobalValue(symbol="kCGImagePropertyJFIFVersion", optional=true)
    protected static native CFString VersionKey();
    
    @GlobalValue(symbol="kCGImagePropertyJFIFXDensity", optional=true)
    protected static native CFString XDensityKey();
    
    @GlobalValue(symbol="kCGImagePropertyJFIFYDensity", optional=true)
    protected static native CFString YDensityKey();
    
    @GlobalValue(symbol="kCGImagePropertyJFIFDensityUnit", optional=true)
    protected static native CFString DensityUnitKey();
    
    @GlobalValue(symbol="kCGImagePropertyJFIFIsProgressive", optional=true)
    protected static native CFString IsProgressiveKey();
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImagePropertyColorModel.Marshaler.class)
@Library("ImageIO")
public class CGImagePropertyColorModel 
    extends CocoaUtility 
     {

    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyColorModel toObject(Class<CGImagePropertyColorModel> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImagePropertyColorModel.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyColorModel o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }
    
    
    
    static { Bro.bind(CGImagePropertyColorModel.class); }
    
    
    public static final CGImagePropertyColorModel RGB = new CGImagePropertyColorModel("RGBValue");
    
    public static final CGImagePropertyColorModel Gray = new CGImagePropertyColorModel("GrayValue");
    
    public static final CGImagePropertyColorModel CMYK = new CGImagePropertyColorModel("CMYKValue");
    
    public static final CGImagePropertyColorModel Lab = new CGImagePropertyColorModel("LabValue");
    
    private static CGImagePropertyColorModel[] values = new CGImagePropertyColorModel[] {RGB, Gray, CMYK, Lab};
    private final LazyGlobalValue<CFString> lazyGlobalValue;
    
    private CGImagePropertyColorModel(String getterName) {
        lazyGlobalValue = new LazyGlobalValue<>(getClass(), getterName);
    }
    
    
    
    public CFString value() {
        return lazyGlobalValue.value();
    }
    
    public static CGImagePropertyColorModel valueOf(CFString value) {
        for (CGImagePropertyColorModel v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImagePropertyColorModel.class.getName());
    }
    
    
    @GlobalValue(symbol="kCGImagePropertyColorModelRGB", optional=true)
    protected static native CFString RGBValue();
    
    @GlobalValue(symbol="kCGImagePropertyColorModelGray", optional=true)
    protected static native CFString GrayValue();
    
    @GlobalValue(symbol="kCGImagePropertyColorModelCMYK", optional=true)
    protected static native CFString CMYKValue();
    
    @GlobalValue(symbol="kCGImagePropertyColorModelLab", optional=true)
    protected static native CFString LabValue();
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImagePropertyExifAux.Marshaler.class)
@Library("ImageIO")
public class CGImagePropertyExifAux 
    extends CocoaUtility 
     {

    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyExifAux toObject(Class<CGImagePropertyExifAux> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImagePropertyExifAux.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyExifAux o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }
    
    
    
    static { Bro.bind(CGImagePropertyExifAux.class); }
    
    
    public static final CGImagePropertyExifAux LensInfo = new CGImagePropertyExifAux("LensInfoKey");
    
    public static final CGImagePropertyExifAux LensModel = new CGImagePropertyExifAux("LensModelKey");
    
    public static final CGImagePropertyExifAux SerialNumber = new CGImagePropertyExifAux("SerialNumberKey");
    
    public static final CGImagePropertyExifAux LensID = new CGImagePropertyExifAux("LensIDKey");
    
    public static final CGImagePropertyExifAux LensSerialNumber = new CGImagePropertyExifAux("LensSerialNumberKey");
    
    public static final CGImagePropertyExifAux ImageNumber = new CGImagePropertyExifAux("ImageNumberKey");
    
    public static final CGImagePropertyExifAux FlashCompensation = new CGImagePropertyExifAux("FlashCompensationKey");
    
    public static final CGImagePropertyExifAux OwnerName = new CGImagePropertyExifAux("OwnerNameKey");
    
    public static final CGImagePropertyExifAux Firmware = new CGImagePropertyExifAux("FirmwareKey");
    
    private static CGImagePropertyExifAux[] values = new CGImagePropertyExifAux[] {LensInfo, LensModel, SerialNumber, 
        LensID, LensSerialNumber, ImageNumber, FlashCompensation, OwnerName, Firmware};
    private final LazyGlobalValue<CFString> lazyGlobalValue;
    
    private CGImagePropertyExifAux(String getterName) {
        lazyGlobalValue = new LazyGlobalValue<>(getClass(), getterName);
    }
    
    
    
    public CFString value() {
        return lazyGlobalValue.value();
    }
    
    public static CGImagePropertyExifAux valueOf(CFString value) {
        for (CGImagePropertyExifAux v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImagePropertyExifAux.class.getName());
    }
    
    
    @GlobalValue(symbol="kCGImagePropertyExifAuxLensInfo", optional=true)
    protected static native CFString LensInfoKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifAuxLensModel", optional=true)
    protected static native CFString LensModelKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifAuxSerialNumber", optional=true)
    protected static native CFString SerialNumberKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifAuxLensID", optional=true)
    protected static native CFString LensIDKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifAuxLensSerialNumber", optional=true)
    protected static native CFString LensSerialNumberKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifAuxImageNumber", optional=true)
    protected static native CFString ImageNumberKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifAuxFlashCompensation", optional=true)
    protected static native CFString FlashCompensationKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifAuxOwnerName", optional=true)
    protected static native CFString OwnerNameKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifAuxFirmware", optional=true)
    protected static native CFString FirmwareKey();
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImagePropertyCIFF.Marshaler.class)
@Library("ImageIO")
public class CGImagePropertyCIFF 
    extends CocoaUtility 
     {

    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyCIFF toObject(Class<CGImagePropertyCIFF> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImagePropertyCIFF.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyCIFF o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }
    
    
    
    static { Bro.bind(CGImagePropertyCIFF.class); }
    
    
    public static final CGImagePropertyCIFF Description = new CGImagePropertyCIFF("DescriptionKey");
    
    public static final CGImagePropertyCIFF Firmware = new CGImagePropertyCIFF("FirmwareKey");
    
    public static final CGImagePropertyCIFF OwnerName = new CGImagePropertyCIFF("OwnerNameKey");
    
    public static final CGImagePropertyCIFF ImageName = new CGImagePropertyCIFF("ImageNameKey");
    
    public static final CGImagePropertyCIFF ImageFileName = new CGImagePropertyCIFF("ImageFileNameKey");
    
    public static final CGImagePropertyCIFF ReleaseMethod = new CGImagePropertyCIFF("ReleaseMethodKey");
    
    public static final CGImagePropertyCIFF ReleaseTiming = new CGImagePropertyCIFF("ReleaseTimingKey");
    
    public static final CGImagePropertyCIFF RecordID = new CGImagePropertyCIFF("RecordIDKey");
    
    public static final CGImagePropertyCIFF SelfTimingTime = new CGImagePropertyCIFF("SelfTimingTimeKey");
    
    public static final CGImagePropertyCIFF CameraSerialNumber = new CGImagePropertyCIFF("CameraSerialNumberKey");
    
    public static final CGImagePropertyCIFF ImageSerialNumber = new CGImagePropertyCIFF("ImageSerialNumberKey");
    
    public static final CGImagePropertyCIFF ContinuousDrive = new CGImagePropertyCIFF("ContinuousDriveKey");
    
    public static final CGImagePropertyCIFF FocusMode = new CGImagePropertyCIFF("FocusModeKey");
    
    public static final CGImagePropertyCIFF MeteringMode = new CGImagePropertyCIFF("MeteringModeKey");
    
    public static final CGImagePropertyCIFF ShootingMode = new CGImagePropertyCIFF("ShootingModeKey");
    
    public static final CGImagePropertyCIFF LensModel = new CGImagePropertyCIFF("LensModelKey");
    
    public static final CGImagePropertyCIFF LensMaxMM = new CGImagePropertyCIFF("LensMaxMMKey");
    
    public static final CGImagePropertyCIFF LensMinMM = new CGImagePropertyCIFF("LensMinMMKey");
    
    public static final CGImagePropertyCIFF WhiteBalanceIndex = new CGImagePropertyCIFF("WhiteBalanceIndexKey");
    
    public static final CGImagePropertyCIFF FlashExposureComp = new CGImagePropertyCIFF("FlashExposureCompKey");
    
    public static final CGImagePropertyCIFF MeasuredEV = new CGImagePropertyCIFF("MeasuredEVKey");
    
    private static CGImagePropertyCIFF[] values = new CGImagePropertyCIFF[] {Description, Firmware, OwnerName, ImageName, 
        ImageFileName, ReleaseMethod, ReleaseTiming, RecordID, SelfTimingTime, CameraSerialNumber, ImageSerialNumber, 
        ContinuousDrive, FocusMode, MeteringMode, ShootingMode, LensModel, LensMaxMM, LensMinMM, WhiteBalanceIndex, 
        FlashExposureComp, MeasuredEV};
    private final LazyGlobalValue<CFString> lazyGlobalValue;
    
    private CGImagePropertyCIFF(String getterName) {
        lazyGlobalValue = new LazyGlobalValue<>(getClass(), getterName);
    }
    
    
    
    public CFString value() {
        return lazyGlobalValue.value();
    }
    
    public static CGImagePropertyCIFF valueOf(CFString value) {
        for (CGImagePropertyCIFF v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImagePropertyCIFF.class.getName());
    }
    
    
    @GlobalValue(symbol="kCGImagePropertyCIFFDescription", optional=true)
    protected static native CFString DescriptionKey();
    
    @GlobalValue(symbol="kCGImagePropertyCIFFFirmware", optional=true)
    protected static native CFString FirmwareKey();
    
    @GlobalValue(symbol="kCGImagePropertyCIFFOwnerName", optional=true)
    protected static native CFString OwnerNameKey();
    
    @GlobalValue(symbol="kCGImagePropertyCIFFImageName", optional=true)
    protected static native CFString ImageNameKey();
    
    @GlobalValue(symbol="kCGImagePropertyCIFFImageFileName", optional=true)
    protected static native CFString ImageFileNameKey();
    
    @GlobalValue(symbol="kCGImagePropertyCIFFReleaseMethod", optional=true)
    protected static native CFString ReleaseMethodKey();
    
    @GlobalValue(symbol="kCGImagePropertyCIFFReleaseTiming", optional=true)
    protected static native CFString ReleaseTimingKey();
    
    @GlobalValue(symbol="kCGImagePropertyCIFFRecordID", optional=true)
    protected static native CFString RecordIDKey();
    
    @GlobalValue(symbol="kCGImagePropertyCIFFSelfTimingTime", optional=true)
    protected static native CFString SelfTimingTimeKey();
    
    @GlobalValue(symbol="kCGImagePropertyCIFFCameraSerialNumber", optional=true)
    protected static native CFString CameraSerialNumberKey();
    
    @GlobalValue(symbol="kCGImagePropertyCIFFImageSerialNumber", optional=true)
    protected static native CFString ImageSerialNumberKey();
    
    @GlobalValue(symbol="kCGImagePropertyCIFFContinuousDrive", optional=true)
    protected static native CFString ContinuousDriveKey();
    
    @GlobalValue(symbol="kCGImagePropertyCIFFFocusMode", optional=true)
    protected static native CFString FocusModeKey();
    
    @GlobalValue(symbol="kCGImagePropertyCIFFMeteringMode", optional=true)
    protected static native CFString MeteringModeKey();
    
    @GlobalValue(symbol="kCGImagePropertyCIFFShootingMode", optional=true)
    protected static native CFString ShootingModeKey();
    
    @GlobalValue(symbol="kCGImagePropertyCIFFLensModel", optional=true)
    protected static native CFString LensModelKey();
    
    @GlobalValue(symbol="kCGImagePropertyCIFFLensMaxMM", optional=true)
    protected static native CFString LensMaxMMKey();
    
    @GlobalValue(symbol="kCGImagePropertyCIFFLensMinMM", optional=true)
    protected static native CFString LensMinMMKey();
    
    @GlobalValue(symbol="kCGImagePropertyCIFFWhiteBalanceIndex", optional=true)
    protected static native CFString WhiteBalanceIndexKey();
    
    @GlobalValue(symbol="kCGImagePropertyCIFFFlashExposureComp", optional=true)
    protected static native CFString FlashExposureCompKey();
    
    @GlobalValue(symbol="kCGImagePropertyCIFFMeasuredEV", optional=true)
    protected static native CFString MeasuredEVKey();
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;





@Marshaler(CGImageProperties.Marshaler.class)
@Library("ImageIO")
public class CGImageProperties 
    extends CocoaUtility 
     {
    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImageProperties toObject(Class<CGImageProperties> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImageProperties(o);
        }
        @MarshalsPointer
        public static long toNative(CGImageProperties o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }

    
    
    protected CFDictionary data;
    
    public CGImageProperties(CFDictionary data) {
        this.data = data;
    }
    public CGImageProperties() {
        this.data = CFMutableDictionary.create();
    }
    static { Bro.bind(CGImageProperties.class); }
    
    
    
    
    public CFDictionary getDictionary() {
        return data;
    }
    
    
    public CGImagePropertyTIFFData getTIFFData() {
        if (data.containsKey(TIFFDictionaryKey())) {
            CFDictionary val = data.get(TIFFDictionaryKey(), CFDictionary.class);
            return new CGImagePropertyTIFFData(val);
        }
        return null;
    }
    public CGImageProperties setTIFFData(CGImagePropertyTIFFData metadata) {
        data.put(TIFFDictionaryKey(), metadata.getDictionary());
        return this;
    }
    public CGImagePropertyGIFData getGIFData() {
        if (data.containsKey(GIFDictionaryKey())) {
            CFDictionary val = data.get(GIFDictionaryKey(), CFDictionary.class);
            return new CGImagePropertyGIFData(val);
        }
        return null;
    }
    public CGImageProperties setGIFData(CGImagePropertyGIFData metadata) {
        data.put(GIFDictionaryKey(), metadata.getDictionary());
        return this;
    }
    public CGImagePropertyJFIFData getJFIFData() {
        if (data.containsKey(JFIFDictionaryKey())) {
            CFDictionary val = data.get(JFIFDictionaryKey(), CFDictionary.class);
            return new CGImagePropertyJFIFData(val);
        }
        return null;
    }
    public CGImageProperties setJFIFData(CGImagePropertyJFIFData metadata) {
        data.put(JFIFDictionaryKey(), metadata.getDictionary());
        return this;
    }
    public CGImagePropertyExifData getExifData() {
        if (data.containsKey(ExifDictionaryKey())) {
            CFDictionary val = data.get(ExifDictionaryKey(), CFDictionary.class);
            return new CGImagePropertyExifData(val);
        }
        return null;
    }
    public CGImageProperties setExifData(CGImagePropertyExifData metadata) {
        data.put(ExifDictionaryKey(), metadata.getDictionary());
        return this;
    }
    public CGImagePropertyPNGData getPNGData() {
        if (data.containsKey(PNGDictionaryKey())) {
            CFDictionary val = data.get(PNGDictionaryKey(), CFDictionary.class);
            return new CGImagePropertyPNGData(val);
        }
        return null;
    }
    public CGImageProperties setPNGData(CGImagePropertyPNGData metadata) {
        data.put(PNGDictionaryKey(), metadata.getDictionary());
        return this;
    }
    public CGImagePropertyIPTCData getIPTCData() {
        if (data.containsKey(IPTCDictionaryKey())) {
            CFDictionary val = data.get(IPTCDictionaryKey(), CFDictionary.class);
            return new CGImagePropertyIPTCData(val);
        }
        return null;
    }
    public CGImageProperties setIPTCData(CGImagePropertyIPTCData metadata) {
        data.put(PNGDictionaryKey(), metadata.getDictionary());
        return this;
    }
    public CGImagePropertyGPSData getGPSData() {
        if (data.containsKey(GPSDictionaryKey())) {
            CFDictionary val = data.get(GPSDictionaryKey(), CFDictionary.class);
            return new CGImagePropertyGPSData(val);
        }
        return null;
    }
    public CGImageProperties setGPSData(CGImagePropertyGPSData metadata) {
        data.put(GPSDictionaryKey(), metadata.getDictionary());
        return this;
    }
    public CFDictionary getRawData() {
        if (data.containsKey(RawDictionaryKey())) {
            CFDictionary val = data.get(RawDictionaryKey(), CFDictionary.class);
            return val;
        }
        return null;
    }
    public CGImageProperties setRawData(CFDictionary metadata) {
        data.put(RawDictionaryKey(), metadata);
        return this;
    }
    public CGImagePropertyCIFFData getCIFFData() {
        if (data.containsKey(CIFFDictionaryKey())) {
            CFDictionary val = data.get(CIFFDictionaryKey(), CFDictionary.class);
            return new CGImagePropertyCIFFData(val);
        }
        return null;
    }
    public CGImageProperties setCIFFData(CGImagePropertyCIFFData metadata) {
        data.put(CIFFDictionaryKey(), metadata.getDictionary());
        return this;
    }
    public CGImageProperty8BIMData get8BIMData() {
        if (data.containsKey(_8BIMDictionaryKey())) {
            CFDictionary val = data.get(_8BIMDictionaryKey(), CFDictionary.class);
            return new CGImageProperty8BIMData(val);
        }
        return null;
    }
    public CGImageProperties set8BIMData(CGImageProperty8BIMData metadata) {
        data.put(_8BIMDictionaryKey(), metadata.getDictionary());
        return this;
    }
    public CGImagePropertyDNGData getDNGData() {
        if (data.containsKey(DNGDictionaryKey())) {
            CFDictionary val = data.get(DNGDictionaryKey(), CFDictionary.class);
            return new CGImagePropertyDNGData(val);
        }
        return null;
    }
    public CGImageProperties setDNGData(CGImagePropertyDNGData metadata) {
        data.put(DNGDictionaryKey(), metadata.getDictionary());
        return this;
    }
    public CGImagePropertyExifAuxData getExifAuxData() {
        if (data.containsKey(ExifAuxDictionaryKey())) {
            CFDictionary val = data.get(ExifAuxDictionaryKey(), CFDictionary.class);
            return new CGImagePropertyExifAuxData(val);
        }
        return null;
    }
    public CGImageProperties setExifAuxData(CGImagePropertyExifAuxData metadata) {
        data.put(ExifAuxDictionaryKey(), metadata.getDictionary());
        return this;
    }
    public CGImagePropertyCanonData getMakerCanonData() {
        if (data.containsKey(MakerCanonDictionaryKey())) {
            CFDictionary val = data.get(MakerCanonDictionaryKey(), CFDictionary.class);
            return new CGImagePropertyCanonData(val);
        }
        return null;
    }
    public CGImageProperties setMakerCanonData(CGImagePropertyCanonData metadata) {
        data.put(MakerCanonDictionaryKey(), metadata.getDictionary());
        return this;
    }
    public CGImagePropertyNikonData getMakerNikonData() {
        if (data.containsKey(MakerNikonDictionaryKey())) {
            CFDictionary val = data.get(MakerNikonDictionaryKey(), CFDictionary.class);
            return new CGImagePropertyNikonData(val);
        }
        return null;
    }
    public CGImageProperties setMakerNikonData(CGImagePropertyNikonData metadata) {
        data.put(MakerNikonDictionaryKey(), metadata.getDictionary());
        return this;
    }
    public CFDictionary getMakerMinoltaData() {
        if (data.containsKey(MakerMinoltaDictionaryKey())) {
            CFDictionary val = data.get(MakerMinoltaDictionaryKey(), CFDictionary.class);
            return val;
        }
        return null;
    }
    public CGImageProperties setMakerMinoltaData(CFDictionary metadata) {
        data.put(MakerMinoltaDictionaryKey(), metadata);
        return this;
    }
    public CFDictionary getMakerFujiData() {
        if (data.containsKey(MakerFujiDictionaryKey())) {
            CFDictionary val = data.get(MakerFujiDictionaryKey(), CFDictionary.class);
            return val;
        }
        return null;
    }
    public CGImageProperties setMakerFujiData(CFDictionary metadata) {
        data.put(MakerFujiDictionaryKey(), metadata);
        return this;
    }
    public CFDictionary getMakerOlympusData() {
        if (data.containsKey(MakerOlympusDictionaryKey())) {
            CFDictionary val = data.get(MakerOlympusDictionaryKey(), CFDictionary.class);
            return val;
        }
        return null;
    }
    public CGImageProperties setMakerOlympusData(CFDictionary metadata) {
        data.put(MakerOlympusDictionaryKey(), metadata);
        return this;
    }
    public CFDictionary getMakerPentaxData() {
        if (data.containsKey(MakerPentaxDictionaryKey())) {
            CFDictionary val = data.get(MakerPentaxDictionaryKey(), CFDictionary.class);
            return val;
        }
        return null;
    }
    public CGImageProperties setMakerPentaxData(CFDictionary metadata) {
        data.put(MakerPentaxDictionaryKey(), metadata);
        return this;
    }
    
    public long getFileSize() {
        if (data.containsKey(FileSizeKey())) {
            CFNumber val = data.get(FileSizeKey(), CFNumber.class);
            return val.longValue();
        }
        return 0;
    }
    public CGImageProperties setFileSize(long fileSize) {
        data.put(FileSizeKey(), CFNumber.valueOf(fileSize));
        return this;
    }
    
    public long getDPIHeight() {
        if (data.containsKey(DPIHeightKey())) {
            CFNumber val = data.get(DPIHeightKey(), CFNumber.class);
            return val.longValue();
        }
        return 0;
    }
    public CGImageProperties setDPIHeight(long dpi) {
        data.put(DPIHeightKey(), CFNumber.valueOf(dpi));
        return this;
    }
    public long getDPIWidth() {
        if (data.containsKey(DPIWidthKey())) {
            CFNumber val = data.get(DPIWidthKey(), CFNumber.class);
            return val.longValue();
        }
        return 0;
    }
    public CGImageProperties setDPIWidth(long dpi) {
        data.put(DPIWidthKey(), CFNumber.valueOf(dpi));
        return this;
    }
    public long getPixelWidth() {
        if (data.containsKey(PixelWidthKey())) {
            CFNumber val = data.get(PixelWidthKey(), CFNumber.class);
            return val.longValue();
        }
        return 0;
    }
    public CGImageProperties setPixelWidth(long width) {
        data.put(PixelWidthKey(), CFNumber.valueOf(width));
        return this;
    }
    public long getPixelHeight() {
        if (data.containsKey(PixelHeightKey())) {
            CFNumber val = data.get(PixelHeightKey(), CFNumber.class);
            return val.longValue();
        }
        return 0;
    }
    public CGImageProperties setPixelHeight(long height) {
        data.put(PixelHeightKey(), CFNumber.valueOf(height));
        return this;
    }
    public int getDepth() {
        if (data.containsKey(DepthKey())) {
            CFNumber val = data.get(DepthKey(), CFNumber.class);
            return val.intValue();
        }
        return 0;
    }
    public CGImageProperties setDepth(int depth) {
        data.put(DepthKey(), CFNumber.valueOf(depth));
        return this;
    }
    public CGImagePropertyOrientation getOrientation() {
        if (data.containsKey(OrientationKey())) {
            CFNumber val = data.get(OrientationKey(), CFNumber.class);
            return CGImagePropertyOrientation.valueOf(val.longValue());
        }
        return null;
    }
    public CGImageProperties setOrientation(CGImagePropertyOrientation orientation) {
        data.put(OrientationKey(), CFNumber.valueOf(orientation.value()));
        return this;
    }
    public boolean isContainingFloatingPointPixels() {
        if (data.containsKey(IsFloatKey())) {
            CFBoolean val = data.get(IsFloatKey(), CFBoolean.class);
            return val.booleanValue();
        }
        return false;
    }
    public CGImageProperties setContainsFloatingPointPixels(boolean isFloat) {
        data.put(IsFloatKey(), CFBoolean.valueOf(isFloat));
        return this;
    }
    public boolean isIndexed() {
        if (data.containsKey(IsIndexedKey())) {
            CFBoolean val = data.get(IsIndexedKey(), CFBoolean.class);
            return val.booleanValue();
        }
        return false;
    }
    public CGImageProperties setIndexed(boolean isIndexed) {
        data.put(IsIndexedKey(), CFBoolean.valueOf(isIndexed));
        return this;
    }
    public boolean hasAlphaChannel() {
        if (data.containsKey(HasAlphaKey())) {
            CFBoolean val = data.get(HasAlphaKey(), CFBoolean.class);
            return val.booleanValue();
        }
        return false;
    }
    public CGImageProperties setHasAlphaChannel(boolean alphaChannel) {
        data.put(HasAlphaKey(), CFBoolean.valueOf(alphaChannel));
        return this;
    }
    public CGImagePropertyColorModel getColorModel() {
        if (data.containsKey(ColorModelKey())) {
            CFString val = data.get(ColorModelKey(), CFString.class);
            return CGImagePropertyColorModel.valueOf(val);
        }
        return null;
    }
    public CGImageProperties setColorModel(CGImagePropertyColorModel colorModel) {
        data.put(ColorModelKey(), colorModel.value());
        return this;
    }
    public String getICCProfile() {
        if (data.containsKey(ProfileNameKey())) {
            CFString val = data.get(ProfileNameKey(), CFString.class);
            return val.toString();
        }
        return null;
    }
    public CGImageProperties setICCProfile(String profile) {
        data.put(ProfileNameKey(), new CFString(profile));
        return this;
    }
    
    
    @GlobalValue(symbol="kCGImagePropertyTIFFDictionary", optional=true)
    protected static native CFString TIFFDictionaryKey();
    
    @GlobalValue(symbol="kCGImagePropertyGIFDictionary", optional=true)
    protected static native CFString GIFDictionaryKey();
    
    @GlobalValue(symbol="kCGImagePropertyJFIFDictionary", optional=true)
    protected static native CFString JFIFDictionaryKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifDictionary", optional=true)
    protected static native CFString ExifDictionaryKey();
    
    @GlobalValue(symbol="kCGImagePropertyPNGDictionary", optional=true)
    protected static native CFString PNGDictionaryKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCDictionary", optional=true)
    protected static native CFString IPTCDictionaryKey();
    
    @GlobalValue(symbol="kCGImagePropertyGPSDictionary", optional=true)
    protected static native CFString GPSDictionaryKey();
    
    @GlobalValue(symbol="kCGImagePropertyRawDictionary", optional=true)
    protected static native CFString RawDictionaryKey();
    
    @GlobalValue(symbol="kCGImagePropertyCIFFDictionary", optional=true)
    protected static native CFString CIFFDictionaryKey();
    
    @GlobalValue(symbol="kCGImagePropertyMakerCanonDictionary", optional=true)
    protected static native CFString MakerCanonDictionaryKey();
    
    @GlobalValue(symbol="kCGImagePropertyMakerNikonDictionary", optional=true)
    protected static native CFString MakerNikonDictionaryKey();
    
    @GlobalValue(symbol="kCGImagePropertyMakerMinoltaDictionary", optional=true)
    protected static native CFString MakerMinoltaDictionaryKey();
    
    @GlobalValue(symbol="kCGImagePropertyMakerFujiDictionary", optional=true)
    protected static native CFString MakerFujiDictionaryKey();
    
    @GlobalValue(symbol="kCGImagePropertyMakerOlympusDictionary", optional=true)
    protected static native CFString MakerOlympusDictionaryKey();
    
    @GlobalValue(symbol="kCGImagePropertyMakerPentaxDictionary", optional=true)
    protected static native CFString MakerPentaxDictionaryKey();
    
    @GlobalValue(symbol="kCGImageProperty8BIMDictionary", optional=true)
    protected static native CFString _8BIMDictionaryKey();
    
    @GlobalValue(symbol="kCGImagePropertyDNGDictionary", optional=true)
    protected static native CFString DNGDictionaryKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifAuxDictionary", optional=true)
    protected static native CFString ExifAuxDictionaryKey();
    
    @GlobalValue(symbol="kCGImagePropertyMakerAppleDictionary", optional=true)
    protected static native CFString MakerAppleDictionaryKey();
    
    @GlobalValue(symbol="kCGImagePropertyFileSize", optional=true)
    protected static native CFString FileSizeKey();
    
    @GlobalValue(symbol="kCGImagePropertyPixelHeight", optional=true)
    protected static native CFString PixelHeightKey();
    
    @GlobalValue(symbol="kCGImagePropertyPixelWidth", optional=true)
    protected static native CFString PixelWidthKey();
    
    @GlobalValue(symbol="kCGImagePropertyDPIHeight", optional=true)
    protected static native CFString DPIHeightKey();
    
    @GlobalValue(symbol="kCGImagePropertyDPIWidth", optional=true)
    protected static native CFString DPIWidthKey();
    
    @GlobalValue(symbol="kCGImagePropertyDepth", optional=true)
    protected static native CFString DepthKey();
    
    @GlobalValue(symbol="kCGImagePropertyOrientation", optional=true)
    protected static native CFString OrientationKey();
    
    @GlobalValue(symbol="kCGImagePropertyIsFloat", optional=true)
    protected static native CFString IsFloatKey();
    
    @GlobalValue(symbol="kCGImagePropertyIsIndexed", optional=true)
    protected static native CFString IsIndexedKey();
    
    @GlobalValue(symbol="kCGImagePropertyHasAlpha", optional=true)
    protected static native CFString HasAlphaKey();
    
    @GlobalValue(symbol="kCGImagePropertyColorModel", optional=true)
    protected static native CFString ColorModelKey();
    
    @GlobalValue(symbol="kCGImagePropertyProfileName", optional=true)
    protected static native CFString ProfileNameKey();
    
    @Override
    public String toString() {
        if (data != null) return data.toString();
        return super.toString();
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;

import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImagePropertyPNGData.Marshaler.class)
@Library("ImageIO")
public class CGImagePropertyPNGData 
    extends Object 
     {

    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyPNGData toObject(Class<CGImagePropertyPNGData> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImagePropertyPNGData(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyPNGData o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    
    
    
    private CFDictionary data;
    
    protected CGImagePropertyPNGData(CFDictionary data) {
        this.data = data;
    }
    public CGImagePropertyPNGData() {
        this.data = CFMutableDictionary.create();
    }
    static { Bro.bind(CGImagePropertyPNGData.class); }
    
    
    
    
    public CFDictionary getDictionary() {
        return data;
    }
    
    public boolean has(CGImagePropertyPNG property) {
        return data.containsKey(property.value());
    }
    
    public String getString(CGImagePropertyPNG property) {
        if (has(property)) {
            CFString val = data.get(property.value(), CFString.class);
            return val.toString();
        }
        return null;
    }
    public double getNumber(CGImagePropertyPNG property) {
        if (has(property)) {
            CFNumber val = data.get(property.value(), CFNumber.class);
            return val.doubleValue();
        }
        return 0;
    }
    public CGImagePropertyPNGData set(CGImagePropertyPNG property, String value) {
        data.put(property.value(), new CFString(value));
        return this;
    }
    public CGImagePropertyPNGData set(CGImagePropertyPNG property, double value) {
        data.put(property.value(), CFNumber.valueOf(value));
        return this;
    }
    
    
    @Override
    public String toString() {
        if (data != null) return data.toString();
        return super.toString();
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImagePropertyIPTC.Marshaler.class)
@Library("ImageIO")
public class CGImagePropertyIPTC 
    extends CocoaUtility 
     {

    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyIPTC toObject(Class<CGImagePropertyIPTC> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImagePropertyIPTC.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyIPTC o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }
    
    
    
    static { Bro.bind(CGImagePropertyIPTC.class); }
    
    
    public static final CGImagePropertyIPTC ObjectTypeReference = new CGImagePropertyIPTC("ObjectTypeReferenceKey");
    
    public static final CGImagePropertyIPTC ObjectAttributeReference = new CGImagePropertyIPTC("ObjectAttributeReferenceKey");
    
    public static final CGImagePropertyIPTC ObjectName = new CGImagePropertyIPTC("ObjectNameKey");
    
    public static final CGImagePropertyIPTC EditStatus = new CGImagePropertyIPTC("EditStatusKey");
    
    public static final CGImagePropertyIPTC EditorialUpdate = new CGImagePropertyIPTC("EditorialUpdateKey");
    
    public static final CGImagePropertyIPTC Urgency = new CGImagePropertyIPTC("UrgencyKey");
    
    public static final CGImagePropertyIPTC SubjectReference = new CGImagePropertyIPTC("SubjectReferenceKey");
    
    public static final CGImagePropertyIPTC Category = new CGImagePropertyIPTC("CategoryKey");
    
    public static final CGImagePropertyIPTC SupplementalCategory = new CGImagePropertyIPTC("SupplementalCategoryKey");
    
    public static final CGImagePropertyIPTC FixtureIdentifier = new CGImagePropertyIPTC("FixtureIdentifierKey");
    
    public static final CGImagePropertyIPTC Keywords = new CGImagePropertyIPTC("KeywordsKey");
    
    public static final CGImagePropertyIPTC ContentLocationCode = new CGImagePropertyIPTC("ContentLocationCodeKey");
    
    public static final CGImagePropertyIPTC ContentLocationName = new CGImagePropertyIPTC("ContentLocationNameKey");
    
    public static final CGImagePropertyIPTC ReleaseDate = new CGImagePropertyIPTC("ReleaseDateKey");
    
    public static final CGImagePropertyIPTC ReleaseTime = new CGImagePropertyIPTC("ReleaseTimeKey");
    
    public static final CGImagePropertyIPTC ExpirationDate = new CGImagePropertyIPTC("ExpirationDateKey");
    
    public static final CGImagePropertyIPTC ExpirationTime = new CGImagePropertyIPTC("ExpirationTimeKey");
    
    public static final CGImagePropertyIPTC SpecialInstructions = new CGImagePropertyIPTC("SpecialInstructionsKey");
    
    public static final CGImagePropertyIPTC ActionAdvised = new CGImagePropertyIPTC("ActionAdvisedKey");
    
    public static final CGImagePropertyIPTC ReferenceService = new CGImagePropertyIPTC("ReferenceServiceKey");
    
    public static final CGImagePropertyIPTC ReferenceDate = new CGImagePropertyIPTC("ReferenceDateKey");
    
    public static final CGImagePropertyIPTC ReferenceNumber = new CGImagePropertyIPTC("ReferenceNumberKey");
    
    public static final CGImagePropertyIPTC DateCreated = new CGImagePropertyIPTC("DateCreatedKey");
    
    public static final CGImagePropertyIPTC TimeCreated = new CGImagePropertyIPTC("TimeCreatedKey");
    
    public static final CGImagePropertyIPTC DigitalCreationDate = new CGImagePropertyIPTC("DigitalCreationDateKey");
    
    public static final CGImagePropertyIPTC DigitalCreationTime = new CGImagePropertyIPTC("DigitalCreationTimeKey");
    
    public static final CGImagePropertyIPTC OriginatingProgram = new CGImagePropertyIPTC("OriginatingProgramKey");
    
    public static final CGImagePropertyIPTC ProgramVersion = new CGImagePropertyIPTC("ProgramVersionKey");
    
    public static final CGImagePropertyIPTC ObjectCycle = new CGImagePropertyIPTC("ObjectCycleKey");
    
    public static final CGImagePropertyIPTC Byline = new CGImagePropertyIPTC("BylineKey");
    
    public static final CGImagePropertyIPTC BylineTitle = new CGImagePropertyIPTC("BylineTitleKey");
    
    public static final CGImagePropertyIPTC City = new CGImagePropertyIPTC("CityKey");
    
    public static final CGImagePropertyIPTC SubLocation = new CGImagePropertyIPTC("SubLocationKey");
    
    public static final CGImagePropertyIPTC ProvinceState = new CGImagePropertyIPTC("ProvinceStateKey");
    
    public static final CGImagePropertyIPTC CountryPrimaryLocationCode = new CGImagePropertyIPTC("CountryPrimaryLocationCodeKey");
    
    public static final CGImagePropertyIPTC CountryPrimaryLocationName = new CGImagePropertyIPTC("CountryPrimaryLocationNameKey");
    
    public static final CGImagePropertyIPTC OriginalTransmissionReference = new CGImagePropertyIPTC("OriginalTransmissionReferenceKey");
    
    public static final CGImagePropertyIPTC Headline = new CGImagePropertyIPTC("HeadlineKey");
    
    public static final CGImagePropertyIPTC Credit = new CGImagePropertyIPTC("CreditKey");
    
    public static final CGImagePropertyIPTC Source = new CGImagePropertyIPTC("SourceKey");
    
    public static final CGImagePropertyIPTC CopyrightNotice = new CGImagePropertyIPTC("CopyrightNoticeKey");
    
    public static final CGImagePropertyIPTC Contact = new CGImagePropertyIPTC("ContactKey");
    
    public static final CGImagePropertyIPTC CaptionAbstract = new CGImagePropertyIPTC("CaptionAbstractKey");
    
    public static final CGImagePropertyIPTC WriterEditor = new CGImagePropertyIPTC("WriterEditorKey");
    
    public static final CGImagePropertyIPTC ImageType = new CGImagePropertyIPTC("ImageTypeKey");
    
    public static final CGImagePropertyIPTC ImageOrientation = new CGImagePropertyIPTC("ImageOrientationKey");
    
    public static final CGImagePropertyIPTC LanguageIdentifier = new CGImagePropertyIPTC("LanguageIdentifierKey");
    
    public static final CGImagePropertyIPTC StarRating = new CGImagePropertyIPTC("StarRatingKey");
    
    public static final CGImagePropertyIPTC CreatorContactInfo = new CGImagePropertyIPTC("CreatorContactInfoKey");
    
    public static final CGImagePropertyIPTC RightsUsageTerms = new CGImagePropertyIPTC("RightsUsageTermsKey");
    
    public static final CGImagePropertyIPTC Scene = new CGImagePropertyIPTC("SceneKey");
    
    private static CGImagePropertyIPTC[] values = new CGImagePropertyIPTC[] {ObjectTypeReference, ObjectAttributeReference, 
        ObjectName, EditStatus, EditorialUpdate, Urgency, SubjectReference, Category, SupplementalCategory, FixtureIdentifier, 
        Keywords, ContentLocationCode, ContentLocationName, ReleaseDate, ReleaseTime, ExpirationDate, ExpirationTime, SpecialInstructions, 
        ActionAdvised, ReferenceService, ReferenceDate, ReferenceNumber, DateCreated, TimeCreated, DigitalCreationDate, DigitalCreationTime, 
        OriginatingProgram, ProgramVersion, ObjectCycle, Byline, BylineTitle, City, SubLocation, ProvinceState, CountryPrimaryLocationCode, 
        CountryPrimaryLocationName, OriginalTransmissionReference, Headline, Credit, Source, CopyrightNotice, Contact, CaptionAbstract, 
        WriterEditor, ImageType, ImageOrientation, LanguageIdentifier, StarRating, CreatorContactInfo, RightsUsageTerms, Scene};
    private final LazyGlobalValue<CFString> lazyGlobalValue;
    
    private CGImagePropertyIPTC(String getterName) {
        lazyGlobalValue = new LazyGlobalValue<>(getClass(), getterName);
    }
    
    
    
    public CFString value() {
        return lazyGlobalValue.value();
    }
    
    public static CGImagePropertyIPTC valueOf(CFString value) {
        for (CGImagePropertyIPTC v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImagePropertyIPTC.class.getName());
    }
    
    
    @GlobalValue(symbol="kCGImagePropertyIPTCObjectTypeReference", optional=true)
    protected static native CFString ObjectTypeReferenceKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCObjectAttributeReference", optional=true)
    protected static native CFString ObjectAttributeReferenceKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCObjectName", optional=true)
    protected static native CFString ObjectNameKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCEditStatus", optional=true)
    protected static native CFString EditStatusKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCEditorialUpdate", optional=true)
    protected static native CFString EditorialUpdateKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCUrgency", optional=true)
    protected static native CFString UrgencyKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCSubjectReference", optional=true)
    protected static native CFString SubjectReferenceKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCCategory", optional=true)
    protected static native CFString CategoryKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCSupplementalCategory", optional=true)
    protected static native CFString SupplementalCategoryKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCFixtureIdentifier", optional=true)
    protected static native CFString FixtureIdentifierKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCKeywords", optional=true)
    protected static native CFString KeywordsKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCContentLocationCode", optional=true)
    protected static native CFString ContentLocationCodeKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCContentLocationName", optional=true)
    protected static native CFString ContentLocationNameKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCReleaseDate", optional=true)
    protected static native CFString ReleaseDateKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCReleaseTime", optional=true)
    protected static native CFString ReleaseTimeKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCExpirationDate", optional=true)
    protected static native CFString ExpirationDateKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCExpirationTime", optional=true)
    protected static native CFString ExpirationTimeKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCSpecialInstructions", optional=true)
    protected static native CFString SpecialInstructionsKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCActionAdvised", optional=true)
    protected static native CFString ActionAdvisedKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCReferenceService", optional=true)
    protected static native CFString ReferenceServiceKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCReferenceDate", optional=true)
    protected static native CFString ReferenceDateKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCReferenceNumber", optional=true)
    protected static native CFString ReferenceNumberKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCDateCreated", optional=true)
    protected static native CFString DateCreatedKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCTimeCreated", optional=true)
    protected static native CFString TimeCreatedKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCDigitalCreationDate", optional=true)
    protected static native CFString DigitalCreationDateKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCDigitalCreationTime", optional=true)
    protected static native CFString DigitalCreationTimeKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCOriginatingProgram", optional=true)
    protected static native CFString OriginatingProgramKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCProgramVersion", optional=true)
    protected static native CFString ProgramVersionKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCObjectCycle", optional=true)
    protected static native CFString ObjectCycleKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCByline", optional=true)
    protected static native CFString BylineKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCBylineTitle", optional=true)
    protected static native CFString BylineTitleKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCCity", optional=true)
    protected static native CFString CityKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCSubLocation", optional=true)
    protected static native CFString SubLocationKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCProvinceState", optional=true)
    protected static native CFString ProvinceStateKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCCountryPrimaryLocationCode", optional=true)
    protected static native CFString CountryPrimaryLocationCodeKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCCountryPrimaryLocationName", optional=true)
    protected static native CFString CountryPrimaryLocationNameKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCOriginalTransmissionReference", optional=true)
    protected static native CFString OriginalTransmissionReferenceKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCHeadline", optional=true)
    protected static native CFString HeadlineKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCCredit", optional=true)
    protected static native CFString CreditKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCSource", optional=true)
    protected static native CFString SourceKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCCopyrightNotice", optional=true)
    protected static native CFString CopyrightNoticeKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCContact", optional=true)
    protected static native CFString ContactKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCCaptionAbstract", optional=true)
    protected static native CFString CaptionAbstractKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCWriterEditor", optional=true)
    protected static native CFString WriterEditorKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCImageType", optional=true)
    protected static native CFString ImageTypeKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCImageOrientation", optional=true)
    protected static native CFString ImageOrientationKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCLanguageIdentifier", optional=true)
    protected static native CFString LanguageIdentifierKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCStarRating", optional=true)
    protected static native CFString StarRatingKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCCreatorContactInfo", optional=true)
    protected static native CFString CreatorContactInfoKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCRightsUsageTerms", optional=true)
    protected static native CFString RightsUsageTermsKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCScene", optional=true)
    protected static native CFString SceneKey();
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;

import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImagePropertyJFIFData.Marshaler.class)
@Library("ImageIO")
public class CGImagePropertyJFIFData 
    extends Object 
     {

    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyJFIFData toObject(Class<CGImagePropertyJFIFData> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImagePropertyJFIFData(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyJFIFData o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    
    
    
    private CFDictionary data;
    
    protected CGImagePropertyJFIFData(CFDictionary data) {
        this.data = data;
    }
    public CGImagePropertyJFIFData() {
        this.data = CFMutableDictionary.create();
    }
    static { Bro.bind(CGImagePropertyJFIFData.class); }
    
    
    
    
    public CFDictionary getDictionary() {
        return data;
    }
    
    public boolean has(CGImagePropertyJFIF property) {
        return data.containsKey(property.value());
    }
    
    public String getString(CGImagePropertyJFIF property) {
        if (has(property)) {
            CFString val = data.get(property.value(), CFString.class);
            return val.toString();
        }
        return null;
    }
    public double getNumber(CGImagePropertyJFIF property) {
        if (has(property)) {
            CFNumber val = data.get(property.value(), CFNumber.class);
            return val.doubleValue();
        }
        return 0;
    }
    public CGImagePropertyJFIFData set(CGImagePropertyJFIF property, String value) {
        data.put(property.value(), new CFString(value));
        return this;
    }
    public CGImagePropertyJFIFData set(CGImagePropertyJFIF property, double value) {
        data.put(property.value(), CFNumber.valueOf(value));
        return this;
    }
    
    
    @Override
    public String toString() {
        if (data != null) return data.toString();
        return super.toString();
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;

import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImagePropertyNikonData.Marshaler.class)
@Library("ImageIO")
public class CGImagePropertyNikonData 
    extends Object 
     {

    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyNikonData toObject(Class<CGImagePropertyNikonData> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImagePropertyNikonData(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyNikonData o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    
    
    
    private CFDictionary data;
    
    protected CGImagePropertyNikonData(CFDictionary data) {
        this.data = data;
    }
    public CGImagePropertyNikonData() {
        this.data = CFMutableDictionary.create();
    }
    static { Bro.bind(CGImagePropertyNikonData.class); }
    
    
    
    
    public CFDictionary getDictionary() {
        return data;
    }
    
    public boolean has(CGImagePropertyNikon property) {
        return data.containsKey(property.value());
    }
    
    public String getString(CGImagePropertyNikon property) {
        if (has(property)) {
            CFString val = data.get(property.value(), CFString.class);
            return val.toString();
        }
        return null;
    }
    public double getNumber(CGImagePropertyNikon property) {
        if (has(property)) {
            CFNumber val = data.get(property.value(), CFNumber.class);
            return val.doubleValue();
        }
        return 0;
    }
    public CGImagePropertyNikonData set(CGImagePropertyNikon property, String value) {
        data.put(property.value(), new CFString(value));
        return this;
    }
    public CGImagePropertyNikonData set(CGImagePropertyNikon property, double value) {
        data.put(property.value(), CFNumber.valueOf(value));
        return this;
    }
    
    
    @Override
    public String toString() {
        if (data != null) return data.toString();
        return super.toString();
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImagePropertyExif.Marshaler.class)
@Library("ImageIO")
public class CGImagePropertyExif 
    extends CocoaUtility 
     {
    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyExif toObject(Class<CGImagePropertyExif> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImagePropertyExif.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyExif o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }

    
    
    static { Bro.bind(CGImagePropertyExif.class); }
    
    
    public static final CGImagePropertyExif ExposureTime = new CGImagePropertyExif("ExposureTimeKey");
    
    public static final CGImagePropertyExif FNumber = new CGImagePropertyExif("FNumberKey");
    
    public static final CGImagePropertyExif ExposureProgram = new CGImagePropertyExif("ExposureProgramKey");
    
    public static final CGImagePropertyExif SpectralSensitivity = new CGImagePropertyExif("SpectralSensitivityKey");
    
    public static final CGImagePropertyExif ISOSpeedRatings = new CGImagePropertyExif("ISOSpeedRatingsKey");
    
    public static final CGImagePropertyExif OECF = new CGImagePropertyExif("OECFKey");
    
    public static final CGImagePropertyExif Version = new CGImagePropertyExif("VersionKey");
    
    public static final CGImagePropertyExif DateTimeOriginal = new CGImagePropertyExif("DateTimeOriginalKey");
    
    public static final CGImagePropertyExif DateTimeDigitized = new CGImagePropertyExif("DateTimeDigitizedKey");
    
    public static final CGImagePropertyExif ComponentsConfiguration = new CGImagePropertyExif("ComponentsConfigurationKey");
    
    public static final CGImagePropertyExif CompressedBitsPerPixel = new CGImagePropertyExif("CompressedBitsPerPixelKey");
    
    public static final CGImagePropertyExif ShutterSpeedValue = new CGImagePropertyExif("ShutterSpeedValueKey");
    
    public static final CGImagePropertyExif ApertureValue = new CGImagePropertyExif("ApertureValueKey");
    
    public static final CGImagePropertyExif BrightnessValue = new CGImagePropertyExif("BrightnessValueKey");
    
    public static final CGImagePropertyExif ExposureBiasValue = new CGImagePropertyExif("ExposureBiasValueKey");
    
    public static final CGImagePropertyExif MaxApertureValue = new CGImagePropertyExif("MaxApertureValueKey");
    
    public static final CGImagePropertyExif SubjectDistance = new CGImagePropertyExif("SubjectDistanceKey");
    
    public static final CGImagePropertyExif MeteringMode = new CGImagePropertyExif("MeteringModeKey");
    
    public static final CGImagePropertyExif LightSource = new CGImagePropertyExif("LightSourceKey");
    
    public static final CGImagePropertyExif Flash = new CGImagePropertyExif("FlashKey");
    
    public static final CGImagePropertyExif FocalLength = new CGImagePropertyExif("FocalLengthKey");
    
    public static final CGImagePropertyExif SubjectArea = new CGImagePropertyExif("SubjectAreaKey");
    
    public static final CGImagePropertyExif MakerNote = new CGImagePropertyExif("MakerNoteKey");
    
    public static final CGImagePropertyExif UserComment = new CGImagePropertyExif("UserCommentKey");
    
    public static final CGImagePropertyExif SubsecTime = new CGImagePropertyExif("SubsecTimeKey");
    
    public static final CGImagePropertyExif SubsecTimeOrginal = new CGImagePropertyExif("SubsecTimeOrginalKey");
    
    public static final CGImagePropertyExif SubsecTimeDigitized = new CGImagePropertyExif("SubsecTimeDigitizedKey");
    
    public static final CGImagePropertyExif FlashPixVersion = new CGImagePropertyExif("FlashPixVersionKey");
    
    public static final CGImagePropertyExif ColorSpace = new CGImagePropertyExif("ColorSpaceKey");
    
    public static final CGImagePropertyExif PixelXDimension = new CGImagePropertyExif("PixelXDimensionKey");
    
    public static final CGImagePropertyExif PixelYDimension = new CGImagePropertyExif("PixelYDimensionKey");
    
    public static final CGImagePropertyExif RelatedSoundFile = new CGImagePropertyExif("RelatedSoundFileKey");
    
    public static final CGImagePropertyExif FlashEnergy = new CGImagePropertyExif("FlashEnergyKey");
    
    public static final CGImagePropertyExif SpatialFrequencyResponse = new CGImagePropertyExif("SpatialFrequencyResponseKey");
    
    public static final CGImagePropertyExif FocalPlaneXResolution = new CGImagePropertyExif("FocalPlaneXResolutionKey");
    
    public static final CGImagePropertyExif FocalPlaneYResolution = new CGImagePropertyExif("FocalPlaneYResolutionKey");
    
    public static final CGImagePropertyExif FocalPlaneResolutionUnit = new CGImagePropertyExif("FocalPlaneResolutionUnitKey");
    
    public static final CGImagePropertyExif SubjectLocation = new CGImagePropertyExif("SubjectLocationKey");
    
    public static final CGImagePropertyExif ExposureIndex = new CGImagePropertyExif("ExposureIndexKey");
    
    public static final CGImagePropertyExif SensingMethod = new CGImagePropertyExif("SensingMethodKey");
    
    public static final CGImagePropertyExif FileSource = new CGImagePropertyExif("FileSourceKey");
    
    public static final CGImagePropertyExif SceneType = new CGImagePropertyExif("SceneTypeKey");
    
    public static final CGImagePropertyExif CFAPattern = new CGImagePropertyExif("CFAPatternKey");
    
    public static final CGImagePropertyExif CustomRendered = new CGImagePropertyExif("CustomRenderedKey");
    
    public static final CGImagePropertyExif ExposureMode = new CGImagePropertyExif("ExposureModeKey");
    
    public static final CGImagePropertyExif WhiteBalance = new CGImagePropertyExif("WhiteBalanceKey");
    
    public static final CGImagePropertyExif DigitalZoomRatio = new CGImagePropertyExif("DigitalZoomRatioKey");
    
    public static final CGImagePropertyExif FocalLenIn35mmFilm = new CGImagePropertyExif("FocalLenIn35mmFilmKey");
    
    public static final CGImagePropertyExif SceneCaptureType = new CGImagePropertyExif("SceneCaptureTypeKey");
    
    public static final CGImagePropertyExif GainControl = new CGImagePropertyExif("GainControlKey");
    
    public static final CGImagePropertyExif Contrast = new CGImagePropertyExif("ContrastKey");
    
    public static final CGImagePropertyExif Saturation = new CGImagePropertyExif("SaturationKey");
    
    public static final CGImagePropertyExif Sharpness = new CGImagePropertyExif("SharpnessKey");
    
    public static final CGImagePropertyExif DeviceSettingDescription = new CGImagePropertyExif("DeviceSettingDescriptionKey");
    
    public static final CGImagePropertyExif SubjectDistRange = new CGImagePropertyExif("SubjectDistRangeKey");
    
    public static final CGImagePropertyExif ImageUniqueID = new CGImagePropertyExif("ImageUniqueIDKey");
    
    public static final CGImagePropertyExif Gamma = new CGImagePropertyExif("GammaKey");
    
    public static final CGImagePropertyExif LensSerialNumber = new CGImagePropertyExif("LensSerialNumberKey");
    
    public static final CGImagePropertyExif CameraOwnerName = new CGImagePropertyExif("CameraOwnerNameKey");
    
    public static final CGImagePropertyExif BodySerialNumber = new CGImagePropertyExif("BodySerialNumberKey");
    
    public static final CGImagePropertyExif LensSpecification = new CGImagePropertyExif("LensSpecificationKey");
    
    public static final CGImagePropertyExif LensMake = new CGImagePropertyExif("LensMakeKey");
    
    public static final CGImagePropertyExif LensModel = new CGImagePropertyExif("LensModelKey");
    
    public static final CGImagePropertyExif SensitivityType = new CGImagePropertyExif("SensitivityTypeKey");
    
    public static final CGImagePropertyExif StandardOutputSensitivity = new CGImagePropertyExif("StandardOutputSensitivityKey");
    
    public static final CGImagePropertyExif RecommendedExposureIndex = new CGImagePropertyExif("RecommendedExposureIndexKey");
    
    public static final CGImagePropertyExif ISOSpeed = new CGImagePropertyExif("ISOSpeedKey");
    
    public static final CGImagePropertyExif ISOSpeedLatitudeyyy = new CGImagePropertyExif("ISOSpeedLatitudeyyyKey");
    
    public static final CGImagePropertyExif ISOSpeedLatitudezzz = new CGImagePropertyExif("ISOSpeedLatitudezzzKey");

    
    private static CGImagePropertyExif[] values = new CGImagePropertyExif[] {ExposureTime, FNumber, ExposureProgram, SpectralSensitivity, 
        ISOSpeedRatings, OECF, Version, DateTimeOriginal, DateTimeDigitized, ComponentsConfiguration, CompressedBitsPerPixel, ShutterSpeedValue, 
        ApertureValue, BrightnessValue, ExposureBiasValue, MaxApertureValue, SubjectDistance, MeteringMode, LightSource, Flash, FocalLength, 
        SubjectArea, MakerNote, UserComment, SubsecTime, SubsecTimeOrginal, SubsecTimeDigitized, FlashPixVersion, ColorSpace, PixelXDimension, 
        PixelYDimension, RelatedSoundFile, FlashEnergy, SpatialFrequencyResponse, FocalPlaneXResolution, FocalPlaneYResolution, FocalPlaneResolutionUnit, 
        SubjectLocation, ExposureIndex, SensingMethod, FileSource, SceneType, CFAPattern, CustomRendered, ExposureMode, WhiteBalance, DigitalZoomRatio, 
        FocalLenIn35mmFilm, SceneCaptureType, GainControl, Contrast, Saturation, Sharpness, DeviceSettingDescription, SubjectDistRange, ImageUniqueID, 
        Gamma, LensSerialNumber, CameraOwnerName, BodySerialNumber, LensSpecification, LensMake, LensModel, SensitivityType, StandardOutputSensitivity, 
        RecommendedExposureIndex, ISOSpeed, ISOSpeedLatitudeyyy, ISOSpeedLatitudezzz};
    private final LazyGlobalValue<CFString> lazyGlobalValue;
    
    private CGImagePropertyExif(String getterName) {
        lazyGlobalValue = new LazyGlobalValue<>(getClass(), getterName);
    }
    
    
    
    public CFString value() {
        return lazyGlobalValue.value();
    }
    
    public static CGImagePropertyExif valueOf(CFString value) {
        for (CGImagePropertyExif v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImagePropertyExif.class.getName());
    }
    
    
    @GlobalValue(symbol="kCGImagePropertyExifExposureTime", optional=true)
    protected static native CFString ExposureTimeKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifFNumber", optional=true)
    protected static native CFString FNumberKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifExposureProgram", optional=true)
    protected static native CFString ExposureProgramKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifSpectralSensitivity", optional=true)
    protected static native CFString SpectralSensitivityKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifISOSpeedRatings", optional=true)
    protected static native CFString ISOSpeedRatingsKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifOECF", optional=true)
    protected static native CFString OECFKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifSensitivityType", optional=true)
    protected static native CFString SensitivityTypeKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifStandardOutputSensitivity", optional=true)
    protected static native CFString StandardOutputSensitivityKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifRecommendedExposureIndex", optional=true)
    protected static native CFString RecommendedExposureIndexKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifISOSpeed", optional=true)
    protected static native CFString ISOSpeedKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifISOSpeedLatitudeyyy", optional=true)
    protected static native CFString ISOSpeedLatitudeyyyKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifISOSpeedLatitudezzz", optional=true)
    protected static native CFString ISOSpeedLatitudezzzKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifVersion", optional=true)
    protected static native CFString VersionKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifDateTimeOriginal", optional=true)
    protected static native CFString DateTimeOriginalKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifDateTimeDigitized", optional=true)
    protected static native CFString DateTimeDigitizedKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifComponentsConfiguration", optional=true)
    protected static native CFString ComponentsConfigurationKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifCompressedBitsPerPixel", optional=true)
    protected static native CFString CompressedBitsPerPixelKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifShutterSpeedValue", optional=true)
    protected static native CFString ShutterSpeedValueKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifApertureValue", optional=true)
    protected static native CFString ApertureValueKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifBrightnessValue", optional=true)
    protected static native CFString BrightnessValueKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifExposureBiasValue", optional=true)
    protected static native CFString ExposureBiasValueKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifMaxApertureValue", optional=true)
    protected static native CFString MaxApertureValueKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifSubjectDistance", optional=true)
    protected static native CFString SubjectDistanceKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifMeteringMode", optional=true)
    protected static native CFString MeteringModeKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifLightSource", optional=true)
    protected static native CFString LightSourceKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifFlash", optional=true)
    protected static native CFString FlashKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifFocalLength", optional=true)
    protected static native CFString FocalLengthKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifSubjectArea", optional=true)
    protected static native CFString SubjectAreaKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifMakerNote", optional=true)
    protected static native CFString MakerNoteKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifUserComment", optional=true)
    protected static native CFString UserCommentKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifSubsecTime", optional=true)
    protected static native CFString SubsecTimeKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifSubsecTimeOrginal", optional=true)
    protected static native CFString SubsecTimeOrginalKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifSubsecTimeDigitized", optional=true)
    protected static native CFString SubsecTimeDigitizedKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifFlashPixVersion", optional=true)
    protected static native CFString FlashPixVersionKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifColorSpace", optional=true)
    protected static native CFString ColorSpaceKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifPixelXDimension", optional=true)
    protected static native CFString PixelXDimensionKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifPixelYDimension", optional=true)
    protected static native CFString PixelYDimensionKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifRelatedSoundFile", optional=true)
    protected static native CFString RelatedSoundFileKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifFlashEnergy", optional=true)
    protected static native CFString FlashEnergyKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifSpatialFrequencyResponse", optional=true)
    protected static native CFString SpatialFrequencyResponseKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifFocalPlaneXResolution", optional=true)
    protected static native CFString FocalPlaneXResolutionKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifFocalPlaneYResolution", optional=true)
    protected static native CFString FocalPlaneYResolutionKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifFocalPlaneResolutionUnit", optional=true)
    protected static native CFString FocalPlaneResolutionUnitKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifSubjectLocation", optional=true)
    protected static native CFString SubjectLocationKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifExposureIndex", optional=true)
    protected static native CFString ExposureIndexKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifSensingMethod", optional=true)
    protected static native CFString SensingMethodKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifFileSource", optional=true)
    protected static native CFString FileSourceKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifSceneType", optional=true)
    protected static native CFString SceneTypeKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifCFAPattern", optional=true)
    protected static native CFString CFAPatternKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifCustomRendered", optional=true)
    protected static native CFString CustomRenderedKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifExposureMode", optional=true)
    protected static native CFString ExposureModeKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifWhiteBalance", optional=true)
    protected static native CFString WhiteBalanceKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifDigitalZoomRatio", optional=true)
    protected static native CFString DigitalZoomRatioKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifFocalLenIn35mmFilm", optional=true)
    protected static native CFString FocalLenIn35mmFilmKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifSceneCaptureType", optional=true)
    protected static native CFString SceneCaptureTypeKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifGainControl", optional=true)
    protected static native CFString GainControlKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifContrast", optional=true)
    protected static native CFString ContrastKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifSaturation", optional=true)
    protected static native CFString SaturationKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifSharpness", optional=true)
    protected static native CFString SharpnessKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifDeviceSettingDescription", optional=true)
    protected static native CFString DeviceSettingDescriptionKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifSubjectDistRange", optional=true)
    protected static native CFString SubjectDistRangeKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifImageUniqueID", optional=true)
    protected static native CFString ImageUniqueIDKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifCameraOwnerName", optional=true)
    protected static native CFString CameraOwnerNameKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifBodySerialNumber", optional=true)
    protected static native CFString BodySerialNumberKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifLensSpecification", optional=true)
    protected static native CFString LensSpecificationKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifLensMake", optional=true)
    protected static native CFString LensMakeKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifLensModel", optional=true)
    protected static native CFString LensModelKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifLensSerialNumber", optional=true)
    protected static native CFString LensSerialNumberKey();
    
    @GlobalValue(symbol="kCGImagePropertyExifGamma", optional=true)
    protected static native CFString GammaKey();
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImagePropertyPNG.Marshaler.class)
@Library("ImageIO")
public class CGImagePropertyPNG 
    extends CocoaUtility 
     {
    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyPNG toObject(Class<CGImagePropertyPNG> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImagePropertyPNG.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyPNG o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }

    
    
    static { Bro.bind(CGImagePropertyPNG.class); }
    
    
    public static final CGImagePropertyPNG Gamma = new CGImagePropertyPNG("GammaKey");
    
    public static final CGImagePropertyPNG InterlaceType = new CGImagePropertyPNG("InterlaceTypeKey");
    
    public static final CGImagePropertyPNG XPixelsPerMeter = new CGImagePropertyPNG("XPixelsPerMeterKey");
    
    public static final CGImagePropertyPNG YPixelsPerMeter = new CGImagePropertyPNG("YPixelsPerMeterKey");
    
    public static final CGImagePropertyPNG sRGBIntent = new CGImagePropertyPNG("sRGBIntentKey");
    
    public static final CGImagePropertyPNG Chromaticities = new CGImagePropertyPNG("ChromaticitiesKey");
    
    public static final CGImagePropertyPNG Author = new CGImagePropertyPNG("AuthorKey");
    
    public static final CGImagePropertyPNG Copyright = new CGImagePropertyPNG("CopyrightKey");
    
    public static final CGImagePropertyPNG CreationTime = new CGImagePropertyPNG("CreationTimeKey");
    
    public static final CGImagePropertyPNG Description = new CGImagePropertyPNG("DescriptionKey");
    
    public static final CGImagePropertyPNG ModificationTime = new CGImagePropertyPNG("ModificationTimeKey");
    
    public static final CGImagePropertyPNG Software = new CGImagePropertyPNG("SoftwareKey");
    
    public static final CGImagePropertyPNG Title = new CGImagePropertyPNG("TitleKey");
    
    public static final CGImagePropertyPNG LoopCount = new CGImagePropertyPNG("LoopCountKey");
    
    public static final CGImagePropertyPNG DelayTime = new CGImagePropertyPNG("DelayTimeKey");
    
    public static final CGImagePropertyPNG UnclampedDelayTime = new CGImagePropertyPNG("UnclampedDelayTimeKey");
    
    private static CGImagePropertyPNG[] values = new CGImagePropertyPNG[] {Gamma, InterlaceType, XPixelsPerMeter, YPixelsPerMeter, 
        sRGBIntent, Chromaticities, Author, Copyright, CreationTime, Description, ModificationTime, Software, Title, LoopCount, 
        DelayTime, UnclampedDelayTime};
    private final LazyGlobalValue<CFString> lazyGlobalValue;
    
    private CGImagePropertyPNG(String getterName) {
        lazyGlobalValue = new LazyGlobalValue<>(getClass(), getterName);
    }
    
    
    
    public CFString value() {
        return lazyGlobalValue.value();
    }
    
    public static CGImagePropertyPNG valueOf(CFString value) {
        for (CGImagePropertyPNG v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImagePropertyPNG.class.getName());
    }
    
    
    @GlobalValue(symbol="kCGImagePropertyPNGGamma", optional=true)
    protected static native CFString GammaKey();
    
    @GlobalValue(symbol="kCGImagePropertyPNGInterlaceType", optional=true)
    protected static native CFString InterlaceTypeKey();
    
    @GlobalValue(symbol="kCGImagePropertyPNGXPixelsPerMeter", optional=true)
    protected static native CFString XPixelsPerMeterKey();
    
    @GlobalValue(symbol="kCGImagePropertyPNGYPixelsPerMeter", optional=true)
    protected static native CFString YPixelsPerMeterKey();
    
    @GlobalValue(symbol="kCGImagePropertyPNGsRGBIntent", optional=true)
    protected static native CFString sRGBIntentKey();
    
    @GlobalValue(symbol="kCGImagePropertyPNGChromaticities", optional=true)
    protected static native CFString ChromaticitiesKey();
    
    @GlobalValue(symbol="kCGImagePropertyPNGAuthor", optional=true)
    protected static native CFString AuthorKey();
    
    @GlobalValue(symbol="kCGImagePropertyPNGCopyright", optional=true)
    protected static native CFString CopyrightKey();
    
    @GlobalValue(symbol="kCGImagePropertyPNGCreationTime", optional=true)
    protected static native CFString CreationTimeKey();
    
    @GlobalValue(symbol="kCGImagePropertyPNGDescription", optional=true)
    protected static native CFString DescriptionKey();
    
    @GlobalValue(symbol="kCGImagePropertyPNGModificationTime", optional=true)
    protected static native CFString ModificationTimeKey();
    
    @GlobalValue(symbol="kCGImagePropertyPNGSoftware", optional=true)
    protected static native CFString SoftwareKey();
    
    @GlobalValue(symbol="kCGImagePropertyPNGTitle", optional=true)
    protected static native CFString TitleKey();
    
    @GlobalValue(symbol="kCGImagePropertyAPNGLoopCount", optional=true)
    protected static native CFString LoopCountKey();
    
    @GlobalValue(symbol="kCGImagePropertyAPNGDelayTime", optional=true)
    protected static native CFString DelayTimeKey();
    
    @GlobalValue(symbol="kCGImagePropertyAPNGUnclampedDelayTime", optional=true)
    protected static native CFString UnclampedDelayTimeKey();
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImagePropertyCanon.Marshaler.class)
@Library("ImageIO")
public class CGImagePropertyCanon 
    extends CocoaUtility 
     {

    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyCanon toObject(Class<CGImagePropertyCanon> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImagePropertyCanon.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyCanon o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }
    
    
    
    static { Bro.bind(CGImagePropertyCanon.class); }
    
    
    public static final CGImagePropertyCanon OwnerName = new CGImagePropertyCanon("OwnerNameKey");
    
    public static final CGImagePropertyCanon CameraSerialNumber = new CGImagePropertyCanon("CameraSerialNumberKey");
    
    public static final CGImagePropertyCanon ImageSerialNumber = new CGImagePropertyCanon("ImageSerialNumberKey");
    
    public static final CGImagePropertyCanon FlashExposureComp = new CGImagePropertyCanon("FlashExposureCompKey");
    
    public static final CGImagePropertyCanon ContinuousDrive = new CGImagePropertyCanon("ContinuousDriveKey");
    
    public static final CGImagePropertyCanon LensModel = new CGImagePropertyCanon("LensModelKey");
    
    public static final CGImagePropertyCanon Firmware = new CGImagePropertyCanon("FirmwareKey");
    
    public static final CGImagePropertyCanon AspectRatioInfo = new CGImagePropertyCanon("AspectRatioInfoKey");
    
    private static CGImagePropertyCanon[] values = new CGImagePropertyCanon[] {OwnerName, CameraSerialNumber, ImageSerialNumber, 
        FlashExposureComp, ContinuousDrive, LensModel, Firmware, AspectRatioInfo};
    private final LazyGlobalValue<CFString> lazyGlobalValue;
    
    private CGImagePropertyCanon(String getterName) {
        lazyGlobalValue = new LazyGlobalValue<>(getClass(), getterName);
    }
    
    
    
    public CFString value() {
        return lazyGlobalValue.value();
    }
    
    public static CGImagePropertyCanon valueOf(CFString value) {
        for (CGImagePropertyCanon v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImagePropertyCanon.class.getName());
    }
    
    
    @GlobalValue(symbol="kCGImagePropertyMakerCanonOwnerName", optional=true)
    protected static native CFString OwnerNameKey();
    
    @GlobalValue(symbol="kCGImagePropertyMakerCanonCameraSerialNumber", optional=true)
    protected static native CFString CameraSerialNumberKey();
    
    @GlobalValue(symbol="kCGImagePropertyMakerCanonImageSerialNumber", optional=true)
    protected static native CFString ImageSerialNumberKey();
    
    @GlobalValue(symbol="kCGImagePropertyMakerCanonFlashExposureComp", optional=true)
    protected static native CFString FlashExposureCompKey();
    
    @GlobalValue(symbol="kCGImagePropertyMakerCanonContinuousDrive", optional=true)
    protected static native CFString ContinuousDriveKey();
    
    @GlobalValue(symbol="kCGImagePropertyMakerCanonLensModel", optional=true)
    protected static native CFString LensModelKey();
    
    @GlobalValue(symbol="kCGImagePropertyMakerCanonFirmware", optional=true)
    protected static native CFString FirmwareKey();
    
    @GlobalValue(symbol="kCGImagePropertyMakerCanonAspectRatioInfo", optional=true)
    protected static native CFString AspectRatioInfoKey();
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImageDestinationProperties.Marshaler.class)
@Library("ImageIO")
public class CGImageDestinationProperties 
    extends CGImageProperties 
     {

    public static class Marshaler {
        @MarshalsPointer
        public static CGImageDestinationProperties toObject(Class<CGImageDestinationProperties> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImageDestinationProperties(o);
        }
        @MarshalsPointer
        public static long toNative(CGImageDestinationProperties o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    
    
    
    public CGImageDestinationProperties(CFDictionary data) {
        this.data = data;
    }
    public CGImageDestinationProperties() {
        this.data = CFMutableDictionary.create();
    }
    static { Bro.bind(CGImageDestinationProperties.class); }
    
    
    
    
    
    public double getLossyCompressionQuality() {
        if (data.containsKey(LossyCompressionQualityKey())) {
            CFNumber val = data.get(LossyCompressionQualityKey(), CFNumber.class);
            return val.doubleValue();
        }
        return 1;
    }
    
    public CGImageDestinationProperties setLossyCompressionQuality(double quality) {
        data.put(LossyCompressionQualityKey(), CFNumber.valueOf(quality));
        return this;
    }
    
    public CGColor getBackgroundColor() {
        if (data.containsKey(BackgroundColorKey())) {
            CGColor val = data.get(BackgroundColorKey(), CGColor.class);
            return val;
        }
        return null;
    }
    
    public CGImageDestinationProperties setBackgroundColor(CGColor color) {
        data.put(BackgroundColorKey(), color);
        return this;
    }
    
    public long getMaxPixelSize() {
        if (data.containsKey(ImageMaxPixelSizeKey())) {
            CFNumber val = data.get(ImageMaxPixelSizeKey(), CFNumber.class);
            return val.longValue();
        }
        return 0;
    }
    
    public CGImageDestinationProperties setMaxPixelSize(long size) {
        data.put(ImageMaxPixelSizeKey(), CFNumber.valueOf(size));
        return this;
    }
    
    public boolean isEmbeddingThumbnail() {
        if (data.containsKey(EmbedThumbnailKey())) {
            CFBoolean val = data.get(EmbedThumbnailKey(), CFBoolean.class);
            return val.booleanValue();
        }
        return false;
    }
    
    public CGImageDestinationProperties setEmbedThumbnail(boolean embed) {
        data.put(EmbedThumbnailKey(), CFBoolean.valueOf(embed));
        return this;
    }
    
    
    @GlobalValue(symbol="kCGImageDestinationLossyCompressionQuality", optional=true)
    protected static native CFString LossyCompressionQualityKey();
    
    @GlobalValue(symbol="kCGImageDestinationBackgroundColor", optional=true)
    protected static native CFString BackgroundColorKey();
    
    @GlobalValue(symbol="kCGImageDestinationImageMaxPixelSize", optional=true)
    protected static native CFString ImageMaxPixelSizeKey();
    
    @GlobalValue(symbol="kCGImageDestinationEmbedThumbnail", optional=true)
    protected static native CFString EmbedThumbnailKey();
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImagePropertyTIFF.Marshaler.class)
@Library("ImageIO")
public class CGImagePropertyTIFF 
    extends CocoaUtility 
     {
    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyTIFF toObject(Class<CGImagePropertyTIFF> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImagePropertyTIFF.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyTIFF o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }

    
    
    static { Bro.bind(CGImagePropertyTIFF.class); }
    
    
    public static final CGImagePropertyTIFF Compression = new CGImagePropertyTIFF("CompressionKey");
    
    public static final CGImagePropertyTIFF PhotometricInterpretation = new CGImagePropertyTIFF("PhotometricInterpretationKey");
    
    public static final CGImagePropertyTIFF DocumentName = new CGImagePropertyTIFF("DocumentNameKey");
    
    public static final CGImagePropertyTIFF ImageDescription = new CGImagePropertyTIFF("ImageDescriptionKey");
    
    public static final CGImagePropertyTIFF Make = new CGImagePropertyTIFF("MakeKey");
    
    public static final CGImagePropertyTIFF Model = new CGImagePropertyTIFF("ModelKey");
    
    public static final CGImagePropertyTIFF Orientation = new CGImagePropertyTIFF("OrientationKey");
    
    public static final CGImagePropertyTIFF XResolution = new CGImagePropertyTIFF("XResolutionKey");
    
    public static final CGImagePropertyTIFF YResolution = new CGImagePropertyTIFF("YResolutionKey");
    
    public static final CGImagePropertyTIFF ResolutionUnit = new CGImagePropertyTIFF("ResolutionUnitKey");
    
    public static final CGImagePropertyTIFF Software = new CGImagePropertyTIFF("SoftwareKey");
    
    public static final CGImagePropertyTIFF TransferFunction = new CGImagePropertyTIFF("TransferFunctionKey");
    
    public static final CGImagePropertyTIFF DateTime = new CGImagePropertyTIFF("DateTimeKey");
    
    public static final CGImagePropertyTIFF Artist = new CGImagePropertyTIFF("ArtistKey");
    
    public static final CGImagePropertyTIFF HostComputer = new CGImagePropertyTIFF("HostComputerKey");
    
    public static final CGImagePropertyTIFF Copyright = new CGImagePropertyTIFF("CopyrightKey");
    
    public static final CGImagePropertyTIFF WhitePoint = new CGImagePropertyTIFF("WhitePointKey");
    
    public static final CGImagePropertyTIFF PrimaryChromaticities = new CGImagePropertyTIFF("PrimaryChromaticitiesKey");
    
    private static CGImagePropertyTIFF[] values = new CGImagePropertyTIFF[] {Compression, PhotometricInterpretation, DocumentName, 
        ImageDescription, Make, Model, Orientation, XResolution, YResolution, ResolutionUnit, Software, TransferFunction, 
        DateTime, Artist, HostComputer, Copyright, WhitePoint, PrimaryChromaticities};
    private final LazyGlobalValue<CFString> lazyGlobalValue;
    
    private CGImagePropertyTIFF(String getterName) {
        lazyGlobalValue = new LazyGlobalValue<>(getClass(), getterName);
    }
    
    
    
    public CFString value() {
        return lazyGlobalValue.value();
    }
    
    public static CGImagePropertyTIFF valueOf(CFString value) {
        for (CGImagePropertyTIFF v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImagePropertyTIFF.class.getName());
    }
    
    
    @GlobalValue(symbol="kCGImagePropertyTIFFCompression", optional=true)
    protected static native CFString CompressionKey();
    
    @GlobalValue(symbol="kCGImagePropertyTIFFPhotometricInterpretation", optional=true)
    protected static native CFString PhotometricInterpretationKey();
    
    @GlobalValue(symbol="kCGImagePropertyTIFFDocumentName", optional=true)
    protected static native CFString DocumentNameKey();
    
    @GlobalValue(symbol="kCGImagePropertyTIFFImageDescription", optional=true)
    protected static native CFString ImageDescriptionKey();
    
    @GlobalValue(symbol="kCGImagePropertyTIFFMake", optional=true)
    protected static native CFString MakeKey();
    
    @GlobalValue(symbol="kCGImagePropertyTIFFModel", optional=true)
    protected static native CFString ModelKey();
    
    @GlobalValue(symbol="kCGImagePropertyTIFFOrientation", optional=true)
    protected static native CFString OrientationKey();
    
    @GlobalValue(symbol="kCGImagePropertyTIFFXResolution", optional=true)
    protected static native CFString XResolutionKey();
    
    @GlobalValue(symbol="kCGImagePropertyTIFFYResolution", optional=true)
    protected static native CFString YResolutionKey();
    
    @GlobalValue(symbol="kCGImagePropertyTIFFResolutionUnit", optional=true)
    protected static native CFString ResolutionUnitKey();
    
    @GlobalValue(symbol="kCGImagePropertyTIFFSoftware", optional=true)
    protected static native CFString SoftwareKey();
    
    @GlobalValue(symbol="kCGImagePropertyTIFFTransferFunction", optional=true)
    protected static native CFString TransferFunctionKey();
    
    @GlobalValue(symbol="kCGImagePropertyTIFFDateTime", optional=true)
    protected static native CFString DateTimeKey();
    
    @GlobalValue(symbol="kCGImagePropertyTIFFArtist", optional=true)
    protected static native CFString ArtistKey();
    
    @GlobalValue(symbol="kCGImagePropertyTIFFHostComputer", optional=true)
    protected static native CFString HostComputerKey();
    
    @GlobalValue(symbol="kCGImagePropertyTIFFCopyright", optional=true)
    protected static native CFString CopyrightKey();
    
    @GlobalValue(symbol="kCGImagePropertyTIFFWhitePoint", optional=true)
    protected static native CFString WhitePointKey();
    
    @GlobalValue(symbol="kCGImagePropertyTIFFPrimaryChromaticities", optional=true)
    protected static native CFString PrimaryChromaticitiesKey();
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImagePropertyDNG.Marshaler.class)
@Library("ImageIO")
public class CGImagePropertyDNG 
    extends CocoaUtility 
     {
    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyDNG toObject(Class<CGImagePropertyDNG> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImagePropertyDNG.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyDNG o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }

    
    
    static { Bro.bind(CGImagePropertyDNG.class); }
    
    
    public static final CGImagePropertyDNG Version = new CGImagePropertyDNG("VersionKey");
    
    public static final CGImagePropertyDNG BackwardVersion = new CGImagePropertyDNG("BackwardVersionKey");
    
    public static final CGImagePropertyDNG UniqueCameraModel = new CGImagePropertyDNG("UniqueCameraModelKey");
    
    public static final CGImagePropertyDNG LocalizedCameraModel = new CGImagePropertyDNG("LocalizedCameraModelKey");
    
    public static final CGImagePropertyDNG CameraSerialNumber = new CGImagePropertyDNG("CameraSerialNumberKey");
    
    public static final CGImagePropertyDNG LensInfo = new CGImagePropertyDNG("LensInfoKey");
    
    private static CGImagePropertyDNG[] values = new CGImagePropertyDNG[] {Version, BackwardVersion, UniqueCameraModel, LocalizedCameraModel, 
        CameraSerialNumber, LensInfo};
    private final LazyGlobalValue<CFString> lazyGlobalValue;
    
    private CGImagePropertyDNG(String getterName) {
        lazyGlobalValue = new LazyGlobalValue<>(getClass(), getterName);
    }
    
    
    
    public CFString value() {
        return lazyGlobalValue.value();
    }
    
    public static CGImagePropertyDNG valueOf(CFString value) {
        for (CGImagePropertyDNG v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImagePropertyDNG.class.getName());
    }
    
    
    @GlobalValue(symbol="kCGImagePropertyDNGVersion", optional=true)
    protected static native CFString VersionKey();
    
    @GlobalValue(symbol="kCGImagePropertyDNGBackwardVersion", optional=true)
    protected static native CFString BackwardVersionKey();
    
    @GlobalValue(symbol="kCGImagePropertyDNGUniqueCameraModel", optional=true)
    protected static native CFString UniqueCameraModelKey();
    
    @GlobalValue(symbol="kCGImagePropertyDNGLocalizedCameraModel", optional=true)
    protected static native CFString LocalizedCameraModelKey();
    
    @GlobalValue(symbol="kCGImagePropertyDNGCameraSerialNumber", optional=true)
    protected static native CFString CameraSerialNumberKey();
    
    @GlobalValue(symbol="kCGImagePropertyDNGLensInfo", optional=true)
    protected static native CFString LensInfoKey();
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;

import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImagePropertyCanonData.Marshaler.class)
@Library("ImageIO")
public class CGImagePropertyCanonData 
    extends Object 
     {

    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyCanonData toObject(Class<CGImagePropertyCanonData> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImagePropertyCanonData(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyCanonData o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    
    
    
    private CFDictionary data;
    
    protected CGImagePropertyCanonData(CFDictionary data) {
        this.data = data;
    }
    public CGImagePropertyCanonData() {
        this.data = CFMutableDictionary.create();
    }
    static { Bro.bind(CGImagePropertyCanonData.class); }
    
    
    
    
    public CFDictionary getDictionary() {
        return data;
    }
    
    public boolean has(CGImagePropertyCanon property) {
        return data.containsKey(property.value());
    }
    
    public String getString(CGImagePropertyCanon property) {
        if (has(property)) {
            CFString val = data.get(property.value(), CFString.class);
            return val.toString();
        }
        return null;
    }
    public double getNumber(CGImagePropertyCanon property) {
        if (has(property)) {
            CFNumber val = data.get(property.value(), CFNumber.class);
            return val.doubleValue();
        }
        return 0;
    }
    public CGImagePropertyCanonData set(CGImagePropertyCanon property, String value) {
        data.put(property.value(), new CFString(value));
        return this;
    }
    public CGImagePropertyCanonData set(CGImagePropertyCanon property, double value) {
        data.put(property.value(), CFNumber.valueOf(value));
        return this;
    }
    
    
    @Override
    public String toString() {
        if (data != null) return data.toString();
        return super.toString();
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImagePropertyGIF.Marshaler.class)
@Library("ImageIO")
public class CGImagePropertyGIF 
    extends CocoaUtility 
     {

    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyGIF toObject(Class<CGImagePropertyGIF> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImagePropertyGIF.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyGIF o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }
    
    
    
    static { Bro.bind(CGImagePropertyGIF.class); }
    
    
    public static final CGImagePropertyGIF LoopCount = new CGImagePropertyGIF("LoopCountKey");
    
    public static final CGImagePropertyGIF DelayTime = new CGImagePropertyGIF("DelayTimeKey");
    
    public static final CGImagePropertyGIF ImageColorMap = new CGImagePropertyGIF("ImageColorMapKey");
    
    public static final CGImagePropertyGIF HasGlobalColorMap = new CGImagePropertyGIF("HasGlobalColorMapKey");
    
    public static final CGImagePropertyGIF UnclampedDelayTime = new CGImagePropertyGIF("UnclampedDelayTimeKey");
    
    private static CGImagePropertyGIF[] values = new CGImagePropertyGIF[] {LoopCount, DelayTime, ImageColorMap, 
        HasGlobalColorMap, UnclampedDelayTime};
    private final LazyGlobalValue<CFString> lazyGlobalValue;
    
    private CGImagePropertyGIF(String getterName) {
        lazyGlobalValue = new LazyGlobalValue<>(getClass(), getterName);
    }
    
    
    
    public CFString value() {
        return lazyGlobalValue.value();
    }
    
    public static CGImagePropertyGIF valueOf(CFString value) {
        for (CGImagePropertyGIF v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImagePropertyGIF.class.getName());
    }
    
    
    @GlobalValue(symbol="kCGImagePropertyGIFLoopCount", optional=true)
    protected static native CFString LoopCountKey();
    
    @GlobalValue(symbol="kCGImagePropertyGIFDelayTime", optional=true)
    protected static native CFString DelayTimeKey();
    
    @GlobalValue(symbol="kCGImagePropertyGIFImageColorMap", optional=true)
    protected static native CFString ImageColorMapKey();
    
    @GlobalValue(symbol="kCGImagePropertyGIFHasGlobalColorMap", optional=true)
    protected static native CFString HasGlobalColorMapKey();
    
    @GlobalValue(symbol="kCGImagePropertyGIFUnclampedDelayTime", optional=true)
    protected static native CFString UnclampedDelayTimeKey();
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImageProperty8BIM.Marshaler.class)
@Library("ImageIO")
public class CGImageProperty8BIM 
    extends CocoaUtility 
     {

    public static class Marshaler {
        @MarshalsPointer
        public static CGImageProperty8BIM toObject(Class<CGImageProperty8BIM> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImageProperty8BIM.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImageProperty8BIM o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }
    
    
    
    static { Bro.bind(CGImageProperty8BIM.class); }
    
    
    public static final CGImageProperty8BIM LayerNames = new CGImageProperty8BIM("LayerNamesKey");
    
    public static final CGImageProperty8BIM Version = new CGImageProperty8BIM("VersionKey");
    
    private static CGImageProperty8BIM[] values = new CGImageProperty8BIM[] {LayerNames, Version};
    private final LazyGlobalValue<CFString> lazyGlobalValue;
    
    private CGImageProperty8BIM(String getterName) {
        lazyGlobalValue = new LazyGlobalValue<>(getClass(), getterName);
    }
    
    
    
    public CFString value() {
        return lazyGlobalValue.value();
    }
    
    public static CGImageProperty8BIM valueOf(CFString value) {
        for (CGImageProperty8BIM v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImageProperty8BIM.class.getName());
    }
    
    
    @GlobalValue(symbol="kCGImageProperty8BIMLayerNames", optional=true)
    protected static native CFString LayerNamesKey();
    
    @GlobalValue(symbol="kCGImageProperty8BIMVersion", optional=true)
    protected static native CFString VersionKey();
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImageSourceOptions.Marshaler.class)
@Library("ImageIO")
public class CGImageSourceOptions 
    extends CocoaUtility 
     {

    public static class Marshaler {
        @MarshalsPointer
        public static CGImageSourceOptions toObject(Class<CGImageSourceOptions> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImageSourceOptions(o);
        }
        @MarshalsPointer
        public static long toNative(CGImageSourceOptions o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    
    
    
    private CFDictionary data;
    
    protected CGImageSourceOptions(CFDictionary data) {
        this.data = data;
    }
    public CGImageSourceOptions() {
        this.data = CFMutableDictionary.create();
    }
    static { Bro.bind(CGImageSourceOptions.class); }
    
    
    
    
    public CFDictionary getDictionary() {
        return data;
    }
    
    
    
    public String getTypeIdentifierHint() {
        if (data.containsKey(TypeIdentifierHintKey())) {
            CFString val = data.get(TypeIdentifierHintKey(), CFString.class);
            return val.toString();
        }
        return null;
    }
    
    public CGImageSourceOptions setTypeIdentifierHint(String typeIdentifier) {
        data.put(TypeIdentifierHintKey(), new CFString(typeIdentifier));
        return this;
    }
    
    public boolean shouldCache() {
        if (data.containsKey(ShouldCacheKey())) {
            CFBoolean val = data.get(ShouldCacheKey(), CFBoolean.class);
            return val.booleanValue();
        }
        return false;
    }
    
    public CGImageSourceOptions setShouldCache(boolean cache) {
        data.put(ShouldCacheKey(), CFBoolean.valueOf(cache));
        return this;
    }
    
    public boolean shouldCacheImmediately() {
        if (data.containsKey(ShouldCacheImmediatelyKey())) {
            CFBoolean val = data.get(ShouldCacheImmediatelyKey(), CFBoolean.class);
            return val.booleanValue();
        }
        return false;
    }
    
    public CGImageSourceOptions setShouldCacheImmediately(boolean cache) {
        data.put(ShouldCacheImmediatelyKey(), CFBoolean.valueOf(cache));
        return this;
    }
    
    public boolean shouldAllowFloat() {
        if (data.containsKey(ShouldAllowFloatKey())) {
            CFBoolean val = data.get(ShouldAllowFloatKey(), CFBoolean.class);
            return val.booleanValue();
        }
        return false;
    }
    
    public CGImageSourceOptions setShouldAllowFloat(boolean allowFloat) {
        data.put(ShouldAllowFloatKey(), CFBoolean.valueOf(allowFloat));
        return this;
    }
    
    public boolean shouldCreateThumbnailFromImageIfAbsent() {
        if (data.containsKey(CreateThumbnailFromImageIfAbsentKey())) {
            CFBoolean val = data.get(CreateThumbnailFromImageIfAbsentKey(), CFBoolean.class);
            return val.booleanValue();
        }
        return false;
    }
    
    public CGImageSourceOptions setShouldCreateThumbnailFromImageIfAbsent(boolean createThumbnail) {
        data.put(CreateThumbnailFromImageIfAbsentKey(), CFBoolean.valueOf(createThumbnail));
        return this;
    }
    
    public boolean shouldCreateThumbnailFromImageAlways() {
        if (data.containsKey(CreateThumbnailFromImageAlwaysKey())) {
            CFBoolean val = data.get(CreateThumbnailFromImageAlwaysKey(), CFBoolean.class);
            return val.booleanValue();
        }
        return false;
    }
    
    public CGImageSourceOptions setShouldCreateThumbnailFromImageAlways(boolean createThumbnail) {
        data.put(CreateThumbnailFromImageAlwaysKey(), CFBoolean.valueOf(createThumbnail));
        return this;
    }
    
    public long getThumbnailMaxPixelSize() {
        if (data.containsKey(ThumbnailMaxPixelSizeKey())) {
            CFNumber val = data.get(ThumbnailMaxPixelSizeKey(), CFNumber.class);
            return val.longValue();
        }
        return 0;
    }
    
    public CGImageSourceOptions setThumbnailMaxPixelSize(long maxSize) {
        data.put(ThumbnailMaxPixelSizeKey(), CFNumber.valueOf(maxSize));
        return this;
    }
    
    public boolean shouldCreateThumbnailWithTransform() {
        if (data.containsKey(CreateThumbnailWithTransformKey())) {
            CFBoolean val = data.get(CreateThumbnailWithTransformKey(), CFBoolean.class);
            return val.booleanValue();
        }
        return false;
    }
    
    public CGImageSourceOptions setShouldCreateThumbnailWithTransform(boolean transform) {
        data.put(CreateThumbnailWithTransformKey(), CFBoolean.valueOf(transform));
        return this;
    }
    
    
    @GlobalValue(symbol="kCGImageSourceTypeIdentifierHint", optional=true)
    protected static native CFString TypeIdentifierHintKey();
    
    @GlobalValue(symbol="kCGImageSourceShouldCache", optional=true)
    protected static native CFString ShouldCacheKey();
    
    @GlobalValue(symbol="kCGImageSourceShouldCacheImmediately", optional=true)
    protected static native CFString ShouldCacheImmediatelyKey();
    
    @GlobalValue(symbol="kCGImageSourceShouldAllowFloat", optional=true)
    protected static native CFString ShouldAllowFloatKey();
    
    @GlobalValue(symbol="kCGImageSourceCreateThumbnailFromImageIfAbsent", optional=true)
    protected static native CFString CreateThumbnailFromImageIfAbsentKey();
    
    @GlobalValue(symbol="kCGImageSourceCreateThumbnailFromImageAlways", optional=true)
    protected static native CFString CreateThumbnailFromImageAlwaysKey();
    
    @GlobalValue(symbol="kCGImageSourceThumbnailMaxPixelSize", optional=true)
    protected static native CFString ThumbnailMaxPixelSizeKey();
    
    @GlobalValue(symbol="kCGImageSourceCreateThumbnailWithTransform", optional=true)
    protected static native CFString CreateThumbnailWithTransformKey();
    
    @Override
    public String toString() {
        if (data != null) return data.toString();
        return super.toString();
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;

import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImageProperty8BIMData.Marshaler.class)
@Library("ImageIO")
public class CGImageProperty8BIMData 
    extends Object 
     {

    public static class Marshaler {
        @MarshalsPointer
        public static CGImageProperty8BIMData toObject(Class<CGImageProperty8BIMData> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImageProperty8BIMData(o);
        }
        @MarshalsPointer
        public static long toNative(CGImageProperty8BIMData o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    
    
    
    private CFDictionary data;
    
    protected CGImageProperty8BIMData(CFDictionary data) {
        this.data = data;
    }
    public CGImageProperty8BIMData() {
        this.data = CFMutableDictionary.create();
    }
    static { Bro.bind(CGImageProperty8BIMData.class); }
    
    
    
    
    public CFDictionary getDictionary() {
        return data;
    }
    
    public boolean has(CGImageProperty8BIM property) {
        return data.containsKey(property.value());
    }
    
    public String getString(CGImageProperty8BIM property) {
        if (has(property)) {
            CFString val = data.get(property.value(), CFString.class);
            return val.toString();
        }
        return null;
    }
    public double getNumber(CGImageProperty8BIM property) {
        if (has(property)) {
            CFNumber val = data.get(property.value(), CFNumber.class);
            return val.doubleValue();
        }
        return 0;
    }
    public CGImageProperty8BIMData set(CGImageProperty8BIM property, String value) {
        data.put(property.value(), new CFString(value));
        return this;
    }
    public CGImageProperty8BIMData set(CGImageProperty8BIM property, double value) {
        data.put(property.value(), CFNumber.valueOf(value));
        return this;
    }
    
    
    @Override
    public String toString() {
        if (data != null) return data.toString();
        return super.toString();
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;

import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImagePropertyGPSData.Marshaler.class)
@Library("ImageIO")
public class CGImagePropertyGPSData 
    extends Object 
     {

    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyGPSData toObject(Class<CGImagePropertyGPSData> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImagePropertyGPSData(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyGPSData o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    
    
    
    private CFDictionary data;
    
    protected CGImagePropertyGPSData(CFDictionary data) {
        this.data = data;
    }
    public CGImagePropertyGPSData() {
        this.data = CFMutableDictionary.create();
    }
    static { Bro.bind(CGImagePropertyGPSData.class); }
    
    
    
    
    public CFDictionary getDictionary() {
        return data;
    }
    
    public boolean has(CGImagePropertyGPS property) {
        return data.containsKey(property.value());
    }
    
    public String getString(CGImagePropertyGPS property) {
        if (has(property)) {
            CFString val = data.get(property.value(), CFString.class);
            return val.toString();
        }
        return null;
    }
    public double getNumber(CGImagePropertyGPS property) {
        if (has(property)) {
            CFNumber val = data.get(property.value(), CFNumber.class);
            return val.doubleValue();
        }
        return 0;
    }
    public CGImagePropertyGPSData set(CGImagePropertyGPS property, String value) {
        data.put(property.value(), new CFString(value));
        return this;
    }
    public CGImagePropertyGPSData set(CGImagePropertyGPS property, double value) {
        data.put(property.value(), CFNumber.valueOf(value));
        return this;
    }
    
    
    @Override
    public String toString() {
        if (data != null) return data.toString();
        return super.toString();
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImageMetadataPrefix.Marshaler.class)
@Library("ImageIO")
public class CGImageMetadataPrefix 
    extends CocoaUtility 
     {
    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImageMetadataPrefix toObject(Class<CGImageMetadataPrefix> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImageMetadataPrefix.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImageMetadataPrefix o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }

    
    
    static { Bro.bind(CGImageMetadataPrefix.class); }
    
    
    public static final CGImageMetadataPrefix Exif = new CGImageMetadataPrefix("ExifValue");
    
    public static final CGImageMetadataPrefix ExifAux = new CGImageMetadataPrefix("ExifAuxValue");
    
    public static final CGImageMetadataPrefix ExifEX = new CGImageMetadataPrefix("ExifEXValue");
    
    public static final CGImageMetadataPrefix DublinCore = new CGImageMetadataPrefix("DublinCoreValue");
    
    public static final CGImageMetadataPrefix IPTCCore = new CGImageMetadataPrefix("IPTCCoreValue");
    
    public static final CGImageMetadataPrefix Photoshop = new CGImageMetadataPrefix("PhotoshopValue");
    
    public static final CGImageMetadataPrefix TIFF = new CGImageMetadataPrefix("TIFFValue");
    
    public static final CGImageMetadataPrefix XMPBasic = new CGImageMetadataPrefix("XMPBasicValue");
    
    public static final CGImageMetadataPrefix XMPRights = new CGImageMetadataPrefix("XMPRightsValue");
    
    private static CGImageMetadataPrefix[] values = new CGImageMetadataPrefix[] {Exif, ExifAux, ExifEX, DublinCore, 
        IPTCCore, Photoshop, TIFF, XMPBasic, XMPRights};
    private final LazyGlobalValue<CFString> lazyGlobalValue;
    
    private CGImageMetadataPrefix(String getterName) {
        lazyGlobalValue = new LazyGlobalValue<>(getClass(), getterName);
    }
    
    
    
    public CFString value() {
        return lazyGlobalValue.value();
    }
    
    public static CGImageMetadataPrefix valueOf(CFString value) {
        for (CGImageMetadataPrefix v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImageMetadataPrefix.class.getName());
    }
    
    
    @GlobalValue(symbol="kCGImageMetadataPrefixExif", optional=true)
    protected static native CFString ExifValue();
    
    @GlobalValue(symbol="kCGImageMetadataPrefixExifAux", optional=true)
    protected static native CFString ExifAuxValue();
    
    @GlobalValue(symbol="kCGImageMetadataPrefixExifEX", optional=true)
    protected static native CFString ExifEXValue();
    
    @GlobalValue(symbol="kCGImageMetadataPrefixDublinCore", optional=true)
    protected static native CFString DublinCoreValue();
    
    @GlobalValue(symbol="kCGImageMetadataPrefixIPTCCore", optional=true)
    protected static native CFString IPTCCoreValue();
    
    @GlobalValue(symbol="kCGImageMetadataPrefixPhotoshop", optional=true)
    protected static native CFString PhotoshopValue();
    
    @GlobalValue(symbol="kCGImageMetadataPrefixTIFF", optional=true)
    protected static native CFString TIFFValue();
    
    @GlobalValue(symbol="kCGImageMetadataPrefixXMPBasic", optional=true)
    protected static native CFString XMPBasicValue();
    
    @GlobalValue(symbol="kCGImageMetadataPrefixXMPRights", optional=true)
    protected static native CFString XMPRightsValue();
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;

import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImagePropertyIPTCData.Marshaler.class)
@Library("ImageIO")
public class CGImagePropertyIPTCData 
    extends Object 
     {

    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyIPTCData toObject(Class<CGImagePropertyIPTCData> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImagePropertyIPTCData(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyIPTCData o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    
    
    
    private CFDictionary data;
    
    protected CGImagePropertyIPTCData(CFDictionary data) {
        this.data = data;
    }
    public CGImagePropertyIPTCData() {
        this.data = CFMutableDictionary.create();
    }
    static { Bro.bind(CGImagePropertyIPTCData.class); }
    
    
    
    
    public CFDictionary getDictionary() {
        return data;
    }
    
    public boolean has(CGImagePropertyIPTC property) {
        return data.containsKey(property.value());
    }
    
    public String getString(CGImagePropertyIPTC property) {
        if (has(property)) {
            CFString val = data.get(property.value(), CFString.class);
            return val.toString();
        }
        return null;
    }
    public double getNumber(CGImagePropertyIPTC property) {
        if (has(property)) {
            CFNumber val = data.get(property.value(), CFNumber.class);
            return val.doubleValue();
        }
        return 0;
    }
    public CGImagePropertyIPTCData set(CGImagePropertyIPTC property, String value) {
        data.put(property.value(), new CFString(value));
        return this;
    }
    public CGImagePropertyIPTCData set(CGImagePropertyIPTC property, double value) {
        data.put(property.value(), CFNumber.valueOf(value));
        return this;
    }
    
    
    public CGImagePropertyIPTCContactInfoData getContactInfo() {
        if (has(CGImagePropertyIPTC.CreatorContactInfo)) {
            CFDictionary val = data.get(CGImagePropertyIPTC.CreatorContactInfoKey(), CFDictionary.class);
            return new CGImagePropertyIPTCContactInfoData(val);
        }
        return null;
    }
    public CGImagePropertyIPTCData setContactInfo(CGImagePropertyIPTCContactInfoData contactInfo) {
        data.put(CGImagePropertyIPTC.CreatorContactInfoKey(), contactInfo.getDictionary());
        return this;
    }
    
    
    @Override
    public String toString() {
        if (data != null) return data.toString();
        return super.toString();
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;

import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImagePropertyExifData.Marshaler.class)
@Library("ImageIO")
public class CGImagePropertyExifData 
    extends Object 
     {

    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyExifData toObject(Class<CGImagePropertyExifData> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImagePropertyExifData(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyExifData o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    
    
    
    private CFDictionary data;
    
    protected CGImagePropertyExifData(CFDictionary data) {
        this.data = data;
    }
    public CGImagePropertyExifData() {
        this.data = CFMutableDictionary.create();
    }
    static { Bro.bind(CGImagePropertyExifData.class); }
    
    
    
    
    public CFDictionary getDictionary() {
        return data;
    }
    
    public boolean has(CGImagePropertyExif property) {
        return data.containsKey(property.value());
    }
    
    public String getString(CGImagePropertyExif property) {
        if (has(property)) {
            CFString val = data.get(property.value(), CFString.class);
            return val.toString();
        }
        return null;
    }
    public double getNumber(CGImagePropertyExif property) {
        if (has(property)) {
            CFNumber val = data.get(property.value(), CFNumber.class);
            return val.doubleValue();
        }
        return 0;
    }
    public CGImagePropertyExifData set(CGImagePropertyExif property, String value) {
        data.put(property.value(), new CFString(value));
        return this;
    }
    public CGImagePropertyExifData set(CGImagePropertyExif property, double value) {
        data.put(property.value(), CFNumber.valueOf(value));
        return this;
    }
    
    
    @Override
    public String toString() {
        if (data != null) return data.toString();
        return super.toString();
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;

import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImagePropertyGIFData.Marshaler.class)
@Library("ImageIO")
public class CGImagePropertyGIFData 
    extends Object 
     {

    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyGIFData toObject(Class<CGImagePropertyGIFData> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImagePropertyGIFData(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyGIFData o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    
    
    
    private CFDictionary data;
    
    protected CGImagePropertyGIFData(CFDictionary data) {
        this.data = data;
    }
    public CGImagePropertyGIFData() {
        this.data = CFMutableDictionary.create();
    }
    static { Bro.bind(CGImagePropertyGIFData.class); }
    
    
    
    
    public CFDictionary getDictionary() {
        return data;
    }
    
    public boolean has(CGImagePropertyGIF property) {
        return data.containsKey(property.value());
    }
    
    public String getString(CGImagePropertyGIF property) {
        if (has(property)) {
            CFString val = data.get(property.value(), CFString.class);
            return val.toString();
        }
        return null;
    }
    public double getNumber(CGImagePropertyGIF property) {
        if (has(property)) {
            CFNumber val = data.get(property.value(), CFNumber.class);
            return val.doubleValue();
        }
        return 0;
    }
    public CGImagePropertyGIFData set(CGImagePropertyGIF property, String value) {
        data.put(property.value(), new CFString(value));
        return this;
    }
    public CGImagePropertyGIFData set(CGImagePropertyGIF property, double value) {
        data.put(property.value(), CFNumber.valueOf(value));
        return this;
    }
    
    
    @Override
    public String toString() {
        if (data != null) return data.toString();
        return super.toString();
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;

import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImagePropertyExifAuxData.Marshaler.class)
@Library("ImageIO")
public class CGImagePropertyExifAuxData 
    extends Object 
     {

    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyExifAuxData toObject(Class<CGImagePropertyExifAuxData> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImagePropertyExifAuxData(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyExifAuxData o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    
    
    
    private CFDictionary data;
    
    protected CGImagePropertyExifAuxData(CFDictionary data) {
        this.data = data;
    }
    public CGImagePropertyExifAuxData() {
        this.data = CFMutableDictionary.create();
    }
    static { Bro.bind(CGImagePropertyExifAuxData.class); }
    
    
    
    
    public CFDictionary getDictionary() {
        return data;
    }
    
    public boolean has(CGImagePropertyExifAux property) {
        return data.containsKey(property.value());
    }
    
    public String getString(CGImagePropertyExifAux property) {
        if (has(property)) {
            CFString val = data.get(property.value(), CFString.class);
            return val.toString();
        }
        return null;
    }
    public double getNumber(CGImagePropertyExifAux property) {
        if (has(property)) {
            CFNumber val = data.get(property.value(), CFNumber.class);
            return val.doubleValue();
        }
        return 0;
    }
    public CGImagePropertyExifAuxData set(CGImagePropertyExifAux property, String value) {
        data.put(property.value(), new CFString(value));
        return this;
    }
    public CGImagePropertyExifAuxData set(CGImagePropertyExifAux property, double value) {
        data.put(property.value(), CFNumber.valueOf(value));
        return this;
    }
    
    
    @Override
    public String toString() {
        if (data != null) return data.toString();
        return super.toString();
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImagePropertyGPS.Marshaler.class)
@Library("ImageIO")
public class CGImagePropertyGPS 
    extends CocoaUtility 
     {
    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyGPS toObject(Class<CGImagePropertyGPS> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImagePropertyGPS.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyGPS o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }

    
    
    static { Bro.bind(CGImagePropertyGPS.class); }
    
    
    public static final CGImagePropertyGPS Version = new CGImagePropertyGPS("VersionKey");
    
    public static final CGImagePropertyGPS LatitudeRef = new CGImagePropertyGPS("LatitudeRefKey");
    
    public static final CGImagePropertyGPS Latitude = new CGImagePropertyGPS("LatitudeKey");
    
    public static final CGImagePropertyGPS LongitudeRef = new CGImagePropertyGPS("LongitudeRefKey");
    
    public static final CGImagePropertyGPS Longitude = new CGImagePropertyGPS("LongitudeKey");
    
    public static final CGImagePropertyGPS AltitudeRef = new CGImagePropertyGPS("AltitudeRefKey");
    
    public static final CGImagePropertyGPS Altitude = new CGImagePropertyGPS("AltitudeKey");
    
    public static final CGImagePropertyGPS TimeStamp = new CGImagePropertyGPS("TimeStampKey");
    
    public static final CGImagePropertyGPS Satellites = new CGImagePropertyGPS("SatellitesKey");
    
    public static final CGImagePropertyGPS Status = new CGImagePropertyGPS("StatusKey");
    
    public static final CGImagePropertyGPS MeasureMode = new CGImagePropertyGPS("MeasureModeKey");
    
    public static final CGImagePropertyGPS DOP = new CGImagePropertyGPS("DOPKey");
    
    public static final CGImagePropertyGPS SpeedRef = new CGImagePropertyGPS("SpeedRefKey");
    
    public static final CGImagePropertyGPS Speed = new CGImagePropertyGPS("SpeedKey");
    
    public static final CGImagePropertyGPS TrackRef = new CGImagePropertyGPS("TrackRefKey");
    
    public static final CGImagePropertyGPS Track = new CGImagePropertyGPS("TrackKey");
    
    public static final CGImagePropertyGPS ImgDirectionRef = new CGImagePropertyGPS("ImgDirectionRefKey");
    
    public static final CGImagePropertyGPS ImgDirection = new CGImagePropertyGPS("ImgDirectionKey");
    
    public static final CGImagePropertyGPS MapDatum = new CGImagePropertyGPS("MapDatumKey");
    
    public static final CGImagePropertyGPS DestLatitudeRef = new CGImagePropertyGPS("DestLatitudeRefKey");
    
    public static final CGImagePropertyGPS DestLatitude = new CGImagePropertyGPS("DestLatitudeKey");
    
    public static final CGImagePropertyGPS DestLongitudeRef = new CGImagePropertyGPS("DestLongitudeRefKey");
    
    public static final CGImagePropertyGPS DestLongitude = new CGImagePropertyGPS("DestLongitudeKey");
    
    public static final CGImagePropertyGPS DestBearingRef = new CGImagePropertyGPS("DestBearingRefKey");
    
    public static final CGImagePropertyGPS DestBearing = new CGImagePropertyGPS("DestBearingKey");
    
    public static final CGImagePropertyGPS DestDistanceRef = new CGImagePropertyGPS("DestDistanceRefKey");
    
    public static final CGImagePropertyGPS DestDistance = new CGImagePropertyGPS("DestDistanceKey");
    
    public static final CGImagePropertyGPS ProcessingMethod = new CGImagePropertyGPS("ProcessingMethodKey");
    
    public static final CGImagePropertyGPS AreaInformation = new CGImagePropertyGPS("AreaInformationKey");
    
    public static final CGImagePropertyGPS DateStamp = new CGImagePropertyGPS("DateStampKey");
    
    public static final CGImagePropertyGPS Differental = new CGImagePropertyGPS("DifferentalKey");
    
    public static final CGImagePropertyGPS HPositioningError = new CGImagePropertyGPS("HPositioningErrorKey");    
    
    private static CGImagePropertyGPS[] values = new CGImagePropertyGPS[] {Version, LatitudeRef, Latitude, LongitudeRef, 
        Longitude, AltitudeRef, Altitude, TimeStamp, Satellites, Status, MeasureMode, DOP, SpeedRef, Speed, TrackRef, Track, 
        ImgDirectionRef, ImgDirection, MapDatum, DestLatitudeRef, DestLatitude, DestLongitudeRef, DestLongitude, DestBearingRef, 
        DestBearing, DestDistanceRef, DestDistance, ProcessingMethod, AreaInformation, DateStamp, Differental, HPositioningError};
    private final LazyGlobalValue<CFString> lazyGlobalValue;
    
    private CGImagePropertyGPS(String getterName) {
        lazyGlobalValue = new LazyGlobalValue<>(getClass(), getterName);
    }
    
    
    
    public CFString value() {
        return lazyGlobalValue.value();
    }
    
    public static CGImagePropertyGPS valueOf(CFString value) {
        for (CGImagePropertyGPS v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImagePropertyGPS.class.getName());
    }
    
    
    @GlobalValue(symbol="kCGImagePropertyGPSVersion", optional=true)
    protected static native CFString VersionKey();
    
    @GlobalValue(symbol="kCGImagePropertyGPSLatitudeRef", optional=true)
    protected static native CFString LatitudeRefKey();
    
    @GlobalValue(symbol="kCGImagePropertyGPSLatitude", optional=true)
    protected static native CFString LatitudeKey();
    
    @GlobalValue(symbol="kCGImagePropertyGPSLongitudeRef", optional=true)
    protected static native CFString LongitudeRefKey();
    
    @GlobalValue(symbol="kCGImagePropertyGPSLongitude", optional=true)
    protected static native CFString LongitudeKey();
    
    @GlobalValue(symbol="kCGImagePropertyGPSAltitudeRef", optional=true)
    protected static native CFString AltitudeRefKey();
    
    @GlobalValue(symbol="kCGImagePropertyGPSAltitude", optional=true)
    protected static native CFString AltitudeKey();
    
    @GlobalValue(symbol="kCGImagePropertyGPSTimeStamp", optional=true)
    protected static native CFString TimeStampKey();
    
    @GlobalValue(symbol="kCGImagePropertyGPSSatellites", optional=true)
    protected static native CFString SatellitesKey();
    
    @GlobalValue(symbol="kCGImagePropertyGPSStatus", optional=true)
    protected static native CFString StatusKey();
    
    @GlobalValue(symbol="kCGImagePropertyGPSMeasureMode", optional=true)
    protected static native CFString MeasureModeKey();
    
    @GlobalValue(symbol="kCGImagePropertyGPSDOP", optional=true)
    protected static native CFString DOPKey();
    
    @GlobalValue(symbol="kCGImagePropertyGPSSpeedRef", optional=true)
    protected static native CFString SpeedRefKey();
    
    @GlobalValue(symbol="kCGImagePropertyGPSSpeed", optional=true)
    protected static native CFString SpeedKey();
    
    @GlobalValue(symbol="kCGImagePropertyGPSTrackRef", optional=true)
    protected static native CFString TrackRefKey();
    
    @GlobalValue(symbol="kCGImagePropertyGPSTrack", optional=true)
    protected static native CFString TrackKey();
    
    @GlobalValue(symbol="kCGImagePropertyGPSImgDirectionRef", optional=true)
    protected static native CFString ImgDirectionRefKey();
    
    @GlobalValue(symbol="kCGImagePropertyGPSImgDirection", optional=true)
    protected static native CFString ImgDirectionKey();
    
    @GlobalValue(symbol="kCGImagePropertyGPSMapDatum", optional=true)
    protected static native CFString MapDatumKey();
    
    @GlobalValue(symbol="kCGImagePropertyGPSDestLatitudeRef", optional=true)
    protected static native CFString DestLatitudeRefKey();
    
    @GlobalValue(symbol="kCGImagePropertyGPSDestLatitude", optional=true)
    protected static native CFString DestLatitudeKey();
    
    @GlobalValue(symbol="kCGImagePropertyGPSDestLongitudeRef", optional=true)
    protected static native CFString DestLongitudeRefKey();
    
    @GlobalValue(symbol="kCGImagePropertyGPSDestLongitude", optional=true)
    protected static native CFString DestLongitudeKey();
    
    @GlobalValue(symbol="kCGImagePropertyGPSDestBearingRef", optional=true)
    protected static native CFString DestBearingRefKey();
    
    @GlobalValue(symbol="kCGImagePropertyGPSDestBearing", optional=true)
    protected static native CFString DestBearingKey();
    
    @GlobalValue(symbol="kCGImagePropertyGPSDestDistanceRef", optional=true)
    protected static native CFString DestDistanceRefKey();
    
    @GlobalValue(symbol="kCGImagePropertyGPSDestDistance", optional=true)
    protected static native CFString DestDistanceKey();
    
    @GlobalValue(symbol="kCGImagePropertyGPSProcessingMethod", optional=true)
    protected static native CFString ProcessingMethodKey();
    
    @GlobalValue(symbol="kCGImagePropertyGPSAreaInformation", optional=true)
    protected static native CFString AreaInformationKey();
    
    @GlobalValue(symbol="kCGImagePropertyGPSDateStamp", optional=true)
    protected static native CFString DateStampKey();
    
    @GlobalValue(symbol="kCGImagePropertyGPSDifferental", optional=true)
    protected static native CFString DifferentalKey();
    
    @GlobalValue(symbol="kCGImagePropertyGPSHPositioningError", optional=true)
    protected static native CFString HPositioningErrorKey();
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;

import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImagePropertyCIFFData.Marshaler.class)
@Library("ImageIO")
public class CGImagePropertyCIFFData 
    extends Object 
     {

    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyCIFFData toObject(Class<CGImagePropertyCIFFData> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImagePropertyCIFFData(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyCIFFData o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    
    
    
    private CFDictionary data;
    
    protected CGImagePropertyCIFFData(CFDictionary data) {
        this.data = data;
    }
    public CGImagePropertyCIFFData() {
        this.data = CFMutableDictionary.create();
    }
    static { Bro.bind(CGImagePropertyCIFFData.class); }
    
    
    
    
    public CFDictionary getDictionary() {
        return data;
    }
    
    public boolean has(CGImagePropertyCIFF property) {
        return data.containsKey(property.value());
    }
    
    public String getString(CGImagePropertyCIFF property) {
        if (has(property)) {
            CFString val = data.get(property.value(), CFString.class);
            return val.toString();
        }
        return null;
    }
    public double getNumber(CGImagePropertyCIFF property) {
        if (has(property)) {
            CFNumber val = data.get(property.value(), CFNumber.class);
            return val.doubleValue();
        }
        return 0;
    }
    public CGImagePropertyCIFFData set(CGImagePropertyCIFF property, String value) {
        data.put(property.value(), new CFString(value));
        return this;
    }
    public CGImagePropertyCIFFData set(CGImagePropertyCIFF property, double value) {
        data.put(property.value(), CFNumber.valueOf(value));
        return this;
    }
    
    
    @Override
    public String toString() {
        if (data != null) return data.toString();
        return super.toString();
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImageDestinationCopySourceOptions.Marshaler.class)
@Library("ImageIO")
public class CGImageDestinationCopySourceOptions 
    extends CocoaUtility 
     {
    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImageDestinationCopySourceOptions toObject(Class<CGImageDestinationCopySourceOptions> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImageDestinationCopySourceOptions(o);
        }
        @MarshalsPointer
        public static long toNative(CGImageDestinationCopySourceOptions o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }

    
    
    private CFDictionary data;
    
    protected CGImageDestinationCopySourceOptions(CFDictionary data) {
        this.data = data;
    }
    public CGImageDestinationCopySourceOptions() {
        this.data = CFMutableDictionary.create();
    }
    static { Bro.bind(CGImageDestinationCopySourceOptions.class); }
    
    
    
    
    public CFDictionary getDictionary() {
        return data;
    }
    
    
    public CGImageMetadata getMetadata() {
        if (data.containsKey(DestinationMetadataKey())) {
            CGImageMetadata val = data.get(DestinationMetadataKey(), CGImageMetadata.class);
            return val;
        }
        return null;
    }
    
    public CGImageDestinationCopySourceOptions setMetadata(CGImageMetadata metadata) {
        data.put(DestinationMetadataKey(), metadata);
        return this;
    }
    
    public boolean isMergingMetadata() {
        if (data.containsKey(DestinationMergeMetadataKey())) {
            CFBoolean val = data.get(DestinationMergeMetadataKey(), CFBoolean.class);
            return val.booleanValue();
        }
        return false;
    }
    
    public CGImageDestinationCopySourceOptions setMergeMetadata(boolean merge) {
        data.put(DestinationMergeMetadataKey(), CFBoolean.valueOf(merge));
        return this;
    }
    
    public boolean shouldExcludeXMP() {
        if (data.containsKey(MetadataShouldExcludeXMPKey())) {
            CFBoolean val = data.get(MetadataShouldExcludeXMPKey(), CFBoolean.class);
            return val.booleanValue();
        }
        return false;
    }
    
    public CGImageDestinationCopySourceOptions setShouldExcludeXMP(boolean exclude) {
        data.put(MetadataShouldExcludeXMPKey(), CFBoolean.valueOf(exclude));
        return this;
    }
    
    public boolean shouldExcludeGPS() {
        if (data.containsKey(MetadataShouldExcludeGPSKey())) {
            CFBoolean val = data.get(MetadataShouldExcludeGPSKey(), CFBoolean.class);
            return val.booleanValue();
        }
        return false;
    }
    
    public CGImageDestinationCopySourceOptions setShouldExcludeGPS(boolean exclude) {
        data.put(MetadataShouldExcludeGPSKey(), CFBoolean.valueOf(exclude));
        return this;
    }
    
    public String getDateTime() {
        if (data.containsKey(DestinationDateTimeKey())) {
            CFString val = data.get(DestinationDateTimeKey(), CFString.class);
            return val.toString();
        }
        return null;
    }
    
    public CGImageDestinationCopySourceOptions setDateTime(String dateTime) {
        data.put(DestinationDateTimeKey(), new CFString(dateTime));
        return this;
    }
    
    public CGImageDestinationCopySourceOptions setDateTime(NSDate dateTime) {
        data.put(DestinationDateTimeKey(), dateTime);
        return this;
    }
    
    public CGImagePropertyOrientation getOrientation() {
        if (data.containsKey(DestinationOrientationKey())) {
            CFNumber val = data.get(DestinationOrientationKey(), CFNumber.class);
            return CGImagePropertyOrientation.valueOf(val.intValue());
        }
        return null;
    }
    
    public CGImageDestinationCopySourceOptions setOrientation(CGImagePropertyOrientation orientation) {
        data.put(DestinationOrientationKey(), CFNumber.valueOf(orientation.value()));
        return this;
    }
    
    
    @GlobalValue(symbol="kCGImageDestinationMetadata", optional=true)
    protected static native CFString DestinationMetadataKey();
    
    @GlobalValue(symbol="kCGImageDestinationMergeMetadata", optional=true)
    protected static native CFString DestinationMergeMetadataKey();
    
    @GlobalValue(symbol="kCGImageMetadataShouldExcludeXMP", optional=true)
    protected static native CFString MetadataShouldExcludeXMPKey();
    
    @GlobalValue(symbol="kCGImageMetadataShouldExcludeGPS", optional=true)
    protected static native CFString MetadataShouldExcludeGPSKey();
    
    @GlobalValue(symbol="kCGImageDestinationDateTime", optional=true)
    protected static native CFString DestinationDateTimeKey();
    
    @GlobalValue(symbol="kCGImageDestinationOrientation", optional=true)
    protected static native CFString DestinationOrientationKey();
    
    @Override
    public String toString() {
        if (data != null) return data.toString();
        return super.toString();
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImagePropertyIPTCContactInfo.Marshaler.class)
@Library("ImageIO")
public class CGImagePropertyIPTCContactInfo 
    extends CocoaUtility 
     {

    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyIPTCContactInfo toObject(Class<CGImagePropertyIPTCContactInfo> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImagePropertyIPTCContactInfo.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyIPTCContactInfo o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }

    
    
    static { Bro.bind(CGImagePropertyIPTCContactInfo.class); }
    
    
    public static final CGImagePropertyIPTCContactInfo City = new CGImagePropertyIPTCContactInfo("CityKey");
    
    public static final CGImagePropertyIPTCContactInfo Country = new CGImagePropertyIPTCContactInfo("CountryKey");
    
    public static final CGImagePropertyIPTCContactInfo Address = new CGImagePropertyIPTCContactInfo("AddressKey");
    
    public static final CGImagePropertyIPTCContactInfo PostalCode = new CGImagePropertyIPTCContactInfo("PostalCodeKey");
    
    public static final CGImagePropertyIPTCContactInfo StateProvince = new CGImagePropertyIPTCContactInfo("StateProvinceKey");
    
    public static final CGImagePropertyIPTCContactInfo Emails = new CGImagePropertyIPTCContactInfo("EmailsKey");
    
    public static final CGImagePropertyIPTCContactInfo Phones = new CGImagePropertyIPTCContactInfo("PhonesKey");
    
    public static final CGImagePropertyIPTCContactInfo WebURLs = new CGImagePropertyIPTCContactInfo("WebURLsKey");
    
    private static CGImagePropertyIPTCContactInfo[] values = new CGImagePropertyIPTCContactInfo[] {City, Country, Address, PostalCode, 
        StateProvince, Emails, Phones, WebURLs};
    private final LazyGlobalValue<CFString> lazyGlobalValue;
    
    private CGImagePropertyIPTCContactInfo(String getterName) {
        lazyGlobalValue = new LazyGlobalValue<>(getClass(), getterName);
    }
    
    
    
    public CFString value() {
        return lazyGlobalValue.value();
    }
    
    public static CGImagePropertyIPTCContactInfo valueOf(CFString value) {
        for (CGImagePropertyIPTCContactInfo v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImagePropertyIPTCContactInfo.class.getName());
    }
    
    
    @GlobalValue(symbol="kCGImagePropertyIPTCContactInfoCity", optional=true)
    protected static native CFString CityKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCContactInfoCountry", optional=true)
    protected static native CFString CountryKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCContactInfoAddress", optional=true)
    protected static native CFString AddressKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCContactInfoPostalCode", optional=true)
    protected static native CFString PostalCodeKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCContactInfoStateProvince", optional=true)
    protected static native CFString StateProvinceKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCContactInfoEmails", optional=true)
    protected static native CFString EmailsKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCContactInfoPhones", optional=true)
    protected static native CFString PhonesKey();
    
    @GlobalValue(symbol="kCGImagePropertyIPTCContactInfoWebURLs", optional=true)
    protected static native CFString WebURLsKey();
    
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;

import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImagePropertyTIFFData.Marshaler.class)
@Library("ImageIO")
public class CGImagePropertyTIFFData 
    extends Object 
     {

    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyTIFFData toObject(Class<CGImagePropertyTIFFData> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImagePropertyTIFFData(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyTIFFData o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    
    
    
    private CFDictionary data;
    
    protected CGImagePropertyTIFFData(CFDictionary data) {
        this.data = data;
    }
    public CGImagePropertyTIFFData() {
        this.data = CFMutableDictionary.create();
    }
    static { Bro.bind(CGImagePropertyTIFFData.class); }
    
    
    
    
    public CFDictionary getDictionary() {
        return data;
    }
    
    public boolean has(CGImagePropertyTIFF property) {
        return data.containsKey(property.value());
    }
    
    public String getString(CGImagePropertyTIFF property) {
        if (has(property)) {
            CFString val = data.get(property.value(), CFString.class);
            return val.toString();
        }
        return null;
    }
    public double getNumber(CGImagePropertyTIFF property) {
        if (has(property)) {
            CFNumber val = data.get(property.value(), CFNumber.class);
            return val.doubleValue();
        }
        return 0;
    }
    public CGImagePropertyTIFFData set(CGImagePropertyTIFF property, String value) {
        data.put(property.value(), new CFString(value));
        return this;
    }
    public CGImagePropertyTIFFData set(CGImagePropertyTIFF property, double value) {
        data.put(property.value(), CFNumber.valueOf(value));
        return this;
    }
    
    
    @Override
    public String toString() {
        if (data != null) return data.toString();
        return super.toString();
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;

import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImagePropertyDNGData.Marshaler.class)
@Library("ImageIO")
public class CGImagePropertyDNGData 
    extends Object 
     {

    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyDNGData toObject(Class<CGImagePropertyDNGData> cls, long handle, long flags) {
            CFDictionary o = (CFDictionary) CFType.Marshaler.toObject(CFDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CGImagePropertyDNGData(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyDNGData o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.data, flags);
        }
    }
    
    
    
    private CFDictionary data;
    
    protected CGImagePropertyDNGData(CFDictionary data) {
        this.data = data;
    }
    public CGImagePropertyDNGData() {
        this.data = CFMutableDictionary.create();
    }
    static { Bro.bind(CGImagePropertyDNGData.class); }
    
    
    
    
    public CFDictionary getDictionary() {
        return data;
    }
    
    public boolean has(CGImagePropertyDNG property) {
        return data.containsKey(property.value());
    }
    
    public String getString(CGImagePropertyDNG property) {
        if (has(property)) {
            CFString val = data.get(property.value(), CFString.class);
            return val.toString();
        }
        return null;
    }
    public double getNumber(CGImagePropertyDNG property) {
        if (has(property)) {
            CFNumber val = data.get(property.value(), CFNumber.class);
            return val.doubleValue();
        }
        return 0;
    }
    public CGImagePropertyDNGData set(CGImagePropertyDNG property, String value) {
        data.put(property.value(), new CFString(value));
        return this;
    }
    public CGImagePropertyDNGData set(CGImagePropertyDNG property, double value) {
        data.put(property.value(), CFNumber.valueOf(value));
        return this;
    }
    
    
    @Override
    public String toString() {
        if (data != null) return data.toString();
        return super.toString();
    }
}

<code block>

package org.robovm.apple.imageio;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.coregraphics.*;




@Marshaler(CGImagePropertyNikon.Marshaler.class)
@Library("ImageIO")
public class CGImagePropertyNikon 
    extends CocoaUtility 
     {
    
    public static class Marshaler {
        @MarshalsPointer
        public static CGImagePropertyNikon toObject(Class<CGImagePropertyNikon> cls, long handle, long flags) {
            CFString o = (CFString) CFType.Marshaler.toObject(CFString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CGImagePropertyNikon.valueOf(o);
        }
        @MarshalsPointer
        public static long toNative(CGImagePropertyNikon o, long flags) {
            if (o == null) {
                return 0L;
            }
            return CFType.Marshaler.toNative(o.value(), flags);
        }
    }

    
    
    static { Bro.bind(CGImagePropertyNikon.class); }
    
    
    public static final CGImagePropertyNikon ISOSetting = new CGImagePropertyNikon("ISOSettingKey");
    
    public static final CGImagePropertyNikon ColorMode = new CGImagePropertyNikon("ColorModeKey");
    
    public static final CGImagePropertyNikon Quality = new CGImagePropertyNikon("QualityKey");
    
    public static final CGImagePropertyNikon WhiteBalanceMode = new CGImagePropertyNikon("WhiteBalanceModeKey");
    
    public static final CGImagePropertyNikon SharpenMode = new CGImagePropertyNikon("SharpenModeKey");
    
    public static final CGImagePropertyNikon FocusMode = new CGImagePropertyNikon("FocusModeKey");
    
    public static final CGImagePropertyNikon FlashSetting = new CGImagePropertyNikon("FlashSettingKey");
    
    public static final CGImagePropertyNikon ISOSelection = new CGImagePropertyNikon("ISOSelectionKey");
    
    public static final CGImagePropertyNikon FlashExposureComp = new CGImagePropertyNikon("FlashExposureCompKey");
    
    public static final CGImagePropertyNikon ImageAdjustment = new CGImagePropertyNikon("ImageAdjustmentKey");
    
    public static final CGImagePropertyNikon LensAdapter = new CGImagePropertyNikon("LensAdapterKey");
    
    public static final CGImagePropertyNikon LensType = new CGImagePropertyNikon("LensTypeKey");
    
    public static final CGImagePropertyNikon LensInfo = new CGImagePropertyNikon("LensInfoKey");
    
    public static final CGImagePropertyNikon FocusDistance = new CGImagePropertyNikon("FocusDistanceKey");
    
    public static final CGImagePropertyNikon DigitalZoom = new CGImagePropertyNikon("DigitalZoomKey");
    
    public static final CGImagePropertyNikon ShootingMode = new CGImagePropertyNikon("ShootingModeKey");
    
    public static final CGImagePropertyNikon CameraSerialNumber = new CGImagePropertyNikon("CameraSerialNumberKey");
    
    public static final CGImagePropertyNikon ShutterCount = new CGImagePropertyNikon("ShutterCountKey");
    
    private static CGImagePropertyNikon[] values = new CGImagePropertyNikon[] {ISOSetting, ColorMode, Quality, 
        WhiteBalanceMode, SharpenMode, FocusMode, FlashSetting, ISOSelection, FlashExposureComp, ImageAdjustment, 
        LensAdapter, LensType, LensInfo, FocusDistance, DigitalZoom, ShootingMode, CameraSerialNumber, ShutterCount};
    private final LazyGlobalValue<CFString> lazyGlobalValue;
    
    private CGImagePropertyNikon(String getterName) {
        lazyGlobalValue = new LazyGlobalValue<>(getClass(), getterName);
    }
    
    
    
    public CFString value() {
        return lazyGlobalValue.value();
    }
    
    public static CGImagePropertyNikon valueOf(CFString value) {
        for (CGImagePropertyNikon v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CGImagePropertyNikon.class.getName());
    }
    
    
    @GlobalValue(symbol="kCGImagePropertyMakerNikonISOSetting", optional=true)
    protected static native CFString ISOSettingKey();
    
    @GlobalValue(symbol="kCGImagePropertyMakerNikonColorMode", optional=true)
    protected static native CFString ColorModeKey();
    
    @GlobalValue(symbol="kCGImagePropertyMakerNikonQuality", optional=true)
    protected static native CFString QualityKey();
    
    @GlobalValue(symbol="kCGImagePropertyMakerNikonWhiteBalanceMode", optional=true)
    protected static native CFString WhiteBalanceModeKey();
    
    @GlobalValue(symbol="kCGImagePropertyMakerNikonSharpenMode", optional=true)
    protected static native CFString SharpenModeKey();
    
    @GlobalValue(symbol="kCGImagePropertyMakerNikonFocusMode", optional=true)
    protected static native CFString FocusModeKey();
    
    @GlobalValue(symbol="kCGImagePropertyMakerNikonFlashSetting", optional=true)
    protected static native CFString FlashSettingKey();
    
    @GlobalValue(symbol="kCGImagePropertyMakerNikonISOSelection", optional=true)
    protected static native CFString ISOSelectionKey();
    
    @GlobalValue(symbol="kCGImagePropertyMakerNikonFlashExposureComp", optional=true)
    protected static native CFString FlashExposureCompKey();
    
    @GlobalValue(symbol="kCGImagePropertyMakerNikonImageAdjustment", optional=true)
    protected static native CFString ImageAdjustmentKey();
    
    @GlobalValue(symbol="kCGImagePropertyMakerNikonLensAdapter", optional=true)
    protected static native CFString LensAdapterKey();
    
    @GlobalValue(symbol="kCGImagePropertyMakerNikonLensType", optional=true)
    protected static native CFString LensTypeKey();
    
    @GlobalValue(symbol="kCGImagePropertyMakerNikonLensInfo", optional=true)
    protected static native CFString LensInfoKey();
    
    @GlobalValue(symbol="kCGImagePropertyMakerNikonFocusDistance", optional=true)
    protected static native CFString FocusDistanceKey();
    
    @GlobalValue(symbol="kCGImagePropertyMakerNikonDigitalZoom", optional=true)
    protected static native CFString DigitalZoomKey();
    
    @GlobalValue(symbol="kCGImagePropertyMakerNikonShootingMode", optional=true)
    protected static native CFString ShootingModeKey();
    
    @GlobalValue(symbol="kCGImagePropertyMakerNikonCameraSerialNumber", optional=true)
    protected static native CFString CameraSerialNumberKey();
    
    @GlobalValue(symbol="kCGImagePropertyMakerNikonShutterCount", optional=true)
    protected static native CFString ShutterCountKey();
    
}

<code block>

package org.robovm.apple.corebluetooth;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.dispatch.*;




@Marshaler(CBAdvertisementData.Marshaler.class)
@Library("CoreBluetooth")
public class CBAdvertisementData 
    extends CocoaUtility 
     {
    
    public static class Marshaler {
        @SuppressWarnings("unchecked")
        @MarshalsPointer
        public static CBAdvertisementData toObject(Class<CBAdvertisementData> cls, long handle, long flags) {
            NSDictionary<NSString, NSObject> o = (NSDictionary<NSString, NSObject>) NSObject.Marshaler.toObject(NSDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CBAdvertisementData(o);
        }
        @MarshalsPointer
        public static long toNative(CBAdvertisementData o, long flags) {
            if (o == null) {
                return 0L;
            }
            return NSObject.Marshaler.toNative(o.data, flags);
        }
    }

    
    
    private NSDictionary<NSString, NSObject> data;
    
    protected CBAdvertisementData(NSDictionary<NSString, NSObject> data) {
        this.data = data;
    }
    static { Bro.bind(CBAdvertisementData.class); }
    
    
    
    
    public NSDictionary<NSString, NSObject> getDictionary() {
        return data;
    }
    
    
    public String getLocalName() {
        if (data.containsKey(LocalNameKey())) {
            NSString val = (NSString)data.get(LocalNameKey());
            return val.toString();
        }
        return null;
    }
    public double getTxPowerLevel() {
        if (data.containsKey(TxPowerLevelKey())) {
            NSNumber val = (NSNumber)data.get(TxPowerLevelKey());
            return val.doubleValue();
        }
        return 0;
    }
    @SuppressWarnings("unchecked")
    public NSArray<CBUUID> getServiceUUIDs() {
        if (data.containsKey(ServiceUUIDsKey())) {
            NSArray<CBUUID> val = (NSArray<CBUUID>)data.get(ServiceUUIDsKey());
            return val;
        }
        return null;
    }
    @SuppressWarnings("unchecked")
    public NSDictionary<CBUUID, NSData> getServiceData() {
        if (data.containsKey(ServiceDataKey())) {
            NSDictionary<CBUUID, NSData> val = (NSDictionary<CBUUID, NSData>)data.get(ServiceDataKey());
            return val;
        }
        return null;
    }
    public NSData getManufacturerData() {
        if (data.containsKey(ManufacturerDataKey())) {
            NSData val = (NSData)data.get(ManufacturerDataKey());
            return val;
        }
        return null;
    }
    
    @SuppressWarnings("unchecked")
    public NSArray<CBUUID> getOverflowServiceUUIDs() {
        if (data.containsKey(OverflowServiceUUIDsKey())) {
            NSArray<CBUUID> val = (NSArray<CBUUID>)data.get(OverflowServiceUUIDsKey());
            return val;
        }
        return null;
    }
    
    public boolean isConnectable() {
        if (data.containsKey(IsConnectable())) {
            NSNumber val = (NSNumber)data.get(IsConnectable());
            return val.booleanValue();
        }
        return false;
    }
    
    @SuppressWarnings("unchecked")
    public NSArray<CBUUID> getSolicitedServiceUUIDs() {
        if (data.containsKey(SolicitedServiceUUIDsKey())) {
            NSArray<CBUUID> val = (NSArray<CBUUID>)data.get(SolicitedServiceUUIDsKey());
            return val;
        }
        return null;
    }
    
    @GlobalValue(symbol="CBAdvertisementDataLocalNameKey", optional=true)
    protected static native NSString LocalNameKey();
    @GlobalValue(symbol="CBAdvertisementDataTxPowerLevelKey", optional=true)
    protected static native NSString TxPowerLevelKey();
    @GlobalValue(symbol="CBAdvertisementDataServiceUUIDsKey", optional=true)
    protected static native NSString ServiceUUIDsKey();
    @GlobalValue(symbol="CBAdvertisementDataServiceDataKey", optional=true)
    protected static native NSString ServiceDataKey();
    @GlobalValue(symbol="CBAdvertisementDataManufacturerDataKey", optional=true)
    protected static native NSString ManufacturerDataKey();
    
    @GlobalValue(symbol="CBAdvertisementDataOverflowServiceUUIDsKey", optional=true)
    protected static native NSString OverflowServiceUUIDsKey();
    
    @GlobalValue(symbol="CBAdvertisementDataIsConnectable", optional=true)
    protected static native NSString IsConnectable();
    
    @GlobalValue(symbol="CBAdvertisementDataSolicitedServiceUUIDsKey", optional=true)
    protected static native NSString SolicitedServiceUUIDsKey();
    
    @Override
    public String toString() {
        if (data != null) return data.toString();
        return super.toString();
    }
}

<code block>

package org.robovm.apple.corebluetooth;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.dispatch.*;




@Marshaler(CBUUIDIdentifier.Marshaler.class)
@Library("CoreBluetooth")
public class CBUUIDIdentifier 
    extends CocoaUtility 
     {
    
    public static class Marshaler {
        @MarshalsPointer
        public static CBUUIDIdentifier toObject(Class<CBUUIDIdentifier> cls, long handle, long flags) {
            NSString o = (NSString) NSObject.Marshaler.toObject(NSString.class, handle, flags);
            if (o == null) {
                return null;
            }
            return CBUUIDIdentifier.valueOf(o.toString());
        }
        @MarshalsPointer
        public static long toNative(CBUUIDIdentifier o, long flags) {
            if (o == null) {
                return 0L;
            }
            return NSObject.Marshaler.toNative(new NSString(o.value()), flags);
        }
    }

    
    
    static { Bro.bind(CBUUIDIdentifier.class); }
    
    public static final CBUUIDIdentifier CharacteristicExtendedProperties = new CBUUIDIdentifier("CharacteristicExtendedPropertiesValue");
    public static final CBUUIDIdentifier CharacteristicUserDescription = new CBUUIDIdentifier("CharacteristicUserDescriptionValue");
    public static final CBUUIDIdentifier ClientCharacteristicConfiguration = new CBUUIDIdentifier("ClientCharacteristicConfigurationValue");
    public static final CBUUIDIdentifier ServerCharacteristicConfiguration = new CBUUIDIdentifier("ServerCharacteristicConfigurationValue");
    public static final CBUUIDIdentifier CharacteristicFormat = new CBUUIDIdentifier("CharacteristicFormatValue");
    public static final CBUUIDIdentifier CharacteristicAggregateFormat = new CBUUIDIdentifier("CharacteristicAggregateFormatValue");
    
    @Deprecated
    public static final CBUUIDIdentifier GenericAccessProfile = new CBUUIDIdentifier("GenericAccessProfileValue");
    
    @Deprecated
    public static final CBUUIDIdentifier GenericAttributeProfile = new CBUUIDIdentifier("GenericAttributeProfileValue");
    
    @Deprecated
    public static final CBUUIDIdentifier DeviceName = new CBUUIDIdentifier("DeviceNameValue");
    
    @Deprecated
    public static final CBUUIDIdentifier Appearance = new CBUUIDIdentifier("AppearanceValue");
    
    @Deprecated
    public static final CBUUIDIdentifier PeripheralPrivacyFlag = new CBUUIDIdentifier("PeripheralPrivacyFlagValue");
    
    @Deprecated
    public static final CBUUIDIdentifier ReconnectionAddress = new CBUUIDIdentifier("ReconnectionAddressValue");
    
    @Deprecated
    public static final CBUUIDIdentifier PeripheralPreferredConnectionParameters = new CBUUIDIdentifier("PeripheralPreferredConnectionParametersValue");
    
    @Deprecated
    public static final CBUUIDIdentifier ServiceChanged = new CBUUIDIdentifier("ServiceChangedValue");
    
    private static CBUUIDIdentifier[] values = new CBUUIDIdentifier[] {CharacteristicExtendedProperties, CharacteristicUserDescription, ClientCharacteristicConfiguration, ServerCharacteristicConfiguration, 
        CharacteristicFormat, CharacteristicAggregateFormat, GenericAccessProfile, GenericAttributeProfile, DeviceName, Appearance, PeripheralPrivacyFlag, ReconnectionAddress, PeripheralPreferredConnectionParameters, 
        ServiceChanged};
    private final LazyGlobalValue<String> lazyGlobalValue;
    
    private CBUUIDIdentifier(String getterName) {
        lazyGlobalValue = new LazyGlobalValue<>(getClass(), getterName);
    }
    
    
    
    public String value() {
        return lazyGlobalValue.value();
    }
    
    public static CBUUIDIdentifier valueOf(String value) {
        for (CBUUIDIdentifier v : values) {
            if (v.value().equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException("No constant with value " + value + " found in " 
            + CBUUIDIdentifier.class.getName());
    }
    
    @GlobalValue(symbol="CBUUIDCharacteristicExtendedPropertiesString", optional=true)
    protected static native String CharacteristicExtendedPropertiesValue();
    @GlobalValue(symbol="CBUUIDCharacteristicUserDescriptionString", optional=true)
    protected static native String CharacteristicUserDescriptionValue();
    @GlobalValue(symbol="CBUUIDClientCharacteristicConfigurationString", optional=true)
    protected static native String ClientCharacteristicConfigurationValue();
    @GlobalValue(symbol="CBUUIDServerCharacteristicConfigurationString", optional=true)
    protected static native String ServerCharacteristicConfigurationValue();
    @GlobalValue(symbol="CBUUIDCharacteristicFormatString", optional=true)
    protected static native String CharacteristicFormatValue();
    @GlobalValue(symbol="CBUUIDCharacteristicAggregateFormatString", optional=true)
    protected static native String CharacteristicAggregateFormatValue();
    
    @Deprecated
    @GlobalValue(symbol="CBUUIDGenericAccessProfileString", optional=true)
    protected static native String GenericAccessProfileValue();
    
    @Deprecated
    @GlobalValue(symbol="CBUUIDGenericAttributeProfileString", optional=true)
    protected static native String GenericAttributeProfileValue();
    
    @Deprecated
    @GlobalValue(symbol="CBUUIDDeviceNameString", optional=true)
    protected static native String DeviceNameValue();
    
    @Deprecated
    @GlobalValue(symbol="CBUUIDAppearanceString", optional=true)
    protected static native String AppearanceValue();
    
    @Deprecated
    @GlobalValue(symbol="CBUUIDPeripheralPrivacyFlagString", optional=true)
    protected static native String PeripheralPrivacyFlagValue();
    
    @Deprecated
    @GlobalValue(symbol="CBUUIDReconnectionAddressString", optional=true)
    protected static native String ReconnectionAddressValue();
    
    @Deprecated
    @GlobalValue(symbol="CBUUIDPeripheralPreferredConnectionParametersString", optional=true)
    protected static native String PeripheralPreferredConnectionParametersValue();
    
    @Deprecated
    @GlobalValue(symbol="CBUUIDServiceChangedString", optional=true)
    protected static native String ServiceChangedValue();
    
}

<code block>

package org.robovm.apple.corebluetooth;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.dispatch.*;




@Marshaler(CBPeripheralManagerOptions.Marshaler.class)
@Library("CoreBluetooth")
public class CBPeripheralManagerOptions 
    extends CocoaUtility 
     {

    public static class Marshaler {
        @SuppressWarnings("unchecked")
        @MarshalsPointer
        public static CBPeripheralManagerOptions toObject(Class<CBPeripheralManagerOptions> cls, long handle, long flags) {
            NSDictionary<NSString, NSObject> o = (NSDictionary<NSString, NSObject>) NSObject.Marshaler.toObject(NSDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CBPeripheralManagerOptions(o);
        }
        @MarshalsPointer
        public static long toNative(CBPeripheralManagerOptions o, long flags) {
            if (o == null) {
                return 0L;
            }
            return NSObject.Marshaler.toNative(o.data, flags);
        }
    }
    
    
    
    private NSDictionary<NSString, NSObject> data;
    
    protected CBPeripheralManagerOptions(NSDictionary<NSString, NSObject> data) {
        this.data = data;
    }
    public CBPeripheralManagerOptions() {
    	this.data = new NSMutableDictionary<>();
    }
    static { Bro.bind(CBPeripheralManagerOptions.class); }
    
    
    
    
    public NSDictionary<NSString, NSObject> getDictionary() {
        return data;
    }
    
    
    
    public boolean isShowingPowerAlert() {
        if (data.containsKey(ShowPowerAlertKey())) {
            NSNumber val = (NSNumber)data.get(ShowPowerAlertKey());
            return val.booleanValue();
        }
        return false;
    }
    
    public CBPeripheralManagerOptions setShowPowerAlert(boolean showAlert) {
        data.put(ShowPowerAlertKey(), NSNumber.valueOf(showAlert));
        return this;
    }
    
    public String getRestoreIdentifier() {
        if (data.containsKey(RestoreIdentifierKey())) {
            NSString val = (NSString)data.get(RestoreIdentifierKey());
            return val.toString();
        }
        return null;
    }
    
    public CBPeripheralManagerOptions setRestoreIdentifier(String identifier) {
        data.put(RestoreIdentifierKey(), new NSString(identifier));
        return this;
    }
    
    
    @GlobalValue(symbol="CBPeripheralManagerOptionShowPowerAlertKey", optional=true)
    protected static native NSString ShowPowerAlertKey();
    
    @GlobalValue(symbol="CBPeripheralManagerOptionRestoreIdentifierKey", optional=true)
    protected static native NSString RestoreIdentifierKey();
    
    @Override
    public String toString() {
        if (data != null) return data.toString();
        return super.toString();
    }
}

<code block>

package org.robovm.apple.corebluetooth;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.dispatch.*;




@Marshaler(CBCentralManagerRestoredState.Marshaler.class)
@Library("CoreBluetooth")
public class CBCentralManagerRestoredState 
    extends CocoaUtility 
     {

    public static class Marshaler {
        @SuppressWarnings("unchecked")
        @MarshalsPointer
        public static CBCentralManagerRestoredState toObject(Class<CBCentralManagerRestoredState> cls, long handle, long flags) {
            NSDictionary<NSString, NSObject> o = (NSDictionary<NSString, NSObject>) NSObject.Marshaler.toObject(NSDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CBCentralManagerRestoredState(o);
        }
        @MarshalsPointer
        public static long toNative(CBCentralManagerRestoredState o, long flags) {
            if (o == null) {
                return 0L;
            }
            return NSObject.Marshaler.toNative(o.data, flags);
        }
    }
    
    
    
    private NSDictionary<NSString, NSObject> data;
    
    protected CBCentralManagerRestoredState(NSDictionary<NSString, NSObject> data) {
        this.data = data;
    }
    static { Bro.bind(CBCentralManagerRestoredState.class); }
    
    
    
    
    public NSDictionary<NSString, NSObject> getDictionary() {
        return data;
    }
    
    
    
    @SuppressWarnings("unchecked")
    public NSArray<CBPeripheral> getPeripherals() {
        if (data.containsKey(PeripheralsKey())) {
            NSArray<CBPeripheral> val = (NSArray<CBPeripheral>)data.get(PeripheralsKey());
            return val;
        }
        return null;
    }
    
    @SuppressWarnings("unchecked")
    public NSArray<CBUUID> getScanServices() {
        if (data.containsKey(ScanServicesKey())) {
            NSArray<CBUUID> val = (NSArray<CBUUID>)data.get(ScanServicesKey());
            return val;
        }
        return null;
    }
    
    @SuppressWarnings("unchecked")
    public CBCentralManagerScanOptions getScanOptions() {
        if (data.containsKey(ScanOptionsKey())) {
            NSDictionary<NSString, NSObject> val = (NSDictionary<NSString, NSObject>)data.get(ScanOptionsKey());
            return new CBCentralManagerScanOptions(val);
        }
        return null;
    }
    
    
    @GlobalValue(symbol="CBCentralManagerRestoredStatePeripheralsKey", optional=true)
    protected static native NSString PeripheralsKey();
    
    @GlobalValue(symbol="CBCentralManagerRestoredStateScanServicesKey", optional=true)
    protected static native NSString ScanServicesKey();
    
    @GlobalValue(symbol="CBCentralManagerRestoredStateScanOptionsKey", optional=true)
    protected static native NSString ScanOptionsKey();
    
    @Override
    public String toString() {
        if (data != null) return data.toString();
        return super.toString();
    }
}

<code block>

package org.robovm.apple.corebluetooth;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.dispatch.*;





@Library("CoreBluetooth") @NativeClass
public class CBUUID 
    extends NSObject 
     {

    public static class CBUUIDPtr extends Ptr<CBUUID, CBUUIDPtr> {}
    static { ObjCRuntime.bind(CBUUID.class); }
    
    
    public CBUUID() {}
    protected CBUUID(SkipInit skipInit) { super(skipInit); }
    
    
    @Property(selector = "data")
    public native NSData getData();
    
    @Property(selector = "UUIDString")
    public native String getUUIDString();
    
    
    public static CBUUID create(CBUUIDIdentifier identifier) {
        return create(identifier.value());
    }
    
    @Method(selector = "UUIDWithString:")
    public static native CBUUID create(String theString);
    @Method(selector = "UUIDWithData:")
    public static native CBUUID create(NSData theData);
    @WeaklyLinked
    @Method(selector = "UUIDWithCFUUID:")
    public static native CBUUID create(CFUUID theUUID);
    
    @Method(selector = "UUIDWithNSUUID:")
    public static native CBUUID create(NSUUID theUUID);
    
}

<code block>

package org.robovm.apple.corebluetooth;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.dispatch.*;




@Marshaler(CBCentralManagerOptions.Marshaler.class)
@Library("CoreBluetooth")
public class CBCentralManagerOptions 
    extends CocoaUtility 
     {

    public static class Marshaler {
        @SuppressWarnings("unchecked")
        @MarshalsPointer
        public static CBCentralManagerOptions toObject(Class<CBCentralManagerOptions> cls, long handle, long flags) {
            NSDictionary<NSString, NSObject> o = (NSDictionary<NSString, NSObject>) NSObject.Marshaler.toObject(NSDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CBCentralManagerOptions(o);
        }
        @MarshalsPointer
        public static long toNative(CBCentralManagerOptions o, long flags) {
            if (o == null) {
                return 0L;
            }
            return NSObject.Marshaler.toNative(o.data, flags);
        }
    }
    
    
    
    private NSDictionary<NSString, NSObject> data;
    
    protected CBCentralManagerOptions(NSDictionary<NSString, NSObject> data) {
        this.data = data;
    }
    public CBCentralManagerOptions() {
    	this.data = new NSMutableDictionary<>();
	}
    static { Bro.bind(CBCentralManagerOptions.class); }
    
    
    
    
    public NSDictionary<NSString, NSObject> getDictionary() {
        return data;
    }
    
    
    
    public boolean isShowingPowerAlert() {
        if (data.containsKey(ShowPowerAlertKey())) {
            NSNumber val = (NSNumber)data.get(ShowPowerAlertKey());
            return val.booleanValue();
        }
        return false;
    }
    
    public CBCentralManagerOptions setShowPowerAlert(boolean showAlert) {
        data.put(ShowPowerAlertKey(), NSNumber.valueOf(showAlert));
        return this;
    }
    
    public String getRestoreIdentifier() {
        if (data.containsKey(RestoreIdentifierKey())) {
            NSString val = (NSString)data.get(RestoreIdentifierKey());
            return val.toString();
        }
        return null;
    }
    
    public CBCentralManagerOptions setRestoreIdentifier(String identifier) {
        data.put(RestoreIdentifierKey(), new NSString(identifier));
        return this;
    }
    
    
    @GlobalValue(symbol="CBCentralManagerOptionShowPowerAlertKey", optional=true)
    protected static native NSString ShowPowerAlertKey();
    
    @GlobalValue(symbol="CBCentralManagerOptionRestoreIdentifierKey", optional=true)
    protected static native NSString RestoreIdentifierKey();
    
    @Override
    public String toString() {
        if (data != null) return data.toString();
        return super.toString();
    }
}

<code block>

package org.robovm.apple.corebluetooth;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.dispatch.*;




@Marshaler(CBConnectPeripheralOptions.Marshaler.class)
@Library("CoreBluetooth")
public class CBConnectPeripheralOptions 
    extends CocoaUtility 
     {

    public static class Marshaler {
        @SuppressWarnings("unchecked")
        @MarshalsPointer
        public static CBConnectPeripheralOptions toObject(Class<CBConnectPeripheralOptions> cls, long handle, long flags) {
            NSDictionary<NSString, NSObject> o = (NSDictionary<NSString, NSObject>) NSObject.Marshaler.toObject(NSDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CBConnectPeripheralOptions(o);
        }
        @MarshalsPointer
        public static long toNative(CBConnectPeripheralOptions o, long flags) {
            if (o == null) {
                return 0L;
            }
            return NSObject.Marshaler.toNative(o.data, flags);
        }
    }
    
    
    
    private NSDictionary<NSString, NSObject> data;
    
    protected CBConnectPeripheralOptions(NSDictionary<NSString, NSObject> data) {
        this.data = data;
    }
    public CBConnectPeripheralOptions() {
    	this.data = new NSMutableDictionary<>();
    }
    static { Bro.bind(CBConnectPeripheralOptions.class); }
    
    
    
    
    public NSDictionary<NSString, NSObject> getDictionary() {
        return data;
    }
    
    
    public boolean isNotifyingOnConnection() {
        if (data.containsKey(NotifyOnConnectionKey())) {
            NSNumber val = (NSNumber)data.get(NotifyOnConnectionKey());
            return val.booleanValue();
        }
        return false;
    }
    
    public CBConnectPeripheralOptions setNotifyOnConnection(boolean notify) {
        data.put(NotifyOnConnectionKey(), NSNumber.valueOf(notify));
        return this;
    }
    public boolean isNotifyingOnDisconnection() {
        if (data.containsKey(NotifyOnDisconnectionKey())) {
            NSNumber val = (NSNumber)data.get(NotifyOnDisconnectionKey());
            return val.booleanValue();
        }
        return false;
    }
    public CBConnectPeripheralOptions setNotifyOnDisconnection(boolean notify) {
        data.put(NotifyOnDisconnectionKey(), NSNumber.valueOf(notify));
        return this;
    }
    
    public boolean isNotifyingOnNotification() {
        if (data.containsKey(NotifyOnNotificationKey())) {
            NSNumber val = (NSNumber)data.get(NotifyOnNotificationKey());
            return val.booleanValue();
        }
        return false;
    }
    
    public CBConnectPeripheralOptions setNotifyOnNotification(boolean notify) {
        data.put(NotifyOnNotificationKey(), NSNumber.valueOf(notify));
        return this;
    }
    
    
    @GlobalValue(symbol="CBConnectPeripheralOptionNotifyOnConnectionKey", optional=true)
    protected static native NSString NotifyOnConnectionKey();
    @GlobalValue(symbol="CBConnectPeripheralOptionNotifyOnDisconnectionKey", optional=true)
    protected static native NSString NotifyOnDisconnectionKey();
    
    @GlobalValue(symbol="CBConnectPeripheralOptionNotifyOnNotificationKey", optional=true)
    protected static native NSString NotifyOnNotificationKey();
    
    @Override
    public String toString() {
        if (data != null) return data.toString();
        return super.toString();
    }
}

<code block>

package org.robovm.apple.corebluetooth;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.dispatch.*;




@Marshaler(CBCentralManagerScanOptions.Marshaler.class)
@Library("CoreBluetooth")
public class CBCentralManagerScanOptions 
    extends CocoaUtility 
     {

    public static class Marshaler {
        @SuppressWarnings("unchecked")
        @MarshalsPointer
        public static CBCentralManagerScanOptions toObject(Class<CBCentralManagerScanOptions> cls, long handle, long flags) {
            NSDictionary<NSString, NSObject> o = (NSDictionary<NSString, NSObject>) NSObject.Marshaler.toObject(NSDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CBCentralManagerScanOptions(o);
        }
        @MarshalsPointer
        public static long toNative(CBCentralManagerScanOptions o, long flags) {
            if (o == null) {
                return 0L;
            }
            return NSObject.Marshaler.toNative(o.data, flags);
        }
    }
    
    
    
    private NSDictionary<NSString, NSObject> data;
    
    protected CBCentralManagerScanOptions(NSDictionary<NSString, NSObject> data) {
        this.data = data;
    }
    public CBCentralManagerScanOptions() {
    	this.data = new NSMutableDictionary<>();
    }
    static { Bro.bind(CBCentralManagerScanOptions.class); }
    
    
    
    
    public NSDictionary<NSString, NSObject> getDictionary() {
        return data;
    }
    
    public boolean isAllowingDuplicates() {
        if (data.containsKey(AllowDuplicatesKey())) {
            NSNumber val = (NSNumber)data.get(AllowDuplicatesKey());
            return val.booleanValue();
        }
        return false;
    }
    public CBCentralManagerScanOptions setAllowsDuplicates(boolean allowDuplicates) {
        data.put(AllowDuplicatesKey(), NSNumber.valueOf(allowDuplicates));
        return this;
    }
    
    @SuppressWarnings("unchecked")
    public NSArray<CBUUID> getSolicitedServiceUUIDs() {
        if (data.containsKey(SolicitedServiceUUIDsKey())) {
            NSArray<CBUUID> val = (NSArray<CBUUID>)data.get(SolicitedServiceUUIDsKey());
            return val;
        }
        return null;
    }
    
    public CBCentralManagerScanOptions setSolicitedServiceUUIDs(NSArray<CBUUID> uuids) {
        data.put(SolicitedServiceUUIDsKey(), uuids);
        return this;
    }
    
    @GlobalValue(symbol="CBCentralManagerScanOptionAllowDuplicatesKey", optional=true)
    protected static native NSString AllowDuplicatesKey();
    
    @GlobalValue(symbol="CBCentralManagerScanOptionSolicitedServiceUUIDsKey", optional=true)
    protected static native NSString SolicitedServiceUUIDsKey();
    
    @Override
    public String toString() {
        if (data != null) return data.toString();
        return super.toString();
    }
}

<code block>

package org.robovm.apple.corebluetooth;


import java.io.*;
import java.nio.*;
import java.util.*;
import org.robovm.objc.*;
import org.robovm.objc.annotation.*;
import org.robovm.objc.block.*;
import org.robovm.rt.*;
import org.robovm.rt.annotation.*;
import org.robovm.rt.bro.*;
import org.robovm.rt.bro.annotation.*;
import org.robovm.rt.bro.ptr.*;
import org.robovm.apple.foundation.*;
import org.robovm.apple.corefoundation.*;
import org.robovm.apple.dispatch.*;




@Marshaler(CBPeripheralManagerRestoredState.Marshaler.class)
@Library("CoreBluetooth")
public class CBPeripheralManagerRestoredState 
    extends CocoaUtility 
     {

    public static class Marshaler {
        @SuppressWarnings("unchecked")
        @MarshalsPointer
        public static CBPeripheralManagerRestoredState toObject(Class<CBPeripheralManagerRestoredState> cls, long handle, long flags) {
            NSDictionary<NSString, NSObject> o = (NSDictionary<NSString, NSObject>) NSObject.Marshaler.toObject(NSDictionary.class, handle, flags);
            if (o == null) {
                return null;
            }
            return new CBPeripheralManagerRestoredState(o);
        }
        @MarshalsPointer
        public static long toNative(CBPeripheralManagerRestoredState o, long flags) {
            if (o == null) {
                return 0L;
            }
            return NSObject.Marshaler.toNative(o.data, flags);
        }
    }
    
    
    
    private NSDictionary<NSString, NSObject> data;
    
    protected CBPeripheralManagerRestoredState(NSDictionary<NSString, NSObject> data) {
        this.data = data;
    }
    static { Bro.bind(CBPeripheralManagerRestoredState.class); }
    
    
    
    
    public NSDictionary<NSString, NSObject> getDictionary() {
        return data;
    }
    
    
    
    @SuppressWarnings("unchecked")
    public NSArray<CBMutableService> getServices() {
        if (data.containsKey(ServicesKey())) {
            NSArray<CBMutableService> val = (NSArray<CBMutableService>)data.get(ServicesKey());
            return val;
        }
        return null;
    }
    
    @SuppressWarnings("unchecked")
    public CBAdvertisementData getAdvertisementData() {
        if (data.containsKey(AdvertisementDataKey())) {
            NSDictionary<NSString, NSObject> val = (NSDictionary<NSString, NSObject>)data.get(AdvertisementDataKey());
            return new CBAdvertisementData(val);
        }
        return null;
    }
    
    
    @GlobalValue(symbol="CBPeripheralManagerRestoredStateServicesKey", optional=true)
    protected static native NSString ServicesKey();
    
    @GlobalValue(symbol="CBPeripheralManagerRestoredStateAdvertisementDataKey", optional=true)
    protected static native NSString AdvertisementDataKey();
    
    @Override
    public String toString() {
        if (data != null) return data.toString();
        return super.toString();
    }
}

<code block>

package org.robovm.compiler.target.ios;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.io.OutputStream;
import java.lang.reflect.Method;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.NoSuchElementException;
import java.util.Properties;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.xml.parsers.DocumentBuilder;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.io.filefilter.AndFileFilter;
import org.apache.commons.io.filefilter.PrefixFileFilter;
import org.apache.commons.io.filefilter.RegexFileFilter;
import org.robovm.compiler.CompilerException;
import org.robovm.compiler.config.Arch;
import org.robovm.compiler.config.Config;
import org.robovm.compiler.config.OS;
import org.robovm.compiler.config.Resource;
import org.robovm.compiler.log.Logger;
import org.robovm.compiler.target.AbstractTarget;
import org.robovm.compiler.target.LaunchParameters;
import org.robovm.compiler.target.Launcher;
import org.robovm.compiler.target.ios.ProvisioningProfile.Type;
import org.robovm.compiler.util.Executor;
import org.robovm.compiler.util.ToolchainUtil;
import org.robovm.compiler.util.io.OpenOnWriteFileOutputStream;
import org.robovm.libimobiledevice.AfcClient.UploadProgressCallback;
import org.robovm.libimobiledevice.IDevice;
import org.robovm.libimobiledevice.InstallationProxyClient.StatusCallback;
import org.robovm.libimobiledevice.util.AppLauncher;
import org.robovm.libimobiledevice.util.AppLauncherCallback;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.Text;

import com.dd.plist.NSArray;
import com.dd.plist.NSDictionary;
import com.dd.plist.NSNumber;
import com.dd.plist.NSObject;
import com.dd.plist.NSString;
import com.dd.plist.PropertyListParser;
import com.dd.plist.XMLPropertyListParser;


public class IOSTarget extends AbstractTarget {
    private static File iosSimPath;

    private Arch arch;
    private SDK sdk;
    private File resourceRulesPList;
    private File entitlementsPList;
    private SigningIdentity signIdentity;
    private ProvisioningProfile provisioningProfile;
    private IDevice device;
    private File partialPListDir;

    public IOSTarget() {}

    @Override
    public Arch getArch() {
        return arch;
    }

    @Override
    public LaunchParameters createLaunchParameters() {
        if (isSimulatorArch(arch)) {
            return new IOSSimulatorLaunchParameters();
        }
        return new IOSDeviceLaunchParameters();
    }

    public static boolean isSimulatorArch(Arch arch) {
        return arch == Arch.x86 || arch == Arch.x86_64;
    }

    public static boolean isDeviceArch(Arch arch) {
        return arch == Arch.thumbv7 || arch == Arch.arm64;
    }

    public static synchronized File getIosSimPath() {
        if (iosSimPath == null) {
            try {
                File path = File.createTempFile("ios-sim", "");
                FileUtils.copyURLToFile(IOSTarget.class.getResource("/ios-sim"), path);
                path.setExecutable(true);
                path.deleteOnExit();
                iosSimPath = path;
            } catch (IOException e) {
                throw new Error(e);
            }
        }
        return iosSimPath;
    }

    public List<SDK> getSDKs() {
        if (isSimulatorArch(arch)) {
            return SDK.listSimulatorSDKs();
        } else {
            return SDK.listDeviceSDKs();
        }
    }

    
    public IDevice getDevice() {
        return device;
    }

    @Override
    protected Launcher createLauncher(LaunchParameters launchParameters) throws IOException {
        if (isSimulatorArch(arch)) {
            return createIOSSimLauncher(launchParameters);
        } else {
            return createIOSDevLauncher(launchParameters);
        }
    }

    private Launcher createIOSSimLauncher(LaunchParameters launchParameters)
            throws IOException {

        File dir = getAppDir();

        String iosSimPath = new File(config.getHome().getBinDir(), "ios-sim").getAbsolutePath();

        List<Object> args = new ArrayList<Object>();
        args.add("launch");
        args.add(dir);
        args.add("--timeout");
        args.add("90");
        args.add("--unbuffered");
        if (((IOSSimulatorLaunchParameters) launchParameters).getDeviceType() != null) {
            DeviceType deviceType = ((IOSSimulatorLaunchParameters) launchParameters).getDeviceType();
            args.add("--devicetypeid");
            args.add(deviceType.getDeviceTypeId());
        }
        if (launchParameters.getStdoutFifo() != null) {
            args.add("--stdout");
            args.add(launchParameters.getStdoutFifo());
        }
        if (launchParameters.getStderrFifo() != null) {
            args.add("--stderr");
            args.add(launchParameters.getStderrFifo());
        }
        if (launchParameters.getEnvironment() != null) {
            for (Entry<String, String> entry : launchParameters.getEnvironment().entrySet()) {
                args.add("--setenv");
                args.add(entry.getKey() + "=" + entry.getValue());
            }
        }

        if (!launchParameters.getArguments().isEmpty()) {
            args.add("--args");
            args.addAll(launchParameters.getArguments());
        }

        File xcodePath = new File(ToolchainUtil.findXcodePath());
        Map<String, String> env = Collections.singletonMap("DEVELOPER_DIR", xcodePath.getAbsolutePath());
        return new Executor(config.getLogger(), iosSimPath)
                .args(args)
                .wd(launchParameters.getWorkingDirectory())
                .inheritEnv(false)
                .env(env);
    }

    private Launcher createIOSDevLauncher(LaunchParameters launchParameters)
            throws IOException {

        IOSDeviceLaunchParameters deviceLaunchParameters = (IOSDeviceLaunchParameters) launchParameters;
        String deviceId = deviceLaunchParameters.getDeviceId();
        int forwardPort = deviceLaunchParameters.getForwardPort();
        AppLauncherCallback callback = deviceLaunchParameters.getAppPathCallback();
        if (deviceId == null) {
            String[] udids = IDevice.listUdids();
            if (udids.length == 0) {
                throw new RuntimeException("No devices connected");
            }
            if (udids.length > 1) {
                config.getLogger().warn("More than 1 device connected (%s). "
                        + "Using %s.", Arrays.asList(udids), udids[0]);
            }
            deviceId = udids[0];
        }
        device = new IDevice(deviceId);

        OutputStream out = null;
        if (launchParameters.getStdoutFifo() != null) {
            out = new OpenOnWriteFileOutputStream(launchParameters.getStdoutFifo());
        } else {
            out = System.out;
        }

        Map<String, String> env = launchParameters.getEnvironment();
        if (env == null) {
            env = new HashMap<>();
        }

        AppLauncher launcher = new AppLauncher(device, getAppDir()) {
            protected void log(String s, Object... args) {
                config.getLogger().debug(s, args);
            }
        }
                .stdout(out)
                .closeOutOnExit(true)
                .args(launchParameters.getArguments().toArray(new String[0]))
                .env(env)
                .forward(forwardPort)
                .appLauncherCallback(callback)
                .xcodePath(ToolchainUtil.findXcodePath())
                .uploadProgressCallback(new UploadProgressCallback() {
                    boolean first = true;

                    public void success() {
                        config.getLogger().debug("[100%%] Upload complete");
                    }

                    public void progress(File path, int percentComplete) {
                        if (first) {
                            config.getLogger().debug("[  0%%] Beginning upload...");
                        }
                        first = false;
                        config.getLogger().debug("[%3d%%] Uploading %s...", percentComplete, path);
                    }

                    public void error(String message) {}
                })
                .installStatusCallback(new StatusCallback() {
                    boolean first = true;

                    public void success() {
                        config.getLogger().debug("[100%%] Install complete");
                    }

                    public void progress(String status, int percentComplete) {
                        if (first) {
                            config.getLogger().debug("[  0%%] Beginning installation...");
                        }
                        first = false;
                        config.getLogger().debug("[%3d%%] %s", percentComplete, status);
                    }

                    public void error(String message) {}
                });

        return new AppLauncherProcess(config.getLogger(), launcher, launchParameters);
    }

    @Override
    protected void doBuild(File outFile, List<String> ccArgs,
            List<File> objectFiles, List<String> libArgs)
            throws IOException {

        
        
        
        if (!config.getFrameworks().contains("UIKit")) {
            libArgs.add("-framework");
            libArgs.add("UIKit");
        }

        String minVersion = getMinimumOSVersion();

        int majorVersionNumber = -1;
        try {
            majorVersionNumber = Integer.parseInt(minVersion.substring(0, minVersion.indexOf('.')));
        } catch (NumberFormatException e) {
            throw new CompilerException("Failed to get major version number from "
                    + "MinimumOSVersion string '" + minVersion + "'");
        }
        if (isDeviceArch(arch)) {
            ccArgs.add("-miphoneos-version-min=" + minVersion);
            if (config.isDebug()) {
                ccArgs.add("-Wl,-no_pie");
            }
        } else {
            ccArgs.add("-mios-simulator-version-min=" + minVersion);
            if (config.getArch() == Arch.x86 || config.isDebug()) {
                ccArgs.add("-Wl,-no_pie");
            }
        }
        if (majorVersionNumber >= 7) {
            
            
            
            
            
            ccArgs.add("-stdlib=libstdc++");
        }
        ccArgs.add("-isysroot");
        ccArgs.add(sdk.getRoot().getAbsolutePath());
        
        
        libArgs.add("-Xlinker");
        libArgs.add("-rpath");
        libArgs.add("-Xlinker");
        libArgs.add("@executable_path/Frameworks");
        libArgs.add("-Xlinker");
        libArgs.add("-rpath");
        libArgs.add("-Xlinker");
        libArgs.add("@loader_path/Frameworks");
        
        super.doBuild(outFile, ccArgs, objectFiles, libArgs);
    }

    protected void prepareInstall(File installDir) throws IOException {
        createInfoPList(installDir);
        generateDsym(installDir, getExecutable(), false);

        if (isDeviceArch(arch)) {
            
            
            if (!config.isDebug()) {
                strip(installDir, getExecutable());
            }
            copyResourcesPList(installDir);
            if (config.isIosSkipSigning()) {
                config.getLogger().warn("Skipping code signing. The resulting app will "
                        + "be unsigned and will not run on unjailbroken devices");
                ldid(entitlementsPList, installDir);
            } else {
                
                copyProvisioningProfile(provisioningProfile, installDir);
                boolean getTaskAllow = provisioningProfile.getType() == Type.Development;
                signFrameworks(installDir, getTaskAllow);
                codesign(signIdentity, getOrCreateEntitlementsPList(getTaskAllow), installDir);
                
                
                
                
                new Executor(config.getLogger(), "ln")
                        .args("-f", "-s", "_CodeSignature/CodeResources", new File(installDir, "CodeResources"))
                        .exec();
            }
        }
    }

    private void copyProvisioningProfile(ProvisioningProfile profile, File destDir) throws IOException {
        config.getLogger().debug("Copying %s provisioning profile: %s (%s)",
                profile.getType(),
                profile.getName(),
                profile.getEntitlements().objectForKey("application-identifier"));
        FileUtils.copyFile(profile.getFile(), new File(destDir, "embedded.mobileprovision"));
    }

    protected void prepareLaunch(File appDir) throws IOException {
        super.doInstall(appDir, getExecutable());
        createInfoPList(appDir);
        generateDsym(appDir, getExecutable(), true);

        if (isDeviceArch(arch)) {
            copyResourcesPList(appDir);
            if (config.isIosSkipSigning()) {
                config.getLogger().warn("Skiping code signing. The resulting app will "
                        + "be unsigned and will not run on unjailbroken devices");
                ldid(getOrCreateEntitlementsPList(true), appDir);
            } else {
                copyProvisioningProfile(provisioningProfile, appDir);
                signFrameworks(appDir, true);
                
                codesign(signIdentity, getOrCreateEntitlementsPList(true), appDir);
            }
        }
    }

    private void signFrameworks(File appDir, boolean getTaskAllow) throws IOException {
        
        File frameworksDir = new File(appDir, "Frameworks");
        if (frameworksDir.exists() && frameworksDir.isDirectory()) {
            
            for (File swiftLib : frameworksDir.listFiles()) {
                if (swiftLib.getName().endsWith(".dylib")) {
                    codesign(signIdentity, getOrCreateEntitlementsPList(getTaskAllow), swiftLib);
                }
            }

            
            for (File framework : frameworksDir.listFiles()) {
                if (framework.isDirectory() && framework.getName().endsWith(".framework")) {
                    codesign(signIdentity, getOrCreateEntitlementsPList(getTaskAllow), framework);
                }
            }
        }
    }

    private void codesign(SigningIdentity identity, File entitlementsPList, File appDir) throws IOException {
        config.getLogger().debug("Code signing using identity '%s' with fingerprint %s", identity.getName(),
                identity.getFingerprint());
        List<Object> args = new ArrayList<Object>();
        args.add("-f");
        args.add("-s");
        args.add(identity.getFingerprint());
        if (entitlementsPList != null) {
            args.add("--entitlements");
            args.add(entitlementsPList);
        }
        args.add(appDir);
        new Executor(config.getLogger(), "codesign")
                .addEnv("CODESIGN_ALLOCATE", ToolchainUtil.findXcodeCommand("codesign_allocate", "iphoneos"))
                .args(args)
                .exec();
    }

    private void ldid(File entitlementsPList, File appDir) throws IOException {
        File executableFile = new File(appDir, getExecutable());
        config.getLogger().debug("Pseudo-signing %s", executableFile.getAbsolutePath());
        List<Object> args = new ArrayList<Object>();
        if (entitlementsPList != null) {
            args.add("-S" + entitlementsPList.getAbsolutePath());
        } else {
            args.add("-S");
        }
        args.add(executableFile);
        new Executor(config.getLogger(), new File(config.getHome().getBinDir(), "ldid"))
                .args(args)
                .exec();
    }

    private void copyResourcesPList(File destDir) throws IOException {
        File destFile = new File(destDir, "ResourceRules.plist");
        if (resourceRulesPList != null) {
            FileUtils.copyFile(resourceRulesPList, destFile);
        } else {
            FileUtils.copyURLToFile(getClass().getResource("/ResourceRules.plist"), destFile);
        }
    }

    private File getOrCreateEntitlementsPList(boolean getTaskAllow) throws IOException {
        try {
            File destFile = new File(config.getTmpDir(), "Entitlements.plist");
            NSDictionary dict = null;
            if (entitlementsPList != null) {
                dict = (NSDictionary) PropertyListParser.parse(entitlementsPList);
            } else {
                dict = (NSDictionary) PropertyListParser.parse(IOUtils.toByteArray(getClass().getResourceAsStream(
                        "/Entitlements.plist")));
            }
            if (provisioningProfile != null) {
                NSDictionary profileEntitlements = provisioningProfile.getEntitlements();
                for (String key : profileEntitlements.allKeys()) {
                    if (dict.objectForKey(key) == null) {
                        dict.put(key, profileEntitlements.objectForKey(key));
                    }
                }
                dict.put("application-identifier", provisioningProfile.getAppIdPrefix() + "." + getBundleId());
            }
            dict.put("get-task-allow", getTaskAllow);
            PropertyListParser.saveAsXML(dict, destFile);
            return destFile;
        } catch (IOException e) {
            throw e;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private void generateDsym(final File dir, final String executable, boolean copyToIndexedDir) throws IOException {
        final File dsymDir = new File(dir.getParentFile(), dir.getName() + ".dSYM");
        final File exePath = new File(dir, executable);
        FileUtils.deleteDirectory(dsymDir);
        final Process process = new Executor(config.getLogger(), "xcrun")
                .args("dsymutil", "-o", dsymDir, exePath)
                .execAsync();
        if (copyToIndexedDir) {
            new Thread() {
                public void run() {
                    try {
                        process.waitFor();
                    } catch (InterruptedException e) {
                        return;
                    }
                    copyToIndexedDir(dir, executable, dsymDir, exePath);
                }
            }.start();
        }
    }

    private void strip(File dir, String executable) throws IOException {
        new Executor(config.getLogger(), "xcrun")
                .args("strip", "-x", new File(dir, executable))
                .exec();
    }

    @Override
    protected void doInstall(File installDir, String executable) throws IOException {
        super.doInstall(installDir, getExecutable());
        prepareInstall(installDir);
    }

    @Override
    protected Process doLaunch(LaunchParameters launchParameters) throws IOException {
        prepareLaunch(getAppDir());
        Process process = super.doLaunch(launchParameters);
        if (launchParameters instanceof IOSSimulatorLaunchParameters) {
            File script = File.createTempFile("BISTF", ".scpt");
            FileUtils.copyURLToFile(getClass().getResource("/BringIOSSimulatorToFront.scpt"), script);
            new Executor(config.getHome().isDev() ? config.getLogger() : Logger.NULL_LOGGER, "osascript")
                    .args(script)
                    .execAsync();
        }
        return process;
    }

    public void createIpa(List<File> slices) throws IOException {
        config.getLogger().debug("Creating IPA in %s", config.getInstallDir());
        config.getInstallDir().mkdirs();
        if (slices.size() > 1) {
            ToolchainUtil.lipo(config, new File(config.getTmpDir(), getExecutable()), slices);
        } else {
            File destFile = new File(config.getTmpDir(), getExecutable());
            FileUtils.copyFile(slices.get(0), destFile);
            destFile.setExecutable(true, false);
        }
        
        File exportedSymbolsFile = new File(slices.get(0).getParentFile(), "exported_symbols");
        FileUtils.copyFile(exportedSymbolsFile, new File(config.getTmpDir(), "exported_symbols"));

        File tmpDir = new File(config.getInstallDir(), getExecutable() + ".app");
        FileUtils.deleteDirectory(tmpDir);
        tmpDir.mkdirs();
        super.doInstall(tmpDir, getExecutable());
        prepareInstall(tmpDir);
        ToolchainUtil.packageApplication(config, tmpDir, new File(config.getInstallDir(), getExecutable() + ".ipa"));
    }

    @Override
    protected boolean processDir(Resource resource, File dir, File destDir) throws IOException {
        if (dir.getName().endsWith(".atlas")) {
            destDir.mkdirs();

            ToolchainUtil.textureatlas(config, dir, destDir);
            return false;
        } else if (dir.getName().endsWith(".xcassets")) {
            ToolchainUtil.actool(config, createPartialInfoPlistFile(dir), dir, getAppDir());
            return false;
        }
        return super.processDir(resource, dir, destDir);
    }

    @Override
    protected void copyFile(Resource resource, File file, File destDir)
            throws IOException {

        if (isDeviceArch(arch) && !resource.isSkipPngCrush()
                && file.getName().toLowerCase().endsWith(".png")) {
            destDir.mkdirs();
            File outFile = new File(destDir, file.getName());
            ToolchainUtil.pngcrush(config, file, outFile);
        } else if (file.getName().toLowerCase().endsWith(".strings")) {
            destDir.mkdirs();
            File outFile = new File(destDir, file.getName());
            ToolchainUtil.compileStrings(config, file, outFile);
        } else if (file.getName().toLowerCase().endsWith(".storyboard")) {
            destDir.mkdirs();
            ToolchainUtil.ibtool(config, createPartialInfoPlistFile(file), file, destDir);
        } else if (file.getName().toLowerCase().endsWith(".xib")) {
            destDir.mkdirs();
            String fileName = file.getName();
            fileName = fileName.substring(0, fileName.lastIndexOf('.')) + ".nib";
            File outFile = new File(destDir, fileName);
            ToolchainUtil.ibtool(config, createPartialInfoPlistFile(file), file, outFile);
        } else {
            super.copyFile(resource, file, destDir);
        }
    }

    private File createPartialInfoPlistFile(File f) throws IOException {
        File tmpFile = File.createTempFile(f.getName() + "_", ".plist", partialPListDir);
        tmpFile.delete();
        return tmpFile;
    }

    protected File getAppDir() {
        File dir = null;
        if (!config.isSkipInstall()) {
            dir = new File(config.getInstallDir(), getExecutable() + ".app");
            if (!dir.exists()) {
                dir = config.getInstallDir();
            }
        } else {
            dir = new File(config.getTmpDir(), getExecutable() + ".app");
            dir.mkdirs();
        }
        return dir;
    }

    protected String getExecutable() {
        if (config.getIosInfoPList() != null) {
            String bundleExecutable = config.getIosInfoPList().getBundleExecutable();
            if (bundleExecutable != null) {
                return bundleExecutable;
            }
        }
        return config.getExecutableName();
    }

    protected String getBundleId() {
        if (config.getIosInfoPList() != null) {
            String bundleIdentifier = config.getIosInfoPList().getBundleIdentifier();
            if (bundleIdentifier != null) {
                return bundleIdentifier;
            }
        }
        return config.getMainClass() != null ? config.getMainClass() : config.getExecutableName();
    }

    protected String getMinimumOSVersion() {
        if (config.getIosInfoPList() != null) {
            String minVersion = config.getIosInfoPList().getMinimumOSVersion();
            if (minVersion != null) {
                return minVersion;
            }
        }
        return config.getOs().getMinVersion();
    }

    private void putIfAbsent(NSDictionary dict, String key, String value) {
        if (dict.objectForKey(key) == null) {
            dict.put(key, value);
        }
    }
    
    protected void customizeInfoPList(NSDictionary dict) {
        if (isSimulatorArch(arch)) {
            dict.put("CFBundleSupportedPlatforms", new NSArray(new NSString("iPhoneSimulator")));
        } else {
            dict.put("CFBundleResourceSpecification", "ResourceRules.plist");
            dict.put("CFBundleSupportedPlatforms", new NSArray(new NSString("iPhoneOS")));
            dict.put("DTPlatformVersion", sdk.getPlatformVersion());
            dict.put("DTPlatformBuild", sdk.getPlatformBuild());
            dict.put("DTSDKBuild", sdk.getBuild());

            
            
            try {
                File versionPListFile = new File(new File(ToolchainUtil.findXcodePath()).getParentFile(),
                        "version.plist");
                NSDictionary versionPList = (NSDictionary) PropertyListParser.parse(versionPListFile);
                File xcodeInfoPListFile = new File(new File(ToolchainUtil.findXcodePath()).getParentFile(),
                        "Info.plist");
                NSDictionary xcodeInfoPList = (NSDictionary) PropertyListParser.parse(xcodeInfoPListFile);
                NSString dtXcodeBuild = (NSString) versionPList.objectForKey("ProductBuildVersion");
                if (dtXcodeBuild == null) {
                    throw new NoSuchElementException("No ProductBuildVersion in " + versionPListFile.getAbsolutePath());
                }
                NSString dtXcode = (NSString) xcodeInfoPList.objectForKey("DTXcode");
                if (dtXcode == null) {
                    throw new NoSuchElementException("No DTXcode in " + xcodeInfoPListFile.getAbsolutePath());
                }
                putIfAbsent(dict, "DTXcode", dtXcode.toString());
                putIfAbsent(dict, "DTXcodeBuild", dtXcodeBuild.toString());
            } catch (Exception e) {
                config.getLogger()
                        .warn("Failed to read DTXcodeBuild/DTXcode from current Xcode install. Will use fake values. (%s: %s)",
                                e.getClass().getName(), e.getMessage());
            }
            
            putIfAbsent(dict, "DTXcode", "0611");
            putIfAbsent(dict, "DTXcodeBuild", "6A2008a");
        }
    }

    protected void createInfoPList(File dir) throws IOException {
        NSDictionary dict = new NSDictionary();
        if (config.getIosInfoPList() != null && config.getIosInfoPList().getDictionary() != null) {
            NSDictionary infoPListDict = config.getIosInfoPList().getDictionary();
            for (String key : infoPListDict.allKeys()) {
                dict.put(key, infoPListDict.objectForKey(key));
            }
        } else {
            dict.put("CFBundleVersion", "1.0");
            dict.put("CFBundleExecutable", config.getExecutableName());
            dict.put("CFBundleName", config.getExecutableName());
            dict.put("CFBundleIdentifier", getBundleId());
            dict.put("CFBundlePackageType", "APPL");
            dict.put("LSRequiresIPhoneOS", true);
            NSObject supportedDeviceFamilies = sdk.getDefaultProperty("SUPPORTED_DEVICE_FAMILIES");
            if (supportedDeviceFamilies != null) {
                
                
                
                
                NSArray families = null;
                if (supportedDeviceFamilies instanceof NSString) {
                    NSString defFamilies = (NSString) supportedDeviceFamilies;
                    String[] parts = defFamilies.toString().split(",");
                    families = new NSArray(parts.length);
                    for (int i = 0; i < families.count(); i++) {
                        families.setValue(i, new NSNumber(parts[i].trim()));
                    }
                } else {
                    NSArray defFamilies = (NSArray) supportedDeviceFamilies;
                    families = new NSArray(defFamilies.count());
                    for (int i = 0; i < families.count(); i++) {
                        families.setValue(i, new NSNumber(defFamilies.objectAtIndex(i).toString()));
                    }
                }
                dict.put("UIDeviceFamily", families);
            }
            dict.put("UISupportedInterfaceOrientations", new NSArray(
                    new NSString("UIInterfaceOrientationPortrait"),
                    new NSString("UIInterfaceOrientationLandscapeLeft"),
                    new NSString("UIInterfaceOrientationLandscapeRight"),
                    new NSString("UIInterfaceOrientationPortraitUpsideDown")
                    ));
            dict.put("UISupportedInterfaceOrientations~ipad", new NSArray(
                    new NSString("UIInterfaceOrientationPortrait"),
                    new NSString("UIInterfaceOrientationLandscapeLeft"),
                    new NSString("UIInterfaceOrientationLandscapeRight"),
                    new NSString("UIInterfaceOrientationPortraitUpsideDown")
                    ));
            dict.put("UIRequiredDeviceCapabilities", new NSArray(new NSString("armv7")));
        }

        dict.put("DTPlatformName", sdk.getPlatformName());
        dict.put("DTSDKName", sdk.getCanonicalName());

        for (File f : FileUtils.listFiles(partialPListDir, new String[] {"plist"}, false)) {
            try {
                NSDictionary d = (NSDictionary) PropertyListParser.parse(f);
                dict.putAll(d);
            } catch (Exception e) {
                throw new CompilerException(e);
            }
        }

        if (dict.objectForKey("MinimumOSVersion") == null) {
            
            dict.put("MinimumOSVersion", "6.0");
        }

        customizeInfoPList(dict);

        
        NSDictionary newDict = new NSDictionary();
        if (dict.objectForKey("CFBundleShortVersionString") != null) {
            newDict.put("CFBundleShortVersionString", dict.objectForKey("CFBundleShortVersionString"));
            dict.remove("CFBundleShortVersionString");
        }
        if (dict.objectForKey("CFBundleVersion") != null) {
            newDict.put("CFBundleVersion", dict.objectForKey("CFBundleVersion"));
            dict.remove("CFBundleVersion");
        }
        for (String key : dict.allKeys()) {
            newDict.put(key, dict.objectForKey(key));
        }

        File tmpInfoPlist = new File(config.getTmpDir(), "Info.plist");
        PropertyListParser.saveAsBinary(newDict, tmpInfoPlist);

        config.getLogger().debug("Installing Info.plist to %s", dir);
        FileUtils.copyFile(tmpInfoPlist, new File(dir, tmpInfoPlist.getName()));
    }

    public void init(Config config) {
        super.init(config);

        if (config.getArch() == null) {
            arch = Arch.thumbv7;
        } else {
            if (!isSimulatorArch(config.getArch()) && !isDeviceArch(config.getArch())) {
                throw new IllegalArgumentException("Arch '" + config.getArch()
                        + "' is unsupported for iOS target");
            }
            arch = config.getArch();
        }

        if (isDeviceArch(arch)) {
            if (!config.isSkipLinking() && !config.isIosSkipSigning()) {
                signIdentity = config.getIosSignIdentity();
                if (signIdentity == null) {
                    signIdentity = SigningIdentity.find(SigningIdentity.list(),
                            "/(?i)iPhone Developer|iOS Development/");
                }
            }
        }

        if (config.getIosInfoPList() != null) {
            config.getIosInfoPList().parse(config.getProperties());
        }

        if (isDeviceArch(arch)) {
            if (!config.isSkipLinking() &&!config.isIosSkipSigning()) {
                provisioningProfile = config.getIosProvisioningProfile();
                if (provisioningProfile == null) {
                    String bundleId = "*";
                    if (config.getIosInfoPList() != null && config.getIosInfoPList().getBundleIdentifier() != null) {
                        bundleId = config.getIosInfoPList().getBundleIdentifier();
                    }
                    provisioningProfile = ProvisioningProfile.find(ProvisioningProfile.list(), signIdentity, bundleId);
                }
            }
        }

        String sdkVersion = config.getIosSdkVersion();
        List<SDK> sdks = getSDKs();
        if (sdkVersion == null) {
            if (sdks.isEmpty()) {
                throw new IllegalArgumentException("No " + (isDeviceArch(arch) ? "device" : "simulator")
                        + " SDKs installed");
            }
            Collections.sort(sdks);
            this.sdk = sdks.get(sdks.size() - 1);
        } else {
            for (SDK sdk : sdks) {
                if (sdk.getVersion().equals(sdkVersion)) {
                    this.sdk = sdk;
                    break;
                }
            }
            if (sdk == null) {
                throw new IllegalArgumentException("No SDK found matching version string " + sdkVersion);
            }
        }

        entitlementsPList = config.getIosEntitlementsPList();

        partialPListDir = new File(config.getTmpDir(), "partial-plists");
        partialPListDir.mkdirs();
        try {
            FileUtils.cleanDirectory(partialPListDir);
        } catch (IOException e) {
            throw new CompilerException(e);
        }
    }

    @Override
    public OS getOs() {
        return OS.ios;
    }

    @Override
    public boolean canLaunchInPlace() {
        return false;
    }

    
    private void copyToIndexedDir(File dir, String executable, File dsymDir, File exePath) {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMddHHmmss");
        final File indexedDir = new File(System.getProperty("user.home"),
                "Library/Developer/Xcode/DerivedData/RoboVM/Build/Products/"
                        + FilenameUtils.removeExtension(dir.getName()) + "_"
                        + sdf.format(new Date()));
        indexedDir.mkdirs();
        File indexedDSymDir = new File(indexedDir, dsymDir.getName());
        File indexedAppDir = new File(indexedDir, dir.getName());
        indexedAppDir.mkdirs();

        try {
            
            
            FileUtils.copyFile(exePath, new File(indexedAppDir, executable));
        } catch (IOException e) {
            config.getLogger().error("Failed to copy %s to indexed dir %s: %s",
                    exePath.getAbsolutePath(),
                    indexedAppDir.getAbsolutePath(), e.getMessage());
        }

        try {
            FileUtils.copyDirectory(dsymDir, indexedDSymDir);
        } catch (IOException e) {
            config.getLogger().error("Failed to copy %s to indexed dir %s: %s",
                    dsymDir.getAbsolutePath(),
                    indexedDir.getAbsolutePath(), e.getMessage());
        }

        
        List<File> dirs = new ArrayList<>(Arrays.asList(indexedDir.getParentFile().listFiles((FileFilter)
                new AndFileFilter(
                        new PrefixFileFilter(FilenameUtils.removeExtension(dir.getName())),
                        new RegexFileFilter(".*_\\d{14}")))));
        Collections.sort(dirs, new Comparator<File>() {
            public int compare(File o1, File o2) {
                return Long.compare(o1.lastModified(), o2.lastModified());
            }
        });
        if (dirs.size() > 3) {
            for (File f : dirs.subList(0, dirs.size() - 3)) {
                try {
                    FileUtils.deleteDirectory(f);
                } catch (IOException e) {
                    config.getLogger().error("Failed to delete diretcory %s",
                            f.getAbsolutePath(), e.getMessage());
                }
            }
        }
    }

    private final static Pattern VARIABLE_PATTERN = Pattern.compile("\\$\\{([^}]+)\\}");

    static void replacePropertyRefs(Node node, Properties props) {
        if (node instanceof Text) {
            Text el = (Text) node;
            String value = el.getNodeValue();
            if (value != null && value.trim().length() > 0) {
                Matcher matcher = VARIABLE_PATTERN.matcher(value);
                StringBuilder sb = new StringBuilder();
                int pos = 0;
                while (matcher.find()) {
                    if (pos < matcher.start()) {
                        sb.append(value.substring(pos, matcher.start()));
                    }
                    String key = matcher.group(1);
                    sb.append(props.getProperty(key, matcher.group()));
                    pos = matcher.end();
                }
                if (pos < value.length()) {
                    sb.append(value.substring(pos));
                }
                el.setNodeValue(sb.toString());
            }
        }
        NodeList children = node.getChildNodes();
        for (int i = 0; i < children.getLength(); i++) {
            replacePropertyRefs(children.item(i), props);
        }
    }

    static NSObject parsePropertyList(File file, Properties props) throws Exception {
        Properties allProps = new Properties(System.getProperties());
        allProps.putAll(props);

        Method getDocBuilder = XMLPropertyListParser.class.getDeclaredMethod("getDocBuilder");
        getDocBuilder.setAccessible(true);
        Method parseDocument = XMLPropertyListParser.class.getDeclaredMethod("parseDocument", Document.class);
        parseDocument.setAccessible(true);
        DocumentBuilder docBuilder = (DocumentBuilder) getDocBuilder.invoke(null);
        Document doc = docBuilder.parse(file);
        replacePropertyRefs(doc, allProps);
        return (NSObject) parseDocument.invoke(null, doc);
    }
}

<code block>

package org.robovm.compiler.target.ios;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.io.OutputStream;
import java.lang.reflect.Method;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.NoSuchElementException;
import java.util.Properties;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.xml.parsers.DocumentBuilder;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.io.filefilter.AndFileFilter;
import org.apache.commons.io.filefilter.PrefixFileFilter;
import org.apache.commons.io.filefilter.RegexFileFilter;
import org.robovm.compiler.CompilerException;
import org.robovm.compiler.config.Arch;
import org.robovm.compiler.config.Config;
import org.robovm.compiler.config.OS;
import org.robovm.compiler.config.Resource;
import org.robovm.compiler.log.Logger;
import org.robovm.compiler.target.AbstractTarget;
import org.robovm.compiler.target.LaunchParameters;
import org.robovm.compiler.target.Launcher;
import org.robovm.compiler.target.ios.ProvisioningProfile.Type;
import org.robovm.compiler.util.Executor;
import org.robovm.compiler.util.ToolchainUtil;
import org.robovm.compiler.util.io.OpenOnWriteFileOutputStream;
import org.robovm.libimobiledevice.AfcClient.UploadProgressCallback;
import org.robovm.libimobiledevice.IDevice;
import org.robovm.libimobiledevice.InstallationProxyClient.StatusCallback;
import org.robovm.libimobiledevice.util.AppLauncher;
import org.robovm.libimobiledevice.util.AppLauncherCallback;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.Text;

import com.dd.plist.NSArray;
import com.dd.plist.NSDictionary;
import com.dd.plist.NSNumber;
import com.dd.plist.NSObject;
import com.dd.plist.NSString;
import com.dd.plist.PropertyListParser;
import com.dd.plist.XMLPropertyListParser;


public class IOSTarget extends AbstractTarget {
    private static File iosSimPath;

    private Arch arch;
    private SDK sdk;
    private File resourceRulesPList;
    private File entitlementsPList;
    private SigningIdentity signIdentity;
    private ProvisioningProfile provisioningProfile;
    private IDevice device;
    private File partialPListDir;

    public IOSTarget() {}

    @Override
    public Arch getArch() {
        return arch;
    }

    @Override
    public LaunchParameters createLaunchParameters() {
        if (isSimulatorArch(arch)) {
            return new IOSSimulatorLaunchParameters();
        }
        return new IOSDeviceLaunchParameters();
    }

    public static boolean isSimulatorArch(Arch arch) {
        return arch == Arch.x86 || arch == Arch.x86_64;
    }

    public static boolean isDeviceArch(Arch arch) {
        return arch == Arch.thumbv7 || arch == Arch.arm64;
    }

    public static synchronized File getIosSimPath() {
        if (iosSimPath == null) {
            try {
                File path = File.createTempFile("ios-sim", "");
                FileUtils.copyURLToFile(IOSTarget.class.getResource("/ios-sim"), path);
                path.setExecutable(true);
                path.deleteOnExit();
                iosSimPath = path;
            } catch (IOException e) {
                throw new Error(e);
            }
        }
        return iosSimPath;
    }

    public List<SDK> getSDKs() {
        if (isSimulatorArch(arch)) {
            return SDK.listSimulatorSDKs();
        } else {
            return SDK.listDeviceSDKs();
        }
    }

    
    public IDevice getDevice() {
        return device;
    }

    @Override
    protected Launcher createLauncher(LaunchParameters launchParameters) throws IOException {
        if (isSimulatorArch(arch)) {
            return createIOSSimLauncher(launchParameters);
        } else {
            return createIOSDevLauncher(launchParameters);
        }
    }

    private Launcher createIOSSimLauncher(LaunchParameters launchParameters)
            throws IOException {

        File dir = getAppDir();

        String iosSimPath = new File(config.getHome().getBinDir(), "ios-sim").getAbsolutePath();

        List<Object> args = new ArrayList<Object>();
        args.add("launch");
        args.add(dir);
        args.add("--timeout");
        args.add("90");
        args.add("--unbuffered");
        if (((IOSSimulatorLaunchParameters) launchParameters).getDeviceType() != null) {
            DeviceType deviceType = ((IOSSimulatorLaunchParameters) launchParameters).getDeviceType();
            args.add("--devicetypeid");
            args.add(deviceType.getDeviceTypeId());
        }
        if (launchParameters.getStdoutFifo() != null) {
            args.add("--stdout");
            args.add(launchParameters.getStdoutFifo());
        }
        if (launchParameters.getStderrFifo() != null) {
            args.add("--stderr");
            args.add(launchParameters.getStderrFifo());
        }
        if (launchParameters.getEnvironment() != null) {
            for (Entry<String, String> entry : launchParameters.getEnvironment().entrySet()) {
                args.add("--setenv");
                args.add(entry.getKey() + "=" + entry.getValue());
            }
        }

        if (!launchParameters.getArguments().isEmpty()) {
            args.add("--args");
            args.addAll(launchParameters.getArguments());
        }

        File xcodePath = new File(ToolchainUtil.findXcodePath());
        Map<String, String> env = Collections.singletonMap("DEVELOPER_DIR", xcodePath.getAbsolutePath());
        return new Executor(config.getLogger(), iosSimPath)
                .args(args)
                .wd(launchParameters.getWorkingDirectory())
                .inheritEnv(false)
                .env(env);
    }

    private Launcher createIOSDevLauncher(LaunchParameters launchParameters)
            throws IOException {

        IOSDeviceLaunchParameters deviceLaunchParameters = (IOSDeviceLaunchParameters) launchParameters;
        String deviceId = deviceLaunchParameters.getDeviceId();
        int forwardPort = deviceLaunchParameters.getForwardPort();
        AppLauncherCallback callback = deviceLaunchParameters.getAppPathCallback();
        if (deviceId == null) {
            String[] udids = IDevice.listUdids();
            if (udids.length == 0) {
                throw new RuntimeException("No devices connected");
            }
            if (udids.length > 1) {
                config.getLogger().warn("More than 1 device connected (%s). "
                        + "Using %s.", Arrays.asList(udids), udids[0]);
            }
            deviceId = udids[0];
        }
        device = new IDevice(deviceId);

        OutputStream out = null;
        if (launchParameters.getStdoutFifo() != null) {
            out = new OpenOnWriteFileOutputStream(launchParameters.getStdoutFifo());
        } else {
            out = System.out;
        }

        Map<String, String> env = launchParameters.getEnvironment();
        if (env == null) {
            env = new HashMap<>();
        }

        AppLauncher launcher = new AppLauncher(device, getAppDir()) {
            protected void log(String s, Object... args) {
                config.getLogger().debug(s, args);
            }
        }
                .stdout(out)
                .closeOutOnExit(true)
                .args(launchParameters.getArguments().toArray(new String[0]))
                .env(env)
                .forward(forwardPort)
                .appLauncherCallback(callback)
                .xcodePath(ToolchainUtil.findXcodePath())
                .uploadProgressCallback(new UploadProgressCallback() {
                    boolean first = true;

                    public void success() {
                        config.getLogger().debug("[100%%] Upload complete");
                    }

                    public void progress(File path, int percentComplete) {
                        if (first) {
                            config.getLogger().debug("[  0%%] Beginning upload...");
                        }
                        first = false;
                        config.getLogger().debug("[%3d%%] Uploading %s...", percentComplete, path);
                    }

                    public void error(String message) {}
                })
                .installStatusCallback(new StatusCallback() {
                    boolean first = true;

                    public void success() {
                        config.getLogger().debug("[100%%] Install complete");
                    }

                    public void progress(String status, int percentComplete) {
                        if (first) {
                            config.getLogger().debug("[  0%%] Beginning installation...");
                        }
                        first = false;
                        config.getLogger().debug("[%3d%%] %s", percentComplete, status);
                    }

                    public void error(String message) {}
                });

        return new AppLauncherProcess(config.getLogger(), launcher, launchParameters);
    }

    @Override
    protected void doBuild(File outFile, List<String> ccArgs,
            List<File> objectFiles, List<String> libArgs)
            throws IOException {

        
        
        
        if (!config.getFrameworks().contains("UIKit")) {
            libArgs.add("-framework");
            libArgs.add("UIKit");
        }

        String minVersion = getMinimumOSVersion();

        int majorVersionNumber = -1;
        try {
            majorVersionNumber = Integer.parseInt(minVersion.substring(0, minVersion.indexOf('.')));
        } catch (NumberFormatException e) {
            throw new CompilerException("Failed to get major version number from "
                    + "MinimumOSVersion string '" + minVersion + "'");
        }
        if (isDeviceArch(arch)) {
            ccArgs.add("-miphoneos-version-min=" + minVersion);
            if (config.isDebug()) {
                ccArgs.add("-Wl,-no_pie");
            }
        } else {
            ccArgs.add("-mios-simulator-version-min=" + minVersion);
            if (config.getArch() == Arch.x86 || config.isDebug()) {
                ccArgs.add("-Wl,-no_pie");
            }
        }
        if (majorVersionNumber >= 7) {
            
            
            
            
            
            ccArgs.add("-stdlib=libstdc++");
        }
        ccArgs.add("-isysroot");
        ccArgs.add(sdk.getRoot().getAbsolutePath());
        
        
        libArgs.add("-Xlinker");
        libArgs.add("-rpath");
        libArgs.add("-Xlinker");
        libArgs.add("@executable_path/Frameworks");
        libArgs.add("-Xlinker");
        libArgs.add("-rpath");
        libArgs.add("-Xlinker");
        libArgs.add("@loader_path/Frameworks");
        
        super.doBuild(outFile, ccArgs, objectFiles, libArgs);
    }

    protected void prepareInstall(File installDir) throws IOException {
        createInfoPList(installDir);
        generateDsym(installDir, getExecutable(), false);

        if (isDeviceArch(arch)) {
            
            
            if (!config.isDebug()) {
                strip(installDir, getExecutable());
            }
            copyResourcesPList(installDir);
            if (config.isIosSkipSigning()) {
                config.getLogger().warn("Skipping code signing. The resulting app will "
                        + "be unsigned and will not run on unjailbroken devices");
                ldid(entitlementsPList, installDir);
            } else {
                
                copyProvisioningProfile(provisioningProfile, installDir);
                boolean getTaskAllow = provisioningProfile.getType() == Type.Development;
                codesign(signIdentity, getOrCreateEntitlementsPList(getTaskAllow), installDir);
                
                
                
                
                new Executor(config.getLogger(), "ln")
                        .args("-f", "-s", "_CodeSignature/CodeResources", new File(installDir, "CodeResources"))
                        .exec();
            }
        }
    }

    private void copyProvisioningProfile(ProvisioningProfile profile, File destDir) throws IOException {
        config.getLogger().debug("Copying %s provisioning profile: %s (%s)",
                profile.getType(),
                profile.getName(),
                profile.getEntitlements().objectForKey("application-identifier"));
        FileUtils.copyFile(profile.getFile(), new File(destDir, "embedded.mobileprovision"));
    }

    protected void prepareLaunch(File appDir) throws IOException {
        super.doInstall(appDir, getExecutable());
        createInfoPList(appDir);
        generateDsym(appDir, getExecutable(), true);

        if (isDeviceArch(arch)) {
            copyResourcesPList(appDir);
            if (config.isIosSkipSigning()) {
                config.getLogger().warn("Skiping code signing. The resulting app will "
                        + "be unsigned and will not run on unjailbroken devices");
                ldid(getOrCreateEntitlementsPList(true), appDir);
            } else {
                copyProvisioningProfile(provisioningProfile, appDir);
                
                File frameworksDir = new File(appDir, "Frameworks");
                if (frameworksDir.exists() && frameworksDir.isDirectory()) {
                    
                    for (File swiftLib : frameworksDir.listFiles()) {
                        if (swiftLib.getName().endsWith(".dylib")) {
                            codesign(signIdentity, getOrCreateEntitlementsPList(true), swiftLib);
                        }
                    }

                    
                    for (File framework : frameworksDir.listFiles()) {
                        if (framework.isDirectory() && framework.getName().endsWith(".framework")) {
                            codesign(signIdentity, getOrCreateEntitlementsPList(true), framework);
                        }
                    }
                }
                
                codesign(signIdentity, getOrCreateEntitlementsPList(true), appDir);
            }
        }
    }

    private void codesign(SigningIdentity identity, File entitlementsPList, File appDir) throws IOException {
        config.getLogger().debug("Code signing using identity '%s' with fingerprint %s", identity.getName(),
                identity.getFingerprint());
        List<Object> args = new ArrayList<Object>();
        args.add("-f");
        args.add("-s");
        args.add(identity.getFingerprint());
        if (entitlementsPList != null) {
            args.add("--entitlements");
            args.add(entitlementsPList);
        }
        args.add(appDir);
        new Executor(config.getLogger(), "codesign")
                .addEnv("CODESIGN_ALLOCATE", ToolchainUtil.findXcodeCommand("codesign_allocate", "iphoneos"))
                .args(args)
                .exec();
    }

    private void ldid(File entitlementsPList, File appDir) throws IOException {
        File executableFile = new File(appDir, getExecutable());
        config.getLogger().debug("Pseudo-signing %s", executableFile.getAbsolutePath());
        List<Object> args = new ArrayList<Object>();
        if (entitlementsPList != null) {
            args.add("-S" + entitlementsPList.getAbsolutePath());
        } else {
            args.add("-S");
        }
        args.add(executableFile);
        new Executor(config.getLogger(), new File(config.getHome().getBinDir(), "ldid"))
                .args(args)
                .exec();
    }

    private void copyResourcesPList(File destDir) throws IOException {
        File destFile = new File(destDir, "ResourceRules.plist");
        if (resourceRulesPList != null) {
            FileUtils.copyFile(resourceRulesPList, destFile);
        } else {
            FileUtils.copyURLToFile(getClass().getResource("/ResourceRules.plist"), destFile);
        }
    }

    private File getOrCreateEntitlementsPList(boolean getTaskAllow) throws IOException {
        try {
            File destFile = new File(config.getTmpDir(), "Entitlements.plist");
            NSDictionary dict = null;
            if (entitlementsPList != null) {
                dict = (NSDictionary) PropertyListParser.parse(entitlementsPList);
            } else {
                dict = (NSDictionary) PropertyListParser.parse(IOUtils.toByteArray(getClass().getResourceAsStream(
                        "/Entitlements.plist")));
            }
            if (provisioningProfile != null) {
                NSDictionary profileEntitlements = provisioningProfile.getEntitlements();
                for (String key : profileEntitlements.allKeys()) {
                    if (dict.objectForKey(key) == null) {
                        dict.put(key, profileEntitlements.objectForKey(key));
                    }
                }
                dict.put("application-identifier", provisioningProfile.getAppIdPrefix() + "." + getBundleId());
            }
            dict.put("get-task-allow", getTaskAllow);
            PropertyListParser.saveAsXML(dict, destFile);
            return destFile;
        } catch (IOException e) {
            throw e;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private void generateDsym(final File dir, final String executable, boolean copyToIndexedDir) throws IOException {
        final File dsymDir = new File(dir.getParentFile(), dir.getName() + ".dSYM");
        final File exePath = new File(dir, executable);
        FileUtils.deleteDirectory(dsymDir);
        final Process process = new Executor(config.getLogger(), "xcrun")
                .args("dsymutil", "-o", dsymDir, exePath)
                .execAsync();
        if (copyToIndexedDir) {
            new Thread() {
                public void run() {
                    try {
                        process.waitFor();
                    } catch (InterruptedException e) {
                        return;
                    }
                    copyToIndexedDir(dir, executable, dsymDir, exePath);
                }
            }.start();
        }
    }

    private void strip(File dir, String executable) throws IOException {
        new Executor(config.getLogger(), "xcrun")
                .args("strip", "-x", new File(dir, executable))
                .exec();
    }

    @Override
    protected void doInstall(File installDir, String executable) throws IOException {
        super.doInstall(installDir, getExecutable());
        prepareInstall(installDir);
    }

    @Override
    protected Process doLaunch(LaunchParameters launchParameters) throws IOException {
        prepareLaunch(getAppDir());
        Process process = super.doLaunch(launchParameters);
        if (launchParameters instanceof IOSSimulatorLaunchParameters) {
            File script = File.createTempFile("BISTF", ".scpt");
            FileUtils.copyURLToFile(getClass().getResource("/BringIOSSimulatorToFront.scpt"), script);
            new Executor(config.getHome().isDev() ? config.getLogger() : Logger.NULL_LOGGER, "osascript")
                    .args(script)
                    .execAsync();
        }
        return process;
    }

    public void createIpa(List<File> slices) throws IOException {
        config.getLogger().debug("Creating IPA in %s", config.getInstallDir());
        config.getInstallDir().mkdirs();
        if (slices.size() > 1) {
            ToolchainUtil.lipo(config, new File(config.getTmpDir(), getExecutable()), slices);
        } else {
            File destFile = new File(config.getTmpDir(), getExecutable());
            FileUtils.copyFile(slices.get(0), destFile);
            destFile.setExecutable(true, false);
        }
        
        File exportedSymbolsFile = new File(slices.get(0).getParentFile(), "exported_symbols");
        FileUtils.copyFile(exportedSymbolsFile, new File(config.getTmpDir(), "exported_symbols"));

        File tmpDir = new File(config.getInstallDir(), getExecutable() + ".app");
        FileUtils.deleteDirectory(tmpDir);
        tmpDir.mkdirs();
        super.doInstall(tmpDir, getExecutable());
        prepareInstall(tmpDir);
        ToolchainUtil.packageApplication(config, tmpDir, new File(config.getInstallDir(), getExecutable() + ".ipa"));
    }

    @Override
    protected boolean processDir(Resource resource, File dir, File destDir) throws IOException {
        if (dir.getName().endsWith(".atlas")) {
            destDir.mkdirs();

            ToolchainUtil.textureatlas(config, dir, destDir);
            return false;
        } else if (dir.getName().endsWith(".xcassets")) {
            ToolchainUtil.actool(config, createPartialInfoPlistFile(dir), dir, getAppDir());
            return false;
        }
        return super.processDir(resource, dir, destDir);
    }

    @Override
    protected void copyFile(Resource resource, File file, File destDir)
            throws IOException {

        if (isDeviceArch(arch) && !resource.isSkipPngCrush()
                && file.getName().toLowerCase().endsWith(".png")) {
            destDir.mkdirs();
            File outFile = new File(destDir, file.getName());
            ToolchainUtil.pngcrush(config, file, outFile);
        } else if (file.getName().toLowerCase().endsWith(".strings")) {
            destDir.mkdirs();
            File outFile = new File(destDir, file.getName());
            ToolchainUtil.compileStrings(config, file, outFile);
        } else if (file.getName().toLowerCase().endsWith(".storyboard")) {
            destDir.mkdirs();
            ToolchainUtil.ibtool(config, createPartialInfoPlistFile(file), file, destDir);
        } else if (file.getName().toLowerCase().endsWith(".xib")) {
            destDir.mkdirs();
            String fileName = file.getName();
            fileName = fileName.substring(0, fileName.lastIndexOf('.')) + ".nib";
            File outFile = new File(destDir, fileName);
            ToolchainUtil.ibtool(config, createPartialInfoPlistFile(file), file, outFile);
        } else {
            super.copyFile(resource, file, destDir);
        }
    }

    private File createPartialInfoPlistFile(File f) throws IOException {
        File tmpFile = File.createTempFile(f.getName() + "_", ".plist", partialPListDir);
        tmpFile.delete();
        return tmpFile;
    }

    protected File getAppDir() {
        File dir = null;
        if (!config.isSkipInstall()) {
            dir = new File(config.getInstallDir(), getExecutable() + ".app");
            if (!dir.exists()) {
                dir = config.getInstallDir();
            }
        } else {
            dir = new File(config.getTmpDir(), getExecutable() + ".app");
            dir.mkdirs();
        }
        return dir;
    }

    protected String getExecutable() {
        if (config.getIosInfoPList() != null) {
            String bundleExecutable = config.getIosInfoPList().getBundleExecutable();
            if (bundleExecutable != null) {
                return bundleExecutable;
            }
        }
        return config.getExecutableName();
    }

    protected String getBundleId() {
        if (config.getIosInfoPList() != null) {
            String bundleIdentifier = config.getIosInfoPList().getBundleIdentifier();
            if (bundleIdentifier != null) {
                return bundleIdentifier;
            }
        }
        return config.getMainClass() != null ? config.getMainClass() : config.getExecutableName();
    }

    protected String getMinimumOSVersion() {
        if (config.getIosInfoPList() != null) {
            String minVersion = config.getIosInfoPList().getMinimumOSVersion();
            if (minVersion != null) {
                return minVersion;
            }
        }
        return config.getOs().getMinVersion();
    }

    private void putIfAbsent(NSDictionary dict, String key, String value) {
        if (dict.objectForKey(key) == null) {
            dict.put(key, value);
        }
    }
    
    protected void customizeInfoPList(NSDictionary dict) {
        if (isSimulatorArch(arch)) {
            dict.put("CFBundleSupportedPlatforms", new NSArray(new NSString("iPhoneSimulator")));
        } else {
            dict.put("CFBundleResourceSpecification", "ResourceRules.plist");
            dict.put("CFBundleSupportedPlatforms", new NSArray(new NSString("iPhoneOS")));
            dict.put("DTPlatformVersion", sdk.getPlatformVersion());
            dict.put("DTPlatformBuild", sdk.getPlatformBuild());
            dict.put("DTSDKBuild", sdk.getBuild());

            
            
            try {
                File versionPListFile = new File(new File(ToolchainUtil.findXcodePath()).getParentFile(),
                        "version.plist");
                NSDictionary versionPList = (NSDictionary) PropertyListParser.parse(versionPListFile);
                File xcodeInfoPListFile = new File(new File(ToolchainUtil.findXcodePath()).getParentFile(),
                        "Info.plist");
                NSDictionary xcodeInfoPList = (NSDictionary) PropertyListParser.parse(xcodeInfoPListFile);
                NSString dtXcodeBuild = (NSString) versionPList.objectForKey("ProductBuildVersion");
                if (dtXcodeBuild == null) {
                    throw new NoSuchElementException("No ProductBuildVersion in " + versionPListFile.getAbsolutePath());
                }
                NSString dtXcode = (NSString) xcodeInfoPList.objectForKey("DTXcode");
                if (dtXcode == null) {
                    throw new NoSuchElementException("No DTXcode in " + xcodeInfoPListFile.getAbsolutePath());
                }
                putIfAbsent(dict, "DTXcode", dtXcode.toString());
                putIfAbsent(dict, "DTXcodeBuild", dtXcodeBuild.toString());
            } catch (Exception e) {
                config.getLogger()
                        .warn("Failed to read DTXcodeBuild/DTXcode from current Xcode install. Will use fake values. (%s: %s)",
                                e.getClass().getName(), e.getMessage());
            }
            
            putIfAbsent(dict, "DTXcode", "0611");
            putIfAbsent(dict, "DTXcodeBuild", "6A2008a");
        }
    }

    protected void createInfoPList(File dir) throws IOException {
        NSDictionary dict = new NSDictionary();
        if (config.getIosInfoPList() != null && config.getIosInfoPList().getDictionary() != null) {
            NSDictionary infoPListDict = config.getIosInfoPList().getDictionary();
            for (String key : infoPListDict.allKeys()) {
                dict.put(key, infoPListDict.objectForKey(key));
            }
        } else {
            dict.put("CFBundleVersion", "1.0");
            dict.put("CFBundleExecutable", config.getExecutableName());
            dict.put("CFBundleName", config.getExecutableName());
            dict.put("CFBundleIdentifier", getBundleId());
            dict.put("CFBundlePackageType", "APPL");
            dict.put("LSRequiresIPhoneOS", true);
            NSObject supportedDeviceFamilies = sdk.getDefaultProperty("SUPPORTED_DEVICE_FAMILIES");
            if (supportedDeviceFamilies != null) {
                
                
                
                
                NSArray families = null;
                if (supportedDeviceFamilies instanceof NSString) {
                    NSString defFamilies = (NSString) supportedDeviceFamilies;
                    String[] parts = defFamilies.toString().split(",");
                    families = new NSArray(parts.length);
                    for (int i = 0; i < families.count(); i++) {
                        families.setValue(i, new NSNumber(parts[i].trim()));
                    }
                } else {
                    NSArray defFamilies = (NSArray) supportedDeviceFamilies;
                    families = new NSArray(defFamilies.count());
                    for (int i = 0; i < families.count(); i++) {
                        families.setValue(i, new NSNumber(defFamilies.objectAtIndex(i).toString()));
                    }
                }
                dict.put("UIDeviceFamily", families);
            }
            dict.put("UISupportedInterfaceOrientations", new NSArray(
                    new NSString("UIInterfaceOrientationPortrait"),
                    new NSString("UIInterfaceOrientationLandscapeLeft"),
                    new NSString("UIInterfaceOrientationLandscapeRight"),
                    new NSString("UIInterfaceOrientationPortraitUpsideDown")
                    ));
            dict.put("UISupportedInterfaceOrientations~ipad", new NSArray(
                    new NSString("UIInterfaceOrientationPortrait"),
                    new NSString("UIInterfaceOrientationLandscapeLeft"),
                    new NSString("UIInterfaceOrientationLandscapeRight"),
                    new NSString("UIInterfaceOrientationPortraitUpsideDown")
                    ));
            dict.put("UIRequiredDeviceCapabilities", new NSArray(new NSString("armv7")));
        }

        dict.put("DTPlatformName", sdk.getPlatformName());
        dict.put("DTSDKName", sdk.getCanonicalName());

        for (File f : FileUtils.listFiles(partialPListDir, new String[] {"plist"}, false)) {
            try {
                NSDictionary d = (NSDictionary) PropertyListParser.parse(f);
                dict.putAll(d);
            } catch (Exception e) {
                throw new CompilerException(e);
            }
        }

        if (dict.objectForKey("MinimumOSVersion") == null) {
            
            dict.put("MinimumOSVersion", "6.0");
        }

        customizeInfoPList(dict);

        
        NSDictionary newDict = new NSDictionary();
        if (dict.objectForKey("CFBundleShortVersionString") != null) {
            newDict.put("CFBundleShortVersionString", dict.objectForKey("CFBundleShortVersionString"));
            dict.remove("CFBundleShortVersionString");
        }
        if (dict.objectForKey("CFBundleVersion") != null) {
            newDict.put("CFBundleVersion", dict.objectForKey("CFBundleVersion"));
            dict.remove("CFBundleVersion");
        }
        for (String key : dict.allKeys()) {
            newDict.put(key, dict.objectForKey(key));
        }

        File tmpInfoPlist = new File(config.getTmpDir(), "Info.plist");
        PropertyListParser.saveAsBinary(newDict, tmpInfoPlist);

        config.getLogger().debug("Installing Info.plist to %s", dir);
        FileUtils.copyFile(tmpInfoPlist, new File(dir, tmpInfoPlist.getName()));
    }

    public void init(Config config) {
        super.init(config);

        if (config.getArch() == null) {
            arch = Arch.thumbv7;
        } else {
            if (!isSimulatorArch(config.getArch()) && !isDeviceArch(config.getArch())) {
                throw new IllegalArgumentException("Arch '" + config.getArch()
                        + "' is unsupported for iOS target");
            }
            arch = config.getArch();
        }

        if (isDeviceArch(arch)) {
            if (!config.isSkipLinking() && !config.isIosSkipSigning()) {
                signIdentity = config.getIosSignIdentity();
                if (signIdentity == null) {
                    signIdentity = SigningIdentity.find(SigningIdentity.list(),
                            "/(?i)iPhone Developer|iOS Development/");
                }
            }
        }

        if (config.getIosInfoPList() != null) {
            config.getIosInfoPList().parse(config.getProperties());
        }

        if (isDeviceArch(arch)) {
            if (!config.isSkipLinking() &&!config.isIosSkipSigning()) {
                provisioningProfile = config.getIosProvisioningProfile();
                if (provisioningProfile == null) {
                    String bundleId = "*";
                    if (config.getIosInfoPList() != null && config.getIosInfoPList().getBundleIdentifier() != null) {
                        bundleId = config.getIosInfoPList().getBundleIdentifier();
                    }
                    provisioningProfile = ProvisioningProfile.find(ProvisioningProfile.list(), signIdentity, bundleId);
                }
            }
        }

        String sdkVersion = config.getIosSdkVersion();
        List<SDK> sdks = getSDKs();
        if (sdkVersion == null) {
            if (sdks.isEmpty()) {
                throw new IllegalArgumentException("No " + (isDeviceArch(arch) ? "device" : "simulator")
                        + " SDKs installed");
            }
            Collections.sort(sdks);
            this.sdk = sdks.get(sdks.size() - 1);
        } else {
            for (SDK sdk : sdks) {
                if (sdk.getVersion().equals(sdkVersion)) {
                    this.sdk = sdk;
                    break;
                }
            }
            if (sdk == null) {
                throw new IllegalArgumentException("No SDK found matching version string " + sdkVersion);
            }
        }

        entitlementsPList = config.getIosEntitlementsPList();

        partialPListDir = new File(config.getTmpDir(), "partial-plists");
        partialPListDir.mkdirs();
        try {
            FileUtils.cleanDirectory(partialPListDir);
        } catch (IOException e) {
            throw new CompilerException(e);
        }
    }

    @Override
    public OS getOs() {
        return OS.ios;
    }

    @Override
    public boolean canLaunchInPlace() {
        return false;
    }

    
    private void copyToIndexedDir(File dir, String executable, File dsymDir, File exePath) {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMddHHmmss");
        final File indexedDir = new File(System.getProperty("user.home"),
                "Library/Developer/Xcode/DerivedData/RoboVM/Build/Products/"
                        + FilenameUtils.removeExtension(dir.getName()) + "_"
                        + sdf.format(new Date()));
        indexedDir.mkdirs();
        File indexedDSymDir = new File(indexedDir, dsymDir.getName());
        File indexedAppDir = new File(indexedDir, dir.getName());
        indexedAppDir.mkdirs();

        try {
            
            
            FileUtils.copyFile(exePath, new File(indexedAppDir, executable));
        } catch (IOException e) {
            config.getLogger().error("Failed to copy %s to indexed dir %s: %s",
                    exePath.getAbsolutePath(),
                    indexedAppDir.getAbsolutePath(), e.getMessage());
        }

        try {
            FileUtils.copyDirectory(dsymDir, indexedDSymDir);
        } catch (IOException e) {
            config.getLogger().error("Failed to copy %s to indexed dir %s: %s",
                    dsymDir.getAbsolutePath(),
                    indexedDir.getAbsolutePath(), e.getMessage());
        }

        
        List<File> dirs = new ArrayList<>(Arrays.asList(indexedDir.getParentFile().listFiles((FileFilter)
                new AndFileFilter(
                        new PrefixFileFilter(FilenameUtils.removeExtension(dir.getName())),
                        new RegexFileFilter(".*_\\d{14}")))));
        Collections.sort(dirs, new Comparator<File>() {
            public int compare(File o1, File o2) {
                return Long.compare(o1.lastModified(), o2.lastModified());
            }
        });
        if (dirs.size() > 3) {
            for (File f : dirs.subList(0, dirs.size() - 3)) {
                try {
                    FileUtils.deleteDirectory(f);
                } catch (IOException e) {
                    config.getLogger().error("Failed to delete diretcory %s",
                            f.getAbsolutePath(), e.getMessage());
                }
            }
        }
    }

    private final static Pattern VARIABLE_PATTERN = Pattern.compile("\\$\\{([^}]+)\\}");

    static void replacePropertyRefs(Node node, Properties props) {
        if (node instanceof Text) {
            Text el = (Text) node;
            String value = el.getNodeValue();
            if (value != null && value.trim().length() > 0) {
                Matcher matcher = VARIABLE_PATTERN.matcher(value);
                StringBuilder sb = new StringBuilder();
                int pos = 0;
                while (matcher.find()) {
                    if (pos < matcher.start()) {
                        sb.append(value.substring(pos, matcher.start()));
                    }
                    String key = matcher.group(1);
                    sb.append(props.getProperty(key, matcher.group()));
                    pos = matcher.end();
                }
                if (pos < value.length()) {
                    sb.append(value.substring(pos));
                }
                el.setNodeValue(sb.toString());
            }
        }
        NodeList children = node.getChildNodes();
        for (int i = 0; i < children.getLength(); i++) {
            replacePropertyRefs(children.item(i), props);
        }
    }

    static NSObject parsePropertyList(File file, Properties props) throws Exception {
        Properties allProps = new Properties(System.getProperties());
        allProps.putAll(props);

        Method getDocBuilder = XMLPropertyListParser.class.getDeclaredMethod("getDocBuilder");
        getDocBuilder.setAccessible(true);
        Method parseDocument = XMLPropertyListParser.class.getDeclaredMethod("parseDocument", Document.class);
        parseDocument.setAccessible(true);
        DocumentBuilder docBuilder = (DocumentBuilder) getDocBuilder.invoke(null);
        Document doc = docBuilder.parse(file);
        replacePropertyRefs(doc, allProps);
        return (NSObject) parseDocument.invoke(null, doc);
    }
}
