
package com.google.gwt.dev.jjs;

import com.google.gwt.core.ext.TreeLogger;
import com.google.gwt.core.ext.UnableToCompleteException;
import com.google.gwt.core.ext.linker.Artifact;
import com.google.gwt.core.ext.linker.ArtifactSet;
import com.google.gwt.core.ext.linker.CompilationMetricsArtifact;
import com.google.gwt.core.ext.linker.EmittedArtifact;
import com.google.gwt.core.ext.linker.EmittedArtifact.Visibility;
import com.google.gwt.core.ext.linker.ModuleMetricsArtifact;
import com.google.gwt.core.ext.linker.PrecompilationMetricsArtifact;
import com.google.gwt.core.ext.linker.StatementRanges;
import com.google.gwt.core.ext.linker.SymbolData;
import com.google.gwt.core.ext.linker.SyntheticArtifact;
import com.google.gwt.core.ext.linker.impl.StandardSymbolData;
import com.google.gwt.core.ext.soyc.SourceMapRecorder;
import com.google.gwt.core.ext.soyc.coderef.DependencyGraphRecorder;
import com.google.gwt.core.ext.soyc.coderef.EntityRecorder;
import com.google.gwt.core.ext.soyc.impl.DependencyRecorder;
import com.google.gwt.core.ext.soyc.impl.SizeMapRecorder;
import com.google.gwt.core.ext.soyc.impl.SplitPointRecorder;
import com.google.gwt.core.ext.soyc.impl.StoryRecorder;
import com.google.gwt.core.linker.SoycReportLinker;
import com.google.gwt.dev.CompilerContext;
import com.google.gwt.dev.MinimalRebuildCache;
import com.google.gwt.dev.Permutation;
import com.google.gwt.dev.PrecompileTaskOptions;
import com.google.gwt.dev.cfg.ConfigurationProperties;
import com.google.gwt.dev.cfg.EntryMethodHolderGenerator;
import com.google.gwt.dev.cfg.ModuleDef;
import com.google.gwt.dev.cfg.PermutationProperties;
import com.google.gwt.dev.javac.CompilationProblemReporter;
import com.google.gwt.dev.javac.CompilationState;
import com.google.gwt.dev.javac.StandardGeneratorContext;
import com.google.gwt.dev.javac.typemodel.TypeOracle;
import com.google.gwt.dev.jdt.RebindPermutationOracle;
import com.google.gwt.dev.jjs.UnifiedAst.AST;
import com.google.gwt.dev.jjs.ast.Context;
import com.google.gwt.dev.jjs.ast.JBlock;
import com.google.gwt.dev.jjs.ast.JCastOperation;
import com.google.gwt.dev.jjs.ast.JClassLiteral;
import com.google.gwt.dev.jjs.ast.JClassType;
import com.google.gwt.dev.jjs.ast.JDeclaredType;
import com.google.gwt.dev.jjs.ast.JMethod;
import com.google.gwt.dev.jjs.ast.JMethodBody;
import com.google.gwt.dev.jjs.ast.JMethodCall;
import com.google.gwt.dev.jjs.ast.JProgram;
import com.google.gwt.dev.jjs.ast.JTypeOracle.StandardTypes;
import com.google.gwt.dev.jjs.ast.JVisitor;
import com.google.gwt.dev.jjs.impl.ArrayNormalizer;
import com.google.gwt.dev.jjs.impl.AssertionNormalizer;
import com.google.gwt.dev.jjs.impl.AssertionRemover;
import com.google.gwt.dev.jjs.impl.AstDumper;
import com.google.gwt.dev.jjs.impl.CatchBlockNormalizer;
import com.google.gwt.dev.jjs.impl.CompileTimeConstantsReplacer;
import com.google.gwt.dev.jjs.impl.ComputeCastabilityInformation;
import com.google.gwt.dev.jjs.impl.ComputeExhaustiveCastabilityInformation;
import com.google.gwt.dev.jjs.impl.ComputeInstantiatedJsoInterfaces;
import com.google.gwt.dev.jjs.impl.ControlFlowAnalyzer;
import com.google.gwt.dev.jjs.impl.ControlFlowRecorder;
import com.google.gwt.dev.jjs.impl.DeadCodeElimination;
import com.google.gwt.dev.jjs.impl.Devirtualizer;
import com.google.gwt.dev.jjs.impl.EnumNameObfuscator;
import com.google.gwt.dev.jjs.impl.EnumOrdinalizer;
import com.google.gwt.dev.jjs.impl.EqualityNormalizer;
import com.google.gwt.dev.jjs.impl.Finalizer;
import com.google.gwt.dev.jjs.impl.FixAssignmentsToUnboxOrCast;
import com.google.gwt.dev.jjs.impl.FullOptimizerContext;
import com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST;
import com.google.gwt.dev.jjs.impl.HandleCrossFragmentReferences;
import com.google.gwt.dev.jjs.impl.ImplementCastsAndTypeChecks;
import com.google.gwt.dev.jjs.impl.ImplementClassLiteralsAsFields;
import com.google.gwt.dev.jjs.impl.JavaAstVerifier;
import com.google.gwt.dev.jjs.impl.JavaToJavaScriptMap;
import com.google.gwt.dev.jjs.impl.JjsUtils;
import com.google.gwt.dev.jjs.impl.JsAbstractTextTransformer;
import com.google.gwt.dev.jjs.impl.JsFunctionClusterer;
import com.google.gwt.dev.jjs.impl.JsInteropRestrictionChecker;
import com.google.gwt.dev.jjs.impl.JsNoopTransformer;
import com.google.gwt.dev.jjs.impl.JsTypeLinker;
import com.google.gwt.dev.jjs.impl.JsniRestrictionChecker;
import com.google.gwt.dev.jjs.impl.LongCastNormalizer;
import com.google.gwt.dev.jjs.impl.LongEmulationNormalizer;
import com.google.gwt.dev.jjs.impl.MakeCallsStatic;
import com.google.gwt.dev.jjs.impl.MethodCallSpecializer;
import com.google.gwt.dev.jjs.impl.MethodCallTightener;
import com.google.gwt.dev.jjs.impl.MethodInliner;
import com.google.gwt.dev.jjs.impl.OptimizerContext;
import com.google.gwt.dev.jjs.impl.OptimizerStats;
import com.google.gwt.dev.jjs.impl.PostOptimizationCompoundAssignmentNormalizer;
import com.google.gwt.dev.jjs.impl.Pruner;
import com.google.gwt.dev.jjs.impl.RecordRebinds;
import com.google.gwt.dev.jjs.impl.RemoveEmptySuperCalls;
import com.google.gwt.dev.jjs.impl.RemoveSpecializations;
import com.google.gwt.dev.jjs.impl.ReplaceDefenderMethodReferences;
import com.google.gwt.dev.jjs.impl.ReplaceGetClassOverrides;
import com.google.gwt.dev.jjs.impl.ResolvePermutationDependentValues;
import com.google.gwt.dev.jjs.impl.ResolveRuntimeTypeReferences;
import com.google.gwt.dev.jjs.impl.ResolveRuntimeTypeReferences.ClosureUniqueIdTypeMapper;
import com.google.gwt.dev.jjs.impl.ResolveRuntimeTypeReferences.IntTypeMapper;
import com.google.gwt.dev.jjs.impl.ResolveRuntimeTypeReferences.StringTypeMapper;
import com.google.gwt.dev.jjs.impl.ResolveRuntimeTypeReferences.TypeMapper;
import com.google.gwt.dev.jjs.impl.ResolveRuntimeTypeReferences.TypeOrder;
import com.google.gwt.dev.jjs.impl.SameParameterValueOptimizer;
import com.google.gwt.dev.jjs.impl.SourceInfoCorrelator;
import com.google.gwt.dev.jjs.impl.TypeCoercionNormalizer;
import com.google.gwt.dev.jjs.impl.TypeReferencesRecorder;
import com.google.gwt.dev.jjs.impl.TypeTightener;
import com.google.gwt.dev.jjs.impl.UnifyAst;
import com.google.gwt.dev.jjs.impl.codesplitter.CodeSplitter;
import com.google.gwt.dev.jjs.impl.codesplitter.CodeSplitters;
import com.google.gwt.dev.jjs.impl.codesplitter.MultipleDependencyGraphRecorder;
import com.google.gwt.dev.jjs.impl.codesplitter.ReplaceRunAsyncs;
import com.google.gwt.dev.jjs.impl.gflow.DataflowOptimizer;
import com.google.gwt.dev.js.BaselineCoverageGatherer;
import com.google.gwt.dev.js.ClosureJsRunner;
import com.google.gwt.dev.js.CoverageInstrumentor;
import com.google.gwt.dev.js.DuplicateExecuteOnceRemover;
import com.google.gwt.dev.js.EvalFunctionsAtTopScope;
import com.google.gwt.dev.js.FreshNameGenerator;
import com.google.gwt.dev.js.JsBreakUpLargeVarStatements;
import com.google.gwt.dev.js.JsDuplicateCaseFolder;
import com.google.gwt.dev.js.JsDuplicateFunctionRemover;
import com.google.gwt.dev.js.JsIncrementalNamer;
import com.google.gwt.dev.js.JsInliner;
import com.google.gwt.dev.js.JsLiteralInterner;
import com.google.gwt.dev.js.JsNamer.IllegalNameException;
import com.google.gwt.dev.js.JsNamespaceChooser;
import com.google.gwt.dev.js.JsNamespaceOption;
import com.google.gwt.dev.js.JsNormalizer;
import com.google.gwt.dev.js.JsObfuscateNamer;
import com.google.gwt.dev.js.JsPrettyNamer;
import com.google.gwt.dev.js.JsReportGenerationVisitor;
import com.google.gwt.dev.js.JsStackEmulator;
import com.google.gwt.dev.js.JsStaticEval;
import com.google.gwt.dev.js.JsSymbolResolver;
import com.google.gwt.dev.js.JsUnusedFunctionRemover;
import com.google.gwt.dev.js.JsVerboseNamer;
import com.google.gwt.dev.js.SizeBreakdown;
import com.google.gwt.dev.js.ast.JsContext;
import com.google.gwt.dev.js.ast.JsForIn;
import com.google.gwt.dev.js.ast.JsFunction;
import com.google.gwt.dev.js.ast.JsLabel;
import com.google.gwt.dev.js.ast.JsLiteral;
import com.google.gwt.dev.js.ast.JsName;
import com.google.gwt.dev.js.ast.JsNameOf;
import com.google.gwt.dev.js.ast.JsNameRef;
import com.google.gwt.dev.js.ast.JsNode;
import com.google.gwt.dev.js.ast.JsParameter;
import com.google.gwt.dev.js.ast.JsProgram;
import com.google.gwt.dev.js.ast.JsVars;
import com.google.gwt.dev.js.ast.JsVisitor;
import com.google.gwt.dev.util.DefaultTextOutput;
import com.google.gwt.dev.util.Memory;
import com.google.gwt.dev.util.Name.SourceName;
import com.google.gwt.dev.util.Pair;
import com.google.gwt.dev.util.Util;
import com.google.gwt.dev.util.arg.OptionOptimize;
import com.google.gwt.dev.util.log.speedtracer.CompilerEventType;
import com.google.gwt.dev.util.log.speedtracer.SpeedTracerLogger;
import com.google.gwt.dev.util.log.speedtracer.SpeedTracerLogger.Event;
import com.google.gwt.soyc.SoycDashboard;
import com.google.gwt.soyc.io.ArtifactsOutputDirectory;
import com.google.gwt.thirdparty.guava.common.collect.ImmutableMap;
import com.google.gwt.thirdparty.guava.common.collect.Iterables;
import com.google.gwt.thirdparty.guava.common.collect.Lists;
import com.google.gwt.thirdparty.guava.common.collect.Multimap;
import com.google.gwt.thirdparty.guava.common.collect.Sets;

import org.xml.sax.SAXException;

import java.io.BufferedInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.management.ManagementFactory;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.zip.GZIPInputStream;

import javax.xml.parsers.ParserConfigurationException;


public final class JavaToJavaScriptCompiler {


  private static final float EFFICIENT_CHANGE_RATE = 0.01f;

  private static final int FIXED_POINT_CHANGE_RATE = 0;

  private static final int MAX_PASSES = 100;

  static {

    InternalCompilerException.preload();
  }

  private final CompilerContext compilerContext;
  private final TreeLogger logger;
  private final ModuleDef module;
  private final PrecompileTaskOptions options;
  private JsProgram jsProgram;
  private JProgram jprogram;

  public JavaToJavaScriptCompiler(TreeLogger logger, CompilerContext compilerContext) {
    this.logger = logger;
    this.compilerContext = compilerContext;
    this.module = compilerContext.getModule();
    this.options = compilerContext.getOptions();
  }

  public static UnifiedAst precompile(TreeLogger logger, CompilerContext compilerContext,
      PrecompilationContext precompilationContext)
      throws UnableToCompleteException {
    return new JavaToJavaScriptCompiler(logger, compilerContext).precompile(precompilationContext);
  }


  public static PermutationResult compilePermutation(UnifiedAst unifiedAst,
      TreeLogger logger, CompilerContext compilerContext, Permutation permutation)
      throws UnableToCompleteException {
    JavaToJavaScriptCompiler javaToJavaScriptCompiler =
        new JavaToJavaScriptCompiler(logger, compilerContext);
    return javaToJavaScriptCompiler.compilePermutation(permutation, unifiedAst);
  }


  private PermutationResult compilePermutation(Permutation permutation, UnifiedAst unifiedAst)
      throws UnableToCompleteException {
    Event jjsCompilePermutationEvent = SpeedTracerLogger.start(
        CompilerEventType.JJS_COMPILE_PERMUTATION, "name", permutation.getProperties().prettyPrint()
    );


    long permStartMs = System.currentTimeMillis();
    try {
      Event javaEvent = SpeedTracerLogger.start(CompilerEventType.PERMUTATION_JAVA);


      long startTimeMs = System.currentTimeMillis();
      PermutationProperties properties = permutation.getProperties();
      int permutationId = permutation.getId();
      AST ast = unifiedAst.getFreshAst();
      jprogram = ast.getJProgram();
      jsProgram = ast.getJsProgram();
      Map<StandardSymbolData, JsName> symbolTable =
          new TreeMap<StandardSymbolData, JsName>(new SymbolData.ClassIdentComparator());


      logger.log(TreeLogger.INFO, "Compiling permutation " + permutationId + "...");


      ResolvePermutationDependentValues
          .exec(jprogram, properties, permutation.getPropertyAndBindingInfos());





      Multimap<String, Integer> instrumentableLines = null;
      if (System.getProperty("gwt.coverage") != null) {
        instrumentableLines = BaselineCoverageGatherer.exec(jprogram);
      }






      maybeRecordReferencesAndControlFlow(false);



      CompileTimeConstantsReplacer.exec(jprogram);



      optimizeJava();



      TypeMapper<?> typeMapper = normalizeSemantics();


      postNormalizationOptimizeJava();


      maybeRecordReferencesAndControlFlow(true);

      javaEvent.end();

      Event javaScriptEvent = SpeedTracerLogger.start(CompilerEventType.PERMUTATION_JAVASCRIPT);


      Pair<? extends JavaToJavaScriptMap, Set<JsNode>> jjsMapAndInlineableFunctions =
          GenerateJavaScriptAST.exec(logger, jprogram, jsProgram,
              compilerContext, typeMapper, symbolTable, properties);
      JavaToJavaScriptMap jjsmap = jjsMapAndInlineableFunctions.getLeft();


      if (System.getProperty("gwt.coverage") != null) {
        CoverageInstrumentor.exec(jsProgram, instrumentableLines);
      }


      JsNormalizer.exec(jsProgram);


      JsSymbolResolver.exec(jsProgram);
      if (options.getNamespace() == JsNamespaceOption.PACKAGE) {
        JsNamespaceChooser.exec(jsProgram, jjsmap);
      }


      EvalFunctionsAtTopScope.exec(jsProgram, jjsmap);


      final Set<JsNode> inlinableJsFunctions = jjsMapAndInlineableFunctions.getRight();
      optimizeJs(inlinableJsFunctions);



      JsStackEmulator.exec(jprogram, jsProgram, properties, jjsmap);


      Pair<SyntheticArtifact, MultipleDependencyGraphRecorder> dependenciesAndRecorder =
          splitJsIntoFragments(properties, permutationId, jjsmap);


      Map<JsName, JsLiteral> internedLiteralByVariableName = renameJsSymbols(properties, jjsmap);


      JsBreakUpLargeVarStatements.exec(jsProgram, properties.getConfigurationProperties());


      List<JsSourceMap> sourceInfoMaps = new ArrayList<JsSourceMap>();
      boolean isSourceMapsEnabled = properties.isTrueInAnyPermutation("compiler.useSourceMaps");
      String[] jsFragments = new String[jsProgram.getFragmentCount()];
      StatementRanges[] ranges = new StatementRanges[jsFragments.length];
      SizeBreakdown[] sizeBreakdowns = options.isJsonSoycEnabled() || options.isSoycEnabled()
          || options.isCompilerMetricsEnabled() ? new SizeBreakdown[jsFragments.length] : null;
      generateJavaScriptCode(jjsmap, jsFragments, ranges, sizeBreakdowns, sourceInfoMaps,
          isSourceMapsEnabled || options.isJsonSoycEnabled());

      javaScriptEvent.end();


      PermutationResult permutationResult =
          new PermutationResultImpl(jsFragments, permutation, makeSymbolMap(symbolTable), ranges);


      addSyntheticArtifacts(unifiedAst, permutation, startTimeMs, permutationId, jjsmap,
          dependenciesAndRecorder, internedLiteralByVariableName, isSourceMapsEnabled, jsFragments,
          sizeBreakdowns, sourceInfoMaps, permutationResult);
      return permutationResult;
    } catch (Throwable e) {
      throw CompilationProblemReporter.logAndTranslateException(logger, e);
    } finally {
      jjsCompilePermutationEvent.end();
      if (logger.isLoggable(TreeLogger.TRACE)) {
        logger.log(TreeLogger.TRACE,
            "Permutation took " + (System.currentTimeMillis() - permStartMs) + " ms");
      }
    }
  }

  private void maybeRecordReferencesAndControlFlow(boolean onlyUpdate) {
    if (options.isIncrementalCompileEnabled()) {


      TypeReferencesRecorder.exec(jprogram, getMinimalRebuildCache(), onlyUpdate);
      ControlFlowRecorder.exec(jprogram, getMinimalRebuildCache().getTypeEnvironment(),
          onlyUpdate);
    }
  }


  protected TypeMapper<?> normalizeSemantics() {
    Event event = SpeedTracerLogger.start(CompilerEventType.JAVA_NORMALIZERS);
    try {
      Devirtualizer.exec(jprogram);
      CatchBlockNormalizer.exec(jprogram);
      PostOptimizationCompoundAssignmentNormalizer.exec(jprogram);
      LongCastNormalizer.exec(jprogram);
      LongEmulationNormalizer.exec(jprogram);
      TypeCoercionNormalizer.exec(jprogram);

      if (options.isIncrementalCompileEnabled()) {



        ComputeExhaustiveCastabilityInformation.exec(jprogram);
      } else {

        ComputeCastabilityInformation.exec(jprogram, options.isCastCheckingDisabled(),
            !shouldOptimize() );
      }

      ComputeInstantiatedJsoInterfaces.exec(jprogram);
      ImplementCastsAndTypeChecks.exec(jprogram, options.isCastCheckingDisabled(),
          shouldOptimize() );
      ArrayNormalizer.exec(jprogram, options.isCastCheckingDisabled());
      EqualityNormalizer.exec(jprogram);

      TypeMapper<?> typeMapper = getTypeMapper();
      ResolveRuntimeTypeReferences.exec(jprogram, typeMapper, getTypeOrder());
      return typeMapper;
    } finally {
      event.end();
    }
  }

  private void optimizeJava() throws InterruptedException {
    if (shouldOptimize()) {
      optimizeJavaToFixedPoint();
      RemoveEmptySuperCalls.exec(jprogram);
    }
  }

  private void optimizeJs(Set<JsNode> inlinableJsFunctions) throws InterruptedException {
    if (shouldOptimize()) {
      optimizeJsLoop(inlinableJsFunctions);
      JsDuplicateCaseFolder.exec(jsProgram);
    }
  }

  private void postNormalizationOptimizeJava() {
    Event event = SpeedTracerLogger.start(CompilerEventType.JAVA_POST_NORMALIZER_OPTIMIZERS);
    try {
      if (shouldOptimize()) {
        RemoveSpecializations.exec(jprogram);
        Pruner.exec(jprogram, false);

        jprogram.typeOracle.recomputeAfterOptimizations(jprogram.getDeclaredTypes());
      }
      ReplaceGetClassOverrides.exec(jprogram);
    } finally {
      event.end();
    }
  }

  private Map<JsName, JsLiteral> runDetailedNamer(ConfigurationProperties config)
      throws IllegalNameException {
    Map<JsName, JsLiteral> internedTextByVariableName =
        maybeInternLiterals(JsLiteralInterner.INTERN_ALL);
    JsVerboseNamer.exec(jsProgram, config);
    return internedTextByVariableName;
  }

  private Map<JsName, JsLiteral> maybeInternLiterals(int interningMask) {
    if (!shouldOptimize()) {
      return null;
    }

    if (options.isClosureCompilerFormatEnabled()) {

      interningMask &= ~JsLiteralInterner.INTERN_STRINGS;
    }
    return JsLiteralInterner.exec(jprogram, jsProgram, interningMask);
  }

  private Pair<SyntheticArtifact, MultipleDependencyGraphRecorder> splitJsIntoFragments(
      PermutationProperties properties, int permutationId, JavaToJavaScriptMap jjsmap) {
    Pair<SyntheticArtifact, MultipleDependencyGraphRecorder> dependenciesAndRecorder;
    MultipleDependencyGraphRecorder dependencyRecorder = null;
    SyntheticArtifact dependencies = null;
    if (options.isRunAsyncEnabled()) {
      ByteArrayOutputStream baos = new ByteArrayOutputStream();

      int expectedFragmentCount = options.getFragmentCount();

      if (expectedFragmentCount <= 0) {

        int numberOfMerges = options.getFragmentsMerge();
        if (numberOfMerges > 0) {


          expectedFragmentCount =
              Math.max(0, jprogram.getRunAsyncs().size() + 2 - numberOfMerges);
        }
      }

      int minFragmentSize = properties.getConfigurationProperties()
          .getInteger(CodeSplitters.MIN_FRAGMENT_SIZE, 0);

      dependencyRecorder = chooseDependencyRecorder(baos);
      CodeSplitter.exec(logger, jprogram, jsProgram, jjsmap, expectedFragmentCount,
          minFragmentSize, dependencyRecorder);

      if (baos.size() == 0) {
        dependencyRecorder = recordNonSplitDependencies(baos);
      }
      if (baos.size() > 0) {
        dependencies = new SyntheticArtifact(
            SoycReportLinker.class, "dependencies" + permutationId + ".xml.gz",
            baos.toByteArray());
      }
    } else if (options.isSoycEnabled() || options.isJsonSoycEnabled()) {
      dependencyRecorder = recordNonSplitDependencies(new ByteArrayOutputStream());
    }
    dependenciesAndRecorder = Pair.create(
        dependencies, dependencyRecorder);



    HandleCrossFragmentReferences.exec(jsProgram, properties);

    return dependenciesAndRecorder;
  }

  private MultipleDependencyGraphRecorder chooseDependencyRecorder(OutputStream out) {
    MultipleDependencyGraphRecorder dependencyRecorder =
        MultipleDependencyGraphRecorder.NULL_RECORDER;
    if (options.isSoycEnabled() && options.isJsonSoycEnabled()) {
      dependencyRecorder = new DependencyGraphRecorder(out, jprogram);
    } else if (options.isSoycEnabled()) {
      dependencyRecorder = new DependencyRecorder(out);
    } else if (options.isJsonSoycEnabled()) {
      dependencyRecorder = new DependencyGraphRecorder(out, jprogram);
    }
    return dependencyRecorder;
  }


  private DependencyRecorder recordNonSplitDependencies(OutputStream out) {
    DependencyRecorder deps;
    if (options.isSoycEnabled() && options.isJsonSoycEnabled()) {
      deps = new DependencyGraphRecorder(out, jprogram);
    } else if (options.isSoycEnabled()) {
      deps = new DependencyRecorder(out);
    } else if (options.isJsonSoycEnabled()) {
      deps = new DependencyGraphRecorder(out, jprogram);
    } else {
      return null;
    }
    deps.open();
    deps.startDependencyGraph("initial", null);

    ControlFlowAnalyzer cfa = new ControlFlowAnalyzer(jprogram);
    cfa.setDependencyRecorder(deps);
    cfa.traverseEntryMethods();
    deps.endDependencyGraph();
    deps.close();
    return deps;
  }

  private CompilationMetricsArtifact addCompilerMetricsArtifact(UnifiedAst unifiedAst,
      Permutation permutation, long startTimeMs, SizeBreakdown[] sizeBreakdowns,
      PermutationResult permutationResult) {
    CompilationMetricsArtifact compilationMetrics = null;

    if (options.isCompilerMetricsEnabled()) {
      if (options.isClosureCompilerEnabled()) {
        logger.log(TreeLogger.WARN, "Incompatible options: -XenableClosureCompiler and "
            + "-XcompilerMetric; ignoring -XcompilerMetric.");
      } else {
        compilationMetrics = new CompilationMetricsArtifact(permutation.getId());
        compilationMetrics.setCompileElapsedMilliseconds(
            System.currentTimeMillis() - startTimeMs);
        compilationMetrics.setElapsedMilliseconds(
            System.currentTimeMillis() - ManagementFactory.getRuntimeMXBean().getStartTime());
        compilationMetrics.setJsSize(sizeBreakdowns);
        compilationMetrics.setPermutationDescription(permutation.getProperties().prettyPrint());
        permutationResult.addArtifacts(Lists.newArrayList(
            unifiedAst.getModuleMetrics(), unifiedAst.getPrecompilationMetrics(),
            compilationMetrics));
      }
    }
    return compilationMetrics;
  }

  private void addSourceMapArtifacts(int permutationId, JavaToJavaScriptMap jjsmap,
      Pair<SyntheticArtifact, MultipleDependencyGraphRecorder> dependenciesAndRecorder,
      boolean isSourceMapsEnabled, SizeBreakdown[] sizeBreakdowns,
      List<JsSourceMap> sourceInfoMaps, PermutationResult permutationResult) {
    if (options.isJsonSoycEnabled()) {

      if (options.isClosureCompilerEnabled()) {
        logger.log(TreeLogger.WARN, "Incompatible options: -XenableClosureCompiler and "
            + "-XjsonSoyc; ignoring -XjsonSoyc.");
      } else {

        permutationResult.addArtifacts(EntityRecorder.makeSoycArtifacts(
            permutationId, sourceInfoMaps, options.getSourceMapFilePrefix(),
            jjsmap, sizeBreakdowns,
            ((DependencyGraphRecorder) dependenciesAndRecorder.getRight()), jprogram));
      }
    } else if (isSourceMapsEnabled) {

      if (options.isClosureCompilerEnabled()) {
        logger.log(TreeLogger.WARN, "Incompatible options: -XenableClosureCompiler and "
            + "compiler.useSourceMaps=true; ignoring compiler.useSourceMaps=true.");
      } else {
        logger.log(TreeLogger.INFO, "Source Maps Enabled");
        permutationResult.addArtifacts(SourceMapRecorder.exec(permutationId, sourceInfoMaps,
            options.getSourceMapFilePrefix()));
      }
    }
  }


  private void maybeAddGeneratedArtifacts(PermutationResult permutationResult) {
    if (options.isIncrementalCompileEnabled()) {
      permutationResult.addArtifacts(
          compilerContext.getMinimalRebuildCache().getGeneratedArtifacts());
    }
  }

  private void addSoycArtifacts(UnifiedAst unifiedAst, int permutationId,
      JavaToJavaScriptMap jjsmap,
      Pair<SyntheticArtifact, MultipleDependencyGraphRecorder> dependenciesAndRecorder,
      Map<JsName, JsLiteral> internedLiteralByVariableName, String[] js,
      SizeBreakdown[] sizeBreakdowns,
      List<JsSourceMap> sourceInfoMaps, PermutationResult permutationResult,
      CompilationMetricsArtifact compilationMetrics)
      throws IOException, UnableToCompleteException {

    if (options.isClosureCompilerEnabled()) {
      if (options.isSoycEnabled()) {
        logger.log(TreeLogger.WARN, "Incompatible options: -XenableClosureCompiler and "
            + "-compileReport; ignoring -compileReport.");
      }
    } else {
      permutationResult.addArtifacts(makeSoycArtifacts(permutationId, js, sizeBreakdowns,
          options.isSoycExtra() ? sourceInfoMaps : null, dependenciesAndRecorder.getLeft(),
          jjsmap, internedLiteralByVariableName, unifiedAst.getModuleMetrics(),
          unifiedAst.getPrecompilationMetrics(), compilationMetrics,
          options.isSoycHtmlDisabled()));
    }
  }

  private void addSyntheticArtifacts(UnifiedAst unifiedAst, Permutation permutation,
      long startTimeMs, int permutationId, JavaToJavaScriptMap jjsmap,
      Pair<SyntheticArtifact, MultipleDependencyGraphRecorder> dependenciesAndRecorder,
      Map<JsName, JsLiteral> internedLiteralByVariableName, boolean isSourceMapsEnabled,
      String[] jsFragments, SizeBreakdown[] sizeBreakdowns,
      List<JsSourceMap> sourceInfoMaps, PermutationResult permutationResult)
      throws IOException, UnableToCompleteException {

    assert internedLiteralByVariableName != null;

    Event event = SpeedTracerLogger.start(CompilerEventType.PERMUTATION_ARTIFACTS);

    CompilationMetricsArtifact compilationMetrics = addCompilerMetricsArtifact(
        unifiedAst, permutation, startTimeMs, sizeBreakdowns, permutationResult);
    addSoycArtifacts(unifiedAst, permutationId, jjsmap, dependenciesAndRecorder,
        internedLiteralByVariableName, jsFragments, sizeBreakdowns, sourceInfoMaps,
        permutationResult, compilationMetrics);
    addSourceMapArtifacts(permutationId, jjsmap, dependenciesAndRecorder, isSourceMapsEnabled,
        sizeBreakdowns, sourceInfoMaps, permutationResult);
    maybeAddGeneratedArtifacts(permutationResult);

    event.end();
  }


  private void generateJavaScriptCode(JavaToJavaScriptMap jjsMap, String[] jsFragments,
      StatementRanges[] ranges, SizeBreakdown[] sizeBreakdowns,
      List<JsSourceMap> sourceInfoMaps, boolean sourceMapsEnabled) {

    Event generateJavascriptEvent =
        SpeedTracerLogger.start(CompilerEventType.GENERATE_JAVASCRIPT);

    boolean useClosureCompiler = options.isClosureCompilerEnabled();
    if (useClosureCompiler) {
      ClosureJsRunner runner = new ClosureJsRunner();
      runner.compile(jprogram, jsProgram, jsFragments, options.getOutput());
      generateJavascriptEvent.end();
      return;
    }

    for (int i = 0; i < jsFragments.length; i++) {
      DefaultTextOutput out = new DefaultTextOutput(!options.isIncrementalCompileEnabled() &&
          options.getOutput().shouldMinimize());
      JsReportGenerationVisitor v = new JsReportGenerationVisitor(out, jjsMap,
          options.isJsonSoycEnabled());
      v.accept(jsProgram.getFragmentBlock(i));

      StatementRanges statementRanges = v.getStatementRanges();
      String code = out.toString();
      JsSourceMap infoMap = (sourceInfoMaps != null) ? v.getSourceInfoMap() : null;

      JsAbstractTextTransformer transformer =
          new JsNoopTransformer(code, statementRanges, infoMap);


      if (options.isIncrementalCompileEnabled()) {
        transformer = new JsTypeLinker(logger, transformer, v.getClassRanges(),
            v.getProgramClassRange(), getMinimalRebuildCache(), jprogram.typeOracle);
        transformer.exec();
      }


      Event functionClusterEvent = SpeedTracerLogger.start(CompilerEventType.FUNCTION_CLUSTER);

      if (!sourceMapsEnabled && !options.isClosureCompilerFormatEnabled()
          && options.shouldClusterSimilarFunctions()
          && options.getNamespace() == JsNamespaceOption.NONE
          && options.getOutput() == JsOutputOption.OBFUSCATED) {
        transformer = new JsFunctionClusterer(transformer);
        transformer.exec();
      }
      functionClusterEvent.end();

      jsFragments[i] = transformer.getJs();
      ranges[i] = transformer.getStatementRanges();
      if (sizeBreakdowns != null) {
        sizeBreakdowns[i] = v.getSizeBreakdown();
      }
      if (sourceInfoMaps != null) {
        sourceInfoMaps.add(transformer.getSourceInfoMap());
      }
    }

    generateJavascriptEvent.end();
  }

  private Collection<? extends Artifact<?>> makeSoycArtifacts(int permutationId, String[] js,
      SizeBreakdown[] sizeBreakdowns, List<JsSourceMap> sourceInfoMaps,
      SyntheticArtifact dependencies, JavaToJavaScriptMap jjsmap,
      Map<JsName, JsLiteral> internedLiteralByVariableName,
      ModuleMetricsArtifact moduleMetricsArtifact,
      PrecompilationMetricsArtifact precompilationMetricsArtifact,
      CompilationMetricsArtifact compilationMetrics, boolean htmlReportsDisabled)
      throws IOException, UnableToCompleteException {
    Memory.maybeDumpMemory("makeSoycArtifactsStart");
    List<SyntheticArtifact> soycArtifacts = new ArrayList<SyntheticArtifact>();

    ByteArrayOutputStream baos = new ByteArrayOutputStream();

    Event soycEvent = SpeedTracerLogger.start(CompilerEventType.MAKE_SOYC_ARTIFACTS);

    Event recordSplitPoints = SpeedTracerLogger.start(
        CompilerEventType.MAKE_SOYC_ARTIFACTS, "phase", "recordSplitPoints");
    SplitPointRecorder.recordSplitPoints(jprogram, baos, logger);
    SyntheticArtifact splitPoints = new SyntheticArtifact(
        SoycReportLinker.class, "splitPoints" + permutationId + ".xml.gz", baos.toByteArray());
    soycArtifacts.add(splitPoints);
    recordSplitPoints.end();

    SyntheticArtifact sizeMaps = null;
    if (sizeBreakdowns != null) {
      Event recordSizeMap = SpeedTracerLogger.start(
          CompilerEventType.MAKE_SOYC_ARTIFACTS, "phase", "recordSizeMap");
      baos.reset();
      SizeMapRecorder.recordMap(logger, baos, sizeBreakdowns, jjsmap,
          internedLiteralByVariableName);
      sizeMaps = new SyntheticArtifact(
          SoycReportLinker.class, "stories" + permutationId + ".xml.gz", baos.toByteArray());
      soycArtifacts.add(sizeMaps);
      recordSizeMap.end();
    }

    if (sourceInfoMaps != null) {
      Event recordStories = SpeedTracerLogger.start(
          CompilerEventType.MAKE_SOYC_ARTIFACTS, "phase", "recordStories");
      baos.reset();
      StoryRecorder.recordStories(logger, baos, sourceInfoMaps, js);
      soycArtifacts.add(new SyntheticArtifact(
          SoycReportLinker.class, "detailedStories" + permutationId + ".xml.gz",
          baos.toByteArray()));
      recordStories.end();
    }

    if (dependencies != null) {
      soycArtifacts.add(dependencies);
    }


    for (SyntheticArtifact soycArtifact : soycArtifacts) {
      soycArtifact.setVisibility(Visibility.Private);
    }

    if (!htmlReportsDisabled && sizeBreakdowns != null) {
      Event generateCompileReport = SpeedTracerLogger.start(
          CompilerEventType.MAKE_SOYC_ARTIFACTS, "phase", "generateCompileReport");
      ArtifactsOutputDirectory outDir = new ArtifactsOutputDirectory();
      SoycDashboard dashboard = new SoycDashboard(outDir);
      dashboard.startNewPermutation(Integer.toString(permutationId));
      try {
        dashboard.readSplitPoints(openWithGunzip(splitPoints));
        if (sizeMaps != null) {
          dashboard.readSizeMaps(openWithGunzip(sizeMaps));
        }
        if (dependencies != null) {
          dashboard.readDependencies(openWithGunzip(dependencies));
        }
        Memory.maybeDumpMemory("soycReadDependenciesEnd");
      } catch (ParserConfigurationException e) {
        throw new InternalCompilerException(
            "Error reading compile report information that was just generated", e);
      } catch (SAXException e) {
        throw new InternalCompilerException(
            "Error reading compile report information that was just generated", e);
      }
      dashboard.generateForOnePermutation();
      if (moduleMetricsArtifact != null && precompilationMetricsArtifact != null
          && compilationMetrics != null) {
        dashboard.generateCompilerMetricsForOnePermutation(
            moduleMetricsArtifact, precompilationMetricsArtifact, compilationMetrics);
      }
      soycArtifacts.addAll(outDir.getArtifacts());
      generateCompileReport.end();
    }

    soycEvent.end();

    return soycArtifacts;
  }

  private SymbolData[] makeSymbolMap(Map<StandardSymbolData, JsName> symbolTable) {


    final Set<String> nameUsed = new HashSet<String>();
    final Map<JsName, Integer> nameToFragment = new HashMap<JsName, Integer>();

    for (int i = 0; i < jsProgram.getFragmentCount(); i++) {
      final Integer fragId = i;
      new JsVisitor() {
        @Override
        public void endVisit(JsForIn x, JsContext ctx) {
          if (x.getIterVarName() != null) {
            nameUsed.add(x.getIterVarName().getIdent());
          }
        }

        @Override
        public void endVisit(JsFunction x, JsContext ctx) {
          if (x.getName() != null) {
            nameToFragment.put(x.getName(), fragId);
            nameUsed.add(x.getName().getIdent());
          }
        }

        @Override
        public void endVisit(JsLabel x, JsContext ctx) {
          nameUsed.add(x.getName().getIdent());
        }

        @Override
        public void endVisit(JsNameOf x, JsContext ctx) {
          if (x.getName() != null) {
            nameUsed.add(x.getName().getIdent());
          }
        }

        @Override
        public void endVisit(JsNameRef x, JsContext ctx) {




          if (x.isResolved()) {
            nameUsed.add(x.getName().getIdent());
          }
        }

        @Override
        public void endVisit(JsParameter x, JsContext ctx) {
          nameUsed.add(x.getName().getIdent());
        }

        @Override

        public void endVisit(JsVars.JsVar x, JsContext ctx) {
          nameUsed.add(x.getName().getIdent());
        }
      }.accept(jsProgram.getFragmentBlock(i));
    }





    List<SymbolData> result = new ArrayList<SymbolData>();

    for (Map.Entry<StandardSymbolData, JsName> entry : symbolTable.entrySet()) {
      StandardSymbolData symbolData = entry.getKey();
      symbolData.setSymbolName(entry.getValue().getShortIdent());
      Integer fragNum = nameToFragment.get(entry.getValue());
      if (fragNum != null) {
        symbolData.setFragmentNumber(fragNum);
      }
      if (nameUsed.contains(entry.getValue().getIdent()) || entry.getKey().isClass()) {
        result.add(symbolData);
      }
    }

    return result.toArray(new SymbolData[result.size()]);
  }


  private InputStream openWithGunzip(EmittedArtifact artifact)
      throws IOException, UnableToCompleteException {
    return new BufferedInputStream(new GZIPInputStream(artifact.getContents(TreeLogger.NULL)));
  }

  private void optimizeJsLoop(Collection<JsNode> toInline) throws InterruptedException {
    int optimizationLevel = options.getOptimizationLevel();
    List<OptimizerStats> allOptimizerStats = Lists.newArrayList();
    int counter = 0;
    while (true) {
      counter++;
      if (Thread.interrupted()) {
        throw new InterruptedException();
      }
      Event optimizeJsEvent = SpeedTracerLogger.start(CompilerEventType.OPTIMIZE_JS);

      OptimizerStats stats = new OptimizerStats("Pass " + counter);


      stats.add(JsStaticEval.exec(jsProgram));

      stats.add(JsInliner.exec(jsProgram, toInline));

      stats.add(JsUnusedFunctionRemover.exec(jsProgram));


      allOptimizerStats.add(stats);

      optimizeJsEvent.end();
      if ((optimizationLevel < OptionOptimize.OPTIMIZE_LEVEL_MAX && counter > optimizationLevel)
          || !stats.didChange()) {
        break;
      }
    }

    if (optimizationLevel > OptionOptimize.OPTIMIZE_LEVEL_DRAFT) {
      DuplicateExecuteOnceRemover.exec(jsProgram);
    }
  }

  private Map<JsName, JsLiteral> renameJsSymbols(PermutationProperties properties,
      JavaToJavaScriptMap jjsmap) throws UnableToCompleteException {
    Map<JsName, JsLiteral> internedLiteralByVariableName = null;
    try {
      switch (options.getOutput()) {
        case OBFUSCATED:
          internedLiteralByVariableName = runObfuscateNamer(options, properties, jjsmap);
          break;
        case PRETTY:
          internedLiteralByVariableName = runPrettyNamer(options, properties, jjsmap);
          break;
        case DETAILED:
          internedLiteralByVariableName = runDetailedNamer(properties.getConfigurationProperties());
          break;
        default:
          throw new InternalCompilerException("Unknown output mode");
      }
    } catch (IllegalNameException e) {
      logger.log(TreeLogger.ERROR, e.getMessage(), e);
      throw new UnableToCompleteException();
    }
    return internedLiteralByVariableName == null ?
        ImmutableMap.<JsName, JsLiteral>of() : internedLiteralByVariableName;
  }

  private Map<JsName, JsLiteral> runObfuscateNamer(JJSOptions options,
      PermutationProperties properties, JavaToJavaScriptMap jjsmap)
      throws IllegalNameException {
    if (options.isIncrementalCompileEnabled()) {
      runIncrementalNamer(options, properties.getConfigurationProperties(), jjsmap);
      return null;
    }

    Map<JsName, JsLiteral> internedLiteralByVariableName =
        maybeInternLiterals(JsLiteralInterner.INTERN_ALL);
    FreshNameGenerator freshNameGenerator =
        JsObfuscateNamer.exec(jsProgram, properties.getConfigurationProperties());
    if (options.shouldRemoveDuplicateFunctions()
        && JsStackEmulator.getStackMode(properties) == JsStackEmulator.StackMode.STRIP) {
      JsDuplicateFunctionRemover.exec(jsProgram, freshNameGenerator);
    }
    return internedLiteralByVariableName;
  }

  private Map<JsName, JsLiteral> runPrettyNamer(JJSOptions options,
      PermutationProperties properties, JavaToJavaScriptMap jjsmap)
      throws IllegalNameException {
    if (options.isIncrementalCompileEnabled()) {
      runIncrementalNamer(options, properties.getConfigurationProperties(), jjsmap);
      return null;
    }

    Map<JsName, JsLiteral> internedLiteralByVariableName =
        maybeInternLiterals(JsLiteralInterner.INTERN_ALL & ~JsLiteralInterner.INTERN_STRINGS);

    JsPrettyNamer.exec(jsProgram, properties.getConfigurationProperties());
    return internedLiteralByVariableName;
  }

  private void runIncrementalNamer(JJSOptions options,
      ConfigurationProperties configurationProperties, JavaToJavaScriptMap jjsmap)
    throws IllegalNameException {
    JsIncrementalNamer.exec(jsProgram, configurationProperties,
        compilerContext.getMinimalRebuildCache().getPersistentPrettyNamerState(), jjsmap,
        options.getOutput() == JsOutputOption.OBFUSCATED);
  }


  private UnifiedAst precompile(PrecompilationContext precompilationContext)
      throws UnableToCompleteException {
    try {


      if (precompilationContext.getEntryPoints().length +
          precompilationContext.getAdditionalRootTypes().length == 0) {
        throw new IllegalArgumentException("entry point(s) required");
      }

      boolean singlePermutation = precompilationContext.getPermutations().length == 1;
      PrecompilationMetricsArtifact precompilationMetrics =
          precompilationContext.getPrecompilationMetricsArtifact();



      jprogram = new JProgram(compilerContext.getMinimalRebuildCache());

      jprogram.typeOracle.setOptimize(
          options.getOptimizationLevel() > OptionOptimize.OPTIMIZE_LEVEL_DRAFT);

      jsProgram = new JsProgram();


      CompilationState compilationState =
          constructJavaAst(precompilationContext);


      JsniRestrictionChecker.exec(logger, jprogram);
      JsInteropRestrictionChecker.exec(logger, jprogram, getMinimalRebuildCache());
      logTypeOracleMetrics(precompilationMetrics, compilationState);
      Memory.maybeDumpMemory("AstOnly");
      AstDumper.maybeDumpAST(jprogram);


      ConfigurationProperties configurationProperties = new ConfigurationProperties(module);
      EnumNameObfuscator.exec(jprogram, logger, configurationProperties, options);



      ReplaceDefenderMethodReferences.exec(jprogram);

      FixAssignmentsToUnboxOrCast.exec(jprogram);
      if (options.isEnableAssertions()) {
        AssertionNormalizer.exec(jprogram);
      } else {
        AssertionRemover.exec(jprogram);
      }
      if (module != null && options.isRunAsyncEnabled()) {
        ReplaceRunAsyncs.exec(logger, jprogram);
        ConfigurationProperties config = new ConfigurationProperties(module);
        CodeSplitters.pickInitialLoadSequence(logger, jprogram, config);
      }
      ImplementClassLiteralsAsFields.exec(jprogram, shouldOptimize());


      logAstTypeMetrics(precompilationMetrics);


      Event createUnifiedAstEvent = SpeedTracerLogger.start(CompilerEventType.CREATE_UNIFIED_AST);
      UnifiedAst result = new UnifiedAst(
          options, new AST(jprogram, jsProgram), singlePermutation, RecordRebinds.exec(jprogram));
      createUnifiedAstEvent.end();
      return result;
    } catch (Throwable e) {
      throw CompilationProblemReporter.logAndTranslateException(logger, e);
    }
  }


  private String buildEntryMethodHolder(StandardGeneratorContext context,
      String[] entryPointTypeNames, Set<String> allRootTypes)
      throws UnableToCompleteException {

    if (entryPointTypeNames.length == 0) {

      return null;
    }

    EntryMethodHolderGenerator entryMethodHolderGenerator = new EntryMethodHolderGenerator();
    String entryMethodHolderTypeName =
        entryMethodHolderGenerator.generate(logger, context, module.getCanonicalName());
    context.finish(logger);

    allRootTypes.add(entryMethodHolderTypeName);


    jprogram.addIndexedTypeName(entryMethodHolderTypeName);
    return entryMethodHolderTypeName;
  }

  private CompilationState constructJavaAst(PrecompilationContext precompilationContext)
      throws UnableToCompleteException {
    RebindPermutationOracle rpo = precompilationContext.getRebindPermutationOracle();

    CompilationState compilationState = rpo.getCompilationState();
    Memory.maybeDumpMemory("CompStateBuilt");
    recordJsoTypes(compilationState.getTypeOracle());
    unifyJavaAst(precompilationContext);
    if (options.isSoycEnabled() || options.isJsonSoycEnabled()) {
      SourceInfoCorrelator.exec(jprogram);
    }


    rpo.clear();
    Set<String> deletedTypeNames = options.isIncrementalCompileEnabled()
        ? getMinimalRebuildCache().computeDeletedTypeNames() : Sets.<String>newHashSet();
    jprogram.typeOracle.computeBeforeAST(StandardTypes.createFrom(jprogram),
        jprogram.getDeclaredTypes(), jprogram.getModuleDeclaredTypes(), deletedTypeNames);
    return compilationState;
  }


  private String[] getReferencedJavaClasses() {
    class ClassNameVisitor extends JVisitor {
      List<String> classNames = new ArrayList<String>();

      @Override
      public boolean visit(JClassType x, Context ctx) {
        classNames.add(x.getName());
        return true;
      }
    }
    ClassNameVisitor v = new ClassNameVisitor();
    v.accept(jprogram);
    return v.classNames.toArray(new String[v.classNames.size()]);
  }

  private void logAstTypeMetrics(PrecompilationMetricsArtifact precompilationMetrics) {
    if (options.isCompilerMetricsEnabled()) {
      precompilationMetrics.setAstTypes(getReferencedJavaClasses());
    }
  }

  private void logTypeOracleMetrics(
      PrecompilationMetricsArtifact precompilationMetrics, CompilationState compilationState) {
    if (precompilationMetrics != null) {
      List<String> finalTypeOracleTypes = Lists.newArrayList();
      for (com.google.gwt.core.ext.typeinfo.JClassType type :
          compilationState.getTypeOracle().getTypes()) {
        finalTypeOracleTypes.add(type.getPackage().getName() + "." + type.getName());
      }
      precompilationMetrics.setFinalTypeOracleTypes(finalTypeOracleTypes);
    }
  }

  private Set<String> computeRootTypes(String[] entryPointTypeNames,
      String[] additionalRootTypes, CompilationState compilationState) {

    Set<String> allRootTypes = Sets.newTreeSet();
    Iterables.addAll(allRootTypes, compilationState.getQualifiedJsInteropRootTypesNames());
    Collections.addAll(allRootTypes, entryPointTypeNames);
    Collections.addAll(allRootTypes, additionalRootTypes);
    allRootTypes.addAll(JProgram.CODEGEN_TYPES_SET);
    allRootTypes.addAll(jprogram.getTypeNamesToIndex());

    TypeOracle typeOracle = compilationState.getTypeOracle();
    for (com.google.gwt.core.ext.typeinfo.JClassType singleJsoIntf :
        typeOracle.getSingleJsoImplInterfaces()) {
      allRootTypes.add(typeOracle.getSingleJsoImpl(singleJsoIntf).getQualifiedSourceName());
    }
    return allRootTypes;
  }

  private void recordJsoTypes(TypeOracle typeOracle) {
    if (!options.isIncrementalCompileEnabled()) {
      return;
    }


    Set<String> jsoTypeNames = Sets.newHashSet();
    for (com.google.gwt.dev.javac.typemodel.JClassType subtype :
        typeOracle.getJavaScriptObject().getSubtypes()) {
      jsoTypeNames.add(subtype.getQualifiedBinaryName());
    }


    Set<String> singleJsoImplInterfaceNames = Sets.newHashSet();
    for (com.google.gwt.core.ext.typeinfo.JClassType singleJsoImplInterface :
        typeOracle.getSingleJsoImplInterfaces()) {
      singleJsoImplInterfaceNames.add(singleJsoImplInterface.getQualifiedBinaryName());
    }



    Set<String> dualJsoImplInterfaceNames = Sets.newHashSet();
    for (com.google.gwt.core.ext.typeinfo.JClassType dualJsoImplInterface :
        typeOracle.getDualJsoImplInterfaces()) {
      dualJsoImplInterfaceNames.add(dualJsoImplInterface.getQualifiedBinaryName());
    }

    compilerContext.getMinimalRebuildCache().setJsoTypeNames(jsoTypeNames,
        singleJsoImplInterfaceNames, dualJsoImplInterfaceNames);
  }

  private void synthesizeEntryMethodHolderInit(UnifyAst unifyAst, String[] entryPointTypeNames,
      String entryMethodHolderTypeName) throws UnableToCompleteException {

    JDeclaredType entryMethodHolderType =
        unifyAst.findType(entryMethodHolderTypeName, unifyAst.getSourceNameBasedTypeLocator());
    JDeclaredType gwtType = unifyAst.findType("com.google.gwt.core.client.GWT",
        unifyAst.getSourceNameBasedTypeLocator());
    JDeclaredType entryPointType = unifyAst.findType("com.google.gwt.core.client.EntryPoint",
        unifyAst.getSourceNameBasedTypeLocator());


    JMethod initMethod = entryMethodHolderType.findMethod("init()V", false);
    JMethod gwtCreateMethod =
        gwtType.findMethod("create(Ljava/lang/Class;)Ljava/lang/Object;", false);


    JBlock initMethodBlock = ((JMethodBody) initMethod.getBody()).getBlock();
    SourceInfo origin = initMethodBlock.getSourceInfo().makeChild();
    for (String entryPointTypeName : entryPointTypeNames) {

      JDeclaredType specificEntryPointType =
          unifyAst.findType(entryPointTypeName, unifyAst.getSourceNameBasedTypeLocator());
      if (specificEntryPointType == null) {
        logger.log(TreeLogger.ERROR,
            "Could not find module entry point class '" + entryPointTypeName + "'", null);
        throw new UnableToCompleteException();
      }
      JMethod onModuleLoadMethod =
          entryPointType.findMethod("onModuleLoad()V", true);
      JMethod specificOnModuleLoadMethod =
          specificEntryPointType.findMethod("onModuleLoad()V", true);

      if (specificOnModuleLoadMethod != null && specificOnModuleLoadMethod.isStatic()) {

        JMethodCall staticOnModuleLoadCall =
            new JMethodCall(origin, null, specificOnModuleLoadMethod);
        initMethodBlock.addStmt(staticOnModuleLoadCall.makeStatement());
      } else {

        JClassLiteral entryPointTypeClassLiteral =
            new JClassLiteral(origin, specificEntryPointType);
        JMethodCall createInstanceCall =
            new JMethodCall(origin, null, gwtCreateMethod, entryPointTypeClassLiteral);
        JCastOperation castToEntryPoint =
            new JCastOperation(origin, entryPointType, createInstanceCall);
        JMethodCall instanceOnModuleLoadCall =
            new JMethodCall(origin, castToEntryPoint, onModuleLoadMethod);
        initMethodBlock.addStmt(instanceOnModuleLoadCall.makeStatement());
      }
    }
  }

  private void unifyJavaAst(PrecompilationContext precompilationContext)
      throws UnableToCompleteException {

    Event event = SpeedTracerLogger.start(CompilerEventType.UNIFY_AST);

    RebindPermutationOracle rpo = precompilationContext.getRebindPermutationOracle();
    String[] entryPointTypeNames = precompilationContext.getEntryPoints();
    String[] additionalRootTypes = precompilationContext.getAdditionalRootTypes();

    Set<String> allRootTypes = computeRootTypes(entryPointTypeNames, additionalRootTypes,
        rpo.getCompilationState());

    String entryMethodHolderTypeName =
        buildEntryMethodHolder(rpo.getGeneratorContext(), entryPointTypeNames, allRootTypes);

    UnifyAst unifyAst =
        new UnifyAst(logger, compilerContext, jprogram, jsProgram, precompilationContext);

    unifyAst.addRootTypes(allRootTypes);


    if (entryMethodHolderTypeName != null) {


      synthesizeEntryMethodHolderInit(unifyAst, entryPointTypeNames, entryMethodHolderTypeName);
    }
    if (entryMethodHolderTypeName != null) {


      jprogram.addEntryMethod(jprogram.getIndexedMethod(
          SourceName.getShortClassName(entryMethodHolderTypeName) + ".init"));
    }
    unifyAst.exec();

    event.end();
  }

  private void optimizeJavaToFixedPoint() throws InterruptedException {
    Event optimizeEvent = SpeedTracerLogger.start(CompilerEventType.OPTIMIZE);

    List<OptimizerStats> allOptimizerStats = Lists.newArrayList();
    int passCount = 0;
    int nodeCount = jprogram.getNodeCount();
    int lastNodeCount;

    boolean atMaxLevel = options.getOptimizationLevel() == OptionOptimize.OPTIMIZE_LEVEL_MAX;
    int passLimit = atMaxLevel ? MAX_PASSES : options.getOptimizationLevel();
    float minChangeRate = atMaxLevel ? FIXED_POINT_CHANGE_RATE : EFFICIENT_CHANGE_RATE;
    OptimizerContext optimizerCtx = new FullOptimizerContext(jprogram);
    while (true) {
      passCount++;
      if (passCount > passLimit) {
        break;
      }
      if (Thread.interrupted()) {
        optimizeEvent.end();
        throw new InterruptedException();
      }
      AstDumper.maybeDumpAST(jprogram);
      OptimizerStats stats = optimizeJavaOneTime("Pass " + passCount, nodeCount, optimizerCtx);
      allOptimizerStats.add(stats);
      lastNodeCount = nodeCount;
      nodeCount = jprogram.getNodeCount();

      float nodeChangeRate = stats.getNumMods() / (float) lastNodeCount;
      float sizeChangeRate = (lastNodeCount - nodeCount) / (float) lastNodeCount;
      if (nodeChangeRate <= minChangeRate && sizeChangeRate <= minChangeRate) {
        break;
      }
    }

    if (options.shouldOptimizeDataflow()) {

      allOptimizerStats.add(DataflowOptimizer.exec(jprogram));
    }

    optimizeEvent.end();
  }

  private boolean shouldOptimize() {
    return options.getOptimizationLevel() > OptionOptimize.OPTIMIZE_LEVEL_DRAFT;
  }

  private TypeMapper getTypeMapper() {


    if (JjsUtils.closureStyleLiteralsNeeded(this.options)) {
      return new ClosureUniqueIdTypeMapper(jprogram);
    }

    if (this.options.useDetailedTypeIds()) {
      return new StringTypeMapper();
    }
    return this.options.isIncrementalCompileEnabled() ?
        compilerContext.getMinimalRebuildCache().getTypeMapper() :
        new IntTypeMapper();
  }

  private TypeOrder getTypeOrder() {


    if (JjsUtils.closureStyleLiteralsNeeded(this.options)) {
      return TypeOrder.ALPHABETICAL;
    }

    if (this.options.useDetailedTypeIds()) {
      return TypeOrder.NONE;
    }
    return this.options.isIncrementalCompileEnabled() ? TypeOrder.ALPHABETICAL
        : TypeOrder.FREQUENCY;
  }

  private OptimizerStats optimizeJavaOneTime(String passName, int numNodes,
      OptimizerContext optimizerCtx) {
    Event optimizeEvent = SpeedTracerLogger.start(CompilerEventType.OPTIMIZE, "phase", "loop");

    jprogram.typeOracle.recomputeAfterOptimizations(jprogram.getDeclaredTypes());
    OptimizerStats stats = new OptimizerStats(passName);
    JavaAstVerifier.assertProgramIsConsistent(jprogram);
    stats.add(Pruner.exec(jprogram, true, optimizerCtx).recordVisits(numNodes));
    stats.add(Finalizer.exec(jprogram, optimizerCtx).recordVisits(numNodes));
    stats.add(MakeCallsStatic.exec(jprogram, options.shouldAddRuntimeChecks(), optimizerCtx)
        .recordVisits(numNodes));
    stats.add(TypeTightener.exec(jprogram, optimizerCtx).recordVisits(numNodes));
    stats.add(MethodCallTightener.exec(jprogram, optimizerCtx).recordVisits(numNodes));

    stats.add(MethodCallSpecializer.exec(jprogram, optimizerCtx).recordVisits(numNodes));
    stats.add(DeadCodeElimination.exec(jprogram, optimizerCtx).recordVisits(numNodes));
    stats.add(MethodInliner.exec(jprogram, optimizerCtx).recordVisits(numNodes));
    if (options.shouldInlineLiteralParameters()) {
      stats.add(SameParameterValueOptimizer.exec(jprogram, optimizerCtx).recordVisits(numNodes));
    }
    if (options.shouldOrdinalizeEnums()) {
      stats.add(EnumOrdinalizer.exec(jprogram, optimizerCtx).recordVisits(numNodes));
    }
    optimizeEvent.end();
    return stats;
  }

  private MinimalRebuildCache getMinimalRebuildCache() {
    return compilerContext.getMinimalRebuildCache();
  }

  private static class PermutationResultImpl implements PermutationResult {

    private final ArtifactSet artifacts = new ArtifactSet();
    private final byte[][] js;
    private final String jsStrongName;
    private final Permutation permutation;
    private final byte[] serializedSymbolMap;
    private final StatementRanges[] statementRanges;

    public PermutationResultImpl(String[] jsFragments, Permutation permutation,
        SymbolData[] symbolMap, StatementRanges[] statementRanges) {
      byte[][] bytes = new byte[jsFragments.length][];
      for (int i = 0; i < jsFragments.length; ++i) {
        bytes[i] = Util.getBytes(jsFragments[i]);
      }
      this.js = bytes;
      this.jsStrongName = Util.computeStrongName(bytes);
      this.permutation = permutation;
      try {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        Util.writeObjectToStream(baos, (Object) symbolMap);
        this.serializedSymbolMap = baos.toByteArray();
      } catch (IOException e) {
        throw new RuntimeException("Should never happen with in-memory stream", e);
      }
      this.statementRanges = statementRanges;
    }

    @Override
    public void addArtifacts(Collection<? extends Artifact<?>> newArtifacts) {
      this.artifacts.addAll(newArtifacts);
    }

    @Override
    public ArtifactSet getArtifacts() {
      return artifacts;
    }

    @Override
    public byte[][] getJs() {
      return js;
    }

    @Override
    public String getJsStrongName() {
      return jsStrongName;
    }

    @Override
    public Permutation getPermutation() {
      return permutation;
    }

    @Override
    public byte[] getSerializedSymbolMap() {
      return serializedSymbolMap;
    }

    @Override
    public StatementRanges[] getStatementRanges() {
      return statementRanges;
    }
  }
}

<code block>

package com.google.gwt.dev.jjs.ast;

import com.google.gwt.dev.MinimalRebuildCache;
import com.google.gwt.dev.jjs.ast.js.JMultiExpression;
import com.google.gwt.thirdparty.guava.common.annotations.VisibleForTesting;
import com.google.gwt.thirdparty.guava.common.base.Function;
import com.google.gwt.thirdparty.guava.common.base.Objects;
import com.google.gwt.thirdparty.guava.common.base.Predicate;
import com.google.gwt.thirdparty.guava.common.base.Strings;
import com.google.gwt.thirdparty.guava.common.collect.HashMultimap;
import com.google.gwt.thirdparty.guava.common.collect.ImmutableList;
import com.google.gwt.thirdparty.guava.common.collect.ImmutableSetMultimap;
import com.google.gwt.thirdparty.guava.common.collect.Iterables;
import com.google.gwt.thirdparty.guava.common.collect.Lists;
import com.google.gwt.thirdparty.guava.common.collect.Maps;
import com.google.gwt.thirdparty.guava.common.collect.Multimap;
import com.google.gwt.thirdparty.guava.common.collect.Multimaps;
import com.google.gwt.thirdparty.guava.common.collect.Sets;

import java.io.Serializable;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;



public class JTypeOracle implements Serializable {

  public static final Function<JType,String> TYPE_TO_NAME = new Function<JType, String>() {
    @Override
    public String apply(JType type) {
      return type.getName();
    }
  };


  public static class ImmediateTypeRelations implements Serializable {


    private Map<String, String> immediateSuperclassesByClass = Maps.newHashMap();


    private Multimap<String, String> immediateSuperInterfacesByInterface = HashMultimap.create();


    private Multimap<String, String> immediateImplementedInterfacesByClass =
        HashMultimap.create();

    public void copyFrom(ImmediateTypeRelations that) {
      this.immediateImplementedInterfacesByClass.clear();
      this.immediateSuperclassesByClass.clear();
      this.immediateSuperInterfacesByInterface.clear();

      this.immediateImplementedInterfacesByClass.putAll(that.immediateImplementedInterfacesByClass);
      this.immediateSuperclassesByClass.putAll(that.immediateSuperclassesByClass);
      this.immediateSuperInterfacesByInterface.putAll(that.immediateSuperInterfacesByInterface);
    }

    @VisibleForTesting
    public boolean hasSameContent(ImmediateTypeRelations that) {
      return Objects.equal(this.immediateImplementedInterfacesByClass,
          that.immediateImplementedInterfacesByClass)
          && Objects.equal(this.immediateSuperclassesByClass, that.immediateSuperclassesByClass)
          && Objects.equal(this.immediateSuperInterfacesByInterface,
              that.immediateSuperInterfacesByInterface);
    }

    @VisibleForTesting
    public Map<String, String> getImmediateSuperclassesByClass() {
      return immediateSuperclassesByClass;
    }

    public boolean isEmpty() {
      return immediateSuperclassesByClass.isEmpty() && immediateSuperInterfacesByInterface.isEmpty()
          && immediateImplementedInterfacesByClass.isEmpty();
    }
  }


  public static class StandardTypes implements Serializable {

    public static StandardTypes createFrom(JProgram program) {
      StandardTypes requiredTypes = new StandardTypes();
      requiredTypes.javaLangObject = program.getTypeJavaLangObject().getName();
      JDeclaredType javaIoSerializableType = program.getFromTypeMap(Serializable.class.getName());
      requiredTypes.javaIoSerializable =
          javaIoSerializableType == null ? null : javaIoSerializableType.getName();
      JDeclaredType javaLangConeableType = program.getFromTypeMap(Cloneable.class.getName());
      requiredTypes.javaLangCloneable =
          javaLangConeableType == null ? null : javaLangConeableType.getName();
      return requiredTypes;
    }

    private String javaIoSerializable;

    private String javaLangCloneable;

    private String javaLangObject;
  }

  private Set<JReferenceType> instantiatedJsoTypesViaCast = Sets.newHashSet();

  public void setInstantiatedJsoTypesViaCast(Set<JReferenceType> instantiatedJsoTypesViaCast) {
    this.instantiatedJsoTypesViaCast = instantiatedJsoTypesViaCast;
  }

  public Set<JReferenceType> getInstantiatedJsoTypesViaCast() {
    return instantiatedJsoTypesViaCast;
  }


  public boolean needsJsInteropBridgeMethod(JMethod x) {


    List<JParameter> xParams = x.getParams();
    if (x.isOrOverridesJsTypeMethod()) {
      for (JMethod other : x.getEnclosingType().getMethods()) {
         if (other == x) {
           continue;
         }
        if (other.isOrOverridesJsTypeMethod() && x.getName().equals(other.getName())) {
           List<JParameter> otherParams = other.getParams();
           if (otherParams.size() == xParams.size()) {
             for (int i = 0; i < otherParams.size(); i++) {
               if (otherParams.get(i).getType() != xParams.get(i).getType()) {
                 break;
               }
             }

             return true;
           } else {
             break;
           }
         }
      }
    }

    if (x.needsVtable() && x.isOrOverridesJsTypeMethod()) {
      for (JMethod override : x.getOverriddenMethods()) {
        if (!override.isOrOverridesJsTypeMethod()) {
          return true;
        }
      }
    }


    if (x.isOrOverridesJsTypeMethod() || x.isExported()) {
      if (x.getOriginalReturnType() == JPrimitiveType.LONG) {
        return true;
      }
      for (JParameter p : xParams) {
        if (p.getType() == JPrimitiveType.LONG) {
          return true;
        }
      }
    }

    return false;
  }

  public void setOptimize(boolean optimize) {
    this.optimize = optimize;
  }


  private static final class CheckClinitVisitor extends JVisitor {

    private final Set<JDeclaredType> clinitTargets = Sets.newIdentityHashSet();


    private boolean hasLiveCode = false;

    public JDeclaredType[] getClinitTargets() {
      return clinitTargets.toArray(new JDeclaredType[clinitTargets.size()]);
    }

    public boolean hasLiveCode() {
      return hasLiveCode;
    }

    @Override
    public boolean visit(JBlock x, Context ctx) {
      for (JStatement stmt : x.getStatements()) {
        if (mightContainOnlyClinitCallsOrDeclarationStatements(stmt)) {
          accept(stmt);
        } else {
          hasLiveCode = true;
        }
      }
      return false;
    }

    @Override
    public boolean visit(JDeclarationStatement x, Context ctx) {
      JVariable target = x.getVariableRef().getTarget();
      if (target instanceof JField) {
        JField field = (JField) target;

        if (field.getLiteralInitializer() != null && field.isStatic()) {



          return false;
        }
      }
      hasLiveCode = true;
      return false;
    }

    @Override
    public boolean visit(JExpressionStatement x, Context ctx) {
      JExpression expr = x.getExpr();
      if (mightContainOnlyClinitCalls(expr)) {
        accept(expr);
      } else {
        hasLiveCode = true;
      }
      return false;
    }

    @Override
    public boolean visit(JMethodCall x, Context ctx) {
      JMethod target = x.getTarget();
      if (JProgram.isClinit(target)) {
        clinitTargets.add(target.getEnclosingType());
      } else {
        hasLiveCode = true;
      }
      return false;
    }

    @Override
    public boolean visit(JMultiExpression x, Context ctx) {
      for (JExpression expr : x.getExpressions()) {

        if (mightContainOnlyClinitCalls(expr)) {
          accept(expr);
        } else {
          hasLiveCode = true;
        }
      }
      return false;
    }

    private boolean mightContainOnlyClinitCalls(JExpression expr) {

      return expr instanceof JMultiExpression || expr instanceof JMethodCall;
    }

    private boolean mightContainOnlyClinitCallsOrDeclarationStatements(JStatement stmt) {

      return stmt instanceof JBlock || stmt instanceof JExpressionStatement
          || stmt instanceof JDeclarationStatement;
    }
  }


  public static boolean methodsDoMatch(JMethod method1, JMethod method2) {

    if (method1.isStatic() || method2.isStatic()) {
      return false;
    }


    if (!method1.getName().equals(method2.getName())) {
      return false;
    }


    if (method1.getOriginalReturnType() != method2.getOriginalReturnType()) {
      return false;
    }


    List<JType> params1 = method1.getOriginalParamTypes();
    List<JType> params2 = method2.getOriginalParamTypes();
    int params1size = params1.size();
    if (params1size != params2.size()) {
      return false;
    }

    for (int i = 0; i < params1size; ++i) {
      if (params1.get(i) != params2.get(i)) {
        return false;
      }
    }
    return true;
  }


  private Set<String> allClasses = Sets.newHashSet();


  private Multimap<String, String> potentialInterfaceByClass;


  private final Set<String> dualImplInterfaces = Sets.newHashSet();


  private Multimap<String, String> implementedInterfacesByClass;


  private Set<JReferenceType> instantiatedTypes = null;


  private Multimap<String, String> classesByImplementingInterface;


  private final Map<String, String> jsoByInterface = Maps.newHashMap();


  private Map<String, JReferenceType> referenceTypesByName = Maps.newHashMap();


  private Multimap<String, String> subclassesByClass;


  private Multimap<String, String> subInterfacesByInterface;


  private Multimap<String, String> superclassesByClass;


  private Multimap<String, String> superInterfacesByInterface;


  private final Map<JClassType, Map<String, JMethod>> methodsBySignatureForType =
      Maps.newIdentityHashMap();

  private boolean optimize = true;

  private ImmediateTypeRelations immediateTypeRelations;
  private ArrayTypeCreator arrayTypeCreator;
  private StandardTypes standardTypes;


  public JTypeOracle(ArrayTypeCreator arrayTypeCreator, MinimalRebuildCache minimalRebuildCache) {
    this.immediateTypeRelations = minimalRebuildCache.getImmediateTypeRelations();
    this.arrayTypeCreator = arrayTypeCreator;


    computeExtendedTypeRelations();
  }


  public boolean canBeJavaScriptObject(JType type) {
    type = type.getUnderlyingType();
    return type.isJsoType() || isSingleJsoImpl(type);
  }


  public boolean canCrossCastLikeJso(JType type) {
    JDeclaredType dtype = getNearestJsType(type, false);
    return canBeJavaScriptObject(type) || (dtype instanceof JInterfaceType
        && isOrExtendsJsType(type, false) && !isOrExtendsJsType(type, true));
  }


  public boolean willCrossCastLikeJso(JType type) {
    return isEffectivelyJavaScriptObject(type) || canCrossCastLikeJso(type)
        && type instanceof JInterfaceType && !hasLiveImplementors(type);
  }

  public boolean hasLiveImplementors(JType type) {
    if (!optimize) {

      return true;
    }
    if (type instanceof JInterfaceType) {
      for (JReferenceType impl : getTypes(classesByImplementingInterface.get(type.getName()))) {
        if (isInstantiatedType((JClassType) impl)) {
          return true;
        }
      }
    }
    return false;
  }


  public boolean canBeInstantiatedInJavascript(JType type) {
    return canBeJavaScriptObject(type) || isJsType(type) || isJsFunction(type);
  }

  public boolean castFailsTrivially(JReferenceType fromType, JReferenceType toType) {
    if (!fromType.canBeNull() && toType.isNullType()) {

      return true;
    }

    if (!fromType.canBeSubclass() && fromType.getUnderlyingType() instanceof JClassType &&
        fromType.getUnderlyingType() != toType.getUnderlyingType() &&
        !isSuperClass(fromType, toType) && !implementsInterface(fromType, toType)) {

      return true;
    }


    fromType = fromType.getUnderlyingType();
    toType = toType.getUnderlyingType();

    if (fromType == toType || isJavaLangObject(fromType)) {
      return false;
    }


    if (canCrossCastLikeJso(fromType) && canCrossCastLikeJso(toType)) {
      return false;
    }


    if (castSucceedsTrivially(fromType, toType)) {
      return false;
    }

    if (fromType instanceof JArrayType) {

      JArrayType fromArrayType = (JArrayType) fromType;
      if (toType instanceof JArrayType) {
        JArrayType toArrayType = (JArrayType) toType;
        JType fromLeafType = fromArrayType.getLeafType();
        JType toLeafType = toArrayType.getLeafType();
        int fromDims = fromArrayType.getDims();
        int toDims = toArrayType.getDims();


        if (fromDims < toDims && !isJavaLangObject(fromLeafType)
            && !fromLeafType.isNullType()) {
          return true;
        }

        if (fromDims == toDims &&
          fromLeafType instanceof JReferenceType && toLeafType instanceof JReferenceType) {
          return castFailsTrivially((JReferenceType) fromLeafType, (JReferenceType) toLeafType);
        }
      }


    } else if (fromType instanceof JClassType) {

      JClassType cType = (JClassType) fromType;
      if (toType instanceof JClassType) {
        return !isSubClass(cType, (JClassType) toType);
      } else if (toType instanceof JInterfaceType) {
        return !potentialInterfaceByClass.containsEntry(cType.getName(), toType.getName());
      }
    } else if (fromType instanceof JInterfaceType) {

      JInterfaceType fromInterfaceType = (JInterfaceType) fromType;
      if (toType instanceof JClassType) {
        return !potentialInterfaceByClass.containsEntry(
            toType.getName(), fromInterfaceType.getName());
      }
    }

    return false;
  }

  public boolean castSucceedsTrivially(JReferenceType fromType, JReferenceType toType) {
    if (fromType.canBeNull() && !toType.canBeNull()) {

      return false;
    }

    if (fromType.isNullType()) {
      assert toType.canBeNull();

      return true;
    }

    if (toType.weakenToNullable() == fromType.weakenToNullable()) {

      return true;
    }

    if (!toType.canBeSubclass()) {
      return false;
    }


    fromType = fromType.getUnderlyingType();
    toType = toType.getUnderlyingType();

    if (fromType == toType) {
      return true;
    }

    if (isJavaLangObject(toType)) {
      return true;
    }

    if (fromType instanceof JArrayType) {
      return castSucceedsTrivially((JArrayType) fromType, toType);
    }

    if (fromType instanceof JClassType) {
      return castSucceedsTrivially((JClassType) fromType, toType);
    }

    if (fromType instanceof JInterfaceType && toType instanceof JInterfaceType) {
       return extendsInterface((JInterfaceType) fromType, (JInterfaceType) toType);
    }

    return false;
  }

  private boolean castSucceedsTrivially(JClassType fromType, JReferenceType toType) {
    if (toType instanceof JClassType) {
      return isSuperClass(fromType, toType);
    }
    if (toType instanceof JInterfaceType) {
      return implementsInterface(fromType, toType);
    }
    return false;
  }

  private boolean castSucceedsTrivially(JArrayType fromArrayType, JReferenceType toType) {



    assert !isJavaLangObject(toType);

    if (isArrayInterface(toType)) {
      return true;
    }

    if (!(toType instanceof JArrayType)) {
      return false;
    }

    JArrayType toArrayType = (JArrayType) toType;
    JType fromLeafType = fromArrayType.getLeafType();
    JType toLeafType = toArrayType.getLeafType();
    int fromDims = fromArrayType.getDims();
    int toDims = toArrayType.getDims();


    if (fromDims > toDims
        && (isJavaLangObject(toLeafType)
        || isArrayInterface(toLeafType)
        || toLeafType.isNullType())) {
      return true;
    }

    if (fromDims != toDims) {
      return false;
    }


    if (fromLeafType instanceof JReferenceType && toLeafType instanceof JReferenceType) {
      return castSucceedsTrivially((JReferenceType) fromLeafType, (JReferenceType) toLeafType);
    }

    return false;
  }

  public boolean castSucceedsTrivially(JType fromType, JType toType) {
    if (fromType instanceof JPrimitiveType && toType instanceof JPrimitiveType) {
      return fromType == toType;
    }
    if (fromType instanceof JReferenceType && toType instanceof JReferenceType) {
      return castSucceedsTrivially((JReferenceType) fromType, (JReferenceType) toType);
    }
    return false;
  }

  public void computeBeforeAST(StandardTypes standardTypes, Collection<JDeclaredType> declaredTypes,
      List<JDeclaredType> moduleDeclaredTypes) {
    computeBeforeAST(standardTypes, declaredTypes, moduleDeclaredTypes,
        ImmutableList.<String> of());
  }

  public void computeBeforeAST(StandardTypes standardTypes, Collection<JDeclaredType> declaredTypes,
      Collection<JDeclaredType> moduleDeclaredTypes, Collection<String> deletedTypeNames) {
    this.standardTypes = standardTypes;
    recordReferenceTypeByName(declaredTypes);
    deleteImmediateTypeRelations(deletedTypeNames);
    deleteImmediateTypeRelations(getNamesOf(moduleDeclaredTypes));
    recordImmediateTypeRelations(moduleDeclaredTypes);
    computeExtendedTypeRelations();
  }

  private static Collection<String> getNamesOf(Collection<JDeclaredType> types) {
    List<String> typeNames = Lists.newArrayList();
    for (JDeclaredType type : types) {
      typeNames.add(type.getName());
    }
    return typeNames;
  }

  private void recordReferenceTypeByName(Collection<JDeclaredType> types) {
    referenceTypesByName.clear();
    for (JReferenceType type : types) {
      referenceTypesByName.put(type.getName(), type);
    }
  }


  public JDeclaredType getNearestJsType(JType type, boolean mustHavePrototype) {
    type = type.getUnderlyingType();

    if (!(type instanceof JDeclaredType)) {
      return null;
    }

    JDeclaredType dtype = (JDeclaredType) type;
    if (dtype.isJsType() && (!mustHavePrototype || !Strings.isNullOrEmpty(dtype.getJsPrototype()))) {
      return dtype;
    }

    for (JInterfaceType superIntf : dtype.getImplements()) {
      JDeclaredType jsIntf = getNearestJsType(superIntf, mustHavePrototype);
      if (jsIntf != null) {
        return jsIntf;
      }
    }

    return null;
  }


  public JMethod getJsFunctionMethod(JClassType type) {
    for (JMethod method : type.getMethods()) {
      if (method.isOrOverridesJsFunctionMethod()) {
        return method;
      }
    }
    return (type.getSuperClass() != null) ? getJsFunctionMethod(type.getSuperClass()) : null;
  }

  public JMethod getInstanceMethodBySignature(JClassType type, String signature) {
    return getOrCreateInstanceMethodsBySignatureForType(type).get(signature);
  }

  public JMethod findMostSpecificOverride(JClassType type, JMethod baseMethod) {
    JMethod foundMethod = getInstanceMethodBySignature(type, baseMethod.getSignature());
    if (foundMethod == baseMethod) {
      return foundMethod;
    }



    if (foundMethod != null && foundMethod.getOverriddenMethods().contains(baseMethod)) {
      return foundMethod;
    }



    if (foundMethod != null && baseMethod.isPackagePrivate() &&
        type.getSuperClass() != null) {
      return findMostSpecificOverride(type.getSuperClass(), baseMethod);
    }

    assert baseMethod.isAbstract();
    return baseMethod;
  }

  public JClassType getSingleJsoImpl(JReferenceType maybeSingleJsoIntf) {
    String className = jsoByInterface.get(maybeSingleJsoIntf.getName());
    if (className == null) {
      return null;
    }
    return (JClassType) referenceTypesByName.get(className);
  }

  public String getSuperTypeName(String className) {
    return immediateTypeRelations.immediateSuperclassesByClass.get(className);
  }

  public Set<JReferenceType> getCastableDestinationTypes(JReferenceType type) {

    if (type instanceof JArrayType) {
      JArrayType arrayType = (JArrayType) type;
      List<JReferenceType> castableDestinationTypes = Lists.newArrayList();


      ImmutableList<JReferenceType> arrayBaseTypes = ImmutableList.of(
          ensureTypeExistsAndAppend(standardTypes.javaLangObject, castableDestinationTypes),
          ensureTypeExistsAndAppend(standardTypes.javaIoSerializable, castableDestinationTypes),
          ensureTypeExistsAndAppend(standardTypes.javaLangCloneable, castableDestinationTypes));


      for (int lowerDimension = 1; lowerDimension < arrayType.getDims(); lowerDimension++) {
        for (JReferenceType arrayBaseType : arrayBaseTypes) {
          castableDestinationTypes.add(
              arrayTypeCreator.getOrCreateArrayType(arrayBaseType, lowerDimension));
        }
      }

      if (arrayType.getLeafType() instanceof JPrimitiveType) {
        castableDestinationTypes.add(arrayType);
      } else {

        JDeclaredType leafType = (JDeclaredType) arrayType.getLeafType();
        for (JReferenceType castableDestinationType : getCastableDestinationTypes(leafType)) {
          JArrayType superArrayType =
              arrayTypeCreator.getOrCreateArrayType(castableDestinationType, arrayType.getDims());
          castableDestinationTypes.add(superArrayType);
        }
      }
      Collections.sort(castableDestinationTypes, HasName.BY_NAME_COMPARATOR);
      return Sets.newLinkedHashSet(castableDestinationTypes);
    }

    List<JReferenceType> castableDestinationTypes = Lists.newArrayList();
    if (superclassesByClass.containsKey(type.getName())) {
      Iterables.addAll(castableDestinationTypes,
          getTypes(superclassesByClass.get(type.getName())));
    }
    if (superInterfacesByInterface.containsKey(type.getName())) {
      Iterables.addAll(castableDestinationTypes,
          getTypes(superInterfacesByInterface.get(type.getName())));
    }
    if (implementedInterfacesByClass.containsKey(type.getName())) {
      Iterables.addAll(castableDestinationTypes,
          getTypes(implementedInterfacesByClass.get(type.getName())));
    }
    if (willCrossCastLikeJso(type)) {
      ensureTypeExistsAndAppend(JProgram.JAVASCRIPTOBJECT, castableDestinationTypes);
    }

    if (type.isJsoType()) {
      ensureTypeExistsAndAppend(JProgram.JAVASCRIPTOBJECT, castableDestinationTypes);
    } else {
      castableDestinationTypes.add(type);
    }



    JReferenceType javaLangObjectType = referenceTypesByName.get(standardTypes.javaLangObject);

    assert javaLangObjectType != null;
    castableDestinationTypes.add(javaLangObjectType);

    Collections.sort(castableDestinationTypes, HasName.BY_NAME_COMPARATOR);
    return Sets.newLinkedHashSet(castableDestinationTypes);
  }

  public boolean isDualJsoInterface(JType maybeDualImpl) {
    return dualImplInterfaces.contains(maybeDualImpl.getName());
  }


  public JMethod getTopMostDefinition(JMethod method) {
    if (method.getEnclosingType() instanceof JInterfaceType) {
      return null;
    }
    JMethod currentMethod = method;
    for (JMethod overriddenMethod : method.getOverriddenMethods()) {
      if (overriddenMethod.getEnclosingType() instanceof JInterfaceType) {
        continue;
      }
      if (isSuperClass(currentMethod.getEnclosingType(), overriddenMethod.getEnclosingType())) {
        currentMethod = overriddenMethod;
      }
    }
    return currentMethod;
  }


  public boolean isEffectivelyJavaScriptObject(JType type) {
    return type.isJsoType() || (isSingleJsoImpl(type) && !isDualJsoInterface(type));
  }





  private boolean isJavaScriptObject(String typeName) {
    if (typeName.equals(JProgram.JAVASCRIPTOBJECT)) {
      return true;
    }
    return isSuperClass(typeName, JProgram.JAVASCRIPTOBJECT);
  }


  public boolean isInstantiatedType(JDeclaredType type) {
    return instantiatedTypes == null || instantiatedTypes.contains(type);
  }


  public boolean isInstantiatedType(JReferenceType type) {
    type = type.getUnderlyingType();

    if (instantiatedTypes == null || instantiatedTypes.contains(type)) {
      return true;
    }

    if (type.isExternal()) {








      return true;
    }

    if (type.isNullType()) {
      return true;
    } else if (type instanceof JArrayType) {
      JArrayType arrayType = (JArrayType) type;
      if (arrayType.getLeafType().isNullType()) {
        return true;
      }
    }



    return isJsType(type) || hasAnyExports(type) || isJsFunction(type);
  }

  private boolean hasAnyExports(JReferenceType type) {
    return type instanceof JDeclaredType ? ((JDeclaredType) type).hasAnyExports() : false;
  }

  private boolean isArrayInterface(JType type) {
    return type.getName().equals(standardTypes.javaIoSerializable)
        || type.getName().equals(standardTypes.javaLangCloneable);
  }

  private boolean isJavaLangObject(JType type) {
    if (!(type instanceof JClassType)) {
      return false;
    }
    JClassType classType = (JClassType) type;


    assert classType.getSuperClass() == null ==
        classType.getName().equals(standardTypes.javaLangObject);

    return classType.getSuperClass() == null;
  }

  public boolean isSingleJsoImpl(JType type) {
    return type instanceof JReferenceType && getSingleJsoImpl((JReferenceType) type) != null;
  }


  public boolean isJsType(JType type) {
    return type instanceof JDeclaredType && ((JDeclaredType) type).isJsType();
  }


  public boolean isOrExtendsJsType(JType type, boolean mustHavePrototype) {
    return getNearestJsType(type, mustHavePrototype) != null;
  }


  public boolean isJsFunction(JType type) {
    return type instanceof JInterfaceType && ((JInterfaceType) type).isJsFunction();
  }


  public boolean isSubClass(JClassType type, JClassType possibleSubType) {
    return subclassesByClass.containsEntry(type.getName(), possibleSubType.getName());
  }

  public Set<String> getSubTypeNames(String typeName) {
    return Sets.union((Set<String>) subclassesByClass.get(typeName),
        (Set<String>) subInterfacesByInterface.get(typeName));
  }


  public boolean isSuperClass(JReferenceType type, JReferenceType possibleSuperClass) {
    return isSuperClass(type.getName(), possibleSuperClass.getName());
  }


  public void recomputeAfterOptimizations(Collection<JDeclaredType> declaredTypes) {
    Set<JDeclaredType> computed = Sets.newIdentityHashSet();
    assert optimize;



    for (JDeclaredType type : declaredTypes) {
      computeClinitTarget(type, computed);
    }

    nextDual:
    for (Iterator<String> it = dualImplInterfaces.iterator(); it.hasNext(); ) {
      String dualIntf = it.next();
      for (String implementorName : classesByImplementingInterface.get(dualIntf)) {
        JClassType implementor = (JClassType) referenceTypesByName.get(implementorName);
        assert implementor != null;
        if (isInstantiatedType(implementor) && !implementor.isJsoType()) {

          continue nextDual;
        }
      }

      it.remove();
    }


    Iterator<Entry<String, String>> jit = jsoByInterface.entrySet().iterator();
    while (jit.hasNext()) {
      Entry<String, String> jsoSingleImplEntry = jit.next();
      JClassType clazz = (JClassType) referenceTypesByName.get(jsoSingleImplEntry.getValue());
      if (isInstantiatedType(clazz)) {
        continue;
      }
      dualImplInterfaces.remove(jsoSingleImplEntry.getKey());
      jit.remove();
    }
  }

  public void setInstantiatedTypes(Set<JReferenceType> instantiatedTypes) {
    this.instantiatedTypes = instantiatedTypes;
    methodsBySignatureForType.keySet().retainAll(instantiatedTypes);
  }

  private void deleteImmediateTypeRelations(final Collection<String> typeNames) {
    Predicate<Entry<String, String>> inToDeleteSet =
        new Predicate<Entry<String, String>>() {
          @Override
          public boolean apply(Entry<String, String> typeTypeEntry) {

            return typeNames.contains(typeTypeEntry.getKey());
          }
        };

    Maps.filterEntries(immediateTypeRelations.immediateSuperclassesByClass, inToDeleteSet).clear();
    Multimaps.filterEntries(immediateTypeRelations.immediateImplementedInterfacesByClass,
        inToDeleteSet).clear();
    Multimaps.filterEntries(immediateTypeRelations.immediateSuperInterfacesByInterface,
        inToDeleteSet).clear();
  }

  private void recordImmediateTypeRelations(Iterable<JDeclaredType> types) {
    for (JReferenceType type : types) {
      if (type instanceof JClassType) {
        JClassType jClassType = (JClassType) type;

        JClassType superClass = jClassType.getSuperClass();
        if (superClass != null) {
          immediateTypeRelations.immediateSuperclassesByClass.put(jClassType.getName(),
              superClass.getName());
        }


        immediateTypeRelations.immediateImplementedInterfacesByClass
            .putAll(type.getName(), Iterables.transform(jClassType.getImplements(), TYPE_TO_NAME));
      } else if (type instanceof JInterfaceType) {

        JInterfaceType currentIntf = (JInterfaceType) type;

        immediateTypeRelations.immediateSuperInterfacesByInterface
            .putAll(type.getName(), Iterables.transform(currentIntf.getImplements(), TYPE_TO_NAME));
      }
    }
  }

  private void computeExtendedTypeRelations() {
    computeAllClasses();
    computeClassMaps();
    computeInterfaceMaps();
    computeImplementsMaps();
    computePotentialImplementMap();
    computeSingleJSO();
    computeDualJSO();
  }

  private void computeAllClasses() {
    allClasses.clear();
    allClasses.addAll(immediateTypeRelations.immediateSuperclassesByClass.values());
    allClasses.addAll(immediateTypeRelations.immediateSuperclassesByClass.keySet());
  }

  private void computePotentialImplementMap() {

    Multimap<String, String> reflexiveSubtypes = HashMultimap.create();
    reflexiveSubtypes.putAll(subclassesByClass);
    reflexiveClosure(reflexiveSubtypes, allClasses);

    potentialInterfaceByClass =
        ImmutableSetMultimap.copyOf(compose(reflexiveSubtypes, implementedInterfacesByClass));
  }

  private void computeDualJSO() {
    dualImplInterfaces.clear();

    for (String jsoIntfName : jsoByInterface.keySet()) {
      for (String implementor : classesByImplementingInterface.get(jsoIntfName)) {
        if (!isJavaScriptObject(implementor)) {





          dualImplInterfaces.add(jsoIntfName);
          break;
        }
      }
    }
  }

  private void computeImplementsMaps() {

    Multimap<String, String> superTypesByType = HashMultimap.create();
    superTypesByType.putAll(immediateTypeRelations.immediateImplementedInterfacesByClass);
    superTypesByType.putAll(Multimaps.forMap(immediateTypeRelations.immediateSuperclassesByClass));
    superTypesByType.putAll(immediateTypeRelations.immediateSuperInterfacesByInterface);

    Multimap<String, String> superTypesByTypeClosure = transitiveClosure(superTypesByType);


    implementedInterfacesByClass = ImmutableSetMultimap.copyOf(
        Multimaps.filterEntries(superTypesByTypeClosure,
            new Predicate<Entry<String, String>>() {
              @Override
              public boolean apply(Entry<String, String> typeTypeEntry) {

                return allClasses.contains(typeTypeEntry.getKey()) &&
                    !allClasses.contains(typeTypeEntry.getValue());
              }
            }));

    classesByImplementingInterface =
        ImmutableSetMultimap.copyOf(inverse(implementedInterfacesByClass));
  }

  private void computeSingleJSO() {
    jsoByInterface.clear();

    for (String jsoSubType : subclassesByClass.get(JProgram.JAVASCRIPTOBJECT)) {
      for (String intf :
          immediateTypeRelations.immediateImplementedInterfacesByClass.get(jsoSubType)) {
        jsoByInterface.put(intf, jsoSubType);
        for (String superIntf : superInterfacesByInterface.get(intf)) {
          if (!jsoByInterface.containsKey(superIntf)) {
            jsoByInterface.put(superIntf, jsoSubType);
          }
        }
      }
    }
  }

  private void computeClassMaps() {
    superclassesByClass = ImmutableSetMultimap.copyOf(
        transitiveClosure(Multimaps.forMap(immediateTypeRelations.immediateSuperclassesByClass)));
    subclassesByClass = ImmutableSetMultimap.copyOf(inverse(superclassesByClass));
  }

  private void computeInterfaceMaps() {
    superInterfacesByInterface = ImmutableSetMultimap.copyOf(
        transitiveClosure(immediateTypeRelations.immediateSuperInterfacesByInterface));
    subInterfacesByInterface  = ImmutableSetMultimap.copyOf(inverse(superInterfacesByInterface));
  }

  private void computeClinitTarget(JDeclaredType type, Set<JDeclaredType> computed) {
    if (type.isExternal() || !type.hasClinit() || computed.contains(type)) {
      return;
    }
    JClassType superClass = null;
    if (type instanceof JClassType) {
      superClass = ((JClassType) type).getSuperClass();
    }
    if (superClass != null) {

      computeClinitTarget(superClass, computed);
    }
    if (type.getClinitTarget() != type) {

      type.setClinitTarget(superClass.getClinitTarget());
    } else {

      JDeclaredType target =
          computeClinitTargetRecursive(type, computed, Sets.<JDeclaredType>newIdentityHashSet());
      type.setClinitTarget(target);
    }
    computed.add(type);
  }

  private JDeclaredType computeClinitTargetRecursive(JDeclaredType type,
      Set<JDeclaredType> computed, Set<JDeclaredType> alreadySeen) {

    alreadySeen.add(type);

    JMethod method = type.getClinitMethod();
    assert (JProgram.isClinit(method));
    CheckClinitVisitor v = new CheckClinitVisitor();
    v.accept(method);
    if (v.hasLiveCode()) {
      return type;
    }

    JDeclaredType[] clinitTargets = v.getClinitTargets();
    if (clinitTargets.length == 1) {
      JDeclaredType singleTarget = clinitTargets[0];
      if (type instanceof JClassType && singleTarget instanceof JClassType
          && isSuperClass(type, singleTarget)) {
        return singleTarget.getClinitTarget();
      }
    }
    for (JDeclaredType target : clinitTargets) {
      if (!target.hasClinit()) {

        continue;
      }


      if (target.hasClinit() && computed.contains(target)) {
        return type;
      }


      if (alreadySeen.contains(target)) {
        continue;
      }

      if (computeClinitTargetRecursive(target, computed, alreadySeen) != null) {

        return type;
      } else {

        continue;
      }
    }
    return null;
  }

  private JReferenceType ensureTypeExistsAndAppend(String typeName, List<JReferenceType> types) {
    JReferenceType type = referenceTypesByName.get(typeName);
    assert type != null;
    types.add(type);
    return type;
  }


  private boolean extendsInterface(JInterfaceType type, JInterfaceType qType) {
    return superInterfacesByInterface.containsEntry(type.getName(), qType.getName());
  }


  private Iterable<JReferenceType> getTypes(Iterable<String> typeNameSet) {
    return Iterables.transform(typeNameSet,
        new Function<String, JReferenceType>() {
          @Override
          public JReferenceType apply(String typeName) {
            JReferenceType referenceType = referenceTypesByName.get(typeName);
            assert referenceType != null;
            return referenceType;
          }
        });
  }

  private Map<String, JMethod> getOrCreateInstanceMethodsBySignatureForType(JClassType type) {
    Map<String, JMethod> methodsBySignature = methodsBySignatureForType.get(type);
    if (methodsBySignature == null) {
      methodsBySignature = Maps.newHashMap();
      JClassType superClass = type.getSuperClass();
      Map<String, JMethod> parentMethods = superClass == null
          ? Collections.<String, JMethod>emptyMap()
          : getOrCreateInstanceMethodsBySignatureForType(type.getSuperClass());


      for (JMethod method : parentMethods.values()) {
        if (method.canBePolymorphic()) {
          methodsBySignature.put(method.getSignature(), method);
        }
      }


      for (JMethod method : type.getMethods()) {
        if (!method.isStatic()) {
          methodsBySignature.put(method.getSignature(), method);
        }
      }

      methodsBySignatureForType.put(type, methodsBySignature);
    }
    return methodsBySignature;
  }


  private void reflexiveClosure(Multimap<String, String> relation, Iterable<String> domain) {
    for (String element : domain) {
      relation.put(element, element);
    }
  }


  private Multimap<String, String> transitiveClosure(Multimap<String, String> relation) {
    Multimap<String, String> transitiveClosure = HashMultimap.create();
    Set<String> domain = Sets.newHashSet(relation.keySet());
    domain.addAll(relation.values());
    for (String element : domain) {
      expandTransitiveClosureForElement(relation, element, transitiveClosure);
    }
    return transitiveClosure;
  }


  private Collection<String> expandTransitiveClosureForElement(Multimap<String, String> relation,
      String element, Multimap<String, String> transitiveClosure) {



    Collection<String> preComputedExpansion = transitiveClosure.get(element);

    if (!preComputedExpansion.isEmpty()) {

      return preComputedExpansion;
    }

    Set<String> transitiveExpansion = Sets.newHashSet();
    Collection<String> immediateSuccessors = relation.get(element);
    transitiveExpansion.addAll(immediateSuccessors);

    for (String child : immediateSuccessors) {
      transitiveExpansion.addAll(expandTransitiveClosureForElement(relation, child,
          transitiveClosure));
    }
    transitiveClosure.putAll(element, transitiveExpansion);
    return transitiveExpansion;
  }


  private <A, B, C> Multimap<A, C> compose(Multimap<A, B> f, Multimap<B, C> g) {
    Multimap<A, C> composition = HashMultimap.create();
    for (A a : f.keySet()) {
      for (B b : f.get(a)) {
        composition.putAll(a, g.get(b));
      }
    }
    return composition;
  }


  private <K, V> Multimap<V, K> inverse(Multimap<K, V> relation) {
    Multimap<V, K> inverse = HashMultimap.create();
    Multimaps.invertFrom(relation, inverse);
    return inverse;
  }


  private boolean implementsInterface(JReferenceType type, JReferenceType interfaceType) {
    return implementedInterfacesByClass.containsEntry(type.getName(), interfaceType.getName());
  }

  private boolean isSuperClass(String type, String potentialSuperClass) {
    return subclassesByClass.containsEntry(potentialSuperClass, type);
  }
}

<code block>

package com.google.gwt.dev.jjs.impl;

import com.google.gwt.dev.jjs.ast.Context;
import com.google.gwt.dev.jjs.ast.JAbsentArrayDimension;
import com.google.gwt.dev.jjs.ast.JArrayType;
import com.google.gwt.dev.jjs.ast.JBinaryOperation;
import com.google.gwt.dev.jjs.ast.JBinaryOperator;
import com.google.gwt.dev.jjs.ast.JCastOperation;
import com.google.gwt.dev.jjs.ast.JClassLiteral;
import com.google.gwt.dev.jjs.ast.JClassType;
import com.google.gwt.dev.jjs.ast.JConstructor;
import com.google.gwt.dev.jjs.ast.JDeclarationStatement;
import com.google.gwt.dev.jjs.ast.JDeclaredType;
import com.google.gwt.dev.jjs.ast.JExpression;
import com.google.gwt.dev.jjs.ast.JField;
import com.google.gwt.dev.jjs.ast.JFieldRef;
import com.google.gwt.dev.jjs.ast.JInterfaceType;
import com.google.gwt.dev.jjs.ast.JLocal;
import com.google.gwt.dev.jjs.ast.JLocalRef;
import com.google.gwt.dev.jjs.ast.JMethod;
import com.google.gwt.dev.jjs.ast.JMethodCall;
import com.google.gwt.dev.jjs.ast.JNewArray;
import com.google.gwt.dev.jjs.ast.JNewInstance;
import com.google.gwt.dev.jjs.ast.JNode;
import com.google.gwt.dev.jjs.ast.JParameter;
import com.google.gwt.dev.jjs.ast.JParameterRef;
import com.google.gwt.dev.jjs.ast.JPrimitiveType;
import com.google.gwt.dev.jjs.ast.JProgram;
import com.google.gwt.dev.jjs.ast.JReferenceType;
import com.google.gwt.dev.jjs.ast.JRunAsync;
import com.google.gwt.dev.jjs.ast.JStringLiteral;
import com.google.gwt.dev.jjs.ast.JType;
import com.google.gwt.dev.jjs.ast.JVariable;
import com.google.gwt.dev.jjs.ast.JVariableRef;
import com.google.gwt.dev.jjs.ast.JVisitor;
import com.google.gwt.dev.jjs.ast.js.JsniFieldRef;
import com.google.gwt.dev.jjs.ast.js.JsniMethodBody;
import com.google.gwt.dev.jjs.ast.js.JsniMethodRef;
import com.google.gwt.dev.js.ast.JsContext;
import com.google.gwt.dev.js.ast.JsFunction;
import com.google.gwt.dev.js.ast.JsName;
import com.google.gwt.dev.js.ast.JsNameRef;
import com.google.gwt.dev.js.ast.JsVisitor;
import com.google.gwt.thirdparty.guava.common.collect.ArrayListMultimap;
import com.google.gwt.thirdparty.guava.common.collect.ListMultimap;
import com.google.gwt.thirdparty.guava.common.collect.Lists;
import com.google.gwt.thirdparty.guava.common.collect.Sets;

import java.util.List;
import java.util.Set;


public class ControlFlowAnalyzer {


  public interface DependencyRecorder {

    void methodIsLiveBecause(JMethod liveMethod, List<JMethod> dependencyChain);
  }


  private class RescueVisitor extends JVisitor {
    private final List<JMethod> curMethodStack = Lists.newArrayList();

    @Override
    public boolean visit(JArrayType type, Context ctx) {
      assert (referencedTypes.contains(type));
      boolean isInstantiated = instantiatedTypes.contains(type);

      JType leafType = type.getLeafType();
      int dims = type.getDims();


      boolean didSuperType = false;
      if (leafType instanceof JClassType) {
        JClassType superClass = ((JClassType) leafType).getSuperClass();
        if (superClass != null) {

          rescue(program.getOrCreateArrayType(superClass, dims), true, isInstantiated);
          didSuperType = true;
        }
      } else if (leafType instanceof JInterfaceType) {

        rescue(program.getOrCreateArrayType(program.getTypeJavaLangObject(), dims),
            true, isInstantiated);
        didSuperType = true;
      }
      if (!didSuperType) {
        if (dims > 1) {

          rescue(program.getOrCreateArrayType(program.getTypeJavaLangObject(), dims - 1), true,
              isInstantiated);
        } else {

          rescue(program.getTypeJavaLangObject(), true, isInstantiated);
        }
      }


      if (leafType instanceof JDeclaredType) {
        JDeclaredType dLeafType = (JDeclaredType) leafType;
        for (JInterfaceType intfType : dLeafType.getImplements()) {
          JArrayType intfArray = program.getOrCreateArrayType(intfType, dims);
          rescue(intfArray, true, isInstantiated);
        }
      }

      return false;
    }

    @Override
    public boolean visit(JBinaryOperation x, Context ctx) {
      if (x.isAssignment() && x.getLhs() instanceof JFieldRef) {
        fieldsWritten.add(((JFieldRef) x.getLhs()).getField());
      }


      if ((x.getOp() == JBinaryOperator.CONCAT || x.getOp() == JBinaryOperator.ASG_CONCAT)) {
        rescueByConcat(x.getLhs().getType());
        rescueByConcat(x.getRhs().getType());
      } else if (x.getOp() == JBinaryOperator.ASG) {

        boolean doSkip = false;
        JExpression lhs = x.getLhs();
        if (lhs.hasSideEffects() || isVolatileField(lhs)) {

        } else if (lhs instanceof JLocalRef) {

          doSkip = true;
        } else if (lhs instanceof JParameterRef) {

          doSkip = true;
        } else if (lhs instanceof JFieldRef) {

          doSkip = true;
          JFieldRef fieldRef = (JFieldRef) lhs;
          JExpression instance = fieldRef.getInstance();
          if (instance != null) {
            accept(instance);
          }
        }

        if (doSkip) {
          accept(x.getRhs());
          return false;
        }
      }
      return true;
    }

    @Override
    public boolean visit(JCastOperation x, Context ctx) {

      JType targetType = x.getCastType();
      if (!program.typeOracle.canBeInstantiatedInJavascript(targetType)) {
        return true;
      }
      rescue((JReferenceType) targetType, true, true);
      JType exprType = x.getExpr().getType();
      if (program.typeOracle.isSingleJsoImpl(targetType)) {

        if (program.getTypeJavaLangObject() == exprType
            || program.typeOracle.canBeJavaScriptObject(exprType)) {

          JClassType jsoImplementor =
              program.typeOracle.getSingleJsoImpl((JReferenceType) targetType);
          if (jsoImplementor != null) {
            rescue(jsoImplementor, true, true);
          }
        }
      } else if (program.typeOracle.isJsType(targetType)
        && ((JDeclaredType) targetType).getJsPrototype() != null) {

        rescue((JReferenceType) targetType, true, true);
      }

      return true;
    }

    @Override
    public boolean visit(JClassLiteral x, Context ctx) {
      JField field = x.getField();
      assert field != null;
      rescue(field);
      return true;
    }

    @Override
    public boolean visit(JClassType type, Context ctx) {
      assert (referencedTypes.contains(type));
      boolean isInstantiated = instantiatedTypes.contains(type);


      rescue(type.getSuperClass(), true, isInstantiated);


      if (type.hasClinit()) {
        rescue(type.getClinitMethod());
      }



      for (JInterfaceType intfType : type.getImplements()) {
        rescue(intfType, false, isInstantiated);
      }

      rescueMembersIfInstantiable(type);
      return false;
    }

    @Override
    public boolean visit(JDeclarationStatement x, Context ctx) {

      if (x.getInitializer() != null &&
          !isStaticFieldInitializedToLiteral(x.getVariableRef().getTarget())) {

        accept(x.getInitializer());

        if (x.getVariableRef().getTarget() instanceof JField) {
          fieldsWritten.add((JField) x.getVariableRef().getTarget());
        }
      }


      JVariableRef variableRef = x.getVariableRef();
      if (variableRef instanceof JFieldRef) {
        JFieldRef fieldRef = (JFieldRef) variableRef;
        JExpression instance = fieldRef.getInstance();
        if (instance != null) {
          accept(instance);
        }
      }
      return false;
    }

    @Override
    public boolean visit(JFieldRef ref, Context ctx) {
      JField target = ref.getField();


      if (target.isStatic()) {
        rescue(target.getEnclosingType(), true, false);
      }
      if (target.isStatic() || instantiatedTypes.contains(target.getEnclosingType())) {
        rescue(target);
      } else {

        if (!liveFieldsAndMethods.contains(target)) {
          membersToRescueIfTypeIsInstantiated.add(target);
        }
      }
      return true;
    }

    @Override
    public boolean visit(JInterfaceType type, Context ctx) {
      boolean isReferenced = referencedTypes.contains(type);
      boolean isInstantiated = instantiatedTypes.contains(type);
      assert (isReferenced || isInstantiated);


      if (type.hasClinit()) {
        rescue(type.getClinitMethod());
      }



      if (isInstantiated) {
        for (JInterfaceType intfType : type.getImplements()) {
          rescue(intfType, false, true);
        }
      }

      rescueMembersIfInstantiable(type);
      return false;
    }

    @Override
    public boolean visit(JLocalRef ref, Context ctx) {
      JLocal target = ref.getLocal();
      rescue(target);
      return true;
    }

    @Override
    public boolean visit(final JMethod x, Context ctx) {
      JReferenceType enclosingType = x.getEnclosingType();
      if (enclosingType.isJsoType()) {

        boolean instance = !x.isStatic() || program.isStaticImpl(x);
        rescue(enclosingType, true, instance);
      } else if (x.isStatic()) {

        rescue(enclosingType, true, false);
      }

      if (x.isNative()) {

        final JsniMethodBody body = (JsniMethodBody) x.getBody();
        final JsFunction func = body.getFunc();

        new JsVisitor() {
          @Override
          public void endVisit(JsNameRef nameRef, JsContext ctx) {
            JsName ident = nameRef.getName();

            if (ident != null) {


              int index = func.getParameters().indexOf(ident.getStaticRef());
              if (index != -1) {
                rescue(x.getParams().get(index));
              }
            }
          }
        }.accept(func);
      }

      return true;
    }

    @Override
    public boolean visit(JMethodCall call, Context ctx) {
      JMethod method = call.getTarget();
      if (call.isVolatile() && method == runAsyncOnsuccess) {

        return true;
      }
      if (method.isStatic() || isTypeInstantiatedOrJso(method.getEnclosingType())) {
        rescue(method);
      } else {

        if (!liveFieldsAndMethods.contains(method)) {
          membersToRescueIfTypeIsInstantiated.add(method);
        }
      }

      if (argsToRescueIfParameterRead == null || method.canBePolymorphic()
          || call instanceof JsniMethodRef) {
        return true;
      }

      if (program.instanceMethodForStaticImpl(method) != null) {

        return true;
      }

      return rescueArgumentsIfParametersCanBeRead(call, method);
    }

    @Override
    public boolean visit(JNewArray newArray, Context ctx) {

      JArrayType arrayType = newArray.getArrayType();
      if (newArray.dims != null) {

        int nDims = arrayType.getDims();
        JType leafType = arrayType.getLeafType();
        assert (newArray.dims.size() == nDims);
        for (int i = 0; i < nDims; ++i) {
          if (newArray.dims.get(i) instanceof JAbsentArrayDimension) {
            break;
          }
          rescue(program.getOrCreateArrayType(leafType, nDims - i), true, true);
        }
      } else {

        rescue(arrayType, true, true);
      }
      return true;
    }

    @Override
    public boolean visit(JNewInstance x, Context ctx) {

      rescueAndInstantiate(x.getClassType());
      return super.visit(x, ctx);
    }

    @Override
    public boolean visit(JParameterRef x, Context ctx) {

      rescue(x.getParameter());
      return true;
    }

    @Override
    public boolean visit(JsniFieldRef x, Context ctx) {

      if (x.isLvalue()) {
        maybeRescueJavaScriptObjectPassingIntoJava(x.getField().getType());
      }

      return visit((JFieldRef) x, ctx);
    }

    @Override
    public boolean visit(JsniMethodBody body, Context ctx) {
      liveStrings.addAll(body.getUsedStrings());
      return true;
    }

    @Override
    public boolean visit(JsniMethodRef x, Context ctx) {

      for (JParameter param : x.getTarget().getParams()) {
        maybeRescueJavaScriptObjectPassingIntoJava(param.getType());


        rescue(param);
      }

      if (x.getTarget() instanceof JConstructor) {

        JConstructor ctor = (JConstructor) x.getTarget();
        rescueAndInstantiate(ctor.getEnclosingType());
      }
      return visit((JMethodCall) x, ctx);
    }

    @Override
    public boolean visit(JStringLiteral literal, Context ctx) {
      liveStrings.add(literal.getValue());


      rescue(program.getTypeJavaLangString(), true, true);
      return true;
    }

    private boolean canBeInstantiatedInJavaScript(JType type) {
      if (program.typeOracle.canBeInstantiatedInJavascript(type) ||
          program.isJavaLangString(type)) {
        return true;
      }


      if (type instanceof JArrayType) {
        return true;
      }

      return false;
    }

    private JMethod getStringValueOfCharMethod() {
      JPrimitiveType charType = program.getTypePrimitiveChar();
      JClassType stringType = program.getTypeJavaLangString();
      if (stringValueOfChar != null) {
        return stringValueOfChar;
      }

      for (JMethod method : stringType.getMethods()) {
        if (method.getName().equals("valueOf") &&
            method.getOriginalParamTypes().size() == 1 &&
            method.getOriginalParamTypes().get(0) == charType) {
          stringValueOfChar = method;
          return stringValueOfChar;
        }
      }
      assert false;
      return null;
    }

    private boolean isStaticFieldInitializedToLiteral(JVariable var) {
      if (!(var instanceof JField)) {
        return false;
      }

      JField field = (JField) var;
      return field.isStatic() && field.getLiteralInitializer() != null;
    }

    private boolean isVolatileField(JExpression x) {
      if (!(x instanceof JFieldRef)) {
        return false;
      }

      JFieldRef xFieldRef = (JFieldRef) x;
      return xFieldRef.getField().isVolatile();
    }

    private void maybeRescueClassLiteral(JReferenceType type) {
      if (liveFieldsAndMethods.contains(getClassMethod) ||
          liveFieldsAndMethods.contains(getClassField)) {

        rescue(program.getClassLiteralField(type));
      } else {

        classLiteralsToBeRescuedIfGetClassIsLive.add(type);
      }
    }


    private void maybeRescueJavaScriptObjectPassingIntoJava(JType type) {
      if (!canBeInstantiatedInJavaScript(type)) {
        return;
      }
      rescue((JReferenceType) type, true, true);
      if (program.typeOracle.isSingleJsoImpl(type)) {

        JClassType singleJsoImpl = program.typeOracle.getSingleJsoImpl((JReferenceType) type);
        if (singleJsoImpl != null) {
          rescue(singleJsoImpl, true, true);
        }
      }
    }

    private void rescue(JMethod method) {
      if (method == null) {
        return;
      }

      if (!liveFieldsAndMethods.contains(method)) {
        liveFieldsAndMethods.add(method);
        membersToRescueIfTypeIsInstantiated.remove(method);
        if (dependencyRecorder != null) {
          curMethodStack.add(method);
          dependencyRecorder.methodIsLiveBecause(method, curMethodStack);
        }
        accept(method);
        if (dependencyRecorder != null) {
          curMethodStack.remove(curMethodStack.size() - 1);
        }
        if (method.isNative() || method.isOrOverridesJsTypeMethod()
            || method.isOrOverridesJsFunctionMethod()) {

          maybeRescueJavaScriptObjectPassingIntoJava(method.getType());
        }
        if (method.isExported()
            || method.isOrOverridesJsTypeMethod()
            || method.isOrOverridesJsFunctionMethod()) {
          for (JParameter param : method.getParams()) {

            rescue(param);

            if (canBeInstantiatedInJavaScript(param.getType())) {




              rescue((JReferenceType) param.getType(), true, true);
            }
          }
        }
        rescueOverridingMethods(method);
        if (method == getClassMethod) {
          rescueClassLiteralsIfGetClassIsLive();
        }
        if (program.isJsTypePrototype(method.getEnclosingType())) {


          for (JParameter param : method.getParams()) {
            rescue(param);
          }
        }
        if (method.getSpecialization() != null) {
          rescue(method.getSpecialization().getTargetMethod());
        }
      }
    }

    private void rescue(JReferenceType type, boolean isReferenced, boolean isInstantiated) {
      if (type == null) {
        return;
      }


      type = type.getUnderlyingType();

      boolean doVisit = false;
      if (isInstantiated && instantiatedTypes.add(type)) {
        maybeRescueClassLiteral(type);
        doVisit = true;
      }

      if (isReferenced && referencedTypes.add(type)) {
        doVisit = true;
      }

      if (!doVisit) {
        return;
      }

      accept(type);
      if (type instanceof JDeclaredType) {

        JDeclaredType dtype = (JDeclaredType) type;





        if (dtype.isJsType() || dtype.isJsFunction()) {
          for (JMethod method : dtype.getMethods()) {
            if (method.isOrOverridesJsTypeMethod()
                || method.isOrOverridesJsFunctionMethod()) {
              rescue(method);
            }
          }
          for (JField field : dtype.getFields()) {
            if (field.isJsTypeMember()) {
              rescue(field);
            }
          }
        }
      }
    }

    private void rescue(JVariable var) {
      if (var == null) {
        return;
      }
      if (!liveFieldsAndMethods.add(var)) {

        return;
      }
      membersToRescueIfTypeIsInstantiated.remove(var);
      if (var == getClassField) {
        rescueClassLiteralsIfGetClassIsLive();
      }

      if (isStaticFieldInitializedToLiteral(var)) {

        accept(((JField) var).getLiteralInitializer());
      } else if (var instanceof JField
          && (program.getTypeClassLiteralHolder().equals(((JField) var).getEnclosingType()))) {

        JField field = (JField) var;
        accept(field.getInitializer());
        referencedTypes.add(field.getEnclosingType());
        liveFieldsAndMethods.add(field.getEnclosingType().getClinitMethod());
      } else if (argsToRescueIfParameterRead != null && var instanceof JParameter) {
        List<JExpression> list = argsToRescueIfParameterRead.removeAll(var);
        for (JExpression arg : list) {
          this.accept(arg);
        }
      }
    }

    private void rescueAndInstantiate(JClassType type) {
      rescue(type, true, true);
    }


    private boolean rescueArgumentsIfParametersCanBeRead(JMethodCall call, JMethod method) {
      if (call.getInstance() != null) {

        this.accept(call.getInstance());
      }
      List<JExpression> args = call.getArgs();
      List<JParameter> params = method.getParams();
      int i = 0;
      for (int c = params.size(); i < c; ++i) {
        JExpression arg = args.get(i);
        JParameter param = params.get(i);
        if (arg.hasSideEffects() || liveFieldsAndMethods.contains(param)

            || method.isOrOverridesJsTypeMethod()
            || method.isOrOverridesJsFunctionMethod()
            || program.isJsTypePrototype(method.getEnclosingType())) {
          this.accept(arg);
          continue;
        }
        argsToRescueIfParameterRead.put(param, arg);
      }

      for (int c = args.size(); i < c; ++i) {
        this.accept(args.get(i));
      }
      return false;
    }


    private void rescueByConcat(JType type) {
      JPrimitiveType charType = program.getTypePrimitiveChar();
      JClassType stringType = program.getTypeJavaLangString();
      if (type instanceof JReferenceType
          && !program.typeOracle.castSucceedsTrivially((JReferenceType) type, stringType)
          && !type.isNullType()) {

        JMethod toStringMethod = program.getIndexedMethod("Object.toString");
        rescue(toStringMethod);
      } else if (type == charType) {

        rescue(getStringValueOfCharMethod());
      }
    }

    private void rescueClassLiteralsIfGetClassIsLive() {
      if (classLiteralsToBeRescuedIfGetClassIsLive != null) {

        Set<JReferenceType> toRescue = classLiteralsToBeRescuedIfGetClassIsLive;
        classLiteralsToBeRescuedIfGetClassIsLive = null;

        for (JReferenceType classLit : toRescue) {
          maybeRescueClassLiteral(classLit);
        }
      }
    }


    private void rescueMembersIfInstantiable(JDeclaredType type) {
      if (!instantiatedTypes.contains(type)) {
        return;
      }
      for (JMethod method : type.getMethods()) {
        if (!method.isStatic() && (membersToRescueIfTypeIsInstantiated.contains(method)

           || method.isOrOverridesJsTypeMethod()
           || method.isOrOverridesJsFunctionMethod())) {
          rescue(method);
        }
      }
      for (JField field : type.getFields()) {
        if (!field.isStatic() && membersToRescueIfTypeIsInstantiated.contains(field)) {
            rescue(field);
        }
      }
    }


    private void rescueOverridingMethods(JMethod method) {
      if (method.isStatic()) {
        return;
      }

      for (JMethod overridingMethod : method.getOverridingMethods()) {
        if (liveFieldsAndMethods.contains(overridingMethod)) {

        } else if (instantiatedTypes.contains(overridingMethod.getEnclosingType())) {

          rescue(overridingMethod);
        } else {

          membersToRescueIfTypeIsInstantiated.add(overridingMethod);
        }
      }
    }
  }

  private boolean isTypeInstantiatedOrJso(JType type) {
    if (type == null) {
      return false;
    }

    return type.isJsoType() || instantiatedTypes.contains(type);
  }


  private ListMultimap<JParameter, JExpression> argsToRescueIfParameterRead;

  private final JMethod asyncFragmentOnLoad;


  private Set<JReferenceType> classLiteralsToBeRescuedIfGetClassIsLive = Sets.newHashSet();

  private DependencyRecorder dependencyRecorder;
  private Set<JField> fieldsWritten = Sets.newHashSet();
  private Set<JReferenceType> instantiatedTypes = Sets.newHashSet();
  private Set<JNode> liveFieldsAndMethods = Sets.newHashSet();
  private Set<String> liveStrings = Sets.newHashSet();


  private Set<JNode> membersToRescueIfTypeIsInstantiated = Sets.newHashSet();

  private final JField getClassField;
  private final JMethod getClassMethod;
  private final JProgram program;
  private Set<JReferenceType> referencedTypes = Sets.newHashSet();
  private final RescueVisitor rescuer;
  private final JMethod runAsyncOnsuccess;
  private JMethod stringValueOfChar = null;

  public ControlFlowAnalyzer(ControlFlowAnalyzer cfa) {
    program = cfa.program;
    asyncFragmentOnLoad = cfa.asyncFragmentOnLoad;
    runAsyncOnsuccess = cfa.runAsyncOnsuccess;
    fieldsWritten = Sets.newHashSet(cfa.fieldsWritten);
    instantiatedTypes = Sets.newHashSet(cfa.instantiatedTypes);
    liveFieldsAndMethods = Sets.newHashSet(cfa.liveFieldsAndMethods);
    referencedTypes = Sets.newHashSet(cfa.referencedTypes);
    stringValueOfChar = cfa.stringValueOfChar;
    liveStrings = Sets.newHashSet(cfa.liveStrings);
    membersToRescueIfTypeIsInstantiated =
        Sets.newHashSet(cfa.membersToRescueIfTypeIsInstantiated);
    if (cfa.argsToRescueIfParameterRead != null) {
      argsToRescueIfParameterRead =
          ArrayListMultimap.create(cfa.argsToRescueIfParameterRead);
    }
    getClassField = program.getIndexedField("Object.___clazz");
    getClassMethod = program.getIndexedMethod("Object.getClass");
    rescuer = new RescueVisitor();
  }

  public ControlFlowAnalyzer(JProgram program) {
    this.program = program;
    asyncFragmentOnLoad = program.getIndexedMethod("AsyncFragmentLoader.onLoad");
    runAsyncOnsuccess = program.getIndexedMethod("RunAsyncCallback.onSuccess");
    getClassField = program.getIndexedField("Object.___clazz");
    getClassMethod = program.getIndexedMethod("Object.getClass");
    rescuer = new RescueVisitor();
  }


  public Set<JField> getFieldsWritten() {
    return fieldsWritten;
  }


  public Set<JReferenceType> getInstantiatedTypes() {
    return instantiatedTypes;
  }


  public Set<? extends JNode> getLiveFieldsAndMethods() {
    return liveFieldsAndMethods;
  }

  public Set<String> getLiveStrings() {
    return liveStrings;
  }


  public Set<? extends JReferenceType> getReferencedTypes() {
    return referencedTypes;
  }


  public void rescue(Iterable<JReferenceType> typesToRescue) {


    for (JReferenceType type : typesToRescue) {
      rescuer.rescue(type, true, true);
    }
  }


  public void setDependencyRecorder(DependencyRecorder dr) {
    if (dependencyRecorder != null && dr != null) {
      throw new IllegalArgumentException("Attempting to set multiple dependency recorders");
    }
    this.dependencyRecorder = dr;
  }

  public void setForPruning() {
    assert argsToRescueIfParameterRead == null;
    argsToRescueIfParameterRead = ArrayListMultimap.create();
  }


  public void traverseEntryMethods() {
    for (JMethod method : program.getEntryMethods()) {
      traverseFrom(method);
    }


    List<JDeclaredType> declaredTypes = program.getDeclaredTypes();
    for (JDeclaredType type : declaredTypes) {

      for (JMethod method : type.getMethods()) {
        if (method.isExported()) {

          rescuer.rescue(method.getEnclosingType(), true, true);
          traverseFrom(method);
        }
      }
      for (JField field : type.getFields()) {
        if (field.isExported()) {
          rescuer.rescue(field.getEnclosingType(), true, true);
          rescuer.rescue(field);
        }
      }
    }

    if (program.getRunAsyncs().size() > 0) {

      traverseFrom(asyncFragmentOnLoad);
    }
  }

  public void traverseEverything() {
    traverseEntryMethods();
    traverseFromRunAsyncs();

    liveFieldsAndMethods.add(runAsyncOnsuccess);
  }


  public void traverseFrom(JMethod method) {
    rescuer.rescue(method);
  }


  public void traverseFromInstantiationOf(JDeclaredType type) {
    rescuer.rescue(type, true, true);
  }

  public void traverseFromReferenceTo(JDeclaredType type) {
    rescuer.rescue(type, true, false);
  }


  public void traverseFromRunAsync(JRunAsync runAsync) {
    runAsync.traverseOnSuccess(rescuer);
  }


  public void traverseFromRunAsyncs() {
    for (JRunAsync runAsync : program.getRunAsyncs()) {
      traverseFromRunAsync(runAsync);
    }
  }
}

<code block>

package com.google.gwt.dev.jjs.impl;

import com.google.gwt.dev.jjs.InternalCompilerException;
import com.google.gwt.dev.jjs.SourceInfo;
import com.google.gwt.dev.jjs.ast.CanBeStatic;
import com.google.gwt.dev.jjs.ast.Context;
import com.google.gwt.dev.jjs.ast.HasEnclosingType;
import com.google.gwt.dev.jjs.ast.HasName;
import com.google.gwt.dev.jjs.ast.JArrayType;
import com.google.gwt.dev.jjs.ast.JBinaryOperation;
import com.google.gwt.dev.jjs.ast.JBinaryOperator;
import com.google.gwt.dev.jjs.ast.JClassType;
import com.google.gwt.dev.jjs.ast.JConstructor;
import com.google.gwt.dev.jjs.ast.JDeclarationStatement;
import com.google.gwt.dev.jjs.ast.JDeclaredType;
import com.google.gwt.dev.jjs.ast.JExpression;
import com.google.gwt.dev.jjs.ast.JField;
import com.google.gwt.dev.jjs.ast.JFieldRef;
import com.google.gwt.dev.jjs.ast.JInterfaceType;
import com.google.gwt.dev.jjs.ast.JLocal;
import com.google.gwt.dev.jjs.ast.JLocalRef;
import com.google.gwt.dev.jjs.ast.JMethod;
import com.google.gwt.dev.jjs.ast.JMethodBody;
import com.google.gwt.dev.jjs.ast.JMethodCall;
import com.google.gwt.dev.jjs.ast.JNameOf;
import com.google.gwt.dev.jjs.ast.JNewInstance;
import com.google.gwt.dev.jjs.ast.JNode;
import com.google.gwt.dev.jjs.ast.JParameter;
import com.google.gwt.dev.jjs.ast.JPrimitiveType;
import com.google.gwt.dev.jjs.ast.JProgram;
import com.google.gwt.dev.jjs.ast.JReferenceType;
import com.google.gwt.dev.jjs.ast.JRuntimeTypeReference;
import com.google.gwt.dev.jjs.ast.JType;
import com.google.gwt.dev.jjs.ast.JVariable;
import com.google.gwt.dev.jjs.ast.JVariableRef;
import com.google.gwt.dev.jjs.ast.js.JMultiExpression;
import com.google.gwt.dev.jjs.ast.js.JsniFieldRef;
import com.google.gwt.dev.jjs.ast.js.JsniMethodRef;
import com.google.gwt.dev.util.collect.Stack;
import com.google.gwt.dev.util.log.speedtracer.CompilerEventType;
import com.google.gwt.dev.util.log.speedtracer.SpeedTracerLogger;
import com.google.gwt.dev.util.log.speedtracer.SpeedTracerLogger.Event;
import com.google.gwt.thirdparty.guava.common.base.Predicate;
import com.google.gwt.thirdparty.guava.common.base.Predicates;
import com.google.gwt.thirdparty.guava.common.collect.ArrayListMultimap;
import com.google.gwt.thirdparty.guava.common.collect.Iterables;
import com.google.gwt.thirdparty.guava.common.collect.ListMultimap;
import com.google.gwt.thirdparty.guava.common.collect.Sets;

import java.util.Iterator;
import java.util.List;
import java.util.Set;


public class Pruner {

  private class CleanupRefsVisitor extends JModVisitorWithTemporaryVariableCreation {
    private final Stack<JExpression> lValues = new Stack<JExpression>();
    private final ListMultimap<JMethod, JParameter> priorParametersByMethod;
    private final Set<? extends JNode> referencedNonTypes;
    {

      lValues.push(null);
    }

    public CleanupRefsVisitor(Set<? extends JNode> referencedNodes,
        ListMultimap<JMethod, JParameter> priorParametersByMethod,
        OptimizerContext optimizerCtx) {
      super(optimizerCtx);
      this.referencedNonTypes = referencedNodes;
      this.priorParametersByMethod = priorParametersByMethod;
    }

    @Override
    public void endVisit(JBinaryOperation x, Context ctx) {
      if (x.getOp() != JBinaryOperator.ASG) {
        return;
      }

      lValues.pop();
      JExpression lhs = x.getLhs();
      if (!(lhs instanceof JVariableRef)) {
        return;
      }

      JVariableRef variableRef = (JVariableRef) lhs;
      if (isVariablePruned(variableRef.getTarget())) {

        JExpression replacement =
            makeReplacementForAssignment(x.getSourceInfo(), variableRef, x.getRhs());
        ctx.replaceMe(replacement);
      }
    }

    @Override
    public void endVisit(JDeclarationStatement x, Context ctx) {
      super.endVisit(x, ctx);
      lValues.pop();

      if (isVariablePruned(x.getVariableRef().getTarget())) {
        JExpression replacement =
            makeReplacementForAssignment(x.getSourceInfo(), x.getVariableRef(), x.getInitializer());
        ctx.replaceMe(replacement.makeStatement());
      }
    }

    @Override
    public void endVisit(JFieldRef x, Context ctx) {

      if (lValues.peek() == x) {
        return;
      }

      if (isPruned(x.getField())) {

        JFieldRef fieldRef = transformToNullFieldRef(x, program);
        ctx.replaceMe(fieldRef);
      }
    }

    @Override
    public void exit(JMethod x, Context ctx) {
      JType type = x.getType();
      if (type instanceof JReferenceType &&
          !program.typeOracle.isInstantiatedType((JReferenceType) type)) {
        x.setType(JReferenceType.NULL_TYPE);
      }
      Predicate<JMethod> isPruned = new Predicate<JMethod>() {
        @Override
        public boolean apply(JMethod method) {
          return isPruned(method);
        }
      };
      Iterables.removeIf(x.getOverriddenMethods(), isPruned);
      Iterables.removeIf(x.getOverridingMethods(), isPruned);
    }

    @Override
    public void endVisit(JMethodCall x, Context ctx) {
      JMethod method = x.getTarget();


      if (isPruned(method)) {

        ctx.replaceMe(transformToNullMethodCall(x, program));
        return;
      }

      maybeReplaceForPrunedParameters(x, ctx);
    }

    @Override
    public void endVisit(JNameOf x, Context ctx) {
      HasName node = x.getNode();
      boolean pruned;
      if (node instanceof JField) {
        pruned = isPruned((JField) node);
      } else if (node instanceof JMethod) {
        pruned = isPruned((JMethod) node);
      } else if (node instanceof JReferenceType) {
        pruned = !program.typeOracle.isInstantiatedType((JReferenceType) node);
      } else {
        throw new InternalCompilerException("Unhandled JNameOf node: " + node);
      }

      if (pruned) {
        ctx.replaceMe(program.getLiteralNull());
      }
    }

    @Override
    public void endVisit(JNewInstance x, Context ctx) {
      maybeReplaceForPrunedParameters(x, ctx);
    }

    @Override
    public void endVisit(JRuntimeTypeReference x, Context ctx) {
      if (!program.typeOracle.isInstantiatedType(x.getReferredType())) {
        ctx.replaceMe(program.getLiteralNull());
      }
    }

    @Override
    public void endVisit(JsniFieldRef x, Context ctx) {
      if (isPruned(x.getField())) {
        String ident = x.getIdent();
        JField nullField = program.getNullField();
        JsniFieldRef nullFieldRef =
            new JsniFieldRef(x.getSourceInfo(), ident, nullField, x.getEnclosingType(), x
                .isLvalue());
        ctx.replaceMe(nullFieldRef);
      }
    }

    @Override
    public void endVisit(JsniMethodRef x, Context ctx) {

      if (isPruned(x.getTarget())) {
        String ident = x.getIdent();
        JMethod nullMethod = program.getNullMethod();
        JsniMethodRef nullMethodRef =
            new JsniMethodRef(x.getSourceInfo(), ident, nullMethod, program.getJavaScriptObject());
        ctx.replaceMe(nullMethodRef);
      }
    }

    @Override
    public void exit(JVariable x, Context ctx) {
      JType type = x.getType();
      if (type instanceof JReferenceType &&
          !program.typeOracle.isInstantiatedType((JReferenceType) type)) {
        x.setType(JReferenceType.NULL_TYPE);
        madeChanges();
      }
    }

    @Override
    public boolean visit(JBinaryOperation x, Context ctx) {
      if (x.getOp() == JBinaryOperator.ASG) {
        lValues.push(x.getLhs());
      }
      return true;
    }

    @Override
    public boolean visit(JDeclarationStatement x, Context ctx) {
      super.visit(x, ctx);
      lValues.push(x.getVariableRef());
      return true;
    }

    private <T extends HasEnclosingType & CanBeStatic> boolean isPruned(T node) {
      if (!referencedNonTypes.contains(node)) {
        return true;
      }
      JReferenceType enclosingType = node.getEnclosingType();
      return !node.isStatic() && enclosingType != null
          && !program.typeOracle.isInstantiatedType(enclosingType);
    }

    private boolean isVariablePruned(JVariable variable) {
      if (variable instanceof JField) {
        return isPruned((JField) variable);
      }
      return !referencedNonTypes.contains(variable);
    }

    private JExpression makeReplacementForAssignment(SourceInfo info, JVariableRef variableRef,
        JExpression rhs) {

      JMultiExpression multi = new JMultiExpression(info);


      if (variableRef instanceof JFieldRef) {
        JFieldRef fieldRef = (JFieldRef) variableRef;
        JExpression instance = fieldRef.getInstance();
        if (instance != null) {
          multi.addExpressions(instance);
        }
      }


      if (rhs != null) {
        multi.addExpressions(rhs);
      }
      if (multi.getNumberOfExpressions() == 1) {
        return multi.getExpression(0);
      } else {
        return multi;
      }
    }



    private void maybeReplaceForPrunedParameters(JMethodCall x, Context ctx) {
      if (!priorParametersByMethod.containsKey(x.getTarget())) {

        return;
      }

      JMethodCall replacementCall = x.cloneWithoutParameters();

      assert !x.getTarget().canBePolymorphic();
      List<JParameter> originalParams = priorParametersByMethod.get(x.getTarget());


      assert originalParams.size() == x.getArgs().size();


      SourceInfo sourceInfo = x.getSourceInfo();
      JMultiExpression unevaluatedArgumentsForPrunedParameters =
          new JMultiExpression(sourceInfo);
      List<JExpression> args = x.getArgs();
      for (int currentArgumentIndex = 0; currentArgumentIndex < args.size();
          ++currentArgumentIndex) {
        JExpression arg = args.get(currentArgumentIndex);


        if (referencedNonTypes.contains(originalParams.get(currentArgumentIndex))) {


          unevaluatedArgumentsForPrunedParameters.addExpressions(arg);
          replacementCall.addArg(unevaluatedArgumentsForPrunedParameters);

          unevaluatedArgumentsForPrunedParameters =  new JMultiExpression(sourceInfo);
        } else if (arg.hasSideEffects()) {

          unevaluatedArgumentsForPrunedParameters.addExpressions(arg);
        }
      }

      if (unevaluatedArgumentsForPrunedParameters.isEmpty()) {

        ctx.replaceMe(replacementCall);
        return;
      }



      if (replacementCall.getArgs().isEmpty()) {

        unevaluatedArgumentsForPrunedParameters.addExpressions(replacementCall);
        ctx.replaceMe(unevaluatedArgumentsForPrunedParameters);
        return;
      }


      JExpression lastArg = Iterables.getLast(replacementCall.getArgs());
      JLocal tempVar =
          createTempLocal(sourceInfo, Iterables.getLast(
              Iterables.filter(originalParams, Predicates.in(referencedNonTypes))).getType());
      unevaluatedArgumentsForPrunedParameters.addExpressions(0, JProgram.createAssignment(
          lastArg.getSourceInfo(), new JLocalRef(sourceInfo, tempVar), lastArg));
      unevaluatedArgumentsForPrunedParameters.addExpressions(new JLocalRef(sourceInfo, tempVar));
      replacementCall.setArg(replacementCall.getArgs().size() - 1, unevaluatedArgumentsForPrunedParameters);
      ctx.replaceMe(replacementCall);
    }

    @Override
    protected String newTemporaryLocalName(SourceInfo info, JType type, JMethodBody methodBody) {


      return "lastArg";
    }
  }


  private class PruneVisitor extends JChangeTrackingVisitor {
    private final ListMultimap<JMethod, JParameter> priorParametersByMethod =
        ArrayListMultimap.create();
    private final Set<? extends JNode> referencedNonTypes;
    private final Set<? extends JReferenceType> referencedTypes;

    public PruneVisitor(Set<? extends JReferenceType> referencedTypes,
        Set<? extends JNode> referencedNodes, OptimizerContext optimizerCtx) {
      super(optimizerCtx);
      this.referencedTypes = referencedTypes;
      this.referencedNonTypes = referencedNodes;
    }

    public ListMultimap<JMethod, JParameter> getPriorParametersByMethod() {
      return priorParametersByMethod;
    }

    @Override
    public boolean visit(JDeclaredType type, Context ctx) {
      assert (referencedTypes.contains(type) || type instanceof JInterfaceType);
      Predicate<JNode> notReferenced = Predicates.not(Predicates.in(referencedNonTypes));
      removeFields(notReferenced, type);
      removeMethods(notReferenced, type);

      for (JMethod method : type.getMethods()) {
        accept(method);
      }

      return false;
    }

    @Override
    public boolean enter(JMethod x, Context ctx) {
      if (!x.canBePolymorphic()) {

        if (!referencedNonTypes.contains(x)) {
          return true;
        }


        JMethod instanceMethod = program.instanceMethodForStaticImpl(x);

        if (saveCodeGenTypes && instanceMethod != null &&
            referencedNonTypes.contains(instanceMethod)) {

          return true;
        }

        priorParametersByMethod.putAll(x, x.getParams());

        for (int i = 0; i < x.getParams().size(); ++i) {
          JParameter param = x.getParams().get(i);
          if (!referencedNonTypes.contains(param)) {
            x.removeParam(i);
            madeChanges();
            --i;
          }
        }
      }

      return true;
    }

    @Override
    public boolean visit(JMethodBody x, Context ctx) {
      for (int i = 0; i < x.getLocals().size(); ++i) {
        if (!referencedNonTypes.contains(x.getLocals().get(i))) {
          x.removeLocal(i--);
          madeChanges();
        }
      }
      return false;
    }

    @Override
    public boolean visit(JProgram program, Context ctx) {
      for (JMethod method : program.getEntryMethods()) {
        accept(method);
      }
      for (Iterator<JDeclaredType> it = program.getDeclaredTypes().iterator(); it.hasNext();) {
        JDeclaredType type = it.next();
        if (referencedTypes.contains(type) || program.typeOracle.isInstantiatedType(type)) {
          accept(type);
        } else {
          prunedMethods.addAll(type.getMethods());
          methodsWereRemoved(type.getMethods());
          fieldsWereRemoved(type.getFields());
          it.remove();
          madeChanges();
        }
      }
      return false;
    }

    private void removeFields(Predicate<JNode> shouldRemove, JDeclaredType type) {
      for (int i = 0; i < type.getFields().size(); ++i) {
        JField field = type.getFields().get(i);
        if (!shouldRemove.apply(field)) {
          continue;
        }
        wasRemoved(field);
        type.removeField(i);
        madeChanges();
        --i;
      }
    }

    private void removeMethods(Predicate<JNode> shouldRemove, JDeclaredType type) {

      assert type.getMethods().get(0) == type.getClinitMethod();
      for (int i = 1; i < type.getMethods().size(); ++i) {
        JMethod method = type.getMethods().get(i);
        if (!shouldRemove.apply(method)) {
          continue;
        }
        prunedMethods.add(method);
        wasRemoved(method);
        type.removeMethod(i);
        program.removeStaticImplMapping(method);
        madeChanges();
        --i;
      }
    }
  }

  private static final String NAME = Pruner.class.getSimpleName();

  public static OptimizerStats exec(JProgram program, boolean noSpecialTypes,
      OptimizerContext optimizerCtx) {
    Event optimizeEvent = SpeedTracerLogger.start(CompilerEventType.OPTIMIZE, "optimizer", NAME);
    OptimizerStats stats = new Pruner(program, noSpecialTypes).execImpl(optimizerCtx);
    optimizeEvent.end("didChange", "" + stats.didChange());
    return stats;
  }

  public static OptimizerStats exec(JProgram program, boolean noSpecialTypes) {
    return exec(program, noSpecialTypes, OptimizerContext.NULL_OPTIMIZATION_CONTEXT);
  }


  public static JFieldRef transformToNullFieldRef(JFieldRef x, JProgram program) {
    JExpression instance = x.getInstance();




    if (x.getField().isStatic() && instance == null) {
      instance = program.getLiteralNull();
    }

    assert instance != null;
    if (!instance.hasSideEffects()) {
      instance = program.getLiteralNull();
    }

    JFieldRef fieldRef =
        new JFieldRef(x.getSourceInfo(), instance, program.getNullField(), x.getEnclosingType(),
            primitiveTypeOrNullTypeOrArray(program, x.getType()));
    return fieldRef;
  }


  public static JMethodCall transformToNullMethodCall(JMethodCall x, JProgram program) {
    JExpression instance = x.getInstance();
    List<JExpression> args = x.getArgs();
    if (program.isStaticImpl(x.getTarget())) {
      instance = args.get(0);
      args = args.subList(1, args.size());
    } else {



      if (x.getTarget().isStatic() && instance == null) {
        instance = program.getLiteralNull();
      }
    }
    assert (instance != null);
    if (!instance.hasSideEffects()) {
      instance = program.getLiteralNull();
    }

    JMethodCall newCall =
        new JMethodCall(x.getSourceInfo(), instance, program.getNullMethod(),
            primitiveTypeOrNullTypeOrArray(program, x.getType()));

    for (JExpression arg : args) {
      if (arg.hasSideEffects()) {
        newCall.addArg(arg);
      }
    }
    return newCall;
  }


  static JType primitiveTypeOrNullTypeOrArray(JProgram program, JType type) {
    if (type instanceof JArrayType) {
      JType leafType = primitiveTypeOrNullTypeOrArray(program, ((JArrayType) type).getLeafType());
      return program.getOrCreateArrayType(leafType, ((JArrayType) type).getDims());
    }
    if (type instanceof JPrimitiveType) {
      return type;
    }
    return JReferenceType.NULL_TYPE;
  }

  private final JProgram program;

  private final boolean saveCodeGenTypes;

  private final Set<JMethod> prunedMethods = Sets.newLinkedHashSet();

  private Pruner(JProgram program, boolean saveCodeGenTypes) {
    this.program = program;
    this.saveCodeGenTypes = saveCodeGenTypes;
  }

  private OptimizerStats execImpl(OptimizerContext optimizerCtx) {
    OptimizerStats stats = new OptimizerStats(NAME);

    ControlFlowAnalyzer livenessAnalyzer = new ControlFlowAnalyzer(program);




    livenessAnalyzer.rescue(program.typeOracle.getInstantiatedJsoTypesViaCast());
    livenessAnalyzer.setForPruning();


    traverseTypes(livenessAnalyzer, program.immortalCodeGenTypes);

    if (saveCodeGenTypes) {

      traverseTypes(livenessAnalyzer, program.codeGenTypes);
    }
    livenessAnalyzer.traverseEverything();

    program.typeOracle.setInstantiatedTypes(livenessAnalyzer.getInstantiatedTypes());

    PruneVisitor pruner =
        new PruneVisitor(livenessAnalyzer.getReferencedTypes(), livenessAnalyzer
            .getLiveFieldsAndMethods(), optimizerCtx);
    pruner.accept(program);
    stats.recordModified(pruner.getNumMods());

    if (!pruner.didChange()) {
      return stats;
    }
    CleanupRefsVisitor cleaner =
        new CleanupRefsVisitor(livenessAnalyzer.getLiveFieldsAndMethods(), pruner
            .getPriorParametersByMethod(), optimizerCtx);
    cleaner.accept(program.getDeclaredTypes());
    optimizerCtx.incOptimizationStep();
    optimizerCtx.syncDeletedSubCallGraphsSince(optimizerCtx.getLastStepFor(NAME) + 1,
        prunedMethods);
    JavaAstVerifier.assertProgramIsConsistent(program);
    return stats;
  }


  private void traverseTypes(ControlFlowAnalyzer livenessAnalyzer,
      List<JClassType> types) {
    for (JClassType type : types) {
      livenessAnalyzer.traverseFromReferenceTo(type);
      for (JMethod method : type.getMethods()) {
        if (method instanceof JConstructor) {
          livenessAnalyzer.traverseFromInstantiationOf(type);
        }
        livenessAnalyzer.traverseFrom(method);
      }
    }
  }
}

<code block>

package com.google.gwt.dev.jjs.impl;

import com.google.gwt.dev.jjs.ast.Context;
import com.google.gwt.dev.jjs.ast.JCastOperation;
import com.google.gwt.dev.jjs.ast.JClassType;
import com.google.gwt.dev.jjs.ast.JDeclaredType;
import com.google.gwt.dev.jjs.ast.JInterfaceType;
import com.google.gwt.dev.jjs.ast.JProgram;
import com.google.gwt.dev.jjs.ast.JReferenceType;
import com.google.gwt.dev.jjs.ast.JType;
import com.google.gwt.dev.jjs.ast.JVisitor;

import java.util.HashSet;
import java.util.Set;


public class ComputeInstantiatedJsoInterfaces {
  class InstantiatedJsoInterfacesCollector extends JVisitor {
    @Override
    public void endVisit(JCastOperation x, Context ctx) {
      JType toType = x.getCastType();

      if (toType instanceof JReferenceType && !toType.isNullType()) {
        toType = toType.getUnderlyingType();
        if (program.typeOracle.willCrossCastLikeJso(toType) ||
            program.typeOracle.isOrExtendsJsType(toType, true) ||
            program.typeOracle.isJsFunction(toType)) {
          instantiateJsoInterface((JReferenceType) toType);
        }
      }
    }
  }

  private void instantiateJsoInterface(JReferenceType toType) {
    if (instantiatedJsoTypes.add(toType)) {
      if (program.typeOracle.getSingleJsoImpl(toType) != null) {

        instantiateJsoInterface(program.typeOracle.getSingleJsoImpl(toType));
      }

      if (toType instanceof JClassType) {
        JClassType superType = ((JClassType) toType).getSuperClass();
        if (superType != null && superType.isJsoType()) {
          instantiateJsoInterface(superType);
        }
      }

      for (JInterfaceType intf : ((JDeclaredType) toType).getImplements()) {
        if (intf.isJsType() || program.typeOracle.getSingleJsoImpl(intf) != null) {
          instantiateJsoInterface(intf);
        }
      }
    }
  }

  private final JProgram program;
  private final Set<JReferenceType> instantiatedJsoTypes = new HashSet<JReferenceType>();

  public static void exec(JProgram program) {
    new ComputeInstantiatedJsoInterfaces(program).execImpl();
  }

  private ComputeInstantiatedJsoInterfaces(JProgram program) {
    this.program = program;
  }

  private void execImpl() {
    InstantiatedJsoInterfacesCollector replacer = new InstantiatedJsoInterfacesCollector();
    replacer.accept(program);
    program.typeOracle.setInstantiatedJsoTypesViaCast(instantiatedJsoTypes);
  }
}

<code block>

package com.google.gwt.dev.js;

import com.google.gwt.core.ext.UnableToCompleteException;
import com.google.gwt.core.ext.linker.SymbolData;
import com.google.gwt.core.ext.linker.impl.StandardSymbolData;
import com.google.gwt.dev.CompilerContext;
import com.google.gwt.dev.MinimalRebuildCache;
import com.google.gwt.dev.PrecompileTaskOptions;
import com.google.gwt.dev.PrecompileTaskOptionsImpl;
import com.google.gwt.dev.cfg.BindingProperties;
import com.google.gwt.dev.cfg.BindingProperty;
import com.google.gwt.dev.cfg.ConditionNone;
import com.google.gwt.dev.cfg.ConfigurationProperties;
import com.google.gwt.dev.cfg.ConfigurationProperty;
import com.google.gwt.dev.cfg.PermutationProperties;
import com.google.gwt.dev.javac.CompilationState;
import com.google.gwt.dev.javac.CompilationStateBuilder;
import com.google.gwt.dev.javac.testing.impl.MockJavaResource;
import com.google.gwt.dev.javac.testing.impl.MockResourceOracle;
import com.google.gwt.dev.jjs.AstConstructor;
import com.google.gwt.dev.jjs.JavaAstConstructor;
import com.google.gwt.dev.jjs.JsOutputOption;
import com.google.gwt.dev.jjs.ast.JProgram;
import com.google.gwt.dev.jjs.impl.ArrayNormalizer;
import com.google.gwt.dev.jjs.impl.CatchBlockNormalizer;
import com.google.gwt.dev.jjs.impl.ComputeCastabilityInformation;
import com.google.gwt.dev.jjs.impl.ComputeInstantiatedJsoInterfaces;
import com.google.gwt.dev.jjs.impl.FullCompileTestBase;
import com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST;
import com.google.gwt.dev.jjs.impl.ImplementCastsAndTypeChecks;
import com.google.gwt.dev.jjs.impl.JavaToJavaScriptMap;
import com.google.gwt.dev.jjs.impl.MethodInliner;
import com.google.gwt.dev.jjs.impl.ResolveRuntimeTypeReferences;
import com.google.gwt.dev.jjs.impl.ResolveRuntimeTypeReferences.StringTypeMapper;
import com.google.gwt.dev.jjs.impl.ResolveRuntimeTypeReferences.TypeMapper;
import com.google.gwt.dev.jjs.impl.ResolveRuntimeTypeReferences.TypeOrder;
import com.google.gwt.dev.js.ast.JsFunction;
import com.google.gwt.dev.js.ast.JsName;
import com.google.gwt.dev.js.ast.JsProgram;
import com.google.gwt.dev.js.ast.JsVisitable;
import com.google.gwt.dev.js.ast.JsVisitor;
import com.google.gwt.dev.util.DefaultTextOutput;
import com.google.gwt.dev.util.TextOutput;
import com.google.gwt.thirdparty.guava.common.base.Joiner;

import java.util.Arrays;
import java.util.Map;
import java.util.TreeMap;


public class JsStackEmulatorTest extends FullCompileTestBase {

  private final ConfigurationProperty recordFileNamesProp =
      new ConfigurationProperty("compiler.emulatedStack.recordFileNames", false);

  private final ConfigurationProperty recordLineNumbersProp =
      new ConfigurationProperty("compiler.emulatedStack.recordLineNumbers", false);

  private boolean inline = false;

  public void testEmptyMethod() throws Exception {
    recordFileNamesProp.setValue("true");
    recordLineNumbersProp.setValue("true");

    JsProgram program = compileClass(
        "package test;",
        "public class EntryPoint {",
        "  public static void onModuleLoad() {",
        "  }",
        "}");

    checkOnModuleLoad(program, "function onModuleLoad(){" +
        "var stackIndex;$stack[stackIndex=++$stackDepth]=onModuleLoad;" +
        "$location[stackIndex]='EntryPoint.java:'+'3',$clinit_EntryPoint();" +
        "$stackDepth=stackIndex-1}");
  }

  public void testCallWithNoArguments() throws Exception {
    recordFileNamesProp.setValue("true");
    recordLineNumbersProp.setValue("true");

    JsProgram program = compileClass(
        "package test;",
        "public class EntryPoint {",
        "  static void foo() {}",
        "  public static void onModuleLoad() {",
        "    foo();",
        "  }",
        "}");

    checkOnModuleLoad(program, "function onModuleLoad(){" +
        "var stackIndex;$stack[stackIndex=++$stackDepth]=onModuleLoad;" +
        "$location[stackIndex]='EntryPoint.java:'+'4',$clinit_EntryPoint();" +
        "$location[stackIndex]='EntryPoint.java:'+'5',foo();" +
        "$stackDepth=stackIndex-1}");
  }

  public void testCallWithArguments() throws Exception {
    recordFileNamesProp.setValue("true");
    recordLineNumbersProp.setValue("true");

    JsProgram program = compileClass(
        "package test;",
        "public class EntryPoint {",
        "  static void foo(int x) {}",
        "  public static void onModuleLoad() {",
        "    foo(123);",
        "  }",
        "}");

    checkOnModuleLoad(program, "function onModuleLoad(){" +
        "var stackIndex;$stack[stackIndex=++$stackDepth]=onModuleLoad;" +
        "$location[stackIndex]='EntryPoint.java:'+'4',$clinit_EntryPoint();" +
        "foo(($tmp=123,$location[stackIndex]='EntryPoint.java:'+'5',$tmp));" +
        "$stackDepth=stackIndex-1}");
  }

  public void testSimpleThrow() throws Exception {
    recordFileNamesProp.setValue("true");
    recordLineNumbersProp.setValue("true");

    JsProgram program = compileClass(
        "package test;",
        "public class EntryPoint {",
        "  public static void onModuleLoad() {",
        "    throw new RuntimeException();",
        "  }",
        "}");


    checkOnModuleLoad(program, "function onModuleLoad(){" +
        "var stackIndex;$stack[stackIndex=++$stackDepth]=onModuleLoad;" +
        "$location[stackIndex]='EntryPoint.java:'+'3',$clinit_EntryPoint();" +
        "throw $location[stackIndex]='EntryPoint.java:'+'4',new RuntimeException" +
        "}");
  }

  public void testThrowWithInlineMethodCall() throws Exception {
    recordFileNamesProp.setValue("true");
    recordLineNumbersProp.setValue("true");
    inline = true;

    JsProgram program = compileClass(
        "package test;",
        "public class EntryPoint {",
        "  static Object thing = \"hello\";",
        "  private static String message() { return thing", 
        "    .toString(); }",
        "  public static void onModuleLoad() {", 
        "    throw new RuntimeException(message());", 
        "  }",
        "}");


    checkOnModuleLoad(program, "function onModuleLoad(){" +
        "var stackIndex;$stack[stackIndex=++$stackDepth]=onModuleLoad;" +
        "$location[stackIndex]='EntryPoint.java:'+'6',$clinit_EntryPoint();" +
        "throw new RuntimeException(" +
        "($tmp=($location[stackIndex]='EntryPoint.java:'+'4',thing).toString$()," +
        "$location[stackIndex]='EntryPoint.java:'+'7',$tmp))" +
        "}");
  }

  public void testThrowWithChainedMethodCall() throws Exception {
    recordFileNamesProp.setValue("true");
    recordLineNumbersProp.setValue("true");
    inline = true;

    JsProgram program = compileClass(
        "package test;",
        "public class EntryPoint {",
        "  static Factory factory;",
        "  static Factory getFactory() {",
        "    return factory;", 
        "  }",
        "  public static void onModuleLoad() {", 
        "    throw getFactory().makeException();", 
        "  }",
        "  static class Factory {",
        "    RuntimeException makeException() {",
        "      return new RuntimeException();",
        "    }",
        "  }",
        "}");

    checkOnModuleLoad(program, "function onModuleLoad(){" +
        "var stackIndex;$stack[stackIndex=++$stackDepth]=onModuleLoad;" +
        "$location[stackIndex]='EntryPoint.java:'+'7',$clinit_EntryPoint();" +
        "throw unwrap(($tmp=($location[stackIndex]='EntryPoint.java:'+'5',factory)," +
        "$location[stackIndex]='EntryPoint.java:'+'8',$tmp).makeException())" +
        "}");
  }

  public void testTryCatch() throws Exception {
    recordFileNamesProp.setValue("true");
    recordLineNumbersProp.setValue("true");

    JsProgram program = compileClass(
        "package test;",
        "public class EntryPoint {",
        "  public static void onModuleLoad() {",
        "    try {",
        "      throw new RuntimeException();",
        "    } catch (RuntimeException e) {" ,
        "      String s = e.getMessage();",
        "    }",
        "  }",
        "}");


    checkOnModuleLoad(program, "function onModuleLoad(){" +
        "var stackIndex;$stack[stackIndex=++$stackDepth]=onModuleLoad;" +
        "$location[stackIndex]='EntryPoint.java:'+'3',$clinit_EntryPoint();var e,s;" +
        "try{throw $location[stackIndex]='EntryPoint.java:'+'5',new RuntimeException" +
        "}catch($e0){$e0=wrap($e0);" +
        "$stackDepth=($location[stackIndex]='EntryPoint.java:'+'6',stackIndex);" +
        "if(instanceOf($e0,'java.lang.RuntimeException')){" +
        "e=$e0;s=($location[stackIndex]='EntryPoint.java:'+'7',e).getMessage()}" +
        "else throw unwrap(($location[stackIndex]='EntryPoint.java:'+'6',$e0))}" +
        "$stackDepth=stackIndex-1" +
        "}");
  }


  private JsProgram compileClass(String... lines) throws UnableToCompleteException {



    final String code = Joiner.on("\n").join(lines);

    MockResourceOracle sourceOracle = new MockResourceOracle();
    sourceOracle.addOrReplace(new MockJavaResource("test.EntryPoint") {
      @Override
      public CharSequence getContent() {
        return code;
      }
    });
    sourceOracle.add(JavaAstConstructor.getCompilerTypes());

    PrecompileTaskOptions options = new PrecompileTaskOptionsImpl();
    options.setOutput(JsOutputOption.PRETTY);
    options.setRunAsyncEnabled(false);
    CompilerContext context = new CompilerContext.Builder().options(options)
        .minimalRebuildCache(new MinimalRebuildCache()).build();

    ConfigurationProperties config = new ConfigurationProperties(Arrays.asList(recordFileNamesProp,
        recordLineNumbersProp));

    CompilationState state =
        CompilationStateBuilder.buildFrom(logger, context,
            sourceOracle.getResources(), null);
    JProgram jProgram = AstConstructor.construct(logger, state, options, config);
    jProgram.addEntryMethod(findMethod(jProgram, "onModuleLoad"));

    if (inline) {
      MethodInliner.exec(jProgram);
    }

    CatchBlockNormalizer.exec(jProgram);



    ComputeCastabilityInformation.exec(jProgram, false);
    ComputeInstantiatedJsoInterfaces.exec(jProgram);
    ImplementCastsAndTypeChecks.exec(jProgram, false);
    ArrayNormalizer.exec(jProgram, false);

    TypeMapper<String> typeMapper = new StringTypeMapper();
    ResolveRuntimeTypeReferences.exec(jProgram, typeMapper, TypeOrder.FREQUENCY);
    Map<StandardSymbolData, JsName> symbolTable =
        new TreeMap<StandardSymbolData, JsName>(new SymbolData.ClassIdentComparator());

    BindingProperty stackMode = new BindingProperty("compiler.stackMode");
    stackMode.addDefinedValue(new ConditionNone(), "EMULATED");

    PermutationProperties properties = new PermutationProperties(Arrays.asList(
        new BindingProperties(new BindingProperty[]{stackMode}, new String[]{"EMULATED"}, config)
    ));

    JsProgram jsProgram = new JsProgram();
    JavaToJavaScriptMap jjsmap = GenerateJavaScriptAST.exec(
        logger, jProgram, jsProgram, context, typeMapper,
        symbolTable, properties).getLeft();


    JsStackEmulator.exec(jProgram, jsProgram, properties, jjsmap);

    return jsProgram;
  }


  private static void checkOnModuleLoad(JsProgram program, String expectedJavascript) {
    JsName onModuleLoad = program.getScope().findExistingName("test_EntryPoint_onModuleLoad__V");
    assertNotNull(onModuleLoad);
    assert onModuleLoad.getStaticRef() instanceof JsFunction;
    assertEquals(expectedJavascript, serializeJs(onModuleLoad.getStaticRef()));
  }

  private static String serializeJs(JsVisitable node) {
    TextOutput text = new DefaultTextOutput(true);
    JsVisitor generator = new JsSourceGenerationVisitor(text);
    generator.accept(node);
    return text.toString();
  }

  @Override
  protected void optimizeJava() {
  }
}

<code block>

package com.google.gwt.dev.jjs.impl;

import com.google.gwt.core.ext.UnableToCompleteException;
import com.google.gwt.core.ext.linker.SymbolData;
import com.google.gwt.core.ext.linker.impl.StandardSymbolData;
import com.google.gwt.dev.CompilerContext;
import com.google.gwt.dev.cfg.BindingProperties;
import com.google.gwt.dev.cfg.BindingProperty;
import com.google.gwt.dev.cfg.ConditionNone;
import com.google.gwt.dev.cfg.ConfigurationProperties;
import com.google.gwt.dev.cfg.ConfigurationProperty;
import com.google.gwt.dev.cfg.PermutationProperties;
import com.google.gwt.dev.javac.CompilationState;
import com.google.gwt.dev.javac.CompilationStateBuilder;
import com.google.gwt.dev.javac.testing.impl.MockJavaResource;
import com.google.gwt.dev.jjs.JavaAstConstructor;
import com.google.gwt.dev.jjs.ast.JProgram;
import com.google.gwt.dev.jjs.impl.ResolveRuntimeTypeReferences.IntTypeMapper;
import com.google.gwt.dev.jjs.impl.ResolveRuntimeTypeReferences.TypeMapper;
import com.google.gwt.dev.jjs.impl.ResolveRuntimeTypeReferences.TypeOrder;
import com.google.gwt.dev.js.ast.JsName;
import com.google.gwt.dev.js.ast.JsNode;
import com.google.gwt.dev.js.ast.JsProgram;
import com.google.gwt.dev.util.Pair;
import com.google.gwt.thirdparty.guava.common.collect.Lists;

import java.util.Arrays;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;


public abstract class FullCompileTestBase extends JJSTestBase {


  private BindingProperty[] orderedProps = null;
  private String[] orderedPropValues = null;
  private ConfigurationProperty[] configurationProperties = {};

  protected JProgram jProgram = null;
  protected JsProgram jsProgram = null;

  @Override
  public void setUp() throws Exception {
    super.setUp();

    BindingProperty stackMode = new BindingProperty("compiler.stackMode");
    stackMode.addDefinedValue(new ConditionNone(), "STRIP");
    setProperties(new BindingProperty[]{stackMode}, new String[]{"STRIP"},
        new ConfigurationProperty[]{});

    jsProgram = new JsProgram();
  }


  protected Pair<JavaToJavaScriptMap, Set<JsNode>> compileSnippetToJS(final String code)
      throws UnableToCompleteException {
    sourceOracle.addOrReplace(new MockJavaResource("test.EntryPoint") {
      @Override
      public CharSequence getContent() {
        return code;
      }
    });

    CompilerContext compilerContext = provideCompilerContext();
    CompilationState state =
        CompilationStateBuilder.buildFrom(logger, compilerContext,
            sourceOracle.getResources(), getAdditionalTypeProviderDelegate());
    ConfigurationProperties config = new ConfigurationProperties(Lists.newArrayList(
        configurationProperties));

    jProgram =
        JavaAstConstructor.construct(logger, state, compilerContext, config,
            "test.EntryPoint", "com.google.gwt.lang.Exceptions");
    jProgram.addEntryMethod(findMethod(jProgram, "onModuleLoad"));

    optimizeJava();
    ComputeCastabilityInformation.exec(jProgram, false);
    ComputeInstantiatedJsoInterfaces.exec(jProgram);
    ImplementCastsAndTypeChecks.exec(jProgram, false);
    ArrayNormalizer.exec(jProgram, false);
    TypeTightener.exec(jProgram);
    MethodCallTightener.exec(jProgram);

    TypeMapper<Integer> typeMapper = new IntTypeMapper();
    ResolveRuntimeTypeReferences.exec(jProgram, typeMapper, TypeOrder.FREQUENCY);

    Map<StandardSymbolData, JsName> symbolTable =
        new TreeMap<StandardSymbolData, JsName>(new SymbolData.ClassIdentComparator());

    PermutationProperties props = new PermutationProperties(Arrays.asList(
        new BindingProperties(orderedProps, orderedPropValues, config)
    ));
    return GenerateJavaScriptAST.exec(logger, jProgram, jsProgram, compilerContext,
        typeMapper, symbolTable, props);
  }

  abstract protected void optimizeJava();

  protected CompilerContext provideCompilerContext() {
    CompilerContext compilerContext = new CompilerContext.Builder().build();
    compilerContext.getOptions().setSourceLevel(sourceLevel);
    return compilerContext;
  }

  public void setProperties(BindingProperty[] orderedProps, String[] orderedValues,
      ConfigurationProperty[] configurationProperties) {
    this.orderedProps = orderedProps;
    this.orderedPropValues = orderedValues;
    this.configurationProperties = configurationProperties;
  }
}

<code block>

package com.google.gwt.dev.jjs.impl;

import com.google.gwt.core.ext.TreeLogger;
import com.google.gwt.core.ext.UnableToCompleteException;
import com.google.gwt.dev.jjs.ast.Context;
import com.google.gwt.dev.jjs.ast.JDeclarationStatement;
import com.google.gwt.dev.jjs.ast.JFieldRef;
import com.google.gwt.dev.jjs.ast.JMethod;
import com.google.gwt.dev.jjs.ast.JProgram;
import com.google.gwt.dev.jjs.ast.JValueLiteral;
import com.google.gwt.dev.jjs.ast.JVisitor;
import com.google.gwt.dev.jjs.impl.EnumOrdinalizer.Tracker;


public class EnumOrdinalizerTest extends OptimizerTestBase {

  private final boolean performCastReplacement = true;
  private final boolean runEqualityNormalizer = true;

  private boolean runMakeCallsStatic;
  private boolean runMethodInliner;
  private boolean runMethodCallTightener;
  private boolean runPruner;
  private boolean runTypeTightener;

  @Override
  protected void setUp() throws Exception {
    super.setUp();
    EnumOrdinalizer.enableTracker();
    EnumOrdinalizer.resetTracker();


    runTypeTightener = false;
    runMethodCallTightener = false;
    runMethodInliner = true;
    runMakeCallsStatic = true;




    runPruner = true;
  }

  @Override
  protected void tearDown() throws Exception {
    super.tearDown();
  }

  public void testOrdinalizeBasicAssignment()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Fruit apple = Fruit.APPLE;",
        "Fruit orange = Fruit.ORANGE;");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testOrdinalizeNewArrayAndAssignmentLocalRef()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result =
        optimize("void", "Fruit[] fruits = new Fruit[] {Fruit.APPLE, Fruit.ORANGE, Fruit.APPLE};",
            "if (fruits[0] == Fruit.APPLE) {",
            "  fruits[0] = Fruit.ORANGE;",
            "}");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testOrdinalizeNewArrayOfArrayAndAssignmentLocalRef()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result =
        optimize("void", "Fruit[][] fruits = new Fruit[][] ",
            " {{Fruit.APPLE, Fruit.ORANGE},{Fruit.APPLE, Fruit.ORANGE}};",
            "if (fruits[0][1] == Fruit.APPLE) {",
            "  fruits[0][1] = Fruit.ORANGE;",
            "}");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testOrdinalizeNewArrayAndAssignmentFieldRef()
      throws UnableToCompleteException {
    setupFruitEnum();
    addSnippetClassDecl("private final Fruit[] fruits = new Fruit[] ",
        "  {Fruit.APPLE, Fruit.ORANGE, Fruit.APPLE};");
    Result result = optimize("void", "EntryPoint ep = new EntryPoint();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testOrdinalizableFinalFieldUninitializedByDefault()
      throws UnableToCompleteException {
    setupFruitEnum();
    addSnippetClassDecl("private final Fruit uninitializedFinalFruit;",
        "public EntryPoint() {",
        "  uninitializedFinalFruit = Fruit.ORANGE;",
        "}");
    Result result = optimize("void", "EntryPoint ep = new EntryPoint();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testOrdinalizeSwitchStatement()
      throws UnableToCompleteException {
    setupFruitEnum();
    setupFruitSwitchMethod();
    Result result = optimize("void", "String apple = fruitSwitch(Fruit.APPLE);",
        "String orange = fruitSwitch(Fruit.ORANGE);");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testOrdinalizeIfStatement()
      throws UnableToCompleteException {
    setupFruitEnum();
    addSnippetClassDecl(
        "public static String fruitIf(Fruit fruit) {",
        " if (fruit == Fruit.APPLE) {",
        "   return \"Apple\";",
        " } else if (fruit == Fruit.ORANGE) {",
        "   return \"Orange\";",
        " } else {",
        "   return \"Unknown\";",
        " }",
        "}");
    Result result = optimize("void", "String apple = fruitIf(Fruit.APPLE);",
        "String orange = fruitIf(Fruit.ORANGE);");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testOrdinalizeConditional()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void",
        "Fruit fruit = (new Integer(1)).toString().isEmpty() ? Fruit.APPLE : Fruit.ORANGE;");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testOrdinalizeFieldRefOrdinalMethodCall()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "int i = Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testOrdinalizeVariableRefOrdinalMethodCall()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Fruit fruit = Fruit.APPLE;",
        "int i = fruit.ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testOrdinalizeUnusedEmptyEnum() throws UnableToCompleteException {
    setupEmptyEnum();

    Result result = optimize("void", "EmptyEnum myEnum;");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isOrdinalized("test.EntryPoint$EmptyEnum") ||
        !tracker.isVisited("test.EntryPoint$EmptyEnum"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testOrdinalizeUnusedEnum() throws UnableToCompleteException {
    setupFruitEnum();

    Result result = optimize("void", "Fruit myEnum;");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Fruit") ||
        !tracker.isVisited("test.EntryPoint$Fruit"));



    tracker.addOrdinalized("test.EntryPoint$Fruit");
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testOrdinalizeMethodCallExpressionOrdinalFieldRef()
      throws UnableToCompleteException {
    setupFruitEnum();
    addSnippetClassDecl("public static Fruit getResolvedFruit(Fruit fruit) {",
        "  if (fruit == Fruit.APPLE) {",
        "    return Fruit.ORANGE;",
        "  } else { ",
        "    return Fruit.APPLE;",
        "  }",
        "}");
    addSnippetClassDecl("public static int switchMethodCall(Fruit fruit) {",
        "  int retVal = 0;",
        "  switch (getResolvedFruit(fruit)) {",
        "    case APPLE: retVal = 12; break;",
        "    case ORANGE:retVal = 73; break;",
        "  }",
        "  return retVal;",
        "}");
    Result result = optimize("void", "int i = switchMethodCall(Fruit.APPLE);",
        "Fruit fruit = Fruit.ORANGE;",
        "int j = switchMethodCall(fruit);");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testOrdinalizableStaticFieldRef()
      throws UnableToCompleteException {

    setupFruitEnumWithStaticField();
    Result result = optimize("void",
        "String y = Fruit.staticField + Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testOrdinalizableStaticMethod()
      throws UnableToCompleteException {

    setupFruitEnumWithStaticMethod();
    Result result = optimize("void", "int y = Fruit.staticMethod() + Fruit.APPLE.ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testOrdinalizableCallingValues()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "int l = Fruit.values().length;",
        "int ord = Fruit.APPLE.ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testOrdinalizableStaticFieldRefToVALUES()
      throws UnableToCompleteException {


    setupFruitEnum();
    Result result = optimize("void", "Fruit[] fruits = Fruit.values();",
        "int ord = Fruit.APPLE.ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testOrdinalizableStaticMethodThatRefsValuesLength()
      throws UnableToCompleteException {

    setupFruitEnumWithStaticMethodThatRefsValuesLength();
    Result result = optimize("void", "Fruit y = Fruit.forInteger(0);",
        "int ord = Fruit.APPLE.ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableInstanceStaticFieldRef()
      throws UnableToCompleteException {

    setupFruitEnumWithStaticField();
    Result result = optimize("void", "Fruit fruit = Fruit.APPLE;",
        "String y = fruit.staticField;");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableInstanceStaticMethod()
      throws UnableToCompleteException {

    setupFruitEnumWithStaticMethod();
    Result result = optimize("void", "Fruit fruit = Fruit.APPLE;",
        "int y = fruit.staticMethod();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableClassLiteralReference()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Class clazz = Fruit.class;",
        "String clazzStr = clazz.toString() + Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableEnumValueOfWithClassLiteralArg()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Object Carrot = Enum.valueOf(Fruit.class, \"APPLE\");",
        "String carrot = Carrot.toString() + Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableGetClassMethodCall()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Class clazz = Fruit.APPLE.getClass();",
        "String clazzStr = clazz.toString() + Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableExplicitCastToEnumClass()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Object obj = new Object();",
        "Fruit fruit = (Fruit) obj;",
        "int ord = Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableExplicitCastToArrayOfEnumClass()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Enum[] enumArray = new Enum[10];",
        "Fruit[] fruitArray = (Fruit[]) enumArray;",
        "int ord = Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableExplicitCastFromArrayOfEnumClass()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Fruit[] fruitArray = new Fruit[10];",
        "Enum[] enumArray = (Enum[]) fruitArray;",
        "int ord = Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableExplicitCastToArrayOfArrayOfEnumClass()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Enum[][] enumArray = new Enum[10][10];",
        "Fruit[][] fruitArray = (Fruit[][]) enumArray;",
        "int ord = Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableExplicitCastFromArrayOfArrayOfEnumClass()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Fruit[][] fruitArray = new Fruit[10][10];",
        "Enum[][] enumArray = (Enum[][]) fruitArray;",
        "int ord = Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableExplicitCastFromEnumClass()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Enum Carrot = (Enum) Fruit.APPLE;",
        "String carrot = Carrot.toString();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableOrdinalMethodRefFromExplicitCastWithBlackListableSubExpression()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "int ord = " +
        "((Fruit) Enum.valueOf(Fruit.class,\"APPLE\")).ordinal();",
        "int ord2 = Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableInstanceFieldRef()
      throws UnableToCompleteException {

    setupFruitEnumWithInstanceField();
    Result result = optimize("void", "String instanceField = Fruit.APPLE.instanceField;");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableInstanceOfEnumExpression()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Fruit fruit = Fruit.APPLE;",
        "if (fruit instanceof Enum) {",
        "  fruit = Fruit.ORANGE;",
        "}");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableInstanceOfEnumTestType()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Object fruitObj = new Object();",
        "if (fruitObj instanceof Fruit) {",
        "  fruitObj = null;",
        "}",
        "int ord = Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableStaticMethodCallValues()
      throws UnableToCompleteException {

    runMethodInliner = false;

    setupFruitEnum();
    Result result = optimize("void", "Fruit[] fruits = Fruit.values();",
        "int ord = Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableJsniFieldRef()
      throws UnableToCompleteException {
    setupFruitEnum();
    addSnippetClassDecl("public static Fruit instanceFruit;");
    addSnippetClassDecl("public static native void jsniMethod() /*-{",
        "  var x = @test.EntryPoint::instanceFruit",
        "}-*/");
    Result result = optimize("void", "instanceFruit = Fruit.APPLE;",
        "jsniMethod();",
        "int ord = Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableJsniFieldRefStatic()
      throws UnableToCompleteException {
    setupFruitEnum();
    addSnippetClassDecl("public static native void jsniMethod() /*-{",
        "  var x = @test.EntryPoint.Fruit::APPLE",
        "}-*/");
    Result result = optimize("void", "jsniMethod();",
        "int ord = Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableJsniFieldRefClassLiteral()
      throws UnableToCompleteException {
    setupFruitEnum();
    addSnippetClassDecl("public static native void jsniMethod() /*-{",
        "  var x = @test.EntryPoint.Fruit::class",
        "}-*/");
    Result result = optimize("void", "jsniMethod();",
        "int ord = Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastBinaryOpAssignment()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void",
        "Enum tomato;",
        "tomato = Fruit.APPLE;",
        "int ord = tomato.ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastFieldInitializedWithNullByDefault()
      throws UnableToCompleteException {
    setupFruitEnum();
    addSnippetClassDecl("static private Fruit uninitializedFruitAsNull;");
    Result result = optimize("void", "if (uninitializedFruitAsNull != Fruit.APPLE) {",
        "  uninitializedFruitAsNull = Fruit.ORANGE;",
        "}",
        "int ord = Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastBinaryOpEquals()
      throws UnableToCompleteException {
    setupFruitAndVegetableEnums();
    Result result = optimize("void", "Fruit fruit = Fruit.APPLE;",
        "Enum carrot = (Enum) Vegetable.CARROT;",
        "boolean test = (fruit == carrot);");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertTrue(tracker.isVisited("test.EntryPoint$Vegetable"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Vegetable"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastBinaryOpNotEquals()
      throws UnableToCompleteException {
    setupFruitAndVegetableEnums();
    Result result = optimize("void", "Fruit fruit = Fruit.APPLE;",
        "Enum carrot = (Enum) Vegetable.CARROT;",

        "boolean test = (carrot != fruit);");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertTrue(tracker.isVisited("test.EntryPoint$Vegetable"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Vegetable"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastBinaryOpEqualsNull()
      throws UnableToCompleteException {
    setupFruitEnum();
    addSnippetClassDecl("public static boolean testIsNull(Fruit fruit) {",
        "  if (fruit == null) {",
        "    return true;",
        "    } else {",
        "    return false;",
        "    }",
        "}");
    Result result = optimize("void", "Fruit fruit = Fruit.APPLE;",
        "boolean isNull = testIsNull(fruit) || testIsNull(Fruit.ORANGE);");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastBinaryOpNotEqualsNull()
      throws UnableToCompleteException {
    setupFruitEnum();
    addSnippetClassDecl("public static boolean testIsNull(Fruit fruit) {",
        "  if (fruit != null) {",
        "    return true;",
        "  } else {",
        "    return false;",
        "  }",
        "}");
    Result result = optimize("void", "Fruit fruit = Fruit.APPLE;",
        "boolean isNull = testIsNull(fruit) || testIsNull(Fruit.ORANGE);");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastBinaryOpStringConcat()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Fruit fruit = Fruit.APPLE;",
        "String str = \"A string followed by \" + fruit;");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastBinaryOpStringConcat2()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Fruit fruit = Fruit.APPLE;",
        "String str = fruit + \" followed by a string\";");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastBinaryOpStringConcatAssignment()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Fruit fruit = Fruit.APPLE;",
        "String str = \"A string concatenated with: \";",
        "str += fruit;");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastDeclarationToNull()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Fruit fruit = null;",
        "int ord = fruit == null ? Util.notInlineable(Fruit.APPLE).ordinal() : fruit.ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastAssignmentToNull()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Fruit fruit;",
        "fruit = null;",
        "int ord = fruit == null ? Util.notInlineable(Fruit.APPLE).ordinal() : fruit.ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastDeclaration()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Enum tomato = Fruit.APPLE;",
        "int ord = Fruit.APPLE.ordinal() + tomato.ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastConditional()
      throws UnableToCompleteException {
    setupFruitAndVegetableEnums();
    Result result = optimize("void", "Enum tomato = null;",
        "tomato = (true) ? Fruit.APPLE : Vegetable.CARROT;",
        "int ord = Util.notInlineable(Fruit.APPLE).ordinal() +",
        "    Util.notInlineable(Vegetable.CARROT).ordinal() + tomato.ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertTrue(tracker.isVisited("test.EntryPoint$Vegetable"));
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Vegetable"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastOverriddenMethodReturnType()
      throws UnableToCompleteException {


    runTypeTightener = true;
    runMethodCallTightener = true;


    addSnippetClassDecl("public interface EnumInterface {",
        "  String name();",
        "}");
    addSnippetClassDecl("public abstract class AbstractClass<T extends EnumInterface> {",
        "  public abstract T getEnumClass();",
        "}");
    addSnippetClassDecl("public class CustomClass1 extends AbstractClass<EnumClass1> {",
        "  public EnumClass1 getEnumClass() { return EnumClass1.CONST1; }",
        "}");
    addSnippetClassDecl("public class CustomClass2 extends AbstractClass<EnumClass2> {",
        "  public EnumClass2 getEnumClass() { return EnumClass2.CONST2; }",
        "}");
    addSnippetClassDecl("public enum EnumClass1 implements EnumInterface {",
        "  CONST1;",
        "}");
    addSnippetClassDecl("public enum EnumClass2 implements EnumInterface {",
        "  CONST2;",
        "}");
    addSnippetClassDecl("public static void testEnumClass(AbstractClass abstractClass) {",
        "  EnumInterface enumClass = abstractClass.getEnumClass();",
        "}");
    Result result = optimize("void", "EntryPoint ep = new EntryPoint();",
        "AbstractClass abstractClass1 = ep.new CustomClass1();",
        "AbstractClass abstractClass2 = ep.new CustomClass2();",
        "testEnumClass(abstractClass1);",
        "testEnumClass(abstractClass2);");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$EnumClass1"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$EnumClass1"));
    assertTrue(tracker.isVisited("test.EntryPoint$EnumClass2"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$EnumClass2"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastMethodCallArgs()
      throws UnableToCompleteException {
    setupFruitEnum();
    addSnippetClassDecl("public static String getEnumString(Enum myEnum) {",

        "  int ord = myEnum.ordinal();",
        "  String retString = \"\";",
        "  for (int i = 0;i<ord;i++) {",
        "    retString += \"-\";",
        "  }",
        "  retString += myEnum.name();",
        "  return retString;",
        "}");
    Result result = optimize("void", "String stringApple = getEnumString(Fruit.APPLE);");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastMethodCallArgsNewArray()
      throws UnableToCompleteException {
    setupFruitEnum();
    addSnippetClassDecl("public static String getEnumString(Enum[] myEnumArray) {",
        "  String retString = \"\";",
        "  for (Enum myEnum : myEnumArray) {",
        "    retString += myEnum.name();",
        "  }",
        "  return retString;",
        "}");
    Result result = optimize("void",
        "String stringFruits = getEnumString(new Enum[] {Fruit.APPLE, Fruit.ORANGE});");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastMethodCallVarArgs()
      throws UnableToCompleteException {
    setupFruitEnum();
    addSnippetClassDecl("public static String getEnumString(Enum...myEnumArray) {",
        "  String retString = \"\";",
        "  for (Enum myEnum : myEnumArray) {",
        "    retString += myEnum.name();",
        "  }",
        "  return retString;",
        "}");
    Result result = optimize("void",
        "String stringFruits = getEnumString(Fruit.APPLE, Fruit.ORANGE);");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastNewArrayElements()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Enum[] enums = new Enum[] {Fruit.APPLE, Fruit.ORANGE};");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastNewArrayArrayElements()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void",
        "Enum[][] enums = new Enum[][] {{Fruit.APPLE, Fruit.ORANGE},{Fruit.ORANGE, Fruit.APPLE}};");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableJsniMethodBodyParams()
      throws UnableToCompleteException {
    setupFruitEnum();
    addSnippetClassDecl("public static native void passEnumToJsniMethod(Enum myEnum) /*-{",
        "  myEnum == null; }-*/");
    Result result = optimize("void", "passEnumToJsniMethod(Fruit.APPLE);");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastJsniMethodBodyParams()
      throws UnableToCompleteException {
    setupFruitEnum();
    addSnippetClassDecl("public static native void passEnumToJsniMethod(Fruit myEnum) /*-{",
        "   myEnum == null; }-*/;");
    Result result = optimize("void", "passEnumToJsniMethod(Fruit.APPLE);");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableJsniMethodBodyCall()
      throws UnableToCompleteException {
    setupFruitEnum();
    addSnippetClassDecl("public static native void consumeFruitViaJsni() /*-{",
        "  var myJso = @test.EntryPoint::calledFromJsni(*)();",
        "}-*/;",
        "public static Fruit calledFromJsni() {",
        "  return Fruit.APPLE;",
        "}");
    Result result = optimize("void", "consumeFruitViaJsni();",
        "int ord = Fruit.APPLE.ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastJsniMethodRefParams()
      throws UnableToCompleteException {
    setupFruitEnum();
    setupFruitSwitchMethod();
    addSnippetClassDecl("public static native void fruitSwitchViaJsni() /*-{",
        "  var myJso;",
        "  var result = @test.EntryPoint::fruitSwitch(Ltest/EntryPoint$Fruit;)(myJso);",
        "}-*/");
    Result result = optimize("void", "fruitSwitchViaJsni();",
        "int ord = Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastJsniMethodRefReturnType()
      throws UnableToCompleteException {
    setupFruitEnum();
    addSnippetClassDecl("public static Fruit returnSomeFruit() {",
        "  return Fruit.APPLE;",
        "}");
    addSnippetClassDecl("public static native void jsniMethodRefWithEnumReturn() /*-{",
        "  var result = @test.EntryPoint::returnSomeFruit()();",
        "}-*/");
    Result result = optimize("void", "jsniMethodRefWithEnumReturn();",
        "int ord = Fruit.APPLE.ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastReturnStatement()
      throws UnableToCompleteException {
    setupFruitAndVegetableEnums();
    addSnippetClassDecl("public static Enum returnAsEnum(int mode) {",
        "  if (mode == 0) {",
        "    return Fruit.APPLE;",
        "  } else {",
        "    return Vegetable.CARROT;",
        "  }",
        "}");
    Result result = optimize("void", "Enum myEnum = returnAsEnum(0);",

        "Enum myOtherEnum = returnAsEnum(1);",
        "int ord = myEnum.ordinal() + myOtherEnum.ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertTrue(tracker.isVisited("test.EntryPoint$Vegetable"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Vegetable"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  private void setupEmptyEnum() {
    addSnippetClassDecl("public enum EmptyEnum {}");
  }

  private void setupFruitEnum() {
    addSnippetClassDecl("public enum Fruit {APPLE, ORANGE}");
    setupNotInlineable("Fruit");
  }

  private void setupFruitEnumWithInstanceField() {
    addSnippetClassDecl("public enum Fruit {APPLE(\"a\"), ORANGE(\"b\");",
        "  public final String instanceField;",
        "  private Fruit(String str) {",
        "    instanceField = str;",
        "  }",
        "}");
    setupNotInlineable("Fruit");
  }

  private void setupFruitEnumWithStaticField() {
    addSnippetClassDecl("public enum Fruit {APPLE, ORANGE;",
        "  public static String staticField = \"STATIC\";",
        "}");
    setupNotInlineable("Fruit");
  }

  private void setupFruitEnumWithStaticMethod() {
    addSnippetClassDecl("public enum Fruit {APPLE, ORANGE;",
        "  public static final int staticMethod() {",
        "    int x = 0;",
        "    return x;",
        "  }",
        "}");
    setupNotInlineable("Fruit");
  }

  private void setupFruitEnumWithStaticMethodThatRefsValuesArray() {

    addSnippetClassDecl("public enum Fruit {APPLE, ORANGE;",
        "  public static Fruit forInteger(int value) {",
        "    if (value < 0 || value >= 2) {",
        "      return ORANGE;",
        "    }",
        "    return Fruit.values()[value];",
        "  }",
        "}");
  }

  private void setupFruitEnumWithStaticMethodThatRefsValuesLength() {
    addSnippetClassDecl("public enum Fruit {APPLE, ORANGE;",
        "  public static Fruit forInteger(int value) {",
        "    if (value < 0 || value >= Fruit.values().length) {",
        "      return ORANGE;",
        "    }",
        "    return APPLE;",
        "  }",
        "}");
    setupNotInlineable("Fruit");
  }

  private void setupVegetableEnum() {
    addSnippetClassDecl("public enum Vegetable {CARROT, SPINACH}");
    setupNotInlineable("Vegetable");
  }

  private void setupFruitAndVegetableEnums() {
    addSnippetClassDecl("public enum Fruit {APPLE, ORANGE}");
    addSnippetClassDecl("public enum Vegetable {CARROT, SPINACH}");
    setupNotInlineable("Fruit", "Vegetable");
  }

  private void setupFruitSwitchMethod() {
    addSnippetClassDecl("public static String fruitSwitch(Fruit fruit) {",
        " switch(fruit) {",
        "   case APPLE: return \"Apple\";",
        "   case ORANGE: return \"Orange\";",
        "   default: return \"Unknown\";",
        " }",
        "}");
  }
  private void setupNotInlineable(String... classes) {
    addSnippetClassDecl("public static class Util {");
    for (String clazz : classes) {
      addSnippetClassDecl(
          "  public static " + clazz + " notInlineable(" + clazz + " obj) {",
          "    if (new Integer(1).toString().isEmpty()) return obj;",
          "    return obj;",
          "  }");
    }
    addSnippetClassDecl("}");
  }

  @Override
  protected boolean doOptimizeMethod(TreeLogger logger, JProgram program, JMethod method) {

    boolean didChange = false;
    program.addEntryMethod(findMainMethod(program));

    OptimizerContext optimizerContext = new FullOptimizerContext(program);
    if (runMakeCallsStatic) {
      didChange = MakeCallsStatic.exec(program, false, optimizerContext).didChange() || didChange;
    }
    if (runTypeTightener) {
      didChange = TypeTightener.exec(program, optimizerContext).didChange() || didChange;
    }
    if (runMethodCallTightener) {
      didChange = MethodCallTightener.exec(program, optimizerContext).didChange() || didChange;
    }
    if (runMethodInliner) {
      didChange = MethodInliner.exec(program, optimizerContext).didChange() || didChange;
    }
    if (runPruner) {
      didChange = Pruner.exec(program, true, optimizerContext).didChange() || didChange;
    }

    didChange = EnumOrdinalizer.exec(program, optimizerContext).didChange() || didChange;


    if (performCastReplacement) {
      ComputeCastabilityInformation.exec(program, false);
      ComputeInstantiatedJsoInterfaces.exec(program);
      ImplementCastsAndTypeChecks.exec(program, false);
    }
    if (runEqualityNormalizer) {
      EqualityNormalizer.exec(program);
    }

    return didChange;
  }

  private void assertAllEnumOrdinalizedReferencesReplaced(JProgram program, final Tracker tracker) {
    new JVisitor() {
      @Override
      public void endVisit(JFieldRef x, Context ctx) {
        assertTrue(x.getField() + " was not replaced everywhere",
            ctx.isLvalue() || !tracker.isOrdinalized(x.getEnclosingType().getName()));
      }

      @Override
      public void endVisit(JDeclarationStatement x, Context ctx) {
        assertTrue(x.getVariableRef().getTarget() + " was not replaced everywhere",
            x.getInitializer() instanceof JValueLiteral ||
                !(x.getVariableRef() instanceof JFieldRef) ||
                !tracker.isOrdinalized(
                    ((JFieldRef) x.getVariableRef()).getField().getEnclosingType().getName()));
      }
    }.accept(program);
  }
}

<code block>

package com.google.gwt.dev.jjs.test;

import com.google.gwt.core.client.JavaScriptObject;
import com.google.gwt.junit.client.GWTTestCase;


public class JsoTest extends GWTTestCase {

  static class Bar extends JavaScriptObject {
    public static int field;

    public static native String staticNative() ;

    public static String staticValue() {
      return "Bar" + field;
    }

    protected Bar() {
    }

    public final native String getBar() ;

    public final String value() {
      return "Bar";
    }
  }

  static final class ClinitStaticFieldFirst extends JavaScriptObject {
    public static String[] FIELD = new String[]{"a","b","c"};
    protected ClinitStaticFieldFirst() {
    }
    public Object invokeInstanceMethod() {
      if (FIELD == null) {
        return null;
      }
      return FIELD;
    }
    public static Object invokeStaticMethod() {
      if (FIELD == null) {
        return null;
      }
      return FIELD;
    }
  }

  static final class ClinitInstanceMethodFirst extends JavaScriptObject {
    public static String[] FIELD = new String[]{"a","b","c"};
    protected ClinitInstanceMethodFirst() {
    }
    public Object invokeInstanceMethod() {
      if (FIELD == null) {
        return null;
      }
      return FIELD;
    }
    public static Object invokeStaticMethod() {
      if (FIELD == null) {
        return null;
      }
      return FIELD;
    }
  }

  static final class ClinitStaticMethodFirst extends JavaScriptObject {
    public static String[] FIELD = new String[]{"a","b","c"};
    protected ClinitStaticMethodFirst() {
    }
    public Object invokeInstanceMethod() {
      if (FIELD == null) {
        return null;
      }
      return FIELD;
    }
    public static Object invokeStaticMethod() {
      if (FIELD == null) {
        return null;
      }
      return FIELD;
    }
  }

  static class Foo extends JavaScriptObject {
    public static int field;

    public static native String staticNative() ;
    

    public static native String staticNativeToSub() ;

    public static String staticValue() {
      return "Foo" + field;
    }

    protected Foo() {
    }

    public final native String getFoo() ;

    public final String value() {
      return "Foo";
    }
  }

  static class FooSub extends Foo {
    static String staticValueSub() {
      return "FooSub";
    }
    
    protected FooSub() {
    }

    public final String anotherValue() {
      return "Still Foo";
    }

    public final String superCall() {
      return super.value();
    }
  }

  static class JsArray<T> extends JavaScriptObject {
    public static native <T> JsArray<T> create() ;

    protected JsArray() {
    }

    public final native T get(int index) ;

    public final native int length() ;

    public final native void put(int index, T value) ;
  }

  static class MethodMangleClash {
    @SuppressWarnings("unused")
    public static String func(JavaScriptObject this_) {
      return "funcJavaScriptObject";
    }

    @SuppressWarnings("unused")
    public static String func(MethodMangleClash this_) {
      return "funcMethodMangleClash";
    }

    @SuppressWarnings("unused")
    public String func() {
      return "func";
    }
  }

  static class Overloads {
    private static volatile boolean FALSE = false;

    @SuppressWarnings("unused")
    static String sFunc(Bar b) {
      return "sFunc Bar";
    }

    @SuppressWarnings("unused")
    static String sFunc(Bar[][] b) {
      return "sFunc Bar[][]";
    }

    @SuppressWarnings("unused")
    static String sFunc(Foo f) {
      return "sFunc Foo";
    }

    @SuppressWarnings("unused")
    static String sFunc(Foo[][] f) {
      return "sFunc Foo[][]";
    }

    @SuppressWarnings("unused")
    public Overloads(Bar b) {
    }

    @SuppressWarnings("unused")
    public Overloads(Bar[][] b) {
    }

    @SuppressWarnings("unused")
    public Overloads(Foo f) {
    }

    @SuppressWarnings("unused")
    public Overloads(Foo[][] f) {
    }

    @SuppressWarnings("unused")
    String func(Bar b) {
      if (FALSE) {

        return func(b);
      }
      return "func Bar";
    }

    @SuppressWarnings("unused")
    String func(Bar[][] b) {
      if (FALSE) {

        return func(b);
      }
      return "func Bar[][]";
    }

    @SuppressWarnings("unused")
    String func(Foo f) {
      if (FALSE) {

        return func(f);
      }
      return "func Foo";
    }

    @SuppressWarnings("unused")
    String func(Foo[][] f) {
      if (FALSE) {

        return func(f);
      }
      return "func Foo[][]";
    }
  }

  private static native Bar makeBar() ;

  private static native Foo makeFoo() ;

  private static native JavaScriptObject makeJSO() ;

  private static native JavaScriptObject makeMixedArray() ;

  private static Object makeObject() {
    return new Object() {
      @Override
      public String toString() {
        return "myObject";
      }
    };
  }

  private static native JavaScriptObject returnMe(JavaScriptObject jso) ;

  @Override
  public String getModuleName() {
    return "com.google.gwt.dev.jjs.CompilerSuite";
  }

  public void testArrayInit() {
    Object[] array = {makeJSO(), new Object(), ""};
    assertTrue(array[0] instanceof JavaScriptObject);
    assertFalse(array[1] instanceof JavaScriptObject);
    assertFalse(array[2] instanceof JavaScriptObject);
  }

  public void testArrayStore() {
    JavaScriptObject[] jsoArray = new JavaScriptObject[1];
    jsoArray[0] = makeJSO();
    jsoArray[0] = makeFoo();
    jsoArray[0] = makeBar();

    Foo[] fooArray = new Foo[1];
    fooArray[0] = (Foo) makeJSO();
    fooArray[0] = makeFoo();
    fooArray[0] = makeBar().cast();

    Bar[] barArray = new Bar[1];
    barArray[0] = (Bar) makeJSO();
    barArray[0] = makeBar();
    barArray[0] = makeFoo().cast();

    Object[] objArray = jsoArray;
    try {
      objArray[0] = new Object();
      fail("Expected ArrayStoreException");
    } catch (ArrayStoreException expected) {
    }

    objArray = new Object[1];
    objArray[0] = makeJSO();
    objArray[0] = makeFoo();
    objArray[0] = makeBar();

    Foo[][] foo = new Foo[10][];
    Object[][] fooAsObject = foo;
    fooAsObject[0] = new Bar[1];
  }

  public void testBasic() {
    JavaScriptObject jso = makeJSO();
    assertEquals("jso", jso.toString());

    Foo foo = (Foo) jso;
    assertEquals("jso", foo.toString());
    assertEquals("jso foo", foo.getFoo());
    assertEquals("Foo", foo.value());

    Bar bar = (Bar) jso;
    assertEquals("jso", bar.toString());
    assertEquals("jso bar", bar.getBar());
    assertEquals("Bar", bar.value());

    foo = makeFoo();
    assertEquals("foo", foo.toString());
    assertEquals("this is foo", foo.getFoo());
    assertEquals("Foo", foo.value());

    bar = makeBar();
    assertEquals("bar", bar.toString());
    assertEquals("this is bar", bar.getBar());
    assertEquals("Bar", bar.value());
  }

  @SuppressWarnings("cast")
  public void testCasts() {
    JavaScriptObject jso = makeJSO();
    assertTrue(jso instanceof JavaScriptObject);
    assertTrue(jso instanceof Foo);
    assertTrue(jso instanceof Bar);

    Foo foo = (Foo) jso;
    foo = makeFoo();
    assertTrue((JavaScriptObject) foo instanceof Bar);
    Bar bar = (Bar) (JavaScriptObject) makeFoo();
    bar = makeFoo().cast();

    bar = (Bar) jso;
    bar = makeBar();
    assertTrue((JavaScriptObject) bar instanceof Foo);
    foo = (Foo) (JavaScriptObject) makeBar();
    foo = makeBar().cast();


    jso = foo;
    jso = bar;

    Object o = new Object();
    assertFalse(o instanceof JavaScriptObject);
    assertFalse(o instanceof Foo);
    assertFalse(o instanceof Bar);
    try {
      jso = (JavaScriptObject) o;
      fail("Expected ClassCastException");
    } catch (ClassCastException expected) {
    }

    o = "foo";
    assertFalse(o instanceof JavaScriptObject);
    assertFalse(o instanceof Foo);
    assertFalse(o instanceof Bar);
    try {
      jso = (JavaScriptObject) o;
      fail("Expected ClassCastException");
    } catch (ClassCastException expected) {
    }

    o = jso;
    assertFalse(o instanceof String);
    try {
      String s = (String) o;
      s = s.toString();
      fail("Expected ClassCastException");
    } catch (ClassCastException expected) {
    }
  }

  @SuppressWarnings("cast")
  public void testCastsArray() {
    JavaScriptObject[][] jso = new JavaScriptObject[0][0];
    assertTrue(jso instanceof JavaScriptObject[][]);
    assertTrue(jso instanceof Foo[][]);
    assertTrue(jso instanceof Bar[][]);

    Foo[][] foo = (Foo[][]) jso;
    foo = new Foo[0][0];
    assertTrue((JavaScriptObject[][]) foo instanceof Bar[][]);
    Bar[][] bar = (Bar[][]) (JavaScriptObject[][]) new Foo[0][0];

    bar = (Bar[][]) jso;
    bar = new Bar[0][0];
    assertTrue((JavaScriptObject[][]) bar instanceof Foo[][]);
    foo = (Foo[][]) (JavaScriptObject[][]) new Bar[0][0];

    Object[][] o = new Object[0][0];
    assertFalse(o instanceof JavaScriptObject[][]);
    assertFalse(o instanceof Foo[][]);
    assertFalse(o instanceof Bar[][]);
    try {
      jso = (JavaScriptObject[][]) o;
      fail("Expected ClassCastException");
    } catch (ClassCastException expected) {
    }

    o = jso;
    assertFalse(o instanceof String[][]);
    try {
      String[][] s = (String[][]) o;
      s.getClass();
      fail("Expected ClassCastException");
    } catch (ClassCastException expected) {
    }
  }

  public void testClassInitializerRun() {
    ClinitStaticMethodFirst staticMethodFirst = JavaScriptObject.createObject().cast();
    assertNotNull("static method", ClinitStaticMethodFirst.invokeStaticMethod());
    assertNotNull("instance method after static method", staticMethodFirst.invokeInstanceMethod());

    ClinitStaticFieldFirst staticFieldFirst = JavaScriptObject.createObject().cast();
    assertNotNull("field access", ClinitStaticFieldFirst.FIELD);
    assertNotNull("instance method after field access", staticFieldFirst.invokeInstanceMethod());

    ClinitInstanceMethodFirst instanceMethodFirst = JavaScriptObject.createObject().cast();
    assertNotNull("instance method", instanceMethodFirst.invokeInstanceMethod());
    assertNotNull("static method after instance method", ClinitInstanceMethodFirst.invokeStaticMethod());
  }

  public void testClassLiterals() {
    JavaScriptObject jso = makeJSO();
    Foo foo = makeFoo();
    Bar bar = makeBar();
    assertEquals(JavaScriptObject.class, jso.getClass());
    assertEquals(Foo.class, jso.getClass());
    assertEquals(Bar.class, jso.getClass());
    assertEquals(JavaScriptObject.class, foo.getClass());
    assertEquals(Foo.class, foo.getClass());
    assertEquals(Bar.class, foo.getClass());
    assertEquals(JavaScriptObject.class, bar.getClass());
    assertEquals(Foo.class, bar.getClass());
    assertEquals(Bar.class, bar.getClass());
    assertEquals(JavaScriptObject.class, Foo.class);
    assertEquals(JavaScriptObject.class, Bar.class);
    assertEquals(Foo.class, Bar.class);

    if (!JavaScriptObject.class.getName().startsWith("Class$")) {

      assertEquals("com.google.gwt.core.client.JavaScriptObject$",
          JavaScriptObject.class.getName());
    }
  }

  public void testClassLiteralsArray() {
    JavaScriptObject[][] jso = new JavaScriptObject[0][0];
    Foo[][] foo = new Foo[0][0];
    Bar[][] bar = new Bar[0][0];
    assertEquals(JavaScriptObject[][].class, jso.getClass());
    assertEquals(Foo[][].class, jso.getClass());
    assertEquals(Bar[][].class, jso.getClass());
    assertEquals(JavaScriptObject[][].class, foo.getClass());
    assertEquals(Foo[][].class, foo.getClass());
    assertEquals(Bar[][].class, foo.getClass());
    assertEquals(JavaScriptObject[][].class, bar.getClass());
    assertEquals(Foo[][].class, bar.getClass());
    assertEquals(Bar[][].class, bar.getClass());
    assertEquals(JavaScriptObject[][].class, Foo[][].class);
    assertEquals(JavaScriptObject[][].class, Bar[][].class);
    assertEquals(Foo[][].class, Bar[][].class);

    if (!JavaScriptObject.class.getName().startsWith("Class$")) {

      assertEquals("[[Lcom.google.gwt.core.client.JavaScriptObject$;",
          JavaScriptObject[][].class.getName());
    }
  }

  public void testEquality() {
    JavaScriptObject jso = makeJSO();
    assertEquals(jso, jso);

    JavaScriptObject jso2 = makeJSO();
    assertFalse(jso.equals(jso2));
    assertFalse(jso2.equals(jso));

    jso2 = returnMe(jso);
    assertEquals(jso, jso2);
  }

  public void testGenericsJsos() {
    JsArray<JavaScriptObject> a = JsArray.create();
    a.put(0, makeJSO());
    a.put(1, makeFoo());
    a.put(2, makeBar());
    a.put(3, null);
    assertEquals(4, a.length());
    assertEquals("jso", a.get(0).toString());
    assertEquals("foo", a.get(1).toString());
    assertEquals("bar", a.get(2).toString());
    assertEquals(null, a.get(3));
  }

  public void testGenericsMixed() {
    JsArray<Object> a = JsArray.create();
    a.put(0, makeJSO());
    a.put(1, "foo");
    a.put(2, makeObject());
    a.put(3, null);
    assertEquals(4, a.length());
    assertEquals("jso", a.get(0).toString());
    assertEquals("foo", a.get(1));
    assertEquals("myObject", a.get(2).toString());
    assertEquals(null, a.get(3));
  }

  @SuppressWarnings("unchecked")
  public void testGenericsRawJson() {
    JsArray a = (JsArray) makeMixedArray();
    assertEquals(4, a.length());
    assertEquals("jso", a.get(0).toString());
    assertEquals("foo", a.get(1));
    assertEquals("myObject", a.get(2).toString());
    assertEquals(null, a.get(3));
  }

  public void testGenericsStrings() {
    JsArray<String> a = JsArray.create();
    a.put(0, "foo");
    a.put(1, "bar");
    a.put(2, "baz");
    a.put(3, null);
    assertEquals(4, a.length());
    assertEquals("foo", a.get(0));
    assertEquals("bar", a.get(1));
    assertEquals("baz", a.get(2));
    assertEquals(null, a.get(3));
  }

  public void testHashCode() {

    JavaScriptObject jso = makeJSO();
    int jsoHashCode = jso.hashCode();
    Foo foo = makeFoo();
    Bar bar = makeBar();
    Object o = new Object() {
      @Override
      public int hashCode() {

        return 0xDEADBEEF;
      }
    };

    assertEquals(jsoHashCode, jso.hashCode());
    assertFalse(jsoHashCode == foo.hashCode());
    assertFalse(jsoHashCode == bar.hashCode());
    assertFalse(jsoHashCode == o.hashCode());
    assertFalse(foo.hashCode() == bar.hashCode());
    assertFalse(foo.hashCode() == o.hashCode());
    assertFalse(bar.hashCode() == o.hashCode());

    o = jso;
    assertEquals(jsoHashCode, o.hashCode());

    String s = "foo";
    int stringHashCode = s.hashCode();
    o = s;
    assertEquals(stringHashCode, o.hashCode());
  }

  public void testIdentity() {
    JavaScriptObject jso = makeJSO();
    assertSame(jso, jso);

    JavaScriptObject jso2 = makeJSO();
    assertNotSame(jso, jso2);

    jso2 = returnMe(jso);
    assertSame(jso, jso2);
  }

  public void testInheritance() {
    Foo foo = makeFoo();
    FooSub fooSub = (FooSub) foo;
    assertEquals("Foo", fooSub.value());
    assertEquals("Still Foo", fooSub.anotherValue());
    assertEquals("Foo", fooSub.superCall());
  }

  public void testMethodMangleClash() {
    assertEquals("funcJavaScriptObject",
        MethodMangleClash.func((JavaScriptObject) null));
    assertEquals("funcMethodMangleClash",
        MethodMangleClash.func((MethodMangleClash) null));
    assertEquals("func", new MethodMangleClash().func());
  }

  public void testOverloads() {
    Foo foo = makeFoo();
    assertEquals("func Foo", new Overloads(foo).func(foo));
    assertEquals("sFunc Foo", Overloads.sFunc(foo));

    Bar bar = makeBar();
    assertEquals("func Bar", new Overloads(bar).func(bar));
    assertEquals("sFunc Bar", Overloads.sFunc(bar));
  }

  public void testOverloadsArray() {
    Foo[][] foo = new Foo[0][0];
    assertEquals("func Foo[][]", new Overloads(foo).func(foo));
    assertEquals("sFunc Foo[][]", Overloads.sFunc(foo));

    Bar[][] bar = new Bar[0][0];
    assertEquals("func Bar[][]", new Overloads(bar).func(bar));
    assertEquals("sFunc Bar[][]", Overloads.sFunc(bar));
  }

  public native void testOverloadsArrayNative() ;

  public native void testOverloadsNative() ;

  public void testStaticAccess() {
    Foo.field = 3;
    assertEquals(3, Foo.field--);
    assertEquals("Foo2", Foo.staticValue());
    assertEquals("nativeFoo", Foo.staticNative());
    assertEquals("FooSub", Foo.staticNativeToSub());

    Bar.field = 10;
    assertEquals(11, ++Bar.field);
    assertEquals("Bar11", Bar.staticValue());
    assertEquals("nativeBar", Bar.staticNative());
  }

  public native void testStaticAccessNative() ;

  public void testStaticAccessSubclass() {
    FooSub.field = 3;
    assertEquals(3, FooSub.field--);
    assertEquals("Foo2", FooSub.staticValue());
    assertEquals("nativeFoo", FooSub.staticNative());
  }

  static JavaScriptObject someObject;
  static class JSO1 extends JavaScriptObject {
    protected JSO1() {
    }
    static native JSO1 create() ;
  }

  static class JSO2 extends JavaScriptObject {
    protected JSO2() {
    }
    static native JSO2 create() ;
  }


  static final class FinalJSO1 extends JavaScriptObject {
    protected FinalJSO1() {
    }
    static native FinalJSO1 create() ;
  }

  static final class FinalJSO2 extends JavaScriptObject {
    protected FinalJSO2() {
    }
    static native FinalJSO2 create() ;
  }

  interface I {
  }


  static class JSOImplementingI extends JavaScriptObject implements I {
    protected JSOImplementingI() {
    }
    static native I create() ;
  }


  public void testCrossCasting() {
    JSO1 jso1 = JSO1.create();
    JSO2 jso2 = JSO2.create();
    FinalJSO1 finalJso1 = FinalJSO1.create();
    FinalJSO2 finalJso2 = FinalJSO2.create();
    I i = JSOImplementingI.create();

    assertTrue(jso1 == (JSO1) (trueFn() ? jso2 : (JavaScriptObject) null));
    assertTrue(jso1 == (JSO1) (trueFn() ? i : (JavaScriptObject) null));
    assertTrue(jso1 == (JSO1) (trueFn() ? finalJso1 : (JavaScriptObject) null));
    assertTrue(jso1 == (JSO1) (trueFn() ? finalJso2 : (JavaScriptObject) null));

    assertTrue(jso2 == (JSO2) (trueFn() ? jso1 : (JavaScriptObject) null));
    assertTrue(jso2 == (JSO2) (trueFn() ? i : (JavaScriptObject) null));
    assertTrue(jso2 == (JSO2) (trueFn() ? finalJso1 : (JavaScriptObject) null));
    assertTrue(jso2 == (JSO2) (trueFn() ? finalJso2 : (JavaScriptObject) null));

    assertTrue(finalJso1 == (FinalJSO1) (trueFn() ? jso1 : (JavaScriptObject) null));
    assertTrue(finalJso1 == (FinalJSO1) (trueFn() ? i : (JavaScriptObject) null));
    assertTrue(finalJso1 == (FinalJSO1) (trueFn() ? jso2 : (JavaScriptObject) null));
    assertTrue(finalJso1 == (FinalJSO1) (trueFn() ? finalJso2 : (JavaScriptObject) null));

    assertTrue(finalJso2 == (FinalJSO2) (trueFn() ? jso1 : (JavaScriptObject) null));
    assertTrue(finalJso2 == (FinalJSO2) (trueFn() ? i : (JavaScriptObject) null));
    assertTrue(finalJso2 == (FinalJSO2) (trueFn() ? jso2 : (JavaScriptObject) null));
    assertTrue(finalJso2 == (FinalJSO2) (trueFn() ? finalJso1 : (JavaScriptObject) null));

    assertTrue(i == (I) (trueFn() ? jso1 : (JavaScriptObject) null));
    assertTrue(i == (I) (trueFn() ? jso2 : (JavaScriptObject) null));
    assertTrue(i == (I) (trueFn() ? finalJso1 : (JavaScriptObject) null));
    assertTrue(i == (I) (trueFn() ? finalJso2 : (JavaScriptObject) null));
  }

  private boolean trueFn() {
    return true;
  }
}

<code block>

package com.google.gwt.core.client.interop;

import com.google.gwt.junit.client.GWTTestCase;


public class JsFunctionTest extends GWTTestCase {

  @Override
  public String getModuleName() {
    return "com.google.gwt.core.Core";
  }


  public void testJsFunctionBasic_js() {
    MyJsFunctionInterface jsFunctionInterface = new MyJsFunctionInterface() {
      @Override
      public int foo(int a) {
        return a + 2;
      }
    };
    assertEquals(12, callAsFunction(jsFunctionInterface, 10));
  }

  public void testJsFunctionBasic_java() {
    MyJsFunctionInterface jsFunctionInterface = new MyJsFunctionInterface() {
      @Override
      public int foo(int a) {
        return a + 2;
      }
    };
    assertEquals(12, jsFunctionInterface.foo(10));
  }

  public void testJsFunctionViaFunctionMethods() {
    MyJsFunctionInterface jsFunctionInterface = new MyJsFunctionInterface() {
      @Override
      public int foo(int a) {
        return a + 2;
      }
    };
    assertEquals(12, callWithFunctionApply(jsFunctionInterface, 10));
    assertEquals(12, callWithFunctionCall(jsFunctionInterface, 10));
  }

  public void testJsFunctionSubImpl_js() {
    MySubclassOfJsFunctionInterfaceImpl impl = new MySubclassOfJsFunctionInterfaceImpl();
    assertEquals(21, callAsFunction(impl, 10));
  }

  public void testJsFunctionSubImpl_java() {
    MySubclassOfJsFunctionInterfaceImpl impl = new MySubclassOfJsFunctionInterfaceImpl();
    assertEquals(21, impl.foo(10));
  }

  public void testJsFunctionIdentity_js() {
    MyJsFunctionIdentityInterface id = new MyJsFunctionIdentityInterface() {
      @Override
      public Object identity() {
        return this;
      }
    };
    assertEquals(id, callAsFunction(id));
  }

  public void testJsFunctionIdentity_java() {
    MyJsFunctionIdentityInterface id = new MyJsFunctionIdentityInterface() {
      @Override
      public Object identity() {
        return this;
      }
    };
    assertEquals(id, id.identity());
  }

  public void testJsFunctionAccess() {
    MyJsFunctionInterface intf = new MyJsFunctionInterface() {
      public int publicField;
      @Override
      public int foo(int a) {
        return a;
      }
    };
    JsTypeTest.assertJsTypeDoesntHaveFields(intf, "foo");
    JsTypeTest.assertJsTypeDoesntHaveFields(intf, "publicField");
  }

  public void testJsFunctionCallFromAMember() {
    MyJsFunctionInterfaceImpl impl = new MyJsFunctionInterfaceImpl();
    assertEquals(16, impl.callFoo(10));
  }

  public void testJsFunctionJs2Java() {
    MyJsFunctionInterface intf = createMyJsFunction();
    assertEquals(10, intf.foo(10));
  }

  public void testJsFunctionSuccessiveCalls() {
    assertEquals(12, new MyJsFunctionInterface() {
      @Override
      public int foo(int a) {
        return a + 2;
      }
    }.foo(10));
    assertEquals(10, createMyJsFunction().foo(10));
  }

  public void testJsFunctionCallbackPattern() {
    MyClassAcceptsJsFunctionAsCallBack c = new MyClassAcceptsJsFunctionAsCallBack();
    c.setCallBack(createMyJsFunction());
    assertEquals(10, c.triggerCallBack(10));
  }

  public void testJsFunctionReferentialIntegrity() {
    MyJsFunctionIdentityInterface intf = createReferentialFunction();
    assertEquals(intf, intf.identity());
  }

  public void testCast_fromJsFunction() {
    MyJsFunctionInterface c1 = (MyJsFunctionInterface) createFunction();
    assertNotNull(c1);
    MyJsFunctionIdentityInterface c2 = (MyJsFunctionIdentityInterface) createFunction();
    assertNotNull(c2);
    ElementLikeJsInterface i = (ElementLikeJsInterface) createFunction();
    assertNotNull(i);
    try {
      MyJsFunctionInterfaceImpl c3 = (MyJsFunctionInterfaceImpl) createFunction();
      assertNotNull(c3);
      fail("ClassCastException should be caught.");
    } catch (ClassCastException cce) {

    }
  }

  public void testCast_fromJsObject() {
    ElementLikeJsInterface obj = (ElementLikeJsInterface) createObject();
    assertNotNull(obj);
    try {
      MyJsFunctionInterface c = (MyJsFunctionInterface) createObject();
      assertNotNull(c);
      fail("ClassCastException should be caught.");
    } catch (ClassCastException cce) {

    }
    try {
      MyJsFunctionInterfaceImpl c = (MyJsFunctionInterfaceImpl) createObject();
      assertNotNull(c);
      fail("ClassCastException should be caught.");
    } catch (ClassCastException cce) {

    }
    try {
      MyJsFunctionIdentityInterface c = (MyJsFunctionIdentityInterface) createObject();
      assertNotNull(c);
      fail("ClassCastException should be caught.");
    } catch (ClassCastException cce) {

    }
  }

  public void testCast_inJava() {
    Object object = alwaysTrue() ? new MyJsFunctionInterfaceImpl() : new Object();
    MyJsFunctionInterface c1 = (MyJsFunctionInterface) object;
    assertNotNull(c1);
    MyJsFunctionInterfaceImpl c2 = (MyJsFunctionInterfaceImpl) c1;
    assertEquals(10, c2.publicField);
    MyJsFunctionInterfaceImpl c3 = (MyJsFunctionInterfaceImpl) object;
    assertNotNull(c3);
    MyJsFunctionIdentityInterface c4 = (MyJsFunctionIdentityInterface) object;
    assertNotNull(c4);
    ElementLikeJsInterface c5 = (ElementLikeJsInterface) object;
    assertNotNull(c5);
  }

  public void testCast_crossCastJavaInstance() {
    Object o = alwaysTrue() ? new MyJsFunctionInterfaceImpl() : new Object();
    assertEquals(11, ((MyOtherJsFunctionInterface) o).bar(10));
    assertSame((MyJsFunctionInterface) o, (MyOtherJsFunctionInterface) o);
  }

  public void testInstanceOf_jsFunction() {
    Object object = createFunction();
    assertTrue(object instanceof MyJsFunctionInterface);
    assertTrue(object instanceof MyJsFunctionIdentityInterface);
    assertFalse(object instanceof MyJsFunctionInterfaceImpl);
    assertTrue(object instanceof ElementLikeJsInterface);
  }

  public void testInstanceOf_jsObject() {
    Object object = createObject();
    assertFalse(object instanceof MyJsFunctionInterface);
    assertFalse(object instanceof MyJsFunctionIdentityInterface);
    assertFalse(object instanceof MyJsFunctionInterfaceImpl);
    assertTrue(object instanceof ElementLikeJsInterface);
  }

  public void testInstanceOf_javaInstance() {
    Object object = alwaysTrue() ? new MyJsFunctionInterfaceImpl() : new Object();
    assertTrue(object instanceof MyJsFunctionInterface);
    assertTrue(object instanceof MyJsFunctionInterfaceImpl);
    assertTrue(object instanceof MyJsFunctionIdentityInterface);
    assertTrue(object instanceof ElementLikeJsInterface);
  }





















  private static native Object callAsFunction(Object fn) ;

  private static native int callAsFunction(Object fn, int arg) ;

  private static native int callWithFunctionApply(Object fn, int arg) ;

  private static native int callWithFunctionCall(Object fn, int arg) ;

  private static native void setField(Object object, String fieldName, int value) ;

  private static native int getField(Object object, String fieldName) ;

  private static native int callIntFunction(Object object, String functionName) ;

  private static native MyJsFunctionInterface createMyJsFunction() ;

  private static native MyJsFunctionIdentityInterface createReferentialFunction() ;

  private static native Object createFunction() ;

  private static native Object createObject() ;

  private static native boolean alwaysTrue() ;
}

<code block>

package com.google.gwt.core.client.interop;

import com.google.gwt.core.client.js.JsProperty;
import com.google.gwt.core.client.js.JsType;
import com.google.gwt.junit.client.GWTTestCase;


public class JsTypeArrayTest extends GWTTestCase {

  @Override
  public String getModuleName() {
    return "com.google.gwt.core.Core";
  }



  @JsType
  interface SimpleJsTypeReturnFromNative { }

  public void testJsTypeArray_returnFromNative() {
    SimpleJsTypeReturnFromNative[] array = returnJsTypeFromNative();
    assertEquals(2, array.length);
    assertNotNull(array[0]);
  }

  private native SimpleJsTypeReturnFromNative[] returnJsTypeFromNative() ;

  @JsType
  interface SimpleJsTypeReturnFromNativeWithACall {
    @JsProperty int getId();
  }


  public void _disabled_testJsTypeArray_returnFromNativeWithACall() {
    SimpleJsTypeReturnFromNativeWithACall[] array = returnJsTypeWithIdsFromNative();
    assertEquals(2, array[1].getId());
  }

  private native SimpleJsTypeReturnFromNativeWithACall[] returnJsTypeWithIdsFromNative() ;

  @JsType
  interface SimpleJsTypeAsAField { }

  @JsType
  static class SimpleJsTypeAsAFieldHolder {
    public SimpleJsTypeAsAField[] arrayField;
  }


  public void _disabled_testJsTypeArray_asAField() {
    SimpleJsTypeAsAFieldHolder holder = new SimpleJsTypeAsAFieldHolder();
    fillArrayField(holder);
    SimpleJsTypeAsAField[] array = holder.arrayField;
    assertEquals(2, array.length);
    assertNotNull(array[0]);
  }

  private native static void fillArrayField(SimpleJsTypeAsAFieldHolder holder) ;

  @JsType
  interface SimpleJsTypeAsAParam { }

  @JsType
  static class SimpleJsTypeAsAParamHolder {
    private SimpleJsTypeAsAParam[] theParam;

    public void setArrayParam(SimpleJsTypeAsAParam[] param) {
      theParam = param;
    }
  }

  public void testJsTypeArray_asAParam() {
    SimpleJsTypeAsAParamHolder holder = new SimpleJsTypeAsAParamHolder();
    fillArrayParam(holder);
    SimpleJsTypeAsAParam[] array = holder.theParam;
    assertEquals(2, array.length);
    assertNotNull(array[0]);
  }

  private native void fillArrayParam(SimpleJsTypeAsAParamHolder holder) ;

  @JsType
  interface SimpleJsTypeReturnForMultiDimArray {
    @JsProperty int getId();
  }


  public void _disabled_testJsType3DimArray_castedFromNativeWithACall() {
    SimpleJsTypeReturnForMultiDimArray[][][] array =
        (SimpleJsTypeReturnForMultiDimArray[][][]) returnJsType3DimFromNative();
    assertEquals(1, array.length);
    assertEquals(2, array[0].length);
    assertEquals(3, array[0][0].length);
    assertEquals(1, array[0][0][0].getId());
  }

  private native Object returnJsType3DimFromNative() ;


  public void _disabled_testString3DimArray_castedFromNative() {
    String[][][] array = (String[][][]) returnString3DimFromNative();
    assertEquals(1, array.length);
    assertEquals(2, array[0].length);
    assertEquals(3, array[0][0].length);
    assertEquals("1", array[0][0][0]);
  }

  private native Object returnString3DimFromNative() ;
}

<code block>

package com.google.gwt.dev.jjs;

import com.google.gwt.core.ext.TreeLogger;
import com.google.gwt.core.ext.UnableToCompleteException;
import com.google.gwt.core.ext.linker.Artifact;
import com.google.gwt.core.ext.linker.ArtifactSet;
import com.google.gwt.core.ext.linker.CompilationMetricsArtifact;
import com.google.gwt.core.ext.linker.EmittedArtifact;
import com.google.gwt.core.ext.linker.EmittedArtifact.Visibility;
import com.google.gwt.core.ext.linker.ModuleMetricsArtifact;
import com.google.gwt.core.ext.linker.PrecompilationMetricsArtifact;
import com.google.gwt.core.ext.linker.StatementRanges;
import com.google.gwt.core.ext.linker.SymbolData;
import com.google.gwt.core.ext.linker.SyntheticArtifact;
import com.google.gwt.core.ext.linker.impl.StandardSymbolData;
import com.google.gwt.core.ext.soyc.SourceMapRecorder;
import com.google.gwt.core.ext.soyc.coderef.DependencyGraphRecorder;
import com.google.gwt.core.ext.soyc.coderef.EntityRecorder;
import com.google.gwt.core.ext.soyc.impl.DependencyRecorder;
import com.google.gwt.core.ext.soyc.impl.SizeMapRecorder;
import com.google.gwt.core.ext.soyc.impl.SplitPointRecorder;
import com.google.gwt.core.ext.soyc.impl.StoryRecorder;
import com.google.gwt.core.linker.SoycReportLinker;
import com.google.gwt.dev.CompilerContext;
import com.google.gwt.dev.MinimalRebuildCache;
import com.google.gwt.dev.Permutation;
import com.google.gwt.dev.PrecompileTaskOptions;
import com.google.gwt.dev.cfg.ConfigurationProperties;
import com.google.gwt.dev.cfg.EntryMethodHolderGenerator;
import com.google.gwt.dev.cfg.ModuleDef;
import com.google.gwt.dev.cfg.PermutationProperties;
import com.google.gwt.dev.javac.CompilationProblemReporter;
import com.google.gwt.dev.javac.CompilationState;
import com.google.gwt.dev.javac.StandardGeneratorContext;
import com.google.gwt.dev.javac.typemodel.TypeOracle;
import com.google.gwt.dev.jdt.RebindPermutationOracle;
import com.google.gwt.dev.jjs.UnifiedAst.AST;
import com.google.gwt.dev.jjs.ast.Context;
import com.google.gwt.dev.jjs.ast.JBlock;
import com.google.gwt.dev.jjs.ast.JCastOperation;
import com.google.gwt.dev.jjs.ast.JClassLiteral;
import com.google.gwt.dev.jjs.ast.JClassType;
import com.google.gwt.dev.jjs.ast.JDeclaredType;
import com.google.gwt.dev.jjs.ast.JMethod;
import com.google.gwt.dev.jjs.ast.JMethodBody;
import com.google.gwt.dev.jjs.ast.JMethodCall;
import com.google.gwt.dev.jjs.ast.JProgram;
import com.google.gwt.dev.jjs.ast.JTypeOracle.StandardTypes;
import com.google.gwt.dev.jjs.ast.JVisitor;
import com.google.gwt.dev.jjs.impl.ArrayNormalizer;
import com.google.gwt.dev.jjs.impl.AssertionNormalizer;
import com.google.gwt.dev.jjs.impl.AssertionRemover;
import com.google.gwt.dev.jjs.impl.AstDumper;
import com.google.gwt.dev.jjs.impl.CatchBlockNormalizer;
import com.google.gwt.dev.jjs.impl.CompileTimeConstantsReplacer;
import com.google.gwt.dev.jjs.impl.ComputeCastabilityInformation;
import com.google.gwt.dev.jjs.impl.ComputeExhaustiveCastabilityInformation;
import com.google.gwt.dev.jjs.impl.ControlFlowAnalyzer;
import com.google.gwt.dev.jjs.impl.ControlFlowRecorder;
import com.google.gwt.dev.jjs.impl.DeadCodeElimination;
import com.google.gwt.dev.jjs.impl.Devirtualizer;
import com.google.gwt.dev.jjs.impl.EnumNameObfuscator;
import com.google.gwt.dev.jjs.impl.EnumOrdinalizer;
import com.google.gwt.dev.jjs.impl.EqualityNormalizer;
import com.google.gwt.dev.jjs.impl.Finalizer;
import com.google.gwt.dev.jjs.impl.FixAssignmentsToUnboxOrCast;
import com.google.gwt.dev.jjs.impl.FullOptimizerContext;
import com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST;
import com.google.gwt.dev.jjs.impl.HandleCrossFragmentReferences;
import com.google.gwt.dev.jjs.impl.ImplementCastsAndTypeChecks;
import com.google.gwt.dev.jjs.impl.ImplementClassLiteralsAsFields;
import com.google.gwt.dev.jjs.impl.JavaAstVerifier;
import com.google.gwt.dev.jjs.impl.JavaToJavaScriptMap;
import com.google.gwt.dev.jjs.impl.JjsUtils;
import com.google.gwt.dev.jjs.impl.JsAbstractTextTransformer;
import com.google.gwt.dev.jjs.impl.JsFunctionClusterer;
import com.google.gwt.dev.jjs.impl.JsInteropRestrictionChecker;
import com.google.gwt.dev.jjs.impl.JsNoopTransformer;
import com.google.gwt.dev.jjs.impl.JsTypeLinker;
import com.google.gwt.dev.jjs.impl.JsniRestrictionChecker;
import com.google.gwt.dev.jjs.impl.LongCastNormalizer;
import com.google.gwt.dev.jjs.impl.LongEmulationNormalizer;
import com.google.gwt.dev.jjs.impl.MakeCallsStatic;
import com.google.gwt.dev.jjs.impl.MethodCallSpecializer;
import com.google.gwt.dev.jjs.impl.MethodCallTightener;
import com.google.gwt.dev.jjs.impl.MethodInliner;
import com.google.gwt.dev.jjs.impl.OptimizerContext;
import com.google.gwt.dev.jjs.impl.OptimizerStats;
import com.google.gwt.dev.jjs.impl.PostOptimizationCompoundAssignmentNormalizer;
import com.google.gwt.dev.jjs.impl.Pruner;
import com.google.gwt.dev.jjs.impl.RecordRebinds;
import com.google.gwt.dev.jjs.impl.RemoveEmptySuperCalls;
import com.google.gwt.dev.jjs.impl.RemoveSpecializations;
import com.google.gwt.dev.jjs.impl.ReplaceDefenderMethodReferences;
import com.google.gwt.dev.jjs.impl.ReplaceGetClassOverrides;
import com.google.gwt.dev.jjs.impl.ResolvePermutationDependentValues;
import com.google.gwt.dev.jjs.impl.ResolveRuntimeTypeReferences;
import com.google.gwt.dev.jjs.impl.ResolveRuntimeTypeReferences.ClosureUniqueIdTypeMapper;
import com.google.gwt.dev.jjs.impl.ResolveRuntimeTypeReferences.IntTypeMapper;
import com.google.gwt.dev.jjs.impl.ResolveRuntimeTypeReferences.StringTypeMapper;
import com.google.gwt.dev.jjs.impl.ResolveRuntimeTypeReferences.TypeMapper;
import com.google.gwt.dev.jjs.impl.ResolveRuntimeTypeReferences.TypeOrder;
import com.google.gwt.dev.jjs.impl.SameParameterValueOptimizer;
import com.google.gwt.dev.jjs.impl.SourceInfoCorrelator;
import com.google.gwt.dev.jjs.impl.TypeCoercionNormalizer;
import com.google.gwt.dev.jjs.impl.TypeReferencesRecorder;
import com.google.gwt.dev.jjs.impl.TypeTightener;
import com.google.gwt.dev.jjs.impl.UnifyAst;
import com.google.gwt.dev.jjs.impl.codesplitter.CodeSplitter;
import com.google.gwt.dev.jjs.impl.codesplitter.CodeSplitters;
import com.google.gwt.dev.jjs.impl.codesplitter.MultipleDependencyGraphRecorder;
import com.google.gwt.dev.jjs.impl.codesplitter.ReplaceRunAsyncs;
import com.google.gwt.dev.jjs.impl.gflow.DataflowOptimizer;
import com.google.gwt.dev.js.BaselineCoverageGatherer;
import com.google.gwt.dev.js.ClosureJsRunner;
import com.google.gwt.dev.js.CoverageInstrumentor;
import com.google.gwt.dev.js.DuplicateExecuteOnceRemover;
import com.google.gwt.dev.js.EvalFunctionsAtTopScope;
import com.google.gwt.dev.js.FreshNameGenerator;
import com.google.gwt.dev.js.JsBreakUpLargeVarStatements;
import com.google.gwt.dev.js.JsDuplicateCaseFolder;
import com.google.gwt.dev.js.JsDuplicateFunctionRemover;
import com.google.gwt.dev.js.JsIncrementalNamer;
import com.google.gwt.dev.js.JsInliner;
import com.google.gwt.dev.js.JsLiteralInterner;
import com.google.gwt.dev.js.JsNamer.IllegalNameException;
import com.google.gwt.dev.js.JsNamespaceChooser;
import com.google.gwt.dev.js.JsNamespaceOption;
import com.google.gwt.dev.js.JsNormalizer;
import com.google.gwt.dev.js.JsObfuscateNamer;
import com.google.gwt.dev.js.JsPrettyNamer;
import com.google.gwt.dev.js.JsReportGenerationVisitor;
import com.google.gwt.dev.js.JsStackEmulator;
import com.google.gwt.dev.js.JsStaticEval;
import com.google.gwt.dev.js.JsSymbolResolver;
import com.google.gwt.dev.js.JsUnusedFunctionRemover;
import com.google.gwt.dev.js.JsVerboseNamer;
import com.google.gwt.dev.js.SizeBreakdown;
import com.google.gwt.dev.js.ast.JsContext;
import com.google.gwt.dev.js.ast.JsForIn;
import com.google.gwt.dev.js.ast.JsFunction;
import com.google.gwt.dev.js.ast.JsLabel;
import com.google.gwt.dev.js.ast.JsLiteral;
import com.google.gwt.dev.js.ast.JsName;
import com.google.gwt.dev.js.ast.JsNameOf;
import com.google.gwt.dev.js.ast.JsNameRef;
import com.google.gwt.dev.js.ast.JsNode;
import com.google.gwt.dev.js.ast.JsParameter;
import com.google.gwt.dev.js.ast.JsProgram;
import com.google.gwt.dev.js.ast.JsVars;
import com.google.gwt.dev.js.ast.JsVisitor;
import com.google.gwt.dev.util.DefaultTextOutput;
import com.google.gwt.dev.util.Memory;
import com.google.gwt.dev.util.Name.SourceName;
import com.google.gwt.dev.util.Pair;
import com.google.gwt.dev.util.Util;
import com.google.gwt.dev.util.arg.OptionOptimize;
import com.google.gwt.dev.util.log.speedtracer.CompilerEventType;
import com.google.gwt.dev.util.log.speedtracer.SpeedTracerLogger;
import com.google.gwt.dev.util.log.speedtracer.SpeedTracerLogger.Event;
import com.google.gwt.soyc.SoycDashboard;
import com.google.gwt.soyc.io.ArtifactsOutputDirectory;
import com.google.gwt.thirdparty.guava.common.collect.ImmutableMap;
import com.google.gwt.thirdparty.guava.common.collect.Iterables;
import com.google.gwt.thirdparty.guava.common.collect.Lists;
import com.google.gwt.thirdparty.guava.common.collect.Multimap;
import com.google.gwt.thirdparty.guava.common.collect.Sets;

import org.xml.sax.SAXException;

import java.io.BufferedInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.management.ManagementFactory;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.zip.GZIPInputStream;

import javax.xml.parsers.ParserConfigurationException;


public final class JavaToJavaScriptCompiler {


  private static final float EFFICIENT_CHANGE_RATE = 0.01f;

  private static final int FIXED_POINT_CHANGE_RATE = 0;

  private static final int MAX_PASSES = 100;

  static {

    InternalCompilerException.preload();
  }

  private final CompilerContext compilerContext;
  private final TreeLogger logger;
  private final ModuleDef module;
  private final PrecompileTaskOptions options;
  private JsProgram jsProgram;
  private JProgram jprogram;

  public JavaToJavaScriptCompiler(TreeLogger logger, CompilerContext compilerContext) {
    this.logger = logger;
    this.compilerContext = compilerContext;
    this.module = compilerContext.getModule();
    this.options = compilerContext.getOptions();
  }

  public static UnifiedAst precompile(TreeLogger logger, CompilerContext compilerContext,
      PrecompilationContext precompilationContext)
      throws UnableToCompleteException {
    return new JavaToJavaScriptCompiler(logger, compilerContext).precompile(precompilationContext);
  }


  public static PermutationResult compilePermutation(UnifiedAst unifiedAst,
      TreeLogger logger, CompilerContext compilerContext, Permutation permutation)
      throws UnableToCompleteException {
    JavaToJavaScriptCompiler javaToJavaScriptCompiler =
        new JavaToJavaScriptCompiler(logger, compilerContext);
    return javaToJavaScriptCompiler.compilePermutation(permutation, unifiedAst);
  }


  private PermutationResult compilePermutation(Permutation permutation, UnifiedAst unifiedAst)
      throws UnableToCompleteException {
    Event jjsCompilePermutationEvent = SpeedTracerLogger.start(
        CompilerEventType.JJS_COMPILE_PERMUTATION, "name", permutation.getProperties().prettyPrint()
    );


    long permStartMs = System.currentTimeMillis();
    try {
      Event javaEvent = SpeedTracerLogger.start(CompilerEventType.PERMUTATION_JAVA);


      long startTimeMs = System.currentTimeMillis();
      PermutationProperties properties = permutation.getProperties();
      int permutationId = permutation.getId();
      AST ast = unifiedAst.getFreshAst();
      jprogram = ast.getJProgram();
      jsProgram = ast.getJsProgram();
      Map<StandardSymbolData, JsName> symbolTable =
          new TreeMap<StandardSymbolData, JsName>(new SymbolData.ClassIdentComparator());


      logger.log(TreeLogger.INFO, "Compiling permutation " + permutationId + "...");


      ResolvePermutationDependentValues
          .exec(jprogram, properties, permutation.getPropertyAndBindingInfos());





      Multimap<String, Integer> instrumentableLines = null;
      if (System.getProperty("gwt.coverage") != null) {
        instrumentableLines = BaselineCoverageGatherer.exec(jprogram);
      }






      maybeRecordReferencesAndControlFlow(false);



      CompileTimeConstantsReplacer.exec(jprogram);



      optimizeJava();



      TypeMapper<?> typeMapper = normalizeSemantics();


      postNormalizationOptimizeJava();


      maybeRecordReferencesAndControlFlow(true);

      javaEvent.end();

      Event javaScriptEvent = SpeedTracerLogger.start(CompilerEventType.PERMUTATION_JAVASCRIPT);


      Pair<? extends JavaToJavaScriptMap, Set<JsNode>> jjsMapAndInlineableFunctions =
          GenerateJavaScriptAST.exec(logger, jprogram, jsProgram,
              compilerContext, typeMapper, symbolTable, properties);
      JavaToJavaScriptMap jjsmap = jjsMapAndInlineableFunctions.getLeft();


      if (System.getProperty("gwt.coverage") != null) {
        CoverageInstrumentor.exec(jsProgram, instrumentableLines);
      }


      JsNormalizer.exec(jsProgram);


      JsSymbolResolver.exec(jsProgram);
      if (options.getNamespace() == JsNamespaceOption.PACKAGE) {
        JsNamespaceChooser.exec(jsProgram, jjsmap);
      }


      EvalFunctionsAtTopScope.exec(jsProgram, jjsmap);


      final Set<JsNode> inlinableJsFunctions = jjsMapAndInlineableFunctions.getRight();
      optimizeJs(inlinableJsFunctions);



      JsStackEmulator.exec(jprogram, jsProgram, properties, jjsmap);


      Pair<SyntheticArtifact, MultipleDependencyGraphRecorder> dependenciesAndRecorder =
          splitJsIntoFragments(properties, permutationId, jjsmap);


      Map<JsName, JsLiteral> internedLiteralByVariableName = renameJsSymbols(properties, jjsmap);


      JsBreakUpLargeVarStatements.exec(jsProgram, properties.getConfigurationProperties());


      List<JsSourceMap> sourceInfoMaps = new ArrayList<JsSourceMap>();
      boolean isSourceMapsEnabled = properties.isTrueInAnyPermutation("compiler.useSourceMaps");
      String[] jsFragments = new String[jsProgram.getFragmentCount()];
      StatementRanges[] ranges = new StatementRanges[jsFragments.length];
      SizeBreakdown[] sizeBreakdowns = options.isJsonSoycEnabled() || options.isSoycEnabled()
          || options.isCompilerMetricsEnabled() ? new SizeBreakdown[jsFragments.length] : null;
      generateJavaScriptCode(jjsmap, jsFragments, ranges, sizeBreakdowns, sourceInfoMaps,
          isSourceMapsEnabled || options.isJsonSoycEnabled());

      javaScriptEvent.end();


      PermutationResult permutationResult =
          new PermutationResultImpl(jsFragments, permutation, makeSymbolMap(symbolTable), ranges);


      addSyntheticArtifacts(unifiedAst, permutation, startTimeMs, permutationId, jjsmap,
          dependenciesAndRecorder, internedLiteralByVariableName, isSourceMapsEnabled, jsFragments,
          sizeBreakdowns, sourceInfoMaps, permutationResult);
      return permutationResult;
    } catch (Throwable e) {
      throw CompilationProblemReporter.logAndTranslateException(logger, e);
    } finally {
      jjsCompilePermutationEvent.end();
      if (logger.isLoggable(TreeLogger.TRACE)) {
        logger.log(TreeLogger.TRACE,
            "Permutation took " + (System.currentTimeMillis() - permStartMs) + " ms");
      }
    }
  }

  private void maybeRecordReferencesAndControlFlow(boolean onlyUpdate) {
    if (options.isIncrementalCompileEnabled()) {


      TypeReferencesRecorder.exec(jprogram, getMinimalRebuildCache(), onlyUpdate);
      ControlFlowRecorder.exec(jprogram, getMinimalRebuildCache().getTypeEnvironment(),
          onlyUpdate);
    }
  }


  protected TypeMapper<?> normalizeSemantics() {
    Event event = SpeedTracerLogger.start(CompilerEventType.JAVA_NORMALIZERS);
    try {
      Devirtualizer.exec(jprogram);
      CatchBlockNormalizer.exec(jprogram);
      PostOptimizationCompoundAssignmentNormalizer.exec(jprogram);
      LongCastNormalizer.exec(jprogram);
      LongEmulationNormalizer.exec(jprogram);
      TypeCoercionNormalizer.exec(jprogram);

      if (options.isIncrementalCompileEnabled()) {



        ComputeExhaustiveCastabilityInformation.exec(jprogram);
      } else {

        ComputeCastabilityInformation.exec(jprogram, options.isCastCheckingDisabled(),
            !shouldOptimize() );
      }

      ImplementCastsAndTypeChecks.exec(jprogram, options.isCastCheckingDisabled(),
          shouldOptimize() );
      ArrayNormalizer.exec(jprogram, options.isCastCheckingDisabled());
      EqualityNormalizer.exec(jprogram);

      TypeMapper<?> typeMapper = getTypeMapper();
      ResolveRuntimeTypeReferences.exec(jprogram, typeMapper, getTypeOrder());
      return typeMapper;
    } finally {
      event.end();
    }
  }

  private void optimizeJava() throws InterruptedException {
    if (shouldOptimize()) {
      optimizeJavaToFixedPoint();
      RemoveEmptySuperCalls.exec(jprogram);
    }
  }

  private void optimizeJs(Set<JsNode> inlinableJsFunctions) throws InterruptedException {
    if (shouldOptimize()) {
      optimizeJsLoop(inlinableJsFunctions);
      JsDuplicateCaseFolder.exec(jsProgram);
    }
  }

  private void postNormalizationOptimizeJava() {
    Event event = SpeedTracerLogger.start(CompilerEventType.JAVA_POST_NORMALIZER_OPTIMIZERS);
    try {
      if (shouldOptimize()) {
        RemoveSpecializations.exec(jprogram);
        Pruner.exec(jprogram, false);

        jprogram.typeOracle.recomputeAfterOptimizations(jprogram.getDeclaredTypes());
      }
      ReplaceGetClassOverrides.exec(jprogram);
    } finally {
      event.end();
    }
  }

  private Map<JsName, JsLiteral> runDetailedNamer(ConfigurationProperties config)
      throws IllegalNameException {
    Map<JsName, JsLiteral> internedTextByVariableName =
        maybeInternLiterals(JsLiteralInterner.INTERN_ALL);
    JsVerboseNamer.exec(jsProgram, config);
    return internedTextByVariableName;
  }

  private Map<JsName, JsLiteral> maybeInternLiterals(int interningMask) {
    if (!shouldOptimize()) {
      return null;
    }

    if (options.isClosureCompilerFormatEnabled()) {

      interningMask &= ~JsLiteralInterner.INTERN_STRINGS;
    }
    return JsLiteralInterner.exec(jprogram, jsProgram, interningMask);
  }

  private Pair<SyntheticArtifact, MultipleDependencyGraphRecorder> splitJsIntoFragments(
      PermutationProperties properties, int permutationId, JavaToJavaScriptMap jjsmap) {
    Pair<SyntheticArtifact, MultipleDependencyGraphRecorder> dependenciesAndRecorder;
    MultipleDependencyGraphRecorder dependencyRecorder = null;
    SyntheticArtifact dependencies = null;
    if (options.isRunAsyncEnabled()) {
      ByteArrayOutputStream baos = new ByteArrayOutputStream();

      int expectedFragmentCount = options.getFragmentCount();

      if (expectedFragmentCount <= 0) {

        int numberOfMerges = options.getFragmentsMerge();
        if (numberOfMerges > 0) {


          expectedFragmentCount =
              Math.max(0, jprogram.getRunAsyncs().size() + 2 - numberOfMerges);
        }
      }

      int minFragmentSize = properties.getConfigurationProperties()
          .getInteger(CodeSplitters.MIN_FRAGMENT_SIZE, 0);

      dependencyRecorder = chooseDependencyRecorder(baos);
      CodeSplitter.exec(logger, jprogram, jsProgram, jjsmap, expectedFragmentCount,
          minFragmentSize, dependencyRecorder);

      if (baos.size() == 0) {
        dependencyRecorder = recordNonSplitDependencies(baos);
      }
      if (baos.size() > 0) {
        dependencies = new SyntheticArtifact(
            SoycReportLinker.class, "dependencies" + permutationId + ".xml.gz",
            baos.toByteArray());
      }
    } else if (options.isSoycEnabled() || options.isJsonSoycEnabled()) {
      dependencyRecorder = recordNonSplitDependencies(new ByteArrayOutputStream());
    }
    dependenciesAndRecorder = Pair.create(
        dependencies, dependencyRecorder);



    HandleCrossFragmentReferences.exec(jsProgram, properties);

    return dependenciesAndRecorder;
  }

  private MultipleDependencyGraphRecorder chooseDependencyRecorder(OutputStream out) {
    MultipleDependencyGraphRecorder dependencyRecorder =
        MultipleDependencyGraphRecorder.NULL_RECORDER;
    if (options.isSoycEnabled() && options.isJsonSoycEnabled()) {
      dependencyRecorder = new DependencyGraphRecorder(out, jprogram);
    } else if (options.isSoycEnabled()) {
      dependencyRecorder = new DependencyRecorder(out);
    } else if (options.isJsonSoycEnabled()) {
      dependencyRecorder = new DependencyGraphRecorder(out, jprogram);
    }
    return dependencyRecorder;
  }


  private DependencyRecorder recordNonSplitDependencies(OutputStream out) {
    DependencyRecorder deps;
    if (options.isSoycEnabled() && options.isJsonSoycEnabled()) {
      deps = new DependencyGraphRecorder(out, jprogram);
    } else if (options.isSoycEnabled()) {
      deps = new DependencyRecorder(out);
    } else if (options.isJsonSoycEnabled()) {
      deps = new DependencyGraphRecorder(out, jprogram);
    } else {
      return null;
    }
    deps.open();
    deps.startDependencyGraph("initial", null);

    ControlFlowAnalyzer cfa = new ControlFlowAnalyzer(jprogram);
    cfa.setDependencyRecorder(deps);
    cfa.traverseEntryMethods();
    deps.endDependencyGraph();
    deps.close();
    return deps;
  }

  private CompilationMetricsArtifact addCompilerMetricsArtifact(UnifiedAst unifiedAst,
      Permutation permutation, long startTimeMs, SizeBreakdown[] sizeBreakdowns,
      PermutationResult permutationResult) {
    CompilationMetricsArtifact compilationMetrics = null;

    if (options.isCompilerMetricsEnabled()) {
      if (options.isClosureCompilerEnabled()) {
        logger.log(TreeLogger.WARN, "Incompatible options: -XenableClosureCompiler and "
            + "-XcompilerMetric; ignoring -XcompilerMetric.");
      } else {
        compilationMetrics = new CompilationMetricsArtifact(permutation.getId());
        compilationMetrics.setCompileElapsedMilliseconds(
            System.currentTimeMillis() - startTimeMs);
        compilationMetrics.setElapsedMilliseconds(
            System.currentTimeMillis() - ManagementFactory.getRuntimeMXBean().getStartTime());
        compilationMetrics.setJsSize(sizeBreakdowns);
        compilationMetrics.setPermutationDescription(permutation.getProperties().prettyPrint());
        permutationResult.addArtifacts(Lists.newArrayList(
            unifiedAst.getModuleMetrics(), unifiedAst.getPrecompilationMetrics(),
            compilationMetrics));
      }
    }
    return compilationMetrics;
  }

  private void addSourceMapArtifacts(int permutationId, JavaToJavaScriptMap jjsmap,
      Pair<SyntheticArtifact, MultipleDependencyGraphRecorder> dependenciesAndRecorder,
      boolean isSourceMapsEnabled, SizeBreakdown[] sizeBreakdowns,
      List<JsSourceMap> sourceInfoMaps, PermutationResult permutationResult) {
    if (options.isJsonSoycEnabled()) {

      if (options.isClosureCompilerEnabled()) {
        logger.log(TreeLogger.WARN, "Incompatible options: -XenableClosureCompiler and "
            + "-XjsonSoyc; ignoring -XjsonSoyc.");
      } else {

        permutationResult.addArtifacts(EntityRecorder.makeSoycArtifacts(
            permutationId, sourceInfoMaps, options.getSourceMapFilePrefix(),
            jjsmap, sizeBreakdowns,
            ((DependencyGraphRecorder) dependenciesAndRecorder.getRight()), jprogram));
      }
    } else if (isSourceMapsEnabled) {

      if (options.isClosureCompilerEnabled()) {
        logger.log(TreeLogger.WARN, "Incompatible options: -XenableClosureCompiler and "
            + "compiler.useSourceMaps=true; ignoring compiler.useSourceMaps=true.");
      } else {
        logger.log(TreeLogger.INFO, "Source Maps Enabled");
        permutationResult.addArtifacts(SourceMapRecorder.exec(permutationId, sourceInfoMaps,
            options.getSourceMapFilePrefix()));
      }
    }
  }


  private void maybeAddGeneratedArtifacts(PermutationResult permutationResult) {
    if (options.isIncrementalCompileEnabled()) {
      permutationResult.addArtifacts(
          compilerContext.getMinimalRebuildCache().getGeneratedArtifacts());
    }
  }

  private void addSoycArtifacts(UnifiedAst unifiedAst, int permutationId,
      JavaToJavaScriptMap jjsmap,
      Pair<SyntheticArtifact, MultipleDependencyGraphRecorder> dependenciesAndRecorder,
      Map<JsName, JsLiteral> internedLiteralByVariableName, String[] js,
      SizeBreakdown[] sizeBreakdowns,
      List<JsSourceMap> sourceInfoMaps, PermutationResult permutationResult,
      CompilationMetricsArtifact compilationMetrics)
      throws IOException, UnableToCompleteException {

    if (options.isClosureCompilerEnabled()) {
      if (options.isSoycEnabled()) {
        logger.log(TreeLogger.WARN, "Incompatible options: -XenableClosureCompiler and "
            + "-compileReport; ignoring -compileReport.");
      }
    } else {
      permutationResult.addArtifacts(makeSoycArtifacts(permutationId, js, sizeBreakdowns,
          options.isSoycExtra() ? sourceInfoMaps : null, dependenciesAndRecorder.getLeft(),
          jjsmap, internedLiteralByVariableName, unifiedAst.getModuleMetrics(),
          unifiedAst.getPrecompilationMetrics(), compilationMetrics,
          options.isSoycHtmlDisabled()));
    }
  }

  private void addSyntheticArtifacts(UnifiedAst unifiedAst, Permutation permutation,
      long startTimeMs, int permutationId, JavaToJavaScriptMap jjsmap,
      Pair<SyntheticArtifact, MultipleDependencyGraphRecorder> dependenciesAndRecorder,
      Map<JsName, JsLiteral> internedLiteralByVariableName, boolean isSourceMapsEnabled,
      String[] jsFragments, SizeBreakdown[] sizeBreakdowns,
      List<JsSourceMap> sourceInfoMaps, PermutationResult permutationResult)
      throws IOException, UnableToCompleteException {

    assert internedLiteralByVariableName != null;

    Event event = SpeedTracerLogger.start(CompilerEventType.PERMUTATION_ARTIFACTS);

    CompilationMetricsArtifact compilationMetrics = addCompilerMetricsArtifact(
        unifiedAst, permutation, startTimeMs, sizeBreakdowns, permutationResult);
    addSoycArtifacts(unifiedAst, permutationId, jjsmap, dependenciesAndRecorder,
        internedLiteralByVariableName, jsFragments, sizeBreakdowns, sourceInfoMaps,
        permutationResult, compilationMetrics);
    addSourceMapArtifacts(permutationId, jjsmap, dependenciesAndRecorder, isSourceMapsEnabled,
        sizeBreakdowns, sourceInfoMaps, permutationResult);
    maybeAddGeneratedArtifacts(permutationResult);

    event.end();
  }


  private void generateJavaScriptCode(JavaToJavaScriptMap jjsMap, String[] jsFragments,
      StatementRanges[] ranges, SizeBreakdown[] sizeBreakdowns,
      List<JsSourceMap> sourceInfoMaps, boolean sourceMapsEnabled) {

    Event generateJavascriptEvent =
        SpeedTracerLogger.start(CompilerEventType.GENERATE_JAVASCRIPT);

    boolean useClosureCompiler = options.isClosureCompilerEnabled();
    if (useClosureCompiler) {
      ClosureJsRunner runner = new ClosureJsRunner();
      runner.compile(jprogram, jsProgram, jsFragments, options.getOutput());
      generateJavascriptEvent.end();
      return;
    }

    for (int i = 0; i < jsFragments.length; i++) {
      DefaultTextOutput out = new DefaultTextOutput(!options.isIncrementalCompileEnabled() &&
          options.getOutput().shouldMinimize());
      JsReportGenerationVisitor v = new JsReportGenerationVisitor(out, jjsMap,
          options.isJsonSoycEnabled());
      v.accept(jsProgram.getFragmentBlock(i));

      StatementRanges statementRanges = v.getStatementRanges();
      String code = out.toString();
      JsSourceMap infoMap = (sourceInfoMaps != null) ? v.getSourceInfoMap() : null;

      JsAbstractTextTransformer transformer =
          new JsNoopTransformer(code, statementRanges, infoMap);


      if (options.isIncrementalCompileEnabled()) {
        transformer = new JsTypeLinker(logger, transformer, v.getClassRanges(),
            v.getProgramClassRange(), getMinimalRebuildCache(), jprogram.typeOracle);
        transformer.exec();
      }


      Event functionClusterEvent = SpeedTracerLogger.start(CompilerEventType.FUNCTION_CLUSTER);

      if (!sourceMapsEnabled && !options.isClosureCompilerFormatEnabled()
          && options.shouldClusterSimilarFunctions()
          && options.getNamespace() == JsNamespaceOption.NONE
          && options.getOutput() == JsOutputOption.OBFUSCATED) {
        transformer = new JsFunctionClusterer(transformer);
        transformer.exec();
      }
      functionClusterEvent.end();

      jsFragments[i] = transformer.getJs();
      ranges[i] = transformer.getStatementRanges();
      if (sizeBreakdowns != null) {
        sizeBreakdowns[i] = v.getSizeBreakdown();
      }
      if (sourceInfoMaps != null) {
        sourceInfoMaps.add(transformer.getSourceInfoMap());
      }
    }

    generateJavascriptEvent.end();
  }

  private Collection<? extends Artifact<?>> makeSoycArtifacts(int permutationId, String[] js,
      SizeBreakdown[] sizeBreakdowns, List<JsSourceMap> sourceInfoMaps,
      SyntheticArtifact dependencies, JavaToJavaScriptMap jjsmap,
      Map<JsName, JsLiteral> internedLiteralByVariableName,
      ModuleMetricsArtifact moduleMetricsArtifact,
      PrecompilationMetricsArtifact precompilationMetricsArtifact,
      CompilationMetricsArtifact compilationMetrics, boolean htmlReportsDisabled)
      throws IOException, UnableToCompleteException {
    Memory.maybeDumpMemory("makeSoycArtifactsStart");
    List<SyntheticArtifact> soycArtifacts = new ArrayList<SyntheticArtifact>();

    ByteArrayOutputStream baos = new ByteArrayOutputStream();

    Event soycEvent = SpeedTracerLogger.start(CompilerEventType.MAKE_SOYC_ARTIFACTS);

    Event recordSplitPoints = SpeedTracerLogger.start(
        CompilerEventType.MAKE_SOYC_ARTIFACTS, "phase", "recordSplitPoints");
    SplitPointRecorder.recordSplitPoints(jprogram, baos, logger);
    SyntheticArtifact splitPoints = new SyntheticArtifact(
        SoycReportLinker.class, "splitPoints" + permutationId + ".xml.gz", baos.toByteArray());
    soycArtifacts.add(splitPoints);
    recordSplitPoints.end();

    SyntheticArtifact sizeMaps = null;
    if (sizeBreakdowns != null) {
      Event recordSizeMap = SpeedTracerLogger.start(
          CompilerEventType.MAKE_SOYC_ARTIFACTS, "phase", "recordSizeMap");
      baos.reset();
      SizeMapRecorder.recordMap(logger, baos, sizeBreakdowns, jjsmap,
          internedLiteralByVariableName);
      sizeMaps = new SyntheticArtifact(
          SoycReportLinker.class, "stories" + permutationId + ".xml.gz", baos.toByteArray());
      soycArtifacts.add(sizeMaps);
      recordSizeMap.end();
    }

    if (sourceInfoMaps != null) {
      Event recordStories = SpeedTracerLogger.start(
          CompilerEventType.MAKE_SOYC_ARTIFACTS, "phase", "recordStories");
      baos.reset();
      StoryRecorder.recordStories(logger, baos, sourceInfoMaps, js);
      soycArtifacts.add(new SyntheticArtifact(
          SoycReportLinker.class, "detailedStories" + permutationId + ".xml.gz",
          baos.toByteArray()));
      recordStories.end();
    }

    if (dependencies != null) {
      soycArtifacts.add(dependencies);
    }


    for (SyntheticArtifact soycArtifact : soycArtifacts) {
      soycArtifact.setVisibility(Visibility.Private);
    }

    if (!htmlReportsDisabled && sizeBreakdowns != null) {
      Event generateCompileReport = SpeedTracerLogger.start(
          CompilerEventType.MAKE_SOYC_ARTIFACTS, "phase", "generateCompileReport");
      ArtifactsOutputDirectory outDir = new ArtifactsOutputDirectory();
      SoycDashboard dashboard = new SoycDashboard(outDir);
      dashboard.startNewPermutation(Integer.toString(permutationId));
      try {
        dashboard.readSplitPoints(openWithGunzip(splitPoints));
        if (sizeMaps != null) {
          dashboard.readSizeMaps(openWithGunzip(sizeMaps));
        }
        if (dependencies != null) {
          dashboard.readDependencies(openWithGunzip(dependencies));
        }
        Memory.maybeDumpMemory("soycReadDependenciesEnd");
      } catch (ParserConfigurationException e) {
        throw new InternalCompilerException(
            "Error reading compile report information that was just generated", e);
      } catch (SAXException e) {
        throw new InternalCompilerException(
            "Error reading compile report information that was just generated", e);
      }
      dashboard.generateForOnePermutation();
      if (moduleMetricsArtifact != null && precompilationMetricsArtifact != null
          && compilationMetrics != null) {
        dashboard.generateCompilerMetricsForOnePermutation(
            moduleMetricsArtifact, precompilationMetricsArtifact, compilationMetrics);
      }
      soycArtifacts.addAll(outDir.getArtifacts());
      generateCompileReport.end();
    }

    soycEvent.end();

    return soycArtifacts;
  }

  private SymbolData[] makeSymbolMap(Map<StandardSymbolData, JsName> symbolTable) {


    final Set<String> nameUsed = new HashSet<String>();
    final Map<JsName, Integer> nameToFragment = new HashMap<JsName, Integer>();

    for (int i = 0; i < jsProgram.getFragmentCount(); i++) {
      final Integer fragId = i;
      new JsVisitor() {
        @Override
        public void endVisit(JsForIn x, JsContext ctx) {
          if (x.getIterVarName() != null) {
            nameUsed.add(x.getIterVarName().getIdent());
          }
        }

        @Override
        public void endVisit(JsFunction x, JsContext ctx) {
          if (x.getName() != null) {
            nameToFragment.put(x.getName(), fragId);
            nameUsed.add(x.getName().getIdent());
          }
        }

        @Override
        public void endVisit(JsLabel x, JsContext ctx) {
          nameUsed.add(x.getName().getIdent());
        }

        @Override
        public void endVisit(JsNameOf x, JsContext ctx) {
          if (x.getName() != null) {
            nameUsed.add(x.getName().getIdent());
          }
        }

        @Override
        public void endVisit(JsNameRef x, JsContext ctx) {




          if (x.isResolved()) {
            nameUsed.add(x.getName().getIdent());
          }
        }

        @Override
        public void endVisit(JsParameter x, JsContext ctx) {
          nameUsed.add(x.getName().getIdent());
        }

        @Override

        public void endVisit(JsVars.JsVar x, JsContext ctx) {
          nameUsed.add(x.getName().getIdent());
        }
      }.accept(jsProgram.getFragmentBlock(i));
    }





    List<SymbolData> result = new ArrayList<SymbolData>();

    for (Map.Entry<StandardSymbolData, JsName> entry : symbolTable.entrySet()) {
      StandardSymbolData symbolData = entry.getKey();
      symbolData.setSymbolName(entry.getValue().getShortIdent());
      Integer fragNum = nameToFragment.get(entry.getValue());
      if (fragNum != null) {
        symbolData.setFragmentNumber(fragNum);
      }
      if (nameUsed.contains(entry.getValue().getIdent()) || entry.getKey().isClass()) {
        result.add(symbolData);
      }
    }

    return result.toArray(new SymbolData[result.size()]);
  }


  private InputStream openWithGunzip(EmittedArtifact artifact)
      throws IOException, UnableToCompleteException {
    return new BufferedInputStream(new GZIPInputStream(artifact.getContents(TreeLogger.NULL)));
  }

  private void optimizeJsLoop(Collection<JsNode> toInline) throws InterruptedException {
    int optimizationLevel = options.getOptimizationLevel();
    List<OptimizerStats> allOptimizerStats = Lists.newArrayList();
    int counter = 0;
    while (true) {
      counter++;
      if (Thread.interrupted()) {
        throw new InterruptedException();
      }
      Event optimizeJsEvent = SpeedTracerLogger.start(CompilerEventType.OPTIMIZE_JS);

      OptimizerStats stats = new OptimizerStats("Pass " + counter);


      stats.add(JsStaticEval.exec(jsProgram));

      stats.add(JsInliner.exec(jsProgram, toInline));

      stats.add(JsUnusedFunctionRemover.exec(jsProgram));


      allOptimizerStats.add(stats);

      optimizeJsEvent.end();
      if ((optimizationLevel < OptionOptimize.OPTIMIZE_LEVEL_MAX && counter > optimizationLevel)
          || !stats.didChange()) {
        break;
      }
    }

    if (optimizationLevel > OptionOptimize.OPTIMIZE_LEVEL_DRAFT) {
      DuplicateExecuteOnceRemover.exec(jsProgram);
    }
  }

  private Map<JsName, JsLiteral> renameJsSymbols(PermutationProperties properties,
      JavaToJavaScriptMap jjsmap) throws UnableToCompleteException {
    Map<JsName, JsLiteral> internedLiteralByVariableName = null;
    try {
      switch (options.getOutput()) {
        case OBFUSCATED:
          internedLiteralByVariableName = runObfuscateNamer(options, properties, jjsmap);
          break;
        case PRETTY:
          internedLiteralByVariableName = runPrettyNamer(options, properties, jjsmap);
          break;
        case DETAILED:
          internedLiteralByVariableName = runDetailedNamer(properties.getConfigurationProperties());
          break;
        default:
          throw new InternalCompilerException("Unknown output mode");
      }
    } catch (IllegalNameException e) {
      logger.log(TreeLogger.ERROR, e.getMessage(), e);
      throw new UnableToCompleteException();
    }
    return internedLiteralByVariableName == null ?
        ImmutableMap.<JsName, JsLiteral>of() : internedLiteralByVariableName;
  }

  private Map<JsName, JsLiteral> runObfuscateNamer(JJSOptions options,
      PermutationProperties properties, JavaToJavaScriptMap jjsmap)
      throws IllegalNameException {
    if (options.isIncrementalCompileEnabled()) {
      runIncrementalNamer(options, properties.getConfigurationProperties(), jjsmap);
      return null;
    }

    Map<JsName, JsLiteral> internedLiteralByVariableName =
        maybeInternLiterals(JsLiteralInterner.INTERN_ALL);
    FreshNameGenerator freshNameGenerator =
        JsObfuscateNamer.exec(jsProgram, properties.getConfigurationProperties());
    if (options.shouldRemoveDuplicateFunctions()
        && JsStackEmulator.getStackMode(properties) == JsStackEmulator.StackMode.STRIP) {
      JsDuplicateFunctionRemover.exec(jsProgram, freshNameGenerator);
    }
    return internedLiteralByVariableName;
  }

  private Map<JsName, JsLiteral> runPrettyNamer(JJSOptions options,
      PermutationProperties properties, JavaToJavaScriptMap jjsmap)
      throws IllegalNameException {
    if (options.isIncrementalCompileEnabled()) {
      runIncrementalNamer(options, properties.getConfigurationProperties(), jjsmap);
      return null;
    }

    Map<JsName, JsLiteral> internedLiteralByVariableName =
        maybeInternLiterals(JsLiteralInterner.INTERN_ALL & ~JsLiteralInterner.INTERN_STRINGS);

    JsPrettyNamer.exec(jsProgram, properties.getConfigurationProperties());
    return internedLiteralByVariableName;
  }

  private void runIncrementalNamer(JJSOptions options,
      ConfigurationProperties configurationProperties, JavaToJavaScriptMap jjsmap)
    throws IllegalNameException {
    JsIncrementalNamer.exec(jsProgram, configurationProperties,
        compilerContext.getMinimalRebuildCache().getPersistentPrettyNamerState(), jjsmap,
        options.getOutput() == JsOutputOption.OBFUSCATED);
  }


  private UnifiedAst precompile(PrecompilationContext precompilationContext)
      throws UnableToCompleteException {
    try {


      if (precompilationContext.getEntryPoints().length +
          precompilationContext.getAdditionalRootTypes().length == 0) {
        throw new IllegalArgumentException("entry point(s) required");
      }

      boolean singlePermutation = precompilationContext.getPermutations().length == 1;
      PrecompilationMetricsArtifact precompilationMetrics =
          precompilationContext.getPrecompilationMetricsArtifact();



      jprogram = new JProgram(compilerContext.getMinimalRebuildCache());

      jprogram.typeOracle.setOptimize(
          options.getOptimizationLevel() > OptionOptimize.OPTIMIZE_LEVEL_DRAFT);

      jsProgram = new JsProgram();


      CompilationState compilationState =
          constructJavaAst(precompilationContext);


      JsniRestrictionChecker.exec(logger, jprogram);
      JsInteropRestrictionChecker.exec(logger, jprogram, getMinimalRebuildCache());
      logTypeOracleMetrics(precompilationMetrics, compilationState);
      Memory.maybeDumpMemory("AstOnly");
      AstDumper.maybeDumpAST(jprogram);


      ConfigurationProperties configurationProperties = new ConfigurationProperties(module);
      EnumNameObfuscator.exec(jprogram, logger, configurationProperties, options);



      ReplaceDefenderMethodReferences.exec(jprogram);

      FixAssignmentsToUnboxOrCast.exec(jprogram);
      if (options.isEnableAssertions()) {
        AssertionNormalizer.exec(jprogram);
      } else {
        AssertionRemover.exec(jprogram);
      }
      if (module != null && options.isRunAsyncEnabled()) {
        ReplaceRunAsyncs.exec(logger, jprogram);
        ConfigurationProperties config = new ConfigurationProperties(module);
        CodeSplitters.pickInitialLoadSequence(logger, jprogram, config);
      }
      ImplementClassLiteralsAsFields.exec(jprogram, shouldOptimize());


      logAstTypeMetrics(precompilationMetrics);


      Event createUnifiedAstEvent = SpeedTracerLogger.start(CompilerEventType.CREATE_UNIFIED_AST);
      UnifiedAst result = new UnifiedAst(
          options, new AST(jprogram, jsProgram), singlePermutation, RecordRebinds.exec(jprogram));
      createUnifiedAstEvent.end();
      return result;
    } catch (Throwable e) {
      throw CompilationProblemReporter.logAndTranslateException(logger, e);
    }
  }


  private String buildEntryMethodHolder(StandardGeneratorContext context,
      String[] entryPointTypeNames, Set<String> allRootTypes)
      throws UnableToCompleteException {

    if (entryPointTypeNames.length == 0) {

      return null;
    }

    EntryMethodHolderGenerator entryMethodHolderGenerator = new EntryMethodHolderGenerator();
    String entryMethodHolderTypeName =
        entryMethodHolderGenerator.generate(logger, context, module.getCanonicalName());
    context.finish(logger);

    allRootTypes.add(entryMethodHolderTypeName);


    jprogram.addIndexedTypeName(entryMethodHolderTypeName);
    return entryMethodHolderTypeName;
  }

  private CompilationState constructJavaAst(PrecompilationContext precompilationContext)
      throws UnableToCompleteException {
    RebindPermutationOracle rpo = precompilationContext.getRebindPermutationOracle();

    CompilationState compilationState = rpo.getCompilationState();
    Memory.maybeDumpMemory("CompStateBuilt");
    recordJsoTypes(compilationState.getTypeOracle());
    unifyJavaAst(precompilationContext);
    if (options.isSoycEnabled() || options.isJsonSoycEnabled()) {
      SourceInfoCorrelator.exec(jprogram);
    }


    rpo.clear();
    Set<String> deletedTypeNames = options.isIncrementalCompileEnabled()
        ? getMinimalRebuildCache().computeDeletedTypeNames() : Sets.<String>newHashSet();
    jprogram.typeOracle.computeBeforeAST(StandardTypes.createFrom(jprogram),
        jprogram.getDeclaredTypes(), jprogram.getModuleDeclaredTypes(), deletedTypeNames);
    return compilationState;
  }


  private String[] getReferencedJavaClasses() {
    class ClassNameVisitor extends JVisitor {
      List<String> classNames = new ArrayList<String>();

      @Override
      public boolean visit(JClassType x, Context ctx) {
        classNames.add(x.getName());
        return true;
      }
    }
    ClassNameVisitor v = new ClassNameVisitor();
    v.accept(jprogram);
    return v.classNames.toArray(new String[v.classNames.size()]);
  }

  private void logAstTypeMetrics(PrecompilationMetricsArtifact precompilationMetrics) {
    if (options.isCompilerMetricsEnabled()) {
      precompilationMetrics.setAstTypes(getReferencedJavaClasses());
    }
  }

  private void logTypeOracleMetrics(
      PrecompilationMetricsArtifact precompilationMetrics, CompilationState compilationState) {
    if (precompilationMetrics != null) {
      List<String> finalTypeOracleTypes = Lists.newArrayList();
      for (com.google.gwt.core.ext.typeinfo.JClassType type :
          compilationState.getTypeOracle().getTypes()) {
        finalTypeOracleTypes.add(type.getPackage().getName() + "." + type.getName());
      }
      precompilationMetrics.setFinalTypeOracleTypes(finalTypeOracleTypes);
    }
  }

  private Set<String> computeRootTypes(String[] entryPointTypeNames,
      String[] additionalRootTypes, CompilationState compilationState) {

    Set<String> allRootTypes = Sets.newTreeSet();
    Iterables.addAll(allRootTypes, compilationState.getQualifiedJsInteropRootTypesNames());
    Collections.addAll(allRootTypes, entryPointTypeNames);
    Collections.addAll(allRootTypes, additionalRootTypes);
    allRootTypes.addAll(JProgram.CODEGEN_TYPES_SET);
    allRootTypes.addAll(jprogram.getTypeNamesToIndex());

    TypeOracle typeOracle = compilationState.getTypeOracle();
    for (com.google.gwt.core.ext.typeinfo.JClassType singleJsoIntf :
        typeOracle.getSingleJsoImplInterfaces()) {
      allRootTypes.add(typeOracle.getSingleJsoImpl(singleJsoIntf).getQualifiedSourceName());
    }
    return allRootTypes;
  }

  private void recordJsoTypes(TypeOracle typeOracle) {
    if (!options.isIncrementalCompileEnabled()) {
      return;
    }


    Set<String> jsoTypeNames = Sets.newHashSet();
    for (com.google.gwt.dev.javac.typemodel.JClassType subtype :
        typeOracle.getJavaScriptObject().getSubtypes()) {
      jsoTypeNames.add(subtype.getQualifiedBinaryName());
    }


    Set<String> singleJsoImplInterfaceNames = Sets.newHashSet();
    for (com.google.gwt.core.ext.typeinfo.JClassType singleJsoImplInterface :
        typeOracle.getSingleJsoImplInterfaces()) {
      singleJsoImplInterfaceNames.add(singleJsoImplInterface.getQualifiedBinaryName());
    }



    Set<String> dualJsoImplInterfaceNames = Sets.newHashSet();
    for (com.google.gwt.core.ext.typeinfo.JClassType dualJsoImplInterface :
        typeOracle.getDualJsoImplInterfaces()) {
      dualJsoImplInterfaceNames.add(dualJsoImplInterface.getQualifiedBinaryName());
    }

    compilerContext.getMinimalRebuildCache().setJsoTypeNames(jsoTypeNames,
        singleJsoImplInterfaceNames, dualJsoImplInterfaceNames);
  }

  private void synthesizeEntryMethodHolderInit(UnifyAst unifyAst, String[] entryPointTypeNames,
      String entryMethodHolderTypeName) throws UnableToCompleteException {

    JDeclaredType entryMethodHolderType =
        unifyAst.findType(entryMethodHolderTypeName, unifyAst.getSourceNameBasedTypeLocator());
    JDeclaredType gwtType = unifyAst.findType("com.google.gwt.core.client.GWT",
        unifyAst.getSourceNameBasedTypeLocator());
    JDeclaredType entryPointType = unifyAst.findType("com.google.gwt.core.client.EntryPoint",
        unifyAst.getSourceNameBasedTypeLocator());


    JMethod initMethod = entryMethodHolderType.findMethod("init()V", false);
    JMethod gwtCreateMethod =
        gwtType.findMethod("create(Ljava/lang/Class;)Ljava/lang/Object;", false);


    JBlock initMethodBlock = ((JMethodBody) initMethod.getBody()).getBlock();
    SourceInfo origin = initMethodBlock.getSourceInfo().makeChild();
    for (String entryPointTypeName : entryPointTypeNames) {

      JDeclaredType specificEntryPointType =
          unifyAst.findType(entryPointTypeName, unifyAst.getSourceNameBasedTypeLocator());
      if (specificEntryPointType == null) {
        logger.log(TreeLogger.ERROR,
            "Could not find module entry point class '" + entryPointTypeName + "'", null);
        throw new UnableToCompleteException();
      }
      JMethod onModuleLoadMethod =
          entryPointType.findMethod("onModuleLoad()V", true);
      JMethod specificOnModuleLoadMethod =
          specificEntryPointType.findMethod("onModuleLoad()V", true);

      if (specificOnModuleLoadMethod != null && specificOnModuleLoadMethod.isStatic()) {

        JMethodCall staticOnModuleLoadCall =
            new JMethodCall(origin, null, specificOnModuleLoadMethod);
        initMethodBlock.addStmt(staticOnModuleLoadCall.makeStatement());
      } else {

        JClassLiteral entryPointTypeClassLiteral =
            new JClassLiteral(origin, specificEntryPointType);
        JMethodCall createInstanceCall =
            new JMethodCall(origin, null, gwtCreateMethod, entryPointTypeClassLiteral);
        JCastOperation castToEntryPoint =
            new JCastOperation(origin, entryPointType, createInstanceCall);
        JMethodCall instanceOnModuleLoadCall =
            new JMethodCall(origin, castToEntryPoint, onModuleLoadMethod);
        initMethodBlock.addStmt(instanceOnModuleLoadCall.makeStatement());
      }
    }
  }

  private void unifyJavaAst(PrecompilationContext precompilationContext)
      throws UnableToCompleteException {

    Event event = SpeedTracerLogger.start(CompilerEventType.UNIFY_AST);

    RebindPermutationOracle rpo = precompilationContext.getRebindPermutationOracle();
    String[] entryPointTypeNames = precompilationContext.getEntryPoints();
    String[] additionalRootTypes = precompilationContext.getAdditionalRootTypes();

    Set<String> allRootTypes = computeRootTypes(entryPointTypeNames, additionalRootTypes,
        rpo.getCompilationState());

    String entryMethodHolderTypeName =
        buildEntryMethodHolder(rpo.getGeneratorContext(), entryPointTypeNames, allRootTypes);

    UnifyAst unifyAst =
        new UnifyAst(logger, compilerContext, jprogram, jsProgram, precompilationContext);

    unifyAst.addRootTypes(allRootTypes);


    if (entryMethodHolderTypeName != null) {


      synthesizeEntryMethodHolderInit(unifyAst, entryPointTypeNames, entryMethodHolderTypeName);
    }
    if (entryMethodHolderTypeName != null) {


      jprogram.addEntryMethod(jprogram.getIndexedMethod(
          SourceName.getShortClassName(entryMethodHolderTypeName) + ".init"));
    }
    unifyAst.exec();

    event.end();
  }

  private void optimizeJavaToFixedPoint() throws InterruptedException {
    Event optimizeEvent = SpeedTracerLogger.start(CompilerEventType.OPTIMIZE);

    List<OptimizerStats> allOptimizerStats = Lists.newArrayList();
    int passCount = 0;
    int nodeCount = jprogram.getNodeCount();
    int lastNodeCount;

    boolean atMaxLevel = options.getOptimizationLevel() == OptionOptimize.OPTIMIZE_LEVEL_MAX;
    int passLimit = atMaxLevel ? MAX_PASSES : options.getOptimizationLevel();
    float minChangeRate = atMaxLevel ? FIXED_POINT_CHANGE_RATE : EFFICIENT_CHANGE_RATE;
    OptimizerContext optimizerCtx = new FullOptimizerContext(jprogram);
    while (true) {
      passCount++;
      if (passCount > passLimit) {
        break;
      }
      if (Thread.interrupted()) {
        optimizeEvent.end();
        throw new InterruptedException();
      }
      AstDumper.maybeDumpAST(jprogram);
      OptimizerStats stats = optimizeJavaOneTime("Pass " + passCount, nodeCount, optimizerCtx);
      allOptimizerStats.add(stats);
      lastNodeCount = nodeCount;
      nodeCount = jprogram.getNodeCount();

      float nodeChangeRate = stats.getNumMods() / (float) lastNodeCount;
      float sizeChangeRate = (lastNodeCount - nodeCount) / (float) lastNodeCount;
      if (nodeChangeRate <= minChangeRate && sizeChangeRate <= minChangeRate) {
        break;
      }
    }

    if (options.shouldOptimizeDataflow()) {

      allOptimizerStats.add(DataflowOptimizer.exec(jprogram));
    }

    optimizeEvent.end();
  }

  private boolean shouldOptimize() {
    return options.getOptimizationLevel() > OptionOptimize.OPTIMIZE_LEVEL_DRAFT;
  }

  private TypeMapper getTypeMapper() {


    if (JjsUtils.closureStyleLiteralsNeeded(this.options)) {
      return new ClosureUniqueIdTypeMapper(jprogram);
    }

    if (this.options.useDetailedTypeIds()) {
      return new StringTypeMapper();
    }
    return this.options.isIncrementalCompileEnabled() ?
        compilerContext.getMinimalRebuildCache().getTypeMapper() :
        new IntTypeMapper();
  }

  private TypeOrder getTypeOrder() {


    if (JjsUtils.closureStyleLiteralsNeeded(this.options)) {
      return TypeOrder.ALPHABETICAL;
    }

    if (this.options.useDetailedTypeIds()) {
      return TypeOrder.NONE;
    }
    return this.options.isIncrementalCompileEnabled() ? TypeOrder.ALPHABETICAL
        : TypeOrder.FREQUENCY;
  }

  private OptimizerStats optimizeJavaOneTime(String passName, int numNodes,
      OptimizerContext optimizerCtx) {
    Event optimizeEvent = SpeedTracerLogger.start(CompilerEventType.OPTIMIZE, "phase", "loop");

    jprogram.typeOracle.recomputeAfterOptimizations(jprogram.getDeclaredTypes());
    OptimizerStats stats = new OptimizerStats(passName);
    JavaAstVerifier.assertProgramIsConsistent(jprogram);
    stats.add(Pruner.exec(jprogram, true, optimizerCtx).recordVisits(numNodes));
    stats.add(Finalizer.exec(jprogram, optimizerCtx).recordVisits(numNodes));
    stats.add(MakeCallsStatic.exec(jprogram, options.shouldAddRuntimeChecks(), optimizerCtx)
        .recordVisits(numNodes));
    stats.add(TypeTightener.exec(jprogram, optimizerCtx).recordVisits(numNodes));
    stats.add(MethodCallTightener.exec(jprogram, optimizerCtx).recordVisits(numNodes));

    stats.add(MethodCallSpecializer.exec(jprogram, optimizerCtx).recordVisits(numNodes));
    stats.add(DeadCodeElimination.exec(jprogram, optimizerCtx).recordVisits(numNodes));
    stats.add(MethodInliner.exec(jprogram, optimizerCtx).recordVisits(numNodes));
    if (options.shouldInlineLiteralParameters()) {
      stats.add(SameParameterValueOptimizer.exec(jprogram, optimizerCtx).recordVisits(numNodes));
    }
    if (options.shouldOrdinalizeEnums()) {
      stats.add(EnumOrdinalizer.exec(jprogram, optimizerCtx).recordVisits(numNodes));
    }
    optimizeEvent.end();
    return stats;
  }

  private MinimalRebuildCache getMinimalRebuildCache() {
    return compilerContext.getMinimalRebuildCache();
  }

  private static class PermutationResultImpl implements PermutationResult {

    private final ArtifactSet artifacts = new ArtifactSet();
    private final byte[][] js;
    private final String jsStrongName;
    private final Permutation permutation;
    private final byte[] serializedSymbolMap;
    private final StatementRanges[] statementRanges;

    public PermutationResultImpl(String[] jsFragments, Permutation permutation,
        SymbolData[] symbolMap, StatementRanges[] statementRanges) {
      byte[][] bytes = new byte[jsFragments.length][];
      for (int i = 0; i < jsFragments.length; ++i) {
        bytes[i] = Util.getBytes(jsFragments[i]);
      }
      this.js = bytes;
      this.jsStrongName = Util.computeStrongName(bytes);
      this.permutation = permutation;
      try {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        Util.writeObjectToStream(baos, (Object) symbolMap);
        this.serializedSymbolMap = baos.toByteArray();
      } catch (IOException e) {
        throw new RuntimeException("Should never happen with in-memory stream", e);
      }
      this.statementRanges = statementRanges;
    }

    @Override
    public void addArtifacts(Collection<? extends Artifact<?>> newArtifacts) {
      this.artifacts.addAll(newArtifacts);
    }

    @Override
    public ArtifactSet getArtifacts() {
      return artifacts;
    }

    @Override
    public byte[][] getJs() {
      return js;
    }

    @Override
    public String getJsStrongName() {
      return jsStrongName;
    }

    @Override
    public Permutation getPermutation() {
      return permutation;
    }

    @Override
    public byte[] getSerializedSymbolMap() {
      return serializedSymbolMap;
    }

    @Override
    public StatementRanges[] getStatementRanges() {
      return statementRanges;
    }
  }
}

<code block>

package com.google.gwt.dev.jjs.ast;

import com.google.gwt.dev.MinimalRebuildCache;
import com.google.gwt.dev.jjs.ast.js.JMultiExpression;
import com.google.gwt.thirdparty.guava.common.annotations.VisibleForTesting;
import com.google.gwt.thirdparty.guava.common.base.Function;
import com.google.gwt.thirdparty.guava.common.base.Objects;
import com.google.gwt.thirdparty.guava.common.base.Predicate;
import com.google.gwt.thirdparty.guava.common.base.Strings;
import com.google.gwt.thirdparty.guava.common.collect.HashMultimap;
import com.google.gwt.thirdparty.guava.common.collect.ImmutableList;
import com.google.gwt.thirdparty.guava.common.collect.ImmutableSetMultimap;
import com.google.gwt.thirdparty.guava.common.collect.Iterables;
import com.google.gwt.thirdparty.guava.common.collect.Lists;
import com.google.gwt.thirdparty.guava.common.collect.Maps;
import com.google.gwt.thirdparty.guava.common.collect.Multimap;
import com.google.gwt.thirdparty.guava.common.collect.Multimaps;
import com.google.gwt.thirdparty.guava.common.collect.Sets;

import java.io.Serializable;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;



public class JTypeOracle implements Serializable {

  public static final Function<JType,String> TYPE_TO_NAME = new Function<JType, String>() {
    @Override
    public String apply(JType type) {
      return type.getName();
    }
  };


  public static class ImmediateTypeRelations implements Serializable {


    private Map<String, String> immediateSuperclassesByClass = Maps.newHashMap();


    private Multimap<String, String> immediateSuperInterfacesByInterface = HashMultimap.create();


    private Multimap<String, String> immediateImplementedInterfacesByClass =
        HashMultimap.create();

    public void copyFrom(ImmediateTypeRelations that) {
      this.immediateImplementedInterfacesByClass.clear();
      this.immediateSuperclassesByClass.clear();
      this.immediateSuperInterfacesByInterface.clear();

      this.immediateImplementedInterfacesByClass.putAll(that.immediateImplementedInterfacesByClass);
      this.immediateSuperclassesByClass.putAll(that.immediateSuperclassesByClass);
      this.immediateSuperInterfacesByInterface.putAll(that.immediateSuperInterfacesByInterface);
    }

    @VisibleForTesting
    public boolean hasSameContent(ImmediateTypeRelations that) {
      return Objects.equal(this.immediateImplementedInterfacesByClass,
          that.immediateImplementedInterfacesByClass)
          && Objects.equal(this.immediateSuperclassesByClass, that.immediateSuperclassesByClass)
          && Objects.equal(this.immediateSuperInterfacesByInterface,
              that.immediateSuperInterfacesByInterface);
    }

    @VisibleForTesting
    public Map<String, String> getImmediateSuperclassesByClass() {
      return immediateSuperclassesByClass;
    }

    public boolean isEmpty() {
      return immediateSuperclassesByClass.isEmpty() && immediateSuperInterfacesByInterface.isEmpty()
          && immediateImplementedInterfacesByClass.isEmpty();
    }
  }


  public static class StandardTypes implements Serializable {

    public static StandardTypes createFrom(JProgram program) {
      StandardTypes requiredTypes = new StandardTypes();
      requiredTypes.javaLangObject = program.getTypeJavaLangObject().getName();
      JDeclaredType javaIoSerializableType = program.getFromTypeMap(Serializable.class.getName());
      requiredTypes.javaIoSerializable =
          javaIoSerializableType == null ? null : javaIoSerializableType.getName();
      JDeclaredType javaLangConeableType = program.getFromTypeMap(Cloneable.class.getName());
      requiredTypes.javaLangCloneable =
          javaLangConeableType == null ? null : javaLangConeableType.getName();
      return requiredTypes;
    }

    private String javaIoSerializable;

    private String javaLangCloneable;

    private String javaLangObject;
  }


  public boolean needsJsInteropBridgeMethod(JMethod x) {


    List<JParameter> xParams = x.getParams();
    if (x.isOrOverridesJsTypeMethod()) {
      for (JMethod other : x.getEnclosingType().getMethods()) {
         if (other == x) {
           continue;
         }
        if (other.isOrOverridesJsTypeMethod() && x.getName().equals(other.getName())) {
           List<JParameter> otherParams = other.getParams();
           if (otherParams.size() == xParams.size()) {
             for (int i = 0; i < otherParams.size(); i++) {
               if (otherParams.get(i).getType() != xParams.get(i).getType()) {
                 break;
               }
             }

             return true;
           } else {
             break;
           }
         }
      }
    }

    if (x.needsVtable() && x.isOrOverridesJsTypeMethod()) {
      for (JMethod override : x.getOverriddenMethods()) {
        if (!override.isOrOverridesJsTypeMethod()) {
          return true;
        }
      }
    }


    if (x.isOrOverridesJsTypeMethod() || x.isExported()) {
      if (x.getOriginalReturnType() == JPrimitiveType.LONG) {
        return true;
      }
      for (JParameter p : xParams) {
        if (p.getType() == JPrimitiveType.LONG) {
          return true;
        }
      }
    }

    return false;
  }

  public void setOptimize(boolean optimize) {
    this.optimize = optimize;
  }


  private static final class CheckClinitVisitor extends JVisitor {

    private final Set<JDeclaredType> clinitTargets = Sets.newIdentityHashSet();


    private boolean hasLiveCode = false;

    public JDeclaredType[] getClinitTargets() {
      return clinitTargets.toArray(new JDeclaredType[clinitTargets.size()]);
    }

    public boolean hasLiveCode() {
      return hasLiveCode;
    }

    @Override
    public boolean visit(JBlock x, Context ctx) {
      for (JStatement stmt : x.getStatements()) {
        if (mightContainOnlyClinitCallsOrDeclarationStatements(stmt)) {
          accept(stmt);
        } else {
          hasLiveCode = true;
        }
      }
      return false;
    }

    @Override
    public boolean visit(JDeclarationStatement x, Context ctx) {
      JVariable target = x.getVariableRef().getTarget();
      if (target instanceof JField) {
        JField field = (JField) target;

        if (field.getLiteralInitializer() != null && field.isStatic()) {



          return false;
        }
      }
      hasLiveCode = true;
      return false;
    }

    @Override
    public boolean visit(JExpressionStatement x, Context ctx) {
      JExpression expr = x.getExpr();
      if (mightContainOnlyClinitCalls(expr)) {
        accept(expr);
      } else {
        hasLiveCode = true;
      }
      return false;
    }

    @Override
    public boolean visit(JMethodCall x, Context ctx) {
      JMethod target = x.getTarget();
      if (JProgram.isClinit(target)) {
        clinitTargets.add(target.getEnclosingType());
      } else {
        hasLiveCode = true;
      }
      return false;
    }

    @Override
    public boolean visit(JMultiExpression x, Context ctx) {
      for (JExpression expr : x.getExpressions()) {

        if (mightContainOnlyClinitCalls(expr)) {
          accept(expr);
        } else {
          hasLiveCode = true;
        }
      }
      return false;
    }

    private boolean mightContainOnlyClinitCalls(JExpression expr) {

      return expr instanceof JMultiExpression || expr instanceof JMethodCall;
    }

    private boolean mightContainOnlyClinitCallsOrDeclarationStatements(JStatement stmt) {

      return stmt instanceof JBlock || stmt instanceof JExpressionStatement
          || stmt instanceof JDeclarationStatement;
    }
  }


  public static boolean methodsDoMatch(JMethod method1, JMethod method2) {

    if (method1.isStatic() || method2.isStatic()) {
      return false;
    }


    if (!method1.getName().equals(method2.getName())) {
      return false;
    }


    if (method1.getOriginalReturnType() != method2.getOriginalReturnType()) {
      return false;
    }


    List<JType> params1 = method1.getOriginalParamTypes();
    List<JType> params2 = method2.getOriginalParamTypes();
    int params1size = params1.size();
    if (params1size != params2.size()) {
      return false;
    }

    for (int i = 0; i < params1size; ++i) {
      if (params1.get(i) != params2.get(i)) {
        return false;
      }
    }
    return true;
  }


  private Set<String> allClasses = Sets.newHashSet();


  private Multimap<String, String> potentialInterfaceByClass;


  private final Set<String> dualImplInterfaces = Sets.newHashSet();


  private Multimap<String, String> implementedInterfacesByClass;


  private Set<JReferenceType> instantiatedTypes = null;


  private Multimap<String, String> classesByImplementingInterface;


  private final Map<String, String> jsoByInterface = Maps.newHashMap();


  private Map<String, JReferenceType> referenceTypesByName = Maps.newHashMap();


  private Multimap<String, String> subclassesByClass;


  private Multimap<String, String> subInterfacesByInterface;


  private Multimap<String, String> superclassesByClass;


  private Multimap<String, String> superInterfacesByInterface;


  private final Map<JClassType, Map<String, JMethod>> methodsBySignatureForType =
      Maps.newIdentityHashMap();

  private boolean optimize = true;

  private ImmediateTypeRelations immediateTypeRelations;
  private ArrayTypeCreator arrayTypeCreator;
  private StandardTypes standardTypes;


  public JTypeOracle(ArrayTypeCreator arrayTypeCreator, MinimalRebuildCache minimalRebuildCache) {
    this.immediateTypeRelations = minimalRebuildCache.getImmediateTypeRelations();
    this.arrayTypeCreator = arrayTypeCreator;


    computeExtendedTypeRelations();
  }


  public boolean canBeJavaScriptObject(JType type) {
    type = type.getUnderlyingType();
    return type.isJsoType() || isSingleJsoImpl(type);
  }


  public boolean canCrossCastLikeJso(JType type) {
    JDeclaredType dtype = getNearestJsType(type, false);
    return canBeJavaScriptObject(type) || (dtype instanceof JInterfaceType
        && isOrExtendsJsType(type, false) && !isOrExtendsJsType(type, true));
  }


  public boolean willCrossCastLikeJso(JType type) {
    return isEffectivelyJavaScriptObject(type) || canCrossCastLikeJso(type)
        && type instanceof JInterfaceType && !hasLiveImplementors(type);
  }

  public boolean hasLiveImplementors(JType type) {
    if (!optimize) {

      return true;
    }
    if (type instanceof JInterfaceType) {
      for (JReferenceType impl : getTypes(classesByImplementingInterface.get(type.getName()))) {
        if (isInstantiatedType((JClassType) impl)) {
          return true;
        }
      }
    }
    return false;
  }

  public boolean castFailsTrivially(JReferenceType fromType, JReferenceType toType) {
    if (!fromType.canBeNull() && toType.isNullType()) {

      return true;
    }

    if (!fromType.canBeSubclass() && fromType.getUnderlyingType() instanceof JClassType &&
        fromType.getUnderlyingType() != toType.getUnderlyingType() &&
        !isSuperClass(fromType, toType) && !implementsInterface(fromType, toType)) {

      return true;
    }


    fromType = fromType.getUnderlyingType();
    toType = toType.getUnderlyingType();

    if (fromType == toType || isJavaLangObject(fromType)) {
      return false;
    }


    if (canCrossCastLikeJso(fromType) && canCrossCastLikeJso(toType)) {
      return false;
    }


    if (castSucceedsTrivially(fromType, toType)) {
      return false;
    }

    if (fromType instanceof JArrayType) {

      JArrayType fromArrayType = (JArrayType) fromType;
      if (toType instanceof JArrayType) {
        JArrayType toArrayType = (JArrayType) toType;
        JType fromLeafType = fromArrayType.getLeafType();
        JType toLeafType = toArrayType.getLeafType();
        int fromDims = fromArrayType.getDims();
        int toDims = toArrayType.getDims();


        if (fromDims < toDims && !isJavaLangObject(fromLeafType)
            && !fromLeafType.isNullType()) {
          return true;
        }

        if (fromDims == toDims &&
          fromLeafType instanceof JReferenceType && toLeafType instanceof JReferenceType) {
          return castFailsTrivially((JReferenceType) fromLeafType, (JReferenceType) toLeafType);
        }
      }


    } else if (fromType instanceof JClassType) {

      JClassType cType = (JClassType) fromType;
      if (toType instanceof JClassType) {
        return !isSubClass(cType, (JClassType) toType);
      } else if (toType instanceof JInterfaceType) {
        return !potentialInterfaceByClass.containsEntry(cType.getName(), toType.getName());
      }
    } else if (fromType instanceof JInterfaceType) {

      JInterfaceType fromInterfaceType = (JInterfaceType) fromType;
      if (toType instanceof JClassType) {
        return !potentialInterfaceByClass.containsEntry(
            toType.getName(), fromInterfaceType.getName());
      }
    }

    return false;
  }

  public boolean castSucceedsTrivially(JReferenceType fromType, JReferenceType toType) {
    if (fromType.canBeNull() && !toType.canBeNull()) {

      return false;
    }

    if (fromType.isNullType()) {
      assert toType.canBeNull();

      return true;
    }

    if (toType.weakenToNullable() == fromType.weakenToNullable()) {

      return true;
    }

    if (!toType.canBeSubclass()) {
      return false;
    }


    fromType = fromType.getUnderlyingType();
    toType = toType.getUnderlyingType();

    if (fromType == toType) {
      return true;
    }

    if (isJavaLangObject(toType)) {
      return true;
    }

    if (fromType instanceof JArrayType) {
      return castSucceedsTrivially((JArrayType) fromType, toType);
    }

    if (fromType instanceof JClassType) {
      return castSucceedsTrivially((JClassType) fromType, toType);
    }

    if (fromType instanceof JInterfaceType && toType instanceof JInterfaceType) {
       return extendsInterface((JInterfaceType) fromType, (JInterfaceType) toType);
    }

    return false;
  }

  private boolean castSucceedsTrivially(JClassType fromType, JReferenceType toType) {
    if (toType instanceof JClassType) {
      return isSuperClass(fromType, toType);
    }
    if (toType instanceof JInterfaceType) {
      return implementsInterface(fromType, toType);
    }
    return false;
  }

  private boolean castSucceedsTrivially(JArrayType fromArrayType, JReferenceType toType) {



    assert !isJavaLangObject(toType);

    if (isArrayInterface(toType)) {
      return true;
    }

    if (!(toType instanceof JArrayType)) {
      return false;
    }

    JArrayType toArrayType = (JArrayType) toType;
    JType fromLeafType = fromArrayType.getLeafType();
    JType toLeafType = toArrayType.getLeafType();
    int fromDims = fromArrayType.getDims();
    int toDims = toArrayType.getDims();


    if (fromDims > toDims
        && (isJavaLangObject(toLeafType)
        || isArrayInterface(toLeafType)
        || toLeafType.isNullType())) {
      return true;
    }

    if (fromDims != toDims) {
      return false;
    }


    if (fromLeafType instanceof JReferenceType && toLeafType instanceof JReferenceType) {
      return castSucceedsTrivially((JReferenceType) fromLeafType, (JReferenceType) toLeafType);
    }

    return false;
  }

  public boolean castSucceedsTrivially(JType fromType, JType toType) {
    if (fromType instanceof JPrimitiveType && toType instanceof JPrimitiveType) {
      return fromType == toType;
    }
    if (fromType instanceof JReferenceType && toType instanceof JReferenceType) {
      return castSucceedsTrivially((JReferenceType) fromType, (JReferenceType) toType);
    }
    return false;
  }

  public void computeBeforeAST(StandardTypes standardTypes, Collection<JDeclaredType> declaredTypes,
      List<JDeclaredType> moduleDeclaredTypes) {
    computeBeforeAST(standardTypes, declaredTypes, moduleDeclaredTypes,
        ImmutableList.<String> of());
  }

  public void computeBeforeAST(StandardTypes standardTypes, Collection<JDeclaredType> declaredTypes,
      Collection<JDeclaredType> moduleDeclaredTypes, Collection<String> deletedTypeNames) {
    this.standardTypes = standardTypes;
    recordReferenceTypeByName(declaredTypes);
    deleteImmediateTypeRelations(deletedTypeNames);
    deleteImmediateTypeRelations(getNamesOf(moduleDeclaredTypes));
    recordImmediateTypeRelations(moduleDeclaredTypes);
    computeExtendedTypeRelations();
  }

  private static Collection<String> getNamesOf(Collection<JDeclaredType> types) {
    List<String> typeNames = Lists.newArrayList();
    for (JDeclaredType type : types) {
      typeNames.add(type.getName());
    }
    return typeNames;
  }

  private void recordReferenceTypeByName(Collection<JDeclaredType> types) {
    referenceTypesByName.clear();
    for (JReferenceType type : types) {
      referenceTypesByName.put(type.getName(), type);
    }
  }


  public JDeclaredType getNearestJsType(JType type, boolean mustHavePrototype) {
    type = type.getUnderlyingType();

    if (!(type instanceof JDeclaredType)) {
      return null;
    }

    JDeclaredType dtype = (JDeclaredType) type;
    if (dtype.isJsType() && (!mustHavePrototype || !Strings.isNullOrEmpty(dtype.getJsPrototype()))) {
      return dtype;
    }

    for (JInterfaceType superIntf : dtype.getImplements()) {
      JDeclaredType jsIntf = getNearestJsType(superIntf, mustHavePrototype);
      if (jsIntf != null) {
        return jsIntf;
      }
    }

    return null;
  }


  public JMethod getJsFunctionMethod(JClassType type) {
    for (JMethod method : type.getMethods()) {
      if (method.isOrOverridesJsFunctionMethod()) {
        return method;
      }
    }
    return (type.getSuperClass() != null) ? getJsFunctionMethod(type.getSuperClass()) : null;
  }

  public JMethod getInstanceMethodBySignature(JClassType type, String signature) {
    return getOrCreateInstanceMethodsBySignatureForType(type).get(signature);
  }

  public JMethod findMostSpecificOverride(JClassType type, JMethod baseMethod) {
    JMethod foundMethod = getInstanceMethodBySignature(type, baseMethod.getSignature());
    if (foundMethod == baseMethod) {
      return foundMethod;
    }



    if (foundMethod != null && foundMethod.getOverriddenMethods().contains(baseMethod)) {
      return foundMethod;
    }



    if (foundMethod != null && baseMethod.isPackagePrivate() &&
        type.getSuperClass() != null) {
      return findMostSpecificOverride(type.getSuperClass(), baseMethod);
    }

    assert baseMethod.isAbstract();
    return baseMethod;
  }

  public JClassType getSingleJsoImpl(JReferenceType maybeSingleJsoIntf) {
    String className = jsoByInterface.get(maybeSingleJsoIntf.getName());
    if (className == null) {
      return null;
    }
    return (JClassType) referenceTypesByName.get(className);
  }

  public String getSuperTypeName(String className) {
    return immediateTypeRelations.immediateSuperclassesByClass.get(className);
  }

  public Set<JReferenceType> getCastableDestinationTypes(JReferenceType type) {

    if (type instanceof JArrayType) {
      JArrayType arrayType = (JArrayType) type;
      List<JReferenceType> castableDestinationTypes = Lists.newArrayList();


      ImmutableList<JReferenceType> arrayBaseTypes = ImmutableList.of(
          ensureTypeExistsAndAppend(standardTypes.javaLangObject, castableDestinationTypes),
          ensureTypeExistsAndAppend(standardTypes.javaIoSerializable, castableDestinationTypes),
          ensureTypeExistsAndAppend(standardTypes.javaLangCloneable, castableDestinationTypes));


      for (int lowerDimension = 1; lowerDimension < arrayType.getDims(); lowerDimension++) {
        for (JReferenceType arrayBaseType : arrayBaseTypes) {
          castableDestinationTypes.add(
              arrayTypeCreator.getOrCreateArrayType(arrayBaseType, lowerDimension));
        }
      }

      if (arrayType.getLeafType() instanceof JPrimitiveType) {
        castableDestinationTypes.add(arrayType);
      } else {

        JDeclaredType leafType = (JDeclaredType) arrayType.getLeafType();
        for (JReferenceType castableDestinationType : getCastableDestinationTypes(leafType)) {
          JArrayType superArrayType =
              arrayTypeCreator.getOrCreateArrayType(castableDestinationType, arrayType.getDims());
          castableDestinationTypes.add(superArrayType);
        }
      }
      Collections.sort(castableDestinationTypes, HasName.BY_NAME_COMPARATOR);
      return Sets.newLinkedHashSet(castableDestinationTypes);
    }

    List<JReferenceType> castableDestinationTypes = Lists.newArrayList();
    if (superclassesByClass.containsKey(type.getName())) {
      Iterables.addAll(castableDestinationTypes,
          getTypes(superclassesByClass.get(type.getName())));
    }
    if (superInterfacesByInterface.containsKey(type.getName())) {
      Iterables.addAll(castableDestinationTypes,
          getTypes(superInterfacesByInterface.get(type.getName())));
    }
    if (implementedInterfacesByClass.containsKey(type.getName())) {
      Iterables.addAll(castableDestinationTypes,
          getTypes(implementedInterfacesByClass.get(type.getName())));
    }
    if (willCrossCastLikeJso(type)) {
      ensureTypeExistsAndAppend(JProgram.JAVASCRIPTOBJECT, castableDestinationTypes);
    }

    if (type.isJsoType()) {
      ensureTypeExistsAndAppend(JProgram.JAVASCRIPTOBJECT, castableDestinationTypes);
    } else {
      castableDestinationTypes.add(type);
    }



    JReferenceType javaLangObjectType = referenceTypesByName.get(standardTypes.javaLangObject);

    assert javaLangObjectType != null;
    castableDestinationTypes.add(javaLangObjectType);

    Collections.sort(castableDestinationTypes, HasName.BY_NAME_COMPARATOR);
    return Sets.newLinkedHashSet(castableDestinationTypes);
  }

  public boolean isDualJsoInterface(JType maybeDualImpl) {
    return dualImplInterfaces.contains(maybeDualImpl.getName());
  }


  public JMethod getTopMostDefinition(JMethod method) {
    if (method.getEnclosingType() instanceof JInterfaceType) {
      return null;
    }
    JMethod currentMethod = method;
    for (JMethod overriddenMethod : method.getOverriddenMethods()) {
      if (overriddenMethod.getEnclosingType() instanceof JInterfaceType) {
        continue;
      }
      if (isSuperClass(currentMethod.getEnclosingType(), overriddenMethod.getEnclosingType())) {
        currentMethod = overriddenMethod;
      }
    }
    return currentMethod;
  }


  public boolean isEffectivelyJavaScriptObject(JType type) {
    return type.isJsoType() || (isSingleJsoImpl(type) && !isDualJsoInterface(type));
  }





  private boolean isJavaScriptObject(String typeName) {
    if (typeName.equals(JProgram.JAVASCRIPTOBJECT)) {
      return true;
    }
    return isSuperClass(typeName, JProgram.JAVASCRIPTOBJECT);
  }


  public boolean isInstantiatedType(JDeclaredType type) {
    return instantiatedTypes == null || instantiatedTypes.contains(type);
  }


  public boolean isInstantiatedType(JReferenceType type) {
    type = type.getUnderlyingType();

    if (instantiatedTypes == null || instantiatedTypes.contains(type)) {
      return true;
    }

    if (type.isExternal()) {








      return true;
    }

    if (type.isNullType()) {
      return true;
    } else if (type instanceof JArrayType) {
      JArrayType arrayType = (JArrayType) type;
      if (arrayType.getLeafType().isNullType()) {
        return true;
      }
    }

    return false;
  }

  private boolean isArrayInterface(JType type) {
    return type.getName().equals(standardTypes.javaIoSerializable)
        || type.getName().equals(standardTypes.javaLangCloneable);
  }

  private boolean isJavaLangObject(JType type) {
    if (!(type instanceof JClassType)) {
      return false;
    }
    JClassType classType = (JClassType) type;


    assert classType.getSuperClass() == null ==
        classType.getName().equals(standardTypes.javaLangObject);

    return classType.getSuperClass() == null;
  }

  public boolean isSingleJsoImpl(JType type) {
    return type instanceof JReferenceType && getSingleJsoImpl((JReferenceType) type) != null;
  }


  public boolean isJsType(JType type) {
    return type instanceof JDeclaredType && ((JDeclaredType) type).isJsType();
  }


  public boolean isOrExtendsJsType(JType type, boolean mustHavePrototype) {
    return getNearestJsType(type, mustHavePrototype) != null;
  }


  public boolean isJsFunction(JType type) {
    return type instanceof JInterfaceType && ((JInterfaceType) type).isJsFunction();
  }


  public boolean isSubClass(JClassType type, JClassType possibleSubType) {
    return subclassesByClass.containsEntry(type.getName(), possibleSubType.getName());
  }

  public Set<String> getSubTypeNames(String typeName) {
    return Sets.union((Set<String>) subclassesByClass.get(typeName),
        (Set<String>) subInterfacesByInterface.get(typeName));
  }


  public boolean isSuperClass(JReferenceType type, JReferenceType possibleSuperClass) {
    return isSuperClass(type.getName(), possibleSuperClass.getName());
  }


  public void recomputeAfterOptimizations(Collection<JDeclaredType> declaredTypes) {
    Set<JDeclaredType> computed = Sets.newIdentityHashSet();
    assert optimize;



    for (JDeclaredType type : declaredTypes) {
      computeClinitTarget(type, computed);
    }

    nextDual:
    for (Iterator<String> it = dualImplInterfaces.iterator(); it.hasNext(); ) {
      String dualIntf = it.next();
      for (String implementorName : classesByImplementingInterface.get(dualIntf)) {
        JClassType implementor = (JClassType) referenceTypesByName.get(implementorName);
        assert implementor != null;
        if (isInstantiatedType(implementor) && !implementor.isJsoType()) {

          continue nextDual;
        }
      }

      it.remove();
    }


    Iterator<Entry<String, String>> jit = jsoByInterface.entrySet().iterator();
    while (jit.hasNext()) {
      Entry<String, String> jsoSingleImplEntry = jit.next();
      JClassType clazz = (JClassType) referenceTypesByName.get(jsoSingleImplEntry.getValue());
      if (isInstantiatedType(clazz)) {
        continue;
      }
      dualImplInterfaces.remove(jsoSingleImplEntry.getKey());
      jit.remove();
    }
  }

  public void setInstantiatedTypes(Set<JReferenceType> instantiatedTypes) {
    this.instantiatedTypes = instantiatedTypes;
    methodsBySignatureForType.keySet().retainAll(instantiatedTypes);
  }

  private void deleteImmediateTypeRelations(final Collection<String> typeNames) {
    Predicate<Entry<String, String>> inToDeleteSet =
        new Predicate<Entry<String, String>>() {
          @Override
          public boolean apply(Entry<String, String> typeTypeEntry) {

            return typeNames.contains(typeTypeEntry.getKey());
          }
        };

    Maps.filterEntries(immediateTypeRelations.immediateSuperclassesByClass, inToDeleteSet).clear();
    Multimaps.filterEntries(immediateTypeRelations.immediateImplementedInterfacesByClass,
        inToDeleteSet).clear();
    Multimaps.filterEntries(immediateTypeRelations.immediateSuperInterfacesByInterface,
        inToDeleteSet).clear();
  }

  private void recordImmediateTypeRelations(Iterable<JDeclaredType> types) {
    for (JReferenceType type : types) {
      if (type instanceof JClassType) {
        JClassType jClassType = (JClassType) type;

        JClassType superClass = jClassType.getSuperClass();
        if (superClass != null) {
          immediateTypeRelations.immediateSuperclassesByClass.put(jClassType.getName(),
              superClass.getName());
        }


        immediateTypeRelations.immediateImplementedInterfacesByClass
            .putAll(type.getName(), Iterables.transform(jClassType.getImplements(), TYPE_TO_NAME));
      } else if (type instanceof JInterfaceType) {

        JInterfaceType currentIntf = (JInterfaceType) type;

        immediateTypeRelations.immediateSuperInterfacesByInterface
            .putAll(type.getName(), Iterables.transform(currentIntf.getImplements(), TYPE_TO_NAME));
      }
    }
  }

  private void computeExtendedTypeRelations() {
    computeAllClasses();
    computeClassMaps();
    computeInterfaceMaps();
    computeImplementsMaps();
    computePotentialImplementMap();
    computeSingleJSO();
    computeDualJSO();
  }

  private void computeAllClasses() {
    allClasses.clear();
    allClasses.addAll(immediateTypeRelations.immediateSuperclassesByClass.values());
    allClasses.addAll(immediateTypeRelations.immediateSuperclassesByClass.keySet());
  }

  private void computePotentialImplementMap() {

    Multimap<String, String> reflexiveSubtypes = HashMultimap.create();
    reflexiveSubtypes.putAll(subclassesByClass);
    reflexiveClosure(reflexiveSubtypes, allClasses);

    potentialInterfaceByClass =
        ImmutableSetMultimap.copyOf(compose(reflexiveSubtypes, implementedInterfacesByClass));
  }

  private void computeDualJSO() {
    dualImplInterfaces.clear();

    for (String jsoIntfName : jsoByInterface.keySet()) {
      for (String implementor : classesByImplementingInterface.get(jsoIntfName)) {
        if (!isJavaScriptObject(implementor)) {





          dualImplInterfaces.add(jsoIntfName);
          break;
        }
      }
    }
  }

  private void computeImplementsMaps() {

    Multimap<String, String> superTypesByType = HashMultimap.create();
    superTypesByType.putAll(immediateTypeRelations.immediateImplementedInterfacesByClass);
    superTypesByType.putAll(Multimaps.forMap(immediateTypeRelations.immediateSuperclassesByClass));
    superTypesByType.putAll(immediateTypeRelations.immediateSuperInterfacesByInterface);

    Multimap<String, String> superTypesByTypeClosure = transitiveClosure(superTypesByType);


    implementedInterfacesByClass = ImmutableSetMultimap.copyOf(
        Multimaps.filterEntries(superTypesByTypeClosure,
            new Predicate<Entry<String, String>>() {
              @Override
              public boolean apply(Entry<String, String> typeTypeEntry) {

                return allClasses.contains(typeTypeEntry.getKey()) &&
                    !allClasses.contains(typeTypeEntry.getValue());
              }
            }));

    classesByImplementingInterface =
        ImmutableSetMultimap.copyOf(inverse(implementedInterfacesByClass));
  }

  private void computeSingleJSO() {
    jsoByInterface.clear();

    for (String jsoSubType : subclassesByClass.get(JProgram.JAVASCRIPTOBJECT)) {
      for (String intf :
          immediateTypeRelations.immediateImplementedInterfacesByClass.get(jsoSubType)) {
        jsoByInterface.put(intf, jsoSubType);
        for (String superIntf : superInterfacesByInterface.get(intf)) {
          if (!jsoByInterface.containsKey(superIntf)) {
            jsoByInterface.put(superIntf, jsoSubType);
          }
        }
      }
    }
  }

  private void computeClassMaps() {
    superclassesByClass = ImmutableSetMultimap.copyOf(
        transitiveClosure(Multimaps.forMap(immediateTypeRelations.immediateSuperclassesByClass)));
    subclassesByClass = ImmutableSetMultimap.copyOf(inverse(superclassesByClass));
  }

  private void computeInterfaceMaps() {
    superInterfacesByInterface = ImmutableSetMultimap.copyOf(
        transitiveClosure(immediateTypeRelations.immediateSuperInterfacesByInterface));
    subInterfacesByInterface  = ImmutableSetMultimap.copyOf(inverse(superInterfacesByInterface));
  }

  private void computeClinitTarget(JDeclaredType type, Set<JDeclaredType> computed) {
    if (type.isExternal() || !type.hasClinit() || computed.contains(type)) {
      return;
    }
    JClassType superClass = null;
    if (type instanceof JClassType) {
      superClass = ((JClassType) type).getSuperClass();
    }
    if (superClass != null) {

      computeClinitTarget(superClass, computed);
    }
    if (type.getClinitTarget() != type) {

      type.setClinitTarget(superClass.getClinitTarget());
    } else {

      JDeclaredType target =
          computeClinitTargetRecursive(type, computed, Sets.<JDeclaredType>newIdentityHashSet());
      type.setClinitTarget(target);
    }
    computed.add(type);
  }

  private JDeclaredType computeClinitTargetRecursive(JDeclaredType type,
      Set<JDeclaredType> computed, Set<JDeclaredType> alreadySeen) {

    alreadySeen.add(type);

    JMethod method = type.getClinitMethod();
    assert (JProgram.isClinit(method));
    CheckClinitVisitor v = new CheckClinitVisitor();
    v.accept(method);
    if (v.hasLiveCode()) {
      return type;
    }

    JDeclaredType[] clinitTargets = v.getClinitTargets();
    if (clinitTargets.length == 1) {
      JDeclaredType singleTarget = clinitTargets[0];
      if (type instanceof JClassType && singleTarget instanceof JClassType
          && isSuperClass(type, singleTarget)) {
        return singleTarget.getClinitTarget();
      }
    }
    for (JDeclaredType target : clinitTargets) {
      if (!target.hasClinit()) {

        continue;
      }


      if (target.hasClinit() && computed.contains(target)) {
        return type;
      }


      if (alreadySeen.contains(target)) {
        continue;
      }

      if (computeClinitTargetRecursive(target, computed, alreadySeen) != null) {

        return type;
      } else {

        continue;
      }
    }
    return null;
  }

  private JReferenceType ensureTypeExistsAndAppend(String typeName, List<JReferenceType> types) {
    JReferenceType type = referenceTypesByName.get(typeName);
    assert type != null;
    types.add(type);
    return type;
  }


  private boolean extendsInterface(JInterfaceType type, JInterfaceType qType) {
    return superInterfacesByInterface.containsEntry(type.getName(), qType.getName());
  }


  private Iterable<JReferenceType> getTypes(Iterable<String> typeNameSet) {
    return Iterables.transform(typeNameSet,
        new Function<String, JReferenceType>() {
          @Override
          public JReferenceType apply(String typeName) {
            JReferenceType referenceType = referenceTypesByName.get(typeName);
            assert referenceType != null;
            return referenceType;
          }
        });
  }

  private Map<String, JMethod> getOrCreateInstanceMethodsBySignatureForType(JClassType type) {
    Map<String, JMethod> methodsBySignature = methodsBySignatureForType.get(type);
    if (methodsBySignature == null) {
      methodsBySignature = Maps.newHashMap();
      JClassType superClass = type.getSuperClass();
      Map<String, JMethod> parentMethods = superClass == null
          ? Collections.<String, JMethod>emptyMap()
          : getOrCreateInstanceMethodsBySignatureForType(type.getSuperClass());


      for (JMethod method : parentMethods.values()) {
        if (method.canBePolymorphic()) {
          methodsBySignature.put(method.getSignature(), method);
        }
      }


      for (JMethod method : type.getMethods()) {
        if (!method.isStatic()) {
          methodsBySignature.put(method.getSignature(), method);
        }
      }

      methodsBySignatureForType.put(type, methodsBySignature);
    }
    return methodsBySignature;
  }


  private void reflexiveClosure(Multimap<String, String> relation, Iterable<String> domain) {
    for (String element : domain) {
      relation.put(element, element);
    }
  }


  private Multimap<String, String> transitiveClosure(Multimap<String, String> relation) {
    Multimap<String, String> transitiveClosure = HashMultimap.create();
    Set<String> domain = Sets.newHashSet(relation.keySet());
    domain.addAll(relation.values());
    for (String element : domain) {
      expandTransitiveClosureForElement(relation, element, transitiveClosure);
    }
    return transitiveClosure;
  }


  private Collection<String> expandTransitiveClosureForElement(Multimap<String, String> relation,
      String element, Multimap<String, String> transitiveClosure) {



    Collection<String> preComputedExpansion = transitiveClosure.get(element);

    if (!preComputedExpansion.isEmpty()) {

      return preComputedExpansion;
    }

    Set<String> transitiveExpansion = Sets.newHashSet();
    Collection<String> immediateSuccessors = relation.get(element);
    transitiveExpansion.addAll(immediateSuccessors);

    for (String child : immediateSuccessors) {
      transitiveExpansion.addAll(expandTransitiveClosureForElement(relation, child,
          transitiveClosure));
    }
    transitiveClosure.putAll(element, transitiveExpansion);
    return transitiveExpansion;
  }


  private <A, B, C> Multimap<A, C> compose(Multimap<A, B> f, Multimap<B, C> g) {
    Multimap<A, C> composition = HashMultimap.create();
    for (A a : f.keySet()) {
      for (B b : f.get(a)) {
        composition.putAll(a, g.get(b));
      }
    }
    return composition;
  }


  private <K, V> Multimap<V, K> inverse(Multimap<K, V> relation) {
    Multimap<V, K> inverse = HashMultimap.create();
    Multimaps.invertFrom(relation, inverse);
    return inverse;
  }


  private boolean implementsInterface(JReferenceType type, JReferenceType interfaceType) {
    return implementedInterfacesByClass.containsEntry(type.getName(), interfaceType.getName());
  }

  private boolean isSuperClass(String type, String potentialSuperClass) {
    return subclassesByClass.containsEntry(potentialSuperClass, type);
  }
}

<code block>

package com.google.gwt.dev.jjs.impl;

import com.google.gwt.dev.jjs.ast.Context;
import com.google.gwt.dev.jjs.ast.JAbsentArrayDimension;
import com.google.gwt.dev.jjs.ast.JArrayLength;
import com.google.gwt.dev.jjs.ast.JArrayRef;
import com.google.gwt.dev.jjs.ast.JArrayType;
import com.google.gwt.dev.jjs.ast.JBinaryOperation;
import com.google.gwt.dev.jjs.ast.JBinaryOperator;
import com.google.gwt.dev.jjs.ast.JCastOperation;
import com.google.gwt.dev.jjs.ast.JClassLiteral;
import com.google.gwt.dev.jjs.ast.JClassType;
import com.google.gwt.dev.jjs.ast.JConstructor;
import com.google.gwt.dev.jjs.ast.JDeclarationStatement;
import com.google.gwt.dev.jjs.ast.JDeclaredType;
import com.google.gwt.dev.jjs.ast.JExpression;
import com.google.gwt.dev.jjs.ast.JField;
import com.google.gwt.dev.jjs.ast.JFieldRef;
import com.google.gwt.dev.jjs.ast.JInstanceOf;
import com.google.gwt.dev.jjs.ast.JInterfaceType;
import com.google.gwt.dev.jjs.ast.JLocal;
import com.google.gwt.dev.jjs.ast.JLocalRef;
import com.google.gwt.dev.jjs.ast.JMethod;
import com.google.gwt.dev.jjs.ast.JMethodCall;
import com.google.gwt.dev.jjs.ast.JNewArray;
import com.google.gwt.dev.jjs.ast.JNewInstance;
import com.google.gwt.dev.jjs.ast.JNode;
import com.google.gwt.dev.jjs.ast.JParameter;
import com.google.gwt.dev.jjs.ast.JParameterRef;
import com.google.gwt.dev.jjs.ast.JPrimitiveType;
import com.google.gwt.dev.jjs.ast.JProgram;
import com.google.gwt.dev.jjs.ast.JReferenceType;
import com.google.gwt.dev.jjs.ast.JRunAsync;
import com.google.gwt.dev.jjs.ast.JStringLiteral;
import com.google.gwt.dev.jjs.ast.JType;
import com.google.gwt.dev.jjs.ast.JVariable;
import com.google.gwt.dev.jjs.ast.JVariableRef;
import com.google.gwt.dev.jjs.ast.JVisitor;
import com.google.gwt.dev.jjs.ast.js.JsniFieldRef;
import com.google.gwt.dev.jjs.ast.js.JsniMethodBody;
import com.google.gwt.dev.jjs.ast.js.JsniMethodRef;
import com.google.gwt.dev.js.ast.JsContext;
import com.google.gwt.dev.js.ast.JsFunction;
import com.google.gwt.dev.js.ast.JsName;
import com.google.gwt.dev.js.ast.JsNameRef;
import com.google.gwt.dev.js.ast.JsVisitor;
import com.google.gwt.thirdparty.guava.common.collect.ArrayListMultimap;
import com.google.gwt.thirdparty.guava.common.collect.ListMultimap;
import com.google.gwt.thirdparty.guava.common.collect.Lists;
import com.google.gwt.thirdparty.guava.common.collect.Sets;

import java.util.List;
import java.util.Set;


public class ControlFlowAnalyzer {


  public interface DependencyRecorder {

    void methodIsLiveBecause(JMethod liveMethod, List<JMethod> dependencyChain);
  }


  private class RescueVisitor extends JVisitor {
    private final List<JMethod> curMethodStack = Lists.newArrayList();

    @Override
    public boolean visit(JArrayRef arrayRef, Context ctx) {
      maybeRescueJsTypeArray(arrayRef.getInstance().getType());
      return true;
    }

    @Override
    public boolean visit(JArrayLength arrayLength, Context ctx) {
      maybeRescueJsTypeArray(arrayLength.getInstance().getType());
      return true;
    }

    @Override
    public boolean visit(JArrayType type, Context ctx) {
      assert (referencedTypes.contains(type));
      boolean isInstantiated = instantiatedTypes.contains(type);

      JType leafType = type.getLeafType();
      int dims = type.getDims();


      boolean didSuperType = false;
      if (leafType instanceof JClassType) {
        JClassType superClass = ((JClassType) leafType).getSuperClass();
        if (superClass != null) {

          rescue(program.getOrCreateArrayType(superClass, dims), isInstantiated);
          didSuperType = true;
        }
      } else if (leafType instanceof JInterfaceType) {

        rescue(program.getOrCreateArrayType(program.getTypeJavaLangObject(), dims),
            isInstantiated);
        didSuperType = true;
      }
      if (!didSuperType) {
        if (dims > 1) {

          rescue(program.getOrCreateArrayType(program.getTypeJavaLangObject(), dims - 1),
              isInstantiated);
        } else {

          rescue(program.getTypeJavaLangObject(), isInstantiated);
        }
      }


      if (leafType instanceof JDeclaredType) {
        JDeclaredType dLeafType = (JDeclaredType) leafType;
        for (JInterfaceType intfType : dLeafType.getImplements()) {
          JArrayType intfArray = program.getOrCreateArrayType(intfType, dims);
          rescue(intfArray, isInstantiated);
        }
      }

      return false;
    }

    @Override
    public boolean visit(JBinaryOperation x, Context ctx) {
      if (x.isAssignment() && x.getLhs() instanceof JFieldRef) {
        fieldsWritten.add(((JFieldRef) x.getLhs()).getField());
      }


      if ((x.getOp() == JBinaryOperator.CONCAT || x.getOp() == JBinaryOperator.ASG_CONCAT)) {
        rescueByConcat(x.getLhs().getType());
        rescueByConcat(x.getRhs().getType());
      } else if (x.getOp() == JBinaryOperator.ASG) {

        boolean doSkip = false;
        JExpression lhs = x.getLhs();
        if (lhs.hasSideEffects() || isVolatileField(lhs)) {

        } else if (lhs instanceof JLocalRef) {

          doSkip = true;
        } else if (lhs instanceof JParameterRef) {

          doSkip = true;
        } else if (lhs instanceof JFieldRef) {

          doSkip = true;
          JFieldRef fieldRef = (JFieldRef) lhs;
          JExpression instance = fieldRef.getInstance();
          if (instance != null) {
            accept(instance);
          }
        }

        if (doSkip) {
          accept(x.getRhs());
          return false;
        }
      }
      return true;
    }

    @Override
    public boolean visit(JCastOperation x, Context ctx) {

      JType targetType = x.getCastType();
      if (!canBeInstantiatedInJavaScript(targetType)) {
        return true;
      }
      rescue((JReferenceType) targetType, true);
      JType exprType = x.getExpr().getType();
      if (program.typeOracle.isSingleJsoImpl(targetType)) {

        if (program.getTypeJavaLangObject() == exprType
            || program.typeOracle.canBeJavaScriptObject(exprType)) {

          JClassType jsoImplementor =
              program.typeOracle.getSingleJsoImpl((JReferenceType) targetType);
          rescue(jsoImplementor, true);
        }
      }

      return true;
    }

    @Override
    public boolean visit(JClassLiteral x, Context ctx) {
      JField field = x.getField();
      assert field != null;
      rescue(field);
      return true;
    }

    @Override
    public boolean visit(JClassType type, Context ctx) {
      assert (referencedTypes.contains(type));
      boolean isInstantiated = instantiatedTypes.contains(type);


      rescue(type.getSuperClass(), isInstantiated);


      if (type.hasClinit()) {
        rescue(type.getClinitMethod());
      }


      if (isInstantiated) {
        rescueMembersAndInstantiateSuperInterfaces(type);
      }

      return false;
    }

    @Override
    public boolean visit(JDeclarationStatement x, Context ctx) {

      if (x.getInitializer() != null &&
          !isStaticFieldInitializedToLiteral(x.getVariableRef().getTarget())) {

        accept(x.getInitializer());

        if (x.getVariableRef().getTarget() instanceof JField) {
          fieldsWritten.add((JField) x.getVariableRef().getTarget());
        }
      }


      JVariableRef variableRef = x.getVariableRef();
      if (variableRef instanceof JFieldRef) {
        JFieldRef fieldRef = (JFieldRef) variableRef;
        JExpression instance = fieldRef.getInstance();
        if (instance != null) {
          accept(instance);
        }
      }
      return false;
    }

    @Override
    public boolean visit(JFieldRef ref, Context ctx) {
      JField target = ref.getField();


      if (target.isStatic()) {
        rescue(target.getEnclosingType(), false);
      }
      if (target.isStatic() || instantiatedTypes.contains(target.getEnclosingType())) {
        rescue(target);
      } else {

        if (!liveFieldsAndMethods.contains(target)) {
          membersToRescueIfTypeIsInstantiated.add(target);
        }
      }
      return true;
    }

    @Override
    public boolean visit(JInstanceOf x, Context ctx) {
      JReferenceType targetType = x.getTestType();
      if (program.typeOracle.isJsType(targetType) || program.typeOracle.isJsFunction(targetType)) {

        rescue(targetType, true);
      }
      return true;
    }

    @Override
    public boolean visit(JInterfaceType type, Context ctx) {
      boolean isReferenced = referencedTypes.contains(type);
      boolean isInstantiated = instantiatedTypes.contains(type);
      assert (isReferenced || isInstantiated);


      if (type.hasClinit()) {
        rescue(type.getClinitMethod());
      }


      if (isInstantiated) {
        rescueMembersAndInstantiateSuperInterfaces(type);
      }

      return false;
    }

    @Override
    public boolean visit(JLocalRef ref, Context ctx) {
      JLocal target = ref.getLocal();
      rescue(target);
      return true;
    }

    @Override
    public boolean visit(final JMethod x, Context ctx) {
      JReferenceType enclosingType = x.getEnclosingType();
      if (enclosingType.isJsoType()) {

        boolean instance = !x.isStatic() || program.isStaticImpl(x);
        rescue(enclosingType, instance);
      } else if (x.isStatic()) {

        rescue(enclosingType, false);
      }

      if (x.isNative()) {

        final JsniMethodBody body = (JsniMethodBody) x.getBody();
        final JsFunction func = body.getFunc();

        new JsVisitor() {
          @Override
          public void endVisit(JsNameRef nameRef, JsContext ctx) {
            JsName ident = nameRef.getName();

            if (ident != null) {


              int index = func.getParameters().indexOf(ident.getStaticRef());
              if (index != -1) {
                rescue(x.getParams().get(index));
              }
            }
          }
        }.accept(func);
      }

      return true;
    }

    @Override
    public boolean visit(JMethodCall call, Context ctx) {
      JMethod method = call.getTarget();
      if (call.isVolatile() && method == runAsyncOnsuccess) {

        return true;
      }
      if (method.isStatic() || isTypeInstantiatedOrJso(method.getEnclosingType())) {
        rescue(method);
      } else {

        if (!liveFieldsAndMethods.contains(method)) {
          membersToRescueIfTypeIsInstantiated.add(method);
        }
      }

      if (argsToRescueIfParameterRead == null || method.canBePolymorphic()
          || call instanceof JsniMethodRef) {
        return true;
      }

      if (program.instanceMethodForStaticImpl(method) != null) {

        return true;
      }

      if (call.getInstance() != null) {

        this.accept(call.getInstance());
      }

      rescueArgumentsIfParametersCanBeRead(call);

      return false;
    }

    @Override
    public boolean visit(JNewArray newArray, Context ctx) {

      JArrayType arrayType = newArray.getArrayType();
      if (newArray.dims != null) {

        int nDims = arrayType.getDims();
        JType leafType = arrayType.getLeafType();
        assert (newArray.dims.size() == nDims);
        for (int i = 0; i < nDims; ++i) {
          if (newArray.dims.get(i) instanceof JAbsentArrayDimension) {
            break;
          }
          rescue(program.getOrCreateArrayType(leafType, nDims - i), true);
        }
      } else {

        rescue(arrayType, true);
      }
      return true;
    }

    @Override
    public boolean visit(JNewInstance x, Context ctx) {

      rescue(x.getClassType(), true);
      return super.visit(x, ctx);
    }

    @Override
    public boolean visit(JParameterRef x, Context ctx) {

      rescue(x.getParameter());
      return true;
    }

    @Override
    public boolean visit(JsniFieldRef x, Context ctx) {

      if (x.isLvalue()) {
        maybeRescueJavaScriptObjectPassingIntoJava(x.getField().getType());
      }

      return visit((JFieldRef) x, ctx);
    }

    @Override
    public boolean visit(JsniMethodBody body, Context ctx) {
      liveStrings.addAll(body.getUsedStrings());
      return true;
    }

    @Override
    public boolean visit(JsniMethodRef x, Context ctx) {

      for (JParameter param : x.getTarget().getParams()) {
        maybeRescueJavaScriptObjectPassingIntoJava(param.getType());


        rescue(param);
      }

      if (x.getTarget() instanceof JConstructor) {

        JConstructor ctor = (JConstructor) x.getTarget();
        rescue(ctor.getEnclosingType(), true);
      }
      return visit((JMethodCall) x, ctx);
    }

    @Override
    public boolean visit(JStringLiteral literal, Context ctx) {
      liveStrings.add(literal.getValue());


      rescue(program.getTypeJavaLangString(), true);
      return true;
    }

    private boolean canBeInstantiatedInJavaScript(JType type) {


      if (program.typeOracle.canBeJavaScriptObject(type) || program.isJavaLangString(type)) {
        return true;
      }


      if (type instanceof JArrayType) {
        return true;
      }

      return false;
    }

    private JMethod getStringValueOfCharMethod() {
      JPrimitiveType charType = program.getTypePrimitiveChar();
      JClassType stringType = program.getTypeJavaLangString();
      if (stringValueOfChar != null) {
        return stringValueOfChar;
      }

      for (JMethod method : stringType.getMethods()) {
        if (method.getName().equals("valueOf") &&
            method.getOriginalParamTypes().size() == 1 &&
            method.getOriginalParamTypes().get(0) == charType) {
          stringValueOfChar = method;
          return stringValueOfChar;
        }
      }
      assert false;
      return null;
    }

    private boolean isStaticFieldInitializedToLiteral(JVariable var) {
      if (!(var instanceof JField)) {
        return false;
      }

      JField field = (JField) var;
      return field.isStatic() && field.getLiteralInitializer() != null;
    }

    private boolean isVolatileField(JExpression x) {
      if (!(x instanceof JFieldRef)) {
        return false;
      }

      JFieldRef xFieldRef = (JFieldRef) x;
      return xFieldRef.getField().isVolatile();
    }

    private void maybeRescueClassLiteral(JReferenceType type) {
      if (liveFieldsAndMethods.contains(getClassMethod) ||
          liveFieldsAndMethods.contains(getClassField)) {

        rescue(program.getClassLiteralField(type));
      } else {

        classLiteralsToBeRescuedIfGetClassIsLive.add(type);
      }
    }


    private void maybeRescueJavaScriptObjectPassingIntoJava(JType type) {
      if (!canBeInstantiatedInJavaScript(type)) {
        return;
      }
      rescue((JReferenceType) type, true);
      if (program.typeOracle.isSingleJsoImpl(type)) {

        JClassType singleJsoImpl = program.typeOracle.getSingleJsoImpl((JReferenceType) type);
        rescue(singleJsoImpl, true);
      }
    }

    private void rescue(JMethod method) {
      if (method == null) {
        return;
      }

      if (liveFieldsAndMethods.add(method)) {
        JDeclaredType enclosingType = method.getEnclosingType();






        if (enclosingType instanceof JInterfaceType
            && (method.isJsTypeMember() || method.isJsFunctionMethod())) {
          rescue(enclosingType, true);
        }

        membersToRescueIfTypeIsInstantiated.remove(method);
        if (dependencyRecorder != null) {
          curMethodStack.add(method);
          dependencyRecorder.methodIsLiveBecause(method, curMethodStack);
        }
        accept(method);
        if (dependencyRecorder != null) {
          curMethodStack.remove(curMethodStack.size() - 1);
        }
        if (method.isNative()) {

          maybeRescueJavaScriptObjectPassingIntoJava(method.getType());
        }
        if (method.isExported() || method.isJsTypeMember() || method.isJsFunctionMethod()) {
          for (JParameter param : method.getParams()) {


            rescue(param);
          }
        }
        rescueOverridingMethods(method);
        if (method == getClassMethod) {
          rescueClassLiteralsIfGetClassIsLive();
        }
        if (program.isJsTypePrototype(enclosingType)) {


          for (JParameter param : method.getParams()) {
            rescue(param);
          }
        }
        if (method.getSpecialization() != null) {
          rescue(method.getSpecialization().getTargetMethod());
        }
      }
    }

    private void maybeRescueJsTypeArray(JType type) {
      if (!(type instanceof JArrayType)) {
        return;
      }
      JArrayType arrayType = (JArrayType) type;
      if (program.typeOracle.isJsType(arrayType.getLeafType()) ||
          program.typeOracle.isJsFunction(arrayType.getLeafType())) {
        rescue(arrayType, true);
        maybeRescueJsTypeArray(arrayType.getElementType());
      }
    }

    private void rescue(JReferenceType type, boolean isInstantiated) {
      if (type == null) {
        return;
      }


      type = type.getUnderlyingType();

      boolean doVisit = false;
      if (isInstantiated && instantiatedTypes.add(type)) {
        maybeRescueClassLiteral(type);
        doVisit = true;
      }

      if (referencedTypes.add(type)) {
        doVisit = true;
      }

      if (!doVisit) {
        return;
      }

      accept(type);

      if (!program.typeOracle.isJsType(type) && !program.typeOracle.isJsFunction(type)) {
        return;
      }


      JDeclaredType declaredType = (JDeclaredType) type;

      for (JMethod method : declaredType.getMethods()) {
        if (method.isJsTypeMember() || method.isJsFunctionMethod()) {
          rescue(method);
        }
      }
      for (JField field : declaredType.getFields()) {
        if (field.isJsTypeMember()) {
          rescue(field);
        }
      }
    }

    private void rescue(JVariable var) {
      if (var == null) {
        return;
      }
      if (!liveFieldsAndMethods.add(var)) {

        return;
      }
      membersToRescueIfTypeIsInstantiated.remove(var);
      if (var == getClassField) {
        rescueClassLiteralsIfGetClassIsLive();
      }

      if (isStaticFieldInitializedToLiteral(var)) {

        accept(((JField) var).getLiteralInitializer());
      } else if (var instanceof JField
          && (program.getTypeClassLiteralHolder().equals(((JField) var).getEnclosingType()))) {

        JField field = (JField) var;
        accept(field.getInitializer());
        referencedTypes.add(field.getEnclosingType());
        liveFieldsAndMethods.add(field.getEnclosingType().getClinitMethod());
      } else if (argsToRescueIfParameterRead != null && var instanceof JParameter) {
        List<JExpression> list = argsToRescueIfParameterRead.removeAll(var);
        for (JExpression arg : list) {
          this.accept(arg);
        }
      }
    }


    private void rescueArgumentsIfParametersCanBeRead(JMethodCall call) {
      JMethod method = call.getTarget();
      assert !method.canBePolymorphic();

      List<JExpression> args = call.getArgs();
      List<JParameter> params = method.getParams();
      int i = 0;
      for (int c = params.size(); i < c; ++i) {
        JExpression arg = args.get(i);
        JParameter param = params.get(i);
        if (arg.hasSideEffects() || liveFieldsAndMethods.contains(param)

            || program.isJsTypePrototype(method.getEnclosingType())) {
          this.accept(arg);
          continue;
        }
        argsToRescueIfParameterRead.put(param, arg);
      }

      for (int c = args.size(); i < c; ++i) {
        this.accept(args.get(i));
      }
    }


    private void rescueByConcat(JType type) {
      JPrimitiveType charType = program.getTypePrimitiveChar();
      JClassType stringType = program.getTypeJavaLangString();
      if (type instanceof JReferenceType
          && !program.typeOracle.castSucceedsTrivially((JReferenceType) type, stringType)
          && !type.isNullType()) {

        JMethod toStringMethod = program.getIndexedMethod("Object.toString");
        rescue(toStringMethod);
      } else if (type == charType) {

        rescue(getStringValueOfCharMethod());
      }
    }

    private void rescueClassLiteralsIfGetClassIsLive() {
      if (classLiteralsToBeRescuedIfGetClassIsLive != null) {

        Set<JReferenceType> toRescue = classLiteralsToBeRescuedIfGetClassIsLive;
        classLiteralsToBeRescuedIfGetClassIsLive = null;

        for (JReferenceType classLit : toRescue) {
          maybeRescueClassLiteral(classLit);
        }
      }
    }

    private void rescueMembersAndInstantiateSuperInterfaces(JDeclaredType type) {
      for (JInterfaceType intfType : type.getImplements()) {
        rescue(intfType, true);
      }
      rescueMembers(type);
    }


    private void rescueMembers(JDeclaredType type) {
      assert instantiatedTypes.contains(type);

      for (JMethod method : type.getMethods()) {
        if (!method.isStatic() && membersToRescueIfTypeIsInstantiated.contains(method)) {
          rescue(method);
        }
      }
      for (JField field : type.getFields()) {
        if (!field.isStatic() && membersToRescueIfTypeIsInstantiated.contains(field)) {
            rescue(field);
        }
      }
    }


    private void rescueOverridingMethods(JMethod method) {
      if (method.isStatic()) {
        return;
      }

      for (JMethod overridingMethod : method.getOverridingMethods()) {
        if (liveFieldsAndMethods.contains(overridingMethod)) {

        } else if (instantiatedTypes.contains(overridingMethod.getEnclosingType())) {

          rescue(overridingMethod);
        } else {

          membersToRescueIfTypeIsInstantiated.add(overridingMethod);
        }
      }
    }
  }

  private boolean isTypeInstantiatedOrJso(JDeclaredType type) {
    if (type == null) {
      return false;
    }

    return type.isJsoType() || type.isJsFunction() || type.isJsType()
        || instantiatedTypes.contains(type);
  }


  private ListMultimap<JParameter, JExpression> argsToRescueIfParameterRead;

  private final JMethod asyncFragmentOnLoad;


  private Set<JReferenceType> classLiteralsToBeRescuedIfGetClassIsLive = Sets.newHashSet();

  private DependencyRecorder dependencyRecorder;
  private Set<JField> fieldsWritten = Sets.newHashSet();
  private Set<JReferenceType> instantiatedTypes = Sets.newHashSet();
  private Set<JNode> liveFieldsAndMethods = Sets.newHashSet();
  private Set<String> liveStrings = Sets.newHashSet();


  private Set<JNode> membersToRescueIfTypeIsInstantiated = Sets.newHashSet();

  private final JField getClassField;
  private final JMethod getClassMethod;
  private final JProgram program;
  private Set<JReferenceType> referencedTypes = Sets.newHashSet();
  private final RescueVisitor rescuer;
  private final JMethod runAsyncOnsuccess;
  private JMethod stringValueOfChar = null;

  public ControlFlowAnalyzer(ControlFlowAnalyzer cfa) {
    program = cfa.program;
    asyncFragmentOnLoad = cfa.asyncFragmentOnLoad;
    runAsyncOnsuccess = cfa.runAsyncOnsuccess;
    fieldsWritten = Sets.newHashSet(cfa.fieldsWritten);
    instantiatedTypes = Sets.newHashSet(cfa.instantiatedTypes);
    liveFieldsAndMethods = Sets.newHashSet(cfa.liveFieldsAndMethods);
    referencedTypes = Sets.newHashSet(cfa.referencedTypes);
    stringValueOfChar = cfa.stringValueOfChar;
    liveStrings = Sets.newHashSet(cfa.liveStrings);
    membersToRescueIfTypeIsInstantiated =
        Sets.newHashSet(cfa.membersToRescueIfTypeIsInstantiated);
    if (cfa.argsToRescueIfParameterRead != null) {
      argsToRescueIfParameterRead =
          ArrayListMultimap.create(cfa.argsToRescueIfParameterRead);
    }
    getClassField = program.getIndexedField("Object.___clazz");
    getClassMethod = program.getIndexedMethod("Object.getClass");
    rescuer = new RescueVisitor();
  }

  public ControlFlowAnalyzer(JProgram program) {
    this.program = program;
    asyncFragmentOnLoad = program.getIndexedMethod("AsyncFragmentLoader.onLoad");
    runAsyncOnsuccess = program.getIndexedMethod("RunAsyncCallback.onSuccess");
    getClassField = program.getIndexedField("Object.___clazz");
    getClassMethod = program.getIndexedMethod("Object.getClass");
    rescuer = new RescueVisitor();
  }


  public Set<JField> getFieldsWritten() {
    return fieldsWritten;
  }


  public Set<JReferenceType> getInstantiatedTypes() {
    return instantiatedTypes;
  }


  public Set<? extends JNode> getLiveFieldsAndMethods() {
    return liveFieldsAndMethods;
  }

  public Set<String> getLiveStrings() {
    return liveStrings;
  }


  public Set<? extends JReferenceType> getReferencedTypes() {
    return referencedTypes;
  }


  public void setDependencyRecorder(DependencyRecorder dr) {
    if (dependencyRecorder != null && dr != null) {
      throw new IllegalArgumentException("Attempting to set multiple dependency recorders");
    }
    this.dependencyRecorder = dr;
  }

  public void setForPruning() {
    assert argsToRescueIfParameterRead == null;
    argsToRescueIfParameterRead = ArrayListMultimap.create();
  }


  public void traverseEntryMethods() {
    for (JMethod method : program.getEntryMethods()) {
      traverseFrom(method);
    }


    List<JDeclaredType> declaredTypes = program.getDeclaredTypes();
    for (JDeclaredType type : declaredTypes) {

      for (JMethod method : type.getMethods()) {
        if (method.isExported()) {

          rescuer.rescue(method.getEnclosingType(), true);
          traverseFrom(method);
        }
      }
      for (JField field : type.getFields()) {
        if (field.isExported()) {
          rescuer.rescue(field.getEnclosingType(), true);
          rescuer.rescue(field);
        }
      }
    }

    if (program.getRunAsyncs().size() > 0) {

      traverseFrom(asyncFragmentOnLoad);
    }
  }

  public void traverseEverything() {
    traverseEntryMethods();
    traverseFromRunAsyncs();

    liveFieldsAndMethods.add(runAsyncOnsuccess);
  }


  public void traverseFrom(JMethod method) {
    rescuer.rescue(method);
  }


  public void traverseFromInstantiationOf(JDeclaredType type) {
    rescuer.rescue(type, true);
  }

  public void traverseFromReferenceTo(JDeclaredType type) {
    rescuer.rescue(type, false);
  }


  public void traverseFromRunAsync(JRunAsync runAsync) {
    runAsync.traverseOnSuccess(rescuer);
  }


  public void traverseFromRunAsyncs() {
    for (JRunAsync runAsync : program.getRunAsyncs()) {
      traverseFromRunAsync(runAsync);
    }
  }
}

<code block>

package com.google.gwt.dev.jjs.impl;

import com.google.gwt.dev.jjs.InternalCompilerException;
import com.google.gwt.dev.jjs.SourceInfo;
import com.google.gwt.dev.jjs.ast.CanBeStatic;
import com.google.gwt.dev.jjs.ast.Context;
import com.google.gwt.dev.jjs.ast.HasEnclosingType;
import com.google.gwt.dev.jjs.ast.HasName;
import com.google.gwt.dev.jjs.ast.JArrayType;
import com.google.gwt.dev.jjs.ast.JBinaryOperation;
import com.google.gwt.dev.jjs.ast.JBinaryOperator;
import com.google.gwt.dev.jjs.ast.JClassType;
import com.google.gwt.dev.jjs.ast.JConstructor;
import com.google.gwt.dev.jjs.ast.JDeclarationStatement;
import com.google.gwt.dev.jjs.ast.JDeclaredType;
import com.google.gwt.dev.jjs.ast.JExpression;
import com.google.gwt.dev.jjs.ast.JField;
import com.google.gwt.dev.jjs.ast.JFieldRef;
import com.google.gwt.dev.jjs.ast.JLocal;
import com.google.gwt.dev.jjs.ast.JLocalRef;
import com.google.gwt.dev.jjs.ast.JMethod;
import com.google.gwt.dev.jjs.ast.JMethodBody;
import com.google.gwt.dev.jjs.ast.JMethodCall;
import com.google.gwt.dev.jjs.ast.JNameOf;
import com.google.gwt.dev.jjs.ast.JNewInstance;
import com.google.gwt.dev.jjs.ast.JNode;
import com.google.gwt.dev.jjs.ast.JParameter;
import com.google.gwt.dev.jjs.ast.JPrimitiveType;
import com.google.gwt.dev.jjs.ast.JProgram;
import com.google.gwt.dev.jjs.ast.JReferenceType;
import com.google.gwt.dev.jjs.ast.JRuntimeTypeReference;
import com.google.gwt.dev.jjs.ast.JType;
import com.google.gwt.dev.jjs.ast.JVariable;
import com.google.gwt.dev.jjs.ast.JVariableRef;
import com.google.gwt.dev.jjs.ast.js.JMultiExpression;
import com.google.gwt.dev.jjs.ast.js.JsniFieldRef;
import com.google.gwt.dev.jjs.ast.js.JsniMethodRef;
import com.google.gwt.dev.util.collect.Stack;
import com.google.gwt.dev.util.log.speedtracer.CompilerEventType;
import com.google.gwt.dev.util.log.speedtracer.SpeedTracerLogger;
import com.google.gwt.dev.util.log.speedtracer.SpeedTracerLogger.Event;
import com.google.gwt.thirdparty.guava.common.base.Predicate;
import com.google.gwt.thirdparty.guava.common.base.Predicates;
import com.google.gwt.thirdparty.guava.common.collect.ArrayListMultimap;
import com.google.gwt.thirdparty.guava.common.collect.Iterables;
import com.google.gwt.thirdparty.guava.common.collect.ListMultimap;
import com.google.gwt.thirdparty.guava.common.collect.Sets;

import java.util.Iterator;
import java.util.List;
import java.util.Set;


public class Pruner {

  private class CleanupRefsVisitor extends JModVisitorWithTemporaryVariableCreation {
    private final Stack<JExpression> lValues = new Stack<JExpression>();
    private final ListMultimap<JMethod, JParameter> priorParametersByMethod;
    private final Set<? extends JNode> referencedNonTypes;
    {

      lValues.push(null);
    }

    public CleanupRefsVisitor(Set<? extends JNode> referencedNodes,
        ListMultimap<JMethod, JParameter> priorParametersByMethod,
        OptimizerContext optimizerCtx) {
      super(optimizerCtx);
      this.referencedNonTypes = referencedNodes;
      this.priorParametersByMethod = priorParametersByMethod;
    }

    @Override
    public void endVisit(JBinaryOperation x, Context ctx) {
      if (x.getOp() != JBinaryOperator.ASG) {
        return;
      }

      lValues.pop();
      JExpression lhs = x.getLhs();
      if (!(lhs instanceof JVariableRef)) {
        return;
      }

      JVariableRef variableRef = (JVariableRef) lhs;
      if (isVariablePruned(variableRef.getTarget())) {

        JExpression replacement =
            makeReplacementForAssignment(x.getSourceInfo(), variableRef, x.getRhs());
        ctx.replaceMe(replacement);
      }
    }

    @Override
    public void endVisit(JDeclarationStatement x, Context ctx) {
      super.endVisit(x, ctx);
      lValues.pop();

      if (isVariablePruned(x.getVariableRef().getTarget())) {
        JExpression replacement =
            makeReplacementForAssignment(x.getSourceInfo(), x.getVariableRef(), x.getInitializer());
        ctx.replaceMe(replacement.makeStatement());
      }
    }

    @Override
    public void endVisit(JFieldRef x, Context ctx) {

      if (lValues.peek() == x) {
        return;
      }

      if (isPruned(x.getField())) {

        JFieldRef fieldRef = transformToNullFieldRef(x, program);
        ctx.replaceMe(fieldRef);
      }
    }

    @Override
    public void exit(JMethod x, Context ctx) {
      JType type = x.getType();
      if (type instanceof JReferenceType &&
          !program.typeOracle.isInstantiatedType((JReferenceType) type)) {
        x.setType(JReferenceType.NULL_TYPE);
      }
      Predicate<JMethod> isPruned = new Predicate<JMethod>() {
        @Override
        public boolean apply(JMethod method) {
          return isPruned(method);
        }
      };
      Iterables.removeIf(x.getOverriddenMethods(), isPruned);
      Iterables.removeIf(x.getOverridingMethods(), isPruned);
    }

    @Override
    public void endVisit(JMethodCall x, Context ctx) {
      JMethod method = x.getTarget();


      if (isPruned(method)) {

        ctx.replaceMe(transformToNullMethodCall(x, program));
        return;
      }

      maybeReplaceForPrunedParameters(x, ctx);
    }

    @Override
    public void endVisit(JNameOf x, Context ctx) {
      HasName node = x.getNode();
      boolean pruned;
      if (node instanceof JField) {
        pruned = isPruned((JField) node);
      } else if (node instanceof JMethod) {
        pruned = isPruned((JMethod) node);
      } else if (node instanceof JReferenceType) {
        pruned = !program.typeOracle.isInstantiatedType((JReferenceType) node);
      } else {
        throw new InternalCompilerException("Unhandled JNameOf node: " + node);
      }

      if (pruned) {
        ctx.replaceMe(program.getLiteralNull());
      }
    }

    @Override
    public void endVisit(JNewInstance x, Context ctx) {
      maybeReplaceForPrunedParameters(x, ctx);
    }

    @Override
    public void endVisit(JRuntimeTypeReference x, Context ctx) {
      if (!program.typeOracle.isInstantiatedType(x.getReferredType())) {
        ctx.replaceMe(program.getLiteralNull());
      }
    }

    @Override
    public void endVisit(JsniFieldRef x, Context ctx) {
      if (isPruned(x.getField())) {
        String ident = x.getIdent();
        JField nullField = program.getNullField();
        JsniFieldRef nullFieldRef =
            new JsniFieldRef(x.getSourceInfo(), ident, nullField, x.getEnclosingType(), x
                .isLvalue());
        ctx.replaceMe(nullFieldRef);
      }
    }

    @Override
    public void endVisit(JsniMethodRef x, Context ctx) {

      if (isPruned(x.getTarget())) {
        String ident = x.getIdent();
        JMethod nullMethod = program.getNullMethod();
        JsniMethodRef nullMethodRef =
            new JsniMethodRef(x.getSourceInfo(), ident, nullMethod, program.getJavaScriptObject());
        ctx.replaceMe(nullMethodRef);
      }
    }

    @Override
    public void exit(JVariable x, Context ctx) {
      JType type = x.getType();
      if (type instanceof JReferenceType &&
          !program.typeOracle.isInstantiatedType((JReferenceType) type)) {
        x.setType(JReferenceType.NULL_TYPE);
        madeChanges();
      }
    }

    @Override
    public boolean visit(JBinaryOperation x, Context ctx) {
      if (x.getOp() == JBinaryOperator.ASG) {
        lValues.push(x.getLhs());
      }
      return true;
    }

    @Override
    public boolean visit(JDeclarationStatement x, Context ctx) {
      super.visit(x, ctx);
      lValues.push(x.getVariableRef());
      return true;
    }

    private <T extends HasEnclosingType & CanBeStatic> boolean isPruned(T node) {
      if (!referencedNonTypes.contains(node)) {
        return true;
      }
      JReferenceType enclosingType = node.getEnclosingType();
      return !node.isStatic() && enclosingType != null
          && !program.typeOracle.isInstantiatedType(enclosingType);
    }

    private boolean isVariablePruned(JVariable variable) {
      if (variable instanceof JField) {
        return isPruned((JField) variable);
      }
      return !referencedNonTypes.contains(variable);
    }

    private JExpression makeReplacementForAssignment(SourceInfo info, JVariableRef variableRef,
        JExpression rhs) {

      JMultiExpression multi = new JMultiExpression(info);


      if (variableRef instanceof JFieldRef) {
        JFieldRef fieldRef = (JFieldRef) variableRef;
        JExpression instance = fieldRef.getInstance();
        if (instance != null) {
          multi.addExpressions(instance);
        }
      }


      if (rhs != null) {
        multi.addExpressions(rhs);
      }
      if (multi.getNumberOfExpressions() == 1) {
        return multi.getExpression(0);
      } else {
        return multi;
      }
    }



    private void maybeReplaceForPrunedParameters(JMethodCall x, Context ctx) {
      if (!priorParametersByMethod.containsKey(x.getTarget())) {

        return;
      }

      JMethodCall replacementCall = x.cloneWithoutParameters();

      assert !x.getTarget().canBePolymorphic();
      List<JParameter> originalParams = priorParametersByMethod.get(x.getTarget());


      assert originalParams.size() == x.getArgs().size();


      SourceInfo sourceInfo = x.getSourceInfo();
      JMultiExpression unevaluatedArgumentsForPrunedParameters =
          new JMultiExpression(sourceInfo);
      List<JExpression> args = x.getArgs();
      for (int currentArgumentIndex = 0; currentArgumentIndex < args.size();
          ++currentArgumentIndex) {
        JExpression arg = args.get(currentArgumentIndex);


        if (referencedNonTypes.contains(originalParams.get(currentArgumentIndex))) {


          unevaluatedArgumentsForPrunedParameters.addExpressions(arg);
          replacementCall.addArg(unevaluatedArgumentsForPrunedParameters);

          unevaluatedArgumentsForPrunedParameters =  new JMultiExpression(sourceInfo);
        } else if (arg.hasSideEffects()) {

          unevaluatedArgumentsForPrunedParameters.addExpressions(arg);
        }
      }

      if (unevaluatedArgumentsForPrunedParameters.isEmpty()) {

        ctx.replaceMe(replacementCall);
        return;
      }



      if (replacementCall.getArgs().isEmpty()) {

        unevaluatedArgumentsForPrunedParameters.addExpressions(replacementCall);
        ctx.replaceMe(unevaluatedArgumentsForPrunedParameters);
        return;
      }


      JExpression lastArg = Iterables.getLast(replacementCall.getArgs());
      JLocal tempVar =
          createTempLocal(sourceInfo, Iterables.getLast(
              Iterables.filter(originalParams, Predicates.in(referencedNonTypes))).getType());
      unevaluatedArgumentsForPrunedParameters.addExpressions(0, JProgram.createAssignment(
          lastArg.getSourceInfo(), new JLocalRef(sourceInfo, tempVar), lastArg));
      unevaluatedArgumentsForPrunedParameters.addExpressions(new JLocalRef(sourceInfo, tempVar));
      replacementCall.setArg(replacementCall.getArgs().size() - 1, unevaluatedArgumentsForPrunedParameters);
      ctx.replaceMe(replacementCall);
    }

    @Override
    protected String newTemporaryLocalName(SourceInfo info, JType type, JMethodBody methodBody) {


      return "lastArg";
    }
  }


  private class PruneVisitor extends JChangeTrackingVisitor {
    private final ListMultimap<JMethod, JParameter> priorParametersByMethod =
        ArrayListMultimap.create();
    private final Set<? extends JNode> referencedNonTypes;
    private final Set<? extends JReferenceType> referencedTypes;

    public PruneVisitor(Set<? extends JReferenceType> referencedTypes,
        Set<? extends JNode> referencedNodes, OptimizerContext optimizerCtx) {
      super(optimizerCtx);
      this.referencedTypes = referencedTypes;
      this.referencedNonTypes = referencedNodes;
    }

    public ListMultimap<JMethod, JParameter> getPriorParametersByMethod() {
      return priorParametersByMethod;
    }

    @Override
    public boolean visit(JDeclaredType type, Context ctx) {
      assert referencedTypes.contains(type);
      Predicate<JNode> notReferenced = Predicates.not(Predicates.in(referencedNonTypes));
      removeFields(notReferenced, type);
      removeMethods(notReferenced, type);

      for (JMethod method : type.getMethods()) {
        accept(method);
      }

      return false;
    }

    @Override
    public boolean enter(JMethod x, Context ctx) {
      if (!x.canBePolymorphic()) {

        if (!referencedNonTypes.contains(x)) {
          return true;
        }


        JMethod instanceMethod = program.instanceMethodForStaticImpl(x);

        if (saveCodeGenTypes && instanceMethod != null &&
            referencedNonTypes.contains(instanceMethod)) {

          return true;
        }

        priorParametersByMethod.putAll(x, x.getParams());

        for (int i = 0; i < x.getParams().size(); ++i) {
          JParameter param = x.getParams().get(i);
          if (!referencedNonTypes.contains(param)) {
            x.removeParam(i);
            madeChanges();
            --i;
          }
        }
      }

      return true;
    }

    @Override
    public boolean visit(JMethodBody x, Context ctx) {
      for (int i = 0; i < x.getLocals().size(); ++i) {
        if (!referencedNonTypes.contains(x.getLocals().get(i))) {
          x.removeLocal(i--);
          madeChanges();
        }
      }
      return false;
    }

    @Override
    public boolean visit(JProgram program, Context ctx) {
      for (Iterator<JDeclaredType> it = program.getDeclaredTypes().iterator(); it.hasNext();) {
        JDeclaredType type = it.next();
        if (referencedTypes.contains(type)) {
          accept(type);
        } else {
          prunedMethods.addAll(type.getMethods());
          methodsWereRemoved(type.getMethods());
          fieldsWereRemoved(type.getFields());
          it.remove();
          madeChanges();
        }
      }
      return false;
    }

    private void removeFields(Predicate<JNode> shouldRemove, JDeclaredType type) {
      for (int i = 0; i < type.getFields().size(); ++i) {
        JField field = type.getFields().get(i);
        if (!shouldRemove.apply(field)) {
          continue;
        }
        wasRemoved(field);
        type.removeField(i);
        madeChanges();
        --i;
      }
    }

    private void removeMethods(Predicate<JNode> shouldRemove, JDeclaredType type) {

      assert type.getMethods().get(0) == type.getClinitMethod();
      for (int i = 1; i < type.getMethods().size(); ++i) {
        JMethod method = type.getMethods().get(i);
        if (!shouldRemove.apply(method)) {
          continue;
        }
        prunedMethods.add(method);
        wasRemoved(method);
        type.removeMethod(i);
        program.removeStaticImplMapping(method);
        madeChanges();
        --i;
      }
    }
  }

  private static final String NAME = Pruner.class.getSimpleName();

  public static OptimizerStats exec(JProgram program, boolean noSpecialTypes,
      OptimizerContext optimizerCtx) {
    Event optimizeEvent = SpeedTracerLogger.start(CompilerEventType.OPTIMIZE, "optimizer", NAME);
    OptimizerStats stats = new Pruner(program, noSpecialTypes).execImpl(optimizerCtx);
    optimizeEvent.end("didChange", "" + stats.didChange());
    return stats;
  }

  public static OptimizerStats exec(JProgram program, boolean noSpecialTypes) {
    return exec(program, noSpecialTypes, OptimizerContext.NULL_OPTIMIZATION_CONTEXT);
  }


  public static JFieldRef transformToNullFieldRef(JFieldRef x, JProgram program) {
    JExpression instance = x.getInstance();




    if (x.getField().isStatic() && instance == null) {
      instance = program.getLiteralNull();
    }

    assert instance != null;
    if (!instance.hasSideEffects()) {
      instance = program.getLiteralNull();
    }

    JFieldRef fieldRef =
        new JFieldRef(x.getSourceInfo(), instance, program.getNullField(), x.getEnclosingType(),
            primitiveTypeOrNullTypeOrArray(program, x.getType()));
    return fieldRef;
  }


  public static JMethodCall transformToNullMethodCall(JMethodCall x, JProgram program) {
    JExpression instance = x.getInstance();
    List<JExpression> args = x.getArgs();
    if (program.isStaticImpl(x.getTarget())) {
      instance = args.get(0);
      args = args.subList(1, args.size());
    } else {



      if (x.getTarget().isStatic() && instance == null) {
        instance = program.getLiteralNull();
      }
    }
    assert (instance != null);
    if (!instance.hasSideEffects()) {
      instance = program.getLiteralNull();
    }

    JMethodCall newCall =
        new JMethodCall(x.getSourceInfo(), instance, program.getNullMethod(),
            primitiveTypeOrNullTypeOrArray(program, x.getType()));

    for (JExpression arg : args) {
      if (arg.hasSideEffects()) {
        newCall.addArg(arg);
      }
    }
    return newCall;
  }


  static JType primitiveTypeOrNullTypeOrArray(JProgram program, JType type) {
    if (type instanceof JArrayType) {
      JType leafType = primitiveTypeOrNullTypeOrArray(program, ((JArrayType) type).getLeafType());
      return program.getOrCreateArrayType(leafType, ((JArrayType) type).getDims());
    }
    if (type instanceof JPrimitiveType) {
      return type;
    }
    return JReferenceType.NULL_TYPE;
  }

  private final JProgram program;

  private final boolean saveCodeGenTypes;

  private final Set<JMethod> prunedMethods = Sets.newLinkedHashSet();

  private Pruner(JProgram program, boolean saveCodeGenTypes) {
    this.program = program;
    this.saveCodeGenTypes = saveCodeGenTypes;
  }

  private OptimizerStats execImpl(OptimizerContext optimizerCtx) {
    OptimizerStats stats = new OptimizerStats(NAME);

    ControlFlowAnalyzer livenessAnalyzer = new ControlFlowAnalyzer(program);
    livenessAnalyzer.setForPruning();


    traverseTypes(livenessAnalyzer, program.immortalCodeGenTypes);

    if (saveCodeGenTypes) {

      traverseTypes(livenessAnalyzer, program.codeGenTypes);
    }
    livenessAnalyzer.traverseEverything();

    program.typeOracle.setInstantiatedTypes(livenessAnalyzer.getInstantiatedTypes());

    PruneVisitor pruner =
        new PruneVisitor(livenessAnalyzer.getReferencedTypes(), livenessAnalyzer
            .getLiveFieldsAndMethods(), optimizerCtx);
    pruner.accept(program);
    stats.recordModified(pruner.getNumMods());

    if (!pruner.didChange()) {
      return stats;
    }
    CleanupRefsVisitor cleaner =
        new CleanupRefsVisitor(livenessAnalyzer.getLiveFieldsAndMethods(), pruner
            .getPriorParametersByMethod(), optimizerCtx);
    cleaner.accept(program.getDeclaredTypes());
    optimizerCtx.incOptimizationStep();
    optimizerCtx.syncDeletedSubCallGraphsSince(optimizerCtx.getLastStepFor(NAME) + 1,
        prunedMethods);
    JavaAstVerifier.assertProgramIsConsistent(program);
    return stats;
  }


  private void traverseTypes(ControlFlowAnalyzer livenessAnalyzer,
      List<JClassType> types) {
    for (JClassType type : types) {
      livenessAnalyzer.traverseFromReferenceTo(type);
      for (JMethod method : type.getMethods()) {
        if (method instanceof JConstructor) {
          livenessAnalyzer.traverseFromInstantiationOf(type);
        }
        livenessAnalyzer.traverseFrom(method);
      }
    }
  }
}

<code block>

package com.google.gwt.dev.js;

import com.google.gwt.core.ext.UnableToCompleteException;
import com.google.gwt.core.ext.linker.SymbolData;
import com.google.gwt.core.ext.linker.impl.StandardSymbolData;
import com.google.gwt.dev.CompilerContext;
import com.google.gwt.dev.MinimalRebuildCache;
import com.google.gwt.dev.PrecompileTaskOptions;
import com.google.gwt.dev.PrecompileTaskOptionsImpl;
import com.google.gwt.dev.cfg.BindingProperties;
import com.google.gwt.dev.cfg.BindingProperty;
import com.google.gwt.dev.cfg.ConditionNone;
import com.google.gwt.dev.cfg.ConfigurationProperties;
import com.google.gwt.dev.cfg.ConfigurationProperty;
import com.google.gwt.dev.cfg.PermutationProperties;
import com.google.gwt.dev.javac.CompilationState;
import com.google.gwt.dev.javac.CompilationStateBuilder;
import com.google.gwt.dev.javac.testing.impl.MockJavaResource;
import com.google.gwt.dev.javac.testing.impl.MockResourceOracle;
import com.google.gwt.dev.jjs.AstConstructor;
import com.google.gwt.dev.jjs.JavaAstConstructor;
import com.google.gwt.dev.jjs.JsOutputOption;
import com.google.gwt.dev.jjs.ast.JProgram;
import com.google.gwt.dev.jjs.impl.ArrayNormalizer;
import com.google.gwt.dev.jjs.impl.CatchBlockNormalizer;
import com.google.gwt.dev.jjs.impl.ComputeCastabilityInformation;
import com.google.gwt.dev.jjs.impl.FullCompileTestBase;
import com.google.gwt.dev.jjs.impl.GenerateJavaScriptAST;
import com.google.gwt.dev.jjs.impl.ImplementCastsAndTypeChecks;
import com.google.gwt.dev.jjs.impl.JavaToJavaScriptMap;
import com.google.gwt.dev.jjs.impl.MethodInliner;
import com.google.gwt.dev.jjs.impl.ResolveRuntimeTypeReferences;
import com.google.gwt.dev.jjs.impl.ResolveRuntimeTypeReferences.StringTypeMapper;
import com.google.gwt.dev.jjs.impl.ResolveRuntimeTypeReferences.TypeMapper;
import com.google.gwt.dev.jjs.impl.ResolveRuntimeTypeReferences.TypeOrder;
import com.google.gwt.dev.js.ast.JsFunction;
import com.google.gwt.dev.js.ast.JsName;
import com.google.gwt.dev.js.ast.JsProgram;
import com.google.gwt.dev.js.ast.JsVisitable;
import com.google.gwt.dev.js.ast.JsVisitor;
import com.google.gwt.dev.util.DefaultTextOutput;
import com.google.gwt.dev.util.TextOutput;
import com.google.gwt.thirdparty.guava.common.base.Joiner;

import java.util.Arrays;
import java.util.Map;
import java.util.TreeMap;


public class JsStackEmulatorTest extends FullCompileTestBase {

  private final ConfigurationProperty recordFileNamesProp =
      new ConfigurationProperty("compiler.emulatedStack.recordFileNames", false);

  private final ConfigurationProperty recordLineNumbersProp =
      new ConfigurationProperty("compiler.emulatedStack.recordLineNumbers", false);

  private boolean inline = false;

  public void testEmptyMethod() throws Exception {
    recordFileNamesProp.setValue("true");
    recordLineNumbersProp.setValue("true");

    JsProgram program = compileClass(
        "package test;",
        "public class EntryPoint {",
        "  public static void onModuleLoad() {",
        "  }",
        "}");

    checkOnModuleLoad(program, "function onModuleLoad(){" +
        "var stackIndex;$stack[stackIndex=++$stackDepth]=onModuleLoad;" +
        "$location[stackIndex]='EntryPoint.java:'+'3',$clinit_EntryPoint();" +
        "$stackDepth=stackIndex-1}");
  }

  public void testCallWithNoArguments() throws Exception {
    recordFileNamesProp.setValue("true");
    recordLineNumbersProp.setValue("true");

    JsProgram program = compileClass(
        "package test;",
        "public class EntryPoint {",
        "  static void foo() {}",
        "  public static void onModuleLoad() {",
        "    foo();",
        "  }",
        "}");

    checkOnModuleLoad(program, "function onModuleLoad(){" +
        "var stackIndex;$stack[stackIndex=++$stackDepth]=onModuleLoad;" +
        "$location[stackIndex]='EntryPoint.java:'+'4',$clinit_EntryPoint();" +
        "$location[stackIndex]='EntryPoint.java:'+'5',foo();" +
        "$stackDepth=stackIndex-1}");
  }

  public void testCallWithArguments() throws Exception {
    recordFileNamesProp.setValue("true");
    recordLineNumbersProp.setValue("true");

    JsProgram program = compileClass(
        "package test;",
        "public class EntryPoint {",
        "  static void foo(int x) {}",
        "  public static void onModuleLoad() {",
        "    foo(123);",
        "  }",
        "}");

    checkOnModuleLoad(program, "function onModuleLoad(){" +
        "var stackIndex;$stack[stackIndex=++$stackDepth]=onModuleLoad;" +
        "$location[stackIndex]='EntryPoint.java:'+'4',$clinit_EntryPoint();" +
        "foo(($tmp=123,$location[stackIndex]='EntryPoint.java:'+'5',$tmp));" +
        "$stackDepth=stackIndex-1}");
  }

  public void testSimpleThrow() throws Exception {
    recordFileNamesProp.setValue("true");
    recordLineNumbersProp.setValue("true");

    JsProgram program = compileClass(
        "package test;",
        "public class EntryPoint {",
        "  public static void onModuleLoad() {",
        "    throw new RuntimeException();",
        "  }",
        "}");


    checkOnModuleLoad(program, "function onModuleLoad(){" +
        "var stackIndex;$stack[stackIndex=++$stackDepth]=onModuleLoad;" +
        "$location[stackIndex]='EntryPoint.java:'+'3',$clinit_EntryPoint();" +
        "throw $location[stackIndex]='EntryPoint.java:'+'4',new RuntimeException" +
        "}");
  }

  public void testThrowWithInlineMethodCall() throws Exception {
    recordFileNamesProp.setValue("true");
    recordLineNumbersProp.setValue("true");
    inline = true;

    JsProgram program = compileClass(
        "package test;",
        "public class EntryPoint {",
        "  static Object thing = \"hello\";",
        "  private static String message() { return thing", 
        "    .toString(); }",
        "  public static void onModuleLoad() {", 
        "    throw new RuntimeException(message());", 
        "  }",
        "}");


    checkOnModuleLoad(program, "function onModuleLoad(){" +
        "var stackIndex;$stack[stackIndex=++$stackDepth]=onModuleLoad;" +
        "$location[stackIndex]='EntryPoint.java:'+'6',$clinit_EntryPoint();" +
        "throw new RuntimeException(" +
        "($tmp=($location[stackIndex]='EntryPoint.java:'+'4',thing).toString$()," +
        "$location[stackIndex]='EntryPoint.java:'+'7',$tmp))" +
        "}");
  }

  public void testThrowWithChainedMethodCall() throws Exception {
    recordFileNamesProp.setValue("true");
    recordLineNumbersProp.setValue("true");
    inline = true;

    JsProgram program = compileClass(
        "package test;",
        "public class EntryPoint {",
        "  static Factory factory;",
        "  static Factory getFactory() {",
        "    return factory;", 
        "  }",
        "  public static void onModuleLoad() {", 
        "    throw getFactory().makeException();", 
        "  }",
        "  static class Factory {",
        "    RuntimeException makeException() {",
        "      return new RuntimeException();",
        "    }",
        "  }",
        "}");

    checkOnModuleLoad(program, "function onModuleLoad(){" +
        "var stackIndex;$stack[stackIndex=++$stackDepth]=onModuleLoad;" +
        "$location[stackIndex]='EntryPoint.java:'+'7',$clinit_EntryPoint();" +
        "throw unwrap(($tmp=($location[stackIndex]='EntryPoint.java:'+'5',factory)," +
        "$location[stackIndex]='EntryPoint.java:'+'8',$tmp).makeException())" +
        "}");
  }

  public void testTryCatch() throws Exception {
    recordFileNamesProp.setValue("true");
    recordLineNumbersProp.setValue("true");

    JsProgram program = compileClass(
        "package test;",
        "public class EntryPoint {",
        "  public static void onModuleLoad() {",
        "    try {",
        "      throw new RuntimeException();",
        "    } catch (RuntimeException e) {" ,
        "      String s = e.getMessage();",
        "    }",
        "  }",
        "}");


    checkOnModuleLoad(program, "function onModuleLoad(){" +
        "var stackIndex;$stack[stackIndex=++$stackDepth]=onModuleLoad;" +
        "$location[stackIndex]='EntryPoint.java:'+'3',$clinit_EntryPoint();var e,s;" +
        "try{throw $location[stackIndex]='EntryPoint.java:'+'5',new RuntimeException" +
        "}catch($e0){$e0=wrap($e0);" +
        "$stackDepth=($location[stackIndex]='EntryPoint.java:'+'6',stackIndex);" +
        "if(instanceOf($e0,'java.lang.RuntimeException')){" +
        "e=$e0;s=($location[stackIndex]='EntryPoint.java:'+'7',e).getMessage()}" +
        "else throw unwrap(($location[stackIndex]='EntryPoint.java:'+'6',$e0))}" +
        "$stackDepth=stackIndex-1" +
        "}");
  }


  private JsProgram compileClass(String... lines) throws UnableToCompleteException {



    final String code = Joiner.on("\n").join(lines);

    MockResourceOracle sourceOracle = new MockResourceOracle();
    sourceOracle.addOrReplace(new MockJavaResource("test.EntryPoint") {
      @Override
      public CharSequence getContent() {
        return code;
      }
    });
    sourceOracle.add(JavaAstConstructor.getCompilerTypes());

    PrecompileTaskOptions options = new PrecompileTaskOptionsImpl();
    options.setOutput(JsOutputOption.PRETTY);
    options.setRunAsyncEnabled(false);
    CompilerContext context = new CompilerContext.Builder().options(options)
        .minimalRebuildCache(new MinimalRebuildCache()).build();

    ConfigurationProperties config = new ConfigurationProperties(Arrays.asList(recordFileNamesProp,
        recordLineNumbersProp));

    CompilationState state =
        CompilationStateBuilder.buildFrom(logger, context,
            sourceOracle.getResources(), null);
    JProgram jProgram = AstConstructor.construct(logger, state, options, config);
    jProgram.addEntryMethod(findMethod(jProgram, "onModuleLoad"));

    if (inline) {
      MethodInliner.exec(jProgram);
    }

    CatchBlockNormalizer.exec(jProgram);



    ComputeCastabilityInformation.exec(jProgram, false);
    ImplementCastsAndTypeChecks.exec(jProgram, false);
    ArrayNormalizer.exec(jProgram, false);

    TypeMapper<String> typeMapper = new StringTypeMapper();
    ResolveRuntimeTypeReferences.exec(jProgram, typeMapper, TypeOrder.FREQUENCY);
    Map<StandardSymbolData, JsName> symbolTable =
        new TreeMap<StandardSymbolData, JsName>(new SymbolData.ClassIdentComparator());

    BindingProperty stackMode = new BindingProperty("compiler.stackMode");
    stackMode.addDefinedValue(new ConditionNone(), "EMULATED");

    PermutationProperties properties = new PermutationProperties(Arrays.asList(
        new BindingProperties(new BindingProperty[]{stackMode}, new String[]{"EMULATED"}, config)
    ));

    JsProgram jsProgram = new JsProgram();
    JavaToJavaScriptMap jjsmap = GenerateJavaScriptAST.exec(
        logger, jProgram, jsProgram, context, typeMapper,
        symbolTable, properties).getLeft();


    JsStackEmulator.exec(jProgram, jsProgram, properties, jjsmap);

    return jsProgram;
  }


  private static void checkOnModuleLoad(JsProgram program, String expectedJavascript) {
    JsName onModuleLoad = program.getScope().findExistingName("test_EntryPoint_onModuleLoad__V");
    assertNotNull(onModuleLoad);
    assert onModuleLoad.getStaticRef() instanceof JsFunction;
    assertEquals(expectedJavascript, serializeJs(onModuleLoad.getStaticRef()));
  }

  private static String serializeJs(JsVisitable node) {
    TextOutput text = new DefaultTextOutput(true);
    JsVisitor generator = new JsSourceGenerationVisitor(text);
    generator.accept(node);
    return text.toString();
  }

  @Override
  protected void optimizeJava() {
  }
}

<code block>

package com.google.gwt.dev.jjs.impl;

import com.google.gwt.core.ext.UnableToCompleteException;
import com.google.gwt.core.ext.linker.SymbolData;
import com.google.gwt.core.ext.linker.impl.StandardSymbolData;
import com.google.gwt.dev.CompilerContext;
import com.google.gwt.dev.cfg.BindingProperties;
import com.google.gwt.dev.cfg.BindingProperty;
import com.google.gwt.dev.cfg.ConditionNone;
import com.google.gwt.dev.cfg.ConfigurationProperties;
import com.google.gwt.dev.cfg.ConfigurationProperty;
import com.google.gwt.dev.cfg.PermutationProperties;
import com.google.gwt.dev.javac.CompilationState;
import com.google.gwt.dev.javac.CompilationStateBuilder;
import com.google.gwt.dev.javac.testing.impl.MockJavaResource;
import com.google.gwt.dev.jjs.JavaAstConstructor;
import com.google.gwt.dev.jjs.ast.JProgram;
import com.google.gwt.dev.jjs.impl.ResolveRuntimeTypeReferences.IntTypeMapper;
import com.google.gwt.dev.jjs.impl.ResolveRuntimeTypeReferences.TypeMapper;
import com.google.gwt.dev.jjs.impl.ResolveRuntimeTypeReferences.TypeOrder;
import com.google.gwt.dev.js.ast.JsName;
import com.google.gwt.dev.js.ast.JsNode;
import com.google.gwt.dev.js.ast.JsProgram;
import com.google.gwt.dev.util.Pair;
import com.google.gwt.thirdparty.guava.common.collect.Lists;

import java.util.Arrays;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;


public abstract class FullCompileTestBase extends JJSTestBase {


  private BindingProperty[] orderedProps = null;
  private String[] orderedPropValues = null;
  private ConfigurationProperty[] configurationProperties = {};

  protected JProgram jProgram = null;
  protected JsProgram jsProgram = null;

  @Override
  public void setUp() throws Exception {
    super.setUp();

    BindingProperty stackMode = new BindingProperty("compiler.stackMode");
    stackMode.addDefinedValue(new ConditionNone(), "STRIP");
    setProperties(new BindingProperty[]{stackMode}, new String[]{"STRIP"},
        new ConfigurationProperty[]{});

    jsProgram = new JsProgram();
  }


  protected Pair<JavaToJavaScriptMap, Set<JsNode>> compileSnippetToJS(final String code)
      throws UnableToCompleteException {
    sourceOracle.addOrReplace(new MockJavaResource("test.EntryPoint") {
      @Override
      public CharSequence getContent() {
        return code;
      }
    });

    CompilerContext compilerContext = provideCompilerContext();
    CompilationState state =
        CompilationStateBuilder.buildFrom(logger, compilerContext,
            sourceOracle.getResources(), getAdditionalTypeProviderDelegate());
    ConfigurationProperties config = new ConfigurationProperties(Lists.newArrayList(
        configurationProperties));

    jProgram =
        JavaAstConstructor.construct(logger, state, compilerContext, config,
            "test.EntryPoint", "com.google.gwt.lang.Exceptions");
    jProgram.addEntryMethod(findMethod(jProgram, "onModuleLoad"));

    optimizeJava();
    ComputeCastabilityInformation.exec(jProgram, false);
    ImplementCastsAndTypeChecks.exec(jProgram, false);
    ArrayNormalizer.exec(jProgram, false);
    TypeTightener.exec(jProgram);
    MethodCallTightener.exec(jProgram);

    TypeMapper<Integer> typeMapper = new IntTypeMapper();
    ResolveRuntimeTypeReferences.exec(jProgram, typeMapper, TypeOrder.FREQUENCY);

    Map<StandardSymbolData, JsName> symbolTable =
        new TreeMap<StandardSymbolData, JsName>(new SymbolData.ClassIdentComparator());

    PermutationProperties props = new PermutationProperties(Arrays.asList(
        new BindingProperties(orderedProps, orderedPropValues, config)
    ));
    return GenerateJavaScriptAST.exec(logger, jProgram, jsProgram, compilerContext,
        typeMapper, symbolTable, props);
  }

  abstract protected void optimizeJava();

  protected CompilerContext provideCompilerContext() {
    CompilerContext compilerContext = new CompilerContext.Builder().build();
    compilerContext.getOptions().setSourceLevel(sourceLevel);
    return compilerContext;
  }

  public void setProperties(BindingProperty[] orderedProps, String[] orderedValues,
      ConfigurationProperty[] configurationProperties) {
    this.orderedProps = orderedProps;
    this.orderedPropValues = orderedValues;
    this.configurationProperties = configurationProperties;
  }
}

<code block>

package com.google.gwt.dev.jjs.impl;

import com.google.gwt.core.ext.TreeLogger;
import com.google.gwt.core.ext.UnableToCompleteException;
import com.google.gwt.dev.jjs.ast.Context;
import com.google.gwt.dev.jjs.ast.JDeclarationStatement;
import com.google.gwt.dev.jjs.ast.JFieldRef;
import com.google.gwt.dev.jjs.ast.JMethod;
import com.google.gwt.dev.jjs.ast.JProgram;
import com.google.gwt.dev.jjs.ast.JValueLiteral;
import com.google.gwt.dev.jjs.ast.JVisitor;
import com.google.gwt.dev.jjs.impl.EnumOrdinalizer.Tracker;


public class EnumOrdinalizerTest extends OptimizerTestBase {

  private final boolean performCastReplacement = true;
  private final boolean runEqualityNormalizer = true;

  private boolean runMakeCallsStatic;
  private boolean runMethodInliner;
  private boolean runMethodCallTightener;
  private boolean runPruner;
  private boolean runTypeTightener;

  @Override
  protected void setUp() throws Exception {
    super.setUp();
    EnumOrdinalizer.enableTracker();
    EnumOrdinalizer.resetTracker();


    runTypeTightener = false;
    runMethodCallTightener = false;
    runMethodInliner = true;
    runMakeCallsStatic = true;




    runPruner = true;
  }

  @Override
  protected void tearDown() throws Exception {
    super.tearDown();
  }

  public void testOrdinalizeBasicAssignment()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Fruit apple = Fruit.APPLE;",
        "Fruit orange = Fruit.ORANGE;");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testOrdinalizeNewArrayAndAssignmentLocalRef()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result =
        optimize("void", "Fruit[] fruits = new Fruit[] {Fruit.APPLE, Fruit.ORANGE, Fruit.APPLE};",
            "if (fruits[0] == Fruit.APPLE) {",
            "  fruits[0] = Fruit.ORANGE;",
            "}");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testOrdinalizeNewArrayOfArrayAndAssignmentLocalRef()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result =
        optimize("void", "Fruit[][] fruits = new Fruit[][] ",
            " {{Fruit.APPLE, Fruit.ORANGE},{Fruit.APPLE, Fruit.ORANGE}};",
            "if (fruits[0][1] == Fruit.APPLE) {",
            "  fruits[0][1] = Fruit.ORANGE;",
            "}");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testOrdinalizeNewArrayAndAssignmentFieldRef()
      throws UnableToCompleteException {
    setupFruitEnum();
    addSnippetClassDecl("private final Fruit[] fruits = new Fruit[] ",
        "  {Fruit.APPLE, Fruit.ORANGE, Fruit.APPLE};");
    Result result = optimize("void", "EntryPoint ep = new EntryPoint();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testOrdinalizableFinalFieldUninitializedByDefault()
      throws UnableToCompleteException {
    setupFruitEnum();
    addSnippetClassDecl("private final Fruit uninitializedFinalFruit;",
        "public EntryPoint() {",
        "  uninitializedFinalFruit = Fruit.ORANGE;",
        "}");
    Result result = optimize("void", "EntryPoint ep = new EntryPoint();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testOrdinalizeSwitchStatement()
      throws UnableToCompleteException {
    setupFruitEnum();
    setupFruitSwitchMethod();
    Result result = optimize("void", "String apple = fruitSwitch(Fruit.APPLE);",
        "String orange = fruitSwitch(Fruit.ORANGE);");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testOrdinalizeIfStatement()
      throws UnableToCompleteException {
    setupFruitEnum();
    addSnippetClassDecl(
        "public static String fruitIf(Fruit fruit) {",
        " if (fruit == Fruit.APPLE) {",
        "   return \"Apple\";",
        " } else if (fruit == Fruit.ORANGE) {",
        "   return \"Orange\";",
        " } else {",
        "   return \"Unknown\";",
        " }",
        "}");
    Result result = optimize("void", "String apple = fruitIf(Fruit.APPLE);",
        "String orange = fruitIf(Fruit.ORANGE);");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testOrdinalizeConditional()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void",
        "Fruit fruit = (new Integer(1)).toString().isEmpty() ? Fruit.APPLE : Fruit.ORANGE;");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testOrdinalizeFieldRefOrdinalMethodCall()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "int i = Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testOrdinalizeVariableRefOrdinalMethodCall()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Fruit fruit = Fruit.APPLE;",
        "int i = fruit.ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testOrdinalizeUnusedEmptyEnum() throws UnableToCompleteException {
    setupEmptyEnum();

    Result result = optimize("void", "EmptyEnum myEnum;");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isOrdinalized("test.EntryPoint$EmptyEnum") ||
        !tracker.isVisited("test.EntryPoint$EmptyEnum"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testOrdinalizeUnusedEnum() throws UnableToCompleteException {
    setupFruitEnum();

    Result result = optimize("void", "Fruit myEnum;");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Fruit") ||
        !tracker.isVisited("test.EntryPoint$Fruit"));



    tracker.addOrdinalized("test.EntryPoint$Fruit");
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testOrdinalizeMethodCallExpressionOrdinalFieldRef()
      throws UnableToCompleteException {
    setupFruitEnum();
    addSnippetClassDecl("public static Fruit getResolvedFruit(Fruit fruit) {",
        "  if (fruit == Fruit.APPLE) {",
        "    return Fruit.ORANGE;",
        "  } else { ",
        "    return Fruit.APPLE;",
        "  }",
        "}");
    addSnippetClassDecl("public static int switchMethodCall(Fruit fruit) {",
        "  int retVal = 0;",
        "  switch (getResolvedFruit(fruit)) {",
        "    case APPLE: retVal = 12; break;",
        "    case ORANGE:retVal = 73; break;",
        "  }",
        "  return retVal;",
        "}");
    Result result = optimize("void", "int i = switchMethodCall(Fruit.APPLE);",
        "Fruit fruit = Fruit.ORANGE;",
        "int j = switchMethodCall(fruit);");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testOrdinalizableStaticFieldRef()
      throws UnableToCompleteException {

    setupFruitEnumWithStaticField();
    Result result = optimize("void",
        "String y = Fruit.staticField + Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testOrdinalizableStaticMethod()
      throws UnableToCompleteException {

    setupFruitEnumWithStaticMethod();
    Result result = optimize("void", "int y = Fruit.staticMethod() + Fruit.APPLE.ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testOrdinalizableCallingValues()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "int l = Fruit.values().length;",
        "int ord = Fruit.APPLE.ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testOrdinalizableStaticFieldRefToVALUES()
      throws UnableToCompleteException {


    setupFruitEnum();
    Result result = optimize("void", "Fruit[] fruits = Fruit.values();",
        "int ord = Fruit.APPLE.ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testOrdinalizableStaticMethodThatRefsValuesLength()
      throws UnableToCompleteException {

    setupFruitEnumWithStaticMethodThatRefsValuesLength();
    Result result = optimize("void", "Fruit y = Fruit.forInteger(0);",
        "int ord = Fruit.APPLE.ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableInstanceStaticFieldRef()
      throws UnableToCompleteException {

    setupFruitEnumWithStaticField();
    Result result = optimize("void", "Fruit fruit = Fruit.APPLE;",
        "String y = fruit.staticField;");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableInstanceStaticMethod()
      throws UnableToCompleteException {

    setupFruitEnumWithStaticMethod();
    Result result = optimize("void", "Fruit fruit = Fruit.APPLE;",
        "int y = fruit.staticMethod();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableClassLiteralReference()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Class clazz = Fruit.class;",
        "String clazzStr = clazz.toString() + Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableEnumValueOfWithClassLiteralArg()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Object Carrot = Enum.valueOf(Fruit.class, \"APPLE\");",
        "String carrot = Carrot.toString() + Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableGetClassMethodCall()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Class clazz = Fruit.APPLE.getClass();",
        "String clazzStr = clazz.toString() + Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableExplicitCastToEnumClass()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Object obj = new Object();",
        "Fruit fruit = (Fruit) obj;",
        "int ord = Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableExplicitCastToArrayOfEnumClass()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Enum[] enumArray = new Enum[10];",
        "Fruit[] fruitArray = (Fruit[]) enumArray;",
        "int ord = Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableExplicitCastFromArrayOfEnumClass()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Fruit[] fruitArray = new Fruit[10];",
        "Enum[] enumArray = (Enum[]) fruitArray;",
        "int ord = Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableExplicitCastToArrayOfArrayOfEnumClass()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Enum[][] enumArray = new Enum[10][10];",
        "Fruit[][] fruitArray = (Fruit[][]) enumArray;",
        "int ord = Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableExplicitCastFromArrayOfArrayOfEnumClass()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Fruit[][] fruitArray = new Fruit[10][10];",
        "Enum[][] enumArray = (Enum[][]) fruitArray;",
        "int ord = Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableExplicitCastFromEnumClass()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Enum Carrot = (Enum) Fruit.APPLE;",
        "String carrot = Carrot.toString();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableOrdinalMethodRefFromExplicitCastWithBlackListableSubExpression()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "int ord = " +
        "((Fruit) Enum.valueOf(Fruit.class,\"APPLE\")).ordinal();",
        "int ord2 = Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableInstanceFieldRef()
      throws UnableToCompleteException {

    setupFruitEnumWithInstanceField();
    Result result = optimize("void", "String instanceField = Fruit.APPLE.instanceField;");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableInstanceOfEnumExpression()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Fruit fruit = Fruit.APPLE;",
        "if (fruit instanceof Enum) {",
        "  fruit = Fruit.ORANGE;",
        "}");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableInstanceOfEnumTestType()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Object fruitObj = new Object();",
        "if (fruitObj instanceof Fruit) {",
        "  fruitObj = null;",
        "}",
        "int ord = Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableStaticMethodCallValues()
      throws UnableToCompleteException {

    runMethodInliner = false;

    setupFruitEnum();
    Result result = optimize("void", "Fruit[] fruits = Fruit.values();",
        "int ord = Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableJsniFieldRef()
      throws UnableToCompleteException {
    setupFruitEnum();
    addSnippetClassDecl("public static Fruit instanceFruit;");
    addSnippetClassDecl("public static native void jsniMethod() /*-{",
        "  var x = @test.EntryPoint::instanceFruit",
        "}-*/");
    Result result = optimize("void", "instanceFruit = Fruit.APPLE;",
        "jsniMethod();",
        "int ord = Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableJsniFieldRefStatic()
      throws UnableToCompleteException {
    setupFruitEnum();
    addSnippetClassDecl("public static native void jsniMethod() /*-{",
        "  var x = @test.EntryPoint.Fruit::APPLE",
        "}-*/");
    Result result = optimize("void", "jsniMethod();",
        "int ord = Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableJsniFieldRefClassLiteral()
      throws UnableToCompleteException {
    setupFruitEnum();
    addSnippetClassDecl("public static native void jsniMethod() /*-{",
        "  var x = @test.EntryPoint.Fruit::class",
        "}-*/");
    Result result = optimize("void", "jsniMethod();",
        "int ord = Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastBinaryOpAssignment()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void",
        "Enum tomato;",
        "tomato = Fruit.APPLE;",
        "int ord = tomato.ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastFieldInitializedWithNullByDefault()
      throws UnableToCompleteException {
    setupFruitEnum();
    addSnippetClassDecl("static private Fruit uninitializedFruitAsNull;");
    Result result = optimize("void", "if (uninitializedFruitAsNull != Fruit.APPLE) {",
        "  uninitializedFruitAsNull = Fruit.ORANGE;",
        "}",
        "int ord = Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastBinaryOpEquals()
      throws UnableToCompleteException {
    setupFruitAndVegetableEnums();
    Result result = optimize("void", "Fruit fruit = Fruit.APPLE;",
        "Enum carrot = (Enum) Vegetable.CARROT;",
        "boolean test = (fruit == carrot);");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertTrue(tracker.isVisited("test.EntryPoint$Vegetable"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Vegetable"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastBinaryOpNotEquals()
      throws UnableToCompleteException {
    setupFruitAndVegetableEnums();
    Result result = optimize("void", "Fruit fruit = Fruit.APPLE;",
        "Enum carrot = (Enum) Vegetable.CARROT;",

        "boolean test = (carrot != fruit);");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertTrue(tracker.isVisited("test.EntryPoint$Vegetable"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Vegetable"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastBinaryOpEqualsNull()
      throws UnableToCompleteException {
    setupFruitEnum();
    addSnippetClassDecl("public static boolean testIsNull(Fruit fruit) {",
        "  if (fruit == null) {",
        "    return true;",
        "    } else {",
        "    return false;",
        "    }",
        "}");
    Result result = optimize("void", "Fruit fruit = Fruit.APPLE;",
        "boolean isNull = testIsNull(fruit) || testIsNull(Fruit.ORANGE);");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastBinaryOpNotEqualsNull()
      throws UnableToCompleteException {
    setupFruitEnum();
    addSnippetClassDecl("public static boolean testIsNull(Fruit fruit) {",
        "  if (fruit != null) {",
        "    return true;",
        "  } else {",
        "    return false;",
        "  }",
        "}");
    Result result = optimize("void", "Fruit fruit = Fruit.APPLE;",
        "boolean isNull = testIsNull(fruit) || testIsNull(Fruit.ORANGE);");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastBinaryOpStringConcat()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Fruit fruit = Fruit.APPLE;",
        "String str = \"A string followed by \" + fruit;");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastBinaryOpStringConcat2()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Fruit fruit = Fruit.APPLE;",
        "String str = fruit + \" followed by a string\";");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastBinaryOpStringConcatAssignment()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Fruit fruit = Fruit.APPLE;",
        "String str = \"A string concatenated with: \";",
        "str += fruit;");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastDeclarationToNull()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Fruit fruit = null;",
        "int ord = fruit == null ? Util.notInlineable(Fruit.APPLE).ordinal() : fruit.ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastAssignmentToNull()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Fruit fruit;",
        "fruit = null;",
        "int ord = fruit == null ? Util.notInlineable(Fruit.APPLE).ordinal() : fruit.ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastDeclaration()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Enum tomato = Fruit.APPLE;",
        "int ord = Fruit.APPLE.ordinal() + tomato.ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastConditional()
      throws UnableToCompleteException {
    setupFruitAndVegetableEnums();
    Result result = optimize("void", "Enum tomato = null;",
        "tomato = (true) ? Fruit.APPLE : Vegetable.CARROT;",
        "int ord = Util.notInlineable(Fruit.APPLE).ordinal() +",
        "    Util.notInlineable(Vegetable.CARROT).ordinal() + tomato.ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertTrue(tracker.isVisited("test.EntryPoint$Vegetable"));
    assertTrue(tracker.isOrdinalized("test.EntryPoint$Vegetable"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastOverriddenMethodReturnType()
      throws UnableToCompleteException {


    runTypeTightener = true;
    runMethodCallTightener = true;


    addSnippetClassDecl("public interface EnumInterface {",
        "  String name();",
        "}");
    addSnippetClassDecl("public abstract class AbstractClass<T extends EnumInterface> {",
        "  public abstract T getEnumClass();",
        "}");
    addSnippetClassDecl("public class CustomClass1 extends AbstractClass<EnumClass1> {",
        "  public EnumClass1 getEnumClass() { return EnumClass1.CONST1; }",
        "}");
    addSnippetClassDecl("public class CustomClass2 extends AbstractClass<EnumClass2> {",
        "  public EnumClass2 getEnumClass() { return EnumClass2.CONST2; }",
        "}");
    addSnippetClassDecl("public enum EnumClass1 implements EnumInterface {",
        "  CONST1;",
        "}");
    addSnippetClassDecl("public enum EnumClass2 implements EnumInterface {",
        "  CONST2;",
        "}");
    addSnippetClassDecl("public static void testEnumClass(AbstractClass abstractClass) {",
        "  EnumInterface enumClass = abstractClass.getEnumClass();",
        "}");
    Result result = optimize("void", "EntryPoint ep = new EntryPoint();",
        "AbstractClass abstractClass1 = ep.new CustomClass1();",
        "AbstractClass abstractClass2 = ep.new CustomClass2();",
        "testEnumClass(abstractClass1);",
        "testEnumClass(abstractClass2);");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$EnumClass1"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$EnumClass1"));
    assertTrue(tracker.isVisited("test.EntryPoint$EnumClass2"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$EnumClass2"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastMethodCallArgs()
      throws UnableToCompleteException {
    setupFruitEnum();
    addSnippetClassDecl("public static String getEnumString(Enum myEnum) {",

        "  int ord = myEnum.ordinal();",
        "  String retString = \"\";",
        "  for (int i = 0;i<ord;i++) {",
        "    retString += \"-\";",
        "  }",
        "  retString += myEnum.name();",
        "  return retString;",
        "}");
    Result result = optimize("void", "String stringApple = getEnumString(Fruit.APPLE);");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastMethodCallArgsNewArray()
      throws UnableToCompleteException {
    setupFruitEnum();
    addSnippetClassDecl("public static String getEnumString(Enum[] myEnumArray) {",
        "  String retString = \"\";",
        "  for (Enum myEnum : myEnumArray) {",
        "    retString += myEnum.name();",
        "  }",
        "  return retString;",
        "}");
    Result result = optimize("void",
        "String stringFruits = getEnumString(new Enum[] {Fruit.APPLE, Fruit.ORANGE});");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastMethodCallVarArgs()
      throws UnableToCompleteException {
    setupFruitEnum();
    addSnippetClassDecl("public static String getEnumString(Enum...myEnumArray) {",
        "  String retString = \"\";",
        "  for (Enum myEnum : myEnumArray) {",
        "    retString += myEnum.name();",
        "  }",
        "  return retString;",
        "}");
    Result result = optimize("void",
        "String stringFruits = getEnumString(Fruit.APPLE, Fruit.ORANGE);");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastNewArrayElements()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void", "Enum[] enums = new Enum[] {Fruit.APPLE, Fruit.ORANGE};");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastNewArrayArrayElements()
      throws UnableToCompleteException {
    setupFruitEnum();
    Result result = optimize("void",
        "Enum[][] enums = new Enum[][] {{Fruit.APPLE, Fruit.ORANGE},{Fruit.ORANGE, Fruit.APPLE}};");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableJsniMethodBodyParams()
      throws UnableToCompleteException {
    setupFruitEnum();
    addSnippetClassDecl("public static native void passEnumToJsniMethod(Enum myEnum) /*-{",
        "  myEnum == null; }-*/");
    Result result = optimize("void", "passEnumToJsniMethod(Fruit.APPLE);");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastJsniMethodBodyParams()
      throws UnableToCompleteException {
    setupFruitEnum();
    addSnippetClassDecl("public static native void passEnumToJsniMethod(Fruit myEnum) /*-{",
        "   myEnum == null; }-*/;");
    Result result = optimize("void", "passEnumToJsniMethod(Fruit.APPLE);");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableJsniMethodBodyCall()
      throws UnableToCompleteException {
    setupFruitEnum();
    addSnippetClassDecl("public static native void consumeFruitViaJsni() /*-{",
        "  var myJso = @test.EntryPoint::calledFromJsni(*)();",
        "}-*/;",
        "public static Fruit calledFromJsni() {",
        "  return Fruit.APPLE;",
        "}");
    Result result = optimize("void", "consumeFruitViaJsni();",
        "int ord = Fruit.APPLE.ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastJsniMethodRefParams()
      throws UnableToCompleteException {
    setupFruitEnum();
    setupFruitSwitchMethod();
    addSnippetClassDecl("public static native void fruitSwitchViaJsni() /*-{",
        "  var myJso;",
        "  var result = @test.EntryPoint::fruitSwitch(Ltest/EntryPoint$Fruit;)(myJso);",
        "}-*/");
    Result result = optimize("void", "fruitSwitchViaJsni();",
        "int ord = Util.notInlineable(Fruit.APPLE).ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastJsniMethodRefReturnType()
      throws UnableToCompleteException {
    setupFruitEnum();
    addSnippetClassDecl("public static Fruit returnSomeFruit() {",
        "  return Fruit.APPLE;",
        "}");
    addSnippetClassDecl("public static native void jsniMethodRefWithEnumReturn() /*-{",
        "  var result = @test.EntryPoint::returnSomeFruit()();",
        "}-*/");
    Result result = optimize("void", "jsniMethodRefWithEnumReturn();",
        "int ord = Fruit.APPLE.ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  public void testNotOrdinalizableImplicitUpcastReturnStatement()
      throws UnableToCompleteException {
    setupFruitAndVegetableEnums();
    addSnippetClassDecl("public static Enum returnAsEnum(int mode) {",
        "  if (mode == 0) {",
        "    return Fruit.APPLE;",
        "  } else {",
        "    return Vegetable.CARROT;",
        "  }",
        "}");
    Result result = optimize("void", "Enum myEnum = returnAsEnum(0);",

        "Enum myOtherEnum = returnAsEnum(1);",
        "int ord = myEnum.ordinal() + myOtherEnum.ordinal();");

    EnumOrdinalizer.Tracker tracker = EnumOrdinalizer.getTracker();
    assertTrue(tracker.isVisited("test.EntryPoint$Fruit"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Fruit"));
    assertTrue(tracker.isVisited("test.EntryPoint$Vegetable"));
    assertFalse(tracker.isOrdinalized("test.EntryPoint$Vegetable"));
    assertAllEnumOrdinalizedReferencesReplaced(result.getOptimizedProgram(), tracker);
  }

  private void setupEmptyEnum() {
    addSnippetClassDecl("public enum EmptyEnum {}");
  }

  private void setupFruitEnum() {
    addSnippetClassDecl("public enum Fruit {APPLE, ORANGE}");
    setupNotInlineable("Fruit");
  }

  private void setupFruitEnumWithInstanceField() {
    addSnippetClassDecl("public enum Fruit {APPLE(\"a\"), ORANGE(\"b\");",
        "  public final String instanceField;",
        "  private Fruit(String str) {",
        "    instanceField = str;",
        "  }",
        "}");
    setupNotInlineable("Fruit");
  }

  private void setupFruitEnumWithStaticField() {
    addSnippetClassDecl("public enum Fruit {APPLE, ORANGE;",
        "  public static String staticField = \"STATIC\";",
        "}");
    setupNotInlineable("Fruit");
  }

  private void setupFruitEnumWithStaticMethod() {
    addSnippetClassDecl("public enum Fruit {APPLE, ORANGE;",
        "  public static final int staticMethod() {",
        "    int x = 0;",
        "    return x;",
        "  }",
        "}");
    setupNotInlineable("Fruit");
  }

  private void setupFruitEnumWithStaticMethodThatRefsValuesArray() {

    addSnippetClassDecl("public enum Fruit {APPLE, ORANGE;",
        "  public static Fruit forInteger(int value) {",
        "    if (value < 0 || value >= 2) {",
        "      return ORANGE;",
        "    }",
        "    return Fruit.values()[value];",
        "  }",
        "}");
  }

  private void setupFruitEnumWithStaticMethodThatRefsValuesLength() {
    addSnippetClassDecl("public enum Fruit {APPLE, ORANGE;",
        "  public static Fruit forInteger(int value) {",
        "    if (value < 0 || value >= Fruit.values().length) {",
        "      return ORANGE;",
        "    }",
        "    return APPLE;",
        "  }",
        "}");
    setupNotInlineable("Fruit");
  }

  private void setupVegetableEnum() {
    addSnippetClassDecl("public enum Vegetable {CARROT, SPINACH}");
    setupNotInlineable("Vegetable");
  }

  private void setupFruitAndVegetableEnums() {
    addSnippetClassDecl("public enum Fruit {APPLE, ORANGE}");
    addSnippetClassDecl("public enum Vegetable {CARROT, SPINACH}");
    setupNotInlineable("Fruit", "Vegetable");
  }

  private void setupFruitSwitchMethod() {
    addSnippetClassDecl("public static String fruitSwitch(Fruit fruit) {",
        " switch(fruit) {",
        "   case APPLE: return \"Apple\";",
        "   case ORANGE: return \"Orange\";",
        "   default: return \"Unknown\";",
        " }",
        "}");
  }
  private void setupNotInlineable(String... classes) {
    addSnippetClassDecl("public static class Util {");
    for (String clazz : classes) {
      addSnippetClassDecl(
          "  public static " + clazz + " notInlineable(" + clazz + " obj) {",
          "    if (new Integer(1).toString().isEmpty()) return obj;",
          "    return obj;",
          "  }");
    }
    addSnippetClassDecl("}");
  }

  @Override
  protected boolean doOptimizeMethod(TreeLogger logger, JProgram program, JMethod method) {

    boolean didChange = false;
    program.addEntryMethod(findMainMethod(program));

    OptimizerContext optimizerContext = new FullOptimizerContext(program);
    if (runMakeCallsStatic) {
      didChange = MakeCallsStatic.exec(program, false, optimizerContext).didChange() || didChange;
    }
    if (runTypeTightener) {
      didChange = TypeTightener.exec(program, optimizerContext).didChange() || didChange;
    }
    if (runMethodCallTightener) {
      didChange = MethodCallTightener.exec(program, optimizerContext).didChange() || didChange;
    }
    if (runMethodInliner) {
      didChange = MethodInliner.exec(program, optimizerContext).didChange() || didChange;
    }
    if (runPruner) {
      didChange = Pruner.exec(program, true, optimizerContext).didChange() || didChange;
    }

    didChange = EnumOrdinalizer.exec(program, optimizerContext).didChange() || didChange;


    if (performCastReplacement) {
      ComputeCastabilityInformation.exec(program, false);
      ImplementCastsAndTypeChecks.exec(program, false);
    }
    if (runEqualityNormalizer) {
      EqualityNormalizer.exec(program);
    }

    return didChange;
  }

  private void assertAllEnumOrdinalizedReferencesReplaced(JProgram program, final Tracker tracker) {
    new JVisitor() {
      @Override
      public void endVisit(JFieldRef x, Context ctx) {
        assertTrue(x.getField() + " was not replaced everywhere",
            ctx.isLvalue() || !tracker.isOrdinalized(x.getEnclosingType().getName()));
      }

      @Override
      public void endVisit(JDeclarationStatement x, Context ctx) {
        assertTrue(x.getVariableRef().getTarget() + " was not replaced everywhere",
            x.getInitializer() instanceof JValueLiteral ||
                !(x.getVariableRef() instanceof JFieldRef) ||
                !tracker.isOrdinalized(
                    ((JFieldRef) x.getVariableRef()).getField().getEnclosingType().getName()));
      }
    }.accept(program);
  }
}

<code block>

package com.google.gwt.dev.jjs.test;

import com.google.gwt.core.client.JavaScriptObject;
import com.google.gwt.junit.client.GWTTestCase;


public class JsoTest extends GWTTestCase {

  static class Bar extends JavaScriptObject {
    public static int field;

    public static native String staticNative() ;

    public static String staticValue() {
      return "Bar" + field;
    }

    protected Bar() {
    }

    public final native String getBar() ;

    public final String value() {
      return "Bar";
    }
  }

  static final class ClinitStaticFieldFirst extends JavaScriptObject {
    public static String[] FIELD = new String[]{"a","b","c"};
    protected ClinitStaticFieldFirst() {
    }
    public Object invokeInstanceMethod() {
      if (FIELD == null) {
        return null;
      }
      return FIELD;
    }
    public static Object invokeStaticMethod() {
      if (FIELD == null) {
        return null;
      }
      return FIELD;
    }
  }

  static final class ClinitInstanceMethodFirst extends JavaScriptObject {
    public static String[] FIELD = new String[]{"a","b","c"};
    protected ClinitInstanceMethodFirst() {
    }
    public Object invokeInstanceMethod() {
      if (FIELD == null) {
        return null;
      }
      return FIELD;
    }
    public static Object invokeStaticMethod() {
      if (FIELD == null) {
        return null;
      }
      return FIELD;
    }
  }

  static final class ClinitStaticMethodFirst extends JavaScriptObject {
    public static String[] FIELD = new String[]{"a","b","c"};
    protected ClinitStaticMethodFirst() {
    }
    public Object invokeInstanceMethod() {
      if (FIELD == null) {
        return null;
      }
      return FIELD;
    }
    public static Object invokeStaticMethod() {
      if (FIELD == null) {
        return null;
      }
      return FIELD;
    }
  }

  static class Foo extends JavaScriptObject {
    public static int field;

    public static native String staticNative() ;
    

    public static native String staticNativeToSub() ;

    public static String staticValue() {
      return "Foo" + field;
    }

    protected Foo() {
    }

    public final native String getFoo() ;

    public final String value() {
      return "Foo";
    }
  }

  static class FooSub extends Foo {
    static String staticValueSub() {
      return "FooSub";
    }
    
    protected FooSub() {
    }

    public final String anotherValue() {
      return "Still Foo";
    }

    public final String superCall() {
      return super.value();
    }
  }

  static class JsArray<T> extends JavaScriptObject {
    public static native <T> JsArray<T> create() ;

    protected JsArray() {
    }

    public final native T get(int index) ;

    public final native int length() ;

    public final native void put(int index, T value) ;
  }

  static class MethodMangleClash {
    @SuppressWarnings("unused")
    public static String func(JavaScriptObject this_) {
      return "funcJavaScriptObject";
    }

    @SuppressWarnings("unused")
    public static String func(MethodMangleClash this_) {
      return "funcMethodMangleClash";
    }

    @SuppressWarnings("unused")
    public String func() {
      return "func";
    }
  }

  static class Overloads {
    private static volatile boolean FALSE = false;

    @SuppressWarnings("unused")
    static String sFunc(Bar b) {
      return "sFunc Bar";
    }

    @SuppressWarnings("unused")
    static String sFunc(Bar[][] b) {
      return "sFunc Bar[][]";
    }

    @SuppressWarnings("unused")
    static String sFunc(Foo f) {
      return "sFunc Foo";
    }

    @SuppressWarnings("unused")
    static String sFunc(Foo[][] f) {
      return "sFunc Foo[][]";
    }

    @SuppressWarnings("unused")
    public Overloads(Bar b) {
    }

    @SuppressWarnings("unused")
    public Overloads(Bar[][] b) {
    }

    @SuppressWarnings("unused")
    public Overloads(Foo f) {
    }

    @SuppressWarnings("unused")
    public Overloads(Foo[][] f) {
    }

    @SuppressWarnings("unused")
    String func(Bar b) {
      if (FALSE) {

        return func(b);
      }
      return "func Bar";
    }

    @SuppressWarnings("unused")
    String func(Bar[][] b) {
      if (FALSE) {

        return func(b);
      }
      return "func Bar[][]";
    }

    @SuppressWarnings("unused")
    String func(Foo f) {
      if (FALSE) {

        return func(f);
      }
      return "func Foo";
    }

    @SuppressWarnings("unused")
    String func(Foo[][] f) {
      if (FALSE) {

        return func(f);
      }
      return "func Foo[][]";
    }
  }

  private static native Bar makeBar() ;

  private static native Foo makeFoo() ;

  private static native JavaScriptObject makeJSO() ;

  private static native JavaScriptObject makeMixedArray() ;

  private static Object makeObject() {
    return new Object() {
      @Override
      public String toString() {
        return "myObject";
      }
    };
  }

  private static native JavaScriptObject returnMe(JavaScriptObject jso) ;

  @Override
  public String getModuleName() {
    return "com.google.gwt.dev.jjs.CompilerSuite";
  }

  public void testArrayInit() {
    Object[] array = {makeJSO(), new Object(), ""};
    assertTrue(array[0] instanceof JavaScriptObject);
    assertFalse(array[1] instanceof JavaScriptObject);
    assertFalse(array[2] instanceof JavaScriptObject);
  }

  public void testArrayStore() {
    JavaScriptObject[] jsoArray = new JavaScriptObject[1];
    jsoArray[0] = makeJSO();
    jsoArray[0] = makeFoo();
    jsoArray[0] = makeBar();

    Foo[] fooArray = new Foo[1];
    fooArray[0] = (Foo) makeJSO();
    fooArray[0] = makeFoo();
    fooArray[0] = makeBar().cast();

    Bar[] barArray = new Bar[1];
    barArray[0] = (Bar) makeJSO();
    barArray[0] = makeBar();
    barArray[0] = makeFoo().cast();

    Object[] objArray = jsoArray;
    try {
      objArray[0] = new Object();
      fail("Expected ArrayStoreException");
    } catch (ArrayStoreException expected) {
    }

    objArray = new Object[1];
    objArray[0] = makeJSO();
    objArray[0] = makeFoo();
    objArray[0] = makeBar();

    Foo[][] foo = new Foo[10][];
    Object[][] fooAsObject = foo;
    fooAsObject[0] = new Bar[1];
  }

  public void testBasic() {
    JavaScriptObject jso = makeJSO();
    assertEquals("jso", jso.toString());

    Foo foo = (Foo) jso;
    assertEquals("jso", foo.toString());
    assertEquals("jso foo", foo.getFoo());
    assertEquals("Foo", foo.value());

    Bar bar = (Bar) jso;
    assertEquals("jso", bar.toString());
    assertEquals("jso bar", bar.getBar());
    assertEquals("Bar", bar.value());

    foo = makeFoo();
    assertEquals("foo", foo.toString());
    assertEquals("this is foo", foo.getFoo());
    assertEquals("Foo", foo.value());

    bar = makeBar();
    assertEquals("bar", bar.toString());
    assertEquals("this is bar", bar.getBar());
    assertEquals("Bar", bar.value());
  }

  @SuppressWarnings("cast")
  public void testCasts() {
    JavaScriptObject jso = makeJSO();
    assertTrue(jso instanceof JavaScriptObject);
    assertTrue(jso instanceof Foo);
    assertTrue(jso instanceof Bar);

    Foo foo = (Foo) jso;
    foo = makeFoo();
    assertTrue((JavaScriptObject) foo instanceof Bar);
    Bar bar = (Bar) (JavaScriptObject) makeFoo();
    bar = makeFoo().cast();

    bar = (Bar) jso;
    bar = makeBar();
    assertTrue((JavaScriptObject) bar instanceof Foo);
    foo = (Foo) (JavaScriptObject) makeBar();
    foo = makeBar().cast();


    jso = foo;
    jso = bar;

    Object o = new Object();
    assertFalse(o instanceof JavaScriptObject);
    assertFalse(o instanceof Foo);
    assertFalse(o instanceof Bar);
    try {
      jso = (JavaScriptObject) o;
      fail("Expected ClassCastException");
    } catch (ClassCastException expected) {
    }

    o = "foo";
    assertFalse(o instanceof JavaScriptObject);
    assertFalse(o instanceof Foo);
    assertFalse(o instanceof Bar);
    try {
      jso = (JavaScriptObject) o;
      fail("Expected ClassCastException");
    } catch (ClassCastException expected) {
    }

    o = jso;
    assertFalse(o instanceof String);
    try {
      String s = (String) o;
      s = s.toString();
      fail("Expected ClassCastException");
    } catch (ClassCastException expected) {
    }
  }

  @SuppressWarnings("cast")
  public void testCastsArray() {
    JavaScriptObject[][] jso = new JavaScriptObject[0][0];
    assertTrue(jso instanceof JavaScriptObject[][]);
    assertTrue(jso instanceof Foo[][]);
    assertTrue(jso instanceof Bar[][]);

    Foo[][] foo = (Foo[][]) jso;
    foo = new Foo[0][0];
    assertTrue((JavaScriptObject[][]) foo instanceof Bar[][]);
    Bar[][] bar = (Bar[][]) (JavaScriptObject[][]) new Foo[0][0];

    bar = (Bar[][]) jso;
    bar = new Bar[0][0];
    assertTrue((JavaScriptObject[][]) bar instanceof Foo[][]);
    foo = (Foo[][]) (JavaScriptObject[][]) new Bar[0][0];

    Object[][] o = new Object[0][0];
    assertFalse(o instanceof JavaScriptObject[][]);
    assertFalse(o instanceof Foo[][]);
    assertFalse(o instanceof Bar[][]);
    try {
      jso = (JavaScriptObject[][]) o;
      fail("Expected ClassCastException");
    } catch (ClassCastException expected) {
    }

    o = jso;
    assertFalse(o instanceof String[][]);
    try {
      String[][] s = (String[][]) o;
      s.getClass();
      fail("Expected ClassCastException");
    } catch (ClassCastException expected) {
    }
  }

  public void testClassInitializerRun() {
    ClinitStaticMethodFirst staticMethodFirst = JavaScriptObject.createObject().cast();
    assertNotNull("static method", ClinitStaticMethodFirst.invokeStaticMethod());
    assertNotNull("instance method after static method", staticMethodFirst.invokeInstanceMethod());

    ClinitStaticFieldFirst staticFieldFirst = JavaScriptObject.createObject().cast();
    assertNotNull("field access", ClinitStaticFieldFirst.FIELD);
    assertNotNull("instance method after field access", staticFieldFirst.invokeInstanceMethod());

    ClinitInstanceMethodFirst instanceMethodFirst = JavaScriptObject.createObject().cast();
    assertNotNull("instance method", instanceMethodFirst.invokeInstanceMethod());
    assertNotNull("static method after instance method", ClinitInstanceMethodFirst.invokeStaticMethod());
  }

  public void testClassLiterals() {
    JavaScriptObject jso = makeJSO();
    Foo foo = makeFoo();
    Bar bar = makeBar();
    assertEquals(JavaScriptObject.class, jso.getClass());
    assertEquals(Foo.class, jso.getClass());
    assertEquals(Bar.class, jso.getClass());
    assertEquals(JavaScriptObject.class, foo.getClass());
    assertEquals(Foo.class, foo.getClass());
    assertEquals(Bar.class, foo.getClass());
    assertEquals(JavaScriptObject.class, bar.getClass());
    assertEquals(Foo.class, bar.getClass());
    assertEquals(Bar.class, bar.getClass());
    assertEquals(JavaScriptObject.class, Foo.class);
    assertEquals(JavaScriptObject.class, Bar.class);
    assertEquals(Foo.class, Bar.class);

    if (!JavaScriptObject.class.getName().startsWith("Class$")) {

      assertEquals("com.google.gwt.core.client.JavaScriptObject$",
          JavaScriptObject.class.getName());
    }
  }

  public void testClassLiteralsArray() {
    JavaScriptObject[][] jso = new JavaScriptObject[0][0];
    Foo[][] foo = new Foo[0][0];
    Bar[][] bar = new Bar[0][0];
    assertEquals(JavaScriptObject[][].class, jso.getClass());
    assertEquals(Foo[][].class, jso.getClass());
    assertEquals(Bar[][].class, jso.getClass());
    assertEquals(JavaScriptObject[][].class, foo.getClass());
    assertEquals(Foo[][].class, foo.getClass());
    assertEquals(Bar[][].class, foo.getClass());
    assertEquals(JavaScriptObject[][].class, bar.getClass());
    assertEquals(Foo[][].class, bar.getClass());
    assertEquals(Bar[][].class, bar.getClass());
    assertEquals(JavaScriptObject[][].class, Foo[][].class);
    assertEquals(JavaScriptObject[][].class, Bar[][].class);
    assertEquals(Foo[][].class, Bar[][].class);

    if (!JavaScriptObject.class.getName().startsWith("Class$")) {

      assertEquals("[[Lcom.google.gwt.core.client.JavaScriptObject$;",
          JavaScriptObject[][].class.getName());
    }
  }

  static class MyJSO extends JavaScriptObject {
    protected MyJSO() {
    }

    public final boolean equalMethod(Object o) {
      return this == o;
    }
  }

  public void testEquality() {
    JavaScriptObject jso = makeJSO();
    assertEquals(jso, jso);

    JavaScriptObject jso2 = makeJSO();
    assertFalse(jso.equals(jso2));
    assertFalse(jso2.equals(jso));

    jso2 = returnMe(jso);
    assertEquals(jso, jso2);

    MyJSO jso3 = (MyJSO) makeJSO();
    MyJSO jso4 = (MyJSO) makeJSO();
    assertTrue(jso3.equalMethod(jso3));
    assertFalse(jso3.equalMethod(jso4));
  }

  public void testGenericsJsos() {
    JsArray<JavaScriptObject> a = JsArray.create();
    a.put(0, makeJSO());
    a.put(1, makeFoo());
    a.put(2, makeBar());
    a.put(3, null);
    assertEquals(4, a.length());
    assertEquals("jso", a.get(0).toString());
    assertEquals("foo", a.get(1).toString());
    assertEquals("bar", a.get(2).toString());
    assertEquals(null, a.get(3));
  }

  public void testGenericsMixed() {
    JsArray<Object> a = JsArray.create();
    a.put(0, makeJSO());
    a.put(1, "foo");
    a.put(2, makeObject());
    a.put(3, null);
    assertEquals(4, a.length());
    assertEquals("jso", a.get(0).toString());
    assertEquals("foo", a.get(1));
    assertEquals("myObject", a.get(2).toString());
    assertEquals(null, a.get(3));
  }

  @SuppressWarnings("unchecked")
  public void testGenericsRawJson() {
    JsArray a = (JsArray) makeMixedArray();
    assertEquals(4, a.length());
    assertEquals("jso", a.get(0).toString());
    assertEquals("foo", a.get(1));
    assertEquals("myObject", a.get(2).toString());
    assertEquals(null, a.get(3));
  }

  public void testGenericsStrings() {
    JsArray<String> a = JsArray.create();
    a.put(0, "foo");
    a.put(1, "bar");
    a.put(2, "baz");
    a.put(3, null);
    assertEquals(4, a.length());
    assertEquals("foo", a.get(0));
    assertEquals("bar", a.get(1));
    assertEquals("baz", a.get(2));
    assertEquals(null, a.get(3));
  }

  public void testHashCode() {

    JavaScriptObject jso = makeJSO();
    int jsoHashCode = jso.hashCode();
    Foo foo = makeFoo();
    Bar bar = makeBar();
    Object o = new Object() {
      @Override
      public int hashCode() {

        return 0xDEADBEEF;
      }
    };

    assertEquals(jsoHashCode, jso.hashCode());
    assertFalse(jsoHashCode == foo.hashCode());
    assertFalse(jsoHashCode == bar.hashCode());
    assertFalse(jsoHashCode == o.hashCode());
    assertFalse(foo.hashCode() == bar.hashCode());
    assertFalse(foo.hashCode() == o.hashCode());
    assertFalse(bar.hashCode() == o.hashCode());

    o = jso;
    assertEquals(jsoHashCode, o.hashCode());

    String s = "foo";
    int stringHashCode = s.hashCode();
    o = s;
    assertEquals(stringHashCode, o.hashCode());
  }

  public void testIdentity() {
    JavaScriptObject jso = makeJSO();
    assertSame(jso, jso);

    JavaScriptObject jso2 = makeJSO();
    assertNotSame(jso, jso2);

    jso2 = returnMe(jso);
    assertSame(jso, jso2);
  }

  public void testInheritance() {
    Foo foo = makeFoo();
    FooSub fooSub = (FooSub) foo;
    assertEquals("Foo", fooSub.value());
    assertEquals("Still Foo", fooSub.anotherValue());
    assertEquals("Foo", fooSub.superCall());
  }

  public void testMethodMangleClash() {
    assertEquals("funcJavaScriptObject",
        MethodMangleClash.func((JavaScriptObject) null));
    assertEquals("funcMethodMangleClash",
        MethodMangleClash.func((MethodMangleClash) null));
    assertEquals("func", new MethodMangleClash().func());
  }

  public void testOverloads() {
    Foo foo = makeFoo();
    assertEquals("func Foo", new Overloads(foo).func(foo));
    assertEquals("sFunc Foo", Overloads.sFunc(foo));

    Bar bar = makeBar();
    assertEquals("func Bar", new Overloads(bar).func(bar));
    assertEquals("sFunc Bar", Overloads.sFunc(bar));
  }

  public void testOverloadsArray() {
    Foo[][] foo = new Foo[0][0];
    assertEquals("func Foo[][]", new Overloads(foo).func(foo));
    assertEquals("sFunc Foo[][]", Overloads.sFunc(foo));

    Bar[][] bar = new Bar[0][0];
    assertEquals("func Bar[][]", new Overloads(bar).func(bar));
    assertEquals("sFunc Bar[][]", Overloads.sFunc(bar));
  }

  public native void testOverloadsArrayNative() ;

  public native void testOverloadsNative() ;

  public void testStaticAccess() {
    Foo.field = 3;
    assertEquals(3, Foo.field--);
    assertEquals("Foo2", Foo.staticValue());
    assertEquals("nativeFoo", Foo.staticNative());
    assertEquals("FooSub", Foo.staticNativeToSub());

    Bar.field = 10;
    assertEquals(11, ++Bar.field);
    assertEquals("Bar11", Bar.staticValue());
    assertEquals("nativeBar", Bar.staticNative());
  }

  public native void testStaticAccessNative() ;

  public void testStaticAccessSubclass() {
    FooSub.field = 3;
    assertEquals(3, FooSub.field--);
    assertEquals("Foo2", FooSub.staticValue());
    assertEquals("nativeFoo", FooSub.staticNative());
  }

  static JavaScriptObject someObject;
  static class JSO1 extends JavaScriptObject {
    protected JSO1() {
    }
    static native JSO1 create() ;
  }

  static class JSO2 extends JavaScriptObject {
    protected JSO2() {
    }
    static native JSO2 create() ;
  }


  static final class FinalJSO1 extends JavaScriptObject {
    protected FinalJSO1() {
    }
    static native FinalJSO1 create() ;
  }

  static final class FinalJSO2 extends JavaScriptObject {
    protected FinalJSO2() {
    }
    static native FinalJSO2 create() ;
  }

  interface I {
  }


  static class JSOImplementingI extends JavaScriptObject implements I {
    protected JSOImplementingI() {
    }
    static native I create() ;
  }


  public void testCrossCasting() {
    JSO1 jso1 = JSO1.create();
    JSO2 jso2 = JSO2.create();
    FinalJSO1 finalJso1 = FinalJSO1.create();
    FinalJSO2 finalJso2 = FinalJSO2.create();
    I i = JSOImplementingI.create();

    assertTrue(jso1 == (JSO1) (trueFn() ? jso2 : (JavaScriptObject) null));
    assertTrue(jso1 == (JSO1) (trueFn() ? i : (JavaScriptObject) null));
    assertTrue(jso1 == (JSO1) (trueFn() ? finalJso1 : (JavaScriptObject) null));
    assertTrue(jso1 == (JSO1) (trueFn() ? finalJso2 : (JavaScriptObject) null));

    assertTrue(jso2 == (JSO2) (trueFn() ? jso1 : (JavaScriptObject) null));
    assertTrue(jso2 == (JSO2) (trueFn() ? i : (JavaScriptObject) null));
    assertTrue(jso2 == (JSO2) (trueFn() ? finalJso1 : (JavaScriptObject) null));
    assertTrue(jso2 == (JSO2) (trueFn() ? finalJso2 : (JavaScriptObject) null));

    assertTrue(finalJso1 == (FinalJSO1) (trueFn() ? jso1 : (JavaScriptObject) null));
    assertTrue(finalJso1 == (FinalJSO1) (trueFn() ? i : (JavaScriptObject) null));
    assertTrue(finalJso1 == (FinalJSO1) (trueFn() ? jso2 : (JavaScriptObject) null));
    assertTrue(finalJso1 == (FinalJSO1) (trueFn() ? finalJso2 : (JavaScriptObject) null));

    assertTrue(finalJso2 == (FinalJSO2) (trueFn() ? jso1 : (JavaScriptObject) null));
    assertTrue(finalJso2 == (FinalJSO2) (trueFn() ? i : (JavaScriptObject) null));
    assertTrue(finalJso2 == (FinalJSO2) (trueFn() ? jso2 : (JavaScriptObject) null));
    assertTrue(finalJso2 == (FinalJSO2) (trueFn() ? finalJso1 : (JavaScriptObject) null));

    assertTrue(i == (I) (trueFn() ? jso1 : (JavaScriptObject) null));
    assertTrue(i == (I) (trueFn() ? jso2 : (JavaScriptObject) null));
    assertTrue(i == (I) (trueFn() ? finalJso1 : (JavaScriptObject) null));
    assertTrue(i == (I) (trueFn() ? finalJso2 : (JavaScriptObject) null));
  }

  private boolean trueFn() {
    return true;
  }
}

<code block>

package com.google.gwt.core.client.interop;

import com.google.gwt.junit.client.GWTTestCase;


public class JsFunctionTest extends GWTTestCase {

  @Override
  public String getModuleName() {
    return "com.google.gwt.core.Core";
  }


  public void testJsFunctionBasic_js() {
    MyJsFunctionInterface jsFunctionInterface = new MyJsFunctionInterface() {
      @Override
      public int foo(int a) {
        return a + 2;
      }
    };
    assertEquals(12, callAsFunction(jsFunctionInterface, 10));
  }

  public void testJsFunctionBasic_java() {
    MyJsFunctionInterface jsFunctionInterface = new MyJsFunctionInterface() {
      @Override
      public int foo(int a) {
        return a + 2;
      }
    };
    assertEquals(12, jsFunctionInterface.foo(10));
  }

  public void testJsFunctionViaFunctionMethods() {
    MyJsFunctionInterface jsFunctionInterface = new MyJsFunctionInterface() {
      @Override
      public int foo(int a) {
        return a + 2;
      }
    };
    assertEquals(12, callWithFunctionApply(jsFunctionInterface, 10));
    assertEquals(12, callWithFunctionCall(jsFunctionInterface, 10));
  }

  public void testJsFunctionSubImpl_js() {
    MySubclassOfJsFunctionInterfaceImpl impl = new MySubclassOfJsFunctionInterfaceImpl();
    assertEquals(21, callAsFunction(impl, 10));
  }

  public void testJsFunctionSubImpl_java() {
    MySubclassOfJsFunctionInterfaceImpl impl = new MySubclassOfJsFunctionInterfaceImpl();
    assertEquals(21, impl.foo(10));
  }

  public void testJsFunctionIdentity_js() {
    MyJsFunctionIdentityInterface id = new MyJsFunctionIdentityInterface() {
      @Override
      public Object identity() {
        return this;
      }
    };
    assertEquals(id, callAsFunction(id));
  }

  public void testJsFunctionIdentity_java() {
    MyJsFunctionIdentityInterface id = new MyJsFunctionIdentityInterface() {
      @Override
      public Object identity() {
        return this;
      }
    };
    assertEquals(id, id.identity());
  }

  public void testJsFunctionAccess() {
    MyJsFunctionInterface intf = new MyJsFunctionInterface() {
      public int publicField;
      @Override
      public int foo(int a) {
        return a;
      }
    };
    JsTypeTest.assertJsTypeDoesntHaveFields(intf, "foo");
    JsTypeTest.assertJsTypeDoesntHaveFields(intf, "publicField");
  }

  public void testJsFunctionCallFromAMember() {
    MyJsFunctionInterfaceImpl impl = new MyJsFunctionInterfaceImpl();
    assertEquals(16, impl.callFoo(10));
  }

  public void testJsFunctionJs2Java() {
    MyJsFunctionInterface intf = createMyJsFunction();
    assertEquals(10, intf.foo(10));
  }

  public void testJsFunctionSuccessiveCalls() {
    assertEquals(12, new MyJsFunctionInterface() {
      @Override
      public int foo(int a) {
        return a + 2;
      }
    }.foo(10));
    assertEquals(10, createMyJsFunction().foo(10));
  }

  public void testJsFunctionCallbackPattern() {
    MyClassAcceptsJsFunctionAsCallBack c = new MyClassAcceptsJsFunctionAsCallBack();
    c.setCallBack(createMyJsFunction());
    assertEquals(10, c.triggerCallBack(10));
  }

  public void testJsFunctionReferentialIntegrity() {
    MyJsFunctionIdentityInterface intf = createReferentialFunction();
    assertEquals(intf, intf.identity());
  }

  public void testCast_fromJsFunction() {
    MyJsFunctionInterface c1 = (MyJsFunctionInterface) createFunction();
    assertNotNull(c1);
    MyJsFunctionIdentityInterface c2 = (MyJsFunctionIdentityInterface) createFunction();
    assertNotNull(c2);
    ElementLikeJsInterface i = (ElementLikeJsInterface) createFunction();
    assertNotNull(i);
    try {
      MyJsFunctionInterfaceImpl c3 = (MyJsFunctionInterfaceImpl) createFunction();
      assertNotNull(c3);
      fail("ClassCastException should be caught.");
    } catch (ClassCastException cce) {

    }
  }

  public void testCast_fromJsObject() {
    ElementLikeJsInterface obj = (ElementLikeJsInterface) createObject();
    assertNotNull(obj);
    try {
      MyJsFunctionInterface c = (MyJsFunctionInterface) createObject();
      assertNotNull(c);
      fail("ClassCastException should be caught.");
    } catch (ClassCastException cce) {

    }
    try {
      MyJsFunctionInterfaceImpl c = (MyJsFunctionInterfaceImpl) createObject();
      assertNotNull(c);
      fail("ClassCastException should be caught.");
    } catch (ClassCastException cce) {

    }
    try {
      MyJsFunctionIdentityInterface c = (MyJsFunctionIdentityInterface) createObject();
      assertNotNull(c);
      fail("ClassCastException should be caught.");
    } catch (ClassCastException cce) {

    }
  }

  public void testCast_inJava() {
    Object object = alwaysTrue() ? new MyJsFunctionInterfaceImpl() : new Object();
    MyJsFunctionInterface c1 = (MyJsFunctionInterface) object;
    assertNotNull(c1);
    MyJsFunctionInterfaceImpl c2 = (MyJsFunctionInterfaceImpl) c1;
    assertEquals(10, c2.publicField);
    MyJsFunctionInterfaceImpl c3 = (MyJsFunctionInterfaceImpl) object;
    assertNotNull(c3);
    MyJsFunctionIdentityInterface c4 = (MyJsFunctionIdentityInterface) object;
    assertNotNull(c4);
    ElementLikeJsInterface c5 = (ElementLikeJsInterface) object;
    assertNotNull(c5);
  }

  public void testCast_crossCastJavaInstance() {
    Object o = alwaysTrue() ? new MyJsFunctionInterfaceImpl() : new Object();
    assertEquals(11, ((MyOtherJsFunctionInterface) o).bar(10));
    assertSame((MyJsFunctionInterface) o, (MyOtherJsFunctionInterface) o);
  }

  public void testInstanceOf_jsFunction() {
    Object object = createFunction();
    assertTrue(object instanceof MyJsFunctionInterface);
    assertTrue(object instanceof MyJsFunctionIdentityInterface);
    assertTrue(object instanceof MyJsFunctionWithOnlyInstanceofReference);
    assertFalse(object instanceof MyJsFunctionInterfaceImpl);
    assertTrue(object instanceof ElementLikeJsInterface);
  }

  public void testInstanceOf_jsObject() {
    Object object = createObject();
    assertFalse(object instanceof MyJsFunctionInterface);
    assertFalse(object instanceof MyJsFunctionIdentityInterface);
    assertFalse(object instanceof MyJsFunctionWithOnlyInstanceofReference);
    assertFalse(object instanceof MyJsFunctionInterfaceImpl);
    assertTrue(object instanceof ElementLikeJsInterface);
  }

  public void testInstanceOf_javaInstance() {
    Object object = alwaysTrue() ? new MyJsFunctionInterfaceImpl() : new Object();
    assertTrue(object instanceof MyJsFunctionInterface);
    assertTrue(object instanceof MyJsFunctionInterfaceImpl);
    assertTrue(object instanceof MyJsFunctionIdentityInterface);
    assertTrue(object instanceof MyJsFunctionWithOnlyInstanceofReference);
    assertTrue(object instanceof ElementLikeJsInterface);
  }





















  private static native Object callAsFunction(Object fn) ;

  private static native int callAsFunction(Object fn, int arg) ;

  private static native int callWithFunctionApply(Object fn, int arg) ;

  private static native int callWithFunctionCall(Object fn, int arg) ;

  private static native void setField(Object object, String fieldName, int value) ;

  private static native int getField(Object object, String fieldName) ;

  private static native int callIntFunction(Object object, String functionName) ;

  private static native MyJsFunctionInterface createMyJsFunction() ;

  private static native MyJsFunctionIdentityInterface createReferentialFunction() ;

  private static native Object createFunction() ;

  private static native Object createObject() ;

  private static native boolean alwaysTrue() ;
}

<code block>

package com.google.gwt.core.client.interop;

import com.google.gwt.core.client.js.JsProperty;
import com.google.gwt.core.client.js.JsType;
import com.google.gwt.junit.client.GWTTestCase;


public class JsTypeArrayTest extends GWTTestCase {

  @Override
  public String getModuleName() {
    return "com.google.gwt.core.Core";
  }



  @JsType
  interface SimpleJsTypeReturnFromNative { }

  public void testJsTypeArray_returnFromNative() {
    SimpleJsTypeReturnFromNative[] array = returnJsTypeFromNative();
    assertEquals(2, array.length);
    assertNotNull(array[0]);
  }

  private native SimpleJsTypeReturnFromNative[] returnJsTypeFromNative() ;

  @JsType
  interface SimpleJsTypeReturnFromNativeWithACall {
    @JsProperty int getId();
  }

  public void testJsTypeArray_returnFromNativeWithACall() {
    SimpleJsTypeReturnFromNativeWithACall[] array = returnJsTypeWithIdsFromNative();
    assertEquals(2, array[1].getId());
  }

  private native SimpleJsTypeReturnFromNativeWithACall[] returnJsTypeWithIdsFromNative() ;

  @JsType
  interface SimpleJsTypeAsAField { }

  @JsType
  static class SimpleJsTypeAsAFieldHolder {
    public SimpleJsTypeAsAField[] arrayField;
  }


  public void __disabled__testJsTypeArray_asAField() {
    SimpleJsTypeAsAFieldHolder holder = new SimpleJsTypeAsAFieldHolder();
    fillArrayField(holder);
    SimpleJsTypeAsAField[] array = holder.arrayField;
    assertEquals(2, array.length);
    assertNotNull(array[0]);
  }

  private native static void fillArrayField(SimpleJsTypeAsAFieldHolder holder) ;

  @JsType
  interface SimpleJsTypeAsAParam { }

  @JsType
  static class SimpleJsTypeAsAParamHolder {
    private SimpleJsTypeAsAParam[] theParam;

    public void setArrayParam(SimpleJsTypeAsAParam[] param) {
      theParam = param;
    }
  }

  public void testJsTypeArray_asAParam() {
    SimpleJsTypeAsAParamHolder holder = new SimpleJsTypeAsAParamHolder();
    fillArrayParam(holder);
    SimpleJsTypeAsAParam[] array = holder.theParam;
    assertEquals(2, array.length);
    assertNotNull(array[0]);
  }

  private native void fillArrayParam(SimpleJsTypeAsAParamHolder holder) ;

  @JsType
  interface SimpleJsTypeReturnForMultiDimArray {
    @JsProperty int getId();
  }


  public void __disabled__testJsType3DimArray_castedFromNativeWithACall() {
    SimpleJsTypeReturnForMultiDimArray[][][] array =
        (SimpleJsTypeReturnForMultiDimArray[][][]) returnJsType3DimFromNative();
    assertEquals(1, array.length);
    assertEquals(2, array[0].length);
    assertEquals(3, array[0][0].length);
    assertEquals(1, array[0][0][0].getId());
  }

  private native Object returnJsType3DimFromNative() ;


  public void __disabled__testObjectArray_castedFromNative() {
    Object[] array = (Object[]) returnObjectArrayFromNative();
    assertEquals(3, array.length);
    assertEquals("1", array[0]);
  }

  private native Object returnObjectArrayFromNative() ;
}

<code block>

package com.google.gwt.core.client.interop;

import com.google.gwt.core.client.js.JsFunction;


@JsFunction
public interface MyJsFunctionWithOnlyInstanceofReference {
  int foo(int a);
}

<code block>






package com.google.gwt.core.client.impl;

import static com.google.gwt.core.client.impl.Coercions.ensureInt;

import java.security.MessageDigest;


public final class Md5Digest extends MessageDigest {


  static byte padding[] = {
      (byte) 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};


  public static byte[] toBytes(long n) {
    byte[] b = new byte[8];

    b[0] = (byte) (n);
    n >>>= 8;
    b[1] = (byte) (n);
    n >>>= 8;
    b[2] = (byte) (n);
    n >>>= 8;
    b[3] = (byte) (n);
    n >>>= 8;
    b[4] = (byte) (n);
    n >>>= 8;
    b[5] = (byte) (n);
    n >>>= 8;
    b[6] = (byte) (n);
    n >>>= 8;
    b[7] = (byte) (n);

    return b;
  }


  private static void byte2int(byte[] in, int[] out) {
    for (int inpos = 0, outpos = 0; outpos < 16; outpos++) {
      out[outpos] = ((in[inpos++] & 0xff) | ((in[inpos++] & 0xff) << 8)
          | ((in[inpos++] & 0xff) << 16) | ((in[inpos++] & 0xff) << 24));
    }
  }


  private static int f(int x, int y, int z) {
    return (z ^ (x & (y ^ z)));
  }


  private static int ff(int a, int b, int c, int d, int x, int s, int ac) {
    a += x + ac + f(b, c, d);
    a = (a << s | a >>> -s);
    return a + b;
  }


  private static int g(int x, int y, int z) {
    return (y ^ (z & (x ^ y)));
  }


  private static int gg(int a, int b, int c, int d, int x, int s, int ac) {
    a += x + ac + g(b, c, d);
    a = (a << s | a >>> -s);
    return a + b;
  }


  private static int h(int x, int y, int z) {
    return (x ^ y ^ z);
  }


  private static int hh(int a, int b, int c, int d, int x, int s, int ac) {
    a += x + ac + h(b, c, d);
    a = (a << s | a >>> -s);
    return a + b;
  }


  private static int i(int x, int y, int z) {
    return (y ^ (x | ~z));
  }


  private static int ii(int a, int b, int c, int d, int x, int s, int ac) {
    a += x + ac + i(b, c, d);
    a = (a << s | a >>> -s);
    return a + b;
  }


  private static void int2byte(int[] in, byte[] out) {
    for (int inpos = 0, outpos = 0; inpos < 4; inpos++) {
      out[outpos++] = (byte) (in[inpos] & 0xff);
      out[outpos++] = (byte) ((in[inpos] >>> 8) & 0xff);
      out[outpos++] = (byte) ((in[inpos] >>> 16) & 0xff);
      out[outpos++] = (byte) ((in[inpos] >>> 24) & 0xff);
    }
  }

  private byte buffer[];


  private long counter;

  private final byte[] oneByte = new byte[1];

  private int remainder;

  private int state[];

  private int x[];

  public Md5Digest() {
    super("MD5");
    engineReset();
  }

  @Override
  protected byte[] engineDigest() {
    byte[] bits = toBytes(counter << 3);
    byte[] digest = new byte[16];

    if (remainder > 8) {
      engineUpdate(padding, 0, remainder - 8);
    } else {
      engineUpdate(padding, 0, 64 + (remainder - 8));
    }

    engineUpdate(bits, 0, 8);

    int2byte(state, digest);

    this.reset();
    return digest;
  }

  @Override
  protected int engineGetDigestLength() {
    return 16;
  }

  @Override
  protected void engineReset() {
    buffer = new byte[64];
    state = new int[4];
    x = new int[16];

    state[0] = 0x67452301;
    state[1] = 0xefcdab89;
    state[2] = 0x98badcfe;
    state[3] = 0x10325476;

    counter = 0;
    remainder = 64;
  }

  @Override
  protected void engineUpdate(byte input) {

    oneByte [0] = input;
    engineUpdate(oneByte, 0, 1);
  }

  @Override
  protected void engineUpdate(byte[] input, int offset, int len) {
    while (true) {
      if (len >= remainder) {
        System.arraycopy(input, offset, buffer, (int) (counter & 63L),
            remainder);
        transform(buffer);
        counter += remainder;
        offset += remainder;
        len -= remainder;
        remainder = 64;
      } else {
        System.arraycopy(input, offset, buffer, (int) (counter & 63L), len);
        counter += len;
        remainder -= len;
        break;
      }
    }
  }


  private void transform(byte[] buffer) {
    int a, b, c, d;

    byte2int(buffer, x);

    a = state[0];
    b = state[1];
    c = state[2];
    d = state[3];

    a = ff(a, b, c, d, x[0], 7, 0xd76aa478);
    d = ff(d, a, b, c, x[1], 12, 0xe8c7b756);
    c = ff(c, d, a, b, x[2], 17, 0x242070db);
    b = ff(b, c, d, a, x[3], 22, 0xc1bdceee);
    a = ff(a, b, c, d, x[4], 7, 0xf57c0faf);
    d = ff(d, a, b, c, x[5], 12, 0x4787c62a);
    c = ff(c, d, a, b, x[6], 17, 0xa8304613);
    b = ff(b, c, d, a, x[7], 22, 0xfd469501);
    a = ff(a, b, c, d, x[8], 7, 0x698098d8);
    d = ff(d, a, b, c, x[9], 12, 0x8b44f7af);
    c = ff(c, d, a, b, x[10], 17, 0xffff5bb1);
    b = ff(b, c, d, a, x[11], 22, 0x895cd7be);
    a = ff(a, b, c, d, x[12], 7, 0x6b901122);
    d = ff(d, a, b, c, x[13], 12, 0xfd987193);
    c = ff(c, d, a, b, x[14], 17, 0xa679438e);
    b = ff(b, c, d, a, x[15], 22, 0x49b40821);

    a = gg(a, b, c, d, x[1], 5, 0xf61e2562);
    d = gg(d, a, b, c, x[6], 9, 0xc040b340);
    c = gg(c, d, a, b, x[11], 14, 0x265e5a51);
    b = gg(b, c, d, a, x[0], 20, 0xe9b6c7aa);
    a = gg(a, b, c, d, x[5], 5, 0xd62f105d);
    d = gg(d, a, b, c, x[10], 9, 0x2441453);
    c = gg(c, d, a, b, x[15], 14, 0xd8a1e681);
    b = gg(b, c, d, a, x[4], 20, 0xe7d3fbc8);
    a = gg(a, b, c, d, x[9], 5, 0x21e1cde6);
    d = gg(d, a, b, c, x[14], 9, 0xc33707d6);
    c = gg(c, d, a, b, x[3], 14, 0xf4d50d87);
    b = gg(b, c, d, a, x[8], 20, 0x455a14ed);
    a = gg(a, b, c, d, x[13], 5, 0xa9e3e905);
    d = gg(d, a, b, c, x[2], 9, 0xfcefa3f8);
    c = gg(c, d, a, b, x[7], 14, 0x676f02d9);
    b = gg(b, c, d, a, x[12], 20, 0x8d2a4c8a);

    a = hh(a, b, c, d, x[5], 4, 0xfffa3942);
    d = hh(d, a, b, c, x[8], 11, 0x8771f681);
    c = hh(c, d, a, b, x[11], 16, 0x6d9d6122);
    b = hh(b, c, d, a, x[14], 23, 0xfde5380c);
    a = hh(a, b, c, d, x[1], 4, 0xa4beea44);
    d = hh(d, a, b, c, x[4], 11, 0x4bdecfa9);
    c = hh(c, d, a, b, x[7], 16, 0xf6bb4b60);
    b = hh(b, c, d, a, x[10], 23, 0xbebfbc70);
    a = hh(a, b, c, d, x[13], 4, 0x289b7ec6);
    d = hh(d, a, b, c, x[0], 11, 0xeaa127fa);
    c = hh(c, d, a, b, x[3], 16, 0xd4ef3085);
    b = hh(b, c, d, a, x[6], 23, 0x4881d05);
    a = hh(a, b, c, d, x[9], 4, 0xd9d4d039);
    d = hh(d, a, b, c, x[12], 11, 0xe6db99e5);
    c = hh(c, d, a, b, x[15], 16, 0x1fa27cf8);
    b = hh(b, c, d, a, x[2], 23, 0xc4ac5665);

    a = ii(a, b, c, d, x[0], 6, 0xf4292244);
    d = ii(d, a, b, c, x[7], 10, 0x432aff97);
    c = ii(c, d, a, b, x[14], 15, 0xab9423a7);
    b = ii(b, c, d, a, x[5], 21, 0xfc93a039);
    a = ii(a, b, c, d, x[12], 6, 0x655b59c3);
    d = ii(d, a, b, c, x[3], 10, 0x8f0ccc92);
    c = ii(c, d, a, b, x[10], 15, 0xffeff47d);
    b = ii(b, c, d, a, x[1], 21, 0x85845dd1);
    a = ii(a, b, c, d, x[8], 6, 0x6fa87e4f);
    d = ii(d, a, b, c, x[15], 10, 0xfe2ce6e0);
    c = ii(c, d, a, b, x[6], 15, 0xa3014314);
    b = ii(b, c, d, a, x[13], 21, 0x4e0811a1);
    a = ii(a, b, c, d, x[4], 6, 0xf7537e82);
    d = ii(d, a, b, c, x[11], 10, 0xbd3af235);
    c = ii(c, d, a, b, x[2], 15, 0x2ad7d2bb);
    b = ii(b, c, d, a, x[9], 21, 0xeb86d391);


    state[0] = ensureInt(state[0] + a);
    state[1] = ensureInt(state[1] + b);
    state[2] = ensureInt(state[2] + c);
    state[3] = ensureInt(state[3] + d);
  }
}

<code block>

package java.security;

import com.google.gwt.core.client.impl.Md5Digest;


public abstract class MessageDigest extends MessageDigestSpi {

  public static MessageDigest getInstance(String algorithm)
      throws NoSuchAlgorithmException {
    if ("MD5".equals(algorithm)) {
      return new Md5Digest();
    }
    throw new NoSuchAlgorithmException(algorithm + " not supported");
  }

  public static boolean isEqual(byte[] digestA, byte[] digestB) {
    int n = digestA.length;
    if (n != digestB.length) {
      return false;
    }
    for (int i = 0; i < n; ++i) {
      if (digestA[i] != digestB[i]) {
        return false;
      }
    }
    return true;
  }

  private final String algorithm;

  protected MessageDigest(String algorithm) {
    this.algorithm = algorithm;
  }

  public byte[] digest() {
    return engineDigest();
  }

  public byte[] digest(byte[] input) {
    update(input);
    return digest();
  }

  public int digest(byte[] buf, int offset, int len) throws DigestException {
    return engineDigest(buf, offset, len);
  }

  public final String getAlgorithm() {
    return algorithm;
  }

  public final int getDigestLength() {
    return engineGetDigestLength();
  }

  public void reset() {
    engineReset();
  }

  public void update(byte input) {
    engineUpdate(input);
  }

  public void update(byte[] input) {
    engineUpdate(input, 0, input.length);
  }

  public void update(byte[] input, int offset, int len) {
    engineUpdate(input, offset, len);
  }
}

<code block>

package java.security;

import static com.google.gwt.core.client.impl.Coercions.ensureInt;


public abstract class MessageDigest extends MessageDigestSpi {

  private static class Md5Digest extends MessageDigest {


    static byte padding[] = {
        (byte) 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};


    public static byte[] toBytes(long n) {
      byte[] b = new byte[8];

      b[0] = (byte) (n);
      n >>>= 8;
      b[1] = (byte) (n);
      n >>>= 8;
      b[2] = (byte) (n);
      n >>>= 8;
      b[3] = (byte) (n);
      n >>>= 8;
      b[4] = (byte) (n);
      n >>>= 8;
      b[5] = (byte) (n);
      n >>>= 8;
      b[6] = (byte) (n);
      n >>>= 8;
      b[7] = (byte) (n);

      return b;
    }


    private static void byte2int(byte[] in, int[] out) {
      for (int inpos = 0, outpos = 0; outpos < 16; outpos++) {
        out[outpos] = ((in[inpos++] & 0xff) | ((in[inpos++] & 0xff) << 8)
            | ((in[inpos++] & 0xff) << 16) | ((in[inpos++] & 0xff) << 24));
      }
    }


    private static int f(int x, int y, int z) {
      return (z ^ (x & (y ^ z)));
    }


    private static int ff(int a, int b, int c, int d, int x, int s, int ac) {
      a += x + ac + f(b, c, d);
      a = (a << s | a >>> -s);
      return a + b;
    }


    private static int g(int x, int y, int z) {
      return (y ^ (z & (x ^ y)));
    }


    private static int gg(int a, int b, int c, int d, int x, int s, int ac) {
      a += x + ac + g(b, c, d);
      a = (a << s | a >>> -s);
      return a + b;
    }


    private static int h(int x, int y, int z) {
      return (x ^ y ^ z);
    }


    private static int hh(int a, int b, int c, int d, int x, int s, int ac) {
      a += x + ac + h(b, c, d);
      a = (a << s | a >>> -s);
      return a + b;
    }


    private static int i(int x, int y, int z) {
      return (y ^ (x | ~z));
    }


    private static int ii(int a, int b, int c, int d, int x, int s, int ac) {
      a += x + ac + i(b, c, d);
      a = (a << s | a >>> -s);
      return a + b;
    }


    private static void int2byte(int[] in, byte[] out) {
      for (int inpos = 0, outpos = 0; inpos < 4; inpos++) {
        out[outpos++] = (byte) (in[inpos] & 0xff);
        out[outpos++] = (byte) ((in[inpos] >>> 8) & 0xff);
        out[outpos++] = (byte) ((in[inpos] >>> 16) & 0xff);
        out[outpos++] = (byte) ((in[inpos] >>> 24) & 0xff);
      }
    }

    private byte buffer[];


    private long counter;

    private final byte[] oneByte = new byte[1];

    private int remainder;

    private int state[];

    private int x[];

    public Md5Digest() {
      super("MD5");
      engineReset();
    }

    @Override
    protected byte[] engineDigest() {
      byte[] bits = toBytes(counter << 3);
      byte[] digest = new byte[16];

      if (remainder > 8) {
        engineUpdate(padding, 0, remainder - 8);
      } else {
        engineUpdate(padding, 0, 64 + (remainder - 8));
      }

      engineUpdate(bits, 0, 8);

      int2byte(state, digest);

      this.reset();
      return digest;
    }

    @Override
    protected int engineGetDigestLength() {
      return 16;
    }

    @Override
    protected void engineReset() {
      buffer = new byte[64];
      state = new int[4];
      x = new int[16];

      state[0] = 0x67452301;
      state[1] = 0xefcdab89;
      state[2] = 0x98badcfe;
      state[3] = 0x10325476;

      counter = 0;
      remainder = 64;
    }

    @Override
    protected void engineUpdate(byte input) {

      oneByte [0] = input;
      engineUpdate(oneByte, 0, 1);
    }

    @Override
    protected void engineUpdate(byte[] input, int offset, int len) {
      while (true) {
        if (len >= remainder) {
          System.arraycopy(input, offset, buffer, (int) (counter & 63L),
              remainder);
          transform(buffer);
          counter += remainder;
          offset += remainder;
          len -= remainder;
          remainder = 64;
        } else {
          System.arraycopy(input, offset, buffer, (int) (counter & 63L), len);
          counter += len;
          remainder -= len;
          break;
        }
      }
    }


    private void transform(byte[] buffer) {
      int a, b, c, d;

      byte2int(buffer, x);

      a = state[0];
      b = state[1];
      c = state[2];
      d = state[3];

      a = ff(a, b, c, d, x[0], 7, 0xd76aa478);
      d = ff(d, a, b, c, x[1], 12, 0xe8c7b756);
      c = ff(c, d, a, b, x[2], 17, 0x242070db);
      b = ff(b, c, d, a, x[3], 22, 0xc1bdceee);
      a = ff(a, b, c, d, x[4], 7, 0xf57c0faf);
      d = ff(d, a, b, c, x[5], 12, 0x4787c62a);
      c = ff(c, d, a, b, x[6], 17, 0xa8304613);
      b = ff(b, c, d, a, x[7], 22, 0xfd469501);
      a = ff(a, b, c, d, x[8], 7, 0x698098d8);
      d = ff(d, a, b, c, x[9], 12, 0x8b44f7af);
      c = ff(c, d, a, b, x[10], 17, 0xffff5bb1);
      b = ff(b, c, d, a, x[11], 22, 0x895cd7be);
      a = ff(a, b, c, d, x[12], 7, 0x6b901122);
      d = ff(d, a, b, c, x[13], 12, 0xfd987193);
      c = ff(c, d, a, b, x[14], 17, 0xa679438e);
      b = ff(b, c, d, a, x[15], 22, 0x49b40821);

      a = gg(a, b, c, d, x[1], 5, 0xf61e2562);
      d = gg(d, a, b, c, x[6], 9, 0xc040b340);
      c = gg(c, d, a, b, x[11], 14, 0x265e5a51);
      b = gg(b, c, d, a, x[0], 20, 0xe9b6c7aa);
      a = gg(a, b, c, d, x[5], 5, 0xd62f105d);
      d = gg(d, a, b, c, x[10], 9, 0x2441453);
      c = gg(c, d, a, b, x[15], 14, 0xd8a1e681);
      b = gg(b, c, d, a, x[4], 20, 0xe7d3fbc8);
      a = gg(a, b, c, d, x[9], 5, 0x21e1cde6);
      d = gg(d, a, b, c, x[14], 9, 0xc33707d6);
      c = gg(c, d, a, b, x[3], 14, 0xf4d50d87);
      b = gg(b, c, d, a, x[8], 20, 0x455a14ed);
      a = gg(a, b, c, d, x[13], 5, 0xa9e3e905);
      d = gg(d, a, b, c, x[2], 9, 0xfcefa3f8);
      c = gg(c, d, a, b, x[7], 14, 0x676f02d9);
      b = gg(b, c, d, a, x[12], 20, 0x8d2a4c8a);

      a = hh(a, b, c, d, x[5], 4, 0xfffa3942);
      d = hh(d, a, b, c, x[8], 11, 0x8771f681);
      c = hh(c, d, a, b, x[11], 16, 0x6d9d6122);
      b = hh(b, c, d, a, x[14], 23, 0xfde5380c);
      a = hh(a, b, c, d, x[1], 4, 0xa4beea44);
      d = hh(d, a, b, c, x[4], 11, 0x4bdecfa9);
      c = hh(c, d, a, b, x[7], 16, 0xf6bb4b60);
      b = hh(b, c, d, a, x[10], 23, 0xbebfbc70);
      a = hh(a, b, c, d, x[13], 4, 0x289b7ec6);
      d = hh(d, a, b, c, x[0], 11, 0xeaa127fa);
      c = hh(c, d, a, b, x[3], 16, 0xd4ef3085);
      b = hh(b, c, d, a, x[6], 23, 0x4881d05);
      a = hh(a, b, c, d, x[9], 4, 0xd9d4d039);
      d = hh(d, a, b, c, x[12], 11, 0xe6db99e5);
      c = hh(c, d, a, b, x[15], 16, 0x1fa27cf8);
      b = hh(b, c, d, a, x[2], 23, 0xc4ac5665);

      a = ii(a, b, c, d, x[0], 6, 0xf4292244);
      d = ii(d, a, b, c, x[7], 10, 0x432aff97);
      c = ii(c, d, a, b, x[14], 15, 0xab9423a7);
      b = ii(b, c, d, a, x[5], 21, 0xfc93a039);
      a = ii(a, b, c, d, x[12], 6, 0x655b59c3);
      d = ii(d, a, b, c, x[3], 10, 0x8f0ccc92);
      c = ii(c, d, a, b, x[10], 15, 0xffeff47d);
      b = ii(b, c, d, a, x[1], 21, 0x85845dd1);
      a = ii(a, b, c, d, x[8], 6, 0x6fa87e4f);
      d = ii(d, a, b, c, x[15], 10, 0xfe2ce6e0);
      c = ii(c, d, a, b, x[6], 15, 0xa3014314);
      b = ii(b, c, d, a, x[13], 21, 0x4e0811a1);
      a = ii(a, b, c, d, x[4], 6, 0xf7537e82);
      d = ii(d, a, b, c, x[11], 10, 0xbd3af235);
      c = ii(c, d, a, b, x[2], 15, 0x2ad7d2bb);
      b = ii(b, c, d, a, x[9], 21, 0xeb86d391);


      state[0] = ensureInt(state[0] + a);
      state[1] = ensureInt(state[1] + b);
      state[2] = ensureInt(state[2] + c);
      state[3] = ensureInt(state[3] + d);
    }
  }

  public static MessageDigest getInstance(String algorithm)
      throws NoSuchAlgorithmException {
    if ("MD5".equals(algorithm)) {
      return new Md5Digest();
    }
    throw new NoSuchAlgorithmException(algorithm + " not supported");
  }

  public static boolean isEqual(byte[] digestA, byte[] digestB) {
    int n = digestA.length;
    if (n != digestB.length) {
      return false;
    }
    for (int i = 0; i < n; ++i) {
      if (digestA[i] != digestB[i]) {
        return false;
      }
    }
    return true;
  }

  private final String algorithm;

  protected MessageDigest(String algorithm) {
    this.algorithm = algorithm;
  }

  public byte[] digest() {
    return engineDigest();
  }

  public byte[] digest(byte[] input) {
    update(input);
    return digest();
  }

  public int digest(byte[] buf, int offset, int len) throws DigestException {
    return engineDigest(buf, offset, len);
  }

  public final String getAlgorithm() {
    return algorithm;
  }

  public final int getDigestLength() {
    return engineGetDigestLength();
  }

  public void reset() {
    engineReset();
  }

  public void update(byte input) {
    engineUpdate(input);
  }

  public void update(byte[] input) {
    engineUpdate(input, 0, input.length);
  }

  public void update(byte[] input, int offset, int len) {
    engineUpdate(input, offset, len);
  }
}

<code block>

package com.google.gwt.user.cellview.client;

import com.google.gwt.cell.client.Cell.Context;
import com.google.gwt.cell.client.HasCell;
import com.google.gwt.dom.builder.shared.ElementBuilderBase;
import com.google.gwt.dom.builder.shared.HtmlBuilderFactory;
import com.google.gwt.dom.builder.shared.HtmlTableSectionBuilder;
import com.google.gwt.dom.builder.shared.TableRowBuilder;
import com.google.gwt.dom.builder.shared.TableSectionBuilder;
import com.google.gwt.dom.client.Document;
import com.google.gwt.dom.client.Element;
import com.google.gwt.dom.client.TableRowElement;
import com.google.gwt.safehtml.shared.SafeHtmlBuilder;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;


public abstract class AbstractCellTableBuilder<T> implements CellTableBuilder<T> {
  

  private static final String CELL_ATTRIBUTE = "__gwt_cell";
  

  private static final String ROW_ATTRIBUTE = "__gwt_row";


  private static final String SUBROW_ATTRIBUTE = "__gwt_subrow";
  
  protected final AbstractCellTable<T> cellTable;
  

  private final Map<String, HasCell<T, ?>> idToCellMap = new HashMap<String, HasCell<T, ?>>();
  private final Map<HasCell<T, ?>, String> cellToIdMap = new HashMap<HasCell<T, ?>, String>();

  private HtmlTableSectionBuilder tbody;  
  private int rowIndex;
  private int subrowIndex;
  private Object rowValueKey;


  public AbstractCellTableBuilder(AbstractCellTable<T> cellTable) {
    this.cellTable = cellTable;
  }
  

  @Override
  public final void buildRow(T rowValue, int absRowIndex) {
    setRowInfo(absRowIndex, rowValue);
    buildRowImpl(rowValue, absRowIndex);
  }
  

  public final Context createContext(int column) {
    return new Context(rowIndex, column, rowValueKey, subrowIndex);
  }
  

  @Override
  public final TableSectionBuilder finish() {

    while (tbody.getDepth() > 0) {
      tbody.endTBody();
    }
    return tbody;
  }
  

  @Override
  public final HasCell<T, ?> getColumn(Context context, T rowValue, Element elem) {
    return getColumn(elem);
  }


  @Override
  public final Collection<HasCell<T, ?>> getColumns() {
    return idToCellMap.values();
  }
  

  @Override
  public final int getRowValueIndex(TableRowElement row) {
    try {
      return Integer.parseInt(row.getAttribute(ROW_ATTRIBUTE));
    } catch (NumberFormatException e) {


      return row.getSectionRowIndex() + cellTable.getPageStart();
    }
  }
  

  @Override
  public final int getSubrowValueIndex(TableRowElement row) {
    try {
      return Integer.parseInt(row.getAttribute(SUBROW_ATTRIBUTE));
    } catch (NumberFormatException e) {


      return 0;
    }
  }
  

  @Override
  public final boolean isColumn(Element elem) {
    return getCellId(elem) != null;
  }
  

  public final <C> void renderCell(ElementBuilderBase<?> builder, Context context,
      HasCell<T, C> column, T rowValue) {

    String cellId = cellToIdMap.get(column);
    if (cellId == null) {
      cellId = "cell-" + Document.get().createUniqueId();
      idToCellMap.put(cellId, column);
      cellToIdMap.put(column, cellId);
    }
    builder.attribute(CELL_ATTRIBUTE, cellId);


    SafeHtmlBuilder cellBuilder = new SafeHtmlBuilder();
    if (column instanceof Column) {

      Column<T, C> theColumn = (Column<T, C>) column;
      theColumn.render(context, rowValue, cellBuilder);
    } else {
      column.getCell().render(context, column.getValue(rowValue), cellBuilder);
    }
    builder.html(cellBuilder.toSafeHtml());
  }
  


  @Override
  public final void start(boolean isRebuildingAllRows) {

    tbody = HtmlBuilderFactory.get().createTBodyBuilder();
    if (isRebuildingAllRows) {
      cellToIdMap.clear();
      idToCellMap.clear();
    }
  }


  public final TableRowBuilder startRow() {

    while (tbody.getDepth() > 1) {
      tbody.end();
    }


    if (tbody.getDepth() < 1) {
      throw new IllegalStateException(
          "Cannot start a row.  Did you call TableRowBuilder.end() too many times?");
    }


    TableRowBuilder row = tbody.startTR();
    row.attribute(ROW_ATTRIBUTE, rowIndex);
    row.attribute(SUBROW_ATTRIBUTE, subrowIndex);
    addRowAttributes(row);
    subrowIndex++;
    return row;
  }


  protected void addRowAttributes(TableRowBuilder row) {
  }


  protected abstract void buildRowImpl(T rowValue, int absRowIndex);
  

  private String getCellId(Element elem) {
    if (elem == null) {
      return null;
    }
    String cellId = elem.getAttribute(CELL_ATTRIBUTE);
    return (cellId == null) || (cellId.length() == 0) ? null : cellId;
  }


  private HasCell<T, ?> getColumn(Element elem) {
    String cellId = getCellId(elem);
    return (cellId == null) ? null : idToCellMap.get(cellId);
  }


  private void setRowInfo(int rowIndex, T rowValue) {
    this.rowIndex = rowIndex;
    this.rowValueKey = cellTable.getValueKey(rowValue);
    this.subrowIndex = 0; 
  }
}

<code block>

package com.google.gwt.user.cellview.client;

import com.google.gwt.cell.client.Cell.Context;
import com.google.gwt.dom.builder.shared.DivBuilder;
import com.google.gwt.dom.builder.shared.TableCellBuilder;
import com.google.gwt.dom.builder.shared.TableRowBuilder;
import com.google.gwt.dom.client.Style.OutlineStyle;
import com.google.gwt.user.cellview.client.AbstractCellTable.Style;
import com.google.gwt.user.client.ui.HasHorizontalAlignment.HorizontalAlignmentConstant;
import com.google.gwt.user.client.ui.HasVerticalAlignment.VerticalAlignmentConstant;
import com.google.gwt.view.client.SelectionModel;


public class DefaultCellTableBuilder<T> extends AbstractCellTableBuilder<T> {

  private final String evenRowStyle;
  private final String oddRowStyle;
  private final String selectedRowStyle;
  private final String cellStyle;
  private final String evenCellStyle;
  private final String oddCellStyle;
  private final String firstColumnStyle;
  private final String lastColumnStyle;
  private final String selectedCellStyle;

  public DefaultCellTableBuilder(AbstractCellTable<T> cellTable) {
    super(cellTable);


    Style style = cellTable.getResources().style();
    evenRowStyle = style.evenRow();
    oddRowStyle = style.oddRow();
    selectedRowStyle = " " + style.selectedRow();
    cellStyle = style.cell();
    evenCellStyle = " " + style.evenRowCell();
    oddCellStyle = " " + style.oddRowCell();
    firstColumnStyle = " " + style.firstColumn();
    lastColumnStyle = " " + style.lastColumn();
    selectedCellStyle = " " + style.selectedRowCell();
  }

  @Override
  public void buildRowImpl(T rowValue, int absRowIndex) {


    SelectionModel<? super T> selectionModel = cellTable.getSelectionModel();
    boolean isSelected =
        (selectionModel == null || rowValue == null) ? false : selectionModel.isSelected(rowValue);
    boolean isEven = absRowIndex % 2 == 0;
    StringBuilder trClasses = new StringBuilder(isEven ? evenRowStyle : oddRowStyle);
    if (isSelected) {
      trClasses.append(selectedRowStyle);
    }


    RowStyles<T> rowStyles = cellTable.getRowStyles();
    if (rowStyles != null) {
      String extraRowStyles = rowStyles.getStyleNames(rowValue, absRowIndex);
      if (extraRowStyles != null) {
        trClasses.append(" ").append(extraRowStyles);
      }
    }


    TableRowBuilder tr = startRow();
    tr.className(trClasses.toString());


    int columnCount = cellTable.getColumnCount();
    for (int curColumn = 0; curColumn < columnCount; curColumn++) {
      Column<T, ?> column = cellTable.getColumn(curColumn);

      StringBuilder tdClasses = new StringBuilder(cellStyle);
      tdClasses.append(isEven ? evenCellStyle : oddCellStyle);
      if (curColumn == 0) {
        tdClasses.append(firstColumnStyle);
      }
      if (isSelected) {
        tdClasses.append(selectedCellStyle);
      }

      if (curColumn == columnCount - 1) {
        tdClasses.append(lastColumnStyle);
      }


      Context context = new Context(absRowIndex, curColumn, cellTable.getValueKey(rowValue));
      String cellStyles = column.getCellStyleNames(context, rowValue);
      if (cellStyles != null) {
        tdClasses.append(" " + cellStyles);
      }


      HorizontalAlignmentConstant hAlign = column.getHorizontalAlignment();
      VerticalAlignmentConstant vAlign = column.getVerticalAlignment();
      TableCellBuilder td = tr.startTD();
      td.className(tdClasses.toString());
      if (hAlign != null) {
        td.align(hAlign.getTextAlignString());
      }
      if (vAlign != null) {
        td.vAlign(vAlign.getVerticalAlignString());
      }
      addCellAttributes(td);


      DivBuilder div = td.startDiv();
      div.style().outlineStyle(OutlineStyle.NONE).endStyle();


      renderCell(div, context, column, rowValue);


      div.endDiv();
      td.endTD();
    }


    tr.endTR();
  }


  protected void addCellAttributes(TableCellBuilder cell) {
  }
}

<code block>

package com.google.gwt.user.cellview.client;

import com.google.gwt.cell.client.AbstractCell;
import com.google.gwt.cell.client.Cell;
import com.google.gwt.cell.client.Cell.Context;
import com.google.gwt.cell.client.TextCell;
import com.google.gwt.dom.builder.shared.TableRowBuilder;
import com.google.gwt.dom.client.Document;
import com.google.gwt.dom.client.NativeEvent;
import com.google.gwt.dom.client.NodeList;
import com.google.gwt.dom.client.Style.Unit;
import com.google.gwt.dom.client.TableCellElement;
import com.google.gwt.dom.client.TableRowElement;
import com.google.gwt.dom.client.TableSectionElement;
import com.google.gwt.event.dom.client.KeyCodes;
import com.google.gwt.safehtml.shared.SafeHtmlBuilder;
import com.google.gwt.user.cellview.client.AbstractHasData.DefaultKeyboardSelectionHandler;
import com.google.gwt.user.cellview.client.HasKeyboardPagingPolicy.KeyboardPagingPolicy;
import com.google.gwt.user.cellview.client.LoadingStateChangeEvent.LoadingState;
import com.google.gwt.user.client.ui.HasHorizontalAlignment;
import com.google.gwt.user.client.ui.HasVerticalAlignment;
import com.google.gwt.user.client.ui.Label;
import com.google.gwt.user.client.ui.RootPanel;
import com.google.gwt.view.client.Range;

import java.util.ArrayList;
import java.util.List;


public abstract class AbstractCellTableTestBase<T extends AbstractCellTable<String>> extends
    AbstractHasDataTestBase {


  private static class MockColumn<T, C> extends Column<T, C> {

    public MockColumn() {
      super(new AbstractCell<C>() {
        @Override
        public void render(Context context, C value, SafeHtmlBuilder sb) {
        }
      });
    }

    @Override
    public C getValue(T object) {
      return null;
    }
  }


  public void testAddColumnSingleRedraw() {
    final List<LoadingState> loadingStates = new ArrayList<LoadingState>();
    T table = createAbstractHasData();
    table.setPageSize(10);
    table.addLoadingStateChangeHandler(new LoadingStateChangeEvent.Handler() {
      @Override
      public void onLoadingStateChanged(LoadingStateChangeEvent event) {
        if (LoadingState.LOADED == event.getLoadingState()) {
          loadingStates.add(event.getLoadingState());
        }
      }
    });
    table.addColumn(new Column<String, String>(new TextCell()) {
      @Override
      public String getValue(String object) {
        return object + "-3";
      }
    });
    table.addColumn(new Column<String, String>(new TextCell()) {
      @Override
      public String getValue(String object) {
        return object + "-4";
      }
    });
    table.setRowData(0, createData(0, 10));
    table.getPresenter().flush();
    assertEquals(1, loadingStates.size());
  }


  public void testBuildTooManyEnds() {
    final List<Integer> builtRows = new ArrayList<Integer>();
    T table = createAbstractHasData(new TextCell());
    CellTableBuilder<String> builder = new DefaultCellTableBuilder<String>(table) {
      @Override
      public void buildRowImpl(String rowValue, int absRowIndex) {
        builtRows.add(absRowIndex);
        TableRowBuilder tr = startRow();
        tr.endTR(); 
        tr.end(); 


        try {
          startRow();
          fail("Expected IllegalStateException: tbody is already ended");
        } catch (IllegalStateException e) {

        }
      }
    };
    table.setTableBuilder(builder);
    table.setVisibleRange(0, 1);
    populateData(table);
    table.getPresenter().flush();

    assertEquals(1, builtRows.size());
    assertEquals(0, builtRows.get(0).intValue());
  }


  public void testBuildMultipleRows() {
    T table = createAbstractHasData(new TextCell());
    CellTableBuilder<String> builder = new DefaultCellTableBuilder<String>(table) {
      @Override
      public void buildRowImpl(String rowValue, int absRowIndex) {
        super.buildRowImpl(rowValue, absRowIndex);


        if (absRowIndex == 5) {
          for (int i = 0; i < 4; i++) {
            TableRowBuilder tr = startRow();
            tr.startTD().colSpan(2).text("child " + i).endTD();
            tr.endTR();
          }
        }
      }
    };
    table.setTableBuilder(builder);
    table.setVisibleRange(0, 10);
    populateData(table);
    table.getPresenter().flush();


    TableSectionElement tbody = table.getTableBodyElement();
    assertEquals(14, tbody.getChildCount());
    assertEquals("child 0", getBodyElement(table, 6, 0).getInnerText());
    assertEquals("child 1", getBodyElement(table, 7, 0).getInnerText());
    assertEquals("child 2", getBodyElement(table, 8, 0).getInnerText());
    assertEquals("child 3", getBodyElement(table, 9, 0).getInnerText());


    assertEquals("test 5", table.getVisibleItem(5));
    assertEquals("test 9", table.getVisibleItem(9));


    assertEquals(4, table.getChildElement(4).getSectionRowIndex());
    assertEquals(5, table.getChildElement(5).getSectionRowIndex());
    assertEquals(10, table.getChildElement(6).getSectionRowIndex());
  }


  public void testBuildZeroRows() {
    T table = createAbstractHasData(new TextCell());
    CellTableBuilder<String> builder = new DefaultCellTableBuilder<String>(table) {
      @Override
      public void buildRowImpl(String rowValue, int absRowIndex) {

        if (absRowIndex != 5) {
          super.buildRowImpl(rowValue, absRowIndex);
        }
      }
    };
    table.setTableBuilder(builder);
    table.setVisibleRange(0, 10);
    populateData(table);
    table.getPresenter().flush();


    TableSectionElement tbody = table.getTableBodyElement();
    assertEquals(9, tbody.getChildCount());


    assertEquals("test 5", table.getVisibleItem(5));
    assertEquals("test 9", table.getVisibleItem(9));


    assertEquals(4, table.getChildElement(4).getSectionRowIndex());
    assertNull(table.getChildElement(5));
    assertEquals(5, table.getChildElement(6).getSectionRowIndex());
  }

  public void testCellAlignment() {
    T table = createAbstractHasData(new TextCell());
    Column<String, String> column = new Column<String, String>(new TextCell()) {
      @Override
      public String getValue(String object) {
        return object;
      }
    };
    table.addColumn(column);


    table.setRowData(0, createData(0, 1));
    table.getPresenter().flush();
    TableCellElement td = getBodyElement(table, 0, 2);
    String hAlign = td.getAlign();
    String vAlign = td.getVAlign();
    assertTrue("".equals(hAlign) || "left".equals(hAlign));
    assertTrue("".equals(vAlign) || "middle".equals(vAlign));


    column.setHorizontalAlignment(HasHorizontalAlignment.ALIGN_RIGHT);
    table.setRowData(0, createData(0, 1));
    table.getPresenter().flush();
    td = getBodyElement(table, 0, 2);
    hAlign = td.getAlign();
    vAlign = td.getVAlign();
    assertTrue("right".equals(hAlign));
    assertTrue("".equals(vAlign) || "middle".equals(vAlign));


    column.setHorizontalAlignment(null);
    column.setVerticalAlignment(HasVerticalAlignment.ALIGN_BOTTOM);
    table.setRowData(0, createData(0, 1));
    table.getPresenter().flush();
    td = getBodyElement(table, 0, 2);
    hAlign = td.getAlign();
    vAlign = td.getVAlign();
    assertTrue("".equals(hAlign) || "left".equals(hAlign));
    assertTrue("bottom".equals(vAlign));


    column.setHorizontalAlignment(HasHorizontalAlignment.ALIGN_RIGHT);
    table.setRowData(0, createData(0, 1));
    table.getPresenter().flush();
    td = getBodyElement(table, 0, 2);
    hAlign = td.getAlign();
    vAlign = td.getVAlign();
    assertTrue("right".equals(hAlign));
    assertTrue("bottom".equals(vAlign));
  }

  public void testCellEvent() {
    IndexCell<String> cell = new IndexCell<String>("click");
    T table = createAbstractHasData(cell);
    
    RootPanel.get().add(table);
    table.setRowData(createData(0, 10));
    table.getPresenter().flush();


    NativeEvent event = Document.get().createClickEvent(0, 0, 0, 0, 0, false, false, false, false);
    getBodyElement(table, 5, 0).getFirstChildElement().dispatchEvent(event);
    cell.assertLastBrowserEventIndex(5);
    cell.assertLastEditingIndex(5);


    event = Document.get().createClickEvent(0, 0, 0, 0, 0, false, false, false, false);
    getBodyElement(table, 3, 0).dispatchEvent(event);
    cell.assertLastBrowserEventIndex(3);
    cell.assertLastEditingIndex(3);

    RootPanel.get().remove(table);
  }

  public void testCellStyles() {
    T table = createAbstractHasData();


    TextColumn<String> col0 = new TextColumn<String>() {
      @Override
      public String getValue(String object) {
        return object;
      }
    };
    col0.setCellStyleNames("col0");
    table.addColumn(col0);


    TextColumn<String> col1 = new TextColumn<String>() {
      @Override
      public String getCellStyleNames(Context context, String object) {
        return object.replace(" ", "_");
      }

      @Override
      public String getValue(String object) {
        return object;
      }
    };
    table.addColumn(col1);


    table.setRowData(createData(0, 10));
    table.flush();

    assertTrue(getBodyElement(table, 1, 0).getClassName().contains(" col0"));
    assertFalse(getBodyElement(table, 1, 0).getClassName().contains(" test_1"));
    assertFalse(getBodyElement(table, 1, 1).getClassName().contains(" col0"));
    assertTrue(getBodyElement(table, 1, 1).getClassName().contains(" test_1"));
  }

  public void testClearColumnWidth() {
    T table = createAbstractHasData();
    assertEquals(0, table.getRealColumnCount());

    table.setColumnWidth(0, "100px");
    assertEquals(1, table.getRealColumnCount());

    table.setColumnWidth(2, "300px");
    assertEquals(3, table.getRealColumnCount());

    table.clearColumnWidth(2);
    assertEquals(1, table.getRealColumnCount());
  }

  public void testDefaultKeyboardSelectionHandlerChangePage() {
    T table = createAbstractHasData();
    DefaultKeyboardSelectionHandler<String> keyHandler =
        new DefaultKeyboardSelectionHandler<String>(table);
    table.setKeyboardSelectionHandler(keyHandler);
    HasDataPresenter<String> presenter = table.getPresenter();

    table.setRowCount(100, true);
    table.setVisibleRange(new Range(50, 10));
    populateData(table);
    presenter.flush();
    table.setKeyboardPagingPolicy(KeyboardPagingPolicy.CHANGE_PAGE);


    table.setKeyboardSelectedRow(1);
    presenter.flush();
    assertEquals(1, table.getKeyboardSelectedRow());
    keyHandler.prevRow();
    presenter.flush();
    assertEquals(0, table.getKeyboardSelectedRow());


    keyHandler.prevRow();
    populateData(table);
    presenter.flush();
    assertEquals(9, table.getKeyboardSelectedRow());
    assertEquals(new Range(40, 10), table.getVisibleRange());


    table.setKeyboardSelectedRow(8);
    presenter.flush();
    assertEquals(8, table.getKeyboardSelectedRow());
    keyHandler.nextRow();
    presenter.flush();
    assertEquals(9, table.getKeyboardSelectedRow());


    keyHandler.nextRow();
    populateData(table);
    presenter.flush();
    assertEquals(0, table.getKeyboardSelectedRow());
    assertEquals(new Range(50, 10), table.getVisibleRange());


    table.setKeyboardSelectedRow(5);
    presenter.flush();
    assertEquals(5, table.getKeyboardSelectedRow());
    keyHandler.prevPage();
    populateData(table);
    presenter.flush();
    assertEquals(0, table.getKeyboardSelectedRow());
    assertEquals(new Range(40, 10), table.getVisibleRange());


    table.setKeyboardSelectedRow(5);
    presenter.flush();
    assertEquals(5, table.getKeyboardSelectedRow());
    keyHandler.nextPage();
    populateData(table);
    presenter.flush();
    assertEquals(0, table.getKeyboardSelectedRow());
    assertEquals(new Range(50, 10), table.getVisibleRange());


    keyHandler.home();
    populateData(table);
    presenter.flush();
    assertEquals(0, table.getKeyboardSelectedRow());
    assertEquals(new Range(0, 10), table.getVisibleRange());


    keyHandler.prevRow();
    presenter.flush();
    assertEquals(0, table.getKeyboardSelectedRow());


    keyHandler.end();
    populateData(table);
    presenter.flush();
    assertEquals(9, table.getKeyboardSelectedRow());
    assertEquals(new Range(90, 10), table.getVisibleRange());


    keyHandler.nextRow();
    presenter.flush();
  }

  public void testDefaultKeyboardSelectionHandlerCurrentPage() {
    T table = createAbstractHasData();
    DefaultKeyboardSelectionHandler<String> keyHandler =
        new DefaultKeyboardSelectionHandler<String>(table);
    table.setKeyboardSelectionHandler(keyHandler);
    HasDataPresenter<String> presenter = table.getPresenter();

    table.setRowCount(100, true);
    table.setVisibleRange(new Range(50, 10));
    populateData(table);
    presenter.flush();
    table.setKeyboardPagingPolicy(KeyboardPagingPolicy.CURRENT_PAGE);


    table.setKeyboardSelectedRow(1);
    presenter.flush();
    assertEquals(1, table.getKeyboardSelectedRow());
    keyHandler.prevRow();
    presenter.flush();
    assertEquals(0, table.getKeyboardSelectedRow());


    keyHandler.prevRow();
    presenter.flush();
    assertEquals(0, table.getKeyboardSelectedRow());
    assertEquals(new Range(50, 10), table.getVisibleRange());


    table.setKeyboardSelectedRow(8);
    presenter.flush();
    assertEquals(8, table.getKeyboardSelectedRow());
    keyHandler.nextRow();
    presenter.flush();
    assertEquals(9, table.getKeyboardSelectedRow());


    keyHandler.nextRow();
    presenter.flush();
    assertEquals(9, table.getKeyboardSelectedRow());
    assertEquals(new Range(50, 10), table.getVisibleRange());


    keyHandler.prevPage(); 
    presenter.flush();
    assertEquals(9, table.getKeyboardSelectedRow());
    assertEquals(new Range(50, 10), table.getVisibleRange());


    keyHandler.nextPage(); 
    presenter.flush();
    assertEquals(9, table.getKeyboardSelectedRow());
    assertEquals(new Range(50, 10), table.getVisibleRange());


    keyHandler.home();
    presenter.flush();
    assertEquals(0, table.getKeyboardSelectedRow());
    assertEquals(new Range(50, 10), table.getVisibleRange());


    keyHandler.end();
    presenter.flush();
    assertEquals(9, table.getKeyboardSelectedRow());
    assertEquals(new Range(50, 10), table.getVisibleRange());
  }

  public void testDefaultKeyboardSelectionHandlerIncreaseRange() {
    int pageStart = 150;
    int pageSize = 10;
    int increment = HasDataPresenter.PAGE_INCREMENT;

    T table = createAbstractHasData();
    DefaultKeyboardSelectionHandler<String> keyHandler =
        new DefaultKeyboardSelectionHandler<String>(table);
    table.setKeyboardSelectionHandler(keyHandler);
    HasDataPresenter<String> presenter = table.getPresenter();

    table.setRowCount(300, true);
    table.setVisibleRange(new Range(pageStart, pageSize));
    populateData(table);
    presenter.flush();
    table.setKeyboardPagingPolicy(KeyboardPagingPolicy.INCREASE_RANGE);


    table.setKeyboardSelectedRow(1);
    presenter.flush();
    assertEquals(1, table.getKeyboardSelectedRow());
    keyHandler.prevRow();
    presenter.flush();
    assertEquals(0, table.getKeyboardSelectedRow());


    keyHandler.prevRow();
    populateData(table);
    presenter.flush();
    pageStart -= increment;
    pageSize += increment;
    assertEquals(increment - 1, table.getKeyboardSelectedRow());
    assertEquals(new Range(pageStart, pageSize), table.getVisibleRange());


    table.setKeyboardSelectedRow(pageSize - 2);
    presenter.flush();
    assertEquals(pageSize - 2, table.getKeyboardSelectedRow());
    keyHandler.nextRow();
    presenter.flush();
    assertEquals(pageSize - 1, table.getKeyboardSelectedRow());


    keyHandler.nextRow();
    populateData(table);
    presenter.flush();
    pageSize += increment;
    assertEquals(pageSize - increment, table.getKeyboardSelectedRow());
    assertEquals(new Range(pageStart, pageSize), table.getVisibleRange());


    table.setKeyboardSelectedRow(increment);
    presenter.flush();
    assertEquals(increment, table.getKeyboardSelectedRow());
    keyHandler.prevPage();
    presenter.flush();
    assertEquals(0, table.getKeyboardSelectedRow());
    assertEquals(new Range(pageStart, pageSize), table.getVisibleRange());


    keyHandler.prevPage();
    populateData(table);
    presenter.flush();
    assertEquals(0, table.getKeyboardSelectedRow());
    pageStart -= increment;
    pageSize += increment;
    assertEquals(new Range(pageStart, pageSize), table.getVisibleRange());


    keyHandler.nextPage();
    presenter.flush();
    assertEquals(increment, table.getKeyboardSelectedRow());
    assertEquals(new Range(pageStart, pageSize), table.getVisibleRange());


    table.setKeyboardSelectedRow(pageSize - 1);
    presenter.flush();
    assertEquals(pageSize - 1, table.getKeyboardSelectedRow());
    keyHandler.nextPage();
    populateData(table);
    presenter.flush();
    pageSize += increment;
    assertEquals(pageSize - 1, table.getKeyboardSelectedRow());
    assertEquals(new Range(pageStart, pageSize), table.getVisibleRange());


    keyHandler.home();
    populateData(table);
    presenter.flush();
    pageSize += pageStart;
    pageStart = 0;
    assertEquals(0, table.getKeyboardSelectedRow());
    assertEquals(new Range(pageStart, pageSize), table.getVisibleRange());


    keyHandler.prevRow();
    presenter.flush();
    assertEquals(0, table.getKeyboardSelectedRow());
    assertEquals(new Range(pageStart, pageSize), table.getVisibleRange());


    keyHandler.end();
    pageSize = 300;
    populateData(table);
    presenter.flush();
    assertEquals(pageSize - 1, table.getKeyboardSelectedRow());
    assertEquals(new Range(0, pageSize), table.getVisibleRange());


    keyHandler.nextRow();
    presenter.flush();
    assertEquals(pageSize - 1, table.getKeyboardSelectedRow());
    assertEquals(new Range(pageStart, pageSize), table.getVisibleRange());
  }

  public void testGetColumnIndex() {
    T table = createAbstractHasData();
    Column<String, String> col0 = new IdentityColumn<String>(new TextCell());
    table.addColumn(col0);
    Column<String, String> col1 = new IdentityColumn<String>(new TextCell());
    table.addColumn(col1);
    Column<String, String> col2 = new IdentityColumn<String>(new TextCell());
    table.addColumn(col2);
    assertEquals(0, table.getColumnIndex(col0));
    assertEquals(1, table.getColumnIndex(col1));
    assertEquals(2, table.getColumnIndex(col2));


    Column<String, String> other = new IdentityColumn<String>(new TextCell());
    assertEquals(-1, table.getColumnIndex(other));


    assertEquals(-1, table.getColumnIndex(null));
  }

  public void testGetColumnOutOfBounds() {
    T table = createAbstractHasData();


    try {
      table.getColumn(0);
      fail("Expected IndexOutOfBoundsException");
    } catch (IndexOutOfBoundsException e) {

    }


    table.addColumn(new MockColumn<String, String>());
    table.addColumn(new MockColumn<String, String>());


    try {
      table.getColumn(-1);
      fail("Expected IndexOutOfBoundsException");
    } catch (IndexOutOfBoundsException e) {

    }


    try {
      table.getColumn(2);
      fail("Expected IndexOutOfBoundsException");
    } catch (IndexOutOfBoundsException e) {

    }
  }

  public void testGetRowElement() {
    AbstractCellTable<String> table = createAbstractHasData(new TextCell());
    table.setRowData(0, createData(0, 10));


    assertNotNull(table.getRowElement(9));
  }

  public void testGetSubRowElement() {
    T table = createAbstractHasData(new TextCell());
    CellTableBuilder<String> builder = new DefaultCellTableBuilder<String>(table) {
      @Override
      public void buildRowImpl(String rowValue, int absRowIndex) {
        super.buildRowImpl(rowValue, absRowIndex);


        for (int i = 0; i < 4; i++) {
          TableRowBuilder tr = startRow();
          tr.startTD().colSpan(2).text("child " + absRowIndex + ":" + i).endTD();
          tr.endTR();
        }
      }
    };
    table.setTableBuilder(builder);
    table.setVisibleRange(0, 5);
    populateData(table);
    table.getPresenter().flush();


    TableSectionElement tbody = table.getTableBodyElement();
    assertEquals(25, tbody.getChildCount());


    assertEquals(0, table.getSubRowElement(0, 0).getSectionRowIndex());
    assertEquals(1, table.getSubRowElement(0, 1).getSectionRowIndex());
    assertEquals(4, table.getSubRowElement(0, 4).getSectionRowIndex());
    assertEquals(5, table.getSubRowElement(1, 0).getSectionRowIndex());
    assertEquals(8, table.getSubRowElement(1, 3).getSectionRowIndex());
    assertEquals(20, table.getSubRowElement(4, 0).getSectionRowIndex());
    assertEquals(24, table.getSubRowElement(4, 4).getSectionRowIndex());


    assertNull(table.getSubRowElement(0, 5));
    assertNull(table.getSubRowElement(4, 5));


    try {
      assertNull(table.getSubRowElement(5, 0));
      fail("Expected IndexOutOfBoundsException: row index is out of bounds");
    } catch (IndexOutOfBoundsException e) {

    }
  }

  public void testHeaderEvent() {
    T table = createAbstractHasData();
    IndexCell<String> cell = new IndexCell<String>("click");
    table.addColumn(new TextColumn<String>() {
      @Override
      public String getValue(String object) {
        return object;
      }
    }, new Header<String>(cell) {
      @Override
      public String getValue() {
        return "header0";
      }
    });
    RootPanel.get().add(table);
    table.setRowData(createData(0, 10));
    table.getPresenter().flush();


    NativeEvent event = Document.get().createClickEvent(0, 0, 0, 0, 0, false, false, false, false);
    getHeaderElement(table, 0).dispatchEvent(event);
    cell.assertLastBrowserEventIndex(0);

    RootPanel.get().remove(table);
  }

  public void testSetHeaderBuilder() {
    T table = createAbstractHasData();
    HeaderBuilder<String> headerBuilder = new AbstractHeaderOrFooterBuilder<String>(table, false) {
      @Override
      protected boolean buildHeaderOrFooterImpl() {
        TableRowBuilder tr = startRow();
        tr.startTH().text("Col 0").endTH();
        tr.startTH().text("Col 1").endTH();
        tr.startTH().text("Col 2").endTH();
        tr.endTR();
        return true;
      }
    };


    table.setHeaderBuilder(headerBuilder);
    assertEquals(headerBuilder, table.getHeaderBuilder());
    table.getPresenter().flush();


    NodeList<TableRowElement> rows = table.getTableHeadElement().getRows();
    assertEquals(1, rows.getLength());
    NodeList<TableCellElement> cells = rows.getItem(0).getCells();
    assertEquals(3, cells.getLength());
    assertEquals("Col 0", cells.getItem(0).getInnerText());
    assertEquals("Col 1", cells.getItem(1).getInnerText());
    assertEquals("Col 2", cells.getItem(2).getInnerText());
  }

  public void testSetFooterBuilder() {
    T table = createAbstractHasData();
    FooterBuilder<String> footerBuilder = new AbstractHeaderOrFooterBuilder<String>(table, true) {
      @Override
      protected boolean buildHeaderOrFooterImpl() {
        TableRowBuilder tr = startRow();
        tr.startTH().text("Col 0").endTH();
        tr.startTH().text("Col 1").endTH();
        tr.startTH().text("Col 2").endTH();
        tr.endTR();
        return true;
      }
    };


    table.setFooterBuilder(footerBuilder);
    assertEquals(footerBuilder, table.getFooterBuilder());
    table.getPresenter().flush();


    NodeList<TableRowElement> rows = table.getTableFootElement().getRows();
    assertEquals(1, rows.getLength());
    NodeList<TableCellElement> cells = rows.getItem(0).getCells();
    assertEquals(3, cells.getLength());
    assertEquals("Col 0", cells.getItem(0).getInnerText());
    assertEquals("Col 1", cells.getItem(1).getInnerText());
    assertEquals("Col 2", cells.getItem(2).getInnerText());
  }

  public void testInsertColumn() {
    T table = createAbstractHasData();
    assertEquals(0, table.getColumnCount());


    Column<String, ?> a = new MockColumn<String, String>();
    table.insertColumn(0, a);
    assertEquals(1, table.getColumnCount());
    assertEquals(a, table.getColumn(0));


    Column<String, ?> b = new MockColumn<String, String>();
    table.insertColumn(0, b);
    assertEquals(2, table.getColumnCount());
    assertEquals(b, table.getColumn(0));
    assertEquals(a, table.getColumn(1));


    Column<String, ?> c = new MockColumn<String, String>();
    table.insertColumn(2, c);
    assertEquals(3, table.getColumnCount());
    assertEquals(b, table.getColumn(0));
    assertEquals(a, table.getColumn(1));
    assertEquals(c, table.getColumn(2));


    Column<String, ?> d = new MockColumn<String, String>();
    table.insertColumn(1, d);
    assertEquals(4, table.getColumnCount());
    assertEquals(b, table.getColumn(0));
    assertEquals(d, table.getColumn(1));
    assertEquals(a, table.getColumn(2));
    assertEquals(c, table.getColumn(3));


    try {
      table.insertColumn(-1, d);
      fail("Expected IndexOutOfBoundsExecltion");
    } catch (IndexOutOfBoundsException e) {

    }
    try {
      table.insertColumn(6, d);
      fail("Expected IndexOutOfBoundsExecltion");
    } catch (IndexOutOfBoundsException e) {

    }
  }

  public void testSetAutoFooterRefreshDisabled() {
    AbstractCellTable<String> table = createAbstractHasData();
    assertFalse(table.isAutoHeaderRefreshDisabled());
    assertFalse(table.isAutoFooterRefreshDisabled());

    table.setAutoFooterRefreshDisabled(true);
    assertFalse(table.isAutoHeaderRefreshDisabled());
    assertTrue(table.isAutoFooterRefreshDisabled());


    final List<String> log = new ArrayList<String>();
    Column<String, ?> col0 = new MockColumn<String, String>();
    TextHeader header0 = new TextHeader("header0") {
      @Override
      public void render(Context context, SafeHtmlBuilder sb) {
        super.render(context, sb);
        log.add("header0 rendered");
      }
    };
    TextHeader footer0 = new TextHeader("footer0") {
      @Override
      public void render(Context context, SafeHtmlBuilder sb) {
        super.render(context, sb);
        log.add("footer0 rendered");
      }
    };
    table.addColumn(col0, header0, footer0);
    assertEquals(0, log.size()); 
    table.getPresenter().flush(); 
    assertEquals("header0 rendered", log.remove(0));
    assertEquals("footer0 rendered", log.remove(0));
    assertEquals(0, log.size());


    Column<String, ?> col1 = new MockColumn<String, String>();
    TextHeader header1 = new TextHeader("header1") {
      @Override
      public void render(Context context, SafeHtmlBuilder sb) {
        super.render(context, sb);
        log.add("header1 rendered");
      }
    };
    TextHeader footer1 = new TextHeader("footer1") {
      @Override
      public void render(Context context, SafeHtmlBuilder sb) {
        super.render(context, sb);
        log.add("footer1 rendered");
      }
    };
    table.addColumn(col1, header1, footer1);
    assertEquals(0, log.size()); 
    table.getPresenter().flush(); 
    assertEquals("header0 rendered", log.remove(0));
    assertEquals("header1 rendered", log.remove(0));
    assertEquals("footer0 rendered", log.remove(0));
    assertEquals("footer1 rendered", log.remove(0));
    assertEquals(0, log.size());


    table.removeColumn(col0);
    assertEquals(0, log.size()); 
    table.getPresenter().flush(); 
    assertEquals("header1 rendered", log.remove(0));
    assertEquals("footer1 rendered", log.remove(0));
    assertEquals(0, log.size());


    populateData(table);
    assertEquals(0, log.size()); 
    table.getPresenter().flush(); 
    assertEquals("header1 rendered", log.remove(0));
    assertEquals(0, log.size());


    table.getColumnSortList().push(col1);
    assertEquals("header1 rendered", log.remove(0));
    assertEquals(0, log.size());
  }

  public void testSetAutoHeaderRefreshDisabled() {
    AbstractCellTable<String> table = createAbstractHasData();
    assertFalse(table.isAutoHeaderRefreshDisabled());
    assertFalse(table.isAutoFooterRefreshDisabled());

    table.setAutoHeaderRefreshDisabled(true);
    assertTrue(table.isAutoHeaderRefreshDisabled());
    assertFalse(table.isAutoFooterRefreshDisabled());


    final List<String> log = new ArrayList<String>();
    Column<String, ?> col0 = new MockColumn<String, String>();
    TextHeader header0 = new TextHeader("header0") {
      @Override
      public void render(Context context, SafeHtmlBuilder sb) {
        super.render(context, sb);
        log.add("header0 rendered");
      }
    };
    TextHeader footer0 = new TextHeader("footer0") {
      @Override
      public void render(Context context, SafeHtmlBuilder sb) {
        super.render(context, sb);
        log.add("footer0 rendered");
      }
    };
    table.addColumn(col0, header0, footer0);
    assertEquals(0, log.size()); 
    table.getPresenter().flush(); 
    assertEquals("header0 rendered", log.remove(0));
    assertEquals("footer0 rendered", log.remove(0));
    assertEquals(0, log.size());


    Column<String, ?> col1 = new MockColumn<String, String>();
    TextHeader header1 = new TextHeader("header1") {
      @Override
      public void render(Context context, SafeHtmlBuilder sb) {
        super.render(context, sb);
        log.add("header1 rendered");
      }
    };
    TextHeader footer1 = new TextHeader("footer1") {
      @Override
      public void render(Context context, SafeHtmlBuilder sb) {
        super.render(context, sb);
        log.add("footer1 rendered");
      }
    };
    table.addColumn(col1, header1, footer1);
    assertEquals(0, log.size()); 
    table.getPresenter().flush(); 
    assertEquals("header0 rendered", log.remove(0));
    assertEquals("header1 rendered", log.remove(0));
    assertEquals("footer0 rendered", log.remove(0));
    assertEquals("footer1 rendered", log.remove(0));
    assertEquals(0, log.size());


    table.removeColumn(col0);
    assertEquals(0, log.size()); 
    table.getPresenter().flush(); 
    assertEquals("header1 rendered", log.remove(0));
    assertEquals("footer1 rendered", log.remove(0));
    assertEquals(0, log.size());


    populateData(table);
    assertEquals(0, log.size()); 
    table.getPresenter().flush(); 
    assertEquals("footer1 rendered", log.remove(0));
    assertEquals(0, log.size());


    table.getColumnSortList().push(col1);
    assertEquals("header1 rendered", log.remove(0));
    assertEquals(0, log.size());
  }

  public void testSetColumnWidth() {
    AbstractCellTable<String> table = createAbstractHasData(new TextCell());
    Column<String, ?> col0 = new MockColumn<String, String>();
    Column<String, ?> col1 = new MockColumn<String, String>();
    Column<String, ?> col2 = new MockColumn<String, String>();


    table.setColumnWidth(col0, "100px");
    table.setColumnWidth(col1, 200.0, Unit.EM);
    assertEquals("100px", table.getColumnWidth(col0));


    assertTrue(table.getColumnWidth(col1).contains("200"));


    assertNull(table.getColumnWidth(col2));


    table.clearColumnWidth(col0);
    assertNull(table.getColumnWidth(col0));
  }


  public void testSetColumnWidthMixed() {
    AbstractCellTable<String> table = createAbstractHasData(new TextCell());
    Column<String, ?> col0 = new MockColumn<String, String>();
    Column<String, ?> col1 = new MockColumn<String, String>();
    Column<String, ?> col2 = new MockColumn<String, String>();


    table.setColumnWidth(col0, "100px");


    table.setColumnWidth(col1, 200.0, Unit.EM);
    table.setColumnWidth(1, "210em");


    table.setColumnWidth(2, "300px");

    assertEquals("100px", table.getColumnWidth(col0));
    assertEquals("300px", table.getColumnWidth(2));


    assertTrue(table.getColumnWidth(col1).contains("200"));


    assertNull(table.getColumnWidth(col2));


    table.clearColumnWidth(col0);
    assertNull(table.getColumnWidth(col0));
  }

  public void testSetEmptyTableWidget() {
    AbstractCellTable<String> table = createAbstractHasData(new TextCell());


    Label l = new Label("Empty");
    table.setEmptyTableWidget(l);
    assertEquals(l, table.getEmptyTableWidget());


    table.setEmptyTableWidget(null);
    assertNull(table.getEmptyTableWidget());
  }

  public void testSetKeyboardSelectedRow() {
    AbstractCellTable<String> table = createAbstractHasData(new TextCell());
    table.setVisibleRange(0, 10);


    table.setKeyboardSelectedRow(5);
    assertEquals(5, table.getKeyboardSelectedRow());
    assertEquals(0, table.getKeyboardSelectedSubRow());


    table.setKeyboardSelectedRow(6, 2, false);
    assertEquals(6, table.getKeyboardSelectedRow());
    assertEquals(2, table.getKeyboardSelectedSubRow());


    table.setKeyboardSelectedRow(6, 5, false);
    assertEquals(6, table.getKeyboardSelectedRow());
    assertEquals(5, table.getKeyboardSelectedSubRow());


    table.setKeyboardSelectedRow(7);
    assertEquals(7, table.getKeyboardSelectedRow());
    assertEquals(0, table.getKeyboardSelectedSubRow());
  }

  public void testSetLoadingIndicator() {
    AbstractCellTable<String> table = createAbstractHasData(new TextCell());


    Label l = new Label("Loading");
    table.setLoadingIndicator(l);
    assertEquals(l, table.getLoadingIndicator());


    table.setLoadingIndicator(null);
    assertNull(table.getLoadingIndicator());
  }

  public void testSortableColumn() {
    T table = createAbstractHasData(new TextCell());
    table.getColumn(0).setSortable(true);
    table.getPresenter().flush();
    RootPanel.get().add(table);


    final List<Column<?, ?>> lastSorted = new ArrayList<Column<?, ?>>();
    table.addColumnSortHandler(new ColumnSortEvent.Handler() {
      @Override
      public void onColumnSort(ColumnSortEvent event) {
        lastSorted.clear();
        lastSorted.add(event.getColumn());
      }
    });


    ColumnSortList sortList = table.getColumnSortList();
    assertEquals(0, sortList.size());


    NativeEvent click = Document.get().createClickEvent(0, 0, 0, 0, 0, false, false, false, false);
    getHeaderElement(table, 0).dispatchEvent(click);
    assertEquals(1, sortList.size());
    assertEquals(table.getColumn(0), sortList.get(0).getColumn());
    assertTrue(sortList.get(0).isAscending());
    assertEquals(1, lastSorted.size());
    lastSorted.clear();


    getHeaderElement(table, 0).dispatchEvent(click);
    assertEquals(1, sortList.size());
    assertEquals(table.getColumn(0), sortList.get(0).getColumn());
    assertFalse(sortList.get(0).isAscending());
    assertEquals(1, lastSorted.size());
    lastSorted.clear();
    

    NativeEvent enter = Document.get().createKeyDownEvent(false, false, false, false,
        KeyCodes.KEY_ENTER);
    getHeaderElement(table, 0).dispatchEvent(enter);
    assertEquals(1, sortList.size());
    assertEquals(table.getColumn(0), sortList.get(0).getColumn());
    assertTrue(sortList.get(0).isAscending());
    assertEquals(1, lastSorted.size());
    lastSorted.clear();


    getHeaderElement(table, 0).dispatchEvent(enter);
    assertEquals(1, sortList.size());
    assertEquals(table.getColumn(0), sortList.get(0).getColumn());
    assertFalse(sortList.get(0).isAscending());
    assertEquals(1, lastSorted.size());
    lastSorted.clear();


    getHeaderElement(table, 1).dispatchEvent(click);
    assertEquals(1, sortList.size());
    assertEquals(table.getColumn(0), sortList.get(0).getColumn());
    assertFalse(sortList.get(0).isAscending());
    assertEquals(0, lastSorted.size());


    RootPanel.get().remove(table);
  }


  protected abstract T createAbstractHasData();

  @Override
  protected final T createAbstractHasData(Cell<String> cell) {
    T table = createAbstractHasData();
    table.addColumn(new Column<String, String>(cell) {
      @Override
      public String getValue(String object) {
        return object;
      }
    }, "Column 0");
    table.addColumn(new Column<String, String>(new TextCell()) {
      @Override
      public String getValue(String object) {
        return object + "-2";
      }
    }, "Column 1");
    return table;
  }


  protected abstract TableCellElement getBodyElement(T table, int row, int column);


  protected abstract int getHeaderCount(T table);


  protected abstract TableCellElement getHeaderElement(T table, int column);
}

<code block>

package com.google.gwt.user.cellview.client;

import com.google.gwt.cell.client.Cell.Context;
import com.google.gwt.cell.client.HasCell;
import com.google.gwt.dom.builder.shared.ElementBuilderBase;
import com.google.gwt.dom.builder.shared.HtmlBuilderFactory;
import com.google.gwt.dom.builder.shared.HtmlTableSectionBuilder;
import com.google.gwt.dom.builder.shared.TableRowBuilder;
import com.google.gwt.dom.builder.shared.TableSectionBuilder;
import com.google.gwt.dom.client.Document;
import com.google.gwt.dom.client.Element;
import com.google.gwt.dom.client.TableRowElement;
import com.google.gwt.safehtml.shared.SafeHtmlBuilder;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;


public abstract class AbstractCellTableBuilder<T> implements CellTableBuilder<T> {
  

  private static final String CELL_ATTRIBUTE = "__gwt_cell";
  

  private static final String ROW_ATTRIBUTE = "__gwt_row";


  private static final String SUBROW_ATTRIBUTE = "__gwt_subrow";
  
  protected final AbstractCellTable<T> cellTable;
  

  private final Map<String, HasCell<T, ?>> idToCellMap = new HashMap<String, HasCell<T, ?>>();
  private final Map<HasCell<T, ?>, String> cellToIdMap = new HashMap<HasCell<T, ?>, String>();

  private HtmlTableSectionBuilder tbody;  
  private int rowIndex;
  private int subrowIndex;
  private Object rowValueKey;


  public AbstractCellTableBuilder(AbstractCellTable<T> cellTable) {
    this.cellTable = cellTable;
  }
  

  @Override
  public final void buildRow(T rowValue, int absRowIndex) {
    setRowInfo(absRowIndex, rowValue);
    buildRowImpl(rowValue, absRowIndex);
  }
  

  public final Context createContext(int column) {
    return new Context(rowIndex, column, rowValueKey, subrowIndex);
  }
  

  @Override
  public final TableSectionBuilder finish() {

    while (tbody.getDepth() > 0) {
      tbody.endTBody();
    }
    return tbody;
  }
  

  @Override
  public final HasCell<T, ?> getColumn(Context context, T rowValue, Element elem) {
    return getColumn(elem);
  }


  @Override
  public final Collection<HasCell<T, ?>> getColumns() {
    return idToCellMap.values();
  }
  

  @Override
  public final int getRowValueIndex(TableRowElement row) {
    try {
      return Integer.parseInt(row.getAttribute(ROW_ATTRIBUTE));
    } catch (NumberFormatException e) {


      return row.getSectionRowIndex() + cellTable.getPageStart();
    }
  }
  

  @Override
  public final int getSubrowValueIndex(TableRowElement row) {
    try {
      return Integer.parseInt(row.getAttribute(SUBROW_ATTRIBUTE));
    } catch (NumberFormatException e) {


      return 0;
    }
  }
  

  @Override
  public final boolean isColumn(Element elem) {
    return getCellId(elem) != null;
  }
  

  public final <C> void renderCell(ElementBuilderBase<?> builder, Context context,
      HasCell<T, C> column, T rowValue) {

    String cellId = cellToIdMap.get(column);
    if (cellId == null) {
      cellId = "cell-" + Document.get().createUniqueId();
      idToCellMap.put(cellId, column);
      cellToIdMap.put(column, cellId);
    }
    builder.attribute(CELL_ATTRIBUTE, cellId);


    SafeHtmlBuilder cellBuilder = new SafeHtmlBuilder();
    if (column instanceof Column) {

      Column<T, C> theColumn = (Column<T, C>) column;
      theColumn.render(context, rowValue, cellBuilder);
    } else {
      column.getCell().render(context, column.getValue(rowValue), cellBuilder);
    }
    builder.html(cellBuilder.toSafeHtml());
  }
  


  @Override
  public final void start(boolean isRebuildingAllRows) {

    tbody = HtmlBuilderFactory.get().createTBodyBuilder();
    if (isRebuildingAllRows) {
      cellToIdMap.clear();
      idToCellMap.clear();
    }
  }


  public final TableRowBuilder startRow() {
    return startRow(null);
  }


  public final TableRowBuilder startRow(T rowValue) {

    while (tbody.getDepth() > 1) {
      tbody.end();
    }


    if (tbody.getDepth() < 1) {
      throw new IllegalStateException(
          "Cannot start a row.  Did you call TableRowBuilder.end() too many times?");
    }


    TableRowBuilder row = tbody.startTR();
    row.attribute(ROW_ATTRIBUTE, rowIndex);
    row.attribute(SUBROW_ATTRIBUTE, subrowIndex);
    addRowAttributes(row, rowValue);
    subrowIndex++;
    return row;
  }


  protected void addRowAttributes(TableRowBuilder row) {
  }


  protected void addRowAttributes(TableRowBuilder row, T rowValue) {
    addRowAttributes(row);
  }


  protected abstract void buildRowImpl(T rowValue, int absRowIndex);
  

  private String getCellId(Element elem) {
    if (elem == null) {
      return null;
    }
    String cellId = elem.getAttribute(CELL_ATTRIBUTE);
    return (cellId == null) || (cellId.length() == 0) ? null : cellId;
  }


  private HasCell<T, ?> getColumn(Element elem) {
    String cellId = getCellId(elem);
    return (cellId == null) ? null : idToCellMap.get(cellId);
  }


  private void setRowInfo(int rowIndex, T rowValue) {
    this.rowIndex = rowIndex;
    this.rowValueKey = cellTable.getValueKey(rowValue);
    this.subrowIndex = 0; 
  }
}

<code block>

package com.google.gwt.user.cellview.client;

import com.google.gwt.cell.client.Cell.Context;
import com.google.gwt.dom.builder.shared.DivBuilder;
import com.google.gwt.dom.builder.shared.TableCellBuilder;
import com.google.gwt.dom.builder.shared.TableRowBuilder;
import com.google.gwt.dom.client.Style.OutlineStyle;
import com.google.gwt.user.cellview.client.AbstractCellTable.Style;
import com.google.gwt.user.client.ui.HasHorizontalAlignment.HorizontalAlignmentConstant;
import com.google.gwt.user.client.ui.HasVerticalAlignment.VerticalAlignmentConstant;
import com.google.gwt.view.client.SelectionModel;


public class DefaultCellTableBuilder<T> extends AbstractCellTableBuilder<T> {

  private final String evenRowStyle;
  private final String oddRowStyle;
  private final String selectedRowStyle;
  private final String cellStyle;
  private final String evenCellStyle;
  private final String oddCellStyle;
  private final String firstColumnStyle;
  private final String lastColumnStyle;
  private final String selectedCellStyle;

  public DefaultCellTableBuilder(AbstractCellTable<T> cellTable) {
    super(cellTable);


    Style style = cellTable.getResources().style();
    evenRowStyle = style.evenRow();
    oddRowStyle = style.oddRow();
    selectedRowStyle = " " + style.selectedRow();
    cellStyle = style.cell();
    evenCellStyle = " " + style.evenRowCell();
    oddCellStyle = " " + style.oddRowCell();
    firstColumnStyle = " " + style.firstColumn();
    lastColumnStyle = " " + style.lastColumn();
    selectedCellStyle = " " + style.selectedRowCell();
  }

  @Override
  public void buildRowImpl(T rowValue, int absRowIndex) {


    SelectionModel<? super T> selectionModel = cellTable.getSelectionModel();
    boolean isSelected =
        (selectionModel == null || rowValue == null) ? false : selectionModel.isSelected(rowValue);
    boolean isEven = absRowIndex % 2 == 0;
    StringBuilder trClasses = new StringBuilder(isEven ? evenRowStyle : oddRowStyle);
    if (isSelected) {
      trClasses.append(selectedRowStyle);
    }


    RowStyles<T> rowStyles = cellTable.getRowStyles();
    if (rowStyles != null) {
      String extraRowStyles = rowStyles.getStyleNames(rowValue, absRowIndex);
      if (extraRowStyles != null) {
        trClasses.append(" ").append(extraRowStyles);
      }
    }


    TableRowBuilder tr = startRow(rowValue);
    tr.className(trClasses.toString());


    int columnCount = cellTable.getColumnCount();
    for (int curColumn = 0; curColumn < columnCount; curColumn++) {
      Column<T, ?> column = cellTable.getColumn(curColumn);

      StringBuilder tdClasses = new StringBuilder(cellStyle);
      tdClasses.append(isEven ? evenCellStyle : oddCellStyle);
      if (curColumn == 0) {
        tdClasses.append(firstColumnStyle);
      }
      if (isSelected) {
        tdClasses.append(selectedCellStyle);
      }

      if (curColumn == columnCount - 1) {
        tdClasses.append(lastColumnStyle);
      }


      Context context = new Context(absRowIndex, curColumn, cellTable.getValueKey(rowValue));
      String cellStyles = column.getCellStyleNames(context, rowValue);
      if (cellStyles != null) {
        tdClasses.append(" " + cellStyles);
      }


      HorizontalAlignmentConstant hAlign = column.getHorizontalAlignment();
      VerticalAlignmentConstant vAlign = column.getVerticalAlignment();
      TableCellBuilder td = tr.startTD();
      td.className(tdClasses.toString());
      if (hAlign != null) {
        td.align(hAlign.getTextAlignString());
      }
      if (vAlign != null) {
        td.vAlign(vAlign.getVerticalAlignString());
      }
      addCellAttributes(td);


      DivBuilder div = td.startDiv();
      div.style().outlineStyle(OutlineStyle.NONE).endStyle();


      renderCell(div, context, column, rowValue);


      div.endDiv();
      td.endTD();
    }


    tr.endTR();
  }


  protected void addCellAttributes(TableCellBuilder cell) {
  }
}

<code block>

package com.google.gwt.user.cellview.client;

import com.google.gwt.cell.client.AbstractCell;
import com.google.gwt.cell.client.Cell;
import com.google.gwt.cell.client.Cell.Context;
import com.google.gwt.cell.client.TextCell;
import com.google.gwt.dom.builder.shared.TableRowBuilder;
import com.google.gwt.dom.client.Document;
import com.google.gwt.dom.client.NativeEvent;
import com.google.gwt.dom.client.NodeList;
import com.google.gwt.dom.client.Style.Unit;
import com.google.gwt.dom.client.TableCellElement;
import com.google.gwt.dom.client.TableRowElement;
import com.google.gwt.dom.client.TableSectionElement;
import com.google.gwt.event.dom.client.KeyCodes;
import com.google.gwt.safehtml.shared.SafeHtmlBuilder;
import com.google.gwt.user.cellview.client.AbstractHasData.DefaultKeyboardSelectionHandler;
import com.google.gwt.user.cellview.client.HasKeyboardPagingPolicy.KeyboardPagingPolicy;
import com.google.gwt.user.cellview.client.LoadingStateChangeEvent.LoadingState;
import com.google.gwt.user.client.ui.HasHorizontalAlignment;
import com.google.gwt.user.client.ui.HasVerticalAlignment;
import com.google.gwt.user.client.ui.Label;
import com.google.gwt.user.client.ui.RootPanel;
import com.google.gwt.view.client.Range;

import java.util.ArrayList;
import java.util.List;


public abstract class AbstractCellTableTestBase<T extends AbstractCellTable<String>> extends
    AbstractHasDataTestBase {


  private static class MockColumn<T, C> extends Column<T, C> {

    public MockColumn() {
      super(new AbstractCell<C>() {
        @Override
        public void render(Context context, C value, SafeHtmlBuilder sb) {
        }
      });
    }

    @Override
    public C getValue(T object) {
      return null;
    }
  }


  public void testAddColumnSingleRedraw() {
    final List<LoadingState> loadingStates = new ArrayList<LoadingState>();
    T table = createAbstractHasData();
    table.setPageSize(10);
    table.addLoadingStateChangeHandler(new LoadingStateChangeEvent.Handler() {
      @Override
      public void onLoadingStateChanged(LoadingStateChangeEvent event) {
        if (LoadingState.LOADED == event.getLoadingState()) {
          loadingStates.add(event.getLoadingState());
        }
      }
    });
    table.addColumn(new Column<String, String>(new TextCell()) {
      @Override
      public String getValue(String object) {
        return object + "-3";
      }
    });
    table.addColumn(new Column<String, String>(new TextCell()) {
      @Override
      public String getValue(String object) {
        return object + "-4";
      }
    });
    table.setRowData(0, createData(0, 10));
    table.getPresenter().flush();
    assertEquals(1, loadingStates.size());
  }


  public void testBuildTooManyEnds() {
    final List<Integer> builtRows = new ArrayList<Integer>();
    T table = createAbstractHasData(new TextCell());
    CellTableBuilder<String> builder = new DefaultCellTableBuilder<String>(table) {
      @Override
      public void buildRowImpl(String rowValue, int absRowIndex) {
        builtRows.add(absRowIndex);
        TableRowBuilder tr = startRow(rowValue);
        tr.endTR(); 
        tr.end(); 


        try {
          startRow(rowValue);
          fail("Expected IllegalStateException: tbody is already ended");
        } catch (IllegalStateException e) {

        }
      }
    };
    table.setTableBuilder(builder);
    table.setVisibleRange(0, 1);
    populateData(table);
    table.getPresenter().flush();

    assertEquals(1, builtRows.size());
    assertEquals(0, builtRows.get(0).intValue());
  }


  public void testBuildMultipleRows() {
    T table = createAbstractHasData(new TextCell());
    CellTableBuilder<String> builder = new DefaultCellTableBuilder<String>(table) {
      @Override
      public void buildRowImpl(String rowValue, int absRowIndex) {
        super.buildRowImpl(rowValue, absRowIndex);


        if (absRowIndex == 5) {
          for (int i = 0; i < 4; i++) {
            TableRowBuilder tr = startRow(rowValue);
            tr.startTD().colSpan(2).text("child " + i).endTD();
            tr.endTR();
          }
        }
      }
    };
    table.setTableBuilder(builder);
    table.setVisibleRange(0, 10);
    populateData(table);
    table.getPresenter().flush();


    TableSectionElement tbody = table.getTableBodyElement();
    assertEquals(14, tbody.getChildCount());
    assertEquals("child 0", getBodyElement(table, 6, 0).getInnerText());
    assertEquals("child 1", getBodyElement(table, 7, 0).getInnerText());
    assertEquals("child 2", getBodyElement(table, 8, 0).getInnerText());
    assertEquals("child 3", getBodyElement(table, 9, 0).getInnerText());


    assertEquals("test 5", table.getVisibleItem(5));
    assertEquals("test 9", table.getVisibleItem(9));


    assertEquals(4, table.getChildElement(4).getSectionRowIndex());
    assertEquals(5, table.getChildElement(5).getSectionRowIndex());
    assertEquals(10, table.getChildElement(6).getSectionRowIndex());
  }


  public void testBuildZeroRows() {
    T table = createAbstractHasData(new TextCell());
    CellTableBuilder<String> builder = new DefaultCellTableBuilder<String>(table) {
      @Override
      public void buildRowImpl(String rowValue, int absRowIndex) {

        if (absRowIndex != 5) {
          super.buildRowImpl(rowValue, absRowIndex);
        }
      }
    };
    table.setTableBuilder(builder);
    table.setVisibleRange(0, 10);
    populateData(table);
    table.getPresenter().flush();


    TableSectionElement tbody = table.getTableBodyElement();
    assertEquals(9, tbody.getChildCount());


    assertEquals("test 5", table.getVisibleItem(5));
    assertEquals("test 9", table.getVisibleItem(9));


    assertEquals(4, table.getChildElement(4).getSectionRowIndex());
    assertNull(table.getChildElement(5));
    assertEquals(5, table.getChildElement(6).getSectionRowIndex());
  }

  public void testCellAlignment() {
    T table = createAbstractHasData(new TextCell());
    Column<String, String> column = new Column<String, String>(new TextCell()) {
      @Override
      public String getValue(String object) {
        return object;
      }
    };
    table.addColumn(column);


    table.setRowData(0, createData(0, 1));
    table.getPresenter().flush();
    TableCellElement td = getBodyElement(table, 0, 2);
    String hAlign = td.getAlign();
    String vAlign = td.getVAlign();
    assertTrue("".equals(hAlign) || "left".equals(hAlign));
    assertTrue("".equals(vAlign) || "middle".equals(vAlign));


    column.setHorizontalAlignment(HasHorizontalAlignment.ALIGN_RIGHT);
    table.setRowData(0, createData(0, 1));
    table.getPresenter().flush();
    td = getBodyElement(table, 0, 2);
    hAlign = td.getAlign();
    vAlign = td.getVAlign();
    assertTrue("right".equals(hAlign));
    assertTrue("".equals(vAlign) || "middle".equals(vAlign));


    column.setHorizontalAlignment(null);
    column.setVerticalAlignment(HasVerticalAlignment.ALIGN_BOTTOM);
    table.setRowData(0, createData(0, 1));
    table.getPresenter().flush();
    td = getBodyElement(table, 0, 2);
    hAlign = td.getAlign();
    vAlign = td.getVAlign();
    assertTrue("".equals(hAlign) || "left".equals(hAlign));
    assertTrue("bottom".equals(vAlign));


    column.setHorizontalAlignment(HasHorizontalAlignment.ALIGN_RIGHT);
    table.setRowData(0, createData(0, 1));
    table.getPresenter().flush();
    td = getBodyElement(table, 0, 2);
    hAlign = td.getAlign();
    vAlign = td.getVAlign();
    assertTrue("right".equals(hAlign));
    assertTrue("bottom".equals(vAlign));
  }

  public void testCellEvent() {
    IndexCell<String> cell = new IndexCell<String>("click");
    T table = createAbstractHasData(cell);
    
    RootPanel.get().add(table);
    table.setRowData(createData(0, 10));
    table.getPresenter().flush();


    NativeEvent event = Document.get().createClickEvent(0, 0, 0, 0, 0, false, false, false, false);
    getBodyElement(table, 5, 0).getFirstChildElement().dispatchEvent(event);
    cell.assertLastBrowserEventIndex(5);
    cell.assertLastEditingIndex(5);


    event = Document.get().createClickEvent(0, 0, 0, 0, 0, false, false, false, false);
    getBodyElement(table, 3, 0).dispatchEvent(event);
    cell.assertLastBrowserEventIndex(3);
    cell.assertLastEditingIndex(3);

    RootPanel.get().remove(table);
  }

  public void testCellStyles() {
    T table = createAbstractHasData();


    TextColumn<String> col0 = new TextColumn<String>() {
      @Override
      public String getValue(String object) {
        return object;
      }
    };
    col0.setCellStyleNames("col0");
    table.addColumn(col0);


    TextColumn<String> col1 = new TextColumn<String>() {
      @Override
      public String getCellStyleNames(Context context, String object) {
        return object.replace(" ", "_");
      }

      @Override
      public String getValue(String object) {
        return object;
      }
    };
    table.addColumn(col1);


    table.setRowData(createData(0, 10));
    table.flush();

    assertTrue(getBodyElement(table, 1, 0).getClassName().contains(" col0"));
    assertFalse(getBodyElement(table, 1, 0).getClassName().contains(" test_1"));
    assertFalse(getBodyElement(table, 1, 1).getClassName().contains(" col0"));
    assertTrue(getBodyElement(table, 1, 1).getClassName().contains(" test_1"));
  }

  public void testClearColumnWidth() {
    T table = createAbstractHasData();
    assertEquals(0, table.getRealColumnCount());

    table.setColumnWidth(0, "100px");
    assertEquals(1, table.getRealColumnCount());

    table.setColumnWidth(2, "300px");
    assertEquals(3, table.getRealColumnCount());

    table.clearColumnWidth(2);
    assertEquals(1, table.getRealColumnCount());
  }

  public void testDefaultKeyboardSelectionHandlerChangePage() {
    T table = createAbstractHasData();
    DefaultKeyboardSelectionHandler<String> keyHandler =
        new DefaultKeyboardSelectionHandler<String>(table);
    table.setKeyboardSelectionHandler(keyHandler);
    HasDataPresenter<String> presenter = table.getPresenter();

    table.setRowCount(100, true);
    table.setVisibleRange(new Range(50, 10));
    populateData(table);
    presenter.flush();
    table.setKeyboardPagingPolicy(KeyboardPagingPolicy.CHANGE_PAGE);


    table.setKeyboardSelectedRow(1);
    presenter.flush();
    assertEquals(1, table.getKeyboardSelectedRow());
    keyHandler.prevRow();
    presenter.flush();
    assertEquals(0, table.getKeyboardSelectedRow());


    keyHandler.prevRow();
    populateData(table);
    presenter.flush();
    assertEquals(9, table.getKeyboardSelectedRow());
    assertEquals(new Range(40, 10), table.getVisibleRange());


    table.setKeyboardSelectedRow(8);
    presenter.flush();
    assertEquals(8, table.getKeyboardSelectedRow());
    keyHandler.nextRow();
    presenter.flush();
    assertEquals(9, table.getKeyboardSelectedRow());


    keyHandler.nextRow();
    populateData(table);
    presenter.flush();
    assertEquals(0, table.getKeyboardSelectedRow());
    assertEquals(new Range(50, 10), table.getVisibleRange());


    table.setKeyboardSelectedRow(5);
    presenter.flush();
    assertEquals(5, table.getKeyboardSelectedRow());
    keyHandler.prevPage();
    populateData(table);
    presenter.flush();
    assertEquals(0, table.getKeyboardSelectedRow());
    assertEquals(new Range(40, 10), table.getVisibleRange());


    table.setKeyboardSelectedRow(5);
    presenter.flush();
    assertEquals(5, table.getKeyboardSelectedRow());
    keyHandler.nextPage();
    populateData(table);
    presenter.flush();
    assertEquals(0, table.getKeyboardSelectedRow());
    assertEquals(new Range(50, 10), table.getVisibleRange());


    keyHandler.home();
    populateData(table);
    presenter.flush();
    assertEquals(0, table.getKeyboardSelectedRow());
    assertEquals(new Range(0, 10), table.getVisibleRange());


    keyHandler.prevRow();
    presenter.flush();
    assertEquals(0, table.getKeyboardSelectedRow());


    keyHandler.end();
    populateData(table);
    presenter.flush();
    assertEquals(9, table.getKeyboardSelectedRow());
    assertEquals(new Range(90, 10), table.getVisibleRange());


    keyHandler.nextRow();
    presenter.flush();
  }

  public void testDefaultKeyboardSelectionHandlerCurrentPage() {
    T table = createAbstractHasData();
    DefaultKeyboardSelectionHandler<String> keyHandler =
        new DefaultKeyboardSelectionHandler<String>(table);
    table.setKeyboardSelectionHandler(keyHandler);
    HasDataPresenter<String> presenter = table.getPresenter();

    table.setRowCount(100, true);
    table.setVisibleRange(new Range(50, 10));
    populateData(table);
    presenter.flush();
    table.setKeyboardPagingPolicy(KeyboardPagingPolicy.CURRENT_PAGE);


    table.setKeyboardSelectedRow(1);
    presenter.flush();
    assertEquals(1, table.getKeyboardSelectedRow());
    keyHandler.prevRow();
    presenter.flush();
    assertEquals(0, table.getKeyboardSelectedRow());


    keyHandler.prevRow();
    presenter.flush();
    assertEquals(0, table.getKeyboardSelectedRow());
    assertEquals(new Range(50, 10), table.getVisibleRange());


    table.setKeyboardSelectedRow(8);
    presenter.flush();
    assertEquals(8, table.getKeyboardSelectedRow());
    keyHandler.nextRow();
    presenter.flush();
    assertEquals(9, table.getKeyboardSelectedRow());


    keyHandler.nextRow();
    presenter.flush();
    assertEquals(9, table.getKeyboardSelectedRow());
    assertEquals(new Range(50, 10), table.getVisibleRange());


    keyHandler.prevPage(); 
    presenter.flush();
    assertEquals(9, table.getKeyboardSelectedRow());
    assertEquals(new Range(50, 10), table.getVisibleRange());


    keyHandler.nextPage(); 
    presenter.flush();
    assertEquals(9, table.getKeyboardSelectedRow());
    assertEquals(new Range(50, 10), table.getVisibleRange());


    keyHandler.home();
    presenter.flush();
    assertEquals(0, table.getKeyboardSelectedRow());
    assertEquals(new Range(50, 10), table.getVisibleRange());


    keyHandler.end();
    presenter.flush();
    assertEquals(9, table.getKeyboardSelectedRow());
    assertEquals(new Range(50, 10), table.getVisibleRange());
  }

  public void testDefaultKeyboardSelectionHandlerIncreaseRange() {
    int pageStart = 150;
    int pageSize = 10;
    int increment = HasDataPresenter.PAGE_INCREMENT;

    T table = createAbstractHasData();
    DefaultKeyboardSelectionHandler<String> keyHandler =
        new DefaultKeyboardSelectionHandler<String>(table);
    table.setKeyboardSelectionHandler(keyHandler);
    HasDataPresenter<String> presenter = table.getPresenter();

    table.setRowCount(300, true);
    table.setVisibleRange(new Range(pageStart, pageSize));
    populateData(table);
    presenter.flush();
    table.setKeyboardPagingPolicy(KeyboardPagingPolicy.INCREASE_RANGE);


    table.setKeyboardSelectedRow(1);
    presenter.flush();
    assertEquals(1, table.getKeyboardSelectedRow());
    keyHandler.prevRow();
    presenter.flush();
    assertEquals(0, table.getKeyboardSelectedRow());


    keyHandler.prevRow();
    populateData(table);
    presenter.flush();
    pageStart -= increment;
    pageSize += increment;
    assertEquals(increment - 1, table.getKeyboardSelectedRow());
    assertEquals(new Range(pageStart, pageSize), table.getVisibleRange());


    table.setKeyboardSelectedRow(pageSize - 2);
    presenter.flush();
    assertEquals(pageSize - 2, table.getKeyboardSelectedRow());
    keyHandler.nextRow();
    presenter.flush();
    assertEquals(pageSize - 1, table.getKeyboardSelectedRow());


    keyHandler.nextRow();
    populateData(table);
    presenter.flush();
    pageSize += increment;
    assertEquals(pageSize - increment, table.getKeyboardSelectedRow());
    assertEquals(new Range(pageStart, pageSize), table.getVisibleRange());


    table.setKeyboardSelectedRow(increment);
    presenter.flush();
    assertEquals(increment, table.getKeyboardSelectedRow());
    keyHandler.prevPage();
    presenter.flush();
    assertEquals(0, table.getKeyboardSelectedRow());
    assertEquals(new Range(pageStart, pageSize), table.getVisibleRange());


    keyHandler.prevPage();
    populateData(table);
    presenter.flush();
    assertEquals(0, table.getKeyboardSelectedRow());
    pageStart -= increment;
    pageSize += increment;
    assertEquals(new Range(pageStart, pageSize), table.getVisibleRange());


    keyHandler.nextPage();
    presenter.flush();
    assertEquals(increment, table.getKeyboardSelectedRow());
    assertEquals(new Range(pageStart, pageSize), table.getVisibleRange());


    table.setKeyboardSelectedRow(pageSize - 1);
    presenter.flush();
    assertEquals(pageSize - 1, table.getKeyboardSelectedRow());
    keyHandler.nextPage();
    populateData(table);
    presenter.flush();
    pageSize += increment;
    assertEquals(pageSize - 1, table.getKeyboardSelectedRow());
    assertEquals(new Range(pageStart, pageSize), table.getVisibleRange());


    keyHandler.home();
    populateData(table);
    presenter.flush();
    pageSize += pageStart;
    pageStart = 0;
    assertEquals(0, table.getKeyboardSelectedRow());
    assertEquals(new Range(pageStart, pageSize), table.getVisibleRange());


    keyHandler.prevRow();
    presenter.flush();
    assertEquals(0, table.getKeyboardSelectedRow());
    assertEquals(new Range(pageStart, pageSize), table.getVisibleRange());


    keyHandler.end();
    pageSize = 300;
    populateData(table);
    presenter.flush();
    assertEquals(pageSize - 1, table.getKeyboardSelectedRow());
    assertEquals(new Range(0, pageSize), table.getVisibleRange());


    keyHandler.nextRow();
    presenter.flush();
    assertEquals(pageSize - 1, table.getKeyboardSelectedRow());
    assertEquals(new Range(pageStart, pageSize), table.getVisibleRange());
  }

  public void testGetColumnIndex() {
    T table = createAbstractHasData();
    Column<String, String> col0 = new IdentityColumn<String>(new TextCell());
    table.addColumn(col0);
    Column<String, String> col1 = new IdentityColumn<String>(new TextCell());
    table.addColumn(col1);
    Column<String, String> col2 = new IdentityColumn<String>(new TextCell());
    table.addColumn(col2);
    assertEquals(0, table.getColumnIndex(col0));
    assertEquals(1, table.getColumnIndex(col1));
    assertEquals(2, table.getColumnIndex(col2));


    Column<String, String> other = new IdentityColumn<String>(new TextCell());
    assertEquals(-1, table.getColumnIndex(other));


    assertEquals(-1, table.getColumnIndex(null));
  }

  public void testGetColumnOutOfBounds() {
    T table = createAbstractHasData();


    try {
      table.getColumn(0);
      fail("Expected IndexOutOfBoundsException");
    } catch (IndexOutOfBoundsException e) {

    }


    table.addColumn(new MockColumn<String, String>());
    table.addColumn(new MockColumn<String, String>());


    try {
      table.getColumn(-1);
      fail("Expected IndexOutOfBoundsException");
    } catch (IndexOutOfBoundsException e) {

    }


    try {
      table.getColumn(2);
      fail("Expected IndexOutOfBoundsException");
    } catch (IndexOutOfBoundsException e) {

    }
  }

  public void testGetRowElement() {
    AbstractCellTable<String> table = createAbstractHasData(new TextCell());
    table.setRowData(0, createData(0, 10));


    assertNotNull(table.getRowElement(9));
  }

  public void testGetSubRowElement() {
    T table = createAbstractHasData(new TextCell());
    CellTableBuilder<String> builder = new DefaultCellTableBuilder<String>(table) {
      @Override
      public void buildRowImpl(String rowValue, int absRowIndex) {
        super.buildRowImpl(rowValue, absRowIndex);


        for (int i = 0; i < 4; i++) {
          TableRowBuilder tr = startRow(rowValue);
          tr.startTD().colSpan(2).text("child " + absRowIndex + ":" + i).endTD();
          tr.endTR();
        }
      }
    };
    table.setTableBuilder(builder);
    table.setVisibleRange(0, 5);
    populateData(table);
    table.getPresenter().flush();


    TableSectionElement tbody = table.getTableBodyElement();
    assertEquals(25, tbody.getChildCount());


    assertEquals(0, table.getSubRowElement(0, 0).getSectionRowIndex());
    assertEquals(1, table.getSubRowElement(0, 1).getSectionRowIndex());
    assertEquals(4, table.getSubRowElement(0, 4).getSectionRowIndex());
    assertEquals(5, table.getSubRowElement(1, 0).getSectionRowIndex());
    assertEquals(8, table.getSubRowElement(1, 3).getSectionRowIndex());
    assertEquals(20, table.getSubRowElement(4, 0).getSectionRowIndex());
    assertEquals(24, table.getSubRowElement(4, 4).getSectionRowIndex());


    assertNull(table.getSubRowElement(0, 5));
    assertNull(table.getSubRowElement(4, 5));


    try {
      assertNull(table.getSubRowElement(5, 0));
      fail("Expected IndexOutOfBoundsException: row index is out of bounds");
    } catch (IndexOutOfBoundsException e) {

    }
  }

  public void testHeaderEvent() {
    T table = createAbstractHasData();
    IndexCell<String> cell = new IndexCell<String>("click");
    table.addColumn(new TextColumn<String>() {
      @Override
      public String getValue(String object) {
        return object;
      }
    }, new Header<String>(cell) {
      @Override
      public String getValue() {
        return "header0";
      }
    });
    RootPanel.get().add(table);
    table.setRowData(createData(0, 10));
    table.getPresenter().flush();


    NativeEvent event = Document.get().createClickEvent(0, 0, 0, 0, 0, false, false, false, false);
    getHeaderElement(table, 0).dispatchEvent(event);
    cell.assertLastBrowserEventIndex(0);

    RootPanel.get().remove(table);
  }

  public void testSetHeaderBuilder() {
    T table = createAbstractHasData();
    HeaderBuilder<String> headerBuilder = new AbstractHeaderOrFooterBuilder<String>(table, false) {
      @Override
      protected boolean buildHeaderOrFooterImpl() {
        TableRowBuilder tr = startRow();
        tr.startTH().text("Col 0").endTH();
        tr.startTH().text("Col 1").endTH();
        tr.startTH().text("Col 2").endTH();
        tr.endTR();
        return true;
      }
    };


    table.setHeaderBuilder(headerBuilder);
    assertEquals(headerBuilder, table.getHeaderBuilder());
    table.getPresenter().flush();


    NodeList<TableRowElement> rows = table.getTableHeadElement().getRows();
    assertEquals(1, rows.getLength());
    NodeList<TableCellElement> cells = rows.getItem(0).getCells();
    assertEquals(3, cells.getLength());
    assertEquals("Col 0", cells.getItem(0).getInnerText());
    assertEquals("Col 1", cells.getItem(1).getInnerText());
    assertEquals("Col 2", cells.getItem(2).getInnerText());
  }

  public void testSetFooterBuilder() {
    T table = createAbstractHasData();
    FooterBuilder<String> footerBuilder = new AbstractHeaderOrFooterBuilder<String>(table, true) {
      @Override
      protected boolean buildHeaderOrFooterImpl() {
        TableRowBuilder tr = startRow();
        tr.startTH().text("Col 0").endTH();
        tr.startTH().text("Col 1").endTH();
        tr.startTH().text("Col 2").endTH();
        tr.endTR();
        return true;
      }
    };


    table.setFooterBuilder(footerBuilder);
    assertEquals(footerBuilder, table.getFooterBuilder());
    table.getPresenter().flush();


    NodeList<TableRowElement> rows = table.getTableFootElement().getRows();
    assertEquals(1, rows.getLength());
    NodeList<TableCellElement> cells = rows.getItem(0).getCells();
    assertEquals(3, cells.getLength());
    assertEquals("Col 0", cells.getItem(0).getInnerText());
    assertEquals("Col 1", cells.getItem(1).getInnerText());
    assertEquals("Col 2", cells.getItem(2).getInnerText());
  }

  public void testInsertColumn() {
    T table = createAbstractHasData();
    assertEquals(0, table.getColumnCount());


    Column<String, ?> a = new MockColumn<String, String>();
    table.insertColumn(0, a);
    assertEquals(1, table.getColumnCount());
    assertEquals(a, table.getColumn(0));


    Column<String, ?> b = new MockColumn<String, String>();
    table.insertColumn(0, b);
    assertEquals(2, table.getColumnCount());
    assertEquals(b, table.getColumn(0));
    assertEquals(a, table.getColumn(1));


    Column<String, ?> c = new MockColumn<String, String>();
    table.insertColumn(2, c);
    assertEquals(3, table.getColumnCount());
    assertEquals(b, table.getColumn(0));
    assertEquals(a, table.getColumn(1));
    assertEquals(c, table.getColumn(2));


    Column<String, ?> d = new MockColumn<String, String>();
    table.insertColumn(1, d);
    assertEquals(4, table.getColumnCount());
    assertEquals(b, table.getColumn(0));
    assertEquals(d, table.getColumn(1));
    assertEquals(a, table.getColumn(2));
    assertEquals(c, table.getColumn(3));


    try {
      table.insertColumn(-1, d);
      fail("Expected IndexOutOfBoundsExecltion");
    } catch (IndexOutOfBoundsException e) {

    }
    try {
      table.insertColumn(6, d);
      fail("Expected IndexOutOfBoundsExecltion");
    } catch (IndexOutOfBoundsException e) {

    }
  }

  public void testSetAutoFooterRefreshDisabled() {
    AbstractCellTable<String> table = createAbstractHasData();
    assertFalse(table.isAutoHeaderRefreshDisabled());
    assertFalse(table.isAutoFooterRefreshDisabled());

    table.setAutoFooterRefreshDisabled(true);
    assertFalse(table.isAutoHeaderRefreshDisabled());
    assertTrue(table.isAutoFooterRefreshDisabled());


    final List<String> log = new ArrayList<String>();
    Column<String, ?> col0 = new MockColumn<String, String>();
    TextHeader header0 = new TextHeader("header0") {
      @Override
      public void render(Context context, SafeHtmlBuilder sb) {
        super.render(context, sb);
        log.add("header0 rendered");
      }
    };
    TextHeader footer0 = new TextHeader("footer0") {
      @Override
      public void render(Context context, SafeHtmlBuilder sb) {
        super.render(context, sb);
        log.add("footer0 rendered");
      }
    };
    table.addColumn(col0, header0, footer0);
    assertEquals(0, log.size()); 
    table.getPresenter().flush(); 
    assertEquals("header0 rendered", log.remove(0));
    assertEquals("footer0 rendered", log.remove(0));
    assertEquals(0, log.size());


    Column<String, ?> col1 = new MockColumn<String, String>();
    TextHeader header1 = new TextHeader("header1") {
      @Override
      public void render(Context context, SafeHtmlBuilder sb) {
        super.render(context, sb);
        log.add("header1 rendered");
      }
    };
    TextHeader footer1 = new TextHeader("footer1") {
      @Override
      public void render(Context context, SafeHtmlBuilder sb) {
        super.render(context, sb);
        log.add("footer1 rendered");
      }
    };
    table.addColumn(col1, header1, footer1);
    assertEquals(0, log.size()); 
    table.getPresenter().flush(); 
    assertEquals("header0 rendered", log.remove(0));
    assertEquals("header1 rendered", log.remove(0));
    assertEquals("footer0 rendered", log.remove(0));
    assertEquals("footer1 rendered", log.remove(0));
    assertEquals(0, log.size());


    table.removeColumn(col0);
    assertEquals(0, log.size()); 
    table.getPresenter().flush(); 
    assertEquals("header1 rendered", log.remove(0));
    assertEquals("footer1 rendered", log.remove(0));
    assertEquals(0, log.size());


    populateData(table);
    assertEquals(0, log.size()); 
    table.getPresenter().flush(); 
    assertEquals("header1 rendered", log.remove(0));
    assertEquals(0, log.size());


    table.getColumnSortList().push(col1);
    assertEquals("header1 rendered", log.remove(0));
    assertEquals(0, log.size());
  }

  public void testSetAutoHeaderRefreshDisabled() {
    AbstractCellTable<String> table = createAbstractHasData();
    assertFalse(table.isAutoHeaderRefreshDisabled());
    assertFalse(table.isAutoFooterRefreshDisabled());

    table.setAutoHeaderRefreshDisabled(true);
    assertTrue(table.isAutoHeaderRefreshDisabled());
    assertFalse(table.isAutoFooterRefreshDisabled());


    final List<String> log = new ArrayList<String>();
    Column<String, ?> col0 = new MockColumn<String, String>();
    TextHeader header0 = new TextHeader("header0") {
      @Override
      public void render(Context context, SafeHtmlBuilder sb) {
        super.render(context, sb);
        log.add("header0 rendered");
      }
    };
    TextHeader footer0 = new TextHeader("footer0") {
      @Override
      public void render(Context context, SafeHtmlBuilder sb) {
        super.render(context, sb);
        log.add("footer0 rendered");
      }
    };
    table.addColumn(col0, header0, footer0);
    assertEquals(0, log.size()); 
    table.getPresenter().flush(); 
    assertEquals("header0 rendered", log.remove(0));
    assertEquals("footer0 rendered", log.remove(0));
    assertEquals(0, log.size());


    Column<String, ?> col1 = new MockColumn<String, String>();
    TextHeader header1 = new TextHeader("header1") {
      @Override
      public void render(Context context, SafeHtmlBuilder sb) {
        super.render(context, sb);
        log.add("header1 rendered");
      }
    };
    TextHeader footer1 = new TextHeader("footer1") {
      @Override
      public void render(Context context, SafeHtmlBuilder sb) {
        super.render(context, sb);
        log.add("footer1 rendered");
      }
    };
    table.addColumn(col1, header1, footer1);
    assertEquals(0, log.size()); 
    table.getPresenter().flush(); 
    assertEquals("header0 rendered", log.remove(0));
    assertEquals("header1 rendered", log.remove(0));
    assertEquals("footer0 rendered", log.remove(0));
    assertEquals("footer1 rendered", log.remove(0));
    assertEquals(0, log.size());


    table.removeColumn(col0);
    assertEquals(0, log.size()); 
    table.getPresenter().flush(); 
    assertEquals("header1 rendered", log.remove(0));
    assertEquals("footer1 rendered", log.remove(0));
    assertEquals(0, log.size());


    populateData(table);
    assertEquals(0, log.size()); 
    table.getPresenter().flush(); 
    assertEquals("footer1 rendered", log.remove(0));
    assertEquals(0, log.size());


    table.getColumnSortList().push(col1);
    assertEquals("header1 rendered", log.remove(0));
    assertEquals(0, log.size());
  }

  public void testSetColumnWidth() {
    AbstractCellTable<String> table = createAbstractHasData(new TextCell());
    Column<String, ?> col0 = new MockColumn<String, String>();
    Column<String, ?> col1 = new MockColumn<String, String>();
    Column<String, ?> col2 = new MockColumn<String, String>();


    table.setColumnWidth(col0, "100px");
    table.setColumnWidth(col1, 200.0, Unit.EM);
    assertEquals("100px", table.getColumnWidth(col0));


    assertTrue(table.getColumnWidth(col1).contains("200"));


    assertNull(table.getColumnWidth(col2));


    table.clearColumnWidth(col0);
    assertNull(table.getColumnWidth(col0));
  }


  public void testSetColumnWidthMixed() {
    AbstractCellTable<String> table = createAbstractHasData(new TextCell());
    Column<String, ?> col0 = new MockColumn<String, String>();
    Column<String, ?> col1 = new MockColumn<String, String>();
    Column<String, ?> col2 = new MockColumn<String, String>();


    table.setColumnWidth(col0, "100px");


    table.setColumnWidth(col1, 200.0, Unit.EM);
    table.setColumnWidth(1, "210em");


    table.setColumnWidth(2, "300px");

    assertEquals("100px", table.getColumnWidth(col0));
    assertEquals("300px", table.getColumnWidth(2));


    assertTrue(table.getColumnWidth(col1).contains("200"));


    assertNull(table.getColumnWidth(col2));


    table.clearColumnWidth(col0);
    assertNull(table.getColumnWidth(col0));
  }

  public void testSetEmptyTableWidget() {
    AbstractCellTable<String> table = createAbstractHasData(new TextCell());


    Label l = new Label("Empty");
    table.setEmptyTableWidget(l);
    assertEquals(l, table.getEmptyTableWidget());


    table.setEmptyTableWidget(null);
    assertNull(table.getEmptyTableWidget());
  }

  public void testSetKeyboardSelectedRow() {
    AbstractCellTable<String> table = createAbstractHasData(new TextCell());
    table.setVisibleRange(0, 10);


    table.setKeyboardSelectedRow(5);
    assertEquals(5, table.getKeyboardSelectedRow());
    assertEquals(0, table.getKeyboardSelectedSubRow());


    table.setKeyboardSelectedRow(6, 2, false);
    assertEquals(6, table.getKeyboardSelectedRow());
    assertEquals(2, table.getKeyboardSelectedSubRow());


    table.setKeyboardSelectedRow(6, 5, false);
    assertEquals(6, table.getKeyboardSelectedRow());
    assertEquals(5, table.getKeyboardSelectedSubRow());


    table.setKeyboardSelectedRow(7);
    assertEquals(7, table.getKeyboardSelectedRow());
    assertEquals(0, table.getKeyboardSelectedSubRow());
  }

  public void testSetLoadingIndicator() {
    AbstractCellTable<String> table = createAbstractHasData(new TextCell());


    Label l = new Label("Loading");
    table.setLoadingIndicator(l);
    assertEquals(l, table.getLoadingIndicator());


    table.setLoadingIndicator(null);
    assertNull(table.getLoadingIndicator());
  }

  public void testSortableColumn() {
    T table = createAbstractHasData(new TextCell());
    table.getColumn(0).setSortable(true);
    table.getPresenter().flush();
    RootPanel.get().add(table);


    final List<Column<?, ?>> lastSorted = new ArrayList<Column<?, ?>>();
    table.addColumnSortHandler(new ColumnSortEvent.Handler() {
      @Override
      public void onColumnSort(ColumnSortEvent event) {
        lastSorted.clear();
        lastSorted.add(event.getColumn());
      }
    });


    ColumnSortList sortList = table.getColumnSortList();
    assertEquals(0, sortList.size());


    NativeEvent click = Document.get().createClickEvent(0, 0, 0, 0, 0, false, false, false, false);
    getHeaderElement(table, 0).dispatchEvent(click);
    assertEquals(1, sortList.size());
    assertEquals(table.getColumn(0), sortList.get(0).getColumn());
    assertTrue(sortList.get(0).isAscending());
    assertEquals(1, lastSorted.size());
    lastSorted.clear();


    getHeaderElement(table, 0).dispatchEvent(click);
    assertEquals(1, sortList.size());
    assertEquals(table.getColumn(0), sortList.get(0).getColumn());
    assertFalse(sortList.get(0).isAscending());
    assertEquals(1, lastSorted.size());
    lastSorted.clear();
    

    NativeEvent enter = Document.get().createKeyDownEvent(false, false, false, false,
        KeyCodes.KEY_ENTER);
    getHeaderElement(table, 0).dispatchEvent(enter);
    assertEquals(1, sortList.size());
    assertEquals(table.getColumn(0), sortList.get(0).getColumn());
    assertTrue(sortList.get(0).isAscending());
    assertEquals(1, lastSorted.size());
    lastSorted.clear();


    getHeaderElement(table, 0).dispatchEvent(enter);
    assertEquals(1, sortList.size());
    assertEquals(table.getColumn(0), sortList.get(0).getColumn());
    assertFalse(sortList.get(0).isAscending());
    assertEquals(1, lastSorted.size());
    lastSorted.clear();


    getHeaderElement(table, 1).dispatchEvent(click);
    assertEquals(1, sortList.size());
    assertEquals(table.getColumn(0), sortList.get(0).getColumn());
    assertFalse(sortList.get(0).isAscending());
    assertEquals(0, lastSorted.size());


    RootPanel.get().remove(table);
  }


  protected abstract T createAbstractHasData();

  @Override
  protected final T createAbstractHasData(Cell<String> cell) {
    T table = createAbstractHasData();
    table.addColumn(new Column<String, String>(cell) {
      @Override
      public String getValue(String object) {
        return object;
      }
    }, "Column 0");
    table.addColumn(new Column<String, String>(new TextCell()) {
      @Override
      public String getValue(String object) {
        return object + "-2";
      }
    }, "Column 1");
    return table;
  }


  protected abstract TableCellElement getBodyElement(T table, int row, int column);


  protected abstract int getHeaderCount(T table);


  protected abstract TableCellElement getHeaderElement(T table, int column);
}
