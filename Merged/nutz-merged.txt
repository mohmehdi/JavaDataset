package org.nutz.dao.util;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Types;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import javax.sql.DataSource;

import org.nutz.dao.Chain;
import org.nutz.dao.Condition;
import org.nutz.dao.ConnCallback;
import org.nutz.dao.Dao;
import org.nutz.dao.DaoException;
import org.nutz.dao.FieldFilter;
import org.nutz.dao.FieldMatcher;
import org.nutz.dao.Sqls;
import org.nutz.dao.TableName;
import org.nutz.dao.entity.Entity;
import org.nutz.dao.entity.MappingField;
import org.nutz.dao.entity.annotation.Table;
import org.nutz.dao.impl.NutDao;
import org.nutz.dao.jdbc.JdbcExpert;
import org.nutz.dao.jdbc.Jdbcs;
import org.nutz.dao.jdbc.ValueAdaptor;
import org.nutz.dao.pager.Pager;
import org.nutz.dao.sql.Sql;
import org.nutz.dao.sql.SqlCallback;
import org.nutz.lang.Lang;
import org.nutz.lang.Strings;
import org.nutz.lang.util.Callback2;
import org.nutz.log.Log;
import org.nutz.log.Logs;
import org.nutz.resource.Scans;
import org.nutz.trans.Molecule;
import org.nutz.trans.Trans;


public abstract class Daos {
    
    private static final Log log = Logs.get();


    public static void safeClose(Statement stat, ResultSet rs) {
        safeClose(rs);
        safeClose(stat);
    }


    public static void safeClose(Statement stat) {
        if (null != stat)
            try {
                stat.close();
            }
            catch (Throwable e) {}
    }


    public static void safeClose(ResultSet rs) {
        if (null != rs)
            try {
                rs.close();
            }
            catch (Throwable e) {}
    }


    public static int getColumnIndex(ResultSetMetaData meta, String colName) throws SQLException {
        if (meta == null)
            return 0;
        int columnCount = meta.getColumnCount();
        for (int i = 1; i <= columnCount; i++)
            if (meta.getColumnName(i).equalsIgnoreCase(colName))
                return i;

        log.infof("Can not find @Column(%s) in table/view (%s)", colName, meta.getTableName(1));
        throw Lang.makeThrow(SQLException.class, "Can not find @Column(%s)", colName);
    }


    public static boolean isIntLikeColumn(ResultSetMetaData meta, int index) throws SQLException {
        switch (meta.getColumnType(index)) {
        case Types.BIGINT:
        case Types.INTEGER:
        case Types.SMALLINT:
        case Types.TINYINT:
        case Types.NUMERIC:
            return true;
        }
        return false;
    }


    public static Pager updatePagerCount(Pager pager, Dao dao, Class<?> entityType, Condition cnd) {
        if (null != pager) {
            pager.setRecordCount(dao.count(entityType, cnd));
        }
        return pager;
    }


    public static Pager updatePagerCount(Pager pager, Dao dao, String tableName, Condition cnd) {
        if (null != pager) {
            pager.setRecordCount(dao.count(tableName, cnd));
        }
        return pager;
    }


    public static <T> List<T> queryList(Dao dao, Class<T> klass, String sql_str) {
        Sql sql = Sqls.create(sql_str)
                        .setCallback(Sqls.callback.entities())
                        .setEntity(dao.getEntity(klass));
        dao.execute(sql);
        return sql.getList(klass);
    }


    public static Object query(Dao dao, String sql_str, SqlCallback callback) {
        Sql sql = Sqls.create(sql_str).setCallback(callback);
        dao.execute(sql);
        return sql.getResult();
    }


    public static <T> List<T> queryWithLinks(    final Dao dao,
                                                final Class<T> classOfT,
                                                final Condition cnd,
                                                final Pager pager,
                                                final String regex) {
        Molecule<List<T>> molecule = new Molecule<List<T>>() {
            public void run() {
                List<T> list = dao.query(classOfT, cnd, pager);
                for (T t : list)
                    dao.fetchLinks(t, regex);
                setObj(list);
            }
        };
        return Trans.exec(molecule);
    }


    public static StringBuilder dataDict(DataSource ds, String...packages) {
        StringBuilder sb = new StringBuilder();
        List<Class<?>> ks = new ArrayList<Class<?>>();
        for (String packageName : packages) {
            ks.addAll(Scans.me().scanPackage(packageName));
        }
        Iterator<Class<?>> it = ks.iterator();
        while (it.hasNext()) {
            Class<?> klass = it.next();
            if (klass.getAnnotation(Table.class) == null)
                it.remove();
        }

        
        JdbcExpert exp = Jdbcs.getExpert(ds);
        NutDao dao = new NutDao(ds);
        
        Method evalFieldType;
        try {
            evalFieldType = exp.getClass().getDeclaredMethod("evalFieldType", MappingField.class);
        } catch (Throwable e) {
            throw Lang.wrapThrow(e);
        }
        evalFieldType.setAccessible(true);
        Entity<?> entity = null;
        String line = "-------------------------------------------------------------------\n";
        sb.append("#title:æ°æ?®å­å¸\n");
        sb.append("#author:wendal\n");
        sb.append("#index:0,1\n").append(line);
        for (Class<?> klass : ks) {
            sb.append(line);
            entity = dao.getEntity(klass);
            sb.append("è¡¨å?? ").append(entity.getTableName()).append("\n\n");
                if (!Strings.isBlank(entity.getTableComment()))
                    sb.append("è¡¨æ³¨é: ").append(entity.getTableComment());
                sb.append("\t").append("Javaç±»å?? ").append(klass.getName()).append("\n\n");
                sb.append("\t||åº?å?·||åå??||æ°æ?®ç±»å||ä¸»é®||é?ç©º||é»è®¤å¼||javaå±æ§å??||javaç±»å||æ³¨é||\n");
                int index = 1;
                for (MappingField field : entity.getMappingFields()) {
                    String dataType;
                    try {
                        dataType = (String) evalFieldType.invoke(exp, field);
                    } catch (Throwable e) {
                        throw Lang.wrapThrow(e); 
                    }
                    sb.append("\t||").append(index++).append("||")
                        .append(field.getColumnName()).append("||")
                        .append(dataType).append("||")
                        .append(field.isPk()).append("||")
                        .append(field.isNotNull()).append("||")
                        .append(field.getDefaultValue(null) == null ? " " : field.getDefaultValue(null)).append("||")
                        .append(field.getName()).append("||")
                        .append(field.getTypeClass().getName()).append("||")
                        .append(field.getColumnComment() == null ? " " : field.getColumnComment()).append("||\n");
                }
        }
        return sb;
    }
    

    public static <T> List<T> query(Dao dao, Class<T> classOfT, String sql, Condition cnd, Pager pager) {
        Sql sql2 = Sqls.queryEntity(sql);
        sql2.setEntity(dao.getEntity(classOfT));
        sql2.setCondition(cnd);
        sql2.setPager(pager);
        dao.execute(sql2);
        return sql2.getList(classOfT);
    }
    

    public static long queryCount(Dao dao, String sql) {
        Sql sql2 = Sqls.fetchInt("select count(1) from (" +sql + ") as _nutz_tmp_" + System.currentTimeMillis());
        dao.execute(sql2);
        return sql2.getInt();
    }
    

    @SuppressWarnings({ "rawtypes" })
    public static int updateBySpecialChain(Dao dao, Entity en, String tableName, Chain chain, Condition cnd) {
        if (en != null)
            tableName = en.getTableName();
        if (tableName == null)
            throw Lang.makeThrow(DaoException.class, "tableName and en is NULL !!");
        final StringBuilder sql = new StringBuilder("UPDATE ").append(tableName).append(" SET ");
        Chain head = chain.head();
        final List<Object> values = new ArrayList<Object>();
        final List<ValueAdaptor> adaptors = new ArrayList<ValueAdaptor>();
        while (head != null) {
            MappingField mf = null;
            if (en != null)
                mf = en.getField(head.name());
            String colName = head.name();
            if (mf != null)
                colName = mf.getColumnName();
            sql.append(colName).append("=");
            if (head.special()) {
            	if (head.value() != null && head.value() instanceof String) {
            		String str = (String)head.value();
            		if (str.length() > 0) {
            			switch (str.charAt(0)) {
						case '+':
						case '-':
						case '*':
						case '/':
						case '%':
						case '&':
						case '^':
						case '|':
							sql.append(colName);
							break;
						}
            		}
                }
                sql.append(head.value());
            } else {
                sql.append("?");
                values.add(head.value());
                ValueAdaptor adaptor = Jdbcs.getAdaptorBy(head.value());
                if (mf != null && mf.getAdaptor() != null)
                    adaptor = mf.getAdaptor();
                adaptors.add(adaptor);
            }
            sql.append(" ");
            head = head.next();
            if (head != null)
                sql.append(", ");
        }
        if (cnd != null)
            sql.append(" ").append(cnd.toSql(en));
        if (log.isDebugEnabled())
            log.debug(sql);
        final int[] ints = new int[1];
        dao.run(new ConnCallback() {
            public void invoke(Connection conn) throws Exception {
                PreparedStatement ps = conn.prepareStatement(sql.toString());
                try {
                    for (int i = 0; i < values.size(); i++)
                        adaptors.get(i).set(ps, values.get(i), i + 1);
                    ints[0] = ps.executeUpdate();
                } finally {
                    Daos.safeClose(ps);
                }
            }
        });
        return ints[0];
    }
    

    @SuppressWarnings({ "rawtypes" })
    public static void insertBySpecialChain(Dao dao, Entity en, String tableName, Chain chain) {
        if (en != null)
            tableName = en.getTableName();
        if (tableName == null)
            throw Lang.makeThrow(DaoException.class, "tableName and en is NULL !!");
        final StringBuilder sql = new StringBuilder("INSERT INTO ").append(tableName).append(" (");
        StringBuilder _value_places = new StringBuilder(" VALUES(");
        final List<Object> values = new ArrayList<Object>();
        final List<ValueAdaptor> adaptors = new ArrayList<ValueAdaptor>();
        Chain head = chain.head();
        while (head != null) {
        	String colName = head.name();
        	MappingField mf = null;
            if (en != null) {
                mf = en.getField(colName);
                if (mf != null)
                	colName = mf.getColumnName();
            }
            sql.append(colName);
            
            if (head.special()) {
            	_value_places.append(head.value());
            } else {
                if (en != null)
                    mf = en.getField(head.name());
                _value_places.append("?");
                values.add(head.value());
                ValueAdaptor adaptor = Jdbcs.getAdaptorBy(head.value());
                if (mf != null && mf.getAdaptor() != null)
                    adaptor = mf.getAdaptor();
                adaptors.add(adaptor);
            }
            
            head = head.next();
            if (head != null) {
                sql.append(", ");
                _value_places.append(", ");
            }
        }
        sql.append(")");
        _value_places.append(")");
        sql.append(_value_places);
        if (log.isDebugEnabled())
            log.debug(sql);
        dao.run(new ConnCallback() {
            public void invoke(Connection conn) throws Exception {
                PreparedStatement ps = conn.prepareStatement(sql.toString());
                try {
                    for (int i = 0; i < values.size(); i++)
                        adaptors.get(i).set(ps, values.get(i), i + 1);
                    ps.execute();
                } finally {
                    Daos.safeClose(ps);
                }
            }
        });
    }
    

    public static void createTablesInPackage(Dao dao, String packageName, boolean force) {
    	for (Class<?> klass : Scans.me().scanPackage(packageName)) {
			if (klass.getAnnotation(Table.class) != null)
				dao.create(klass, force);
		}
    }
    
	private static Class<?>[] iz = new Class<?>[]{Dao.class};
	

	public static Dao ext(Dao dao, FieldFilter filter) {
		return ext(dao, filter, null);
	}
	

	public static Dao ext(Dao dao, Object tableName) {
		return ext(dao, null, tableName);
	}
	

	public static Dao ext(Dao dao, FieldFilter filter, Object tableName) {
		if (tableName == null && filter == null)
			return dao;
		ExtDaoInvocationHandler handler = new ExtDaoInvocationHandler(dao, filter, tableName);
		return (Dao) Proxy.newProxyInstance(dao.getClass().getClassLoader(), iz, handler);
	}

    
    @SuppressWarnings({"unchecked", "rawtypes"})
    public static boolean filterFields(Object obj, FieldMatcher matcher, Dao dao, Callback2<MappingField, Object> callback) {
        if (obj == null)
            return false;
        obj = Lang.first(obj);
        if (obj == null) {
            return false;
        }
        if (obj.getClass() == Class.class) {
            throw Lang.impossible();
        }
        if (obj instanceof String || obj instanceof Number || obj instanceof Boolean) {
            throw Lang.impossible();
        }
        Entity en = dao.getEntity(obj.getClass());
        if (en == null) {
            throw Lang.impossible();
        }
        
        List<MappingField> mfs = en.getMappingFields();
        if (matcher != null) {
                Iterator<MappingField> it = mfs.iterator();
                while (it.hasNext()) {
                    MappingField mf = it.next();
                    if (!matcher.match(mf.getName()))
                        it.remove();
                }
        }
        boolean flag = false;
        for (MappingField mf : mfs) {
            if (matcher.isIgnoreId() && mf.isId())
                continue;
            if (matcher.isIgnoreName() && mf.isName())
                continue;
            if (matcher.isIgnorePk() && mf.isCompositePk())
                continue;
            Object val = mf.getValue(obj);
            if (val == null) {
                if (matcher.isIgnoreNull())
                    continue;
            } if (val instanceof Number && ((Number)val).doubleValue() == 0.0) {
                if (matcher.isIgnoreZero())
                    continue;
            } if (val instanceof Date) {
                if (matcher.isIgnoreDate())
                    continue;
            }
            callback.invoke(mf, val);
            flag = true;
        }
        return flag;
    }
    

    public static void migration(final Dao dao, final Class<?> klass, final boolean add, final boolean del) {
        final Entity<?> en = dao.getEntity(klass);
        if (!dao.exists(klass))
            return;
        final JdbcExpert expert = ((NutDao)dao).getJdbcExpert();
        final List<Sql> sqls = new ArrayList<Sql>();
        final boolean sqlAddNeedColumn = !dao.meta().isOracle();
        dao.run(new ConnCallback() {
            public void invoke(Connection conn) throws Exception {
                Statement stat = null;
                ResultSet rs = null;
                ResultSetMetaData meta = null;
                try {

                    stat = conn.createStatement();
                    rs = stat.executeQuery("select * from " + en.getTableName() + " where 1 != 1");
                    meta = rs.getMetaData();
                    
                    Set<String> columnNames = new HashSet<String>();
                    int columnCount = meta.getColumnCount();
                    for (int i = 1; i <= columnCount; i++) {
                        columnNames.add(meta.getColumnName(i).toLowerCase());
                    }
                    for (MappingField mf : en.getMappingFields()) {
                        String colName = mf.getColumnName();
                        if (columnNames.contains(colName.toLowerCase())) {
                            columnNames.remove(colName);
                            continue;
                        }
                        if (add) {
                            log.infof("add column[%s] to table[%s]", mf.getColumnName(), en.getTableName());
                            Sql sql = Sqls.create("ALTER table $table ADD " + (sqlAddNeedColumn ? "column" : "") + "$name $type");
                            sql.vars().set("table", en.getTableName());
                            sql.vars().set("name", mf.getColumnName());
                            sql.vars().set("type", expert.evalFieldType(mf));
                            sqls.add(sql);
                        }
                    }
                    if (del) {
                        for (String colName : columnNames) {
                            log.infof("del column[%s] from table[%s]", colName, en.getTableName());
                            Sql sql = Sqls.create("ALTER table $table DROP column $name");
                            sql.vars().set("table", en.getTableName());
                            sql.vars().set("name", colName);
                            sqls.add(sql);
                        }
                    }
                }
                catch (SQLException e) {
                    if (log.isDebugEnabled())
                        log.debugf("migration Table '%s' fail!", en.getTableName(), e);
                }

                finally {
                    Daos.safeClose(stat, rs);
                }
            }
        });
        for (Sql sql : sqls) {
            dao.execute(sql);
        }
    }


    public static void migration(Dao dao, String packageName, boolean add, boolean del) {
        for (Class<?> klass : Scans.me().scanPackage(packageName)) {
            if (klass.getAnnotation(Table.class) != null) {
                migration(dao, klass, add, del);
            }
        }
    }
}

class ExtDaoInvocationHandler implements InvocationHandler {
	
	protected ExtDaoInvocationHandler(Dao dao, FieldFilter filter, Object tableName) {
		this.dao = dao;
		this.filter = filter;
		this.tableName = tableName;
	}
 
	public Dao dao;
	public FieldFilter filter;
	public Object tableName;
 
	public Object invoke(Object proxy, final Method method, final Object[] args) throws Throwable {
		
		final Molecule<Object> m = new Molecule<Object>() {
			public void run() {
				try {
					setObj(method.invoke(dao, args));
				}
				catch (IllegalArgumentException e) {
					throw Lang.wrapThrow(e);
				}
				catch (IllegalAccessException e) {
					throw Lang.wrapThrow(e);
				}
				catch (InvocationTargetException e) {
					throw Lang.wrapThrow(e.getTargetException());
				}
			}
		};
		if (filter != null && tableName != null) {
			TableName.run(tableName, new Runnable() {
				public void run() {
					filter.run(m);
				}
			});
			return m.getObj();
		}
		if (filter != null)
			filter.run(m);
		else
			TableName.run(tableName, m);
		return m.getObj();
	}
}
<code block>
package org.nutz.dao.util;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Types;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import javax.sql.DataSource;

import org.nutz.dao.Chain;
import org.nutz.dao.Condition;
import org.nutz.dao.ConnCallback;
import org.nutz.dao.Dao;
import org.nutz.dao.DaoException;
import org.nutz.dao.FieldFilter;
import org.nutz.dao.FieldMatcher;
import org.nutz.dao.Sqls;
import org.nutz.dao.TableName;
import org.nutz.dao.entity.Entity;
import org.nutz.dao.entity.MappingField;
import org.nutz.dao.entity.annotation.ColType;
import org.nutz.dao.entity.annotation.Table;
import org.nutz.dao.impl.NutDao;
import org.nutz.dao.jdbc.JdbcExpert;
import org.nutz.dao.jdbc.Jdbcs;
import org.nutz.dao.jdbc.ValueAdaptor;
import org.nutz.dao.pager.Pager;
import org.nutz.dao.sql.Sql;
import org.nutz.dao.sql.SqlCallback;
import org.nutz.lang.Lang;
import org.nutz.lang.Strings;
import org.nutz.lang.util.Callback2;
import org.nutz.log.Log;
import org.nutz.log.Logs;
import org.nutz.resource.Scans;
import org.nutz.trans.Molecule;
import org.nutz.trans.Trans;


public abstract class Daos {

    private static final Log log = Logs.get();


    public static void safeClose(Statement stat, ResultSet rs) {
        safeClose(rs);
        safeClose(stat);
    }


    public static void safeClose(Statement stat) {
        if (null != stat)
            try {
                stat.close();
            }
            catch (Throwable e) {}
    }


    public static void safeClose(ResultSet rs) {
        if (null != rs)
            try {
                rs.close();
            }
            catch (Throwable e) {}
    }


    public static int getColumnIndex(ResultSetMetaData meta, String colName) throws SQLException {
        if (meta == null)
            return 0;
        int columnCount = meta.getColumnCount();
        for (int i = 1; i <= columnCount; i++)
            if (meta.getColumnName(i).equalsIgnoreCase(colName))
                return i;

        log.infof("Can not find @Column(%s) in table/view (%s)", colName, meta.getTableName(1));
        throw Lang.makeThrow(SQLException.class, "Can not find @Column(%s)", colName);
    }


    public static boolean isIntLikeColumn(ResultSetMetaData meta, int index) throws SQLException {
        switch (meta.getColumnType(index)) {
        case Types.BIGINT:
        case Types.INTEGER:
        case Types.SMALLINT:
        case Types.TINYINT:
        case Types.NUMERIC:
            return true;
        }
        return false;
    }


    public static Pager updatePagerCount(Pager pager, Dao dao, Class<?> entityType, Condition cnd) {
        if (null != pager) {
            pager.setRecordCount(dao.count(entityType, cnd));
        }
        return pager;
    }


    public static Pager updatePagerCount(Pager pager, Dao dao, String tableName, Condition cnd) {
        if (null != pager) {
            pager.setRecordCount(dao.count(tableName, cnd));
        }
        return pager;
    }


    public static <T> List<T> queryList(Dao dao, Class<T> klass, String sql_str) {
        Sql sql = Sqls.create(sql_str)
                      .setCallback(Sqls.callback.entities())
                      .setEntity(dao.getEntity(klass));
        dao.execute(sql);
        return sql.getList(klass);
    }


    public static Object query(Dao dao, String sql_str, SqlCallback callback) {
        Sql sql = Sqls.create(sql_str).setCallback(callback);
        dao.execute(sql);
        return sql.getResult();
    }


    public static <T> List<T> queryWithLinks(final Dao dao,
                                             final Class<T> classOfT,
                                             final Condition cnd,
                                             final Pager pager,
                                             final String regex) {
        Molecule<List<T>> molecule = new Molecule<List<T>>() {
            public void run() {
                List<T> list = dao.query(classOfT, cnd, pager);
                for (T t : list)
                    dao.fetchLinks(t, regex);
                setObj(list);
            }
        };
        return Trans.exec(molecule);
    }


    public static StringBuilder dataDict(DataSource ds, String... packages) {
        StringBuilder sb = new StringBuilder();
        List<Class<?>> ks = new ArrayList<Class<?>>();
        for (String packageName : packages) {
            ks.addAll(Scans.me().scanPackage(packageName));
        }
        Iterator<Class<?>> it = ks.iterator();
        while (it.hasNext()) {
            Class<?> klass = it.next();
            if (klass.getAnnotation(Table.class) == null)
                it.remove();
        }


        JdbcExpert exp = Jdbcs.getExpert(ds);
        NutDao dao = new NutDao(ds);

        Method evalFieldType;
        try {
            evalFieldType = exp.getClass().getDeclaredMethod("evalFieldType", MappingField.class);
        }
        catch (Throwable e) {
            throw Lang.wrapThrow(e);
        }
        evalFieldType.setAccessible(true);
        Entity<?> entity = null;
        String line = "-------------------------------------------------------------------\n";
        sb.append("#title:æ°æ?®å­å¸\n");
        sb.append("#author:wendal\n");
        sb.append("#index:0,1\n").append(line);
        for (Class<?> klass : ks) {
            sb.append(line);
            entity = dao.getEntity(klass);
            sb.append("è¡¨å?? ").append(entity.getTableName()).append("\n\n");
            if (!Strings.isBlank(entity.getTableComment()))
                sb.append("è¡¨æ³¨é: ").append(entity.getTableComment());
            sb.append("\t").append("Javaç±»å?? ").append(klass.getName()).append("\n\n");
            sb.append("\t||åº?å?·||åå??||æ°æ?®ç±»å||ä¸»é®||é?ç©º||é»è®¤å¼||javaå±æ§å??||javaç±»å||æ³¨é||\n");
            int index = 1;
            for (MappingField field : entity.getMappingFields()) {
                String dataType;
                try {
                    dataType = (String) evalFieldType.invoke(exp, field);
                }
                catch (Throwable e) {
                    throw Lang.wrapThrow(e); 
                }
                sb.append("\t||")
                  .append(index++)
                  .append("||")
                  .append(field.getColumnName())
                  .append("||")
                  .append(dataType)
                  .append("||")
                  .append(field.isPk())
                  .append("||")
                  .append(field.isNotNull())
                  .append("||")
                  .append(field.getDefaultValue(null) == null ? " " : field.getDefaultValue(null))
                  .append("||")
                  .append(field.getName())
                  .append("||")
                  .append(field.getTypeClass().getName())
                  .append("||")
                  .append(field.getColumnComment() == null ? " " : field.getColumnComment())
                  .append("||\n");
            }
        }
        return sb;
    }


    public static <T> List<T> query(Dao dao,
                                    Class<T> classOfT,
                                    String sql,
                                    Condition cnd,
                                    Pager pager) {
        Sql sql2 = Sqls.queryEntity(sql);
        sql2.setEntity(dao.getEntity(classOfT));
        sql2.setCondition(cnd);
        sql2.setPager(pager);
        dao.execute(sql2);
        return sql2.getList(classOfT);
    }


    public static long queryCount(Dao dao, String sql) {
        Sql sql2 = Sqls.fetchInt("select count(1) from ("
                                 + sql
                                 + ") as _nutz_tmp_"
                                 + System.currentTimeMillis());
        dao.execute(sql2);
        return sql2.getInt();
    }


    @SuppressWarnings({"rawtypes"})
    public static int updateBySpecialChain(Dao dao,
                                           Entity en,
                                           String tableName,
                                           Chain chain,
                                           Condition cnd) {
        if (en != null)
            tableName = en.getTableName();
        if (tableName == null)
            throw Lang.makeThrow(DaoException.class, "tableName and en is NULL !!");
        final StringBuilder sql = new StringBuilder("UPDATE ").append(tableName).append(" SET ");
        Chain head = chain.head();
        final List<Object> values = new ArrayList<Object>();
        final List<ValueAdaptor> adaptors = new ArrayList<ValueAdaptor>();
        while (head != null) {
            MappingField mf = null;
            if (en != null)
                mf = en.getField(head.name());
            String colName = head.name();
            if (mf != null)
                colName = mf.getColumnName();
            sql.append(colName).append("=");
            if (head.special()) {
                if (head.value() != null && head.value() instanceof String) {
                    String str = (String) head.value();
                    if (str.length() > 0) {
                        switch (str.charAt(0)) {
                        case '+':
                        case '-':
                        case '*':
                        case '/':
                        case '%':
                        case '&':
                        case '^':
                        case '|':
                            sql.append(colName);
                            break;
                        }
                    }
                }
                sql.append(head.value());
            } else {
                sql.append("?");
                values.add(head.value());
                ValueAdaptor adaptor = Jdbcs.getAdaptorBy(head.value());
                if (mf != null && mf.getAdaptor() != null)
                    adaptor = mf.getAdaptor();
                adaptors.add(adaptor);
            }
            sql.append(" ");
            head = head.next();
            if (head != null)
                sql.append(", ");
        }
        if (cnd != null)
            sql.append(" ").append(cnd.toSql(en));
        if (log.isDebugEnabled())
            log.debug(sql);
        final int[] ints = new int[1];
        dao.run(new ConnCallback() {
            public void invoke(Connection conn) throws Exception {
                PreparedStatement ps = conn.prepareStatement(sql.toString());
                try {
                    for (int i = 0; i < values.size(); i++)
                        adaptors.get(i).set(ps, values.get(i), i + 1);
                    ints[0] = ps.executeUpdate();
                }
                finally {
                    Daos.safeClose(ps);
                }
            }
        });
        return ints[0];
    }


    @SuppressWarnings({"rawtypes"})
    public static void insertBySpecialChain(Dao dao, Entity en, String tableName, Chain chain) {
        if (en != null)
            tableName = en.getTableName();
        if (tableName == null)
            throw Lang.makeThrow(DaoException.class, "tableName and en is NULL !!");
        final StringBuilder sql = new StringBuilder("INSERT INTO ").append(tableName).append(" (");
        StringBuilder _value_places = new StringBuilder(" VALUES(");
        final List<Object> values = new ArrayList<Object>();
        final List<ValueAdaptor> adaptors = new ArrayList<ValueAdaptor>();
        Chain head = chain.head();
        while (head != null) {
            String colName = head.name();
            MappingField mf = null;
            if (en != null) {
                mf = en.getField(colName);
                if (mf != null)
                    colName = mf.getColumnName();
            }
            sql.append(colName);

            if (head.special()) {
                _value_places.append(head.value());
            } else {
                if (en != null)
                    mf = en.getField(head.name());
                _value_places.append("?");
                values.add(head.value());
                ValueAdaptor adaptor = Jdbcs.getAdaptorBy(head.value());
                if (mf != null && mf.getAdaptor() != null)
                    adaptor = mf.getAdaptor();
                adaptors.add(adaptor);
            }

            head = head.next();
            if (head != null) {
                sql.append(", ");
                _value_places.append(", ");
            }
        }
        sql.append(")");
        _value_places.append(")");
        sql.append(_value_places);
        if (log.isDebugEnabled())
            log.debug(sql);
        dao.run(new ConnCallback() {
            public void invoke(Connection conn) throws Exception {
                PreparedStatement ps = conn.prepareStatement(sql.toString());
                try {
                    for (int i = 0; i < values.size(); i++)
                        adaptors.get(i).set(ps, values.get(i), i + 1);
                    ps.execute();
                }
                finally {
                    Daos.safeClose(ps);
                }
            }
        });
    }


    public static void createTablesInPackage(Dao dao, String packageName, boolean force) {
        for (Class<?> klass : Scans.me().scanPackage(packageName)) {
            if (klass.getAnnotation(Table.class) != null)
                dao.create(klass, force);
        }
    }

    private static Class<?>[] iz = new Class<?>[]{Dao.class};


    public static Dao ext(Dao dao, FieldFilter filter) {
        return ext(dao, filter, null);
    }


    public static Dao ext(Dao dao, Object tableName) {
        return ext(dao, null, tableName);
    }


    public static Dao ext(Dao dao, FieldFilter filter, Object tableName) {
        if (tableName == null && filter == null)
            return dao;
        ExtDaoInvocationHandler handler = new ExtDaoInvocationHandler(dao, filter, tableName);
        return (Dao) Proxy.newProxyInstance(dao.getClass().getClassLoader(), iz, handler);
    }

    @SuppressWarnings({"unchecked", "rawtypes"})
    public static boolean filterFields(Object obj,
                                       FieldMatcher matcher,
                                       Dao dao,
                                       Callback2<MappingField, Object> callback) {
        if (obj == null)
            return false;
        obj = Lang.first(obj);
        if (obj == null) {
            return false;
        }
        if (obj.getClass() == Class.class) {
            throw Lang.impossible();
        }
        if (obj instanceof String || obj instanceof Number || obj instanceof Boolean) {
            throw Lang.impossible();
        }
        Entity en = dao.getEntity(obj.getClass());
        if (en == null) {
            throw Lang.impossible();
        }

        List<MappingField> mfs = en.getMappingFields();
        if (matcher != null) {
            Iterator<MappingField> it = mfs.iterator();
            while (it.hasNext()) {
                MappingField mf = it.next();
                if (!matcher.match(mf.getName()))
                    it.remove();
            }
        }
        boolean flag = false;
        for (MappingField mf : mfs) {
            if (matcher.isIgnoreId() && mf.isId())
                continue;
            if (matcher.isIgnoreName() && mf.isName())
                continue;
            if (matcher.isIgnorePk() && mf.isCompositePk())
                continue;
            Object val = mf.getValue(obj);
            if (val == null) {
                if (matcher.isIgnoreNull())
                    continue;
            }
            if (val instanceof Number && ((Number) val).doubleValue() == 0.0) {
                if (matcher.isIgnoreZero())
                    continue;
            }
            if (val instanceof Date) {
                if (matcher.isIgnoreDate())
                    continue;
            }
            callback.invoke(mf, val);
            flag = true;
        }
        return flag;
    }


    public static void migration(Dao dao, final Class<?> klass, final boolean add, final boolean del) {
        migration(dao, klass, add, del, null);
    }


    public static void migration(Dao dao,
                                 final Class<?> klass,
                                 final boolean add,
                                 final boolean del,
                                 Object tableName) {
        final Entity<?> en = dao.getEntity(klass);
        if (!dao.exists(klass))
            return;
        final JdbcExpert expert = ((NutDao) dao).getJdbcExpert();
        final List<Sql> sqls = new ArrayList<Sql>();
        final boolean sqlAddNeedColumn = !dao.meta().isOracle();
        if (tableName != null && Strings.isNotBlank(tableName.toString())) {
            dao = ext(dao, tableName);
        }
        dao.run(new ConnCallback() {
            public void invoke(Connection conn) throws Exception {
                expert.setupEntityField(conn, en);
                Statement stat = null;
                ResultSet rs = null;
                ResultSetMetaData meta = null;
                try {

                    stat = conn.createStatement();
                    rs = stat.executeQuery("select * from " + en.getTableName() + " where 1 != 1");
                    meta = rs.getMetaData();

                    Set<String> columnNames = new HashSet<String>();
                    int columnCount = meta.getColumnCount();
                    for (int i = 1; i <= columnCount; i++) {
                        columnNames.add(meta.getColumnName(i).toLowerCase());
                    }
                    for (MappingField mf : en.getMappingFields()) {
                        String colName = mf.getColumnName();
                        if (columnNames.contains(colName.toLowerCase())) {
                            columnNames.remove(colName.toLowerCase());
                            continue;
                        }
                        if (add) {
                            log.infof("add column[%s] to table[%s]",
                                      mf.getColumnName(),
                                      en.getTableName());
                            StringBuilder sb = new StringBuilder("ALTER TABLE ");
                            sb.append(meta.getTableName(1)).append(" ADD ");
                            if (sqlAddNeedColumn)
                                sb.append("COLUMN ");
                            sb.append(colName).append(" ").append(expert.evalFieldType(mf));
                            if (mf.isUnsigned()) {
                                sb.append(" UNSIGNED");
                            }
                            if (mf.isNotNull()) {
                                sb.append(" NOT NULL");
                            }
                            if (mf.getColumnType() == ColType.TIMESTAMP) {
                                if (mf.hasDefaultValue()) {
                                    sb.append(" ")
                                      .append(mf.getDefaultValue(null).replaceAll("@", "@@"));
                                } else {
                                    if (mf.isNotNull()) {
                                        sb.append(" DEFAULT 0");
                                    } else {
                                        sb.append(" NULL DEFAULT NULL");
                                    }
                                }
                            } else {
                                if (mf.hasDefaultValue())
                                    sb.append(" DEFAULT '")
                                      .append(mf.getDefaultValue(null).replaceAll("@", "@@"))
                                      .append("'");
                            }
                            if (mf.hasColumnComment()) {
                                sb.append(" COMMENT '").append(mf.getColumnComment()).append("'");
                            }
                            sb.append(';');
                            Sql sql = Sqls.create(sb.toString());
                            sqls.add(sql);
                        }
                    }
                    if (del) {
                        for (String colName : columnNames) {
                            log.infof("del column[%s] from table[%s]", colName, en.getTableName());
                            Sql sql = Sqls.create("ALTER table $table DROP column $name");
                            sql.vars().set("table", en.getTableName());
                            sql.vars().set("name", colName);
                            sqls.add(sql);
                        }
                    }
                }
                catch (SQLException e) {
                    if (log.isDebugEnabled())
                        log.debugf("migration Table '%s' fail!", en.getTableName(), e);
                }

                finally {
                    Daos.safeClose(stat, rs);
                }
            }
        });
        for (Sql sql : sqls) {
            dao.execute(sql);
        }
    }


    public static void migration(Dao dao,
                                 String packageName,
                                 boolean add,
                                 boolean del,
                                 String nameTable) {
        for (Class<?> klass : Scans.me().scanPackage(packageName)) {
            if (klass.getAnnotation(Table.class) != null) {
                migration(dao, klass, add, del, nameTable);
            }
        }
    }


    public static void migration(Dao dao, String packageName, boolean add, boolean del) {
        for (Class<?> klass : Scans.me().scanPackage(packageName)) {
            if (klass.getAnnotation(Table.class) != null) {
                migration(dao, klass, add, del, null);
            }
        }
    }
}

class ExtDaoInvocationHandler implements InvocationHandler {

    protected ExtDaoInvocationHandler(Dao dao, FieldFilter filter, Object tableName) {
        this.dao = dao;
        this.filter = filter;
        this.tableName = tableName;
    }

    public Dao dao;
    public FieldFilter filter;
    public Object tableName;

    public Object invoke(Object proxy, final Method method, final Object[] args) throws Throwable {

        final Molecule<Object> m = new Molecule<Object>() {
            public void run() {
                try {
                    setObj(method.invoke(dao, args));
                }
                catch (IllegalArgumentException e) {
                    throw Lang.wrapThrow(e);
                }
                catch (IllegalAccessException e) {
                    throw Lang.wrapThrow(e);
                }
                catch (InvocationTargetException e) {
                    throw Lang.wrapThrow(e.getTargetException());
                }
            }
        };
        if (filter != null && tableName != null) {
            TableName.run(tableName, new Runnable() {
                public void run() {
                    filter.run(m);
                }
            });
            return m.getObj();
        }
        if (filter != null)
            filter.run(m);
        else
            TableName.run(tableName, m);
        return m.getObj();
    }
}
<code block>
package org.nutz.dao;

import java.util.Iterator;
import java.util.List;

import org.nutz.dao.entity.Entity;
import org.nutz.dao.entity.MappingField;
import org.nutz.dao.jdbc.ValueAdaptor;
import org.nutz.dao.pager.Pager;
import org.nutz.dao.sql.Criteria;
import org.nutz.dao.sql.GroupBy;
import org.nutz.dao.sql.OrderBy;
import org.nutz.dao.sql.Pojo;
import org.nutz.dao.util.cnd.SimpleCondition;
import org.nutz.dao.util.cri.Exps;
import org.nutz.dao.util.cri.SimpleCriteria;
import org.nutz.dao.util.cri.SqlExpression;
import org.nutz.dao.util.cri.SqlExpressionGroup;
import org.nutz.lang.Lang;
import org.nutz.lang.Strings;
import org.nutz.lang.segment.CharSegment;


public class Cnd implements OrderBy, Criteria, GroupBy {


    public static Condition format(String format, Object... args) {
        return Strings.isBlank(format) ? null : new SimpleCondition(format,
                                                                    args);
    }

    public static Condition wrap(String str) {
        return Strings.isBlank(str) ? null : new SimpleCondition((Object) str);
    }

    public static Condition wrap(String sql, Object value) {
        return Strings.isBlank(sql) ? null
                                   : new SimpleCondition(new CharSegment(sql).setBy(value));
    }

    public static SqlExpression exp(String name, String op, Object value) {
        return Exps.create(name, op, value);
    }

    public static SqlExpressionGroup exps(String name, String op, Object value) {
        return exps(exp(name, op, value));
    }

    public static SqlExpressionGroup exps(SqlExpression exp) {
        return new SqlExpressionGroup().and(exp);
    }

    public static Cnd where(String name, String op, Object value) {
        return new Cnd(Cnd.exp(name, op, value));
    }

    public static Cnd where(SqlExpression e) {
        return new Cnd(e);
    }

    public static SimpleCriteria cri() {
        return new SimpleCriteria();
    }

    public static OrderBy orderBy() {
        return new Cnd();
    }


    public static Cnd limit() {
        return new Cnd();
    }


    public static Cnd NEW() {
        return new Cnd();
    }

    public static Cnd byCri(SimpleCriteria cri) {
        return new Cnd().setCri(cri);
    }



    private SimpleCriteria cri;

    Cnd() {
        cri = new SimpleCriteria();
    }

    private Cnd setCri(SimpleCriteria cri) {
        this.cri = cri;
        return this;
    }

    public SimpleCriteria getCri() {
        return cri;
    }

    protected Cnd(SqlExpression exp) {
        this();
        cri.where().and(exp);
    }

    public OrderBy asc(String name) {
        cri.asc(name);
        return this;
    }

    public OrderBy desc(String name) {
        cri.desc(name);
        return this;
    }

    public OrderBy orderBy(String name, String dir) {
        if ("asc".equalsIgnoreCase(dir)) {
            this.asc(name);
        } else {
            this.desc(name);
        }
        return this;
    }

    public Cnd and(SqlExpression exp) {
        cri.where().and(exp);
        return this;
    }

    public Cnd and(String name, String op, Object value) {
        return and(Cnd.exp(name, op, value));
    }

    public Cnd or(SqlExpression exp) {
        cri.where().or(exp);
        return this;
    }

    public Cnd or(String name, String op, Object value) {
        return or(Cnd.exp(name, op, value));
    }

    public Cnd andNot(SqlExpression exp) {
        cri.where().and(exp.setNot(true));
        return this;
    }

    public Cnd andNot(String name, String op, Object value) {
        return andNot(Cnd.exp(name, op, value));
    }

    public Cnd orNot(SqlExpression exp) {
        cri.where().or(exp.setNot(true));
        return this;
    }

    public Cnd orNot(String name, String op, Object value) {
        return orNot(Cnd.exp(name, op, value));
    }

    public Pager getPager() {
        return cri.getPager();
    }

    public String toSql(Entity<?> en) {
        return cri.toSql(en);
    }

    public boolean equals(Object obj) {
        return cri.equals(obj);
    }

    public String toString() {
        return cri.toString();
    }

    public void setPojo(Pojo pojo) {
        cri.setPojo(pojo);
    }

    public Pojo getPojo() {
        return cri.getPojo();
    }

    public void joinSql(Entity<?> en, StringBuilder sb) {
        cri.joinSql(en, sb);
    }

    public int joinAdaptor(Entity<?> en, ValueAdaptor[] adaptors, int off) {
        return cri.joinAdaptor(en, adaptors, off);
    }

    public int joinParams(Entity<?> en, Object obj, Object[] params, int off) {
        return cri.joinParams(en, obj, params, off);
    }

    public int paramCount(Entity<?> en) {
        return cri.paramCount(en);
    }

    public SqlExpressionGroup where() {
        return cri.where();
    }

    public GroupBy groupBy(String... names) {
        cri.groupBy(names);
        return this;
    }

    public GroupBy having(Condition cnd) {
        cri.having(cnd);
        return this;
    }

    public OrderBy getOrderBy() {
        return cri.getOrderBy();
    }

    public Cnd limit(int pageNumber, int pageSize) {
        cri.setPager(pageNumber, pageSize);
        return this;
    }

    public Cnd limit(int pageSize) {
        cri.setPager(1, pageSize);
        return this;
    }

    public Cnd limit(Pager pager) {
        cri.setPager(pager);
        return this;
    }

    public static Cnd from(Dao dao, Object obj) {
        return from(dao, obj, null);
    }
    
    @SuppressWarnings({"rawtypes", "unchecked"})
    public static Cnd from(Dao dao, Object obj, FieldFilter filter) {
        if (obj == null)
            return null;
        obj = Lang.first(obj);
        if (obj == null) {
            return null;
        }
        if (obj.getClass() == Class.class) {
            throw Lang.impossible();
        }
        if (obj instanceof String || obj instanceof Number || obj instanceof Boolean) {
            throw Lang.impossible();
        }
        Entity en = dao.getEntity(obj.getClass());
        if (en == null) {
            throw Lang.impossible();
        }
        
        List<MappingField> mfs = en.getMappingFields();
        if (filter != null) {
            FieldMatcher fm = filter.map().get(obj.getClass());
            if (fm != null) {
                Iterator<MappingField> it = mfs.iterator();
                while (it.hasNext()) {
                    MappingField mf = it.next();
                    if (!fm.match(mf.getName()))
                        it.remove();
                }
            }
        }
        
        Cnd cnd = Cnd.NEW();
        for (MappingField mf : mfs) {
            Object val = mf.getValue(obj);
            if (val == null || (val instanceof Number && ((Number)val).doubleValue() == 0.0))
                continue;
            cnd.and(mf.getName(), "=", val);
        }
        return cnd;
    }
}

<code block>
package org.nutz.dao.texp;

import static org.junit.Assert.assertEquals;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.junit.Test;
import org.nutz.dao.Cnd;
import org.nutz.dao.Condition;
import org.nutz.dao.entity.Entity;
import org.nutz.dao.test.DaoCase;
import org.nutz.dao.util.cri.SqlExpression;
import org.nutz.lang.Lang;

public class CndTest extends DaoCase {

    private Entity<?> en;

    protected void before() {
        en = dao.create(Worker.class, true);
    }

    protected void after() {}

    @Test
    public void test_segment() {
        Map<String, Object> map = new HashMap<String, Object>();
        map.put("name", "æ¯å°çè¨");
        map.put("age", 50);
        Condition c1 = Cnd.wrap("name='${name}' AND age>${age}", map);
        assertEquals("name='æ¯å°çè¨' AND age>50", c1.toSql(en));

        Worker worker = new Worker();
        worker.name = "è?æ?¿";
        worker.age = 30;
        Condition c2 = Cnd.wrap("name like'${name}%' AND age>${age}", worker);
        assertEquals("name like'è?æ?¿%' AND age>30", c2.toSql(en));
    }

    @Test
    public void test_gt_like() {
        Condition c = Cnd.where("id", ">", 45).and("name", "LIKE", "%ry%");
        String exp = "WHERE wid>45 AND wname LIKE '%ry%'";
        assertEquals(exp, c.toSql(en).trim());
    }

    @Test
    public void test_bracket() {
        Condition c = Cnd.where(Cnd.exps("id", ">", 45)).and("name",
                                                             "LIKE",
                                                             "%ry%");
        String exp = "WHERE (wid>45) AND wname LIKE '%ry%'";
        assertEquals(exp, c.toSql(en).trim());
    }

    @Test
    public void test_order() {
        Condition c = Cnd.orderBy()
                         .asc("id")
                         .desc("name")
                         .asc("age")
                         .desc("workingDay");
        String exp = "ORDER BY wid ASC, wname DESC, age ASC, days DESC";
        assertEquals(exp, c.toSql(en).trim());
    }

    @Test
    public void test_like_in() {
        int[] ages = {4, 7, 9};
        SqlExpression e = Cnd.exps("age", ">", 35).and("id", "<", 47);
        SqlExpression e2 = Cnd.exps("name", "\tLIKE ", "%t%")
                              .and("age", "IN  \n\r", ages)
                              .or(e);
        Condition c = Cnd.where("id", "=", 37)
                         .and(e)
                         .or(e2)
                         .asc("age")
                         .desc("id");
        String exp = "WHERE wid=37 AND (age>35 AND wid<47) OR (wname LIKE '%t%' AND age IN (4,7,9) OR (age>35 AND wid<47)) ORDER BY age ASC, wid DESC";
        assertEquals(exp, c.toSql(en).trim());
    }

    @Test
    public void test_equel() {
        Condition c = Cnd.where("ff", "=", true);
        String exp = "WHERE ff=true";
        assertEquals(exp, c.toSql(en).trim());
    }

    @Test
    public void test_in_by_int_array() {
        int[] ids = {3, 5, 7};
        Condition c = Cnd.where("id", "iN", ids);
        String exp = "WHERE id IN (3,5,7)";
        assertEquals(exp, c.toSql(null).trim());
    }

    @Test
    public void test_in_by_int_list() {
        List<Integer> list = new ArrayList<Integer>();
        list.add(3);
        list.add(5);
        list.add(7);
        Condition c = Cnd.where("id", "iN", list);
        String exp = "WHERE id IN (3,5,7)";
        assertEquals(exp, c.toSql(null).trim());
    }

    @Test
    public void test_in_by_str_array() {
        Condition c = Cnd.where("nm", "iN", Lang.array("'A'", "B"));
        String exp = "WHERE nm IN ('''A''','B')";
        assertEquals(exp, c.toSql(null).trim());
    }

    @Test
    public void test_in_by_str_list() {
        List<String> list = new ArrayList<String>();
        list.add("'A'");
        list.add("B");
        Condition c = Cnd.where("nm", "iN", list);
        String exp = "WHERE nm IN ('''A''','B')";
        assertEquals(exp, c.toSql(null).trim());
    }

    @Test
    public void test_is_null() {
        Condition c = Cnd.where("nm", " is ", null);
        String exp = "WHERE nm IS NULL";
        assertEquals(exp, c.toSql(null).trim());
    }

    @Test
    public void test_is_not_null() {
        Condition c = Cnd.where("nm", " is nOT ", null);
        String exp = "WHERE nm IS NOT NULL";
        assertEquals(exp, c.toSql(null).trim());
    }

    @Test
    public void test_not_in() {
        Condition c = Cnd.where("nm", " Not iN ", new int[]{1, 2, 3});
        String exp = "WHERE nm NOT IN (1,2,3)";
        assertEquals(exp, c.toSql(null).trim());
    }

    @Test
    public void test_add_other_or_method_by_github_issuse_148() {
        SqlExpression e1 = Cnd.exps("city", "=", "beijing")
                              .or("city", "=", "shanghai")
                              .or("city", "=", "guangzhou")
                              .or("city", "=", "shenzhen");
        SqlExpression e2 = Cnd.exps("age", ">", 18).and("age", "<", 30);
        String exp = "WHERE (ct='beijing' OR ct='shanghai' OR ct='guangzhou' OR ct='shenzhen') AND (age>18 AND age<30)";
        assertEquals(exp, Cnd.where(e1).and(e2).toSql(en).trim());
    }

    @Test
    public void test_other_op() {
        assertEquals(" WHERE ok IS true", Cnd.where("ok", "is", true)
                                             .toString());
    }
}

<code block>
package org.nutz.dao;

import java.util.Date;
import java.util.Iterator;
import java.util.List;

import org.nutz.dao.entity.Entity;
import org.nutz.dao.entity.MappingField;
import org.nutz.dao.jdbc.ValueAdaptor;
import org.nutz.dao.pager.Pager;
import org.nutz.dao.sql.Criteria;
import org.nutz.dao.sql.GroupBy;
import org.nutz.dao.sql.OrderBy;
import org.nutz.dao.sql.Pojo;
import org.nutz.dao.util.cnd.SimpleCondition;
import org.nutz.dao.util.cri.Exps;
import org.nutz.dao.util.cri.SimpleCriteria;
import org.nutz.dao.util.cri.SqlExpression;
import org.nutz.dao.util.cri.SqlExpressionGroup;
import org.nutz.lang.Lang;
import org.nutz.lang.Strings;
import org.nutz.lang.segment.CharSegment;


public class Cnd implements OrderBy, Criteria, GroupBy {


    public static Condition format(String format, Object... args) {
        return Strings.isBlank(format) ? null : new SimpleCondition(format,
                                                                    args);
    }

    public static Condition wrap(String str) {
        return Strings.isBlank(str) ? null : new SimpleCondition((Object) str);
    }

    public static Condition wrap(String sql, Object value) {
        return Strings.isBlank(sql) ? null
                                   : new SimpleCondition(new CharSegment(sql).setBy(value));
    }

    public static SqlExpression exp(String name, String op, Object value) {
        return Exps.create(name, op, value);
    }

    public static SqlExpressionGroup exps(String name, String op, Object value) {
        return exps(exp(name, op, value));
    }

    public static SqlExpressionGroup exps(SqlExpression exp) {
        return new SqlExpressionGroup().and(exp);
    }

    public static Cnd where(String name, String op, Object value) {
        return new Cnd(Cnd.exp(name, op, value));
    }

    public static Cnd where(SqlExpression e) {
        return new Cnd(e);
    }

    public static SimpleCriteria cri() {
        return new SimpleCriteria();
    }

    public static OrderBy orderBy() {
        return new Cnd();
    }


    public static Cnd limit() {
        return new Cnd();
    }


    public static Cnd NEW() {
        return new Cnd();
    }

    public static Cnd byCri(SimpleCriteria cri) {
        return new Cnd().setCri(cri);
    }



    private SimpleCriteria cri;

    Cnd() {
        cri = new SimpleCriteria();
    }

    private Cnd setCri(SimpleCriteria cri) {
        this.cri = cri;
        return this;
    }

    public SimpleCriteria getCri() {
        return cri;
    }

    protected Cnd(SqlExpression exp) {
        this();
        cri.where().and(exp);
    }

    public OrderBy asc(String name) {
        cri.asc(name);
        return this;
    }

    public OrderBy desc(String name) {
        cri.desc(name);
        return this;
    }

    public OrderBy orderBy(String name, String dir) {
        if ("asc".equalsIgnoreCase(dir)) {
            this.asc(name);
        } else {
            this.desc(name);
        }
        return this;
    }

    public Cnd and(SqlExpression exp) {
        cri.where().and(exp);
        return this;
    }

    public Cnd and(String name, String op, Object value) {
        return and(Cnd.exp(name, op, value));
    }

    public Cnd or(SqlExpression exp) {
        cri.where().or(exp);
        return this;
    }

    public Cnd or(String name, String op, Object value) {
        return or(Cnd.exp(name, op, value));
    }

    public Cnd andNot(SqlExpression exp) {
        cri.where().and(exp.setNot(true));
        return this;
    }

    public Cnd andNot(String name, String op, Object value) {
        return andNot(Cnd.exp(name, op, value));
    }

    public Cnd orNot(SqlExpression exp) {
        cri.where().or(exp.setNot(true));
        return this;
    }

    public Cnd orNot(String name, String op, Object value) {
        return orNot(Cnd.exp(name, op, value));
    }

    public Pager getPager() {
        return cri.getPager();
    }

    public String toSql(Entity<?> en) {
        return cri.toSql(en);
    }

    public boolean equals(Object obj) {
        return cri.equals(obj);
    }

    public String toString() {
        return cri.toString();
    }

    public void setPojo(Pojo pojo) {
        cri.setPojo(pojo);
    }

    public Pojo getPojo() {
        return cri.getPojo();
    }

    public void joinSql(Entity<?> en, StringBuilder sb) {
        cri.joinSql(en, sb);
    }

    public int joinAdaptor(Entity<?> en, ValueAdaptor[] adaptors, int off) {
        return cri.joinAdaptor(en, adaptors, off);
    }

    public int joinParams(Entity<?> en, Object obj, Object[] params, int off) {
        return cri.joinParams(en, obj, params, off);
    }

    public int paramCount(Entity<?> en) {
        return cri.paramCount(en);
    }

    public SqlExpressionGroup where() {
        return cri.where();
    }

    public GroupBy groupBy(String... names) {
        cri.groupBy(names);
        return this;
    }

    public GroupBy having(Condition cnd) {
        cri.having(cnd);
        return this;
    }

    public OrderBy getOrderBy() {
        return cri.getOrderBy();
    }

    public Cnd limit(int pageNumber, int pageSize) {
        cri.setPager(pageNumber, pageSize);
        return this;
    }

    public Cnd limit(int pageSize) {
        cri.setPager(1, pageSize);
        return this;
    }

    public Cnd limit(Pager pager) {
        cri.setPager(pager);
        return this;
    }
    

    public static Cnd from(Dao dao, Object obj) {
        return from(dao, obj, null);
    }


    public static Cnd from(Dao dao, Object obj, FieldFilter filter) {
        return from(dao, obj, filter, true, true, false, false, false, false);
    }
    

    public static Cnd from(Dao dao, Object obj, FieldFilter filter,
                           boolean ignoreNull, boolean ignoreZero, boolean ignoreDate) {
        return from(dao, obj, filter, ignoreNull, ignoreZero, ignoreDate, false, false, false);
    }
    

    @SuppressWarnings({"rawtypes", "unchecked"})
    public static Cnd from(Dao dao, Object obj, FieldFilter filter, 
                           boolean ignoreNull, boolean ignoreZero, boolean ignoreDate, 
                           boolean ignoreId,
                           boolean ignoreName,
                           boolean ignorePk
                           ) {
        if (obj == null)
            return null;
        obj = Lang.first(obj);
        if (obj == null) {
            return null;
        }
        if (obj.getClass() == Class.class) {
            throw Lang.impossible();
        }
        if (obj instanceof String || obj instanceof Number || obj instanceof Boolean) {
            throw Lang.impossible();
        }
        Entity en = dao.getEntity(obj.getClass());
        if (en == null) {
            throw Lang.impossible();
        }
        
        List<MappingField> mfs = en.getMappingFields();
        if (filter != null) {
            FieldMatcher fm = filter.map().get(obj.getClass());
            if (fm != null) {
                Iterator<MappingField> it = mfs.iterator();
                while (it.hasNext()) {
                    MappingField mf = it.next();
                    if (!fm.match(mf.getName()))
                        it.remove();
                }
            }
        }
        
        Cnd cnd = Cnd.NEW();
        for (MappingField mf : mfs) {
            if (ignoreId && mf.isId())
                continue;
            if (ignoreName && mf.isName())
                continue;
            if (ignorePk && mf.isCompositePk())
                continue;
            Object val = mf.getValue(obj);
            if (val == null) {
                if (ignoreNull)
                    continue;
            } if (val instanceof Number && ((Number)val).doubleValue() == 0.0) {
                if (ignoreZero)
                    continue;
            } if (val instanceof Date) {
                if (ignoreDate)
                    continue;
            }
            cnd.and(mf.getName(), "=", val);
        }
        return cnd;
    }
}

<code block>
package org.nutz.dao.texp;

import static org.junit.Assert.assertEquals;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.junit.Test;
import org.nutz.dao.Cnd;
import org.nutz.dao.Condition;
import org.nutz.dao.FieldFilter;
import org.nutz.dao.entity.Entity;
import org.nutz.dao.test.DaoCase;
import org.nutz.dao.test.meta.Pet;
import org.nutz.dao.util.cri.SqlExpression;
import org.nutz.lang.Lang;

public class CndTest extends DaoCase {

    private Entity<?> en;

    protected void before() {
        en = dao.create(Worker.class, true);
    }

    protected void after() {}

    @Test
    public void test_segment() {
        Map<String, Object> map = new HashMap<String, Object>();
        map.put("name", "æ¯å°çè¨");
        map.put("age", 50);
        Condition c1 = Cnd.wrap("name='${name}' AND age>${age}", map);
        assertEquals("name='æ¯å°çè¨' AND age>50", c1.toSql(en));

        Worker worker = new Worker();
        worker.name = "è?æ?¿";
        worker.age = 30;
        Condition c2 = Cnd.wrap("name like'${name}%' AND age>${age}", worker);
        assertEquals("name like'è?æ?¿%' AND age>30", c2.toSql(en));
    }

    @Test
    public void test_gt_like() {
        Condition c = Cnd.where("id", ">", 45).and("name", "LIKE", "%ry%");
        String exp = "WHERE wid>45 AND wname LIKE '%ry%'";
        assertEquals(exp, c.toSql(en).trim());
    }

    @Test
    public void test_bracket() {
        Condition c = Cnd.where(Cnd.exps("id", ">", 45)).and("name",
                                                             "LIKE",
                                                             "%ry%");
        String exp = "WHERE (wid>45) AND wname LIKE '%ry%'";
        assertEquals(exp, c.toSql(en).trim());
    }

    @Test
    public void test_order() {
        Condition c = Cnd.orderBy()
                         .asc("id")
                         .desc("name")
                         .asc("age")
                         .desc("workingDay");
        String exp = "ORDER BY wid ASC, wname DESC, age ASC, days DESC";
        assertEquals(exp, c.toSql(en).trim());
    }

    @Test
    public void test_like_in() {
        int[] ages = {4, 7, 9};
        SqlExpression e = Cnd.exps("age", ">", 35).and("id", "<", 47);
        SqlExpression e2 = Cnd.exps("name", "\tLIKE ", "%t%")
                              .and("age", "IN  \n\r", ages)
                              .or(e);
        Condition c = Cnd.where("id", "=", 37)
                         .and(e)
                         .or(e2)
                         .asc("age")
                         .desc("id");
        String exp = "WHERE wid=37 AND (age>35 AND wid<47) OR (wname LIKE '%t%' AND age IN (4,7,9) OR (age>35 AND wid<47)) ORDER BY age ASC, wid DESC";
        assertEquals(exp, c.toSql(en).trim());
    }

    @Test
    public void test_equel() {
        Condition c = Cnd.where("ff", "=", true);
        String exp = "WHERE ff=true";
        assertEquals(exp, c.toSql(en).trim());
    }

    @Test
    public void test_in_by_int_array() {
        int[] ids = {3, 5, 7};
        Condition c = Cnd.where("id", "iN", ids);
        String exp = "WHERE id IN (3,5,7)";
        assertEquals(exp, c.toSql(null).trim());
    }

    @Test
    public void test_in_by_int_list() {
        List<Integer> list = new ArrayList<Integer>();
        list.add(3);
        list.add(5);
        list.add(7);
        Condition c = Cnd.where("id", "iN", list);
        String exp = "WHERE id IN (3,5,7)";
        assertEquals(exp, c.toSql(null).trim());
    }

    @Test
    public void test_in_by_str_array() {
        Condition c = Cnd.where("nm", "iN", Lang.array("'A'", "B"));
        String exp = "WHERE nm IN ('''A''','B')";
        assertEquals(exp, c.toSql(null).trim());
    }

    @Test
    public void test_in_by_str_list() {
        List<String> list = new ArrayList<String>();
        list.add("'A'");
        list.add("B");
        Condition c = Cnd.where("nm", "iN", list);
        String exp = "WHERE nm IN ('''A''','B')";
        assertEquals(exp, c.toSql(null).trim());
    }

    @Test
    public void test_is_null() {
        Condition c = Cnd.where("nm", " is ", null);
        String exp = "WHERE nm IS NULL";
        assertEquals(exp, c.toSql(null).trim());
    }

    @Test
    public void test_is_not_null() {
        Condition c = Cnd.where("nm", " is nOT ", null);
        String exp = "WHERE nm IS NOT NULL";
        assertEquals(exp, c.toSql(null).trim());
    }

    @Test
    public void test_not_in() {
        Condition c = Cnd.where("nm", " Not iN ", new int[]{1, 2, 3});
        String exp = "WHERE nm NOT IN (1,2,3)";
        assertEquals(exp, c.toSql(null).trim());
    }

    @Test
    public void test_add_other_or_method_by_github_issuse_148() {
        SqlExpression e1 = Cnd.exps("city", "=", "beijing")
                              .or("city", "=", "shanghai")
                              .or("city", "=", "guangzhou")
                              .or("city", "=", "shenzhen");
        SqlExpression e2 = Cnd.exps("age", ">", 18).and("age", "<", 30);
        String exp = "WHERE (ct='beijing' OR ct='shanghai' OR ct='guangzhou' OR ct='shenzhen') AND (age>18 AND age<30)";
        assertEquals(exp, Cnd.where(e1).and(e2).toSql(en).trim());
    }

    @Test
    public void test_other_op() {
        assertEquals(" WHERE ok IS true", Cnd.where("ok", "is", true)
                                             .toString());
    }
    
    @Test
    public void test_from_obj() {
        Pet pet = new Pet();
        pet.setName("wendal");
        System.out.println("===============================");
        System.out.println(Cnd.from(dao, pet));
        assertEquals(" WHERE name='wendal'", Cnd.from(dao, pet).toString());
        
        pet.setAge(10);
        System.out.println(Cnd.from(dao, pet));
        assertEquals(" WHERE name='wendal' AND age=10", Cnd.from(dao, pet).toString());
        
        pet.setAge(0);
        assertEquals(" WHERE name='wendal' AND age=0", Cnd.from(dao, pet, FieldFilter.create(Pet.class, "age|name"), false, false, true).toString());
    }
}
