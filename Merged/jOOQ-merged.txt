
package org.jooq.tools;

import static java.time.temporal.ChronoField.INSTANT_SECONDS;
import static java.time.temporal.ChronoField.MILLI_OF_DAY;
import static java.time.temporal.ChronoField.MILLI_OF_SECOND;
import static org.jooq.types.Unsigned.ubyte;
import static org.jooq.types.Unsigned.uint;
import static org.jooq.types.Unsigned.ulong;
import static org.jooq.types.Unsigned.ushort;

import java.io.File;
import java.lang.reflect.Array;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.sql.Date;
import java.sql.Time;
import java.sql.Timestamp;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.OffsetDateTime;
import java.time.OffsetTime;
import java.time.format.DateTimeParseException;
import java.time.temporal.Temporal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.UUID;
import java.util.regex.Pattern;


import org.jooq.Converter;
import org.jooq.EnumType;
import org.jooq.Field;
import org.jooq.Record;
import org.jooq.SQLDialect;
import org.jooq.exception.DataTypeException;
import org.jooq.tools.jdbc.MockArray;
import org.jooq.types.UByte;
import org.jooq.types.UInteger;
import org.jooq.types.ULong;
import org.jooq.types.UShort;


public final class Convert {


    public static final Set<String> TRUE_VALUES;


    public static final Set<String> FALSE_VALUES;


    private static final Pattern UUID_PATTERN = Pattern.compile("(\\p{XDigit}{8})-?(\\p{XDigit}{4})-?(\\p{XDigit}{4})-?(\\p{XDigit}{4})-?(\\p{XDigit}{12})");

    static {
        Set<String> trueValues = new HashSet<String>();
        Set<String> falseValues = new HashSet<String>();

        trueValues.add("1");
        trueValues.add("1.0");
        trueValues.add("y");
        trueValues.add("Y");
        trueValues.add("yes");
        trueValues.add("YES");
        trueValues.add("true");
        trueValues.add("TRUE");
        trueValues.add("t");
        trueValues.add("T");
        trueValues.add("on");
        trueValues.add("ON");
        trueValues.add("enabled");
        trueValues.add("ENABLED");

        falseValues.add("0");
        falseValues.add("0.0");
        falseValues.add("n");
        falseValues.add("N");
        falseValues.add("no");
        falseValues.add("NO");
        falseValues.add("false");
        falseValues.add("FALSE");
        falseValues.add("f");
        falseValues.add("F");
        falseValues.add("off");
        falseValues.add("OFF");
        falseValues.add("disabled");
        falseValues.add("DISABLED");

        TRUE_VALUES = Collections.unmodifiableSet(trueValues);
        FALSE_VALUES = Collections.unmodifiableSet(falseValues);
    }


    public static final Object[] convert(Object[] values, Field<?>[] fields) {



        if (values != null) {
            Object[] result = new Object[values.length];

            for (int i = 0; i < values.length; i++) {



                if (values[i] instanceof Field<?>) {
                    result[i] = values[i];
                }
                else {
                    result[i] = convert(values[i], fields[i].getType());
                }
            }

            return result;
        }
        else {
            return null;
        }
    }


    public static final Object[] convert(Object[] values, Class<?>[] types) {



        if (values != null) {
            Object[] result = new Object[values.length];

            for (int i = 0; i < values.length; i++) {



                if (values[i] instanceof Field<?>) {
                    result[i] = values[i];
                }
                else {
                    result[i] = convert(values[i], types[i]);
                }
            }

            return result;
        }
        else {
            return null;
        }
    }

    @SuppressWarnings("unchecked")
    public static final <U> U[] convertArray(Object[] from, Converter<?, U> converter) throws DataTypeException {
        if (from == null) {
            return null;
        }
        else {
            Object[] arrayOfT = convertArray(from, converter.fromType());
            Object[] arrayOfU = (Object[]) Array.newInstance(converter.toType(), from.length);

            for (int i = 0; i < arrayOfT.length; i++) {
                arrayOfU[i] = convert(arrayOfT[i], converter);
            }

            return (U[]) arrayOfU;
        }
    }


    @SuppressWarnings("unchecked")
    public static final Object[] convertArray(Object[] from, Class<?> toClass) throws DataTypeException {
        if (from == null) {
            return null;
        }
        else if (!toClass.isArray()) {
            return convertArray(from, Array.newInstance(toClass, 0).getClass());
        }
        else if (toClass == from.getClass()) {
            return from;
        }
        else {
            final Class<?> toComponentType = toClass.getComponentType();

            if (from.length == 0) {
                return Arrays.copyOf(from, from.length, (Class<? extends Object[]>) toClass);
            }
            else if (from[0] != null && from[0].getClass() == toComponentType) {
                return Arrays.copyOf(from, from.length, (Class<? extends Object[]>) toClass);
            }
            else {
                final Object[] result = (Object[]) Array.newInstance(toComponentType, from.length);

                for (int i = 0; i < from.length; i++) {
                    result[i] = convert(from[i], toComponentType);
                }

                return result;
            }
        }
    }


    public static final <U> U convert(Object from, Converter<?, U> converter) throws DataTypeException {
        return convert0(from, converter);
    }


    private static final <T, U> U convert0(Object from, Converter<T, U> converter) throws DataTypeException {
        ConvertAll<T> all = new ConvertAll<T>(converter.fromType());
        return converter.from(all.from(from));
    }


    public static final <T> T convert(Object from, Class<? extends T> toClass) throws DataTypeException {
        return convert(from, new ConvertAll<T>(toClass));
    }


    public static final <T> List<T> convert(Collection<?> collection, Class<? extends T> type) throws DataTypeException {
        return convert(collection, new ConvertAll<T>(type));
    }


    public static final <U> List<U> convert(Collection<?> collection, Converter<?, U> converter) throws DataTypeException {
        return convert0(collection, converter);
    }


    private static final <T, U> List<U> convert0(Collection<?> collection, Converter<T, U> converter) throws DataTypeException {
        ConvertAll<T> all = new ConvertAll<T>(converter.fromType());
        List<U> result = new ArrayList<U>(collection.size());

        for (Object o : collection) {
            result.add(convert(all.from(o), converter));
        }

        return result;
    }


    private Convert() {}


    private static class ConvertAll<U> implements Converter<Object, U> {


        private static final long        serialVersionUID = 2508560107067092501L;

        private final Class<? extends U> toClass;

        ConvertAll(Class<? extends U> toClass) {
            this.toClass = toClass;
        }

        @SuppressWarnings({ "unchecked", "rawtypes" })
        @Override
        public U from(Object from) {
            if (from == null) {



                if (toClass.isPrimitive()) {


                    if (toClass == char.class) {
                        return (U) Character.valueOf((char) 0);
                    }


                    else {
                        return convert(0, toClass);
                    }
                }
                else {
                    return null;
                }
            }
            else {
                final Class<?> fromClass = from.getClass();


                if (toClass == fromClass) {
                    return (U) from;
                }



                else if (toClass.isAssignableFrom(fromClass)) {
                    return (U) from;
                }


                else if (fromClass == byte[].class) {


                    return convert(Arrays.toString((byte[]) from), toClass);
                }
                else if (fromClass.isArray()) {


                    if (toClass == java.sql.Array.class) {
                        return (U) new MockArray(null, (Object[]) from, fromClass);
                    }
                    else {
                        return (U) convertArray((Object[]) from, toClass);
                    }
                }


                else if (toClass == String.class) {
                    if (from instanceof EnumType) {
                        return (U) ((EnumType) from).getLiteral();
                    }

                    return (U) from.toString();
                }


                else if (toClass == Byte.class || toClass == byte.class) {
                    if (Number.class.isAssignableFrom(fromClass)) {
                        return (U) Byte.valueOf(((Number) from).byteValue());
                    }

                    if (fromClass == Boolean.class || fromClass == boolean.class) {
                        return (U) (((Boolean) from) ? Byte.valueOf((byte) 1) : Byte.valueOf((byte) 0));
                    }

                    try {
                        return (U) Byte.valueOf(new BigDecimal(from.toString().trim()).byteValue());
                    }
                    catch (NumberFormatException e) {
                        return null;
                    }
                }
                else if (toClass == Short.class || toClass == short.class) {
                    if (Number.class.isAssignableFrom(fromClass)) {
                        return (U) Short.valueOf(((Number) from).shortValue());
                    }

                    if (fromClass == Boolean.class || fromClass == boolean.class) {
                        return (U) (((Boolean) from) ? Short.valueOf((short) 1) : Short.valueOf((short) 0));
                    }

                    try {
                        return (U) Short.valueOf(new BigDecimal(from.toString().trim()).shortValue());
                    }
                    catch (NumberFormatException e) {
                        return null;
                    }
                }
                else if (toClass == Integer.class || toClass == int.class) {
                    if (Number.class.isAssignableFrom(fromClass)) {
                        return (U) Integer.valueOf(((Number) from).intValue());
                    }

                    if (fromClass == Boolean.class || fromClass == boolean.class) {
                        return (U) (((Boolean) from) ? Integer.valueOf(1) : Integer.valueOf(0));
                    }

                    try {
                        return (U) Integer.valueOf(new BigDecimal(from.toString().trim()).intValue());
                    }
                    catch (NumberFormatException e) {
                        return null;
                    }
                }
                else if (toClass == Long.class || toClass == long.class) {
                    if (Number.class.isAssignableFrom(fromClass)) {
                        return (U) Long.valueOf(((Number) from).longValue());
                    }

                    if (fromClass == Boolean.class || fromClass == boolean.class) {
                        return (U) (((Boolean) from) ? Long.valueOf(1L) : Long.valueOf(0L));
                    }

                    if (java.util.Date.class.isAssignableFrom(fromClass)) {
                        return (U) Long.valueOf(((java.util.Date) from).getTime());
                    }


                    if (Temporal.class.isAssignableFrom(fromClass)) {
                        Temporal temporal = (Temporal) from;


                        if (temporal instanceof LocalDate) {
                            return (U) Long.valueOf(Date.valueOf((LocalDate) temporal).getTime());
                        }
                        else if (temporal instanceof LocalTime) {
                            return (U) Long.valueOf(Time.valueOf((LocalTime) temporal).getTime());
                        }
                        else if (temporal instanceof LocalDateTime) {
                            return (U) Long.valueOf(Timestamp.valueOf((LocalDateTime) temporal).getTime());
                        }


                        else if (temporal.isSupported(INSTANT_SECONDS)) {
                            return (U) Long.valueOf(1000 * temporal.getLong(INSTANT_SECONDS) + temporal.getLong(MILLI_OF_SECOND));
                        }


                        else if (temporal.isSupported(MILLI_OF_DAY)) {
                            return (U) Long.valueOf(temporal.getLong(MILLI_OF_DAY));
                        }
                    }


                    try {
                        return (U) Long.valueOf(new BigDecimal(from.toString().trim()).longValue());
                    }
                    catch (NumberFormatException e) {
                        return null;
                    }
                }


                else if (toClass == UByte.class) {
                    try {
                        if (Number.class.isAssignableFrom(fromClass)) {
                            return (U) ubyte(((Number) from).shortValue());
                        }

                        if (fromClass == Boolean.class || fromClass == boolean.class) {
                            return (U) (((Boolean) from) ? ubyte(1) : ubyte(0));
                        }

                        return (U) ubyte(new BigDecimal(from.toString().trim()).shortValue());
                    }
                    catch (NumberFormatException e) {
                        return null;
                    }
                }
                else if (toClass == UShort.class) {
                    try {
                        if (Number.class.isAssignableFrom(fromClass)) {
                            return (U) ushort(((Number) from).intValue());
                        }

                        if (fromClass == Boolean.class || fromClass == boolean.class) {
                            return (U) (((Boolean) from) ? ushort(1) : ushort(0));
                        }

                        return (U) ushort(new BigDecimal(from.toString().trim()).intValue());
                    }
                    catch (NumberFormatException e) {
                        return null;
                    }
                }
                else if (toClass == UInteger.class) {
                    try {
                        if (Number.class.isAssignableFrom(fromClass)) {
                            return (U) uint(((Number) from).longValue());
                        }

                        if (fromClass == Boolean.class || fromClass == boolean.class) {
                            return (U) (((Boolean) from) ? uint(1) : uint(0));
                        }

                        return (U) uint(new BigDecimal(from.toString().trim()).longValue());
                    }
                    catch (NumberFormatException e) {
                        return null;
                    }
                }
                else if (toClass == ULong.class) {
                    if (fromClass == Boolean.class || fromClass == boolean.class) {
                        return (U) (((Boolean) from) ? ulong(1) : ulong(0));
                    }

                    if (java.util.Date.class.isAssignableFrom(fromClass)) {
                        return (U) ulong(((java.util.Date) from).getTime());
                    }


                    if (Temporal.class.isAssignableFrom(fromClass)) {
                        Temporal temporal = (Temporal) from;


                        if (temporal instanceof LocalDate) {
                            return (U) ulong(Date.valueOf((LocalDate) temporal).getTime());
                        }
                        else if (temporal instanceof LocalTime) {
                            return (U) ulong(Time.valueOf((LocalTime) temporal).getTime());
                        }
                        else if (temporal instanceof LocalDateTime) {
                            return (U) ulong(Timestamp.valueOf((LocalDateTime) temporal).getTime());
                        }


                        else if (temporal.isSupported(INSTANT_SECONDS)) {
                            return (U) ulong(1000 * temporal.getLong(INSTANT_SECONDS) + temporal.getLong(MILLI_OF_SECOND));
                        }


                        else if (temporal.isSupported(MILLI_OF_DAY)) {
                            return (U) ulong(temporal.getLong(MILLI_OF_DAY));
                        }
                    }


                    try {
                        return (U) ulong(new BigDecimal(from.toString().trim()).toBigInteger().toString());
                    }
                    catch (NumberFormatException e) {
                        return null;
                    }
                }


                else if (toClass == Float.class || toClass == float.class) {
                    if (Number.class.isAssignableFrom(fromClass)) {
                        return (U) Float.valueOf(((Number) from).floatValue());
                    }

                    if (fromClass == Boolean.class || fromClass == boolean.class) {
                        return (U) (((Boolean) from) ? Float.valueOf(1.0f) : Float.valueOf(0.0f));
                    }

                    try {
                        return (U) Float.valueOf(from.toString().trim());
                    }
                    catch (NumberFormatException e) {
                        return null;
                    }
                }
                else if (toClass == Double.class || toClass == double.class) {
                    if (Number.class.isAssignableFrom(fromClass)) {
                        return (U) Double.valueOf(((Number) from).doubleValue());
                    }

                    if (fromClass == Boolean.class || fromClass == boolean.class) {
                        return (U) (((Boolean) from) ? Double.valueOf(1.0) : Double.valueOf(0.0));
                    }

                    try {
                        return (U) Double.valueOf(from.toString().trim());
                    }
                    catch (NumberFormatException e) {
                        return null;
                    }
                }
                else if (toClass == BigDecimal.class) {
                    if (fromClass == Boolean.class || fromClass == boolean.class) {
                        return (U) (((Boolean) from) ? BigDecimal.ONE : BigDecimal.ZERO);
                    }

                    try {
                        return (U) new BigDecimal(from.toString().trim());
                    }
                    catch (NumberFormatException e) {
                        return null;
                    }
                }
                else if (toClass == BigInteger.class) {
                    if (fromClass == Boolean.class || fromClass == boolean.class) {
                        return (U) (((Boolean) from) ? BigInteger.ONE : BigInteger.ZERO);
                    }

                    try {
                        return (U) new BigDecimal(from.toString().trim()).toBigInteger();
                    }
                    catch (NumberFormatException e) {
                        return null;
                    }
                }
                else if (toClass == Boolean.class || toClass == boolean.class) {
                    String s = from.toString().toLowerCase().trim();

                    if (TRUE_VALUES.contains(s)) {
                        return (U) Boolean.TRUE;
                    }
                    else if (FALSE_VALUES.contains(s)) {
                        return (U) Boolean.FALSE;
                    }
                    else {
                        return (U) (toClass == Boolean.class ? null : false);
                    }
                }
                else if (toClass == Character.class || toClass == char.class) {
                    if (fromClass == Boolean.class || fromClass == boolean.class) {
                        return (U) (((Boolean) from) ? Character.valueOf('1') : Character.valueOf('0'));
                    }

                    if (from.toString().length() < 1) {
                        return null;
                    }

                    return (U) Character.valueOf(from.toString().charAt(0));
                }


                else if ((fromClass == String.class) && toClass == URI.class) {
                    try {
                        return (U) new URI(from.toString());
                    }
                    catch (URISyntaxException e) {
                        return null;
                    }
                }


                else if ((fromClass == String.class) && toClass == URL.class) {
                    try {
                        return (U) new URI(from.toString()).toURL();
                    }
                    catch (Exception e) {
                        return null;
                    }
                }


                else if ((fromClass == String.class) && toClass == File.class) {
                    try {
                        return (U) new File(from.toString());
                    }
                    catch (Exception e) {
                        return null;
                    }
                }


                else if (java.util.Date.class.isAssignableFrom(fromClass)) {
                    return toDate(((java.util.Date) from).getTime(), toClass);
                }


                else if (Temporal.class.isAssignableFrom(fromClass)) {
                    return toDate(convert(from, Long.class), toClass);
                }



                else if ((fromClass == Long.class || fromClass == long.class) && java.util.Date.class.isAssignableFrom(toClass)) {
                    return toDate((Long) from, toClass);
                }


                else if ((fromClass == Long.class || fromClass == long.class) && Temporal.class.isAssignableFrom(toClass)) {
                    return toDate((Long) from, toClass);
                }



                else if ((fromClass == String.class) && toClass == java.sql.Date.class) {
                    try {
                        return (U) java.sql.Date.valueOf((String) from);
                    }
                    catch (IllegalArgumentException e) {
                        return null;
                    }
                }


                else if ((fromClass == String.class) && toClass == java.sql.Time.class) {
                    try {
                        return (U) java.sql.Time.valueOf((String) from);
                    }
                    catch (IllegalArgumentException e) {
                        return null;
                    }
                }


                else if ((fromClass == String.class) && toClass == java.sql.Timestamp.class) {
                    try {
                        return (U) java.sql.Timestamp.valueOf((String) from);
                    }
                    catch (IllegalArgumentException e) {
                        return null;
                    }
                }


                else if ((fromClass == String.class) && toClass == LocalDate.class) {


                    try {
                        return (U) java.sql.Date.valueOf((String) from).toLocalDate();
                    }
                    catch (IllegalArgumentException e1) {
                        try {
                            return (U) LocalDate.parse((String) from);
                        }
                        catch (DateTimeParseException e2) {
                            return null;
                        }
                    }
                }

                else if ((fromClass == String.class) && toClass == LocalTime.class) {


                    try {
                        return (U) java.sql.Time.valueOf((String) from).toLocalTime();
                    }
                    catch (IllegalArgumentException e1) {
                        try {
                            return (U) LocalTime.parse((String) from);
                        }
                        catch (DateTimeParseException e2) {
                            return null;
                        }
                    }
                }

                else if ((fromClass == String.class) && toClass == OffsetTime.class) {


                    try {
                        return (U) java.sql.Time.valueOf((String) from).toLocalTime().atOffset(OffsetTime.now().getOffset());
                    }
                    catch (IllegalArgumentException e1) {
                        try {
                            return (U) OffsetTime.parse((String) from);
                        }
                        catch (DateTimeParseException e2) {
                            return null;
                        }
                    }
                }

                else if ((fromClass == String.class) && toClass == LocalDateTime.class) {


                    try {
                        return (U) java.sql.Timestamp.valueOf((String) from).toLocalDateTime();
                    }
                    catch (IllegalArgumentException e1) {
                        try {
                            return (U) LocalDateTime.parse((String) from);
                        }
                        catch (DateTimeParseException e2) {
                            return null;
                        }
                    }
                }

                else if ((fromClass == String.class) && toClass == OffsetDateTime.class) {


                    try {
                        return (U) java.sql.Timestamp.valueOf((String) from).toLocalDateTime().atOffset(OffsetDateTime.now().getOffset());
                    }
                    catch (IllegalArgumentException e1) {
                        try {
                            return (U) OffsetDateTime.parse((String) from);
                        }
                        catch (DateTimeParseException e2) {
                            return null;
                        }
                    }
                }




                else if ((fromClass == String.class) && java.lang.Enum.class.isAssignableFrom(toClass)) {
                    try {
                        return (U) java.lang.Enum.valueOf((Class) toClass, (String) from);
                    }
                    catch (IllegalArgumentException e) {
                        return null;
                    }
                }


                else if ((fromClass == String.class) && toClass == UUID.class) {
                    try {
                        return (U) parseUUID((String) from);
                    }
                    catch (IllegalArgumentException e) {
                        return null;
                    }
                }



                else if (Record.class.isAssignableFrom(fromClass)) {
                    Record record = (Record) from;
                    return record.into(toClass);
                }




            }

            throw fail(from, toClass);
        }

        @Override
        public Object to(U to) {
            return to;
        }

        @Override
        public Class<Object> fromType() {
            return Object.class;
        }

        @SuppressWarnings("unchecked")
        @Override
        public Class<U> toType() {
            return (Class<U>) toClass;
        }


        @SuppressWarnings("unchecked")
        private static <X> X toDate(long time, Class<X> toClass) {
            if (toClass == Date.class) {
                return (X) new Date(time);
            }
            else if (toClass == Time.class) {
                return (X) new Time(time);
            }
            else if (toClass == Timestamp.class) {
                return (X) new Timestamp(time);
            }
            else if (toClass == java.util.Date.class) {
                return (X) new java.util.Date(time);
            }
            else if (toClass == Calendar.class) {
                Calendar calendar = Calendar.getInstance();
                calendar.setTimeInMillis(time);
                return (X) calendar;
            }


            else if (toClass == LocalDate.class) {
                return (X) new Date(time).toLocalDate();
            }
            else if (toClass == LocalTime.class) {
                return (X) new Time(time).toLocalTime();
            }
            else if (toClass == OffsetTime.class) {
                return (X) new Time(time).toLocalTime().atOffset(OffsetTime.now().getOffset());
            }
            else if (toClass == LocalDateTime.class) {
                return (X) new Timestamp(time).toLocalDateTime();
            }
            else if (toClass == OffsetDateTime.class) {
                return (X) new Timestamp(time).toLocalDateTime().atOffset(OffsetDateTime.now().getOffset());
            }


            throw fail(time, toClass);
        }


        private static final UUID parseUUID(String string) {
            if (string == null) {
                return null;
            }
            else if (string.contains("-")) {
                return UUID.fromString(string);
            }
            else {
                return UUID.fromString(UUID_PATTERN.matcher(string).replaceAll("$1-$2-$3-$4-$5"));
            }
        }

        private static DataTypeException fail(Object from, Class<?> toClass) {
            return new DataTypeException("Cannot convert from " + from + " (" + from.getClass() + ") to " + toClass);
        }
    }
}

<code block>

package org.jooq.test;

import static java.time.temporal.ChronoField.INSTANT_SECONDS;
import static java.time.temporal.ChronoField.MILLI_OF_DAY;
import static java.time.temporal.ChronoField.MILLI_OF_SECOND;
import static org.jooq.tools.reflect.Reflect.wrapper;
import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import java.lang.reflect.Array;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.sql.Date;
import java.sql.SQLException;
import java.sql.Time;
import java.sql.Timestamp;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.OffsetDateTime;
import java.time.OffsetTime;
import java.time.ZoneOffset;
import java.time.temporal.Temporal;

import org.jooq.Record;
import org.jooq.Result;
import org.jooq.tools.Convert;

import org.junit.Test;


public class ConvertAllTest extends AbstractTest {

    @Test
    public void testToObject() {
        testConversion(null, null, Object.class);
        testConversion("a", "a", Object.class);
        testConversion(true, true, Object.class);
        testConversion((byte) 1, (byte) 1, Object.class);
        testConversion((short) 1, (short) 1, Object.class);
        testConversion(1, 1, Object.class);
        testConversion(1L, 1L, Object.class);
        testConversion(1.0d, 1.0d, Object.class);
        testConversion(1.0f, 1.0f, Object.class);
        testConversion(BigInteger.ONE, BigInteger.ONE, Object.class);
        testConversion(BigDecimal.ONE, BigDecimal.ONE, Object.class);
        testConversion(new Date(0), new Date(0), Object.class);
        testConversion(new Time(0), new Time(0), Object.class);
        testConversion(new Timestamp(0), new Timestamp(0), Object.class);
    }

    @Test
    public void testToString() {
        testConversion(null, null, String.class);
        testConversion("a", "a", String.class);
        testConversion("true", true, String.class);
        testConversion("1", (byte) 1, String.class);
        testConversion("1", (short) 1, String.class);
        testConversion("1", 1, String.class);
        testConversion("1", 1L, String.class);
        testConversion("1.0", 1.0d, String.class);
        testConversion("1.0", 1.0f, String.class);
        testConversion("1", BigInteger.ONE, String.class);
        testConversion("1", BigDecimal.ONE, String.class);
        testConversion(zeroDate(), new Date(0), String.class);
        testConversion(zeroTime(), new Time(0), String.class);
        testConversion(zeroTimestamp(), new Timestamp(0), String.class);
    }

    @Test
    public void testToBoolean() {
        testConversion(false, null, boolean.class);
        testConversion(false, "xmf", boolean.class);
        testConversion(null, null, Boolean.class);
        testConversion(true, "true", Boolean.class);
        testConversion(true, "1", Boolean.class);
        testConversion(true, "yes", Boolean.class);
        testConversion(false, "false", Boolean.class);
        testConversion(true, "t", Boolean.class);
        testConversion(false, "f", Boolean.class);
        testConversion(false, "0", Boolean.class);
        testConversion(false, "no", Boolean.class);
        testConversion(null, "xmf", Boolean.class);
        testConversion(true, true, Boolean.class);
        testConversion(false, false, Boolean.class);
        testConversion(null, (byte) 2, Boolean.class);
        testConversion(true, (byte) 1, Boolean.class);
        testConversion(false, (byte) 0, Boolean.class);
        testConversion(null, (short) 2, Boolean.class);
        testConversion(true, (short) 1, Boolean.class);
        testConversion(false, (short) 0, Boolean.class);
        testConversion(null, 2, Boolean.class);
        testConversion(true, 1, Boolean.class);
        testConversion(false, 0, Boolean.class);
        testConversion(null, 2L, Boolean.class);
        testConversion(true, 1L, Boolean.class);
        testConversion(false, 0L, Boolean.class);
        testConversion(null, 2.0, Boolean.class);
        testConversion(true, 1.0, Boolean.class);
        testConversion(false, 0.0, Boolean.class);
        testConversion(null, BigInteger.TEN, Boolean.class);
        testConversion(true, BigInteger.ONE, Boolean.class);
        testConversion(false, BigInteger.ZERO, Boolean.class);
        testConversion(null, BigDecimal.TEN, Boolean.class);
        testConversion(true, BigDecimal.ONE, Boolean.class);
        testConversion(false, BigDecimal.ZERO, Boolean.class);
        testConversion(null, new Date(0), Boolean.class);
        testConversion(null, new Time(0), Boolean.class);
        testConversion(null, new Timestamp(0), Boolean.class);
    }

    @Test
    public void testToByte() {
        testConversion(null, null, Byte.class);
        testConversion((byte) 0, null, byte.class);
        testConversion((byte) 1, "1", Byte.class);
        testConversion((byte) 1, true, Byte.class);
        testConversion((byte) 0, false, Byte.class);
        testConversion((byte) 1, (byte) 1, Byte.class);
        testConversion((byte) 1, (short) 1, Byte.class);
        testConversion((byte) 1, 1, Byte.class);
        testConversion((byte) 1, 1L, Byte.class);
        testConversion((byte) 1, 1.0d, Byte.class);
        testConversion((byte) 1, 1.0f, Byte.class);
        testConversion((byte) 1, BigInteger.ONE, Byte.class);
        testConversion((byte) 1, BigDecimal.ONE, Byte.class);
        testConversion(null, new Date(0), Byte.class);
        testConversion(null, new Time(0), Byte.class);
        testConversion(null, new Timestamp(0), Byte.class);
    }

    @Test
    public void testToShort() {
        testConversion(null, null, Short.class);
        testConversion((short) 0, null, short.class);
        testConversion((short) 1, "1", Short.class);
        testConversion((short) 1, true, Short.class);
        testConversion((short) 0, false, Short.class);
        testConversion((short) 1, (byte) 1, Short.class);
        testConversion((short) 1, (short) 1, Short.class);
        testConversion((short) 1, 1, Short.class);
        testConversion((short) 1, 1L, Short.class);
        testConversion((short) 1, 1.0d, Short.class);
        testConversion((short) 1, 1.0f, Short.class);
        testConversion((short) 1, BigInteger.ONE, Short.class);
        testConversion((short) 1, BigDecimal.ONE, Short.class);
        testConversion(null, new Date(0), Short.class);
        testConversion(null, new Time(0), Short.class);
        testConversion(null, new Timestamp(0), Short.class);
    }

    @Test
    public void testToInteger() {
        testConversion(null, null, Integer.class);
        testConversion(0, null, int.class);
        testConversion(1, "1", Integer.class);
        testConversion(1, true, Integer.class);
        testConversion(0, false, Integer.class);
        testConversion(1, (byte) 1, Integer.class);
        testConversion(1, (short) 1, Integer.class);
        testConversion(1, 1, Integer.class);
        testConversion(1, 1L, Integer.class);
        testConversion(1, 1.0d, Integer.class);
        testConversion(1, 1.0f, Integer.class);
        testConversion(1, BigInteger.ONE, Integer.class);
        testConversion(1, BigDecimal.ONE, Integer.class);
        testConversion(null, new Date(0), Integer.class);
        testConversion(null, new Time(0), Integer.class);
        testConversion(null, new Timestamp(0), Integer.class);
    }

    @Test
    public void testToLong() {
        testConversion(null, null, Long.class);
        testConversion(0L, null, long.class);
        testConversion(1L, "1", Long.class);
        testConversion(1L, true, Long.class);
        testConversion(0L, false, Long.class);
        testConversion(1L, (byte) 1, Long.class);
        testConversion(1L, (short) 1, Long.class);
        testConversion(1L, 1, Long.class);
        testConversion(1L, 1L, Long.class);
        testConversion(1L, 1.0d, Long.class);
        testConversion(1L, 1.0f, Long.class);
        testConversion(1L, BigInteger.ONE, Long.class);
        testConversion(1L, BigDecimal.ONE, Long.class);


        Date date = Date.valueOf("2001-02-03");
        testConversion(date.getTime(), date, Long.class);
        testConversion(date.getTime(), date.toLocalDate(), Long.class);


        Time time = Time.valueOf("04:05:06");
        testConversion(time.getTime(), time, Long.class);
        testConversion(time.getTime(), time.toLocalTime(), Long.class);

        OffsetTime t1 = OffsetTime.parse("04:05:06.789Z");
        OffsetTime t2 = OffsetTime.parse("04:05:06.789+02:00");
        testConversion(millis(t1), t1, Long.class);
        testConversion(millis(t2), t2, Long.class);


        Timestamp timestamp = Timestamp.valueOf("2001-02-03 04:05:06.789");
        testConversion(timestamp.getTime(), timestamp, Long.class);
        testConversion(timestamp.getTime(), timestamp.toLocalDateTime(), Long.class);

        OffsetDateTime dt1 = OffsetDateTime.parse("2001-02-03T04:05:06.789Z");
        OffsetDateTime dt2 = OffsetDateTime.parse("2001-02-03T04:05:06.789+02:00");
        testConversion(millis(dt1), dt1, Long.class);
        testConversion(millis(dt2), dt2, Long.class);
    }

    @Test
    public void testToBigInteger() {
        testConversion(null, null, BigInteger.class);
        testConversion(BigInteger.ONE, "1", BigInteger.class);
        testConversion(BigInteger.ONE, true, BigInteger.class);
        testConversion(BigInteger.ZERO, false, BigInteger.class);
        testConversion(BigInteger.ONE, (byte) 1, BigInteger.class);
        testConversion(BigInteger.ONE, (short) 1, BigInteger.class);
        testConversion(BigInteger.ONE, 1, BigInteger.class);
        testConversion(BigInteger.ONE, 1L, BigInteger.class);
        testConversion(BigInteger.ONE, 1.0d, BigInteger.class);
        testConversion(BigInteger.ONE, 1.0f, BigInteger.class);
        testConversion(BigInteger.ONE, BigInteger.ONE, BigInteger.class);
        testConversion(BigInteger.ONE, BigDecimal.ONE, BigInteger.class);
        testConversion(null, new Date(0), BigInteger.class);
        testConversion(null, new Time(0), BigInteger.class);
        testConversion(null, new Timestamp(0), BigInteger.class);
    }

    @Test
    public void testToBigDecimal() {
        testConversion(null, null, BigDecimal.class);
        testConversion(BigDecimal.ONE, "1", BigDecimal.class);
        testConversion(BigDecimal.ONE, true, BigDecimal.class);
        testConversion(BigDecimal.ZERO, false, BigDecimal.class);
        testConversion(BigDecimal.ONE, (byte) 1, BigDecimal.class);
        testConversion(BigDecimal.ONE, (short) 1, BigDecimal.class);
        testConversion(BigDecimal.ONE, 1, BigDecimal.class);
        testConversion(BigDecimal.ONE, 1L, BigDecimal.class);
        testConversion(new BigDecimal("1.0"), 1.0d, BigDecimal.class);
        testConversion(new BigDecimal("1.0"), 1.0f, BigDecimal.class);
        testConversion(BigDecimal.ONE, BigInteger.ONE, BigDecimal.class);
        testConversion(BigDecimal.ONE, BigDecimal.ONE, BigDecimal.class);
        testConversion(null, new Date(0), BigDecimal.class);
        testConversion(null, new Time(0), BigDecimal.class);
        testConversion(null, new Timestamp(0), BigDecimal.class);
    }

    @SuppressWarnings("unchecked")
    private static <T, U> void testConversion(U expected, T from, Class<U> toClass) {
        if (from != null) {
            assertEquals(from, Convert.convert(from, Object.class));
            assertEquals(from, Convert.convert(from, from.getClass()));
        }

        U conv1 = Convert.convert(from, toClass);
        assertEquals(expected, conv1);

        if (toClass.isPrimitive()) {
            assertTrue(wrapper(toClass).isInstance(conv1));
            return;
        }
        else if (expected == null) {
            assertNull(conv1);
        }
        else {
            assertTrue(toClass.isInstance(conv1));
        }

        Class<?> toArrayClass = Array.newInstance(toClass, 0).getClass();

        Object[] conv2 = Convert.convert(new Object[] { from, from }, new Class[] { toClass, toClass });
        U[] conv3 = (U[]) Convert.convert(new Object[] { from, from }, toClass);
        U[] conv4 = (U[]) Convert.convertArray(new Object[] { from, from }, toClass);
        U[] conv5 = (U[]) Convert.convertArray(new Object[] { from, from }, toArrayClass);

        assertEquals(2, conv2.length);
        assertEquals(2, conv3.length);
        assertEquals(2, conv4.length);
        assertEquals(2, conv5.length);
        assertEquals(expected, conv2[0]);
        assertEquals(expected, conv2[1]);
        assertEquals(expected, conv3[0]);
        assertEquals(expected, conv3[1]);
        assertEquals(expected, conv4[0]);
        assertEquals(expected, conv4[1]);
        assertEquals(expected, conv5[0]);
        assertEquals(expected, conv5[1]);
        assertTrue(Object[].class.isInstance(conv2));
        assertTrue(toArrayClass.isInstance(conv3));
        assertTrue(toArrayClass.isInstance(conv4));
        assertTrue(toArrayClass.isInstance(conv5));
    }

    @Test
    public void testToJDBCArray() throws SQLException {
        Object[] from1 = null;
        java.sql.Array a1 = Convert.convert(from1, java.sql.Array.class);
        assertNull(a1);

        Object[] from2 = new Object[0];
        java.sql.Array a2 = Convert.convert(from2, java.sql.Array.class);
        Result<Record> r2 = create.fetch(a2.getResultSet());
        assertArrayEquals(from2, (Object[]) a2.getArray());
        assertEquals(0, r2.size());
        assertEquals(2, r2.fields().length);
        assertEquals("INDEX", r2.field(0).getName());
        assertEquals(Long.class, r2.field(0).getType());
        assertEquals("VALUE", r2.field(1).getName());
        assertEquals(Object.class, r2.field(1).getType());

        Object[] from3 = { 1 };
        java.sql.Array a3 = Convert.convert(from3, java.sql.Array.class);
        Result<Record> r3 = create.fetch(a3.getResultSet());
        assertArrayEquals(from3, (Object[]) a3.getArray());
        assertEquals(1, r3.size());
        assertEquals(1L, r3.getValue(0, "INDEX"));
        assertEquals(1, r3.getValue(0, "VALUE"));
        assertEquals(2, r3.fields().length);
        assertEquals("INDEX", r3.field(0).getName());
        assertEquals(Long.class, r3.field(0).getType());
        assertEquals("VALUE", r3.field(1).getName());
        assertEquals(Object.class, r3.field(1).getType());

        String[] from4 = { "A", "B" };
        java.sql.Array a4 = Convert.convert(from4, java.sql.Array.class);
        Result<Record> r4 = create.fetch(a4.getResultSet());
        assertArrayEquals(from4, (String[]) a4.getArray());
        assertEquals(2, r4.size());
        assertEquals(1L, r4.getValue(0, "INDEX"));
        assertEquals("A", r4.getValue(0, "VALUE"));
        assertEquals(2L, r4.getValue(1, "INDEX"));
        assertEquals("B", r4.getValue(1, "VALUE"));
        assertEquals(2, r4.fields().length);
        assertEquals("INDEX", r4.field(0).getName());
        assertEquals(Long.class, r4.field(0).getType());
        assertEquals("VALUE", r4.field(1).getName());
        assertEquals(String.class, r4.field(1).getType());
    }

    @Test
    public void testToDate() {
        Date date = Date.valueOf("2001-02-03");

        testConversion(date, "2001-02-03", Date.class);
        testConversion(date, date.getTime(), Date.class);
        testConversion(date, date.toLocalDate(), Date.class);
    }

    @Test
    public void testToLocalDate() {
        Date date = Date.valueOf("2001-02-03");

        testConversion(date.toLocalDate(), "2001-02-03", LocalDate.class);
        testConversion(date.toLocalDate(), date.getTime(), LocalDate.class);
        testConversion(date.toLocalDate(), date, LocalDate.class);
    }

    @Test
    public void testToTime() {
        Time time = Time.valueOf("04:05:06");

        testConversion(time, "04:05:06", Time.class);
        testConversion(time, time.getTime(), Time.class);
        testConversion(time, time.toLocalTime(), Time.class);

        OffsetTime o1 = OffsetTime.parse("04:05:06.789Z");
        OffsetTime o2 = OffsetTime.parse("04:05:06.789+02:00");
        testConversion(new Time(millis(o1)), o1, Time.class);
        testConversion(new Time(millis(o2)), o2, Time.class);
    }

    @Test
    public void testToLocalTime() {
        Time time = Time.valueOf("04:05:06");

        testConversion(time.toLocalTime(), "04:05:06", LocalTime.class);
        testConversion(time.toLocalTime(), time.getTime(), LocalTime.class);
        testConversion(time.toLocalTime(), time, LocalTime.class);

        OffsetTime o1 = OffsetTime.parse("04:05:06.789Z");
        OffsetTime o2 = OffsetTime.parse("04:05:06.789+02:00");
        testConversion(new Time(millis(o1)).toLocalTime(), o1, LocalTime.class);
        testConversion(new Time(millis(o2)).toLocalTime(), o2, LocalTime.class);
    }

    @Test
    public void testToOffsetTime() {
        Time time = Time.valueOf("04:05:06");
        ZoneOffset offset = OffsetDateTime.now().getOffset();

        testConversion(time.toLocalTime().atOffset(offset), "04:05:06", OffsetTime.class);
        testConversion(time.toLocalTime().atOffset(offset), time.getTime(), OffsetTime.class);
        testConversion(time.toLocalTime().atOffset(offset), time, OffsetTime.class);
    }

    @Test
    public void testToTimestamp() {
        Timestamp t1 = Timestamp.valueOf("2001-02-03 04:05:06");
        Timestamp t2 = Timestamp.valueOf("2001-02-03 04:05:06.7");
        Timestamp t3 = Timestamp.valueOf("2001-02-03 04:05:06.789");

        testConversion(t1, "2001-02-03 04:05:06", Timestamp.class);
        testConversion(t2, "2001-02-03 04:05:06.7", Timestamp.class);
        testConversion(t3, "2001-02-03 04:05:06.789", Timestamp.class);

        testConversion(t1, t1.getTime(), Timestamp.class);
        testConversion(t2, t2.getTime(), Timestamp.class);
        testConversion(t3, t3.getTime(), Timestamp.class);

        testConversion(t1, t1.toLocalDateTime(), Timestamp.class);
        testConversion(t2, t2.toLocalDateTime(), Timestamp.class);
        testConversion(t3, t3.toLocalDateTime(), Timestamp.class);

        OffsetDateTime o1 = OffsetDateTime.parse("2001-02-03T04:05:06.789Z");
        OffsetDateTime o2 = OffsetDateTime.parse("2001-02-03T04:05:06.789+02:00");
        testConversion(new Timestamp(millis(o1)), o1, Timestamp.class);
        testConversion(new Timestamp(millis(o2)), o2, Timestamp.class);
    }

    @Test
    public void testToLocalDateTime() {
        Timestamp t1 = Timestamp.valueOf("2001-02-03 04:05:06");
        Timestamp t2 = Timestamp.valueOf("2001-02-03 04:05:06.7");
        Timestamp t3 = Timestamp.valueOf("2001-02-03 04:05:06.789");

        testConversion(t1.toLocalDateTime(), "2001-02-03 04:05:06", LocalDateTime.class);
        testConversion(t2.toLocalDateTime(), "2001-02-03 04:05:06.7", LocalDateTime.class);
        testConversion(t3.toLocalDateTime(), "2001-02-03 04:05:06.789", LocalDateTime.class);

        testConversion(t1.toLocalDateTime(), t1.getTime(), LocalDateTime.class);
        testConversion(t2.toLocalDateTime(), t2.getTime(), LocalDateTime.class);
        testConversion(t3.toLocalDateTime(), t3.getTime(), LocalDateTime.class);

        testConversion(t1.toLocalDateTime(), t1, LocalDateTime.class);
        testConversion(t2.toLocalDateTime(), t2, LocalDateTime.class);
        testConversion(t3.toLocalDateTime(), t3, LocalDateTime.class);

        OffsetDateTime o1 = OffsetDateTime.parse("2001-02-03T04:05:06.789Z");
        OffsetDateTime o2 = OffsetDateTime.parse("2001-02-03T04:05:06.789+02:00");
        testConversion(new Timestamp(millis(o1)).toLocalDateTime(), o1, LocalDateTime.class);
        testConversion(new Timestamp(millis(o2)).toLocalDateTime(), o2, LocalDateTime.class);
    }

    @Test
    public void testToOffsetDateTime() {
        Timestamp t1 = Timestamp.valueOf("2001-02-03 04:05:06");
        Timestamp t2 = Timestamp.valueOf("2001-02-03 04:05:06.7");
        Timestamp t3 = Timestamp.valueOf("2001-02-03 04:05:06.789");
        ZoneOffset offset = OffsetDateTime.now().getOffset();

        testConversion(t1.toLocalDateTime().atOffset(offset), "2001-02-03 04:05:06", OffsetDateTime.class);
        testConversion(t2.toLocalDateTime().atOffset(offset), "2001-02-03 04:05:06.7", OffsetDateTime.class);
        testConversion(t3.toLocalDateTime().atOffset(offset), "2001-02-03 04:05:06.789", OffsetDateTime.class);

        testConversion(t1.toLocalDateTime().atOffset(offset), t1.getTime(), OffsetDateTime.class);
        testConversion(t2.toLocalDateTime().atOffset(offset), t2.getTime(), OffsetDateTime.class);
        testConversion(t3.toLocalDateTime().atOffset(offset), t3.getTime(), OffsetDateTime.class);

        testConversion(t1.toLocalDateTime().atOffset(offset), t1, OffsetDateTime.class);
        testConversion(t2.toLocalDateTime().atOffset(offset), t2, OffsetDateTime.class);
        testConversion(t3.toLocalDateTime().atOffset(offset), t3, OffsetDateTime.class);
    }

    private Long millis(Temporal t) {
        if (t.isSupported(INSTANT_SECONDS))
            return 1000 * t.getLong(INSTANT_SECONDS) + t.getLong(MILLI_OF_SECOND);
        else
            return t.getLong(MILLI_OF_DAY);
    }
}

<code block>

package org.jooq.tools;

import static java.time.temporal.ChronoField.INSTANT_SECONDS;
import static java.time.temporal.ChronoField.MILLI_OF_DAY;
import static java.time.temporal.ChronoField.MILLI_OF_SECOND;
import static org.jooq.types.Unsigned.ubyte;
import static org.jooq.types.Unsigned.uint;
import static org.jooq.types.Unsigned.ulong;
import static org.jooq.types.Unsigned.ushort;

import java.io.File;
import java.lang.reflect.Array;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.sql.Date;
import java.sql.Time;
import java.sql.Timestamp;
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.OffsetDateTime;
import java.time.OffsetTime;
import java.time.format.DateTimeParseException;
import java.time.temporal.Temporal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.UUID;
import java.util.regex.Pattern;


import org.jooq.Converter;
import org.jooq.EnumType;
import org.jooq.Field;
import org.jooq.Record;
import org.jooq.SQLDialect;
import org.jooq.exception.DataTypeException;
import org.jooq.tools.jdbc.MockArray;
import org.jooq.types.UByte;
import org.jooq.types.UInteger;
import org.jooq.types.ULong;
import org.jooq.types.UShort;


public final class Convert {


    public static final Set<String> TRUE_VALUES;


    public static final Set<String> FALSE_VALUES;


    private static final Pattern UUID_PATTERN = Pattern.compile("(\\p{XDigit}{8})-?(\\p{XDigit}{4})-?(\\p{XDigit}{4})-?(\\p{XDigit}{4})-?(\\p{XDigit}{12})");

    static {
        Set<String> trueValues = new HashSet<String>();
        Set<String> falseValues = new HashSet<String>();

        trueValues.add("1");
        trueValues.add("1.0");
        trueValues.add("y");
        trueValues.add("Y");
        trueValues.add("yes");
        trueValues.add("YES");
        trueValues.add("true");
        trueValues.add("TRUE");
        trueValues.add("t");
        trueValues.add("T");
        trueValues.add("on");
        trueValues.add("ON");
        trueValues.add("enabled");
        trueValues.add("ENABLED");

        falseValues.add("0");
        falseValues.add("0.0");
        falseValues.add("n");
        falseValues.add("N");
        falseValues.add("no");
        falseValues.add("NO");
        falseValues.add("false");
        falseValues.add("FALSE");
        falseValues.add("f");
        falseValues.add("F");
        falseValues.add("off");
        falseValues.add("OFF");
        falseValues.add("disabled");
        falseValues.add("DISABLED");

        TRUE_VALUES = Collections.unmodifiableSet(trueValues);
        FALSE_VALUES = Collections.unmodifiableSet(falseValues);
    }


    public static final Object[] convert(Object[] values, Field<?>[] fields) {



        if (values != null) {
            Object[] result = new Object[values.length];

            for (int i = 0; i < values.length; i++) {



                if (values[i] instanceof Field<?>) {
                    result[i] = values[i];
                }
                else {
                    result[i] = convert(values[i], fields[i].getType());
                }
            }

            return result;
        }
        else {
            return null;
        }
    }


    public static final Object[] convert(Object[] values, Class<?>[] types) {



        if (values != null) {
            Object[] result = new Object[values.length];

            for (int i = 0; i < values.length; i++) {



                if (values[i] instanceof Field<?>) {
                    result[i] = values[i];
                }
                else {
                    result[i] = convert(values[i], types[i]);
                }
            }

            return result;
        }
        else {
            return null;
        }
    }

    @SuppressWarnings("unchecked")
    public static final <U> U[] convertArray(Object[] from, Converter<?, U> converter) throws DataTypeException {
        if (from == null) {
            return null;
        }
        else {
            Object[] arrayOfT = convertArray(from, converter.fromType());
            Object[] arrayOfU = (Object[]) Array.newInstance(converter.toType(), from.length);

            for (int i = 0; i < arrayOfT.length; i++) {
                arrayOfU[i] = convert(arrayOfT[i], converter);
            }

            return (U[]) arrayOfU;
        }
    }


    @SuppressWarnings("unchecked")
    public static final Object[] convertArray(Object[] from, Class<?> toClass) throws DataTypeException {
        if (from == null) {
            return null;
        }
        else if (!toClass.isArray()) {
            return convertArray(from, Array.newInstance(toClass, 0).getClass());
        }
        else if (toClass == from.getClass()) {
            return from;
        }
        else {
            final Class<?> toComponentType = toClass.getComponentType();

            if (from.length == 0) {
                return Arrays.copyOf(from, from.length, (Class<? extends Object[]>) toClass);
            }
            else if (from[0] != null && from[0].getClass() == toComponentType) {
                return Arrays.copyOf(from, from.length, (Class<? extends Object[]>) toClass);
            }
            else {
                final Object[] result = (Object[]) Array.newInstance(toComponentType, from.length);

                for (int i = 0; i < from.length; i++) {
                    result[i] = convert(from[i], toComponentType);
                }

                return result;
            }
        }
    }


    public static final <U> U convert(Object from, Converter<?, U> converter) throws DataTypeException {
        return convert0(from, converter);
    }


    private static final <T, U> U convert0(Object from, Converter<T, U> converter) throws DataTypeException {
        ConvertAll<T> all = new ConvertAll<T>(converter.fromType());
        return converter.from(all.from(from));
    }


    public static final <T> T convert(Object from, Class<? extends T> toClass) throws DataTypeException {
        return convert(from, new ConvertAll<T>(toClass));
    }


    public static final <T> List<T> convert(Collection<?> collection, Class<? extends T> type) throws DataTypeException {
        return convert(collection, new ConvertAll<T>(type));
    }


    public static final <U> List<U> convert(Collection<?> collection, Converter<?, U> converter) throws DataTypeException {
        return convert0(collection, converter);
    }


    private static final <T, U> List<U> convert0(Collection<?> collection, Converter<T, U> converter) throws DataTypeException {
        ConvertAll<T> all = new ConvertAll<T>(converter.fromType());
        List<U> result = new ArrayList<U>(collection.size());

        for (Object o : collection) {
            result.add(convert(all.from(o), converter));
        }

        return result;
    }


    private Convert() {}


    private static class ConvertAll<U> implements Converter<Object, U> {


        private static final long        serialVersionUID = 2508560107067092501L;

        private final Class<? extends U> toClass;

        ConvertAll(Class<? extends U> toClass) {
            this.toClass = toClass;
        }

        @SuppressWarnings({ "unchecked", "rawtypes" })
        @Override
        public U from(Object from) {
            if (from == null) {



                if (toClass.isPrimitive()) {


                    if (toClass == char.class) {
                        return (U) Character.valueOf((char) 0);
                    }


                    else {
                        return convert(0, toClass);
                    }
                }
                else {
                    return null;
                }
            }
            else {
                final Class<?> fromClass = from.getClass();


                if (toClass == fromClass) {
                    return (U) from;
                }



                else if (toClass.isAssignableFrom(fromClass)) {
                    return (U) from;
                }


                else if (fromClass == byte[].class) {


                    return convert(Arrays.toString((byte[]) from), toClass);
                }
                else if (fromClass.isArray()) {


                    if (toClass == java.sql.Array.class) {
                        return (U) new MockArray(null, (Object[]) from, fromClass);
                    }
                    else {
                        return (U) convertArray((Object[]) from, toClass);
                    }
                }


                else if (toClass == String.class) {
                    if (from instanceof EnumType) {
                        return (U) ((EnumType) from).getLiteral();
                    }

                    return (U) from.toString();
                }


                else if (toClass == Byte.class || toClass == byte.class) {
                    if (Number.class.isAssignableFrom(fromClass)) {
                        return (U) Byte.valueOf(((Number) from).byteValue());
                    }

                    if (fromClass == Boolean.class || fromClass == boolean.class) {
                        return (U) (((Boolean) from) ? Byte.valueOf((byte) 1) : Byte.valueOf((byte) 0));
                    }

                    try {
                        return (U) Byte.valueOf(new BigDecimal(from.toString().trim()).byteValue());
                    }
                    catch (NumberFormatException e) {
                        return null;
                    }
                }
                else if (toClass == Short.class || toClass == short.class) {
                    if (Number.class.isAssignableFrom(fromClass)) {
                        return (U) Short.valueOf(((Number) from).shortValue());
                    }

                    if (fromClass == Boolean.class || fromClass == boolean.class) {
                        return (U) (((Boolean) from) ? Short.valueOf((short) 1) : Short.valueOf((short) 0));
                    }

                    try {
                        return (U) Short.valueOf(new BigDecimal(from.toString().trim()).shortValue());
                    }
                    catch (NumberFormatException e) {
                        return null;
                    }
                }
                else if (toClass == Integer.class || toClass == int.class) {
                    if (Number.class.isAssignableFrom(fromClass)) {
                        return (U) Integer.valueOf(((Number) from).intValue());
                    }

                    if (fromClass == Boolean.class || fromClass == boolean.class) {
                        return (U) (((Boolean) from) ? Integer.valueOf(1) : Integer.valueOf(0));
                    }

                    try {
                        return (U) Integer.valueOf(new BigDecimal(from.toString().trim()).intValue());
                    }
                    catch (NumberFormatException e) {
                        return null;
                    }
                }
                else if (toClass == Long.class || toClass == long.class) {
                    if (Number.class.isAssignableFrom(fromClass)) {
                        return (U) Long.valueOf(((Number) from).longValue());
                    }

                    if (fromClass == Boolean.class || fromClass == boolean.class) {
                        return (U) (((Boolean) from) ? Long.valueOf(1L) : Long.valueOf(0L));
                    }

                    if (java.util.Date.class.isAssignableFrom(fromClass)) {
                        return (U) Long.valueOf(((java.util.Date) from).getTime());
                    }


                    if (Temporal.class.isAssignableFrom(fromClass)) {
                        return (U) Long.valueOf(millis((Temporal) from));
                    }


                    try {
                        return (U) Long.valueOf(new BigDecimal(from.toString().trim()).longValue());
                    }
                    catch (NumberFormatException e) {
                        return null;
                    }
                }


                else if (toClass == UByte.class) {
                    try {
                        if (Number.class.isAssignableFrom(fromClass)) {
                            return (U) ubyte(((Number) from).shortValue());
                        }

                        if (fromClass == Boolean.class || fromClass == boolean.class) {
                            return (U) (((Boolean) from) ? ubyte(1) : ubyte(0));
                        }

                        return (U) ubyte(new BigDecimal(from.toString().trim()).shortValue());
                    }
                    catch (NumberFormatException e) {
                        return null;
                    }
                }
                else if (toClass == UShort.class) {
                    try {
                        if (Number.class.isAssignableFrom(fromClass)) {
                            return (U) ushort(((Number) from).intValue());
                        }

                        if (fromClass == Boolean.class || fromClass == boolean.class) {
                            return (U) (((Boolean) from) ? ushort(1) : ushort(0));
                        }

                        return (U) ushort(new BigDecimal(from.toString().trim()).intValue());
                    }
                    catch (NumberFormatException e) {
                        return null;
                    }
                }
                else if (toClass == UInteger.class) {
                    try {
                        if (Number.class.isAssignableFrom(fromClass)) {
                            return (U) uint(((Number) from).longValue());
                        }

                        if (fromClass == Boolean.class || fromClass == boolean.class) {
                            return (U) (((Boolean) from) ? uint(1) : uint(0));
                        }

                        return (U) uint(new BigDecimal(from.toString().trim()).longValue());
                    }
                    catch (NumberFormatException e) {
                        return null;
                    }
                }
                else if (toClass == ULong.class) {
                    if (fromClass == Boolean.class || fromClass == boolean.class) {
                        return (U) (((Boolean) from) ? ulong(1) : ulong(0));
                    }

                    if (java.util.Date.class.isAssignableFrom(fromClass)) {
                        return (U) ulong(((java.util.Date) from).getTime());
                    }


                    if (Temporal.class.isAssignableFrom(fromClass)) {
                        return (U) ulong(millis((Temporal) from));
                    }


                    try {
                        return (U) ulong(new BigDecimal(from.toString().trim()).toBigInteger().toString());
                    }
                    catch (NumberFormatException e) {
                        return null;
                    }
                }


                else if (toClass == Float.class || toClass == float.class) {
                    if (Number.class.isAssignableFrom(fromClass)) {
                        return (U) Float.valueOf(((Number) from).floatValue());
                    }

                    if (fromClass == Boolean.class || fromClass == boolean.class) {
                        return (U) (((Boolean) from) ? Float.valueOf(1.0f) : Float.valueOf(0.0f));
                    }

                    try {
                        return (U) Float.valueOf(from.toString().trim());
                    }
                    catch (NumberFormatException e) {
                        return null;
                    }
                }
                else if (toClass == Double.class || toClass == double.class) {
                    if (Number.class.isAssignableFrom(fromClass)) {
                        return (U) Double.valueOf(((Number) from).doubleValue());
                    }

                    if (fromClass == Boolean.class || fromClass == boolean.class) {
                        return (U) (((Boolean) from) ? Double.valueOf(1.0) : Double.valueOf(0.0));
                    }

                    try {
                        return (U) Double.valueOf(from.toString().trim());
                    }
                    catch (NumberFormatException e) {
                        return null;
                    }
                }
                else if (toClass == BigDecimal.class) {
                    if (fromClass == Boolean.class || fromClass == boolean.class) {
                        return (U) (((Boolean) from) ? BigDecimal.ONE : BigDecimal.ZERO);
                    }

                    try {
                        return (U) new BigDecimal(from.toString().trim());
                    }
                    catch (NumberFormatException e) {
                        return null;
                    }
                }
                else if (toClass == BigInteger.class) {
                    if (fromClass == Boolean.class || fromClass == boolean.class) {
                        return (U) (((Boolean) from) ? BigInteger.ONE : BigInteger.ZERO);
                    }

                    try {
                        return (U) new BigDecimal(from.toString().trim()).toBigInteger();
                    }
                    catch (NumberFormatException e) {
                        return null;
                    }
                }
                else if (toClass == Boolean.class || toClass == boolean.class) {
                    String s = from.toString().toLowerCase().trim();

                    if (TRUE_VALUES.contains(s)) {
                        return (U) Boolean.TRUE;
                    }
                    else if (FALSE_VALUES.contains(s)) {
                        return (U) Boolean.FALSE;
                    }
                    else {
                        return (U) (toClass == Boolean.class ? null : false);
                    }
                }
                else if (toClass == Character.class || toClass == char.class) {
                    if (fromClass == Boolean.class || fromClass == boolean.class) {
                        return (U) (((Boolean) from) ? Character.valueOf('1') : Character.valueOf('0'));
                    }

                    if (from.toString().length() < 1) {
                        return null;
                    }

                    return (U) Character.valueOf(from.toString().charAt(0));
                }


                else if ((fromClass == String.class) && toClass == URI.class) {
                    try {
                        return (U) new URI(from.toString());
                    }
                    catch (URISyntaxException e) {
                        return null;
                    }
                }


                else if ((fromClass == String.class) && toClass == URL.class) {
                    try {
                        return (U) new URI(from.toString()).toURL();
                    }
                    catch (Exception e) {
                        return null;
                    }
                }


                else if ((fromClass == String.class) && toClass == File.class) {
                    try {
                        return (U) new File(from.toString());
                    }
                    catch (Exception e) {
                        return null;
                    }
                }


                else if (java.util.Date.class.isAssignableFrom(fromClass)) {
                    return toDate(((java.util.Date) from).getTime(), toClass);
                }


                else if (Temporal.class.isAssignableFrom(fromClass)) {
                    return toDate(convert(from, Long.class), toClass);
                }



                else if ((fromClass == Long.class || fromClass == long.class) && java.util.Date.class.isAssignableFrom(toClass)) {
                    return toDate((Long) from, toClass);
                }


                else if ((fromClass == Long.class || fromClass == long.class) && Temporal.class.isAssignableFrom(toClass)) {
                    return toDate((Long) from, toClass);
                }



                else if ((fromClass == String.class) && toClass == java.sql.Date.class) {
                    try {
                        return (U) java.sql.Date.valueOf((String) from);
                    }
                    catch (IllegalArgumentException e) {
                        return null;
                    }
                }


                else if ((fromClass == String.class) && toClass == java.sql.Time.class) {
                    try {
                        return (U) java.sql.Time.valueOf((String) from);
                    }
                    catch (IllegalArgumentException e) {
                        return null;
                    }
                }


                else if ((fromClass == String.class) && toClass == java.sql.Timestamp.class) {
                    try {
                        return (U) java.sql.Timestamp.valueOf((String) from);
                    }
                    catch (IllegalArgumentException e) {
                        return null;
                    }
                }


                else if ((fromClass == String.class) && toClass == LocalDate.class) {


                    try {
                        return (U) java.sql.Date.valueOf((String) from).toLocalDate();
                    }
                    catch (IllegalArgumentException e1) {
                        try {
                            return (U) LocalDate.parse((String) from);
                        }
                        catch (DateTimeParseException e2) {
                            return null;
                        }
                    }
                }

                else if ((fromClass == String.class) && toClass == LocalTime.class) {


                    try {
                        return (U) java.sql.Time.valueOf((String) from).toLocalTime();
                    }
                    catch (IllegalArgumentException e1) {
                        try {
                            return (U) LocalTime.parse((String) from);
                        }
                        catch (DateTimeParseException e2) {
                            return null;
                        }
                    }
                }

                else if ((fromClass == String.class) && toClass == OffsetTime.class) {


                    try {
                        return (U) java.sql.Time.valueOf((String) from).toLocalTime().atOffset(OffsetTime.now().getOffset());
                    }
                    catch (IllegalArgumentException e1) {
                        try {
                            return (U) OffsetTime.parse((String) from);
                        }
                        catch (DateTimeParseException e2) {
                            return null;
                        }
                    }
                }

                else if ((fromClass == String.class) && toClass == LocalDateTime.class) {


                    try {
                        return (U) java.sql.Timestamp.valueOf((String) from).toLocalDateTime();
                    }
                    catch (IllegalArgumentException e1) {
                        try {
                            return (U) LocalDateTime.parse((String) from);
                        }
                        catch (DateTimeParseException e2) {
                            return null;
                        }
                    }
                }

                else if ((fromClass == String.class) && toClass == OffsetDateTime.class) {


                    try {
                        return (U) java.sql.Timestamp.valueOf((String) from).toLocalDateTime().atOffset(OffsetDateTime.now().getOffset());
                    }
                    catch (IllegalArgumentException e1) {
                        try {
                            return (U) OffsetDateTime.parse((String) from);
                        }
                        catch (DateTimeParseException e2) {
                            return null;
                        }
                    }
                }

                else if ((fromClass == String.class) && toClass == Instant.class) {


                    try {
                        return (U) java.sql.Timestamp.valueOf((String) from).toLocalDateTime().atOffset(OffsetDateTime.now().getOffset()).toInstant();
                    }
                    catch (IllegalArgumentException e1) {
                        try {
                            return (U) Instant.parse((String) from);
                        }
                        catch (DateTimeParseException e2) {
                            return null;
                        }
                    }
                }




                else if ((fromClass == String.class) && java.lang.Enum.class.isAssignableFrom(toClass)) {
                    try {
                        return (U) java.lang.Enum.valueOf((Class) toClass, (String) from);
                    }
                    catch (IllegalArgumentException e) {
                        return null;
                    }
                }


                else if ((fromClass == String.class) && toClass == UUID.class) {
                    try {
                        return (U) parseUUID((String) from);
                    }
                    catch (IllegalArgumentException e) {
                        return null;
                    }
                }



                else if (Record.class.isAssignableFrom(fromClass)) {
                    Record record = (Record) from;
                    return record.into(toClass);
                }




            }

            throw fail(from, toClass);
        }

        @Override
        public Object to(U to) {
            return to;
        }

        @Override
        public Class<Object> fromType() {
            return Object.class;
        }

        @SuppressWarnings("unchecked")
        @Override
        public Class<U> toType() {
            return (Class<U>) toClass;
        }


        @SuppressWarnings("unchecked")
        private static <X> X toDate(long time, Class<X> toClass) {
            if (toClass == Date.class) {
                return (X) new Date(time);
            }
            else if (toClass == Time.class) {
                return (X) new Time(time);
            }
            else if (toClass == Timestamp.class) {
                return (X) new Timestamp(time);
            }
            else if (toClass == java.util.Date.class) {
                return (X) new java.util.Date(time);
            }
            else if (toClass == Calendar.class) {
                Calendar calendar = Calendar.getInstance();
                calendar.setTimeInMillis(time);
                return (X) calendar;
            }


            else if (toClass == LocalDate.class) {
                return (X) new Date(time).toLocalDate();
            }
            else if (toClass == LocalTime.class) {
                return (X) new Time(time).toLocalTime();
            }
            else if (toClass == OffsetTime.class) {
                return (X) new Time(time).toLocalTime().atOffset(OffsetTime.now().getOffset());
            }
            else if (toClass == LocalDateTime.class) {
                return (X) new Timestamp(time).toLocalDateTime();
            }
            else if (toClass == OffsetDateTime.class) {
                return (X) new Timestamp(time).toLocalDateTime().atOffset(OffsetDateTime.now().getOffset());
            }
            else if (toClass == Instant.class) {
                return (X) new Timestamp(time).toLocalDateTime().atOffset(OffsetDateTime.now().getOffset()).toInstant();
            }


            throw fail(time, toClass);
        }


        private static final long millis(Temporal temporal) {


            if (temporal instanceof LocalDate) {
                return Date.valueOf((LocalDate) temporal).getTime();
            }
            else if (temporal instanceof LocalTime) {
                return Time.valueOf((LocalTime) temporal).getTime();
            }
            else if (temporal instanceof LocalDateTime) {
                return Timestamp.valueOf((LocalDateTime) temporal).getTime();
            }


            else if (temporal.isSupported(INSTANT_SECONDS)) {
                return 1000 * temporal.getLong(INSTANT_SECONDS) + temporal.getLong(MILLI_OF_SECOND);
            }


            else if (temporal.isSupported(MILLI_OF_DAY)) {
                return temporal.getLong(MILLI_OF_DAY);
            }

            throw fail(temporal, Long.class);
        }



        private static final UUID parseUUID(String string) {
            if (string == null) {
                return null;
            }
            else if (string.contains("-")) {
                return UUID.fromString(string);
            }
            else {
                return UUID.fromString(UUID_PATTERN.matcher(string).replaceAll("$1-$2-$3-$4-$5"));
            }
        }

        private static DataTypeException fail(Object from, Class<?> toClass) {
            return new DataTypeException("Cannot convert from " + from + " (" + from.getClass() + ") to " + toClass);
        }
    }
}

<code block>

package org.jooq.test;

import static java.time.temporal.ChronoField.INSTANT_SECONDS;
import static java.time.temporal.ChronoField.MILLI_OF_DAY;
import static java.time.temporal.ChronoField.MILLI_OF_SECOND;
import static org.jooq.tools.reflect.Reflect.wrapper;
import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import java.lang.reflect.Array;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.sql.Date;
import java.sql.SQLException;
import java.sql.Time;
import java.sql.Timestamp;
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.OffsetDateTime;
import java.time.OffsetTime;
import java.time.ZoneOffset;
import java.time.temporal.Temporal;

import org.jooq.Record;
import org.jooq.Result;
import org.jooq.tools.Convert;

import org.junit.Test;


public class ConvertAllTest extends AbstractTest {

    @Test
    public void testToObject() {
        testConversion(null, null, Object.class);
        testConversion("a", "a", Object.class);
        testConversion(true, true, Object.class);
        testConversion((byte) 1, (byte) 1, Object.class);
        testConversion((short) 1, (short) 1, Object.class);
        testConversion(1, 1, Object.class);
        testConversion(1L, 1L, Object.class);
        testConversion(1.0d, 1.0d, Object.class);
        testConversion(1.0f, 1.0f, Object.class);
        testConversion(BigInteger.ONE, BigInteger.ONE, Object.class);
        testConversion(BigDecimal.ONE, BigDecimal.ONE, Object.class);
        testConversion(new Date(0), new Date(0), Object.class);
        testConversion(new Time(0), new Time(0), Object.class);
        testConversion(new Timestamp(0), new Timestamp(0), Object.class);
    }

    @Test
    public void testToString() {
        testConversion(null, null, String.class);
        testConversion("a", "a", String.class);
        testConversion("true", true, String.class);
        testConversion("1", (byte) 1, String.class);
        testConversion("1", (short) 1, String.class);
        testConversion("1", 1, String.class);
        testConversion("1", 1L, String.class);
        testConversion("1.0", 1.0d, String.class);
        testConversion("1.0", 1.0f, String.class);
        testConversion("1", BigInteger.ONE, String.class);
        testConversion("1", BigDecimal.ONE, String.class);
        testConversion(zeroDate(), new Date(0), String.class);
        testConversion(zeroTime(), new Time(0), String.class);
        testConversion(zeroTimestamp(), new Timestamp(0), String.class);
    }

    @Test
    public void testToBoolean() {
        testConversion(false, null, boolean.class);
        testConversion(false, "xmf", boolean.class);
        testConversion(null, null, Boolean.class);
        testConversion(true, "true", Boolean.class);
        testConversion(true, "1", Boolean.class);
        testConversion(true, "yes", Boolean.class);
        testConversion(false, "false", Boolean.class);
        testConversion(true, "t", Boolean.class);
        testConversion(false, "f", Boolean.class);
        testConversion(false, "0", Boolean.class);
        testConversion(false, "no", Boolean.class);
        testConversion(null, "xmf", Boolean.class);
        testConversion(true, true, Boolean.class);
        testConversion(false, false, Boolean.class);
        testConversion(null, (byte) 2, Boolean.class);
        testConversion(true, (byte) 1, Boolean.class);
        testConversion(false, (byte) 0, Boolean.class);
        testConversion(null, (short) 2, Boolean.class);
        testConversion(true, (short) 1, Boolean.class);
        testConversion(false, (short) 0, Boolean.class);
        testConversion(null, 2, Boolean.class);
        testConversion(true, 1, Boolean.class);
        testConversion(false, 0, Boolean.class);
        testConversion(null, 2L, Boolean.class);
        testConversion(true, 1L, Boolean.class);
        testConversion(false, 0L, Boolean.class);
        testConversion(null, 2.0, Boolean.class);
        testConversion(true, 1.0, Boolean.class);
        testConversion(false, 0.0, Boolean.class);
        testConversion(null, BigInteger.TEN, Boolean.class);
        testConversion(true, BigInteger.ONE, Boolean.class);
        testConversion(false, BigInteger.ZERO, Boolean.class);
        testConversion(null, BigDecimal.TEN, Boolean.class);
        testConversion(true, BigDecimal.ONE, Boolean.class);
        testConversion(false, BigDecimal.ZERO, Boolean.class);
        testConversion(null, new Date(0), Boolean.class);
        testConversion(null, new Time(0), Boolean.class);
        testConversion(null, new Timestamp(0), Boolean.class);
    }

    @Test
    public void testToByte() {
        testConversion(null, null, Byte.class);
        testConversion((byte) 0, null, byte.class);
        testConversion((byte) 1, "1", Byte.class);
        testConversion((byte) 1, true, Byte.class);
        testConversion((byte) 0, false, Byte.class);
        testConversion((byte) 1, (byte) 1, Byte.class);
        testConversion((byte) 1, (short) 1, Byte.class);
        testConversion((byte) 1, 1, Byte.class);
        testConversion((byte) 1, 1L, Byte.class);
        testConversion((byte) 1, 1.0d, Byte.class);
        testConversion((byte) 1, 1.0f, Byte.class);
        testConversion((byte) 1, BigInteger.ONE, Byte.class);
        testConversion((byte) 1, BigDecimal.ONE, Byte.class);
        testConversion(null, new Date(0), Byte.class);
        testConversion(null, new Time(0), Byte.class);
        testConversion(null, new Timestamp(0), Byte.class);
    }

    @Test
    public void testToShort() {
        testConversion(null, null, Short.class);
        testConversion((short) 0, null, short.class);
        testConversion((short) 1, "1", Short.class);
        testConversion((short) 1, true, Short.class);
        testConversion((short) 0, false, Short.class);
        testConversion((short) 1, (byte) 1, Short.class);
        testConversion((short) 1, (short) 1, Short.class);
        testConversion((short) 1, 1, Short.class);
        testConversion((short) 1, 1L, Short.class);
        testConversion((short) 1, 1.0d, Short.class);
        testConversion((short) 1, 1.0f, Short.class);
        testConversion((short) 1, BigInteger.ONE, Short.class);
        testConversion((short) 1, BigDecimal.ONE, Short.class);
        testConversion(null, new Date(0), Short.class);
        testConversion(null, new Time(0), Short.class);
        testConversion(null, new Timestamp(0), Short.class);
    }

    @Test
    public void testToInteger() {
        testConversion(null, null, Integer.class);
        testConversion(0, null, int.class);
        testConversion(1, "1", Integer.class);
        testConversion(1, true, Integer.class);
        testConversion(0, false, Integer.class);
        testConversion(1, (byte) 1, Integer.class);
        testConversion(1, (short) 1, Integer.class);
        testConversion(1, 1, Integer.class);
        testConversion(1, 1L, Integer.class);
        testConversion(1, 1.0d, Integer.class);
        testConversion(1, 1.0f, Integer.class);
        testConversion(1, BigInteger.ONE, Integer.class);
        testConversion(1, BigDecimal.ONE, Integer.class);
        testConversion(null, new Date(0), Integer.class);
        testConversion(null, new Time(0), Integer.class);
        testConversion(null, new Timestamp(0), Integer.class);
    }

    @Test
    public void testToLong() {
        testConversion(null, null, Long.class);
        testConversion(0L, null, long.class);
        testConversion(1L, "1", Long.class);
        testConversion(1L, true, Long.class);
        testConversion(0L, false, Long.class);
        testConversion(1L, (byte) 1, Long.class);
        testConversion(1L, (short) 1, Long.class);
        testConversion(1L, 1, Long.class);
        testConversion(1L, 1L, Long.class);
        testConversion(1L, 1.0d, Long.class);
        testConversion(1L, 1.0f, Long.class);
        testConversion(1L, BigInteger.ONE, Long.class);
        testConversion(1L, BigDecimal.ONE, Long.class);


        Date date = Date.valueOf("2001-02-03");
        testConversion(date.getTime(), date, Long.class);
        testConversion(date.getTime(), date.toLocalDate(), Long.class);


        Time time = Time.valueOf("04:05:06");
        testConversion(time.getTime(), time, Long.class);
        testConversion(time.getTime(), time.toLocalTime(), Long.class);

        OffsetTime t1 = OffsetTime.parse("04:05:06.789Z");
        OffsetTime t2 = OffsetTime.parse("04:05:06.789+02:00");
        testConversion(millis(t1), t1, Long.class);
        testConversion(millis(t2), t2, Long.class);


        Timestamp timestamp = Timestamp.valueOf("2001-02-03 04:05:06.789");
        testConversion(timestamp.getTime(), timestamp, Long.class);
        testConversion(timestamp.getTime(), timestamp.toLocalDateTime(), Long.class);

        OffsetDateTime dt1 = OffsetDateTime.parse("2001-02-03T04:05:06.789Z");
        OffsetDateTime dt2 = OffsetDateTime.parse("2001-02-03T04:05:06.789+02:00");
        testConversion(millis(dt1), dt1, Long.class);
        testConversion(millis(dt2), dt2, Long.class);

        Instant now = Instant.now();
        testConversion(0L, Instant.ofEpochMilli(0), Long.class);
        testConversion(millis(now), now, Long.class);
    }

    @Test
    public void testToBigInteger() {
        testConversion(null, null, BigInteger.class);
        testConversion(BigInteger.ONE, "1", BigInteger.class);
        testConversion(BigInteger.ONE, true, BigInteger.class);
        testConversion(BigInteger.ZERO, false, BigInteger.class);
        testConversion(BigInteger.ONE, (byte) 1, BigInteger.class);
        testConversion(BigInteger.ONE, (short) 1, BigInteger.class);
        testConversion(BigInteger.ONE, 1, BigInteger.class);
        testConversion(BigInteger.ONE, 1L, BigInteger.class);
        testConversion(BigInteger.ONE, 1.0d, BigInteger.class);
        testConversion(BigInteger.ONE, 1.0f, BigInteger.class);
        testConversion(BigInteger.ONE, BigInteger.ONE, BigInteger.class);
        testConversion(BigInteger.ONE, BigDecimal.ONE, BigInteger.class);
        testConversion(null, new Date(0), BigInteger.class);
        testConversion(null, new Time(0), BigInteger.class);
        testConversion(null, new Timestamp(0), BigInteger.class);
    }

    @Test
    public void testToBigDecimal() {
        testConversion(null, null, BigDecimal.class);
        testConversion(BigDecimal.ONE, "1", BigDecimal.class);
        testConversion(BigDecimal.ONE, true, BigDecimal.class);
        testConversion(BigDecimal.ZERO, false, BigDecimal.class);
        testConversion(BigDecimal.ONE, (byte) 1, BigDecimal.class);
        testConversion(BigDecimal.ONE, (short) 1, BigDecimal.class);
        testConversion(BigDecimal.ONE, 1, BigDecimal.class);
        testConversion(BigDecimal.ONE, 1L, BigDecimal.class);
        testConversion(new BigDecimal("1.0"), 1.0d, BigDecimal.class);
        testConversion(new BigDecimal("1.0"), 1.0f, BigDecimal.class);
        testConversion(BigDecimal.ONE, BigInteger.ONE, BigDecimal.class);
        testConversion(BigDecimal.ONE, BigDecimal.ONE, BigDecimal.class);
        testConversion(null, new Date(0), BigDecimal.class);
        testConversion(null, new Time(0), BigDecimal.class);
        testConversion(null, new Timestamp(0), BigDecimal.class);
    }

    @SuppressWarnings("unchecked")
    private static <T, U> void testConversion(U expected, T from, Class<U> toClass) {
        if (from != null) {
            assertEquals(from, Convert.convert(from, Object.class));
            assertEquals(from, Convert.convert(from, from.getClass()));
        }

        U conv1 = Convert.convert(from, toClass);
        assertEquals(expected, conv1);

        if (toClass.isPrimitive()) {
            assertTrue(wrapper(toClass).isInstance(conv1));
            return;
        }
        else if (expected == null) {
            assertNull(conv1);
        }
        else {
            assertTrue(toClass.isInstance(conv1));
        }

        Class<?> toArrayClass = Array.newInstance(toClass, 0).getClass();

        Object[] conv2 = Convert.convert(new Object[] { from, from }, new Class[] { toClass, toClass });
        U[] conv3 = (U[]) Convert.convert(new Object[] { from, from }, toClass);
        U[] conv4 = (U[]) Convert.convertArray(new Object[] { from, from }, toClass);
        U[] conv5 = (U[]) Convert.convertArray(new Object[] { from, from }, toArrayClass);

        assertEquals(2, conv2.length);
        assertEquals(2, conv3.length);
        assertEquals(2, conv4.length);
        assertEquals(2, conv5.length);
        assertEquals(expected, conv2[0]);
        assertEquals(expected, conv2[1]);
        assertEquals(expected, conv3[0]);
        assertEquals(expected, conv3[1]);
        assertEquals(expected, conv4[0]);
        assertEquals(expected, conv4[1]);
        assertEquals(expected, conv5[0]);
        assertEquals(expected, conv5[1]);
        assertTrue(Object[].class.isInstance(conv2));
        assertTrue(toArrayClass.isInstance(conv3));
        assertTrue(toArrayClass.isInstance(conv4));
        assertTrue(toArrayClass.isInstance(conv5));
    }

    @Test
    public void testToJDBCArray() throws SQLException {
        Object[] from1 = null;
        java.sql.Array a1 = Convert.convert(from1, java.sql.Array.class);
        assertNull(a1);

        Object[] from2 = new Object[0];
        java.sql.Array a2 = Convert.convert(from2, java.sql.Array.class);
        Result<Record> r2 = create.fetch(a2.getResultSet());
        assertArrayEquals(from2, (Object[]) a2.getArray());
        assertEquals(0, r2.size());
        assertEquals(2, r2.fields().length);
        assertEquals("INDEX", r2.field(0).getName());
        assertEquals(Long.class, r2.field(0).getType());
        assertEquals("VALUE", r2.field(1).getName());
        assertEquals(Object.class, r2.field(1).getType());

        Object[] from3 = { 1 };
        java.sql.Array a3 = Convert.convert(from3, java.sql.Array.class);
        Result<Record> r3 = create.fetch(a3.getResultSet());
        assertArrayEquals(from3, (Object[]) a3.getArray());
        assertEquals(1, r3.size());
        assertEquals(1L, r3.getValue(0, "INDEX"));
        assertEquals(1, r3.getValue(0, "VALUE"));
        assertEquals(2, r3.fields().length);
        assertEquals("INDEX", r3.field(0).getName());
        assertEquals(Long.class, r3.field(0).getType());
        assertEquals("VALUE", r3.field(1).getName());
        assertEquals(Object.class, r3.field(1).getType());

        String[] from4 = { "A", "B" };
        java.sql.Array a4 = Convert.convert(from4, java.sql.Array.class);
        Result<Record> r4 = create.fetch(a4.getResultSet());
        assertArrayEquals(from4, (String[]) a4.getArray());
        assertEquals(2, r4.size());
        assertEquals(1L, r4.getValue(0, "INDEX"));
        assertEquals("A", r4.getValue(0, "VALUE"));
        assertEquals(2L, r4.getValue(1, "INDEX"));
        assertEquals("B", r4.getValue(1, "VALUE"));
        assertEquals(2, r4.fields().length);
        assertEquals("INDEX", r4.field(0).getName());
        assertEquals(Long.class, r4.field(0).getType());
        assertEquals("VALUE", r4.field(1).getName());
        assertEquals(String.class, r4.field(1).getType());
    }

    @Test
    public void testToDate() {
        Date date = Date.valueOf("2001-02-03");

        testConversion(date, "2001-02-03", Date.class);
        testConversion(date, date.getTime(), Date.class);
        testConversion(date, date.toLocalDate(), Date.class);
    }

    @Test
    public void testToLocalDate() {
        Date date = Date.valueOf("2001-02-03");

        testConversion(date.toLocalDate(), "2001-02-03", LocalDate.class);
        testConversion(date.toLocalDate(), date.getTime(), LocalDate.class);
        testConversion(date.toLocalDate(), date, LocalDate.class);
    }

    @Test
    public void testToTime() {
        Time time = Time.valueOf("04:05:06");

        testConversion(time, "04:05:06", Time.class);
        testConversion(time, time.getTime(), Time.class);
        testConversion(time, time.toLocalTime(), Time.class);

        OffsetTime o1 = OffsetTime.parse("04:05:06.789Z");
        OffsetTime o2 = OffsetTime.parse("04:05:06.789+02:00");
        testConversion(new Time(millis(o1)), o1, Time.class);
        testConversion(new Time(millis(o2)), o2, Time.class);
    }

    @Test
    public void testToLocalTime() {
        Time time = Time.valueOf("04:05:06");

        testConversion(time.toLocalTime(), "04:05:06", LocalTime.class);
        testConversion(time.toLocalTime(), time.getTime(), LocalTime.class);
        testConversion(time.toLocalTime(), time, LocalTime.class);

        OffsetTime o1 = OffsetTime.parse("04:05:06.789Z");
        OffsetTime o2 = OffsetTime.parse("04:05:06.789+02:00");
        testConversion(new Time(millis(o1)).toLocalTime(), o1, LocalTime.class);
        testConversion(new Time(millis(o2)).toLocalTime(), o2, LocalTime.class);
    }

    @Test
    public void testToOffsetTime() {
        Time time = Time.valueOf("04:05:06");
        ZoneOffset offset = OffsetDateTime.now().getOffset();

        testConversion(time.toLocalTime().atOffset(offset), "04:05:06", OffsetTime.class);
        testConversion(time.toLocalTime().atOffset(offset), time.getTime(), OffsetTime.class);
        testConversion(time.toLocalTime().atOffset(offset), time, OffsetTime.class);
    }

    @Test
    public void testToTimestamp() {
        Timestamp t1 = Timestamp.valueOf("2001-02-03 04:05:06");
        Timestamp t2 = Timestamp.valueOf("2001-02-03 04:05:06.7");
        Timestamp t3 = Timestamp.valueOf("2001-02-03 04:05:06.789");

        testConversion(t1, "2001-02-03 04:05:06", Timestamp.class);
        testConversion(t2, "2001-02-03 04:05:06.7", Timestamp.class);
        testConversion(t3, "2001-02-03 04:05:06.789", Timestamp.class);

        testConversion(t1, t1.getTime(), Timestamp.class);
        testConversion(t2, t2.getTime(), Timestamp.class);
        testConversion(t3, t3.getTime(), Timestamp.class);

        testConversion(t1, t1.toLocalDateTime(), Timestamp.class);
        testConversion(t2, t2.toLocalDateTime(), Timestamp.class);
        testConversion(t3, t3.toLocalDateTime(), Timestamp.class);

        OffsetDateTime o1 = OffsetDateTime.parse("2001-02-03T04:05:06.789Z");
        OffsetDateTime o2 = OffsetDateTime.parse("2001-02-03T04:05:06.789+02:00");
        testConversion(new Timestamp(millis(o1)), o1, Timestamp.class);
        testConversion(new Timestamp(millis(o2)), o2, Timestamp.class);
    }

    @Test
    public void testToLocalDateTime() {
        Timestamp t1 = Timestamp.valueOf("2001-02-03 04:05:06");
        Timestamp t2 = Timestamp.valueOf("2001-02-03 04:05:06.7");
        Timestamp t3 = Timestamp.valueOf("2001-02-03 04:05:06.789");

        testConversion(t1.toLocalDateTime(), "2001-02-03 04:05:06", LocalDateTime.class);
        testConversion(t2.toLocalDateTime(), "2001-02-03 04:05:06.7", LocalDateTime.class);
        testConversion(t3.toLocalDateTime(), "2001-02-03 04:05:06.789", LocalDateTime.class);

        testConversion(t1.toLocalDateTime(), t1.getTime(), LocalDateTime.class);
        testConversion(t2.toLocalDateTime(), t2.getTime(), LocalDateTime.class);
        testConversion(t3.toLocalDateTime(), t3.getTime(), LocalDateTime.class);

        testConversion(t1.toLocalDateTime(), t1, LocalDateTime.class);
        testConversion(t2.toLocalDateTime(), t2, LocalDateTime.class);
        testConversion(t3.toLocalDateTime(), t3, LocalDateTime.class);

        OffsetDateTime o1 = OffsetDateTime.parse("2001-02-03T04:05:06.789Z");
        OffsetDateTime o2 = OffsetDateTime.parse("2001-02-03T04:05:06.789+02:00");
        testConversion(new Timestamp(millis(o1)).toLocalDateTime(), o1, LocalDateTime.class);
        testConversion(new Timestamp(millis(o2)).toLocalDateTime(), o2, LocalDateTime.class);
    }

    @Test
    public void testToOffsetDateTime() {
        Timestamp t1 = Timestamp.valueOf("2001-02-03 04:05:06");
        Timestamp t2 = Timestamp.valueOf("2001-02-03 04:05:06.7");
        Timestamp t3 = Timestamp.valueOf("2001-02-03 04:05:06.789");
        ZoneOffset offset = OffsetDateTime.now().getOffset();

        testConversion(t1.toLocalDateTime().atOffset(offset), "2001-02-03 04:05:06", OffsetDateTime.class);
        testConversion(t2.toLocalDateTime().atOffset(offset), "2001-02-03 04:05:06.7", OffsetDateTime.class);
        testConversion(t3.toLocalDateTime().atOffset(offset), "2001-02-03 04:05:06.789", OffsetDateTime.class);

        testConversion(t1.toLocalDateTime().atOffset(offset), t1.getTime(), OffsetDateTime.class);
        testConversion(t2.toLocalDateTime().atOffset(offset), t2.getTime(), OffsetDateTime.class);
        testConversion(t3.toLocalDateTime().atOffset(offset), t3.getTime(), OffsetDateTime.class);

        testConversion(t1.toLocalDateTime().atOffset(offset), t1, OffsetDateTime.class);
        testConversion(t2.toLocalDateTime().atOffset(offset), t2, OffsetDateTime.class);
        testConversion(t3.toLocalDateTime().atOffset(offset), t3, OffsetDateTime.class);
    }

    @Test
    public void testToInstant() {
        Timestamp t1 = Timestamp.valueOf("2001-02-03 04:05:06");
        Timestamp t2 = Timestamp.valueOf("2001-02-03 04:05:06.7");
        Timestamp t3 = Timestamp.valueOf("2001-02-03 04:05:06.789");
        ZoneOffset offset = OffsetDateTime.now().getOffset();

        testConversion(t1.toLocalDateTime().atOffset(offset).toInstant(), "2001-02-03 04:05:06", Instant.class);
        testConversion(t2.toLocalDateTime().atOffset(offset).toInstant(), "2001-02-03 04:05:06.7", Instant.class);
        testConversion(t3.toLocalDateTime().atOffset(offset).toInstant(), "2001-02-03 04:05:06.789", Instant.class);

        testConversion(t1.toLocalDateTime().atOffset(offset).toInstant(), t1.getTime(), Instant.class);
        testConversion(t2.toLocalDateTime().atOffset(offset).toInstant(), t2.getTime(), Instant.class);
        testConversion(t3.toLocalDateTime().atOffset(offset).toInstant(), t3.getTime(), Instant.class);

        testConversion(t1.toLocalDateTime().atOffset(offset).toInstant(), t1, Instant.class);
        testConversion(t2.toLocalDateTime().atOffset(offset).toInstant(), t2, Instant.class);
        testConversion(t3.toLocalDateTime().atOffset(offset).toInstant(), t3, Instant.class);
    }

    private Long millis(Temporal t) {
        if (t.isSupported(INSTANT_SECONDS))
            return 1000 * t.getLong(INSTANT_SECONDS) + t.getLong(MILLI_OF_SECOND);
        else
            return t.getLong(MILLI_OF_DAY);
    }
}

<code block>


package org.jooq;

import java.io.OutputStream;
import java.io.Writer;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.annotation.Generated;

import org.jooq.exception.DataAccessException;
import org.jooq.exception.DataTypeException;
import org.jooq.exception.IOException;
import org.jooq.exception.InvalidResultException;
import org.jooq.exception.MappingException;
import org.jooq.impl.DefaultRecordMapper;
import org.jooq.tools.Convert;

import org.w3c.dom.Document;
import org.xml.sax.ContentHandler;
import org.xml.sax.SAXException;


public interface Result<R extends Record> extends List<R>, Attachable {


    RecordType<R> recordType();


    Row fieldsRow();


    <T> Field<T> field(Field<T> field);


    Field<?> field(String name);


    <T> Field<T> field(String name, Class<T> type);


    <T> Field<T> field(String name, DataType<T> dataType);


    Field<?> field(Name name);


    <T> Field<T> field(Name name, Class<T> type);


    <T> Field<T> field(Name name, DataType<T> dataType);


    Field<?> field(int index);


    <T> Field<T> field(int index, Class<T> type);


    <T> Field<T> field(int index, DataType<T> dataType);


    Field<?>[] fields();


    <T> T getValue(int index, Field<T> field) throws IndexOutOfBoundsException, IllegalArgumentException;


    @Deprecated
    <T> T getValue(int index, Field<T> field, T defaultValue) throws IndexOutOfBoundsException,
        IllegalArgumentException;


    Object getValue(int index, int fieldIndex) throws IndexOutOfBoundsException, IllegalArgumentException;


    @Deprecated
    Object getValue(int index, int fieldIndex, Object defaultValue) throws IndexOutOfBoundsException,
        IllegalArgumentException;


    Object getValue(int index, String fieldName) throws IndexOutOfBoundsException, IllegalArgumentException;


    @Deprecated
    Object getValue(int index, String fieldName, Object defaultValue) throws IndexOutOfBoundsException,
        IllegalArgumentException;


    <T> List<T> getValues(Field<T> field) throws IllegalArgumentException;


    <T> List<T> getValues(Field<?> field, Class<? extends T> type) throws IllegalArgumentException;


    <T, U> List<U> getValues(Field<T> field, Converter<? super T, U> converter) throws IllegalArgumentException;


    List<?> getValues(int fieldIndex) throws IllegalArgumentException;


    <T> List<T> getValues(int fieldIndex, Class<? extends T> type) throws IllegalArgumentException, DataTypeException;


    <U> List<U> getValues(int fieldIndex, Converter<?, U> converter) throws IllegalArgumentException, DataTypeException;


    List<?> getValues(String fieldName) throws IllegalArgumentException;


    <T> List<T> getValues(String fieldName, Class<? extends T> type) throws IllegalArgumentException, DataTypeException;


    <U> List<U> getValues(String fieldName, Converter<?, U> converter) throws IllegalArgumentException,
        DataTypeException;


    List<?> getValues(Name fieldName) throws IllegalArgumentException;


    <T> List<T> getValues(Name fieldName, Class<? extends T> type) throws IllegalArgumentException, DataTypeException;


    <U> List<U> getValues(Name fieldName, Converter<?, U> converter) throws IllegalArgumentException,
        DataTypeException;


    @Override
    boolean isEmpty();


    boolean isNotEmpty();


    String format();


    String format(int maxRecords);


    String formatHTML();


    String formatCSV();


    String formatCSV(char delimiter);


    String formatCSV(char delimiter, String nullString);


    String formatJSON();


    String formatXML();


    String formatInsert();


    String formatInsert(Table<?> table, Field<?>... fields);


    void format(OutputStream stream) throws IOException;


    void format(OutputStream stream, int maxRecords) throws IOException;


    void formatHTML(OutputStream stream) throws IOException;


    void formatCSV(OutputStream stream) throws IOException;


    void formatCSV(OutputStream stream, char delimiter) throws IOException;


    void formatCSV(OutputStream stream, char delimiter, String nullString) throws IOException;


    void formatJSON(OutputStream stream) throws IOException;


    void formatXML(OutputStream stream) throws IOException;


    void formatInsert(OutputStream stream) throws IOException;


    void formatInsert(OutputStream stream, Table<?> table, Field<?>... fields) throws IOException;


    void format(Writer writer) throws IOException;


    void format(Writer writer, int maxRecords) throws IOException;


    void formatHTML(Writer writer) throws IOException;


    void formatCSV(Writer writer) throws IOException;


    void formatCSV(Writer writer, char delimiter) throws IOException;


    void formatCSV(Writer writer, char delimiter, String nullString) throws IOException;


    void formatJSON(Writer writer) throws IOException;


    void formatXML(Writer writer) throws IOException;


    void formatInsert(Writer writer) throws IOException;


    void formatInsert(Writer writer, Table<?> table, Field<?>... fields) throws IOException;


    Document intoXML();


    <H extends ContentHandler> H intoXML(H handler) throws SAXException;


    List<Map<String, Object>> intoMaps();


    <K> Map<K, R> intoMap(Field<K> key) throws IllegalArgumentException, InvalidResultException;


    Map<?, R> intoMap(int keyFieldIndex) throws IllegalArgumentException, InvalidResultException;


    Map<?, R> intoMap(String keyFieldName) throws IllegalArgumentException, InvalidResultException;


    Map<?, R> intoMap(Name keyFieldName) throws IllegalArgumentException, InvalidResultException;


    <K, V> Map<K, V> intoMap(Field<K> key, Field<V> value) throws IllegalArgumentException, InvalidResultException;


    Map<?, ?> intoMap(int keyFieldIndex, int valueFieldIndex) throws IllegalArgumentException,
        InvalidResultException;


    Map<?, ?> intoMap(String keyFieldName, String valueFieldName) throws IllegalArgumentException,
        InvalidResultException;


    Map<?, ?> intoMap(Name keyFieldName, Name valueFieldName) throws IllegalArgumentException,
        InvalidResultException;


    <K, E> Map<K, E> intoMap(Field<K> key, Class<? extends E> type) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    <E> Map<?, E> intoMap(int keyFieldIndex, Class<? extends E> type) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    <E> Map<?, E> intoMap(String keyFieldName, Class<? extends E> type) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    <E> Map<?, E> intoMap(Name keyFieldName, Class<? extends E> type) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    <K, E> Map<K, E> intoMap(Field<K> key, RecordMapper<? super R, E> mapper) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    <E> Map<?, E> intoMap(int keyFieldIndex, RecordMapper<? super R, E> mapper) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    <E> Map<?, E> intoMap(String keyFieldName, RecordMapper<? super R, E> mapper) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    <E> Map<?, E> intoMap(Name keyFieldName, RecordMapper<? super R, E> mapper) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    Map<Record, R> intoMap(Field<?>[] keys) throws IllegalArgumentException, InvalidResultException;


    Map<Record, R> intoMap(int[] keyFieldIndexes) throws IllegalArgumentException, InvalidResultException;


    Map<Record, R> intoMap(String[] keyFieldNames) throws IllegalArgumentException, InvalidResultException;


    Map<Record, R> intoMap(Name[] keyFieldNames) throws IllegalArgumentException, InvalidResultException;


    <E> Map<List<?>, E> intoMap(Field<?>[] keys, Class<? extends E> type) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    <E> Map<List<?>, E> intoMap(int[] keyFieldIndexes, Class<? extends E> type) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    <E> Map<List<?>, E> intoMap(String[] keyFieldNames, Class<? extends E> type) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    <E> Map<List<?>, E> intoMap(Name[] keyFieldNames, Class<? extends E> type) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    <E> Map<List<?>, E> intoMap(Field<?>[] keys, RecordMapper<? super R, E> mapper) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    <E> Map<List<?>, E> intoMap(int[] keyFieldIndexes, RecordMapper<? super R, E> mapper) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    <E> Map<List<?>, E> intoMap(String[] keyFieldNames, RecordMapper<? super R, E> mapper) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    <E> Map<List<?>, E> intoMap(Name[] keyFieldNames, RecordMapper<? super R, E> mapper) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    <S extends Record> Map<S, R> intoMap(Table<S> table) throws IllegalArgumentException, InvalidResultException;


    <E, S extends Record> Map<S, E> intoMap(Table<S> table, Class<? extends E> type) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    <E, S extends Record> Map<S, E> intoMap(Table<S> table, RecordMapper<? super R, E> mapper) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    <K> Map<K, Result<R>> intoGroups(Field<K> key) throws IllegalArgumentException;


    Map<?, Result<R>> intoGroups(int keyFieldIndex) throws IllegalArgumentException;


    Map<?, Result<R>> intoGroups(String keyFieldName) throws IllegalArgumentException;


    Map<?, Result<R>> intoGroups(Name keyFieldName) throws IllegalArgumentException;


    <K, V> Map<K, List<V>> intoGroups(Field<K> key, Field<V> value) throws IllegalArgumentException;


    Map<?, List<?>> intoGroups(int keyFieldIndex, int valueFieldIndex) throws IllegalArgumentException;


    Map<?, List<?>> intoGroups(String keyFieldName, String valueFieldName) throws IllegalArgumentException;


    Map<?, List<?>> intoGroups(Name keyFieldName, Name valueFieldName) throws IllegalArgumentException;


    <K, E> Map<K, List<E>> intoGroups(Field<K> key, Class<? extends E> type) throws IllegalArgumentException,
        MappingException;


    <E> Map<?, List<E>> intoGroups(int keyFieldIndex, Class<? extends E> type) throws IllegalArgumentException,
        MappingException;


    <E> Map<?, List<E>> intoGroups(String keyFieldName, Class<? extends E> type) throws IllegalArgumentException,
        MappingException;


    <E> Map<?, List<E>> intoGroups(Name keyFieldName, Class<? extends E> type) throws IllegalArgumentException,
        MappingException;


    <K, E> Map<K, List<E>> intoGroups(Field<K> key, RecordMapper<? super R, E> mapper) throws IllegalArgumentException,
        MappingException;


    <E> Map<?, List<E>> intoGroups(int keyFieldIndex, RecordMapper<? super R, E> mapper) throws IllegalArgumentException,
        MappingException;


    <E> Map<?, List<E>> intoGroups(String keyFieldName, RecordMapper<? super R, E> mapper) throws IllegalArgumentException,
        MappingException;


    <E> Map<?, List<E>> intoGroups(Name keyFieldName, RecordMapper<? super R, E> mapper) throws IllegalArgumentException,
        MappingException;


    Map<Record, Result<R>> intoGroups(Field<?>[] keys) throws IllegalArgumentException;


    Map<Record, Result<R>> intoGroups(int[] keyFieldIndexes) throws IllegalArgumentException;


    Map<Record, Result<R>> intoGroups(String[] keyFieldNames) throws IllegalArgumentException;


    Map<Record, Result<R>> intoGroups(Name[] keyFieldNames) throws IllegalArgumentException;


    <E> Map<Record, List<E>> intoGroups(Field<?>[] keys, Class<? extends E> type) throws IllegalArgumentException,
        MappingException;


    <E> Map<Record, List<E>> intoGroups(int[] keyFieldIndexes, Class<? extends E> type) throws IllegalArgumentException,
        MappingException;


    <E> Map<Record, List<E>> intoGroups(String[] keyFieldNames, Class<? extends E> type) throws IllegalArgumentException,
        MappingException;


    <E> Map<Record, List<E>> intoGroups(Name[] keyFieldNames, Class<? extends E> type) throws IllegalArgumentException,
        MappingException;


    <E> Map<Record, List<E>> intoGroups(Field<?>[] keys, RecordMapper<? super R, E> mapper)
        throws IllegalArgumentException, MappingException;


    <E> Map<Record, List<E>> intoGroups(int[] keyFieldIndexes, RecordMapper<? super R, E> mapper)
        throws IllegalArgumentException, MappingException;


    <E> Map<Record, List<E>> intoGroups(String[] keyFieldNames, RecordMapper<? super R, E> mapper)
        throws IllegalArgumentException, MappingException;


    <E> Map<Record, List<E>> intoGroups(Name[] keyFieldNames, RecordMapper<? super R, E> mapper)
        throws IllegalArgumentException, MappingException;


    <S extends Record> Map<S, Result<R>> intoGroups(Table<S> table) throws IllegalArgumentException;


    <E, S extends Record> Map<S, List<E>> intoGroups(Table<S> table, Class<? extends E> type)
        throws IllegalArgumentException, MappingException;


    <E, S extends Record> Map<S, List<E>> intoGroups(Table<S> table, RecordMapper<? super R, E> mapper)
        throws IllegalArgumentException, MappingException;


    @Deprecated
    Object[][] intoArray();


    Object[][] intoArrays();


    Object[] intoArray(int fieldIndex) throws IllegalArgumentException;


    <T> T[] intoArray(int fieldIndex, Class<? extends T> type) throws IllegalArgumentException, DataTypeException;


    <U> U[] intoArray(int fieldIndex, Converter<?, U> converter) throws IllegalArgumentException, DataTypeException;


    Object[] intoArray(String fieldName) throws IllegalArgumentException;


    <T> T[] intoArray(String fieldName, Class<? extends T> type) throws IllegalArgumentException, DataTypeException;


    <U> U[] intoArray(String fieldName, Converter<?, U> converter) throws IllegalArgumentException, DataTypeException;


    Object[] intoArray(Name fieldName) throws IllegalArgumentException;


    <T> T[] intoArray(Name fieldName, Class<? extends T> type) throws IllegalArgumentException, DataTypeException;


    <U> U[] intoArray(Name fieldName, Converter<?, U> converter) throws IllegalArgumentException, DataTypeException;


    <T> T[] intoArray(Field<T> field) throws IllegalArgumentException;


    <T> T[] intoArray(Field<?> field, Class<? extends T> type) throws IllegalArgumentException, DataTypeException;


    <T, U> U[] intoArray(Field<T> field, Converter<? super T, U> converter) throws IllegalArgumentException,
        DataTypeException;


    Set<?> intoSet(int fieldIndex) throws IllegalArgumentException;


    <T> Set<T> intoSet(int fieldIndex, Class<? extends T> type) throws IllegalArgumentException, DataTypeException;


    <U> Set<U> intoSet(int fieldIndex, Converter<?, U> converter) throws IllegalArgumentException, DataTypeException;


    Set<?> intoSet(String fieldName) throws IllegalArgumentException;


    <T> Set<T> intoSet(String fieldName, Class<? extends T> type) throws IllegalArgumentException, DataTypeException;


    <U> Set<U> intoSet(String fieldName, Converter<?, U> converter) throws IllegalArgumentException, DataTypeException;


    Set<?> intoSet(Name fieldName) throws IllegalArgumentException;


    <T> Set<T> intoSet(Name fieldName, Class<? extends T> type) throws IllegalArgumentException, DataTypeException;


    <U> Set<U> intoSet(Name fieldName, Converter<?, U> converter) throws IllegalArgumentException, DataTypeException;


    <T> Set<T> intoSet(Field<T> field) throws IllegalArgumentException;


    <T> Set<T> intoSet(Field<?> field, Class<? extends T> type) throws IllegalArgumentException, DataTypeException;


    <T, U> Set<U> intoSet(Field<T> field, Converter<? super T, U> converter) throws IllegalArgumentException,
        DataTypeException;


    Result<Record> into(Field<?>... fields);




    @Generated("This class was generated using jOOQ-tools")
    <T1> Result<Record1<T1>> into(Field<T1> field1);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2> Result<Record2<T1, T2>> into(Field<T1> field1, Field<T2> field2);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3> Result<Record3<T1, T2, T3>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4> Result<Record4<T1, T2, T3, T4>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5> Result<Record5<T1, T2, T3, T4, T5>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5, T6> Result<Record6<T1, T2, T3, T4, T5, T6>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5, T6, T7> Result<Record7<T1, T2, T3, T4, T5, T6, T7>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5, T6, T7, T8> Result<Record8<T1, T2, T3, T4, T5, T6, T7, T8>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5, T6, T7, T8, T9> Result<Record9<T1, T2, T3, T4, T5, T6, T7, T8, T9>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> Result<Record10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> Result<Record11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> Result<Record12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> Result<Record13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> Result<Record14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> Result<Record15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> Result<Record16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> Result<Record17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> Result<Record18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> Result<Record19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> Result<Record20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> Result<Record21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20, Field<T21> field21);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> Result<Record22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20, Field<T21> field21, Field<T22> field22);




    <E> List<E> into(Class<? extends E> type) throws MappingException;


    <Z extends Record> Result<Z> into(Table<Z> table) throws MappingException;


    <H extends RecordHandler<? super R>> H into(H handler);


    ResultSet intoResultSet();


    <E> List<E> map(RecordMapper<? super R, E> mapper);


    <T extends Comparable<? super T>> Result<R> sortAsc(Field<T> field) throws IllegalArgumentException;


    <T extends Comparable<? super T>> Result<R> sortDesc(Field<T> field) throws IllegalArgumentException;


    Result<R> sortAsc(int fieldIndex) throws IllegalArgumentException;


    Result<R> sortDesc(int fieldIndex) throws IllegalArgumentException;


    Result<R> sortAsc(String fieldName) throws IllegalArgumentException;


    Result<R> sortDesc(String fieldName) throws IllegalArgumentException;


    Result<R> sortAsc(Name fieldName) throws IllegalArgumentException;


    Result<R> sortDesc(Name fieldName) throws IllegalArgumentException;


    <T> Result<R> sortAsc(Field<T> field, java.util.Comparator<? super T> comparator) throws IllegalArgumentException;


    <T> Result<R> sortDesc(Field<T> field, java.util.Comparator<? super T> comparator) throws IllegalArgumentException;


    Result<R> sortAsc(int fieldIndex, java.util.Comparator<?> comparator) throws IllegalArgumentException;


    Result<R> sortDesc(int fieldIndex, java.util.Comparator<?> comparator) throws IllegalArgumentException;


    Result<R> sortAsc(String fieldName, java.util.Comparator<?> comparator) throws IllegalArgumentException;


    Result<R> sortDesc(String fieldName, java.util.Comparator<?> comparator) throws IllegalArgumentException;


    Result<R> sortAsc(Name fieldName, java.util.Comparator<?> comparator) throws IllegalArgumentException;


    Result<R> sortDesc(Name fieldName, java.util.Comparator<?> comparator) throws IllegalArgumentException;


    Result<R> sortAsc(java.util.Comparator<? super R> comparator);


    Result<R> sortDesc(java.util.Comparator<? super R> comparator);


    Result<R> intern(Field<?>... fields);


    Result<R> intern(int... fieldIndexes);


    Result<R> intern(String... fieldNames);


    Result<R> intern(Name... fieldNames);






    <O extends UpdatableRecord<O>> Result<O> fetchParents(ForeignKey<R, O> key) throws DataAccessException;


    <O extends TableRecord<O>> Result<O> fetchChildren(ForeignKey<O, R> key) throws DataAccessException;






    @Override
    void attach(Configuration configuration);


    @Override
    void detach();

}

<code block>


package org.jooq.impl;

import static java.lang.Math.max;
import static java.lang.Math.min;
import static org.jooq.impl.DSL.insertInto;
import static org.jooq.impl.DSL.name;
import static org.jooq.impl.DSL.table;
import static org.jooq.impl.Utils.indexOrFail;
import static org.jooq.tools.StringUtils.abbreviate;
import static org.jooq.tools.StringUtils.leftPad;
import static org.jooq.tools.StringUtils.rightPad;

import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.lang.reflect.Array;
import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;

import javax.xml.bind.DatatypeConverter;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.jooq.AttachableInternal;
import org.jooq.Configuration;
import org.jooq.Converter;
import org.jooq.DSLContext;
import org.jooq.DataType;
import org.jooq.EnumType;
import org.jooq.Field;
import org.jooq.ForeignKey;
import org.jooq.Name;
import org.jooq.Record;
import org.jooq.Record1;
import org.jooq.Record10;
import org.jooq.Record11;
import org.jooq.Record12;
import org.jooq.Record13;
import org.jooq.Record14;
import org.jooq.Record15;
import org.jooq.Record16;
import org.jooq.Record17;
import org.jooq.Record18;
import org.jooq.Record19;
import org.jooq.Record2;
import org.jooq.Record20;
import org.jooq.Record21;
import org.jooq.Record22;
import org.jooq.Record3;
import org.jooq.Record4;
import org.jooq.Record5;
import org.jooq.Record6;
import org.jooq.Record7;
import org.jooq.Record8;
import org.jooq.Record9;
import org.jooq.RecordHandler;
import org.jooq.RecordMapper;
import org.jooq.RecordType;
import org.jooq.Result;
import org.jooq.Row;
import org.jooq.Table;
import org.jooq.TableRecord;
import org.jooq.UpdatableRecord;
import org.jooq.exception.IOException;
import org.jooq.exception.InvalidResultException;
import org.jooq.tools.Convert;
import org.jooq.tools.StringUtils;
import org.jooq.tools.jdbc.MockResultSet;
import org.jooq.tools.json.JSONObject;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.xml.sax.Attributes;
import org.xml.sax.ContentHandler;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.AttributesImpl;


@SuppressWarnings({"rawtypes", "unchecked" })
class ResultImpl<R extends Record> implements Result<R>, AttachableInternal {


    private static final long serialVersionUID = 6416154375799578362L;

    private Configuration     configuration;
    private final Fields<R>   fields;
    private final List<R>     records;

    ResultImpl(Configuration configuration, Collection<? extends Field<?>> fields) {
        this(configuration, new Fields<R>(fields));
    }

    ResultImpl(Configuration configuration, Field<?>... fields) {
        this(configuration, new Fields<R>(fields));
    }

    ResultImpl(Configuration configuration, Fields<R> fields) {
        this.configuration = configuration;
        this.fields = fields;
        this.records = new ArrayList<R>();
    }





    @Override
    public final void attach(Configuration c) {
        this.configuration = c;

        for (R record : records) {
            if (record != null) {
                record.attach(c);
            }
        }
    }

    @Override
    public final void detach() {
        attach(null);
    }

    @Override
    public final Configuration configuration() {
        return configuration;
    }





    @Override
    public final RecordType<R> recordType() {
        return fields;
    }

    @Override
    public final Row fieldsRow() {
        return new RowImpl(fields);
    }

    @Override
    public final <T> Field<T> field(Field<T> field) {
        return fields.field(field);
    }

    @Override
    public final Field<?> field(String name) {
        return fields.field(name);
    }

    @Override
    public final <T> Field<T> field(String name, Class<T> type) {
        return fields.field(name, type);
    }

    @Override
    public final <T> Field<T> field(String name, DataType<T> dataType) {
        return fields.field(name, dataType);
    }

    @Override
    public final Field<?> field(Name name) {
        return fields.field(name);
    }

    @Override
    public final <T> Field<T> field(Name name, Class<T> type) {
        return fields.field(name, type);
    }

    @Override
    public final <T> Field<T> field(Name name, DataType<T> dataType) {
        return fields.field(name, dataType);
    }

    @Override
    public final Field<?> field(int index) {
        return fields.field(index);
    }

    @Override
    public final <T> Field<T> field(int index, Class<T> type) {
        return fields.field(index, type);
    }

    @Override
    public final <T> Field<T> field(int index, DataType<T> dataType) {
        return fields.field(index, dataType);
    }

    @Override
    public final Field<?>[] fields() {
        return fields.fields().clone();
    }


    final Field<?>[] fields(Field<?>... f) {
        Field<?>[] result = new Field[f.length];

        for (int i = 0; i < f.length; i++)
            result[i] = field(f[i]);

        return result;
    }


    final Field<?>[] fields(int... indexes) {
        Field<?>[] result = new Field[indexes.length];

        for (int i = 0; i < indexes.length; i++)
            result[i] = field(indexes[i]);

        return result;
    }


    final Field<?>[] fields(String... names) {
        Field<?>[] result = new Field[names.length];

        for (int i = 0; i < names.length; i++)
            result[i] = field(names[i]);

        return result;
    }


    final Field<?>[] fields(Name... names) {
        Field<?>[] result = new Field[names.length];

        for (int i = 0; i < names.length; i++)
            result[i] = field(names[i]);

        return result;
    }

    @Override
    public final boolean isEmpty() {
        return records.isEmpty();
    }

    @Override
    public final boolean isNotEmpty() {
        return !records.isEmpty();
    }

    @Override
    public final <T> T getValue(int index, Field<T> field) {
        return get(index).getValue(field);
    }

    @Override
    @Deprecated
    public final <T> T getValue(int index, Field<T> field, T defaultValue) {
        return get(index).getValue(field, defaultValue);
    }

    @Override
    public final Object getValue(int index, int fieldIndex) {
        return get(index).getValue(fieldIndex);
    }

    @Override
    @Deprecated
    public final Object getValue(int index, int fieldIndex, Object defaultValue) {
        return get(index).getValue(fieldIndex, defaultValue);
    }

    @Override
    public final Object getValue(int index, String fieldName) {
        return get(index).getValue(fieldName);
    }

    @Override
    @Deprecated
    public final Object getValue(int index, String fieldName, Object defaultValue) {
        return get(index).getValue(fieldName, defaultValue);
    }

    @Override
    public final <T> List<T> getValues(Field<T> field) {
        return (List<T>) getValues(indexOrFail(fieldsRow(), field));
    }

    @Override
    public final <T> List<T> getValues(Field<?> field, Class<? extends T> type) {
        return Convert.convert(getValues(field), type);
    }

    @Override
    public final <T, U> List<U> getValues(Field<T> field, Converter<? super T, U> converter) {
        return Convert.convert(getValues(field), converter);
    }

    @Override
    public final List<?> getValues(int fieldIndex) {
        List<Object> result = new ArrayList<Object>(size());

        for (R record : this) {
            result.add(record.getValue(fieldIndex));
        }

        return result;
    }

    @Override
    public final <T> List<T> getValues(int fieldIndex, Class<? extends T> type) {
        return Convert.convert(getValues(fieldIndex), type);
    }

    @Override
    public final <U> List<U> getValues(int fieldIndex, Converter<?, U> converter) {
        return Convert.convert(getValues(fieldIndex), converter);
    }

    @Override
    public final List<?> getValues(String fieldName) {
        return getValues(field(fieldName));
    }

    @Override
    public final <T> List<T> getValues(String fieldName, Class<? extends T> type) {
        return Convert.convert(getValues(fieldName), type);
    }

    @Override
    public final <U> List<U> getValues(String fieldName, Converter<?, U> converter) {
        return Convert.convert(getValues(fieldName), converter);
    }

    @Override
    public final List<?> getValues(Name fieldName) {
        return getValues(field(fieldName));
    }

    @Override
    public final <T> List<T> getValues(Name fieldName, Class<? extends T> type) {
        return Convert.convert(getValues(fieldName), type);
    }

    @Override
    public final <U> List<U> getValues(Name fieldName, Converter<?, U> converter) {
        return Convert.convert(getValues(fieldName), converter);
    }

    final void addRecord(R record) {
        records.add(record);
    }

    @Override
    public final String format() {
        StringWriter writer = new StringWriter();
        format(writer);
        return writer.toString();
    }

    @Override
    public final void format(OutputStream stream) {
        format(new OutputStreamWriter(stream));
    }

    @Override
    public final void format(Writer writer) {
        format(writer, 50);
    }

    @Override
    public final String format(int maxRecords) {
        StringWriter writer = new StringWriter();
        format(writer, maxRecords);
        return writer.toString();
    }

    @Override
    public final void format(OutputStream stream, int maxRecords) {
        format(new OutputStreamWriter(stream), maxRecords);
    }

    @Override
    public final void format(Writer writer, int maxRecords) {
        try {
            final int COL_MIN_WIDTH = 4;
            final int COL_MAX_WIDTH = 50;


            final int NUM_COL_MAX_WIDTH = 100;


            final int MAX_RECORDS = min(50, maxRecords);


            final int[] decimalPlaces = new int[fields.fields.length];
            final int[] widths = new int[fields.fields.length];

            for (int index = 0; index < fields.fields.length; index++) {
                if (Number.class.isAssignableFrom(fields.fields[index].getType())) {
                    List<Integer> decimalPlacesList = new ArrayList<Integer>();


                    decimalPlacesList.add(0);


                    String value;
                    for (int i = 0; i < min(MAX_RECORDS, size()); i++) {
                        value = format0(getValue(i, index), get(i).changed(index), true);
                        decimalPlacesList.add(getDecimalPlaces(value));
                    }


                    decimalPlaces[index] = Collections.max(decimalPlacesList);
                }
            }


            int colMaxWidth;
            for (int index = 0; index < fields.fields.length; index++) {


                boolean isNumCol = Number.class.isAssignableFrom(fields.fields[index].getType());

                colMaxWidth = isNumCol ? NUM_COL_MAX_WIDTH : COL_MAX_WIDTH;


                List<Integer> widthList = new ArrayList<Integer>();


                widthList.add(min(colMaxWidth, max(COL_MIN_WIDTH, fields.fields[index].getName().length())));


                String value;
                for (int i = 0; i < min(MAX_RECORDS, size()); i++) {
                    value = format0(getValue(i, index), get(i).changed(index), true);

                    if (isNumCol) {
                        value = alignNumberValue(decimalPlaces[index], value);
                    }

                    widthList.add(min(colMaxWidth, value.length()));
                }


                widths[index] = Collections.max(widthList);
            }





            writer.append("+");
            for (int index = 0; index < fields.fields.length; index++) {
                writer.append(rightPad("", widths[index], "-"));
                writer.append("+");
            }


            writer.append("\n|");
            for (int index = 0; index < fields.fields.length; index++) {
                String padded;

                if (Number.class.isAssignableFrom(fields.fields[index].getType())) {
                    padded = leftPad(fields.fields[index].getName(), widths[index]);
                }
                else {
                    padded = rightPad(fields.fields[index].getName(), widths[index]);
                }

                writer.append(abbreviate(padded, widths[index]));
                writer.append("|");
            }


            writer.append("\n+");
            for (int index = 0; index < fields.fields.length; index++) {
                writer.append(rightPad("", widths[index], "-"));
                writer.append("+");
            }


            for (int i = 0; i < min(maxRecords, size()); i++) {
                writer.append("\n|");

                for (int index = 0; index < fields.fields.length; index++) {
                    String value = format0(getValue(i, index), get(i).changed(index), true).replace("\n", "{lf}").replace("\r", "{cr}");

                    String padded;
                    if (Number.class.isAssignableFrom(fields.fields[index].getType())) {

                        value = alignNumberValue(decimalPlaces[index], value);


                        padded = leftPad(value, widths[index]);
                    }
                    else {

                        padded = rightPad(value, widths[index]);
                    }

                    writer.append(abbreviate(padded, widths[index]));
                    writer.append("|");
                }
            }


            if (size() > 0) {
                writer.append("\n+");

                for (int index = 0; index < fields.fields.length; index++) {
                    writer.append(rightPad("", widths[index], "-"));
                    writer.append("+");
                }
            }


            if (maxRecords < size()) {
                writer.append("\n|...");
                writer.append("" + (size() - maxRecords));
                writer.append(" record(s) truncated...");
            }
        }
        catch (java.io.IOException e) {
            throw new IOException("Exception while writing TEXT", e);
        }
    }

    private static final String alignNumberValue(Integer columnDecimalPlaces, String value) {
        if (!"{null}".equals(value) && columnDecimalPlaces != 0) {
            int decimalPlaces = getDecimalPlaces(value);
            int rightPadSize = value.length() + columnDecimalPlaces - decimalPlaces;

            if (decimalPlaces == 0) {

                value = rightPad(value, rightPadSize + 1);
            }
            else {
                value = rightPad(value, rightPadSize);
            }
        }

        return value;
    }

    private static final int getDecimalPlaces(String value) {
        int decimalPlaces = 0;

        int dotIndex = value.indexOf(".");
        if (dotIndex != -1) {
            decimalPlaces = value.length() - dotIndex - 1;
        }

        return decimalPlaces;
    }

    @Override
    public final String formatHTML() {
        StringWriter writer = new StringWriter();
        formatHTML(writer);
        return writer.toString();
    }

    @Override
    public final void formatHTML(OutputStream stream) {
        formatHTML(new OutputStreamWriter(stream));
    }

    @Override
    public final void formatHTML(Writer writer) {
        try {
            writer.append("<table>");
            writer.append("<thead>");
            writer.append("<tr>");

            for (Field<?> field : fields.fields) {
                writer.append("<th>");
                writer.append(field.getName());
                writer.append("</th>");
            }

            writer.append("</tr>");
            writer.append("</thead>");
            writer.append("<tbody>");

            for (Record record : this) {
                writer.append("<tr>");

                for (int index = 0; index < fields.fields.length; index++) {
                    writer.append("<td>");
                    writer.append(format0(record.getValue(index), false, true));
                    writer.append("</td>");
                }

                writer.append("</tr>");
            }

            writer.append("</tbody>");
            writer.append("</table>");
        }
        catch (java.io.IOException e) {
            throw new IOException("Exception while writing HTML", e);
        }
    }

    @Override
    public final String formatCSV() {
        StringWriter writer = new StringWriter();
        formatCSV(writer);
        return writer.toString();
    }

    @Override
    public final void formatCSV(OutputStream stream) {
        formatCSV(new OutputStreamWriter(stream));
    }

    @Override
    public final void formatCSV(Writer writer) {
        formatCSV(writer, ',', "");
    }

    @Override
    public final String formatCSV(char delimiter) {
        StringWriter writer = new StringWriter();
        formatCSV(writer, delimiter);
        return writer.toString();
    }

    @Override
    public final void formatCSV(OutputStream stream, char delimiter) {
        formatCSV(new OutputStreamWriter(stream), delimiter);
    }

    @Override
    public final void formatCSV(Writer writer, char delimiter) {
        formatCSV(writer, delimiter, "");
    }

    @Override
    public final String formatCSV(char delimiter, String nullString) {
        StringWriter writer = new StringWriter();
        formatCSV(writer, delimiter, nullString);
        return writer.toString();
    }

    @Override
    public final void formatCSV(OutputStream stream, char delimiter, String nullString) {
        formatCSV(new OutputStreamWriter(stream), delimiter, nullString);
    }

    @Override
    public final void formatCSV(Writer writer, char delimiter, String nullString) {
        try {
            String sep1 = "";
            for (Field<?> field : fields.fields) {
                writer.append(sep1);
                writer.append(formatCSV0(field.getName(), ""));

                sep1 = Character.toString(delimiter);
            }

            writer.append("\n");

            for (Record record : this) {
                String sep2 = "";

                for (int index = 0; index < fields.fields.length; index++) {
                    writer.append(sep2);
                    writer.append(formatCSV0(record.getValue(index), nullString));

                    sep2 = Character.toString(delimiter);
                }

                writer.append("\n");
            }
        }
        catch (java.io.IOException e) {
            throw new IOException("Exception while writing CSV", e);
        }
    }

    private final String formatCSV0(Object value, String nullString) {


        if (value == null || "".equals(value)) {
            if (StringUtils.isEmpty(nullString)) {
                return "\"\"";
            }
            else {
                return nullString;
            }
        }

        String result = format0(value, false, false);

        if (StringUtils.containsAny(result, ',', ';', '\t', '"', '\n', '\r', '\'', '\\')) {
            return "\"" + result.replace("\\", "\\\\").replace("\"", "\"\"") + "\"";
        }
        else {
            return result;
        }
    }

    private final Object formatJSON0(Object value) {
        if (value instanceof byte[])
            return DatatypeConverter.printBase64Binary((byte[]) value);

        return value;
    }


    private static final String format0(Object value, boolean changed, boolean visual) {
        String formatted = changed && visual ? "*" : "";

        if (value == null) {
            formatted += visual ? "{null}" : null;
        }
        else if (value.getClass() == byte[].class) {
            formatted += DatatypeConverter.printBase64Binary((byte[]) value);
        }
        else if (value.getClass().isArray()) {
            formatted += Arrays.toString((Object[]) value);
        }
        else if (value instanceof EnumType) {
            formatted += ((EnumType) value).getLiteral();
        }
        else if (value instanceof Record) {
            formatted += ((Record) value).valuesRow().toString();
        }
        else {
            formatted += value.toString();
        }

        return formatted;
    }

    @Override
    public final String formatJSON() {
        StringWriter writer = new StringWriter();
        formatJSON(writer);
        return writer.toString();
    }

    @Override
    public final void formatJSON(OutputStream stream) {
        formatJSON(new OutputStreamWriter(stream));
    }

    @Override
    public final void formatJSON(Writer writer) {
        try {
            List<Map<String, String>> f = new ArrayList<Map<String, String>>();
            List<List<Object>> r = new ArrayList<List<Object>>();

            Map<String, String> fieldMap;
            for (Field<?> field : fields.fields) {
                fieldMap = new LinkedHashMap<String, String>();
                fieldMap.put("name", field.getName());
                fieldMap.put("type", field.getDataType().getTypeName().toUpperCase());

                f.add(fieldMap);
            }

            for (Record record : this) {
                List<Object> list = new ArrayList<Object>();

                for (int index = 0; index < fields.fields.length; index++) {
                    list.add(formatJSON0(record.getValue(index)));
                }

                r.add(list);
            }

            Map<String, List<?>> map = new LinkedHashMap<String, List<?>>();

            map.put("fields", f);
            map.put("records", r);

            writer.append(JSONObject.toJSONString(map));
        }
        catch (java.io.IOException e) {
            throw new IOException("Exception while writing JSON", e);
        }
    }

    @Override
    public final String formatXML() {
        StringWriter writer = new StringWriter();
        formatXML(writer);
        return writer.toString();
    }

    @Override
    public final void formatXML(OutputStream stream) {
        formatXML(new OutputStreamWriter(stream));
    }

    @Override
    public final void formatXML(Writer writer) {
        try {
            writer.append("<result xmlns=\"http://www.jooq.org/xsd/jooq-export-2.6.0.xsd\">");
            writer.append("<fields>");

            for (Field<?> field : fields.fields) {
                writer.append("<field name=\"");
                writer.append(escapeXML(field.getName()));
                writer.append("\" ");
                writer.append("type=\"");
                writer.append(field.getDataType().getTypeName().toUpperCase());
                writer.append("\"/>");
            }

            writer.append("</fields>");
            writer.append("<records>");

            for (Record record : this) {
                writer.append("<record>");

                for (int index = 0; index < fields.fields.length; index++) {
                    Object value = record.getValue(index);

                    writer.append("<value field=\"");
                    writer.append(escapeXML(fields.fields[index].getName()));
                    writer.append("\"");

                    if (value == null) {
                        writer.append("/>");
                    }
                    else {
                        writer.append(">");
                        writer.append(escapeXML(format0(value, false, false)));
                        writer.append("</value>");
                    }
                }

                writer.append("</record>");
            }

            writer.append("</records>");
            writer.append("</result>");
        }
        catch (java.io.IOException e) {
            throw new IOException("Exception while writing XML", e);
        }
    }

    @Override
    public final String formatInsert() {
        StringWriter writer = new StringWriter();
        formatInsert(writer);
        return writer.toString();
    }

    @Override
    public final void formatInsert(OutputStream stream) {
        formatInsert(new OutputStreamWriter(stream));
    }

    @Override
    public final void formatInsert(Writer writer) {
        Table<?> table = null;

        if (records.size() > 0 && records.get(0) instanceof TableRecord)
            table = ((TableRecord<?>) records.get(0)).getTable();

        if (table == null)
            table = table(name("UNKNOWN_TABLE"));

        formatInsert(writer, table, fields());
    }

    @Override
    public final String formatInsert(Table<?> table, Field<?>... f) {
        StringWriter writer = new StringWriter();
        formatInsert(writer, table, f);
        return writer.toString();
    }

    @Override
    public final void formatInsert(OutputStream stream, Table<?> table, Field<?>... f) {
        formatInsert(new OutputStreamWriter(stream), table, f);
    }

    @Override
    public final void formatInsert(Writer writer, Table<?> table, Field<?>... f) {
        DSLContext ctx = DSL.using(configuration());

        try {
            for (R record : this) {
                writer.append(ctx.renderInlined(insertInto(table, f).values(record.intoArray())));
                writer.append(";\n");
            }
        }
        catch (java.io.IOException e) {
            throw new IOException("Exception while writing INSERTs", e);
        }
    }

    @Override
    public final Document intoXML() {
        try {
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();
            Document document = builder.newDocument();

            Element eResult = document.createElement("result");
            eResult.setAttribute("xmlns", "http://www.jooq.org/xsd/jooq-export-2.6.0.xsd");
            document.appendChild(eResult);

            Element eFields = document.createElement("fields");
            eResult.appendChild(eFields);

            for (Field<?> field : fields.fields) {
                Element eField = document.createElement("field");
                eField.setAttribute("name", field.getName());
                eField.setAttribute("type", field.getDataType().getTypeName().toUpperCase());
                eFields.appendChild(eField);
            }

            Element eRecords = document.createElement("records");
            eResult.appendChild(eRecords);

            for (Record record : this) {
                Element eRecord = document.createElement("record");
                eRecords.appendChild(eRecord);

                for (int index = 0; index < fields.fields.length; index++) {
                    Field<?> field = fields.fields[index];
                    Object value = record.getValue(index);

                    Element eValue = document.createElement("value");
                    eValue.setAttribute("field", field.getName());
                    eRecord.appendChild(eValue);

                    if (value != null) {
                        eValue.setTextContent(format0(value, false, false));
                    }
                }
            }

            return document;
        }
        catch (ParserConfigurationException ignore) {
            throw new RuntimeException(ignore);
        }
    }

    @Override
    public final <H extends ContentHandler> H intoXML(H handler) throws SAXException {
        Attributes empty = new AttributesImpl();

        handler.startDocument();
        handler.startPrefixMapping("", "http://www.jooq.org/xsd/jooq-export-2.6.0.xsd");
        handler.startElement("", "", "result", empty);
        handler.startElement("", "", "fields", empty);

        for (Field<?> field : fields.fields) {
            AttributesImpl attrs = new AttributesImpl();
            attrs.addAttribute("", "", "name", "CDATA", field.getName());
            attrs.addAttribute("", "", "type", "CDATA", field.getDataType().getTypeName().toUpperCase());

            handler.startElement("", "", "field", attrs);
            handler.endElement("", "", "field");
        }

        handler.endElement("", "", "fields");
        handler.startElement("", "", "records", empty);

        for (Record record : this) {
            handler.startElement("", "", "record", empty);

            for (int index = 0; index < fields.fields.length; index++) {
                Field<?> field = fields.fields[index];
                Object value = record.getValue(index);

                AttributesImpl attrs = new AttributesImpl();
                attrs.addAttribute("", "", "field", "CDATA", field.getName());

                handler.startElement("", "", "value", attrs);

                if (value != null) {
                    char[] chars = format0(value, false, false).toCharArray();
                    handler.characters(chars, 0, chars.length);
                }

                handler.endElement("", "", "value");
            }

            handler.endElement("", "", "record");
        }

        handler.endElement("", "", "records");
        handler.endPrefixMapping("");
        handler.endDocument();
        return handler;
    }

    private final String escapeXML(String string) {
        return StringUtils.replaceEach(string,
            new String[] { "\"", "'", "<", ">", "&" },
            new String[] { "&quot;", "&apos;", "&lt;", "&gt;", "&amp;"});
    }

    @Override
    public final List<Map<String, Object>> intoMaps() {
        List<Map<String, Object>> list = new ArrayList<Map<String, Object>>();

        for (R record : this) {
            list.add(record.intoMap());
        }

        return list;
    }

    @Override
    public final <K> Map<K, R> intoMap(Field<K> key) {
        return intoMap0(indexOrFail(fieldsRow(), key));
    }

    @Override
    public final Map<?, R> intoMap(int keyFieldIndex) {
        return intoMap0(keyFieldIndex);
    }

    @Override
    public final Map<?, R> intoMap(String keyFieldName) {
        return intoMap(field(keyFieldName));
    }

    @Override
    public final Map<?, R> intoMap(Name keyFieldName) {
        return intoMap(field(keyFieldName));
    }

    private final <K> Map<K, R> intoMap0(int keyFieldIndex) {
        Map<K, R> map = new LinkedHashMap<K, R>();

        for (R record : this)
            if (map.put((K) record.getValue(keyFieldIndex), record) != null)
                throw new InvalidResultException("Key " + keyFieldIndex + " is not unique in Result for " + this);

        return map;
    }

    @Override
    public final <K, V> Map<K, V> intoMap(Field<K> key, Field<V> value) {
        int kIndex = indexOrFail(fieldsRow(), key);
        int vIndex = indexOrFail(fieldsRow(), value);

        return intoMap0(kIndex, vIndex);
    }

    @Override
    public final Map<?, ?> intoMap(int keyFieldIndex, int valueFieldIndex) {
        return intoMap0(keyFieldIndex, valueFieldIndex);
    }

    @Override
    public final Map<?, ?> intoMap(String keyFieldName, String valueFieldName) {
        return intoMap(field(keyFieldName), field(valueFieldName));
    }

    @Override
    public final Map<?, ?> intoMap(Name keyFieldName, Name valueFieldName) {
        return intoMap(field(keyFieldName), field(valueFieldName));
    }

    private final <K, V> Map<K, V> intoMap0(int kIndex, int vIndex) {
        Map<K, V> map = new LinkedHashMap<K, V>();

        for (R record : this)
            if (map.put((K) record.getValue(kIndex), (V) record.getValue(vIndex)) != null)
                throw new InvalidResultException("Key " + kIndex + " is not unique in Result for " + this);

        return map;
    }

    @Override
    public final Map<Record, R> intoMap(int[] keyFieldIndexes) {
        return intoMap(fields(keyFieldIndexes));
    }

    @Override
    public final Map<Record, R> intoMap(String[] keyFieldNames) {
        return intoMap(fields(keyFieldNames));
    }

    @Override
    public final Map<Record, R> intoMap(Name[] keyFieldNames) {
        return intoMap(fields(keyFieldNames));
    }

    @Override
    public final Map<Record, R> intoMap(Field<?>[] keys) {
        if (keys == null) {
            keys = new Field[0];
        }

        Map<Record, R> map = new LinkedHashMap<Record, R>();
        for (R record : this) {
            RecordImpl key = new RecordImpl(keys);

            for (Field<?> field : keys) {
                Utils.copyValue(key, field, record, field);
            }

            if (map.put(key, record) != null) {
                throw new InvalidResultException("Key list " + Arrays.asList(keys) + " is not unique in Result for " + this);
            }
        }

        return map;
    }

    @Override
    public final <E> Map<List<?>, E> intoMap(int[] keyFieldIndexes, Class<? extends E> type) {
        return intoMap(fields(keyFieldIndexes), type);
    }

    @Override
    public final <E> Map<List<?>, E> intoMap(String[] keyFieldNames, Class<? extends E> type) {
        return intoMap(fields(keyFieldNames), type);
    }

    @Override
    public final <E> Map<List<?>, E> intoMap(Name[] keyFieldNames, Class<? extends E> type) {
        return intoMap(fields(keyFieldNames), type);
    }

    @Override
    public final <E> Map<List<?>, E> intoMap(Field<?>[] keys, Class<? extends E> type) {
        return intoMap(keys, Utils.configuration(this).recordMapperProvider().provide(fields, type));
    }

    @Override
    public final <E> Map<List<?>, E> intoMap(int[] keyFieldIndexes, RecordMapper<? super R, E> mapper) {
        return intoMap(fields(keyFieldIndexes), mapper);
    }

    @Override
    public final <E> Map<List<?>, E> intoMap(String[] keyFieldNames, RecordMapper<? super R, E> mapper) {
        return intoMap(fields(keyFieldNames), mapper);
    }

    @Override
    public final <E> Map<List<?>, E> intoMap(Name[] keyFieldNames, RecordMapper<? super R, E> mapper) {
        return intoMap(fields(keyFieldNames), mapper);
    }

    @Override
    public final <E> Map<List<?>, E> intoMap(Field<?>[] keys, RecordMapper<? super R, E> mapper) {
        if (keys == null) {
            keys = new Field[0];
        }

        Map<List<?>, E> map = new LinkedHashMap<List<?>, E>();

        for (R record : this) {
            List<Object> keyValueList = new ArrayList<Object>();
            for (Field<?> key : keys) {
                keyValueList.add(record.getValue(key));
            }

            if (map.put(keyValueList, mapper.map(record)) != null) {
                throw new InvalidResultException("Key list " + keyValueList + " is not unique in Result for " + this);
            }
        }

        return map;
    }

    @Override
    public final <S extends Record> Map<S, R> intoMap(Table<S> table) {
        Map<S, R> map = new LinkedHashMap<S, R>();

        for (R record : this) {
            S key = record.into(table);

            if (map.put(key, record) != null) {
                throw new InvalidResultException("Key list " + key + " is not unique in Result for " + this);
            }
        }

        return map;
    }

    @Override
    public final <E, S extends Record> Map<S, E> intoMap(Table<S> table, Class<? extends E> type) {
        return intoMap(table, Utils.configuration(this).recordMapperProvider().provide(fields, type));
    }

    @Override
    public final <E, S extends Record> Map<S, E> intoMap(Table<S> table, RecordMapper<? super R, E> mapper) {
        Map<S, E> map = new LinkedHashMap<S, E>();

        for (R record : this) {
            S key = record.into(table);

            if (map.put(key, mapper.map(record)) != null) {
                throw new InvalidResultException("Key list " + key + " is not unique in Result for " + this);
            }
        }

        return map;
    }

    @Override
    public final <E> Map<?, E> intoMap(int keyFieldIndex, Class<? extends E> type) {
        return intoMap(keyFieldIndex, Utils.configuration(this).recordMapperProvider().provide(fields, type));
    }

    @Override
    public final <E> Map<?, E> intoMap(String keyFieldName, Class<? extends E> type) {
        return intoMap(keyFieldName, Utils.configuration(this).recordMapperProvider().provide(fields, type));
    }

    @Override
    public final <E> Map<?, E> intoMap(Name keyFieldName, Class<? extends E> type) {
        return intoMap(keyFieldName, Utils.configuration(this).recordMapperProvider().provide(fields, type));
    }

    @Override
    public final <K, E> Map<K, E> intoMap(Field<K> key, Class<? extends E> type) {
        return intoMap(key, Utils.configuration(this).recordMapperProvider().provide(fields, type));
    }

    @Override
    public final <E> Map<?, E> intoMap(int keyFieldIndex, RecordMapper<? super R, E> mapper) {
        return intoMap0(keyFieldIndex, mapper);
    }

    @Override
    public final <E> Map<?, E> intoMap(String keyFieldName, RecordMapper<? super R, E> mapper) {
        return intoMap(field(keyFieldName), mapper);
    }

    @Override
    public final <E> Map<?, E> intoMap(Name keyFieldName, RecordMapper<? super R, E> mapper) {
        return intoMap(field(keyFieldName), mapper);
    }

    @Override
    public final <K, E> Map<K, E> intoMap(Field<K> key, RecordMapper<? super R, E> mapper) {
        return intoMap0(indexOrFail(fieldsRow(), key), mapper);
    }

    private final <K, E> Map<K, E> intoMap0(int keyFieldIndex, RecordMapper<? super R, E> mapper) {
        Map<K, E> map = new LinkedHashMap<K, E>();

        for (R record : this)
            if (map.put((K) record.getValue(keyFieldIndex), mapper.map(record)) != null)
                throw new InvalidResultException("Key " + keyFieldIndex + " is not unique in Result for " + this);

        return map;
    }

    @Override
    public final <K> Map<K, Result<R>> intoGroups(Field<K> key) {
        return intoGroups0(indexOrFail(fieldsRow(), key));
    }

    @Override
    public final Map<?, Result<R>> intoGroups(int keyFieldIndex) {
        return intoGroups0(keyFieldIndex);
    }

    @Override
    public final Map<?, Result<R>> intoGroups(String keyFieldName) {
        return intoGroups(field(keyFieldName));
    }

    @Override
    public final Map<?, Result<R>> intoGroups(Name keyFieldName) {
        return intoGroups(field(keyFieldName));
    }

    private final <K> Map<K, Result<R>> intoGroups0(int keyFieldIndex) {
        Map<K, Result<R>> map = new LinkedHashMap<K, Result<R>>();

        for (R record : this) {
            K val = (K) record.getValue(keyFieldIndex);
            Result<R> result = map.get(val);

            if (result == null) {
                result = new ResultImpl<R>(configuration, fields);
                map.put(val, result);
            }

            result.add(record);
        }

        return map;
    }

    @Override
    public final <K, V> Map<K, List<V>> intoGroups(Field<K> key, Field<V> value) {
        int kIndex = indexOrFail(fieldsRow(), key);
        int vIndex = indexOrFail(fieldsRow(), value);

        return intoGroups0(kIndex, vIndex);
    }

    @Override
    public final Map<?, List<?>> intoGroups(int keyFieldIndex, int valueFieldIndex) {
        return (Map) intoGroups0(keyFieldIndex, valueFieldIndex);
    }

    @Override
    public final Map<?, List<?>> intoGroups(String keyFieldName, String valueFieldName) {
        return (Map) intoGroups(field(keyFieldName), field(valueFieldName));
    }

    @Override
    public final Map<?, List<?>> intoGroups(Name keyFieldName, Name valueFieldName) {
        return (Map) intoGroups(field(keyFieldName), field(valueFieldName));
    }

    private final <K, V> Map<K, List<V>> intoGroups0(int kIndex, int vIndex) {
        Map<K, List<V>> map = new LinkedHashMap<K, List<V>>();

        for (R record : this) {
            K k = (K) record.getValue(kIndex);
            V v = (V) record.getValue(vIndex);
            List<V> result = map.get(k);

            if (result == null) {
                result = new ArrayList<V>();
                map.put(k, result);
            }

            result.add(v);
        }

        return map;
    }

    @Override
    public final <E> Map<?, List<E>> intoGroups(int keyFieldIndex, Class<? extends E> type) {
        return intoGroups(keyFieldIndex, Utils.configuration(this).recordMapperProvider().provide(fields, type));
    }

    @Override
    public final <E> Map<?, List<E>> intoGroups(String keyFieldName, Class<? extends E> type) {
        return intoGroups(keyFieldName, Utils.configuration(this).recordMapperProvider().provide(fields, type));
    }

    @Override
    public final <E> Map<?, List<E>> intoGroups(Name keyFieldName, Class<? extends E> type) {
        return intoGroups(keyFieldName, Utils.configuration(this).recordMapperProvider().provide(fields, type));
    }

    @Override
    public final <K, E> Map<K, List<E>> intoGroups(Field<K> key, Class<? extends E> type) {
        return intoGroups(key, Utils.configuration(this).recordMapperProvider().provide(fields, type));
    }

    @Override
    public final <K, E> Map<K, List<E>> intoGroups(Field<K> key, RecordMapper<? super R, E> mapper) {
        return intoGroups0(indexOrFail(fieldsRow(), key), mapper);
    }

    @Override
    public final <E> Map<?, List<E>> intoGroups(int keyFieldIndex, RecordMapper<? super R, E> mapper) {
        return intoGroups0(keyFieldIndex, mapper);
    }

    @Override
    public final <E> Map<?, List<E>> intoGroups(String keyFieldName, RecordMapper<? super R, E> mapper) {
        return intoGroups(field(keyFieldName), mapper);
    }

    @Override
    public final <E> Map<?, List<E>> intoGroups(Name keyFieldName, RecordMapper<? super R, E> mapper) {
        return intoGroups(field(keyFieldName), mapper);
    }

    private final <K, E> Map<K, List<E>> intoGroups0(int keyFieldIndex, RecordMapper<? super R, E> mapper) {
        Map<K, List<E>> map = new LinkedHashMap<K, List<E>>();

        for (R record : this) {
            K keyVal = (K) record.getValue(keyFieldIndex);

            List<E> list = map.get(keyVal);
            if (list == null) {
                list = new ArrayList<E>();
                map.put(keyVal, list);
            }

            list.add(mapper.map(record));
        }

        return map;
    }

    @Override
    public final Map<Record, Result<R>> intoGroups(int[] keyFieldIndexes) {
        return intoGroups(fields(keyFieldIndexes));
    }

    @Override
    public final Map<Record, Result<R>> intoGroups(String[] keyFieldNames) {
        return intoGroups(fields(keyFieldNames));
    }

    @Override
    public final Map<Record, Result<R>> intoGroups(Name[] keyFieldNames) {
        return intoGroups(fields(keyFieldNames));
    }

    @Override
    public final Map<Record, Result<R>> intoGroups(Field<?>[] keys) {
        if (keys == null) {
            keys = new Field[0];
        }

        Map<Record, Result<R>> map = new LinkedHashMap<Record, Result<R>>();
        for (R record : this) {
            RecordImpl key = new RecordImpl(keys);

            for (Field<?> field : keys) {
                Utils.copyValue(key, field, record, field);
            }

            Result<R> result = map.get(key);
            if (result == null) {
                result = new ResultImpl<R>(configuration(), this.fields);
                map.put(key, result);
            }

            result.add(record);
        }

        return map;
    }

    @Override
    public <E> Map<Record, List<E>> intoGroups(int[] keyFieldIndexes, Class<? extends E> type) {
        return intoGroups(keyFieldIndexes, Utils.configuration(this).recordMapperProvider().provide(fields, type));
    }

    @Override
    public <E> Map<Record, List<E>> intoGroups(String[] keyFieldNames, Class<? extends E> type) {
        return intoGroups(keyFieldNames, Utils.configuration(this).recordMapperProvider().provide(fields, type));
    }

    @Override
    public <E> Map<Record, List<E>> intoGroups(Name[] keyFieldNames, Class<? extends E> type) {
        return intoGroups(keyFieldNames, Utils.configuration(this).recordMapperProvider().provide(fields, type));
    }

    @Override
    public final <E> Map<Record, List<E>> intoGroups(Field<?>[] keys, Class<? extends E> type) {
        return intoGroups(keys, Utils.configuration(this).recordMapperProvider().provide(fields, type));
    }

    @Override
    public final <E> Map<Record, List<E>> intoGroups(int[] keyFieldIndexes, RecordMapper<? super R, E> mapper) {
        return intoGroups(fields(keyFieldIndexes), mapper);
    }

    @Override
    public final <E> Map<Record, List<E>> intoGroups(String[] keyFieldNames, RecordMapper<? super R, E> mapper) {
        return intoGroups(fields(keyFieldNames), mapper);
    }

    @Override
    public final <E> Map<Record, List<E>> intoGroups(Name[] keyFieldNames, RecordMapper<? super R, E> mapper) {
        return intoGroups(fields(keyFieldNames), mapper);
    }

    @Override
    public final <E> Map<Record, List<E>> intoGroups(Field<?>[] keys, RecordMapper<? super R, E> mapper) {
        if (keys == null) {
            keys = new Field[0];
        }

        Map<Record, List<E>> map = new LinkedHashMap<Record, List<E>>();
        for (R record : this) {
            RecordImpl key = new RecordImpl(keys);

            for (Field<?> field : keys) {
                Utils.copyValue(key, field, record, field);
            }

            List<E> list = map.get(key);
            if (list == null) {
                list = new ArrayList<E>();
                map.put(key, list);
            }

            list.add(mapper.map(record));
        }

        return map;
    }

    @Override
    public final <S extends Record> Map<S, Result<R>> intoGroups(Table<S> table) {
        Map<S, Result<R>> map = new LinkedHashMap<S, Result<R>>();

        for (R record : this) {
            S key = record.into(table);

            Result<R> result = map.get(key);
            if (result == null) {
                result = new ResultImpl<R>(configuration(), this.fields);
                map.put(key, result);
            }

            result.add(record);
        }

        return map;
    }

    @Override
    public final <E, S extends Record> Map<S, List<E>> intoGroups(Table<S> table, Class<? extends E> type) {
        return intoGroups(table, Utils.configuration(this).recordMapperProvider().provide(fields, type));
    }

    @Override
    public final <E, S extends Record> Map<S, List<E>> intoGroups(Table<S> table, RecordMapper<? super R, E> mapper) {
        Map<S, List<E>> map = new LinkedHashMap<S, List<E>>();

        for (R record : this) {
            S key = record.into(table);

            List<E> list = map.get(key);
            if (list == null) {
                list = new ArrayList<E>();
                map.put(key, list);
            }

            list.add(mapper.map(record));
        }

        return map;
    }

    @Override
    @Deprecated
    public final Object[][] intoArray() {
        return intoArrays();
    }

    @Override
    public final Object[][] intoArrays() {
        int size = size();
        Object[][] array = new Object[size][];

        for (int i = 0; i < size; i++) {
            array[i] = get(i).intoArray();
        }

        return array;
    }

    @Override
    public final Object[] intoArray(int fieldIndex) {
        Class<?> type = fields.fields[fieldIndex].getType();
        List<?> list = getValues(fieldIndex);
        return list.toArray((Object[]) Array.newInstance(type, list.size()));
    }

    @Override
    public final <T> T[] intoArray(int fieldIndex, Class<? extends T> type) {
        return (T[]) Convert.convertArray(intoArray(fieldIndex), type);
    }

    @Override
    public final <U> U[] intoArray(int fieldIndex, Converter<?, U> converter) {
        return Convert.convertArray(intoArray(fieldIndex), converter);
    }

    @Override
    public final Object[] intoArray(String fieldName) {
        Class<?> type = field(fieldName).getType();
        List<?> list = getValues(fieldName);
        return list.toArray((Object[]) Array.newInstance(type, list.size()));
    }

    @Override
    public final <T> T[] intoArray(String fieldName, Class<? extends T> type) {
        return (T[]) Convert.convertArray(intoArray(fieldName), type);
    }

    @Override
    public final <U> U[] intoArray(String fieldName, Converter<?, U> converter) {
        return Convert.convertArray(intoArray(fieldName), converter);
    }

    @Override
    public final Object[] intoArray(Name fieldName) {
        Class<?> type = field(fieldName).getType();
        List<?> list = getValues(fieldName);
        return list.toArray((Object[]) Array.newInstance(type, list.size()));
    }

    @Override
    public final <T> T[] intoArray(Name fieldName, Class<? extends T> type) {
        return (T[]) Convert.convertArray(intoArray(fieldName), type);
    }

    @Override
    public final <U> U[] intoArray(Name fieldName, Converter<?, U> converter) {
        return Convert.convertArray(intoArray(fieldName), converter);
    }

    @Override
    public final <T> T[] intoArray(Field<T> field) {
        return getValues(field).toArray((T[]) Array.newInstance(field.getType(), 0));
    }

    @Override
    public final <T> T[] intoArray(Field<?> field, Class<? extends T> type) {
        return (T[]) Convert.convertArray(intoArray(field), type);
    }

    @Override
    public final <T, U> U[] intoArray(Field<T> field, Converter<? super T, U> converter) {
        return Convert.convertArray(intoArray(field), converter);
    }

    @Override
    public final Set<?> intoSet(int fieldIndex) {
        return new LinkedHashSet<Object>(getValues(fieldIndex));
    }

    @Override
    public final <T> Set<T> intoSet(int fieldIndex, Class<? extends T> type) {
        return new LinkedHashSet<T>(getValues(fieldIndex, type));
    }

    @Override
    public final <U> Set<U> intoSet(int fieldIndex, Converter<?, U> converter) {
        return new LinkedHashSet<U>(getValues(fieldIndex, converter));
    }

    @Override
    public final Set<?> intoSet(String fieldName) {
        return new LinkedHashSet<Object>(getValues(fieldName));
    }

    @Override
    public final <T> Set<T> intoSet(String fieldName, Class<? extends T> type) {
        return new LinkedHashSet<T>(getValues(fieldName, type));
    }

    @Override
    public final <U> Set<U> intoSet(String fieldName, Converter<?, U> converter) {
        return new LinkedHashSet<U>(getValues(fieldName, converter));
    }

    @Override
    public final Set<?> intoSet(Name fieldName) {
        return new LinkedHashSet<Object>(getValues(fieldName));
    }

    @Override
    public final <T> Set<T> intoSet(Name fieldName, Class<? extends T> type) {
        return new LinkedHashSet<T>(getValues(fieldName, type));
    }

    @Override
    public final <U> Set<U> intoSet(Name fieldName, Converter<?, U> converter) {
        return new LinkedHashSet<U>(getValues(fieldName, converter));
    }

    @Override
    public final <T> Set<T> intoSet(Field<T> field) {
        return new LinkedHashSet<T>(getValues(field));
    }

    @Override
    public final <T> Set<T> intoSet(Field<?> field, Class<? extends T> type) {
        return new LinkedHashSet<T>(getValues(field, type));
    }

    @Override
    public final <T, U> Set<U> intoSet(Field<T> field, Converter<? super T, U> converter) {
        return new LinkedHashSet<U>(getValues(field, converter));
    }

    @Override
    public final Result<Record> into(Field<?>... f) {
        Result<Record> result = new ResultImpl<Record>(Utils.configuration(this), f);

        for (Record record : this)
            result.add(record.into(f));

        return result;
    }



    @Override
    public final <T1> Result<Record1<T1>> into(Field<T1> field1) {
        return (Result) into(new Field[] { field1 });
    }

    @Override
    public final <T1, T2> Result<Record2<T1, T2>> into(Field<T1> field1, Field<T2> field2) {
        return (Result) into(new Field[] { field1, field2 });
    }

    @Override
    public final <T1, T2, T3> Result<Record3<T1, T2, T3>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3) {
        return (Result) into(new Field[] { field1, field2, field3 });
    }

    @Override
    public final <T1, T2, T3, T4> Result<Record4<T1, T2, T3, T4>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4) {
        return (Result) into(new Field[] { field1, field2, field3, field4 });
    }

    @Override
    public final <T1, T2, T3, T4, T5> Result<Record5<T1, T2, T3, T4, T5>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5 });
    }

    @Override
    public final <T1, T2, T3, T4, T5, T6> Result<Record6<T1, T2, T3, T4, T5, T6>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5, field6 });
    }

    @Override
    public final <T1, T2, T3, T4, T5, T6, T7> Result<Record7<T1, T2, T3, T4, T5, T6, T7>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5, field6, field7 });
    }

    @Override
    public final <T1, T2, T3, T4, T5, T6, T7, T8> Result<Record8<T1, T2, T3, T4, T5, T6, T7, T8>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5, field6, field7, field8 });
    }

    @Override
    public final <T1, T2, T3, T4, T5, T6, T7, T8, T9> Result<Record9<T1, T2, T3, T4, T5, T6, T7, T8, T9>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9 });
    }

    @Override
    public final <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> Result<Record10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10 });
    }

    @Override
    public final <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> Result<Record11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11 });
    }

    @Override
    public final <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> Result<Record12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12 });
    }

    @Override
    public final <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> Result<Record13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13 });
    }

    @Override
    public final <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> Result<Record14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14 });
    }

    @Override
    public final <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> Result<Record15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15 });
    }

    @Override
    public final <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> Result<Record16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16 });
    }

    @Override
    public final <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> Result<Record17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17 });
    }

    @Override
    public final <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> Result<Record18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18 });
    }

    @Override
    public final <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> Result<Record19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19 });
    }

    @Override
    public final <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> Result<Record20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20 });
    }

    @Override
    public final <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> Result<Record21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20, Field<T21> field21) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21 });
    }

    @Override
    public final <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> Result<Record22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20, Field<T21> field21, Field<T22> field22) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21, field22 });
    }



    @Override
    public final <E> List<E> into(Class<? extends E> type) {
        List<E> list = new ArrayList<E>(size());
        RecordMapper<R, E> mapper = Utils.configuration(this).recordMapperProvider().provide(fields, type);

        for (R record : this) {
            list.add(mapper.map(record));
        }

        return list;
    }

    @Override
    public final <Z extends Record> Result<Z> into(Table<Z> table) {
        Result<Z> list = new ResultImpl<Z>(configuration(), table.fields());

        for (R record : this) {
            list.add(record.into(table));
        }

        return list;
    }

    @Override
    public final <H extends RecordHandler<? super R>> H into(H handler) {
        for (R record : this) {
            handler.next(record);
        }

        return handler;
    }

    @Override
    public final ResultSet intoResultSet() {
        return new MockResultSet(this);
    }

    @Override
    public final <E> List<E> map(RecordMapper<? super R, E> mapper) {
        List<E> result = new ArrayList<E>();

        for (R record : this) {
            result.add(mapper.map(record));
        }

        return result;
    }

    @Override
    public final <T extends Comparable<? super T>> Result<R> sortAsc(Field<T> field) {
        return sortAsc(field, new NaturalComparator<T>());
    }

    @Override
    public final Result<R> sortAsc(int fieldIndex) {
        return sortAsc(fieldIndex, new NaturalComparator());
    }

    @Override
    public final Result<R> sortAsc(String fieldName) {
        return sortAsc(fieldName, new NaturalComparator());
    }

    @Override
    public final Result<R> sortAsc(Name fieldName) {
        return sortAsc(fieldName, new NaturalComparator());
    }

    @Override
    public final <T> Result<R> sortAsc(Field<T> field, Comparator<? super T> comparator) {
        return sortAsc(indexOrFail(fieldsRow(), field), comparator);
    }

    @Override
    public final Result<R> sortAsc(int fieldIndex, Comparator<?> comparator) {
        return sortAsc(new RecordComparator(fieldIndex, comparator));
    }

    @Override
    public final Result<R> sortAsc(String fieldName, Comparator<?> comparator) {
        return sortAsc(indexOrFail(fieldsRow(), fieldName), comparator);
    }

    @Override
    public final Result<R> sortAsc(Name fieldName, Comparator<?> comparator) {
        return sortAsc(indexOrFail(fieldsRow(), fieldName), comparator);
    }

    @Override
    public final Result<R> sortAsc(Comparator<? super R> comparator) {
        Collections.sort(this, comparator);
        return this;
    }

    @Override
    public final <T extends Comparable<? super T>> Result<R> sortDesc(Field<T> field) {
        return sortAsc(field, Collections.reverseOrder(new NaturalComparator<T>()));
    }

    @Override
    public final Result<R> sortDesc(int fieldIndex) {
        return sortAsc(fieldIndex, Collections.reverseOrder(new NaturalComparator()));
    }

    @Override
    public final Result<R> sortDesc(String fieldName) {
        return sortAsc(fieldName, Collections.reverseOrder(new NaturalComparator()));
    }

    @Override
    public final Result<R> sortDesc(Name fieldName) {
        return sortAsc(fieldName, Collections.reverseOrder(new NaturalComparator()));
    }

    @Override
    public final <T> Result<R> sortDesc(Field<T> field, Comparator<? super T> comparator) {
        return sortAsc(field, Collections.reverseOrder(comparator));
    }

    @Override
    public final Result<R> sortDesc(int fieldIndex, Comparator<?> comparator) {
        return sortAsc(fieldIndex, Collections.reverseOrder(comparator));
    }

    @Override
    public final Result<R> sortDesc(String fieldName, Comparator<?> comparator) {
        return sortAsc(fieldName, Collections.reverseOrder(comparator));
    }

    @Override
    public final Result<R> sortDesc(Name fieldName, Comparator<?> comparator) {
        return sortAsc(fieldName, Collections.reverseOrder(comparator));
    }

    @Override
    public final Result<R> sortDesc(Comparator<? super R> comparator) {
        return sortAsc(Collections.reverseOrder(comparator));
    }

    @Override
    public final Result<R> intern(Field<?>... f) {
        return intern(fields.indexesOf(f));
    }

    @Override
    public final Result<R> intern(int... fieldIndexes) {
        for (int fieldIndex : fieldIndexes) {
            if (fields.fields[fieldIndex].getType() == String.class) {
                for (Record record : this) {
                    ((AbstractRecord) record).intern0(fieldIndex);
                }
            }
        }

        return this;
    }

    @Override
    public final Result<R> intern(String... fieldNames) {
        return intern(fields.indexesOf(fieldNames));
    }

    @Override
    public final Result<R> intern(Name... fieldNames) {
        return intern(fields.indexesOf(fieldNames));
    }


    private static class RecordComparator<T, R extends Record> implements Comparator<R> {

        private final Comparator<? super T> comparator;
        private final int fieldIndex;

        RecordComparator(int fieldIndex, Comparator<? super T> comparator) {
            this.fieldIndex = fieldIndex;
            this.comparator = comparator;
        }

        @Override
        public int compare(R record1, R record2) {
            return comparator.compare((T) record1.getValue(fieldIndex), (T) record2.getValue(fieldIndex));
        }
    }


    private static class NaturalComparator<T extends Comparable<? super T>> implements Comparator<T> {

        @Override
        public int compare(T o1, T o2) {
            if (o1 == null && o2 == null) {
                return 0;
            }
            else if (o1 == null) {
                return -1;
            }
            else if (o2 == null) {
                return 1;
            }
            return o1.compareTo(o2);
        }
    }





    @Override
    public final <O extends UpdatableRecord<O>> Result<O> fetchParents(ForeignKey<R, O> key) {
        return key.fetchParents(this);
    }

    @Override
    public final <O extends TableRecord<O>> Result<O> fetchChildren(ForeignKey<O, R> key) {
        return key.fetchChildren(this);
    }





    @Override
    public String toString() {
        return format();
    }

    @Override
    public int hashCode() {
        return records.hashCode();
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }

        if (obj instanceof ResultImpl) {
            ResultImpl<R> other = (ResultImpl<R>) obj;
            return records.equals(other.records);
        }

        return false;
    }





    @Override
    public final int size() {
        return records.size();
    }

    @Override
    public final boolean contains(Object o) {
        return records.contains(o);
    }

    @Override
    public final Object[] toArray() {
        return records.toArray();
    }

    @Override
    public final <T> T[] toArray(T[] a) {
        return records.toArray(a);
    }

    @Override
    public final boolean add(R e) {
        return records.add(e);
    }

    @Override
    public final boolean remove(Object o) {
        return records.remove(o);
    }

    @Override
    public final boolean containsAll(Collection<?> c) {
        return records.containsAll(c);
    }

    @Override
    public final boolean addAll(Collection<? extends R> c) {
        return records.addAll(c);
    }

    @Override
    public final boolean addAll(int index, Collection<? extends R> c) {
        return records.addAll(index, c);
    }

    @Override
    public final boolean removeAll(Collection<?> c) {
        return records.removeAll(c);
    }

    @Override
    public final boolean retainAll(Collection<?> c) {
        return records.retainAll(c);
    }

    @Override
    public final void clear() {
        records.clear();
    }

    @Override
    public final R get(int index) {
        return records.get(index);
    }

    @Override
    public final R set(int index, R element) {
        return records.set(index, element);
    }

    @Override
    public final void add(int index, R element) {
        records.add(index, element);
    }

    @Override
    public final R remove(int index) {
        return records.remove(index);
    }

    @Override
    public final int indexOf(Object o) {
        return records.indexOf(o);
    }

    @Override
    public final int lastIndexOf(Object o) {
        return records.lastIndexOf(o);
    }

    @Override
    public final Iterator<R> iterator() {
        return records.iterator();
    }

    @Override
    public final ListIterator<R> listIterator() {
        return records.listIterator();
    }

    @Override
    public final ListIterator<R> listIterator(int index) {
        return records.listIterator(index);
    }

    @Override
    public final List<R> subList(int fromIndex, int toIndex) {
        return records.subList(fromIndex, toIndex);
    }
}

<code block>


package org.jooq;

import java.io.OutputStream;
import java.io.Writer;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.annotation.Generated;

import org.jooq.exception.DataAccessException;
import org.jooq.exception.DataTypeException;
import org.jooq.exception.IOException;
import org.jooq.exception.InvalidResultException;
import org.jooq.exception.MappingException;
import org.jooq.impl.DefaultRecordMapper;
import org.jooq.tools.Convert;

import org.w3c.dom.Document;
import org.xml.sax.ContentHandler;
import org.xml.sax.SAXException;


public interface Result<R extends Record> extends List<R>, Attachable {


    RecordType<R> recordType();


    Row fieldsRow();


    <T> Field<T> field(Field<T> field);


    Field<?> field(String name);


    <T> Field<T> field(String name, Class<T> type);


    <T> Field<T> field(String name, DataType<T> dataType);


    Field<?> field(Name name);


    <T> Field<T> field(Name name, Class<T> type);


    <T> Field<T> field(Name name, DataType<T> dataType);


    Field<?> field(int index);


    <T> Field<T> field(int index, Class<T> type);


    <T> Field<T> field(int index, DataType<T> dataType);


    Field<?>[] fields();


    <T> T getValue(int index, Field<T> field) throws IndexOutOfBoundsException, IllegalArgumentException;


    @Deprecated
    <T> T getValue(int index, Field<T> field, T defaultValue) throws IndexOutOfBoundsException,
        IllegalArgumentException;


    Object getValue(int index, int fieldIndex) throws IndexOutOfBoundsException, IllegalArgumentException;


    @Deprecated
    Object getValue(int index, int fieldIndex, Object defaultValue) throws IndexOutOfBoundsException,
        IllegalArgumentException;


    Object getValue(int index, String fieldName) throws IndexOutOfBoundsException, IllegalArgumentException;


    @Deprecated
    Object getValue(int index, String fieldName, Object defaultValue) throws IndexOutOfBoundsException,
        IllegalArgumentException;


    <T> List<T> getValues(Field<T> field) throws IllegalArgumentException;


    <T> List<T> getValues(Field<?> field, Class<? extends T> type) throws IllegalArgumentException;


    <T, U> List<U> getValues(Field<T> field, Converter<? super T, U> converter) throws IllegalArgumentException;


    List<?> getValues(int fieldIndex) throws IllegalArgumentException;


    <T> List<T> getValues(int fieldIndex, Class<? extends T> type) throws IllegalArgumentException, DataTypeException;


    <U> List<U> getValues(int fieldIndex, Converter<?, U> converter) throws IllegalArgumentException, DataTypeException;


    List<?> getValues(String fieldName) throws IllegalArgumentException;


    <T> List<T> getValues(String fieldName, Class<? extends T> type) throws IllegalArgumentException, DataTypeException;


    <U> List<U> getValues(String fieldName, Converter<?, U> converter) throws IllegalArgumentException,
        DataTypeException;


    List<?> getValues(Name fieldName) throws IllegalArgumentException;


    <T> List<T> getValues(Name fieldName, Class<? extends T> type) throws IllegalArgumentException, DataTypeException;


    <U> List<U> getValues(Name fieldName, Converter<?, U> converter) throws IllegalArgumentException,
        DataTypeException;


    @Override
    boolean isEmpty();


    boolean isNotEmpty();


    String format();


    String format(int maxRecords);


    String formatHTML();


    String formatCSV();


    String formatCSV(char delimiter);


    String formatCSV(char delimiter, String nullString);


    String formatCSV(boolean header);


    String formatCSV(boolean header, char delimiter);


    String formatCSV(boolean header, char delimiter, String nullString);


    String formatJSON();


    String formatXML();


    String formatInsert();


    String formatInsert(Table<?> table, Field<?>... fields);


    void format(OutputStream stream) throws IOException;


    void format(OutputStream stream, int maxRecords) throws IOException;


    void formatHTML(OutputStream stream) throws IOException;


    void formatCSV(OutputStream stream) throws IOException;


    void formatCSV(OutputStream stream, char delimiter) throws IOException;


    void formatCSV(OutputStream stream, char delimiter, String nullString) throws IOException;


    void formatCSV(OutputStream stream, boolean header) throws IOException;


    void formatCSV(OutputStream stream, boolean header, char delimiter) throws IOException;


    void formatCSV(OutputStream stream, boolean header, char delimiter, String nullString) throws IOException;


    void formatJSON(OutputStream stream) throws IOException;


    void formatXML(OutputStream stream) throws IOException;


    void formatInsert(OutputStream stream) throws IOException;


    void formatInsert(OutputStream stream, Table<?> table, Field<?>... fields) throws IOException;


    void format(Writer writer) throws IOException;


    void format(Writer writer, int maxRecords) throws IOException;


    void formatHTML(Writer writer) throws IOException;


    void formatCSV(Writer writer) throws IOException;


    void formatCSV(Writer writer, char delimiter) throws IOException;


    void formatCSV(Writer writer, char delimiter, String nullString) throws IOException;


    void formatCSV(Writer writer, boolean header) throws IOException;


    void formatCSV(Writer writer, boolean header, char delimiter) throws IOException;


    void formatCSV(Writer writer, boolean header, char delimiter, String nullString) throws IOException;


    void formatJSON(Writer writer) throws IOException;


    void formatXML(Writer writer) throws IOException;


    void formatInsert(Writer writer) throws IOException;


    void formatInsert(Writer writer, Table<?> table, Field<?>... fields) throws IOException;


    Document intoXML();


    <H extends ContentHandler> H intoXML(H handler) throws SAXException;


    List<Map<String, Object>> intoMaps();


    <K> Map<K, R> intoMap(Field<K> key) throws IllegalArgumentException, InvalidResultException;


    Map<?, R> intoMap(int keyFieldIndex) throws IllegalArgumentException, InvalidResultException;


    Map<?, R> intoMap(String keyFieldName) throws IllegalArgumentException, InvalidResultException;


    Map<?, R> intoMap(Name keyFieldName) throws IllegalArgumentException, InvalidResultException;


    <K, V> Map<K, V> intoMap(Field<K> key, Field<V> value) throws IllegalArgumentException, InvalidResultException;


    Map<?, ?> intoMap(int keyFieldIndex, int valueFieldIndex) throws IllegalArgumentException,
        InvalidResultException;


    Map<?, ?> intoMap(String keyFieldName, String valueFieldName) throws IllegalArgumentException,
        InvalidResultException;


    Map<?, ?> intoMap(Name keyFieldName, Name valueFieldName) throws IllegalArgumentException,
        InvalidResultException;


    <K, E> Map<K, E> intoMap(Field<K> key, Class<? extends E> type) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    <E> Map<?, E> intoMap(int keyFieldIndex, Class<? extends E> type) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    <E> Map<?, E> intoMap(String keyFieldName, Class<? extends E> type) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    <E> Map<?, E> intoMap(Name keyFieldName, Class<? extends E> type) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    <K, E> Map<K, E> intoMap(Field<K> key, RecordMapper<? super R, E> mapper) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    <E> Map<?, E> intoMap(int keyFieldIndex, RecordMapper<? super R, E> mapper) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    <E> Map<?, E> intoMap(String keyFieldName, RecordMapper<? super R, E> mapper) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    <E> Map<?, E> intoMap(Name keyFieldName, RecordMapper<? super R, E> mapper) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    Map<Record, R> intoMap(Field<?>[] keys) throws IllegalArgumentException, InvalidResultException;


    Map<Record, R> intoMap(int[] keyFieldIndexes) throws IllegalArgumentException, InvalidResultException;


    Map<Record, R> intoMap(String[] keyFieldNames) throws IllegalArgumentException, InvalidResultException;


    Map<Record, R> intoMap(Name[] keyFieldNames) throws IllegalArgumentException, InvalidResultException;


    <E> Map<List<?>, E> intoMap(Field<?>[] keys, Class<? extends E> type) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    <E> Map<List<?>, E> intoMap(int[] keyFieldIndexes, Class<? extends E> type) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    <E> Map<List<?>, E> intoMap(String[] keyFieldNames, Class<? extends E> type) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    <E> Map<List<?>, E> intoMap(Name[] keyFieldNames, Class<? extends E> type) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    <E> Map<List<?>, E> intoMap(Field<?>[] keys, RecordMapper<? super R, E> mapper) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    <E> Map<List<?>, E> intoMap(int[] keyFieldIndexes, RecordMapper<? super R, E> mapper) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    <E> Map<List<?>, E> intoMap(String[] keyFieldNames, RecordMapper<? super R, E> mapper) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    <E> Map<List<?>, E> intoMap(Name[] keyFieldNames, RecordMapper<? super R, E> mapper) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    <S extends Record> Map<S, R> intoMap(Table<S> table) throws IllegalArgumentException, InvalidResultException;


    <E, S extends Record> Map<S, E> intoMap(Table<S> table, Class<? extends E> type) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    <E, S extends Record> Map<S, E> intoMap(Table<S> table, RecordMapper<? super R, E> mapper) throws IllegalArgumentException,
        InvalidResultException, MappingException;


    <K> Map<K, Result<R>> intoGroups(Field<K> key) throws IllegalArgumentException;


    Map<?, Result<R>> intoGroups(int keyFieldIndex) throws IllegalArgumentException;


    Map<?, Result<R>> intoGroups(String keyFieldName) throws IllegalArgumentException;


    Map<?, Result<R>> intoGroups(Name keyFieldName) throws IllegalArgumentException;


    <K, V> Map<K, List<V>> intoGroups(Field<K> key, Field<V> value) throws IllegalArgumentException;


    Map<?, List<?>> intoGroups(int keyFieldIndex, int valueFieldIndex) throws IllegalArgumentException;


    Map<?, List<?>> intoGroups(String keyFieldName, String valueFieldName) throws IllegalArgumentException;


    Map<?, List<?>> intoGroups(Name keyFieldName, Name valueFieldName) throws IllegalArgumentException;


    <K, E> Map<K, List<E>> intoGroups(Field<K> key, Class<? extends E> type) throws IllegalArgumentException,
        MappingException;


    <E> Map<?, List<E>> intoGroups(int keyFieldIndex, Class<? extends E> type) throws IllegalArgumentException,
        MappingException;


    <E> Map<?, List<E>> intoGroups(String keyFieldName, Class<? extends E> type) throws IllegalArgumentException,
        MappingException;


    <E> Map<?, List<E>> intoGroups(Name keyFieldName, Class<? extends E> type) throws IllegalArgumentException,
        MappingException;


    <K, E> Map<K, List<E>> intoGroups(Field<K> key, RecordMapper<? super R, E> mapper) throws IllegalArgumentException,
        MappingException;


    <E> Map<?, List<E>> intoGroups(int keyFieldIndex, RecordMapper<? super R, E> mapper) throws IllegalArgumentException,
        MappingException;


    <E> Map<?, List<E>> intoGroups(String keyFieldName, RecordMapper<? super R, E> mapper) throws IllegalArgumentException,
        MappingException;


    <E> Map<?, List<E>> intoGroups(Name keyFieldName, RecordMapper<? super R, E> mapper) throws IllegalArgumentException,
        MappingException;


    Map<Record, Result<R>> intoGroups(Field<?>[] keys) throws IllegalArgumentException;


    Map<Record, Result<R>> intoGroups(int[] keyFieldIndexes) throws IllegalArgumentException;


    Map<Record, Result<R>> intoGroups(String[] keyFieldNames) throws IllegalArgumentException;


    Map<Record, Result<R>> intoGroups(Name[] keyFieldNames) throws IllegalArgumentException;


    <E> Map<Record, List<E>> intoGroups(Field<?>[] keys, Class<? extends E> type) throws IllegalArgumentException,
        MappingException;


    <E> Map<Record, List<E>> intoGroups(int[] keyFieldIndexes, Class<? extends E> type) throws IllegalArgumentException,
        MappingException;


    <E> Map<Record, List<E>> intoGroups(String[] keyFieldNames, Class<? extends E> type) throws IllegalArgumentException,
        MappingException;


    <E> Map<Record, List<E>> intoGroups(Name[] keyFieldNames, Class<? extends E> type) throws IllegalArgumentException,
        MappingException;


    <E> Map<Record, List<E>> intoGroups(Field<?>[] keys, RecordMapper<? super R, E> mapper)
        throws IllegalArgumentException, MappingException;


    <E> Map<Record, List<E>> intoGroups(int[] keyFieldIndexes, RecordMapper<? super R, E> mapper)
        throws IllegalArgumentException, MappingException;


    <E> Map<Record, List<E>> intoGroups(String[] keyFieldNames, RecordMapper<? super R, E> mapper)
        throws IllegalArgumentException, MappingException;


    <E> Map<Record, List<E>> intoGroups(Name[] keyFieldNames, RecordMapper<? super R, E> mapper)
        throws IllegalArgumentException, MappingException;


    <S extends Record> Map<S, Result<R>> intoGroups(Table<S> table) throws IllegalArgumentException;


    <E, S extends Record> Map<S, List<E>> intoGroups(Table<S> table, Class<? extends E> type)
        throws IllegalArgumentException, MappingException;


    <E, S extends Record> Map<S, List<E>> intoGroups(Table<S> table, RecordMapper<? super R, E> mapper)
        throws IllegalArgumentException, MappingException;


    @Deprecated
    Object[][] intoArray();


    Object[][] intoArrays();


    Object[] intoArray(int fieldIndex) throws IllegalArgumentException;


    <T> T[] intoArray(int fieldIndex, Class<? extends T> type) throws IllegalArgumentException, DataTypeException;


    <U> U[] intoArray(int fieldIndex, Converter<?, U> converter) throws IllegalArgumentException, DataTypeException;


    Object[] intoArray(String fieldName) throws IllegalArgumentException;


    <T> T[] intoArray(String fieldName, Class<? extends T> type) throws IllegalArgumentException, DataTypeException;


    <U> U[] intoArray(String fieldName, Converter<?, U> converter) throws IllegalArgumentException, DataTypeException;


    Object[] intoArray(Name fieldName) throws IllegalArgumentException;


    <T> T[] intoArray(Name fieldName, Class<? extends T> type) throws IllegalArgumentException, DataTypeException;


    <U> U[] intoArray(Name fieldName, Converter<?, U> converter) throws IllegalArgumentException, DataTypeException;


    <T> T[] intoArray(Field<T> field) throws IllegalArgumentException;


    <T> T[] intoArray(Field<?> field, Class<? extends T> type) throws IllegalArgumentException, DataTypeException;


    <T, U> U[] intoArray(Field<T> field, Converter<? super T, U> converter) throws IllegalArgumentException,
        DataTypeException;


    Set<?> intoSet(int fieldIndex) throws IllegalArgumentException;


    <T> Set<T> intoSet(int fieldIndex, Class<? extends T> type) throws IllegalArgumentException, DataTypeException;


    <U> Set<U> intoSet(int fieldIndex, Converter<?, U> converter) throws IllegalArgumentException, DataTypeException;


    Set<?> intoSet(String fieldName) throws IllegalArgumentException;


    <T> Set<T> intoSet(String fieldName, Class<? extends T> type) throws IllegalArgumentException, DataTypeException;


    <U> Set<U> intoSet(String fieldName, Converter<?, U> converter) throws IllegalArgumentException, DataTypeException;


    Set<?> intoSet(Name fieldName) throws IllegalArgumentException;


    <T> Set<T> intoSet(Name fieldName, Class<? extends T> type) throws IllegalArgumentException, DataTypeException;


    <U> Set<U> intoSet(Name fieldName, Converter<?, U> converter) throws IllegalArgumentException, DataTypeException;


    <T> Set<T> intoSet(Field<T> field) throws IllegalArgumentException;


    <T> Set<T> intoSet(Field<?> field, Class<? extends T> type) throws IllegalArgumentException, DataTypeException;


    <T, U> Set<U> intoSet(Field<T> field, Converter<? super T, U> converter) throws IllegalArgumentException,
        DataTypeException;


    Result<Record> into(Field<?>... fields);




    @Generated("This class was generated using jOOQ-tools")
    <T1> Result<Record1<T1>> into(Field<T1> field1);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2> Result<Record2<T1, T2>> into(Field<T1> field1, Field<T2> field2);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3> Result<Record3<T1, T2, T3>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4> Result<Record4<T1, T2, T3, T4>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5> Result<Record5<T1, T2, T3, T4, T5>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5, T6> Result<Record6<T1, T2, T3, T4, T5, T6>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5, T6, T7> Result<Record7<T1, T2, T3, T4, T5, T6, T7>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5, T6, T7, T8> Result<Record8<T1, T2, T3, T4, T5, T6, T7, T8>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5, T6, T7, T8, T9> Result<Record9<T1, T2, T3, T4, T5, T6, T7, T8, T9>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> Result<Record10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> Result<Record11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> Result<Record12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> Result<Record13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> Result<Record14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> Result<Record15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> Result<Record16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> Result<Record17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> Result<Record18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> Result<Record19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> Result<Record20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> Result<Record21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20, Field<T21> field21);


    @Generated("This class was generated using jOOQ-tools")
    <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> Result<Record22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20, Field<T21> field21, Field<T22> field22);




    <E> List<E> into(Class<? extends E> type) throws MappingException;


    <Z extends Record> Result<Z> into(Table<Z> table) throws MappingException;


    <H extends RecordHandler<? super R>> H into(H handler);


    ResultSet intoResultSet();


    <E> List<E> map(RecordMapper<? super R, E> mapper);


    <T extends Comparable<? super T>> Result<R> sortAsc(Field<T> field) throws IllegalArgumentException;


    <T extends Comparable<? super T>> Result<R> sortDesc(Field<T> field) throws IllegalArgumentException;


    Result<R> sortAsc(int fieldIndex) throws IllegalArgumentException;


    Result<R> sortDesc(int fieldIndex) throws IllegalArgumentException;


    Result<R> sortAsc(String fieldName) throws IllegalArgumentException;


    Result<R> sortDesc(String fieldName) throws IllegalArgumentException;


    Result<R> sortAsc(Name fieldName) throws IllegalArgumentException;


    Result<R> sortDesc(Name fieldName) throws IllegalArgumentException;


    <T> Result<R> sortAsc(Field<T> field, java.util.Comparator<? super T> comparator) throws IllegalArgumentException;


    <T> Result<R> sortDesc(Field<T> field, java.util.Comparator<? super T> comparator) throws IllegalArgumentException;


    Result<R> sortAsc(int fieldIndex, java.util.Comparator<?> comparator) throws IllegalArgumentException;


    Result<R> sortDesc(int fieldIndex, java.util.Comparator<?> comparator) throws IllegalArgumentException;


    Result<R> sortAsc(String fieldName, java.util.Comparator<?> comparator) throws IllegalArgumentException;


    Result<R> sortDesc(String fieldName, java.util.Comparator<?> comparator) throws IllegalArgumentException;


    Result<R> sortAsc(Name fieldName, java.util.Comparator<?> comparator) throws IllegalArgumentException;


    Result<R> sortDesc(Name fieldName, java.util.Comparator<?> comparator) throws IllegalArgumentException;


    Result<R> sortAsc(java.util.Comparator<? super R> comparator);


    Result<R> sortDesc(java.util.Comparator<? super R> comparator);


    Result<R> intern(Field<?>... fields);


    Result<R> intern(int... fieldIndexes);


    Result<R> intern(String... fieldNames);


    Result<R> intern(Name... fieldNames);






    <O extends UpdatableRecord<O>> Result<O> fetchParents(ForeignKey<R, O> key) throws DataAccessException;


    <O extends TableRecord<O>> Result<O> fetchChildren(ForeignKey<O, R> key) throws DataAccessException;






    @Override
    void attach(Configuration configuration);


    @Override
    void detach();

}

<code block>


package org.jooq.impl;

import static java.lang.Math.max;
import static java.lang.Math.min;
import static org.jooq.impl.DSL.insertInto;
import static org.jooq.impl.DSL.name;
import static org.jooq.impl.DSL.table;
import static org.jooq.impl.Utils.indexOrFail;
import static org.jooq.tools.StringUtils.abbreviate;
import static org.jooq.tools.StringUtils.leftPad;
import static org.jooq.tools.StringUtils.rightPad;

import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.lang.reflect.Array;
import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;

import javax.xml.bind.DatatypeConverter;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.jooq.AttachableInternal;
import org.jooq.Configuration;
import org.jooq.Converter;
import org.jooq.DSLContext;
import org.jooq.DataType;
import org.jooq.EnumType;
import org.jooq.Field;
import org.jooq.ForeignKey;
import org.jooq.Name;
import org.jooq.Record;
import org.jooq.Record1;
import org.jooq.Record10;
import org.jooq.Record11;
import org.jooq.Record12;
import org.jooq.Record13;
import org.jooq.Record14;
import org.jooq.Record15;
import org.jooq.Record16;
import org.jooq.Record17;
import org.jooq.Record18;
import org.jooq.Record19;
import org.jooq.Record2;
import org.jooq.Record20;
import org.jooq.Record21;
import org.jooq.Record22;
import org.jooq.Record3;
import org.jooq.Record4;
import org.jooq.Record5;
import org.jooq.Record6;
import org.jooq.Record7;
import org.jooq.Record8;
import org.jooq.Record9;
import org.jooq.RecordHandler;
import org.jooq.RecordMapper;
import org.jooq.RecordType;
import org.jooq.Result;
import org.jooq.Row;
import org.jooq.Table;
import org.jooq.TableRecord;
import org.jooq.UpdatableRecord;
import org.jooq.exception.IOException;
import org.jooq.exception.InvalidResultException;
import org.jooq.tools.Convert;
import org.jooq.tools.StringUtils;
import org.jooq.tools.jdbc.MockResultSet;
import org.jooq.tools.json.JSONObject;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.xml.sax.Attributes;
import org.xml.sax.ContentHandler;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.AttributesImpl;


@SuppressWarnings({"rawtypes", "unchecked" })
class ResultImpl<R extends Record> implements Result<R>, AttachableInternal {


    private static final long serialVersionUID = 6416154375799578362L;

    private Configuration     configuration;
    private final Fields<R>   fields;
    private final List<R>     records;

    ResultImpl(Configuration configuration, Collection<? extends Field<?>> fields) {
        this(configuration, new Fields<R>(fields));
    }

    ResultImpl(Configuration configuration, Field<?>... fields) {
        this(configuration, new Fields<R>(fields));
    }

    ResultImpl(Configuration configuration, Fields<R> fields) {
        this.configuration = configuration;
        this.fields = fields;
        this.records = new ArrayList<R>();
    }





    @Override
    public final void attach(Configuration c) {
        this.configuration = c;

        for (R record : records) {
            if (record != null) {
                record.attach(c);
            }
        }
    }

    @Override
    public final void detach() {
        attach(null);
    }

    @Override
    public final Configuration configuration() {
        return configuration;
    }





    @Override
    public final RecordType<R> recordType() {
        return fields;
    }

    @Override
    public final Row fieldsRow() {
        return new RowImpl(fields);
    }

    @Override
    public final <T> Field<T> field(Field<T> field) {
        return fields.field(field);
    }

    @Override
    public final Field<?> field(String name) {
        return fields.field(name);
    }

    @Override
    public final <T> Field<T> field(String name, Class<T> type) {
        return fields.field(name, type);
    }

    @Override
    public final <T> Field<T> field(String name, DataType<T> dataType) {
        return fields.field(name, dataType);
    }

    @Override
    public final Field<?> field(Name name) {
        return fields.field(name);
    }

    @Override
    public final <T> Field<T> field(Name name, Class<T> type) {
        return fields.field(name, type);
    }

    @Override
    public final <T> Field<T> field(Name name, DataType<T> dataType) {
        return fields.field(name, dataType);
    }

    @Override
    public final Field<?> field(int index) {
        return fields.field(index);
    }

    @Override
    public final <T> Field<T> field(int index, Class<T> type) {
        return fields.field(index, type);
    }

    @Override
    public final <T> Field<T> field(int index, DataType<T> dataType) {
        return fields.field(index, dataType);
    }

    @Override
    public final Field<?>[] fields() {
        return fields.fields().clone();
    }


    final Field<?>[] fields(Field<?>... f) {
        Field<?>[] result = new Field[f.length];

        for (int i = 0; i < f.length; i++)
            result[i] = field(f[i]);

        return result;
    }


    final Field<?>[] fields(int... indexes) {
        Field<?>[] result = new Field[indexes.length];

        for (int i = 0; i < indexes.length; i++)
            result[i] = field(indexes[i]);

        return result;
    }


    final Field<?>[] fields(String... names) {
        Field<?>[] result = new Field[names.length];

        for (int i = 0; i < names.length; i++)
            result[i] = field(names[i]);

        return result;
    }


    final Field<?>[] fields(Name... names) {
        Field<?>[] result = new Field[names.length];

        for (int i = 0; i < names.length; i++)
            result[i] = field(names[i]);

        return result;
    }

    @Override
    public final boolean isEmpty() {
        return records.isEmpty();
    }

    @Override
    public final boolean isNotEmpty() {
        return !records.isEmpty();
    }

    @Override
    public final <T> T getValue(int index, Field<T> field) {
        return get(index).getValue(field);
    }

    @Override
    @Deprecated
    public final <T> T getValue(int index, Field<T> field, T defaultValue) {
        return get(index).getValue(field, defaultValue);
    }

    @Override
    public final Object getValue(int index, int fieldIndex) {
        return get(index).getValue(fieldIndex);
    }

    @Override
    @Deprecated
    public final Object getValue(int index, int fieldIndex, Object defaultValue) {
        return get(index).getValue(fieldIndex, defaultValue);
    }

    @Override
    public final Object getValue(int index, String fieldName) {
        return get(index).getValue(fieldName);
    }

    @Override
    @Deprecated
    public final Object getValue(int index, String fieldName, Object defaultValue) {
        return get(index).getValue(fieldName, defaultValue);
    }

    @Override
    public final <T> List<T> getValues(Field<T> field) {
        return (List<T>) getValues(indexOrFail(fieldsRow(), field));
    }

    @Override
    public final <T> List<T> getValues(Field<?> field, Class<? extends T> type) {
        return Convert.convert(getValues(field), type);
    }

    @Override
    public final <T, U> List<U> getValues(Field<T> field, Converter<? super T, U> converter) {
        return Convert.convert(getValues(field), converter);
    }

    @Override
    public final List<?> getValues(int fieldIndex) {
        List<Object> result = new ArrayList<Object>(size());

        for (R record : this) {
            result.add(record.getValue(fieldIndex));
        }

        return result;
    }

    @Override
    public final <T> List<T> getValues(int fieldIndex, Class<? extends T> type) {
        return Convert.convert(getValues(fieldIndex), type);
    }

    @Override
    public final <U> List<U> getValues(int fieldIndex, Converter<?, U> converter) {
        return Convert.convert(getValues(fieldIndex), converter);
    }

    @Override
    public final List<?> getValues(String fieldName) {
        return getValues(field(fieldName));
    }

    @Override
    public final <T> List<T> getValues(String fieldName, Class<? extends T> type) {
        return Convert.convert(getValues(fieldName), type);
    }

    @Override
    public final <U> List<U> getValues(String fieldName, Converter<?, U> converter) {
        return Convert.convert(getValues(fieldName), converter);
    }

    @Override
    public final List<?> getValues(Name fieldName) {
        return getValues(field(fieldName));
    }

    @Override
    public final <T> List<T> getValues(Name fieldName, Class<? extends T> type) {
        return Convert.convert(getValues(fieldName), type);
    }

    @Override
    public final <U> List<U> getValues(Name fieldName, Converter<?, U> converter) {
        return Convert.convert(getValues(fieldName), converter);
    }

    final void addRecord(R record) {
        records.add(record);
    }

    @Override
    public final String format() {
        StringWriter writer = new StringWriter();
        format(writer);
        return writer.toString();
    }

    @Override
    public final void format(OutputStream stream) {
        format(new OutputStreamWriter(stream));
    }

    @Override
    public final void format(Writer writer) {
        format(writer, 50);
    }

    @Override
    public final String format(int maxRecords) {
        StringWriter writer = new StringWriter();
        format(writer, maxRecords);
        return writer.toString();
    }

    @Override
    public final void format(OutputStream stream, int maxRecords) {
        format(new OutputStreamWriter(stream), maxRecords);
    }

    @Override
    public final void format(Writer writer, int maxRecords) {
        try {
            final int COL_MIN_WIDTH = 4;
            final int COL_MAX_WIDTH = 50;


            final int NUM_COL_MAX_WIDTH = 100;


            final int MAX_RECORDS = min(50, maxRecords);


            final int[] decimalPlaces = new int[fields.fields.length];
            final int[] widths = new int[fields.fields.length];

            for (int index = 0; index < fields.fields.length; index++) {
                if (Number.class.isAssignableFrom(fields.fields[index].getType())) {
                    List<Integer> decimalPlacesList = new ArrayList<Integer>();


                    decimalPlacesList.add(0);


                    String value;
                    for (int i = 0; i < min(MAX_RECORDS, size()); i++) {
                        value = format0(getValue(i, index), get(i).changed(index), true);
                        decimalPlacesList.add(getDecimalPlaces(value));
                    }


                    decimalPlaces[index] = Collections.max(decimalPlacesList);
                }
            }


            int colMaxWidth;
            for (int index = 0; index < fields.fields.length; index++) {


                boolean isNumCol = Number.class.isAssignableFrom(fields.fields[index].getType());

                colMaxWidth = isNumCol ? NUM_COL_MAX_WIDTH : COL_MAX_WIDTH;


                List<Integer> widthList = new ArrayList<Integer>();


                widthList.add(min(colMaxWidth, max(COL_MIN_WIDTH, fields.fields[index].getName().length())));


                String value;
                for (int i = 0; i < min(MAX_RECORDS, size()); i++) {
                    value = format0(getValue(i, index), get(i).changed(index), true);

                    if (isNumCol) {
                        value = alignNumberValue(decimalPlaces[index], value);
                    }

                    widthList.add(min(colMaxWidth, value.length()));
                }


                widths[index] = Collections.max(widthList);
            }





            writer.append("+");
            for (int index = 0; index < fields.fields.length; index++) {
                writer.append(rightPad("", widths[index], "-"));
                writer.append("+");
            }


            writer.append("\n|");
            for (int index = 0; index < fields.fields.length; index++) {
                String padded;

                if (Number.class.isAssignableFrom(fields.fields[index].getType())) {
                    padded = leftPad(fields.fields[index].getName(), widths[index]);
                }
                else {
                    padded = rightPad(fields.fields[index].getName(), widths[index]);
                }

                writer.append(abbreviate(padded, widths[index]));
                writer.append("|");
            }


            writer.append("\n+");
            for (int index = 0; index < fields.fields.length; index++) {
                writer.append(rightPad("", widths[index], "-"));
                writer.append("+");
            }


            for (int i = 0; i < min(maxRecords, size()); i++) {
                writer.append("\n|");

                for (int index = 0; index < fields.fields.length; index++) {
                    String value = format0(getValue(i, index), get(i).changed(index), true).replace("\n", "{lf}").replace("\r", "{cr}");

                    String padded;
                    if (Number.class.isAssignableFrom(fields.fields[index].getType())) {

                        value = alignNumberValue(decimalPlaces[index], value);


                        padded = leftPad(value, widths[index]);
                    }
                    else {

                        padded = rightPad(value, widths[index]);
                    }

                    writer.append(abbreviate(padded, widths[index]));
                    writer.append("|");
                }
            }


            if (size() > 0) {
                writer.append("\n+");

                for (int index = 0; index < fields.fields.length; index++) {
                    writer.append(rightPad("", widths[index], "-"));
                    writer.append("+");
                }
            }


            if (maxRecords < size()) {
                writer.append("\n|...");
                writer.append("" + (size() - maxRecords));
                writer.append(" record(s) truncated...");
            }
        }
        catch (java.io.IOException e) {
            throw new IOException("Exception while writing TEXT", e);
        }
    }

    private static final String alignNumberValue(Integer columnDecimalPlaces, String value) {
        if (!"{null}".equals(value) && columnDecimalPlaces != 0) {
            int decimalPlaces = getDecimalPlaces(value);
            int rightPadSize = value.length() + columnDecimalPlaces - decimalPlaces;

            if (decimalPlaces == 0) {

                value = rightPad(value, rightPadSize + 1);
            }
            else {
                value = rightPad(value, rightPadSize);
            }
        }

        return value;
    }

    private static final int getDecimalPlaces(String value) {
        int decimalPlaces = 0;

        int dotIndex = value.indexOf(".");
        if (dotIndex != -1) {
            decimalPlaces = value.length() - dotIndex - 1;
        }

        return decimalPlaces;
    }

    @Override
    public final String formatHTML() {
        StringWriter writer = new StringWriter();
        formatHTML(writer);
        return writer.toString();
    }

    @Override
    public final void formatHTML(OutputStream stream) {
        formatHTML(new OutputStreamWriter(stream));
    }

    @Override
    public final void formatHTML(Writer writer) {
        try {
            writer.append("<table>");
            writer.append("<thead>");
            writer.append("<tr>");

            for (Field<?> field : fields.fields) {
                writer.append("<th>");
                writer.append(field.getName());
                writer.append("</th>");
            }

            writer.append("</tr>");
            writer.append("</thead>");
            writer.append("<tbody>");

            for (Record record : this) {
                writer.append("<tr>");

                for (int index = 0; index < fields.fields.length; index++) {
                    writer.append("<td>");
                    writer.append(format0(record.getValue(index), false, true));
                    writer.append("</td>");
                }

                writer.append("</tr>");
            }

            writer.append("</tbody>");
            writer.append("</table>");
        }
        catch (java.io.IOException e) {
            throw new IOException("Exception while writing HTML", e);
        }
    }

    @Override
    public final String formatCSV() {
        return formatCSV(true);
    }

    @Override
    public final String formatCSV(boolean header) {
        StringWriter writer = new StringWriter();
        formatCSV(writer, header);
        return writer.toString();
    }

    @Override
    public final void formatCSV(OutputStream stream) {
        formatCSV(stream, true);
    }

    @Override
    public final void formatCSV(OutputStream stream, boolean header) {
        formatCSV(new OutputStreamWriter(stream), header);
    }

    @Override
    public final void formatCSV(Writer writer) {
        formatCSV(writer, true);
    }

    @Override
    public final void formatCSV(Writer writer, boolean header) {
        formatCSV(writer, header, ',', "");
    }

    @Override
    public final String formatCSV(char delimiter) {
        return formatCSV(true, delimiter);
    }

    @Override
    public final String formatCSV(boolean header, char delimiter) {
        StringWriter writer = new StringWriter();
        formatCSV(writer, delimiter);
        return writer.toString();
    }

    @Override
    public final void formatCSV(OutputStream stream, char delimiter) {
        formatCSV(stream, true, delimiter);
    }

    @Override
    public final void formatCSV(OutputStream stream, boolean header, char delimiter) {
        formatCSV(new OutputStreamWriter(stream), delimiter);
    }

    @Override
    public final void formatCSV(Writer writer, char delimiter) {
        formatCSV(writer, true, delimiter);
    }

    @Override
    public final void formatCSV(Writer writer, boolean header, char delimiter) {
        formatCSV(writer, header, delimiter, "");
    }

    @Override
    public final String formatCSV(char delimiter, String nullString) {
        return formatCSV(true, delimiter, nullString);
    }

    @Override
    public final String formatCSV(boolean header, char delimiter, String nullString) {
        StringWriter writer = new StringWriter();
        formatCSV(writer, header, delimiter, nullString);
        return writer.toString();
    }

    @Override
    public final void formatCSV(OutputStream stream, char delimiter, String nullString) {
        formatCSV(stream, true, delimiter, nullString);
    }

    @Override
    public final void formatCSV(OutputStream stream, boolean header, char delimiter, String nullString) {
        formatCSV(new OutputStreamWriter(stream), header, delimiter, nullString);
    }

    @Override
    public final void formatCSV(Writer writer, char delimiter, String nullString) {
        formatCSV(writer, true, delimiter, nullString);
    }

    @Override
    public final void formatCSV(Writer writer, boolean header, char delimiter, String nullString) {
        try {
            if (header) {
                String sep1 = "";
                for (Field<?> field : fields.fields) {
                    writer.append(sep1);
                    writer.append(formatCSV0(field.getName(), ""));

                    sep1 = Character.toString(delimiter);
                }

                writer.append("\n");
            }

            for (Record record : this) {
                String sep2 = "";

                for (int index = 0; index < fields.fields.length; index++) {
                    writer.append(sep2);
                    writer.append(formatCSV0(record.getValue(index), nullString));

                    sep2 = Character.toString(delimiter);
                }

                writer.append("\n");
            }
        }
        catch (java.io.IOException e) {
            throw new IOException("Exception while writing CSV", e);
        }
    }

    private final String formatCSV0(Object value, String nullString) {


        if (value == null || "".equals(value)) {
            if (StringUtils.isEmpty(nullString)) {
                return "\"\"";
            }
            else {
                return nullString;
            }
        }

        String result = format0(value, false, false);

        if (StringUtils.containsAny(result, ',', ';', '\t', '"', '\n', '\r', '\'', '\\')) {
            return "\"" + result.replace("\\", "\\\\").replace("\"", "\"\"") + "\"";
        }
        else {
            return result;
        }
    }

    private final Object formatJSON0(Object value) {
        if (value instanceof byte[])
            return DatatypeConverter.printBase64Binary((byte[]) value);

        return value;
    }


    private static final String format0(Object value, boolean changed, boolean visual) {
        String formatted = changed && visual ? "*" : "";

        if (value == null) {
            formatted += visual ? "{null}" : null;
        }
        else if (value.getClass() == byte[].class) {
            formatted += DatatypeConverter.printBase64Binary((byte[]) value);
        }
        else if (value.getClass().isArray()) {
            formatted += Arrays.toString((Object[]) value);
        }
        else if (value instanceof EnumType) {
            formatted += ((EnumType) value).getLiteral();
        }
        else if (value instanceof Record) {
            formatted += ((Record) value).valuesRow().toString();
        }
        else {
            formatted += value.toString();
        }

        return formatted;
    }

    @Override
    public final String formatJSON() {
        StringWriter writer = new StringWriter();
        formatJSON(writer);
        return writer.toString();
    }

    @Override
    public final void formatJSON(OutputStream stream) {
        formatJSON(new OutputStreamWriter(stream));
    }

    @Override
    public final void formatJSON(Writer writer) {
        try {
            List<Map<String, String>> f = new ArrayList<Map<String, String>>();
            List<List<Object>> r = new ArrayList<List<Object>>();

            Map<String, String> fieldMap;
            for (Field<?> field : fields.fields) {
                fieldMap = new LinkedHashMap<String, String>();
                fieldMap.put("name", field.getName());
                fieldMap.put("type", field.getDataType().getTypeName().toUpperCase());

                f.add(fieldMap);
            }

            for (Record record : this) {
                List<Object> list = new ArrayList<Object>();

                for (int index = 0; index < fields.fields.length; index++) {
                    list.add(formatJSON0(record.getValue(index)));
                }

                r.add(list);
            }

            Map<String, List<?>> map = new LinkedHashMap<String, List<?>>();

            map.put("fields", f);
            map.put("records", r);

            writer.append(JSONObject.toJSONString(map));
        }
        catch (java.io.IOException e) {
            throw new IOException("Exception while writing JSON", e);
        }
    }

    @Override
    public final String formatXML() {
        StringWriter writer = new StringWriter();
        formatXML(writer);
        return writer.toString();
    }

    @Override
    public final void formatXML(OutputStream stream) {
        formatXML(new OutputStreamWriter(stream));
    }

    @Override
    public final void formatXML(Writer writer) {
        try {
            writer.append("<result xmlns=\"http://www.jooq.org/xsd/jooq-export-2.6.0.xsd\">");
            writer.append("<fields>");

            for (Field<?> field : fields.fields) {
                writer.append("<field name=\"");
                writer.append(escapeXML(field.getName()));
                writer.append("\" ");
                writer.append("type=\"");
                writer.append(field.getDataType().getTypeName().toUpperCase());
                writer.append("\"/>");
            }

            writer.append("</fields>");
            writer.append("<records>");

            for (Record record : this) {
                writer.append("<record>");

                for (int index = 0; index < fields.fields.length; index++) {
                    Object value = record.getValue(index);

                    writer.append("<value field=\"");
                    writer.append(escapeXML(fields.fields[index].getName()));
                    writer.append("\"");

                    if (value == null) {
                        writer.append("/>");
                    }
                    else {
                        writer.append(">");
                        writer.append(escapeXML(format0(value, false, false)));
                        writer.append("</value>");
                    }
                }

                writer.append("</record>");
            }

            writer.append("</records>");
            writer.append("</result>");
        }
        catch (java.io.IOException e) {
            throw new IOException("Exception while writing XML", e);
        }
    }

    @Override
    public final String formatInsert() {
        StringWriter writer = new StringWriter();
        formatInsert(writer);
        return writer.toString();
    }

    @Override
    public final void formatInsert(OutputStream stream) {
        formatInsert(new OutputStreamWriter(stream));
    }

    @Override
    public final void formatInsert(Writer writer) {
        Table<?> table = null;

        if (records.size() > 0 && records.get(0) instanceof TableRecord)
            table = ((TableRecord<?>) records.get(0)).getTable();

        if (table == null)
            table = table(name("UNKNOWN_TABLE"));

        formatInsert(writer, table, fields());
    }

    @Override
    public final String formatInsert(Table<?> table, Field<?>... f) {
        StringWriter writer = new StringWriter();
        formatInsert(writer, table, f);
        return writer.toString();
    }

    @Override
    public final void formatInsert(OutputStream stream, Table<?> table, Field<?>... f) {
        formatInsert(new OutputStreamWriter(stream), table, f);
    }

    @Override
    public final void formatInsert(Writer writer, Table<?> table, Field<?>... f) {
        DSLContext ctx = DSL.using(configuration());

        try {
            for (R record : this) {
                writer.append(ctx.renderInlined(insertInto(table, f).values(record.intoArray())));
                writer.append(";\n");
            }
        }
        catch (java.io.IOException e) {
            throw new IOException("Exception while writing INSERTs", e);
        }
    }

    @Override
    public final Document intoXML() {
        try {
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();
            Document document = builder.newDocument();

            Element eResult = document.createElement("result");
            eResult.setAttribute("xmlns", "http://www.jooq.org/xsd/jooq-export-2.6.0.xsd");
            document.appendChild(eResult);

            Element eFields = document.createElement("fields");
            eResult.appendChild(eFields);

            for (Field<?> field : fields.fields) {
                Element eField = document.createElement("field");
                eField.setAttribute("name", field.getName());
                eField.setAttribute("type", field.getDataType().getTypeName().toUpperCase());
                eFields.appendChild(eField);
            }

            Element eRecords = document.createElement("records");
            eResult.appendChild(eRecords);

            for (Record record : this) {
                Element eRecord = document.createElement("record");
                eRecords.appendChild(eRecord);

                for (int index = 0; index < fields.fields.length; index++) {
                    Field<?> field = fields.fields[index];
                    Object value = record.getValue(index);

                    Element eValue = document.createElement("value");
                    eValue.setAttribute("field", field.getName());
                    eRecord.appendChild(eValue);

                    if (value != null) {
                        eValue.setTextContent(format0(value, false, false));
                    }
                }
            }

            return document;
        }
        catch (ParserConfigurationException ignore) {
            throw new RuntimeException(ignore);
        }
    }

    @Override
    public final <H extends ContentHandler> H intoXML(H handler) throws SAXException {
        Attributes empty = new AttributesImpl();

        handler.startDocument();
        handler.startPrefixMapping("", "http://www.jooq.org/xsd/jooq-export-2.6.0.xsd");
        handler.startElement("", "", "result", empty);
        handler.startElement("", "", "fields", empty);

        for (Field<?> field : fields.fields) {
            AttributesImpl attrs = new AttributesImpl();
            attrs.addAttribute("", "", "name", "CDATA", field.getName());
            attrs.addAttribute("", "", "type", "CDATA", field.getDataType().getTypeName().toUpperCase());

            handler.startElement("", "", "field", attrs);
            handler.endElement("", "", "field");
        }

        handler.endElement("", "", "fields");
        handler.startElement("", "", "records", empty);

        for (Record record : this) {
            handler.startElement("", "", "record", empty);

            for (int index = 0; index < fields.fields.length; index++) {
                Field<?> field = fields.fields[index];
                Object value = record.getValue(index);

                AttributesImpl attrs = new AttributesImpl();
                attrs.addAttribute("", "", "field", "CDATA", field.getName());

                handler.startElement("", "", "value", attrs);

                if (value != null) {
                    char[] chars = format0(value, false, false).toCharArray();
                    handler.characters(chars, 0, chars.length);
                }

                handler.endElement("", "", "value");
            }

            handler.endElement("", "", "record");
        }

        handler.endElement("", "", "records");
        handler.endPrefixMapping("");
        handler.endDocument();
        return handler;
    }

    private final String escapeXML(String string) {
        return StringUtils.replaceEach(string,
            new String[] { "\"", "'", "<", ">", "&" },
            new String[] { "&quot;", "&apos;", "&lt;", "&gt;", "&amp;"});
    }

    @Override
    public final List<Map<String, Object>> intoMaps() {
        List<Map<String, Object>> list = new ArrayList<Map<String, Object>>();

        for (R record : this) {
            list.add(record.intoMap());
        }

        return list;
    }

    @Override
    public final <K> Map<K, R> intoMap(Field<K> key) {
        return intoMap0(indexOrFail(fieldsRow(), key));
    }

    @Override
    public final Map<?, R> intoMap(int keyFieldIndex) {
        return intoMap0(keyFieldIndex);
    }

    @Override
    public final Map<?, R> intoMap(String keyFieldName) {
        return intoMap(field(keyFieldName));
    }

    @Override
    public final Map<?, R> intoMap(Name keyFieldName) {
        return intoMap(field(keyFieldName));
    }

    private final <K> Map<K, R> intoMap0(int keyFieldIndex) {
        Map<K, R> map = new LinkedHashMap<K, R>();

        for (R record : this)
            if (map.put((K) record.getValue(keyFieldIndex), record) != null)
                throw new InvalidResultException("Key " + keyFieldIndex + " is not unique in Result for " + this);

        return map;
    }

    @Override
    public final <K, V> Map<K, V> intoMap(Field<K> key, Field<V> value) {
        int kIndex = indexOrFail(fieldsRow(), key);
        int vIndex = indexOrFail(fieldsRow(), value);

        return intoMap0(kIndex, vIndex);
    }

    @Override
    public final Map<?, ?> intoMap(int keyFieldIndex, int valueFieldIndex) {
        return intoMap0(keyFieldIndex, valueFieldIndex);
    }

    @Override
    public final Map<?, ?> intoMap(String keyFieldName, String valueFieldName) {
        return intoMap(field(keyFieldName), field(valueFieldName));
    }

    @Override
    public final Map<?, ?> intoMap(Name keyFieldName, Name valueFieldName) {
        return intoMap(field(keyFieldName), field(valueFieldName));
    }

    private final <K, V> Map<K, V> intoMap0(int kIndex, int vIndex) {
        Map<K, V> map = new LinkedHashMap<K, V>();

        for (R record : this)
            if (map.put((K) record.getValue(kIndex), (V) record.getValue(vIndex)) != null)
                throw new InvalidResultException("Key " + kIndex + " is not unique in Result for " + this);

        return map;
    }

    @Override
    public final Map<Record, R> intoMap(int[] keyFieldIndexes) {
        return intoMap(fields(keyFieldIndexes));
    }

    @Override
    public final Map<Record, R> intoMap(String[] keyFieldNames) {
        return intoMap(fields(keyFieldNames));
    }

    @Override
    public final Map<Record, R> intoMap(Name[] keyFieldNames) {
        return intoMap(fields(keyFieldNames));
    }

    @Override
    public final Map<Record, R> intoMap(Field<?>[] keys) {
        if (keys == null) {
            keys = new Field[0];
        }

        Map<Record, R> map = new LinkedHashMap<Record, R>();
        for (R record : this) {
            RecordImpl key = new RecordImpl(keys);

            for (Field<?> field : keys) {
                Utils.copyValue(key, field, record, field);
            }

            if (map.put(key, record) != null) {
                throw new InvalidResultException("Key list " + Arrays.asList(keys) + " is not unique in Result for " + this);
            }
        }

        return map;
    }

    @Override
    public final <E> Map<List<?>, E> intoMap(int[] keyFieldIndexes, Class<? extends E> type) {
        return intoMap(fields(keyFieldIndexes), type);
    }

    @Override
    public final <E> Map<List<?>, E> intoMap(String[] keyFieldNames, Class<? extends E> type) {
        return intoMap(fields(keyFieldNames), type);
    }

    @Override
    public final <E> Map<List<?>, E> intoMap(Name[] keyFieldNames, Class<? extends E> type) {
        return intoMap(fields(keyFieldNames), type);
    }

    @Override
    public final <E> Map<List<?>, E> intoMap(Field<?>[] keys, Class<? extends E> type) {
        return intoMap(keys, Utils.configuration(this).recordMapperProvider().provide(fields, type));
    }

    @Override
    public final <E> Map<List<?>, E> intoMap(int[] keyFieldIndexes, RecordMapper<? super R, E> mapper) {
        return intoMap(fields(keyFieldIndexes), mapper);
    }

    @Override
    public final <E> Map<List<?>, E> intoMap(String[] keyFieldNames, RecordMapper<? super R, E> mapper) {
        return intoMap(fields(keyFieldNames), mapper);
    }

    @Override
    public final <E> Map<List<?>, E> intoMap(Name[] keyFieldNames, RecordMapper<? super R, E> mapper) {
        return intoMap(fields(keyFieldNames), mapper);
    }

    @Override
    public final <E> Map<List<?>, E> intoMap(Field<?>[] keys, RecordMapper<? super R, E> mapper) {
        if (keys == null) {
            keys = new Field[0];
        }

        Map<List<?>, E> map = new LinkedHashMap<List<?>, E>();

        for (R record : this) {
            List<Object> keyValueList = new ArrayList<Object>();
            for (Field<?> key : keys) {
                keyValueList.add(record.getValue(key));
            }

            if (map.put(keyValueList, mapper.map(record)) != null) {
                throw new InvalidResultException("Key list " + keyValueList + " is not unique in Result for " + this);
            }
        }

        return map;
    }

    @Override
    public final <S extends Record> Map<S, R> intoMap(Table<S> table) {
        Map<S, R> map = new LinkedHashMap<S, R>();

        for (R record : this) {
            S key = record.into(table);

            if (map.put(key, record) != null) {
                throw new InvalidResultException("Key list " + key + " is not unique in Result for " + this);
            }
        }

        return map;
    }

    @Override
    public final <E, S extends Record> Map<S, E> intoMap(Table<S> table, Class<? extends E> type) {
        return intoMap(table, Utils.configuration(this).recordMapperProvider().provide(fields, type));
    }

    @Override
    public final <E, S extends Record> Map<S, E> intoMap(Table<S> table, RecordMapper<? super R, E> mapper) {
        Map<S, E> map = new LinkedHashMap<S, E>();

        for (R record : this) {
            S key = record.into(table);

            if (map.put(key, mapper.map(record)) != null) {
                throw new InvalidResultException("Key list " + key + " is not unique in Result for " + this);
            }
        }

        return map;
    }

    @Override
    public final <E> Map<?, E> intoMap(int keyFieldIndex, Class<? extends E> type) {
        return intoMap(keyFieldIndex, Utils.configuration(this).recordMapperProvider().provide(fields, type));
    }

    @Override
    public final <E> Map<?, E> intoMap(String keyFieldName, Class<? extends E> type) {
        return intoMap(keyFieldName, Utils.configuration(this).recordMapperProvider().provide(fields, type));
    }

    @Override
    public final <E> Map<?, E> intoMap(Name keyFieldName, Class<? extends E> type) {
        return intoMap(keyFieldName, Utils.configuration(this).recordMapperProvider().provide(fields, type));
    }

    @Override
    public final <K, E> Map<K, E> intoMap(Field<K> key, Class<? extends E> type) {
        return intoMap(key, Utils.configuration(this).recordMapperProvider().provide(fields, type));
    }

    @Override
    public final <E> Map<?, E> intoMap(int keyFieldIndex, RecordMapper<? super R, E> mapper) {
        return intoMap0(keyFieldIndex, mapper);
    }

    @Override
    public final <E> Map<?, E> intoMap(String keyFieldName, RecordMapper<? super R, E> mapper) {
        return intoMap(field(keyFieldName), mapper);
    }

    @Override
    public final <E> Map<?, E> intoMap(Name keyFieldName, RecordMapper<? super R, E> mapper) {
        return intoMap(field(keyFieldName), mapper);
    }

    @Override
    public final <K, E> Map<K, E> intoMap(Field<K> key, RecordMapper<? super R, E> mapper) {
        return intoMap0(indexOrFail(fieldsRow(), key), mapper);
    }

    private final <K, E> Map<K, E> intoMap0(int keyFieldIndex, RecordMapper<? super R, E> mapper) {
        Map<K, E> map = new LinkedHashMap<K, E>();

        for (R record : this)
            if (map.put((K) record.getValue(keyFieldIndex), mapper.map(record)) != null)
                throw new InvalidResultException("Key " + keyFieldIndex + " is not unique in Result for " + this);

        return map;
    }

    @Override
    public final <K> Map<K, Result<R>> intoGroups(Field<K> key) {
        return intoGroups0(indexOrFail(fieldsRow(), key));
    }

    @Override
    public final Map<?, Result<R>> intoGroups(int keyFieldIndex) {
        return intoGroups0(keyFieldIndex);
    }

    @Override
    public final Map<?, Result<R>> intoGroups(String keyFieldName) {
        return intoGroups(field(keyFieldName));
    }

    @Override
    public final Map<?, Result<R>> intoGroups(Name keyFieldName) {
        return intoGroups(field(keyFieldName));
    }

    private final <K> Map<K, Result<R>> intoGroups0(int keyFieldIndex) {
        Map<K, Result<R>> map = new LinkedHashMap<K, Result<R>>();

        for (R record : this) {
            K val = (K) record.getValue(keyFieldIndex);
            Result<R> result = map.get(val);

            if (result == null) {
                result = new ResultImpl<R>(configuration, fields);
                map.put(val, result);
            }

            result.add(record);
        }

        return map;
    }

    @Override
    public final <K, V> Map<K, List<V>> intoGroups(Field<K> key, Field<V> value) {
        int kIndex = indexOrFail(fieldsRow(), key);
        int vIndex = indexOrFail(fieldsRow(), value);

        return intoGroups0(kIndex, vIndex);
    }

    @Override
    public final Map<?, List<?>> intoGroups(int keyFieldIndex, int valueFieldIndex) {
        return (Map) intoGroups0(keyFieldIndex, valueFieldIndex);
    }

    @Override
    public final Map<?, List<?>> intoGroups(String keyFieldName, String valueFieldName) {
        return (Map) intoGroups(field(keyFieldName), field(valueFieldName));
    }

    @Override
    public final Map<?, List<?>> intoGroups(Name keyFieldName, Name valueFieldName) {
        return (Map) intoGroups(field(keyFieldName), field(valueFieldName));
    }

    private final <K, V> Map<K, List<V>> intoGroups0(int kIndex, int vIndex) {
        Map<K, List<V>> map = new LinkedHashMap<K, List<V>>();

        for (R record : this) {
            K k = (K) record.getValue(kIndex);
            V v = (V) record.getValue(vIndex);
            List<V> result = map.get(k);

            if (result == null) {
                result = new ArrayList<V>();
                map.put(k, result);
            }

            result.add(v);
        }

        return map;
    }

    @Override
    public final <E> Map<?, List<E>> intoGroups(int keyFieldIndex, Class<? extends E> type) {
        return intoGroups(keyFieldIndex, Utils.configuration(this).recordMapperProvider().provide(fields, type));
    }

    @Override
    public final <E> Map<?, List<E>> intoGroups(String keyFieldName, Class<? extends E> type) {
        return intoGroups(keyFieldName, Utils.configuration(this).recordMapperProvider().provide(fields, type));
    }

    @Override
    public final <E> Map<?, List<E>> intoGroups(Name keyFieldName, Class<? extends E> type) {
        return intoGroups(keyFieldName, Utils.configuration(this).recordMapperProvider().provide(fields, type));
    }

    @Override
    public final <K, E> Map<K, List<E>> intoGroups(Field<K> key, Class<? extends E> type) {
        return intoGroups(key, Utils.configuration(this).recordMapperProvider().provide(fields, type));
    }

    @Override
    public final <K, E> Map<K, List<E>> intoGroups(Field<K> key, RecordMapper<? super R, E> mapper) {
        return intoGroups0(indexOrFail(fieldsRow(), key), mapper);
    }

    @Override
    public final <E> Map<?, List<E>> intoGroups(int keyFieldIndex, RecordMapper<? super R, E> mapper) {
        return intoGroups0(keyFieldIndex, mapper);
    }

    @Override
    public final <E> Map<?, List<E>> intoGroups(String keyFieldName, RecordMapper<? super R, E> mapper) {
        return intoGroups(field(keyFieldName), mapper);
    }

    @Override
    public final <E> Map<?, List<E>> intoGroups(Name keyFieldName, RecordMapper<? super R, E> mapper) {
        return intoGroups(field(keyFieldName), mapper);
    }

    private final <K, E> Map<K, List<E>> intoGroups0(int keyFieldIndex, RecordMapper<? super R, E> mapper) {
        Map<K, List<E>> map = new LinkedHashMap<K, List<E>>();

        for (R record : this) {
            K keyVal = (K) record.getValue(keyFieldIndex);

            List<E> list = map.get(keyVal);
            if (list == null) {
                list = new ArrayList<E>();
                map.put(keyVal, list);
            }

            list.add(mapper.map(record));
        }

        return map;
    }

    @Override
    public final Map<Record, Result<R>> intoGroups(int[] keyFieldIndexes) {
        return intoGroups(fields(keyFieldIndexes));
    }

    @Override
    public final Map<Record, Result<R>> intoGroups(String[] keyFieldNames) {
        return intoGroups(fields(keyFieldNames));
    }

    @Override
    public final Map<Record, Result<R>> intoGroups(Name[] keyFieldNames) {
        return intoGroups(fields(keyFieldNames));
    }

    @Override
    public final Map<Record, Result<R>> intoGroups(Field<?>[] keys) {
        if (keys == null) {
            keys = new Field[0];
        }

        Map<Record, Result<R>> map = new LinkedHashMap<Record, Result<R>>();
        for (R record : this) {
            RecordImpl key = new RecordImpl(keys);

            for (Field<?> field : keys) {
                Utils.copyValue(key, field, record, field);
            }

            Result<R> result = map.get(key);
            if (result == null) {
                result = new ResultImpl<R>(configuration(), this.fields);
                map.put(key, result);
            }

            result.add(record);
        }

        return map;
    }

    @Override
    public <E> Map<Record, List<E>> intoGroups(int[] keyFieldIndexes, Class<? extends E> type) {
        return intoGroups(keyFieldIndexes, Utils.configuration(this).recordMapperProvider().provide(fields, type));
    }

    @Override
    public <E> Map<Record, List<E>> intoGroups(String[] keyFieldNames, Class<? extends E> type) {
        return intoGroups(keyFieldNames, Utils.configuration(this).recordMapperProvider().provide(fields, type));
    }

    @Override
    public <E> Map<Record, List<E>> intoGroups(Name[] keyFieldNames, Class<? extends E> type) {
        return intoGroups(keyFieldNames, Utils.configuration(this).recordMapperProvider().provide(fields, type));
    }

    @Override
    public final <E> Map<Record, List<E>> intoGroups(Field<?>[] keys, Class<? extends E> type) {
        return intoGroups(keys, Utils.configuration(this).recordMapperProvider().provide(fields, type));
    }

    @Override
    public final <E> Map<Record, List<E>> intoGroups(int[] keyFieldIndexes, RecordMapper<? super R, E> mapper) {
        return intoGroups(fields(keyFieldIndexes), mapper);
    }

    @Override
    public final <E> Map<Record, List<E>> intoGroups(String[] keyFieldNames, RecordMapper<? super R, E> mapper) {
        return intoGroups(fields(keyFieldNames), mapper);
    }

    @Override
    public final <E> Map<Record, List<E>> intoGroups(Name[] keyFieldNames, RecordMapper<? super R, E> mapper) {
        return intoGroups(fields(keyFieldNames), mapper);
    }

    @Override
    public final <E> Map<Record, List<E>> intoGroups(Field<?>[] keys, RecordMapper<? super R, E> mapper) {
        if (keys == null) {
            keys = new Field[0];
        }

        Map<Record, List<E>> map = new LinkedHashMap<Record, List<E>>();
        for (R record : this) {
            RecordImpl key = new RecordImpl(keys);

            for (Field<?> field : keys) {
                Utils.copyValue(key, field, record, field);
            }

            List<E> list = map.get(key);
            if (list == null) {
                list = new ArrayList<E>();
                map.put(key, list);
            }

            list.add(mapper.map(record));
        }

        return map;
    }

    @Override
    public final <S extends Record> Map<S, Result<R>> intoGroups(Table<S> table) {
        Map<S, Result<R>> map = new LinkedHashMap<S, Result<R>>();

        for (R record : this) {
            S key = record.into(table);

            Result<R> result = map.get(key);
            if (result == null) {
                result = new ResultImpl<R>(configuration(), this.fields);
                map.put(key, result);
            }

            result.add(record);
        }

        return map;
    }

    @Override
    public final <E, S extends Record> Map<S, List<E>> intoGroups(Table<S> table, Class<? extends E> type) {
        return intoGroups(table, Utils.configuration(this).recordMapperProvider().provide(fields, type));
    }

    @Override
    public final <E, S extends Record> Map<S, List<E>> intoGroups(Table<S> table, RecordMapper<? super R, E> mapper) {
        Map<S, List<E>> map = new LinkedHashMap<S, List<E>>();

        for (R record : this) {
            S key = record.into(table);

            List<E> list = map.get(key);
            if (list == null) {
                list = new ArrayList<E>();
                map.put(key, list);
            }

            list.add(mapper.map(record));
        }

        return map;
    }

    @Override
    @Deprecated
    public final Object[][] intoArray() {
        return intoArrays();
    }

    @Override
    public final Object[][] intoArrays() {
        int size = size();
        Object[][] array = new Object[size][];

        for (int i = 0; i < size; i++) {
            array[i] = get(i).intoArray();
        }

        return array;
    }

    @Override
    public final Object[] intoArray(int fieldIndex) {
        Class<?> type = fields.fields[fieldIndex].getType();
        List<?> list = getValues(fieldIndex);
        return list.toArray((Object[]) Array.newInstance(type, list.size()));
    }

    @Override
    public final <T> T[] intoArray(int fieldIndex, Class<? extends T> type) {
        return (T[]) Convert.convertArray(intoArray(fieldIndex), type);
    }

    @Override
    public final <U> U[] intoArray(int fieldIndex, Converter<?, U> converter) {
        return Convert.convertArray(intoArray(fieldIndex), converter);
    }

    @Override
    public final Object[] intoArray(String fieldName) {
        Class<?> type = field(fieldName).getType();
        List<?> list = getValues(fieldName);
        return list.toArray((Object[]) Array.newInstance(type, list.size()));
    }

    @Override
    public final <T> T[] intoArray(String fieldName, Class<? extends T> type) {
        return (T[]) Convert.convertArray(intoArray(fieldName), type);
    }

    @Override
    public final <U> U[] intoArray(String fieldName, Converter<?, U> converter) {
        return Convert.convertArray(intoArray(fieldName), converter);
    }

    @Override
    public final Object[] intoArray(Name fieldName) {
        Class<?> type = field(fieldName).getType();
        List<?> list = getValues(fieldName);
        return list.toArray((Object[]) Array.newInstance(type, list.size()));
    }

    @Override
    public final <T> T[] intoArray(Name fieldName, Class<? extends T> type) {
        return (T[]) Convert.convertArray(intoArray(fieldName), type);
    }

    @Override
    public final <U> U[] intoArray(Name fieldName, Converter<?, U> converter) {
        return Convert.convertArray(intoArray(fieldName), converter);
    }

    @Override
    public final <T> T[] intoArray(Field<T> field) {
        return getValues(field).toArray((T[]) Array.newInstance(field.getType(), 0));
    }

    @Override
    public final <T> T[] intoArray(Field<?> field, Class<? extends T> type) {
        return (T[]) Convert.convertArray(intoArray(field), type);
    }

    @Override
    public final <T, U> U[] intoArray(Field<T> field, Converter<? super T, U> converter) {
        return Convert.convertArray(intoArray(field), converter);
    }

    @Override
    public final Set<?> intoSet(int fieldIndex) {
        return new LinkedHashSet<Object>(getValues(fieldIndex));
    }

    @Override
    public final <T> Set<T> intoSet(int fieldIndex, Class<? extends T> type) {
        return new LinkedHashSet<T>(getValues(fieldIndex, type));
    }

    @Override
    public final <U> Set<U> intoSet(int fieldIndex, Converter<?, U> converter) {
        return new LinkedHashSet<U>(getValues(fieldIndex, converter));
    }

    @Override
    public final Set<?> intoSet(String fieldName) {
        return new LinkedHashSet<Object>(getValues(fieldName));
    }

    @Override
    public final <T> Set<T> intoSet(String fieldName, Class<? extends T> type) {
        return new LinkedHashSet<T>(getValues(fieldName, type));
    }

    @Override
    public final <U> Set<U> intoSet(String fieldName, Converter<?, U> converter) {
        return new LinkedHashSet<U>(getValues(fieldName, converter));
    }

    @Override
    public final Set<?> intoSet(Name fieldName) {
        return new LinkedHashSet<Object>(getValues(fieldName));
    }

    @Override
    public final <T> Set<T> intoSet(Name fieldName, Class<? extends T> type) {
        return new LinkedHashSet<T>(getValues(fieldName, type));
    }

    @Override
    public final <U> Set<U> intoSet(Name fieldName, Converter<?, U> converter) {
        return new LinkedHashSet<U>(getValues(fieldName, converter));
    }

    @Override
    public final <T> Set<T> intoSet(Field<T> field) {
        return new LinkedHashSet<T>(getValues(field));
    }

    @Override
    public final <T> Set<T> intoSet(Field<?> field, Class<? extends T> type) {
        return new LinkedHashSet<T>(getValues(field, type));
    }

    @Override
    public final <T, U> Set<U> intoSet(Field<T> field, Converter<? super T, U> converter) {
        return new LinkedHashSet<U>(getValues(field, converter));
    }

    @Override
    public final Result<Record> into(Field<?>... f) {
        Result<Record> result = new ResultImpl<Record>(Utils.configuration(this), f);

        for (Record record : this)
            result.add(record.into(f));

        return result;
    }



    @Override
    public final <T1> Result<Record1<T1>> into(Field<T1> field1) {
        return (Result) into(new Field[] { field1 });
    }

    @Override
    public final <T1, T2> Result<Record2<T1, T2>> into(Field<T1> field1, Field<T2> field2) {
        return (Result) into(new Field[] { field1, field2 });
    }

    @Override
    public final <T1, T2, T3> Result<Record3<T1, T2, T3>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3) {
        return (Result) into(new Field[] { field1, field2, field3 });
    }

    @Override
    public final <T1, T2, T3, T4> Result<Record4<T1, T2, T3, T4>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4) {
        return (Result) into(new Field[] { field1, field2, field3, field4 });
    }

    @Override
    public final <T1, T2, T3, T4, T5> Result<Record5<T1, T2, T3, T4, T5>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5 });
    }

    @Override
    public final <T1, T2, T3, T4, T5, T6> Result<Record6<T1, T2, T3, T4, T5, T6>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5, field6 });
    }

    @Override
    public final <T1, T2, T3, T4, T5, T6, T7> Result<Record7<T1, T2, T3, T4, T5, T6, T7>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5, field6, field7 });
    }

    @Override
    public final <T1, T2, T3, T4, T5, T6, T7, T8> Result<Record8<T1, T2, T3, T4, T5, T6, T7, T8>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5, field6, field7, field8 });
    }

    @Override
    public final <T1, T2, T3, T4, T5, T6, T7, T8, T9> Result<Record9<T1, T2, T3, T4, T5, T6, T7, T8, T9>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9 });
    }

    @Override
    public final <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> Result<Record10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10 });
    }

    @Override
    public final <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> Result<Record11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11 });
    }

    @Override
    public final <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> Result<Record12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12 });
    }

    @Override
    public final <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> Result<Record13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13 });
    }

    @Override
    public final <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> Result<Record14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14 });
    }

    @Override
    public final <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> Result<Record15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15 });
    }

    @Override
    public final <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> Result<Record16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16 });
    }

    @Override
    public final <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17> Result<Record17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17 });
    }

    @Override
    public final <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18> Result<Record18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18 });
    }

    @Override
    public final <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19> Result<Record19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19 });
    }

    @Override
    public final <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20> Result<Record20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20 });
    }

    @Override
    public final <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21> Result<Record21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20, Field<T21> field21) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21 });
    }

    @Override
    public final <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> Result<Record22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>> into(Field<T1> field1, Field<T2> field2, Field<T3> field3, Field<T4> field4, Field<T5> field5, Field<T6> field6, Field<T7> field7, Field<T8> field8, Field<T9> field9, Field<T10> field10, Field<T11> field11, Field<T12> field12, Field<T13> field13, Field<T14> field14, Field<T15> field15, Field<T16> field16, Field<T17> field17, Field<T18> field18, Field<T19> field19, Field<T20> field20, Field<T21> field21, Field<T22> field22) {
        return (Result) into(new Field[] { field1, field2, field3, field4, field5, field6, field7, field8, field9, field10, field11, field12, field13, field14, field15, field16, field17, field18, field19, field20, field21, field22 });
    }



    @Override
    public final <E> List<E> into(Class<? extends E> type) {
        List<E> list = new ArrayList<E>(size());
        RecordMapper<R, E> mapper = Utils.configuration(this).recordMapperProvider().provide(fields, type);

        for (R record : this) {
            list.add(mapper.map(record));
        }

        return list;
    }

    @Override
    public final <Z extends Record> Result<Z> into(Table<Z> table) {
        Result<Z> list = new ResultImpl<Z>(configuration(), table.fields());

        for (R record : this) {
            list.add(record.into(table));
        }

        return list;
    }

    @Override
    public final <H extends RecordHandler<? super R>> H into(H handler) {
        for (R record : this) {
            handler.next(record);
        }

        return handler;
    }

    @Override
    public final ResultSet intoResultSet() {
        return new MockResultSet(this);
    }

    @Override
    public final <E> List<E> map(RecordMapper<? super R, E> mapper) {
        List<E> result = new ArrayList<E>();

        for (R record : this) {
            result.add(mapper.map(record));
        }

        return result;
    }

    @Override
    public final <T extends Comparable<? super T>> Result<R> sortAsc(Field<T> field) {
        return sortAsc(field, new NaturalComparator<T>());
    }

    @Override
    public final Result<R> sortAsc(int fieldIndex) {
        return sortAsc(fieldIndex, new NaturalComparator());
    }

    @Override
    public final Result<R> sortAsc(String fieldName) {
        return sortAsc(fieldName, new NaturalComparator());
    }

    @Override
    public final Result<R> sortAsc(Name fieldName) {
        return sortAsc(fieldName, new NaturalComparator());
    }

    @Override
    public final <T> Result<R> sortAsc(Field<T> field, Comparator<? super T> comparator) {
        return sortAsc(indexOrFail(fieldsRow(), field), comparator);
    }

    @Override
    public final Result<R> sortAsc(int fieldIndex, Comparator<?> comparator) {
        return sortAsc(new RecordComparator(fieldIndex, comparator));
    }

    @Override
    public final Result<R> sortAsc(String fieldName, Comparator<?> comparator) {
        return sortAsc(indexOrFail(fieldsRow(), fieldName), comparator);
    }

    @Override
    public final Result<R> sortAsc(Name fieldName, Comparator<?> comparator) {
        return sortAsc(indexOrFail(fieldsRow(), fieldName), comparator);
    }

    @Override
    public final Result<R> sortAsc(Comparator<? super R> comparator) {
        Collections.sort(this, comparator);
        return this;
    }

    @Override
    public final <T extends Comparable<? super T>> Result<R> sortDesc(Field<T> field) {
        return sortAsc(field, Collections.reverseOrder(new NaturalComparator<T>()));
    }

    @Override
    public final Result<R> sortDesc(int fieldIndex) {
        return sortAsc(fieldIndex, Collections.reverseOrder(new NaturalComparator()));
    }

    @Override
    public final Result<R> sortDesc(String fieldName) {
        return sortAsc(fieldName, Collections.reverseOrder(new NaturalComparator()));
    }

    @Override
    public final Result<R> sortDesc(Name fieldName) {
        return sortAsc(fieldName, Collections.reverseOrder(new NaturalComparator()));
    }

    @Override
    public final <T> Result<R> sortDesc(Field<T> field, Comparator<? super T> comparator) {
        return sortAsc(field, Collections.reverseOrder(comparator));
    }

    @Override
    public final Result<R> sortDesc(int fieldIndex, Comparator<?> comparator) {
        return sortAsc(fieldIndex, Collections.reverseOrder(comparator));
    }

    @Override
    public final Result<R> sortDesc(String fieldName, Comparator<?> comparator) {
        return sortAsc(fieldName, Collections.reverseOrder(comparator));
    }

    @Override
    public final Result<R> sortDesc(Name fieldName, Comparator<?> comparator) {
        return sortAsc(fieldName, Collections.reverseOrder(comparator));
    }

    @Override
    public final Result<R> sortDesc(Comparator<? super R> comparator) {
        return sortAsc(Collections.reverseOrder(comparator));
    }

    @Override
    public final Result<R> intern(Field<?>... f) {
        return intern(fields.indexesOf(f));
    }

    @Override
    public final Result<R> intern(int... fieldIndexes) {
        for (int fieldIndex : fieldIndexes) {
            if (fields.fields[fieldIndex].getType() == String.class) {
                for (Record record : this) {
                    ((AbstractRecord) record).intern0(fieldIndex);
                }
            }
        }

        return this;
    }

    @Override
    public final Result<R> intern(String... fieldNames) {
        return intern(fields.indexesOf(fieldNames));
    }

    @Override
    public final Result<R> intern(Name... fieldNames) {
        return intern(fields.indexesOf(fieldNames));
    }


    private static class RecordComparator<T, R extends Record> implements Comparator<R> {

        private final Comparator<? super T> comparator;
        private final int fieldIndex;

        RecordComparator(int fieldIndex, Comparator<? super T> comparator) {
            this.fieldIndex = fieldIndex;
            this.comparator = comparator;
        }

        @Override
        public int compare(R record1, R record2) {
            return comparator.compare((T) record1.getValue(fieldIndex), (T) record2.getValue(fieldIndex));
        }
    }


    private static class NaturalComparator<T extends Comparable<? super T>> implements Comparator<T> {

        @Override
        public int compare(T o1, T o2) {
            if (o1 == null && o2 == null) {
                return 0;
            }
            else if (o1 == null) {
                return -1;
            }
            else if (o2 == null) {
                return 1;
            }
            return o1.compareTo(o2);
        }
    }





    @Override
    public final <O extends UpdatableRecord<O>> Result<O> fetchParents(ForeignKey<R, O> key) {
        return key.fetchParents(this);
    }

    @Override
    public final <O extends TableRecord<O>> Result<O> fetchChildren(ForeignKey<O, R> key) {
        return key.fetchChildren(this);
    }





    @Override
    public String toString() {
        return format();
    }

    @Override
    public int hashCode() {
        return records.hashCode();
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }

        if (obj instanceof ResultImpl) {
            ResultImpl<R> other = (ResultImpl<R>) obj;
            return records.equals(other.records);
        }

        return false;
    }





    @Override
    public final int size() {
        return records.size();
    }

    @Override
    public final boolean contains(Object o) {
        return records.contains(o);
    }

    @Override
    public final Object[] toArray() {
        return records.toArray();
    }

    @Override
    public final <T> T[] toArray(T[] a) {
        return records.toArray(a);
    }

    @Override
    public final boolean add(R e) {
        return records.add(e);
    }

    @Override
    public final boolean remove(Object o) {
        return records.remove(o);
    }

    @Override
    public final boolean containsAll(Collection<?> c) {
        return records.containsAll(c);
    }

    @Override
    public final boolean addAll(Collection<? extends R> c) {
        return records.addAll(c);
    }

    @Override
    public final boolean addAll(int index, Collection<? extends R> c) {
        return records.addAll(index, c);
    }

    @Override
    public final boolean removeAll(Collection<?> c) {
        return records.removeAll(c);
    }

    @Override
    public final boolean retainAll(Collection<?> c) {
        return records.retainAll(c);
    }

    @Override
    public final void clear() {
        records.clear();
    }

    @Override
    public final R get(int index) {
        return records.get(index);
    }

    @Override
    public final R set(int index, R element) {
        return records.set(index, element);
    }

    @Override
    public final void add(int index, R element) {
        records.add(index, element);
    }

    @Override
    public final R remove(int index) {
        return records.remove(index);
    }

    @Override
    public final int indexOf(Object o) {
        return records.indexOf(o);
    }

    @Override
    public final int lastIndexOf(Object o) {
        return records.lastIndexOf(o);
    }

    @Override
    public final Iterator<R> iterator() {
        return records.iterator();
    }

    @Override
    public final ListIterator<R> listIterator() {
        return records.listIterator();
    }

    @Override
    public final ListIterator<R> listIterator(int index) {
        return records.listIterator(index);
    }

    @Override
    public final List<R> subList(int fromIndex, int toIndex) {
        return records.subList(fromIndex, toIndex);
    }
}
