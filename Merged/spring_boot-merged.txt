

package org.springframework.boot.orm.jpa;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedHashSet;
import java.util.Set;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.SmartInitializingSingleton;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.beans.factory.support.BeanDefinitionRegistry;
import org.springframework.beans.factory.support.GenericBeanDefinition;
import org.springframework.context.annotation.ImportBeanDefinitionRegistrar;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.AnnotationAttributes;
import org.springframework.core.type.AnnotationMetadata;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;
import org.springframework.util.ObjectUtils;


class EntityScanRegistrar implements ImportBeanDefinitionRegistrar {

	private static final String BEAN_NAME = "entityScanBeanPostProcessor";

	@Override
	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
			BeanDefinitionRegistry registry) {
		if (!registry.containsBeanDefinition(BEAN_NAME)) {
			GenericBeanDefinition beanDefinition = new GenericBeanDefinition();
			beanDefinition.setBeanClass(EntityScanBeanPostProcessor.class);
			beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(
					getPackagesToScan(importingClassMetadata));
			beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);


			beanDefinition.setSynthetic(true);
			registry.registerBeanDefinition(BEAN_NAME, beanDefinition);
		}
	}

	private String[] getPackagesToScan(AnnotationMetadata metadata) {
		AnnotationAttributes attributes = AnnotationAttributes.fromMap(metadata
				.getAnnotationAttributes(EntityScan.class.getName()));
		String[] value = attributes.getStringArray("value");
		String[] basePackages = attributes.getStringArray("basePackages");
		Class<?>[] basePackageClasses = attributes.getClassArray("basePackageClasses");

		if (!ObjectUtils.isEmpty(value)) {
			Assert.state(ObjectUtils.isEmpty(basePackages),
					"@EntityScan basePackages and value attributes are mutually exclusive");
		}

		Set<String> packagesToScan = new LinkedHashSet<String>();
		packagesToScan.addAll(Arrays.asList(value));
		packagesToScan.addAll(Arrays.asList(basePackages));
		for (Class<?> basePackageClass : basePackageClasses) {
			packagesToScan.add(ClassUtils.getPackageName(basePackageClass));
		}
		if (packagesToScan.isEmpty()) {
			return new String[] { ClassUtils.getPackageName(metadata.getClassName()) };
		}
		return new ArrayList<String>(packagesToScan).toArray(new String[packagesToScan
				.size()]);
	}


	static class EntityScanBeanPostProcessor implements BeanPostProcessor,
			SmartInitializingSingleton, Ordered {

		private final String[] packagesToScan;

		private boolean processed;

		public EntityScanBeanPostProcessor(String[] packagesToScan) {
			this.packagesToScan = packagesToScan;
		}

		@Override
		public Object postProcessBeforeInitialization(Object bean, String beanName)
				throws BeansException {
			if (bean instanceof LocalContainerEntityManagerFactoryBean) {
				LocalContainerEntityManagerFactoryBean factoryBean = (LocalContainerEntityManagerFactoryBean) bean;
				factoryBean.setPackagesToScan(this.packagesToScan);
				this.processed = true;
			}
			return bean;
		}

		@Override
		public Object postProcessAfterInitialization(Object bean, String beanName)
				throws BeansException {
			return bean;
		}

		@Override
		public void afterSingletonsInstantiated() {
			Assert.state(this.processed, "Unable to configure "
					+ "LocalContainerEntityManagerFactoryBean from @EntityScan, "
					+ "ensure an appropriate bean is registered.");
		}

		@Override
		public int getOrder() {
			return 0;
		}

	}

}

<code block>


package org.springframework.boot.orm.jpa;

import javax.persistence.EntityManagerFactory;
import javax.persistence.PersistenceException;

import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;

import static org.hamcrest.Matchers.equalTo;
import static org.junit.Assert.assertThat;
import static org.mockito.Mockito.mock;


public class EntityScanTests {

	@Rule
	public ExpectedException thrown = ExpectedException.none();

	private AnnotationConfigApplicationContext context;

	@Test
	public void testValue() throws Exception {
		this.context = new AnnotationConfigApplicationContext(ValueConfig.class);
		assertSetPackagesToScan("com.mycorp.entity");
	}

	@Test
	public void basePackages() throws Exception {
		this.context = new AnnotationConfigApplicationContext(BasePackagesConfig.class);
		assertSetPackagesToScan("com.mycorp.entity2");
	}

	@Test
	public void basePackageClasses() throws Exception {
		this.context = new AnnotationConfigApplicationContext(
				BasePackageClassesConfig.class);
		assertSetPackagesToScan(getClass().getPackage().getName());
	}

	@Test
	public void fromConfigurationClass() throws Exception {
		this.context = new AnnotationConfigApplicationContext(FromConfigConfig.class);
		assertSetPackagesToScan(getClass().getPackage().getName());
	}

	@Test
	public void valueAndBasePackagesThrows() throws Exception {
		this.thrown.expect(IllegalStateException.class);
		this.thrown.expectMessage("@EntityScan basePackages and value "
				+ "attributes are mutually exclusive");
		this.context = new AnnotationConfigApplicationContext(ValueAndBasePackages.class);
	}

	@Test
	public void valueAndBasePackageClassesMerges() throws Exception {
		this.context = new AnnotationConfigApplicationContext(
				ValueAndBasePackageClasses.class);
		assertSetPackagesToScan("com.mycorp.entity", getClass().getPackage().getName());
	}

	@Test
	public void basePackageAndBasePackageClassesMerges() throws Exception {
		this.context = new AnnotationConfigApplicationContext(
				BasePackagesAndBasePackageClasses.class);
		assertSetPackagesToScan("com.mycorp.entity2", getClass().getPackage().getName());
	}

	@Test
	public void needsEntityManageFactory() throws Exception {
		this.thrown.expect(IllegalStateException.class);
		this.thrown.expectMessage("Unable to configure "
				+ "LocalContainerEntityManagerFactoryBean from @EntityScan, "
				+ "ensure an appropriate bean is registered.");
		this.context = new AnnotationConfigApplicationContext(MissingEntityManager.class);
	}

	@Test
	public void userDeclaredBeanPostProcessorWithEntityManagerDependencyDoesNotPreventConfigurationOfPackagesToScan() {
		this.context = new AnnotationConfigApplicationContext(
				BeanPostProcessorConfiguration.class, BaseConfig.class);
		assertSetPackagesToScan("com.mycorp.entity");
	}

	private void assertSetPackagesToScan(String... expected) {
		String[] actual = this.context.getBean(
				TestLocalContainerEntityManagerFactoryBean.class).getPackagesToScan();
		assertThat(actual, equalTo(expected));
	}

	@Configuration
	static class BaseConfig {

		@Bean
		public TestLocalContainerEntityManagerFactoryBean entityManagerFactoryBean() {
			return new TestLocalContainerEntityManagerFactoryBean();
		}

	}

	@EntityScan("com.mycorp.entity")
	static class ValueConfig extends BaseConfig {
	}

	@EntityScan(basePackages = "com.mycorp.entity2")
	static class BasePackagesConfig extends BaseConfig {
	}

	@EntityScan(basePackageClasses = EntityScanTests.class)
	static class BasePackageClassesConfig extends BaseConfig {
	}

	@EntityScan
	static class FromConfigConfig extends BaseConfig {
	}

	@EntityScan(value = "com.mycorp.entity", basePackages = "com.mycorp")
	static class ValueAndBasePackages extends BaseConfig {
	}

	@EntityScan(value = "com.mycorp.entity", basePackageClasses = EntityScanTests.class)
	static class ValueAndBasePackageClasses extends BaseConfig {
	}

	@EntityScan(basePackages = "com.mycorp.entity2", basePackageClasses = EntityScanTests.class)
	static class BasePackagesAndBasePackageClasses extends BaseConfig {
	}

	@Configuration
	@EntityScan("com.mycorp.entity")
	static class MissingEntityManager {
	}

	@Configuration
	@EntityScan("com.mycorp.entity")
	static class BeanPostProcessorConfiguration {

		@Autowired
		private EntityManagerFactory entityManagerFactory;

		@Bean
		public BeanPostProcessor beanPostProcessor() {
			return new BeanPostProcessor() {

				@Override
				public Object postProcessBeforeInitialization(Object bean, String beanName)
						throws BeansException {
					return bean;
				}

				@Override
				public Object postProcessAfterInitialization(Object bean, String beanName)
						throws BeansException {
					return bean;
				}
			};

		}
	}

	private static class TestLocalContainerEntityManagerFactoryBean extends
			LocalContainerEntityManagerFactoryBean {

		private String[] packagesToScan;

		@Override
		protected EntityManagerFactory createNativeEntityManagerFactory()
				throws PersistenceException {
			return mock(EntityManagerFactory.class);
		}

		@Override
		public void setPackagesToScan(String... packagesToScan) {
			this.packagesToScan = packagesToScan;
		}

		public String[] getPackagesToScan() {
			return this.packagesToScan;
		}

	}

}

<code block>


package org.springframework.boot.orm.jpa;

import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.Set;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.SmartInitializingSingleton;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.beans.factory.config.ConstructorArgumentValues.ValueHolder;
import org.springframework.beans.factory.support.BeanDefinitionRegistry;
import org.springframework.beans.factory.support.GenericBeanDefinition;
import org.springframework.context.annotation.ImportBeanDefinitionRegistrar;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.AnnotationAttributes;
import org.springframework.core.type.AnnotationMetadata;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;
import org.springframework.util.ObjectUtils;


class EntityScanRegistrar implements ImportBeanDefinitionRegistrar {

	private static final String BEAN_NAME = "entityScanBeanPostProcessor";

	@Override
	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
			BeanDefinitionRegistry registry) {
		Set<String> packagesToScan = getPackagesToScan(importingClassMetadata);
		if (!registry.containsBeanDefinition(BEAN_NAME)) {
			addEntityScanBeanPostProcessor(registry, packagesToScan);
		}
		else {
			updateEntityScanBeanPostProcessor(registry, packagesToScan);
		}
	}

	private Set<String> getPackagesToScan(AnnotationMetadata metadata) {
		AnnotationAttributes attributes = AnnotationAttributes.fromMap(metadata
				.getAnnotationAttributes(EntityScan.class.getName()));
		String[] value = attributes.getStringArray("value");
		String[] basePackages = attributes.getStringArray("basePackages");
		Class<?>[] basePackageClasses = attributes.getClassArray("basePackageClasses");
		if (!ObjectUtils.isEmpty(value)) {
			Assert.state(ObjectUtils.isEmpty(basePackages),
					"@EntityScan basePackages and value attributes are mutually exclusive");
		}
		Set<String> packagesToScan = new LinkedHashSet<String>();
		packagesToScan.addAll(Arrays.asList(value));
		packagesToScan.addAll(Arrays.asList(basePackages));
		for (Class<?> basePackageClass : basePackageClasses) {
			packagesToScan.add(ClassUtils.getPackageName(basePackageClass));
		}
		if (packagesToScan.isEmpty()) {
			return Collections.singleton(ClassUtils.getPackageName(metadata
					.getClassName()));
		}
		return packagesToScan;
	}

	private void addEntityScanBeanPostProcessor(BeanDefinitionRegistry registry,
			Set<String> packagesToScan) {
		GenericBeanDefinition beanDefinition = new GenericBeanDefinition();
		beanDefinition.setBeanClass(EntityScanBeanPostProcessor.class);
		beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(
				toArray(packagesToScan));
		beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);


		beanDefinition.setSynthetic(true);
		registry.registerBeanDefinition(BEAN_NAME, beanDefinition);
	}

	private void updateEntityScanBeanPostProcessor(BeanDefinitionRegistry registry,
			Set<String> packagesToScan) {
		BeanDefinition definition = registry.getBeanDefinition(BEAN_NAME);
		ValueHolder constructorArguments = definition.getConstructorArgumentValues()
				.getGenericArgumentValue(String[].class);
		Set<String> mergedPackages = new LinkedHashSet<String>();
		mergedPackages.addAll(Arrays.asList((String[]) constructorArguments.getValue()));
		mergedPackages.addAll(packagesToScan);
		constructorArguments.setValue(toArray(mergedPackages));
	}

	private String[] toArray(Set<String> set) {
		return set.toArray(new String[set.size()]);
	}


	static class EntityScanBeanPostProcessor implements BeanPostProcessor,
			SmartInitializingSingleton, Ordered {

		private final String[] packagesToScan;

		private boolean processed;

		public EntityScanBeanPostProcessor(String[] packagesToScan) {
			this.packagesToScan = packagesToScan;
		}

		@Override
		public Object postProcessBeforeInitialization(Object bean, String beanName)
				throws BeansException {
			if (bean instanceof LocalContainerEntityManagerFactoryBean) {
				LocalContainerEntityManagerFactoryBean factoryBean = (LocalContainerEntityManagerFactoryBean) bean;
				factoryBean.setPackagesToScan(this.packagesToScan);
				this.processed = true;
			}
			return bean;
		}

		@Override
		public Object postProcessAfterInitialization(Object bean, String beanName)
				throws BeansException {
			return bean;
		}

		@Override
		public void afterSingletonsInstantiated() {
			Assert.state(this.processed, "Unable to configure "
					+ "LocalContainerEntityManagerFactoryBean from @EntityScan, "
					+ "ensure an appropriate bean is registered.");
		}

		@Override
		public int getOrder() {
			return 0;
		}

	}

}

<code block>


package org.springframework.boot.orm.jpa;

import javax.persistence.EntityManagerFactory;
import javax.persistence.PersistenceException;

import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;

import static org.hamcrest.Matchers.equalTo;
import static org.junit.Assert.assertThat;
import static org.mockito.Mockito.mock;


public class EntityScanTests {

	@Rule
	public ExpectedException thrown = ExpectedException.none();

	private AnnotationConfigApplicationContext context;

	@Test
	public void testValue() throws Exception {
		this.context = new AnnotationConfigApplicationContext(ValueConfig.class);
		assertSetPackagesToScan("com.mycorp.entity");
	}

	@Test
	public void basePackages() throws Exception {
		this.context = new AnnotationConfigApplicationContext(BasePackagesConfig.class);
		assertSetPackagesToScan("com.mycorp.entity2");
	}

	@Test
	public void basePackageClasses() throws Exception {
		this.context = new AnnotationConfigApplicationContext(
				BasePackageClassesConfig.class);
		assertSetPackagesToScan(getClass().getPackage().getName());
	}

	@Test
	public void fromConfigurationClass() throws Exception {
		this.context = new AnnotationConfigApplicationContext(FromConfigConfig.class);
		assertSetPackagesToScan(getClass().getPackage().getName());
	}

	@Test
	public void valueAndBasePackagesThrows() throws Exception {
		this.thrown.expect(IllegalStateException.class);
		this.thrown.expectMessage("@EntityScan basePackages and value "
				+ "attributes are mutually exclusive");
		this.context = new AnnotationConfigApplicationContext(ValueAndBasePackages.class);
	}

	@Test
	public void valueAndBasePackageClassesMerges() throws Exception {
		this.context = new AnnotationConfigApplicationContext(
				ValueAndBasePackageClasses.class);
		assertSetPackagesToScan("com.mycorp.entity", getClass().getPackage().getName());
	}

	@Test
	public void basePackageAndBasePackageClassesMerges() throws Exception {
		this.context = new AnnotationConfigApplicationContext(
				BasePackagesAndBasePackageClasses.class);
		assertSetPackagesToScan("com.mycorp.entity2", getClass().getPackage().getName());
	}

	@Test
	public void needsEntityManageFactory() throws Exception {
		this.thrown.expect(IllegalStateException.class);
		this.thrown.expectMessage("Unable to configure "
				+ "LocalContainerEntityManagerFactoryBean from @EntityScan, "
				+ "ensure an appropriate bean is registered.");
		this.context = new AnnotationConfigApplicationContext(MissingEntityManager.class);
	}

	@Test
	public void userDeclaredBeanPostProcessorWithEntityManagerDependencyDoesNotPreventConfigurationOfPackagesToScan() {
		this.context = new AnnotationConfigApplicationContext(
				BeanPostProcessorConfiguration.class, BaseConfig.class);
		assertSetPackagesToScan("com.mycorp.entity");
	}

	@Test
	public void considersMultipleEntityScanAnnotations() {
		this.context = new AnnotationConfigApplicationContext(MultiScanFirst.class,
				MultiScanSecond.class);
		assertSetPackagesToScan("foo", "bar");
	}

	private void assertSetPackagesToScan(String... expected) {
		String[] actual = this.context.getBean(
				TestLocalContainerEntityManagerFactoryBean.class).getPackagesToScan();
		assertThat(actual, equalTo(expected));
	}

	@Configuration
	static class BaseConfig {

		@Bean
		public TestLocalContainerEntityManagerFactoryBean entityManagerFactoryBean() {
			return new TestLocalContainerEntityManagerFactoryBean();
		}

	}

	@EntityScan("com.mycorp.entity")
	static class ValueConfig extends BaseConfig {
	}

	@EntityScan(basePackages = "com.mycorp.entity2")
	static class BasePackagesConfig extends BaseConfig {
	}

	@EntityScan(basePackageClasses = EntityScanTests.class)
	static class BasePackageClassesConfig extends BaseConfig {
	}

	@EntityScan
	static class FromConfigConfig extends BaseConfig {
	}

	@EntityScan(value = "com.mycorp.entity", basePackages = "com.mycorp")
	static class ValueAndBasePackages extends BaseConfig {
	}

	@EntityScan(value = "com.mycorp.entity", basePackageClasses = EntityScanTests.class)
	static class ValueAndBasePackageClasses extends BaseConfig {
	}

	@EntityScan(basePackages = "com.mycorp.entity2", basePackageClasses = EntityScanTests.class)
	static class BasePackagesAndBasePackageClasses extends BaseConfig {
	}

	@Configuration
	@EntityScan("com.mycorp.entity")
	static class MissingEntityManager {
	}

	@Configuration
	@EntityScan("com.mycorp.entity")
	static class BeanPostProcessorConfiguration {

		@Autowired
		private EntityManagerFactory entityManagerFactory;

		@Bean
		public BeanPostProcessor beanPostProcessor() {
			return new BeanPostProcessor() {

				@Override
				public Object postProcessBeforeInitialization(Object bean, String beanName)
						throws BeansException {
					return bean;
				}

				@Override
				public Object postProcessAfterInitialization(Object bean, String beanName)
						throws BeansException {
					return bean;
				}
			};

		}
	}

	@EntityScan(basePackages = "foo")
	static class MultiScanFirst extends BaseConfig {

	}

	@EntityScan(basePackages = "bar")
	static class MultiScanSecond extends BaseConfig {

	}

	private static class TestLocalContainerEntityManagerFactoryBean extends
			LocalContainerEntityManagerFactoryBean {

		private String[] packagesToScan;

		@Override
		protected EntityManagerFactory createNativeEntityManagerFactory()
				throws PersistenceException {
			return mock(EntityManagerFactory.class);
		}

		@Override
		public void setPackagesToScan(String... packagesToScan) {
			this.packagesToScan = packagesToScan;
		}

		public String[] getPackagesToScan() {
			return this.packagesToScan;
		}

	}

}

<code block>


package org.springframework.boot.cloudfoundry;

import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.boot.context.config.ConfigFileApplicationListener;
import org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent;
import org.springframework.boot.json.JsonParser;
import org.springframework.boot.json.JsonParserFactory;
import org.springframework.context.ApplicationListener;
import org.springframework.core.Ordered;
import org.springframework.core.env.CommandLinePropertySource;
import org.springframework.core.env.ConfigurableEnvironment;
import org.springframework.core.env.Environment;
import org.springframework.core.env.MutablePropertySources;
import org.springframework.core.env.PropertiesPropertySource;
import org.springframework.util.StringUtils;


public class VcapApplicationListener implements
		ApplicationListener<ApplicationEnvironmentPreparedEvent>, Ordered {

	private static final Log logger = LogFactory.getLog(VcapApplicationListener.class);

	private static final String VCAP_APPLICATION = "VCAP_APPLICATION";

	private static final String VCAP_SERVICES = "VCAP_SERVICES";


	private int order = ConfigFileApplicationListener.DEFAULT_ORDER - 1;

	private final JsonParser parser = JsonParserFactory.getJsonParser();

	public void setOrder(int order) {
		this.order = order;
	}

	@Override
	public int getOrder() {
		return this.order;
	}

	@Override
	public void onApplicationEvent(ApplicationEnvironmentPreparedEvent event) {
		ConfigurableEnvironment environment = event.getEnvironment();
		if (!environment.containsProperty(VCAP_APPLICATION)
				&& !environment.containsProperty(VCAP_SERVICES)) {
			return;
		}
		Properties properties = new Properties();
		addWithPrefix(properties, getPropertiesFromApplication(environment),
				"vcap.application.");
		addWithPrefix(properties, getPropertiesFromServices(environment),
				"vcap.services.");
		MutablePropertySources propertySources = environment.getPropertySources();
		if (propertySources
				.contains(CommandLinePropertySource.COMMAND_LINE_PROPERTY_SOURCE_NAME)) {
			propertySources.addAfter(
					CommandLinePropertySource.COMMAND_LINE_PROPERTY_SOURCE_NAME,
					new PropertiesPropertySource("vcap", properties));
		}
		else {
			propertySources.addFirst(new PropertiesPropertySource("vcap", properties));
		}
	}

	private void addWithPrefix(Properties properties, Properties other, String prefix) {
		for (String key : other.stringPropertyNames()) {
			String prefixed = prefix + key;
			properties.setProperty(prefixed, other.getProperty(key));
		}
	}

	private Properties getPropertiesFromApplication(Environment environment) {
		Properties properties = new Properties();
		try {
			Map<String, Object> map = this.parser.parseMap(environment.getProperty(
					VCAP_APPLICATION, "{}"));
			extractPropertiesFromApplication(properties, map);
		}
		catch (Exception ex) {
			logger.error("Could not parse VCAP_APPLICATION", ex);
		}
		return properties;
	}

	private Properties getPropertiesFromServices(Environment environment) {
		Properties properties = new Properties();
		try {
			Map<String, Object> map = this.parser.parseMap(environment.getProperty(
					VCAP_SERVICES, "{}"));
			extractPropertiesFromServices(properties, map);
		}
		catch (Exception ex) {
			logger.error("Could not parse VCAP_SERVICES", ex);
		}
		return properties;
	}

	private void extractPropertiesFromApplication(Properties properties,
			Map<String, Object> map) {
		if (map != null) {
			flatten(properties, map, "");
		}
	}

	private void extractPropertiesFromServices(Properties properties,
			Map<String, Object> map) {
		if (map != null) {
			for (Object services : map.values()) {
				@SuppressWarnings("unchecked")
				List<Object> list = (List<Object>) services;
				for (Object object : list) {
					@SuppressWarnings("unchecked")
					Map<String, Object> service = (Map<String, Object>) object;
					String key = (String) service.get("name");
					if (key == null) {
						key = (String) service.get("label");
					}
					flatten(properties, service, key);
				}
			}
		}
	}

	private void flatten(Properties properties, Map<String, Object> input, String path) {
		for (Entry<String, Object> entry : input.entrySet()) {
			String key = entry.getKey();
			if (StringUtils.hasText(path)) {
				if (key.startsWith("[")) {
					key = path + key;
				}
				else {
					key = path + "." + key;
				}
			}
			Object value = entry.getValue();
			if (value instanceof String) {
				properties.put(key, value);
			}
			else if (value instanceof Number) {
				properties.put(key, value.toString());
			}
			else if (value instanceof Boolean) {
				properties.put(key, value.toString());
			}
			else if (value instanceof Map) {

				@SuppressWarnings("unchecked")
				Map<String, Object> map = (Map<String, Object>) value;
				flatten(properties, map, key);
			}
			else if (value instanceof Collection) {

				@SuppressWarnings("unchecked")
				Collection<Object> collection = (Collection<Object>) value;
				properties.put(key,
						StringUtils.collectionToCommaDelimitedString(collection));
				int count = 0;
				for (Object object : collection) {
					flatten(properties,
							Collections.singletonMap("[" + (count++) + "]", object), key);
				}
			}
			else {
				properties.put(key, value == null ? "" : value);
			}
		}
	}

}

<code block>


package org.springframework.boot.cloudfoundry;

import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.boot.context.config.ConfigFileApplicationListener;
import org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent;
import org.springframework.boot.json.JsonParser;
import org.springframework.boot.json.JsonParserFactory;
import org.springframework.context.ApplicationListener;
import org.springframework.core.Ordered;
import org.springframework.core.env.CommandLinePropertySource;
import org.springframework.core.env.ConfigurableEnvironment;
import org.springframework.core.env.Environment;
import org.springframework.core.env.MutablePropertySources;
import org.springframework.core.env.PropertiesPropertySource;
import org.springframework.util.StringUtils;


public class VcapApplicationListener implements
		ApplicationListener<ApplicationEnvironmentPreparedEvent>, Ordered {

	private static final Log logger = LogFactory.getLog(VcapApplicationListener.class);

	private static final String VCAP_APPLICATION = "VCAP_APPLICATION";

	private static final String VCAP_SERVICES = "VCAP_SERVICES";


	private int order = ConfigFileApplicationListener.DEFAULT_ORDER - 1;

	private final JsonParser parser = JsonParserFactory.getJsonParser();

	public void setOrder(int order) {
		this.order = order;
	}

	@Override
	public int getOrder() {
		return this.order;
	}

	@Override
	public void onApplicationEvent(ApplicationEnvironmentPreparedEvent event) {
		ConfigurableEnvironment environment = event.getEnvironment();
		if (!environment.containsProperty(VCAP_APPLICATION)
				&& !environment.containsProperty(VCAP_SERVICES)) {
			return;
		}
		Properties properties = new Properties();
		addWithPrefix(properties, getPropertiesFromApplication(environment),
				"vcap.application.");
		addWithPrefix(properties, getPropertiesFromServices(environment),
				"vcap.services.");
		MutablePropertySources propertySources = environment.getPropertySources();
		if (propertySources
				.contains(CommandLinePropertySource.COMMAND_LINE_PROPERTY_SOURCE_NAME)) {
			propertySources.addAfter(
					CommandLinePropertySource.COMMAND_LINE_PROPERTY_SOURCE_NAME,
					new PropertiesPropertySource("vcap", properties));
		}
		else {
			propertySources.addFirst(new PropertiesPropertySource("vcap", properties));
		}
	}

	private void addWithPrefix(Properties properties, Properties other, String prefix) {
		for (String key : other.stringPropertyNames()) {
			String prefixed = prefix + key;
			properties.setProperty(prefixed, other.getProperty(key));
		}
	}

	private Properties getPropertiesFromApplication(Environment environment) {
		Properties properties = new Properties();
		try {
			Map<String, Object> map = this.parser.parseMap(environment.getProperty(
					VCAP_APPLICATION, "{}"));
			extractPropertiesFromApplication(properties, map);
		}
		catch (Exception ex) {
			logger.error("Could not parse VCAP_APPLICATION", ex);
		}
		return properties;
	}

	private Properties getPropertiesFromServices(Environment environment) {
		Properties properties = new Properties();
		try {
			Map<String, Object> map = this.parser.parseMap(environment.getProperty(
					VCAP_SERVICES, "{}"));
			extractPropertiesFromServices(properties, map);
		}
		catch (Exception ex) {
			logger.error("Could not parse VCAP_SERVICES", ex);
		}
		return properties;
	}

	private void extractPropertiesFromApplication(Properties properties,
			Map<String, Object> map) {
		if (map != null) {
			flatten(properties, map, "");
		}
	}

	private void extractPropertiesFromServices(Properties properties,
			Map<String, Object> map) {
		if (map != null) {
			for (Object services : map.values()) {
				@SuppressWarnings("unchecked")
				List<Object> list = (List<Object>) services;
				for (Object object : list) {
					@SuppressWarnings("unchecked")
					Map<String, Object> service = (Map<String, Object>) object;
					String key = (String) service.get("name");
					if (key == null) {
						key = (String) service.get("label");
					}
					flatten(properties, service, key);
				}
			}
		}
	}

	@SuppressWarnings("unchecked")
	private void flatten(Properties properties, Map<String, Object> input, String path) {
		for (Entry<String, Object> entry : input.entrySet()) {
			String key = getFullKey(path, entry.getKey());
			Object value = entry.getValue();
			if (value instanceof Map) {

				flatten(properties, (Map<String, Object>) value, key);
			}
			else if (value instanceof Collection) {

				Collection<Object> collection = (Collection<Object>) value;
				properties.put(key,
						StringUtils.collectionToCommaDelimitedString(collection));
				int count = 0;
				for (Object item : collection) {
					String itemKey = "[" + (count++) + "]";
					flatten(properties, Collections.singletonMap(itemKey, item), key);
				}
			}
			else if (value instanceof String) {
				properties.put(key, value);
			}
			else if (value instanceof Number) {
				properties.put(key, value.toString());
			}
			else if (value instanceof Boolean) {
				properties.put(key, value.toString());
			}
			else {
				properties.put(key, value == null ? "" : value);
			}
		}
	}

	private String getFullKey(String path, String key) {
		if (!StringUtils.hasText(path)) {
			return key;
		}
		if (key.startsWith("[")) {
			return path + key;
		}
		return path + "." + key;
	}

}

<code block>


package org.springframework.boot.autoconfigure.web;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.validation.DefaultMessageCodesResolver;


@ConfigurationProperties("spring.mvc")
public class WebMvcProperties {


	private DefaultMessageCodesResolver.Format messageCodesResolverFormat;


	private String locale;


	private String dateFormat;


	private boolean ignoreDefaultModelOnRedirect = true;

	private final Async async = new Async();

	public DefaultMessageCodesResolver.Format getMessageCodesResolverFormat() {
		return this.messageCodesResolverFormat;
	}

	public void setMessageCodesResolverFormat(
			DefaultMessageCodesResolver.Format messageCodesResolverFormat) {
		this.messageCodesResolverFormat = messageCodesResolverFormat;
	}

	public String getLocale() {
		return this.locale;
	}

	public void setLocale(String locale) {
		this.locale = locale;
	}

	public String getDateFormat() {
		return this.dateFormat;
	}

	public void setDateFormat(String dateFormat) {
		this.dateFormat = dateFormat;
	}

	public boolean isIgnoreDefaultModelOnRedirect() {
		return this.ignoreDefaultModelOnRedirect;
	}

	public void setIgnoreDefaultModelOnRedirect(boolean ignoreDefaultModelOnRedirect) {
		this.ignoreDefaultModelOnRedirect = ignoreDefaultModelOnRedirect;
	}

	public Async getAsync() {
		return this.async;
	}

	public static class Async {


		private Long requestTimeout;

		public Long getRequestTimeout() {
			return this.requestTimeout;
		}

		public void setRequestTimeout(Long requestTimeout) {
			this.requestTimeout = requestTimeout;
		}

	}
}

<code block>


package org.springframework.boot.autoconfigure.web;

import java.lang.reflect.Field;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.joda.time.DateTime;
import org.junit.After;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.springframework.beans.factory.NoSuchBeanDefinitionException;
import org.springframework.boot.autoconfigure.PropertyPlaceholderAutoConfiguration;
import org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration.WebMvcAutoConfigurationAdapter;
import org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext;
import org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizerBeanPostProcessor;
import org.springframework.boot.context.embedded.EmbeddedServletContainerFactory;
import org.springframework.boot.context.embedded.MockEmbeddedServletContainerFactory;
import org.springframework.boot.test.EnvironmentTestUtils;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;
import org.springframework.format.support.FormattingConversionService;
import org.springframework.mock.web.MockHttpServletRequest;
import org.springframework.test.util.ReflectionTestUtils;
import org.springframework.util.ReflectionUtils;
import org.springframework.util.StringUtils;
import org.springframework.web.servlet.HandlerAdapter;
import org.springframework.web.servlet.HandlerMapping;
import org.springframework.web.servlet.LocaleResolver;
import org.springframework.web.servlet.View;
import org.springframework.web.servlet.ViewResolver;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;
import org.springframework.web.servlet.handler.SimpleUrlHandlerMapping;
import org.springframework.web.servlet.i18n.FixedLocaleResolver;
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter;
import org.springframework.web.servlet.resource.ResourceHttpRequestHandler;
import org.springframework.web.servlet.view.AbstractView;
import org.springframework.web.servlet.view.ContentNegotiatingViewResolver;

import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.instanceOf;
import static org.hamcrest.Matchers.is;
import static org.hamcrest.Matchers.notNullValue;
import static org.hamcrest.Matchers.nullValue;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertThat;


public class WebMvcAutoConfigurationTests {

	private static final MockEmbeddedServletContainerFactory containerFactory = new MockEmbeddedServletContainerFactory();

	@Rule
	public ExpectedException thrown = ExpectedException.none();

	private AnnotationConfigEmbeddedWebApplicationContext context;

	@After
	public void close() {
		if (this.context != null) {
			this.context.close();
		}
	}

	@Test
	public void handerAdaptersCreated() throws Exception {
		this.context = new AnnotationConfigEmbeddedWebApplicationContext();
		this.context.register(Config.class, WebMvcAutoConfiguration.class,
				HttpMessageConvertersAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(3, this.context.getBeanNamesForType(HandlerAdapter.class).length);
		assertFalse(this.context.getBean(RequestMappingHandlerAdapter.class)
				.getMessageConverters().isEmpty());
		assertEquals(this.context.getBean(HttpMessageConverters.class).getConverters(),
				this.context.getBean(RequestMappingHandlerAdapter.class)
						.getMessageConverters());
	}

	@Test
	public void handerMappingsCreated() throws Exception {
		this.context = new AnnotationConfigEmbeddedWebApplicationContext();
		this.context.register(Config.class, WebMvcAutoConfiguration.class,
				HttpMessageConvertersAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(6, this.context.getBeanNamesForType(HandlerMapping.class).length);
	}

	@Test
	public void resourceHandlerMapping() throws Exception {
		this.context = new AnnotationConfigEmbeddedWebApplicationContext();
		this.context.register(Config.class, WebMvcAutoConfiguration.class,
				HttpMessageConvertersAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		Map<String, List<Resource>> mappingLocations = getResourceMappingLocations();
		assertThat(mappingLocations.get("/**").size(), equalTo(5));
		assertThat(mappingLocations.get("/webjars/**").size(), equalTo(1));
		assertThat(mappingLocations.get("/webjars/**").get(0),
				equalTo((Resource) new ClassPathResource("/META-INF/resources/webjars/")));
	}

	@Test
	public void resourceHandlerMappingOverrideWebjars() throws Exception {
		this.context = new AnnotationConfigEmbeddedWebApplicationContext();
		this.context.register(WebJars.class, Config.class, WebMvcAutoConfiguration.class,
				HttpMessageConvertersAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		Map<String, List<Resource>> mappingLocations = getResourceMappingLocations();
		assertThat(mappingLocations.get("/webjars/**").size(), equalTo(1));
		assertThat(mappingLocations.get("/webjars/**").get(0),
				equalTo((Resource) new ClassPathResource("/foo/")));
	}

	@Test
	public void resourceHandlerMappingOverrideAll() throws Exception {
		this.context = new AnnotationConfigEmbeddedWebApplicationContext();
		this.context.register(AllResources.class, Config.class,
				WebMvcAutoConfiguration.class,
				HttpMessageConvertersAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		Map<String, List<Resource>> mappingLocations = getResourceMappingLocations();
		assertThat(mappingLocations.get("/**").size(), equalTo(1));
		assertThat(mappingLocations.get("/**").get(0),
				equalTo((Resource) new ClassPathResource("/foo/")));
	}

	@Test
	public void resourceHandlerMappingDisabled() throws Exception {
		this.context = new AnnotationConfigEmbeddedWebApplicationContext();
		EnvironmentTestUtils.addEnvironment(this.context,
				"spring.resources.add-mappings:false");
		this.context.register(Config.class, WebMvcAutoConfiguration.class,
				HttpMessageConvertersAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		Map<String, List<Resource>> mappingLocations = getResourceMappingLocations();
		assertThat(mappingLocations.size(), equalTo(0));
	}

	@Test
	public void noLocaleResolver() throws Exception {
		this.context = new AnnotationConfigEmbeddedWebApplicationContext();
		this.context.register(AllResources.class, Config.class,
				WebMvcAutoConfiguration.class,
				HttpMessageConvertersAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		this.thrown.expect(NoSuchBeanDefinitionException.class);
		this.context.getBean(LocaleResolver.class);
	}

	@Test
	public void overrideLocale() throws Exception {
		this.context = new AnnotationConfigEmbeddedWebApplicationContext();

		EnvironmentTestUtils.addEnvironment(this.context, "spring.mvc.locale:en_UK");
		this.context.register(AllResources.class, Config.class,
				WebMvcAutoConfiguration.class,
				HttpMessageConvertersAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		MockHttpServletRequest request = new MockHttpServletRequest();
		request.addPreferredLocale(StringUtils.parseLocaleString("nl_NL"));
		LocaleResolver localeResolver = this.context.getBean(LocaleResolver.class);
		Locale locale = localeResolver.resolveLocale(request);
		assertThat(localeResolver, instanceOf(FixedLocaleResolver.class));

		assertThat(locale.toString(), equalTo("en_UK"));
	}

	@Test
	public void noDateFormat() throws Exception {
		this.context = new AnnotationConfigEmbeddedWebApplicationContext();
		this.context.register(AllResources.class, Config.class,
				WebMvcAutoConfiguration.class,
				HttpMessageConvertersAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		FormattingConversionService cs = this.context
				.getBean(FormattingConversionService.class);
		Date date = new DateTime(1988, 6, 25, 20, 30).toDate();

		assertThat(cs.convert(date, String.class), equalTo(date.toString()));
	}

	@Test
	public void overrideDateFormat() throws Exception {
		this.context = new AnnotationConfigEmbeddedWebApplicationContext();

		EnvironmentTestUtils.addEnvironment(this.context,
				"spring.mvc.dateFormat:dd*MM*yyyy");
		this.context.register(AllResources.class, Config.class,
				WebMvcAutoConfiguration.class,
				HttpMessageConvertersAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		FormattingConversionService cs = this.context
				.getBean(FormattingConversionService.class);
		Date date = new DateTime(1988, 6, 25, 20, 30).toDate();
		assertThat(cs.convert(date, String.class), equalTo("25*06*1988"));
	}

	@Test
	public void noMessageCodesResolver() throws Exception {
		this.context = new AnnotationConfigEmbeddedWebApplicationContext();
		this.context.register(AllResources.class, Config.class,
				WebMvcAutoConfiguration.class,
				HttpMessageConvertersAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertNull(this.context.getBean(WebMvcAutoConfigurationAdapter.class)
				.getMessageCodesResolver());
	}

	@Test
	public void overrideMessageCodesFormat() throws Exception {
		this.context = new AnnotationConfigEmbeddedWebApplicationContext();
		EnvironmentTestUtils.addEnvironment(this.context,
				"spring.mvc.messageCodesResolverFormat:POSTFIX_ERROR_CODE");
		this.context.register(AllResources.class, Config.class,
				WebMvcAutoConfiguration.class,
				HttpMessageConvertersAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertNotNull(this.context.getBean(WebMvcAutoConfigurationAdapter.class)
				.getMessageCodesResolver());
	}

	protected Map<String, List<Resource>> getFaviconMappingLocations()
			throws IllegalAccessException {
		HandlerMapping mapping = (HandlerMapping) this.context
				.getBean("faviconHandlerMapping");
		return getMappingLocations(mapping);
	}

	protected Map<String, List<Resource>> getResourceMappingLocations()
			throws IllegalAccessException {
		HandlerMapping mapping = (HandlerMapping) this.context
				.getBean("resourceHandlerMapping");
		return getMappingLocations(mapping);
	}

	@SuppressWarnings("unchecked")
	protected Map<String, List<Resource>> getMappingLocations(HandlerMapping mapping)
			throws IllegalAccessException {
		Map<String, List<Resource>> mappingLocations = new LinkedHashMap<String, List<Resource>>();
		if (mapping instanceof SimpleUrlHandlerMapping) {
			Field locationsField = ReflectionUtils.findField(
					ResourceHttpRequestHandler.class, "locations");
			locationsField.setAccessible(true);
			for (Map.Entry<String, Object> entry : ((SimpleUrlHandlerMapping) mapping)
					.getHandlerMap().entrySet()) {
				ResourceHttpRequestHandler handler = (ResourceHttpRequestHandler) entry
						.getValue();
				mappingLocations.put(entry.getKey(),
						(List<Resource>) locationsField.get(handler));
			}
		}
		return mappingLocations;
	}

	@Test
	public void ignoreDefaultModelOnRedirectIsTrue() throws Exception {
		this.context = new AnnotationConfigEmbeddedWebApplicationContext();
		this.context.register(Config.class, WebMvcAutoConfiguration.class,
				HttpMessageConvertersAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		RequestMappingHandlerAdapter adapter = this.context
				.getBean(RequestMappingHandlerAdapter.class);
		assertEquals(true,
				ReflectionTestUtils.getField(adapter, "ignoreDefaultModelOnRedirect"));
	}

	@Test
	public void overrideIgnoreDefaultModelOnRedirect() throws Exception {
		this.context = new AnnotationConfigEmbeddedWebApplicationContext();
		EnvironmentTestUtils.addEnvironment(this.context,
				"spring.mvc.ignore-default-model-on-redirect:false");
		this.context.register(Config.class, WebMvcAutoConfiguration.class,
				HttpMessageConvertersAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		RequestMappingHandlerAdapter adapter = this.context
				.getBean(RequestMappingHandlerAdapter.class);
		assertEquals(false,
				ReflectionTestUtils.getField(adapter, "ignoreDefaultModelOnRedirect"));
	}

	@Test
	public void customViewResolver() throws Exception {
		this.context = new AnnotationConfigEmbeddedWebApplicationContext();
		this.context.register(Config.class, CustomViewResolver.class,
				WebMvcAutoConfiguration.class,
				HttpMessageConvertersAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean("viewResolver"), instanceOf(MyViewResolver.class));
	}

	@Test
	public void customContentNegotiatingViewResolver() throws Exception {
		this.context = new AnnotationConfigEmbeddedWebApplicationContext();
		this.context.register(Config.class, CustomContentNegotiatingViewResolver.class,
				WebMvcAutoConfiguration.class,
				HttpMessageConvertersAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		Map<String, ContentNegotiatingViewResolver> beans = this.context
				.getBeansOfType(ContentNegotiatingViewResolver.class);
		assertThat(beans.size(), equalTo(1));
		assertThat(beans.keySet().iterator().next(), equalTo("myViewResolver"));
	}

	@Test
	public void faviconMapping() throws IllegalAccessException {
		this.context = new AnnotationConfigEmbeddedWebApplicationContext();
		this.context.register(Config.class, WebMvcAutoConfiguration.class,
				HttpMessageConvertersAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(
				this.context.getBeansOfType(ResourceHttpRequestHandler.class).get(
						"faviconRequestHandler"), is(notNullValue()));
		assertThat(
				this.context.getBeansOfType(SimpleUrlHandlerMapping.class).get(
						"faviconHandlerMapping"), is(notNullValue()));
		Map<String, List<Resource>> mappingLocations = getFaviconMappingLocations();
		assertThat(mappingLocations.get("/**/favicon.ico").size(), equalTo(5));
	}

	@Test
	public void faviconMappingDisabled() throws IllegalAccessException {
		this.context = new AnnotationConfigEmbeddedWebApplicationContext();
		this.context.register(Config.class, WebMvcAutoConfiguration.class,
				HttpMessageConvertersAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		EnvironmentTestUtils.addEnvironment(this.context,
				"spring.mvc.favicon.enabled:false");
		this.context.refresh();
		assertThat(
				this.context.getBeansOfType(ResourceHttpRequestHandler.class).get(
						"faviconRequestHandler"), is(nullValue()));
		assertThat(
				this.context.getBeansOfType(SimpleUrlHandlerMapping.class).get(
						"faviconHandlerMapping"), is(nullValue()));
	}

	@Test
	public void defaultAsyncRequestTimeout() throws Exception {
		this.context = new AnnotationConfigEmbeddedWebApplicationContext();
		this.context.register(Config.class, WebMvcAutoConfiguration.class,
				HttpMessageConvertersAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		RequestMappingHandlerAdapter adapter = this.context
				.getBean(RequestMappingHandlerAdapter.class);
		assertNull(ReflectionTestUtils.getField(adapter, "asyncRequestTimeout"));
	}

	@Test
	public void customAsyncRequestTimeout() throws Exception {
		this.context = new AnnotationConfigEmbeddedWebApplicationContext();
		EnvironmentTestUtils.addEnvironment(this.context,
				"spring.mvc.async.request-timeout:123456");
		this.context.register(Config.class, WebMvcAutoConfiguration.class,
				HttpMessageConvertersAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		RequestMappingHandlerAdapter adapter = this.context
				.getBean(RequestMappingHandlerAdapter.class);
		Object actual = ReflectionTestUtils.getField(adapter, "asyncRequestTimeout");
		assertEquals(123456L, actual);
	}

	@Configuration
	protected static class ViewConfig {

		@Bean
		public View jsonView() {
			return new AbstractView() {

				@Override
				protected void renderMergedOutputModel(Map<String, Object> model,
						HttpServletRequest request, HttpServletResponse response)
						throws Exception {
					response.getOutputStream().write("Hello World".getBytes());
				}
			};
		}

	}

	@Configuration
	protected static class WebJars extends WebMvcConfigurerAdapter {

		@Override
		public void addResourceHandlers(ResourceHandlerRegistry registry) {
			registry.addResourceHandler("/webjars/**").addResourceLocations(
					"classpath:/foo/");
		}

	}

	@Configuration
	protected static class AllResources extends WebMvcConfigurerAdapter {

		@Override
		public void addResourceHandlers(ResourceHandlerRegistry registry) {
			registry.addResourceHandler("/**").addResourceLocations("classpath:/foo/");
		}

	}

	@Configuration
	public static class Config {

		@Bean
		public EmbeddedServletContainerFactory containerFactory() {
			return containerFactory;
		}

		@Bean
		public EmbeddedServletContainerCustomizerBeanPostProcessor embeddedServletContainerCustomizerBeanPostProcessor() {
			return new EmbeddedServletContainerCustomizerBeanPostProcessor();
		}

	}

	@Configuration
	public static class CustomViewResolver {

		@Bean
		public ViewResolver viewResolver() {
			return new MyViewResolver();
		}

	}

	@Configuration
	public static class CustomContentNegotiatingViewResolver {

		@Bean
		public ContentNegotiatingViewResolver myViewResolver() {
			return new ContentNegotiatingViewResolver();
		}

	}

	private static class MyViewResolver implements ViewResolver {

		@Override
		public View resolveViewName(String viewName, Locale locale) throws Exception {
			return null;
		}

	}

}

<code block>


package org.springframework.boot.autoconfigure.web;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.validation.DefaultMessageCodesResolver;


@ConfigurationProperties("spring.mvc")
public class WebMvcProperties {


	private DefaultMessageCodesResolver.Format messageCodesResolverFormat;


	private String locale;


	private String dateFormat;


	private boolean ignoreDefaultModelOnRedirect = true;

	private final Async async = new Async();

	public DefaultMessageCodesResolver.Format getMessageCodesResolverFormat() {
		return this.messageCodesResolverFormat;
	}

	public void setMessageCodesResolverFormat(
			DefaultMessageCodesResolver.Format messageCodesResolverFormat) {
		this.messageCodesResolverFormat = messageCodesResolverFormat;
	}

	public String getLocale() {
		return this.locale;
	}

	public void setLocale(String locale) {
		this.locale = locale;
	}

	public String getDateFormat() {
		return this.dateFormat;
	}

	public void setDateFormat(String dateFormat) {
		this.dateFormat = dateFormat;
	}

	public boolean isIgnoreDefaultModelOnRedirect() {
		return this.ignoreDefaultModelOnRedirect;
	}

	public void setIgnoreDefaultModelOnRedirect(boolean ignoreDefaultModelOnRedirect) {
		this.ignoreDefaultModelOnRedirect = ignoreDefaultModelOnRedirect;
	}

	public Async getAsync() {
		return this.async;
	}

	public static class Async {


		private Long requestTimeout;

		public Long getRequestTimeout() {
			return this.requestTimeout;
		}

		public void setRequestTimeout(Long requestTimeout) {
			this.requestTimeout = requestTimeout;
		}

	}
}

<code block>


package org.springframework.boot.autoconfigure.web;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.joda.time.DateTime;
import org.junit.After;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.springframework.beans.factory.NoSuchBeanDefinitionException;
import org.springframework.boot.autoconfigure.PropertyPlaceholderAutoConfiguration;
import org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration.WebMvcAutoConfigurationAdapter;
import org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext;
import org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizerBeanPostProcessor;
import org.springframework.boot.context.embedded.EmbeddedServletContainerFactory;
import org.springframework.boot.context.embedded.MockEmbeddedServletContainerFactory;
import org.springframework.boot.test.EnvironmentTestUtils;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;
import org.springframework.format.support.FormattingConversionService;
import org.springframework.mock.web.MockHttpServletRequest;
import org.springframework.test.util.ReflectionTestUtils;
import org.springframework.util.ReflectionUtils;
import org.springframework.util.StringUtils;
import org.springframework.web.servlet.HandlerAdapter;
import org.springframework.web.servlet.HandlerMapping;
import org.springframework.web.servlet.LocaleResolver;
import org.springframework.web.servlet.View;
import org.springframework.web.servlet.ViewResolver;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;
import org.springframework.web.servlet.handler.SimpleUrlHandlerMapping;
import org.springframework.web.servlet.i18n.FixedLocaleResolver;
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter;
import org.springframework.web.servlet.resource.ResourceHttpRequestHandler;
import org.springframework.web.servlet.view.AbstractView;
import org.springframework.web.servlet.view.ContentNegotiatingViewResolver;

import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.instanceOf;
import static org.hamcrest.Matchers.is;
import static org.hamcrest.Matchers.notNullValue;
import static org.hamcrest.Matchers.nullValue;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertThat;


public class WebMvcAutoConfigurationTests {

	private static final MockEmbeddedServletContainerFactory containerFactory = new MockEmbeddedServletContainerFactory();

	@Rule
	public ExpectedException thrown = ExpectedException.none();

	private AnnotationConfigEmbeddedWebApplicationContext context;

	@After
	public void close() {
		if (this.context != null) {
			this.context.close();
		}
	}

	@Test
	public void handerAdaptersCreated() throws Exception {
		load();
		assertEquals(3, this.context.getBeanNamesForType(HandlerAdapter.class).length);
		assertFalse(this.context.getBean(RequestMappingHandlerAdapter.class)
				.getMessageConverters().isEmpty());
		assertEquals(this.context.getBean(HttpMessageConverters.class).getConverters(),
				this.context.getBean(RequestMappingHandlerAdapter.class)
						.getMessageConverters());
	}

	@Test
	public void handerMappingsCreated() throws Exception {
		load();
		assertEquals(6, this.context.getBeanNamesForType(HandlerMapping.class).length);
	}

	@Test
	public void resourceHandlerMapping() throws Exception {
		load();
		Map<String, List<Resource>> mappingLocations = getResourceMappingLocations();
		assertThat(mappingLocations.get("/**").size(), equalTo(5));
		assertThat(mappingLocations.get("/webjars/**").size(), equalTo(1));
		assertThat(mappingLocations.get("/webjars/**").get(0),
				equalTo((Resource) new ClassPathResource("/META-INF/resources/webjars/")));
	}

	@Test
	public void resourceHandlerMappingOverrideWebjars() throws Exception {
		load(WebJars.class);
		Map<String, List<Resource>> mappingLocations = getResourceMappingLocations();
		assertThat(mappingLocations.get("/webjars/**").size(), equalTo(1));
		assertThat(mappingLocations.get("/webjars/**").get(0),
				equalTo((Resource) new ClassPathResource("/foo/")));
	}

	@Test
	 public void resourceHandlerMappingOverrideAll() throws Exception {
		load(AllResources.class);
		Map<String, List<Resource>> mappingLocations = getResourceMappingLocations();
		assertThat(mappingLocations.get("/**").size(), equalTo(1));
		assertThat(mappingLocations.get("/**").get(0),
				equalTo((Resource) new ClassPathResource("/foo/")));
	}

	@Test
	public void resourceHandlerMappingDisabled() throws Exception {
		load("spring.resources.add-mappings:false");
		Map<String, List<Resource>> mappingLocations = getResourceMappingLocations();
		assertThat(mappingLocations.size(), equalTo(0));
	}

	@Test
	public void noLocaleResolver() throws Exception {
		load(AllResources.class);
		this.thrown.expect(NoSuchBeanDefinitionException.class);
		this.context.getBean(LocaleResolver.class);
	}

	@Test
	public void overrideLocale() throws Exception {
		load(AllResources.class, "spring.mvc.locale:en_UK");


		MockHttpServletRequest request = new MockHttpServletRequest();
		request.addPreferredLocale(StringUtils.parseLocaleString("nl_NL"));
		LocaleResolver localeResolver = this.context.getBean(LocaleResolver.class);
		Locale locale = localeResolver.resolveLocale(request);
		assertThat(localeResolver, instanceOf(FixedLocaleResolver.class));

		assertThat(locale.toString(), equalTo("en_UK"));
	}

	@Test
	public void noDateFormat() throws Exception {
		load(AllResources.class);
		FormattingConversionService cs = this.context
				.getBean(FormattingConversionService.class);
		Date date = new DateTime(1988, 6, 25, 20, 30).toDate();

		assertThat(cs.convert(date, String.class), equalTo(date.toString()));
	}

	@Test
	public void overrideDateFormat() throws Exception {
		load(AllResources.class, "spring.mvc.dateFormat:dd*MM*yyyy");
		FormattingConversionService cs = this.context
				.getBean(FormattingConversionService.class);
		Date date = new DateTime(1988, 6, 25, 20, 30).toDate();
		assertThat(cs.convert(date, String.class), equalTo("25*06*1988"));
	}

	@Test
	public void noMessageCodesResolver() throws Exception {
		load(AllResources.class);
		assertNull(this.context.getBean(WebMvcAutoConfigurationAdapter.class)
				.getMessageCodesResolver());
	}

	@Test
	public void overrideMessageCodesFormat() throws Exception {
		load(AllResources.class, "spring.mvc.messageCodesResolverFormat:POSTFIX_ERROR_CODE");
		assertNotNull(this.context.getBean(WebMvcAutoConfigurationAdapter.class)
				.getMessageCodesResolver());
	}

	protected Map<String, List<Resource>> getFaviconMappingLocations()
			throws IllegalAccessException {
		HandlerMapping mapping = (HandlerMapping) this.context
				.getBean("faviconHandlerMapping");
		return getMappingLocations(mapping);
	}

	protected Map<String, List<Resource>> getResourceMappingLocations()
			throws IllegalAccessException {
		HandlerMapping mapping = (HandlerMapping) this.context
				.getBean("resourceHandlerMapping");
		return getMappingLocations(mapping);
	}

	@SuppressWarnings("unchecked")
	protected Map<String, List<Resource>> getMappingLocations(HandlerMapping mapping)
			throws IllegalAccessException {
		Map<String, List<Resource>> mappingLocations = new LinkedHashMap<String, List<Resource>>();
		if (mapping instanceof SimpleUrlHandlerMapping) {
			Field locationsField = ReflectionUtils.findField(
					ResourceHttpRequestHandler.class, "locations");
			locationsField.setAccessible(true);
			for (Map.Entry<String, Object> entry : ((SimpleUrlHandlerMapping) mapping)
					.getHandlerMap().entrySet()) {
				ResourceHttpRequestHandler handler = (ResourceHttpRequestHandler) entry
						.getValue();
				mappingLocations.put(entry.getKey(),
						(List<Resource>) locationsField.get(handler));
			}
		}
		return mappingLocations;
	}

	@Test
	public void ignoreDefaultModelOnRedirectIsTrue() throws Exception {
		load();
		RequestMappingHandlerAdapter adapter = this.context
				.getBean(RequestMappingHandlerAdapter.class);
		assertEquals(true,
				ReflectionTestUtils.getField(adapter, "ignoreDefaultModelOnRedirect"));
	}

	@Test
	public void overrideIgnoreDefaultModelOnRedirect() throws Exception {
		this.context = new AnnotationConfigEmbeddedWebApplicationContext();
		EnvironmentTestUtils.addEnvironment(this.context,
				"spring.mvc.ignore-default-model-on-redirect:false");
		this.context.register(Config.class, WebMvcAutoConfiguration.class,
				HttpMessageConvertersAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		RequestMappingHandlerAdapter adapter = this.context
				.getBean(RequestMappingHandlerAdapter.class);
		assertEquals(false,
				ReflectionTestUtils.getField(adapter, "ignoreDefaultModelOnRedirect"));
	}

	@Test
	public void customViewResolver() throws Exception {
		load(CustomViewResolver.class);
		assertThat(this.context.getBean("viewResolver"), instanceOf(MyViewResolver.class));
	}

	@Test
	public void customContentNegotiatingViewResolver() throws Exception {
		load(CustomContentNegotiatingViewResolver.class);
		Map<String, ContentNegotiatingViewResolver> beans = this.context
				.getBeansOfType(ContentNegotiatingViewResolver.class);
		assertThat(beans.size(), equalTo(1));
		assertThat(beans.keySet().iterator().next(), equalTo("myViewResolver"));
	}

	@Test
	public void faviconMapping() throws IllegalAccessException {
		load();
		assertThat(
				this.context.getBeansOfType(ResourceHttpRequestHandler.class).get(
						"faviconRequestHandler"), is(notNullValue()));
		assertThat(
				this.context.getBeansOfType(SimpleUrlHandlerMapping.class).get(
						"faviconHandlerMapping"), is(notNullValue()));
		Map<String, List<Resource>> mappingLocations = getFaviconMappingLocations();
		assertThat(mappingLocations.get("/**/favicon.ico").size(), equalTo(5));
	}

	@Test
	public void faviconMappingDisabled() throws IllegalAccessException {
		load("spring.mvc.favicon.enabled:false");
		assertThat(
				this.context.getBeansOfType(ResourceHttpRequestHandler.class).get(
						"faviconRequestHandler"), is(nullValue()));
		assertThat(
				this.context.getBeansOfType(SimpleUrlHandlerMapping.class).get(
						"faviconHandlerMapping"), is(nullValue()));
	}

	@Test
	public void defaultAsyncRequestTimeout() throws Exception {
		load();
		RequestMappingHandlerAdapter adapter = this.context
				.getBean(RequestMappingHandlerAdapter.class);
		assertNull(ReflectionTestUtils.getField(adapter, "asyncRequestTimeout"));
	}

	@Test
	public void customAsyncRequestTimeout() throws Exception {
		load("spring.mvc.async.request-timeout:123456");
		RequestMappingHandlerAdapter adapter = this.context
				.getBean(RequestMappingHandlerAdapter.class);
		Object actual = ReflectionTestUtils.getField(adapter, "asyncRequestTimeout");
		assertEquals(123456L, actual);
	}


	@SuppressWarnings("unchecked")
	private void load(Class<?> config, String... environment) {
		this.context = new AnnotationConfigEmbeddedWebApplicationContext();
		EnvironmentTestUtils.addEnvironment(this.context, environment);
		List<Class<?>> configClasses = new ArrayList<Class<?>>();
		if (config != null) {
			configClasses.add(config);
		}
		configClasses.addAll(Arrays.asList(Config.class, WebMvcAutoConfiguration.class,
				HttpMessageConvertersAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class));
		this.context.register(configClasses.toArray(new Class<?>[configClasses.size()]));
		this.context.refresh();
	}

	private void load(String... environment) {
		load(null, environment);
	}


	@Configuration
	protected static class ViewConfig {

		@Bean
		public View jsonView() {
			return new AbstractView() {

				@Override
				protected void renderMergedOutputModel(Map<String, Object> model,
						HttpServletRequest request, HttpServletResponse response)
						throws Exception {
					response.getOutputStream().write("Hello World".getBytes());
				}
			};
		}

	}

	@Configuration
	protected static class WebJars extends WebMvcConfigurerAdapter {

		@Override
		public void addResourceHandlers(ResourceHandlerRegistry registry) {
			registry.addResourceHandler("/webjars/**").addResourceLocations(
					"classpath:/foo/");
		}

	}

	@Configuration
	protected static class AllResources extends WebMvcConfigurerAdapter {

		@Override
		public void addResourceHandlers(ResourceHandlerRegistry registry) {
			registry.addResourceHandler("/**").addResourceLocations("classpath:/foo/");
		}

	}

	@Configuration
	public static class Config {

		@Bean
		public EmbeddedServletContainerFactory containerFactory() {
			return containerFactory;
		}

		@Bean
		public EmbeddedServletContainerCustomizerBeanPostProcessor embeddedServletContainerCustomizerBeanPostProcessor() {
			return new EmbeddedServletContainerCustomizerBeanPostProcessor();
		}

	}

	@Configuration
	public static class CustomViewResolver {

		@Bean
		public ViewResolver viewResolver() {
			return new MyViewResolver();
		}

	}

	@Configuration
	public static class CustomContentNegotiatingViewResolver {

		@Bean
		public ContentNegotiatingViewResolver myViewResolver() {
			return new ContentNegotiatingViewResolver();
		}

	}

	private static class MyViewResolver implements ViewResolver {

		@Override
		public View resolveViewName(String viewName, Locale locale) throws Exception {
			return null;
		}

	}

}

<code block>


package org.springframework.boot.actuate.system;

import java.io.File;
import java.io.IOException;
import java.util.concurrent.atomic.AtomicBoolean;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.boot.ApplicationPid;
import org.springframework.boot.bind.RelaxedPropertyResolver;
import org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent;
import org.springframework.boot.context.event.ApplicationPreparedEvent;
import org.springframework.boot.context.event.SpringApplicationEvent;
import org.springframework.context.ApplicationListener;
import org.springframework.core.Ordered;
import org.springframework.core.env.Environment;
import org.springframework.util.Assert;


public class ApplicationPidFileWriter implements
		ApplicationListener<SpringApplicationEvent>, Ordered {

	private static final Log logger = LogFactory.getLog(ApplicationPidFileWriter.class);

	private static final String DEFAULT_FILE_NAME = "application.pid";

	private static final String[] SYSTEM_PROPERTY_VARIABLES = { "PIDFILE", "pidfile" };

	private static final String SPRING_PROPERTY = "spring.pidfile";

	private static final AtomicBoolean created = new AtomicBoolean(false);

	private int order = Ordered.HIGHEST_PRECEDENCE + 13;

	private final File file;

	private Class<? extends SpringApplicationEvent> triggerEventType = ApplicationPreparedEvent.class;


	public ApplicationPidFileWriter() {
		this(new File(DEFAULT_FILE_NAME));
	}


	public ApplicationPidFileWriter(String filename) {
		this(new File(filename));
	}


	public ApplicationPidFileWriter(File file) {
		Assert.notNull(file, "File must not be null");
		this.file = file;
	}


	public void setTriggerEventType(
			Class<? extends SpringApplicationEvent> triggerEventType) {
		Assert.notNull(triggerEventType, "Trigger event type must not be null");
		this.triggerEventType = triggerEventType;
	}

	@Override
	public void onApplicationEvent(SpringApplicationEvent event) {
		if (this.triggerEventType.isInstance(event)) {
			if (created.compareAndSet(false, true)) {
				try {
					writePidFile(event);
				}
				catch (Exception ex) {
					logger.warn(String.format("Cannot create pid file %s", this.file), ex);
				}
			}
		}
	}

	private void writePidFile(SpringApplicationEvent event) throws IOException {
		File pidFile = this.file;
		String override = SystemProperties.get(SYSTEM_PROPERTY_VARIABLES);
		if (override != null) {
			pidFile = new File(override);
		}
		else {
			Environment environment = getEnvironment(event);
			if (environment != null) {
				override = new RelaxedPropertyResolver(environment)
						.getProperty(SPRING_PROPERTY);
				if (override != null) {
					pidFile = new File(override);
				}
			}
		}
		new ApplicationPid().write(pidFile);
		pidFile.deleteOnExit();
	}

	private Environment getEnvironment(SpringApplicationEvent event) {
		if (event instanceof ApplicationEnvironmentPreparedEvent) {
			return ((ApplicationEnvironmentPreparedEvent) event).getEnvironment();
		}
		if (event instanceof ApplicationPreparedEvent) {
			return ((ApplicationPreparedEvent) event).getApplicationContext()
					.getEnvironment();
		}
		return null;
	}

	public void setOrder(int order) {
		this.order = order;
	}

	@Override
	public int getOrder() {
		return this.order;
	}


	static void reset() {
		created.set(false);
	}
}

<code block>


package org.springframework.boot.actuate.system;


class SystemProperties {

	public static String get(String... properties) {
		for (String property : properties) {
			try {
				String override = System.getProperty(property);
				override = (override != null ? override : System.getenv(property));
				if (override != null) {
					return override;
				}
			}
			catch (Throwable ex) {
				System.err.println("Could not resolve '" + property
						+ "' as system property: " + ex);
			}
		}
		return null;
	}

}

<code block>


package org.springframework.boot.actuate.system;

import java.io.File;
import java.io.FileReader;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent;
import org.springframework.boot.context.event.ApplicationPreparedEvent;
import org.springframework.boot.context.event.ApplicationStartedEvent;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.core.env.ConfigurableEnvironment;
import org.springframework.core.env.StandardEnvironment;
import org.springframework.mock.env.MockPropertySource;
import org.springframework.util.FileCopyUtils;

import static org.hamcrest.Matchers.isEmptyString;
import static org.hamcrest.Matchers.not;
import static org.junit.Assert.assertThat;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.mock;


public class ApplicationPidFileWriterTests {

	private static final ApplicationPreparedEvent EVENT = new ApplicationPreparedEvent(
			new SpringApplication(), new String[] {},
			mock(ConfigurableApplicationContext.class));

	@Rule
	public TemporaryFolder temporaryFolder = new TemporaryFolder();

	@Before
	@After
	public void resetListener() {
		System.clearProperty("PIDFILE");
		ApplicationPidFileWriter.reset();
	}

	@Test
	public void createPidFile() throws Exception {
		File file = this.temporaryFolder.newFile();
		ApplicationPidFileWriter listener = new ApplicationPidFileWriter(file);
		listener.onApplicationEvent(EVENT);
		assertThat(FileCopyUtils.copyToString(new FileReader(file)), not(isEmptyString()));
	}

	@Test
	public void overridePidFile() throws Exception {
		File file = this.temporaryFolder.newFile();
		System.setProperty("PIDFILE", this.temporaryFolder.newFile().getAbsolutePath());
		ApplicationPidFileWriter listener = new ApplicationPidFileWriter(file);
		listener.onApplicationEvent(EVENT);
		assertThat(
				FileCopyUtils.copyToString(new FileReader(System.getProperty("PIDFILE"))),
				not(isEmptyString()));
	}

	@Test
	public void overridePidFileWithSpring() throws Exception {
		File file = this.temporaryFolder.newFile();
		ConfigurableEnvironment environment = new StandardEnvironment();
		MockPropertySource propertySource = new MockPropertySource();
		propertySource.setProperty("spring.pidfile", file.getAbsolutePath());
		environment.getPropertySources().addLast(propertySource);
		ConfigurableApplicationContext context = mock(ConfigurableApplicationContext.class);
		given(context.getEnvironment()).willReturn(environment);
		ApplicationPreparedEvent event = new ApplicationPreparedEvent(
				new SpringApplication(), new String[] {}, context);
		ApplicationPidFileWriter listener = new ApplicationPidFileWriter();
		listener.onApplicationEvent(event);
		assertThat(FileCopyUtils.copyToString(new FileReader(file)), not(isEmptyString()));
	}

	@Test
	public void differentEventTypes() throws Exception {
		File file = this.temporaryFolder.newFile();
		ConfigurableEnvironment environment = new StandardEnvironment();
		MockPropertySource propertySource = new MockPropertySource();
		propertySource.setProperty("spring.pidfile", file.getAbsolutePath());
		environment.getPropertySources().addLast(propertySource);
		ApplicationEnvironmentPreparedEvent event = new ApplicationEnvironmentPreparedEvent(
				new SpringApplication(), new String[] {}, environment);
		ApplicationPidFileWriter listener = new ApplicationPidFileWriter();
		listener.onApplicationEvent(event);
		assertThat(FileCopyUtils.copyToString(new FileReader(file)), isEmptyString());
		listener.setTriggerEventType(ApplicationEnvironmentPreparedEvent.class);
		listener.onApplicationEvent(event);
		assertThat(FileCopyUtils.copyToString(new FileReader(file)), not(isEmptyString()));
	}

	@Test
	public void withNoEnvironment() throws Exception {
		File file = this.temporaryFolder.newFile();
		ApplicationPidFileWriter listener = new ApplicationPidFileWriter(file);
		listener.setTriggerEventType(ApplicationStartedEvent.class);
		listener.onApplicationEvent(new ApplicationStartedEvent(new SpringApplication(),
				new String[] {}));
		assertThat(FileCopyUtils.copyToString(new FileReader(file)), not(isEmptyString()));
	}

}

<code block>


package org.springframework.boot.actuate.system;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.boot.ApplicationPid;
import org.springframework.boot.bind.RelaxedPropertyResolver;
import org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent;
import org.springframework.boot.context.event.ApplicationPreparedEvent;
import org.springframework.boot.context.event.SpringApplicationEvent;
import org.springframework.context.ApplicationListener;
import org.springframework.core.Ordered;
import org.springframework.core.env.Environment;
import org.springframework.util.Assert;


public class ApplicationPidFileWriter implements
		ApplicationListener<SpringApplicationEvent>, Ordered {

	private static final Log logger = LogFactory.getLog(ApplicationPidFileWriter.class);

	private static final String DEFAULT_FILE_NAME = "application.pid";

	private static final List<Property> FILE_PROPERTIES;
	static {
		List<Property> properties = new ArrayList<Property>();
		properties.add(new SpringProperty("spring.pid.", "file"));
		properties.add(new SpringProperty("spring.", "pidfile"));
		properties.add(new SystemProperty("PIDFILE"));
		FILE_PROPERTIES = Collections.unmodifiableList(properties);
	}

	private static final List<Property> FAIL_ON_WRITE_ERROR_PROPERTIES;
	static {
		List<Property> properties = new ArrayList<Property>();
		properties.add(new SpringProperty("spring.pid.", "fail-on-write-error"));
		properties.add(new SystemProperty("PID_FAIL_ON_WRITE_ERROR"));
		FAIL_ON_WRITE_ERROR_PROPERTIES = Collections.unmodifiableList(properties);
	}

	private static final AtomicBoolean created = new AtomicBoolean(false);

	private int order = Ordered.HIGHEST_PRECEDENCE + 13;

	private final File file;

	private Class<? extends SpringApplicationEvent> triggerEventType = ApplicationPreparedEvent.class;


	public ApplicationPidFileWriter() {
		this(new File(DEFAULT_FILE_NAME));
	}


	public ApplicationPidFileWriter(String filename) {
		this(new File(filename));
	}


	public ApplicationPidFileWriter(File file) {
		Assert.notNull(file, "File must not be null");
		this.file = file;
	}


	public void setTriggerEventType(
			Class<? extends SpringApplicationEvent> triggerEventType) {
		Assert.notNull(triggerEventType, "Trigger event type must not be null");
		this.triggerEventType = triggerEventType;
	}

	@Override
	public void onApplicationEvent(SpringApplicationEvent event) {
		if (this.triggerEventType.isInstance(event)) {
			if (created.compareAndSet(false, true)) {
				try {
					writePidFile(event);
				}
				catch (Exception ex) {
					String message = String
							.format("Cannot create pid file %s", this.file);
					if (failOnWriteError(event)) {
						throw new IllegalStateException(message, ex);
					}
					logger.warn(message, ex);
				}
			}
		}
	}

	private void writePidFile(SpringApplicationEvent event) throws IOException {
		File pidFile = this.file;
		String override = getProperty(event, FILE_PROPERTIES);
		if (override != null) {
			pidFile = new File(override);
		}
		new ApplicationPid().write(pidFile);
		pidFile.deleteOnExit();
	}

	private boolean failOnWriteError(SpringApplicationEvent event) {
		String value = getProperty(event, FAIL_ON_WRITE_ERROR_PROPERTIES);
		return (value == null ? false : Boolean.parseBoolean(value));
	}

	private String getProperty(SpringApplicationEvent event, List<Property> candidates) {
		for (Property candidate : candidates) {
			String value = candidate.getValue(event);
			if (value != null) {
				return value;
			}
		}
		return null;
	}

	public void setOrder(int order) {
		this.order = order;
	}

	@Override
	public int getOrder() {
		return this.order;
	}


	static void reset() {
		created.set(false);
	}


	private static interface Property {

		String getValue(SpringApplicationEvent event);

	}


	private static class SpringProperty implements Property {

		private final String prexfix;

		private final String key;

		public SpringProperty(String prefix, String key) {
			this.prexfix = prefix;
			this.key = key;
		}

		@Override
		public String getValue(SpringApplicationEvent event) {
			Environment environment = getEnvironment(event);
			if (environment == null) {
				return null;
			}
			return new RelaxedPropertyResolver(environment, this.prexfix)
					.getProperty(this.key);
		}

		private Environment getEnvironment(SpringApplicationEvent event) {
			if (event instanceof ApplicationEnvironmentPreparedEvent) {
				return ((ApplicationEnvironmentPreparedEvent) event).getEnvironment();
			}
			if (event instanceof ApplicationPreparedEvent) {
				return ((ApplicationPreparedEvent) event).getApplicationContext()
						.getEnvironment();
			}
			return null;
		}

	}


	private static class SystemProperty implements Property {

		private final String[] properties;

		public SystemProperty(String name) {
			this.properties = new String[] { name.toUpperCase(), name.toLowerCase() };
		}

		@Override
		public String getValue(SpringApplicationEvent event) {
			return SystemProperties.get(this.properties);
		}

	}

}

<code block>


package org.springframework.boot.actuate.system;


class SystemProperties {

	public static String get(String... properties) {
		for (String property : properties) {
			try {
				String override = System.getProperty(property);
				override = (override != null ? override : System.getenv(property));
				if (override != null) {
					return override;
				}
			}
			catch (Throwable ex) {
				System.err.println("Could not resolve '" + property
						+ "' as system property: " + ex);
			}
		}
		return null;
	}

}

<code block>


package org.springframework.boot.actuate.system;

import java.io.File;
import java.io.FileReader;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.rules.TemporaryFolder;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent;
import org.springframework.boot.context.event.ApplicationPreparedEvent;
import org.springframework.boot.context.event.ApplicationStartedEvent;
import org.springframework.boot.context.event.SpringApplicationEvent;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.core.env.ConfigurableEnvironment;
import org.springframework.core.env.StandardEnvironment;
import org.springframework.mock.env.MockPropertySource;
import org.springframework.util.FileCopyUtils;

import static org.hamcrest.Matchers.isEmptyString;
import static org.hamcrest.Matchers.not;
import static org.junit.Assert.assertThat;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.mock;


public class ApplicationPidFileWriterTests {

	private static final ApplicationPreparedEvent EVENT = new ApplicationPreparedEvent(
			new SpringApplication(), new String[] {},
			mock(ConfigurableApplicationContext.class));

	@Rule
	public TemporaryFolder temporaryFolder = new TemporaryFolder();

	@Rule
	public ExpectedException exception = ExpectedException.none();

	@Before
	@After
	public void resetListener() {
		System.clearProperty("PIDFILE");
		System.clearProperty("PID_FAIL_ON_WRITE_ERROR");
		ApplicationPidFileWriter.reset();
	}

	@Test
	public void createPidFile() throws Exception {
		File file = this.temporaryFolder.newFile();
		ApplicationPidFileWriter listener = new ApplicationPidFileWriter(file);
		listener.onApplicationEvent(EVENT);
		assertThat(FileCopyUtils.copyToString(new FileReader(file)), not(isEmptyString()));
	}

	@Test
	public void overridePidFile() throws Exception {
		File file = this.temporaryFolder.newFile();
		System.setProperty("PIDFILE", this.temporaryFolder.newFile().getAbsolutePath());
		ApplicationPidFileWriter listener = new ApplicationPidFileWriter(file);
		listener.onApplicationEvent(EVENT);
		assertThat(
				FileCopyUtils.copyToString(new FileReader(System.getProperty("PIDFILE"))),
				not(isEmptyString()));
	}

	@Test
	public void overridePidFileWithSpring() throws Exception {
		File file = this.temporaryFolder.newFile();
		SpringApplicationEvent event = createPreparedEvent("spring.pidfile",
				file.getAbsolutePath());
		ApplicationPidFileWriter listener = new ApplicationPidFileWriter();
		listener.onApplicationEvent(event);
		assertThat(FileCopyUtils.copyToString(new FileReader(file)), not(isEmptyString()));
	}

	@Test
	public void differentEventTypes() throws Exception {
		File file = this.temporaryFolder.newFile();
		SpringApplicationEvent event = createEnvironmentPreparedEvent("spring.pidfile",
				file.getAbsolutePath());
		ApplicationPidFileWriter listener = new ApplicationPidFileWriter();
		listener.onApplicationEvent(event);
		assertThat(FileCopyUtils.copyToString(new FileReader(file)), isEmptyString());
		listener.setTriggerEventType(ApplicationEnvironmentPreparedEvent.class);
		listener.onApplicationEvent(event);
		assertThat(FileCopyUtils.copyToString(new FileReader(file)), not(isEmptyString()));
	}

	@Test
	public void withNoEnvironment() throws Exception {
		File file = this.temporaryFolder.newFile();
		ApplicationPidFileWriter listener = new ApplicationPidFileWriter(file);
		listener.setTriggerEventType(ApplicationStartedEvent.class);
		listener.onApplicationEvent(new ApplicationStartedEvent(new SpringApplication(),
				new String[] {}));
		assertThat(FileCopyUtils.copyToString(new FileReader(file)), not(isEmptyString()));
	}

	@Test
	public void continueWhenPidFileIsReadOnly() throws Exception {
		File file = this.temporaryFolder.newFile();
		file.setReadOnly();
		ApplicationPidFileWriter listener = new ApplicationPidFileWriter(file);
		listener.onApplicationEvent(EVENT);
		assertThat(FileCopyUtils.copyToString(new FileReader(file)), isEmptyString());
	}

	@Test
	public void throwWhenPidFileIsReadOnly() throws Exception {
		File file = this.temporaryFolder.newFile();
		file.setReadOnly();
		System.setProperty("PID_FAIL_ON_WRITE_ERROR", "true");
		ApplicationPidFileWriter listener = new ApplicationPidFileWriter(file);
		this.exception.expect(IllegalStateException.class);
		this.exception.expectMessage("Cannot create pid file");
		listener.onApplicationEvent(EVENT);
	}

	@Test
	public void throwWhenPidFileIsReadOnlyWithSpring() throws Exception {
		File file = this.temporaryFolder.newFile();
		file.setReadOnly();
		SpringApplicationEvent event = createPreparedEvent(
				"spring.pid.fail-on-write-error", "true");
		ApplicationPidFileWriter listener = new ApplicationPidFileWriter(file);
		this.exception.expect(IllegalStateException.class);
		this.exception.expectMessage("Cannot create pid file");
		listener.onApplicationEvent(event);
	}

	private SpringApplicationEvent createEnvironmentPreparedEvent(String propName,
			String propValue) {
		ConfigurableEnvironment environment = createEnvironment(propName, propValue);
		return new ApplicationEnvironmentPreparedEvent(new SpringApplication(),
				new String[] {}, environment);
	}

	private SpringApplicationEvent createPreparedEvent(String propName, String propValue) {
		ConfigurableEnvironment environment = createEnvironment(propName, propValue);
		ConfigurableApplicationContext context = mock(ConfigurableApplicationContext.class);
		given(context.getEnvironment()).willReturn(environment);
		return new ApplicationPreparedEvent(new SpringApplication(), new String[] {},
				context);
	}

	private ConfigurableEnvironment createEnvironment(String propName, String propValue) {
		MockPropertySource propertySource = mockPropertySource(propName, propValue);
		ConfigurableEnvironment environment = new StandardEnvironment();
		environment.getPropertySources().addLast(propertySource);
		return environment;
	}

	private MockPropertySource mockPropertySource(String name, String value) {
		MockPropertySource propertySource = new MockPropertySource();
		propertySource.setProperty(name, value);
		return propertySource;
	}

}

<code block>


package org.springframework.boot.cli.compiler;

import java.io.File;
import java.net.URI;
import java.util.ArrayList;
import java.util.List;

import org.apache.maven.settings.Settings;
import org.apache.maven.settings.building.DefaultSettingsBuilderFactory;
import org.apache.maven.settings.building.DefaultSettingsBuildingRequest;
import org.apache.maven.settings.building.SettingsBuildingException;
import org.apache.maven.settings.building.SettingsBuildingRequest;
import org.springframework.boot.cli.compiler.grape.RepositoryConfiguration;
import org.springframework.util.StringUtils;


public final class RepositoryConfigurationFactory {

	private static final RepositoryConfiguration MAVEN_CENTRAL = new RepositoryConfiguration(
			"central", URI.create("http://repo1.maven.org/maven2/"), false);

	private static final RepositoryConfiguration SPRING_MILESTONE = new RepositoryConfiguration(
			"spring-milestone", URI.create("http://repo.spring.io/milestone"), false);

	private static final RepositoryConfiguration SPRING_SNAPSHOT = new RepositoryConfiguration(
			"spring-snapshot", URI.create("http://repo.spring.io/snapshot"), true);


	public static List<RepositoryConfiguration> createDefaultRepositoryConfiguration() {
		List<RepositoryConfiguration> repositoryConfiguration = new ArrayList<RepositoryConfiguration>();

		repositoryConfiguration.add(MAVEN_CENTRAL);

		if (!Boolean.getBoolean("disableSpringSnapshotRepos")) {
			repositoryConfiguration.add(SPRING_MILESTONE);
			repositoryConfiguration.add(SPRING_SNAPSHOT);
		}

		addDefaultCacheAsRepository(repositoryConfiguration);
		return repositoryConfiguration;
	}


	public static void addDefaultCacheAsRepository(
			List<RepositoryConfiguration> repositoryConfiguration) {
		RepositoryConfiguration repository = new RepositoryConfiguration("local",
				getLocalRepositoryDirectory().toURI(), true);
		if (!repositoryConfiguration.contains(repository)) {
			repositoryConfiguration.add(0, repository);
		}
	}

	private static File getLocalRepositoryDirectory() {
		String localRepository = loadSettings().getLocalRepository();
		if (StringUtils.hasText(localRepository)) {
			return new File(localRepository);
		}
		return new File(getM2HomeDirectory(), "repository");
	}

	private static Settings loadSettings() {
		File settingsFile = new File(System.getProperty("user.home"), ".m2/settings.xml");
		SettingsBuildingRequest request = new DefaultSettingsBuildingRequest();
		request.setUserSettingsFile(settingsFile);
		request.setSystemProperties(System.getProperties());
		try {
			return new DefaultSettingsBuilderFactory().newInstance().build(request)
					.getEffectiveSettings();
		}
		catch (SettingsBuildingException ex) {
			throw new IllegalStateException("Failed to build settings from "
					+ settingsFile, ex);
		}
	}

	private static File getM2HomeDirectory() {
		String mavenRoot = System.getProperty("maven.home");
		if (StringUtils.hasLength(mavenRoot)) {
			return new File(mavenRoot);
		}
		return new File(System.getProperty("user.home"), ".m2");
	}

}

<code block>


package org.springframework.boot.cli.compiler.grape;

import java.io.File;
import java.lang.reflect.Field;
import java.util.List;

import org.apache.maven.settings.Mirror;
import org.apache.maven.settings.Proxy;
import org.apache.maven.settings.Server;
import org.apache.maven.settings.Settings;
import org.apache.maven.settings.building.DefaultSettingsBuilderFactory;
import org.apache.maven.settings.building.DefaultSettingsBuildingRequest;
import org.apache.maven.settings.building.SettingsBuildingException;
import org.apache.maven.settings.building.SettingsBuildingRequest;
import org.apache.maven.settings.crypto.DefaultSettingsDecrypter;
import org.apache.maven.settings.crypto.DefaultSettingsDecryptionRequest;
import org.apache.maven.settings.crypto.SettingsDecrypter;
import org.apache.maven.settings.crypto.SettingsDecryptionResult;
import org.eclipse.aether.DefaultRepositorySystemSession;
import org.eclipse.aether.RepositorySystem;
import org.eclipse.aether.repository.Authentication;
import org.eclipse.aether.repository.AuthenticationSelector;
import org.eclipse.aether.repository.LocalRepository;
import org.eclipse.aether.repository.MirrorSelector;
import org.eclipse.aether.repository.ProxySelector;
import org.eclipse.aether.util.repository.AuthenticationBuilder;
import org.eclipse.aether.util.repository.ConservativeAuthenticationSelector;
import org.eclipse.aether.util.repository.DefaultAuthenticationSelector;
import org.eclipse.aether.util.repository.DefaultMirrorSelector;
import org.eclipse.aether.util.repository.DefaultProxySelector;
import org.sonatype.plexus.components.cipher.DefaultPlexusCipher;
import org.sonatype.plexus.components.cipher.PlexusCipherException;
import org.sonatype.plexus.components.sec.dispatcher.DefaultSecDispatcher;
import org.springframework.boot.cli.util.Log;


public class SettingsXmlRepositorySystemSessionAutoConfiguration implements
		RepositorySystemSessionAutoConfiguration {

	private final String homeDir;

	public SettingsXmlRepositorySystemSessionAutoConfiguration() {
		this(System.getProperty("user.home"));
	}

	SettingsXmlRepositorySystemSessionAutoConfiguration(String homeDir) {
		this.homeDir = homeDir;
	}

	@Override
	public void apply(DefaultRepositorySystemSession session,
			RepositorySystem repositorySystem) {

		Settings settings = loadSettings();
		SettingsDecryptionResult decryptionResult = decryptSettings(settings);
		if (!decryptionResult.getProblems().isEmpty()) {
			Log.error("Maven settings decryption failed. Some Maven repositories may be inaccessible");

		}

		session.setOffline(settings.isOffline());
		session.setMirrorSelector(createMirrorSelector(settings));
		session.setAuthenticationSelector(createAuthenticationSelector(decryptionResult
				.getServers()));
		session.setProxySelector(createProxySelector(decryptionResult.getProxies()));

		String localRepository = settings.getLocalRepository();
		if (localRepository != null) {
			session.setLocalRepositoryManager(repositorySystem.newLocalRepositoryManager(
					session, new LocalRepository(localRepository)));
		}
	}

	private Settings loadSettings() {
		File settingsFile = new File(this.homeDir, ".m2/settings.xml");
		SettingsBuildingRequest request = new DefaultSettingsBuildingRequest();
		request.setUserSettingsFile(settingsFile);
		request.setSystemProperties(System.getProperties());
		try {
			return new DefaultSettingsBuilderFactory().newInstance().build(request)
					.getEffectiveSettings();
		}
		catch (SettingsBuildingException ex) {
			throw new IllegalStateException("Failed to build settings from "
					+ settingsFile, ex);
		}
	}

	private SettingsDecryptionResult decryptSettings(Settings settings) {
		DefaultSettingsDecryptionRequest request = new DefaultSettingsDecryptionRequest(
				settings);

		return createSettingsDecrypter().decrypt(request);
	}

	private SettingsDecrypter createSettingsDecrypter() {
		SettingsDecrypter settingsDecrypter = new DefaultSettingsDecrypter();
		setField(DefaultSettingsDecrypter.class, "securityDispatcher", settingsDecrypter,
				new SpringBootSecDispatcher());
		return settingsDecrypter;
	}

	private void setField(Class<?> clazz, String fieldName, Object target, Object value) {
		try {
			Field field = clazz.getDeclaredField(fieldName);
			field.setAccessible(true);
			field.set(target, value);
		}
		catch (Exception e) {
			throw new IllegalStateException("Failed to set field '" + fieldName
					+ "' on '" + target + "'", e);
		}
	}

	private MirrorSelector createMirrorSelector(Settings settings) {
		DefaultMirrorSelector selector = new DefaultMirrorSelector();
		for (Mirror mirror : settings.getMirrors()) {
			selector.add(mirror.getId(), mirror.getUrl(), mirror.getLayout(), false,
					mirror.getMirrorOf(), mirror.getMirrorOfLayouts());
		}
		return selector;
	}

	private AuthenticationSelector createAuthenticationSelector(List<Server> servers) {
		DefaultAuthenticationSelector selector = new DefaultAuthenticationSelector();
		for (Server server : servers) {
			AuthenticationBuilder auth = new AuthenticationBuilder();
			auth.addUsername(server.getUsername()).addPassword(server.getPassword());
			auth.addPrivateKey(server.getPrivateKey(), server.getPassphrase());
			selector.add(server.getId(), auth.build());
		}
		return new ConservativeAuthenticationSelector(selector);
	}

	private ProxySelector createProxySelector(List<Proxy> proxies) {
		DefaultProxySelector selector = new DefaultProxySelector();
		for (Proxy proxy : proxies) {
			Authentication authentication = new AuthenticationBuilder()
					.addUsername(proxy.getUsername()).addPassword(proxy.getPassword())
					.build();
			selector.add(new org.eclipse.aether.repository.Proxy(proxy.getProtocol(),
					proxy.getHost(), proxy.getPort(), authentication), proxy
					.getNonProxyHosts());
		}
		return selector;
	}

	private class SpringBootSecDispatcher extends DefaultSecDispatcher {

		public SpringBootSecDispatcher() {
			this._configurationFile = new File(
					SettingsXmlRepositorySystemSessionAutoConfiguration.this.homeDir,
					".m2/settings-security.xml").getAbsolutePath();
			try {
				this._cipher = new DefaultPlexusCipher();
			}
			catch (PlexusCipherException e) {
				throw new IllegalStateException(e);
			}
		}
	}
}

<code block>


package org.springframework.boot.cli.compiler.grape;

import java.io.File;

import org.apache.maven.repository.internal.MavenRepositorySystemUtils;
import org.apache.maven.settings.building.SettingsBuildingException;
import org.eclipse.aether.DefaultRepositorySystemSession;
import org.eclipse.aether.RepositorySystem;
import org.eclipse.aether.internal.impl.SimpleLocalRepositoryManagerFactory;
import org.eclipse.aether.repository.Authentication;
import org.eclipse.aether.repository.AuthenticationContext;
import org.eclipse.aether.repository.LocalRepository;
import org.eclipse.aether.repository.LocalRepositoryManager;
import org.eclipse.aether.repository.Proxy;
import org.eclipse.aether.repository.RemoteRepository;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.runners.MockitoJUnitRunner;
import org.mockito.stubbing.Answer;

import static org.hamcrest.Matchers.endsWith;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertThat;
import static org.mockito.BDDMockito.given;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.eq;


@RunWith(MockitoJUnitRunner.class)
public class SettingsXmlRepositorySystemSessionAutoConfigurationTests {

	@Rule
	public ExpectedException thrown = ExpectedException.none();

	@Mock
	private RepositorySystem repositorySystem;

	@Test
	public void basicSessionCustomization() throws SettingsBuildingException {
		assertSessionCustomization("src/test/resources/maven-settings/basic");
	}

	@Test
	public void encryptedSettingsSessionCustomization() throws SettingsBuildingException {
		assertSessionCustomization("src/test/resources/maven-settings/encrypted");
	}

	@Test
	public void propertyInterpolation() throws SettingsBuildingException {
		final DefaultRepositorySystemSession session = MavenRepositorySystemUtils
				.newSession();
		given(
				this.repositorySystem.newLocalRepositoryManager(eq(session),
						any(LocalRepository.class))).willAnswer(
				new Answer<LocalRepositoryManager>() {

					@Override
					public LocalRepositoryManager answer(InvocationOnMock invocation)
							throws Throwable {
						LocalRepository localRepository = invocation.getArgumentAt(1,
								LocalRepository.class);
						return new SimpleLocalRepositoryManagerFactory().newInstance(
								session, localRepository);
					}
				});

		System.setProperty("foo", "bar");
		try {
			new SettingsXmlRepositorySystemSessionAutoConfiguration(
					"src/test/resources/maven-settings/property-interpolation").apply(
					session, this.repositorySystem);
		}
		finally {
			System.clearProperty("foo");
		}

		assertThat(session.getLocalRepository().getBasedir().getAbsolutePath(),
				endsWith(File.separatorChar + "bar" + File.separatorChar + "repository"));
	}

	private void assertSessionCustomization(String userHome) {
		DefaultRepositorySystemSession session = MavenRepositorySystemUtils.newSession();

		new SettingsXmlRepositorySystemSessionAutoConfiguration(userHome).apply(session,
				this.repositorySystem);

		RemoteRepository repository = new RemoteRepository.Builder("my-server",
				"default", "http://maven.example.com").build();

		assertMirrorSelectorConfiguration(session, repository);
		assertProxySelectorConfiguration(session, repository);
		assertAuthenticationSelectorConfiguration(session, repository);
	}

	private void assertProxySelectorConfiguration(DefaultRepositorySystemSession session,
			RemoteRepository repository) {
		Proxy proxy = session.getProxySelector().getProxy(repository);
		repository = new RemoteRepository.Builder(repository).setProxy(proxy).build();
		AuthenticationContext authenticationContext = AuthenticationContext.forProxy(
				session, repository);
		assertEquals("proxy.example.com", proxy.getHost());
		assertEquals("proxyuser",
				authenticationContext.get(AuthenticationContext.USERNAME));
		assertEquals("somepassword",
				authenticationContext.get(AuthenticationContext.PASSWORD));
	}

	private void assertMirrorSelectorConfiguration(
			DefaultRepositorySystemSession session, RemoteRepository repository) {
		RemoteRepository mirror = session.getMirrorSelector().getMirror(repository);
		assertNotNull("No mirror configured for repository " + repository.getId(), mirror);
		assertEquals("maven.example.com", mirror.getHost());
	}

	private void assertAuthenticationSelectorConfiguration(
			DefaultRepositorySystemSession session, RemoteRepository repository) {
		Authentication authentication = session.getAuthenticationSelector()
				.getAuthentication(repository);

		repository = new RemoteRepository.Builder(repository).setAuthentication(
				authentication).build();

		AuthenticationContext authenticationContext = AuthenticationContext
				.forRepository(session, repository);

		assertEquals("tester", authenticationContext.get(AuthenticationContext.USERNAME));
		assertEquals("secret", authenticationContext.get(AuthenticationContext.PASSWORD));
	}
}

<code block>


package org.springframework.boot.cli.compiler;

import java.io.File;
import java.net.URI;
import java.util.ArrayList;
import java.util.List;

import org.apache.maven.settings.Profile;
import org.apache.maven.settings.Repository;
import org.springframework.boot.cli.compiler.grape.RepositoryConfiguration;
import org.springframework.util.StringUtils;


public final class RepositoryConfigurationFactory {

	private static final RepositoryConfiguration MAVEN_CENTRAL = new RepositoryConfiguration(
			"central", URI.create("http://repo1.maven.org/maven2/"), false);

	private static final RepositoryConfiguration SPRING_MILESTONE = new RepositoryConfiguration(
			"spring-milestone", URI.create("http://repo.spring.io/milestone"), false);

	private static final RepositoryConfiguration SPRING_SNAPSHOT = new RepositoryConfiguration(
			"spring-snapshot", URI.create("http://repo.spring.io/snapshot"), true);

	private RepositoryConfigurationFactory() {

	}


	public static List<RepositoryConfiguration> createDefaultRepositoryConfiguration() {
		MavenSettings mavenSettings = new MavenSettingsReader().readSettings();
		List<RepositoryConfiguration> repositoryConfiguration = new ArrayList<RepositoryConfiguration>();
		repositoryConfiguration.add(MAVEN_CENTRAL);
		if (!Boolean.getBoolean("disableSpringSnapshotRepos")) {
			repositoryConfiguration.add(SPRING_MILESTONE);
			repositoryConfiguration.add(SPRING_SNAPSHOT);
		}
		addDefaultCacheAsRepository(mavenSettings.getLocalRepository(),
				repositoryConfiguration);
		addActiveProfileRepositories(mavenSettings.getActiveProfiles(),
				repositoryConfiguration);
		return repositoryConfiguration;
	}

	private static void addDefaultCacheAsRepository(String localRepository,
			List<RepositoryConfiguration> repositoryConfiguration) {
		RepositoryConfiguration repository = new RepositoryConfiguration("local",
				getLocalRepositoryDirectory(localRepository).toURI(), true);
		if (!repositoryConfiguration.contains(repository)) {
			repositoryConfiguration.add(0, repository);
		}
	}

	private static void addActiveProfileRepositories(List<Profile> activeProfiles,
			List<RepositoryConfiguration> repositoryConfiguration) {
		for (Profile activeProfile : activeProfiles) {
			for (Repository repository : activeProfile.getRepositories()) {
				repositoryConfiguration.add(new RepositoryConfiguration(repository
						.getId(), URI.create(repository.getUrl()), repository
						.getSnapshots() != null ? repository.getSnapshots().isEnabled()
						: false));
			}
		}
	}

	private static File getLocalRepositoryDirectory(String localRepository) {
		if (StringUtils.hasText(localRepository)) {
			return new File(localRepository);
		}
		return new File(getM2HomeDirectory(), "repository");
	}

	private static File getM2HomeDirectory() {
		String mavenRoot = System.getProperty("maven.home");
		if (StringUtils.hasLength(mavenRoot)) {
			return new File(mavenRoot);
		}
		return new File(System.getProperty("user.home"), ".m2");
	}

}

<code block>


package org.springframework.boot.cli.compiler;

import java.io.File;
import java.lang.reflect.Field;

import org.apache.maven.settings.Settings;
import org.apache.maven.settings.building.DefaultSettingsBuilderFactory;
import org.apache.maven.settings.building.DefaultSettingsBuildingRequest;
import org.apache.maven.settings.building.SettingsBuildingException;
import org.apache.maven.settings.building.SettingsBuildingRequest;
import org.apache.maven.settings.crypto.DefaultSettingsDecrypter;
import org.apache.maven.settings.crypto.DefaultSettingsDecryptionRequest;
import org.apache.maven.settings.crypto.SettingsDecrypter;
import org.apache.maven.settings.crypto.SettingsDecryptionResult;
import org.sonatype.plexus.components.cipher.DefaultPlexusCipher;
import org.sonatype.plexus.components.cipher.PlexusCipherException;
import org.sonatype.plexus.components.sec.dispatcher.DefaultSecDispatcher;
import org.springframework.boot.cli.util.Log;


public class MavenSettingsReader {

	private final String homeDir;

	public MavenSettingsReader() {
		this(System.getProperty("user.home"));
	}

	public MavenSettingsReader(String homeDir) {
		this.homeDir = homeDir;
	}

	public MavenSettings readSettings() {
		Settings settings = loadSettings();
		SettingsDecryptionResult decrypted = decryptSettings(settings);
		if (!decrypted.getProblems().isEmpty()) {
			Log.error("Maven settings decryption failed. Some Maven repositories may be inaccessible");

		}
		return new MavenSettings(settings, decrypted);
	}

	private Settings loadSettings() {
		File settingsFile = new File(this.homeDir, ".m2/settings.xml");
		SettingsBuildingRequest request = new DefaultSettingsBuildingRequest();
		request.setUserSettingsFile(settingsFile);
		request.setSystemProperties(System.getProperties());
		try {
			return new DefaultSettingsBuilderFactory().newInstance().build(request)
					.getEffectiveSettings();
		}
		catch (SettingsBuildingException ex) {
			throw new IllegalStateException("Failed to build settings from "
					+ settingsFile, ex);
		}
	}

	private SettingsDecryptionResult decryptSettings(Settings settings) {
		DefaultSettingsDecryptionRequest request = new DefaultSettingsDecryptionRequest(
				settings);

		return createSettingsDecrypter().decrypt(request);
	}

	private SettingsDecrypter createSettingsDecrypter() {
		SettingsDecrypter settingsDecrypter = new DefaultSettingsDecrypter();
		setField(DefaultSettingsDecrypter.class, "securityDispatcher", settingsDecrypter,
				new SpringBootSecDispatcher());
		return settingsDecrypter;
	}

	private void setField(Class<?> clazz, String fieldName, Object target, Object value) {
		try {
			Field field = clazz.getDeclaredField(fieldName);
			field.setAccessible(true);
			field.set(target, value);
		}
		catch (Exception e) {
			throw new IllegalStateException("Failed to set field '" + fieldName
					+ "' on '" + target + "'", e);
		}
	}

	private class SpringBootSecDispatcher extends DefaultSecDispatcher {

		public SpringBootSecDispatcher() {
			this._configurationFile = new File(MavenSettingsReader.this.homeDir,
					".m2/settings-security.xml").getAbsolutePath();
			try {
				this._cipher = new DefaultPlexusCipher();
			}
			catch (PlexusCipherException e) {
				throw new IllegalStateException(e);
			}
		}
	}

}

<code block>


package org.springframework.boot.cli.compiler;

import java.io.File;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;

import org.apache.maven.model.ActivationFile;
import org.apache.maven.model.ActivationOS;
import org.apache.maven.model.ActivationProperty;
import org.apache.maven.model.building.ModelProblemCollector;
import org.apache.maven.model.building.ModelProblemCollectorRequest;
import org.apache.maven.model.profile.DefaultProfileSelector;
import org.apache.maven.model.profile.ProfileActivationContext;
import org.apache.maven.model.profile.activation.FileProfileActivator;
import org.apache.maven.model.profile.activation.JdkVersionProfileActivator;
import org.apache.maven.model.profile.activation.OperatingSystemProfileActivator;
import org.apache.maven.model.profile.activation.PropertyProfileActivator;
import org.apache.maven.settings.Activation;
import org.apache.maven.settings.Mirror;
import org.apache.maven.settings.Profile;
import org.apache.maven.settings.Proxy;
import org.apache.maven.settings.Server;
import org.apache.maven.settings.Settings;
import org.apache.maven.settings.crypto.SettingsDecryptionResult;
import org.eclipse.aether.repository.Authentication;
import org.eclipse.aether.repository.AuthenticationSelector;
import org.eclipse.aether.repository.MirrorSelector;
import org.eclipse.aether.repository.ProxySelector;
import org.eclipse.aether.util.repository.AuthenticationBuilder;
import org.eclipse.aether.util.repository.ConservativeAuthenticationSelector;
import org.eclipse.aether.util.repository.DefaultAuthenticationSelector;
import org.eclipse.aether.util.repository.DefaultMirrorSelector;
import org.eclipse.aether.util.repository.DefaultProxySelector;


public class MavenSettings {

	private final boolean offline;

	private final MirrorSelector mirrorSelector;

	private final AuthenticationSelector authenticationSelector;

	private final ProxySelector proxySelector;

	private final String localRepository;

	private final List<Profile> activeProfiles;


	public MavenSettings(Settings settings, SettingsDecryptionResult decryptedSettings) {
		this.offline = settings.isOffline();
		this.mirrorSelector = createMirrorSelector(settings);
		this.authenticationSelector = createAuthenticationSelector(decryptedSettings);
		this.proxySelector = createProxySelector(decryptedSettings);
		this.localRepository = settings.getLocalRepository();
		this.activeProfiles = determineActiveProfiles(settings);
	}

	private MirrorSelector createMirrorSelector(Settings settings) {
		DefaultMirrorSelector selector = new DefaultMirrorSelector();
		for (Mirror mirror : settings.getMirrors()) {
			selector.add(mirror.getId(), mirror.getUrl(), mirror.getLayout(), false,
					mirror.getMirrorOf(), mirror.getMirrorOfLayouts());
		}
		return selector;
	}

	private AuthenticationSelector createAuthenticationSelector(
			SettingsDecryptionResult decryptedSettings) {
		DefaultAuthenticationSelector selector = new DefaultAuthenticationSelector();
		for (Server server : decryptedSettings.getServers()) {
			AuthenticationBuilder auth = new AuthenticationBuilder();
			auth.addUsername(server.getUsername()).addPassword(server.getPassword());
			auth.addPrivateKey(server.getPrivateKey(), server.getPassphrase());
			selector.add(server.getId(), auth.build());
		}
		return new ConservativeAuthenticationSelector(selector);
	}

	private ProxySelector createProxySelector(SettingsDecryptionResult decryptedSettings) {
		DefaultProxySelector selector = new DefaultProxySelector();
		for (Proxy proxy : decryptedSettings.getProxies()) {
			Authentication authentication = new AuthenticationBuilder()
					.addUsername(proxy.getUsername()).addPassword(proxy.getPassword())
					.build();
			selector.add(new org.eclipse.aether.repository.Proxy(proxy.getProtocol(),
					proxy.getHost(), proxy.getPort(), authentication), proxy
					.getNonProxyHosts());
		}
		return selector;
	}

	private List<Profile> determineActiveProfiles(Settings settings) {
		SpringBootCliModelProblemCollector problemCollector = new SpringBootCliModelProblemCollector();
		List<org.apache.maven.model.Profile> activeModelProfiles = createProfileSelector()
				.getActiveProfiles(
						createModelProfiles(settings.getProfiles()),
						new SpringBootCliProfileActivationContext(settings
								.getActiveProfiles()), problemCollector);
		if (!problemCollector.getProblems().isEmpty()) {
			throw new IllegalStateException(createFailureMessage(problemCollector));
		}
		List<Profile> activeProfiles = new ArrayList<Profile>();
		Map<String, Profile> profiles = settings.getProfilesAsMap();
		for (org.apache.maven.model.Profile modelProfile : activeModelProfiles) {
			activeProfiles.add(profiles.get(modelProfile.getId()));
		}
		return activeProfiles;
	}

	private String createFailureMessage(
			SpringBootCliModelProblemCollector problemCollector) {
		StringWriter message = new StringWriter();
		PrintWriter printer = new PrintWriter(message);
		printer.println("Failed to determine active profiles:");
		for (ModelProblemCollectorRequest problem : problemCollector.getProblems()) {
			printer.println("    " + problem.getMessage() + " at "
					+ problem.getLocation());
		}
		return message.toString();
	}

	private DefaultProfileSelector createProfileSelector() {
		DefaultProfileSelector selector = new DefaultProfileSelector();
		selector.addProfileActivator(new FileProfileActivator());
		selector.addProfileActivator(new JdkVersionProfileActivator());
		selector.addProfileActivator(new PropertyProfileActivator());
		selector.addProfileActivator(new OperatingSystemProfileActivator());
		return selector;
	}

	private List<org.apache.maven.model.Profile> createModelProfiles(
			List<Profile> profiles) {
		List<org.apache.maven.model.Profile> modelProfiles = new ArrayList<org.apache.maven.model.Profile>();
		for (Profile profile : profiles) {
			org.apache.maven.model.Profile modelProfile = new org.apache.maven.model.Profile();
			modelProfile.setId(profile.getId());
			modelProfile.setActivation(createModelActivation(profile.getActivation()));
			modelProfiles.add(modelProfile);
		}
		return modelProfiles;
	}

	private org.apache.maven.model.Activation createModelActivation(Activation activation) {
		org.apache.maven.model.Activation modelActivation = new org.apache.maven.model.Activation();
		modelActivation.setActiveByDefault(activation.isActiveByDefault());
		if (activation.getFile() != null) {
			ActivationFile activationFile = new ActivationFile();
			activationFile.setExists(activation.getFile().getExists());
			activationFile.setMissing(activation.getFile().getMissing());
			modelActivation.setFile(activationFile);
		}
		modelActivation.setJdk(activation.getJdk());
		if (activation.getOs() != null) {
			ActivationOS os = new ActivationOS();
			os.setArch(activation.getOs().getArch());
			os.setFamily(activation.getOs().getFamily());
			os.setName(activation.getOs().getName());
			os.setVersion(activation.getOs().getVersion());
			modelActivation.setOs(os);
		}
		if (activation.getProperty() != null) {
			ActivationProperty property = new ActivationProperty();
			property.setName(activation.getProperty().getName());
			property.setValue(activation.getProperty().getValue());
			modelActivation.setProperty(property);
		}
		return modelActivation;
	}

	public boolean getOffline() {
		return this.offline;
	}

	public MirrorSelector getMirrorSelector() {
		return this.mirrorSelector;
	}

	public AuthenticationSelector getAuthenticationSelector() {
		return this.authenticationSelector;
	}

	public ProxySelector getProxySelector() {
		return this.proxySelector;
	}

	public String getLocalRepository() {
		return this.localRepository;
	}

	public List<Profile> getActiveProfiles() {
		return this.activeProfiles;
	}

	private static final class SpringBootCliProfileActivationContext implements
			ProfileActivationContext {

		private final List<String> activeProfiles;

		SpringBootCliProfileActivationContext(List<String> activeProfiles) {
			this.activeProfiles = activeProfiles;
		}

		@Override
		public List<String> getActiveProfileIds() {
			return this.activeProfiles;
		}

		@Override
		public List<String> getInactiveProfileIds() {
			return Collections.emptyList();
		}

		@SuppressWarnings({ "unchecked", "rawtypes" })
		@Override
		public Map<String, String> getSystemProperties() {
			return (Map) System.getProperties();
		}

		@Override
		public Map<String, String> getUserProperties() {
			return Collections.emptyMap();
		}

		@Override
		public File getProjectDirectory() {
			return new File(".");
		}

		@Override
		public Map<String, String> getProjectProperties() {
			return Collections.emptyMap();
		}

	}

	private static final class SpringBootCliModelProblemCollector implements
			ModelProblemCollector {

		private final List<ModelProblemCollectorRequest> problems = new ArrayList<ModelProblemCollectorRequest>();

		@Override
		public void add(ModelProblemCollectorRequest req) {
			this.problems.add(req);
		}

		List<ModelProblemCollectorRequest> getProblems() {
			return this.problems;
		}

	}

}

<code block>


package org.springframework.boot.cli.compiler.grape;

import org.eclipse.aether.DefaultRepositorySystemSession;
import org.eclipse.aether.RepositorySystem;
import org.eclipse.aether.repository.LocalRepository;
import org.springframework.boot.cli.compiler.MavenSettings;
import org.springframework.boot.cli.compiler.MavenSettingsReader;


public class SettingsXmlRepositorySystemSessionAutoConfiguration implements
		RepositorySystemSessionAutoConfiguration {

	@Override
	public void apply(DefaultRepositorySystemSession session,
			RepositorySystem repositorySystem) {

		MavenSettings settings = new MavenSettingsReader().readSettings();

		session.setOffline(settings.getOffline());
		session.setMirrorSelector(settings.getMirrorSelector());
		session.setAuthenticationSelector(settings.getAuthenticationSelector());
		session.setProxySelector(settings.getProxySelector());

		String localRepository = settings.getLocalRepository();
		if (localRepository != null) {
			session.setLocalRepositoryManager(repositorySystem.newLocalRepositoryManager(
					session, new LocalRepository(localRepository)));
		}
	}

}

<code block>


package org.springframework.boot.cli.util;

import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;


public class SystemProperties {


	public static void doWithSystemProperties(Runnable action,
			String... systemPropertyPairs) {
		Map<String, String> originalValues = new HashMap<String, String>();
		for (String pair : systemPropertyPairs) {
			String[] components = pair.split(":");
			String key = components[0];
			String value = components[1];
			originalValues.put(key, System.setProperty(key, value));
		}
		try {
			action.run();
		}
		finally {
			for (Entry<String, String> entry : originalValues.entrySet()) {
				if (entry.getValue() == null) {
					System.clearProperty(entry.getKey());
				}
				else {
					System.setProperty(entry.getKey(), entry.getValue());
				}
			}
		}
	}
}

<code block>


package org.springframework.boot.cli.compiler;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.junit.Test;
import org.springframework.boot.cli.compiler.grape.RepositoryConfiguration;
import org.springframework.boot.cli.util.SystemProperties;

import static org.hamcrest.Matchers.hasItems;
import static org.hamcrest.Matchers.hasSize;
import static org.junit.Assert.assertThat;


public class RepositoryConfigurationFactoryTests {

	@Test
	public void defaultRepositories() {
		SystemProperties.doWithSystemProperties(new Runnable() {
			@Override
			public void run() {
				List<RepositoryConfiguration> repositoryConfiguration = RepositoryConfigurationFactory
						.createDefaultRepositoryConfiguration();
				assertRepositoryConfiguration(repositoryConfiguration, "central",
						"local", "spring-snapshot", "spring-milestone");
			}
		}, "user.home:src/test/resources/maven-settings/basic");
	}

	@Test
	public void snapshotRepositoriesDisabled() {
		SystemProperties.doWithSystemProperties(
				new Runnable() {
					@Override
					public void run() {
						List<RepositoryConfiguration> repositoryConfiguration = RepositoryConfigurationFactory
								.createDefaultRepositoryConfiguration();
						assertRepositoryConfiguration(repositoryConfiguration, "central",
								"local");
					}
				}, "user.home:src/test/resources/maven-settings/basic",
				"disableSpringSnapshotRepos:true");
	}

	@Test
	public void activeByDefaultProfileRepositories() {
		SystemProperties.doWithSystemProperties(new Runnable() {
			@Override
			public void run() {
				List<RepositoryConfiguration> repositoryConfiguration = RepositoryConfigurationFactory
						.createDefaultRepositoryConfiguration();
				assertRepositoryConfiguration(repositoryConfiguration, "central",
						"local", "spring-snapshot", "spring-milestone",
						"active-by-default");
			}
		}, "user.home:src/test/resources/maven-settings/active-profile-repositories");
	}

	@Test
	public void activeByPropertyProfileRepositories() {
		SystemProperties.doWithSystemProperties(
				new Runnable() {
					@Override
					public void run() {
						List<RepositoryConfiguration> repositoryConfiguration = RepositoryConfigurationFactory
								.createDefaultRepositoryConfiguration();
						assertRepositoryConfiguration(repositoryConfiguration, "central",
								"local", "spring-snapshot", "spring-milestone",
								"active-by-property");
					}
				},
				"user.home:src/test/resources/maven-settings/active-profile-repositories",
				"foo:bar");
	}

	private void assertRepositoryConfiguration(
			List<RepositoryConfiguration> configurations, String... expectedNames) {
		assertThat(configurations, hasSize(expectedNames.length));
		Set<String> actualNames = new HashSet<String>();
		for (RepositoryConfiguration configuration : configurations) {
			actualNames.add(configuration.getName());
		}
		assertThat(actualNames, hasItems(expectedNames));
	}
}

<code block>


package org.springframework.boot.cli.compiler.grape;

import java.io.File;

import org.apache.maven.repository.internal.MavenRepositorySystemUtils;
import org.apache.maven.settings.building.SettingsBuildingException;
import org.eclipse.aether.DefaultRepositorySystemSession;
import org.eclipse.aether.RepositorySystem;
import org.eclipse.aether.internal.impl.SimpleLocalRepositoryManagerFactory;
import org.eclipse.aether.repository.Authentication;
import org.eclipse.aether.repository.AuthenticationContext;
import org.eclipse.aether.repository.LocalRepository;
import org.eclipse.aether.repository.LocalRepositoryManager;
import org.eclipse.aether.repository.Proxy;
import org.eclipse.aether.repository.RemoteRepository;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.runners.MockitoJUnitRunner;
import org.mockito.stubbing.Answer;
import org.springframework.boot.cli.util.SystemProperties;

import static org.hamcrest.Matchers.endsWith;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertThat;
import static org.mockito.BDDMockito.given;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.eq;


@RunWith(MockitoJUnitRunner.class)
public class SettingsXmlRepositorySystemSessionAutoConfigurationTests {

	@Rule
	public ExpectedException thrown = ExpectedException.none();

	@Mock
	private RepositorySystem repositorySystem;

	@Test
	public void basicSessionCustomization() throws SettingsBuildingException {
		assertSessionCustomization("src/test/resources/maven-settings/basic");
	}

	@Test
	public void encryptedSettingsSessionCustomization() throws SettingsBuildingException {
		assertSessionCustomization("src/test/resources/maven-settings/encrypted");
	}

	@Test
	public void propertyInterpolation() throws SettingsBuildingException {
		final DefaultRepositorySystemSession session = MavenRepositorySystemUtils
				.newSession();
		given(
				this.repositorySystem.newLocalRepositoryManager(eq(session),
						any(LocalRepository.class))).willAnswer(
				new Answer<LocalRepositoryManager>() {

					@Override
					public LocalRepositoryManager answer(InvocationOnMock invocation)
							throws Throwable {
						LocalRepository localRepository = invocation.getArgumentAt(1,
								LocalRepository.class);
						return new SimpleLocalRepositoryManagerFactory().newInstance(
								session, localRepository);
					}
				});

		SystemProperties.doWithSystemProperties(
				new Runnable() {
					@Override
					public void run() {
						new SettingsXmlRepositorySystemSessionAutoConfiguration()
								.apply(session,
										SettingsXmlRepositorySystemSessionAutoConfigurationTests.this.repositorySystem);
					}
				}, "user.home:src/test/resources/maven-settings/property-interpolation",
				"foo:bar");

		assertThat(session.getLocalRepository().getBasedir().getAbsolutePath(),
				endsWith(File.separatorChar + "bar" + File.separatorChar + "repository"));
	}

	private void assertSessionCustomization(String userHome) {
		final DefaultRepositorySystemSession session = MavenRepositorySystemUtils
				.newSession();

		SystemProperties.doWithSystemProperties(new Runnable() {
			@Override
			public void run() {
				new SettingsXmlRepositorySystemSessionAutoConfiguration()
						.apply(session,
								SettingsXmlRepositorySystemSessionAutoConfigurationTests.this.repositorySystem);
			}
		}, "user.home:" + userHome);

		RemoteRepository repository = new RemoteRepository.Builder("my-server",
				"default", "http://maven.example.com").build();

		assertMirrorSelectorConfiguration(session, repository);
		assertProxySelectorConfiguration(session, repository);
		assertAuthenticationSelectorConfiguration(session, repository);
	}

	private void assertProxySelectorConfiguration(DefaultRepositorySystemSession session,
			RemoteRepository repository) {
		Proxy proxy = session.getProxySelector().getProxy(repository);
		repository = new RemoteRepository.Builder(repository).setProxy(proxy).build();
		AuthenticationContext authenticationContext = AuthenticationContext.forProxy(
				session, repository);
		assertEquals("proxy.example.com", proxy.getHost());
		assertEquals("proxyuser",
				authenticationContext.get(AuthenticationContext.USERNAME));
		assertEquals("somepassword",
				authenticationContext.get(AuthenticationContext.PASSWORD));
	}

	private void assertMirrorSelectorConfiguration(
			DefaultRepositorySystemSession session, RemoteRepository repository) {
		RemoteRepository mirror = session.getMirrorSelector().getMirror(repository);
		assertNotNull("No mirror configured for repository " + repository.getId(), mirror);
		assertEquals("maven.example.com", mirror.getHost());
	}

	private void assertAuthenticationSelectorConfiguration(
			DefaultRepositorySystemSession session, RemoteRepository repository) {
		Authentication authentication = session.getAuthenticationSelector()
				.getAuthentication(repository);

		repository = new RemoteRepository.Builder(repository).setAuthentication(
				authentication).build();

		AuthenticationContext authenticationContext = AuthenticationContext
				.forRepository(session, repository);

		assertEquals("tester", authenticationContext.get(AuthenticationContext.USERNAME));
		assertEquals("secret", authenticationContext.get(AuthenticationContext.PASSWORD));
	}

}

<code block>


package org.springframework.boot.actuate.endpoint.mvc;

import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanFactoryUtils;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.boot.actuate.endpoint.Endpoint;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.stereotype.Component;


@Component
public class MvcEndpoints implements ApplicationContextAware, InitializingBean {

	private ApplicationContext applicationContext;

	private final Set<MvcEndpoint> endpoints = new HashSet<MvcEndpoint>();

	private Set<Class<?>> customTypes;

	@Override
	public void setApplicationContext(ApplicationContext applicationContext)
			throws BeansException {
		this.applicationContext = applicationContext;
	}

	@Override
	public void afterPropertiesSet() throws Exception {
		Collection<MvcEndpoint> existing = this.applicationContext.getBeansOfType(
				MvcEndpoint.class).values();
		this.endpoints.addAll(existing);
		this.customTypes = findEndpointClasses(existing);
		@SuppressWarnings("rawtypes")
		Collection<Endpoint> delegates = BeanFactoryUtils.beansOfTypeIncludingAncestors(
				this.applicationContext, Endpoint.class).values();
		for (Endpoint<?> endpoint : delegates) {
			if (isGenericEndpoint(endpoint.getClass()) && endpoint.isEnabled()) {
				this.endpoints.add(new EndpointMvcAdapter(endpoint));
			}
		}
	}

	private Set<Class<?>> findEndpointClasses(Collection<MvcEndpoint> existing) {
		Set<Class<?>> types = new HashSet<Class<?>>();
		for (MvcEndpoint endpoint : existing) {
			Class<?> type = endpoint.getEndpointType();
			if (type != null) {
				types.add(type);
			}
		}
		return types;
	}

	public Set<? extends MvcEndpoint> getEndpoints() {
		return this.endpoints;
	}

	private boolean isGenericEndpoint(Class<?> type) {
		return !this.customTypes.contains(type)
				&& !MvcEndpoint.class.isAssignableFrom(type);
	}

}

<code block>


package org.springframework.boot.actuate.endpoint.mvc;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.springframework.boot.actuate.endpoint.Endpoint;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.util.Assert;
import org.springframework.util.StringUtils;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.servlet.HandlerMapping;
import org.springframework.web.servlet.mvc.condition.PatternsRequestCondition;
import org.springframework.web.servlet.mvc.method.RequestMappingInfo;
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;


public class EndpointHandlerMapping extends RequestMappingHandlerMapping implements
		ApplicationContextAware {

	private final Set<MvcEndpoint> endpoints;

	private final CorsConfiguration corsConfiguration;

	private String prefix = "";

	private boolean disabled = false;


	public EndpointHandlerMapping(Collection<? extends MvcEndpoint> endpoints) {
		this(endpoints, null);
	}


	public EndpointHandlerMapping(Collection<? extends MvcEndpoint> endpoints,
			CorsConfiguration corsConfiguration) {
		this.endpoints = new HashSet<MvcEndpoint>(endpoints);
		this.corsConfiguration = corsConfiguration;


		setOrder(-100);
	}

	@Override
	public void afterPropertiesSet() {
		super.afterPropertiesSet();
		if (!this.disabled) {
			for (MvcEndpoint endpoint : this.endpoints) {
				detectHandlerMethods(endpoint);
			}
		}
	}


	@Override
	protected boolean isHandler(Class<?> beanType) {
		return false;
	}

	@Override
	@Deprecated
	protected void registerHandlerMethod(Object handler, Method method,
			RequestMappingInfo mapping) {
		if (mapping == null) {
			return;
		}
		String[] patterns = getPatterns(handler, mapping);
		super.registerHandlerMethod(handler, method, withNewPatterns(mapping, patterns));
	}

	private String[] getPatterns(Object handler, RequestMappingInfo mapping) {
		String path = getPath(handler);
		String prefix = StringUtils.hasText(this.prefix) ? this.prefix + path : path;
		Set<String> defaultPatterns = mapping.getPatternsCondition().getPatterns();
		if (defaultPatterns.isEmpty()) {
			return new String[] { prefix };
		}
		List<String> patterns = new ArrayList<String>(defaultPatterns);
		for (int i = 0; i < patterns.size(); i++) {
			patterns.set(i, prefix + patterns.get(i));
		}
		return patterns.toArray(new String[patterns.size()]);
	}

	private String getPath(Object handler) {
		if (handler instanceof String) {
			handler = getApplicationContext().getBean((String) handler);
		}
		if (handler instanceof MvcEndpoint) {
			return ((MvcEndpoint) handler).getPath();
		}
		return "";
	}

	private RequestMappingInfo withNewPatterns(RequestMappingInfo mapping,
			String[] patternStrings) {
		PatternsRequestCondition patterns = new PatternsRequestCondition(patternStrings);
		return new RequestMappingInfo(patterns, mapping.getMethodsCondition(),
				mapping.getParamsCondition(), mapping.getHeadersCondition(),
				mapping.getConsumesCondition(), mapping.getProducesCondition(),
				mapping.getCustomCondition());
	}


	public void setPrefix(String prefix) {
		Assert.isTrue("".equals(prefix) || StringUtils.startsWithIgnoreCase(prefix, "/"),
				"prefix must start with '/'");
		this.prefix = prefix;
	}


	public String getPrefix() {
		return this.prefix;
	}


	public String getPath(String endpoint) {
		return this.prefix + endpoint;
	}


	public void setDisabled(boolean disabled) {
		this.disabled = disabled;
	}


	public boolean isDisabled() {
		return this.disabled;
	}


	public Set<? extends MvcEndpoint> getEndpoints() {
		return new HashSet<MvcEndpoint>(this.endpoints);
	}

	@Override
	protected CorsConfiguration initCorsConfiguration(Object handler, Method method,
			RequestMappingInfo mappingInfo) {
		return this.corsConfiguration;
	}
}

<code block>


package org.springframework.boot.actuate.autoconfigure;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Set;

import javax.annotation.PostConstruct;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.actuate.endpoint.Endpoint;
import org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMapping;
import org.springframework.boot.actuate.endpoint.mvc.MvcEndpoint;
import org.springframework.boot.autoconfigure.AutoConfigureAfter;
import org.springframework.boot.autoconfigure.AutoConfigureBefore;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.condition.ConditionOutcome;
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;
import org.springframework.boot.autoconfigure.condition.SpringBootCondition;
import org.springframework.boot.autoconfigure.security.AuthenticationManagerConfiguration;
import org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration;
import org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration;
import org.springframework.boot.autoconfigure.security.SecurityPrerequisite;
import org.springframework.boot.autoconfigure.security.SecurityProperties;
import org.springframework.boot.autoconfigure.security.SpringBootWebSecurityConfiguration;
import org.springframework.boot.autoconfigure.web.ErrorController;
import org.springframework.boot.autoconfigure.web.ServerProperties;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ConditionContext;
import org.springframework.context.annotation.Conditional;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.annotation.Order;
import org.springframework.core.type.AnnotatedTypeMetadata;
import org.springframework.security.config.annotation.web.WebSecurityConfigurer;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.builders.WebSecurity;
import org.springframework.security.config.annotation.web.builders.WebSecurity.IgnoredRequestConfigurer;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.annotation.web.configurers.ExpressionUrlAuthorizationConfigurer;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.security.web.authentication.www.BasicAuthenticationEntryPoint;
import org.springframework.util.StringUtils;


@Configuration
@ConditionalOnWebApplication
@ConditionalOnClass({ EnableWebSecurity.class })
@AutoConfigureAfter(SecurityAutoConfiguration.class)
@AutoConfigureBefore(FallbackWebSecurityAutoConfiguration.class)
@EnableConfigurationProperties
public class ManagementSecurityAutoConfiguration {

	private static final String[] NO_PATHS = new String[0];

	@Bean
	@ConditionalOnMissingBean({ IgnoredPathsWebSecurityConfigurerAdapter.class })
	public IgnoredPathsWebSecurityConfigurerAdapter ignoredPathsWebSecurityConfigurerAdapter() {
		return new IgnoredPathsWebSecurityConfigurerAdapter();
	}

	@Configuration
	protected static class ManagementSecurityPropertiesConfiguration implements
			SecurityPrerequisite {

		@Autowired(required = false)
		private SecurityProperties security;

		@Autowired(required = false)
		private ManagementServerProperties management;

		@PostConstruct
		public void init() {
			if (this.management != null && this.security != null) {
				this.security.getUser().getRole()
						.add(this.management.getSecurity().getRole());
			}
		}

	}


	@Order(SecurityProperties.IGNORED_ORDER + 1)
	private static class IgnoredPathsWebSecurityConfigurerAdapter implements
			WebSecurityConfigurer<WebSecurity> {

		@Autowired(required = false)
		private ErrorController errorController;

		@Autowired(required = false)
		private EndpointHandlerMapping endpointHandlerMapping;

		@Autowired
		private ManagementServerProperties management;

		@Autowired
		private SecurityProperties security;

		@Autowired(required = false)
		private ServerProperties server;

		@Override
		public void configure(WebSecurity builder) throws Exception {
		}

		@Override
		public void init(WebSecurity builder) throws Exception {
			IgnoredRequestConfigurer ignoring = builder.ignoring();


			List<String> ignored = SpringBootWebSecurityConfiguration
					.getIgnored(this.security);
			if (!this.management.getSecurity().isEnabled()) {
				ignored.addAll(Arrays
						.asList(getEndpointPaths(this.endpointHandlerMapping)));
			}
			if (ignored.contains("none")) {
				ignored.remove("none");
			}
			if (this.errorController != null) {
				ignored.add(normalizePath(this.errorController.getErrorPath()));
			}
			if (this.server != null) {
				String[] paths = this.server.getPathsArray(ignored);
				ignoring.antMatchers(paths);
			}
		}

		private String normalizePath(String errorPath) {
			String result = StringUtils.cleanPath(errorPath);
			if (!result.startsWith("/")) {
				result = "/" + result;
			}
			return result;
		}

	}

	@Configuration
	@ConditionalOnMissingBean(WebSecurityConfiguration.class)
	@Conditional(WebSecurityEnablerCondition.class)
	@EnableWebSecurity
	protected static class WebSecurityEnabler extends AuthenticationManagerConfiguration {
	}


	static class WebSecurityEnablerCondition extends SpringBootCondition {

		@Override
		public ConditionOutcome getMatchOutcome(ConditionContext context,
				AnnotatedTypeMetadata metadata) {
			String managementEnabled = context.getEnvironment().getProperty(
					"management.security.enabled", "true");
			String basicEnabled = context.getEnvironment().getProperty(
					"security.basic.enabled", "true");
			return new ConditionOutcome("true".equalsIgnoreCase(managementEnabled)
					&& !"true".equalsIgnoreCase(basicEnabled),
					"Management security enabled and basic disabled");
		}

	}

	@Configuration
	@ConditionalOnMissingBean({ ManagementWebSecurityConfigurerAdapter.class })
	@ConditionalOnProperty(prefix = "management.security", name = "enabled", matchIfMissing = true)
	@Order(ManagementServerProperties.BASIC_AUTH_ORDER)
	protected static class ManagementWebSecurityConfigurerAdapter extends
			WebSecurityConfigurerAdapter {

		@Autowired
		private SecurityProperties security;

		@Autowired
		private ManagementServerProperties management;

		@Autowired
		private ServerProperties server;

		@Autowired(required = false)
		private EndpointHandlerMapping endpointHandlerMapping;

		public void setEndpointHandlerMapping(
				EndpointHandlerMapping endpointHandlerMapping) {
			this.endpointHandlerMapping = endpointHandlerMapping;
		}

		@Override
		protected void configure(HttpSecurity http) throws Exception {

			String[] paths = getEndpointPaths(this.endpointHandlerMapping);
			if (paths.length > 0 && this.management.getSecurity().isEnabled()) {

				if (this.security.isRequireSsl()) {
					http.requiresChannel().anyRequest().requiresSecure();
				}
				AuthenticationEntryPoint entryPoint = entryPoint();
				http.exceptionHandling().authenticationEntryPoint(entryPoint);
				paths = this.server.getPathsArray(paths);
				http.requestMatchers().antMatchers(paths);
				String[] endpointPaths = this.server.getPathsArray(getEndpointPaths(
						this.endpointHandlerMapping, false));
				configureAuthorizeRequests(endpointPaths, http.authorizeRequests());
				http.httpBasic().authenticationEntryPoint(entryPoint);

				http.csrf().disable();
				http.sessionManagement().sessionCreationPolicy(
						this.management.getSecurity().getSessions());
				SpringBootWebSecurityConfiguration.configureHeaders(http.headers(),
						this.security.getHeaders());
			}
		}

		private AuthenticationEntryPoint entryPoint() {
			BasicAuthenticationEntryPoint entryPoint = new BasicAuthenticationEntryPoint();
			entryPoint.setRealmName(this.security.getBasic().getRealm());
			return entryPoint;
		}

		private void configureAuthorizeRequests(
				String[] endpointPaths,
				ExpressionUrlAuthorizationConfigurer<HttpSecurity>.ExpressionInterceptUrlRegistry requests) {
			requests.antMatchers(endpointPaths).permitAll();
			requests.anyRequest().hasRole(this.management.getSecurity().getRole());
		}

	}

	private static String[] getEndpointPaths(EndpointHandlerMapping endpointHandlerMapping) {
		return StringUtils.mergeStringArrays(
				getEndpointPaths(endpointHandlerMapping, false),
				getEndpointPaths(endpointHandlerMapping, true));
	}

	private static String[] getEndpointPaths(
			EndpointHandlerMapping endpointHandlerMapping, boolean secure) {
		if (endpointHandlerMapping == null) {
			return NO_PATHS;
		}
		Set<? extends MvcEndpoint> endpoints = endpointHandlerMapping.getEndpoints();
		List<String> paths = new ArrayList<String>(endpoints.size());
		for (MvcEndpoint endpoint : endpoints) {
			if (endpoint.isSensitive() == secure) {
				String path = endpointHandlerMapping.getPath(endpoint.getPath());
				paths.add(path);

				paths.add(path + "/**");

				paths.add(path + ".*");
			}
		}
		return paths.toArray(new String[paths.size()]);
	}

}

<code block>


package org.springframework.boot.actuate.autoconfigure;

import java.io.IOException;
import java.util.List;
import java.util.Set;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.Servlet;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.NoSuchBeanDefinitionException;
import org.springframework.beans.factory.SmartInitializingSingleton;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.actuate.autoconfigure.ManagementServerProperties.Security;
import org.springframework.boot.actuate.condition.ConditionalOnEnabledEndpoint;
import org.springframework.boot.actuate.endpoint.Endpoint;
import org.springframework.boot.actuate.endpoint.EnvironmentEndpoint;
import org.springframework.boot.actuate.endpoint.HealthEndpoint;
import org.springframework.boot.actuate.endpoint.MetricsEndpoint;
import org.springframework.boot.actuate.endpoint.ShutdownEndpoint;
import org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMapping;
import org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMappingCustomizer;
import org.springframework.boot.actuate.endpoint.mvc.EnvironmentMvcEndpoint;
import org.springframework.boot.actuate.endpoint.mvc.HealthMvcEndpoint;
import org.springframework.boot.actuate.endpoint.mvc.LogFileMvcEndpoint;
import org.springframework.boot.actuate.endpoint.mvc.MetricsMvcEndpoint;
import org.springframework.boot.actuate.endpoint.mvc.MvcEndpoint;
import org.springframework.boot.actuate.endpoint.mvc.MvcEndpoints;
import org.springframework.boot.actuate.endpoint.mvc.ShutdownMvcEndpoint;
import org.springframework.boot.autoconfigure.AutoConfigureAfter;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.PropertyPlaceholderAutoConfiguration;
import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;
import org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration;
import org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration;
import org.springframework.boot.autoconfigure.web.ServerProperties;
import org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration;
import org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext;
import org.springframework.boot.context.embedded.EmbeddedServletContainerException;
import org.springframework.boot.context.embedded.EmbeddedWebApplicationContext;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.ApplicationListener;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.event.ContextClosedEvent;
import org.springframework.core.env.ConfigurableEnvironment;
import org.springframework.core.env.PropertySource;
import org.springframework.util.CollectionUtils;
import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.filter.OncePerRequestFilter;
import org.springframework.web.servlet.DispatcherServlet;


@Configuration
@ConditionalOnClass({ Servlet.class, DispatcherServlet.class })
@ConditionalOnWebApplication
@AutoConfigureAfter({ PropertyPlaceholderAutoConfiguration.class,
		EmbeddedServletContainerAutoConfiguration.class, WebMvcAutoConfiguration.class,
		ManagementServerPropertiesAutoConfiguration.class })
@EnableConfigurationProperties({ HealthMvcEndpointProperties.class,
		EndpointCorsProperties.class })
public class EndpointWebMvcAutoConfiguration implements ApplicationContextAware,
		SmartInitializingSingleton {

	private static Log logger = LogFactory.getLog(EndpointWebMvcAutoConfiguration.class);

	private ApplicationContext applicationContext;

	@Autowired
	private HealthMvcEndpointProperties healthMvcEndpointProperties;

	@Autowired
	private ManagementServerProperties managementServerProperties;

	@Autowired
	private EndpointCorsProperties corsProperties;

	@Autowired(required = false)
	private List<EndpointHandlerMappingCustomizer> mappingCustomizers;

	@Override
	public void setApplicationContext(ApplicationContext applicationContext)
			throws BeansException {
		this.applicationContext = applicationContext;
	}

	@Bean
	@ConditionalOnMissingBean
	public EndpointHandlerMapping endpointHandlerMapping() {
		Set<? extends MvcEndpoint> endpoints = mvcEndpoints().getEndpoints();
		CorsConfiguration corsConfiguration = getCorsConfiguration(this.corsProperties);
		EndpointHandlerMapping mapping = new EndpointHandlerMapping(endpoints,
				corsConfiguration);
		boolean disabled = ManagementServerPort.get(this.applicationContext) != ManagementServerPort.SAME;
		mapping.setDisabled(disabled);
		if (!disabled) {
			mapping.setPrefix(this.managementServerProperties.getContextPath());
		}
		if (this.mappingCustomizers != null) {
			for (EndpointHandlerMappingCustomizer customizer : this.mappingCustomizers) {
				customizer.customize(mapping);
			}
		}
		return mapping;
	}

	private CorsConfiguration getCorsConfiguration(EndpointCorsProperties properties) {
		if (CollectionUtils.isEmpty(properties.getAllowedOrigins())) {
			return null;
		}
		CorsConfiguration configuration = new CorsConfiguration();
		configuration.setAllowedOrigins(properties.getAllowedOrigins());
		if (!CollectionUtils.isEmpty(properties.getAllowedHeaders())) {
			configuration.setAllowedHeaders(properties.getAllowedHeaders());
		}
		if (!CollectionUtils.isEmpty(properties.getAllowedMethods())) {
			configuration.setAllowedMethods(properties.getAllowedMethods());
		}
		if (!CollectionUtils.isEmpty(properties.getExposedHeaders())) {
			configuration.setExposedHeaders(properties.getExposedHeaders());
		}
		if (properties.getMaxAge() != null) {
			configuration.setMaxAge(properties.getMaxAge());
		}
		if (properties.getAllowCredentials() != null) {
			configuration.setAllowCredentials(properties.getAllowCredentials());
		}
		return configuration;
	}

	@Override
	public void afterSingletonsInstantiated() {
		ManagementServerPort managementPort = ManagementServerPort
				.get(this.applicationContext);
		if (managementPort == ManagementServerPort.DIFFERENT
				&& this.applicationContext instanceof EmbeddedWebApplicationContext
				&& ((EmbeddedWebApplicationContext) this.applicationContext)
						.getEmbeddedServletContainer() != null) {
			createChildManagementContext();
		}
		if (managementPort == ManagementServerPort.SAME
				&& this.applicationContext.getEnvironment() instanceof ConfigurableEnvironment) {
			addLocalManagementPortPropertyAlias((ConfigurableEnvironment) this.applicationContext
					.getEnvironment());
		}
	}

	@Bean
	@ConditionalOnMissingBean
	public MvcEndpoints mvcEndpoints() {
		return new MvcEndpoints();
	}

	@Bean
	@ConditionalOnBean(EnvironmentEndpoint.class)
	@ConditionalOnEnabledEndpoint("env")
	public EnvironmentMvcEndpoint environmentMvcEndpoint(EnvironmentEndpoint delegate) {
		return new EnvironmentMvcEndpoint(delegate);
	}

	@Bean
	@ConditionalOnBean(HealthEndpoint.class)
	@ConditionalOnEnabledEndpoint("health")
	public HealthMvcEndpoint healthMvcEndpoint(HealthEndpoint delegate) {
		Security security = this.managementServerProperties.getSecurity();
		boolean secure = (security != null && security.isEnabled());
		HealthMvcEndpoint healthMvcEndpoint = new HealthMvcEndpoint(delegate, secure);
		if (this.healthMvcEndpointProperties.getMapping() != null) {
			healthMvcEndpoint.addStatusMapping(this.healthMvcEndpointProperties
					.getMapping());
		}
		return healthMvcEndpoint;
	}

	@Bean
	@ConditionalOnBean(MetricsEndpoint.class)
	@ConditionalOnEnabledEndpoint("metrics")
	public MetricsMvcEndpoint metricsMvcEndpoint(MetricsEndpoint delegate) {
		return new MetricsMvcEndpoint(delegate);
	}

	@Bean
	@ConditionalOnEnabledEndpoint("logfile")
	public LogFileMvcEndpoint logfileMvcEndpoint() {
		return new LogFileMvcEndpoint();
	}

	@Bean
	@ConditionalOnBean(ShutdownEndpoint.class)
	@ConditionalOnEnabledEndpoint(value = "shutdown", enabledByDefault = false)
	public ShutdownMvcEndpoint shutdownMvcEndpoint(ShutdownEndpoint delegate) {
		return new ShutdownMvcEndpoint(delegate);
	}

	private void createChildManagementContext() {

		final AnnotationConfigEmbeddedWebApplicationContext childContext = new AnnotationConfigEmbeddedWebApplicationContext();
		childContext.setParent(this.applicationContext);
		childContext.setNamespace("management");
		childContext.setId(this.applicationContext.getId() + ":management");




		childContext.register(EndpointWebMvcChildContextConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class,
				EmbeddedServletContainerAutoConfiguration.class,
				DispatcherServletAutoConfiguration.class);


		if (this.applicationContext instanceof ConfigurableApplicationContext) {
			((ConfigurableApplicationContext) this.applicationContext)
					.addApplicationListener(new ApplicationListener<ContextClosedEvent>() {
						@Override
						public void onApplicationEvent(ContextClosedEvent event) {
							if (event.getApplicationContext() == EndpointWebMvcAutoConfiguration.this.applicationContext) {
								childContext.close();
							}
						}
					});
		}
		try {
			childContext.refresh();
		}
		catch (RuntimeException ex) {


			if (ex instanceof EmbeddedServletContainerException
					|| ex.getCause() instanceof EmbeddedServletContainerException) {
				logger.warn("Could not start embedded container (management endpoints are still available through JMX)");
			}
			else {
				throw ex;
			}
		}
	}


	private void addLocalManagementPortPropertyAlias(
			final ConfigurableEnvironment environment) {
		environment.getPropertySources().addLast(
				new PropertySource<Object>("Management Server") {
					@Override
					public Object getProperty(String name) {
						if ("local.management.port".equals(name)) {
							return environment.getProperty("local.server.port");
						}
						return null;
					}
				});
	}



	@Configuration
	protected static class ApplicationContextFilterConfiguration {

		@Bean
		public Filter applicationContextIdFilter(ApplicationContext context) {
			return new ApplicationContextHeaderFilter(context);
		}

	}


	private static class ApplicationContextHeaderFilter extends OncePerRequestFilter {

		private final ApplicationContext applicationContext;

		private ManagementServerProperties properties;

		public ApplicationContextHeaderFilter(ApplicationContext applicationContext) {
			this.applicationContext = applicationContext;
		}

		@Override
		protected void doFilterInternal(HttpServletRequest request,
				HttpServletResponse response, FilterChain filterChain)
				throws ServletException, IOException {
			if (this.properties == null) {
				this.properties = this.applicationContext
						.getBean(ManagementServerProperties.class);
			}
			if (this.properties.getAddApplicationContextHeader()) {
				response.addHeader("X-Application-Context",
						this.applicationContext.getId());
			}
			filterChain.doFilter(request, response);
		}

	}

	protected static enum ManagementServerPort {

		DISABLE, SAME, DIFFERENT;

		public static ManagementServerPort get(BeanFactory beanFactory) {
			ServerProperties serverProperties;
			try {
				serverProperties = beanFactory.getBean(ServerProperties.class);
			}
			catch (NoSuchBeanDefinitionException ex) {
				serverProperties = new ServerProperties();
			}
			ManagementServerProperties managementServerProperties;
			try {
				managementServerProperties = beanFactory
						.getBean(ManagementServerProperties.class);
			}
			catch (NoSuchBeanDefinitionException ex) {
				managementServerProperties = new ManagementServerProperties();
			}
			Integer port = managementServerProperties.getPort();
			if (port != null && port < 0) {
				return DISABLE;
			}
			if (!(beanFactory instanceof WebApplicationContext)) {

				return DIFFERENT;
			}
			return ((port == null)
					|| (serverProperties.getPort() == null && port.equals(8080))
					|| (port != 0 && port.equals(serverProperties.getPort())) ? SAME
					: DIFFERENT);
		}

	}

}

<code block>


package org.springframework.boot.actuate.autoconfigure;

import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.servlet.Filter;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.BeanFactoryUtils;
import org.springframework.beans.factory.HierarchicalBeanFactory;
import org.springframework.beans.factory.ListableBeanFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.actuate.autoconfigure.ManagementSecurityAutoConfiguration.ManagementWebSecurityConfigurerAdapter;
import org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMapping;
import org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMappingCustomizer;
import org.springframework.boot.actuate.endpoint.mvc.ManagementErrorEndpoint;
import org.springframework.boot.actuate.endpoint.mvc.MvcEndpoint;
import org.springframework.boot.actuate.endpoint.mvc.MvcEndpoints;
import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingClass;
import org.springframework.boot.autoconfigure.condition.SearchStrategy;
import org.springframework.boot.autoconfigure.web.ErrorAttributes;
import org.springframework.boot.autoconfigure.web.HttpMessageConverters;
import org.springframework.boot.autoconfigure.web.ServerProperties;
import org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;
import org.springframework.boot.context.embedded.EmbeddedServletContainer;
import org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;
import org.springframework.boot.context.embedded.ErrorPage;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.Ordered;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.web.servlet.DispatcherServlet;
import org.springframework.web.servlet.HandlerAdapter;
import org.springframework.web.servlet.HandlerMapping;
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter;


@Configuration
public class EndpointWebMvcChildContextConfiguration {

	private static Log logger = LogFactory
			.getLog(EndpointWebMvcChildContextConfiguration.class);

	@Value("${error.path:/error}")
	private String errorPath = "/error";

	@Configuration
	protected static class ServerCustomization implements
			EmbeddedServletContainerCustomizer, Ordered {

		@Value("${error.path:/error}")
		private String errorPath = "/error";

		@Autowired
		private ListableBeanFactory beanFactory;



		private ManagementServerProperties managementServerProperties;

		private ServerProperties server;

		@Override
		public int getOrder() {
			return 0;
		}

		@Override
		public void customize(ConfigurableEmbeddedServletContainer container) {
			if (this.managementServerProperties == null) {
				this.managementServerProperties = BeanFactoryUtils
						.beanOfTypeIncludingAncestors(this.beanFactory,
								ManagementServerProperties.class);
				this.server = BeanFactoryUtils.beanOfTypeIncludingAncestors(
						this.beanFactory, ServerProperties.class);
			}


			this.server.customize(container);

			container.setErrorPages(Collections.<ErrorPage> emptySet());

			container.setPort(this.managementServerProperties.getPort());
			container.setAddress(this.managementServerProperties.getAddress());
			container.setContextPath(this.managementServerProperties.getContextPath());
			container.addErrorPages(new ErrorPage(this.errorPath));
		}

	}

	@Bean
	public DispatcherServlet dispatcherServlet() {
		DispatcherServlet dispatcherServlet = new DispatcherServlet();


		dispatcherServlet.setDetectAllHandlerAdapters(false);
		dispatcherServlet.setDetectAllHandlerExceptionResolvers(false);
		dispatcherServlet.setDetectAllHandlerMappings(false);
		dispatcherServlet.setDetectAllViewResolvers(false);

		return dispatcherServlet;
	}

	@Bean
	public HandlerAdapter handlerAdapter(HttpMessageConverters converters) {
		RequestMappingHandlerAdapter adapter = new RequestMappingHandlerAdapter();
		adapter.setMessageConverters(converters.getConverters());
		return adapter;
	}


	@Bean
	public ManagementErrorEndpoint errorEndpoint(final ErrorAttributes errorAttributes) {
		return new ManagementErrorEndpoint(this.errorPath, errorAttributes);
	}


	@Configuration
	@ConditionalOnMissingClass("org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter")
	protected static class EndpointHandlerMappingConfiguration {

		@Autowired(required = false)
		private List<EndpointHandlerMappingCustomizer> mappingCustomizers;

		@Bean
		public HandlerMapping handlerMapping(MvcEndpoints endpoints,
				ListableBeanFactory beanFactory) {
			Set<MvcEndpoint> set = new HashSet<MvcEndpoint>(endpoints.getEndpoints());
			set.addAll(beanFactory.getBeansOfType(MvcEndpoint.class).values());
			EndpointHandlerMapping mapping = new EndpointHandlerMapping(set);

			mapping.setDetectHandlerMethodsInAncestorContexts(true);
			postProcessMapping(beanFactory, mapping);
			if (this.mappingCustomizers != null) {
				for (EndpointHandlerMappingCustomizer customizer : this.mappingCustomizers) {
					customizer.customize(mapping);
				}
			}
			return mapping;
		}


		protected void postProcessMapping(ListableBeanFactory beanFactory,
				EndpointHandlerMapping mapping) {
		}

	}


	@Configuration
	@ConditionalOnClass(WebSecurityConfigurerAdapter.class)
	protected static class SecureEndpointHandlerMappingConfiguration extends
			EndpointHandlerMappingConfiguration {

		@Override
		protected void postProcessMapping(ListableBeanFactory beanFactory,
				EndpointHandlerMapping mapping) {


			if (BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory,
					ManagementWebSecurityConfigurerAdapter.class).length == 1) {
				ManagementWebSecurityConfigurerAdapter bean = beanFactory
						.getBean(ManagementWebSecurityConfigurerAdapter.class);
				bean.setEndpointHandlerMapping(mapping);
			}
			else {
				logger.warn("No single bean of type "
						+ ManagementWebSecurityConfigurerAdapter.class.getSimpleName()
						+ " found (this might make some endpoints inaccessible without authentication)");
			}
		}

	}

	@Configuration
	@ConditionalOnClass({ EnableWebSecurity.class, Filter.class })
	@ConditionalOnBean(name = "springSecurityFilterChain", search = SearchStrategy.PARENTS)
	public static class EndpointWebMvcChildContextSecurityConfiguration {

		@Bean
		public Filter springSecurityFilterChain(HierarchicalBeanFactory beanFactory) {
			BeanFactory parent = beanFactory.getParentBeanFactory();
			return parent.getBean("springSecurityFilterChain", Filter.class);
		}

	}

}

<code block>


package org.springframework.boot.actuate.endpoint.mvc;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.actuate.autoconfigure.EndpointWebMvcAutoConfiguration;
import org.springframework.boot.actuate.autoconfigure.ManagementServerPropertiesAutoConfiguration;
import org.springframework.boot.actuate.endpoint.EnvironmentEndpoint;
import org.springframework.boot.actuate.endpoint.mvc.EnvironmentMvcEndpointTests.TestConfiguration;
import org.springframework.boot.test.EnvironmentTestUtils;
import org.springframework.boot.test.SpringApplicationConfiguration;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.web.WebAppConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;

import static org.hamcrest.Matchers.containsString;
import static org.hamcrest.Matchers.equalToIgnoringCase;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;


@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = { TestConfiguration.class })
@WebAppConfiguration
public class EnvironmentMvcEndpointTests {

	@Autowired
	private WebApplicationContext context;

	private MockMvc mvc;

	@Before
	public void setUp() {
		this.context.getBean(EnvironmentEndpoint.class).setEnabled(true);
		this.mvc = MockMvcBuilders.webAppContextSetup(this.context).build();
		EnvironmentTestUtils.addEnvironment(
				(ConfigurableApplicationContext) this.context, "foo:bar", "fool:baz");
	}

	@Test
	public void home() throws Exception {
		this.mvc.perform(get("/env")).andExpect(status().isOk())
				.andExpect(content().string(containsString("systemProperties")));
	}

	@Test
	public void sub() throws Exception {
		this.mvc.perform(get("/env/foo")).andExpect(status().isOk())
				.andExpect(content().string(equalToIgnoringCase("bar")));
	}

	@Test
	public void subWhenDisabled() throws Exception {
		this.context.getBean(EnvironmentEndpoint.class).setEnabled(false);
		this.mvc.perform(get("/env/foo")).andExpect(status().isNotFound());
	}

	@Test
	public void regex() throws Exception {
		this.mvc.perform(get("/env/foo.*")).andExpect(status().isOk())
				.andExpect(content().string(containsString("\"foo\":\"bar\"")))
				.andExpect(content().string(containsString("\"fool\":\"baz\"")));
	}

	@Import({ EndpointWebMvcAutoConfiguration.class,
			ManagementServerPropertiesAutoConfiguration.class })
	@EnableWebMvc
	@Configuration
	public static class TestConfiguration {

		@Bean
		public EnvironmentEndpoint endpoint() {
			return new EnvironmentEndpoint();
		}

		@Bean
		public EnvironmentMvcEndpoint mvcEndpoint() {
			return new EnvironmentMvcEndpoint(endpoint());
		}

	}

}

<code block>


package org.springframework.boot.actuate.endpoint.mvc;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.actuate.autoconfigure.EndpointWebMvcAutoConfiguration;
import org.springframework.boot.actuate.autoconfigure.ManagementServerPropertiesAutoConfiguration;
import org.springframework.boot.actuate.endpoint.MetricsEndpoint;
import org.springframework.boot.actuate.endpoint.PublicMetrics;
import org.springframework.boot.actuate.endpoint.mvc.MetricsMvcEndpointTests.TestConfiguration;
import org.springframework.boot.actuate.metrics.Metric;
import org.springframework.boot.test.SpringApplicationConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.web.WebAppConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;

import static org.hamcrest.Matchers.containsString;
import static org.hamcrest.Matchers.equalTo;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;


@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = { TestConfiguration.class })
@WebAppConfiguration
public class MetricsMvcEndpointTests {

	@Autowired
	private WebApplicationContext context;

	private MockMvc mvc;

	@Before
	public void setUp() {
		this.context.getBean(MetricsEndpoint.class).setEnabled(true);
		this.mvc = MockMvcBuilders.webAppContextSetup(this.context).build();
	}

	@Test
	public void home() throws Exception {
		this.mvc.perform(get("/metrics")).andExpect(status().isOk())
				.andExpect(content().string(containsString("\"foo\":1")));
	}

	@Test
	public void homeWhenDisabled() throws Exception {
		this.context.getBean(MetricsEndpoint.class).setEnabled(false);
		this.mvc.perform(get("/metrics")).andExpect(status().isNotFound());
	}

	@Test
	public void specificMetric() throws Exception {
		this.mvc.perform(get("/metrics/foo")).andExpect(status().isOk())
				.andExpect(content().string(equalTo("1")));
	}

	@Test
	public void specificMetricWhenDisabled() throws Exception {
		this.context.getBean(MetricsEndpoint.class).setEnabled(false);
		this.mvc.perform(get("/metrics/foo")).andExpect(status().isNotFound());
	}

	@Test
	public void specificMetricThatDoesNotExist() throws Exception {
		this.mvc.perform(get("/metrics/bar")).andExpect(status().isNotFound());
	}

	@Test
	public void regexAll() throws Exception {
		String expected = "{\"foo\":1,\"group1.a\":1,\"group1.b\":1,\"group2.a\":1,\"group2_a\":1}";
		this.mvc.perform(get("/metrics/.*")).andExpect(status().isOk())
				.andExpect(content().string(expected));
	}

	@Test
	public void regexGroupDot() throws Exception {
		String expected = "{\"group1.a\":1,\"group1.b\":1,\"group2.a\":1}";
		this.mvc.perform(get("/metrics/group[0-9]+\\..*")).andExpect(status().isOk())
				.andExpect(content().string(expected));
	}

	@Test
	public void regexGroup1() throws Exception {
		String expected = "{\"group1.a\":1,\"group1.b\":1}";
		this.mvc.perform(get("/metrics/group1\\..*")).andExpect(status().isOk())
				.andExpect(content().string(expected));
	}

	@Test
	public void specificMetricWithDot() throws Exception {
		this.mvc.perform(get("/metrics/group2.a")).andExpect(status().isOk())
				.andExpect(content().string("1"));

	}

	@Import({ EndpointWebMvcAutoConfiguration.class,
			ManagementServerPropertiesAutoConfiguration.class })
	@EnableWebMvc
	@Configuration
	public static class TestConfiguration {

		@Bean
		public MetricsEndpoint endpoint() {
			return new MetricsEndpoint(new PublicMetrics() {

				@Override
				public Collection<Metric<?>> metrics() {
					ArrayList<Metric<?>> metrics = new ArrayList<Metric<?>>();
					metrics.add(new Metric<Integer>("foo", 1));
					metrics.add(new Metric<Integer>("group1.a", 1));
					metrics.add(new Metric<Integer>("group1.b", 1));
					metrics.add(new Metric<Integer>("group2.a", 1));
					metrics.add(new Metric<Integer>("group2_a", 1));
					return Collections.unmodifiableList(metrics);
				}

			});
		}

		@Bean
		public MetricsMvcEndpoint mvcEndpoint() {
			return new MetricsMvcEndpoint(endpoint());
		}

	}

}

<code block>


package org.springframework.boot.actuate.autoconfigure;

import java.io.FileNotFoundException;
import java.net.SocketException;
import java.net.URI;
import java.nio.charset.Charset;
import java.util.List;
import java.util.Vector;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.springframework.boot.actuate.endpoint.Endpoint;
import org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMapping;
import org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMappingCustomizer;
import org.springframework.boot.actuate.endpoint.mvc.EnvironmentMvcEndpoint;
import org.springframework.boot.actuate.endpoint.mvc.HealthMvcEndpoint;
import org.springframework.boot.actuate.endpoint.mvc.MetricsMvcEndpoint;
import org.springframework.boot.actuate.endpoint.mvc.MvcEndpoint;
import org.springframework.boot.actuate.endpoint.mvc.ShutdownMvcEndpoint;
import org.springframework.boot.autoconfigure.PropertyPlaceholderAutoConfiguration;
import org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration;
import org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration;
import org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration;
import org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration;
import org.springframework.boot.autoconfigure.web.ServerProperties;
import org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration;
import org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration;
import org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext;
import org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;
import org.springframework.boot.context.embedded.EmbeddedServletContainer;
import org.springframework.boot.context.embedded.EmbeddedServletContainerInitializedEvent;
import org.springframework.boot.context.web.ServerPortInfoApplicationContextInitializer;
import org.springframework.boot.test.EnvironmentTestUtils;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationListener;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.http.HttpMethod;
import org.springframework.http.client.ClientHttpRequest;
import org.springframework.http.client.ClientHttpResponse;
import org.springframework.http.client.SimpleClientHttpRequestFactory;
import org.springframework.stereotype.Controller;
import org.springframework.test.util.ReflectionTestUtils;
import org.springframework.util.SocketUtils;
import org.springframework.util.StreamUtils;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;
import org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping;

import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.instanceOf;
import static org.hamcrest.Matchers.is;
import static org.hamcrest.Matchers.not;
import static org.hamcrest.Matchers.notNullValue;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.mock;


public class EndpointWebMvcAutoConfigurationTests {

	private final AnnotationConfigEmbeddedWebApplicationContext applicationContext = new AnnotationConfigEmbeddedWebApplicationContext();

	private static ThreadLocal<Ports> ports = new ThreadLocal<Ports>();

	@Before
	public void grabPorts() {
		ports.set(new Ports());
	}

	@After
	public void close() {
		if (this.applicationContext != null) {
			this.applicationContext.close();
		}
	}

	@Test
	public void onSamePort() throws Exception {
		this.applicationContext.register(RootConfig.class, EndpointConfig.class,
				BaseConfiguration.class, ServerPortConfig.class,
				EndpointWebMvcAutoConfiguration.class);
		this.applicationContext.refresh();
		assertContent("/controller", ports.get().server, "controlleroutput");
		assertContent("/endpoint", ports.get().server, "endpointoutput");
		assertContent("/controller", ports.get().management, null);
		assertContent("/endpoint", ports.get().management, null);
		assertTrue(hasHeader("/endpoint", ports.get().server, "X-Application-Context"));
		this.applicationContext.close();
		assertAllClosed();
	}

	@Test
	public void onSamePortWithoutHeader() throws Exception {
		EnvironmentTestUtils.addEnvironment(this.applicationContext,
				"management.add-application-context-header:false");
		this.applicationContext.register(RootConfig.class, EndpointConfig.class,
				BaseConfiguration.class, ServerPortConfig.class,
				EndpointWebMvcAutoConfiguration.class);
		this.applicationContext.refresh();
		assertFalse(hasHeader("/endpoint", ports.get().server, "X-Application-Context"));
		this.applicationContext.close();
		assertAllClosed();
	}

	@Test
	public void onDifferentPort() throws Exception {
		this.applicationContext.register(RootConfig.class, EndpointConfig.class,
				DifferentPortConfig.class, BaseConfiguration.class,
				EndpointWebMvcAutoConfiguration.class, ErrorMvcAutoConfiguration.class);
		this.applicationContext.refresh();
		assertContent("/controller", ports.get().server, "controlleroutput");
		assertContent("/endpoint", ports.get().server, null);
		assertContent("/controller", ports.get().management, null);
		assertContent("/endpoint", ports.get().management, "endpointoutput");
		List<?> interceptors = (List<?>) ReflectionTestUtils.getField(
				this.applicationContext.getBean(EndpointHandlerMapping.class),
				"interceptors");
		assertEquals(1, interceptors.size());
		this.applicationContext.close();
		assertAllClosed();
	}

	@Test
	public void onDifferentPortInServletContainer() throws Exception {
		this.applicationContext.register(RootConfig.class, EndpointConfig.class,
				DifferentPortConfig.class, BaseConfiguration.class,
				EndpointWebMvcAutoConfiguration.class, ErrorMvcAutoConfiguration.class);
		ServletContext servletContext = mock(ServletContext.class);
		given(servletContext.getInitParameterNames()).willReturn(
				new Vector<String>().elements());
		given(servletContext.getAttributeNames()).willReturn(
				new Vector<String>().elements());
		this.applicationContext.setServletContext(servletContext);
		this.applicationContext.refresh();
		assertContent("/controller", ports.get().management, null);
		assertContent("/endpoint", ports.get().management, null);
		this.applicationContext.close();
		assertAllClosed();
	}

	@Test
	public void onRandomPort() throws Exception {
		this.applicationContext.register(RootConfig.class, EndpointConfig.class,
				RandomPortConfig.class, BaseConfiguration.class,
				EndpointWebMvcAutoConfiguration.class, ErrorMvcAutoConfiguration.class);
		GrabManagementPort grabManagementPort = new GrabManagementPort(
				this.applicationContext);
		this.applicationContext.addApplicationListener(grabManagementPort);
		this.applicationContext.refresh();
		int managementPort = grabManagementPort.getServletContainer().getPort();
		assertThat(managementPort, not(equalTo(ports.get().server)));
		assertContent("/controller", ports.get().server, "controlleroutput");
		assertContent("/endpoint", ports.get().server, null);
		assertContent("/controller", managementPort, null);
		assertContent("/endpoint", managementPort, "endpointoutput");
	}

	@Test
	public void disabled() throws Exception {
		this.applicationContext.register(RootConfig.class, EndpointConfig.class,
				DisableConfig.class, BaseConfiguration.class,
				EndpointWebMvcAutoConfiguration.class);
		this.applicationContext.refresh();
		assertContent("/controller", ports.get().server, "controlleroutput");
		assertContent("/endpoint", ports.get().server, null);
		assertContent("/controller", ports.get().management, null);
		assertContent("/endpoint", ports.get().management, null);
		this.applicationContext.close();
		assertAllClosed();
	}

	@Test
	public void specificPortsViaProperties() throws Exception {
		EnvironmentTestUtils.addEnvironment(this.applicationContext, "server.port:"
				+ ports.get().server, "management.port:" + ports.get().management);
		this.applicationContext.register(RootConfig.class, EndpointConfig.class,
				BaseConfiguration.class, EndpointWebMvcAutoConfiguration.class,
				ErrorMvcAutoConfiguration.class);
		this.applicationContext.refresh();
		assertContent("/controller", ports.get().server, "controlleroutput");
		assertContent("/endpoint", ports.get().server, null);
		assertContent("/controller", ports.get().management, null);
		assertContent("/endpoint", ports.get().management, "endpointoutput");
		this.applicationContext.close();
		assertAllClosed();
	}

	@Test
	public void contextPath() throws Exception {
		EnvironmentTestUtils.addEnvironment(this.applicationContext,
				"management.contextPath:/test");
		this.applicationContext.register(RootConfig.class, EndpointConfig.class,
				ServerPortConfig.class, PropertyPlaceholderAutoConfiguration.class,
				ManagementServerPropertiesAutoConfiguration.class,
				ServerPropertiesAutoConfiguration.class,
				EmbeddedServletContainerAutoConfiguration.class,
				HttpMessageConvertersAutoConfiguration.class,
				DispatcherServletAutoConfiguration.class, WebMvcAutoConfiguration.class,
				EndpointWebMvcAutoConfiguration.class);
		this.applicationContext.refresh();
		assertContent("/controller", ports.get().server, "controlleroutput");
		assertContent("/test/endpoint", ports.get().server, "endpointoutput");
		this.applicationContext.close();
		assertAllClosed();
	}

	@Test
	public void portPropertiesOnSamePort() throws Exception {
		this.applicationContext.register(RootConfig.class, BaseConfiguration.class,
				ServerPortConfig.class, EndpointWebMvcAutoConfiguration.class);
		new ServerPortInfoApplicationContextInitializer()
				.initialize(this.applicationContext);
		this.applicationContext.refresh();
		Integer localServerPort = this.applicationContext.getEnvironment().getProperty(
				"local.server.port", Integer.class);
		Integer localManagementPort = this.applicationContext.getEnvironment()
				.getProperty("local.management.port", Integer.class);
		assertThat(localServerPort, notNullValue());
		assertThat(localManagementPort, notNullValue());
		assertThat(localServerPort, equalTo(localManagementPort));
		this.applicationContext.close();
		assertAllClosed();
	}

	@Test
	public void portPropertiesOnDifferentPort() throws Exception {
		new ServerPortInfoApplicationContextInitializer()
				.initialize(this.applicationContext);
		this.applicationContext.register(RootConfig.class, DifferentPortConfig.class,
				BaseConfiguration.class, EndpointWebMvcAutoConfiguration.class,
				ErrorMvcAutoConfiguration.class);
		this.applicationContext.refresh();
		Integer localServerPort = this.applicationContext.getEnvironment().getProperty(
				"local.server.port", Integer.class);
		Integer localManagementPort = this.applicationContext.getEnvironment()
				.getProperty("local.management.port", Integer.class);
		assertThat(localServerPort, notNullValue());
		assertThat(localManagementPort, notNullValue());
		assertThat(localServerPort, not(equalTo(localManagementPort)));
		assertThat(this.applicationContext.getBean(ServerPortConfig.class).getCount(),
				equalTo(2));
		this.applicationContext.close();
		assertAllClosed();
	}

	@Test
	public void singleRequestMappingInfoHandlerMappingBean() throws Exception {
		this.applicationContext.register(RootConfig.class, BaseConfiguration.class,
				ServerPortConfig.class, EndpointWebMvcAutoConfiguration.class);
		this.applicationContext.refresh();
		RequestMappingInfoHandlerMapping mapping = this.applicationContext
				.getBean(RequestMappingInfoHandlerMapping.class);
		assertThat(mapping, not(instanceOf(EndpointHandlerMapping.class)));
	}

	@Test
	public void endpointsDefaultConfiguration() throws Exception {
		this.applicationContext.register(RootConfig.class, BaseConfiguration.class,
				ServerPortConfig.class, EndpointWebMvcAutoConfiguration.class);
		this.applicationContext.refresh();

		assertThat(this.applicationContext.getBeansOfType(MvcEndpoint.class).size(),
				is(equalTo(4)));
	}

	@Test
	public void endpointsAllDisabled() throws Exception {
		this.applicationContext.register(RootConfig.class, BaseConfiguration.class,
				ServerPortConfig.class, EndpointWebMvcAutoConfiguration.class);
		EnvironmentTestUtils.addEnvironment(this.applicationContext,
				"ENDPOINTS_ENABLED:false");
		this.applicationContext.refresh();
		assertThat(this.applicationContext.getBeansOfType(MvcEndpoint.class).size(),
				is(equalTo(0)));
	}

	@Test
	public void environmentEndpointDisabled() throws Exception {
		endpointDisabled("env", EnvironmentMvcEndpoint.class);
	}

	@Test
	public void environmentEndpointEnabledOverride() throws Exception {
		endpointEnabledOverride("env", EnvironmentMvcEndpoint.class);
	}

	@Test
	public void metricsEndpointDisabled() throws Exception {
		endpointDisabled("metrics", MetricsMvcEndpoint.class);
	}

	@Test
	public void metricsEndpointEnabledOverride() throws Exception {
		endpointEnabledOverride("metrics", MetricsMvcEndpoint.class);
	}

	@Test
	public void healthEndpointDisabled() throws Exception {
		endpointDisabled("health", HealthMvcEndpoint.class);
	}

	@Test
	public void healthEndpointEnabledOverride() throws Exception {
		endpointEnabledOverride("health", HealthMvcEndpoint.class);
	}

	@Test
	public void shutdownEndpointEnabled() {
		this.applicationContext.register(RootConfig.class, BaseConfiguration.class,
				ServerPortConfig.class, EndpointWebMvcAutoConfiguration.class);
		EnvironmentTestUtils.addEnvironment(this.applicationContext,
				"endpoints.shutdown.enabled:true");
		this.applicationContext.refresh();
		assertThat(this.applicationContext.getBeansOfType(ShutdownMvcEndpoint.class)
				.size(), is(equalTo(1)));
	}

	private void endpointDisabled(String name, Class<? extends MvcEndpoint> type) {
		this.applicationContext.register(RootConfig.class, BaseConfiguration.class,
				ServerPortConfig.class, EndpointWebMvcAutoConfiguration.class);
		EnvironmentTestUtils.addEnvironment(this.applicationContext,
				String.format("endpoints.%s.enabled:false", name));
		this.applicationContext.refresh();
		assertThat(this.applicationContext.getBeansOfType(type).size(), is(equalTo(0)));
	}

	private void endpointEnabledOverride(String name, Class<? extends MvcEndpoint> type)
			throws Exception {
		this.applicationContext.register(RootConfig.class, BaseConfiguration.class,
				ServerPortConfig.class, EndpointWebMvcAutoConfiguration.class);
		EnvironmentTestUtils.addEnvironment(this.applicationContext,
				"endpoints.enabled:false",
				String.format("endpoints_%s_enabled:true", name));
		this.applicationContext.refresh();
		assertThat(this.applicationContext.getBeansOfType(type).size(), is(equalTo(1)));
	}

	private void assertAllClosed() throws Exception {
		assertContent("/controller", ports.get().server, null);
		assertContent("/endpoint", ports.get().server, null);
		assertContent("/controller", ports.get().management, null);
		assertContent("/endpoint", ports.get().management, null);
	}

	public void assertContent(String url, int port, Object expected) throws Exception {
		SimpleClientHttpRequestFactory clientHttpRequestFactory = new SimpleClientHttpRequestFactory();
		ClientHttpRequest request = clientHttpRequestFactory.createRequest(new URI(
				"http://localhost:" + port + url), HttpMethod.GET);
		try {
			ClientHttpResponse response = request.execute();
			try {
				String actual = StreamUtils.copyToString(response.getBody(),
						Charset.forName("UTF-8"));
				assertThat(actual, equalTo(expected));
			}
			finally {
				response.close();
			}
		}
		catch (Exception ex) {
			if (expected == null) {
				if (SocketException.class.isInstance(ex)
						|| FileNotFoundException.class.isInstance(ex)) {
					return;
				}
			}
			throw ex;
		}
	}

	public boolean hasHeader(String url, int port, String header) throws Exception {
		SimpleClientHttpRequestFactory clientHttpRequestFactory = new SimpleClientHttpRequestFactory();
		ClientHttpRequest request = clientHttpRequestFactory.createRequest(new URI(
				"http://localhost:" + port + url), HttpMethod.GET);
		ClientHttpResponse response = request.execute();
		return response.getHeaders().containsKey(header);
	}

	private static class Ports {

		int server = SocketUtils.findAvailableTcpPort();

		int management = SocketUtils.findAvailableTcpPort();

	}

	@Configuration
	@Import({ PropertyPlaceholderAutoConfiguration.class,
			EmbeddedServletContainerAutoConfiguration.class,
			EndpointAutoConfiguration.class,
			HttpMessageConvertersAutoConfiguration.class,
			DispatcherServletAutoConfiguration.class, WebMvcAutoConfiguration.class,
			ManagementServerPropertiesAutoConfiguration.class,
			ServerPropertiesAutoConfiguration.class, WebMvcAutoConfiguration.class })
	protected static class BaseConfiguration {

	}

	@Configuration
	public static class RootConfig {

		@Bean
		public TestController testController() {
			return new TestController();
		}

	}

	@Configuration
	public static class EndpointConfig {

		@Bean
		public TestEndpoint testEndpoint() {
			return new TestEndpoint();
		}

	}

	@Configuration
	public static class ServerPortConfig {

		private int count = 0;

		public int getCount() {
			return this.count;
		}

		@Bean
		public ServerProperties serverProperties() {
			ServerProperties properties = new ServerProperties() {
				@Override
				public void customize(ConfigurableEmbeddedServletContainer container) {
					ServerPortConfig.this.count++;
					super.customize(container);
				}
			};
			properties.setPort(ports.get().server);
			return properties;
		}

	}

	@Controller
	public static class TestController {

		@RequestMapping("/controller")
		@ResponseBody
		public String requestMappedMethod() {
			return "controlleroutput";
		}

	}

	@Configuration
	@Import(ServerPortConfig.class)
	public static class DifferentPortConfig {

		@Bean
		public ManagementServerProperties managementServerProperties() {
			ManagementServerProperties properties = new ManagementServerProperties();
			properties.setPort(ports.get().management);
			return properties;
		}

		@Bean
		public EndpointHandlerMappingCustomizer mappingCustomizer() {
			return new EndpointHandlerMappingCustomizer() {

				@Override
				public void customize(EndpointHandlerMapping mapping) {
					mapping.setInterceptors(new Object[] { interceptor() });
				}

			};
		}

		@Bean
		protected TestInterceptor interceptor() {
			return new TestInterceptor();
		}

		protected static class TestInterceptor extends HandlerInterceptorAdapter {
			private int count = 0;

			@Override
			public void postHandle(HttpServletRequest request,
					HttpServletResponse response, Object handler,
					ModelAndView modelAndView) throws Exception {
				this.count++;
			}

			public int getCount() {
				return this.count;
			}
		}

	}

	@Configuration
	@Import(ServerPortConfig.class)
	public static class RandomPortConfig {

		@Bean
		public ManagementServerProperties managementServerProperties() {
			ManagementServerProperties properties = new ManagementServerProperties();
			properties.setPort(0);
			return properties;
		}

	}

	@Configuration
	@Import(ServerPortConfig.class)
	public static class DisableConfig {

		@Bean
		public ManagementServerProperties managementServerProperties() {
			ManagementServerProperties properties = new ManagementServerProperties();
			properties.setPort(-1);
			return properties;
		}

	}

	public static class TestEndpoint implements MvcEndpoint {

		@RequestMapping
		@ResponseBody
		public String invoke() {
			return "endpointoutput";
		}

		@Override
		public String getPath() {
			return "/endpoint";
		}

		@Override
		public boolean isSensitive() {
			return true;
		}

		@Override
		@SuppressWarnings("rawtypes")
		public Class<? extends Endpoint> getEndpointType() {
			return Endpoint.class;
		}

	}

	private static class GrabManagementPort implements
			ApplicationListener<EmbeddedServletContainerInitializedEvent> {

		private ApplicationContext rootContext;

		private EmbeddedServletContainer servletContainer;

		public GrabManagementPort(ApplicationContext rootContext) {
			this.rootContext = rootContext;
		}

		@Override
		public void onApplicationEvent(EmbeddedServletContainerInitializedEvent event) {
			if (event.getApplicationContext() != this.rootContext) {
				this.servletContainer = event.getEmbeddedServletContainer();
			}
		}

		public EmbeddedServletContainer getServletContainer() {
			return this.servletContainer;
		}

	}

}

<code block>


package org.springframework.boot.autoconfigure.web;

import org.springframework.boot.context.properties.ConfigurationProperties;


@ConfigurationProperties(prefix = "spring.resources", ignoreUnknownFields = false)
public class ResourceProperties {


	private Integer cachePeriod;


	private boolean addMappings = true;

	private final Chain chain = new Chain();

	public Integer getCachePeriod() {
		return this.cachePeriod;
	}

	public void setCachePeriod(Integer cachePeriod) {
		this.cachePeriod = cachePeriod;
	}

	public boolean isAddMappings() {
		return this.addMappings;
	}

	public void setAddMappings(boolean addMappings) {
		this.addMappings = addMappings;
	}

	public Chain getChain() {
		return this.chain;
	}


	public static class Chain {


		private Boolean enabled;


		private boolean cache = true;


		private boolean htmlApplicationCache = false;

		private final Strategy strategy = new Strategy();

		public Boolean getEnabled() {
			return this.enabled;
		}

		public void setEnabled(boolean enabled) {
			this.enabled = enabled;
		}

		public boolean isCache() {
			return this.cache;
		}

		public void setCache(boolean cache) {
			this.cache = cache;
		}

		public Strategy getStrategy() {
			return this.strategy;
		}

		public boolean isHtmlApplicationCache() {
			return this.htmlApplicationCache;
		}

		public void setHtmlApplicationCache(boolean htmlApplicationCache) {
			this.htmlApplicationCache = htmlApplicationCache;
		}

	}


	public static class Strategy {

		private final Fixed fixed = new Fixed();

		private final Content content = new Content();

		public Fixed getFixed() {
			return this.fixed;
		}

		public Content getContent() {
			return this.content;
		}

	}


	public static class Content {


		private boolean enabled;


		private String[] paths = new String[] { "/**" };

		public boolean isEnabled() {
			return this.enabled;
		}

		public void setEnabled(boolean enabled) {
			this.enabled = enabled;
		}

		public String[] getPaths() {
			return this.paths;
		}

		public void setPaths(String[] paths) {
			this.paths = paths;
		}

	}


	public static class Fixed {


		private boolean enabled;


		private String[] paths;


		private String version;

		public boolean isEnabled() {
			return this.enabled;
		}

		public void setEnabled(boolean enabled) {
			this.enabled = enabled;
		}

		public String[] getPaths() {
			return this.paths;
		}

		public void setPaths(String[] paths) {
			this.paths = paths;
		}

		public String getVersion() {
			return this.version;
		}

		public void setVersion(String version) {
			this.version = version;
		}

	}

}

<code block>


package org.springframework.boot.autoconfigure.web;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.List;

import javax.servlet.Servlet;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.ListableBeanFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.AutoConfigureAfter;
import org.springframework.boot.autoconfigure.AutoConfigureOrder;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;
import org.springframework.boot.autoconfigure.web.ResourceProperties.Strategy;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.boot.context.web.OrderedHiddenHttpMethodFilter;
import org.springframework.context.ResourceLoaderAware;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.context.annotation.Primary;
import org.springframework.core.Ordered;
import org.springframework.core.convert.converter.Converter;
import org.springframework.core.convert.converter.GenericConverter;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
import org.springframework.format.Formatter;
import org.springframework.format.FormatterRegistry;
import org.springframework.format.datetime.DateFormatter;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.util.StringUtils;
import org.springframework.validation.DefaultMessageCodesResolver;
import org.springframework.validation.MessageCodesResolver;
import org.springframework.web.accept.ContentNegotiationManager;
import org.springframework.web.context.request.RequestContextListener;
import org.springframework.web.filter.HiddenHttpMethodFilter;
import org.springframework.web.servlet.DispatcherServlet;
import org.springframework.web.servlet.LocaleResolver;
import org.springframework.web.servlet.View;
import org.springframework.web.servlet.ViewResolver;
import org.springframework.web.servlet.config.annotation.AsyncSupportConfigurer;
import org.springframework.web.servlet.config.annotation.DelegatingWebMvcConfiguration;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.ResourceChainRegistration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;
import org.springframework.web.servlet.handler.SimpleUrlHandlerMapping;
import org.springframework.web.servlet.i18n.FixedLocaleResolver;
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter;
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;
import org.springframework.web.servlet.resource.AppCacheManifestTransformer;
import org.springframework.web.servlet.resource.ResourceHttpRequestHandler;
import org.springframework.web.servlet.resource.ResourceResolver;
import org.springframework.web.servlet.resource.VersionResourceResolver;
import org.springframework.web.servlet.view.BeanNameViewResolver;
import org.springframework.web.servlet.view.ContentNegotiatingViewResolver;
import org.springframework.web.servlet.view.InternalResourceViewResolver;


@Configuration
@ConditionalOnWebApplication
@ConditionalOnClass({ Servlet.class, DispatcherServlet.class,
		WebMvcConfigurerAdapter.class })
@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@AutoConfigureAfter(DispatcherServletAutoConfiguration.class)
public class WebMvcAutoConfiguration {

	private static final String[] SERVLET_RESOURCE_LOCATIONS = { "/" };

	private static final String[] CLASSPATH_RESOURCE_LOCATIONS = {
			"classpath:/META-INF/resources/", "classpath:/resources/",
			"classpath:/static/", "classpath:/public/" };

	private static final String[] RESOURCE_LOCATIONS;
	static {
		RESOURCE_LOCATIONS = new String[CLASSPATH_RESOURCE_LOCATIONS.length
				+ SERVLET_RESOURCE_LOCATIONS.length];
		System.arraycopy(SERVLET_RESOURCE_LOCATIONS, 0, RESOURCE_LOCATIONS, 0,
				SERVLET_RESOURCE_LOCATIONS.length);
		System.arraycopy(CLASSPATH_RESOURCE_LOCATIONS, 0, RESOURCE_LOCATIONS,
				SERVLET_RESOURCE_LOCATIONS.length, CLASSPATH_RESOURCE_LOCATIONS.length);
	}

	private static final String[] STATIC_INDEX_HTML_RESOURCES;
	static {
		STATIC_INDEX_HTML_RESOURCES = new String[RESOURCE_LOCATIONS.length];
		for (int i = 0; i < STATIC_INDEX_HTML_RESOURCES.length; i++) {
			STATIC_INDEX_HTML_RESOURCES[i] = RESOURCE_LOCATIONS[i] + "index.html";
		}
	}

	public static String DEFAULT_PREFIX = "";

	public static String DEFAULT_SUFFIX = "";

	@Bean
	@ConditionalOnMissingBean(HiddenHttpMethodFilter.class)
	public HiddenHttpMethodFilter hiddenHttpMethodFilter() {
		return new OrderedHiddenHttpMethodFilter();
	}



	@Configuration
	@Import(EnableWebMvcConfiguration.class)
	@EnableConfigurationProperties({ WebMvcProperties.class, ResourceProperties.class })
	public static class WebMvcAutoConfigurationAdapter extends WebMvcConfigurerAdapter {

		private static Log logger = LogFactory.getLog(WebMvcConfigurerAdapter.class);

		@Autowired
		private ResourceProperties resourceProperties = new ResourceProperties();

		@Autowired
		private WebMvcProperties mvcProperties = new WebMvcProperties();

		@Autowired
		private ListableBeanFactory beanFactory;

		@Autowired
		private ResourceLoader resourceLoader;

		@Autowired
		private HttpMessageConverters messageConverters;

		@Override
		public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
			converters.addAll(this.messageConverters.getConverters());
		}

		@Override
		public void configureAsyncSupport(AsyncSupportConfigurer configurer) {
			Long timeout = this.mvcProperties.getAsync().getRequestTimeout();
			if (timeout != null) {
				configurer.setDefaultTimeout(timeout);
			}
		}

		@Bean
		@ConditionalOnMissingBean(InternalResourceViewResolver.class)
		public InternalResourceViewResolver defaultViewResolver() {
			InternalResourceViewResolver resolver = new InternalResourceViewResolver();
			resolver.setPrefix(this.mvcProperties.getView().getPrefix());
			resolver.setSuffix(this.mvcProperties.getView().getSuffix());
			return resolver;
		}

		@Bean
		@ConditionalOnMissingBean(RequestContextListener.class)
		public RequestContextListener requestContextListener() {
			return new RequestContextListener();
		}

		@Bean
		@ConditionalOnBean(View.class)
		public BeanNameViewResolver beanNameViewResolver() {
			BeanNameViewResolver resolver = new BeanNameViewResolver();
			resolver.setOrder(Ordered.LOWEST_PRECEDENCE - 10);
			return resolver;
		}

		@Bean
		@ConditionalOnBean(ViewResolver.class)
		@ConditionalOnMissingBean(name = "viewResolver", value = ContentNegotiatingViewResolver.class)
		public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory) {
			ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver();
			resolver.setContentNegotiationManager(beanFactory
					.getBean(ContentNegotiationManager.class));


			resolver.setOrder(Ordered.HIGHEST_PRECEDENCE);
			return resolver;
		}

		@Bean
		@ConditionalOnMissingBean(LocaleResolver.class)
		@ConditionalOnProperty(prefix = "spring.mvc", name = "locale")
		public LocaleResolver localeResolver() {
			return new FixedLocaleResolver(
					StringUtils.parseLocaleString(this.mvcProperties.getLocale()));
		}

		@Bean
		@ConditionalOnProperty(prefix = "spring.mvc", name = "date-format")
		public Formatter<Date> dateFormatter() {
			return new DateFormatter(this.mvcProperties.getDateFormat());
		}

		@Override
		public MessageCodesResolver getMessageCodesResolver() {
			if (this.mvcProperties.getMessageCodesResolverFormat() != null) {
				DefaultMessageCodesResolver resolver = new DefaultMessageCodesResolver();
				resolver.setMessageCodeFormatter(this.mvcProperties
						.getMessageCodesResolverFormat());
				return resolver;
			}
			return null;
		}

		@Override
		public void addFormatters(FormatterRegistry registry) {
			for (Converter<?, ?> converter : getBeansOfType(Converter.class)) {
				registry.addConverter(converter);
			}
			for (GenericConverter converter : getBeansOfType(GenericConverter.class)) {
				registry.addConverter(converter);
			}
			for (Formatter<?> formatter : getBeansOfType(Formatter.class)) {
				registry.addFormatter(formatter);
			}
		}

		private <T> Collection<T> getBeansOfType(Class<T> type) {
			return this.beanFactory.getBeansOfType(type).values();
		}

		@Override
		public void addResourceHandlers(ResourceHandlerRegistry registry) {
			if (!this.resourceProperties.isAddMappings()) {
				logger.debug("Default resource handling disabled");
				return;
			}
			Integer cachePeriod = this.resourceProperties.getCachePeriod();
			if (!registry.hasMappingForPattern("/webjars/**")) {
				registerResourceChain(registry.addResourceHandler("/webjars/**")
						.addResourceLocations("classpath:/META-INF/resources/webjars/")
						.setCachePeriod(cachePeriod));
			}
			if (!registry.hasMappingForPattern("/**")) {
				registerResourceChain(registry.addResourceHandler("/**")
						.addResourceLocations(RESOURCE_LOCATIONS)
						.setCachePeriod(cachePeriod));
			}
		}

		private void registerResourceChain(ResourceHandlerRegistration registration) {
			ResourceProperties.Chain properties = this.resourceProperties.getChain();
			if (Boolean.TRUE.equals(properties.getEnabled())
					|| properties.getStrategy().getFixed().isEnabled()
					|| properties.getStrategy().getContent().isEnabled()) {
				configureResourceChain(properties,
						registration.resourceChain(properties.isCache()));
			}
		}

		private void configureResourceChain(ResourceProperties.Chain properties,
				ResourceChainRegistration chain) {
			Strategy strategy = properties.getStrategy();
			if (strategy.getFixed().isEnabled() || strategy.getContent().isEnabled()) {
				chain.addResolver(getVersionResourceResolver(strategy));
			}
			if (properties.isHtmlApplicationCache()) {
				chain.addTransformer(new AppCacheManifestTransformer());
			}
		}

		private ResourceResolver getVersionResourceResolver(
				ResourceProperties.Strategy properties) {
			VersionResourceResolver resolver = new VersionResourceResolver();
			if (properties.getFixed().isEnabled()) {
				String version = properties.getFixed().getVersion();
				String[] paths = properties.getFixed().getPaths();
				resolver.addFixedVersionStrategy(version, paths);
			}
			if (properties.getContent().isEnabled()) {
				String[] paths = properties.getContent().getPaths();
				resolver.addContentVersionStrategy(paths);
			}
			return resolver;
		}

		@Override
		public void addViewControllers(ViewControllerRegistry registry) {
			addStaticIndexHtmlViewControllers(registry);
		}

		private void addStaticIndexHtmlViewControllers(ViewControllerRegistry registry) {
			for (String resource : STATIC_INDEX_HTML_RESOURCES) {
				if (this.resourceLoader.getResource(resource).exists()) {
					try {
						logger.info("Adding welcome page: "
								+ this.resourceLoader.getResource(resource).getURL());
					}
					catch (IOException ex) {

					}

					registry.addViewController("/").setViewName("forward:index.html");
					return;
				}
			}
		}

		@Configuration
		@ConditionalOnProperty(value = "spring.mvc.favicon.enabled", matchIfMissing = true)
		public static class FaviconConfiguration implements ResourceLoaderAware {

			private ResourceLoader resourceLoader;

			@Bean
			public SimpleUrlHandlerMapping faviconHandlerMapping() {
				SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();
				mapping.setOrder(Integer.MIN_VALUE + 1);
				mapping.setUrlMap(Collections.singletonMap("**/favicon.ico",
						faviconRequestHandler()));
				return mapping;
			}

			@Override
			public void setResourceLoader(ResourceLoader resourceLoader) {
				this.resourceLoader = resourceLoader;
			}

			@Bean
			public ResourceHttpRequestHandler faviconRequestHandler() {
				ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler();
				requestHandler.setLocations(getLocations());
				return requestHandler;
			}

			private List<Resource> getLocations() {
				List<Resource> locations = new ArrayList<Resource>(
						CLASSPATH_RESOURCE_LOCATIONS.length + 1);
				for (String location : CLASSPATH_RESOURCE_LOCATIONS) {
					locations.add(this.resourceLoader.getResource(location));
				}
				locations.add(new ClassPathResource("/"));
				return Collections.unmodifiableList(locations);
			}

		}

	}


	@Configuration
	public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration {

		@Autowired(required = false)
		private WebMvcProperties mvcProperties;

		@Bean
		@Override
		public RequestMappingHandlerAdapter requestMappingHandlerAdapter() {
			RequestMappingHandlerAdapter adapter = super.requestMappingHandlerAdapter();
			adapter.setIgnoreDefaultModelOnRedirect(this.mvcProperties == null ? true
					: this.mvcProperties.isIgnoreDefaultModelOnRedirect());
			return adapter;
		}

		@Bean
		@Primary
		@Override
		public RequestMappingHandlerMapping requestMappingHandlerMapping() {

			return super.requestMappingHandlerMapping();
		}

	}

}

<code block>


package org.springframework.boot.actuate.endpoint.mvc;

import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanFactoryUtils;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.boot.actuate.endpoint.Endpoint;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.stereotype.Component;


@Component
public class MvcEndpoints implements ApplicationContextAware, InitializingBean {

	private ApplicationContext applicationContext;

	private final Set<MvcEndpoint> endpoints = new HashSet<MvcEndpoint>();

	private Set<Class<?>> customTypes;

	@Override
	public void setApplicationContext(ApplicationContext applicationContext)
			throws BeansException {
		this.applicationContext = applicationContext;
	}

	@Override
	public void afterPropertiesSet() throws Exception {
		Collection<MvcEndpoint> existing = BeanFactoryUtils.beansOfTypeIncludingAncestors(
				this.applicationContext, MvcEndpoint.class).values();
		this.endpoints.addAll(existing);
		this.customTypes = findEndpointClasses(existing);
		@SuppressWarnings("rawtypes")
		Collection<Endpoint> delegates = BeanFactoryUtils.beansOfTypeIncludingAncestors(
				this.applicationContext, Endpoint.class).values();
		for (Endpoint<?> endpoint : delegates) {
			if (isGenericEndpoint(endpoint.getClass()) && endpoint.isEnabled()) {
				this.endpoints.add(new EndpointMvcAdapter(endpoint));
			}
		}
	}

	private Set<Class<?>> findEndpointClasses(Collection<MvcEndpoint> existing) {
		Set<Class<?>> types = new HashSet<Class<?>>();
		for (MvcEndpoint endpoint : existing) {
			Class<?> type = endpoint.getEndpointType();
			if (type != null) {
				types.add(type);
			}
		}
		return types;
	}

	public Set<? extends MvcEndpoint> getEndpoints() {
		return this.endpoints;
	}

	private boolean isGenericEndpoint(Class<?> type) {
		return !this.customTypes.contains(type)
				&& !MvcEndpoint.class.isAssignableFrom(type);
	}

}

<code block>


package org.springframework.boot.actuate.endpoint.mvc;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.springframework.boot.actuate.endpoint.Endpoint;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.core.Ordered;
import org.springframework.util.Assert;
import org.springframework.util.StringUtils;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.servlet.HandlerMapping;
import org.springframework.web.servlet.mvc.condition.PatternsRequestCondition;
import org.springframework.web.servlet.mvc.method.RequestMappingInfo;
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;


public class EndpointHandlerMapping extends RequestMappingHandlerMapping implements
		ApplicationContextAware {

	private final Set<MvcEndpoint> endpoints;

	private final CorsConfiguration corsConfiguration;

	private String prefix = "";

	private boolean disabled = false;


	public EndpointHandlerMapping(Collection<? extends MvcEndpoint> endpoints) {
		this(endpoints, null);
	}


	public EndpointHandlerMapping(Collection<? extends MvcEndpoint> endpoints,
			CorsConfiguration corsConfiguration) {
		this.endpoints = new HashSet<MvcEndpoint>(endpoints);
		this.corsConfiguration = corsConfiguration;


		setOrder(-100);
	}

	@Override
	public void afterPropertiesSet() {
		super.afterPropertiesSet();
		if (!this.disabled) {
			for (MvcEndpoint endpoint : this.endpoints) {
				detectHandlerMethods(endpoint);
			}
		}
	}


	@Override
	protected boolean isHandler(Class<?> beanType) {
		return false;
	}

	@Override
	@Deprecated
	protected void registerHandlerMethod(Object handler, Method method,
			RequestMappingInfo mapping) {
		if (mapping == null) {
			return;
		}
		String[] patterns = getPatterns(handler, mapping);
		super.registerHandlerMethod(handler, method, withNewPatterns(mapping, patterns));
	}

	private String[] getPatterns(Object handler, RequestMappingInfo mapping) {
		String path = getPath(handler);
		String prefix = StringUtils.hasText(this.prefix) ? this.prefix + path : path;
		Set<String> defaultPatterns = mapping.getPatternsCondition().getPatterns();
		if (defaultPatterns.isEmpty()) {
			return new String[] { prefix };
		}
		List<String> patterns = new ArrayList<String>(defaultPatterns);
		for (int i = 0; i < patterns.size(); i++) {
			patterns.set(i, prefix + patterns.get(i));
		}
		return patterns.toArray(new String[patterns.size()]);
	}

	private String getPath(Object handler) {
		if (handler instanceof String) {
			handler = getApplicationContext().getBean((String) handler);
		}
		if (handler instanceof MvcEndpoint) {
			return ((MvcEndpoint) handler).getPath();
		}
		return "";
	}

	private RequestMappingInfo withNewPatterns(RequestMappingInfo mapping,
			String[] patternStrings) {
		PatternsRequestCondition patterns = new PatternsRequestCondition(patternStrings);
		return new RequestMappingInfo(patterns, mapping.getMethodsCondition(),
				mapping.getParamsCondition(), mapping.getHeadersCondition(),
				mapping.getConsumesCondition(), mapping.getProducesCondition(),
				mapping.getCustomCondition());
	}


	public void setPrefix(String prefix) {
		Assert.isTrue("".equals(prefix) || StringUtils.startsWithIgnoreCase(prefix, "/"),
				"prefix must start with '/'");
		this.prefix = prefix;
	}


	public String getPrefix() {
		return this.prefix;
	}


	public String getPath(String endpoint) {
		return this.prefix + endpoint;
	}


	public void setDisabled(boolean disabled) {
		this.disabled = disabled;
	}


	public boolean isDisabled() {
		return this.disabled;
	}


	public Set<? extends MvcEndpoint> getEndpoints() {
		return new HashSet<MvcEndpoint>(this.endpoints);
	}

	@Override
	protected CorsConfiguration initCorsConfiguration(Object handler, Method method,
			RequestMappingInfo mappingInfo) {
		return this.corsConfiguration;
	}
}

<code block>


package org.springframework.boot.actuate.autoconfigure;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Set;

import javax.annotation.PostConstruct;
import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.actuate.autoconfigure.EndpointWebMvcAutoConfiguration.ManagementContextResolver;
import org.springframework.boot.actuate.endpoint.Endpoint;
import org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMapping;
import org.springframework.boot.actuate.endpoint.mvc.MvcEndpoint;
import org.springframework.boot.autoconfigure.AutoConfigureAfter;
import org.springframework.boot.autoconfigure.AutoConfigureBefore;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.condition.ConditionOutcome;
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;
import org.springframework.boot.autoconfigure.condition.SpringBootCondition;
import org.springframework.boot.autoconfigure.security.AuthenticationManagerConfiguration;
import org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration;
import org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration;
import org.springframework.boot.autoconfigure.security.SecurityPrerequisite;
import org.springframework.boot.autoconfigure.security.SecurityProperties;
import org.springframework.boot.autoconfigure.security.SpringBootWebSecurityConfiguration;
import org.springframework.boot.autoconfigure.web.ErrorController;
import org.springframework.boot.autoconfigure.web.ServerProperties;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ConditionContext;
import org.springframework.context.annotation.Conditional;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.annotation.Order;
import org.springframework.core.type.AnnotatedTypeMetadata;
import org.springframework.security.config.annotation.web.WebSecurityConfigurer;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.builders.WebSecurity;
import org.springframework.security.config.annotation.web.builders.WebSecurity.IgnoredRequestConfigurer;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.annotation.web.configurers.ExpressionUrlAuthorizationConfigurer;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.security.web.authentication.www.BasicAuthenticationEntryPoint;
import org.springframework.security.web.util.matcher.AntPathRequestMatcher;
import org.springframework.security.web.util.matcher.AnyRequestMatcher;
import org.springframework.security.web.util.matcher.OrRequestMatcher;
import org.springframework.security.web.util.matcher.RequestMatcher;
import org.springframework.util.StringUtils;


@Configuration
@ConditionalOnWebApplication
@ConditionalOnClass({ EnableWebSecurity.class })
@AutoConfigureAfter(SecurityAutoConfiguration.class)
@AutoConfigureBefore(FallbackWebSecurityAutoConfiguration.class)
@EnableConfigurationProperties
public class ManagementSecurityAutoConfiguration {

	private static final String[] NO_PATHS = new String[0];

	@Bean
	@ConditionalOnMissingBean({ IgnoredPathsWebSecurityConfigurerAdapter.class })
	public IgnoredPathsWebSecurityConfigurerAdapter ignoredPathsWebSecurityConfigurerAdapter() {
		return new IgnoredPathsWebSecurityConfigurerAdapter();
	}

	@Configuration
	protected static class ManagementSecurityPropertiesConfiguration implements
			SecurityPrerequisite {

		@Autowired(required = false)
		private SecurityProperties security;

		@Autowired(required = false)
		private ManagementServerProperties management;

		@PostConstruct
		public void init() {
			if (this.management != null && this.security != null) {
				this.security.getUser().getRole()
						.add(this.management.getSecurity().getRole());
			}
		}

	}


	@Order(SecurityProperties.IGNORED_ORDER + 1)
	private static class IgnoredPathsWebSecurityConfigurerAdapter implements
			WebSecurityConfigurer<WebSecurity> {

		@Autowired(required = false)
		private ErrorController errorController;

		@Autowired(required = false)
		private EndpointHandlerMapping endpointHandlerMapping;

		@Autowired
		private ManagementServerProperties management;

		@Autowired
		private SecurityProperties security;

		@Autowired(required = false)
		private ServerProperties server;

		@Override
		public void configure(WebSecurity builder) throws Exception {
		}

		@Override
		public void init(WebSecurity builder) throws Exception {
			IgnoredRequestConfigurer ignoring = builder.ignoring();


			List<String> ignored = SpringBootWebSecurityConfiguration
					.getIgnored(this.security);
			if (!this.management.getSecurity().isEnabled()) {
				ignored.addAll(Arrays
						.asList(getEndpointPaths(this.endpointHandlerMapping)));
			}
			if (ignored.contains("none")) {
				ignored.remove("none");
			}
			if (this.errorController != null) {
				ignored.add(normalizePath(this.errorController.getErrorPath()));
			}
			if (this.server != null) {
				String[] paths = this.server.getPathsArray(ignored);
				ignoring.antMatchers(paths);
			}
		}

		private String normalizePath(String errorPath) {
			String result = StringUtils.cleanPath(errorPath);
			if (!result.startsWith("/")) {
				result = "/" + result;
			}
			return result;
		}

	}

	@Configuration
	@ConditionalOnMissingBean(WebSecurityConfiguration.class)
	@Conditional(WebSecurityEnablerCondition.class)
	@EnableWebSecurity
	protected static class WebSecurityEnabler extends AuthenticationManagerConfiguration {
	}


	static class WebSecurityEnablerCondition extends SpringBootCondition {

		@Override
		public ConditionOutcome getMatchOutcome(ConditionContext context,
				AnnotatedTypeMetadata metadata) {
			String managementEnabled = context.getEnvironment().getProperty(
					"management.security.enabled", "true");
			String basicEnabled = context.getEnvironment().getProperty(
					"security.basic.enabled", "true");
			return new ConditionOutcome("true".equalsIgnoreCase(managementEnabled)
					&& !"true".equalsIgnoreCase(basicEnabled),
					"Management security enabled and basic disabled");
		}

	}

	@Configuration
	@ConditionalOnMissingBean({ ManagementWebSecurityConfigurerAdapter.class })
	@ConditionalOnProperty(prefix = "management.security", name = "enabled", matchIfMissing = true)
	@Order(ManagementServerProperties.BASIC_AUTH_ORDER)
	protected static class ManagementWebSecurityConfigurerAdapter extends
			WebSecurityConfigurerAdapter {

		@Autowired
		private SecurityProperties security;

		@Autowired
		private ManagementServerProperties management;

		@Autowired(required = false)
		private ManagementContextResolver contextResolver;

		@Autowired(required = false)
		private ServerProperties server;

		@Autowired(required = false)
		private EndpointHandlerMapping endpointHandlerMapping;

		public void setEndpointHandlerMapping(
				EndpointHandlerMapping endpointHandlerMapping) {
			this.endpointHandlerMapping = endpointHandlerMapping;
		}

		@Override
		protected void configure(HttpSecurity http) throws Exception {

			RequestMatcher matcher = getRequestMatcher();
			if (matcher != null) {

				if (this.security.isRequireSsl()) {
					http.requiresChannel().anyRequest().requiresSecure();
				}
				AuthenticationEntryPoint entryPoint = entryPoint();
				http.exceptionHandling().authenticationEntryPoint(entryPoint);
				http.requestMatcher(matcher);
				configureAuthorizeRequests(new EndpointPathRequestMatcher(false),
						http.authorizeRequests());
				http.httpBasic().authenticationEntryPoint(entryPoint);

				http.csrf().disable();
				http.sessionManagement().sessionCreationPolicy(
						this.management.getSecurity().getSessions());
				SpringBootWebSecurityConfiguration.configureHeaders(http.headers(),
						this.security.getHeaders());
			}
		}

		private RequestMatcher getRequestMatcher() {
			if (!this.management.getSecurity().isEnabled()) {
				return null;
			}
			String path = management.getContextPath();
			if (StringUtils.hasText(path)) {
				AntPathRequestMatcher matcher = new AntPathRequestMatcher(
						server.getPath(path) + "/**");
				return matcher;
			}
			return new EndpointPathRequestMatcher();
		}

		private AuthenticationEntryPoint entryPoint() {
			BasicAuthenticationEntryPoint entryPoint = new BasicAuthenticationEntryPoint();
			entryPoint.setRealmName(this.security.getBasic().getRealm());
			return entryPoint;
		}

		private void configureAuthorizeRequests(
				RequestMatcher permitAllMatcher,
				ExpressionUrlAuthorizationConfigurer<HttpSecurity>.ExpressionInterceptUrlRegistry requests) {
			requests.requestMatchers(permitAllMatcher).permitAll();
			requests.anyRequest().hasRole(this.management.getSecurity().getRole());
		}

		private final class EndpointPathRequestMatcher implements RequestMatcher {

			private boolean sensitive;

			private RequestMatcher delegate;

			public EndpointPathRequestMatcher(boolean sensitive) {
				this.sensitive = sensitive;
			}

			public EndpointPathRequestMatcher() {
				this(true);
			}

			@Override
			public boolean matches(HttpServletRequest request) {
				if (endpointHandlerMapping == null && contextResolver != null) {
					ApplicationContext context = contextResolver.getApplicationContext();
					if (context != null
							&& context.getBeanNamesForType(EndpointHandlerMapping.class).length > 0) {
						endpointHandlerMapping = context
								.getBean(EndpointHandlerMapping.class);
					}
				}
				if (endpointHandlerMapping == null) {
					endpointHandlerMapping = new EndpointHandlerMapping(
							Collections.<MvcEndpoint> emptySet());
				}
				if (delegate == null) {
					List<RequestMatcher> pathMatchers = new ArrayList<RequestMatcher>();
					String[] paths = !sensitive ? getEndpointPaths(
							endpointHandlerMapping, false)
							: getEndpointPaths(endpointHandlerMapping);
					for (String path : paths) {
						pathMatchers.add(new AntPathRequestMatcher(server.getPath(path)));
					}
					delegate = pathMatchers.isEmpty() ? AnyRequestMatcher.INSTANCE
							: new OrRequestMatcher(pathMatchers);
				}
				return delegate.matches(request);
			}
		}

	}

	private static String[] getEndpointPaths(EndpointHandlerMapping endpointHandlerMapping) {
		return StringUtils.mergeStringArrays(
				getEndpointPaths(endpointHandlerMapping, false),
				getEndpointPaths(endpointHandlerMapping, true));
	}

	private static String[] getEndpointPaths(
			EndpointHandlerMapping endpointHandlerMapping, boolean secure) {
		if (endpointHandlerMapping == null) {
			return NO_PATHS;
		}
		Set<? extends MvcEndpoint> endpoints = endpointHandlerMapping.getEndpoints();
		List<String> paths = new ArrayList<String>(endpoints.size());
		for (MvcEndpoint endpoint : endpoints) {
			if (endpoint.isSensitive() == secure) {
				String path = endpointHandlerMapping.getPath(endpoint.getPath());
				paths.add(path);

				paths.add(path + "/**");

				paths.add(path + ".*");
			}
		}
		return paths.toArray(new String[paths.size()]);
	}

}

<code block>


package org.springframework.boot.actuate.autoconfigure;

import java.util.List;
import java.util.Set;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.actuate.autoconfigure.ManagementServerProperties.Security;
import org.springframework.boot.actuate.condition.ConditionalOnEnabledEndpoint;
import org.springframework.boot.actuate.endpoint.EnvironmentEndpoint;
import org.springframework.boot.actuate.endpoint.HealthEndpoint;
import org.springframework.boot.actuate.endpoint.MetricsEndpoint;
import org.springframework.boot.actuate.endpoint.ShutdownEndpoint;
import org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMapping;
import org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMappingCustomizer;
import org.springframework.boot.actuate.endpoint.mvc.EnvironmentMvcEndpoint;
import org.springframework.boot.actuate.endpoint.mvc.HealthMvcEndpoint;
import org.springframework.boot.actuate.endpoint.mvc.LogFileMvcEndpoint;
import org.springframework.boot.actuate.endpoint.mvc.MetricsMvcEndpoint;
import org.springframework.boot.actuate.endpoint.mvc.MvcEndpoint;
import org.springframework.boot.actuate.endpoint.mvc.MvcEndpoints;
import org.springframework.boot.actuate.endpoint.mvc.ShutdownMvcEndpoint;
import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.util.CollectionUtils;
import org.springframework.web.cors.CorsConfiguration;


@Configuration
@EnableConfigurationProperties({ HealthMvcEndpointProperties.class,
	EndpointCorsProperties.class })
public class EndpointWebMvcConfiguration {

	@Autowired
	private ApplicationContext applicationContext;

	@Autowired
	private HealthMvcEndpointProperties healthMvcEndpointProperties;

	@Autowired
	private ManagementServerProperties managementServerProperties;

	@Autowired
	private EndpointCorsProperties corsProperties;

	@Autowired(required = false)
	private List<EndpointHandlerMappingCustomizer> mappingCustomizers;

	@Bean
	@ConditionalOnMissingBean
	public EndpointHandlerMapping endpointHandlerMapping() {
		Set<? extends MvcEndpoint> endpoints = mvcEndpoints().getEndpoints();
		CorsConfiguration corsConfiguration = getCorsConfiguration(this.corsProperties);
		EndpointHandlerMapping mapping = new EndpointHandlerMapping(endpoints,
				corsConfiguration);
		boolean disabled = this.managementServerProperties.getPort()!=null && this.managementServerProperties.getPort()==-1;
		mapping.setDisabled(disabled);
		if (!disabled) {
			mapping.setPrefix(this.managementServerProperties.getContextPath());
		}
		if (this.mappingCustomizers != null) {
			for (EndpointHandlerMappingCustomizer customizer : this.mappingCustomizers) {
				customizer.customize(mapping);
			}
		}
		return mapping;
	}

	private CorsConfiguration getCorsConfiguration(EndpointCorsProperties properties) {
		if (CollectionUtils.isEmpty(properties.getAllowedOrigins())) {
			return null;
		}
		CorsConfiguration configuration = new CorsConfiguration();
		configuration.setAllowedOrigins(properties.getAllowedOrigins());
		if (!CollectionUtils.isEmpty(properties.getAllowedHeaders())) {
			configuration.setAllowedHeaders(properties.getAllowedHeaders());
		}
		if (!CollectionUtils.isEmpty(properties.getAllowedMethods())) {
			configuration.setAllowedMethods(properties.getAllowedMethods());
		}
		if (!CollectionUtils.isEmpty(properties.getExposedHeaders())) {
			configuration.setExposedHeaders(properties.getExposedHeaders());
		}
		if (properties.getMaxAge() != null) {
			configuration.setMaxAge(properties.getMaxAge());
		}
		if (properties.getAllowCredentials() != null) {
			configuration.setAllowCredentials(properties.getAllowCredentials());
		}
		return configuration;
	}

	@Bean
	@ConditionalOnMissingBean
	public MvcEndpoints mvcEndpoints() {
		return new MvcEndpoints();
	}

	@Bean
	@ConditionalOnBean(EnvironmentEndpoint.class)
	@ConditionalOnEnabledEndpoint("env")
	public EnvironmentMvcEndpoint environmentMvcEndpoint(EnvironmentEndpoint delegate) {
		return new EnvironmentMvcEndpoint(delegate);
	}

	@Bean
	@ConditionalOnBean(HealthEndpoint.class)
	@ConditionalOnEnabledEndpoint("health")
	public HealthMvcEndpoint healthMvcEndpoint(HealthEndpoint delegate) {
		Security security = this.managementServerProperties.getSecurity();
		boolean secure = (security != null && security.isEnabled());
		HealthMvcEndpoint healthMvcEndpoint = new HealthMvcEndpoint(delegate, secure);
		if (this.healthMvcEndpointProperties.getMapping() != null) {
			healthMvcEndpoint.addStatusMapping(this.healthMvcEndpointProperties
					.getMapping());
		}
		return healthMvcEndpoint;
	}

	@Bean
	@ConditionalOnBean(MetricsEndpoint.class)
	@ConditionalOnEnabledEndpoint("metrics")
	public MetricsMvcEndpoint metricsMvcEndpoint(MetricsEndpoint delegate) {
		return new MetricsMvcEndpoint(delegate);
	}

	@Bean
	@ConditionalOnEnabledEndpoint("logfile")
	public LogFileMvcEndpoint logfileMvcEndpoint() {
		return new LogFileMvcEndpoint();
	}

	@Bean
	@ConditionalOnBean(ShutdownEndpoint.class)
	@ConditionalOnEnabledEndpoint(value = "shutdown", enabledByDefault = false)
	public ShutdownMvcEndpoint shutdownMvcEndpoint(ShutdownEndpoint delegate) {
		return new ShutdownMvcEndpoint(delegate);
	}

}

<code block>


package org.springframework.boot.actuate.autoconfigure;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.Servlet;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.NoSuchBeanDefinitionException;
import org.springframework.beans.factory.SmartInitializingSingleton;
import org.springframework.boot.actuate.condition.ConditionalOnManagementMvcContext;
import org.springframework.boot.actuate.endpoint.Endpoint;
import org.springframework.boot.actuate.endpoint.mvc.MvcEndpoints;
import org.springframework.boot.autoconfigure.AutoConfigureAfter;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.PropertyPlaceholderAutoConfiguration;
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;
import org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration;
import org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration;
import org.springframework.boot.autoconfigure.web.ServerProperties;
import org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration;
import org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext;
import org.springframework.boot.context.embedded.EmbeddedServletContainerException;
import org.springframework.boot.context.embedded.EmbeddedWebApplicationContext;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.ApplicationListener;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.context.event.ContextClosedEvent;
import org.springframework.core.env.ConfigurableEnvironment;
import org.springframework.core.env.PropertySource;
import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.filter.OncePerRequestFilter;
import org.springframework.web.servlet.DispatcherServlet;


@Configuration
@ConditionalOnClass({ Servlet.class, DispatcherServlet.class })
@ConditionalOnWebApplication
@AutoConfigureAfter({ PropertyPlaceholderAutoConfiguration.class,
		EmbeddedServletContainerAutoConfiguration.class, WebMvcAutoConfiguration.class,
		ManagementServerPropertiesAutoConfiguration.class })
public class EndpointWebMvcAutoConfiguration implements ApplicationContextAware, SmartInitializingSingleton {

	private static Log logger = LogFactory.getLog(EndpointWebMvcAutoConfiguration.class);

	private ApplicationContext applicationContext;

	@Override
	public void setApplicationContext(ApplicationContext applicationContext)
			throws BeansException {
		this.applicationContext = applicationContext;
	}

	@ConditionalOnManagementMvcContext
	@Configuration
	@Import(EndpointWebMvcImportSelector.class)
	protected static class EndpointWebMvcConfiguration {
	}

	@Bean
	public ManagementContextResolver managementContextResolver() {
		return new ManagementContextResolver(this.applicationContext);
	}

	@Override
	public void afterSingletonsInstantiated() {
		ManagementServerPort managementPort = ManagementServerPort
				.get(this.applicationContext);
		if (managementPort == ManagementServerPort.DIFFERENT
				&& this.applicationContext instanceof EmbeddedWebApplicationContext
				&& ((EmbeddedWebApplicationContext) this.applicationContext)
						.getEmbeddedServletContainer() != null) {
			createChildManagementContext();
		}
		if (managementPort == ManagementServerPort.SAME
				&& this.applicationContext.getEnvironment() instanceof ConfigurableEnvironment) {
			addLocalManagementPortPropertyAlias((ConfigurableEnvironment) this.applicationContext
					.getEnvironment());
		}
	}

	private void createChildManagementContext() {

		final AnnotationConfigEmbeddedWebApplicationContext childContext = new AnnotationConfigEmbeddedWebApplicationContext();
		childContext.setParent(this.applicationContext);
		childContext.setNamespace("management");
		childContext.setId(this.applicationContext.getId() + ":management");

		List<Class<?>> configurations = new ArrayList<Class<?>>();
		configurations.addAll(Arrays.<Class<?>> asList(
				EndpointWebMvcChildContextConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class,
				EmbeddedServletContainerAutoConfiguration.class,
				DispatcherServletAutoConfiguration.class));



		childContext.register(configurations.toArray(new Class<?>[0]));


		if (this.applicationContext instanceof ConfigurableApplicationContext) {
			((ConfigurableApplicationContext) this.applicationContext)
					.addApplicationListener(new ApplicationListener<ContextClosedEvent>() {
						@Override
						public void onApplicationEvent(ContextClosedEvent event) {
							if (event.getApplicationContext() == EndpointWebMvcAutoConfiguration.this.applicationContext) {
								childContext.close();
							}
						}
					});
		}
		managementContextResolver().setApplicationContext(childContext);
		try {
			childContext.refresh();
		}
		catch (RuntimeException ex) {


			if (ex instanceof EmbeddedServletContainerException
					|| ex.getCause() instanceof EmbeddedServletContainerException) {
				logger.warn("Could not start embedded container (management endpoints are still available through JMX)");
			}
			else {
				throw ex;
			}
		}
	}


	private void addLocalManagementPortPropertyAlias(
			final ConfigurableEnvironment environment) {
		environment.getPropertySources().addLast(
				new PropertySource<Object>("Management Server") {
					@Override
					public Object getProperty(String name) {
						if ("local.management.port".equals(name)) {
							return environment.getProperty("local.server.port");
						}
						return null;
					}
				});
	}



	@Configuration
	protected static class ApplicationContextFilterConfiguration {

		@Bean
		public Filter applicationContextIdFilter(ApplicationContext context) {
			return new ApplicationContextHeaderFilter(context);
		}

	}


	private static class ApplicationContextHeaderFilter extends OncePerRequestFilter {

		private final ApplicationContext applicationContext;

		private ManagementServerProperties properties;

		public ApplicationContextHeaderFilter(ApplicationContext applicationContext) {
			this.applicationContext = applicationContext;
		}

		@Override
		protected void doFilterInternal(HttpServletRequest request,
				HttpServletResponse response, FilterChain filterChain)
				throws ServletException, IOException {
			if (this.properties == null) {
				this.properties = this.applicationContext
						.getBean(ManagementServerProperties.class);
			}
			if (this.properties.getAddApplicationContextHeader()) {
				response.addHeader("X-Application-Context",
						this.applicationContext.getId());
			}
			filterChain.doFilter(request, response);
		}

	}

	protected static enum ManagementServerPort {

		DISABLE, SAME, DIFFERENT;

		public static ManagementServerPort get(BeanFactory beanFactory) {
			ServerProperties serverProperties;
			try {
				serverProperties = beanFactory.getBean(ServerProperties.class);
			}
			catch (NoSuchBeanDefinitionException ex) {
				serverProperties = new ServerProperties();
			}
			ManagementServerProperties managementServerProperties;
			try {
				managementServerProperties = beanFactory
						.getBean(ManagementServerProperties.class);
			}
			catch (NoSuchBeanDefinitionException ex) {
				managementServerProperties = new ManagementServerProperties();
			}
			Integer port = managementServerProperties.getPort();
			if (port != null && port < 0) {
				return DISABLE;
			}
			if (!(beanFactory instanceof WebApplicationContext)) {

				return DIFFERENT;
			}
			return ((port == null)
					|| (serverProperties.getPort() == null && port.equals(8080))
					|| (port != 0 && port.equals(serverProperties.getPort())) ? SAME
					: DIFFERENT);
		}

	}

	public static class ManagementContextResolver {

		private ApplicationContext applicationContext;

		public ManagementContextResolver(ApplicationContext applicationContext) {
			this.applicationContext = applicationContext;
		}

		public ApplicationContext getApplicationContext() {
			return this.applicationContext;
		}

		public void setApplicationContext(ApplicationContext applicationContext) {
			this.applicationContext = applicationContext;
		}

		public MvcEndpoints getMvcEndpoints() {
			try {
				return applicationContext.getBean(MvcEndpoints.class);
			}
			catch (Exception e) {
				return null;
			}
		}

	}

}

<code block>


package org.springframework.boot.actuate.autoconfigure;

import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;

import org.springframework.beans.factory.BeanClassLoaderAware;
import org.springframework.context.annotation.DeferredImportSelector;
import org.springframework.core.io.support.SpringFactoriesLoader;
import org.springframework.core.type.AnnotationMetadata;


public class EndpointWebMvcImportSelector implements DeferredImportSelector,
		BeanClassLoaderAware {

	private ClassLoader beanClassLoader;

	@Override
	public String[] selectImports(AnnotationMetadata metadata) {

		List<String> factories = new ArrayList<String>(new LinkedHashSet<String>(
				SpringFactoriesLoader.loadFactoryNames(EndpointWebMvcConfiguration.class,
						this.beanClassLoader)));
		return factories.toArray(new String[0]);
	}

	@Override
	public void setBeanClassLoader(ClassLoader classLoader) {
		beanClassLoader = classLoader;
	}

}

<code block>


package org.springframework.boot.actuate.autoconfigure;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import javax.servlet.Filter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.BeanFactoryUtils;
import org.springframework.beans.factory.HierarchicalBeanFactory;
import org.springframework.beans.factory.ListableBeanFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.actuate.autoconfigure.ManagementSecurityAutoConfiguration.ManagementWebSecurityConfigurerAdapter;
import org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMapping;
import org.springframework.boot.actuate.endpoint.mvc.ManagementErrorEndpoint;
import org.springframework.boot.actuate.endpoint.mvc.MvcEndpoint;
import org.springframework.boot.actuate.endpoint.mvc.MvcEndpoints;
import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingClass;
import org.springframework.boot.autoconfigure.condition.SearchStrategy;
import org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration;
import org.springframework.boot.autoconfigure.web.ErrorAttributes;
import org.springframework.boot.autoconfigure.web.ServerProperties;
import org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;
import org.springframework.boot.context.embedded.EmbeddedServletContainer;
import org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;
import org.springframework.boot.context.embedded.ErrorPage;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.AnnotationAwareOrderComparator;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.web.servlet.DispatcherServlet;
import org.springframework.web.servlet.HandlerAdapter;
import org.springframework.web.servlet.HandlerExceptionResolver;
import org.springframework.web.servlet.HandlerExecutionChain;
import org.springframework.web.servlet.HandlerMapping;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;


@Configuration
public class EndpointWebMvcChildContextConfiguration {

	private static Log logger = LogFactory
			.getLog(EndpointWebMvcChildContextConfiguration.class);

	@Value("${error.path:/error}")
	private String errorPath = "/error";

	@Autowired
	private ManagementServerProperties managementServerProperties;

	@Configuration
	@Import(EndpointWebMvcImportSelector.class)
	protected static class EndpointWebMvcConfiguration {
	}

	@Configuration
	protected static class ServerCustomization implements
	EmbeddedServletContainerCustomizer, Ordered {

		@Value("${error.path:/error}")
		private String errorPath = "/error";

		@Autowired
		private ListableBeanFactory beanFactory;



		private ManagementServerProperties managementServerProperties;

		private ServerProperties server;

		@Override
		public int getOrder() {
			return 0;
		}

		@Override
		public void customize(ConfigurableEmbeddedServletContainer container) {
			if (this.managementServerProperties == null) {
				this.managementServerProperties = BeanFactoryUtils
						.beanOfTypeIncludingAncestors(this.beanFactory,
								ManagementServerProperties.class);
				this.server = BeanFactoryUtils.beanOfTypeIncludingAncestors(
						this.beanFactory, ServerProperties.class);
			}


			this.server.customize(container);

			container.setErrorPages(Collections.<ErrorPage> emptySet());

			container.setPort(this.managementServerProperties.getPort());
			container.setAddress(this.managementServerProperties.getAddress());
			container.addErrorPages(new ErrorPage(this.errorPath));
		}

	}

	@Bean(name = DispatcherServletAutoConfiguration.DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)
	public DispatcherServlet dispatcherServlet() {
		DispatcherServlet dispatcherServlet = new DispatcherServlet();


		dispatcherServlet.setDetectAllHandlerAdapters(false);
		dispatcherServlet.setDetectAllHandlerExceptionResolvers(false);
		dispatcherServlet.setDetectAllHandlerMappings(false);
		dispatcherServlet.setDetectAllViewResolvers(false);

		return dispatcherServlet;
	}

	@Configuration(DispatcherServlet.HANDLER_MAPPING_BEAN_NAME)
	@EnableWebMvc
	public static class CompositeHandlerMapping implements HandlerMapping {

		@Autowired
		private ListableBeanFactory beanFactory;

		private List<HandlerMapping> mappings;

		@Override
		public HandlerExecutionChain getHandler(HttpServletRequest request)
				throws Exception {
			if (this.mappings == null) {
				this.mappings = extractMappings();
			}
			for (HandlerMapping mapping : this.mappings) {
				HandlerExecutionChain handler = mapping.getHandler(request);
				if (handler != null) {
					return handler;
				}
			}
			return null;
		}

		private List<HandlerMapping> extractMappings() {
			List<HandlerMapping> list = new ArrayList<HandlerMapping>();
			list.addAll(this.beanFactory.getBeansOfType(HandlerMapping.class).values());
			list.remove(this);
			AnnotationAwareOrderComparator.sort(list);
			return list;
		}

	}

	@Configuration(DispatcherServlet.HANDLER_ADAPTER_BEAN_NAME)
	public static class CompositeHandlerAdapter implements HandlerAdapter {

		@Autowired
		private ListableBeanFactory beanFactory;

		private List<HandlerAdapter> adapters;

		private List<HandlerAdapter> extractAdapters() {
			List<HandlerAdapter> list = new ArrayList<HandlerAdapter>();
			list.addAll(this.beanFactory.getBeansOfType(HandlerAdapter.class).values());
			list.remove(this);
			AnnotationAwareOrderComparator.sort(list);
			return list;
		}

		@Override
		public boolean supports(Object handler) {
			if (this.adapters == null) {
				this.adapters = extractAdapters();
			}
			for (HandlerAdapter mapping : this.adapters) {
				if (mapping.supports(handler)) {
					return true;
				}
			}
			return false;
		}

		@Override
		public ModelAndView handle(HttpServletRequest request,
				HttpServletResponse response, Object handler) throws Exception {
			if (this.adapters == null) {
				this.adapters = extractAdapters();
			}
			for (HandlerAdapter mapping : this.adapters) {
				if (mapping.supports(handler)) {
					return mapping.handle(request, response, handler);
				}
			}
			return null;
		}

		@Override
		public long getLastModified(HttpServletRequest request, Object handler) {
			if (this.adapters == null) {
				this.adapters = extractAdapters();
			}
			for (HandlerAdapter mapping : this.adapters) {
				if (mapping.supports(handler)) {
					return mapping.getLastModified(request, handler);
				}
			}
			return 0;
		}

	}

	@Configuration(DispatcherServlet.HANDLER_EXCEPTION_RESOLVER_BEAN_NAME)
	public static class CompositeHandlerExceptionResolver implements
	HandlerExceptionResolver {

		@Autowired
		private ListableBeanFactory beanFactory;

		private List<HandlerExceptionResolver> resolvers;

		private List<HandlerExceptionResolver> extractResolvers() {
			List<HandlerExceptionResolver> list = new ArrayList<HandlerExceptionResolver>();
			list.addAll(this.beanFactory.getBeansOfType(HandlerExceptionResolver.class)
					.values());
			list.remove(this);
			AnnotationAwareOrderComparator.sort(list);
			return list;
		}

		@Override
		public ModelAndView resolveException(HttpServletRequest request,
				HttpServletResponse response, Object handler, Exception ex) {
			if (this.resolvers == null) {
				this.resolvers = extractResolvers();
			}
			for (HandlerExceptionResolver mapping : this.resolvers) {
				ModelAndView mav = mapping.resolveException(request, response, handler,
						ex);
				if (mav != null) {
					return mav;
				}
			}
			return null;
		}

	}


	@Bean
	public ManagementErrorEndpoint errorEndpoint(final ErrorAttributes errorAttributes) {
		return new ManagementErrorEndpoint(this.errorPath, errorAttributes);
	}


	@Configuration
	@ConditionalOnMissingClass("org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter")
	protected static class EndpointHandlerMappingConfiguration {

		@Autowired
		public void handlerMapping(MvcEndpoints endpoints,
				ListableBeanFactory beanFactory, EndpointHandlerMapping mapping) {

			mapping.setDetectHandlerMethodsInAncestorContexts(true);
			postProcessMapping(beanFactory, mapping);
		}


		protected void postProcessMapping(ListableBeanFactory beanFactory,
				EndpointHandlerMapping mapping) {
		}

	}


	@Configuration
	@ConditionalOnClass(WebSecurityConfigurerAdapter.class)
	protected static class SecureEndpointHandlerMappingConfiguration extends
	EndpointHandlerMappingConfiguration {

		@Override
		protected void postProcessMapping(ListableBeanFactory beanFactory,
				EndpointHandlerMapping mapping) {


			if (BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory,
					ManagementWebSecurityConfigurerAdapter.class).length == 1) {
				ManagementWebSecurityConfigurerAdapter bean = beanFactory
						.getBean(ManagementWebSecurityConfigurerAdapter.class);
				bean.setEndpointHandlerMapping(mapping);
			}
			else {
				logger.warn("No single bean of type "
						+ ManagementWebSecurityConfigurerAdapter.class.getSimpleName()
						+ " found (this might make some endpoints inaccessible without authentication)");
			}
		}

	}

	@Configuration
	@ConditionalOnClass({ EnableWebSecurity.class, Filter.class })
	@ConditionalOnBean(name = "springSecurityFilterChain", search = SearchStrategy.PARENTS)
	public static class EndpointWebMvcChildContextSecurityConfiguration {

		@Bean
		public Filter springSecurityFilterChain(HierarchicalBeanFactory beanFactory) {
			BeanFactory parent = beanFactory.getParentBeanFactory();
			return parent.getBean("springSecurityFilterChain", Filter.class);
		}

	}

}

<code block>


package org.springframework.boot.actuate.condition;

import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.BeanFactoryUtils;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
import org.springframework.beans.factory.support.DefaultListableBeanFactory;
import org.springframework.beans.factory.support.RootBeanDefinition;
import org.springframework.boot.actuate.autoconfigure.ManagementServerProperties;
import org.springframework.boot.autoconfigure.condition.ConditionOutcome;
import org.springframework.boot.autoconfigure.condition.SpringBootCondition;
import org.springframework.boot.autoconfigure.web.ServerProperties;
import org.springframework.boot.bind.RelaxedPropertyResolver;
import org.springframework.context.annotation.Condition;
import org.springframework.context.annotation.ConditionContext;
import org.springframework.core.type.AnnotatedTypeMetadata;
import org.springframework.web.context.WebApplicationContext;


class OnManagementMvcCondition extends SpringBootCondition {

	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context,
			AnnotatedTypeMetadata metadata) {
		RelaxedPropertyResolver management = new RelaxedPropertyResolver(
				context.getEnvironment(), "management.");
		RelaxedPropertyResolver server = new RelaxedPropertyResolver(
				context.getEnvironment(), "server.");
		Integer managementPort = management.getProperty("port", Integer.class);
		if (managementPort == null) {
			ManagementServerProperties managementServerProperties = getBeanCarefully(
					context, ManagementServerProperties.class);
			if (managementServerProperties != null) {
				managementPort = managementServerProperties.getPort();
			}
		}
		if (managementPort != null && managementPort < 0) {
			return new ConditionOutcome(false, "The mangagement port is disabled");
		}
		if (!(context.getResourceLoader() instanceof WebApplicationContext)) {

			return new ConditionOutcome(false, "The context is not a webapp");
		}
		Integer serverPort = server.getProperty("port", Integer.class);
		if (serverPort == null) {
			ServerProperties serverProperties = getBeanCarefully(context,
					ServerProperties.class);
			if (serverProperties != null) {
				serverPort = serverProperties.getPort();
			}
		}
		if ((managementPort == null)
				|| (serverPort == null && managementPort.equals(8080))
				|| (managementPort != 0 && managementPort.equals(serverPort))) {
			return new ConditionOutcome(true,
					"The main context is the management context");
		}
		return new ConditionOutcome(false,
				"The main context is not the management context");
	}

	private <T> T getBeanCarefully(ConditionContext context, Class<T> type) {
		String[] names = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
				context.getBeanFactory(), type, false, false);
		if (names.length == 1) {
			BeanDefinition original = findBeanDefinition(context.getBeanFactory(), names[0]);
			if (original instanceof RootBeanDefinition) {
				DefaultListableBeanFactory temp = new DefaultListableBeanFactory();
				temp.setParentBeanFactory(context.getBeanFactory());
				temp.registerBeanDefinition("bean",
						((RootBeanDefinition) original).cloneBeanDefinition());
				return temp.getBean(type);
			}
			return BeanFactoryUtils.beanOfType(context.getBeanFactory(), type, false,
					false);
		}
		;
		return null;
	}

	private BeanDefinition findBeanDefinition(ConfigurableListableBeanFactory beanFactory, String name) {
		BeanDefinition original = null;
		while (beanFactory!=null && original==null){
			if (beanFactory.containsLocalBean(name)) {
				original = beanFactory.getBeanDefinition(name);
			} else {
				BeanFactory parentBeanFactory = beanFactory.getParentBeanFactory();
				if (parentBeanFactory instanceof ConfigurableListableBeanFactory) {
					beanFactory = (ConfigurableListableBeanFactory) parentBeanFactory;
				} else {
					beanFactory = null;
				}
			}
		}
		return original;
	}

}

<code block>


package org.springframework.boot.actuate.condition;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import org.springframework.context.annotation.Conditional;


@Conditional(OnManagementMvcCondition.class)
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE, ElementType.METHOD })
public @interface ConditionalOnManagementMvcContext {

}

<code block>


package org.springframework.boot.actuate.endpoint.mvc;

import static org.hamcrest.Matchers.containsString;
import static org.hamcrest.Matchers.equalToIgnoringCase;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.actuate.autoconfigure.EndpointWebMvcAutoConfiguration;
import org.springframework.boot.actuate.autoconfigure.ManagementServerPropertiesAutoConfiguration;
import org.springframework.boot.actuate.endpoint.EnvironmentEndpoint;
import org.springframework.boot.actuate.endpoint.mvc.EnvironmentMvcEndpointTests.TestConfiguration;
import org.springframework.boot.test.EnvironmentTestUtils;
import org.springframework.boot.test.SpringApplicationConfiguration;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.web.WebAppConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;


@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = { TestConfiguration.class })
@WebAppConfiguration
public class EnvironmentMvcEndpointTests {

	@Autowired
	private WebApplicationContext context;

	private MockMvc mvc;

	@Before
	public void setUp() {
		this.context.getBean(EnvironmentEndpoint.class).setEnabled(true);
		this.mvc = MockMvcBuilders.webAppContextSetup(this.context).build();
		EnvironmentTestUtils.addEnvironment(
				(ConfigurableApplicationContext) this.context, "foo:bar", "fool:baz");
	}

	@Test
	public void home() throws Exception {
		this.mvc.perform(get("/env")).andExpect(status().isOk())
				.andExpect(content().string(containsString("systemProperties")));
	}

	@Test
	public void sub() throws Exception {
		this.mvc.perform(get("/env/foo")).andExpect(status().isOk())
				.andExpect(content().string(equalToIgnoringCase("bar")));
	}

	@Test
	public void subWhenDisabled() throws Exception {
		this.context.getBean(EnvironmentEndpoint.class).setEnabled(false);
		this.mvc.perform(get("/env/foo")).andExpect(status().isNotFound());
	}

	@Test
	public void regex() throws Exception {
		this.mvc.perform(get("/env/foo.*")).andExpect(status().isOk())
				.andExpect(content().string(containsString("\"foo\":\"bar\"")))
				.andExpect(content().string(containsString("\"fool\":\"baz\"")));
	}

	@Import({ EndpointWebMvcAutoConfiguration.class,
			ManagementServerPropertiesAutoConfiguration.class })
	@EnableWebMvc
	@Configuration
	public static class TestConfiguration {

		@Bean
		public EnvironmentEndpoint endpoint() {
			return new EnvironmentEndpoint();
		}

	}

}

<code block>


package org.springframework.boot.actuate.endpoint.mvc;

import static org.hamcrest.Matchers.containsString;
import static org.hamcrest.Matchers.equalTo;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.actuate.autoconfigure.EndpointWebMvcAutoConfiguration;
import org.springframework.boot.actuate.autoconfigure.ManagementServerPropertiesAutoConfiguration;
import org.springframework.boot.actuate.endpoint.MetricsEndpoint;
import org.springframework.boot.actuate.endpoint.PublicMetrics;
import org.springframework.boot.actuate.endpoint.mvc.MetricsMvcEndpointTests.TestConfiguration;
import org.springframework.boot.actuate.metrics.Metric;
import org.springframework.boot.test.SpringApplicationConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.web.WebAppConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;


@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = { TestConfiguration.class })
@WebAppConfiguration
public class MetricsMvcEndpointTests {

	@Autowired
	private WebApplicationContext context;

	private MockMvc mvc;

	@Before
	public void setUp() {
		this.context.getBean(MetricsEndpoint.class).setEnabled(true);
		this.mvc = MockMvcBuilders.webAppContextSetup(this.context).build();
	}

	@Test
	public void home() throws Exception {
		this.mvc.perform(get("/metrics")).andExpect(status().isOk())
				.andExpect(content().string(containsString("\"foo\":1")));
	}

	@Test
	public void homeWhenDisabled() throws Exception {
		this.context.getBean(MetricsEndpoint.class).setEnabled(false);
		this.mvc.perform(get("/metrics")).andExpect(status().isNotFound());
	}

	@Test
	public void specificMetric() throws Exception {
		this.mvc.perform(get("/metrics/foo")).andExpect(status().isOk())
				.andExpect(content().string(equalTo("1")));
	}

	@Test
	public void specificMetricWhenDisabled() throws Exception {
		this.context.getBean(MetricsEndpoint.class).setEnabled(false);
		this.mvc.perform(get("/metrics/foo")).andExpect(status().isNotFound());
	}

	@Test
	public void specificMetricThatDoesNotExist() throws Exception {
		this.mvc.perform(get("/metrics/bar")).andExpect(status().isNotFound());
	}

	@Test
	public void regexAll() throws Exception {
		String expected = "{\"foo\":1,\"group1.a\":1,\"group1.b\":1,\"group2.a\":1,\"group2_a\":1}";
		this.mvc.perform(get("/metrics/.*")).andExpect(status().isOk())
				.andExpect(content().string(expected));
	}

	@Test
	public void regexGroupDot() throws Exception {
		String expected = "{\"group1.a\":1,\"group1.b\":1,\"group2.a\":1}";
		this.mvc.perform(get("/metrics/group[0-9]+\\..*")).andExpect(status().isOk())
				.andExpect(content().string(expected));
	}

	@Test
	public void regexGroup1() throws Exception {
		String expected = "{\"group1.a\":1,\"group1.b\":1}";
		this.mvc.perform(get("/metrics/group1\\..*")).andExpect(status().isOk())
				.andExpect(content().string(expected));
	}

	@Test
	public void specificMetricWithDot() throws Exception {
		this.mvc.perform(get("/metrics/group2.a")).andExpect(status().isOk())
				.andExpect(content().string("1"));

	}

	@Import({ EndpointWebMvcAutoConfiguration.class,
			ManagementServerPropertiesAutoConfiguration.class })
	@EnableWebMvc
	@Configuration
	public static class TestConfiguration {

		@Bean
		public MetricsEndpoint endpoint() {
			return new MetricsEndpoint(new PublicMetrics() {

				@Override
				public Collection<Metric<?>> metrics() {
					ArrayList<Metric<?>> metrics = new ArrayList<Metric<?>>();
					metrics.add(new Metric<Integer>("foo", 1));
					metrics.add(new Metric<Integer>("group1.a", 1));
					metrics.add(new Metric<Integer>("group1.b", 1));
					metrics.add(new Metric<Integer>("group2.a", 1));
					metrics.add(new Metric<Integer>("group2_a", 1));
					return Collections.unmodifiableList(metrics);
				}

			});
		}

	}

}

<code block>


package org.springframework.boot.actuate.autoconfigure;

import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.instanceOf;
import static org.hamcrest.Matchers.is;
import static org.hamcrest.Matchers.not;
import static org.hamcrest.Matchers.notNullValue;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.mock;

import java.io.FileNotFoundException;
import java.net.SocketException;
import java.net.URI;
import java.nio.charset.Charset;
import java.util.List;
import java.util.Vector;

import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.springframework.boot.actuate.autoconfigure.EndpointWebMvcAutoConfiguration.ManagementContextResolver;
import org.springframework.boot.actuate.endpoint.Endpoint;
import org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMapping;
import org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMappingCustomizer;
import org.springframework.boot.actuate.endpoint.mvc.EnvironmentMvcEndpoint;
import org.springframework.boot.actuate.endpoint.mvc.HealthMvcEndpoint;
import org.springframework.boot.actuate.endpoint.mvc.MetricsMvcEndpoint;
import org.springframework.boot.actuate.endpoint.mvc.MvcEndpoint;
import org.springframework.boot.actuate.endpoint.mvc.ShutdownMvcEndpoint;
import org.springframework.boot.autoconfigure.PropertyPlaceholderAutoConfiguration;
import org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration;
import org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration;
import org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration;
import org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration;
import org.springframework.boot.autoconfigure.web.ServerProperties;
import org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration;
import org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration;
import org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext;
import org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;
import org.springframework.boot.context.embedded.EmbeddedServletContainer;
import org.springframework.boot.context.embedded.EmbeddedServletContainerInitializedEvent;
import org.springframework.boot.context.web.ServerPortInfoApplicationContextInitializer;
import org.springframework.boot.test.EnvironmentTestUtils;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationListener;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.http.HttpMethod;
import org.springframework.http.client.ClientHttpRequest;
import org.springframework.http.client.ClientHttpResponse;
import org.springframework.http.client.SimpleClientHttpRequestFactory;
import org.springframework.stereotype.Controller;
import org.springframework.test.util.ReflectionTestUtils;
import org.springframework.util.SocketUtils;
import org.springframework.util.StreamUtils;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;
import org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping;


public class EndpointWebMvcAutoConfigurationTests {

	private final AnnotationConfigEmbeddedWebApplicationContext applicationContext = new AnnotationConfigEmbeddedWebApplicationContext();

	private static ThreadLocal<Ports> ports = new ThreadLocal<Ports>();

	@Before
	public void grabPorts() {
		ports.set(new Ports());
	}

	@After
	public void close() {
		if (this.applicationContext != null) {
			this.applicationContext.close();
		}
	}

	@Test
	public void onSamePort() throws Exception {
		this.applicationContext.register(RootConfig.class, EndpointConfig.class,
				BaseConfiguration.class, ServerPortConfig.class,
				EndpointWebMvcAutoConfiguration.class);
		this.applicationContext.refresh();
		assertContent("/controller", ports.get().server, "controlleroutput");
		assertContent("/endpoint", ports.get().server, "endpointoutput");
		assertContent("/controller", ports.get().management, null);
		assertContent("/endpoint", ports.get().management, null);
		assertTrue(hasHeader("/endpoint", ports.get().server, "X-Application-Context"));
		this.applicationContext.close();
		assertAllClosed();
	}

	@Test
	public void onSamePortWithoutHeader() throws Exception {
		EnvironmentTestUtils.addEnvironment(this.applicationContext,
				"management.add-application-context-header:false");
		this.applicationContext.register(RootConfig.class, EndpointConfig.class,
				BaseConfiguration.class, ServerPortConfig.class,
				EndpointWebMvcAutoConfiguration.class);
		this.applicationContext.refresh();
		assertFalse(hasHeader("/endpoint", ports.get().server, "X-Application-Context"));
		this.applicationContext.close();
		assertAllClosed();
	}

	@Test
	public void onDifferentPort() throws Exception {
		this.applicationContext.register(RootConfig.class, EndpointConfig.class,
				DifferentPortConfig.class, BaseConfiguration.class,
				EndpointWebMvcAutoConfiguration.class, ErrorMvcAutoConfiguration.class);
		this.applicationContext.refresh();
		assertContent("/controller", ports.get().server, "controlleroutput");
		assertContent("/endpoint", ports.get().server, null);
		assertContent("/controller", ports.get().management, null);
		assertContent("/endpoint", ports.get().management, "endpointoutput");
		ApplicationContext managementContext = this.applicationContext.getBean(
				ManagementContextResolver.class).getApplicationContext();
		List<?> interceptors = (List<?>) ReflectionTestUtils.getField(
				managementContext.getBean(EndpointHandlerMapping.class), "interceptors");
		assertEquals(1, interceptors.size());
		this.applicationContext.close();
		assertAllClosed();
	}

	@Test
	public void onDifferentPortInServletContainer() throws Exception {
		this.applicationContext.register(RootConfig.class, EndpointConfig.class,
				DifferentPortConfig.class, BaseConfiguration.class,
				EndpointWebMvcAutoConfiguration.class, ErrorMvcAutoConfiguration.class);
		ServletContext servletContext = mock(ServletContext.class);
		given(servletContext.getInitParameterNames()).willReturn(
				new Vector<String>().elements());
		given(servletContext.getAttributeNames()).willReturn(
				new Vector<String>().elements());
		this.applicationContext.setServletContext(servletContext);
		this.applicationContext.refresh();
		assertContent("/controller", ports.get().management, null);
		assertContent("/endpoint", ports.get().management, null);
		this.applicationContext.close();
		assertAllClosed();
	}

	@Test
	public void onRandomPort() throws Exception {
		this.applicationContext.register(RootConfig.class, EndpointConfig.class,
				RandomPortConfig.class, BaseConfiguration.class,
				EndpointWebMvcAutoConfiguration.class, ErrorMvcAutoConfiguration.class);
		GrabManagementPort grabManagementPort = new GrabManagementPort(
				this.applicationContext);
		this.applicationContext.addApplicationListener(grabManagementPort);
		this.applicationContext.refresh();
		int managementPort = grabManagementPort.getServletContainer().getPort();
		assertThat(managementPort, not(equalTo(ports.get().server)));
		assertContent("/controller", ports.get().server, "controlleroutput");
		assertContent("/endpoint", ports.get().server, null);
		assertContent("/controller", managementPort, null);
		assertContent("/endpoint", managementPort, "endpointoutput");
	}

	@Test
	public void disabled() throws Exception {
		this.applicationContext.register(RootConfig.class, EndpointConfig.class,
				DisableConfig.class, BaseConfiguration.class,
				EndpointWebMvcAutoConfiguration.class);
		this.applicationContext.refresh();
		assertContent("/controller", ports.get().server, "controlleroutput");
		assertContent("/endpoint", ports.get().server, null);
		assertContent("/controller", ports.get().management, null);
		assertContent("/endpoint", ports.get().management, null);
		this.applicationContext.close();
		assertAllClosed();
	}

	@Test
	public void specificPortsViaProperties() throws Exception {
		EnvironmentTestUtils.addEnvironment(this.applicationContext, "server.port:"
				+ ports.get().server, "management.port:" + ports.get().management);
		this.applicationContext.register(RootConfig.class, EndpointConfig.class,
				BaseConfiguration.class, EndpointWebMvcAutoConfiguration.class,
				ErrorMvcAutoConfiguration.class);
		this.applicationContext.refresh();
		assertContent("/controller", ports.get().server, "controlleroutput");
		assertContent("/endpoint", ports.get().server, null);
		assertContent("/controller", ports.get().management, null);
		assertContent("/endpoint", ports.get().management, "endpointoutput");
		this.applicationContext.close();
		assertAllClosed();
	}

	@Test
	public void contextPath() throws Exception {
		EnvironmentTestUtils.addEnvironment(this.applicationContext,
				"management.contextPath:/test");
		this.applicationContext.register(RootConfig.class, EndpointConfig.class,
				ServerPortConfig.class, PropertyPlaceholderAutoConfiguration.class,
				ManagementServerPropertiesAutoConfiguration.class,
				ServerPropertiesAutoConfiguration.class,
				EmbeddedServletContainerAutoConfiguration.class,
				HttpMessageConvertersAutoConfiguration.class,
				DispatcherServletAutoConfiguration.class, WebMvcAutoConfiguration.class,
				EndpointWebMvcAutoConfiguration.class);
		this.applicationContext.refresh();
		assertContent("/controller", ports.get().server, "controlleroutput");
		assertContent("/test/endpoint", ports.get().server, "endpointoutput");
		this.applicationContext.close();
		assertAllClosed();
	}

	@Test
	public void portPropertiesOnSamePort() throws Exception {
		this.applicationContext.register(RootConfig.class, BaseConfiguration.class,
				ServerPortConfig.class, EndpointWebMvcAutoConfiguration.class);
		new ServerPortInfoApplicationContextInitializer()
		.initialize(this.applicationContext);
		this.applicationContext.refresh();
		Integer localServerPort = this.applicationContext.getEnvironment().getProperty(
				"local.server.port", Integer.class);
		Integer localManagementPort = this.applicationContext.getEnvironment()
				.getProperty("local.management.port", Integer.class);
		assertThat(localServerPort, notNullValue());
		assertThat(localManagementPort, notNullValue());
		assertThat(localServerPort, equalTo(localManagementPort));
		this.applicationContext.close();
		assertAllClosed();
	}

	@Test
	public void portPropertiesOnDifferentPort() throws Exception {
		new ServerPortInfoApplicationContextInitializer()
		.initialize(this.applicationContext);
		this.applicationContext.register(RootConfig.class, DifferentPortConfig.class,
				BaseConfiguration.class, EndpointWebMvcAutoConfiguration.class,
				ErrorMvcAutoConfiguration.class);
		this.applicationContext.refresh();
		Integer localServerPort = this.applicationContext.getEnvironment().getProperty(
				"local.server.port", Integer.class);
		Integer localManagementPort = this.applicationContext.getEnvironment()
				.getProperty("local.management.port", Integer.class);
		assertThat(localServerPort, notNullValue());
		assertThat(localManagementPort, notNullValue());
		assertThat(localServerPort, not(equalTo(localManagementPort)));
		assertThat(this.applicationContext.getBean(ServerPortConfig.class).getCount(),
				equalTo(2));
		this.applicationContext.close();
		assertAllClosed();
	}

	@Test
	public void singleRequestMappingInfoHandlerMappingBean() throws Exception {
		this.applicationContext.register(RootConfig.class, BaseConfiguration.class,
				ServerPortConfig.class, EndpointWebMvcAutoConfiguration.class);
		this.applicationContext.refresh();
		RequestMappingInfoHandlerMapping mapping = this.applicationContext
				.getBean(RequestMappingInfoHandlerMapping.class);
		assertThat(mapping, not(instanceOf(EndpointHandlerMapping.class)));
	}

	@Test
	public void endpointsDefaultConfiguration() throws Exception {
		this.applicationContext.register(RootConfig.class, BaseConfiguration.class,
				ServerPortConfig.class, EndpointWebMvcAutoConfiguration.class);
		this.applicationContext.refresh();

		assertThat(this.applicationContext.getBeansOfType(MvcEndpoint.class).size(),
				is(equalTo(4)));
	}

	@Test
	public void endpointsAllDisabled() throws Exception {
		this.applicationContext.register(RootConfig.class, BaseConfiguration.class,
				ServerPortConfig.class, EndpointWebMvcAutoConfiguration.class);
		EnvironmentTestUtils.addEnvironment(this.applicationContext,
				"ENDPOINTS_ENABLED:false");
		this.applicationContext.refresh();
		assertThat(this.applicationContext.getBeansOfType(MvcEndpoint.class).size(),
				is(equalTo(0)));
	}

	@Test
	public void environmentEndpointDisabled() throws Exception {
		endpointDisabled("env", EnvironmentMvcEndpoint.class);
	}

	@Test
	public void environmentEndpointEnabledOverride() throws Exception {
		endpointEnabledOverride("env", EnvironmentMvcEndpoint.class);
	}

	@Test
	public void metricsEndpointDisabled() throws Exception {
		endpointDisabled("metrics", MetricsMvcEndpoint.class);
	}

	@Test
	public void metricsEndpointEnabledOverride() throws Exception {
		endpointEnabledOverride("metrics", MetricsMvcEndpoint.class);
	}

	@Test
	public void healthEndpointDisabled() throws Exception {
		endpointDisabled("health", HealthMvcEndpoint.class);
	}

	@Test
	public void healthEndpointEnabledOverride() throws Exception {
		endpointEnabledOverride("health", HealthMvcEndpoint.class);
	}

	@Test
	public void shutdownEndpointEnabled() {
		this.applicationContext.register(RootConfig.class, BaseConfiguration.class,
				ServerPortConfig.class, EndpointWebMvcAutoConfiguration.class);
		EnvironmentTestUtils.addEnvironment(this.applicationContext,
				"endpoints.shutdown.enabled:true");
		this.applicationContext.refresh();
		assertThat(this.applicationContext.getBeansOfType(ShutdownMvcEndpoint.class)
				.size(), is(equalTo(1)));
	}

	private void endpointDisabled(String name, Class<? extends MvcEndpoint> type) {
		this.applicationContext.register(RootConfig.class, BaseConfiguration.class,
				ServerPortConfig.class, EndpointWebMvcAutoConfiguration.class);
		EnvironmentTestUtils.addEnvironment(this.applicationContext,
				String.format("endpoints.%s.enabled:false", name));
		this.applicationContext.refresh();
		assertThat(this.applicationContext.getBeansOfType(type).size(), is(equalTo(0)));
	}

	private void endpointEnabledOverride(String name, Class<? extends MvcEndpoint> type)
			throws Exception {
		this.applicationContext.register(RootConfig.class, BaseConfiguration.class,
				ServerPortConfig.class, EndpointWebMvcAutoConfiguration.class);
		EnvironmentTestUtils.addEnvironment(this.applicationContext,
				"endpoints.enabled:false",
				String.format("endpoints_%s_enabled:true", name));
		this.applicationContext.refresh();
		assertThat(this.applicationContext.getBeansOfType(type).size(), is(equalTo(1)));
	}

	private void assertAllClosed() throws Exception {
		assertContent("/controller", ports.get().server, null);
		assertContent("/endpoint", ports.get().server, null);
		assertContent("/controller", ports.get().management, null);
		assertContent("/endpoint", ports.get().management, null);
	}

	public void assertContent(String url, int port, Object expected) throws Exception {
		SimpleClientHttpRequestFactory clientHttpRequestFactory = new SimpleClientHttpRequestFactory();
		ClientHttpRequest request = clientHttpRequestFactory.createRequest(new URI(
				"http://localhost:" + port + url), HttpMethod.GET);
		try {
			ClientHttpResponse response = request.execute();
			try {
				String actual = StreamUtils.copyToString(response.getBody(),
						Charset.forName("UTF-8"));
				assertThat(actual, equalTo(expected));
			}
			finally {
				response.close();
			}
		}
		catch (Exception ex) {
			if (expected == null) {
				if (SocketException.class.isInstance(ex)
						|| FileNotFoundException.class.isInstance(ex)) {
					return;
				}
			}
			throw ex;
		}
	}

	public boolean hasHeader(String url, int port, String header) throws Exception {
		SimpleClientHttpRequestFactory clientHttpRequestFactory = new SimpleClientHttpRequestFactory();
		ClientHttpRequest request = clientHttpRequestFactory.createRequest(new URI(
				"http://localhost:" + port + url), HttpMethod.GET);
		ClientHttpResponse response = request.execute();
		return response.getHeaders().containsKey(header);
	}

	private static class Ports {

		int server = SocketUtils.findAvailableTcpPort();

		int management = SocketUtils.findAvailableTcpPort();

	}

	@Configuration
	@Import({ PropertyPlaceholderAutoConfiguration.class,
		EmbeddedServletContainerAutoConfiguration.class,
		EndpointAutoConfiguration.class,
		HttpMessageConvertersAutoConfiguration.class,
		DispatcherServletAutoConfiguration.class, WebMvcAutoConfiguration.class,
		ManagementServerPropertiesAutoConfiguration.class,
		ServerPropertiesAutoConfiguration.class, WebMvcAutoConfiguration.class })
	protected static class BaseConfiguration {

	}

	@Configuration
	public static class RootConfig {

		@Bean
		public TestController testController() {
			return new TestController();
		}

	}

	@Configuration
	public static class EndpointConfig {

		@Bean
		public TestEndpoint testEndpoint() {
			return new TestEndpoint();
		}

	}

	@Configuration
	public static class ServerPortConfig {

		private int count = 0;

		public int getCount() {
			return this.count;
		}

		@Bean
		public ServerProperties serverProperties() {
			ServerProperties properties = new ServerProperties() {
				@Override
				public void customize(ConfigurableEmbeddedServletContainer container) {
					ServerPortConfig.this.count++;
					super.customize(container);
				}
			};
			properties.setPort(ports.get().server);
			return properties;
		}

	}

	@Controller
	public static class TestController {

		@RequestMapping("/controller")
		@ResponseBody
		public String requestMappedMethod() {
			return "controlleroutput";
		}

	}

	@Configuration
	@Import(ServerPortConfig.class)
	public static class DifferentPortConfig {

		@Bean
		public ManagementServerProperties managementServerProperties() {
			ManagementServerProperties properties = new ManagementServerProperties();
			properties.setPort(ports.get().management);
			return properties;
		}

		@Bean
		public EndpointHandlerMappingCustomizer mappingCustomizer() {
			return new EndpointHandlerMappingCustomizer() {

				@Override
				public void customize(EndpointHandlerMapping mapping) {
					mapping.setInterceptors(new Object[] { interceptor() });
				}

			};
		}

		@Bean
		protected TestInterceptor interceptor() {
			return new TestInterceptor();
		}

		protected static class TestInterceptor extends HandlerInterceptorAdapter {
			private int count = 0;

			@Override
			public void postHandle(HttpServletRequest request,
					HttpServletResponse response, Object handler,
					ModelAndView modelAndView) throws Exception {
				this.count++;
			}

			public int getCount() {
				return this.count;
			}
		}

	}

	@Configuration
	@Import(ServerPortConfig.class)
	public static class RandomPortConfig {

		@Bean
		public ManagementServerProperties managementServerProperties() {
			ManagementServerProperties properties = new ManagementServerProperties();
			properties.setPort(0);
			return properties;
		}

	}

	@Configuration
	@Import(ServerPortConfig.class)
	public static class DisableConfig {

		@Bean
		public ManagementServerProperties managementServerProperties() {
			ManagementServerProperties properties = new ManagementServerProperties();
			properties.setPort(-1);
			return properties;
		}

	}

	public static class TestEndpoint implements MvcEndpoint {

		@RequestMapping
		@ResponseBody
		public String invoke() {
			return "endpointoutput";
		}

		@Override
		public String getPath() {
			return "/endpoint";
		}

		@Override
		public boolean isSensitive() {
			return true;
		}

		@Override
		@SuppressWarnings("rawtypes")
		public Class<? extends Endpoint> getEndpointType() {
			return Endpoint.class;
		}

	}

	private static class GrabManagementPort implements
	ApplicationListener<EmbeddedServletContainerInitializedEvent> {

		private ApplicationContext rootContext;

		private EmbeddedServletContainer servletContainer;

		public GrabManagementPort(ApplicationContext rootContext) {
			this.rootContext = rootContext;
		}

		@Override
		public void onApplicationEvent(EmbeddedServletContainerInitializedEvent event) {
			if (event.getApplicationContext() != this.rootContext) {
				this.servletContainer = event.getEmbeddedServletContainer();
			}
		}

		public EmbeddedServletContainer getServletContainer() {
			return this.servletContainer;
		}

	}

}

<code block>


package org.springframework.boot.autoconfigure.web;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.ResourceLoaderAware;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;


@ConfigurationProperties(prefix = "spring.resources", ignoreUnknownFields = false)
public class ResourceProperties implements ResourceLoaderAware {

	private static final String[] SERVLET_RESOURCE_LOCATIONS = { "/" };

	private static final String[] CLASSPATH_RESOURCE_LOCATIONS = {
			"classpath:/META-INF/resources/", "classpath:/resources/",
			"classpath:/static/", "classpath:/public/" };

	private static final String[] RESOURCE_LOCATIONS;
	static {
		RESOURCE_LOCATIONS = new String[CLASSPATH_RESOURCE_LOCATIONS.length
				+ SERVLET_RESOURCE_LOCATIONS.length];
		System.arraycopy(SERVLET_RESOURCE_LOCATIONS, 0, RESOURCE_LOCATIONS, 0,
				SERVLET_RESOURCE_LOCATIONS.length);
		System.arraycopy(CLASSPATH_RESOURCE_LOCATIONS, 0, RESOURCE_LOCATIONS,
				SERVLET_RESOURCE_LOCATIONS.length, CLASSPATH_RESOURCE_LOCATIONS.length);
	}

	private static final String[] STATIC_INDEX_HTML_RESOURCES;
	static {
		STATIC_INDEX_HTML_RESOURCES = new String[RESOURCE_LOCATIONS.length];
		for (int i = 0; i < STATIC_INDEX_HTML_RESOURCES.length; i++) {
			STATIC_INDEX_HTML_RESOURCES[i] = RESOURCE_LOCATIONS[i] + "index.html";
		}
	}


	private Integer cachePeriod;


	private boolean addMappings = true;

	private final Chain chain = new Chain();


	private String[] staticLocations = RESOURCE_LOCATIONS;

	private ResourceLoader resourceLoader;

	@Override
	public void setResourceLoader(ResourceLoader resourceLoader) {
		this.resourceLoader = resourceLoader;
	}

	public Integer getCachePeriod() {
		return this.cachePeriod;
	}

	public void setCachePeriod(Integer cachePeriod) {
		this.cachePeriod = cachePeriod;
	}

	public boolean isAddMappings() {
		return this.addMappings;
	}

	public void setAddMappings(boolean addMappings) {
		this.addMappings = addMappings;
	}

	public Chain getChain() {
		return this.chain;
	}


	public static class Chain {


		private Boolean enabled;


		private boolean cache = true;


		private boolean htmlApplicationCache = false;

		private final Strategy strategy = new Strategy();

		public Boolean getEnabled() {
			return this.enabled;
		}

		public void setEnabled(boolean enabled) {
			this.enabled = enabled;
		}

		public boolean isCache() {
			return this.cache;
		}

		public void setCache(boolean cache) {
			this.cache = cache;
		}

		public Strategy getStrategy() {
			return this.strategy;
		}

		public boolean isHtmlApplicationCache() {
			return this.htmlApplicationCache;
		}

		public void setHtmlApplicationCache(boolean htmlApplicationCache) {
			this.htmlApplicationCache = htmlApplicationCache;
		}

	}


	public static class Strategy {

		private final Fixed fixed = new Fixed();

		private final Content content = new Content();

		public Fixed getFixed() {
			return this.fixed;
		}

		public Content getContent() {
			return this.content;
		}

	}


	public static class Content {


		private boolean enabled;


		private String[] paths = new String[] { "/**" };

		public boolean isEnabled() {
			return this.enabled;
		}

		public void setEnabled(boolean enabled) {
			this.enabled = enabled;
		}

		public String[] getPaths() {
			return this.paths;
		}

		public void setPaths(String[] paths) {
			this.paths = paths;
		}

	}


	public static class Fixed {


		private boolean enabled;


		private String[] paths;


		private String version;

		public boolean isEnabled() {
			return this.enabled;
		}

		public void setEnabled(boolean enabled) {
			this.enabled = enabled;
		}

		public String[] getPaths() {
			return this.paths;
		}

		public void setPaths(String[] paths) {
			this.paths = paths;
		}

		public String getVersion() {
			return this.version;
		}

		public void setVersion(String version) {
			this.version = version;
		}

	}

	public String[] getStaticLocations() {
		return this.staticLocations;
	}

	public void setStaticLocations(String[] staticLocations) {
		this.staticLocations = staticLocations;
	}

	private String[] getStaticWelcomePageLocations() {
		String[] result = new String[staticLocations.length];
		for (int i = 0; i < result.length; i++) {
			String location = staticLocations[i];
			if (!location.endsWith("/")) {
				location = location + "/";
			}
			result[i] = location + "index.html";
		}
		return result;
	}

	public List<Resource> getFaviconLocations() {
		List<Resource> locations = new ArrayList<Resource>(
				CLASSPATH_RESOURCE_LOCATIONS.length + 1);
		if (resourceLoader != null) {
			for (String location : CLASSPATH_RESOURCE_LOCATIONS) {
				locations.add(this.resourceLoader.getResource(location));
			}
		}
		locations.add(new ClassPathResource("/"));
		return Collections.unmodifiableList(locations);
	}

	public Resource getWelcomePage() {
		for (String location : getStaticWelcomePageLocations()) {
			Resource resource = this.resourceLoader.getResource(location);
			if (resource.exists()) {
				try {
					resource.getURL();
					return resource;
				}
				catch (IOException ex) {

				}
			}
		}
		return null;
	}

}

<code block>


package org.springframework.boot.autoconfigure.web;

import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.List;

import javax.servlet.Servlet;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.ListableBeanFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.AutoConfigureAfter;
import org.springframework.boot.autoconfigure.AutoConfigureOrder;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;
import org.springframework.boot.autoconfigure.web.ResourceProperties.Strategy;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.boot.context.web.OrderedHiddenHttpMethodFilter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.context.annotation.Primary;
import org.springframework.core.Ordered;
import org.springframework.core.convert.converter.Converter;
import org.springframework.core.convert.converter.GenericConverter;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
import org.springframework.format.Formatter;
import org.springframework.format.FormatterRegistry;
import org.springframework.format.datetime.DateFormatter;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.util.StringUtils;
import org.springframework.validation.DefaultMessageCodesResolver;
import org.springframework.validation.MessageCodesResolver;
import org.springframework.web.accept.ContentNegotiationManager;
import org.springframework.web.context.request.RequestContextListener;
import org.springframework.web.filter.HiddenHttpMethodFilter;
import org.springframework.web.servlet.DispatcherServlet;
import org.springframework.web.servlet.LocaleResolver;
import org.springframework.web.servlet.View;
import org.springframework.web.servlet.ViewResolver;
import org.springframework.web.servlet.config.annotation.AsyncSupportConfigurer;
import org.springframework.web.servlet.config.annotation.DelegatingWebMvcConfiguration;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.ResourceChainRegistration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;
import org.springframework.web.servlet.handler.SimpleUrlHandlerMapping;
import org.springframework.web.servlet.i18n.FixedLocaleResolver;
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter;
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;
import org.springframework.web.servlet.resource.AppCacheManifestTransformer;
import org.springframework.web.servlet.resource.ResourceHttpRequestHandler;
import org.springframework.web.servlet.resource.ResourceResolver;
import org.springframework.web.servlet.resource.VersionResourceResolver;
import org.springframework.web.servlet.view.BeanNameViewResolver;
import org.springframework.web.servlet.view.ContentNegotiatingViewResolver;
import org.springframework.web.servlet.view.InternalResourceViewResolver;


@Configuration
@ConditionalOnWebApplication
@ConditionalOnClass({ Servlet.class, DispatcherServlet.class,
		WebMvcConfigurerAdapter.class })
@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@AutoConfigureAfter(DispatcherServletAutoConfiguration.class)
public class WebMvcAutoConfiguration {

	public static String DEFAULT_PREFIX = "";

	public static String DEFAULT_SUFFIX = "";

	@Bean
	@ConditionalOnMissingBean(HiddenHttpMethodFilter.class)
	public HiddenHttpMethodFilter hiddenHttpMethodFilter() {
		return new OrderedHiddenHttpMethodFilter();
	}



	@Configuration
	@Import(EnableWebMvcConfiguration.class)
	@EnableConfigurationProperties({ WebMvcProperties.class, ResourceProperties.class })
	public static class WebMvcAutoConfigurationAdapter extends WebMvcConfigurerAdapter {

		private static Log logger = LogFactory.getLog(WebMvcConfigurerAdapter.class);

		@Autowired
		private ResourceProperties resourceProperties = new ResourceProperties();

		@Autowired
		private WebMvcProperties mvcProperties = new WebMvcProperties();

		@Autowired
		private ListableBeanFactory beanFactory;

		@Autowired
		private ResourceLoader resourceLoader;

		@Autowired
		private HttpMessageConverters messageConverters;

		@Override
		public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
			converters.addAll(this.messageConverters.getConverters());
		}

		@Override
		public void configureAsyncSupport(AsyncSupportConfigurer configurer) {
			Long timeout = this.mvcProperties.getAsync().getRequestTimeout();
			if (timeout != null) {
				configurer.setDefaultTimeout(timeout);
			}
		}

		@Bean
		@ConditionalOnMissingBean(InternalResourceViewResolver.class)
		public InternalResourceViewResolver defaultViewResolver() {
			InternalResourceViewResolver resolver = new InternalResourceViewResolver();
			resolver.setPrefix(this.mvcProperties.getView().getPrefix());
			resolver.setSuffix(this.mvcProperties.getView().getSuffix());
			return resolver;
		}

		@Bean
		@ConditionalOnMissingBean(RequestContextListener.class)
		public RequestContextListener requestContextListener() {
			return new RequestContextListener();
		}

		@Bean
		@ConditionalOnBean(View.class)
		public BeanNameViewResolver beanNameViewResolver() {
			BeanNameViewResolver resolver = new BeanNameViewResolver();
			resolver.setOrder(Ordered.LOWEST_PRECEDENCE - 10);
			return resolver;
		}

		@Bean
		@ConditionalOnBean(ViewResolver.class)
		@ConditionalOnMissingBean(name = "viewResolver", value = ContentNegotiatingViewResolver.class)
		public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory) {
			ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver();
			resolver.setContentNegotiationManager(beanFactory
					.getBean(ContentNegotiationManager.class));


			resolver.setOrder(Ordered.HIGHEST_PRECEDENCE);
			return resolver;
		}

		@Bean
		@ConditionalOnMissingBean(LocaleResolver.class)
		@ConditionalOnProperty(prefix = "spring.mvc", name = "locale")
		public LocaleResolver localeResolver() {
			return new FixedLocaleResolver(
					StringUtils.parseLocaleString(this.mvcProperties.getLocale()));
		}

		@Bean
		@ConditionalOnProperty(prefix = "spring.mvc", name = "date-format")
		public Formatter<Date> dateFormatter() {
			return new DateFormatter(this.mvcProperties.getDateFormat());
		}

		@Override
		public MessageCodesResolver getMessageCodesResolver() {
			if (this.mvcProperties.getMessageCodesResolverFormat() != null) {
				DefaultMessageCodesResolver resolver = new DefaultMessageCodesResolver();
				resolver.setMessageCodeFormatter(this.mvcProperties
						.getMessageCodesResolverFormat());
				return resolver;
			}
			return null;
		}

		@Override
		public void addFormatters(FormatterRegistry registry) {
			for (Converter<?, ?> converter : getBeansOfType(Converter.class)) {
				registry.addConverter(converter);
			}
			for (GenericConverter converter : getBeansOfType(GenericConverter.class)) {
				registry.addConverter(converter);
			}
			for (Formatter<?> formatter : getBeansOfType(Formatter.class)) {
				registry.addFormatter(formatter);
			}
		}

		private <T> Collection<T> getBeansOfType(Class<T> type) {
			return this.beanFactory.getBeansOfType(type).values();
		}

		@Override
		public void addResourceHandlers(ResourceHandlerRegistry registry) {
			if (!this.resourceProperties.isAddMappings()) {
				logger.debug("Default resource handling disabled");
				return;
			}
			Integer cachePeriod = this.resourceProperties.getCachePeriod();
			if (!registry.hasMappingForPattern("/webjars/**")) {
				registerResourceChain(registry.addResourceHandler("/webjars/**")
						.addResourceLocations("classpath:/META-INF/resources/webjars/")
						.setCachePeriod(cachePeriod));
			}
			if (!registry.hasMappingForPattern("/**")) {
				registerResourceChain(registry.addResourceHandler("/**")
						.addResourceLocations(resourceProperties.getStaticLocations())
						.setCachePeriod(cachePeriod));
			}
		}

		private void registerResourceChain(ResourceHandlerRegistration registration) {
			ResourceProperties.Chain properties = this.resourceProperties.getChain();
			if (Boolean.TRUE.equals(properties.getEnabled())
					|| properties.getStrategy().getFixed().isEnabled()
					|| properties.getStrategy().getContent().isEnabled()) {
				configureResourceChain(properties,
						registration.resourceChain(properties.isCache()));
			}
		}

		private void configureResourceChain(ResourceProperties.Chain properties,
				ResourceChainRegistration chain) {
			Strategy strategy = properties.getStrategy();
			if (strategy.getFixed().isEnabled() || strategy.getContent().isEnabled()) {
				chain.addResolver(getVersionResourceResolver(strategy));
			}
			if (properties.isHtmlApplicationCache()) {
				chain.addTransformer(new AppCacheManifestTransformer());
			}
		}

		private ResourceResolver getVersionResourceResolver(
				ResourceProperties.Strategy properties) {
			VersionResourceResolver resolver = new VersionResourceResolver();
			if (properties.getFixed().isEnabled()) {
				String version = properties.getFixed().getVersion();
				String[] paths = properties.getFixed().getPaths();
				resolver.addFixedVersionStrategy(version, paths);
			}
			if (properties.getContent().isEnabled()) {
				String[] paths = properties.getContent().getPaths();
				resolver.addContentVersionStrategy(paths);
			}
			return resolver;
		}

		@Override
		public void addViewControllers(ViewControllerRegistry registry) {
			Resource page = resourceProperties.getWelcomePage();
			if (page != null) {
				logger.info("Adding welcome page: " + page);
				registry.addViewController("/").setViewName("forward:index.html");
			}
		}

		@Configuration
		@ConditionalOnProperty(value = "spring.mvc.favicon.enabled", matchIfMissing = true)
		public static class FaviconConfiguration {

			@Autowired
			private ResourceProperties resourceProperties = new ResourceProperties();

			@Bean
			public SimpleUrlHandlerMapping faviconHandlerMapping() {
				SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();
				mapping.setOrder(Integer.MIN_VALUE + 1);
				mapping.setUrlMap(Collections.singletonMap("**/favicon.ico",
						faviconRequestHandler()));
				return mapping;
			}

			@Bean
			public ResourceHttpRequestHandler faviconRequestHandler() {
				ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler();
				requestHandler.setLocations(resourceProperties.getFaviconLocations());
				return requestHandler;
			}

		}

	}


	@Configuration
	public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration {

		@Autowired(required = false)
		private WebMvcProperties mvcProperties;

		@Bean
		@Override
		public RequestMappingHandlerAdapter requestMappingHandlerAdapter() {
			RequestMappingHandlerAdapter adapter = super.requestMappingHandlerAdapter();
			adapter.setIgnoreDefaultModelOnRedirect(this.mvcProperties == null ? true
					: this.mvcProperties.isIgnoreDefaultModelOnRedirect());
			return adapter;
		}

		@Bean
		@Primary
		@Override
		public RequestMappingHandlerMapping requestMappingHandlerMapping() {

			return super.requestMappingHandlerMapping();
		}

	}

}

<code block>


package org.springframework.boot.autoconfigure.web;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import org.junit.After;
import org.junit.Test;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.PropertyPlaceholderAutoConfiguration;
import org.springframework.boot.builder.SpringApplicationBuilder;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.web.context.ConfigurableWebApplicationContext;


public class WelcomePageMockMvcTests {

	private ConfigurableWebApplicationContext wac;

	private MockMvc mockMvc;

	@After
	public void close() {
		if (wac != null) {
			wac.close();
		}
	}

	@Test
	public void homePageNotFound() throws Exception {
		wac = (ConfigurableWebApplicationContext) new SpringApplicationBuilder(
				TestConfiguration.class).run();
		this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();
		this.mockMvc.perform(get("/")).andExpect(status().isNotFound()).andReturn();
	}

	@Test
	public void homePageCustomLocation() throws Exception {
		wac = (ConfigurableWebApplicationContext) new SpringApplicationBuilder(
				TestConfiguration.class).properties(
				"spring.resources.staticLocations:classpath:/custom/").run();
		this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();
		this.mockMvc.perform(get("/")).andExpect(status().isOk()).andReturn();
	}

	@Test
	public void homePageCustomLocationNoTrailingSlash() throws Exception {
		wac = (ConfigurableWebApplicationContext) new SpringApplicationBuilder(
				TestConfiguration.class).properties("spring.resources.staticLocations:classpath:/custom").run();
		this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();
		this.mockMvc.perform(get("/")).andExpect(status().isOk()).andReturn();
	}

	@Target(ElementType.TYPE)
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	@Import({ EmbeddedServletContainerAutoConfiguration.EmbeddedTomcat.class,
			EmbeddedServletContainerAutoConfiguration.class,
			ServerPropertiesAutoConfiguration.class,
			DispatcherServletAutoConfiguration.class, WebMvcAutoConfiguration.class,
			HttpMessageConvertersAutoConfiguration.class,
			ErrorMvcAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class })
	protected static @interface MinimalWebConfiguration {
	}

	@Configuration
	@MinimalWebConfiguration
	public static class TestConfiguration {


		public static void main(String[] args) {
			SpringApplication.run(TestConfiguration.class, args);
		}

	}

}

<code block>


package org.springframework.boot.actuate.metrics.buffer;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.function.BiConsumer;
import java.util.function.Predicate;
import java.util.regex.Pattern;

import org.springframework.boot.actuate.metrics.Metric;
import org.springframework.boot.actuate.metrics.reader.MetricReader;
import org.springframework.boot.actuate.metrics.reader.PrefixMetricReader;
import org.springframework.lang.UsesJava8;


@UsesJava8
public class BufferMetricReader implements MetricReader, PrefixMetricReader {

	private final CounterBuffers counters;

	private final GaugeBuffers gauges;

	private final Predicate<String> all = Pattern.compile(".*").asPredicate();

	public BufferMetricReader(CounterBuffers counters, GaugeBuffers gauges) {
		this.counters = counters;
		this.gauges = gauges;
	}

	@Override
	public Iterable<Metric<?>> findAll(String prefix) {
		final List<Metric<?>> metrics = new ArrayList<Metric<?>>();
		this.counters.forEach(Pattern.compile(prefix + ".*").asPredicate(),
				new BiConsumer<String, LongBuffer>() {
					@Override
					public void accept(String name, LongBuffer value) {
						metrics.add(new Metric<Long>(name, value.getValue(), new Date(
								value.getTimestamp())));
					}
				});
		this.gauges.forEach(Pattern.compile(prefix + ".*").asPredicate(),
				new BiConsumer<String, DoubleBuffer>() {
					@Override
					public void accept(String name, DoubleBuffer value) {
						metrics.add(new Metric<Double>(name, value.getValue(), new Date(
								value.getTimestamp())));
					}
				});
		return metrics;
	}

	@Override
	public Metric<?> findOne(final String name) {
		LongBuffer buffer = this.counters.find(name);
		if (buffer != null) {
			return new Metric<Long>(name, buffer.getValue(), new Date(
					buffer.getTimestamp()));
		}
		DoubleBuffer doubleValue = this.gauges.find(name);
		if (doubleValue != null) {
			return new Metric<Double>(name, doubleValue.getValue(), new Date(
					doubleValue.getTimestamp()));
		}
		return null;
	}

	@Override
	public Iterable<Metric<?>> findAll() {
		final List<Metric<?>> metrics = new ArrayList<Metric<?>>();
		this.counters.forEach(this.all, new BiConsumer<String, LongBuffer>() {
			@Override
			public void accept(String name, LongBuffer value) {
				metrics.add(new Metric<Long>(name, value.getValue(), new Date(value
						.getTimestamp())));
			}
		});
		this.gauges.forEach(this.all, new BiConsumer<String, DoubleBuffer>() {
			@Override
			public void accept(String name, DoubleBuffer value) {
				metrics.add(new Metric<Double>(name, value.getValue(), new Date(value
						.getTimestamp())));
			}
		});
		return metrics;
	}

	@Override
	public long count() {
		return this.counters.count() + this.gauges.count();
	}

}

<code block>


package org.springframework.boot.actuate.metrics.buffer;

import java.util.concurrent.ConcurrentHashMap;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;

import org.springframework.lang.UsesJava8;


@UsesJava8
public class GaugeBuffers {

	private final ConcurrentHashMap<String, DoubleBuffer> metrics = new ConcurrentHashMap<String, DoubleBuffer>();

	public void forEach(final Predicate<String> predicate,
			final BiConsumer<String, DoubleBuffer> consumer) {
		this.metrics.forEach(new BiConsumer<String, DoubleBuffer>() {
			@Override
			public void accept(String name, DoubleBuffer value) {
				if (predicate.test(name)) {
					consumer.accept(name, value);
				}
			}
		});
	}

	public DoubleBuffer find(final String name) {
		return this.metrics.get(name);
	}

	public void get(final String name, final Consumer<DoubleBuffer> consumer) {
		acceptInternal(name, new Consumer<DoubleBuffer>() {
			@Override
			public void accept(DoubleBuffer value) {
				consumer.accept(value);
			}
		});
	}

	public void set(final String name, final double value) {
		write(name, value);
	}

	public int count() {
		return this.metrics.size();
	}

	private void write(final String name, final double value) {
		acceptInternal(name, new Consumer<DoubleBuffer>() {
			@Override
			public void accept(DoubleBuffer buffer) {
				buffer.setTimestamp(System.currentTimeMillis());
				buffer.setValue(value);
			}
		});
	}

	public void reset(String name) {
		this.metrics.remove(name, this.metrics.get(name));
	}

	private void acceptInternal(final String name, final Consumer<DoubleBuffer> consumer) {
		DoubleBuffer value;
		if (null == (value = this.metrics.get(name))) {
			value = this.metrics.computeIfAbsent(name,
					new Function<String, DoubleBuffer>() {
						@Override
						public DoubleBuffer apply(String tag) {
							return new DoubleBuffer(0L);
						}
					});
		}
		consumer.accept(value);
	}

}

<code block>


package org.springframework.boot.actuate.metrics.buffer;

import java.util.concurrent.ConcurrentHashMap;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;

import org.springframework.lang.UsesJava8;


@UsesJava8
public class CounterBuffers {

	private final ConcurrentHashMap<String, LongBuffer> metrics = new ConcurrentHashMap<String, LongBuffer>();

	public void forEach(final Predicate<String> predicate,
			final BiConsumer<String, LongBuffer> consumer) {
		this.metrics.forEach(new BiConsumer<String, LongBuffer>() {
			@Override
			public void accept(String name, LongBuffer value) {
				if (predicate.test(name)) {
					consumer.accept(name, value);
				}
			}
		});
	}

	public LongBuffer find(final String name) {
		return this.metrics.get(name);
	}

	public void get(final String name, final Consumer<LongBuffer> consumer) {
		read(name, new Consumer<LongBuffer>() {
			@Override
			public void accept(LongBuffer adder) {
				consumer.accept(adder);
			}
		});
	}

	public void increment(final String name, final long delta) {
		write(name, new Consumer<LongBuffer>() {
			@Override
			public void accept(LongBuffer adder) {
				adder.add(delta);
			}
		});
	}

	public void reset(final String name) {
		write(name, new Consumer<LongBuffer>() {
			@Override
			public void accept(LongBuffer adder) {
				adder.reset();
			}
		});
	}

	public int count() {
		return this.metrics.size();
	}

	private void read(final String name, final Consumer<LongBuffer> consumer) {
		acceptInternal(name, new Consumer<LongBuffer>() {
			@Override
			public void accept(LongBuffer adder) {
				consumer.accept(adder);
			}
		});
	}

	private void write(final String name, final Consumer<LongBuffer> consumer) {
		acceptInternal(name, new Consumer<LongBuffer>() {
			@Override
			public void accept(LongBuffer buffer) {
				buffer.setTimestamp(System.currentTimeMillis());
				consumer.accept(buffer);
			}
		});
	}

	private void acceptInternal(final String name, final Consumer<LongBuffer> consumer) {
		LongBuffer adder;
		if (null == (adder = this.metrics.get(name))) {
			adder = this.metrics.computeIfAbsent(name,
					new Function<String, LongBuffer>() {
						@Override
						public LongBuffer apply(String name) {
							return new LongBuffer(0L);
						}
					});
		}
		consumer.accept(adder);
	}

}

<code block>


package org.springframework.boot.actuate.metrics.buffer;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.function.BiConsumer;
import java.util.function.Predicate;
import java.util.regex.Pattern;

import org.springframework.boot.actuate.metrics.Metric;
import org.springframework.boot.actuate.metrics.reader.MetricReader;
import org.springframework.boot.actuate.metrics.reader.PrefixMetricReader;
import org.springframework.lang.UsesJava8;


@UsesJava8
public class BufferMetricReader implements MetricReader, PrefixMetricReader {

	private final CounterBuffers counters;

	private final GaugeBuffers gauges;

	private final Predicate<String> all = Pattern.compile(".*").asPredicate();

	public BufferMetricReader(CounterBuffers counters, GaugeBuffers gauges) {
		this.counters = counters;
		this.gauges = gauges;
	}

	@Override
	public Metric<?> findOne(final String name) {
		LongBuffer buffer = this.counters.find(name);
		if (buffer != null) {
			return new Metric<Long>(name, buffer.getValue(), new Date(
					buffer.getTimestamp()));
		}
		DoubleBuffer doubleValue = this.gauges.find(name);
		if (doubleValue != null) {
			return new Metric<Double>(name, doubleValue.getValue(), new Date(
					doubleValue.getTimestamp()));
		}
		return null;
	}

	@Override
	public Iterable<Metric<?>> findAll() {
		return findAll(this.all);
	}

	@Override
	public Iterable<Metric<?>> findAll(String prefix) {
		return findAll(Pattern.compile(prefix + ".*").asPredicate());
	}

	@Override
	public long count() {
		return this.counters.count() + this.gauges.count();
	}

	private Iterable<Metric<?>> findAll(Predicate<String> predicate) {
		final List<Metric<?>> metrics = new ArrayList<Metric<?>>();
		this.counters.forEach(predicate, new BiConsumer<String, LongBuffer>() {

			@Override
			public void accept(String name, LongBuffer value) {
				metrics.add(new Metric<Long>(name, value.getValue(), new Date(value
						.getTimestamp())));
			}

		});
		this.gauges.forEach(predicate, new BiConsumer<String, DoubleBuffer>() {

			@Override
			public void accept(String name, DoubleBuffer value) {
				metrics.add(new Metric<Double>(name, value.getValue(), new Date(value
						.getTimestamp())));
			}

		});
		return metrics;
	}

}

<code block>


package org.springframework.boot.actuate.metrics.buffer;

import java.util.concurrent.ConcurrentHashMap;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;

import org.springframework.lang.UsesJava8;


@UsesJava8
public class GaugeBuffers {

	private final ConcurrentHashMap<String, DoubleBuffer> metrics = new ConcurrentHashMap<String, DoubleBuffer>();

	public void forEach(final Predicate<String> predicate,
			final BiConsumer<String, DoubleBuffer> consumer) {
		this.metrics.forEach(new BiConsumer<String, DoubleBuffer>() {
			@Override
			public void accept(String name, DoubleBuffer value) {
				if (predicate.test(name)) {
					consumer.accept(name, value);
				}
			}
		});
	}

	public DoubleBuffer find(final String name) {
		return this.metrics.get(name);
	}

	public void get(final String name, final Consumer<DoubleBuffer> consumer) {
		acceptInternal(name, consumer);
	}

	public void set(final String name, final double value) {
		write(name, value);
	}

	public int count() {
		return this.metrics.size();
	}

	private void write(final String name, final double value) {
		acceptInternal(name, new Consumer<DoubleBuffer>() {
			@Override
			public void accept(DoubleBuffer buffer) {
				buffer.setTimestamp(System.currentTimeMillis());
				buffer.setValue(value);
			}
		});
	}

	public void reset(String name) {
		this.metrics.remove(name, this.metrics.get(name));
	}

	private void acceptInternal(final String name, final Consumer<DoubleBuffer> consumer) {
		DoubleBuffer value;
		if (null == (value = this.metrics.get(name))) {
			value = this.metrics.computeIfAbsent(name,
					new Function<String, DoubleBuffer>() {
						@Override
						public DoubleBuffer apply(String tag) {
							return new DoubleBuffer(0L);
						}
					});
		}
		consumer.accept(value);
	}

}

<code block>


package org.springframework.boot.actuate.metrics.buffer;

import java.util.concurrent.ConcurrentHashMap;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;

import org.springframework.lang.UsesJava8;


@UsesJava8
public class CounterBuffers {

	private final ConcurrentHashMap<String, LongBuffer> metrics = new ConcurrentHashMap<String, LongBuffer>();

	public void forEach(final Predicate<String> predicate,
			final BiConsumer<String, LongBuffer> consumer) {
		this.metrics.forEach(new BiConsumer<String, LongBuffer>() {
			@Override
			public void accept(String name, LongBuffer value) {
				if (predicate.test(name)) {
					consumer.accept(name, value);
				}
			}
		});
	}

	public LongBuffer find(final String name) {
		return this.metrics.get(name);
	}

	public void get(final String name, final Consumer<LongBuffer> consumer) {
		read(name, consumer);
	}

	public void increment(final String name, final long delta) {
		write(name, new Consumer<LongBuffer>() {
			@Override
			public void accept(LongBuffer adder) {
				adder.add(delta);
			}
		});
	}

	public void reset(final String name) {
		write(name, new Consumer<LongBuffer>() {
			@Override
			public void accept(LongBuffer adder) {
				adder.reset();
			}
		});
	}

	public int count() {
		return this.metrics.size();
	}

	private void read(final String name, final Consumer<LongBuffer> consumer) {
		acceptInternal(name, consumer);
	}

	private void write(final String name, final Consumer<LongBuffer> consumer) {
		acceptInternal(name, new Consumer<LongBuffer>() {
			@Override
			public void accept(LongBuffer buffer) {
				buffer.setTimestamp(System.currentTimeMillis());
				consumer.accept(buffer);
			}
		});
	}

	private void acceptInternal(final String name, final Consumer<LongBuffer> consumer) {
		LongBuffer adder;
		if (null == (adder = this.metrics.get(name))) {
			adder = this.metrics.computeIfAbsent(name,
					new Function<String, LongBuffer>() {
						@Override
						public LongBuffer apply(String name) {
							return new LongBuffer(0L);
						}
					});
		}
		consumer.accept(adder);
	}

}
