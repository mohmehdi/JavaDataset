
package org.mockito;

import org.mockito.internal.matchers.CapturingMatcher;
import org.mockito.internal.progress.HandyReturnValues;

import java.util.List;


public class ArgumentCaptor<T> {
    
    HandyReturnValues handyReturnValues = new HandyReturnValues();

    private final CapturingMatcher<T> capturingMatcher = new CapturingMatcher<T>();
    private final Class<? extends T> clazz;


    @Deprecated
    public ArgumentCaptor() {
        this.clazz = null;
    }

    private ArgumentCaptor(Class<? extends T> clazz) {
        this.clazz = clazz;
    }


    public T capture() {
        Mockito.argThat(capturingMatcher);
        return handyReturnValues.returnFor(clazz);
    }


    public T getValue() {
        return this.capturingMatcher.getLastValue();
    }


    public List<T> getAllValues() {
        return this.capturingMatcher.getAllValues();
    }


    public static <U,S extends U> ArgumentCaptor<U> forClass(Class<S> clazz) {
        return new ArgumentCaptor<U>(clazz);
    }
}
<code block>


package org.mockito;

import org.mockito.internal.matchers.ArrayEquals;
import org.mockito.internal.matchers.CompareEqual;
import org.mockito.internal.matchers.EqualsWithDelta;
import org.mockito.internal.matchers.Find;
import org.mockito.internal.matchers.GreaterOrEqual;
import org.mockito.internal.matchers.GreaterThan;
import org.mockito.internal.matchers.LessOrEqual;
import org.mockito.internal.matchers.LessThan;
import org.mockito.internal.progress.HandyReturnValues;
import org.mockito.internal.progress.MockingProgress;
import org.mockito.internal.progress.ThreadSafeMockingProgress;


public class AdditionalMatchers {
    
    private static final MockingProgress MOCKING_PROGRESS = new ThreadSafeMockingProgress();


    public static <T extends Comparable<T>> T geq(Comparable<T> value) {
        return reportMatcher(new GreaterOrEqual<T>(value)).<T>returnNull();
    }


    public static byte geq(byte value) {
        return reportMatcher(new GreaterOrEqual<Byte>(value)).returnZero();
    }


    public static double geq(double value) {
        return reportMatcher(new GreaterOrEqual<Double>(value)).returnZero();
    }


    public static float geq(float value) {
        return reportMatcher(new GreaterOrEqual<Float>(value)).returnZero();
    }


    public static int geq(int value) {
        return reportMatcher(new GreaterOrEqual<Integer>(value)).returnZero();
    }


    public static long geq(long value) {
        return reportMatcher(new GreaterOrEqual<Long>(value)).returnZero();
    }


    public static short geq(short value) {
        return reportMatcher(new GreaterOrEqual<Short>(value)).returnZero();
    }


    public static <T extends Comparable<T>> T leq(Comparable<T> value) {
        return reportMatcher(new LessOrEqual<T>(value)).<T>returnNull();
    }


    public static byte leq(byte value) {
        return reportMatcher(new LessOrEqual<Byte>(value)).returnZero();
    }


    public static double leq(double value) {
        return reportMatcher(new LessOrEqual<Double>(value)).returnZero();
    }


    public static float leq(float value) {
        return reportMatcher(new LessOrEqual<Float>(value)).returnZero();
    }


    public static int leq(int value) {
        return reportMatcher(new LessOrEqual<Integer>(value)).returnZero();
    }


    public static long leq(long value) {
        return reportMatcher(new LessOrEqual<Long>(value)).returnZero();
    }


    public static short leq(short value) {
        return reportMatcher(new LessOrEqual<Short>(value)).returnZero();
    }


    public static <T extends Comparable<T>> T gt(Comparable<T> value) {
        return reportMatcher(new GreaterThan<T>(value)).<T>returnNull();
    }


    public static byte gt(byte value) {
        return reportMatcher(new GreaterThan<Byte>(value)).returnZero();
    }


    public static double gt(double value) {
        return reportMatcher(new GreaterThan<Double>(value)).returnZero();
    }


    public static float gt(float value) {
        return reportMatcher(new GreaterThan<Float>(value)).returnZero();
    }


    public static int gt(int value) {
        return reportMatcher(new GreaterThan<Integer>(value)).returnZero();
    }


    public static long gt(long value) {
        return reportMatcher(new GreaterThan<Long>(value)).returnZero();
    }


    public static short gt(short value) {
        return reportMatcher(new GreaterThan<Short>(value)).returnZero();
    }


    public static <T extends Comparable<T>> T lt(Comparable<T> value) {
        return reportMatcher(new LessThan<T>(value)).<T>returnNull();
    }


    public static byte lt(byte value) {
        return reportMatcher(new LessThan<Byte>(value)).returnZero();
    }


    public static double lt(double value) {
        return reportMatcher(new LessThan<Double>(value)).returnZero();
    }


    public static float lt(float value) {
        return reportMatcher(new LessThan<Float>(value)).returnZero();
    }


    public static int lt(int value) {
        return reportMatcher(new LessThan<Integer>(value)).returnZero();
    }


    public static long lt(long value) {
        return reportMatcher(new LessThan<Long>(value)).returnZero();
    }


    public static short lt(short value) {
        return reportMatcher(new LessThan<Short>(value)).returnZero();
    }


    public static <T extends Comparable<T>> T cmpEq(Comparable<T> value) {
        return reportMatcher(new CompareEqual<T>(value)).<T>returnNull();
    }


    public static String find(String regex) {
        return reportMatcher(new Find(regex)).<String>returnNull();
    }


    public static <T> T[] aryEq(T[] value) {
        return reportMatcher(new ArrayEquals(value)).returnNull();
    }


    public static short[] aryEq(short[] value) {
        return reportMatcher(new ArrayEquals(value)).returnNull();
    }


    public static long[] aryEq(long[] value) {
        return reportMatcher(new ArrayEquals(value)).returnNull();
    }


    public static int[] aryEq(int[] value) {
        return reportMatcher(new ArrayEquals(value)).returnNull();       
    }


    public static float[] aryEq(float[] value) {
        return reportMatcher(new ArrayEquals(value)).returnNull();
    }


    public static double[] aryEq(double[] value) {
        return reportMatcher(new ArrayEquals(value)).returnNull();
    }


    public static char[] aryEq(char[] value) {
        return reportMatcher(new ArrayEquals(value)).returnNull();
    }


    public static byte[] aryEq(byte[] value) {
        return reportMatcher(new ArrayEquals(value)).returnNull();
    }


    public static boolean[] aryEq(boolean[] value) {
        return reportMatcher(new ArrayEquals(value)).returnNull();
    }


    public static boolean and(boolean first, boolean second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().returnFalse();
    }


    public static byte and(byte first, byte second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().returnZero();
    }


    public static char and(char first, char second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().returnChar();
    }


    public static double and(double first, double second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().returnZero();
    }


    public static float and(float first, float second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().returnZero();
    }


    public static int and(int first, int second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().returnZero();
    }


    public static long and(long first, long second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().returnZero();
    }


    public static short and(short first, short second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().returnZero();
    }


    public static <T> T and(T first, T second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().<T>returnNull();
    }


    public static boolean or(boolean first, boolean second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().returnFalse();
    }


    public static <T> T or(T first, T second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().<T>returnNull();
    }


    public static short or(short first, short second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().returnZero();
    }


    public static long or(long first, long second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().returnZero();
    }


    public static int or(int first, int second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().returnZero();
    }


    public static float or(float first, float second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().returnZero();
    }


    public static double or(double first, double second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().returnZero();
    }


    public static char or(char first, char second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().returnChar();
    }


    public static byte or(byte first, byte second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().returnZero();
    }


    public static <T> T not(T first) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().<T>returnNull();
    }


    public static short not(short first) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().returnZero();
    }


    public static int not(int first) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().returnZero();
    }


    public static long not(long first) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().returnZero();
    }


    public static float not(float first) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().returnZero();
    }


    public static double not(double first) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().returnZero();
    }


    public static char not(char first) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().returnChar();
    }


    public static boolean not(boolean first) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().returnFalse();
    }


    public static byte not(byte first) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().returnZero();
    }


    public static double eq(double value, double delta) {
        return reportMatcher(new EqualsWithDelta(value, delta)).returnZero();
    }
    

    public static float eq(float value, float delta) {
        return reportMatcher(new EqualsWithDelta(value, delta)).returnZero();
    }
    
    private static HandyReturnValues reportMatcher(ArgumentMatcher<?> matcher) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportMatcher(matcher);
    }
}
<code block>


package org.mockito;

import org.hamcrest.BaseMatcher;
import org.hamcrest.Description;
import org.hamcrest.Matcher;
import org.mockito.internal.util.Decamelizer;


public abstract class ArgumentMatcher<T> extends BaseMatcher<T> {

    private static final long serialVersionUID = -2145234737829370369L;


    public abstract boolean matches(Object argument);


    public void describeTo(Description description) {
        String className = getClass().getSimpleName();
        description.appendText(Decamelizer.decamelizeMatcher(className));
    }
}
<code block>

package org.mockito;

import org.hamcrest.Matcher;
import org.mockito.internal.matchers.*;
import org.mockito.internal.matchers.apachecommons.ReflectionEquals;
import org.mockito.internal.progress.HandyReturnValues;
import org.mockito.internal.progress.MockingProgress;
import org.mockito.internal.progress.ThreadSafeMockingProgress;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;


@SuppressWarnings("unchecked")
public class Matchers {
    
    private static final MockingProgress MOCKING_PROGRESS = new ThreadSafeMockingProgress();


    public static boolean anyBoolean() {
        return reportMatcher(new InstanceOf(Boolean.class)).returnFalse();
    }


    public static byte anyByte() {
        return reportMatcher(new InstanceOf(Byte.class)).returnZero();
    }


    public static char anyChar() {
        return reportMatcher(new InstanceOf(Character.class)).returnChar();
    }


    public static int anyInt() {
        return reportMatcher(new InstanceOf(Integer.class)).returnZero();
    }


    public static long anyLong() {
        return reportMatcher(new InstanceOf(Long.class)).returnZero();
    }


    public static float anyFloat() {
        return reportMatcher(new InstanceOf(Float.class)).returnZero();
    }


    public static double anyDouble() {
        return reportMatcher(new InstanceOf(Double.class)).returnZero();
    }


    public static short anyShort() {
        return reportMatcher(new InstanceOf(Short.class)).returnZero();
    }


    public static <T> T anyObject() {
        return (T) reportMatcher(Any.ANY).returnNull();
    }


    public static <T> T anyVararg() {
        return (T) reportMatcher(AnyVararg.ANY_VARARG).returnNull();
    }
    

    public static <T> T any(Class<T> clazz) {
        return (T) reportMatcher(Any.ANY).returnFor(clazz);
    }
    

    public static <T> T any() {
        return anyObject();
    }


    public static String anyString() {
        return reportMatcher(new InstanceOf(String.class)).returnString();
    }
    

    public static List anyList() {
        return reportMatcher(new InstanceOf(List.class)).returnList();
    }
    

    public static <T> List<T> anyListOf(Class<T> clazz) {
        return anyList();
    }
    

    public static Set anySet() {
        return reportMatcher(new InstanceOf(Set.class)).returnSet();
    }
    

    public static <T> Set<T> anySetOf(Class<T> clazz) {
        return anySet();
    }


    public static Map anyMap() {
        return reportMatcher(new InstanceOf(Map.class)).returnMap();
    }


    public static <K, V>  Map<K, V> anyMapOf(Class<K> keyClazz, Class<V> valueClazz) {
        return anyMap();
    }
    

    public static Collection anyCollection() {
        return reportMatcher(new InstanceOf(Collection.class)).returnList();
    }    
    

    public static <T> Collection<T> anyCollectionOf(Class<T> clazz) {
        return anyCollection();
    }    


    public static <T> T isA(Class<T> clazz) {
        return reportMatcher(new InstanceOf(clazz)).<T>returnFor(clazz);
    }


    public static boolean eq(boolean value) {
        return reportMatcher(new Equals(value)).returnFalse();
    }


    public static byte eq(byte value) {
        return reportMatcher(new Equals(value)).returnZero();
    }


    public static char eq(char value) {
        return reportMatcher(new Equals(value)).returnChar();
    }


    public static double eq(double value) {
        return reportMatcher(new Equals(value)).returnZero();
    }


    public static float eq(float value) {
        return reportMatcher(new Equals(value)).returnZero();
    }
    

    public static int eq(int value) {
        return reportMatcher(new Equals(value)).returnZero();
    }


    public static long eq(long value) {
        return reportMatcher(new Equals(value)).returnZero();
    }


    public static short eq(short value) {
        return reportMatcher(new Equals(value)).returnZero();
    }


    public static <T> T eq(T value) {
        return (T) reportMatcher(new Equals(value)).<T>returnFor(value);
    }


    public static <T> T refEq(T value, String... excludeFields) {
        return reportMatcher(new ReflectionEquals(value, excludeFields)).<T>returnNull();
    }
    

    public static <T> T same(T value) {
        return (T) reportMatcher(new Same(value)).<T>returnFor(value);
    }


    public static Object isNull() {
        return reportMatcher(Null.NULL).returnNull();
    }


    public static <T> T isNull(Class<T> clazz) {
        return (T) reportMatcher(Null.NULL).returnNull();
    }


    public static Object notNull() {
        return reportMatcher(NotNull.NOT_NULL).returnNull();
    }


    public static <T> T notNull(Class<T> clazz) {
        return (T) reportMatcher(NotNull.NOT_NULL).returnNull();
    }
    

    public static Object isNotNull() {
        return notNull();
    }


    public static <T> T isNotNull(Class<T> clazz) {
        return notNull(clazz);
    }


    public static String contains(String substring) {
        return reportMatcher(new Contains(substring)).returnString();
    }


    public static String matches(String regex) {
        return reportMatcher(new Matches(regex)).returnString();
    }


    public static String endsWith(String suffix) {
        return reportMatcher(new EndsWith(suffix)).returnString();
    }


    public static String startsWith(String prefix) {
        return reportMatcher(new StartsWith(prefix)).returnString();
    }


    public static <T> T argThat(Matcher<T> matcher) {
        return reportMatcher(matcher).<T>returnNull();
    }
    

    public static char charThat(Matcher<Character> matcher) {
        return reportMatcher(matcher).returnChar();
    }
    

    public static boolean booleanThat(Matcher<Boolean> matcher) {
        return reportMatcher(matcher).returnFalse();
    }
    

    public static byte byteThat(Matcher<Byte> matcher) {
        return reportMatcher(matcher).returnZero();
    }
    

    public static short shortThat(Matcher<Short> matcher) {
        return reportMatcher(matcher).returnZero();
    }
    

    public static int intThat(Matcher<Integer> matcher) {
        return reportMatcher(matcher).returnZero();
    }


    public static long longThat(Matcher<Long> matcher) {
        return reportMatcher(matcher).returnZero();
    }
    

    public static float floatThat(Matcher<Float> matcher) {
        return reportMatcher(matcher).returnZero();
    }
    

    public static double doubleThat(Matcher<Double> matcher) {
        return reportMatcher(matcher).returnZero();
    }

    private static HandyReturnValues reportMatcher(Matcher<?> matcher) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportMatcher(matcher);
    }
}

<code block>

package org.mockito.internal.verification.argumentmatching;

import java.util.LinkedList;
import java.util.List;

import org.hamcrest.Matcher;
import org.mockito.internal.matchers.ContainsTypedDescription;
import org.mockito.internal.util.text.HamcrestPrinter;

@SuppressWarnings("unchecked")
public class ArgumentMatchingTool {


    public Integer[] getSuspiciouslyNotMatchingArgsIndexes(List<Matcher> matchers, Object[] arguments) {
        if (matchers.size() != arguments.length) {
            return new Integer[0];
        }
        
        List<Integer> suspicious = new LinkedList<Integer>();
        int i = 0;
        for (Matcher m : matchers) {
            if (m instanceof ContainsTypedDescription
                    && !safelyMatches(m, arguments[i]) 
                    && toStringEquals(m, arguments[i])
                    && !((ContainsTypedDescription) m).typeMatches(arguments[i])) {
                suspicious.add(i);
            }
            i++;
        }
        return suspicious.toArray(new Integer[0]);
    }

    private boolean safelyMatches(Matcher m, Object arg) {
        try {
            return m.matches(arg);
        } catch (Throwable t) {
            return false;
        }
    }

    private boolean toStringEquals(Matcher m, Object arg) {
        return HamcrestPrinter.print(m).equals(arg == null? "null" : arg.toString());
    }
}

<code block>
package org.mockito.internal.util.text;

import java.lang.reflect.Array;
import java.util.Iterator;


class ArrayIterator implements Iterator<Object> {

    private final Object array;
    private int currentIndex = 0;

    public ArrayIterator(Object array) {
        if (array == null) {

            throw new IllegalArgumentException("Expected array instance but got null");
        }
        if (!array.getClass().isArray()) {
            throw new IllegalArgumentException("Expected array but got object of type: "
                    + array.getClass() + ", the object: " + array.toString());
        }
        this.array = array;
    }

    public boolean hasNext() {
        return currentIndex < Array.getLength(array);
    }

    public Object next() {
        return Array.get(array, currentIndex++);
    }

    public void remove() {
        throw new UnsupportedOperationException("cannot remove items from an array");
    }
}

<code block>
package org.mockito.internal.util.text;

import org.hamcrest.SelfDescribing;
import org.hamcrest.StringDescription;


public class HamcrestPrinter {

    public static String print(SelfDescribing object) {
        return StringDescription.toString(object);
    }
}

<code block>
package org.mockito.internal.util.text;

import org.hamcrest.SelfDescribing;

import java.util.Iterator;

import static java.lang.String.valueOf;


public class ValuePrinter {

    private final StringBuilder content = new StringBuilder();

    public String toString() {
        return content.toString();
    }

    public ValuePrinter appendText(String text) {
        append(text);
        return this;
    }
    
    public ValuePrinter appendValue(Object value) {
        if (value == null) {
            append("null");
        } else if (value instanceof String) {
            toJavaSyntax((String) value);
        } else if (value instanceof Character) {
            append('"');
            toJavaSyntax((Character) value);
            append('"');
        } else if (value instanceof Short) {
            append('<');
            append(descriptionOf(value));
            append("s>");
        } else if (value instanceof Long) {
            append('<');
            append(descriptionOf(value));
            append("L>");
        } else if (value instanceof Float) {
            append('<');
            append(descriptionOf(value));
            append("F>");
        } else if (value.getClass().isArray()) {
            appendList("[", ", ", "]", new org.mockito.internal.util.text.ArrayIterator(value));
        } else if (value instanceof SelfDescribing) {
            append(HamcrestPrinter.print((SelfDescribing) value));
        } else {
            append('<');
            append(descriptionOf(value));
            append('>');
        }
        return this;
    }

    private String descriptionOf(Object value) {
        try {
            return valueOf(value);
        }
        catch (Exception e) {
            return value.getClass().getName() + "@" + Integer.toHexString(value.hashCode());
        }
    }

    public ValuePrinter appendList(String start, String separator, String end, Iterator i) {
        boolean separate = false;
        
        append(start);
        while (i.hasNext()) {
            if (separate) append(separator);
            appendValue(i.next());
            separate = true;
        }
        append(end);
        
        return this;
    }


    protected void append(String str) {
        for (int i = 0; i < str.length(); i++) {
            append(str.charAt(i));
        }
    }
    

    protected void append(char c) {
        content.append(c);
    }

    private void toJavaSyntax(String unformatted) {
        append('"');
        for (int i = 0; i < unformatted.length(); i++) {
            toJavaSyntax(unformatted.charAt(i));
        }
        append('"');
    }

    private void toJavaSyntax(char ch) {
        switch (ch) {
            case '"':
                append("\\\"");
                break;
            case '\n':
                append("\\n");
                break;
            case '\r':
                append("\\r");
                break;
            case '\t':
                append("\\t");
                break;
            default:
                append(ch);
        }
    }

}

<code block>

package org.mockito.internal.matchers;

import java.io.Serializable;

import org.hamcrest.Matcher;
import org.mockito.ArgumentMatcher;

@SuppressWarnings("unchecked")
public class AnyVararg extends ArgumentMatcher implements VarargMatcher, Serializable {

    private static final long serialVersionUID = 1700721373094731555L;
    public static final Matcher ANY_VARARG = new AnyVararg();

    public boolean matches(Object arg) {
        return true;
    }
}
<code block>


package org.mockito.internal.matchers;

import java.io.Serializable;

import org.hamcrest.Description;
import org.mockito.ArgumentMatcher;

@SuppressWarnings("unchecked")
public class Any extends ArgumentMatcher implements Serializable {

    private static final long serialVersionUID = -4062420125651019029L;
    public static final Any ANY = new Any();
    
    private Any() {}
    
    public boolean matches(Object actual) {
        return true;
    }

    public void describeTo(Description description) {
        description.appendText("<any>");
    }
}

<code block>


package org.mockito.internal.matchers;

import java.io.Serializable;

public class GreaterOrEqual<T extends Comparable<T>> extends CompareTo<T> implements Serializable {

    private static final long serialVersionUID = 87695769061286092L;

    public GreaterOrEqual(Comparable<T> value) {
        super(value);
    }

    @Override
    protected String getName() {
        return "geq";
    }

    @Override
    protected boolean matchResult(int result) {
        return result >= 0;
    }
}

<code block>


package org.mockito.internal.matchers;

import org.hamcrest.Description;
import org.mockito.ArgumentMatcher;

import java.io.Serializable;

public class Equals extends ArgumentMatcher<Object> implements ContainsTypedDescription, Serializable {

    private static final long serialVersionUID = -3395637450058086891L;
    private final Object wanted;

    public Equals(Object wanted) {
        this.wanted = wanted;
    }

    public boolean matches(Object actual) {
        return Equality.areEqual(this.wanted, actual);
    }

    public void describeTo(Description description) {
        description.appendText(describe(wanted));
    }

    public String describe(Object object) {
        return quoting() + object + quoting();
    }

    private String quoting() {
        if (wanted instanceof String) {
            return "\"";
        } else if (wanted instanceof Character) {
            return "'";
        } else {
            return "";
        }
    }

    protected final Object getWanted() {
        return wanted;
    }

    @Override
    public boolean equals(Object o) {
        if (o == null || !this.getClass().equals(o.getClass())) {
            return false;
        }
        Equals other = (Equals) o;
        return this.wanted == null && other.wanted == null || this.wanted != null && this.wanted.equals(other.wanted);
    }

    @Override
    public int hashCode() {
        return 1;
    }

    public String getTypedDescription() {
        return "("+ wanted.getClass().getSimpleName() +") " + describe(wanted);
    }

    public boolean typeMatches(Object object) {
        return wanted != null && object != null && object.getClass() == wanted.getClass();
    }
}
<code block>


package org.mockito.internal.matchers;

import java.io.Serializable;
import java.util.Iterator;
import java.util.List;

import org.hamcrest.Description;
import org.hamcrest.Matcher;
import org.mockito.ArgumentMatcher;

@SuppressWarnings("unchecked")
public class Or extends ArgumentMatcher implements Serializable {

    private static final long serialVersionUID = 5888739035212283087L;
    private final List<Matcher> matchers;

    public Or(List<Matcher> matchers) {
        this.matchers = matchers;
    }

    public boolean matches(Object actual) {
        for (Matcher matcher : matchers) {
            if (matcher.matches(actual)) {
                return true;
            }
        }
        return false;
    }

    public void describeTo(Description description) {
        description.appendText("or(");
        for (Iterator<Matcher> it = matchers.iterator(); it.hasNext();) {
            it.next().describeTo(description);
            if (it.hasNext()) {
                description.appendText(", ");
            }
        }
        description.appendText(")");
    }
}

<code block>


package org.mockito.internal.matchers;

import java.lang.reflect.Array;
import java.util.Arrays;

import org.hamcrest.Description;

public class ArrayEquals extends Equals {

    private static final long serialVersionUID = -7167812844261087583L;

    public ArrayEquals(Object wanted) {
        super(wanted);
    }

    public boolean matches(Object actual) {
        Object wanted = getWanted();
        if (wanted == null || actual == null) {
            return super.matches(actual);
        } else if (wanted instanceof boolean[] && actual instanceof boolean[]) {
            return Arrays.equals((boolean[]) wanted, (boolean[]) actual);
        } else if (wanted instanceof byte[] && actual instanceof byte[]) {
            return Arrays.equals((byte[]) wanted, (byte[]) actual);
        } else if (wanted instanceof char[] && actual instanceof char[]) {
            return Arrays.equals((char[]) wanted, (char[]) actual);
        } else if (wanted instanceof double[] && actual instanceof double[]) {
            return Arrays.equals((double[]) wanted, (double[]) actual);
        } else if (wanted instanceof float[] && actual instanceof float[]) {
            return Arrays.equals((float[]) wanted, (float[]) actual);
        } else if (wanted instanceof int[] && actual instanceof int[]) {
            return Arrays.equals((int[]) wanted, (int[]) actual);
        } else if (wanted instanceof long[] && actual instanceof long[]) {
            return Arrays.equals((long[]) wanted, (long[]) actual);
        } else if (wanted instanceof short[] && actual instanceof short[]) {
            return Arrays.equals((short[]) wanted, (short[]) actual);
        } else if (wanted instanceof Object[] && actual instanceof Object[]) {
            return Arrays.equals((Object[]) wanted, (Object[]) actual);
        }
        return false;
    }

    public void describeTo(Description description) {
        if (getWanted() != null && getWanted().getClass().isArray()) {
            appendArray(createObjectArray(getWanted()), description);
        } else {
            super.describeTo(description);
        }
    }

    private void appendArray(Object[] array, Description description) {
        description.appendText("[");
        for (int i = 0; i < array.length; i++) {
            new Equals(array[i]).describeTo(description);
            if (i != array.length - 1) {
                description.appendText(", ");
            }
        }
        description.appendText("]");
    }

    public static Object[] createObjectArray(Object array) {
        if (array instanceof Object[]) {
            return (Object[]) array;
        }
        Object[] result = new Object[Array.getLength(array)];
        for (int i = 0; i < Array.getLength(array); i++) {
            result[i] = Array.get(array, i);
        }
        return result;
    }
}

<code block>


package org.mockito.internal.matchers;

import java.io.Serializable;

import org.hamcrest.Description;
import org.mockito.ArgumentMatcher;


public class NotNull extends ArgumentMatcher<Object> implements Serializable {

    private static final long serialVersionUID = 7278261081285153228L;
    public static final NotNull NOT_NULL = new NotNull();
    
    private NotNull() {
        
    }
    
    public boolean matches(Object actual) {
        return actual != null;
    }

    public void describeTo(Description description) {
        description.appendText("notNull()");
    }
}

<code block>


package org.mockito.internal.matchers;

import org.hamcrest.Description;
import org.mockito.ArgumentMatcher;


public abstract class CompareTo<T extends Comparable<T>> extends ArgumentMatcher<T> {
    private final Comparable<T> wanted;

    public CompareTo(Comparable<T> value) {
        this.wanted = value;
    }

    @SuppressWarnings("unchecked")
    public boolean matches(Object actual) {
        
        if(!(actual instanceof Comparable)) {
            return false;
        }
        
        return matchResult(((Comparable) actual).compareTo(wanted));
    }

    public void describeTo(Description description) {
        description.appendText(getName() + "(" + wanted + ")");
    }
    
    protected abstract String getName();
    
    protected abstract boolean matchResult(int result);
}

<code block>


package org.mockito.internal.matchers;

import java.io.Serializable;

public class GreaterThan<T extends Comparable<T>> extends CompareTo<T> implements Serializable {

    private static final long serialVersionUID = 7446529803235604408L;

    public GreaterThan(Comparable<T> value) {
        super(value);
    }

    @Override
    protected String getName() {
        return "gt";
    }

    @Override
    protected boolean matchResult(int result) {
        return result > 0;
    }    
}

<code block>


package org.mockito.internal.matchers;

import java.io.Serializable;

import org.hamcrest.Description;
import org.mockito.ArgumentMatcher;


public class StartsWith extends ArgumentMatcher<String> implements Serializable {

    private static final long serialVersionUID = -5978092285707998431L;
    private final String prefix;

    public StartsWith(String prefix) {
        this.prefix = prefix;
    }

    public boolean matches(Object actual) {
        return actual != null && ((String) actual).startsWith(prefix);
    }

    public void describeTo(Description description) {
        description.appendText("startsWith(\"" + prefix + "\")");
    }
}

<code block>


package org.mockito.internal.matchers;

import java.io.Serializable;

import org.hamcrest.Description;
import org.mockito.ArgumentMatcher;


public class Null extends ArgumentMatcher<Object> implements Serializable {

    private static final long serialVersionUID = 2823082637424390314L;
    public static final Null NULL = new Null();

    private Null() {
    }

    public boolean matches(Object actual) {
        return actual == null;
    }

    public void describeTo(Description description) {
        description.appendText("isNull()");
    }
}

<code block>

package org.mockito.internal.matchers;

import java.io.Serializable;

public interface VarargMatcher extends Serializable {
}

<code block>

package org.mockito.internal.matchers;

import java.io.Serializable;

import org.hamcrest.Matcher;

@SuppressWarnings("unchecked")
public interface MatcherDecorator extends Serializable {
    Matcher getActualMatcher();
}

<code block>


package org.mockito.internal.matchers;

import java.io.Serializable;

public class LessThan<T extends Comparable<T>> extends CompareTo<T> implements Serializable {

    private static final long serialVersionUID = -133860804462310942L;

    public LessThan(Comparable<T> value) {
        super(value);
    }

    @Override
    protected String getName() {
        return "lt";
    }

    @Override
    protected boolean matchResult(int result) {
        return result < 0;
    }
}

<code block>

package org.mockito.internal.matchers;

import org.hamcrest.Description;
import org.mockito.ArgumentMatcher;
import org.mockito.exceptions.Reporter;

import java.io.Serializable;
import java.util.LinkedList;
import java.util.List;

@SuppressWarnings("unchecked")
public class CapturingMatcher<T> extends ArgumentMatcher<T> implements CapturesArguments, VarargMatcher, Serializable {
    
    private static final long serialVersionUID = 4274067078639307295L;
    private final LinkedList<Object> arguments = new LinkedList<Object>();


    public boolean matches(Object argument) {
        return true;
    }    


    public void describeTo(Description description) {
        description.appendText("<Capturing argument>");
    }

    public T getLastValue() {
        if (arguments.isEmpty()) {
            new Reporter().noArgumentValueWasCaptured();
            return null;
        } else {
            return (T) arguments.getLast();
        }
    }

    public List<T> getAllValues() {
        return (List) arguments;
    }

    public void captureFrom(Object argument) {
        this.arguments.add(argument);
    }
}
<code block>


package org.mockito.internal.matchers;

import java.io.Serializable;

import org.hamcrest.Description;
import org.mockito.ArgumentMatcher;


public class EndsWith extends ArgumentMatcher<String> implements Serializable {

    private static final long serialVersionUID = 8556443228350129421L;
    private final String suffix;

    public EndsWith(String suffix) {
        this.suffix = suffix;
    }

    public boolean matches(Object actual) {
        return actual != null && ((String) actual).endsWith(suffix);
    }

    public void describeTo(Description description) {
        description.appendText("endsWith(\"" + suffix + "\")");
    }
}
<code block>


package org.mockito.internal.matchers;

import java.io.Serializable;

import org.hamcrest.Description;
import org.mockito.ArgumentMatcher;


public class Matches extends ArgumentMatcher<Object> implements Serializable {

    private static final long serialVersionUID = 8787704593379472029L;
    private final String regex;

    public Matches(String regex) {
        this.regex = regex;
    }

    public boolean matches(Object actual) {
        return (actual instanceof String) && ((String) actual).matches(regex);
    }

    public void describeTo(Description description) {
        description.appendText("matches(\"" + regex.replaceAll("\\\\", "\\\\\\\\")
                + "\")");
    }
}

<code block>


package org.mockito.internal.matchers;

import java.io.Serializable;

import org.hamcrest.Description;
import org.mockito.ArgumentMatcher;


public class InstanceOf extends ArgumentMatcher<Object> implements Serializable {

    private static final long serialVersionUID = 517358915876138366L;
    private final Class<?> clazz;

    public InstanceOf(Class<?> clazz) {
        this.clazz = clazz;
    }

    public boolean matches(Object actual) {
        return (actual != null) && clazz.isAssignableFrom(actual.getClass());
    }

    public void describeTo(Description description) {
        description.appendText("isA(" + clazz.getName() + ")");
    }
}

<code block>

package org.mockito.internal.matchers;

import org.hamcrest.Description;
import org.hamcrest.Matcher;
import org.mockito.internal.debugging.LocationImpl;
import org.mockito.internal.util.text.HamcrestPrinter;
import org.mockito.invocation.Location;

import java.io.Serializable;

@SuppressWarnings("unchecked")
public class LocalizedMatcher implements Matcher, ContainsTypedDescription, CapturesArguments, MatcherDecorator, Serializable {

    private static final long serialVersionUID = 6748641229659825725L;
    private final Matcher actualMatcher;
    private final Location location;

    public LocalizedMatcher(Matcher actualMatcher) {
        this.actualMatcher = actualMatcher;
        this.location = new LocationImpl();
    }

    public void _dont_implement_Matcher___instead_extend_BaseMatcher_() {

    }

    public boolean matches(Object item) {
        return actualMatcher.matches(item);
    }

    public void describeTo(Description description) {
        actualMatcher.describeTo(description);
    }

    public Location getLocation() {
        return location;
    }
    
    @Override
    public String toString() {
        return "Localized: " + this.actualMatcher;
    }

    public String getTypedDescription() {
        if (actualMatcher instanceof ContainsTypedDescription) {
            return ((ContainsTypedDescription) actualMatcher).getTypedDescription();
        } else {
            return HamcrestPrinter.print(actualMatcher);
        }
    }

    public boolean typeMatches(Object object) {
        return actualMatcher instanceof ContainsTypedDescription
                && ((ContainsTypedDescription) actualMatcher).typeMatches(object);
    }

    public void captureFrom(Object argument) {
        if (actualMatcher instanceof CapturesArguments) {
            ((CapturesArguments) actualMatcher).captureFrom(argument);
        }
    }


    public Matcher getActualMatcher() {
        return actualMatcher;
    }
}
<code block>


package org.mockito.internal.matchers;

import org.hamcrest.Description;
import org.mockito.ArgumentMatcher;

import java.io.Serializable;


public class Same extends ArgumentMatcher<Object> implements Serializable {

    private static final long serialVersionUID = -1226959355938572597L;
    private final Object wanted;

    public Same(Object wanted) {
        this.wanted = wanted;
    }

    public boolean matches(Object actual) {
        return wanted == actual;
    }

    public void describeTo(Description description) {
        description.appendText("same(");
        appendQuoting(description);
        description.appendText("" + wanted);
        appendQuoting(description);
        description.appendText(")");
    }

    private void appendQuoting(Description description) {
        if (wanted instanceof String) {
            description.appendText("\"");
        } else if (wanted instanceof Character) {
            description.appendText("'");
        }
    }
}

<code block>


package org.mockito.internal.matchers;

import java.io.Serializable;

import org.hamcrest.Description;
import org.mockito.ArgumentMatcher;


public class Contains extends ArgumentMatcher<String> implements Serializable {

    private static final long serialVersionUID = -1909837398271763801L;
    private final String substring;

    public Contains(String substring) {
        this.substring = substring;
    }

    public boolean matches(Object actual) {
        return actual != null && ((String) actual).contains(substring);
    }

    public void describeTo(Description description) {
        description.appendText("contains(\"" + substring + "\")");
    }
}

<code block>

package org.mockito.internal.matchers;

import org.hamcrest.Description;
import org.hamcrest.Matcher;
import org.hamcrest.SelfDescribing;
import org.mockito.internal.reporting.PrintSettings;
import org.mockito.internal.util.text.ValuePrinter;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

@SuppressWarnings("unchecked")
public class MatchersPrinter {

    public String getArgumentsLine(List<Matcher> matchers, PrintSettings printSettings) {
        ValuePrinter printer = new ValuePrinter();
        printer.appendList("(", ", ", ");", applyPrintSettings(matchers, printSettings));
        return printer.toString();
    }

    public String getArgumentsBlock(List<Matcher> matchers, PrintSettings printSettings) {
        ValuePrinter printer = new ValuePrinter();
        printer.appendList("(\n    ", ",\n    ", "\n);", applyPrintSettings(matchers, printSettings));
        return printer.toString();
    }

    private Iterator applyPrintSettings(List<Matcher> matchers, PrintSettings printSettings) {
        List out = new LinkedList();
        int i = 0;
        for (final Matcher matcher : matchers) {
            if (matcher instanceof ContainsTypedDescription && printSettings.extraTypeInfoFor(i)) {
                SelfDescribing s = new SelfDescribing() {
                    public void describeTo(Description description) {
                        String d = ((ContainsTypedDescription) matcher).getTypedDescription();
                        description.appendText(d);
                    }
                };
                out.add(s);
            } else {
                out.add(matcher);
            }
            i++;
        }
        return out.iterator();
    }
}

<code block>


package org.mockito.internal.matchers;

import java.io.Serializable;

public class CompareEqual<T extends Comparable<T>> extends CompareTo<T> implements Serializable {

    private static final long serialVersionUID = 2998586260452920429L;

    public CompareEqual(Comparable<T> value) {
        super(value);
    }

    @Override
    protected String getName() {
        return "cmpEq";
    }

    @Override
    protected boolean matchResult(int result) {
        return result == 0;
    }
}

<code block>


package org.mockito.internal.matchers;

import java.io.Serializable;
import java.util.regex.Pattern;

import org.hamcrest.Description;
import org.mockito.ArgumentMatcher;

public class Find extends ArgumentMatcher<String> implements Serializable {

    private static final long serialVersionUID = 8895781429480404872L;
    private final String regex;

    public Find(String regex) {
        this.regex = regex;
    }

    public boolean matches(Object actual) {
        return actual != null && Pattern.compile(regex).matcher((String) actual).find();
    }

    public void describeTo(Description description) {
        description.appendText("find(\"" + regex.replaceAll("\\\\", "\\\\\\\\") + "\")");
    }
}
<code block>


package org.mockito.internal.matchers;

import org.hamcrest.Description;
import org.mockito.ArgumentMatcher;

import java.io.Serializable;


public class EqualsWithDelta extends ArgumentMatcher<Number> implements Serializable {
    private static final long serialVersionUID = 5066980489920383664L;

    private final Number wanted;

    private final Number delta;

    public EqualsWithDelta(Number value, Number delta) {
        this.wanted = value;
        this.delta = delta;
    }

    public boolean matches(Object actual) {
        Number actualNumber = (Number) actual;
        if (wanted == null ^ actual == null) {
            return false;
        }

        if (wanted == actual) {
            return true;
        }

        return wanted.doubleValue() - delta.doubleValue() <= actualNumber.doubleValue()
                && actualNumber.doubleValue() <= wanted.doubleValue()
                        + delta.doubleValue();
    }

    public void describeTo(Description description) {
        description.appendText("eq(" + wanted + ", " + delta + ")");
    }
}

<code block>


package org.mockito.internal.matchers;

import java.io.Serializable;
import java.util.Iterator;
import java.util.List;

import org.hamcrest.Description;
import org.hamcrest.Matcher;
import org.mockito.ArgumentMatcher;

@SuppressWarnings("unchecked")
public class And extends ArgumentMatcher implements Serializable {

    private static final long serialVersionUID = -4624719625691177501L;
    private final List<Matcher> matchers;

    public And(List<Matcher> matchers) {
        this.matchers = matchers;
    }

    public boolean matches(Object actual) {
        for (Matcher matcher : matchers) {
            if (!matcher.matches(actual)) {
                return false;
            }
        }
        return true;
    }

    public void describeTo(Description description) {
        description.appendText("and(");
        for (Iterator<Matcher> it = matchers.iterator(); it.hasNext();) {
            it.next().describeTo(description);
            if (it.hasNext()) {
                description.appendText(", ");
            }
        }
        description.appendText(")");
    }
}

<code block>


package org.mockito.internal.matchers;

import java.io.Serializable;

import org.hamcrest.Description;
import org.hamcrest.Matcher;
import org.mockito.ArgumentMatcher;

@SuppressWarnings("unchecked")
public class Not extends ArgumentMatcher implements Serializable {

    private static final long serialVersionUID = 4627373642333593264L;
    private final Matcher first;

    public Not(Matcher first) {
        this.first = first;
    }

    public boolean matches(Object actual) {
        return !first.matches(actual);
    }

    public void describeTo(Description description) {
        description.appendText("not(");
        first.describeTo(description);
        description.appendText(")");
    }
}
<code block>


package org.mockito.internal.matchers;

import java.io.Serializable;

public class LessOrEqual<T extends Comparable<T>> extends CompareTo<T> implements Serializable {

    private static final long serialVersionUID = -6648773374429103565L;

    public LessOrEqual(Comparable<T> value) {
        super(value);
    }

    @Override
    protected String getName() {
        return "leq";
    }

    @Override
    protected boolean matchResult(int result) {
        return result <= 0;
    }
}

<code block>
package org.mockito.internal.matchers;

import org.hamcrest.Description;
import org.mockito.ArgumentMatcher;
import org.mockito.exceptions.Reporter;

import java.io.Serializable;
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;


@SuppressWarnings("unchecked")
public class VarargCapturingMatcher<T> extends ArgumentMatcher<T> implements CapturesArguments, VarargMatcher, Serializable {
    private static final long serialVersionUID = 4057053345838026645L;
    private final LinkedList<List<T>> arguments = new LinkedList<List<T>>();

    public boolean matches(Object argument) {
        return true;
    }

    public void describeTo(Description description) {
        description.appendText("<Capturing variable argument>");
    }

    public List<T> getLastVarargs() {
        if (arguments.isEmpty()) {
            new Reporter().noArgumentValueWasCaptured();
            return null;
        } else {
            return arguments.getLast();
        }
    }

    public List<List<T>> getAllVarargs() {
        return arguments;
    }

    public void captureFrom(Object varArgArray) {
        List<T> vararg = unpackAsList(varArgArray);
        this.arguments.add(vararg);
    }

    private List<T> unpackAsList(Object varArgArray) {
        if (varArgArray instanceof Object[]) {
            return Arrays.asList((T[]) varArgArray);
        } else if (varArgArray.getClass().isArray()) {
            Object[] primitiveArray = new Object[Array.getLength(varArgArray)];
            for (int i = 0; i < primitiveArray.length; i++) {
                primitiveArray[i] = Array.get(varArgArray, i);
            }
            return Arrays.asList((T[]) primitiveArray);
        } else {
            return Collections.singletonList((T) varArgArray);
        }
    }
}

<code block>


package org.mockito.internal.matchers.apachecommons;

import java.io.Serializable;

import org.hamcrest.Description;
import org.mockito.ArgumentMatcher;

public class ReflectionEquals extends ArgumentMatcher<Object> implements Serializable {
    private static final long serialVersionUID = 2022780425116330014L;
    private final Object wanted;
    private final String[] excludeFields;

    public ReflectionEquals(Object wanted, String... excludeFields) {
        this.wanted = wanted;
        this.excludeFields = excludeFields;
    }

    public boolean matches(Object actual) {
        return EqualsBuilder.reflectionEquals(wanted, actual, excludeFields);
    }

    public void describeTo(Description description) {
        description.appendText("refEq(" + wanted + ")");
    }
}
<code block>

package org.mockito.internal.reporting;

import org.hamcrest.Matcher;
import org.mockito.internal.invocation.ArgumentsProcessor;
import org.mockito.internal.invocation.InvocationMatcher;
import org.mockito.internal.matchers.MatchersPrinter;
import org.mockito.internal.util.MockUtil;
import org.mockito.invocation.Invocation;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

public class PrintSettings {

    public static final int MAX_LINE_LENGTH = 45;
    private boolean multiline;
    private List<Integer> withTypeInfo = new LinkedList<Integer>();

    public void setMultiline(boolean multiline) {
        this.multiline = multiline;
    }

    public boolean isMultiline() {
        return multiline;
    }

    public static PrintSettings verboseMatchers(Integer ... indexesOfMatchers) {
        PrintSettings settings = new PrintSettings();
        settings.setMatchersToBeDescribedWithExtraTypeInfo(indexesOfMatchers);
        return settings;
    }

    public boolean extraTypeInfoFor(int argumentIndex) {
        return withTypeInfo.contains(argumentIndex);
    }

    public void setMatchersToBeDescribedWithExtraTypeInfo(Integer[] indexesOfMatchers) {
        this.withTypeInfo = Arrays.asList(indexesOfMatchers);
    }

    public String print(List<Matcher> matchers, Invocation invocation) {
        MatchersPrinter matchersPrinter = new MatchersPrinter();
        String qualifiedName = new MockUtil().getMockName(invocation.getMock()) + "." + invocation.getMethod().getName();
        String invocationString = qualifiedName + matchersPrinter.getArgumentsLine(matchers, this);
        if (isMultiline() || (!matchers.isEmpty() && invocationString.length() > MAX_LINE_LENGTH)) {
            return qualifiedName + matchersPrinter.getArgumentsBlock(matchers, this);
        } else {
            return invocationString;
        }
    }

    public String print(Invocation invocation) {
        return print(ArgumentsProcessor.argumentsToMatchers(invocation.getArguments()), invocation);
    }

    public String print(InvocationMatcher invocationMatcher) {
        return print(invocationMatcher.getMatchers(), invocationMatcher.getInvocation());
    }
}
<code block>

package org.mockito.internal.invocation;

import org.hamcrest.Matcher;
import org.mockito.internal.matchers.MatcherDecorator;
import org.mockito.internal.matchers.VarargMatcher;
import org.mockito.invocation.Invocation;

import java.util.List;

@SuppressWarnings("unchecked")
public class ArgumentsComparator {
    public boolean argumentsMatch(InvocationMatcher invocationMatcher, Invocation actual) {
        Object[] actualArgs = actual.getArguments();
        return argumentsMatch(invocationMatcher, actualArgs) || varArgsMatch(invocationMatcher, actual);
    }

    public boolean argumentsMatch(InvocationMatcher invocationMatcher, Object[] actualArgs) {
        if (actualArgs.length != invocationMatcher.getMatchers().size()) {
            return false;
        }
        for (int i = 0; i < actualArgs.length; i++) {
            if (!invocationMatcher.getMatchers().get(i).matches(actualArgs[i])) {
                return false;
            }
        }
        return true;
    }


    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {
        if (!actual.getMethod().isVarArgs()) {

            return false;
        }


        Object[] rawArgs = actual.getRawArguments();
        List<Matcher> matchers = invocationMatcher.getMatchers();

        if (rawArgs.length != matchers.size()) {
            return false;
        }

        for (int i = 0; i < rawArgs.length; i++) {
            Matcher m = matchers.get(i);

            if (rawArgs[i] != null && rawArgs[i].getClass().isArray() && i == rawArgs.length-1) {
                Matcher actualMatcher;

                if (m instanceof MatcherDecorator) {
                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();
                } else {
                    actualMatcher = m;
                }

                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {
                    return false;
                }

            } else if (!m.matches(rawArgs[i])){
                return false;
            }
        }

        return true;
    }
}
<code block>


package org.mockito.internal.invocation;

import org.hamcrest.Matcher;
import org.mockito.internal.matchers.CapturesArguments;
import org.mockito.internal.matchers.MatcherDecorator;
import org.mockito.internal.reporting.PrintSettings;
import org.mockito.invocation.DescribedInvocation;
import org.mockito.invocation.Invocation;
import org.mockito.invocation.Location;

import java.io.Serializable;
import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.*;

@SuppressWarnings("unchecked")
public class InvocationMatcher implements DescribedInvocation, CapturesArgumentsFromInvocation, Serializable {

    private static final long serialVersionUID = -3047126096857467610L;
    private final Invocation invocation;
    private final List<Matcher> matchers;

    public InvocationMatcher(Invocation invocation, List<Matcher> matchers) {
        this.invocation = invocation;
        if (matchers.isEmpty()) {
            this.matchers = ArgumentsProcessor.argumentsToMatchers(invocation.getArguments());
        } else {
            this.matchers = matchers;
        }
    }

    public InvocationMatcher(Invocation invocation) {
        this(invocation, Collections.<Matcher>emptyList());
    }

    public Method getMethod() {
        return invocation.getMethod();
    }

    public Invocation getInvocation() {
        return this.invocation;
    }

    public List<Matcher> getMatchers() {
        return this.matchers;
    }

    public String toString() {
        return new PrintSettings().print(matchers, invocation);
    }

    public boolean matches(Invocation actual) {
        return invocation.getMock().equals(actual.getMock())
                && hasSameMethod(actual)
                && new ArgumentsComparator().argumentsMatch(this, actual);
    }

    private boolean safelyArgumentsMatch(Object[] actualArgs) {
        try {
            return new ArgumentsComparator().argumentsMatch(this, actualArgs);
        } catch (Throwable t) {
            return false;
        }
    }


    public boolean hasSimilarMethod(Invocation candidate) {
        String wantedMethodName = getMethod().getName();
        String currentMethodName = candidate.getMethod().getName();

        final boolean methodNameEquals = wantedMethodName.equals(currentMethodName);
        final boolean isUnverified = !candidate.isVerified();
        final boolean mockIsTheSame = getInvocation().getMock() == candidate.getMock();
        final boolean methodEquals = hasSameMethod(candidate);

        if (!methodNameEquals || !isUnverified || !mockIsTheSame) {
            return false;
        }

        final boolean overloadedButSameArgs = !methodEquals && safelyArgumentsMatch(candidate.getArguments());

        return !overloadedButSameArgs;
    }

    public boolean hasSameMethod(Invocation candidate) {


        Method m1 = invocation.getMethod();
        Method m2 = candidate.getMethod();

        if (m1.getName() != null && m1.getName().equals(m2.getName())) {

            Class[] params1 = m1.getParameterTypes();
            Class[] params2 = m2.getParameterTypes();
            if (params1.length == params2.length) {
                for (int i = 0; i < params1.length; i++) {
                    if (params1[i] != params2[i])
                        return false;
                }
                return true;
            }
        }
        return false;
    }

    public Location getLocation() {
        return invocation.getLocation();
    }

    public void captureArgumentsFrom(Invocation invocation) {
        captureRegularArguments(invocation);
        captureVarargsPart(invocation);
    }

    private void captureRegularArguments(Invocation invocation) {
        for (int position = 0; position < regularArgumentsSize(invocation); position++) {
            Matcher m = matchers.get(position);
            if (m instanceof CapturesArguments) {
                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));
            }
        }
    }

    private void captureVarargsPart(Invocation invocation) {
        if (!invocation.getMethod().isVarArgs()) {
            return;
        }
        int indexOfVararg = invocation.getRawArguments().length - 1;
        for (Matcher m : uniqueMatcherSet(indexOfVararg)) {
            if (m instanceof CapturesArguments) {
                Object rawArgument = invocation.getRawArguments()[indexOfVararg];
                for (int i = 0; i < Array.getLength(rawArgument); i++) {
                    ((CapturesArguments) m).captureFrom(Array.get(rawArgument, i));
                }
            }
        }
    }

    private int regularArgumentsSize(Invocation invocation) {
        return invocation.getMethod().isVarArgs() ?
                invocation.getRawArguments().length - 1 
                : matchers.size();
    }

    private Set<Matcher> uniqueMatcherSet(int indexOfVararg) {
        HashSet<Matcher> set = new HashSet<Matcher>();
        for (int position = indexOfVararg; position < matchers.size(); position++) {
            Matcher matcher = matchers.get(position);
            if (matcher instanceof MatcherDecorator) {
                set.add(((MatcherDecorator) matcher).getActualMatcher());
            } else {
                set.add(matcher);
            }
        }
        return set;
    }

    public static List<InvocationMatcher> createFrom(List<Invocation> invocations) {
        LinkedList<InvocationMatcher> out = new LinkedList<InvocationMatcher>();
        for (Invocation i : invocations) {
            out.add(new InvocationMatcher(i));
        }
        return out;
    }
}

<code block>


package org.mockito.internal.invocation;

import org.hamcrest.Matcher;
import org.mockito.exceptions.Reporter;
import org.mockito.internal.matchers.LocalizedMatcher;
import org.mockito.internal.progress.ArgumentMatcherStorage;
import org.mockito.invocation.Invocation;

import java.io.Serializable;
import java.util.List;

@SuppressWarnings("unchecked")
public class MatchersBinder implements Serializable {

    private static final long serialVersionUID = -311433939339443463L;

    public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {
        List<LocalizedMatcher> lastMatchers = argumentMatcherStorage.pullLocalizedMatchers();
        validateMatchers(invocation, lastMatchers);

        InvocationMatcher invocationWithMatchers = new InvocationMatcher(invocation, (List<Matcher>)(List) lastMatchers);
        return invocationWithMatchers;
    }

    private void validateMatchers(Invocation invocation, List<LocalizedMatcher> lastMatchers) {
        if (!lastMatchers.isEmpty()) {
            int recordedMatchersSize = lastMatchers.size();
            int expectedMatchersSize = invocation.getArguments().length;
            if (expectedMatchersSize != recordedMatchersSize) {
                new Reporter().invalidUseOfMatchers(expectedMatchersSize, lastMatchers);
            }
        }
    }
}
<code block>

package org.mockito.internal.invocation;

import org.hamcrest.Matcher;
import org.mockito.internal.matchers.ArrayEquals;
import org.mockito.internal.matchers.Equals;
import org.mockito.internal.util.collections.ArrayUtils;

import java.util.ArrayList;
import java.util.List;


public class ArgumentsProcessor {


    public static Object[] expandVarArgs(final boolean isVarArgs, final Object[] args) {
        if (!isVarArgs || new ArrayUtils().isEmpty(args) || args[args.length - 1] != null && !args[args.length - 1].getClass().isArray()) {
            return args == null ? new Object[0] : args;
        }

        final int nonVarArgsCount = args.length - 1;
        Object[] varArgs;
        if (args[nonVarArgsCount] == null) {

            varArgs = new Object[] { null };
        } else {
            varArgs = ArrayEquals.createObjectArray(args[nonVarArgsCount]);
        }
        final int varArgsCount = varArgs.length;
        Object[] newArgs = new Object[nonVarArgsCount + varArgsCount];
        System.arraycopy(args, 0, newArgs, 0, nonVarArgsCount);
        System.arraycopy(varArgs, 0, newArgs, nonVarArgsCount, varArgsCount);
        return newArgs;
    }

    public static List<Matcher> argumentsToMatchers(Object[] arguments) {
        List<Matcher> matchers = new ArrayList<Matcher>(arguments.length);
        for (Object arg : arguments) {
            if (arg != null && arg.getClass().isArray()) {
                matchers.add(new ArrayEquals(arg));
            } else {
                matchers.add(new Equals(arg));
            }
        }
        return matchers;
    }
}

<code block>


package org.mockito.internal.progress;

import org.hamcrest.Matcher;
import org.mockito.exceptions.Reporter;
import org.mockito.internal.matchers.And;
import org.mockito.internal.matchers.LocalizedMatcher;
import org.mockito.internal.matchers.Not;
import org.mockito.internal.matchers.Or;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Stack;

@SuppressWarnings("unchecked")
public class ArgumentMatcherStorageImpl implements ArgumentMatcherStorage {

    public static final int TWO_SUB_MATCHERS = 2;
    public static final int ONE_SUB_MATCHER = 1;
    private final Stack<LocalizedMatcher> matcherStack = new Stack<LocalizedMatcher>();
    

    public HandyReturnValues reportMatcher(Matcher matcher) {
        matcherStack.push(new LocalizedMatcher(matcher));
        return new HandyReturnValues();
    }


    public List<LocalizedMatcher> pullLocalizedMatchers() {
        if (matcherStack.isEmpty()) {
            return Collections.emptyList();
        }
        
        List<LocalizedMatcher> matchers = new ArrayList<LocalizedMatcher>(matcherStack);
        matcherStack.clear();
        return (List) matchers;
    }


    public HandyReturnValues reportAnd() {
        assertStateFor("And(?)", TWO_SUB_MATCHERS);
        And and = new And(popLastArgumentMatchers(TWO_SUB_MATCHERS));
        matcherStack.push(new LocalizedMatcher(and));
        return new HandyReturnValues();
    }


    public HandyReturnValues reportOr() {
        assertStateFor("Or(?)", TWO_SUB_MATCHERS);
        Or or = new Or(popLastArgumentMatchers(TWO_SUB_MATCHERS));
        matcherStack.push(new LocalizedMatcher(or));
        return new HandyReturnValues();
    }


    public HandyReturnValues reportNot() {
        assertStateFor("Not(?)", ONE_SUB_MATCHER);
        Not not = new Not(popLastArgumentMatchers(ONE_SUB_MATCHER).get(0));
        matcherStack.push(new LocalizedMatcher(not));
        return new HandyReturnValues();
    }

    private void assertStateFor(String additionalMatcherName, int subMatchersCount) {
        assertMatchersFoundFor(additionalMatcherName);
        assertIncorrectUseOfAdditionalMatchers(additionalMatcherName, subMatchersCount);
    }

    private List<Matcher> popLastArgumentMatchers(int count) {
        List<Matcher> result = new LinkedList<Matcher>();
        result.addAll(matcherStack.subList(matcherStack.size() - count, matcherStack.size()));
        for (int i = 0; i < count; i++) {
            matcherStack.pop();
        }
        return result;
    }

    private void assertMatchersFoundFor(String additionalMatcherName) {
        if (matcherStack.isEmpty()) {
            matcherStack.clear();
            new Reporter().reportNoSubMatchersFound(additionalMatcherName);
        }
    }

    private void assertIncorrectUseOfAdditionalMatchers(String additionalMatcherName, int count) {
        if(matcherStack.size() < count) {
            ArrayList<LocalizedMatcher> lastMatchers = new ArrayList<LocalizedMatcher>(matcherStack);
            matcherStack.clear();
            new Reporter().incorrectUseOfAdditionalMatchers(additionalMatcherName, count, lastMatchers);
        }
    }


    public void validateState() {
        if (!matcherStack.isEmpty()) {
            ArrayList lastMatchers = new ArrayList<LocalizedMatcher>(matcherStack);
            matcherStack.clear();
            new Reporter().misplacedArgumentMatcher(lastMatchers);
        }
    }


    public void reset() {
        matcherStack.clear();
    }
}
<code block>

package org.mockito.internal.progress;

import org.hamcrest.Matcher;
import org.mockito.internal.matchers.LocalizedMatcher;

import java.util.List;

@SuppressWarnings("unchecked")
public interface ArgumentMatcherStorage {

    HandyReturnValues reportMatcher(Matcher matcher);

    List<LocalizedMatcher> pullLocalizedMatchers();

    HandyReturnValues reportAnd();

    HandyReturnValues reportNot();

    HandyReturnValues reportOr();

    void validateState();

    void reset();

}
<code block>


package org.mockitoutil;

import junit.framework.Assert;
import org.hamcrest.Matcher;
import org.hamcrest.SelfDescribing;
import org.hamcrest.StringDescription;
import org.junit.After;
import org.junit.Before;
import org.mockito.MockitoAnnotations;
import org.mockito.StateMaster;
import org.mockito.internal.MockitoCore;
import org.mockito.internal.configuration.ConfigurationAccess;
import org.mockito.internal.invocation.InvocationImpl;
import org.mockito.internal.invocation.SerializableMethod;
import org.mockito.internal.invocation.realmethod.RealMethod;
import org.mockito.internal.matchers.MatchersPrinter;
import org.mockito.internal.util.MockUtil;
import org.mockito.internal.util.text.HamcrestPrinter;
import org.mockito.invocation.Invocation;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.util.Collection;

import static org.mockito.Mockito.mock;


@SuppressWarnings("unchecked")
public class TestBase extends Assert {

    @After
    public void cleanUpConfigInAnyCase() {
        ConfigurationAccess.getConfig().overrideCleansStackTrace(false);
        ConfigurationAccess.getConfig().overrideDefaultAnswer(null);
        StateMaster state = new StateMaster();


        state.validate();

        state.reset();
    }

    @Before
    public void init() {
        MockitoAnnotations.initMocks(this);
    }
    
    public static void makeStackTracesClean() {
        ConfigurationAccess.getConfig().overrideCleansStackTrace(true);
    }
    
    public void resetState() {
        new StateMaster().reset();
    }
    
    protected Invocation getLastInvocation() {
        return new MockitoCore().getLastInvocation();
    }


    protected static <T> void assertThat(T o, Assertor<T> a) {
        a.assertValue(o);
    }
    
    protected static <T> void assertThat(T actual, Matcher<T> m) {
        org.junit.Assert.assertThat(actual, m);
    }
    
    protected static <T> void assertThat(String message, T actual, Matcher<T> m) {
        org.junit.Assert.assertThat(message, actual, m);
    }
    
    public static <T> Assertor<String> endsWith(final String substring) {
        return new Assertor<String>() {
            public void assertValue(String value) {
                assertTrue("This substring: \n" + substring + 
                        "\nshould be at the end of:\n" + value
                        , value.endsWith(substring));
            }
        };
    }
    
    public static void assertNotEquals(Object expected, Object got) {
        assertFalse(expected.equals(got));
    }

    public static void assertContains(String sub, String string) {
        assertTrue("\n" +
                "This substring:[" +
                sub +
                "]\n" +
                "should be inside of:[" +
                string +
                "]\n"
                , string.contains(sub));
    }

    public static void assertContainsIgnoringCase(String sub, String string) {
        assertTrue("\n" +
                "This substring:" +
                sub +
                "\n" +
                "should be inside of:" +
                string +
                "\n"
                , containsIgnoringCase(string, sub));
    }

    private static boolean containsIgnoringCase(String string, String sub) {
        int subLength = sub.length();
        if (string.length() < subLength) {
            return false;
        }
        int i = 0;
        while(i+subLength <= string.length()) {
            boolean temp = string.substring(i, i+subLength).equalsIgnoreCase(sub);
            if (temp) {
                return true;
            }
            i++;
        }
        return false;
    }

    public static void assertNotContains(String sub, String string) {
        assertFalse("\n" +
                "This substring:" +
                sub +
                "\n" +
                "should NOT be inside of:" +
                string +
                "\n"
                , string.contains(sub));
    }
    
    protected static Invocation invocationOf(Class<?> type, String methodName, Object ... args) throws NoSuchMethodException {
        Class[] types = new Class[args.length];
        for (int i = 0; i < args.length; i++) {
            types[i] = args[i].getClass();
        }
        return new InvocationImpl(mock(type), new SerializableMethod(type.getMethod(methodName,
                types)), args, 1, null);
    }

    protected static Invocation invocationOf(Class<?> type, String methodName, RealMethod realMethod) throws NoSuchMethodException {
        return new InvocationImpl(new Object(), new SerializableMethod(type.getMethod(methodName,
                new Class[0])), new Object[0], 1, realMethod);
    }

    protected static String describe(SelfDescribing m) {
        return HamcrestPrinter.print(m);
    }

    protected boolean isMock(Object o) {
        return new MockUtil().isMock(o);
    }

    protected void assertContainsType(final Collection<?> list, final Class<?> clazz) {
        for (Object o : list) {
            if (clazz.isAssignableFrom(o.getClass())) {
                return;
            }
        }
        throw new AssertionError("Input list does not contain any element of type: '" + clazz + "'. " +
            "Inspected following elements: " + list);
    }

    protected String getStackTrace(Throwable e) {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        e.printStackTrace(new PrintStream(out));
        try {
            out.close();
        } catch (IOException ex) {}
        return out.toString();
    }
}

<code block>

package org.mockito.internal.verification.argumentmatching;

import java.util.Arrays;
import java.util.List;

import org.hamcrest.BaseMatcher;
import org.hamcrest.Description;
import org.hamcrest.Matcher;
import org.junit.Test;
import org.mockito.internal.matchers.Equals;
import org.mockitoutil.TestBase;

@SuppressWarnings({"unchecked","serial"})
public class ArgumentMatchingToolTest extends TestBase {

    private ArgumentMatchingTool tool = new ArgumentMatchingTool();

    @Test
    public void shouldNotFindAnySuspiciousMatchersWhenNumberOfArgumentsDoesntMatch() {

        List<Matcher> matchers = (List) Arrays.asList(new Equals(1));


        Integer[] suspicious = tool.getSuspiciouslyNotMatchingArgsIndexes(matchers, new Object[] {10, 20});
        

        assertEquals(0, suspicious.length);
    }

    @Test
    public void shouldNotFindAnySuspiciousMatchersWhenArgumentsMatch() {

        List<Matcher> matchers = (List) Arrays.asList(new Equals(10), new Equals(20));
        

        Integer[] suspicious = tool.getSuspiciouslyNotMatchingArgsIndexes(matchers, new Object[] {10, 20});
        

        assertEquals(0, suspicious.length);
    }
    
    @Test
    public void shouldFindSuspiciousMatchers() {

        Equals matcherInt20 = new Equals(20);
        Long longPretendingAnInt = new Long(20);
        

        List<Matcher> matchers = (List) Arrays.asList(new Equals(10), matcherInt20);
        Integer[] suspicious = tool.getSuspiciouslyNotMatchingArgsIndexes(matchers, new Object[] {10, longPretendingAnInt});
        

        assertEquals(1, suspicious.length);
        assertEquals(new Integer(1), suspicious[0]);
    }
    
    @Test
    public void shouldNotFindSuspiciousMatchersWhenTypesAreTheSame() {

        Equals matcherWithBadDescription = new Equals(20) {
            public void describeTo(Description desc) {

                desc.appendText("10");
            }
        };
        Integer argument = 10;
        

        Integer[] suspicious = tool.getSuspiciouslyNotMatchingArgsIndexes((List) Arrays.asList(matcherWithBadDescription), new Object[] {argument});
        

        assertEquals(0, suspicious.length);
    }
    
    @Test
    public void shouldWorkFineWhenGivenArgIsNull() {

        Integer[] suspicious = tool.getSuspiciouslyNotMatchingArgsIndexes((List) Arrays.asList(new Equals(20)), new Object[] {null});
        

        assertEquals(0, suspicious.length);
    }
    
    @Test
    public void shouldUseMatchersSafely() {

        List<Matcher> matchers = (List) Arrays.asList(new BaseMatcher() {
            public boolean matches(Object item) {
                throw new ClassCastException("nasty matcher");
            }

            public void describeTo(Description description) {
            }});
        

        Integer[] suspicious = tool.getSuspiciouslyNotMatchingArgsIndexes(matchers, new Object[] {10});
        

        assertEquals(0, suspicious.length);
    }
}
<code block>

package org.mockito.internal.matchers;

import org.hamcrest.Matcher;
import org.junit.Test;
import org.mockitoutil.TestBase;

@SuppressWarnings("unchecked")
public class LocalizedMatcherTest extends TestBase {
    
    @Test
    public void shouldMatchTypesWhenActualMatcherHasCorrectType() throws Exception {

        ContainsTypedDescription equals10 = new Equals(10);
        LocalizedMatcher m = new LocalizedMatcher((Matcher) equals10);
        

        assertTrue(m.typeMatches(10));
        assertFalse(m.typeMatches(10L));
    }

    @Test
    public void shouldNotMatchTypesWhenActualMatcherDoesNotHaveCorrectType() throws Exception {

        LocalizedMatcher m = new LocalizedMatcher(Any.ANY);
        

        assertFalse(m.typeMatches(10));
    }
    
    @Test
    public void shouldDescribeWithTypeInfoWhenActualMatcherHasCorrectType() throws Exception {

        ContainsTypedDescription equals10 = new Equals(10);
        LocalizedMatcher m = new LocalizedMatcher((Matcher) equals10);
        

        assertEquals("(Integer) 10", m.getTypedDescription());
    }

    @Test
    public void shouldDescribeStringWithType() throws Exception {

        ContainsTypedDescription e = new Equals("x");
        LocalizedMatcher m = new LocalizedMatcher((Matcher) e);


        assertEquals("(String) \"x\"", m.getTypedDescription());
    }
    
    @Test
    public void shouldNotDescribeWithTypeInfoWhenActualMatcherDoesNotHaveCorrectType() throws Exception {

        LocalizedMatcher m = new LocalizedMatcher(Any.ANY);
        

        assertEquals(describe(m), m.getTypedDescription());
    }
    
    @Test
    public void shouldDelegateToCapturingMatcher() throws Exception {

        CapturingMatcher capturingMatcher = new CapturingMatcher();
        LocalizedMatcher m = new LocalizedMatcher(capturingMatcher);
        

        m.captureFrom("boo");
        

        assertEquals("boo", capturingMatcher.getLastValue());
    }
}
<code block>


package org.mockito.internal.matchers;

import org.junit.Test;
import org.mockitoutil.TestBase;

import java.math.BigDecimal;

public class ComparableMatchersTest extends TestBase {

    @Test
    public void testLessThan() {
        test(new LessThan<String>("b"), true, false, false, "lt");
    }

    @Test
    public void testGreaterThan() {
        test(new GreaterThan<String>("b"), false, true, false, "gt");
    }

    @Test
    public void testLessOrEqual() {
        test(new LessOrEqual<String>("b"), true, false, true, "leq");
    }

    @Test
    public void testGreaterOrEqual() {
        test(new GreaterOrEqual<String>("b"), false, true, true, "geq");
    }

    @Test
    public void testCompareEqual() {
        test(new CompareEqual<String>("b"), false, false, true, "cmpEq");


        CompareEqual<BigDecimal> cmpEq = new CompareEqual<BigDecimal>(new BigDecimal("5.00"));
        assertTrue(cmpEq.matches(new BigDecimal("5")));
    }

    private void test(CompareTo<String> compareTo, boolean lower, boolean higher,
            boolean equals, String name) {

        assertEquals(lower, compareTo.matches("a"));
        assertEquals(equals, compareTo.matches("b"));
        assertEquals(higher, compareTo.matches("c"));

        assertEquals(name + "(b)", describe(compareTo));
    }
}

<code block>


package org.mockito.internal.matchers;

import org.junit.Test;
import org.mockitoutil.TestBase;


public class EqualsTest extends TestBase {

    @Test
    public void shouldBeEqual() {
        assertEquals(new Equals(null), new Equals(null));
        assertEquals(new Equals(new Integer(2)), new Equals(new Integer(2)));
        assertFalse(new Equals(null).equals(null));
        assertFalse(new Equals(null).equals("Test"));
        assertEquals(1, new Equals(null).hashCode());
    }

    @Test
    public void shouldArraysBeEqual() {
        assertTrue(new Equals(new int[] {1, 2}).matches(new int[] {1, 2}));
        assertFalse(new Equals(new Object[] {"1"}).matches(new Object[] {"1.0"}));
    }
    
    @Test
    public void shouldDescribeWithExtraTypeInfo() throws Exception {
        String descStr = new Equals(100).getTypedDescription();
        
        assertEquals("(Integer) 100", descStr);
    }

    @Test
    public void shouldDescribeWithExtraTypeInfoOfLong() throws Exception {
        String descStr = new Equals(100L).getTypedDescription();
        
        assertEquals("(Long) 100", descStr);
    }

    @Test
    public void shouldDescribeWithTypeOfString() throws Exception {
        String descStr = new Equals("x").getTypedDescription();

        assertEquals("(String) \"x\"", descStr);
    }
    
    @Test
    public void shouldAppendQuotingForString() {
        String descStr = describe(new Equals("str"));
        
        assertEquals("\"str\"", descStr);
    }

    @Test
    public void shouldAppendQuotingForChar() {
        String descStr = describe(new Equals('s'));
        
        assertEquals("'s'", descStr);
    }
    
    @Test
    public void shouldDescribeUsingToString() {
        String descStr = describe(new Equals(100));
        
        assertEquals("100", descStr);
    }

    @Test
    public void shouldDescribeNull() {
        String descStr = describe(new Equals(null));
        
        assertEquals("null", descStr);
    }
    
    @Test
    public void shouldMatchTypes() throws Exception {

        ContainsTypedDescription equals = new Equals(10);
        

        assertTrue(equals.typeMatches(10));
        assertFalse(equals.typeMatches(10L));
    }
    
    @Test
    public void shouldMatchTypesSafelyWhenActualIsNull() throws Exception {

        ContainsTypedDescription equals = new Equals(null);
        

        assertFalse(equals.typeMatches(10));
    }

    @Test
    public void shouldMatchTypesSafelyWhenGivenIsNull() throws Exception {

        ContainsTypedDescription equals = new Equals(10);
        

        assertFalse(equals.typeMatches(null));
    }
}
<code block>

package org.mockito.internal.matchers;

import java.util.Arrays;
import java.util.List;

import org.junit.Test;
import org.mockito.internal.reporting.PrintSettings;
import org.mockitoutil.TestBase;

@SuppressWarnings("unchecked")
public class MatchersPrinterTest extends TestBase {

    MatchersPrinter printer = new MatchersPrinter();

    @Test
    public void shouldGetArgumentsLine() {
        String line = printer.getArgumentsLine((List) Arrays.asList(new Equals(1), new Equals(2)), new PrintSettings());
        assertEquals("(1, 2);", line);
    }

    @Test
    public void shouldGetArgumentsBlock() {
        String line = printer.getArgumentsBlock((List) Arrays.asList(new Equals(1), new Equals(2)), new PrintSettings());
        assertEquals("(\n    1,\n    2\n);", line);
    }

    @Test
    public void shouldDescribeTypeInfoOnlyMarkedMatchers() {

        String line = printer.getArgumentsLine((List) Arrays.asList(new Equals(1L), new Equals(2)), PrintSettings.verboseMatchers(1));

        assertEquals("(1, (Integer) 2);", line);
    }

    @Test
    public void shouldDescribeStringMatcher() {

        String line = printer.getArgumentsLine((List) Arrays.asList(new Equals(1L), new Equals("x")), PrintSettings.verboseMatchers(1));

        assertEquals("(1, (String) \"x\");", line);
    }

    @Test
    public void shouldGetVerboseArgumentsInBlock() {

        String line = printer.getArgumentsBlock((List) Arrays.asList(new Equals(1L), new Equals(2)), PrintSettings.verboseMatchers(0, 1));

        assertEquals("(\n    (Long) 1,\n    (Integer) 2\n);", line);
    }

    @Test
    public void shouldGetVerboseArgumentsEvenIfSomeMatchersAreNotVerbose() {

        String line = printer.getArgumentsLine((List) Arrays.asList(new Equals(1L), NotNull.NOT_NULL), PrintSettings.verboseMatchers(0));

        assertEquals("((Long) 1, notNull());", line);
    }
}
<code block>


package org.mockito.internal.matchers;

import java.util.ArrayList;
import java.util.List;

import org.hamcrest.Matcher;
import org.junit.Test;
import org.mockitoutil.TestBase;

@SuppressWarnings("unchecked")
public class MatchersToStringTest extends TestBase {

    @Test
    public void sameToStringWithString() {
        assertEquals("same(\"X\")", describe(new Same("X")));

    }

    @Test
    public void nullToString() {
        assertEquals("isNull()", describe(Null.NULL));
    }

    @Test
    public void notNullToString() {
        assertEquals("notNull()", describe(NotNull.NOT_NULL));
    }

    @Test
    public void anyToString() {
        assertEquals("<any>", describe(Any.ANY));
    }

    @Test
    public void sameToStringWithChar() {
        assertEquals("same('x')", describe(new Same('x')));
    }

    @Test
    public void sameToStringWithObject() {
        Object o = new Object() {
            @Override
            public String toString() {
                return "X";
            }
        };
        assertEquals("same(X)", describe(new Same(o)));
    }

    @Test
    public void equalsToStringWithString() {
        assertEquals("\"X\"", describe(new Equals("X")));

    }

    @Test
    public void equalsToStringWithChar() {
        assertEquals("'x'", describe(new Equals('x')));
    }

    @Test
    public void equalsToStringWithObject() {
        Object o = new Object() {
            @Override
            public String toString() {
                return "X";
            }
        };
        assertEquals("X", describe(new Equals(o)));
    }

    @Test
    public void orToString() {
        List<Matcher> matchers = new ArrayList<Matcher>();
        matchers.add(new Equals(1));
        matchers.add(new Equals(2));
        assertEquals("or(1, 2)", describe(new Or(matchers)));
    }

    @Test
    public void notToString() {
        assertEquals("not(1)", describe(new Not(new Equals(1))));
    }

    @Test
    public void andToString() {
        List<Matcher> matchers = new ArrayList<Matcher>();
        matchers.add(new Equals(1));
        matchers.add(new Equals(2));
        assertEquals("and(1, 2)", describe(new And(matchers)));
    }

    @Test
    public void startsWithToString() {
        assertEquals("startsWith(\"AB\")", describe(new StartsWith("AB")));
    }

    @Test
    public void endsWithToString() {
        assertEquals("endsWith(\"AB\")", describe(new EndsWith("AB")));
    }

    @Test
    public void containsToString() {
        assertEquals("contains(\"AB\")", describe(new Contains("AB")));
    }

    @Test
    public void findToString() {
        assertEquals("find(\"\\\\s+\")", describe(new Find("\\s+")));
    }

    @Test
    public void matchesToString() {
        assertEquals("matches(\"\\\\s+\")", describe(new Matches("\\s+")));
    }

}

<code block>


package org.mockito.internal.invocation;

import org.fest.assertions.Assertions;
import org.hamcrest.Matcher;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.internal.matchers.*;
import org.mockito.invocation.Invocation;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;

import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static java.util.Arrays.asList;

@SuppressWarnings("unchecked")
public class InvocationMatcherTest extends TestBase {

    private InvocationMatcher simpleMethod;
    @Mock private IMethods mock;

    @Before
    public void setup() {
        simpleMethod = new InvocationBuilder().mock(mock).simpleMethod().toInvocationMatcher();
    }

    @Test
    public void should_be_a_citizen_of_hashes() throws Exception {
        Invocation invocation = new InvocationBuilder().toInvocation();
        Invocation invocationTwo = new InvocationBuilder().args("blah").toInvocation();

        Map map = new HashMap();
        map.put(new InvocationMatcher(invocation), "one");
        map.put(new InvocationMatcher(invocationTwo), "two");

        assertEquals(2, map.size());
    }

    @Test
    public void should_not_equal_if_number_of_arguments_differ() throws Exception {
        InvocationMatcher withOneArg = new InvocationMatcher(new InvocationBuilder().args("test").toInvocation());
        InvocationMatcher withTwoArgs = new InvocationMatcher(new InvocationBuilder().args("test", 100).toInvocation());

        assertFalse(withOneArg.equals(null));
        assertFalse(withOneArg.equals(withTwoArgs));
    }

    @Test
    public void should_to_string_with_matchers() throws Exception {
        Matcher m = NotNull.NOT_NULL;
        InvocationMatcher notNull = new InvocationMatcher(new InvocationBuilder().toInvocation(), asList(m));
        Matcher mTwo = new Equals('x');
        InvocationMatcher equals = new InvocationMatcher(new InvocationBuilder().toInvocation(), asList(mTwo));

        assertContains("simpleMethod(notNull())", notNull.toString());
        assertContains("simpleMethod('x')", equals.toString());
    }

    @Test
    public void should_know_if_is_similar_to() throws Exception {
        Invocation same = new InvocationBuilder().mock(mock).simpleMethod().toInvocation();
        assertTrue(simpleMethod.hasSimilarMethod(same));

        Invocation different = new InvocationBuilder().mock(mock).differentMethod().toInvocation();
        assertFalse(simpleMethod.hasSimilarMethod(different));
    }

    @Test
    public void should_not_be_similar_to_verified_invocation() throws Exception {
        Invocation verified = new InvocationBuilder().simpleMethod().verified().toInvocation();
        assertFalse(simpleMethod.hasSimilarMethod(verified));
    }

    @Test
    public void should_not_be_similar_if_mocks_are_different() throws Exception {
        Invocation onDifferentMock = new InvocationBuilder().simpleMethod().mock("different mock").toInvocation();
        assertFalse(simpleMethod.hasSimilarMethod(onDifferentMock));
    }

    @Test
    public void should_not_be_similar_if_is_overloaded_but_used_with_the_same_arg() throws Exception {
        Method method = IMethods.class.getMethod("simpleMethod", String.class);
        Method overloadedMethod = IMethods.class.getMethod("simpleMethod", Object.class);

        String sameArg = "test";

        InvocationMatcher invocation = new InvocationBuilder().method(method).arg(sameArg).toInvocationMatcher();
        Invocation overloadedInvocation = new InvocationBuilder().method(overloadedMethod).arg(sameArg).toInvocation();

        assertFalse(invocation.hasSimilarMethod(overloadedInvocation));
    }

    @Test
    public void should_be_similar_if_is_overloaded_but_used_with_different_arg() throws Exception {
        Method method = IMethods.class.getMethod("simpleMethod", String.class);
        Method overloadedMethod = IMethods.class.getMethod("simpleMethod", Object.class);

        InvocationMatcher invocation = new InvocationBuilder().mock(mock).method(method).arg("foo").toInvocationMatcher();
        Invocation overloadedInvocation = new InvocationBuilder().mock(mock).method(overloadedMethod).arg("bar").toInvocation();

        assertTrue(invocation.hasSimilarMethod(overloadedInvocation));
    }

    @Test
    public void should_capture_arguments_from_invocation() throws Exception {

        Invocation invocation = new InvocationBuilder().args("1", 100).toInvocation();
        CapturingMatcher capturingMatcher = new CapturingMatcher();
        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals("1"), capturingMatcher));


        invocationMatcher.captureArgumentsFrom(invocation);


        assertEquals(1, capturingMatcher.getAllValues().size());
        assertEquals(100, capturingMatcher.getLastValue());
    }

    @Test
    public void should_match_varargs_using_any_varargs() throws Exception {

        mock.varargs("1", "2");
        Invocation invocation = getLastInvocation();
        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(AnyVararg.ANY_VARARG));


        boolean match = invocationMatcher.matches(invocation);


        assertTrue(match);
    }

    @Test
    public void should_capture_varargs_as_vararg() throws Exception {

        mock.mixedVarargs(1, "a", "b");
        Invocation invocation = getLastInvocation();
        CapturingMatcher m = new CapturingMatcher();
        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(1), new LocalizedMatcher(m)));


        invocationMatcher.captureArgumentsFrom(invocation);


        Assertions.assertThat(m.getAllValues()).containsExactly("a", "b");
    }

    @Test  
    public void should_capture_arguments_when_args_count_does_NOT_match() throws Exception {

        mock.varargs();
        Invocation invocation = getLastInvocation();


        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new LocalizedMatcher(AnyVararg.ANY_VARARG)));


        invocationMatcher.captureArgumentsFrom(invocation);
    }

    @Test
    public void should_create_from_invocations() throws Exception {

        Invocation i = new InvocationBuilder().toInvocation();

        List<InvocationMatcher> out = InvocationMatcher.createFrom(asList(i));

        assertEquals(1, out.size());
        assertEquals(i, out.get(0).getInvocation());
    }
}
<code block>

package org.mockitousage.matchers;

import static org.mockito.Matchers.argThat;
import static org.mockito.Mockito.verify;

import org.junit.Test;
import org.mockito.ArgumentMatcher;
import org.mockito.Mock;
import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;

public class CustomMatcherDoesYieldCCETest extends TestBase {

    @Mock private IMethods mock;

    @Test
    public void shouldNotThrowCCE() {
        mock.simpleMethod(new Object());

        try {


            verify(mock).simpleMethod(argThat(isStringWithTextFoo()));
            fail();
        } catch (ArgumentsAreDifferent e) {}
    }

    private ArgumentMatcher<String> isStringWithTextFoo() {
        return new ArgumentMatcher<String>() {
            @Override
            public boolean matches(Object argument) {

                String str = (String) argument;
                return str.equals("foo");
            }
        };
    }
}
<code block>


package org.mockitousage.matchers;

import static org.mockito.Matchers.*;
import static org.mockito.Mockito.*;

import org.junit.Before;
import org.junit.Test;
import org.mockito.ArgumentMatcher;
import org.mockito.Mockito;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;

public class CustomMatchersTest extends TestBase {
    
    private final class ContainsFoo extends ArgumentMatcher<String> {
        public boolean matches(Object arg) {
            return ((String) arg).contains("foo");
        }
    }

    private final class IsAnyBoolean extends ArgumentMatcher<Boolean> {
        public boolean matches(Object arg) {
            return true;
        }
    }
    
    private final class IsSorZ extends ArgumentMatcher<Character> {
        public boolean matches(Object arg) {
            Character character = (Character) arg;
            return character.equals('s') || character.equals('z');
        }
    }

    private final class IsZeroOrOne<T extends Number> extends ArgumentMatcher<T> {
        public boolean matches(Object arg) {
            Number number = (Number) arg;
            if (number.intValue() == 0 || number.intValue() == 1) {
                return true;
            }
            return false;
        }
    }

    private IMethods mock;

    @Before
    public void setUp() {
        mock = Mockito.mock(IMethods.class);
    }

    @Test
    public void shouldUseCustomBooleanMatcher() {
        when(mock.oneArg(booleanThat(new IsAnyBoolean()))).thenReturn("foo");
        
        assertEquals("foo", mock.oneArg(true));
        assertEquals("foo", mock.oneArg(false));
        
        assertEquals(null, mock.oneArg("x"));
    }
    
    @Test
    public void shouldUseCustomCharMatcher() {
        when(mock.oneArg(charThat(new IsSorZ()))).thenReturn("foo");
      
        assertEquals("foo", mock.oneArg('s'));
        assertEquals("foo", mock.oneArg('z'));
        assertEquals(null, mock.oneArg('x'));
    }
    
    class Article {
        
        private int pageNumber;
        private String headline;
        
        public Article(int pageNumber, String headline) {
            super();
            this.pageNumber = pageNumber;
            this.headline = headline;
        }

        public int getPageNumber() {
            return pageNumber;
        }

        public String getHeadline() {
            return headline;
        }
    }
    
    @Test
    public void shouldUseCustomPrimitiveNumberMatchers() {
        when(mock.oneArg(byteThat(new IsZeroOrOne<Byte>()))).thenReturn("byte");
        when(mock.oneArg(shortThat(new IsZeroOrOne<Short>()))).thenReturn("short");
        when(mock.oneArg(intThat(new IsZeroOrOne<Integer>()))).thenReturn("int");
        when(mock.oneArg(longThat(new IsZeroOrOne<Long>()))).thenReturn("long");
        when(mock.oneArg(floatThat(new IsZeroOrOne<Float>()))).thenReturn("float");
        when(mock.oneArg(doubleThat(new IsZeroOrOne<Double>()))).thenReturn("double");
        
        assertEquals("byte", mock.oneArg((byte) 0));
        assertEquals("short", mock.oneArg((short) 1));
        assertEquals("int", mock.oneArg(0));
        assertEquals("long", mock.oneArg(1L));
        assertEquals("float", mock.oneArg(0F));
        assertEquals("double", mock.oneArg(1.0));
        
        assertEquals(null, mock.oneArg(2));
        assertEquals(null, mock.oneArg("foo"));
    }
         
    @Test
    public void shouldUseCustomObjectMatcher() {
        when(mock.oneArg(argThat(new ContainsFoo()))).thenReturn("foo");
        
        assertEquals("foo", mock.oneArg("foo"));
        assertEquals(null, mock.oneArg("bar"));
    }
    
    @Test
    public void shouldCustomMatcherPrintDescriptionBasedOnName() {
        mock.simpleMethod("foo");

        try {
            verify(mock).simpleMethod(containsTest());
            fail();
        } catch (AssertionError e) {
            assertContains("<String that contains xxx>", e.getMessage());
        }
    }

    private String containsTest() {
        return argThat(new StringThatContainsXxx());
    }
    
    private final class StringThatContainsXxx extends ArgumentMatcher<String> {
        public boolean matches(Object argument) {
            String arg = (String) argument;
            return arg.contains("xxx");
        }
    }
    
    @Test
    public void shouldAnonymousCustomMatcherPrintDefaultDescription() {
        mock.simpleMethod("foo");

        try {
            verify(mock).simpleMethod((String) argThat(new ArgumentMatcher<Object>() {
                @Override public boolean matches(Object argument) {
                    return false;
                }}));
            fail();
        } catch (AssertionError e) {
            assertContains("<custom argument matcher>", e.getMessage());
            assertContains("foo", e.getMessage());
        }
    }
}
<code block>


package org.mockitousage.matchers;

import static org.mockito.Matchers.*;
import static org.mockito.Mockito.*;

import org.hamcrest.BaseMatcher;
import org.hamcrest.Description;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;

public class HamcrestMatchersTest extends TestBase {
    
    private final class ContainsX extends BaseMatcher<String> {
        public boolean matches(Object o) {
            return ((String) o).contains("X");
        }

        public void describeTo(Description d) {
            d.appendText("contains 'X'");
        }
    }

    @Mock private IMethods mock;

    @Test
    public void shouldAcceptHamcrestMatcher() {
        when(mock.simpleMethod(argThat(new ContainsX()))).thenReturn("X");
        assertNull(mock.simpleMethod("blah"));
        assertEquals("X", mock.simpleMethod("blah X blah"));
    }
    
    @Test
    public void shouldVerifyUsingHamcrestMatcher() {
        mock.simpleMethod("blah");
        
        try {
            verify(mock).simpleMethod(argThat(new ContainsX()));
            fail();
        } catch (ArgumentsAreDifferent e) {
            assertContains("contains 'X'", e.getMessage());
        }
    }
}
<code block>
package org.mockitousage.bugs;

import org.hamcrest.Matcher;
import org.junit.Test;
import org.mockito.internal.matchers.EqualsWithDelta;

import static org.fest.assertions.Assertions.assertThat;

public class EqualsWithDeltaTest {

    @Test
    public void testEqualsWithDelta_NullExpected() throws Exception {
        Matcher<Number> matcher = equalsWithDelta(null);
        assertThat(matcher.matches(1.0)).isFalse();
    }

    @Test
    public void testEqualsWithDelta_NullActual() throws Exception {
        Matcher<Number> matcher = equalsWithDelta(1.0);
        assertThat(matcher.matches(null)).isFalse();
    }

    @Test
    public void testEqualsWithDelta_NullActualAndExpected() throws Exception {
        Matcher<Number> matcher = equalsWithDelta(null);
        assertThat(matcher.matches(null)).isTrue();
    }

    @Test
    public void testEqualsWithDelta_WhenActualAndExpectedAreTheSameObject() throws Exception {
        Double expected = 1.0;
        Double actual = expected;
        Matcher<Number> matcher = equalsWithDelta(expected);
        assertThat(matcher.matches(actual)).isTrue();
    }

    public Matcher<Number> equalsWithDelta(final Double expected) {
        return new EqualsWithDelta(expected, .000001);
    }
}
<code block>
package org.mockito;

import org.mockito.internal.util.Decamelizer;


public abstract class MockitoMatcher<T> {


    public abstract boolean matches(Object argument);


    public String describe() {
        String className = getClass().getSimpleName();
        return Decamelizer.decamelizeMatcher(className);
    }
}

<code block>

package org.mockito;

import org.mockito.internal.matchers.CapturingMatcher;
import org.mockito.internal.progress.HandyReturnValues;

import java.util.List;


public class ArgumentCaptor<T> {
    
    HandyReturnValues handyReturnValues = new HandyReturnValues();

    private final CapturingMatcher<T> capturingMatcher = new CapturingMatcher<T>();
    private final Class<? extends T> clazz;


    @Deprecated
    public ArgumentCaptor() {
        this.clazz = null;
    }

    private ArgumentCaptor(Class<? extends T> clazz) {
        this.clazz = clazz;
    }


    public T capture() {
        Mockito.argThat(capturingMatcher);
        return handyReturnValues.returnFor(clazz);
    }


    public T getValue() {
        return this.capturingMatcher.getLastValue();
    }


    public List<T> getAllValues() {
        return this.capturingMatcher.getAllValues();
    }


    public static <U,S extends U> ArgumentCaptor<U> forClass(Class<S> clazz) {
        return new ArgumentCaptor<U>(clazz);
    }
}
<code block>


package org.mockito;

import org.mockito.internal.matchers.ArrayEquals;
import org.mockito.internal.matchers.CompareEqual;
import org.mockito.internal.matchers.EqualsWithDelta;
import org.mockito.internal.matchers.Find;
import org.mockito.internal.matchers.GreaterOrEqual;
import org.mockito.internal.matchers.GreaterThan;
import org.mockito.internal.matchers.LessOrEqual;
import org.mockito.internal.matchers.LessThan;
import org.mockito.internal.progress.HandyReturnValues;
import org.mockito.internal.progress.MockingProgress;
import org.mockito.internal.progress.ThreadSafeMockingProgress;


public class AdditionalMatchers {
    
    private static final MockingProgress MOCKING_PROGRESS = new ThreadSafeMockingProgress();


    public static <T extends Comparable<T>> T geq(Comparable<T> value) {
        return reportMatcher(new GreaterOrEqual<T>(value)).<T>returnNull();
    }


    public static byte geq(byte value) {
        return reportMatcher(new GreaterOrEqual<Byte>(value)).returnZero();
    }


    public static double geq(double value) {
        return reportMatcher(new GreaterOrEqual<Double>(value)).returnZero();
    }


    public static float geq(float value) {
        return reportMatcher(new GreaterOrEqual<Float>(value)).returnZero();
    }


    public static int geq(int value) {
        return reportMatcher(new GreaterOrEqual<Integer>(value)).returnZero();
    }


    public static long geq(long value) {
        return reportMatcher(new GreaterOrEqual<Long>(value)).returnZero();
    }


    public static short geq(short value) {
        return reportMatcher(new GreaterOrEqual<Short>(value)).returnZero();
    }


    public static <T extends Comparable<T>> T leq(Comparable<T> value) {
        return reportMatcher(new LessOrEqual<T>(value)).<T>returnNull();
    }


    public static byte leq(byte value) {
        return reportMatcher(new LessOrEqual<Byte>(value)).returnZero();
    }


    public static double leq(double value) {
        return reportMatcher(new LessOrEqual<Double>(value)).returnZero();
    }


    public static float leq(float value) {
        return reportMatcher(new LessOrEqual<Float>(value)).returnZero();
    }


    public static int leq(int value) {
        return reportMatcher(new LessOrEqual<Integer>(value)).returnZero();
    }


    public static long leq(long value) {
        return reportMatcher(new LessOrEqual<Long>(value)).returnZero();
    }


    public static short leq(short value) {
        return reportMatcher(new LessOrEqual<Short>(value)).returnZero();
    }


    public static <T extends Comparable<T>> T gt(Comparable<T> value) {
        return reportMatcher(new GreaterThan<T>(value)).<T>returnNull();
    }


    public static byte gt(byte value) {
        return reportMatcher(new GreaterThan<Byte>(value)).returnZero();
    }


    public static double gt(double value) {
        return reportMatcher(new GreaterThan<Double>(value)).returnZero();
    }


    public static float gt(float value) {
        return reportMatcher(new GreaterThan<Float>(value)).returnZero();
    }


    public static int gt(int value) {
        return reportMatcher(new GreaterThan<Integer>(value)).returnZero();
    }


    public static long gt(long value) {
        return reportMatcher(new GreaterThan<Long>(value)).returnZero();
    }


    public static short gt(short value) {
        return reportMatcher(new GreaterThan<Short>(value)).returnZero();
    }


    public static <T extends Comparable<T>> T lt(Comparable<T> value) {
        return reportMatcher(new LessThan<T>(value)).<T>returnNull();
    }


    public static byte lt(byte value) {
        return reportMatcher(new LessThan<Byte>(value)).returnZero();
    }


    public static double lt(double value) {
        return reportMatcher(new LessThan<Double>(value)).returnZero();
    }


    public static float lt(float value) {
        return reportMatcher(new LessThan<Float>(value)).returnZero();
    }


    public static int lt(int value) {
        return reportMatcher(new LessThan<Integer>(value)).returnZero();
    }


    public static long lt(long value) {
        return reportMatcher(new LessThan<Long>(value)).returnZero();
    }


    public static short lt(short value) {
        return reportMatcher(new LessThan<Short>(value)).returnZero();
    }


    public static <T extends Comparable<T>> T cmpEq(Comparable<T> value) {
        return reportMatcher(new CompareEqual<T>(value)).<T>returnNull();
    }


    public static String find(String regex) {
        return reportMatcher(new Find(regex)).<String>returnNull();
    }


    public static <T> T[] aryEq(T[] value) {
        return reportMatcher(new ArrayEquals(value)).returnNull();
    }


    public static short[] aryEq(short[] value) {
        return reportMatcher(new ArrayEquals(value)).returnNull();
    }


    public static long[] aryEq(long[] value) {
        return reportMatcher(new ArrayEquals(value)).returnNull();
    }


    public static int[] aryEq(int[] value) {
        return reportMatcher(new ArrayEquals(value)).returnNull();       
    }


    public static float[] aryEq(float[] value) {
        return reportMatcher(new ArrayEquals(value)).returnNull();
    }


    public static double[] aryEq(double[] value) {
        return reportMatcher(new ArrayEquals(value)).returnNull();
    }


    public static char[] aryEq(char[] value) {
        return reportMatcher(new ArrayEquals(value)).returnNull();
    }


    public static byte[] aryEq(byte[] value) {
        return reportMatcher(new ArrayEquals(value)).returnNull();
    }


    public static boolean[] aryEq(boolean[] value) {
        return reportMatcher(new ArrayEquals(value)).returnNull();
    }


    public static boolean and(boolean first, boolean second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().returnFalse();
    }


    public static byte and(byte first, byte second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().returnZero();
    }


    public static char and(char first, char second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().returnChar();
    }


    public static double and(double first, double second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().returnZero();
    }


    public static float and(float first, float second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().returnZero();
    }


    public static int and(int first, int second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().returnZero();
    }


    public static long and(long first, long second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().returnZero();
    }


    public static short and(short first, short second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().returnZero();
    }


    public static <T> T and(T first, T second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().<T>returnNull();
    }


    public static boolean or(boolean first, boolean second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().returnFalse();
    }


    public static <T> T or(T first, T second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().<T>returnNull();
    }


    public static short or(short first, short second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().returnZero();
    }


    public static long or(long first, long second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().returnZero();
    }


    public static int or(int first, int second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().returnZero();
    }


    public static float or(float first, float second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().returnZero();
    }


    public static double or(double first, double second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().returnZero();
    }


    public static char or(char first, char second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().returnChar();
    }


    public static byte or(byte first, byte second) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().returnZero();
    }


    public static <T> T not(T first) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().<T>returnNull();
    }


    public static short not(short first) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().returnZero();
    }


    public static int not(int first) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().returnZero();
    }


    public static long not(long first) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().returnZero();
    }


    public static float not(float first) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().returnZero();
    }


    public static double not(double first) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().returnZero();
    }


    public static char not(char first) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().returnChar();
    }


    public static boolean not(boolean first) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().returnFalse();
    }


    public static byte not(byte first) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().returnZero();
    }


    public static double eq(double value, double delta) {
        return reportMatcher(new EqualsWithDelta(value, delta)).returnZero();
    }
    

    public static float eq(float value, float delta) {
        return reportMatcher(new EqualsWithDelta(value, delta)).returnZero();
    }
    
    private static HandyReturnValues reportMatcher(MockitoMatcher<?> matcher) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportMatcher(matcher);
    }
}
<code block>


package org.mockito;

import org.hamcrest.BaseMatcher;
import org.hamcrest.Description;
import org.hamcrest.Matcher;
import org.mockito.internal.util.Decamelizer;


public abstract class ArgumentMatcher<T> extends BaseMatcher<T> {


    public abstract boolean matches(Object argument);


    public void describeTo(Description description) {
        String className = getClass().getSimpleName();
        description.appendText(Decamelizer.decamelizeMatcher(className));
    }
}
<code block>

package org.mockito;

import org.mockito.internal.matchers.*;
import org.mockito.internal.matchers.apachecommons.ReflectionEquals;
import org.mockito.internal.progress.HandyReturnValues;
import org.mockito.internal.progress.MockingProgress;
import org.mockito.internal.progress.ThreadSafeMockingProgress;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;


@SuppressWarnings("unchecked")
public class Matchers {
    
    private static final MockingProgress MOCKING_PROGRESS = new ThreadSafeMockingProgress();


    public static boolean anyBoolean() {
        return reportMatcher(new InstanceOf(Boolean.class)).returnFalse();
    }


    public static byte anyByte() {
        return reportMatcher(new InstanceOf(Byte.class)).returnZero();
    }


    public static char anyChar() {
        return reportMatcher(new InstanceOf(Character.class)).returnChar();
    }


    public static int anyInt() {
        return reportMatcher(new InstanceOf(Integer.class)).returnZero();
    }


    public static long anyLong() {
        return reportMatcher(new InstanceOf(Long.class)).returnZero();
    }


    public static float anyFloat() {
        return reportMatcher(new InstanceOf(Float.class)).returnZero();
    }


    public static double anyDouble() {
        return reportMatcher(new InstanceOf(Double.class)).returnZero();
    }


    public static short anyShort() {
        return reportMatcher(new InstanceOf(Short.class)).returnZero();
    }


    public static <T> T anyObject() {
        return (T) reportMatcher(Any.ANY).returnNull();
    }


    public static <T> T anyVararg() {
        return (T) reportMatcher(AnyVararg.ANY_VARARG).returnNull();
    }
    

    public static <T> T any(Class<T> clazz) {
        return (T) reportMatcher(Any.ANY).returnFor(clazz);
    }
    

    public static <T> T any() {
        return anyObject();
    }


    public static String anyString() {
        return reportMatcher(new InstanceOf(String.class)).returnString();
    }
    

    public static List anyList() {
        return reportMatcher(new InstanceOf(List.class)).returnList();
    }
    

    public static <T> List<T> anyListOf(Class<T> clazz) {
        return anyList();
    }
    

    public static Set anySet() {
        return reportMatcher(new InstanceOf(Set.class)).returnSet();
    }
    

    public static <T> Set<T> anySetOf(Class<T> clazz) {
        return anySet();
    }


    public static Map anyMap() {
        return reportMatcher(new InstanceOf(Map.class)).returnMap();
    }


    public static <K, V>  Map<K, V> anyMapOf(Class<K> keyClazz, Class<V> valueClazz) {
        return anyMap();
    }
    

    public static Collection anyCollection() {
        return reportMatcher(new InstanceOf(Collection.class)).returnList();
    }    
    

    public static <T> Collection<T> anyCollectionOf(Class<T> clazz) {
        return anyCollection();
    }    


    public static <T> T isA(Class<T> clazz) {
        return reportMatcher(new InstanceOf(clazz)).<T>returnFor(clazz);
    }


    public static boolean eq(boolean value) {
        return reportMatcher(new Equals(value)).returnFalse();
    }


    public static byte eq(byte value) {
        return reportMatcher(new Equals(value)).returnZero();
    }


    public static char eq(char value) {
        return reportMatcher(new Equals(value)).returnChar();
    }


    public static double eq(double value) {
        return reportMatcher(new Equals(value)).returnZero();
    }


    public static float eq(float value) {
        return reportMatcher(new Equals(value)).returnZero();
    }
    

    public static int eq(int value) {
        return reportMatcher(new Equals(value)).returnZero();
    }


    public static long eq(long value) {
        return reportMatcher(new Equals(value)).returnZero();
    }


    public static short eq(short value) {
        return reportMatcher(new Equals(value)).returnZero();
    }


    public static <T> T eq(T value) {
        return (T) reportMatcher(new Equals(value)).<T>returnFor(value);
    }


    public static <T> T refEq(T value, String... excludeFields) {
        return reportMatcher(new ReflectionEquals(value, excludeFields)).<T>returnNull();
    }
    

    public static <T> T same(T value) {
        return (T) reportMatcher(new Same(value)).<T>returnFor(value);
    }


    public static Object isNull() {
        return reportMatcher(Null.NULL).returnNull();
    }


    public static <T> T isNull(Class<T> clazz) {
        return (T) reportMatcher(Null.NULL).returnNull();
    }


    public static Object notNull() {
        return reportMatcher(NotNull.NOT_NULL).returnNull();
    }


    public static <T> T notNull(Class<T> clazz) {
        return (T) reportMatcher(NotNull.NOT_NULL).returnNull();
    }
    

    public static Object isNotNull() {
        return notNull();
    }


    public static <T> T isNotNull(Class<T> clazz) {
        return notNull(clazz);
    }


    public static String contains(String substring) {
        return reportMatcher(new Contains(substring)).returnString();
    }


    public static String matches(String regex) {
        return reportMatcher(new Matches(regex)).returnString();
    }


    public static String endsWith(String suffix) {
        return reportMatcher(new EndsWith(suffix)).returnString();
    }


    public static String startsWith(String prefix) {
        return reportMatcher(new StartsWith(prefix)).returnString();
    }


    public static <T> T argThat(MockitoMatcher<T> matcher) {
        return reportMatcher(matcher).<T>returnNull();
    }
    

    public static char charThat(MockitoMatcher<Character> matcher) {
        return reportMatcher(matcher).returnChar();
    }
    

    public static boolean booleanThat(MockitoMatcher<Boolean> matcher) {
        return reportMatcher(matcher).returnFalse();
    }
    

    public static byte byteThat(MockitoMatcher<Byte> matcher) {
        return reportMatcher(matcher).returnZero();
    }
    

    public static short shortThat(MockitoMatcher<Short> matcher) {
        return reportMatcher(matcher).returnZero();
    }
    

    public static int intThat(MockitoMatcher<Integer> matcher) {
        return reportMatcher(matcher).returnZero();
    }


    public static long longThat(MockitoMatcher<Long> matcher) {
        return reportMatcher(matcher).returnZero();
    }
    

    public static float floatThat(MockitoMatcher<Float> matcher) {
        return reportMatcher(matcher).returnZero();
    }
    

    public static double doubleThat(MockitoMatcher<Double> matcher) {
        return reportMatcher(matcher).returnZero();
    }

    private static HandyReturnValues reportMatcher(MockitoMatcher<?> matcher) {
        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportMatcher(matcher);
    }
}

<code block>

package org.mockito.internal.verification.argumentmatching;

import org.mockito.MockitoMatcher;
import org.mockito.internal.matchers.ContainsTypedDescription;

import java.util.LinkedList;
import java.util.List;

@SuppressWarnings("unchecked")
public class ArgumentMatchingTool {


    public Integer[] getSuspiciouslyNotMatchingArgsIndexes(List<MockitoMatcher> matchers, Object[] arguments) {
        if (matchers.size() != arguments.length) {
            return new Integer[0];
        }
        
        List<Integer> suspicious = new LinkedList<Integer>();
        int i = 0;
        for (MockitoMatcher m : matchers) {
            if (m instanceof ContainsTypedDescription
                    && !safelyMatches(m, arguments[i]) 
                    && toStringEquals(m, arguments[i])
                    && !((ContainsTypedDescription) m).typeMatches(arguments[i])) {
                suspicious.add(i);
            }
            i++;
        }
        return suspicious.toArray(new Integer[0]);
    }

    private boolean safelyMatches(MockitoMatcher m, Object arg) {
        try {
            return m.matches(arg);
        } catch (Throwable t) {
            return false;
        }
    }

    private boolean toStringEquals(MockitoMatcher m, Object arg) {
        return m.describe().equals(arg == null ? "null" : arg.toString());
    }
}

<code block>

package org.mockito.internal.matchers;

import org.mockito.MockitoMatcher;

import java.io.Serializable;

@SuppressWarnings("unchecked")
public class AnyVararg extends MockitoMatcher implements VarargMatcher, Serializable {

    public static final MockitoMatcher ANY_VARARG = new AnyVararg();

    public boolean matches(Object arg) {
        return true;
    }

    public String describe() {
        return "<any>";
    }
}
<code block>


package org.mockito.internal.matchers;

import java.io.Serializable;

import org.mockito.MockitoMatcher;

@SuppressWarnings("unchecked")
public class Any extends MockitoMatcher implements Serializable {

    public static final Any ANY = new Any();

    private Any() {
    }

    public boolean matches(Object actual) {
        return true;
    }

    public String describe() {
        return "<any>";
    }
}

<code block>


package org.mockito.internal.matchers;

import java.io.Serializable;

public class GreaterOrEqual<T extends Comparable<T>> extends CompareTo<T> implements Serializable {

    public GreaterOrEqual(Comparable<T> value) {
        super(value);
    }

    @Override
    protected String getName() {
        return "geq";
    }

    @Override
    protected boolean matchResult(int result) {
        return result >= 0;
    }
}

<code block>


package org.mockito.internal.matchers;

import org.mockito.MockitoMatcher;

import java.io.Serializable;

public class Equals extends MockitoMatcher<Object> implements ContainsTypedDescription, Serializable {

    private final Object wanted;

    public Equals(Object wanted) {
        this.wanted = wanted;
    }

    public boolean matches(Object actual) {
        return Equality.areEqual(this.wanted, actual);
    }

    public String describe() {
        return describe(wanted);
    }

    public String describe(Object object) {
        return quoting() + object + quoting();
    }

    private String quoting() {
        if (wanted instanceof String) {
            return "\"";
        } else if (wanted instanceof Character) {
            return "'";
        } else {
            return "";
        }
    }

    protected final Object getWanted() {
        return wanted;
    }

    @Override
    public boolean equals(Object o) {
        if (o == null || !this.getClass().equals(o.getClass())) {
            return false;
        }
        Equals other = (Equals) o;
        return this.wanted == null && other.wanted == null || this.wanted != null && this.wanted.equals(other.wanted);
    }

    @Override
    public int hashCode() {
        return 1;
    }

    public String getTypedDescription() {
        return "("+ wanted.getClass().getSimpleName() +") " + describe(wanted);
    }

    public boolean typeMatches(Object object) {
        return wanted != null && object != null && object.getClass() == wanted.getClass();
    }
}
<code block>


package org.mockito.internal.matchers;

import org.mockito.MockitoMatcher;

import java.io.Serializable;
import java.util.Iterator;
import java.util.List;

@SuppressWarnings("unchecked")
public class Or extends MockitoMatcher implements Serializable {

    private final List<MockitoMatcher> matchers;

    public Or(List<MockitoMatcher> matchers) {
        this.matchers = matchers;
    }

    public boolean matches(Object actual) {
        for (MockitoMatcher matcher : matchers) {
            if (matcher.matches(actual)) {
                return true;
            }
        }
        return false;
    }

    public String describe() {

        StringBuilder sb = new StringBuilder("or(");
        for (Iterator<MockitoMatcher> it = matchers.iterator(); it.hasNext();) {
            sb.append(it.next().describe());
            if (it.hasNext()) {
                sb.append(", ");
            }
        }
        return sb.append(")").toString();
    }
}

<code block>


package org.mockito.internal.matchers;

import java.lang.reflect.Array;
import java.util.Arrays;

public class ArrayEquals extends Equals {

    public ArrayEquals(Object wanted) {
        super(wanted);
    }

    public boolean matches(Object actual) {
        Object wanted = getWanted();
        if (wanted == null || actual == null) {
            return super.matches(actual);
        } else if (wanted instanceof boolean[] && actual instanceof boolean[]) {
            return Arrays.equals((boolean[]) wanted, (boolean[]) actual);
        } else if (wanted instanceof byte[] && actual instanceof byte[]) {
            return Arrays.equals((byte[]) wanted, (byte[]) actual);
        } else if (wanted instanceof char[] && actual instanceof char[]) {
            return Arrays.equals((char[]) wanted, (char[]) actual);
        } else if (wanted instanceof double[] && actual instanceof double[]) {
            return Arrays.equals((double[]) wanted, (double[]) actual);
        } else if (wanted instanceof float[] && actual instanceof float[]) {
            return Arrays.equals((float[]) wanted, (float[]) actual);
        } else if (wanted instanceof int[] && actual instanceof int[]) {
            return Arrays.equals((int[]) wanted, (int[]) actual);
        } else if (wanted instanceof long[] && actual instanceof long[]) {
            return Arrays.equals((long[]) wanted, (long[]) actual);
        } else if (wanted instanceof short[] && actual instanceof short[]) {
            return Arrays.equals((short[]) wanted, (short[]) actual);
        } else if (wanted instanceof Object[] && actual instanceof Object[]) {
            return Arrays.equals((Object[]) wanted, (Object[]) actual);
        }
        return false;
    }

    public String describe() {
        if (getWanted() != null && getWanted().getClass().isArray()) {
            return appendArray(createObjectArray(getWanted()));
        } else {
            return super.describe();
        }
    }

    private String appendArray(Object[] array) {
        StringBuilder out = new StringBuilder("[");
        for (int i = 0; i < array.length; i++) {
            out.append(new Equals(array[i]).describe());
            if (i != array.length - 1) {
                out.append(", ");
            }
        }
        out.append("]");
        return out.toString();
    }

    public static Object[] createObjectArray(Object array) {
        if (array instanceof Object[]) {
            return (Object[]) array;
        }
        Object[] result = new Object[Array.getLength(array)];
        for (int i = 0; i < Array.getLength(array); i++) {
            result[i] = Array.get(array, i);
        }
        return result;
    }
}

<code block>


package org.mockito.internal.matchers;

import org.mockito.MockitoMatcher;

import java.io.Serializable;

public class NotNull extends MockitoMatcher<Object> implements Serializable {

    public static final NotNull NOT_NULL = new NotNull();

    private NotNull() {
    }

    public boolean matches(Object actual) {
        return actual != null;
    }

    public String describe() {
        return "notNull()";
    }
}

<code block>


package org.mockito.internal.matchers;

import org.mockito.MockitoMatcher;


public abstract class CompareTo<T extends Comparable<T>> extends MockitoMatcher<T> {
    private final Comparable<T> wanted;

    public CompareTo(Comparable<T> value) {
        this.wanted = value;
    }

    @SuppressWarnings("unchecked")
    public boolean matches(Object actual) {
        if(!(actual instanceof Comparable)) {
            return false;
        }
        
        return matchResult(((Comparable) actual).compareTo(wanted));
    }

    public String describe() {
        return getName() + "(" + wanted + ")";
    }
    
    protected abstract String getName();
    
    protected abstract boolean matchResult(int result);
}

<code block>


package org.mockito.internal.matchers;

import java.io.Serializable;

public class GreaterThan<T extends Comparable<T>> extends CompareTo<T> implements Serializable {

    public GreaterThan(Comparable<T> value) {
        super(value);
    }

    @Override
    protected String getName() {
        return "gt";
    }

    @Override
    protected boolean matchResult(int result) {
        return result > 0;
    }    
}

<code block>


package org.mockito.internal.matchers;

import org.mockito.MockitoMatcher;

import java.io.Serializable;

public class StartsWith extends MockitoMatcher<String> implements Serializable {

    private final String prefix;

    public StartsWith(String prefix) {
        this.prefix = prefix;
    }

    public boolean matches(Object actual) {
        return actual != null && ((String) actual).startsWith(prefix);
    }

    public String describe() {
        return "startsWith(\"" + prefix + "\")";
    }
}

<code block>


package org.mockito.internal.matchers;

import org.mockito.MockitoMatcher;

import java.io.Serializable;

public class Null extends MockitoMatcher<Object> implements Serializable {

    public static final Null NULL = new Null();

    private Null() {
    }

    public boolean matches(Object actual) {
        return actual == null;
    }

    public String describe() {
        return "isNull()";
    }
}

<code block>

package org.mockito.internal.matchers;

import java.io.Serializable;


public interface VarargMatcher extends Serializable {
}

<code block>

package org.mockito.internal.matchers;

import org.mockito.MockitoMatcher;

import java.io.Serializable;

@SuppressWarnings("unchecked")
public interface MatcherDecorator extends Serializable {
    MockitoMatcher getActualMatcher();
}

<code block>


package org.mockito.internal.matchers;

import java.io.Serializable;

public class LessThan<T extends Comparable<T>> extends CompareTo<T> implements Serializable {

    public LessThan(Comparable<T> value) {
        super(value);
    }

    @Override
    protected String getName() {
        return "lt";
    }

    @Override
    protected boolean matchResult(int result) {
        return result < 0;
    }
}

<code block>

package org.mockito.internal.matchers;

import org.mockito.MockitoMatcher;
import org.mockito.exceptions.Reporter;

import java.io.Serializable;
import java.util.LinkedList;
import java.util.List;

@SuppressWarnings("unchecked")
public class CapturingMatcher<T> extends MockitoMatcher<T> implements CapturesArguments, VarargMatcher, Serializable {
    
    private final LinkedList<Object> arguments = new LinkedList<Object>();

    public boolean matches(Object argument) {
        return true;
    }    

    public String describe() {
        return "<Capturing argument>";
    }

    public T getLastValue() {
        if (arguments.isEmpty()) {
            new Reporter().noArgumentValueWasCaptured();
            return null;
        } else {
            return (T) arguments.getLast();
        }
    }

    public List<T> getAllValues() {
        return (List) arguments;
    }

    public void captureFrom(Object argument) {
        this.arguments.add(argument);
    }
}
<code block>


package org.mockito.internal.matchers;

import java.io.Serializable;

import org.mockito.MockitoMatcher;

public class EndsWith extends MockitoMatcher<String> implements Serializable {

    private final String suffix;

    public EndsWith(String suffix) {
        this.suffix = suffix;
    }

    public boolean matches(Object actual) {
        return actual != null && ((String) actual).endsWith(suffix);
    }

    public String describe() {
        return "endsWith(\"" + suffix + "\")";
    }
}
<code block>


package org.mockito.internal.matchers;

import org.mockito.MockitoMatcher;

import java.io.Serializable;

public class Matches extends MockitoMatcher<Object> implements Serializable {

    private final String regex;

    public Matches(String regex) {
        this.regex = regex;
    }

    public boolean matches(Object actual) {
        return (actual instanceof String) && ((String) actual).matches(regex);
    }

    public String describe() {
        return "matches(\"" + regex.replaceAll("\\\\", "\\\\\\\\") + "\")";
    }
}
<code block>


package org.mockito.internal.matchers;

import org.mockito.MockitoMatcher;

import java.io.Serializable;


public class InstanceOf extends MockitoMatcher<Object> implements Serializable {

    private final Class<?> clazz;

    public InstanceOf(Class<?> clazz) {
        this.clazz = clazz;
    }

    public boolean matches(Object actual) {
        return (actual != null) && clazz.isAssignableFrom(actual.getClass());
    }

    public String describe() {
        return "isA(" + clazz.getName() + ")";
    }
}

<code block>

package org.mockito.internal.matchers;

import org.mockito.MockitoMatcher;
import org.mockito.internal.debugging.LocationImpl;
import org.mockito.invocation.Location;

import java.io.Serializable;

@SuppressWarnings("unchecked")
public class LocalizedMatcher extends MockitoMatcher implements ContainsTypedDescription, CapturesArguments, MatcherDecorator, Serializable {

    private final MockitoMatcher actualMatcher;
    private final Location location;


    public LocalizedMatcher(MockitoMatcher actualMatcher) {
        this.actualMatcher = actualMatcher;
        this.location = new LocationImpl();
    }

    public boolean matches(Object item) {
        return actualMatcher.matches(item);
    }

    public String describe() {
        return actualMatcher.describe();
    }

    public Location getLocation() {
        return location;
    }
    
    @Override
    public String toString() {
        return "Localized: " + this.actualMatcher;
    }

    public String getTypedDescription() {
        if (actualMatcher instanceof ContainsTypedDescription) {
            return ((ContainsTypedDescription) actualMatcher).getTypedDescription();
        } else {
            return actualMatcher.describe();
        }
    }

    public boolean typeMatches(Object object) {
        return actualMatcher instanceof ContainsTypedDescription
                && ((ContainsTypedDescription) actualMatcher).typeMatches(object);
    }

    public void captureFrom(Object argument) {
        if (actualMatcher instanceof CapturesArguments) {
            ((CapturesArguments) actualMatcher).captureFrom(argument);
        }
    }


    public MockitoMatcher getActualMatcher() {
        return actualMatcher;
    }
}
<code block>


package org.mockito.internal.matchers;

import org.mockito.MockitoMatcher;
import org.mockito.internal.matchers.text.ValuePrinter;

import java.io.Serializable;

public class Same extends MockitoMatcher<Object> implements Serializable {

    private final Object wanted;

    public Same(Object wanted) {
        this.wanted = wanted;
    }

    public boolean matches(Object actual) {
        return wanted == actual;
    }

    public String describe() {

        return "same(" + new ValuePrinter().appendValue(wanted).toString() + ")";
    }
}

<code block>


package org.mockito.internal.matchers;

import org.mockito.MockitoMatcher;

import java.io.Serializable;


public class Contains extends MockitoMatcher<String> implements Serializable {

    private final String substring;

    public Contains(String substring) {
        this.substring = substring;
    }

    public boolean matches(Object actual) {
        return actual != null && ((String) actual).contains(substring);
    }

    public String describe() {
        return "contains(\"" + substring + "\")";
    }
}

<code block>


package org.mockito.internal.matchers;

import java.io.Serializable;

public class CompareEqual<T extends Comparable<T>> extends CompareTo<T> implements Serializable {

    public CompareEqual(Comparable<T> value) {
        super(value);
    }

    @Override
    protected String getName() {
        return "cmpEq";
    }

    @Override
    protected boolean matchResult(int result) {
        return result == 0;
    }
}

<code block>


package org.mockito.internal.matchers;

import java.io.Serializable;
import java.util.regex.Pattern;

import org.mockito.MockitoMatcher;

public class Find extends MockitoMatcher<String> implements Serializable {

    private final String regex;

    public Find(String regex) {
        this.regex = regex;
    }

    public boolean matches(Object actual) {
        return actual != null && Pattern.compile(regex).matcher((String) actual).find();
    }

    public String describe() {
        return "find(\"" + regex.replaceAll("\\\\", "\\\\\\\\") + "\")";
    }
}
<code block>


package org.mockito.internal.matchers;

import org.mockito.MockitoMatcher;

import java.io.Serializable;

public class EqualsWithDelta extends MockitoMatcher<Number> implements Serializable {

    private final Number wanted;
    private final Number delta;

    public EqualsWithDelta(Number value, Number delta) {
        this.wanted = value;
        this.delta = delta;
    }

    public boolean matches(Object object) {
        Number actual = (Number) object;
        if (wanted == null ^ actual == null) {
            return false;
        }

        if (wanted == actual) {
            return true;
        }

        return wanted.doubleValue() - delta.doubleValue() <= actual.doubleValue()
                && actual.doubleValue() <= wanted.doubleValue()
                        + delta.doubleValue();
    }

    public String describe() {
        return "eq(" + wanted + ", " + delta + ")";
    }
}

<code block>


package org.mockito.internal.matchers;

import org.mockito.MockitoMatcher;

import java.io.Serializable;
import java.util.Iterator;
import java.util.List;

@SuppressWarnings("unchecked")
public class And extends MockitoMatcher implements Serializable {

    private final List<MockitoMatcher> matchers;

    public And(List<MockitoMatcher> matchers) {
        this.matchers = matchers;
    }

    public boolean matches(Object actual) {
        for (MockitoMatcher matcher : matchers) {
            if (!matcher.matches(actual)) {
                return false;
            }
        }
        return true;
    }

    public String describe() {
        StringBuilder out = new StringBuilder();
        out.append("and(");
        for (Iterator<MockitoMatcher> it = matchers.iterator(); it.hasNext();) {
            out.append(it.next().describe());
            if (it.hasNext()) {
                out.append(", ");
            }
        }
        out.append(")");
        return out.toString();
    }
}

<code block>


package org.mockito.internal.matchers;

import org.mockito.MockitoMatcher;

import java.io.Serializable;

@SuppressWarnings("unchecked")
public class Not extends MockitoMatcher implements Serializable {

    private final MockitoMatcher first;

    public Not(MockitoMatcher first) {
        this.first = first;
    }

    public boolean matches(Object actual) {
        return !first.matches(actual);
    }

    public String describe() {
        return "not(" + first.describe() + ")";
    }
}
<code block>


package org.mockito.internal.matchers;

import java.io.Serializable;

public class LessOrEqual<T extends Comparable<T>> extends CompareTo<T> implements Serializable {

    public LessOrEqual(Comparable<T> value) {
        super(value);
    }

    @Override
    protected String getName() {
        return "leq";
    }

    @Override
    protected boolean matchResult(int result) {
        return result <= 0;
    }
}

<code block>
package org.mockito.internal.matchers;

import org.mockito.MockitoMatcher;
import org.mockito.exceptions.Reporter;

import java.io.Serializable;
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

@SuppressWarnings("unchecked")
public class VarargCapturingMatcher<T> extends MockitoMatcher<T> implements CapturesArguments, VarargMatcher, Serializable {

    private final LinkedList<List<T>> arguments = new LinkedList<List<T>>();

    public boolean matches(Object argument) {
        return true;
    }

    public String describe() {
        return "<Capturing variable argument>";
    }

    public List<T> getLastVarargs() {
        if (arguments.isEmpty()) {
            new Reporter().noArgumentValueWasCaptured();
            return null;
        } else {
            return arguments.getLast();
        }
    }

    public List<List<T>> getAllVarargs() {
        return arguments;
    }

    public void captureFrom(Object varArgArray) {
        List<T> vararg = unpackAsList(varArgArray);
        this.arguments.add(vararg);
    }

    private List<T> unpackAsList(Object varArgArray) {
        if (varArgArray instanceof Object[]) {
            return Arrays.asList((T[]) varArgArray);
        } else if (varArgArray.getClass().isArray()) {
            Object[] primitiveArray = new Object[Array.getLength(varArgArray)];
            for (int i = 0; i < primitiveArray.length; i++) {
                primitiveArray[i] = Array.get(varArgArray, i);
            }
            return Arrays.asList((T[]) primitiveArray);
        } else {
            return Collections.singletonList((T) varArgArray);
        }
    }
}

<code block>
package org.mockito.internal.matchers.text;


class FormattedText {

    private String text;

    public FormattedText(String text) {
        this.text = text;
    }

    public String getText() {
        return text;
    }
}

<code block>
package org.mockito.internal.matchers.text;

import java.lang.reflect.Array;
import java.util.Iterator;


class ArrayIterator implements Iterator<Object> {

    private final Object array;
    private int currentIndex = 0;

    public ArrayIterator(Object array) {
        if (array == null) {

            throw new IllegalArgumentException("Expected array instance but got null");
        }
        if (!array.getClass().isArray()) {
            throw new IllegalArgumentException("Expected array but got object of type: "
                    + array.getClass() + ", the object: " + array.toString());
        }
        this.array = array;
    }

    public boolean hasNext() {
        return currentIndex < Array.getLength(array);
    }

    public Object next() {
        return Array.get(array, currentIndex++);
    }

    public void remove() {
        throw new UnsupportedOperationException("cannot remove items from an array");
    }
}

<code block>
package org.mockito.internal.matchers.text;

import org.hamcrest.SelfDescribing;
import org.hamcrest.StringDescription;


class HamcrestPrinter {

    public static String print(SelfDescribing object) {
        return StringDescription.toString(object);
    }
}

<code block>
package org.mockito.internal.matchers.text;

import java.util.Iterator;

import static java.lang.String.valueOf;


public class ValuePrinter {

    private final StringBuilder content = new StringBuilder();

    public String toString() {
        return content.toString();
    }

    public ValuePrinter appendText(String text) {
        append(text);
        return this;
    }


    public ValuePrinter appendValue(Object value) {
        if (value == null) {
            append("null");
        } else if (value instanceof String) {
            toJavaSyntax((String) value);
        } else if (value instanceof Character) {
            append('\'');
            toJavaSyntax((Character) value);
            append('\'');
        } else if (value.getClass().isArray()) {
            appendList("[", ", ", "]", new org.mockito.internal.matchers.text.ArrayIterator(value));
        } else if (value instanceof FormattedText) {
            append(((FormattedText) value).getText());
        } else {
            append(descriptionOf(value));
        }
        return this;
    }

    private String descriptionOf(Object value) {
        try {
            return valueOf(value);
        }
        catch (Exception e) {
            return value.getClass().getName() + "@" + Integer.toHexString(value.hashCode());
        }
    }

    public ValuePrinter appendList(String start, String separator, String end, Iterator i) {
        boolean separate = false;
        
        append(start);
        while (i.hasNext()) {
            if (separate) append(separator);
            appendValue(i.next());
            separate = true;
        }
        append(end);
        
        return this;
    }


    protected void append(String str) {
        for (int i = 0; i < str.length(); i++) {
            append(str.charAt(i));
        }
    }
    

    protected void append(char c) {
        content.append(c);
    }

    private void toJavaSyntax(String unformatted) {
        append('"');
        for (int i = 0; i < unformatted.length(); i++) {
            toJavaSyntax(unformatted.charAt(i));
        }
        append('"');
    }

    private void toJavaSyntax(char ch) {
        switch (ch) {
            case '"':
                append("\\\"");
                break;
            case '\n':
                append("\\n");
                break;
            case '\r':
                append("\\r");
                break;
            case '\t':
                append("\\t");
                break;
            default:
                append(ch);
        }
    }

}

<code block>

package org.mockito.internal.matchers.text;

import org.mockito.MockitoMatcher;
import org.mockito.internal.matchers.ContainsTypedDescription;
import org.mockito.internal.reporting.PrintSettings;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

@SuppressWarnings("unchecked")
public class MatchersPrinter {

    public String getArgumentsLine(List<MockitoMatcher> matchers, PrintSettings printSettings) {
        ValuePrinter printer = new ValuePrinter();
        printer.appendList("(", ", ", ");", applyPrintSettings(matchers, printSettings));
        return printer.toString();
    }

    public String getArgumentsBlock(List<MockitoMatcher> matchers, PrintSettings printSettings) {
        ValuePrinter printer = new ValuePrinter();
        printer.appendList("(\n    ", ",\n    ", "\n);", applyPrintSettings(matchers, printSettings));
        return printer.toString();
    }

    private Iterator applyPrintSettings(List<MockitoMatcher> matchers, PrintSettings printSettings) {
        List out = new LinkedList();
        int i = 0;
        for (final MockitoMatcher matcher : matchers) {
            if (matcher instanceof ContainsTypedDescription && printSettings.extraTypeInfoFor(i)) {
                out.add(new FormattedText(((ContainsTypedDescription) matcher).getTypedDescription()));
            } else {
                out.add(new FormattedText(matcher.describe()));
            }
            i++;
        }
        return out.iterator();
    }
}

<code block>


package org.mockito.internal.matchers.apachecommons;

import org.mockito.MockitoMatcher;

import java.io.Serializable;

public class ReflectionEquals extends MockitoMatcher<Object> implements Serializable {

    private final Object wanted;
    private final String[] excludeFields;

    public ReflectionEquals(Object wanted, String... excludeFields) {
        this.wanted = wanted;
        this.excludeFields = excludeFields;
    }

    public boolean matches(Object actual) {
        return EqualsBuilder.reflectionEquals(wanted, actual, excludeFields);
    }

    public String describe() {
        return "refEq(" + wanted + ")";
    }
}
<code block>

package org.mockito.internal.reporting;

import org.mockito.MockitoMatcher;
import org.mockito.internal.invocation.ArgumentsProcessor;
import org.mockito.internal.invocation.InvocationMatcher;
import org.mockito.internal.matchers.text.MatchersPrinter;
import org.mockito.internal.util.MockUtil;
import org.mockito.invocation.Invocation;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

public class PrintSettings {

    public static final int MAX_LINE_LENGTH = 45;
    private boolean multiline;
    private List<Integer> withTypeInfo = new LinkedList<Integer>();

    public void setMultiline(boolean multiline) {
        this.multiline = multiline;
    }

    public boolean isMultiline() {
        return multiline;
    }

    public static PrintSettings verboseMatchers(Integer ... indexesOfMatchers) {
        PrintSettings settings = new PrintSettings();
        settings.setMatchersToBeDescribedWithExtraTypeInfo(indexesOfMatchers);
        return settings;
    }

    public boolean extraTypeInfoFor(int argumentIndex) {
        return withTypeInfo.contains(argumentIndex);
    }

    public void setMatchersToBeDescribedWithExtraTypeInfo(Integer[] indexesOfMatchers) {
        this.withTypeInfo = Arrays.asList(indexesOfMatchers);
    }

    public String print(List<MockitoMatcher> matchers, Invocation invocation) {
        MatchersPrinter matchersPrinter = new MatchersPrinter();
        String qualifiedName = new MockUtil().getMockName(invocation.getMock()) + "." + invocation.getMethod().getName();
        String invocationString = qualifiedName + matchersPrinter.getArgumentsLine(matchers, this);
        if (isMultiline() || (!matchers.isEmpty() && invocationString.length() > MAX_LINE_LENGTH)) {
            return qualifiedName + matchersPrinter.getArgumentsBlock(matchers, this);
        } else {
            return invocationString;
        }
    }

    public String print(Invocation invocation) {
        return print(ArgumentsProcessor.argumentsToMatchers(invocation.getArguments()), invocation);
    }

    public String print(InvocationMatcher invocationMatcher) {
        return print(invocationMatcher.getMatchers(), invocationMatcher.getInvocation());
    }
}
<code block>

package org.mockito.internal.invocation;

import org.mockito.MockitoMatcher;
import org.mockito.internal.matchers.MatcherDecorator;
import org.mockito.internal.matchers.VarargMatcher;
import org.mockito.invocation.Invocation;

import java.util.List;

@SuppressWarnings("unchecked")
public class ArgumentsComparator {
    public boolean argumentsMatch(InvocationMatcher invocationMatcher, Invocation actual) {
        Object[] actualArgs = actual.getArguments();
        return argumentsMatch(invocationMatcher, actualArgs) || varArgsMatch(invocationMatcher, actual);
    }

    public boolean argumentsMatch(InvocationMatcher invocationMatcher, Object[] actualArgs) {
        if (actualArgs.length != invocationMatcher.getMatchers().size()) {
            return false;
        }
        for (int i = 0; i < actualArgs.length; i++) {
            if (!invocationMatcher.getMatchers().get(i).matches(actualArgs[i])) {
                return false;
            }
        }
        return true;
    }


    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {
        if (!actual.getMethod().isVarArgs()) {

            return false;
        }


        Object[] rawArgs = actual.getRawArguments();
        List<MockitoMatcher> matchers = invocationMatcher.getMatchers();

        if (rawArgs.length != matchers.size()) {
            return false;
        }

        for (int i = 0; i < rawArgs.length; i++) {
            MockitoMatcher m = matchers.get(i);

            if (rawArgs[i] != null && rawArgs[i].getClass().isArray() && i == rawArgs.length-1) {
                MockitoMatcher actualMatcher;

                if (m instanceof MatcherDecorator) {
                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();
                } else {
                    actualMatcher = m;
                }

                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {
                    return false;
                }

            } else if (!m.matches(rawArgs[i])){
                return false;
            }
        }

        return true;
    }
}
<code block>


package org.mockito.internal.invocation;

import org.mockito.MockitoMatcher;
import org.mockito.internal.matchers.CapturesArguments;
import org.mockito.internal.matchers.MatcherDecorator;
import org.mockito.internal.reporting.PrintSettings;
import org.mockito.invocation.DescribedInvocation;
import org.mockito.invocation.Invocation;
import org.mockito.invocation.Location;

import java.io.Serializable;
import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.*;

@SuppressWarnings("unchecked")
public class InvocationMatcher implements DescribedInvocation, CapturesArgumentsFromInvocation, Serializable {

    private final Invocation invocation;
    private final List<MockitoMatcher> matchers;

    public InvocationMatcher(Invocation invocation, List<MockitoMatcher> matchers) {
        this.invocation = invocation;
        if (matchers.isEmpty()) {
            this.matchers = ArgumentsProcessor.argumentsToMatchers(invocation.getArguments());
        } else {
            this.matchers = matchers;
        }
    }

    public InvocationMatcher(Invocation invocation) {
        this(invocation, Collections.<MockitoMatcher>emptyList());
    }

    public Method getMethod() {
        return invocation.getMethod();
    }

    public Invocation getInvocation() {
        return this.invocation;
    }

    public List<MockitoMatcher> getMatchers() {
        return this.matchers;
    }

    public String toString() {
        return new PrintSettings().print(matchers, invocation);
    }

    public boolean matches(Invocation actual) {
        return invocation.getMock().equals(actual.getMock())
                && hasSameMethod(actual)
                && new ArgumentsComparator().argumentsMatch(this, actual);
    }

    private boolean safelyArgumentsMatch(Object[] actualArgs) {
        try {
            return new ArgumentsComparator().argumentsMatch(this, actualArgs);
        } catch (Throwable t) {
            return false;
        }
    }


    public boolean hasSimilarMethod(Invocation candidate) {
        String wantedMethodName = getMethod().getName();
        String currentMethodName = candidate.getMethod().getName();

        final boolean methodNameEquals = wantedMethodName.equals(currentMethodName);
        final boolean isUnverified = !candidate.isVerified();
        final boolean mockIsTheSame = getInvocation().getMock() == candidate.getMock();
        final boolean methodEquals = hasSameMethod(candidate);

        if (!methodNameEquals || !isUnverified || !mockIsTheSame) {
            return false;
        }

        final boolean overloadedButSameArgs = !methodEquals && safelyArgumentsMatch(candidate.getArguments());

        return !overloadedButSameArgs;
    }

    public boolean hasSameMethod(Invocation candidate) {


        Method m1 = invocation.getMethod();
        Method m2 = candidate.getMethod();

        if (m1.getName() != null && m1.getName().equals(m2.getName())) {

            Class[] params1 = m1.getParameterTypes();
            Class[] params2 = m2.getParameterTypes();
            if (params1.length == params2.length) {
                for (int i = 0; i < params1.length; i++) {
                    if (params1[i] != params2[i])
                        return false;
                }
                return true;
            }
        }
        return false;
    }

    public Location getLocation() {
        return invocation.getLocation();
    }

    public void captureArgumentsFrom(Invocation invocation) {
        captureRegularArguments(invocation);
        captureVarargsPart(invocation);
    }

    private void captureRegularArguments(Invocation invocation) {
        for (int position = 0; position < regularArgumentsSize(invocation); position++) {
            MockitoMatcher m = matchers.get(position);
            if (m instanceof CapturesArguments) {
                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));
            }
        }
    }

    private void captureVarargsPart(Invocation invocation) {
        if (!invocation.getMethod().isVarArgs()) {
            return;
        }
        int indexOfVararg = invocation.getRawArguments().length - 1;
        for (MockitoMatcher m : uniqueMatcherSet(indexOfVararg)) {
            if (m instanceof CapturesArguments) {
                Object rawArgument = invocation.getRawArguments()[indexOfVararg];
                for (int i = 0; i < Array.getLength(rawArgument); i++) {
                    ((CapturesArguments) m).captureFrom(Array.get(rawArgument, i));
                }
            }
        }
    }

    private int regularArgumentsSize(Invocation invocation) {
        return invocation.getMethod().isVarArgs() ?
                invocation.getRawArguments().length - 1 
                : matchers.size();
    }

    private Set<MockitoMatcher> uniqueMatcherSet(int indexOfVararg) {
        HashSet<MockitoMatcher> set = new HashSet<MockitoMatcher>();
        for (int position = indexOfVararg; position < matchers.size(); position++) {
            MockitoMatcher matcher = matchers.get(position);
            if (matcher instanceof MatcherDecorator) {
                set.add(((MatcherDecorator) matcher).getActualMatcher());
            } else {
                set.add(matcher);
            }
        }
        return set;
    }

    public static List<InvocationMatcher> createFrom(List<Invocation> invocations) {
        LinkedList<InvocationMatcher> out = new LinkedList<InvocationMatcher>();
        for (Invocation i : invocations) {
            out.add(new InvocationMatcher(i));
        }
        return out;
    }
}

<code block>


package org.mockito.internal.invocation;

import org.mockito.MockitoMatcher;
import org.mockito.exceptions.Reporter;
import org.mockito.internal.matchers.LocalizedMatcher;
import org.mockito.internal.progress.ArgumentMatcherStorage;
import org.mockito.invocation.Invocation;

import java.io.Serializable;
import java.util.List;

@SuppressWarnings("unchecked")
public class MatchersBinder implements Serializable {

    public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {
        List<LocalizedMatcher> lastMatchers = argumentMatcherStorage.pullLocalizedMatchers();
        validateMatchers(invocation, lastMatchers);

        InvocationMatcher invocationWithMatchers = new InvocationMatcher(invocation, (List<MockitoMatcher>)(List) lastMatchers);
        return invocationWithMatchers;
    }

    private void validateMatchers(Invocation invocation, List<LocalizedMatcher> lastMatchers) {
        if (!lastMatchers.isEmpty()) {
            int recordedMatchersSize = lastMatchers.size();
            int expectedMatchersSize = invocation.getArguments().length;
            if (expectedMatchersSize != recordedMatchersSize) {
                new Reporter().invalidUseOfMatchers(expectedMatchersSize, lastMatchers);
            }
        }
    }
}
<code block>

package org.mockito.internal.invocation;

import org.mockito.MockitoMatcher;
import org.mockito.internal.matchers.ArrayEquals;
import org.mockito.internal.matchers.Equals;
import org.mockito.internal.util.collections.ArrayUtils;

import java.util.ArrayList;
import java.util.List;


public class ArgumentsProcessor {


    public static Object[] expandVarArgs(final boolean isVarArgs, final Object[] args) {
        if (!isVarArgs || new ArrayUtils().isEmpty(args) || args[args.length - 1] != null && !args[args.length - 1].getClass().isArray()) {
            return args == null ? new Object[0] : args;
        }

        final int nonVarArgsCount = args.length - 1;
        Object[] varArgs;
        if (args[nonVarArgsCount] == null) {

            varArgs = new Object[] { null };
        } else {
            varArgs = ArrayEquals.createObjectArray(args[nonVarArgsCount]);
        }
        final int varArgsCount = varArgs.length;
        Object[] newArgs = new Object[nonVarArgsCount + varArgsCount];
        System.arraycopy(args, 0, newArgs, 0, nonVarArgsCount);
        System.arraycopy(varArgs, 0, newArgs, nonVarArgsCount, varArgsCount);
        return newArgs;
    }

    public static List<MockitoMatcher> argumentsToMatchers(Object[] arguments) {
        List<MockitoMatcher> matchers = new ArrayList<MockitoMatcher>(arguments.length);
        for (Object arg : arguments) {
            if (arg != null && arg.getClass().isArray()) {
                matchers.add(new ArrayEquals(arg));
            } else {
                matchers.add(new Equals(arg));
            }
        }
        return matchers;
    }
}

<code block>


package org.mockito.internal.progress;

import org.mockito.MockitoMatcher;
import org.mockito.exceptions.Reporter;
import org.mockito.internal.matchers.And;
import org.mockito.internal.matchers.LocalizedMatcher;
import org.mockito.internal.matchers.Not;
import org.mockito.internal.matchers.Or;

import java.util.*;

@SuppressWarnings("unchecked")
public class ArgumentMatcherStorageImpl implements ArgumentMatcherStorage {

    public static final int TWO_SUB_MATCHERS = 2;
    public static final int ONE_SUB_MATCHER = 1;
    private final Stack<LocalizedMatcher> matcherStack = new Stack<LocalizedMatcher>();
    
    public HandyReturnValues reportMatcher(MockitoMatcher matcher) {
        matcherStack.push(new LocalizedMatcher(matcher));
        return new HandyReturnValues();
    }

    public List<LocalizedMatcher> pullLocalizedMatchers() {
        if (matcherStack.isEmpty()) {
            return Collections.emptyList();
        }
        
        List<LocalizedMatcher> matchers = new ArrayList<LocalizedMatcher>(matcherStack);
        matcherStack.clear();
        return (List) matchers;
    }


    public HandyReturnValues reportAnd() {
        assertStateFor("And(?)", TWO_SUB_MATCHERS);
        And and = new And(popLastArgumentMatchers(TWO_SUB_MATCHERS));
        matcherStack.push(new LocalizedMatcher(and));
        return new HandyReturnValues();
    }


    public HandyReturnValues reportOr() {
        assertStateFor("Or(?)", TWO_SUB_MATCHERS);
        Or or = new Or(popLastArgumentMatchers(TWO_SUB_MATCHERS));
        matcherStack.push(new LocalizedMatcher(or));
        return new HandyReturnValues();
    }


    public HandyReturnValues reportNot() {
        assertStateFor("Not(?)", ONE_SUB_MATCHER);
        Not not = new Not(popLastArgumentMatchers(ONE_SUB_MATCHER).get(0));
        matcherStack.push(new LocalizedMatcher(not));
        return new HandyReturnValues();
    }

    private void assertStateFor(String additionalMatcherName, int subMatchersCount) {
        assertMatchersFoundFor(additionalMatcherName);
        assertIncorrectUseOfAdditionalMatchers(additionalMatcherName, subMatchersCount);
    }

    private List<MockitoMatcher> popLastArgumentMatchers(int count) {
        List<MockitoMatcher> result = new LinkedList<MockitoMatcher>();
        result.addAll(matcherStack.subList(matcherStack.size() - count, matcherStack.size()));
        for (int i = 0; i < count; i++) {
            matcherStack.pop();
        }
        return result;
    }

    private void assertMatchersFoundFor(String additionalMatcherName) {
        if (matcherStack.isEmpty()) {
            matcherStack.clear();
            new Reporter().reportNoSubMatchersFound(additionalMatcherName);
        }
    }

    private void assertIncorrectUseOfAdditionalMatchers(String additionalMatcherName, int count) {
        if(matcherStack.size() < count) {
            ArrayList<LocalizedMatcher> lastMatchers = new ArrayList<LocalizedMatcher>(matcherStack);
            matcherStack.clear();
            new Reporter().incorrectUseOfAdditionalMatchers(additionalMatcherName, count, lastMatchers);
        }
    }


    public void validateState() {
        if (!matcherStack.isEmpty()) {
            ArrayList lastMatchers = new ArrayList<LocalizedMatcher>(matcherStack);
            matcherStack.clear();
            new Reporter().misplacedArgumentMatcher(lastMatchers);
        }
    }


    public void reset() {
        matcherStack.clear();
    }
}
<code block>

package org.mockito.internal.progress;

import org.mockito.MockitoMatcher;
import org.mockito.internal.matchers.LocalizedMatcher;

import java.util.List;

@SuppressWarnings("unchecked")
public interface ArgumentMatcherStorage {

    HandyReturnValues reportMatcher(MockitoMatcher matcher);

    List<LocalizedMatcher> pullLocalizedMatchers();

    HandyReturnValues reportAnd();

    HandyReturnValues reportNot();

    HandyReturnValues reportOr();

    void validateState();

    void reset();

}
<code block>


package org.mockitoutil;

import junit.framework.Assert;
import org.hamcrest.Matcher;
import org.junit.After;
import org.junit.Before;
import org.mockito.MockitoAnnotations;
import org.mockito.StateMaster;
import org.mockito.internal.MockitoCore;
import org.mockito.internal.configuration.ConfigurationAccess;
import org.mockito.internal.invocation.InvocationImpl;
import org.mockito.internal.invocation.SerializableMethod;
import org.mockito.internal.invocation.realmethod.RealMethod;
import org.mockito.internal.util.MockUtil;
import org.mockito.invocation.Invocation;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.util.Collection;

import static org.mockito.Mockito.mock;


@SuppressWarnings("unchecked")
public class TestBase extends Assert {

    @After
    public void cleanUpConfigInAnyCase() {
        ConfigurationAccess.getConfig().overrideCleansStackTrace(false);
        ConfigurationAccess.getConfig().overrideDefaultAnswer(null);
        StateMaster state = new StateMaster();


        state.validate();

        state.reset();
    }

    @Before
    public void init() {
        MockitoAnnotations.initMocks(this);
    }
    
    public static void makeStackTracesClean() {
        ConfigurationAccess.getConfig().overrideCleansStackTrace(true);
    }
    
    public void resetState() {
        new StateMaster().reset();
    }
    
    protected Invocation getLastInvocation() {
        return new MockitoCore().getLastInvocation();
    }


    protected static <T> void assertThat(T o, Assertor<T> a) {
        a.assertValue(o);
    }
    
    protected static <T> void assertThat(T actual, Matcher<T> m) {
        org.junit.Assert.assertThat(actual, m);
    }
    
    protected static <T> void assertThat(String message, T actual, Matcher<T> m) {
        org.junit.Assert.assertThat(message, actual, m);
    }
    
    public static <T> Assertor<String> endsWith(final String substring) {
        return new Assertor<String>() {
            public void assertValue(String value) {
                assertTrue("This substring: \n" + substring + 
                        "\nshould be at the end of:\n" + value
                        , value.endsWith(substring));
            }
        };
    }
    
    public static void assertNotEquals(Object expected, Object got) {
        assertFalse(expected.equals(got));
    }

    public static void assertContains(String sub, String string) {
        assertTrue("\n" +
                "This substring:[" +
                sub +
                "]\n" +
                "should be inside of:[" +
                string +
                "]\n"
                , string.contains(sub));
    }

    public static void assertContainsIgnoringCase(String sub, String string) {
        assertTrue("\n" +
                "This substring:" +
                sub +
                "\n" +
                "should be inside of:" +
                string +
                "\n"
                , containsIgnoringCase(string, sub));
    }

    private static boolean containsIgnoringCase(String string, String sub) {
        int subLength = sub.length();
        if (string.length() < subLength) {
            return false;
        }
        int i = 0;
        while(i+subLength <= string.length()) {
            boolean temp = string.substring(i, i+subLength).equalsIgnoreCase(sub);
            if (temp) {
                return true;
            }
            i++;
        }
        return false;
    }

    public static void assertNotContains(String sub, String string) {
        assertFalse("\n" +
                "This substring:" +
                sub +
                "\n" +
                "should NOT be inside of:" +
                string +
                "\n"
                , string.contains(sub));
    }
    
    protected static Invocation invocationOf(Class<?> type, String methodName, Object ... args) throws NoSuchMethodException {
        Class[] types = new Class[args.length];
        for (int i = 0; i < args.length; i++) {
            types[i] = args[i].getClass();
        }
        return new InvocationImpl(mock(type), new SerializableMethod(type.getMethod(methodName,
                types)), args, 1, null);
    }

    protected static Invocation invocationOf(Class<?> type, String methodName, RealMethod realMethod) throws NoSuchMethodException {
        return new InvocationImpl(new Object(), new SerializableMethod(type.getMethod(methodName,
                new Class[0])), new Object[0], 1, realMethod);
    }

    protected boolean isMock(Object o) {
        return new MockUtil().isMock(o);
    }

    protected void assertContainsType(final Collection<?> list, final Class<?> clazz) {
        for (Object o : list) {
            if (clazz.isAssignableFrom(o.getClass())) {
                return;
            }
        }
        throw new AssertionError("Input list does not contain any element of type: '" + clazz + "'. " +
            "Inspected following elements: " + list);
    }

    protected String getStackTrace(Throwable e) {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        e.printStackTrace(new PrintStream(out));
        try {
            out.close();
        } catch (IOException ex) {}
        return out.toString();
    }
}

<code block>

package org.mockito.internal.verification.argumentmatching;

import org.junit.Test;
import org.mockito.MockitoMatcher;
import org.mockito.internal.matchers.Equals;
import org.mockitoutil.TestBase;

import java.util.Arrays;
import java.util.List;

@SuppressWarnings({"unchecked","serial"})
public class ArgumentMatchingToolTest extends TestBase {

    private ArgumentMatchingTool tool = new ArgumentMatchingTool();

    @Test
    public void shouldNotFindAnySuspiciousMatchersWhenNumberOfArgumentsDoesntMatch() {

        List<MockitoMatcher> matchers = (List) Arrays.asList(new Equals(1));


        Integer[] suspicious = tool.getSuspiciouslyNotMatchingArgsIndexes(matchers, new Object[] {10, 20});
        

        assertEquals(0, suspicious.length);
    }

    @Test
    public void shouldNotFindAnySuspiciousMatchersWhenArgumentsMatch() {

        List<MockitoMatcher> matchers = (List) Arrays.asList(new Equals(10), new Equals(20));
        

        Integer[] suspicious = tool.getSuspiciouslyNotMatchingArgsIndexes(matchers, new Object[] {10, 20});
        

        assertEquals(0, suspicious.length);
    }
    
    @Test
    public void shouldFindSuspiciousMatchers() {

        Equals matcherInt20 = new Equals(20);
        Long longPretendingAnInt = new Long(20);
        

        List<MockitoMatcher> matchers = (List) Arrays.asList(new Equals(10), matcherInt20);
        Integer[] suspicious = tool.getSuspiciouslyNotMatchingArgsIndexes(matchers, new Object[] {10, longPretendingAnInt});
        

        assertEquals(1, suspicious.length);
        assertEquals(new Integer(1), suspicious[0]);
    }
    
    @Test
    public void shouldNotFindSuspiciousMatchersWhenTypesAreTheSame() {

        Equals matcherWithBadDescription = new Equals(20) {
            public String describe() {
                return "10";
            }
        };
        Integer argument = 10;
        

        Integer[] suspicious = tool.getSuspiciouslyNotMatchingArgsIndexes((List) Arrays.asList(matcherWithBadDescription), new Object[] {argument});
        

        assertEquals(0, suspicious.length);
    }
    
    @Test
    public void shouldWorkFineWhenGivenArgIsNull() {

        Integer[] suspicious = tool.getSuspiciouslyNotMatchingArgsIndexes((List) Arrays.asList(new Equals(20)), new Object[] {null});
        

        assertEquals(0, suspicious.length);
    }
    
    @Test
    public void shouldUseMatchersSafely() {

        List<MockitoMatcher> matchers = (List) Arrays.asList(new MockitoMatcher() {
            public boolean matches(Object item) {
                throw new ClassCastException("nasty matcher");
            }
        });
        

        Integer[] suspicious = tool.getSuspiciouslyNotMatchingArgsIndexes(matchers, new Object[] {10});
        

        assertEquals(0, suspicious.length);
    }
}
<code block>

package org.mockito.internal.matchers;

import org.hamcrest.Matcher;
import org.junit.Test;
import org.mockito.MockitoMatcher;
import org.mockitoutil.TestBase;

@SuppressWarnings("unchecked")
public class LocalizedMatcherTest extends TestBase {
    
    @Test
    public void shouldMatchTypesWhenActualMatcherHasCorrectType() throws Exception {

        ContainsTypedDescription equals10 = new Equals(10);
        LocalizedMatcher m = new LocalizedMatcher((MockitoMatcher) equals10);
        

        assertTrue(m.typeMatches(10));
        assertFalse(m.typeMatches(10L));
    }

    @Test
    public void shouldNotMatchTypesWhenActualMatcherDoesNotHaveCorrectType() throws Exception {

        LocalizedMatcher m = new LocalizedMatcher(Any.ANY);
        

        assertFalse(m.typeMatches(10));
    }
    
    @Test
    public void shouldDescribeWithTypeInfoWhenActualMatcherHasCorrectType() throws Exception {

        ContainsTypedDescription equals10 = new Equals(10);
        LocalizedMatcher m = new LocalizedMatcher((MockitoMatcher) equals10);
        

        assertEquals("(Integer) 10", m.getTypedDescription());
    }

    @Test
    public void shouldDescribeStringWithType() throws Exception {

        ContainsTypedDescription e = new Equals("x");
        LocalizedMatcher m = new LocalizedMatcher((MockitoMatcher) e);


        assertEquals("(String) \"x\"", m.getTypedDescription());
    }
    
    @Test
    public void shouldNotDescribeWithTypeInfoWhenActualMatcherDoesNotHaveCorrectType() throws Exception {

        LocalizedMatcher m = new LocalizedMatcher(Any.ANY);
        

        assertEquals(m.describe(), m.getTypedDescription());
    }
    
    @Test
    public void shouldDelegateToCapturingMatcher() throws Exception {

        CapturingMatcher capturingMatcher = new CapturingMatcher();
        LocalizedMatcher m = new LocalizedMatcher(capturingMatcher);
        

        m.captureFrom("boo");
        

        assertEquals("boo", capturingMatcher.getLastValue());
    }
}
<code block>


package org.mockito.internal.matchers;

import org.junit.Test;
import org.mockitoutil.TestBase;

import java.math.BigDecimal;

public class ComparableMatchersTest extends TestBase {

    @Test
    public void testLessThan() {
        test(new LessThan<String>("b"), true, false, false, "lt");
    }

    @Test
    public void testGreaterThan() {
        test(new GreaterThan<String>("b"), false, true, false, "gt");
    }

    @Test
    public void testLessOrEqual() {
        test(new LessOrEqual<String>("b"), true, false, true, "leq");
    }

    @Test
    public void testGreaterOrEqual() {
        test(new GreaterOrEqual<String>("b"), false, true, true, "geq");
    }

    @Test
    public void testCompareEqual() {
        test(new CompareEqual<String>("b"), false, false, true, "cmpEq");


        CompareEqual<BigDecimal> cmpEq = new CompareEqual<BigDecimal>(new BigDecimal("5.00"));
        assertTrue(cmpEq.matches(new BigDecimal("5")));
    }

    private void test(CompareTo<String> compareTo, boolean lower, boolean higher,
            boolean equals, String name) {

        assertEquals(lower, compareTo.matches("a"));
        assertEquals(equals, compareTo.matches("b"));
        assertEquals(higher, compareTo.matches("c"));

        assertEquals(name + "(b)", compareTo.describe());
    }
}

<code block>


package org.mockito.internal.matchers;

import org.junit.Test;
import org.mockitoutil.TestBase;


public class EqualsTest extends TestBase {

    @Test
    public void shouldBeEqual() {
        assertEquals(new Equals(null), new Equals(null));
        assertEquals(new Equals(new Integer(2)), new Equals(new Integer(2)));
        assertFalse(new Equals(null).equals(null));
        assertFalse(new Equals(null).equals("Test"));
        assertEquals(1, new Equals(null).hashCode());
    }

    @Test
    public void shouldArraysBeEqual() {
        assertTrue(new Equals(new int[] {1, 2}).matches(new int[] {1, 2}));
        assertFalse(new Equals(new Object[] {"1"}).matches(new Object[] {"1.0"}));
    }
    
    @Test
    public void shouldDescribeWithExtraTypeInfo() throws Exception {
        String descStr = new Equals(100).getTypedDescription();
        
        assertEquals("(Integer) 100", descStr);
    }

    @Test
    public void shouldDescribeWithExtraTypeInfoOfLong() throws Exception {
        String descStr = new Equals(100L).getTypedDescription();
        
        assertEquals("(Long) 100", descStr);
    }

    @Test
    public void shouldDescribeWithTypeOfString() throws Exception {
        String descStr = new Equals("x").getTypedDescription();

        assertEquals("(String) \"x\"", descStr);
    }
    
    @Test
    public void shouldAppendQuotingForString() {
        String descStr = new Equals("str").describe();
        
        assertEquals("\"str\"", descStr);
    }

    @Test
    public void shouldAppendQuotingForChar() {
        String descStr = new Equals('s').describe();
        
        assertEquals("'s'", descStr);
    }
    
    @Test
    public void shouldDescribeUsingToString() {
        String descStr = new Equals(100).describe();
        
        assertEquals("100", descStr);
    }

    @Test
    public void shouldDescribeNull() {
        String descStr = new Equals(null).describe();
        
        assertEquals("null", descStr);
    }
    
    @Test
    public void shouldMatchTypes() throws Exception {

        ContainsTypedDescription equals = new Equals(10);
        

        assertTrue(equals.typeMatches(10));
        assertFalse(equals.typeMatches(10L));
    }
    
    @Test
    public void shouldMatchTypesSafelyWhenActualIsNull() throws Exception {

        ContainsTypedDescription equals = new Equals(null);
        

        assertFalse(equals.typeMatches(10));
    }

    @Test
    public void shouldMatchTypesSafelyWhenGivenIsNull() throws Exception {

        ContainsTypedDescription equals = new Equals(10);
        

        assertFalse(equals.typeMatches(null));
    }
}
<code block>

package org.mockito.internal.matchers;

import java.util.Arrays;
import java.util.List;

import org.junit.Test;
import org.mockito.internal.matchers.text.MatchersPrinter;
import org.mockito.internal.reporting.PrintSettings;
import org.mockitoutil.TestBase;

@SuppressWarnings("unchecked")
public class MatchersPrinterTest extends TestBase {

    MatchersPrinter printer = new MatchersPrinter();

    @Test
    public void shouldGetArgumentsLine() {
        String line = printer.getArgumentsLine((List) Arrays.asList(new Equals(1), new Equals(2)), new PrintSettings());
        assertEquals("(1, 2);", line);
    }

    @Test
    public void shouldGetArgumentsBlock() {
        String line = printer.getArgumentsBlock((List) Arrays.asList(new Equals(1), new Equals(2)), new PrintSettings());
        assertEquals("(\n    1,\n    2\n);", line);
    }

    @Test
    public void shouldDescribeTypeInfoOnlyMarkedMatchers() {

        String line = printer.getArgumentsLine((List) Arrays.asList(new Equals(1L), new Equals(2)), PrintSettings.verboseMatchers(1));

        assertEquals("(1, (Integer) 2);", line);
    }

    @Test
    public void shouldDescribeStringMatcher() {

        String line = printer.getArgumentsLine((List) Arrays.asList(new Equals(1L), new Equals("x")), PrintSettings.verboseMatchers(1));

        assertEquals("(1, (String) \"x\");", line);
    }

    @Test
    public void shouldGetVerboseArgumentsInBlock() {

        String line = printer.getArgumentsBlock((List) Arrays.asList(new Equals(1L), new Equals(2)), PrintSettings.verboseMatchers(0, 1));

        assertEquals("(\n    (Long) 1,\n    (Integer) 2\n);", line);
    }

    @Test
    public void shouldGetVerboseArgumentsEvenIfSomeMatchersAreNotVerbose() {

        String line = printer.getArgumentsLine((List) Arrays.asList(new Equals(1L), NotNull.NOT_NULL), PrintSettings.verboseMatchers(0));

        assertEquals("((Long) 1, notNull());", line);
    }
}
<code block>


package org.mockito.internal.matchers;

import java.util.ArrayList;
import java.util.List;

import org.hamcrest.Matcher;
import org.junit.Test;
import org.mockito.MockitoMatcher;
import org.mockitoutil.TestBase;

@SuppressWarnings("unchecked")
public class MatchersToStringTest extends TestBase {

    @Test
    public void sameToStringWithString() {
        assertEquals("same(\"X\")", new Same("X").describe());
    }

    @Test
    public void nullToString() {
        assertEquals("isNull()", Null.NULL.describe());
    }

    @Test
    public void notNullToString() {
        assertEquals("notNull()", NotNull.NOT_NULL.describe());
    }

    @Test
    public void anyToString() {
        assertEquals("<any>", Any.ANY.describe());
    }

    @Test
    public void sameToStringWithChar() {
        assertEquals("same('x')", new Same('x').describe());
    }

    @Test
    public void sameToStringWithObject() {
        Object o = new Object() {
            @Override
            public String toString() {
                return "X";
            }
        };
        assertEquals("same(X)", new Same(o).describe());
    }

    @Test
    public void equalsToStringWithString() {
        assertEquals("\"X\"", new Equals("X").describe());

    }

    @Test
    public void equalsToStringWithChar() {
        assertEquals("'x'", new Equals('x').describe());
    }

    @Test
    public void equalsToStringWithObject() {
        Object o = new Object() {
            @Override
            public String toString() {
                return "X";
            }
        };
        assertEquals("X", new Equals(o).describe());
    }

    @Test
    public void orToString() {
        List<MockitoMatcher> matchers = new ArrayList<MockitoMatcher>();
        matchers.add(new Equals(1));
        matchers.add(new Equals(2));
        assertEquals("or(1, 2)", new Or(matchers).describe());
    }

    @Test
    public void notToString() {
        assertEquals("not(1)", new Not(new Equals(1)).describe());
    }

    @Test
    public void andToString() {
        List<MockitoMatcher> matchers = new ArrayList<MockitoMatcher>();
        matchers.add(new Equals(1));
        matchers.add(new Equals(2));
        assertEquals("and(1, 2)", new And(matchers).describe());
    }

    @Test
    public void startsWithToString() {
        assertEquals("startsWith(\"AB\")", new StartsWith("AB").describe());
    }

    @Test
    public void endsWithToString() {
        assertEquals("endsWith(\"AB\")", new EndsWith("AB").describe());
    }

    @Test
    public void containsToString() {
        assertEquals("contains(\"AB\")", new Contains("AB").describe());
    }

    @Test
    public void findToString() {
        assertEquals("find(\"\\\\s+\")", new Find("\\s+").describe());
    }

    @Test
    public void matchesToString() {
        assertEquals("matches(\"\\\\s+\")", new Matches("\\s+").describe());
    }

}

<code block>


package org.mockito.internal.invocation;

import org.fest.assertions.Assertions;
import org.hamcrest.Matcher;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoMatcher;
import org.mockito.internal.matchers.*;
import org.mockito.invocation.Invocation;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;

import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static java.util.Arrays.asList;

@SuppressWarnings("unchecked")
public class InvocationMatcherTest extends TestBase {

    private InvocationMatcher simpleMethod;
    @Mock private IMethods mock;

    @Before
    public void setup() {
        simpleMethod = new InvocationBuilder().mock(mock).simpleMethod().toInvocationMatcher();
    }

    @Test
    public void should_be_a_citizen_of_hashes() throws Exception {
        Invocation invocation = new InvocationBuilder().toInvocation();
        Invocation invocationTwo = new InvocationBuilder().args("blah").toInvocation();

        Map map = new HashMap();
        map.put(new InvocationMatcher(invocation), "one");
        map.put(new InvocationMatcher(invocationTwo), "two");

        assertEquals(2, map.size());
    }

    @Test
    public void should_not_equal_if_number_of_arguments_differ() throws Exception {
        InvocationMatcher withOneArg = new InvocationMatcher(new InvocationBuilder().args("test").toInvocation());
        InvocationMatcher withTwoArgs = new InvocationMatcher(new InvocationBuilder().args("test", 100).toInvocation());

        assertFalse(withOneArg.equals(null));
        assertFalse(withOneArg.equals(withTwoArgs));
    }

    @Test
    public void should_to_string_with_matchers() throws Exception {
        MockitoMatcher m = NotNull.NOT_NULL;
        InvocationMatcher notNull = new InvocationMatcher(new InvocationBuilder().toInvocation(), asList(m));
        MockitoMatcher mTwo = new Equals('x');
        InvocationMatcher equals = new InvocationMatcher(new InvocationBuilder().toInvocation(), asList(mTwo));

        assertContains("simpleMethod(notNull())", notNull.toString());
        assertContains("simpleMethod('x')", equals.toString());
    }

    @Test
    public void should_know_if_is_similar_to() throws Exception {
        Invocation same = new InvocationBuilder().mock(mock).simpleMethod().toInvocation();
        assertTrue(simpleMethod.hasSimilarMethod(same));

        Invocation different = new InvocationBuilder().mock(mock).differentMethod().toInvocation();
        assertFalse(simpleMethod.hasSimilarMethod(different));
    }

    @Test
    public void should_not_be_similar_to_verified_invocation() throws Exception {
        Invocation verified = new InvocationBuilder().simpleMethod().verified().toInvocation();
        assertFalse(simpleMethod.hasSimilarMethod(verified));
    }

    @Test
    public void should_not_be_similar_if_mocks_are_different() throws Exception {
        Invocation onDifferentMock = new InvocationBuilder().simpleMethod().mock("different mock").toInvocation();
        assertFalse(simpleMethod.hasSimilarMethod(onDifferentMock));
    }

    @Test
    public void should_not_be_similar_if_is_overloaded_but_used_with_the_same_arg() throws Exception {
        Method method = IMethods.class.getMethod("simpleMethod", String.class);
        Method overloadedMethod = IMethods.class.getMethod("simpleMethod", Object.class);

        String sameArg = "test";

        InvocationMatcher invocation = new InvocationBuilder().method(method).arg(sameArg).toInvocationMatcher();
        Invocation overloadedInvocation = new InvocationBuilder().method(overloadedMethod).arg(sameArg).toInvocation();

        assertFalse(invocation.hasSimilarMethod(overloadedInvocation));
    }

    @Test
    public void should_be_similar_if_is_overloaded_but_used_with_different_arg() throws Exception {
        Method method = IMethods.class.getMethod("simpleMethod", String.class);
        Method overloadedMethod = IMethods.class.getMethod("simpleMethod", Object.class);

        InvocationMatcher invocation = new InvocationBuilder().mock(mock).method(method).arg("foo").toInvocationMatcher();
        Invocation overloadedInvocation = new InvocationBuilder().mock(mock).method(overloadedMethod).arg("bar").toInvocation();

        assertTrue(invocation.hasSimilarMethod(overloadedInvocation));
    }

    @Test
    public void should_capture_arguments_from_invocation() throws Exception {

        Invocation invocation = new InvocationBuilder().args("1", 100).toInvocation();
        CapturingMatcher capturingMatcher = new CapturingMatcher();
        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals("1"), capturingMatcher));


        invocationMatcher.captureArgumentsFrom(invocation);


        assertEquals(1, capturingMatcher.getAllValues().size());
        assertEquals(100, capturingMatcher.getLastValue());
    }

    @Test
    public void should_match_varargs_using_any_varargs() throws Exception {

        mock.varargs("1", "2");
        Invocation invocation = getLastInvocation();
        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(AnyVararg.ANY_VARARG));


        boolean match = invocationMatcher.matches(invocation);


        assertTrue(match);
    }

    @Test
    public void should_capture_varargs_as_vararg() throws Exception {

        mock.mixedVarargs(1, "a", "b");
        Invocation invocation = getLastInvocation();
        CapturingMatcher m = new CapturingMatcher();
        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(1), new LocalizedMatcher(m)));


        invocationMatcher.captureArgumentsFrom(invocation);


        Assertions.assertThat(m.getAllValues()).containsExactly("a", "b");
    }

    @Test  
    public void should_capture_arguments_when_args_count_does_NOT_match() throws Exception {

        mock.varargs();
        Invocation invocation = getLastInvocation();


        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new LocalizedMatcher(AnyVararg.ANY_VARARG)));


        invocationMatcher.captureArgumentsFrom(invocation);
    }

    @Test
    public void should_create_from_invocations() throws Exception {

        Invocation i = new InvocationBuilder().toInvocation();

        List<InvocationMatcher> out = InvocationMatcher.createFrom(asList(i));

        assertEquals(1, out.size());
        assertEquals(i, out.get(0).getInvocation());
    }
}
<code block>

package org.mockitousage.matchers;

import static org.mockito.Matchers.argThat;
import static org.mockito.Mockito.verify;

import org.junit.Test;
import org.mockito.ArgumentMatcher;
import org.mockito.Mock;
import org.mockito.MockitoMatcher;
import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;

public class CustomMatcherDoesYieldCCETest extends TestBase {

    @Mock private IMethods mock;

    @Test
    public void shouldNotThrowCCE() {
        mock.simpleMethod(new Object());

        try {


            verify(mock).simpleMethod(argThat(isStringWithTextFoo()));
            fail();
        } catch (ArgumentsAreDifferent e) {}
    }

    private MockitoMatcher<String> isStringWithTextFoo() {
        return new MockitoMatcher<String>() {
            @Override
            public boolean matches(Object argument) {

                String str = (String) argument;
                return str.equals("foo");
            }
        };
    }
}
<code block>


package org.mockitousage.matchers;

import static org.mockito.Matchers.*;
import static org.mockito.Mockito.*;

import org.junit.Before;
import org.junit.Test;
import org.mockito.ArgumentMatcher;
import org.mockito.Mockito;
import org.mockito.MockitoMatcher;
import org.mockitousage.IMethods;
import org.mockitoutil.TestBase;

public class CustomMatchersTest extends TestBase {
    
    private final class ContainsFoo extends MockitoMatcher<String> {
        public boolean matches(Object arg) {
            return ((String) arg).contains("foo");
        }
    }

    private final class IsAnyBoolean extends MockitoMatcher<Boolean> {
        public boolean matches(Object arg) {
            return true;
        }
    }
    
    private final class IsSorZ extends MockitoMatcher<Character> {
        public boolean matches(Object arg) {
            Character character = (Character) arg;
            return character.equals('s') || character.equals('z');
        }
    }

    private final class IsZeroOrOne<T extends Number> extends MockitoMatcher<T> {
        public boolean matches(Object arg) {
            Number number = (Number) arg;
            if (number.intValue() == 0 || number.intValue() == 1) {
                return true;
            }
            return false;
        }
    }

    private IMethods mock;

    @Before
    public void setUp() {
        mock = Mockito.mock(IMethods.class);
    }

    @Test
    public void shouldUseCustomBooleanMatcher() {
        when(mock.oneArg(booleanThat(new IsAnyBoolean()))).thenReturn("foo");
        
        assertEquals("foo", mock.oneArg(true));
        assertEquals("foo", mock.oneArg(false));
        
        assertEquals(null, mock.oneArg("x"));
    }
    
    @Test
    public void shouldUseCustomCharMatcher() {
        when(mock.oneArg(charThat(new IsSorZ()))).thenReturn("foo");
      
        assertEquals("foo", mock.oneArg('s'));
        assertEquals("foo", mock.oneArg('z'));
        assertEquals(null, mock.oneArg('x'));
    }
    
    class Article {
        
        private int pageNumber;
        private String headline;
        
        public Article(int pageNumber, String headline) {
            super();
            this.pageNumber = pageNumber;
            this.headline = headline;
        }

        public int getPageNumber() {
            return pageNumber;
        }

        public String getHeadline() {
            return headline;
        }
    }
    
    @Test
    public void shouldUseCustomPrimitiveNumberMatchers() {
        when(mock.oneArg(byteThat(new IsZeroOrOne<Byte>()))).thenReturn("byte");
        when(mock.oneArg(shortThat(new IsZeroOrOne<Short>()))).thenReturn("short");
        when(mock.oneArg(intThat(new IsZeroOrOne<Integer>()))).thenReturn("int");
        when(mock.oneArg(longThat(new IsZeroOrOne<Long>()))).thenReturn("long");
        when(mock.oneArg(floatThat(new IsZeroOrOne<Float>()))).thenReturn("float");
        when(mock.oneArg(doubleThat(new IsZeroOrOne<Double>()))).thenReturn("double");
        
        assertEquals("byte", mock.oneArg((byte) 0));
        assertEquals("short", mock.oneArg((short) 1));
        assertEquals("int", mock.oneArg(0));
        assertEquals("long", mock.oneArg(1L));
        assertEquals("float", mock.oneArg(0F));
        assertEquals("double", mock.oneArg(1.0));
        
        assertEquals(null, mock.oneArg(2));
        assertEquals(null, mock.oneArg("foo"));
    }
         
    @Test
    public void shouldUseCustomObjectMatcher() {
        when(mock.oneArg(argThat(new ContainsFoo()))).thenReturn("foo");
        
        assertEquals("foo", mock.oneArg("foo"));
        assertEquals(null, mock.oneArg("bar"));
    }
    
    @Test
    public void shouldCustomMatcherPrintDescriptionBasedOnName() {
        mock.simpleMethod("foo");

        try {
            verify(mock).simpleMethod(containsTest());
            fail();
        } catch (AssertionError e) {
            assertContains("<String that contains xxx>", e.getMessage());
        }
    }

    private String containsTest() {
        return argThat(new StringThatContainsXxx());
    }
    
    private final class StringThatContainsXxx extends MockitoMatcher<String> {
        public boolean matches(Object argument) {
            String arg = (String) argument;
            return arg.contains("xxx");
        }
    }
    
    @Test
    public void shouldAnonymousCustomMatcherPrintDefaultDescription() {
        mock.simpleMethod("foo");

        try {
            verify(mock).simpleMethod((String) argThat(new MockitoMatcher<Object>() {
                @Override public boolean matches(Object argument) {
                    return false;
                }}));
            fail();
        } catch (AssertionError e) {
            assertContains("<custom argument matcher>", e.getMessage());
            assertContains("foo", e.getMessage());
        }
    }
}
<code block>


package org.mockitousage.matchers;

import org.mockitoutil.TestBase;

public class HamcrestMatchersTest extends TestBase {




}
<code block>
package org.mockitousage.bugs;

import org.hamcrest.Matcher;
import org.junit.Test;
import org.mockito.MockitoMatcher;
import org.mockito.internal.matchers.EqualsWithDelta;

import static org.fest.assertions.Assertions.assertThat;

public class EqualsWithDeltaTest {

    @Test
    public void testEqualsWithDelta_NullExpected() throws Exception {
        MockitoMatcher<Number> matcher = equalsWithDelta(null);
        assertThat(matcher.matches(1.0)).isFalse();
    }

    @Test
    public void testEqualsWithDelta_NullActual() throws Exception {
        MockitoMatcher<Number> matcher = equalsWithDelta(1.0);
        assertThat(matcher.matches(null)).isFalse();
    }

    @Test
    public void testEqualsWithDelta_NullActualAndExpected() throws Exception {
        MockitoMatcher<Number> matcher = equalsWithDelta(null);
        assertThat(matcher.matches(null)).isTrue();
    }

    @Test
    public void testEqualsWithDelta_WhenActualAndExpectedAreTheSameObject() throws Exception {
        Double expected = 1.0;
        Double actual = expected;
        MockitoMatcher<Number> matcher = equalsWithDelta(expected);
        assertThat(matcher.matches(actual)).isTrue();
    }

    public MockitoMatcher<Number> equalsWithDelta(final Double expected) {
        return new EqualsWithDelta(expected, .000001);
    }
}
<code block>
package org.mockito.internal.creation.bytebuddy;

import net.bytebuddy.ByteBuddy;
import net.bytebuddy.ClassFileVersion;
import net.bytebuddy.dynamic.DynamicType;
import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
import net.bytebuddy.dynamic.scaffold.subclass.ConstructorStrategy;
import net.bytebuddy.implementation.attribute.MethodAttributeAppender;
import net.bytebuddy.implementation.attribute.TypeAttributeAppender;
import org.mockito.internal.creation.bytebuddy.ByteBuddyCrossClassLoaderSerializationSupport.CrossClassLoaderSerializableMock;
import org.mockito.internal.creation.util.SearchingClassLoader;

import java.util.Random;

import static net.bytebuddy.description.modifier.FieldManifestation.FINAL;
import static net.bytebuddy.description.modifier.Ownership.STATIC;
import static net.bytebuddy.description.modifier.Visibility.PRIVATE;
import static net.bytebuddy.implementation.FieldAccessor.ofBeanProperty;
import static net.bytebuddy.implementation.MethodDelegation.to;
import static net.bytebuddy.implementation.MethodDelegation.toInstanceField;
import static net.bytebuddy.matcher.ElementMatchers.*;

class MockBytecodeGenerator {
    private final ByteBuddy byteBuddy;
    private final Random random;

    public MockBytecodeGenerator() {
        byteBuddy = new ByteBuddy(ClassFileVersion.JAVA_V5)

                .withDefaultMethodAttributeAppender(MethodAttributeAppender.ForInstrumentedMethod.INSTANCE)
                .withAttribute(TypeAttributeAppender.ForSuperType.INSTANCE);

        random = new Random();
    }

    public <T> Class<? extends T> generateMockClass(MockFeatures<T> features) {
        DynamicType.Builder<T> builder =
                byteBuddy.subclass(features.mockedType, ConstructorStrategy.Default.IMITATE_SUPER_TYPE)
                         .name(nameFor(features.mockedType))
                         .implement(features.interfaces.toArray(new Class<?>[features.interfaces.size()]))
                         .method(any()).intercept(toInstanceField(MockMethodInterceptor.class, "mockitoInterceptor")
                                                          .filter(isDeclaredBy(MockMethodInterceptor.class)))
                         .implement(MockMethodInterceptor.MockAccess.class).intercept(ofBeanProperty())
                         .method(isHashCode()).intercept(to(MockMethodInterceptor.ForHashCode.class))
                         .method(isEquals()).intercept(to(MockMethodInterceptor.ForEquals.class))
                         .defineField("serialVersionUID", long.class, STATIC, PRIVATE, FINAL).value(42L);
        if (features.crossClassLoaderSerializable) {
            builder = builder.implement(CrossClassLoaderSerializableMock.class)
                             .intercept(to(MockMethodInterceptor.ForWriteReplace.class));
        }
        Class<?>[] allMockedTypes = new Class<?>[features.interfaces.size() + 1];
        allMockedTypes[0] = features.mockedType;

        int index = 1;
        for (Class<?> type : features.interfaces) {
            allMockedTypes[index++] = type;
        }
        return builder.make()
                      .load(SearchingClassLoader.combineLoadersOf(allMockedTypes), ClassLoadingStrategy.Default.INJECTION)
                      .getLoaded();
    }


    private String nameFor(Class<?> type) {
        String typeName = type.getName();
        if (isComingFromJDK(type)
                || isComingFromSignedJar(type)
                || isComingFromSealedPackage(type)) {
            typeName = "codegen." + typeName;
        }
        return String.format("%s$%s$%d", typeName, "MockitoMock", Math.abs(random.nextInt()));
    }

    private boolean isComingFromJDK(Class<?> type) {



        return type.getPackage() != null && "Java Runtime Environment".equalsIgnoreCase(type.getPackage().getImplementationTitle())
                || type.getName().startsWith("java.")
                || type.getName().startsWith("javax.");
    }

    private boolean isComingFromSealedPackage(Class<?> type) {
        return type.getPackage() != null && type.getPackage().isSealed();
    }

    private boolean isComingFromSignedJar(Class<?> type) {
        return type.getSigners() != null;
    }
}

<code block>
package org.mockito.internal.creation.bytebuddy;

import java.io.ObjectStreamException;
import java.io.Serializable;
import java.lang.reflect.Method;
import java.util.concurrent.Callable;
import org.mockito.internal.InternalMockHandler;
import org.mockito.internal.creation.DelegatingMethod;
import org.mockito.internal.invocation.MockitoMethod;
import org.mockito.internal.invocation.SerializableMethod;
import org.mockito.internal.progress.SequenceNumber;
import org.mockito.invocation.MockHandler;
import org.mockito.mock.MockCreationSettings;
import net.bytebuddy.implementation.bind.annotation.AllArguments;
import net.bytebuddy.implementation.bind.annotation.Argument;
import net.bytebuddy.implementation.bind.annotation.BindingPriority;
import net.bytebuddy.implementation.bind.annotation.DefaultCall;
import net.bytebuddy.implementation.bind.annotation.Origin;
import net.bytebuddy.implementation.bind.annotation.RuntimeType;
import net.bytebuddy.implementation.bind.annotation.SuperCall;
import net.bytebuddy.implementation.bind.annotation.This;

public class MockMethodInterceptor implements Serializable {

    private static final long serialVersionUID = 7152947254057253027L;

    private final InternalMockHandler handler;
    private final MockCreationSettings mockCreationSettings;

    private final ByteBuddyCrossClassLoaderSerializationSupport serializationSupport;

    public MockMethodInterceptor(InternalMockHandler handler, MockCreationSettings mockCreationSettings) {
        this.handler = handler;
        this.mockCreationSettings = mockCreationSettings;
        serializationSupport = new ByteBuddyCrossClassLoaderSerializationSupport();
    }

    @RuntimeType
    @BindingPriority(BindingPriority.DEFAULT * 3)
    public Object interceptSuperCallable(@This Object mock,
                                         @Origin(cache = true) Method invokedMethod,
                                         @AllArguments Object[] arguments,
                                         @SuperCall(serializableProxy = true) Callable<?> superCall) throws Throwable {
        return doIntercept(
                mock,
                invokedMethod,
                arguments,
                new InterceptedInvocation.SuperMethod.FromCallable(superCall)
        );
    }

    @RuntimeType
    @BindingPriority(BindingPriority.DEFAULT * 2)
    public Object interceptDefaultCallable(@This Object mock,
                                           @Origin(cache = true) Method invokedMethod,
                                           @AllArguments Object[] arguments,
                                           @DefaultCall(serializableProxy = true) Callable<?> superCall) throws Throwable {
        return doIntercept(
                mock,
                invokedMethod,
                arguments,
                new InterceptedInvocation.SuperMethod.FromCallable(superCall)
        );
    }

    @RuntimeType
    public Object interceptAbstract(@This Object mock,
                                    @Origin(cache = true) Method invokedMethod,
                                    @AllArguments Object[] arguments) throws Throwable {
        return doIntercept(
                mock,
                invokedMethod,
                arguments,
                InterceptedInvocation.SuperMethod.IsIllegal.INSTANCE
        );
    }

    private Object doIntercept(Object mock,
                               Method invokedMethod,
                               Object[] arguments,
                               InterceptedInvocation.SuperMethod superMethod) throws Throwable {
        return handler.handle(new InterceptedInvocation(
                mock,
                createMockitoMethod(invokedMethod),
                arguments,
                superMethod,
                SequenceNumber.next()
        ));
    }

    private MockitoMethod createMockitoMethod(Method method) {
        if (mockCreationSettings.isSerializable()) {
            return new SerializableMethod(method);
        } else {
            return new DelegatingMethod(method);
        }
    }

    public MockHandler getMockHandler() {
        return handler;
    }

    public ByteBuddyCrossClassLoaderSerializationSupport getSerializationSupport() {
        return serializationSupport;
    }

    public static class ForHashCode {
        public static int doIdentityHashCode(@This Object thiz) {
            return System.identityHashCode(thiz);
        }
    }

    public static class ForEquals {
        public static boolean doIdentityEquals(@This Object thiz, @Argument(0) Object other) {
            return thiz == other;
        }
    }

    public static class ForWriteReplace {
        public static Object doWriteReplace(@This MockAccess thiz) throws ObjectStreamException {
            return thiz.getMockitoInterceptor().getSerializationSupport().writeReplace(thiz);
        }
    }

    public static interface MockAccess {
        MockMethodInterceptor getMockitoInterceptor();
        void setMockitoInterceptor(MockMethodInterceptor mockMethodInterceptor);
    }
}

<code block>
package org.mockito.internal.creation.bytebuddy;

import net.bytebuddy.ByteBuddy;
import net.bytebuddy.ClassFileVersion;
import net.bytebuddy.dynamic.DynamicType;
import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
import net.bytebuddy.dynamic.scaffold.subclass.ConstructorStrategy;
import net.bytebuddy.implementation.FieldAccessor;
import net.bytebuddy.implementation.Implementation;
import net.bytebuddy.implementation.MethodDelegation;
import net.bytebuddy.implementation.attribute.MethodAttributeAppender;
import net.bytebuddy.implementation.attribute.TypeAttributeAppender;
import net.bytebuddy.implementation.bind.annotation.FieldProxy;
import org.mockito.internal.creation.bytebuddy.ByteBuddyCrossClassLoaderSerializationSupport.CrossClassLoaderSerializableMock;
import org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.InterceptionDispatcher;
import org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.InterceptionDispatcher.FieldGetter;
import org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.InterceptionDispatcher.FieldSetter;
import org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.MockAccess;
import org.mockito.internal.creation.util.SearchingClassLoader;

import java.util.Random;

import static net.bytebuddy.description.modifier.FieldManifestation.FINAL;
import static net.bytebuddy.description.modifier.Ownership.STATIC;
import static net.bytebuddy.description.modifier.Visibility.PRIVATE;
import static net.bytebuddy.implementation.MethodDelegation.to;
import static net.bytebuddy.matcher.ElementMatchers.*;

class MockBytecodeGenerator {
    private final ByteBuddy byteBuddy;
    private final Random random;
    private final Implementation delegation;

    public MockBytecodeGenerator() {
        byteBuddy = new ByteBuddy(ClassFileVersion.JAVA_V5)
                .withDefaultMethodAttributeAppender(MethodAttributeAppender.ForInstrumentedMethod.INSTANCE)
                .withAttribute(TypeAttributeAppender.ForSuperType.INSTANCE);

        delegation = MethodDelegation.to(InterceptionDispatcher.class)
                                     .appendParameterBinder(FieldProxy.Binder.install(FieldGetter.class,
                                                                                      FieldSetter.class));
        random = new Random();
    }

    public <T> Class<? extends T> generateMockClass(MockFeatures<T> features) {
        DynamicType.Builder<T> builder =
                byteBuddy.subclass(features.mockedType, ConstructorStrategy.Default.IMITATE_SUPER_TYPE)
                         .name(nameFor(features.mockedType))
                         .implement(features.interfaces.toArray(new Class<?>[features.interfaces.size()]))
                         .method(any()).intercept(delegation)
                         .defineField("mockitoInterceptor", MockMethodInterceptor.class, PRIVATE)
                         .implement(MockAccess.class).intercept(FieldAccessor.ofBeanProperty())
                         .method(isHashCode()).intercept(to(MockMethodInterceptor.ForHashCode.class))
                         .method(isEquals()).intercept(to(MockMethodInterceptor.ForEquals.class))
                         .defineField("serialVersionUID", long.class, STATIC, PRIVATE, FINAL).value(42L);
        if (features.crossClassLoaderSerializable) {
            builder = builder.implement(CrossClassLoaderSerializableMock.class)
                             .intercept(to(MockMethodInterceptor.ForWriteReplace.class));
        }
        return builder.make()
                      .load(SearchingClassLoader.combineLoadersOf(allMockedTypes(features)), ClassLoadingStrategy.Default.INJECTION)
                      .getLoaded();
    }

    private <T> Class<?>[] allMockedTypes(MockFeatures<T> features) {
        Class<?>[] allMockedTypes = new Class<?>[features.interfaces.size() + 1];
        allMockedTypes[0] = features.mockedType;
        System.arraycopy(features.interfaces.toArray(), 0,
                         (Object[]) allMockedTypes, 1, features.interfaces.size());
        return allMockedTypes;
    }


    private String nameFor(Class<?> type) {
        String typeName = type.getName();
        if (isComingFromJDK(type)
                || isComingFromSignedJar(type)
                || isComingFromSealedPackage(type)) {
            typeName = "codegen." + typeName;
        }
        return String.format("%s$%s$%d", typeName, "MockitoMock", Math.abs(random.nextInt()));
    }

    private boolean isComingFromJDK(Class<?> type) {



        return type.getPackage() != null && "Java Runtime Environment".equalsIgnoreCase(type.getPackage().getImplementationTitle())
                || type.getName().startsWith("java.")
                || type.getName().startsWith("javax.");
    }

    private boolean isComingFromSealedPackage(Class<?> type) {
        return type.getPackage() != null && type.getPackage().isSealed();
    }

    private boolean isComingFromSignedJar(Class<?> type) {
        return type.getSigners() != null;
    }
}

<code block>
package org.mockito.internal.creation.bytebuddy;

import net.bytebuddy.implementation.bind.annotation.*;
import org.mockito.internal.InternalMockHandler;
import org.mockito.internal.creation.DelegatingMethod;
import org.mockito.internal.invocation.MockitoMethod;
import org.mockito.internal.invocation.SerializableMethod;
import org.mockito.internal.progress.SequenceNumber;
import org.mockito.invocation.MockHandler;
import org.mockito.mock.MockCreationSettings;

import java.io.ObjectStreamException;
import java.io.Serializable;
import java.lang.reflect.Method;
import java.util.concurrent.Callable;

public class MockMethodInterceptor implements Serializable {

    private static final long serialVersionUID = 7152947254057253027L;

    private final InternalMockHandler handler;
    private final MockCreationSettings mockCreationSettings;

    private final ByteBuddyCrossClassLoaderSerializationSupport serializationSupport;

    public MockMethodInterceptor(InternalMockHandler handler, MockCreationSettings mockCreationSettings) {
        this.handler = handler;
        this.mockCreationSettings = mockCreationSettings;
        serializationSupport = new ByteBuddyCrossClassLoaderSerializationSupport();
    }

    @RuntimeType
    @BindingPriority(BindingPriority.DEFAULT * 3)
    public Object interceptSuperCallable(@This Object mock,
                                         @Origin(cache = true) Method invokedMethod,
                                         @AllArguments Object[] arguments,
                                         @SuperCall(serializableProxy = true) Callable<?> superCall) throws Throwable {
        return doIntercept(
                mock,
                invokedMethod,
                arguments,
                new InterceptedInvocation.SuperMethod.FromCallable(superCall)
        );
    }

    @RuntimeType
    @BindingPriority(BindingPriority.DEFAULT * 2)
    public Object interceptDefaultCallable(@This Object mock,
                                           @Origin(cache = true) Method invokedMethod,
                                           @AllArguments Object[] arguments,
                                           @DefaultCall(serializableProxy = true) Callable<?> superCall) throws Throwable {
        return doIntercept(
                mock,
                invokedMethod,
                arguments,
                new InterceptedInvocation.SuperMethod.FromCallable(superCall)
        );
    }

    @RuntimeType
    public Object interceptAbstract(@This Object mock,
                                    @Origin(cache = true) Method invokedMethod,
                                    @AllArguments Object[] arguments) throws Throwable {
        return doIntercept(
                mock,
                invokedMethod,
                arguments,
                InterceptedInvocation.SuperMethod.IsIllegal.INSTANCE
        );
    }

    private Object doIntercept(Object mock,
                               Method invokedMethod,
                               Object[] arguments,
                               InterceptedInvocation.SuperMethod superMethod) throws Throwable {
        return handler.handle(new InterceptedInvocation(
                mock,
                createMockitoMethod(invokedMethod),
                arguments,
                superMethod,
                SequenceNumber.next()
        ));
    }

    private MockitoMethod createMockitoMethod(Method method) {
        if (mockCreationSettings.isSerializable()) {
            return new SerializableMethod(method);
        } else {
            return new DelegatingMethod(method);
        }
    }

    public MockHandler getMockHandler() {
        return handler;
    }

    public ByteBuddyCrossClassLoaderSerializationSupport getSerializationSupport() {
        return serializationSupport;
    }

    public static class ForHashCode {
        public static int doIdentityHashCode(@This Object thiz) {
            return System.identityHashCode(thiz);
        }
    }

    public static class ForEquals {
        public static boolean doIdentityEquals(@This Object thiz, @Argument(0) Object other) {
            return thiz == other;
        }
    }

    public static class ForWriteReplace {
        public static Object doWriteReplace(@This MockAccess thiz) throws ObjectStreamException {
            return thiz.getMockitoInterceptor().getSerializationSupport().writeReplace(thiz);
        }
    }

    public interface MockAccess {
        MockMethodInterceptor getMockitoInterceptor();
        void setMockitoInterceptor(MockMethodInterceptor mockMethodInterceptor);
    }

    public static class InterceptionDispatcher {
        public interface FieldGetter<T> {
            T getValue();
        }
        public interface FieldSetter<T> {
            void setValue(T value);
        }

        @RuntimeType
        @BindingPriority(BindingPriority.DEFAULT * 2)
        public static Object interceptSuperCallable(@This Object mock,
                                                    @FieldProxy("mockitoInterceptor") FieldGetter<MockMethodInterceptor> fieldGetter,
                                                    @Origin Method invokedMethod,
                                                    @AllArguments Object[] arguments,
                                                    @SuperCall(serializableProxy = true) Callable<?> superCall) throws Throwable {
            MockMethodInterceptor interceptor = fieldGetter.getValue();
            if (interceptor == null) {
                return null;
            }
            return interceptor.doIntercept(
                    mock,
                    invokedMethod,
                    arguments,
                    new InterceptedInvocation.SuperMethod.FromCallable(superCall)
            );
        }

        @RuntimeType
        public static Object interceptAbstract(@This Object mock,
                                               @FieldProxy("mockitoInterceptor") FieldGetter<MockMethodInterceptor> fieldGetter,
                                               @Origin(cache = true) Method invokedMethod,
                                               @AllArguments Object[] arguments) throws Throwable {
            MockMethodInterceptor interceptor = fieldGetter.getValue();
            if (interceptor == null) {
                return null;
            }
            return interceptor.doIntercept(
                    mock,
                    invokedMethod,
                    arguments,
                    InterceptedInvocation.SuperMethod.IsIllegal.INSTANCE
            );
        }
    }
}
