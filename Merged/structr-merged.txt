
package org.structr.rest.resource;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.servlet.http.HttpServletRequest;
import org.structr.common.CaseHelper;
import org.structr.common.SecurityContext;
import org.structr.common.error.FrameworkException;
import org.structr.core.GraphObject;
import org.structr.core.GraphObjectMap;
import org.structr.core.Result;
import org.structr.core.app.StructrApp;
import org.structr.core.converter.PropertyConverter;
import org.structr.core.entity.AbstractRelationship;
import org.structr.core.entity.Relation;
import org.structr.core.entity.SchemaNode;
import org.structr.core.entity.SchemaNodeLocalization;
import org.structr.core.entity.SchemaProperty;
import org.structr.core.entity.SchemaPropertyLocalization;
import org.structr.core.property.BooleanProperty;
import org.structr.core.property.GenericProperty;
import org.structr.core.property.LongProperty;
import org.structr.core.property.PropertyKey;
import org.structr.core.property.RelationProperty;
import org.structr.core.property.StringProperty;
import org.structr.core.property.UuidProperty;
import org.structr.rest.RestMethodResult;
import org.structr.rest.exception.IllegalMethodException;
import org.structr.schema.SchemaHelper;



public class SchemaTypeResource extends Resource {

	protected Class entityClass = null;
	protected String rawType = null;
	protected HttpServletRequest request = null;
	protected TypeResource typeResource = null;
	private String propertyView = null;

	
	public SchemaTypeResource(SecurityContext securityContext, TypeResource typeResource) {
		this.securityContext = securityContext;
		this.typeResource = typeResource;
		this.rawType = typeResource.getRawType();
	}

	@Override
	public boolean checkAndConfigure(String part, SecurityContext securityContext, HttpServletRequest request) throws FrameworkException {

		return true;

	}

	@Override
	public Result doGet(PropertyKey sortKey, boolean sortDescending, int pageSize, int page, String offsetId) throws FrameworkException {

		List<GraphObjectMap> resultList = new LinkedList<>();

		
		Class type = typeResource.getEntityClass();
		if (type != null) {

			SchemaNode schemaNode = null;
			try {

				schemaNode = StructrApp.getInstance().nodeQuery(SchemaNode.class).andName(type.getSimpleName()).getFirst();

			} catch (FrameworkException ex) {

				Logger.getLogger(SchemaTypeResource.class.getName()).log(Level.SEVERE, "Error looking up SchemaNode - cannot display labels for properties!", ex);
			}

			if (propertyView != null) {

				for (final Map.Entry<String, Object> entry : getPropertiesForView(type, propertyView, schemaNode).entrySet()) {

					final GraphObjectMap property = new GraphObjectMap();

					for (final Map.Entry<String, Object> prop : ((Map<String, Object>) entry.getValue()).entrySet()) {

						property.setProperty(new GenericProperty(prop.getKey()), prop.getValue());
					}

					resultList.add(property);
				}

			} else {

				final GraphObjectMap schema = new GraphObjectMap();

				resultList.add(schema);

				String url = "/".concat(CaseHelper.toUnderscore(rawType, false));

				schema.setProperty(new StringProperty("url"), url);
				schema.setProperty(new StringProperty("type"), type.getSimpleName());
				schema.setProperty(new StringProperty("className"), type.getName());
				schema.setProperty(new BooleanProperty("isRel"), AbstractRelationship.class.isAssignableFrom(type));
				schema.setProperty(new LongProperty("flags"), SecurityContext.getResourceFlags(rawType));

				if (schemaNode != null) {
					final List<SchemaNodeLocalization> nodeLocalizations = schemaNode.localizations.getProperty(securityContext, schemaNode, false);
					final List<GraphObjectMap> localizationsMap = new ArrayList<>(nodeLocalizations.size());

					for (final SchemaNodeLocalization loc : nodeLocalizations) {

						final GraphObjectMap tmpMap = new GraphObjectMap();
						tmpMap.setProperty(new UuidProperty(), loc.getProperty(SchemaNodeLocalization.id));
						tmpMap.setProperty(new StringProperty("locale"), loc.getProperty(SchemaNodeLocalization.locale));
						tmpMap.setProperty(new StringProperty("name"), loc.getProperty(SchemaNodeLocalization.name));
						localizationsMap.add(tmpMap);

					}

					schema.setProperty(new GenericProperty("localizations"), localizationsMap);
				}

				Set<String> propertyViews = new LinkedHashSet<>(StructrApp.getConfiguration().getPropertyViews());

				
				Map<String, Map<String, Object>> views = new TreeMap();
				schema.setProperty(new GenericProperty("views"), views);

				for (String view : propertyViews) {

					views.put(view, getPropertiesForView(type, view, schemaNode));

				}

			}

		}

		return new Result(resultList, resultList.size(), false, false);

	}

	@Override
	public RestMethodResult doPost(Map<String, Object> propertySet) throws FrameworkException {

		throw new IllegalMethodException();

	}

	@Override
	public Resource tryCombineWith(Resource next) throws FrameworkException {

		if (next instanceof ViewFilterResource) {

			propertyView = ((ViewFilterResource) next).getPropertyView();
		}

		return this;
	}

	
	@Override
	public String getUriPart() {

		return rawType;

	}

	public String getRawType() {

		return rawType;

	}

	@Override
	public Class getEntityClass() {

		return entityClass;

	}

	@Override
	public String getResourceSignature() {

		return SchemaResource.UriPart._schema.name().concat("/").concat(SchemaHelper.normalizeEntityName(getUriPart()));

	}

	@Override
	public boolean isCollectionResource() {

		return true;

	}

	private Map<String, Object> getPropertiesForView(final Class type, final String view, final SchemaNode schemaNode) throws FrameworkException {

		final Set<PropertyKey> properties = new LinkedHashSet<>(StructrApp.getConfiguration().getPropertySet(type, view));
		final Map<String, Object> propertyConverterMap = new LinkedHashMap<>();

		List<SchemaProperty> schemaProperties = getSchemaProperties(schemaNode);

		for (PropertyKey property : properties) {

			final Map<String, Object> propProperties = new LinkedHashMap();

			propProperties.put("dbName", property.dbName());
			propProperties.put("jsonName", property.jsonName());
			propProperties.put("className", property.getClass().getName());

			final Class declaringClass = property.getDeclaringClass();

			propProperties.put("declaringClass", declaringClass.getSimpleName());
			propProperties.put("defaultValue", property.defaultValue());
			if (property instanceof StringProperty) {
				propProperties.put("contentType", ((StringProperty) property).contentType());
			}
			propProperties.put("format", property.format());
			propProperties.put("readOnly", property.isReadOnly());
			propProperties.put("system", property.isUnvalidated());
			propProperties.put("indexed", property.isIndexed());
			propProperties.put("indexedWhenEmpty", property.isIndexedWhenEmpty());
			propProperties.put("unique", property.isUnique());
			propProperties.put("notNull", property.isNotNull());
			propProperties.put("dynamic", property.isDynamic());

			if ((schemaProperties == null || schemaProperties.isEmpty()) && !declaringClass.equals(type)) {
				
				
				schemaProperties = getSchemaProperties(StructrApp.getInstance().nodeQuery(SchemaNode.class).andName(declaringClass.getSimpleName()).getFirst());
				
			}
			
			if (property.isDynamic() && schemaProperties != null) {

				for (final SchemaProperty sProp : schemaProperties) {

					if (sProp.getName().equals(property.jsonName())) {

						final List<SchemaPropertyLocalization> propertyLocalizations = sProp.localizations.getProperty(securityContext, sProp, false);
						final List<GraphObjectMap> localizationsMap = new ArrayList<>(propertyLocalizations.size());

						for (final SchemaPropertyLocalization loc : propertyLocalizations) {

							final GraphObjectMap tmpMap = new GraphObjectMap();
							tmpMap.setProperty(new UuidProperty(), loc.getProperty(SchemaPropertyLocalization.id));
							tmpMap.setProperty(new StringProperty("locale"), loc.getProperty(SchemaPropertyLocalization.locale));
							tmpMap.setProperty(new StringProperty("name"), loc.getProperty(SchemaPropertyLocalization.name));
							localizationsMap.add(tmpMap);

						}

						propProperties.put("localizations", localizationsMap);
						break;

					}

				}

			}

			final Class<? extends GraphObject> relatedType = property.relatedType();
			if (relatedType != null) {

				propProperties.put("relatedType", relatedType.getName());
				propProperties.put("type", relatedType.getSimpleName());

			} else {

				propProperties.put("type", property.typeName());
			}
			propProperties.put("isCollection", property.isCollection());

			final PropertyConverter databaseConverter = property.databaseConverter(securityContext, null);
			final PropertyConverter inputConverter = property.inputConverter(securityContext);

			if (databaseConverter != null) {

				propProperties.put("databaseConverter", databaseConverter.getClass().getName());
			}

			if (inputConverter != null) {

				propProperties.put("inputConverter", inputConverter.getClass().getName());
			}

			
			if (declaringClass != null && property instanceof RelationProperty) {

				Relation relation = ((RelationProperty) property).getRelation();
				if (relation != null) {

					propProperties.put("relationshipType", relation.name());
				}
			}

			propertyConverterMap.put(property.jsonName(), propProperties);
		}

		return propertyConverterMap;
	}
	
	private List<SchemaProperty> getSchemaProperties(final SchemaNode schemaNode) {
		
		final List<SchemaProperty> schemaProperties = new LinkedList<>();
		
		if (schemaNode != null) {
			
			schemaProperties.addAll(schemaNode.schemaProperties.getProperty(securityContext, schemaNode, false));
			
		}
		
		return schemaProperties;
	}
}

<code block>

package org.structr.rest.resource;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.servlet.http.HttpServletRequest;
import org.structr.common.CaseHelper;
import org.structr.common.SecurityContext;
import org.structr.common.error.FrameworkException;
import org.structr.core.GraphObject;
import org.structr.core.GraphObjectMap;
import org.structr.core.Result;
import org.structr.core.app.StructrApp;
import org.structr.core.converter.PropertyConverter;
import org.structr.core.entity.AbstractRelationship;
import org.structr.core.entity.Relation;
import org.structr.core.entity.SchemaNode;
import org.structr.core.entity.SchemaNodeLocalization;
import org.structr.core.entity.SchemaProperty;
import org.structr.core.entity.SchemaPropertyLocalization;
import org.structr.core.property.BooleanProperty;
import org.structr.core.property.GenericProperty;
import org.structr.core.property.LongProperty;
import org.structr.core.property.PropertyKey;
import org.structr.core.property.RelationProperty;
import org.structr.core.property.StringProperty;
import org.structr.core.property.UuidProperty;
import org.structr.rest.RestMethodResult;
import org.structr.rest.exception.IllegalMethodException;
import org.structr.schema.SchemaHelper;



public class SchemaTypeResource extends Resource {

	protected Class entityClass = null;
	protected String rawType = null;
	protected HttpServletRequest request = null;
	protected TypeResource typeResource = null;
	private String propertyView = null;

	
	public SchemaTypeResource(SecurityContext securityContext, TypeResource typeResource) {
		this.securityContext = securityContext;
		this.typeResource = typeResource;
		this.rawType = typeResource.getRawType();
	}

	@Override
	public boolean checkAndConfigure(String part, SecurityContext securityContext, HttpServletRequest request) throws FrameworkException {

		return true;

	}

	@Override
	public Result doGet(PropertyKey sortKey, boolean sortDescending, int pageSize, int page, String offsetId) throws FrameworkException {

		List<GraphObjectMap> resultList = new LinkedList<>();

		
		Class type = typeResource.getEntityClass();
		if (type != null) {

			SchemaNode schemaNode = null;
			try {

				schemaNode = StructrApp.getInstance().nodeQuery(SchemaNode.class).andName(type.getSimpleName()).getFirst();

			} catch (FrameworkException ex) {

				Logger.getLogger(SchemaTypeResource.class.getName()).log(Level.SEVERE, "Error looking up SchemaNode - cannot display labels for properties!", ex);
			}

			if (propertyView != null) {

				for (final Map.Entry<String, Object> entry : getPropertiesForView(type, propertyView, schemaNode).entrySet()) {

					final GraphObjectMap property = new GraphObjectMap();

					for (final Map.Entry<String, Object> prop : ((Map<String, Object>) entry.getValue()).entrySet()) {

						property.setProperty(new GenericProperty(prop.getKey()), prop.getValue());
					}

					resultList.add(property);
				}

			} else {

				final GraphObjectMap schema = new GraphObjectMap();

				resultList.add(schema);

				String url = "/".concat(CaseHelper.toUnderscore(rawType, false));

				schema.setProperty(new StringProperty("url"), url);
				schema.setProperty(new StringProperty("type"), type.getSimpleName());
				schema.setProperty(new StringProperty("className"), type.getName());
				schema.setProperty(new BooleanProperty("isRel"), AbstractRelationship.class.isAssignableFrom(type));
				schema.setProperty(new LongProperty("flags"), SecurityContext.getResourceFlags(rawType));

				if (schemaNode != null) {
					final List<SchemaNodeLocalization> nodeLocalizations = schemaNode.localizations.getProperty(securityContext, schemaNode, false);
					final List<GraphObjectMap> localizationsMap = new ArrayList<>(nodeLocalizations.size());

					for (final SchemaNodeLocalization loc : nodeLocalizations) {

						final GraphObjectMap tmpMap = new GraphObjectMap();
						tmpMap.setProperty(new UuidProperty(), loc.getProperty(SchemaNodeLocalization.id));
						tmpMap.setProperty(new StringProperty("locale"), loc.getProperty(SchemaNodeLocalization.locale));
						tmpMap.setProperty(new StringProperty("name"), loc.getProperty(SchemaNodeLocalization.name));
						localizationsMap.add(tmpMap);

					}

					schema.setProperty(new GenericProperty("localizations"), localizationsMap);
				}

				Set<String> propertyViews = new LinkedHashSet<>(StructrApp.getConfiguration().getPropertyViews());

				
				Map<String, Map<String, Object>> views = new TreeMap();
				schema.setProperty(new GenericProperty("views"), views);

				for (String view : propertyViews) {

					views.put(view, getPropertiesForView(type, view, schemaNode));

				}

			}

		}

		return new Result(resultList, resultList.size(), false, false);

	}

	@Override
	public RestMethodResult doPost(Map<String, Object> propertySet) throws FrameworkException {

		throw new IllegalMethodException();

	}

	@Override
	public Resource tryCombineWith(Resource next) throws FrameworkException {

		if (next instanceof ViewFilterResource) {

			propertyView = ((ViewFilterResource) next).getPropertyView();
		}

		return this;
	}

	
	@Override
	public String getUriPart() {

		return rawType;

	}

	public String getRawType() {

		return rawType;

	}

	@Override
	public Class getEntityClass() {

		return entityClass;

	}

	@Override
	public String getResourceSignature() {

		return SchemaResource.UriPart._schema.name().concat("/").concat(SchemaHelper.normalizeEntityName(getUriPart()));

	}

	@Override
	public boolean isCollectionResource() {

		return true;

	}

	private Map<String, Object> getPropertiesForView(final Class type, final String view, SchemaNode schemaNode) throws FrameworkException {

		final Set<PropertyKey> properties = new LinkedHashSet<>(StructrApp.getConfiguration().getPropertySet(type, view));
		final Map<String, Object> propertyConverterMap = new LinkedHashMap<>();

		List<SchemaProperty> schemaProperties = null;
		if (schemaNode != null) {

			schemaProperties = schemaNode.schemaProperties.getProperty(securityContext, schemaNode, false);

		}

		for (PropertyKey property : properties) {

			final Map<String, Object> propProperties = new LinkedHashMap();

			propProperties.put("dbName", property.dbName());
			propProperties.put("jsonName", property.jsonName());
			propProperties.put("className", property.getClass().getName());

			final Class declaringClass = property.getDeclaringClass();

			propProperties.put("declaringClass", declaringClass.getSimpleName());
			propProperties.put("defaultValue", property.defaultValue());
			if (property instanceof StringProperty) {
				propProperties.put("contentType", ((StringProperty) property).contentType());
			}
			propProperties.put("format", property.format());
			propProperties.put("readOnly", property.isReadOnly());
			propProperties.put("system", property.isUnvalidated());
			propProperties.put("indexed", property.isIndexed());
			propProperties.put("indexedWhenEmpty", property.isIndexedWhenEmpty());
			propProperties.put("unique", property.isUnique());
			propProperties.put("notNull", property.isNotNull());
			propProperties.put("dynamic", property.isDynamic());

			if (property.isDynamic() && schemaProperties != null) {

				for (final SchemaProperty sProp : schemaProperties) {

					if (sProp.getName().equals(property.jsonName())) {

						final List<SchemaPropertyLocalization> propertyLocalizations = sProp.localizations.getProperty(securityContext, sProp, false);
						final List<GraphObjectMap> localizationsMap = new ArrayList<>(propertyLocalizations.size());

						for (final SchemaPropertyLocalization loc : propertyLocalizations) {

							final GraphObjectMap tmpMap = new GraphObjectMap();
							tmpMap.setProperty(new UuidProperty(), loc.getProperty(SchemaPropertyLocalization.id));
							tmpMap.setProperty(new StringProperty("locale"), loc.getProperty(SchemaPropertyLocalization.locale));
							tmpMap.setProperty(new StringProperty("name"), loc.getProperty(SchemaPropertyLocalization.name));
							localizationsMap.add(tmpMap);

						}

						propProperties.put("localizations", localizationsMap);
						break;

					}

				}

			}

			final Class<? extends GraphObject> relatedType = property.relatedType();
			if (relatedType != null) {

				propProperties.put("relatedType", relatedType.getName());
				propProperties.put("type", relatedType.getSimpleName());

			} else {

				propProperties.put("type", property.typeName());
			}
			propProperties.put("isCollection", property.isCollection());

			final PropertyConverter databaseConverter = property.databaseConverter(securityContext, null);
			final PropertyConverter inputConverter = property.inputConverter(securityContext);

			if (databaseConverter != null) {

				propProperties.put("databaseConverter", databaseConverter.getClass().getName());
			}

			if (inputConverter != null) {

				propProperties.put("inputConverter", inputConverter.getClass().getName());
			}

			
			if (declaringClass != null && property instanceof RelationProperty) {

				Relation relation = ((RelationProperty) property).getRelation();
				if (relation != null) {

					propProperties.put("relationshipType", relation.name());
				}
			}

			propertyConverterMap.put(property.jsonName(), propProperties);
		}

		return propertyConverterMap;
	}
}

<code block>

package org.structr.core;

import java.io.File;
import java.io.IOException;
import java.net.URI;
import java.nio.file.Files;
import java.util.Arrays;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.commons.configuration.ConfigurationException;
import org.apache.commons.configuration.PropertiesConfiguration;
import org.apache.commons.lang3.RandomStringUtils;
import org.apache.commons.lang3.StringUtils;
import org.neo4j.graphdb.GraphDatabaseService;
import org.neo4j.graphdb.Node;
import org.neo4j.graphdb.Relationship;
import org.neo4j.tooling.GlobalGraphOperations;
import org.structr.common.Permission;
import org.structr.common.Permissions;
import org.structr.common.SecurityContext;
import org.structr.common.StructrConf;
import org.structr.core.app.App;
import org.structr.core.app.StructrApp;
import org.structr.core.graph.NodeFactory;
import org.structr.core.graph.NodeInterface;
import org.structr.core.graph.NodeService;
import org.structr.core.graph.RelationshipFactory;
import org.structr.core.graph.RelationshipInterface;
import org.structr.core.graph.Tx;
import org.structr.core.property.StringProperty;
import org.structr.module.JarConfigurationProvider;
import org.structr.schema.ConfigurationProvider;




public class Services {

	private static final Logger logger                              = Logger.getLogger(StructrApp.class.getName());
	private static StructrConf baseConf                             = null;

	
	public static final String INITIAL_SEED_FILE                    = "seed.zip";
	public static final String BASE_PATH                            = "base.path";
	public static final String CONFIGURED_SERVICES                  = "configured.services";
	public static final String CONFIG_FILE_PATH                     = "configfile.path";
	public static final String DATABASE_PATH                        = "database.path";
	public static final String FILES_PATH                           = "files.path";
	public static final String DATA_EXCHANGE_PATH                   = "data.exchange.path";
	public static final String LOG_DATABASE_PATH                    = "log.database.path";
	public static final String FOREIGN_TYPE                         = "foreign.type.key";
	public static final String NEO4J_SHELL_ENABLED                  = "neo4j.shell.enabled";
	public static final String NEO4J_SHELL_PORT                     = "neo4j.shell.port";
	public static final String NEO4J_PAGE_CACHE_MEMORY              = "neo4j.pagecache.memory";
	public static final String LOG_SERVICE_INTERVAL                 = "structr.logging.interval";
	public static final String LOG_SERVICE_THRESHOLD                = "structr.logging.threshold";
	public static final String SERVER_IP                            = "server.ip";
	public static final String SMTP_HOST                            = "smtp.host";
	public static final String SMTP_PORT                            = "smtp.port";
	public static final String SMTP_USER                            = "smtp.user";
	public static final String SMTP_PASSWORD                        = "smtp.password";
	public static final String SMTP_USE_TLS                         = "smtp.tls.enabled";
	public static final String SMTP_REQUIRE_TLS                     = "smtp.tls.required";
	public static final String SUPERUSER_USERNAME                   = "superuser.username";
	public static final String SUPERUSER_PASSWORD                   = "superuser.password";
	public static final String TCP_PORT                             = "tcp.port";
	public static final String TMP_PATH                             = "tmp.path";
	public static final String UDP_PORT                             = "udp.port";
	public static final String JSON_INDENTATION                     = "json.indentation";
	public static final String JSON_REDUNDANCY_REDUCTION            = "json.redundancyReduction";
	public static final String GEOCODING_PROVIDER                   = "geocoding.provider";
	public static final String GEOCODING_LANGUAGE                   = "geocoding.language";
	public static final String GEOCODING_APIKEY                     = "geocoding.apikey";
	public static final String CONFIGURATION                        = "configuration.provider";
	public static final String TESTING                              = "testing";
	public static final String MIGRATION_KEY                        = "NodeService.migration";
	public static final String ACCESS_CONTROL_MAX_AGE               = "access.control.max.age";
	public static final String ACCESS_CONTROL_ALLOW_METHODS         = "access.control.allow.methods";
	public static final String ACCESS_CONTROL_ALLOW_HEADERS         = "access.control.allow.headers";
	public static final String ACCESS_CONTROL_ALLOW_CREDENTIALS     = "access.control.allow.credentials";
	public static final String ACCESS_CONTROL_EXPOSE_HEADERS        = "access.control.expose.headers";
	public static final String APPLICATION_SESSION_TIMEOUT          = "application.session.timeout";
	public static final String APPLICATION_SECURITY_OWNERLESS_NODES = "application.security.ownerless.nodes";
	public static final String APPLICATION_UUID_CACHE_SIZE          = "application.cache.uuid.size";
	public static final String APPLICATION_NODE_CACHE_SIZE          = "application.cache.node.size";
	public static final String APPLICATION_REL_CACHE_SIZE           = "application.cache.relationship.size";
	public static final String SNAPSHOT_PATH                        = "snapshot.path";
	public static final String WEBSOCKET_FRONTEND_ACCESS            = "WebSocketServlet.frontendAccess";

	
	private static int globalSessionTimeout            = -1;
	private static Services singletonInstance          = null;

	
	private final List<InitializationCallback> callbacks       = new LinkedList<>();
	private final Set<Permission> permissionsForOwnerlessNodes = new LinkedHashSet<>();
	private final Map<String, Object> attributes               = new ConcurrentHashMap<>(10, 0.9f, 8);
	private final Map<Class, Service> serviceCache             = new ConcurrentHashMap<>(10, 0.9f, 8);
	private final Set<Class> registeredServiceClasses          = new LinkedHashSet<>();
	private final Set<String> configuredServiceClasses         = new LinkedHashSet<>();
	private StructrConf structrConf                            = new StructrConf();
	private ConfigurationProvider configuration                = null;
	private boolean initializationDone                         = false;
	private boolean shutdownDone                               = false;
	private String configuredServiceNames                      = null;
	private String configurationClass                          = null;

	private Services() { }

	public static Services getInstance() {

		if (singletonInstance == null) {

			singletonInstance = new Services();
			singletonInstance.initialize();

			new Thread(new Runnable() {

				@Override
				public void run() {

					
					try { Thread.sleep(1000); } catch (Throwable ignore) {}

					
					for (final InitializationCallback callback : singletonInstance.callbacks) {
						callback.initializationDone();
					}
				}

			}).start();

		}

		return singletonInstance;
	}

	public static Services getInstance(final StructrConf properties) {

		if (singletonInstance == null) {

			singletonInstance = new Services();
			singletonInstance.initialize(properties);
		}

		return singletonInstance;
	}

	
	public <T extends Command> T command(SecurityContext securityContext, Class<T> commandType) {

		Class serviceClass = null;
		T command          = null;

		try {

			command = commandType.newInstance();
			command.setSecurityContext(securityContext);

			serviceClass = command.getServiceClass();

			if ((serviceClass != null) && configuredServiceClasses.contains(serviceClass.getSimpleName())) {

				
				Service service = serviceCache.get(serviceClass);

				if (service == null) {

					
					service = createService(serviceClass);

				} else {

					
					if (service instanceof RunnableService) {

						RunnableService runnableService = (RunnableService) service;

						if (!runnableService.isRunning()) {

							runnableService.stopService();
							runnableService.shutdown();
							service = createService(serviceClass);
						}
					}
				}

				logger.log(Level.FINEST, "Initializing command ", commandType.getName());
				service.injectArguments(command);
			}

		} catch (Throwable t) {

			t.printStackTrace();

			logger.log(Level.SEVERE, "Exception while creating command " + commandType.getName(), t);
		}

		return (command);
	}

	private void initialize() {

		final StructrConf config = getBaseConfiguration();

		
		final String configTemplateFileName = "structr.conf_templ";
		final String configFileName         = "structr.conf";
		final File configTemplateFile       = new File(configTemplateFileName);
		final File configFile               = new File(configFileName);

		if (!configFile.exists() && !configTemplateFile.exists()) {

			logger.log(Level.SEVERE, "Unable to create config file, {0} and {1} do not exist, aborting. Please create a {0} configuration file and try again.", new Object[] { configFileName, configTemplateFileName } );

			
			System.exit(1);
		}

		if (!configFile.exists() && configTemplateFile.exists()) {

			logger.log(Level.WARNING, "Configuration file {0} not found, copying from template {1}. Please adapt newly created {0} to your needs.", new Object[] { configFileName, configTemplateFileName } );

			try {
				Files.copy(configTemplateFile.toPath(), configFile.toPath());

			} catch (IOException ioex) {

				logger.log(Level.SEVERE, "Unable to create config file, copying of template failed.", ioex);

				System.exit(1);
			}
		}

		logger.log(Level.INFO, "Reading {0}..", configFileName);

		try {




			PropertiesConfiguration.setDefaultListDelimiter('\0');
			final PropertiesConfiguration propConf = new PropertiesConfiguration(configFileName);

			structrConf.load(propConf);

		} catch (ConfigurationException ex) {
			logger.log(Level.SEVERE, null, ex);
		}

		mergeConfiguration(config, structrConf);

		initialize(config);
	}

	private void initialize(final StructrConf properties) {

		this.structrConf = properties;

		configurationClass     = properties.getProperty(Services.CONFIGURATION);
		configuredServiceNames = properties.getProperty(Services.CONFIGURED_SERVICES);

		
		configuredServiceClasses.addAll(Arrays.asList(configuredServiceNames.split("[ ,]+")));

		
		
		
		getConfigurationProvider();

		logger.log(Level.INFO, "Starting services");

		
		for (final String serviceClassName : configuredServiceClasses) {

				Class serviceClass = getServiceClassForName(serviceClassName);
				if (serviceClass != null) {

					try {

						final Service service = createService(serviceClass);
						if (service != null) {

							service.initialized();

						} else {

							logger.log(Level.WARNING, "Service {0} was not started!", serviceClassName);
						}

					} catch (Throwable t) {

						logger.log(Level.WARNING, "Exception while registering service {0}: {1}", new Object[] { serviceClassName, t });
						t.printStackTrace();
					}
				}
		}

		logger.log(Level.INFO, "{0} service(s) processed", serviceCache.size());
		registeredServiceClasses.clear();

		
		if (getService(NodeService.class) != null) {

			if ("true".equals(properties.getProperty(Services.MIGRATION_KEY))) {
				migrateDatabase();
			}
		}

		logger.log(Level.INFO, "Registering shutdown hook.");

		
		Runtime.getRuntime().addShutdownHook(new Thread() {

			@Override
			public void run() {

				shutdown();
			}
		});

		
		final String configForOwnerlessNodes = this.structrConf.getProperty(Services.APPLICATION_SECURITY_OWNERLESS_NODES, "read");
		if (StringUtils.isNotBlank(configForOwnerlessNodes)) {

			for (final String permission : configForOwnerlessNodes.split("[, ]+")) {

				final String trimmed = permission.trim();
				if (StringUtils.isNotBlank(trimmed)) {

					final Permission val = Permissions.valueOf(trimmed);
					if (val != null) {

						permissionsForOwnerlessNodes.add(val);

					} else {

						logger.log(Level.WARNING, "Invalid permisson {0}, ignoring.", trimmed);
					}
				}
			}

		} else {

			
			permissionsForOwnerlessNodes.add(Permission.read);
		}

		logger.log(Level.INFO, "Initialization complete");

		initializationDone = true;
	}

	public void registerInitializationCallback(final InitializationCallback callback) {
		callbacks.add(callback);
	}

	public boolean isInitialized() {
		return initializationDone;
	}

	public void shutdown() {

		initializationDone = false;

		if (!shutdownDone) {

			System.out.println("INFO: Shutting down...");
			for (Service service : serviceCache.values()) {

				try {

					if (service instanceof RunnableService) {

						RunnableService runnableService = (RunnableService) service;

						if (runnableService.isRunning()) {
							runnableService.stopService();
						}
					}

					service.shutdown();

				} catch (Throwable t) {

					System.out.println("WARNING: Failed to shut down " + service.getName() + ": " + t.getMessage());
				}
			}

			serviceCache.clear();

			
			configuration.shutdown();

			
			singletonInstance = null;

			System.out.println("INFO: Shutdown complete");

			
			shutdownDone = true;
		}

	}

	
	public void registerServiceClass(Class serviceClass) {

		registeredServiceClasses.add(serviceClass);










	}

	public String getConfigurationValue(String key) {
		return getConfigurationValue(key, "");
	}

	public String getConfigurationValue(String key, String defaultValue) {
		return getCurrentConfig().getProperty(key, defaultValue);
	}

	public Class getServiceClassForName(final String serviceClassName) {

		for (Class serviceClass : registeredServiceClasses) {

			if (serviceClass.getSimpleName().equals(serviceClassName)) {
				return serviceClass;
			}

		}

		return null;
	}

	public ConfigurationProvider getConfigurationProvider() {

		
		if (configuration == null) {

			
			
			
			
			try {

				configuration = (ConfigurationProvider)Class.forName(configurationClass).newInstance();
				configuration.initialize();

			} catch (Throwable t) {

				t.printStackTrace();

				logger.log(Level.SEVERE, "Unable to instantiate schema provider of type {0}: {1}", new Object[] { configurationClass, t.getMessage() });
			}
		}

		return configuration;
	}

	
	public void setAttribute(final String name, final Object value) {
		synchronized (attributes) {
			attributes.put(name, value);
		}
	}

	
	public Object getAttribute(final String name) {
		return attributes.get(name);
	}

	
	public void removeAttribute(final String name) {
		attributes.remove(name);
	}

	private Service createService(Class serviceClass) {

		logger.log(Level.FINE, "Creating service ", serviceClass.getName());

		Service service = null;

		try {

			service = (Service) serviceClass.newInstance();
			service.initialize(getCurrentConfig());

			if (service instanceof RunnableService) {

				RunnableService runnableService = (RunnableService) service;

				if (runnableService.runOnStartup()) {

					logger.log(Level.FINER, "Starting RunnableService instance ", serviceClass.getName());

					
					runnableService.startService();
					serviceCache.put(serviceClass, service);
				}

			} else if (service instanceof SingletonService) {

				
				serviceCache.put(serviceClass, service);
			}

		} catch (Throwable t) {

			t.printStackTrace();

			if (service.isVital()) {

				logger.log(Level.SEVERE, "Vital service {0} failed to start: {1}. Aborting", new Object[] { service.getClass().getSimpleName(), t.getMessage() } );

				
				System.exit(1);

			} else {

				logger.log(Level.SEVERE, "Service {0} failed to start: {1}.", new Object[] { service.getClass().getSimpleName(), t.getMessage() } );
			}
		}

		return service;
	}

	
	public List<Service> getServices() {

		List<Service> services = new LinkedList<>();
		for (Service service : serviceCache.values()) {
			services.add(service);
		}

		return services;
	}

	public <T extends Service> T getService(final Class<T> type) {
		return (T) serviceCache.get(type);
	}

	public String getConfigValue(final Map<String, String> config, final String key, final String defaultValue) {

		String value = StringUtils.strip(config.get(key));

		if (value != null) {
			return value;
		}

		return defaultValue;
	}

	
	public boolean isReady(final Class serviceClass) {
                Service service = serviceCache.get(serviceClass);
                return (service != null && service.isRunning());
	}

	public StructrConf getCurrentConfig() {
		return structrConf;
	}

	public Set<String> getResources() {

		final Set<String> resources = new LinkedHashSet<>();

		
		for (final Object configurationValue : structrConf.values()) {

			for (final String value : configurationValue.toString().split("[\\s ,;]+")) {

				try {

					
					final Class candidate = Class.forName(value);
					if (!candidate.getName().startsWith("org.structr")) {

						final String codeLocation = candidate.getProtectionDomain().getCodeSource().getLocation().toString();
						if (codeLocation.startsWith("file:") && codeLocation.endsWith(".jar") || codeLocation.endsWith(".war")) {

							final File file = new File(URI.create(codeLocation));
							if (file.exists()) {

								resources.add(file.getAbsolutePath());
							}
						}
					}

				} catch (Throwable ignore) { }
			}
		}

		logger.log(Level.INFO, "Found {0} possible resources: {1}", new Object[] { resources.size(), resources } );

		return resources;
	}

	public static StructrConf getBaseConfiguration() {

		if (baseConf == null) {

			baseConf = new StructrConf();

			baseConf.setProperty(CONFIGURATION,             JarConfigurationProvider.class.getName());
			baseConf.setProperty(CONFIGURED_SERVICES,       "NodeService AgentService CronService SchemaService");
			baseConf.setProperty(NEO4J_SHELL_ENABLED,       "true");
			baseConf.setProperty(NEO4J_SHELL_PORT,          "1337");
			baseConf.setProperty(JSON_INDENTATION,          "true");

			baseConf.setProperty(SUPERUSER_USERNAME,        "superadmin");
			baseConf.setProperty(SUPERUSER_PASSWORD,        RandomStringUtils.randomAlphanumeric(12));

			baseConf.setProperty(BASE_PATH,                 "");
			baseConf.setProperty(TMP_PATH,                  "/tmp");
			baseConf.setProperty(DATABASE_PATH,             System.getProperty("user.dir").concat("/db"));
			baseConf.setProperty(FILES_PATH,                System.getProperty("user.dir").concat("/files"));
			baseConf.setProperty(LOG_DATABASE_PATH,         System.getProperty("user.dir").concat("/logDb.dat"));

			baseConf.setProperty(SMTP_HOST,                 "localhost");
			baseConf.setProperty(SMTP_PORT,                 "25");
			baseConf.setProperty(TCP_PORT,                  "54555");
			baseConf.setProperty(UDP_PORT,                  "57555");
		}

		return baseConf;
	}

	public static void mergeConfiguration(final StructrConf baseConfig, final StructrConf additionalConfig) {
		baseConfig.putAll(additionalConfig);
		trim(baseConfig);
	}


	private void migrateDatabase() {

		final GraphDatabaseService graphDb     = getService(NodeService.class).getGraphDb();
		final SecurityContext superUserContext = SecurityContext.getSuperUserInstance();
		final NodeFactory nodeFactory          = new NodeFactory(superUserContext);
		final RelationshipFactory relFactory   = new RelationshipFactory(superUserContext);
		final App app                          = StructrApp.getInstance();
		final StringProperty uuidProperty      = new StringProperty("uuid");
		final int txLimit                      = 2000;

		boolean hasChanges                     = true;
		int actualNodeCount                    = 0;
		int actualRelCount                     = 0;

		logger.log(Level.INFO, "Migration of ID properties from uuid to id requested.");

		while (hasChanges) {

			hasChanges = false;

			try (final Tx tx = app.tx(false, false)) {

				
				final Iterator<Node> allNodes = GlobalGraphOperations.at(graphDb).getAllNodes().iterator();
				while (allNodes.hasNext()) {

					final Node node = allNodes.next();

					
					if (node.hasProperty("uuid") && node.getProperty("uuid") instanceof String && !node.hasProperty("id")) {

						try {
							final NodeInterface nodeInterface = nodeFactory.instantiate(node);
							final String uuid = nodeInterface.getProperty(uuidProperty);

							if (uuid != null) {

								nodeInterface.setProperty(GraphObject.id, uuid);
								nodeInterface.removeProperty(uuidProperty);
								actualNodeCount++;
								hasChanges = true;
							}

						} catch (Throwable t) {
							t.printStackTrace();
						}
					}

					
					if (hasChanges && (actualNodeCount % txLimit) == 0) {
						break;
					}
				}

				tx.success();

			} catch (Throwable t) {

				t.printStackTrace();
			}

			logger.log(Level.INFO, "Migrated {0} nodes so far.", actualNodeCount);
		}

		logger.log(Level.INFO, "Migrated {0} nodes to new ID property.", actualNodeCount);

		
		hasChanges = true;
		while (hasChanges) {

			hasChanges = false;

			try (final Tx tx = app.tx(false, false)) {

				final Iterator<Relationship> allRels = GlobalGraphOperations.at(graphDb).getAllRelationships().iterator();
				while (allRels.hasNext()) {

					final Relationship rel = allRels.next();

					
					if (rel.hasProperty("uuid") && rel.getProperty("uuid") instanceof String && !rel.hasProperty("id")) {

						try {
							final RelationshipInterface relInterface = relFactory.instantiate(rel);
							final String uuid = relInterface.getProperty(uuidProperty);

							if (uuid != null) {
								relInterface.setProperty(GraphObject.id, uuid);
								relInterface.removeProperty(uuidProperty);
								actualRelCount++;
								hasChanges = true;
							}

						} catch (Throwable t) {
							t.printStackTrace();
						}
					}

					
					if (hasChanges && (actualRelCount % txLimit) == 0) {
						break;
					}
				}

				tx.success();

			} catch (Throwable t) {

				t.printStackTrace();
			}

			logger.log(Level.INFO, "Migrated {0} relationships so far.", actualRelCount);
		}

		logger.log(Level.INFO, "Migrated {0} relationships to new ID property.", actualRelCount);
	}

	public static String trim(final String value) {
		return StringUtils.trim(value);
	}

	public static void trim(StructrConf properties) {
		for (Object k : properties.keySet()) {
			properties.put(k, trim((String) properties.get(k)));
		}
	}

	
	public static int parseInt(String value, int defaultValue) {

		if (StringUtils.isBlank(value)) {
			return defaultValue;
		}

		try {
			return Integer.parseInt(value);
		} catch (NumberFormatException ignore) {}

		return defaultValue;
	}

	public static boolean parseBoolean(String value, boolean defaultValue) {

		if (StringUtils.isBlank(value)) {
			return defaultValue;
		}

		try {
			return Boolean.parseBoolean(value);
		} catch(Throwable ignore) {}

		return defaultValue;
	}

	public static int getGlobalSessionTimeout() {

		if (globalSessionTimeout == -1) {
			globalSessionTimeout = parseInt(Services.getInstance().getConfigurationValue(APPLICATION_SESSION_TIMEOUT, "1800"), 1800);
		}

		return globalSessionTimeout;
	}

	public static Set<Permission> getPermissionsForOwnerlessNodes() {
		return getInstance().permissionsForOwnerlessNodes;
	}

	
	public static interface InitializationCallback {
		public void initializationDone();
	}
}

<code block>

package org.structr.core.property;

import java.util.LinkedHashSet;
import java.util.Set;
import org.neo4j.graphdb.DynamicLabel;
import org.neo4j.graphdb.Label;
import org.neo4j.graphdb.Node;
import org.structr.common.SecurityContext;
import org.structr.common.error.FrameworkException;
import org.structr.core.GraphObject;
import org.structr.core.app.StructrApp;
import org.structr.core.graph.NodeFactory;
import org.structr.core.graph.NodeInterface;
import org.structr.core.graph.RelationshipFactory;
import org.structr.core.graph.search.SearchCommand;


public class TypeProperty extends StringProperty {

	public TypeProperty() {

		super("type");

		readOnly();
		indexed();
		writeOnce();
	}

	@Override
	public void setProperty(SecurityContext securityContext, final GraphObject obj, String value) throws FrameworkException {

		super.setProperty(securityContext, obj, value);

		RelationshipFactory.invalidateCache();
		NodeFactory.invalidateCache();

		if (obj instanceof NodeInterface) {

			final Class type              = StructrApp.getConfiguration().getNodeEntityClass(value);
			final Set<Label> intersection = new LinkedHashSet<>();
			final Set<Label> toRemove     = new LinkedHashSet<>();
			final Set<Label> toAdd        = new LinkedHashSet<>();
			final Node dbNode             = ((NodeInterface)obj).getNode();

			
			for (final Label label : dbNode.getLabels()) {
				toRemove.add(label);
			}

			
			for (final Class supertype : SearchCommand.typeAndAllSupertypes(type)) {

				final String supertypeName = supertype.getName();

				if (supertypeName.startsWith("org.structr.") || supertypeName.startsWith("com.structr.")) {
					toAdd.add(DynamicLabel.label(supertype.getSimpleName()));
				}
			}

			
			intersection.addAll(toAdd);
			intersection.retainAll(toRemove);

			
			toAdd.removeAll(intersection);
			toRemove.removeAll(intersection);

			
			for (final Label remove : toRemove) {
				dbNode.removeLabel(remove);
			}

			
			for (final Label add : toAdd) {
				dbNode.addLabel(add);
			}
		}
	}
}

<code block>

package org.structr.core.graph;

import org.neo4j.graphdb.Node;

import org.structr.common.SecurityContext;
import org.structr.common.error.FrameworkException;


import java.util.*;
import org.neo4j.gis.spatial.indexprovider.SpatialRecordHits;
import org.neo4j.graphdb.index.IndexHits;
import org.neo4j.helpers.collection.LruMap;
import org.structr.common.AccessControllable;
import org.structr.core.Result;
import org.structr.core.Services;
import org.structr.core.app.StructrApp;
import org.structr.core.entity.GenericNode;
import org.structr.core.entity.relationship.NodeHasLocation;




public class NodeFactory<T extends NodeInterface & AccessControllable> extends Factory<Node, T> {

	private static final Map<Long, Class> idTypeMap = Collections.synchronizedMap(new LruMap<Long, Class>(Services.parseInt(StructrApp.getConfigurationValue(Services.APPLICATION_NODE_CACHE_SIZE), 10000)));

	public NodeFactory(final SecurityContext securityContext) {
		super(securityContext);
	}

	public NodeFactory(final SecurityContext securityContext, final boolean includeDeletedAndHidden, final boolean publicOnly) {
		super(securityContext, includeDeletedAndHidden, publicOnly);
	}

	public NodeFactory(final SecurityContext securityContext, final int pageSize, final int page, final String offsetId) {
		super(securityContext, pageSize, page, offsetId);
	}

	public NodeFactory(final SecurityContext securityContext, final boolean includeDeletedAndHidden, final boolean publicOnly, final int pageSize, final int page, final String offsetId) {
		super(securityContext, includeDeletedAndHidden, publicOnly, pageSize, page, offsetId);
	}

	@Override
	public T instantiate(final Node node) throws FrameworkException {

		if (TransactionCommand.isDeleted(node)) {
			return (T)instantiateWithType(node, null, false);
		}

		Class type = idTypeMap.get(node.getId());
		if (type == null) {

			type = factoryDefinition.determineNodeType(node);
			if (type != null && !GenericNode.class.equals(type)) {

				idTypeMap.put(node.getId(), type);
			}
		}

		return (T) instantiateWithType(node, type, false);
	}

	@Override
	public T instantiateWithType(final Node node, final Class<T> nodeClass, boolean isCreation) throws FrameworkException {

		
		if (nodeClass == null) {
			return null;
		}

		SecurityContext securityContext = factoryProfile.getSecurityContext();
		T newNode                       = null;

		try {
			newNode = nodeClass.newInstance();

		} catch (InstantiationException|IllegalAccessException itex) {
			newNode = null;
		}

		if (newNode == null) {
			newNode = (T)factoryDefinition.createGenericNode();
		}

		newNode.init(factoryProfile.getSecurityContext(), node, nodeClass, isCreation);
		newNode.onNodeInstantiation();

		
		if (isCreation || securityContext.isReadable(newNode, factoryProfile.includeDeletedAndHidden(), factoryProfile.publicOnly())) {

			return newNode;
		}

		return null;
	}

	@Override
	public T instantiate(final Node node, final boolean includeDeletedAndHidden, final boolean publicOnly) throws FrameworkException {

		factoryProfile.setIncludeDeletedAndHidden(includeDeletedAndHidden);
		factoryProfile.setPublicOnly(publicOnly);

		return instantiate(node);
	}

	@Override
	public Result instantiate(final IndexHits<Node> input) throws FrameworkException {

		if (input != null && input instanceof SpatialRecordHits) {
			return resultFromSpatialRecords((SpatialRecordHits) input);
		}

		return super.instantiate(input);
	}

	@Override
	public T instantiateDummy(final Node entity, final String entityType) throws FrameworkException {

		Map<String, Class<? extends NodeInterface>> entities = StructrApp.getConfiguration().getNodeEntities();
		Class<T> nodeClass                                   = (Class<T>)entities.get(entityType);
		T newNode                                            = null;

		if (nodeClass != null) {

			try {

				newNode = nodeClass.newInstance();
				newNode.init(factoryProfile.getSecurityContext(), entity, nodeClass, false);

			} catch (InstantiationException|IllegalAccessException itex) { itex.printStackTrace(); }

		}

		return newNode;

	}

	public static void invalidateCache() {
		idTypeMap.clear();
	}

	private Result resultFromSpatialRecords(final SpatialRecordHits spatialRecordHits) throws FrameworkException {

		final int pageSize                    = factoryProfile.getPageSize();
		final SecurityContext securityContext = factoryProfile.getSecurityContext();
		final boolean includeDeletedAndHidden = factoryProfile.includeDeletedAndHidden();
		final boolean publicOnly              = factoryProfile.publicOnly();
		List<T> nodes                         = new LinkedList<>();
		int size                              = spatialRecordHits.size();
		int position                          = 0;
		int count                             = 0;
		int offset                            = 0;

		try (final SpatialRecordHits closeable = spatialRecordHits) {

			for (Node node : closeable) {

				Node realNode = node;
				if (realNode != null) {

					
					T n = instantiate(realNode);

					nodes.add(n);

					
					if (n != null) {    

						List<T> nodesAt = (List<T>)getNodesAt(n);

						size += nodesAt.size();

						for (T nodeAt : nodesAt) {

							if (nodeAt != null && securityContext.isReadable(nodeAt, includeDeletedAndHidden, publicOnly)) {

								if (++position > offset) {

									
									if (++count > pageSize) {

										return new Result(nodes, size, true, false);
									}

									nodes.add((T)nodeAt);
								}

							}

						}

					}

				}

			}
		}

		return new Result(nodes, size, true, false);

	}

	
	protected List<NodeInterface> getNodesAt(final NodeInterface locationNode) {

		final List<NodeInterface> nodes = new LinkedList<>();

		

		for(RelationshipInterface rel : locationNode.getIncomingRelationships(NodeHasLocation.class)) {

			NodeInterface startNode = rel.getSourceNode();

			nodes.add(startNode);

			
			nodes.addAll(getNodesAt(startNode));
		}

		return nodes;

	}
}

<code block>

package org.structr.core.graph;

import java.util.Collections;
import org.neo4j.graphdb.Relationship;

import org.structr.common.SecurityContext;
import org.structr.common.error.FrameworkException;



import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.neo4j.helpers.collection.LruMap;
import org.structr.core.GraphObject;
import org.structr.core.Services;
import org.structr.core.app.StructrApp;




public class RelationshipFactory<T extends RelationshipInterface> extends Factory<Relationship, T> {

	private static final Map<Long, Class> idTypeMap = Collections.synchronizedMap(new LruMap<Long, Class>(Services.parseInt(StructrApp.getConfigurationValue(Services.APPLICATION_REL_CACHE_SIZE), 10000)));
	private static final Logger logger              = Logger.getLogger(RelationshipFactory.class.getName());

	
	public RelationshipFactory(final SecurityContext securityContext) {
		super(securityContext);
	}

	public RelationshipFactory(final SecurityContext securityContext, final boolean includeDeletedAndHidden, final boolean publicOnly) {
		super(securityContext, includeDeletedAndHidden, publicOnly);
	}

	public RelationshipFactory(final SecurityContext securityContext, final int pageSize, final int page, final String offsetId) {
		super(securityContext, pageSize, page, offsetId);
	}

	public RelationshipFactory(final SecurityContext securityContext, final boolean includeDeletedAndHidden, final boolean publicOnly, final int pageSize, final int page, final String offsetId) {
		super(securityContext, includeDeletedAndHidden, publicOnly, pageSize, page, offsetId);
	}

	@Override
	public T instantiate(final Relationship relationship) throws FrameworkException {

		if (TransactionCommand.isDeleted(relationship)) {
			return (T) instantiateWithType(relationship, null, false);
		}

		Class type = idTypeMap.get(relationship.getId());
		if (type == null) {

			type = factoryDefinition.determineRelationshipType(relationship);
			if (type != null) {

				idTypeMap.put(relationship.getId(), type);
			}
		}

		return (T) instantiateWithType(relationship, type, false);
	}

	@Override
	public T instantiateWithType(final Relationship relationship, final Class<T> relClass, final boolean isCreation) throws FrameworkException {

		
		if (relClass == null) {
			return null;
		}

		logger.log(Level.FINEST, "Instantiate relationship with type {0}", relClass.getName());

		SecurityContext securityContext = factoryProfile.getSecurityContext();
		T newRel          = null;

		try {

			newRel = relClass.newInstance();

		} catch (Throwable t) {
			newRel = null;
		}

		if (newRel == null) {
			newRel = (T)StructrApp.getConfiguration().getFactoryDefinition().createGenericRelationship();
		}

		newRel.init(securityContext, relationship, relClass);

		if (!TransactionCommand.isDeleted(relationship)) {

			
			final String type = newRel.getProperty(GraphObject.type);
			if (type == null || (type != null && !type.equals(relClass.getSimpleName()))) {

				newRel.unlockReadOnlyPropertiesOnce();
				newRel.setProperty(GraphObject.type, relClass.getSimpleName());
			}
		}

		newRel.onRelationshipInstantiation();

		return newRel;
	}

	@Override
	public T adapt(final Relationship relationship) {

		try {
			return instantiate(relationship);

		} catch (FrameworkException fex) {

			logger.log(Level.WARNING, "Unable to adapt relationship", fex);
		}

		return null;
	}

	
	public List<T> instantiate(final Iterable<Relationship> input) throws FrameworkException {

		List<T> rels = new LinkedList<>();

		if ((input != null) && input.iterator().hasNext()) {

			for (Relationship rel : input) {

				T n = instantiate(rel);

				rels.add(n);

			}

		}

		return rels;
	}

	@Override
	public T instantiate(final Relationship obj, final boolean includeDeletedAndHidden, final boolean publicOnly) throws FrameworkException {

		factoryProfile.setIncludeDeletedAndHidden(includeDeletedAndHidden);
		factoryProfile.setPublicOnly(publicOnly);

		return instantiate(obj);
	}

	@Override
	public T instantiateDummy(final Relationship entity, final String entityType) throws FrameworkException {

		Map<String, Class<? extends RelationshipInterface>> entities = StructrApp.getConfiguration().getRelationshipEntities();
		Class<T> relClass                                            = (Class<T>)entities.get(entityType);
		T newRel                                                     = null;

		if (relClass != null) {

			try {

				newRel = relClass.newInstance();
				newRel.init(factoryProfile.getSecurityContext(), entity, relClass);

				
				newRel.onRelationshipInstantiation();

			} catch (Throwable t) {

				newRel = null;

			}

		}

		return newRel;

	}

	public static void invalidateCache() {
		idTypeMap.clear();
	}
}

<code block>

package org.structr.core.graph;

import org.neo4j.graphdb.Node;
import org.neo4j.graphdb.Relationship;

import org.structr.common.error.FrameworkException;
import org.structr.core.GraphObject;



import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.logging.Logger;
import org.neo4j.graphdb.GraphDatabaseService;
import org.neo4j.graphdb.Result;
import org.structr.core.GraphObjectMap;
import org.structr.core.property.GenericProperty;




public class CypherQueryCommand extends NodeServiceCommand {

	private static final Logger logger = Logger.getLogger(CypherQueryCommand.class.getName());

	

	

	public List<GraphObject> execute(String query) throws FrameworkException {
		return execute(query, null);
	}

	public List<GraphObject> execute(String query, Map<String, Object> parameters) throws FrameworkException {
		return execute(query, parameters, true);
	}

	public List<GraphObject> execute(String query, Map<String, Object> parameters, boolean includeHiddenAndDeleted) throws FrameworkException {
		return execute(query, parameters, includeHiddenAndDeleted, false);
	}

	public List<GraphObject> execute(String query, Map<String, Object> parameters, boolean includeHiddenAndDeleted, boolean publicOnly) throws FrameworkException {

		GraphDatabaseService graphDb    = (GraphDatabaseService) arguments.get("graphDb");
		RelationshipFactory relFactory  = new RelationshipFactory(securityContext);
		NodeFactory nodeFactory         = new NodeFactory(securityContext);
		List<GraphObject> resultList    = new LinkedList<>();
		Result result                   = null;

		if (parameters != null) {

			result = graphDb.execute(query, parameters);

		} else {

			result = graphDb.execute(query);
		}

		while (result.hasNext()) {

			final Map<String, Object> row = result.next();
			for (Entry<String, Object> entry : row.entrySet()) {

				String key   = entry.getKey();
				Object value = entry.getValue();

				resultList.add((GraphObject)handleObject(nodeFactory, relFactory, key, value, includeHiddenAndDeleted, publicOnly, 0));
			}

		}

		return resultList;
	}

	final Object handleObject(final NodeFactory nodeFactory, final RelationshipFactory relFactory, final String key, final Object value, boolean includeHiddenAndDeleted, boolean publicOnly, int level) throws FrameworkException {

		GraphObject graphObject = null;

		if (value instanceof Node) {

			graphObject = nodeFactory.instantiate((Node) value, includeHiddenAndDeleted, publicOnly);

		} else if (value instanceof Relationship) {

			graphObject = relFactory.instantiate((Relationship) value);

		} else if (value instanceof Map) {

			final Map<String, Object> valueMap = (Map<String, Object>)value;
			graphObject = new GraphObjectMap();

			for (final Entry<String, Object> valueEntry : valueMap.entrySet()) {

				final String valueKey   = valueEntry.getKey();
				final Object valueValue = valueEntry.getValue();

				graphObject.setProperty(new GenericProperty(valueKey), handleObject(nodeFactory, relFactory, valueKey, valueValue, includeHiddenAndDeleted, publicOnly, level + 1));
			}

		} else if (level == 0) {

			graphObject = new GraphObjectMap();
			graphObject.setProperty(new GenericProperty(key), value);

		} else {

			return value;
		}

		return graphObject;
	}

}

<code block>

package org.structr.core.app;

import java.io.IOException;
import java.net.URI;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.commons.lang3.StringUtils;
import org.neo4j.graphdb.GraphDatabaseService;
import org.neo4j.graphdb.NotFoundException;
import org.neo4j.helpers.collection.LruMap;
import org.neo4j.kernel.GraphDatabaseAPI;
import org.neo4j.kernel.impl.core.GraphProperties;
import org.neo4j.kernel.impl.core.NodeManager;
import org.structr.agent.AgentService;
import org.structr.agent.Task;
import org.structr.common.SecurityContext;
import org.structr.common.error.FrameworkException;
import org.structr.core.Command;
import org.structr.core.GraphObject;
import org.structr.core.Service;
import org.structr.core.Services;
import org.structr.core.entity.AbstractNode;
import org.structr.core.entity.Relation;
import org.structr.core.graph.CreateNodeCommand;
import org.structr.core.graph.CreateRelationshipCommand;
import org.structr.core.graph.CypherQueryCommand;
import org.structr.core.graph.DeleteNodeCommand;
import org.structr.core.graph.DeleteRelationshipCommand;
import org.structr.core.graph.GraphDatabaseCommand;
import org.structr.core.graph.MaintenanceCommand;
import org.structr.core.graph.NodeAttribute;
import org.structr.core.graph.NodeFactory;
import org.structr.core.graph.NodeInterface;
import org.structr.core.graph.NodeServiceCommand;
import org.structr.core.graph.RelationshipFactory;
import org.structr.core.graph.RelationshipInterface;
import org.structr.core.graph.Tx;
import org.structr.core.graph.search.SearchNodeCommand;
import org.structr.core.graph.search.SearchRelationshipCommand;
import org.structr.core.property.PropertyMap;
import org.structr.schema.ConfigurationProvider;


public class StructrApp implements App {

	private static final int cacheSize                 = Services.parseInt(StructrApp.getConfigurationValue(Services.APPLICATION_UUID_CACHE_SIZE), 10000);
	private static final Map<String, Long> nodeUuidMap = Collections.synchronizedMap(new LruMap<String, Long>(cacheSize));
	private static final Map<String, Long> relUuidMap  = Collections.synchronizedMap(new LruMap<String, Long>(cacheSize));
	private static final Logger logger                 = Logger.getLogger(StructrApp.class.getName());
	private static final URI schemaBaseURI             = URI.create("https:
	private static final Object globalConfigLock       = new Object();
	private static GraphProperties config              = null;
	private GraphDatabaseService graphDb               = null;
	private SecurityContext securityContext            = null;
	private RelationshipFactory relFactory             = null;
	private NodeFactory nodeFactory                    = null;

	private StructrApp(final SecurityContext securityContext) {
		this.relFactory      = new RelationshipFactory(securityContext);
		this.nodeFactory     = new NodeFactory(securityContext);
		this.securityContext = securityContext;
	}

	
	@Override
	public <T extends NodeInterface> T create(final Class<T> type, final String name) throws FrameworkException {
		return create(type, new NodeAttribute(AbstractNode.name, name));
	}

	@Override
	public <T extends NodeInterface> T create(final Class<T> type, final PropertyMap source) throws FrameworkException {

		final CreateNodeCommand<T> command = command(CreateNodeCommand.class);
		final PropertyMap properties       = new PropertyMap(source);

		
		properties.put(AbstractNode.type, type.getSimpleName());

		return command.execute(properties);
	}

	@Override
	public <T extends NodeInterface> T create(final Class<T> type, final NodeAttribute<?>... attributes) throws FrameworkException {

		final List<NodeAttribute<?>> attrs = new LinkedList<>(Arrays.asList(attributes));
		final CreateNodeCommand<T> command = command(CreateNodeCommand.class);

		
		attrs.add(new NodeAttribute(AbstractNode.type, type.getSimpleName()));

		return command.execute(attrs);
	}

	@Override
	public void delete(final NodeInterface node) {
		command(DeleteNodeCommand.class).execute(node);
	}

	@Override
	public <A extends NodeInterface, B extends NodeInterface, R extends Relation<A, B, ?, ?>> R create(final A fromNode, final B toNode, final Class<R> relType) throws FrameworkException {
		return command(CreateRelationshipCommand.class).execute(fromNode, toNode, relType);
	}

	@Override
	public <A extends NodeInterface, B extends NodeInterface, R extends Relation<A, B, ?, ?>> R create(final A fromNode, final B toNode, final Class<R> relType, final PropertyMap properties) throws FrameworkException {
		return command(CreateRelationshipCommand.class).execute(fromNode, toNode, relType, properties);
	}

	@Override
	public void delete(final RelationshipInterface relationship) {
		command(DeleteRelationshipCommand.class).execute(relationship);
	}

	@Override
	public GraphObject get(final String uuid) throws FrameworkException {

		final NodeInterface node = getNodeById(uuid);
		if (node != null) {

			return node;
		}

		final RelationshipInterface rel = getRelationshipById(uuid);
		if (rel != null) {

			return rel;
		}

		return null;
	}

	@Override
	public NodeInterface getNodeById(final String uuid) throws FrameworkException {

		final Long nodeId = nodeUuidMap.get(uuid);
		if (nodeId == null) {

			GraphObject entity = nodeQuery().uuid(uuid).includeDeletedAndHidden().getFirst();
			if (entity != null && uuid.equals(entity.getUuid())) {

				nodeUuidMap.put(uuid, entity.getId());
				return (NodeInterface)entity;
			}
			
		} else {

			try {
				return nodeFactory.instantiate(getGraphDatabaseService().getNodeById(nodeId));

			} catch (NotFoundException ignore) {
				nodeUuidMap.remove(uuid);
			}
		}

		return null;
	}

	@Override
	public RelationshipInterface getRelationshipById(final String uuid) throws FrameworkException {

		final Long id = relUuidMap.get(uuid);
		if (id == null) {

			GraphObject entity = relationshipQuery().uuid(uuid).getFirst();
			if (entity != null && uuid.equals(entity.getUuid())) {

				relUuidMap.put(uuid, entity.getId());
				return (RelationshipInterface)entity;
			}

		} else {

			try {
				return relFactory.instantiate(getGraphDatabaseService().getRelationshipById(id));

			} catch (NotFoundException ignore) {
				relUuidMap.remove(uuid);
			}
		}

		return null;
	}

	@Override
	public <T extends GraphObject> T get(final Class<T> type, final String uuid) throws FrameworkException {

		final GraphObject entity = get(uuid);

		if (type.isAssignableFrom(entity.getClass())) {

			return (T) entity;

		} else {

			return null;
		}
	}

	@Override
	public <T extends GraphObject> List<T> get(final Class<T> type) throws FrameworkException {

		final Query<T> query = command(SearchNodeCommand.class);
		return query.andType(type).getAsList();
	}

	@Override
	public Query<NodeInterface> nodeQuery() {
		return command(SearchNodeCommand.class);
	}

	@Override
	public Query<NodeInterface> nodeQuery(final boolean exact) {
		return command(SearchNodeCommand.class).exact(exact);
	}

	@Override
	public <T extends NodeInterface> Query<T> nodeQuery(final Class<T> type) {
		return command(SearchNodeCommand.class).andTypes(type);
	}

	@Override
	public <T extends NodeInterface> Query<T> nodeQuery(final Class<T> type, final boolean exact) {
		return command(SearchNodeCommand.class).exact(exact).andTypes(type);
	}

	@Override
	public Query<RelationshipInterface> relationshipQuery() {
		return command(SearchRelationshipCommand.class);
	}

	@Override
	public Query<RelationshipInterface> relationshipQuery(final boolean exact) {
		return command(SearchRelationshipCommand.class).exact(exact);
	}

	@Override
	public <T extends RelationshipInterface> Query<T> relationshipQuery(final Class<T> type) {
		return command(SearchRelationshipCommand.class).andTypes(type);
	}

	@Override
	public <T extends RelationshipInterface> Query<T> relationshipQuery(final Class<T> type, final boolean exact) {
		return command(SearchRelationshipCommand.class).exact(exact).andTypes(type);
	}

	@Override
	public Tx tx() {
		return tx(true);
	}

	@Override
	public Tx tx(final boolean doValidation) {
		return tx(doValidation, true);
	}

	@Override
	public Tx tx(final boolean doValidation, final boolean doCallbacks) {
		return new Tx(securityContext, this, doValidation, doCallbacks).begin();
	}

	@Override
	public Tx tx(final boolean doValidation, final boolean doCallbacks, final boolean doNotifications) {
		return new Tx(securityContext, this, doValidation, doCallbacks, doNotifications).begin();
	}

	@Override
	public void shutdown() {
		Services.getInstance().shutdown();
	}

	@Override
	public void close() throws IOException {
		shutdown();
	}

	@Override
	public <T extends Command> T command(Class<T> commandType) {
		return Services.getInstance().command(securityContext, commandType);
	}

	@Override
	public void processTasks(Task... tasks) {

		final AgentService agentService = getService(AgentService.class);
		if(agentService != null) {

			for(final Task task : tasks) {

				agentService.processTask(task);
			}
		}
	}

	@Override
	public <T extends Command & MaintenanceCommand> void maintenance(final Class<T> commandClass, final Map<String, Object> propertySet) throws FrameworkException {
		((MaintenanceCommand)Services.getInstance().command(securityContext, commandClass)).execute(propertySet);
	}

	@Override
	public List<GraphObject> cypher(final String cypherQuery, final Map<String, Object> parameters) throws FrameworkException {
		return Services.getInstance().command(securityContext, CypherQueryCommand.class).execute(cypherQuery, parameters);
	}

	@Override
	public <T extends Service> T getService(Class<T> serviceClass) {
		return Services.getInstance().getService(serviceClass);
	}

	@Override
	public GraphDatabaseService getGraphDatabaseService() {

		
		if (graphDb == null) {
			graphDb = Services.getInstance().command(securityContext, GraphDatabaseCommand.class).execute();
		}

		return graphDb;
	}

	private GraphProperties getOrCreateGraphProperties() {

		GraphProperties graphProperties = null;

		try (final Tx tx = StructrApp.getInstance().tx()) {

			final NodeManager mgr = ((GraphDatabaseAPI)getGraphDatabaseService()).getDependencyResolver().resolveDependency(NodeManager.class);

			tx.success();

			graphProperties = mgr.newGraphProperties();

		} catch (Throwable t) {
			logger.log(Level.WARNING, t.getMessage());
			t.printStackTrace();
		}

		return graphProperties;
	}

	@Override
	public <T> T getGlobalSetting(final String key, final T defaultValue) throws FrameworkException {

		if (config == null) {
			config = getOrCreateGraphProperties();
		}

		T value = null;

		try (final Tx tx = StructrApp.getInstance().tx()) {

			value = (T) config.getProperty(key);
			tx.success();

		} catch (Throwable t) {
			logger.log(Level.WARNING, t.getMessage());
			t.printStackTrace();

			try (final Tx tx = StructrApp.getInstance().tx()) {

				config = getOrCreateGraphProperties();
				config.setProperty(key, value);

				tx.success();

			} catch (Throwable t1) {
				logger.log(Level.WARNING, t1.getMessage());
				t1.printStackTrace();
			}
		}

		if (value == null) {
			return defaultValue;
		}

		return value;
	}

	@Override
	public void setGlobalSetting(final String key, final Object value) throws FrameworkException {

		if (config == null) {
			config = getOrCreateGraphProperties();
		}

		try (final Tx tx = StructrApp.getInstance().tx()) {

			config.setProperty(key, value);
			tx.success();

		} catch (Throwable t) {
			logger.log(Level.WARNING, t.getMessage());
			t.printStackTrace();

			try (final Tx tx = StructrApp.getInstance().tx()) {

				config = getOrCreateGraphProperties();
				config.setProperty(key, value);

				tx.success();

			} catch (Throwable t1) {
				logger.log(Level.WARNING, t1.getMessage());
				t1.printStackTrace();
			}
		}
	}

	@Override
	public String getInstanceId() throws FrameworkException {

		synchronized (globalConfigLock) {

			String instanceId = (String) getGlobalSetting("structr.instance.id", null);
			System.out.println("instance id from getGlobalSetting: " + instanceId);
			if (instanceId == null) {

				instanceId = NodeServiceCommand.getNextUuid();
				setGlobalSetting("structr.instance.id", instanceId);
			}
			System.out.println("instance id: " + instanceId);
			return instanceId;
		}
	}



	
	
	public static App getInstance() {
		return new StructrApp(SecurityContext.getSuperUserInstance());
	}

	
	public static App getInstance(final SecurityContext securityContext) {
		return new StructrApp(securityContext);
	}

	public static ConfigurationProvider getConfiguration() {
		return Services.getInstance().getConfigurationProvider();
	}

	public static String getConfigurationValue(final String key) {
		return StringUtils.trim(Services.getInstance().getConfigurationValue(key, null));
	}

	public static String getConfigurationValue(final String key, final String defaultValue) {
		return StringUtils.trim(Services.getInstance().getConfigurationValue(key, defaultValue));
	}

	public static <T extends GraphObject> URI getSchemaId(final Class<T> type) {
		initializeSchemaIds();
		return typeIdMap.get(type);
	}

	public static Class resolveSchemaId(final URI uri) {
		initializeSchemaIds();
		return schemaIdMap.get(uri);
	}

	public static URI getSchemaBaseURI() {
		return schemaBaseURI;
	}

	private static void initializeSchemaIds() {

		if (schemaIdMap.isEmpty()) {

			for (final Class type : StructrApp.getConfiguration().getNodeEntities().values()) {
				registerType(type);
			}

			for (final Class type : StructrApp.getConfiguration().getRelationshipEntities().values()) {
				registerType(type);
			}
		}
	}

	private static void registerType(final Class type) {

		final URI id = schemaBaseURI.resolve(URI.create(("definitions/" + type.getSimpleName())));

		schemaIdMap.put(id, type);
		typeIdMap.put(type, id);
	}

	private static final Map<URI, Class> schemaIdMap = new LinkedHashMap<>();
	private static final Map<Class, URI> typeIdMap   = new LinkedHashMap<>();
}

<code block>

package org.structr.core.parser;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonPrimitive;
import com.google.gson.reflect.TypeToken;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.StreamTokenizer;
import java.io.StringReader;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import java.net.URLEncoder;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.text.Normalizer;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.RandomStringUtils;
import org.apache.commons.lang3.StringEscapeUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.math.NumberUtils;
import org.apache.commons.mail.EmailException;
import org.neo4j.graphdb.Direction;
import org.neo4j.graphdb.DynamicRelationshipType;
import org.neo4j.graphdb.Node;
import org.structr.common.GraphObjectComparator;
import org.structr.common.MailHelper;
import org.structr.common.Permission;
import org.structr.common.Permissions;
import org.structr.common.SecurityContext;
import org.structr.common.error.ErrorToken;
import org.structr.common.error.FrameworkException;
import org.structr.common.error.SemanticErrorToken;
import org.structr.common.geo.GeoCodingResult;
import org.structr.common.geo.GeoHelper;
import org.structr.core.GraphObject;
import org.structr.core.GraphObjectMap;
import org.structr.core.Services;
import org.structr.core.app.App;
import org.structr.core.app.Query;
import org.structr.core.app.StructrApp;
import org.structr.core.converter.PropertyConverter;
import org.structr.core.entity.AbstractNode;
import org.structr.core.entity.AbstractRelationship;
import org.structr.core.entity.MailTemplate;
import org.structr.core.entity.Principal;
import org.structr.core.graph.NodeFactory;
import org.structr.core.graph.NodeInterface;
import org.structr.core.graph.RelationshipFactory;
import org.structr.core.graph.RelationshipInterface;
import org.structr.core.property.DateProperty;
import org.structr.core.property.PropertyKey;
import org.structr.core.property.PropertyMap;
import org.structr.core.property.StringProperty;
import org.structr.core.script.Scripting;
import org.structr.schema.ConfigurationProvider;
import org.structr.schema.action.ActionContext;
import org.structr.schema.action.Actions;
import org.structr.schema.action.Function;
import org.structr.schema.parser.DatePropertyParser;
import org.w3c.dom.Document;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;


public class Functions {

	private static final Logger logger = Logger.getLogger(Functions.class.getName());
	public static final Map<String, Function<Object, Object>> functions = new LinkedHashMap<>();

	public static final String NULL_STRING = "___NULL___";

	public static final String ERROR_MESSAGE_MD5 = "Usage: ${md5(string)}. Example: ${md5(this.email)}";
	public static final String ERROR_MESSAGE_ERROR = "Usage: ${error(...)}. Example: ${error(\"base\", \"must_equal\", int(5))}";
	public static final String ERROR_MESSAGE_UPPER = "Usage: ${upper(string)}. Example: ${upper(this.nickName)}";
	public static final String ERROR_MESSAGE_LOWER = "Usage: ${lower(string)}. Example: ${lower(this.email)}";
	public static final String ERROR_MESSAGE_JOIN = "Usage: ${join(collection, separator)}. Example: ${join(this.names, \",\")}";
	public static final String ERROR_MESSAGE_CONCAT = "Usage: ${concat(values...)}. Example: ${concat(this.firstName, this.lastName)}";
	public static final String ERROR_MESSAGE_SPLIT = "Usage: ${split(value)}. Example: ${split(this.commaSeparatedItems)}";
	public static final String ERROR_MESSAGE_ABBR = "Usage: ${abbr(longString, maxLength)}. Example: ${abbr(this.title, 20)}";
	public static final String ERROR_MESSAGE_CAPITALIZE = "Usage: ${capitalize(string)}. Example: ${capitalize(this.nickName)}";
	public static final String ERROR_MESSAGE_TITLEIZE = "Usage: ${titleize(string, separator}. (Default separator is \" \") Example: ${titleize(this.lowerCamelCaseString, \"_\")}";
	public static final String ERROR_MESSAGE_NUM = "Usage: ${num(string)}. Example: ${num(this.numericalStringValue)}";
	public static final String ERROR_MESSAGE_INT = "Usage: ${int(string)}. Example: ${int(this.numericalStringValue)}";
	public static final String ERROR_MESSAGE_RANDOM = "Usage: ${random(num)}. Example: ${set(this, \"password\", random(8))}";
	public static final String ERROR_MESSAGE_RINT = "Usage: ${rint(range)}. Example: ${rint(1000)}";
	public static final String ERROR_MESSAGE_INDEX_OF = "Usage: ${index_of(string, word)}. Example: ${index_of(this.name, \"the\")}";
	public static final String ERROR_MESSAGE_CONTAINS = "Usage: ${contains(string, word)}. Example: ${contains(this.name, \"the\")}";
	public static final String ERROR_MESSAGE_SUBSTRING = "Usage: ${substring(string, start, length)}. Example: ${substring(this.name, 19, 3)}";
	public static final String ERROR_MESSAGE_LENGTH = "Usage: ${length(string)}. Example: ${length(this.name)}";
	public static final String ERROR_MESSAGE_REPLACE = "Usage: ${replace(template, source)}. Example: ${replace(\"${this.id}\", this)}";
	public static final String ERROR_MESSAGE_CLEAN = "Usage: ${clean(string)}. Example: ${clean(this.stringWithNonWordChars)}";
	public static final String ERROR_MESSAGE_URLENCODE = "Usage: ${urlencode(string)}. Example: ${urlencode(this.email)}";
	public static final String ERROR_MESSAGE_ESCAPE_JS = "Usage: ${escape_javascript(string)}. Example: ${escape_javascript(this.name)}";
	public static final String ERROR_MESSAGE_ESCAPE_JSON = "Usage: ${escape_json(string)}. Example: ${escape_json(this.name)}";
	public static final String ERROR_MESSAGE_IF = "Usage: ${if(condition, trueValue, falseValue)}. Example: ${if(empty(this.name), this.nickName, this.name)}";
	public static final String ERROR_MESSAGE_EMPTY = "Usage: ${empty(string)}. Example: ${if(empty(possibleEmptyString), \"empty\", \"non-empty\")}";
	public static final String ERROR_MESSAGE_EQUAL = "Usage: ${equal(value1, value2)}. Example: ${equal(this.children.size, 0)}";
	public static final String ERROR_MESSAGE_ADD = "Usage: ${add(values...)}. Example: ${add(1, 2, 3, this.children.size)}";
	public static final String ERROR_MESSAGE_INT_SUM = "Usage: ${int_sum(list)}. Example: ${int_sum(extract(this.children, \"number\"))}";
	public static final String ERROR_MESSAGE_DOUBLE_SUM = "Usage: ${double_sum(list)}. Example: ${double_sum(extract(this.children, \"amount\"))}";
	public static final String ERROR_MESSAGE_IS_COLLECTION = "Usage: ${is_collection(value)}. Example: ${is_collection(this)}";
	public static final String ERROR_MESSAGE_IS_ENTITY = "Usage: ${is_entity(value)}. Example: ${is_entity(this)}";
	public static final String ERROR_MESSAGE_EXTRACT = "Usage: ${extract(list, propertyName)}. Example: ${extract(this.children, \"amount\")}";
	public static final String ERROR_MESSAGE_FILTER = "Usage: ${filter(list, expression)}. Example: ${filter(this.children, gt(size(data.children), 0))}";
	public static final String ERROR_MESSAGE_MERGE = "Usage: ${merge(list1, list2, list3, ...)}. Example: ${merge(this.children, this.siblings)}";
	public static final String ERROR_MESSAGE_COMPLEMENT = "Usage: ${complement(list1, list2, list3, ...)}. (The resulting list contains no duplicates) Example: ${complement(allUsers, me)} => List of all users except myself";
	public static final String ERROR_MESSAGE_UNWIND = "Usage: ${unwind(list1, ...)}. Example: ${unwind(this.children)}";
	public static final String ERROR_MESSAGE_SORT = "Usage: ${sort(list1, key [, true])}. Example: ${sort(this.children, \"name\")}";
	public static final String ERROR_MESSAGE_LT = "Usage: ${lt(value1, value2)}. Example: ${if(lt(this.children, 2), \"Less than two\", \"Equal to or more than two\")}";
	public static final String ERROR_MESSAGE_GT = "Usage: ${gt(value1, value2)}. Example: ${if(gt(this.children, 2), \"More than two\", \"Equal to or less than two\")}";
	public static final String ERROR_MESSAGE_LTE = "Usage: ${lte(value1, value2)}. Example: ${if(lte(this.children, 2), \"Equal to or less than two\", \"More than two\")}";
	public static final String ERROR_MESSAGE_GTE = "Usage: ${gte(value1, value2)}. Example: ${if(gte(this.children, 2), \"Equal to or more than two\", \"Less than two\")}";
	public static final String ERROR_MESSAGE_SUBT = "Usage: ${subt(value1, value)}. Example: ${subt(5, 2)}";
	public static final String ERROR_MESSAGE_MULT = "Usage: ${mult(value1, value)}. Example: ${mult(5, 2)}";
	public static final String ERROR_MESSAGE_QUOT = "Usage: ${quot(value1, value)}. Example: ${quot(5, 2)}";
	public static final String ERROR_MESSAGE_ROUND = "Usage: ${round(value1 [, decimalPlaces])}. Example: ${round(2.345678, 2)}";
	public static final String ERROR_MESSAGE_MAX = "Usage: ${max(value1, value2)}. Example: ${max(this.children, 10)}";
	public static final String ERROR_MESSAGE_MIN = "Usage: ${min(value1, value2)}. Example: ${min(this.children, 5)}";
	public static final String ERROR_MESSAGE_CONFIG = "Usage: ${config(keyFromStructrConf)}. Example: ${config(\"base.path\")}";
	public static final String ERROR_MESSAGE_CONFIG_JS = "Usage: ${{Structr.config(keyFromStructrConf)}}. Example: ${{Structr.config(\"base.path\")}}";
	public static final String ERROR_MESSAGE_DATE_FORMAT = "Usage: ${date_format(value, pattern)}. Example: ${date_format(this.creationDate, \"yyyy-MM-dd'T'HH:mm:ssZ\")}";
	public static final String ERROR_MESSAGE_DATE_FORMAT_JS = "Usage: ${{Structr.date_format(value, pattern)}}. Example: ${{Structr.date_format(Structr.get('this').creationDate, \"yyyy-MM-dd'T'HH:mm:ssZ\")}";
	public static final String ERROR_MESSAGE_PARSE_DATE = "Usage: ${parse_date(value, pattern)}. Example: ${parse_format(\"2014-01-01\", \"yyyy-MM-dd\")}";
	public static final String ERROR_MESSAGE_PARSE_DATE_JS = "Usage: ${{Structr.parse_date(value, pattern)}}. Example: ${{Structr.parse_format(\"2014-01-01\", \"yyyy-MM-dd\")}}";
	public static final String ERROR_MESSAGE_NUMBER_FORMAT = "Usage: ${number_format(value, ISO639LangCode, pattern)}. Example: ${number_format(12345.6789, 'en', '#,##0.00')}";
	public static final String ERROR_MESSAGE_NUMBER_FORMAT_JS = "Usage: ${{Structr.number_format(value, ISO639LangCode, pattern)}}. Example: ${{Structr.number_format(12345.6789, 'en', '#,##0.00')}}";
	public static final String ERROR_MESSAGE_TEMPLATE = "Usage: ${{Structr.template(name, locale, source)}}. Example: ${{Structr.template(\"TEXT_TEMPLATE_1\", \"en_EN\", Structr.get('this'))}}";
	public static final String ERROR_MESSAGE_TEMPLATE_JS = "Usage: ${template(name, locale, source)}. Example: ${template(\"TEXT_TEMPLATE_1\", \"en_EN\", this)}";
	public static final String ERROR_MESSAGE_NOT = "Usage: ${not(bool1, bool2)}. Example: ${not(\"true\", \"true\")}";
	public static final String ERROR_MESSAGE_AND = "Usage: ${and(bool1, bool2)}. Example: ${and(\"true\", \"true\")}";
	public static final String ERROR_MESSAGE_OR = "Usage: ${or(bool1, bool2)}. Example: ${or(\"true\", \"true\")}";
	public static final String ERROR_MESSAGE_GET = "Usage: ${get(entity, propertyKey)}. Example: ${get(this, \"children\")}";
	public static final String ERROR_MESSAGE_GET_ENTITY = "Cannot evaluate first argument to entity, must be entity or single element list of entities.";
	public static final String ERROR_MESSAGE_SIZE = "Usage: ${size(collection)}. Example: ${size(this.children)}";
	public static final String ERROR_MESSAGE_FIRST = "Usage: ${first(collection)}. Example: ${first(this.children)}";
	public static final String ERROR_MESSAGE_LAST = "Usage: ${last(collection)}. Example: ${last(this.children)}";
	public static final String ERROR_MESSAGE_NTH = "Usage: ${nth(collection)}. Example: ${nth(this.children, 2)}";
	public static final String ERROR_MESSAGE_GET_COUNTER = "Usage: ${get_counter(level)}. Example: ${get_counter(1)}";
	public static final String ERROR_MESSAGE_INC_COUNTER = "Usage: ${inc_counter(level, [resetLowerLevels])}. Example: ${inc_counter(1, true)}";
	public static final String ERROR_MESSAGE_RESET_COUNTER = "Usage: ${reset_counter(level)}. Example: ${reset_counter(1)}";
	public static final String ERROR_MESSAGE_MERGE_PROPERTIES = "Usage: ${merge_properties(source, target , mergeKeys...)}. Example: ${merge_properties(this, parent, \"eMail\")}";
	public static final String ERROR_MESSAGE_KEYS = "Usage: ${keys(entity, viewName)}. Example: ${keys(this, \"ui\")}";
	public static final String ERROR_MESSAGE_EACH = "Usage: ${each(collection, expression)}. Example: ${each(this.children, \"set(this, \"email\", lower(get(this.email))))\")}";
	public static final String ERROR_MESSAGE_STORE = "Usage: ${store(key, value)}. Example: ${store('tmpUser', this.owner)}";
	public static final String ERROR_MESSAGE_STORE_JS = "Usage: ${{Structr.store(key, value)}}. Example: ${{Structr.store('tmpUser', Structr.get('this').owner)}}";
	public static final String ERROR_MESSAGE_RETRIEVE = "Usage: ${retrieve(key)}. Example: ${retrieve('tmpUser')}";
	public static final String ERROR_MESSAGE_RETRIEVE_JS = "Usage: ${{Structr.retrieve(key)}}. Example: ${{retrieve('tmpUser')}}";
	public static final String ERROR_MESSAGE_PRINT = "Usage: ${print(objects...)}. Example: ${print(this.name, \"test\")}";
	public static final String ERROR_MESSAGE_PRINT_JS = "Usage: ${{Structr.print(objects...)}}. Example: ${{Structr.print(Structr.get('this').name, \"test\")}}";
	public static final String ERROR_MESSAGE_READ = "Usage: ${read(filename)}. Example: ${read(\"text.xml\")}";
	public static final String ERROR_MESSAGE_WRITE = "Usage: ${write(filename, value)}. Example: ${write(\"text.txt\", this.name)}";
	public static final String ERROR_MESSAGE_APPEND = "Usage: ${append(filename, value)}. Example: ${append(\"test.txt\", this.name)}";
	public static final String ERROR_MESSAGE_XML = "Usage: ${xml(xmlSource)}. Example: ${xpath(xml(this.xmlSource), \"/test/testValue\")}";
	public static final String ERROR_MESSAGE_XPATH = "Usage: ${xpath(xmlDocument, expression)}. Example: ${xpath(xml(this.xmlSource), \"/test/testValue\")}";
	public static final String ERROR_MESSAGE_SET = "Usage: ${set(entity, propertyKey, value)}. Example: ${set(this, \"email\", lower(this.email))}";
	public static final String ERROR_MESSAGE_SET_PRIVILEGED = "Usage: ${set_privileged(entity, propertyKey, value)}. Example: ${set_privileged(this, \"email\", lower(this.email))}";
	public static final String ERROR_MESSAGE_SET_PRIVILEGED_JS = "Usage: ${setPrvileged(entity, propertyKey, value)}. Example: ${Structr.setPrivileged(this, \"email\", lower(this.email))}";
	public static final String ERROR_MESSAGE_SEND_PLAINTEXT_MAIL = "Usage: ${send_plaintext_mail(fromAddress, fromName, toAddress, toName, subject, content)}.";
	public static final String ERROR_MESSAGE_SEND_HTML_MAIL = "Usage: ${send_html_mail(fromAddress, fromName, toAddress, toName, subject, content)}.";
	public static final String ERROR_MESSAGE_GEOCODE = "Usage: ${geocode(street, city, country)}. Example: ${set(this, geocode(this.street, this.city, this.country))}";
	public static final String ERROR_MESSAGE_FIND = "Usage: ${find(type, key, value)}. Example: ${find(\"User\", \"email\", \"tester@test.com\"}";
	public static final String ERROR_MESSAGE_SEARCH = "Usage: ${search(type, key, value)}. Example: ${search(\"User\", \"name\", \"abc\"}";
	public static final String ERROR_MESSAGE_CREATE = "Usage: ${create(type, key, value)}. Example: ${create(\"Feedback\", \"text\", this.text)}";
	public static final String ERROR_MESSAGE_DELETE = "Usage: ${delete(entity)}. Example: ${delete(this)}";
	public static final String ERROR_MESSAGE_CACHE = "Usage: ${cache(key, timeout, valueExpression)}. Example: ${cache('value', 60, GET('http:
	public static final String ERROR_MESSAGE_GRANT = "Usage: ${grant(principal, node, permissions)}. Example: ${grant(me, this, 'read, write, delete'))}";
	public static final String ERROR_MESSAGE_GRANT_JS = "Usage: ${Structr.grant(principal, node, permissions)}. Example: ${Structr.grant(Structr.get('me'), Structr.this, 'read, write, delete'))}";
	public static final String ERROR_MESSAGE_REVOKE = "Usage: ${revoke(principal, node, permissions)}. Example: ${revoke(me, this, 'write, delete'))}";
	public static final String ERROR_MESSAGE_REVOKE_JS = "Usage: ${Structr.revoke(principal, node, permissions)}. Example: ${Structr.revoke(Structr.('me'), Structr.this, 'write, delete'))}";
	public static final String ERROR_MESSAGE_UNLOCK_READONLY_PROPERTIES_ONCE = "Usage: ${unlock_readonly_properties_once(node)}. Example ${unlock_readonly_properties_once, this}";
	public static final String ERROR_MESSAGE_UNLOCK_READONLY_PROPERTIES_ONCE_JS = "Usage: ${Structr.unlock_readonly_properties_once(node)}. Example ${Structr.unlock_readonly_properties_once, Structr.get('this')}";
	public static final String ERROR_MESSAGE_CALL = "Usage: ${call(key [, payloads...]}. Example ${call('myEvent')}";
	public static final String ERROR_MESSAGE_CALL_JS = "Usage: ${Structr.call(key [, payloads...]}. Example ${Structr.call('myEvent')}";
	public static final String ERROR_MESSAGE_IS_LOCALE = "Usage: ${is_locale(locales...)}";
	public static final String ERROR_MESSAGE_IS_LOCALE_JS = "Usage: ${Structr.isLocale(locales...}. Example ${Structr.isLocale('de_DE', 'de_AT', 'de_CH')}";
	public static final String ERROR_MESSAGE_CYPHER = "Usage: ${cypher('MATCH (n) RETURN n')}";
	public static final String ERROR_MESSAGE_CYPHER_JS = "Usage: ${Structr.cypher(query)}. Example ${Structr.cypher('MATCH (n) RETURN n')}";

	
	public static final String ERROR_MESSAGE_INSTANTIATE = "Usage: ${instantiate(node)}. Example: ${instantiate(result.node)}";
	public static final String ERROR_MESSAGE_INCOMING = "Usage: ${incoming(entity [, relType])}. Example: ${incoming(this, 'PARENT_OF')}";
	public static final String ERROR_MESSAGE_INCOMING_JS = "Usage: ${Structr.incoming(entity [, relType])}. Example: ${Structr.incoming(Structr.this, 'PARENT_OF')}";
	public static final String ERROR_MESSAGE_OUTGOING = "Usage: ${outgoing(entity [, relType])}. Example: ${outgoing(this, 'PARENT_OF')}";
	public static final String ERROR_MESSAGE_OUTGOING_JS = "Usage: ${Structr.outgoing(entity [, relType])}. Example: ${outgoing(Structr.this, 'PARENT_OF')}";
	public static final String ERROR_MESSAGE_HAS_RELATIONSHIP = "Usage: ${has_relationship(entity1, entity2 [, relType])}. Example: ${has_relationship(me, user, 'FOLLOWS')} (ignores direction of the relationship)";
	public static final String ERROR_MESSAGE_HAS_RELATIONSHIP_JS = "Usage: ${Structr.has_relationship(entity1, entity2 [, relType])}. Example: ${Structr.has_relationship(Structr.get('me'), user, 'FOLLOWS')} (ignores direction of the relationship)";
	public static final String ERROR_MESSAGE_HAS_OUTGOING_RELATIONSHIP = "Usage: ${has_outgoing_relationship(from, to [, relType])}. Example: ${has_outgoing_relationship(me, user, 'FOLLOWS')}";
	public static final String ERROR_MESSAGE_HAS_OUTGOING_RELATIONSHIP_JS = "Usage: ${Structr.has_outgoing_relationship(from, to [, relType])}. Example: ${Structr.has_outgoing_relationship(Structr.get('me'), user, 'FOLLOWS')}";
	public static final String ERROR_MESSAGE_HAS_INCOMING_RELATIONSHIP = "Usage: ${has_incoming_relationship(from, to [, relType])}. Example: ${has_incoming_relationship(me, user, 'FOLLOWS')}";
	public static final String ERROR_MESSAGE_HAS_INCOMING_RELATIONSHIP_JS = "Usage: ${Structr.has_incoming_relationship(from, to [, relType])}. Example: ${Structr.has_incoming_relationship(Structr.get('me'), user, 'FOLLOWS')}";
	public static final String ERROR_MESSAGE_GET_RELATIONSHIPS = "Usage: ${get_relationships(entity1, entity2 [, relType])}. Example: ${get_relationships(me, user, 'FOLLOWS')}  (ignores direction of the relationship)";
	public static final String ERROR_MESSAGE_GET_RELATIONSHIPS_JS = "Usage: ${Structr.get_relationships(entity1, entity2 [, relType])}. Example: ${Structr.get_relationships(Structr.get('me'), user, 'FOLLOWS')}  (ignores direction of the relationship)";
	public static final String ERROR_MESSAGE_GET_OUTGOING_RELATIONSHIPS = "Usage: ${get_outgoing_relationships(from, to [, relType])}. Example: ${get_outgoing_relationships(me, user, 'FOLLOWS')}";
	public static final String ERROR_MESSAGE_GET_OUTGOING_RELATIONSHIPS_JS = "Usage: ${Structr.get_outgoing_relationships(from, to [, relType])}. Example: ${Structr.get_outgoing_relationships(Structr.get('me'), user, 'FOLLOWS')}";
	public static final String ERROR_MESSAGE_GET_INCOMING_RELATIONSHIPS = "Usage: ${get_incoming_relationships(from, to [, relType])}. Example: ${get_incoming_relationships(me, user, 'FOLLOWS')}";
	public static final String ERROR_MESSAGE_GET_INCOMING_RELATIONSHIPS_JS = "Usage: ${Structr.get_incoming_relationships(from, to [, relType])}. Example: ${Structr.get_incoming_relationships(Structr.get('me'), user, 'FOLLOWS')}";
	public static final String ERROR_MESSAGE_CREATE_RELATIONSHIP = "Usage: ${create_relationship(from, to, relType)}. Example: ${create_relationship(me, user, 'FOLLOWS')} (Relationshiptype has to exist)";
	public static final String ERROR_MESSAGE_CREATE_RELATIONSHIP_JS = "Usage: ${Structr.create_relationship(from, to, relType)}. Example: ${Structr.create_relationship(Structr.get('me'), user, 'FOLLOWS')} (Relationshiptype has to exist)";

	public static Function<Object, Object> get(final String name) {
		return functions.get(name);
	}

	public static Object evaluate(final ActionContext actionContext, final GraphObject entity, final String expression) throws FrameworkException {

		final String expressionWithoutNewlines = expression.replace('\n', ' ');
		final StreamTokenizer tokenizer = new StreamTokenizer(new StringReader(expressionWithoutNewlines));
		tokenizer.eolIsSignificant(true);
		tokenizer.ordinaryChar('.');
		tokenizer.wordChars('_', '_');
		tokenizer.wordChars('.', '.');
		tokenizer.wordChars('!', '!');

		Expression root = new RootExpression();
		Expression current = root;
		Expression next = null;
		String lastToken = null;
		int token = 0;
		int level = 0;

		while (token != StreamTokenizer.TT_EOF) {

			token = nextToken(tokenizer);

			switch (token) {

				case StreamTokenizer.TT_EOF:
					break;

				case StreamTokenizer.TT_EOL:
					break;

				case StreamTokenizer.TT_NUMBER:
					if (current == null) {
						throw new FrameworkException(422, "Invalid expression: mismatched opening bracket before NUMBER");
					}
					next = new ConstantExpression(tokenizer.nval);
					current.add(next);
					lastToken += "NUMBER";
					break;

				case StreamTokenizer.TT_WORD:
					if (current == null) {
						throw new FrameworkException(422, "Invalid expression: mismatched opening bracket before " + tokenizer.sval);
					}
					next = checkReservedWords(tokenizer.sval);
					current.add(next);
					lastToken = tokenizer.sval;
					break;

				case '(':
					if (((current == null || current instanceof RootExpression) && next == null) || current == next) {

						
						
						next = new GroupExpression();
						current.add(next);
					}

					current = next;
					lastToken += "(";
					level++;
					break;

				case ')':
					if (current == null) {
						throw new FrameworkException(422, "Invalid expression: mismatched opening bracket before " + lastToken);
					}
					current = current.getParent();
					if (current == null) {
						throw new FrameworkException(422, "Invalid expression: mismatched closing bracket after " + lastToken);
					}
					lastToken += ")";
					level--;
					break;

				case '[':
					
					next = new ArrayExpression();
					current.add(next);
					current = next;
					lastToken += "[";
					level++;
					break;

				case ']':

					if (current == null) {
						throw new FrameworkException(422, "Invalid expression: mismatched closing bracket before " + lastToken);
					}
					current = current.getParent();
					if (current == null) {
						throw new FrameworkException(422, "Invalid expression: mismatched closing bracket after " + lastToken);
					}
					lastToken += "]";
					level--;
					break;

				case ';':
					next = null;
					lastToken += ";";
					break;

				case ',':
					next = current;
					lastToken += ",";
					break;

				default:
					if (current == null) {
						throw new FrameworkException(422, "Invalid expression: mismatched opening bracket before " + tokenizer.sval);
					}
					current.add(new ConstantExpression(tokenizer.sval));
					lastToken = tokenizer.sval;

			}
		}

		if (level > 0) {
			throw new FrameworkException(422, "Invalid expression: mismatched closing bracket after " + lastToken);
		}

		return root.evaluate(actionContext, entity);
	}

	private static Expression checkReservedWords(final String word) throws FrameworkException {

		if (word == null) {
			return new NullExpression();
		}

		switch (word) {

			case "cache":
				return new CacheExpression();

			case "true":
				return new ConstantExpression(true);

			case "false":
				return new ConstantExpression(false);

			case "if":
				return new IfExpression();

			case "each":
				return new EachExpression();

			case "filter":
				return new FilterExpression();

			case "data":
				return new ValueExpression("data");

			case "null":
				return new ConstantExpression(NULL_STRING);
		}

		
		final Function<Object, Object> function = Functions.get(word);
		if (function != null) {

			return new FunctionExpression(word, function);

		} else {

			return new ValueExpression(word);
		}
	}

	public static int nextToken(final StreamTokenizer tokenizer) {

		try {

			return tokenizer.nextToken();

		} catch (IOException ioex) {
		}

		return StreamTokenizer.TT_EOF;
	}

	static {

		functions.put("error", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				final Class entityType;
				final String type;

				if (entity != null) {

					entityType = entity.getClass();
					type       = entity.getType();

				} else {

					entityType = GraphObject.class;
					type       = "Base";

				}

				if (arrayHasLengthAndAllElementsNotNull(sources, 2)) {

					final PropertyKey key = StructrApp.getConfiguration().getPropertyKeyForJSONName(entityType, sources[0].toString());
					ctx.raiseError(type, new ErrorToken(422, key) {

						@Override
						public JsonElement getContent() {
							return new JsonPrimitive(getErrorToken());
						}

						@Override
						public String getErrorToken() {
							return sources[1].toString();
						}
					});

				} else if (arrayHasLengthAndAllElementsNotNull(sources, 3)) {

					final PropertyKey key = StructrApp.getConfiguration().getPropertyKeyForJSONName(entityType, sources[0].toString());
					ctx.raiseError(type, new SemanticErrorToken(key) {

						@Override
						public JsonElement getContent() {

							JsonObject obj = new JsonObject();

							if (sources[2] instanceof Number) {

								obj.add(getErrorToken(), new JsonPrimitive((Number) sources[2]));

							} else if (sources[2] instanceof Boolean) {

								obj.add(getErrorToken(), new JsonPrimitive((Boolean) sources[2]));

							} else {

								obj.add(getErrorToken(), new JsonPrimitive(sources[2].toString()));
							}

							return obj;
						}

						@Override
						public String getErrorToken() {
							return sources[1].toString();
						}
					});
				}

				return null;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_ERROR;
			}
		});
		functions.put("md5", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				return (arrayHasMinLengthAndAllElementsNotNull(sources, 1))
					? DigestUtils.md5Hex(sources[0].toString())
					: "";

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_MD5;
			}
		});
		functions.put("upper", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				return (arrayHasMinLengthAndAllElementsNotNull(sources, 1))
					? sources[0].toString().toUpperCase()
					: "";

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_UPPER;
			}

		});
		functions.put("lower", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				return (arrayHasMinLengthAndAllElementsNotNull(sources, 1))
					? sources[0].toString().toLowerCase()
					: "";

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_LOWER;
			}

		});
		functions.put("join", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 2)) {

					if (sources[0] instanceof Collection) {

						return StringUtils.join((Collection) sources[0], sources[1].toString());
					}

					if (sources[0].getClass().isArray()) {

						return StringUtils.join((Object[]) sources[0], sources[1].toString());
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_JOIN;
			}

		});
		functions.put("concat", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				final List list = new ArrayList();
				for (final Object source : sources) {

					
					if (source != null) {

						if (source instanceof Collection) {

							list.addAll((Collection) source);

						} else if (source.getClass().isArray()) {

							list.addAll(Arrays.asList((Object[]) source));

						} else {

							list.add(source);
						}
					}
				}

				return StringUtils.join(list, "");
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_CONCAT;
			}

		});
		functions.put("split", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 1)) {

					final String toSplit = sources[0].toString();
					String splitExpr = "[,;]+";

					if (sources.length >= 2) {
						splitExpr = sources[1].toString();
					}

					return Arrays.asList(toSplit.split(splitExpr));
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_SPLIT;
			}

		});
		functions.put("abbr", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 2)) {

					try {
						int maxLength = Double.valueOf(sources[1].toString()).intValue();

						if (sources[0].toString().length() > maxLength) {

							return StringUtils.substringBeforeLast(StringUtils.substring(sources[0].toString(), 0, maxLength), " ").concat("");

						} else {

							return sources[0];
						}

					} catch (NumberFormatException nfe) {

						return nfe.getMessage();

					}

				}

				return "";

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_ABBR;
			}

		});
		functions.put("capitalize", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				return (arrayHasMinLengthAndAllElementsNotNull(sources, 1))
					? StringUtils.capitalize(sources[0].toString())
					: "";

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_CAPITALIZE;
			}
		});
		functions.put("titleize", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (sources == null || sources[0] == null) {
					return null;
				}

				if (StringUtils.isBlank(sources[0].toString())) {
					return "";
				}

				final String separator;
				if (sources.length < 2) {
					separator = " ";
				} else {
					separator = sources[1].toString();
				}

				String[] in = StringUtils.split(sources[0].toString(), separator);
				String[] out = new String[in.length];
				for (int i = 0; i < in.length; i++) {
					out[i] = StringUtils.capitalize(in[i]);
				}
				return StringUtils.join(out, " ");

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_TITLEIZE;
			}

		});
		functions.put("num", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 1)) {

					try {
						return getDoubleOrNull(sources[0]);

					} catch (Throwable t) {
						
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_NUM;
			}
		});
		functions.put("int", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 1)) {

					if (sources[0] instanceof Number) {
						return ((Number) sources[0]).intValue();
					}

					try {
						return getDoubleOrNull(sources[0]).intValue();

					} catch (Throwable t) {
						
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_INT;
			}
		});
		functions.put("random", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 1) && sources[0] instanceof Number) {

					try {
						return RandomStringUtils.randomAlphanumeric(((Number) sources[0]).intValue());

					} catch (Throwable t) {
						
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_RANDOM;
			}
		});
		functions.put("rint", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 1) && sources[0] instanceof Number) {

					try {
						return new Random(System.currentTimeMillis()).nextInt(((Number) sources[0]).intValue());

					} catch (Throwable t) {
						
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_RINT;
			}
		});
		functions.put("index_of", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 2)) {

					final String source = sources[0].toString();
					final String part = sources[1].toString();

					return source.indexOf(part);
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_INDEX_OF;
			}
		});
		functions.put("contains", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 2)) {

					if (sources[0] instanceof String && sources[1] instanceof String) {

						final String source = sources[0].toString();
						final String part = sources[1].toString();

						return source.contains(part);

					} else if (sources[0] instanceof Collection && sources[1] instanceof GraphObject) {

						final Collection collection = (Collection) sources[0];
						final GraphObject obj = (GraphObject) sources[1];

						return collection.contains(obj);

					} else if (sources[0].getClass().isArray()) {

						return ArrayUtils.contains((Object[]) sources[0], sources[1]);
					}
				}

				return false;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_CONTAINS;
			}
		});
		functions.put("substring", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 2)) {

					final String source = sources[0].toString();
					final int sourceLength = source.length();
					final int start = parseInt(sources[1]);
					final int length = sources.length >= 3 ? parseInt(sources[2]) : sourceLength - start;
					final int end = start + length;

					if (start >= 0 && start < sourceLength && end >= 0 && end <= sourceLength && start <= end) {

						return source.substring(start, end);
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_SUBSTRING;
			}
		});
		functions.put("length", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 1)) {

					return sources[0].toString().length();
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_SUBSTRING;
			}
		});
		functions.put("replace", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 2)) {

					final String template = sources[0].toString();
					AbstractNode node = null;

					if (sources[1] instanceof AbstractNode) {
						node = (AbstractNode) sources[1];
					}

					if (sources[1] instanceof List) {

						final List list = (List) sources[1];
						if (list.size() == 1 && list.get(0) instanceof AbstractNode) {

							node = (AbstractNode) list.get(0);
						}
					}

					if (node != null) {

						
						return Scripting.replaceVariables(ctx, node, template);
					}

					return "";
				}

				return usage(ctx.isJavaScriptContext());

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_REPLACE;
			}
		});
		functions.put("clean", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 1)) {

					if (StringUtils.isBlank(sources[0].toString())) {
						return "";
					}

					return cleanString(sources[0]);
				}

				return null;

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_CLEAN;
			}

		});
		functions.put("urlencode", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				return (arrayHasMinLengthAndAllElementsNotNull(sources, 1))
					? encodeURL(sources[0].toString())
					: "";

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_URLENCODE;
			}

		});
		functions.put("escape_javascript", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				return (arrayHasMinLengthAndAllElementsNotNull(sources, 1))
					? StringEscapeUtils.escapeEcmaScript(sources[0].toString())
					: "";

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_ESCAPE_JS;
			}

		});
		functions.put("escape_json", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				return (arrayHasMinLengthAndAllElementsNotNull(sources, 1))
					? StringEscapeUtils.escapeJson(sources[0].toString())
					: "";

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_ESCAPE_JSON;
			}

		});
		functions.put("if", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (sources[0] == null || sources.length < 3) {

					return "";
				}

				if ("true".equals(sources[0]) || Boolean.TRUE.equals(sources[0])) {

					return sources[1];

				} else {

					return sources[2];
				}

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_IF;
			}

		});
		functions.put("empty", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (sources.length == 0 || sources[0] == null || StringUtils.isEmpty(sources[0].toString())) {

					return true;

				} else {
					return false;
				}

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_EMPTY;
			}

		});
		functions.put("equal", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				logger.log(Level.FINE, "Length: {0}", sources.length);

				if (sources.length < 2) {

					return true;
				}

				logger.log(Level.FINE, "Comparing {0} to {1}", new java.lang.Object[]{sources[0], sources[1]});

				if (sources[0] == null && sources[1] == null) {
					return true;
				}

				if (sources[0] == null || sources[1] == null) {
					return false;
				}

				return valueEquals(sources[0], sources[1]);
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_EQUAL;
			}

		});
		functions.put("eq", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				return functions.get("equal").apply(ctx, entity, sources);
			}

			@Override
			public String usage(boolean inJavaScriptContext) {

				return functions.get("equal").usage(inJavaScriptContext);
			}

		});
		functions.put("add", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				Double result = 0.0;

				if (sources != null) {

					for (Object i : sources) {

						if (i != null) {

							try {

								result += Double.parseDouble(i.toString());

							} catch (Throwable t) {

								return t.getMessage();

							}

						} else {

							result += 0.0;
						}
					}

				}

				return result;

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_ADD;
			}

		});
		functions.put("double_sum", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				double result = 0.0;

				if (arrayHasLengthAndAllElementsNotNull(sources, 1)) {

					if (sources[0] instanceof Collection) {

						for (final Number num : (Collection<Number>) sources[0]) {

							result += num.doubleValue();
						}
					}
				}

				return result;

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_DOUBLE_SUM;
			}

		});
		functions.put("int_sum", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				int result = 0;

				if (arrayHasLengthAndAllElementsNotNull(sources, 1)) {

					if (sources[0] instanceof Collection) {

						for (final Number num : (Collection<Number>) sources[0]) {

							result += num.intValue();
						}
					}
				}

				return result;

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_INT_SUM;
			}

		});
		functions.put("is_collection", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 1)) {
					return (sources[0] instanceof Collection);
				} else {
					return false;
				}

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_IS_COLLECTION;
			}

		});
		functions.put("is_entity", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 1)) {
					return (sources[0] instanceof GraphObject);
				} else {
					return false;
				}

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_IS_ENTITY;
			}

		});
		functions.put("extract", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 1)) {

					
					if (sources[0] instanceof Collection) {

						final List extraction = new LinkedList();

						for (final Object obj : (Collection) sources[0]) {

							if (obj instanceof Collection) {

								extraction.addAll((Collection) obj);
							}
						}

						return extraction;
					}

				} else if (arrayHasLengthAndAllElementsNotNull(sources, 2)) {

					if (sources[0] instanceof Collection && sources[1] instanceof String) {

						final ConfigurationProvider config = StructrApp.getConfiguration();
						final List extraction = new LinkedList();
						final String keyName = (String) sources[1];

						for (final Object obj : (Collection) sources[0]) {

							if (obj instanceof GraphObject) {

								final PropertyKey key = config.getPropertyKeyForJSONName(obj.getClass(), keyName);
								final Object value = ((GraphObject) obj).getProperty(key);
								if (value != null) {

									extraction.add(value);
								}
							}
						}

						return extraction;
					}
				}

				return null;

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_EXTRACT;
			}

		});
		functions.put("merge", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				final List list = new ArrayList();
				for (final Object source : sources) {

					if (source instanceof Collection) {

						
						for (Object obj : (Collection) source) {

							if (obj != null) {

								list.add(obj);
							}
						}

					} else if (source != null) {

						list.add(source);
					}
				}

				return list;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_MERGE;
			}

		});
		functions.put("complement", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				final Set sourceSet = new HashSet();

				if (sources[0] instanceof Collection) {

					sourceSet.addAll((Collection) sources[0]);

					for (int cnt = 1; cnt < sources.length; cnt++) {

						final Object source = sources[cnt];

						if (source instanceof Collection) {

							sourceSet.removeAll((Collection) source);

						} else if (source != null) {

							sourceSet.remove(source);
						}
					}

				} else {

					return "Argument 1 for complement must be a Collection";
				}

				return sourceSet;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_COMPLEMENT;
			}

		});
		functions.put("unwind", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				final List list = new ArrayList();
				for (final Object source : sources) {

					if (source instanceof Collection) {

						
						for (Object obj : (Collection) source) {
							if (obj != null) {

								if (obj instanceof Collection) {

									for (final Object elem : (Collection) obj) {

										if (elem != null) {

											list.add(elem);
										}
									}

								} else {

									list.add(obj);
								}
							}
						}

					} else if (source != null) {

						list.add(source);
					}
				}

				return list;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_UNWIND;
			}

		});
		functions.put("sort", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 2)) {

					if (sources[0] instanceof List && sources[1] instanceof String) {

						final List list = (List) sources[0];
						final String sortKey = sources[1].toString();
						final Iterator iterator = list.iterator();

						if (iterator.hasNext()) {

							final Object firstElement = iterator.next();
							if (firstElement instanceof GraphObject) {

								final Class type = firstElement.getClass();
								final PropertyKey key = StructrApp.getConfiguration().getPropertyKeyForJSONName(type, sortKey);
								final boolean descending = sources.length == 3 && sources[2] != null && "true".equals(sources[2].toString());

								if (key != null) {

									List<GraphObject> sortCollection = (List<GraphObject>) list;
									Collections.sort(sortCollection, new GraphObjectComparator(key, descending));

									return sortCollection;
								}
							}

						}
					}
				}

				return sources[0];
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_SORT;
			}

		});
		functions.put("lt", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				String result = "";

				if (arrayHasLengthAndAllElementsNotNull(sources, 2)) {

					return lt(sources[0], sources[1]);
				}

				return result;

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_LT;
			}
		});
		functions.put("gt", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				String result = "";

				if (arrayHasLengthAndAllElementsNotNull(sources, 2)) {

					return gt(sources[0], sources[1]);
				}

				return result;

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_GT;
			}
		});
		functions.put("lte", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				String result = "";

				if (arrayHasLengthAndAllElementsNotNull(sources, 2)) {

					return lte(sources[0], sources[1]);
				}

				return result;

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_LTE;
			}
		});
		functions.put("gte", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				String result = "";

				if (arrayHasLengthAndAllElementsNotNull(sources, 2)) {

					return gte(sources[0], sources[1]);

				}

				return result;

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_GTE;
			}
		});
		functions.put("subt", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 2)) {

					try {

						Double result = Double.parseDouble(sources[0].toString());

						for (int i = 1; i < sources.length; i++) {

							result -= Double.parseDouble(sources[i].toString());

						}

						return result;

					} catch (Throwable t) {

						return t.getMessage();

					}
				}

				return "";

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_SUBT;
			}
		});
		functions.put("mult", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				Double result = 1.0d;

				if (sources != null) {

					for (Object i : sources) {

						try {

							result *= Double.parseDouble(i.toString());

						} catch (Throwable t) {

							return t.getMessage();

						}
					}

				}

				return result;

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_MULT;
			}
		});
		functions.put("quot", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 2)) {

					try {

						return Double.parseDouble(sources[0].toString()) / Double.parseDouble(sources[1].toString());

					} catch (Throwable t) {

						return t.getMessage();

					}

				} else {

					if (sources != null) {

						if (sources.length > 0 && sources[0] != null) {
							return Double.valueOf(sources[0].toString());
						}

						return "";
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_QUOT;
			}
		});
		functions.put("round", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 2)) {

					if (StringUtils.isBlank(sources[0].toString())) {
						return "";
					}

					try {

						Double f1 = Double.parseDouble(sources[0].toString());
						double f2 = Math.pow(10, (Double.parseDouble(sources[1].toString())));
						long r = Math.round(f1 * f2);

						return (double) r / f2;

					} catch (Throwable t) {

						return t.getMessage();

					}

				} else {

					return "";
				}
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_ROUND;
			}
		});
		functions.put("max", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				Object result = "";
				String errorMsg = "ERROR! Usage: ${max(val1, val2)}. Example: ${max(5,10)}";

				if (arrayHasLengthAndAllElementsNotNull(sources, 2)) {

					try {
						result = Math.max(Double.parseDouble(sources[0].toString()), Double.parseDouble(sources[1].toString()));

					} catch (Throwable t) {

						logger.log(Level.WARNING, "Could not determine max() of {0} and {1}", new Object[]{sources[0], sources[1]});
						result = errorMsg;
					}

				} else {

					result = "";
				}

				return result;

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_MAX;
			}
		});
		functions.put("min", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				Object result = "";
				String errorMsg = "ERROR! Usage: ${min(val1, val2)}. Example: ${min(5,10)}";

				if (arrayHasLengthAndAllElementsNotNull(sources, 2)) {

					try {
						result = Math.min(Double.parseDouble(sources[0].toString()), Double.parseDouble(sources[1].toString()));

					} catch (Throwable t) {

						logger.log(Level.WARNING, "Could not determine min() of {0} and {1}", new Object[]{sources[0], sources[1]});
						result = errorMsg;
					}

				} else {

					result = "";
				}

				return result;

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_MIN;
			}
		});
		functions.put("config", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 1)) {

					final String configKey = sources[0].toString();
					final String defaultValue = sources.length >= 2 ? sources[1].toString() : "";

					return StructrApp.getConfigurationValue(configKey, defaultValue);
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_CONFIG_JS : ERROR_MESSAGE_CONFIG);
			}
		});
		functions.put("date_format", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (sources == null || sources != null && sources.length != 2) {
					return usage(ctx.isJavaScriptContext());
				}

				if (arrayHasLengthAndAllElementsNotNull(sources, 2)) {

					Date date = null;

					if (sources[0] instanceof Date) {

						date = (Date) sources[0];

					} else if (sources[0] instanceof Number) {

						date = new Date(((Number) sources[0]).longValue());

					} else {

						try {

							
							date = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").parse(sources[0].toString());

						} catch (ParseException ex) {
							ex.printStackTrace();
						}

					}

					
					return new SimpleDateFormat(sources[1].toString()).format(date);
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_DATE_FORMAT_JS : ERROR_MESSAGE_DATE_FORMAT);
			}
		});
		functions.put("parse_date", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (sources == null || sources != null && sources.length != 2) {
					return usage(ctx.isJavaScriptContext());
				}

				if (arrayHasLengthAndAllElementsNotNull(sources, 2)) {

					String dateString = sources[0].toString();

					if (StringUtils.isBlank(dateString)) {
						return "";
					}

					String pattern = sources[1].toString();

					try {
						
						return new SimpleDateFormat(pattern).parse(dateString);

					} catch (ParseException ex) {
						logger.log(Level.WARNING, "Could not parse date " + dateString + " and format it to pattern " + pattern, ex);
					}

				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_PARSE_DATE_JS : ERROR_MESSAGE_PARSE_DATE);
			}
		});
		functions.put("number_format", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (sources == null || sources != null && sources.length != 3) {
					return usage(ctx.isJavaScriptContext());
				}

				if (arrayHasLengthAndAllElementsNotNull(sources, 3)) {

					if (StringUtils.isBlank(sources[0].toString())) {
						return "";
					}

					try {

						Double val = Double.parseDouble(sources[0].toString());
						String langCode = sources[1].toString();
						String pattern = sources[2].toString();

						return new DecimalFormat(pattern, DecimalFormatSymbols.getInstance(Locale.forLanguageTag(langCode))).format(val);

					} catch (Throwable t) {
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_NUMBER_FORMAT_JS : ERROR_MESSAGE_NUMBER_FORMAT);
			}
		});
		functions.put("template", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (sources == null || sources != null && sources.length != 3) {
					return usage(ctx.isJavaScriptContext());
				}

				if (arrayHasLengthAndAllElementsNotNull(sources, 3) && sources[2] instanceof AbstractNode) {

					final App app = StructrApp.getInstance(entity != null ? entity.getSecurityContext() : ctx.getSecurityContext());
					final String name = sources[0].toString();
					final String locale = sources[1].toString();
					final MailTemplate template = app.nodeQuery(MailTemplate.class).andName(name).and(MailTemplate.locale, locale).getFirst();
					final AbstractNode templateInstance = (AbstractNode) sources[2];

					if (template != null) {

						final String text = template.getProperty(MailTemplate.text);
						if (text != null) {

							
							return Scripting.replaceVariables(ctx, templateInstance, text);
						}
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_TEMPLATE_JS : ERROR_MESSAGE_TEMPLATE);
			}
		});
		functions.put("not", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 1)) {

					return !("true".equals(sources[0].toString()) || Boolean.TRUE.equals(sources[0]));

				}

				return true;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_NOT;
			}

		});
		functions.put("and", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				boolean result = true;

				if (sources != null) {

					if (sources.length < 2) {
						return usage(ctx.isJavaScriptContext());
					}

					for (Object i : sources) {

						if (i != null) {

							try {

								result &= "true".equals(i.toString()) || Boolean.TRUE.equals(i);

							} catch (Throwable t) {

								return t.getMessage();

							}

						} else {

							
							return false;
						}
					}

				}

				return result;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_AND;
			}

		});
		functions.put("or", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				boolean result = false;

				if (sources != null) {

					if (sources.length < 2) {
						return usage(ctx.isJavaScriptContext());
					}

					for (Object i : sources) {

						if (i != null) {

							try {

								result |= "true".equals(i.toString()) || Boolean.TRUE.equals(i);

							} catch (Throwable t) {

								return t.getMessage();

							}

						} else {

							
							result |= false;
						}
					}

				}

				return result;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_OR;
			}
		});
		functions.put("get", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				final SecurityContext securityContext = entity != null ? entity.getSecurityContext() : ctx.getSecurityContext();
				if (arrayHasLengthAndAllElementsNotNull(sources, 2)) {

					GraphObject dataObject = null;

					if (sources[0] instanceof GraphObject) {
						dataObject = (GraphObject) sources[0];
					}

					if (sources[0] instanceof List) {

						final List list = (List) sources[0];
						if (list.size() == 1 && list.get(0) instanceof GraphObject) {

							dataObject = (GraphObject) list.get(0);
						}
					}

					if (dataObject != null) {

						final String keyName = sources[1].toString();
						final PropertyKey key = StructrApp.getConfiguration().getPropertyKeyForJSONName(dataObject.getClass(), keyName);

						if (key != null) {

							final PropertyConverter inputConverter = key.inputConverter(securityContext);
							Object value = dataObject.getProperty(key);

							if (inputConverter != null) {
								return inputConverter.revert(value);
							}

							return dataObject.getProperty(key);
						}

						return "";

					} else {

						return ERROR_MESSAGE_GET_ENTITY;
					}
				}

				return usage(ctx.isJavaScriptContext());
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_GET;
			}
		});
		functions.put("size", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				final List list = new ArrayList();
				for (final Object source : sources) {

					if (source != null) {

						if (source instanceof Collection) {

							
							for (Object obj : (Collection) source) {
								if (obj != null && !NULL_STRING.equals(obj)) {

									list.add(obj);
								}
							}

						} else if (source.getClass().isArray()) {

							list.addAll(Arrays.asList((Object[]) source));

						} else if (source != null && !NULL_STRING.equals(source)) {

							list.add(source);
						}

						return list.size();
					}
				}

				return 0;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_SIZE;
			}
		});
		functions.put("first", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 1)) {

					if (sources[0] instanceof List && !((List) sources[0]).isEmpty()) {
						return ((List) sources[0]).get(0);
					}

					if (sources[0].getClass().isArray()) {

						final Object[] arr = (Object[]) sources[0];
						if (arr.length > 0) {

							return arr[0];
						}
					}
				}

				return null;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_FIRST;
			}
		});
		functions.put("last", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 1)) {

					if (sources[0] instanceof List && !((List) sources[0]).isEmpty()) {

						final List list = (List) sources[0];
						return list.get(list.size() - 1);
					}

					if (sources[0].getClass().isArray()) {

						final Object[] arr = (Object[]) sources[0];
						if (arr.length > 0) {

							return arr[arr.length - 1];
						}
					}

				}

				return null;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_LAST;
			}
		});
		functions.put("nth", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 2)) {

					final int pos = Double.valueOf(sources[1].toString()).intValue();

					if (sources[0] instanceof List && !((List) sources[0]).isEmpty()) {

						final List list = (List) sources[0];
						final int size = list.size();

						if (pos >= size) {

							return null;

						}

						return list.get(Math.min(Math.max(0, pos), size - 1));
					}

					if (sources[0].getClass().isArray()) {

						final Object[] arr = (Object[]) sources[0];
						if (pos <= arr.length) {

							return arr[pos];
						}
					}
				}

				return null;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_NTH;
			}
		});
		functions.put("get_counter", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 1)) {

					return ctx.getCounter(parseInt(sources[0]));
				}

				return 0;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_GET_COUNTER;
			}
		});
		functions.put("inc_counter", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 1)) {

					final int level = parseInt(sources[0]);

					ctx.incrementCounter(level);

					
					if (sources.length == 2 && "true".equals(sources[1].toString())) {

						
						for (int i = level + 1; i < 10; i++) {
							ctx.resetCounter(i);
						}
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_INC_COUNTER;
			}
		});
		functions.put("reset_counter", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 1)) {

					ctx.resetCounter(parseInt(sources[0]));
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_RESET_COUNTER;
			}
		});
		functions.put("merge_properties", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 2) && sources[0] instanceof GraphObject && sources[1] instanceof GraphObject) {

					final ConfigurationProvider config = StructrApp.getConfiguration();
					final Set<PropertyKey> mergeKeys = new LinkedHashSet<>();
					final GraphObject source = (GraphObject) sources[0];
					final GraphObject target = (GraphObject) sources[1];
					final int paramCount = sources.length;

					for (int i = 2; i < paramCount; i++) {

						final String keyName = sources[i].toString();
						final PropertyKey key = config.getPropertyKeyForJSONName(target.getClass(), keyName);

						mergeKeys.add(key);
					}

					for (final PropertyKey key : mergeKeys) {

						final Object sourceValue = source.getProperty(key);
						if (sourceValue != null) {

							target.setProperty(key, sourceValue);
						}

					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_MERGE_PROPERTIES;
			}
		});
		functions.put("keys", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 2) && sources[0] instanceof GraphObject) {

					final Set<String> keys = new LinkedHashSet<>();
					final GraphObject source = (GraphObject) sources[0];

					for (final PropertyKey key : source.getPropertyKeys(sources[1].toString())) {
						keys.add(key.jsonName());
					}

					return new LinkedList<>(keys);

				} else if (arrayHasMinLengthAndAllElementsNotNull(sources, 1) && sources[0] instanceof GraphObjectMap) {

					return new LinkedList<>(((GraphObjectMap) sources[0]).keySet());

				} else if (arrayHasMinLengthAndAllElementsNotNull(sources, 1) && sources[0] instanceof Map) {

					return new LinkedList<>(((Map) sources[0]).keySet());

				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_KEYS;
			}
		});

		
		functions.put("retrieve", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 1) && sources[0] instanceof String) {

					return ctx.retrieve(sources[0].toString());

				} else {

					return usage(ctx.isJavaScriptContext());
				}
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_RETRIEVE_JS : ERROR_MESSAGE_RETRIEVE);
			}
		});
		functions.put("store", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 2) && sources[0] instanceof String) {

					ctx.store(sources[0].toString(), sources[1]);

				} else {

					return usage(ctx.isJavaScriptContext());
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_STORE_JS : ERROR_MESSAGE_STORE);
			}
		});
		functions.put("print", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (sources != null) {

					for (Object i : sources) {

						System.out.print(i);
					}

					System.out.println();
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_PRINT;
			}
		});
		functions.put("read", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 1)) {

					try {
						final String sandboxFilename = getSandboxFileName(sources[0].toString());
						if (sandboxFilename != null) {

							final File file = new File(sandboxFilename);
							if (file.exists() && file.length() < 10000000) {

								try (final FileInputStream fis = new FileInputStream(file)) {

									return IOUtils.toString(fis, "utf-8");
								}
							}
						}

					} catch (IOException ioex) {
						ioex.printStackTrace();
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_READ;
			}
		});
		functions.put("write", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 1)) {

					try {
						final String sandboxFilename = getSandboxFileName(sources[0].toString());
						if (sandboxFilename != null) {

							final File file = new File(sandboxFilename);
							if (!file.exists()) {

								try (final Writer writer = new OutputStreamWriter(new FileOutputStream(file, false))) {

									for (int i = 1; i < sources.length; i++) {
										if (sources[i] != null) {
											IOUtils.write(sources[i].toString(), writer);
										}
									}

									writer.flush();
								}

							} else {

								logger.log(Level.SEVERE, "Trying to overwrite an existing file, please use append() for that purpose.");
							}
						}

					} catch (IOException ioex) {
						ioex.printStackTrace();
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_WRITE;
			}
		});
		functions.put("append", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 1)) {

					try {
						final String sandboxFilename = getSandboxFileName(sources[0].toString());
						if (sandboxFilename != null) {

							final File file = new File(sandboxFilename);

							try (final Writer writer = new OutputStreamWriter(new FileOutputStream(file, true))) {

								for (int i = 1; i < sources.length; i++) {
									IOUtils.write(sources[i].toString(), writer);
								}

								writer.flush();
							}
						}

					} catch (IOException ioex) {
						ioex.printStackTrace();
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_APPEND;
			}
		});
		functions.put("xml", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 1) && sources[0] instanceof String) {

					try {

						final DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
						if (builder != null) {

							final String xml = (String) sources[0];
							final StringReader reader = new StringReader(xml);
							final InputSource src = new InputSource(reader);

							return builder.parse(src);
						}

					} catch (IOException | SAXException | ParserConfigurationException ex) {
						ex.printStackTrace();
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_XML;
			}
		});
		functions.put("xpath", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 2) && sources[0] instanceof Document) {

					try {

						XPath xpath = XPathFactory.newInstance().newXPath();
						return xpath.evaluate(sources[1].toString(), sources[0], XPathConstants.STRING);

					} catch (XPathExpressionException ioex) {
						ioex.printStackTrace();
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_XPATH;
			}
		});
		functions.put("set", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 2)) {

					if (sources[0] instanceof GraphObject) {

						final GraphObject source = (GraphObject) sources[0];
						final Map<String, Object> properties = new LinkedHashMap<>();
						final SecurityContext securityContext = source.getSecurityContext();
						final Gson gson = new GsonBuilder().create();
						final Class type = source.getClass();
						final int sourceCount = sources.length;

						if (sources.length == 3 && sources[2] != null && sources[1].toString().matches("[a-zA-Z0-9_]+")) {

							properties.put(sources[1].toString(), sources[2]);

						} else {

							
							for (int i = 1; i < sourceCount; i++) {

								final Map<String, Object> values = deserialize(gson, sources[i].toString());
								if (values != null) {

									properties.putAll(values);
								}
							}
						}

						
						final PropertyMap map = PropertyMap.inputTypeToJavaType(securityContext, type, properties);
						for (final Map.Entry<PropertyKey, Object> entry : map.entrySet()) {

							source.setProperty(entry.getKey(), entry.getValue());
						}

					} else {

						throw new FrameworkException(422, "Invalid use of builtin method set, usage: set(entity, params..)");
					}

				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_SET;
			}
		});
		functions.put("send_plaintext_mail", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 6)) {

					final String from = sources[0].toString();
					final String fromName = sources[1].toString();
					final String to = sources[2].toString();
					final String toName = sources[3].toString();
					final String subject = sources[4].toString();
					final String textContent = sources[5].toString();

					try {
						return MailHelper.sendSimpleMail(from, fromName, to, toName, null, null, from, subject, textContent);

					} catch (EmailException eex) {
						eex.printStackTrace();
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_SEND_PLAINTEXT_MAIL;
			}
		});
		functions.put("send_html_mail", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 6)) {

					final String from = sources[0].toString();
					final String fromName = sources[1].toString();
					final String to = sources[2].toString();
					final String toName = sources[3].toString();
					final String subject = sources[4].toString();
					final String htmlContent = sources[5].toString();
					String textContent = "";

					if (sources.length == 7) {
						textContent = sources[6].toString();
					}

					try {
						return MailHelper.sendHtmlMail(from, fromName, to, toName, null, null, from, subject, htmlContent, textContent);

					} catch (EmailException eex) {
						eex.printStackTrace();
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_SEND_HTML_MAIL;
			}
		});
		functions.put("geocode", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 3)) {

					final Gson gson = new GsonBuilder().create();
					final String street = sources[0].toString();
					final String city = sources[1].toString();
					final String country = sources[2].toString();

					GeoCodingResult result = GeoHelper.geocode(street, null, null, city, null, country);
					if (result != null) {

						final Map<String, Object> map = new LinkedHashMap<>();

						map.put("latitude", result.getLatitude());
						map.put("longitude", result.getLongitude());

						return serialize(gson, map);
					}

				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_GEOCODE;
			}
		});
		functions.put("find", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (sources != null) {

					final SecurityContext securityContext = ctx.getSecurityContext();
					final ConfigurationProvider config = StructrApp.getConfiguration();
					final Query query = StructrApp.getInstance(securityContext).nodeQuery().sort(GraphObject.createdDate).order(false);

					
					Class type = null;

					if (sources.length >= 1 && sources[0] != null) {

						type = config.getNodeEntityClass(sources[0].toString());

						if (type != null) {

							query.andTypes(type);
						}
					}

					
					if (sources.length == 2 && sources[1] instanceof Map) {

						query.and(PropertyMap.inputTypeToJavaType(securityContext, type, (Map) sources[1]));

					} else {

						final Integer parameter_count = sources.length;

						if (parameter_count % 2 == 0) {

							throw new FrameworkException(400, "Invalid number of parameters: " + parameter_count + ". Should be uneven: " + ERROR_MESSAGE_FIND);
						}

						for (Integer c = 1; c < parameter_count; c += 2) {

							final PropertyKey key = config.getPropertyKeyForJSONName(type, sources[c].toString());

							if (key != null) {

								
								if (!key.isSearchable()) {

									throw new FrameworkException(400, "Search key " + key.jsonName() + " is not indexed.");
								}

								final PropertyConverter inputConverter = key.inputConverter(securityContext);
								Object value = sources[c + 1];

								if (inputConverter != null) {

									value = inputConverter.convert(value);
								}

								query.and(key, value);
							}
						}
					}

					return query.getAsList();
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_FIND;
			}
		});
		functions.put("search", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (sources != null) {

					final SecurityContext securityContext = entity != null ? entity.getSecurityContext() : ctx.getSecurityContext();
					final ConfigurationProvider config = StructrApp.getConfiguration();
					final Query query = StructrApp.getInstance(securityContext).nodeQuery();
					Class type = null;

					if (sources.length >= 1 && sources[0] != null) {

						type = config.getNodeEntityClass(sources[0].toString());

						if (type != null) {

							query.andTypes(type);
						}
					}

					
					if (sources.length == 2 && sources[1] instanceof Map) {

						final PropertyMap map = PropertyMap.inputTypeToJavaType(securityContext, type, (Map) sources[1]);
						for (final Entry<PropertyKey, Object> entry : map.entrySet()) {

							query.and(entry.getKey(), entry.getValue(), false);
						}

					} else {

						final Integer parameter_count = sources.length;

						if (parameter_count % 2 == 0) {

							throw new FrameworkException(400, "Invalid number of parameters: " + parameter_count + ". Should be uneven: " + ERROR_MESSAGE_FIND);
						}

						for (Integer c = 1; c < parameter_count; c += 2) {

							final PropertyKey key = config.getPropertyKeyForJSONName(type, sources[c].toString());

							if (key != null) {

								
								if (!key.isSearchable()) {

									throw new FrameworkException(400, "Search key " + key.jsonName() + " is not indexed.");
								}

								final PropertyConverter inputConverter = key.inputConverter(securityContext);
								Object value = sources[c + 1];

								if (inputConverter != null) {

									value = inputConverter.convert(value);
								}

								query.and(key, value, false);
							}

						}
					}

					final Object x = query.getAsList();

					
					return x;
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_SEARCH;
			}
		});
		functions.put("create", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (sources != null) {

					final SecurityContext securityContext = entity != null ? entity.getSecurityContext() : ctx.getSecurityContext();
					final App app = StructrApp.getInstance(securityContext);
					final ConfigurationProvider config = StructrApp.getConfiguration();
					PropertyMap propertyMap = null;
					Class type = null;

					if (sources.length >= 1 && sources[0] != null) {

						type = config.getNodeEntityClass(sources[0].toString());

						if (entity != null && type.equals(entity.getClass())) {

							throw new FrameworkException(422, "Cannot create() entity of the same type in save action.");
						}
					}

					
					if (sources.length == 2 && sources[1] instanceof Map) {

						propertyMap = PropertyMap.inputTypeToJavaType(securityContext, type, (Map) sources[1]);

					} else {

						propertyMap = new PropertyMap();
						final Integer parameter_count = sources.length;

						if (parameter_count % 2 == 0) {

							throw new FrameworkException(400, "Invalid number of parameters: " + parameter_count + ". Should be uneven: " + ERROR_MESSAGE_CREATE);
						}

						for (Integer c = 1; c < parameter_count; c += 2) {

							final PropertyKey key = config.getPropertyKeyForJSONName(type, sources[c].toString());

							if (key != null) {

								final PropertyConverter inputConverter = key.inputConverter(securityContext);
								Object value = sources[c + 1];

								if (inputConverter != null) {

									value = inputConverter.convert(value);
								}

								propertyMap.put(key, value);

							}

						}
					}

					if (type != null) {

						return app.create(type, propertyMap);

					} else {

						throw new FrameworkException(422, "Unknown type in create() save action.");
					}

				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_CREATE;
			}
		});
		functions.put("delete", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (sources != null) {

					final App app = StructrApp.getInstance(entity != null ? entity.getSecurityContext() : ctx.getSecurityContext());
					for (final Object obj : sources) {

						if (obj instanceof NodeInterface) {

							app.delete((NodeInterface) obj);
							continue;
						}

						if (obj instanceof RelationshipInterface) {

							app.delete((RelationshipInterface) obj);
							continue;
						}
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_DELETE;
			}
		});
		functions.put("incoming", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 1)) {

					final RelationshipFactory factory = new RelationshipFactory(entity != null ? entity.getSecurityContext() : ctx.getSecurityContext());
					final Object source = sources[0];

					if (source instanceof NodeInterface) {

						final NodeInterface node = (NodeInterface) source;
						if (sources.length > 1) {

							final Object relType = sources[1];
							if (relType != null && relType instanceof String) {

								final String relTypeName = (String) relType;
								return factory.instantiate(node.getNode().getRelationships(Direction.INCOMING, DynamicRelationshipType.withName(relTypeName)));
							}

						} else {

							return factory.instantiate(node.getNode().getRelationships(Direction.INCOMING));
						}

					} else {

						return "Error: entity is not a node.";
					}
				}
				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_INCOMING_JS : ERROR_MESSAGE_INCOMING);
			}
		});
		functions.put("instantiate", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 1)) {

					return new NodeFactory<>(ctx.getSecurityContext()).instantiate((Node)sources[0]);
				}
				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_INCOMING_JS : ERROR_MESSAGE_INCOMING);
			}
		});
		functions.put("outgoing", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 1)) {

					final RelationshipFactory factory = new RelationshipFactory(entity != null ? entity.getSecurityContext() : ctx.getSecurityContext());
					final Object source = sources[0];

					if (source instanceof NodeInterface) {

						final NodeInterface node = (NodeInterface) source;
						if (sources.length > 1) {

							final Object relType = sources[1];
							if (relType != null && relType instanceof String) {

								final String relTypeName = (String) relType;
								return factory.instantiate(node.getNode().getRelationships(Direction.OUTGOING, DynamicRelationshipType.withName(relTypeName)));
							}

						} else {

							return factory.instantiate(node.getNode().getRelationships(Direction.OUTGOING));
						}

					} else {

						return "Error: entity is not a node.";
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_OUTGOING_JS : ERROR_MESSAGE_OUTGOING);
			}
		});
		functions.put("has_relationship", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 2)) {

					final Object source = sources[0];
					final Object target = sources[1];

					AbstractNode sourceNode = null;
					AbstractNode targetNode = null;

					if (source instanceof AbstractNode && target instanceof AbstractNode) {

						sourceNode = (AbstractNode) source;
						targetNode = (AbstractNode) target;

					} else {

						return "Error: entities are not nodes.";
					}

					if (sources.length == 2) {

						for (final AbstractRelationship rel : sourceNode.getRelationships()) {

							final NodeInterface s = rel.getSourceNode();
							final NodeInterface t = rel.getTargetNode();

							
							if (s != null & t != null
								&& ((s.equals(sourceNode) && t.equals(targetNode)) || (s.equals(targetNode) && t.equals(sourceNode)))) {
								return true;
							}
						}

					} else if (sources.length == 3) {

						
						final String relType = (String) sources[2];

						for (final AbstractRelationship rel : sourceNode.getRelationships()) {

							final NodeInterface s = rel.getSourceNode();
							final NodeInterface t = rel.getTargetNode();

							
							if (s != null & t != null
								&& rel.getRelType().name().equals(relType)
								&& ((s.equals(sourceNode) && t.equals(targetNode)) || (s.equals(targetNode) && t.equals(sourceNode)))) {
								return true;
							}
						}

					}

				}

				return false;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_HAS_RELATIONSHIP_JS : ERROR_MESSAGE_HAS_RELATIONSHIP);
			}
		});
		functions.put("has_outgoing_relationship", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 2)) {

					final Object source = sources[0];
					final Object target = sources[1];

					AbstractNode sourceNode = null;
					AbstractNode targetNode = null;

					if (source instanceof AbstractNode && target instanceof AbstractNode) {

						sourceNode = (AbstractNode) source;
						targetNode = (AbstractNode) target;

					} else {

						return "Error: entities are not nodes.";
					}

					if (sources.length == 2) {

						for (final AbstractRelationship rel : sourceNode.getOutgoingRelationships()) {

							final NodeInterface s = rel.getSourceNode();
							final NodeInterface t = rel.getTargetNode();

							
							if (s != null & t != null
								&& s.equals(sourceNode) && t.equals(targetNode)) {
								return true;
							}
						}

					} else if (sources.length == 3) {

						
						final String relType = (String) sources[2];

						for (final AbstractRelationship rel : sourceNode.getOutgoingRelationships()) {

							final NodeInterface s = rel.getSourceNode();
							final NodeInterface t = rel.getTargetNode();

							
							if (s != null & t != null
								&& rel.getRelType().name().equals(relType)
								&& s.equals(sourceNode) && t.equals(targetNode)) {
								return true;
							}
						}

					}

				}

				return false;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_HAS_OUTGOING_RELATIONSHIP_JS : ERROR_MESSAGE_HAS_OUTGOING_RELATIONSHIP);
			}
		});
		functions.put("has_incoming_relationship", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 2)) {

					final Object source = sources[0];
					final Object target = sources[1];

					AbstractNode sourceNode = null;
					AbstractNode targetNode = null;

					if (source instanceof AbstractNode && target instanceof AbstractNode) {

						sourceNode = (AbstractNode) source;
						targetNode = (AbstractNode) target;

					} else {

						return "Error: entities are not nodes.";
					}

					if (sources.length == 2) {

						for (final AbstractRelationship rel : sourceNode.getIncomingRelationships()) {

							final NodeInterface s = rel.getSourceNode();
							final NodeInterface t = rel.getTargetNode();

							
							if (s != null & t != null
								&& s.equals(targetNode) && t.equals(sourceNode)) {
								return true;
							}
						}

					} else if (sources.length == 3) {

						
						final String relType = (String) sources[2];

						for (final AbstractRelationship rel : sourceNode.getIncomingRelationships()) {

							final NodeInterface s = rel.getSourceNode();
							final NodeInterface t = rel.getTargetNode();

							
							if (s != null & t != null
								&& rel.getRelType().name().equals(relType)
								&& s.equals(targetNode) && t.equals(sourceNode)) {
								return true;
							}
						}

					}

				}

				return false;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_HAS_INCOMING_RELATIONSHIP_JS : ERROR_MESSAGE_HAS_INCOMING_RELATIONSHIP);
			}
		});
		functions.put("get_relationships", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				final List<AbstractRelationship> list = new ArrayList<>();

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 2)) {

					final Object source = sources[0];
					final Object target = sources[1];

					NodeInterface sourceNode = null;
					NodeInterface targetNode = null;

					if (source instanceof NodeInterface && target instanceof NodeInterface) {

						sourceNode = (NodeInterface) source;
						targetNode = (NodeInterface) target;

					} else {

						return "Error: Entities are not nodes.";
					}

					if (sources.length == 2) {

						for (final AbstractRelationship rel : sourceNode.getRelationships()) {

							final NodeInterface s = rel.getSourceNode();
							final NodeInterface t = rel.getTargetNode();

							
							if (s != null && t != null
								&& ((s.equals(sourceNode) && t.equals(targetNode)) || (s.equals(targetNode) && t.equals(sourceNode)))) {
								list.add(rel);
							}
						}

					} else if (sources.length == 3) {

						
						final String relType = (String) sources[2];

						for (final AbstractRelationship rel : sourceNode.getRelationships()) {

							final NodeInterface s = rel.getSourceNode();
							final NodeInterface t = rel.getTargetNode();

							
							if (s != null && t != null
								&& rel.getRelType().name().equals(relType)
								&& ((s.equals(sourceNode) && t.equals(targetNode)) || (s.equals(targetNode) && t.equals(sourceNode)))) {
								list.add(rel);
							}
						}

					}
				}

				return list;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_GET_RELATIONSHIPS_JS : ERROR_MESSAGE_GET_RELATIONSHIPS);
			}
		});
		functions.put("get_outgoing_relationships", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				final List<AbstractRelationship> list = new ArrayList<>();

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 2)) {

					final Object source = sources[0];
					final Object target = sources[1];

					AbstractNode sourceNode = null;
					AbstractNode targetNode = null;

					if (source instanceof AbstractNode && target instanceof AbstractNode) {

						sourceNode = (AbstractNode) source;
						targetNode = (AbstractNode) target;

					} else {

						return "Error: entities are not nodes.";
					}

					if (sources.length == 2) {

						for (final AbstractRelationship rel : sourceNode.getOutgoingRelationships()) {

							final NodeInterface s = rel.getSourceNode();
							final NodeInterface t = rel.getTargetNode();

							
							if (s != null && t != null
								&& s.equals(sourceNode) && t.equals(targetNode)) {
								list.add(rel);
							}
						}

					} else if (sources.length == 3) {

						
						final String relType = (String) sources[2];

						for (final AbstractRelationship rel : sourceNode.getOutgoingRelationships()) {

							final NodeInterface s = rel.getSourceNode();
							final NodeInterface t = rel.getTargetNode();

							
							if (s != null && t != null
								&& rel.getRelType().name().equals(relType)
								&& s.equals(sourceNode) && t.equals(targetNode)) {
								list.add(rel);
							}
						}

					}
				}

				return list;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_GET_OUTGOING_RELATIONSHIPS_JS : ERROR_MESSAGE_GET_OUTGOING_RELATIONSHIPS);
			}
		});
		functions.put("get_incoming_relationships", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				final List<AbstractRelationship> list = new ArrayList<>();

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 2)) {

					final Object source = sources[0];
					final Object target = sources[1];

					AbstractNode sourceNode = null;
					AbstractNode targetNode = null;

					if (source instanceof AbstractNode && target instanceof AbstractNode) {

						sourceNode = (AbstractNode) source;
						targetNode = (AbstractNode) target;

					} else {

						return "Error: entities are not nodes.";
					}

					if (sources.length == 2) {

						for (final AbstractRelationship rel : sourceNode.getIncomingRelationships()) {

							final NodeInterface s = rel.getSourceNode();
							final NodeInterface t = rel.getTargetNode();

							
							if (s != null && t != null
								&& s.equals(targetNode) && t.equals(sourceNode)) {
								list.add(rel);
							}
						}

					} else if (sources.length == 3) {

						
						final String relType = (String) sources[2];

						for (final AbstractRelationship rel : sourceNode.getIncomingRelationships()) {

							final NodeInterface s = rel.getSourceNode();
							final NodeInterface t = rel.getTargetNode();

							
							if (s != null && t != null
								&& rel.getRelType().name().equals(relType)
								&& s.equals(targetNode) && t.equals(sourceNode)) {
								list.add(rel);
							}
						}

					}
				}

				return list;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_GET_INCOMING_RELATIONSHIPS_JS : ERROR_MESSAGE_GET_INCOMING_RELATIONSHIPS);
			}
		});
		functions.put("create_relationship", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 3)) {

					final Object source = sources[0];
					final Object target = sources[1];
					final String relType = (String) sources[2];

					AbstractNode sourceNode = null;
					AbstractNode targetNode = null;

					if (source instanceof AbstractNode && target instanceof AbstractNode) {

						sourceNode = (AbstractNode) source;
						targetNode = (AbstractNode) target;

					} else {

						return "Error: entities are not nodes.";
					}

					final Class relClass = StructrApp.getConfiguration().getRelationClassForCombinedType(sourceNode.getType(), relType, targetNode.getType());

					if (relClass != null) {

						StructrApp.getInstance(sourceNode.getSecurityContext()).create(sourceNode, targetNode, relClass);

					} else {

						return "Error: Unknown relationship type";
					}

				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_CREATE_RELATIONSHIP_JS : ERROR_MESSAGE_CREATE_RELATIONSHIP);
			}
		});
		functions.put("grant", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 3)) {

					if (sources[0] instanceof Principal) {

						final Principal principal = (Principal) sources[0];

						if (sources[1] instanceof AbstractNode) {

							final AbstractNode node = (AbstractNode) sources[1];

							if (sources[2] instanceof String) {

								final String[] parts = ((String) sources[2]).split("[,]+");
								for (final String part : parts) {

									final String trimmedPart = part.trim();
									if (trimmedPart.length() > 0) {

										final Permission permission = Permissions.valueOf(trimmedPart);
										if (permission != null) {

											node.grant(permission, principal);

										} else {

											return "Error: unknown permission " + trimmedPart;
										}
									}
								}

								return "";

							} else {

								return "Error: third argument is not a string.";
							}

						} else {

							return "Error: second argument is not a node.";
						}

					} else {

						return "Error: first argument is not of type Principal.";
					}

				} else {

					return usage(ctx.isJavaScriptContext());
				}
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_GRANT_JS : ERROR_MESSAGE_GRANT);
			}
		});
		functions.put("revoke", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 3)) {

					if (sources[0] instanceof Principal) {

						final Principal principal = (Principal) sources[0];

						if (sources[1] instanceof AbstractNode) {

							final AbstractNode node = (AbstractNode) sources[1];

							if (sources[2] instanceof String) {

								final String[] parts = ((String) sources[2]).split("[,]+");
								for (final String part : parts) {

									final String trimmedPart = part.trim();
									if (trimmedPart.length() > 0) {

										final Permission permission = Permissions.valueOf(trimmedPart);
										if (permission != null) {

											node.revoke(permission, principal);

										} else {

											return "Error: unknown permission " + trimmedPart;
										}
									}
								}

								return "";

							} else {

								return "Error: third argument is not a string.";
							}

						} else {

							return "Error: second argument is not a node.";
						}

					} else {

						return "Error: first argument is not of type Principal.";
					}

				} else {

					return usage(ctx.isJavaScriptContext());
				}
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_REVOKE_JS : ERROR_MESSAGE_REVOKE);
			}
		});
		functions.put("unlock_readonly_properties_once", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 1)) {

					if (sources[0] instanceof AbstractNode) {

						((AbstractNode) sources[0]).unlockReadOnlyPropertiesOnce();

					} else {

						return usage(ctx.isJavaScriptContext());

					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_UNLOCK_READONLY_PROPERTIES_ONCE_JS : ERROR_MESSAGE_UNLOCK_READONLY_PROPERTIES_ONCE);
			}
		});
		functions.put("call", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 1)) {

					final String key = sources[0].toString();

					if (sources.length > 1) {

						Actions.call(key, Arrays.copyOfRange(sources, 1, sources.length));

					} else {

						Actions.call(key);
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_UNLOCK_READONLY_PROPERTIES_ONCE_JS : ERROR_MESSAGE_UNLOCK_READONLY_PROPERTIES_ONCE);
			}
		});
		functions.put("set_privileged", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				Function<Object, Object> set = functions.get("set");
				if (set != null) {

					synchronized (entity) {

						final SecurityContext previousSecurityContext = entity.getSecurityContext();
						entity.setSecurityContext(SecurityContext.getSuperUserInstance());

						try {

							set.apply(ctx, entity, sources);

						} finally {

							entity.setSecurityContext(previousSecurityContext);
						}
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_SET_PRIVILEGED_JS : ERROR_MESSAGE_SET_PRIVILEGED);
			}
		});
		functions.put("cypher", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 1)) {

					final Map<String, Object> params = new LinkedHashMap<>();
					final String query               = sources[0].toString();

					
					if (sources.length > 1 && sources[1] != null && sources[1] instanceof Map) {
						params.putAll((Map)sources[1]);
					}

					return StructrApp.getInstance(ctx.getSecurityContext()).cypher(query, params);
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_SET_PRIVILEGED_JS : ERROR_MESSAGE_SET_PRIVILEGED);
			}
		});
	}

	
	public static boolean arrayHasMinLengthAndAllElementsNotNull(final Object[] array, final Integer minLength) {

		if (array == null) {
			return false;
		}

		for (final Object element : array) {

			if (element == null) {
				return false;
			}

		}

		return minLength != null ? array.length >= minLength : true;

	}

	
	public static boolean arrayHasLengthAndAllElementsNotNull(final Object[] array, final Integer length) {

		if (array == null) {
			return false;
		}

		for (final Object element : array) {

			if (element == null) {
				return false;
			}

		}

		return length != null ? array.length == length : true;

	}

	protected static String serialize(final Gson gson, final Map<String, Object> map) {
		return gson.toJson(map, new TypeToken<Map<String, String>>() {
		}.getType());
	}

	protected static Map<String, Object> deserialize(final Gson gson, final String source) {
		return gson.fromJson(source, new TypeToken<Map<String, Object>>() {
		}.getType());
	}

	protected static Integer parseInt(final Object source) {

		if (source instanceof Integer) {

			return ((Integer) source);
		}

		if (source instanceof Number) {

			return ((Number) source).intValue();
		}

		if (source instanceof String) {

			return Integer.parseInt((String) source);
		}

		return null;
	}

	protected static String encodeURL(final String source) {

		try {
			return URLEncoder.encode(source, "UTF-8");

		} catch (UnsupportedEncodingException ex) {

			logger.log(Level.WARNING, "Unsupported Encoding", ex);
		}

		
		return source;
	}

	protected static double getDoubleForComparison(final Object obj) {

		if (obj instanceof Number) {

			return ((Number) obj).doubleValue();

		} else {

			try {
				return Double.valueOf(obj.toString());

			} catch (Throwable t) {

				t.printStackTrace();
			}
		}

		return 0.0;
	}

	protected static Double getDoubleOrNull(final Object obj) {

		try {

			if (obj instanceof Date) {

				return (double) ((Date) obj).getTime();

			} else if (obj instanceof Number) {

				return ((Number) obj).doubleValue();

			} else {

				Date date = DatePropertyParser.parseISO8601DateString(obj.toString());

				if (date != null) {

					return (double) (date).getTime();
				}

				return Double.parseDouble(obj.toString());

			}

		} catch (Throwable t) {

			t.printStackTrace();
		}

		return null;
	}

	protected static boolean valueEquals(final Object obj1, final Object obj2) {

		if (obj1 instanceof Enum || obj2 instanceof Enum) {

			return obj1.toString().equals(obj2.toString());

		}

		return eq(obj1, obj2);
	}

	protected static String getSandboxFileName(final String source) throws IOException {

		final File sandboxFile = new File(source);
		final String fileName = sandboxFile.getName();
		final String basePath = StructrApp.getConfigurationValue(Services.BASE_PATH);

		if (!basePath.isEmpty()) {

			final String defaultExchangePath = basePath.endsWith("/") ? basePath.concat("exchange") : basePath.concat("/exchange");
			String exchangeDir = StructrApp.getConfigurationValue(Services.DATA_EXCHANGE_PATH, defaultExchangePath);

			if (!exchangeDir.endsWith("/")) {
				exchangeDir = exchangeDir.concat("/");
			}

			
			final File dir = new File(exchangeDir);
			if (!dir.exists()) {

				dir.mkdirs();
			}

			
			return exchangeDir.concat(fileName);

		} else {

			logger.log(Level.WARNING, "Unable to determine base.path from structr.conf, no data input/output possible.");
		}

		return null;
	}

	public static String cleanString(final Object input) {

		if (input == null) {

			return "";

		}

		String normalized = Normalizer.normalize(input.toString(), Normalizer.Form.NFD)
			.replaceAll("\\<", "")
			.replaceAll("\\>", "")
			.replaceAll("\\.", "")
			.replaceAll("\\'", "-")
			.replaceAll("\\?", "")
			.replaceAll("\\(", "")
			.replaceAll("\\)", "")
			.replaceAll("\\{", "")
			.replaceAll("\\}", "")
			.replaceAll("\\[", "")
			.replaceAll("\\]", "")
			.replaceAll("\\+", "-")
			.replaceAll("/", "-")
			.replaceAll("", "-")
			.replaceAll("\\\\", "-")
			.replaceAll("\\|", "-")
			.replaceAll("'", "-")
			.replaceAll("!", "")
			.replaceAll(",", "")
			.replaceAll("-", " ")
			.replaceAll("_", " ")
			.replaceAll("`", "-");

		String result = normalized.replaceAll("-", " ");
		result = StringUtils.normalizeSpace(result.toLowerCase());
		result = result.replaceAll("[^\\p{ASCII}]", "").replaceAll("\\p{P}", "-").replaceAll("\\-(\\s+\\-)+", "-");
		result = result.replaceAll(" ", "-");

		return result;

	}

	public static void recursivelyConvertMapToGraphObjectMap(final GraphObjectMap destination, final Map<String, Object> source, final int depth) {

		if (depth > 20) {
			return;
		}

		for (final Map.Entry<String, Object> entry : source.entrySet()) {

			final String key = entry.getKey();
			final Object value = entry.getValue();

			if (value instanceof Map) {

				final Map<String, Object> map = (Map<String, Object>) value;
				final GraphObjectMap obj = new GraphObjectMap();

				destination.put(new StringProperty(key), obj);

				recursivelyConvertMapToGraphObjectMap(obj, map, depth + 1);

			} else if (value instanceof Collection) {

				final List list = new LinkedList();
				final Collection collection = (Collection) value;

				for (final Object obj : collection) {

					if (obj instanceof Map) {

						final GraphObjectMap container = new GraphObjectMap();
						list.add(container);

						recursivelyConvertMapToGraphObjectMap(container, (Map<String, Object>) obj, depth + 1);

					} else {

						list.add(obj);
					}
				}

				destination.put(new StringProperty(key), list);

			} else {

				destination.put(new StringProperty(key), value);
			}
		}
	}

	public static Object numberOrString(final String value) {

		if (value != null) {

			if ("true".equals(value.toLowerCase())) {
				return true;
			}

			if ("false".equals(value.toLowerCase())) {
				return false;
			}

			if (NumberUtils.isNumber(value)) {
				return NumberUtils.createNumber(value);
			}
		}

		return value;
	}

	private static int compareBooleanBoolean(final Object o1, final Object o2) {

		final Boolean value1 = (Boolean) o1;
		final Boolean value2 = (Boolean) o2;

		return value1.compareTo(value2);
	}

	private static int compareNumberNumber(final Object o1, final Object o2) {

		final Double value1 = getDoubleForComparison(o1);
		final Double value2 = getDoubleForComparison(o2);

		return value1.compareTo(value2);
	}

	private static int compareStringString(final Object o1, final Object o2) {

		final String value1 = (String) o1;
		final String value2 = (String) o2;

		return value1.compareTo(value2);
	}

	private static int compareDateDate(final Object o1, final Object o2) {

		final Date value1 = (Date) o1;
		final Date value2 = (Date) o2;

		return value1.compareTo(value2);
	}

	private static int compareDateString(final Object o1, final Object o2) {

		final String value1 = DatePropertyParser.format((Date) o1, DateProperty.DEFAULT_FORMAT);
		final String value2 = (String) o2;

		return value1.compareTo(value2);
	}

	private static int compareStringDate(final Object o1, final Object o2) {

		final String value1 = (String) o1;
		final String value2 = DatePropertyParser.format((Date) o2, DateProperty.DEFAULT_FORMAT);

		return value1.compareTo(value2);
	}

	private static int compareBooleanString(final Object o1, final Object o2) {

		return -1;
	}

	private static int compareStringBoolean(final Object o1, final Object o2) {

		return -1;
	}

	private static int compareNumberString(final Object o1, final Object o2) {

		final Double value1 = getDoubleForComparison(o1);
		final Double value2 = Double.parseDouble((String) o2);

		return (value1.compareTo(value2) == 0 ? -1 : value1.compareTo(value2));
	}

	private static int compareStringNumber(final Object o1, final Object o2) {

		final Double value1 = Double.parseDouble((String) o1);
		final Double value2 = getDoubleForComparison(o2);

		return (value1.compareTo(value2) == 0 ? -1 : value1.compareTo(value2));
	}

	private static boolean gt(final Object o1, final Object o2) {

		if (o1 instanceof Number && o2 instanceof Number) {

			return compareNumberNumber(o1, o2) > 0;

		} else if (o1 instanceof String && o2 instanceof String) {

			return compareStringString(o1, o2) > 0;

		} else if (o1 instanceof Date && o2 instanceof Date) {

			return compareDateDate(o1, o2) > 0;

		} else if (o1 instanceof Date && o2 instanceof String) {

			return compareDateString(o1, o2) > 0;

		} else if (o1 instanceof String && o2 instanceof Date) {

			return compareStringDate(o1, o2) > 0;

		} else if (o1 instanceof Boolean && o2 instanceof String) {

			return compareBooleanString(o1, o2) > 0;

		} else if (o1 instanceof String && o2 instanceof Boolean) {

			return compareStringBoolean(o1, o2) > 0;

		} else if (o1 instanceof Number && o2 instanceof String) {

			return compareNumberString(o1, o2) > 0;

		} else if (o1 instanceof String && o2 instanceof Number) {

			return compareStringNumber(o1, o2) > 0;

		} else {

			return compareStringString(o1.toString(), o2.toString()) > 0;

		}
	}

	private static boolean lt(final Object o1, final Object o2) {

		if (o1 instanceof Number && o2 instanceof Number) {

			return compareNumberNumber(o1, o2) < 0;

		} else if (o1 instanceof String && o2 instanceof String) {

			return compareStringString(o1, o2) < 0;

		} else if (o1 instanceof Date && o2 instanceof Date) {

			return compareDateDate(o1, o2) < 0;

		} else if (o1 instanceof Date && o2 instanceof String) {

			return compareDateString(o1, o2) < 0;

		} else if (o1 instanceof String && o2 instanceof Date) {

			return compareStringDate(o1, o2) < 0;

		} else if (o1 instanceof Boolean && o2 instanceof String) {

			return compareBooleanString(o1, o2) < 0;

		} else if (o1 instanceof String && o2 instanceof Boolean) {

			return compareStringBoolean(o1, o2) < 0;

		} else if (o1 instanceof Number && o2 instanceof String) {

			return compareNumberString(o1, o2) < 0;

		} else if (o1 instanceof String && o2 instanceof Number) {

			return compareStringNumber(o1, o2) < 0;

		} else {

			return compareStringString(o1.toString(), o2.toString()) < 0;

		}
	}

	private static boolean eq(final Object o1, final Object o2) {

		if (o1 instanceof Number && o2 instanceof Number) {

			return compareNumberNumber(o1, o2) == 0;

		} else if (o1 instanceof String && o2 instanceof String) {

			return compareStringString(o1, o2) == 0;

		} else if (o1 instanceof Date && o2 instanceof Date) {

			return compareDateDate(o1, o2) == 0;

		} else if (o1 instanceof Date && o2 instanceof String) {

			return compareDateString(o1, o2) == 0;

		} else if (o1 instanceof String && o2 instanceof Date) {

			return compareStringDate(o1, o2) == 0;

		} else if (o1 instanceof Boolean && o2 instanceof String) {

			return compareBooleanString(o1, o2) == 0;

		} else if (o1 instanceof String && o2 instanceof Boolean) {

			return compareStringBoolean(o1, o2) == 0;

		} else if (o1 instanceof Number && o2 instanceof String) {

			return compareNumberString(o1, o2) == 0;

		} else if (o1 instanceof String && o2 instanceof Number) {

			return compareStringNumber(o1, o2) == 0;

		} else {

			return compareStringString(o1.toString(), o2.toString()) == 0;

		}
	}

	private static boolean gte(final Object o1, final Object o2) {
		return eq(o1, o2) || gt(o1, o2);
	}

	private static boolean lte(final Object o1, final Object o2) {
		return eq(o1, o2) || lt(o1, o2);
	}

}

<code block>



package org.structr.schema;

import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.structr.common.StructrConf;
import org.structr.common.error.ErrorBuffer;
import org.structr.common.error.FrameworkException;
import org.structr.core.Command;
import org.structr.core.Service;
import org.structr.core.app.App;
import org.structr.core.app.StructrApp;
import org.structr.core.entity.SchemaNode;
import org.structr.core.entity.SchemaRelationshipNode;
import org.structr.core.graph.NodeFactory;
import org.structr.core.graph.RelationshipFactory;
import org.structr.core.graph.Tx;
import org.structr.core.graph.search.SearchCommand;
import org.structr.schema.compiler.NodeExtender;


public class SchemaService implements Service {

	private static final Logger logger                            = Logger.getLogger(SchemaService.class.getName());
	private static final AtomicBoolean compiling                  = new AtomicBoolean(false);
	private static final Map<String, String> builtinTypeMap       = new LinkedHashMap<>();

	@Override
	public void injectArguments(final Command command) {
	}

	@Override
	public void initialize(final StructrConf config) {
		reloadSchema(new ErrorBuffer());
	}

	public static void registerBuiltinTypeOverride(final String type, final String fqcn) {
		builtinTypeMap.put(type, fqcn);
	}

	public static boolean reloadSchema(final ErrorBuffer errorBuffer) {

		final ConfigurationProvider config = StructrApp.getConfiguration();
		boolean success = true;

		
		if (compiling.compareAndSet(false, true)) {

			try {

				final Set<String> dynamicViews  = new LinkedHashSet<>();
				final NodeExtender nodeExtender = new NodeExtender();

				try (final Tx tx = StructrApp.getInstance().tx()) {

					SchemaService.ensureBuiltinTypesExist();

					
					final List<SchemaNode> schemaNodes = StructrApp.getInstance().nodeQuery(SchemaNode.class).getAsList();
					for (final SchemaNode schemaNode : schemaNodes) {

						nodeExtender.addClass(schemaNode.getClassName(), schemaNode.getSource(errorBuffer));

						final String auxSource = schemaNode.getAuxiliarySource();
						if (auxSource != null) {

							nodeExtender.addClass("_" + schemaNode.getClassName() + "Helper", auxSource);
						}

						dynamicViews.addAll(schemaNode.getViews());
					}

					
					for (final SchemaRelationshipNode schemaRelationship : StructrApp.getInstance().nodeQuery(SchemaRelationshipNode.class).getAsList()) {

						nodeExtender.addClass(schemaRelationship.getClassName(), schemaRelationship.getSource(errorBuffer));

						final String auxSource = schemaRelationship.getAuxiliarySource();
						if (auxSource != null) {

							nodeExtender.addClass("_" + schemaRelationship.getClassName() + "Helper", auxSource);
						}

						dynamicViews.addAll(schemaRelationship.getViews());
					}

					
					synchronized (SchemaService.class) {

						
						Map<String, Class> newTypes = nodeExtender.compile(errorBuffer);

						for (final Class newType : newTypes.values()) {

							
							config.registerEntityType(newType);

							
							
							try { newType.newInstance(); } catch (Throwable t) {}
						}
					}

					
					for (final SchemaNode schemaNode : StructrApp.getInstance().nodeQuery(SchemaNode.class).getAsList()) {
						schemaNode.createBuiltInSchemaEntities(errorBuffer);
					}

					
					SearchCommand.clearInheritanceMap();
					NodeFactory.invalidateCache();
					RelationshipFactory.invalidateCache();

					success = !errorBuffer.hasError();

					
					if (success) {

						config.registerDynamicViews(dynamicViews);
						tx.success();
					}

				} catch (Throwable t) {

					logger.log(Level.SEVERE, "Unable to compile dynamic schema.", t);
					t.printStackTrace();

					success = false;
				}

				calculateHierarchy();

			} finally {

				
				compiling.set(false);

			}
		}

		return success;
	}

	@Override
	public void initialized() {
	}

	@Override
	public void shutdown() {
	}

	@Override
	public String getName() {
		return SchemaService.class.getName();
	}

	@Override
	public boolean isRunning() {
		return true;
	}

	public static void ensureBuiltinTypesExist() throws FrameworkException {

		final App app = StructrApp.getInstance();

		for (final Entry<String, String> entry : builtinTypeMap.entrySet()) {

			final String type = entry.getKey();
			final String fqcn = entry.getValue();

			SchemaNode schemaNode = app.nodeQuery(SchemaNode.class).andName(type).getFirst();
			if (schemaNode == null) {

				schemaNode = app.create(SchemaNode.class, type);
			}

			schemaNode.setProperty(SchemaNode.extendsClass, fqcn);
			schemaNode.unlockReadOnlyPropertiesOnce();
			schemaNode.setProperty(SchemaNode.isBuiltinType, true);
		}
	}

	@Override
	public boolean isVital() {
		return true;
	}

	
	private static void calculateHierarchy() {

		try (final Tx tx = StructrApp.getInstance().tx()) {

			final List<SchemaNode> schemaNodes  = StructrApp.getInstance().nodeQuery(SchemaNode.class).getAsList();
			final Set<String> alreadyCalculated = new HashSet<>();
			final Map<String, SchemaNode> map   = new LinkedHashMap<>();

			
			for (final SchemaNode schemaNode : schemaNodes) {
				map.put(schemaNode.getName(), schemaNode);
			}

			
			for (final SchemaNode schemaNode : schemaNodes) {

				final int relCount = schemaNode.getProperty(SchemaNode.relatedFrom).size() + schemaNode.getProperty(SchemaNode.relatedTo).size();
				final int level    = recursiveGetHierarchyLevel(map, alreadyCalculated, schemaNode);

				schemaNode.setProperty(SchemaNode.hierarchyLevel, level);
				schemaNode.setProperty(SchemaNode.relCount, relCount);
			}

			tx.success();

		} catch (FrameworkException fex) {
			fex.printStackTrace();
		}
	}

	private static int recursiveGetHierarchyLevel(final Map<String, SchemaNode> map, final Set<String> alreadyCalculated, final SchemaNode schemaNode) {

		String superclass = schemaNode.getProperty(SchemaNode.extendsClass);
		if (superclass == null) {

			return 0;

		} else if (superclass.startsWith("org.structr.dynamic.")) {

			
			superclass = superclass.substring(superclass.lastIndexOf(".") + 1);

			
			final SchemaNode superSchemaNode = map.get(superclass);
			if (superSchemaNode != null) {

				return recursiveGetHierarchyLevel(map, alreadyCalculated, superSchemaNode) + 1;
			}
		}

		return 0;
	}
}

<code block>

package org.structr.core;

import java.io.File;
import java.io.IOException;
import java.net.URI;
import java.nio.file.Files;
import java.util.Arrays;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.commons.configuration.ConfigurationException;
import org.apache.commons.configuration.PropertiesConfiguration;
import org.apache.commons.lang3.RandomStringUtils;
import org.apache.commons.lang3.StringUtils;
import org.neo4j.graphdb.GraphDatabaseService;
import org.neo4j.graphdb.Node;
import org.neo4j.graphdb.Relationship;
import org.neo4j.tooling.GlobalGraphOperations;
import org.structr.common.Permission;
import org.structr.common.Permissions;
import org.structr.common.SecurityContext;
import org.structr.common.StructrConf;
import org.structr.core.app.App;
import org.structr.core.app.StructrApp;
import org.structr.core.graph.NodeFactory;
import org.structr.core.graph.NodeInterface;
import org.structr.core.graph.NodeService;
import org.structr.core.graph.RelationshipFactory;
import org.structr.core.graph.RelationshipInterface;
import org.structr.core.graph.Tx;
import org.structr.core.property.StringProperty;
import org.structr.module.JarConfigurationProvider;
import org.structr.schema.ConfigurationProvider;




public class Services {

	private static final Logger logger                              = Logger.getLogger(StructrApp.class.getName());
	private static StructrConf baseConf                             = null;

	
	public static final String INITIAL_SEED_FILE                    = "seed.zip";
	public static final String BASE_PATH                            = "base.path";
	public static final String CONFIGURED_SERVICES                  = "configured.services";
	public static final String CONFIG_FILE_PATH                     = "configfile.path";
	public static final String DATABASE_PATH                        = "database.path";
	public static final String FILES_PATH                           = "files.path";
	public static final String DATA_EXCHANGE_PATH                   = "data.exchange.path";
	public static final String LOG_DATABASE_PATH                    = "log.database.path";
	public static final String FOREIGN_TYPE                         = "foreign.type.key";
	public static final String NEO4J_SHELL_ENABLED                  = "neo4j.shell.enabled";
	public static final String NEO4J_SHELL_PORT                     = "neo4j.shell.port";
	public static final String NEO4J_PAGE_CACHE_MEMORY              = "neo4j.pagecache.memory";
	public static final String LOG_SERVICE_INTERVAL                 = "structr.logging.interval";
	public static final String LOG_SERVICE_THRESHOLD                = "structr.logging.threshold";
	public static final String SERVER_IP                            = "server.ip";
	public static final String SMTP_HOST                            = "smtp.host";
	public static final String SMTP_PORT                            = "smtp.port";
	public static final String SMTP_USER                            = "smtp.user";
	public static final String SMTP_PASSWORD                        = "smtp.password";
	public static final String SMTP_USE_TLS                         = "smtp.tls.enabled";
	public static final String SMTP_REQUIRE_TLS                     = "smtp.tls.required";
	public static final String SUPERUSER_USERNAME                   = "superuser.username";
	public static final String SUPERUSER_PASSWORD                   = "superuser.password";
	public static final String TCP_PORT                             = "tcp.port";
	public static final String TMP_PATH                             = "tmp.path";
	public static final String UDP_PORT                             = "udp.port";
	public static final String JSON_INDENTATION                     = "json.indentation";
	public static final String JSON_REDUNDANCY_REDUCTION            = "json.redundancyReduction";
	public static final String GEOCODING_PROVIDER                   = "geocoding.provider";
	public static final String GEOCODING_LANGUAGE                   = "geocoding.language";
	public static final String GEOCODING_APIKEY                     = "geocoding.apikey";
	public static final String CONFIGURATION                        = "configuration.provider";
	public static final String TESTING                              = "testing";
	public static final String MIGRATION_KEY                        = "NodeService.migration";
	public static final String ACCESS_CONTROL_MAX_AGE               = "access.control.max.age";
	public static final String ACCESS_CONTROL_ALLOW_METHODS         = "access.control.allow.methods";
	public static final String ACCESS_CONTROL_ALLOW_HEADERS         = "access.control.allow.headers";
	public static final String ACCESS_CONTROL_ALLOW_CREDENTIALS     = "access.control.allow.credentials";
	public static final String ACCESS_CONTROL_EXPOSE_HEADERS        = "access.control.expose.headers";
	public static final String APPLICATION_SESSION_TIMEOUT          = "application.session.timeout";
	public static final String APPLICATION_SECURITY_OWNERLESS_NODES = "application.security.ownerless.nodes";
	public static final String APPLICATION_UUID_CACHE_SIZE          = "application.cache.uuid.size";
	public static final String SNAPSHOT_PATH                        = "snapshot.path";
	public static final String WEBSOCKET_FRONTEND_ACCESS            = "WebSocketServlet.frontendAccess";

	
	private static int globalSessionTimeout            = -1;
	private static Services singletonInstance          = null;

	
	private final List<InitializationCallback> callbacks       = new LinkedList<>();
	private final Set<Permission> permissionsForOwnerlessNodes = new LinkedHashSet<>();
	private final Map<String, Object> attributes               = new ConcurrentHashMap<>(10, 0.9f, 8);
	private final Map<Class, Service> serviceCache             = new ConcurrentHashMap<>(10, 0.9f, 8);
	private final Set<Class> registeredServiceClasses          = new LinkedHashSet<>();
	private final Set<String> configuredServiceClasses         = new LinkedHashSet<>();
	private StructrConf structrConf                            = new StructrConf();
	private ConfigurationProvider configuration                = null;
	private boolean initializationDone                         = false;
	private boolean shutdownDone                               = false;
	private String configuredServiceNames                      = null;
	private String configurationClass                          = null;

	private Services() { }

	public static Services getInstance() {

		if (singletonInstance == null) {

			singletonInstance = new Services();
			singletonInstance.initialize();

			new Thread(new Runnable() {

				@Override
				public void run() {

					
					try { Thread.sleep(1000); } catch (Throwable ignore) {}

					
					for (final InitializationCallback callback : singletonInstance.callbacks) {
						callback.initializationDone();
					}
				}

			}).start();

		}

		return singletonInstance;
	}

	public static Services getInstance(final StructrConf properties) {

		if (singletonInstance == null) {

			singletonInstance = new Services();
			singletonInstance.initialize(properties);
		}

		return singletonInstance;
	}

	
	public <T extends Command> T command(SecurityContext securityContext, Class<T> commandType) {

		Class serviceClass = null;
		T command          = null;

		try {

			command = commandType.newInstance();
			command.setSecurityContext(securityContext);

			serviceClass = command.getServiceClass();

			if ((serviceClass != null) && configuredServiceClasses.contains(serviceClass.getSimpleName())) {

				
				Service service = serviceCache.get(serviceClass);

				if (service == null) {

					
					service = createService(serviceClass);

				} else {

					
					if (service instanceof RunnableService) {

						RunnableService runnableService = (RunnableService) service;

						if (!runnableService.isRunning()) {

							runnableService.stopService();
							runnableService.shutdown();
							service = createService(serviceClass);
						}
					}
				}

				logger.log(Level.FINEST, "Initializing command ", commandType.getName());
				service.injectArguments(command);
			}

		} catch (Throwable t) {

			t.printStackTrace();

			logger.log(Level.SEVERE, "Exception while creating command " + commandType.getName(), t);
		}

		return (command);
	}

	private void initialize() {

		final StructrConf config = getBaseConfiguration();

		
		final String configTemplateFileName = "structr.conf_templ";
		final String configFileName         = "structr.conf";
		final File configTemplateFile       = new File(configTemplateFileName);
		final File configFile               = new File(configFileName);

		if (!configFile.exists() && !configTemplateFile.exists()) {

			logger.log(Level.SEVERE, "Unable to create config file, {0} and {1} do not exist, aborting. Please create a {0} configuration file and try again.", new Object[] { configFileName, configTemplateFileName } );

			
			System.exit(1);
		}

		if (!configFile.exists() && configTemplateFile.exists()) {

			logger.log(Level.WARNING, "Configuration file {0} not found, copying from template {1}. Please adapt newly created {0} to your needs.", new Object[] { configFileName, configTemplateFileName } );

			try {
				Files.copy(configTemplateFile.toPath(), configFile.toPath());

			} catch (IOException ioex) {

				logger.log(Level.SEVERE, "Unable to create config file, copying of template failed.", ioex);

				System.exit(1);
			}
		}

		logger.log(Level.INFO, "Reading {0}..", configFileName);

		try {




			PropertiesConfiguration.setDefaultListDelimiter('\0');
			final PropertiesConfiguration propConf = new PropertiesConfiguration(configFileName);

			structrConf.load(propConf);

		} catch (ConfigurationException ex) {
			logger.log(Level.SEVERE, null, ex);
		}

		mergeConfiguration(config, structrConf);

		initialize(config);
	}

	private void initialize(final StructrConf properties) {

		this.structrConf = properties;

		configurationClass     = properties.getProperty(Services.CONFIGURATION);
		configuredServiceNames = properties.getProperty(Services.CONFIGURED_SERVICES);

		
		configuredServiceClasses.addAll(Arrays.asList(configuredServiceNames.split("[ ,]+")));

		
		
		
		getConfigurationProvider();

		logger.log(Level.INFO, "Starting services");

		
		for (final String serviceClassName : configuredServiceClasses) {

				Class serviceClass = getServiceClassForName(serviceClassName);
				if (serviceClass != null) {

					try {

						final Service service = createService(serviceClass);
						if (service != null) {

							service.initialized();

						} else {

							logger.log(Level.WARNING, "Service {0} was not started!", serviceClassName);
						}

					} catch (Throwable t) {

						logger.log(Level.WARNING, "Exception while registering service {0}: {1}", new Object[] { serviceClassName, t });
						t.printStackTrace();
					}
				}
		}

		logger.log(Level.INFO, "{0} service(s) processed", serviceCache.size());
		registeredServiceClasses.clear();

		
		if (getService(NodeService.class) != null) {

			if ("true".equals(properties.getProperty(Services.MIGRATION_KEY))) {
				migrateDatabase();
			}
		}

		logger.log(Level.INFO, "Registering shutdown hook.");

		
		Runtime.getRuntime().addShutdownHook(new Thread() {

			@Override
			public void run() {

				shutdown();
			}
		});

		
		final String configForOwnerlessNodes = this.structrConf.getProperty(Services.APPLICATION_SECURITY_OWNERLESS_NODES, "read");
		if (StringUtils.isNotBlank(configForOwnerlessNodes)) {

			for (final String permission : configForOwnerlessNodes.split("[, ]+")) {

				final String trimmed = permission.trim();
				if (StringUtils.isNotBlank(trimmed)) {

					final Permission val = Permissions.valueOf(trimmed);
					if (val != null) {

						permissionsForOwnerlessNodes.add(val);

					} else {

						logger.log(Level.WARNING, "Invalid permisson {0}, ignoring.", trimmed);
					}
				}
			}

		} else {

			
			permissionsForOwnerlessNodes.add(Permission.read);
		}

		logger.log(Level.INFO, "Initialization complete");

		initializationDone = true;
	}

	public void registerInitializationCallback(final InitializationCallback callback) {
		callbacks.add(callback);
	}

	public boolean isInitialized() {
		return initializationDone;
	}

	public void shutdown() {

		initializationDone = false;

		if (!shutdownDone) {

			System.out.println("INFO: Shutting down...");
			for (Service service : serviceCache.values()) {

				try {

					if (service instanceof RunnableService) {

						RunnableService runnableService = (RunnableService) service;

						if (runnableService.isRunning()) {
							runnableService.stopService();
						}
					}

					service.shutdown();

				} catch (Throwable t) {

					System.out.println("WARNING: Failed to shut down " + service.getName() + ": " + t.getMessage());
				}
			}

			serviceCache.clear();

			
			configuration.shutdown();

			
			singletonInstance = null;

			System.out.println("INFO: Shutdown complete");

			
			shutdownDone = true;
		}

	}

	
	public void registerServiceClass(Class serviceClass) {

		registeredServiceClasses.add(serviceClass);










	}

	public String getConfigurationValue(String key) {
		return getConfigurationValue(key, "");
	}

	public String getConfigurationValue(String key, String defaultValue) {
		return getCurrentConfig().getProperty(key, defaultValue);
	}

	public Class getServiceClassForName(final String serviceClassName) {

		for (Class serviceClass : registeredServiceClasses) {

			if (serviceClass.getSimpleName().equals(serviceClassName)) {
				return serviceClass;
			}

		}

		return null;
	}

	public ConfigurationProvider getConfigurationProvider() {

		
		if (configuration == null) {

			
			
			
			
			try {

				configuration = (ConfigurationProvider)Class.forName(configurationClass).newInstance();
				configuration.initialize();

			} catch (Throwable t) {

				t.printStackTrace();

				logger.log(Level.SEVERE, "Unable to instantiate schema provider of type {0}: {1}", new Object[] { configurationClass, t.getMessage() });
			}
		}

		return configuration;
	}

	
	public void setAttribute(final String name, final Object value) {
		synchronized (attributes) {
			attributes.put(name, value);
		}
	}

	
	public Object getAttribute(final String name) {
		return attributes.get(name);
	}

	
	public void removeAttribute(final String name) {
		attributes.remove(name);
	}

	private Service createService(Class serviceClass) {

		logger.log(Level.FINE, "Creating service ", serviceClass.getName());

		Service service = null;

		try {

			service = (Service) serviceClass.newInstance();
			service.initialize(getCurrentConfig());

			if (service instanceof RunnableService) {

				RunnableService runnableService = (RunnableService) service;

				if (runnableService.runOnStartup()) {

					logger.log(Level.FINER, "Starting RunnableService instance ", serviceClass.getName());

					
					runnableService.startService();
					serviceCache.put(serviceClass, service);
				}

			} else if (service instanceof SingletonService) {

				
				serviceCache.put(serviceClass, service);
			}

		} catch (Throwable t) {

			t.printStackTrace();

			if (service.isVital()) {

				logger.log(Level.SEVERE, "Vital service {0} failed to start: {1}. Aborting", new Object[] { service.getClass().getSimpleName(), t.getMessage() } );

				
				System.exit(1);

			} else {

				logger.log(Level.SEVERE, "Service {0} failed to start: {1}.", new Object[] { service.getClass().getSimpleName(), t.getMessage() } );
			}
		}

		return service;
	}

	
	public List<Service> getServices() {

		List<Service> services = new LinkedList<>();
		for (Service service : serviceCache.values()) {
			services.add(service);
		}

		return services;
	}

	public <T extends Service> T getService(final Class<T> type) {
		return (T) serviceCache.get(type);
	}

	public String getConfigValue(final Map<String, String> config, final String key, final String defaultValue) {

		String value = StringUtils.strip(config.get(key));

		if (value != null) {
			return value;
		}

		return defaultValue;
	}

	
	public boolean isReady(final Class serviceClass) {
                Service service = serviceCache.get(serviceClass);
                return (service != null && service.isRunning());
	}

	public StructrConf getCurrentConfig() {
		return structrConf;
	}

	public Set<String> getResources() {

		final Set<String> resources = new LinkedHashSet<>();

		
		for (final Object configurationValue : structrConf.values()) {

			for (final String value : configurationValue.toString().split("[\\s ,;]+")) {

				try {

					
					final Class candidate = Class.forName(value);
					if (!candidate.getName().startsWith("org.structr")) {

						final String codeLocation = candidate.getProtectionDomain().getCodeSource().getLocation().toString();
						if (codeLocation.startsWith("file:") && codeLocation.endsWith(".jar") || codeLocation.endsWith(".war")) {

							final File file = new File(URI.create(codeLocation));
							if (file.exists()) {

								resources.add(file.getAbsolutePath());
							}
						}
					}

				} catch (Throwable ignore) { }
			}
		}

		logger.log(Level.INFO, "Found {0} possible resources: {1}", new Object[] { resources.size(), resources } );

		return resources;
	}

	public static StructrConf getBaseConfiguration() {

		if (baseConf == null) {

			baseConf = new StructrConf();

			baseConf.setProperty(CONFIGURATION,             JarConfigurationProvider.class.getName());
			baseConf.setProperty(CONFIGURED_SERVICES,       "NodeService AgentService CronService SchemaService");
			baseConf.setProperty(NEO4J_SHELL_ENABLED,       "true");
			baseConf.setProperty(NEO4J_SHELL_PORT,          "1337");
			baseConf.setProperty(JSON_INDENTATION,          "true");

			baseConf.setProperty(SUPERUSER_USERNAME,        "superadmin");
			baseConf.setProperty(SUPERUSER_PASSWORD,        RandomStringUtils.randomAlphanumeric(12));

			baseConf.setProperty(BASE_PATH,                 "");
			baseConf.setProperty(TMP_PATH,                  "/tmp");
			baseConf.setProperty(DATABASE_PATH,             System.getProperty("user.dir").concat("/db"));
			baseConf.setProperty(FILES_PATH,                System.getProperty("user.dir").concat("/files"));
			baseConf.setProperty(LOG_DATABASE_PATH,         System.getProperty("user.dir").concat("/logDb.dat"));

			baseConf.setProperty(SMTP_HOST,                 "localhost");
			baseConf.setProperty(SMTP_PORT,                 "25");
			baseConf.setProperty(TCP_PORT,                  "54555");
			baseConf.setProperty(UDP_PORT,                  "57555");
		}

		return baseConf;
	}

	public static void mergeConfiguration(final StructrConf baseConfig, final StructrConf additionalConfig) {
		baseConfig.putAll(additionalConfig);
		trim(baseConfig);
	}


	private void migrateDatabase() {

		final GraphDatabaseService graphDb     = getService(NodeService.class).getGraphDb();
		final SecurityContext superUserContext = SecurityContext.getSuperUserInstance();
		final NodeFactory nodeFactory          = new NodeFactory(superUserContext);
		final RelationshipFactory relFactory   = new RelationshipFactory(superUserContext);
		final App app                          = StructrApp.getInstance();
		final StringProperty uuidProperty      = new StringProperty("uuid");
		final int txLimit                      = 2000;

		boolean hasChanges                     = true;
		int actualNodeCount                    = 0;
		int actualRelCount                     = 0;

		logger.log(Level.INFO, "Migration of ID properties from uuid to id requested.");

		while (hasChanges) {

			hasChanges = false;

			try (final Tx tx = app.tx(false, false)) {

				
				final Iterator<Node> allNodes = GlobalGraphOperations.at(graphDb).getAllNodes().iterator();
				while (allNodes.hasNext()) {

					final Node node = allNodes.next();

					
					if (node.hasProperty("uuid") && node.getProperty("uuid") instanceof String && !node.hasProperty("id")) {

						try {
							final NodeInterface nodeInterface = nodeFactory.instantiate(node);
							final String uuid = nodeInterface.getProperty(uuidProperty);

							if (uuid != null) {

								nodeInterface.setProperty(GraphObject.id, uuid);
								nodeInterface.removeProperty(uuidProperty);
								actualNodeCount++;
								hasChanges = true;
							}

						} catch (Throwable t) {
							t.printStackTrace();
						}
					}

					
					if (hasChanges && (actualNodeCount % txLimit) == 0) {
						break;
					}
				}

				tx.success();

			} catch (Throwable t) {

				t.printStackTrace();
			}

			logger.log(Level.INFO, "Migrated {0} nodes so far.", actualNodeCount);
		}

		logger.log(Level.INFO, "Migrated {0} nodes to new ID property.", actualNodeCount);

		
		hasChanges = true;
		while (hasChanges) {

			hasChanges = false;

			try (final Tx tx = app.tx(false, false)) {

				final Iterator<Relationship> allRels = GlobalGraphOperations.at(graphDb).getAllRelationships().iterator();
				while (allRels.hasNext()) {

					final Relationship rel = allRels.next();

					
					if (rel.hasProperty("uuid") && rel.getProperty("uuid") instanceof String && !rel.hasProperty("id")) {

						try {
							final RelationshipInterface relInterface = relFactory.instantiate(rel);
							final String uuid = relInterface.getProperty(uuidProperty);

							if (uuid != null) {
								relInterface.setProperty(GraphObject.id, uuid);
								relInterface.removeProperty(uuidProperty);
								actualRelCount++;
								hasChanges = true;
							}

						} catch (Throwable t) {
							t.printStackTrace();
						}
					}

					
					if (hasChanges && (actualRelCount % txLimit) == 0) {
						break;
					}
				}

				tx.success();

			} catch (Throwable t) {

				t.printStackTrace();
			}

			logger.log(Level.INFO, "Migrated {0} relationships so far.", actualRelCount);
		}

		logger.log(Level.INFO, "Migrated {0} relationships to new ID property.", actualRelCount);
	}

	public static String trim(final String value) {
		return StringUtils.trim(value);
	}

	public static void trim(StructrConf properties) {
		for (Object k : properties.keySet()) {
			properties.put(k, trim((String) properties.get(k)));
		}
	}

	
	public static int parseInt(String value, int defaultValue) {

		if (StringUtils.isBlank(value)) {
			return defaultValue;
		}

		try {
			return Integer.parseInt(value);
		} catch (NumberFormatException ignore) {}

		return defaultValue;
	}

	public static boolean parseBoolean(String value, boolean defaultValue) {

		if (StringUtils.isBlank(value)) {
			return defaultValue;
		}

		try {
			return Boolean.parseBoolean(value);
		} catch(Throwable ignore) {}

		return defaultValue;
	}

	public static int getGlobalSessionTimeout() {

		if (globalSessionTimeout == -1) {
			globalSessionTimeout = parseInt(Services.getInstance().getConfigurationValue(APPLICATION_SESSION_TIMEOUT, "1800"), 1800);
		}

		return globalSessionTimeout;
	}

	public static Set<Permission> getPermissionsForOwnerlessNodes() {
		return getInstance().permissionsForOwnerlessNodes;
	}

	
	public static interface InitializationCallback {
		public void initializationDone();
	}
}

<code block>

package org.structr.core.property;

import java.util.LinkedHashSet;
import java.util.Set;
import org.neo4j.graphdb.DynamicLabel;
import org.neo4j.graphdb.Label;
import org.neo4j.graphdb.Node;
import org.structr.common.SecurityContext;
import org.structr.common.error.FrameworkException;
import org.structr.core.GraphObject;
import org.structr.core.app.StructrApp;
import org.structr.core.graph.NodeInterface;
import org.structr.core.graph.search.SearchCommand;


public class TypeProperty extends StringProperty {

	public TypeProperty() {

		super("type");

		readOnly();
		indexed();
		writeOnce();
	}

	@Override
	public void setProperty(SecurityContext securityContext, final GraphObject obj, String value) throws FrameworkException {

		super.setProperty(securityContext, obj, value);

		if (obj instanceof NodeInterface) {

			final Class type              = StructrApp.getConfiguration().getNodeEntityClass(value);
			final Set<Label> intersection = new LinkedHashSet<>();
			final Set<Label> toRemove     = new LinkedHashSet<>();
			final Set<Label> toAdd        = new LinkedHashSet<>();
			final Node dbNode             = ((NodeInterface)obj).getNode();

			
			for (final Label label : dbNode.getLabels()) {
				toRemove.add(label);
			}

			
			for (final Class supertype : SearchCommand.typeAndAllSupertypes(type)) {
				toAdd.add(DynamicLabel.label(supertype.getSimpleName()));
			}

			
			intersection.addAll(toAdd);
			intersection.retainAll(toRemove);

			
			toAdd.removeAll(intersection);
			toRemove.removeAll(intersection);

			
			for (final Label remove : toRemove) {
				dbNode.removeLabel(remove);
			}

			
			for (final Label add : toAdd) {
				dbNode.addLabel(add);
			}
		}
	}
}

<code block>

package org.structr.core.graph;

import org.neo4j.graphdb.Node;

import org.structr.common.SecurityContext;
import org.structr.common.error.FrameworkException;


import java.util.*;
import java.util.logging.Logger;
import org.neo4j.gis.spatial.indexprovider.SpatialRecordHits;
import org.neo4j.graphdb.index.IndexHits;
import org.structr.common.AccessControllable;
import org.structr.core.Result;
import org.structr.core.app.StructrApp;
import org.structr.core.entity.relationship.NodeHasLocation;




public class NodeFactory<T extends NodeInterface & AccessControllable> extends Factory<Node, T> {

	private static final Logger logger = Logger.getLogger(NodeFactory.class.getName());

	public NodeFactory(final SecurityContext securityContext) {
		super(securityContext);
	}

	public NodeFactory(final SecurityContext securityContext, final boolean includeDeletedAndHidden, final boolean publicOnly) {
		super(securityContext, includeDeletedAndHidden, publicOnly);
	}

	public NodeFactory(final SecurityContext securityContext, final int pageSize, final int page, final String offsetId) {
		super(securityContext, pageSize, page, offsetId);
	}

	public NodeFactory(final SecurityContext securityContext, final boolean includeDeletedAndHidden, final boolean publicOnly, final int pageSize, final int page, final String offsetId) {
		super(securityContext, includeDeletedAndHidden, publicOnly, pageSize, page, offsetId);
	}

	@Override
	public T instantiate(final Node node) throws FrameworkException {
		return (T) instantiateWithType(node, factoryDefinition.determineNodeType(node), false);
	}

	@Override
	public T instantiateWithType(final Node node, final Class<T> nodeClass, boolean isCreation) throws FrameworkException {

		
		if (nodeClass == null) {
			return null;
		}

		SecurityContext securityContext = factoryProfile.getSecurityContext();
		T newNode                       = null;

		try {
			newNode = nodeClass.newInstance();

		} catch (InstantiationException|IllegalAccessException itex) {
			newNode = null;
		}

		if (newNode == null) {
			newNode = (T)factoryDefinition.createGenericNode();
		}

		newNode.init(factoryProfile.getSecurityContext(), node, nodeClass, isCreation);
		newNode.onNodeInstantiation();

		
		if (isCreation || securityContext.isReadable(newNode, factoryProfile.includeDeletedAndHidden(), factoryProfile.publicOnly())) {

			return newNode;
		}

		return null;
	}

	@Override
	public T instantiate(final Node node, final boolean includeDeletedAndHidden, final boolean publicOnly) throws FrameworkException {

		factoryProfile.setIncludeDeletedAndHidden(includeDeletedAndHidden);
		factoryProfile.setPublicOnly(publicOnly);

		return instantiate(node);
	}

	@Override
	public Result instantiate(final IndexHits<Node> input) throws FrameworkException {

		if (input != null && input instanceof SpatialRecordHits) {
			return resultFromSpatialRecords((SpatialRecordHits) input);
		}

		return super.instantiate(input);
	}

	@Override
	public T instantiateDummy(final Node entity, final String entityType) throws FrameworkException {

		Map<String, Class<? extends NodeInterface>> entities = StructrApp.getConfiguration().getNodeEntities();
		Class<T> nodeClass                                   = (Class<T>)entities.get(entityType);
		T newNode                                            = null;

		if (nodeClass != null) {

			try {

				newNode = nodeClass.newInstance();
				newNode.init(factoryProfile.getSecurityContext(), entity, nodeClass, false);

			} catch (InstantiationException|IllegalAccessException itex) { itex.printStackTrace(); }

		}

		return newNode;

	}

	private Result resultFromSpatialRecords(final SpatialRecordHits spatialRecordHits) throws FrameworkException {

		final int pageSize                    = factoryProfile.getPageSize();
		final SecurityContext securityContext = factoryProfile.getSecurityContext();
		final boolean includeDeletedAndHidden = factoryProfile.includeDeletedAndHidden();
		final boolean publicOnly              = factoryProfile.publicOnly();
		List<T> nodes                         = new LinkedList<>();
		int size                              = spatialRecordHits.size();
		int position                          = 0;
		int count                             = 0;
		int offset                            = 0;

		try (final SpatialRecordHits closeable = spatialRecordHits) {

			for (Node node : closeable) {

				Node realNode = node;
				if (realNode != null) {

					
					T n = instantiate(realNode);

					nodes.add(n);

					
					if (n != null) {    

						List<T> nodesAt = (List<T>)getNodesAt(n);

						size += nodesAt.size();

						for (T nodeAt : nodesAt) {

							if (nodeAt != null && securityContext.isReadable(nodeAt, includeDeletedAndHidden, publicOnly)) {

								if (++position > offset) {

									
									if (++count > pageSize) {

										return new Result(nodes, size, true, false);
									}

									nodes.add((T)nodeAt);
								}

							}

						}

					}

				}

			}
		}

		return new Result(nodes, size, true, false);

	}

	
	protected List<NodeInterface> getNodesAt(final NodeInterface locationNode) {

		final List<NodeInterface> nodes = new LinkedList<>();

		

		for(RelationshipInterface rel : locationNode.getIncomingRelationships(NodeHasLocation.class)) {

			NodeInterface startNode = rel.getSourceNode();

			nodes.add(startNode);

			
			nodes.addAll(getNodesAt(startNode));
		}

		return nodes;

	}
}

<code block>

package org.structr.core.graph;

import org.neo4j.graphdb.Relationship;

import org.structr.common.SecurityContext;
import org.structr.common.error.FrameworkException;



import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.structr.core.GraphObject;
import org.structr.core.app.StructrApp;




public class RelationshipFactory<T extends RelationshipInterface> extends Factory<Relationship, T> {

	private static final Logger logger = Logger.getLogger(RelationshipFactory.class.getName());

	
	public RelationshipFactory(final SecurityContext securityContext) {
		super(securityContext);
	}

	public RelationshipFactory(final SecurityContext securityContext, final boolean includeDeletedAndHidden, final boolean publicOnly) {
		super(securityContext, includeDeletedAndHidden, publicOnly);
	}

	public RelationshipFactory(final SecurityContext securityContext, final int pageSize, final int page, final String offsetId) {
		super(securityContext, pageSize, page, offsetId);
	}

	public RelationshipFactory(final SecurityContext securityContext, final boolean includeDeletedAndHidden, final boolean publicOnly, final int pageSize, final int page, final String offsetId) {
		super(securityContext, includeDeletedAndHidden, publicOnly, pageSize, page, offsetId);
	}
	
	@Override
	public T instantiate(final Relationship relationship) throws FrameworkException {
		return (T) instantiateWithType(relationship, factoryDefinition.determineRelationshipType(relationship), false);
	}

	@Override
	public T instantiateWithType(final Relationship relationship, final Class<T> relClass, final boolean isCreation) throws FrameworkException {

		
		if (relClass == null) {
			return null;
		}

		logger.log(Level.FINEST, "Instantiate relationship with type {0}", relClass.getName());

		SecurityContext securityContext = factoryProfile.getSecurityContext();
		T newRel          = null;

		try {

			newRel = relClass.newInstance();

		} catch (Throwable t) {
			newRel = null;
		}

		if (newRel == null) {
			newRel = (T)StructrApp.getConfiguration().getFactoryDefinition().createGenericRelationship();
		}

		newRel.init(securityContext, relationship, relClass);

		
		final String type = newRel.getProperty(GraphObject.type);
		if (type == null || (type != null && !type.equals(relClass.getSimpleName()))) {

			newRel.unlockReadOnlyPropertiesOnce();
			newRel.setProperty(GraphObject.type, relClass.getSimpleName());
		}

		newRel.onRelationshipInstantiation();

		return newRel;
	}

	@Override
	public T adapt(final Relationship relationship) {

		try {
			return instantiate(relationship);

		} catch (FrameworkException fex) {

			logger.log(Level.WARNING, "Unable to adapt relationship", fex);
		}

		return null;
	}

	
	public List<T> instantiate(final Iterable<Relationship> input) throws FrameworkException {

		List<T> rels = new LinkedList<>();

		if ((input != null) && input.iterator().hasNext()) {

			for (Relationship rel : input) {

				T n = instantiate(rel);

				rels.add(n);

			}

		}

		return rels;
	}

	@Override
	public T instantiate(final Relationship obj, final boolean includeDeletedAndHidden, final boolean publicOnly) throws FrameworkException {

		factoryProfile.setIncludeDeletedAndHidden(includeDeletedAndHidden);
		factoryProfile.setPublicOnly(publicOnly);

		return instantiate(obj);
	}

	@Override
	public T instantiateDummy(final Relationship entity, final String entityType) throws FrameworkException {

		Map<String, Class<? extends RelationshipInterface>> entities = StructrApp.getConfiguration().getRelationshipEntities();
		Class<T> relClass                                            = (Class<T>)entities.get(entityType);
		T newRel                                                     = null;

		if (relClass != null) {

			try {

				newRel = relClass.newInstance();
				newRel.init(factoryProfile.getSecurityContext(), entity, relClass);

				
				newRel.onRelationshipInstantiation();

			} catch (Throwable t) {

				newRel = null;

			}

		}

		return newRel;

	}
}

<code block>

package org.structr.core.graph;

import org.neo4j.graphdb.Node;
import org.neo4j.graphdb.Relationship;

import org.structr.common.error.FrameworkException;
import org.structr.core.GraphObject;



import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.logging.Logger;
import org.neo4j.graphdb.GraphDatabaseService;
import org.neo4j.graphdb.Result;
import org.structr.core.GraphObjectMap;
import org.structr.core.property.GenericProperty;




public class CypherQueryCommand extends NodeServiceCommand {

	private static final Logger logger = Logger.getLogger(CypherQueryCommand.class.getName());

	

	

	public List<GraphObject> execute(String query) throws FrameworkException {
		return execute(query, null);
	}

	public List<GraphObject> execute(String query, Map<String, Object> parameters) throws FrameworkException {
		return execute(query, parameters, true);
	}

	public List<GraphObject> execute(String query, Map<String, Object> parameters, boolean includeHiddenAndDeleted) throws FrameworkException {
		return execute(query, parameters, includeHiddenAndDeleted, false);
	}

	public List<GraphObject> execute(String query, Map<String, Object> parameters, boolean includeHiddenAndDeleted, boolean publicOnly) throws FrameworkException {

		GraphDatabaseService graphDb    = (GraphDatabaseService) arguments.get("graphDb");
		RelationshipFactory relFactory  = new RelationshipFactory(securityContext);
		NodeFactory nodeFactory         = new NodeFactory(securityContext);
		List<GraphObject> resultList    = new LinkedList<>();
		Result result                   = null;

		if (parameters != null) {

			result = graphDb.execute(query, parameters);

		} else {

			result = graphDb.execute(query);
		}

		while (result.hasNext()) {

			final Map<String, Object> row = result.next();
			GraphObjectMap dummyObject    = null;

			for (Entry<String, Object> entry : row.entrySet()) {

				String key   = entry.getKey();
				Object value = entry.getValue();

				if (value instanceof Node) {

					NodeInterface node = nodeFactory.instantiate((Node) value, includeHiddenAndDeleted, publicOnly);

					if (node != null) {

						resultList.add(node);
					}

				} else if (value instanceof Relationship) {

					RelationshipInterface rel = relFactory.instantiate((Relationship) value);

					if (rel != null) {

						resultList.add(rel);
					}

				} else {

					if (dummyObject == null) {

						dummyObject = new GraphObjectMap();
						resultList.add(dummyObject);
					}

					dummyObject.setProperty(new GenericProperty(key), value);
				}

			}

		}

		return resultList;
	}

}

<code block>

package org.structr.core.app;

import java.io.IOException;
import java.net.URI;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.commons.lang3.StringUtils;
import org.neo4j.graphdb.GraphDatabaseService;
import org.neo4j.graphdb.NotFoundException;
import org.neo4j.helpers.collection.LruMap;
import org.neo4j.kernel.GraphDatabaseAPI;
import org.neo4j.kernel.impl.core.GraphProperties;
import org.neo4j.kernel.impl.core.NodeManager;
import org.structr.agent.AgentService;
import org.structr.agent.Task;
import org.structr.common.SecurityContext;
import org.structr.common.error.FrameworkException;
import org.structr.core.Command;
import org.structr.core.GraphObject;
import org.structr.core.Service;
import org.structr.core.Services;
import org.structr.core.entity.AbstractNode;
import org.structr.core.entity.Relation;
import org.structr.core.graph.CreateNodeCommand;
import org.structr.core.graph.CreateRelationshipCommand;
import org.structr.core.graph.CypherQueryCommand;
import org.structr.core.graph.DeleteNodeCommand;
import org.structr.core.graph.DeleteRelationshipCommand;
import org.structr.core.graph.GraphDatabaseCommand;
import org.structr.core.graph.MaintenanceCommand;
import org.structr.core.graph.NodeAttribute;
import org.structr.core.graph.NodeFactory;
import org.structr.core.graph.NodeInterface;
import org.structr.core.graph.NodeServiceCommand;
import org.structr.core.graph.RelationshipFactory;
import org.structr.core.graph.RelationshipInterface;
import org.structr.core.graph.Tx;
import org.structr.core.graph.search.SearchNodeCommand;
import org.structr.core.graph.search.SearchRelationshipCommand;
import org.structr.core.property.PropertyMap;
import org.structr.schema.ConfigurationProvider;


public class StructrApp implements App {

	private static final int cacheSize                 = Services.parseInt(StructrApp.getConfigurationValue(Services.APPLICATION_UUID_CACHE_SIZE), 10000);
	private static final Map<String, Long> nodeUuidMap = Collections.synchronizedMap(new LruMap<String, Long>(cacheSize));
	private static final Map<String, Long> relUuidMap  = Collections.synchronizedMap(new LruMap<String, Long>(cacheSize));
	private static final Logger logger                 = Logger.getLogger(StructrApp.class.getName());
	private static final URI schemaBaseURI             = URI.create("https:
	private static final Object globalConfigLock       = new Object();
	private static GraphProperties config              = null;
	private GraphDatabaseService graphDb               = null;
	private SecurityContext securityContext            = null;
	private RelationshipFactory relFactory             = null;
	private NodeFactory nodeFactory                    = null;

	private StructrApp(final SecurityContext securityContext) {
		this.relFactory      = new RelationshipFactory(securityContext);
		this.nodeFactory     = new NodeFactory(securityContext);
		this.securityContext = securityContext;
	}

	
	@Override
	public <T extends NodeInterface> T create(final Class<T> type, final String name) throws FrameworkException {
		return create(type, new NodeAttribute(AbstractNode.name, name));
	}

	@Override
	public <T extends NodeInterface> T create(final Class<T> type, final PropertyMap source) throws FrameworkException {

		final CreateNodeCommand<T> command = command(CreateNodeCommand.class);
		final PropertyMap properties       = new PropertyMap(source);

		
		properties.put(AbstractNode.type, type.getSimpleName());

		return command.execute(properties);
	}

	@Override
	public <T extends NodeInterface> T create(final Class<T> type, final NodeAttribute<?>... attributes) throws FrameworkException {

		final List<NodeAttribute<?>> attrs = new LinkedList<>(Arrays.asList(attributes));
		final CreateNodeCommand<T> command = command(CreateNodeCommand.class);

		
		attrs.add(new NodeAttribute(AbstractNode.type, type.getSimpleName()));

		return command.execute(attrs);
	}

	@Override
	public void delete(final NodeInterface node) {
		command(DeleteNodeCommand.class).execute(node);
	}

	@Override
	public <A extends NodeInterface, B extends NodeInterface, R extends Relation<A, B, ?, ?>> R create(final A fromNode, final B toNode, final Class<R> relType) throws FrameworkException {
		return command(CreateRelationshipCommand.class).execute(fromNode, toNode, relType);
	}

	@Override
	public <A extends NodeInterface, B extends NodeInterface, R extends Relation<A, B, ?, ?>> R create(final A fromNode, final B toNode, final Class<R> relType, final PropertyMap properties) throws FrameworkException {
		return command(CreateRelationshipCommand.class).execute(fromNode, toNode, relType, properties);
	}

	@Override
	public void delete(final RelationshipInterface relationship) {
		command(DeleteRelationshipCommand.class).execute(relationship);
	}

	@Override
	public GraphObject get(final String uuid) throws FrameworkException {

		final NodeInterface node = getNodeById(uuid);
		if (node != null) {

			return node;
		}

		final RelationshipInterface rel = getRelationshipById(uuid);
		if (rel != null) {

			return rel;
		}

		return null;
	}

	@Override
	public NodeInterface getNodeById(final String uuid) throws FrameworkException {

		final Long nodeId = nodeUuidMap.get(uuid);
		if (nodeId == null) {

			GraphObject entity = nodeQuery().uuid(uuid).includeDeletedAndHidden().getFirst();
			if (entity != null && uuid.equals(entity.getUuid())) {

				nodeUuidMap.put(uuid, entity.getId());
				return (NodeInterface)entity;
			}
		}

		if (nodeId != null) {

			try {
				final GraphDatabaseService graphDb = getGraphDatabaseService();
				return nodeFactory.instantiate(graphDb.getNodeById(nodeId));

			} catch (NotFoundException ignore) {
				nodeUuidMap.remove(uuid);
			}
		}

		return null;
	}

	@Override
	public RelationshipInterface getRelationshipById(final String uuid) throws FrameworkException {

		final Long id = relUuidMap.get(uuid);
		if (id == null) {

			GraphObject entity = relationshipQuery().uuid(uuid).getFirst();
			if (entity != null && uuid.equals(entity.getUuid())) {

				relUuidMap.put(uuid, entity.getId());
				return (RelationshipInterface)entity;
			}
		}

		if (id != null) {

			try {
				final GraphDatabaseService graphDb = getGraphDatabaseService();
				return relFactory.instantiate(graphDb.getRelationshipById(id));

			} catch (NotFoundException ignore) { }

		} else {

			relUuidMap.remove(uuid);
		}

		return null;
	}

	@Override
	public <T extends GraphObject> T get(final Class<T> type, final String uuid) throws FrameworkException {

		final GraphObject entity = get(uuid);

		if (type.isAssignableFrom(entity.getClass())) {

			return (T) entity;

		} else {

			return null;
		}
	}

	@Override
	public <T extends GraphObject> List<T> get(final Class<T> type) throws FrameworkException {

		final Query<T> query = command(SearchNodeCommand.class);
		return query.andType(type).getAsList();
	}

	@Override
	public Query<NodeInterface> nodeQuery() {
		return command(SearchNodeCommand.class);
	}

	@Override
	public Query<NodeInterface> nodeQuery(final boolean exact) {
		return command(SearchNodeCommand.class).exact(exact);
	}

	@Override
	public <T extends NodeInterface> Query<T> nodeQuery(final Class<T> type) {
		return command(SearchNodeCommand.class).andTypes(type);
	}

	@Override
	public <T extends NodeInterface> Query<T> nodeQuery(final Class<T> type, final boolean exact) {
		return command(SearchNodeCommand.class).exact(exact).andTypes(type);
	}

	@Override
	public Query<RelationshipInterface> relationshipQuery() {
		return command(SearchRelationshipCommand.class);
	}

	@Override
	public Query<RelationshipInterface> relationshipQuery(final boolean exact) {
		return command(SearchRelationshipCommand.class).exact(exact);
	}

	@Override
	public <T extends RelationshipInterface> Query<T> relationshipQuery(final Class<T> type) {
		return command(SearchRelationshipCommand.class).andTypes(type);
	}

	@Override
	public <T extends RelationshipInterface> Query<T> relationshipQuery(final Class<T> type, final boolean exact) {
		return command(SearchRelationshipCommand.class).exact(exact).andTypes(type);
	}

	@Override
	public Tx tx() {
		return tx(true);
	}

	@Override
	public Tx tx(final boolean doValidation) {
		return tx(doValidation, true);
	}

	@Override
	public Tx tx(final boolean doValidation, final boolean doCallbacks) {
		return new Tx(securityContext, this, doValidation, doCallbacks).begin();
	}

	@Override
	public Tx tx(final boolean doValidation, final boolean doCallbacks, final boolean doNotifications) {
		return new Tx(securityContext, this, doValidation, doCallbacks, doNotifications).begin();
	}

	@Override
	public void shutdown() {
		Services.getInstance().shutdown();
	}

	@Override
	public void close() throws IOException {
		shutdown();
	}

	@Override
	public <T extends Command> T command(Class<T> commandType) {
		return Services.getInstance().command(securityContext, commandType);
	}

	@Override
	public void processTasks(Task... tasks) {

		final AgentService agentService = getService(AgentService.class);
		if(agentService != null) {

			for(final Task task : tasks) {

				agentService.processTask(task);
			}
		}
	}

	@Override
	public <T extends Command & MaintenanceCommand> void maintenance(final Class<T> commandClass, final Map<String, Object> propertySet) throws FrameworkException {
		((MaintenanceCommand)Services.getInstance().command(securityContext, commandClass)).execute(propertySet);
	}

	@Override
	public List<GraphObject> cypher(final String cypherQuery, final Map<String, Object> parameters) throws FrameworkException {
		return Services.getInstance().command(securityContext, CypherQueryCommand.class).execute(cypherQuery, parameters);
	}

	@Override
	public <T extends Service> T getService(Class<T> serviceClass) {
		return Services.getInstance().getService(serviceClass);
	}

	@Override
	public GraphDatabaseService getGraphDatabaseService() {

		
		if (graphDb == null) {
			graphDb = Services.getInstance().command(securityContext, GraphDatabaseCommand.class).execute();
		}

		return graphDb;
	}

	private GraphProperties getOrCreateGraphProperties() {

		GraphProperties graphProperties = null;

		try (final Tx tx = StructrApp.getInstance().tx()) {

			final NodeManager mgr = ((GraphDatabaseAPI)getGraphDatabaseService()).getDependencyResolver().resolveDependency(NodeManager.class);

			tx.success();

			graphProperties = mgr.newGraphProperties();

		} catch (Throwable t) {
			logger.log(Level.WARNING, t.getMessage());
			t.printStackTrace();
		}

		return graphProperties;
	}

	@Override
	public <T> T getGlobalSetting(final String key, final T defaultValue) throws FrameworkException {

		if (config == null) {
			config = getOrCreateGraphProperties();
		}

		T value = null;

		try (final Tx tx = StructrApp.getInstance().tx()) {

			value = (T) config.getProperty(key);
			tx.success();

		} catch (Throwable t) {
			logger.log(Level.WARNING, t.getMessage());
			t.printStackTrace();

			try (final Tx tx = StructrApp.getInstance().tx()) {

				config = getOrCreateGraphProperties();
				config.setProperty(key, value);

				tx.success();

			} catch (Throwable t1) {
				logger.log(Level.WARNING, t1.getMessage());
				t1.printStackTrace();
			}
		}

		if (value == null) {
			return defaultValue;
		}

		return value;
	}

	@Override
	public void setGlobalSetting(final String key, final Object value) throws FrameworkException {

		if (config == null) {
			config = getOrCreateGraphProperties();
		}

		try (final Tx tx = StructrApp.getInstance().tx()) {

			config.setProperty(key, value);
			tx.success();

		} catch (Throwable t) {
			logger.log(Level.WARNING, t.getMessage());
			t.printStackTrace();

			try (final Tx tx = StructrApp.getInstance().tx()) {

				config = getOrCreateGraphProperties();
				config.setProperty(key, value);

				tx.success();

			} catch (Throwable t1) {
				logger.log(Level.WARNING, t1.getMessage());
				t1.printStackTrace();
			}
		}
	}

	@Override
	public String getInstanceId() throws FrameworkException {

		synchronized (globalConfigLock) {

			String instanceId = (String) getGlobalSetting("structr.instance.id", null);
			System.out.println("instance id from getGlobalSetting: " + instanceId);
			if (instanceId == null) {

				instanceId = NodeServiceCommand.getNextUuid();
				setGlobalSetting("structr.instance.id", instanceId);
			}
			System.out.println("instance id: " + instanceId);
			return instanceId;
		}
	}



	
	
	public static App getInstance() {
		return new StructrApp(SecurityContext.getSuperUserInstance());
	}

	
	public static App getInstance(final SecurityContext securityContext) {
		return new StructrApp(securityContext);
	}

	public static ConfigurationProvider getConfiguration() {
		return Services.getInstance().getConfigurationProvider();
	}

	public static String getConfigurationValue(final String key) {
		return StringUtils.trim(Services.getInstance().getConfigurationValue(key, null));
	}

	public static String getConfigurationValue(final String key, final String defaultValue) {
		return StringUtils.trim(Services.getInstance().getConfigurationValue(key, defaultValue));
	}

	public static <T extends GraphObject> URI getSchemaId(final Class<T> type) {
		initializeSchemaIds();
		return typeIdMap.get(type);
	}

	public static Class resolveSchemaId(final URI uri) {
		initializeSchemaIds();
		return schemaIdMap.get(uri);
	}

	public static URI getSchemaBaseURI() {
		return schemaBaseURI;
	}

	private static void initializeSchemaIds() {

		if (schemaIdMap.isEmpty()) {

			for (final Class type : StructrApp.getConfiguration().getNodeEntities().values()) {
				registerType(type);
			}

			for (final Class type : StructrApp.getConfiguration().getRelationshipEntities().values()) {
				registerType(type);
			}
		}
	}

	private static void registerType(final Class type) {

		final URI id = schemaBaseURI.resolve(URI.create(("definitions/" + type.getSimpleName())));

		schemaIdMap.put(id, type);
		typeIdMap.put(type, id);
	}

	private static final Map<URI, Class> schemaIdMap = new LinkedHashMap<>();
	private static final Map<Class, URI> typeIdMap   = new LinkedHashMap<>();
}

<code block>

package org.structr.core.parser;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonPrimitive;
import com.google.gson.reflect.TypeToken;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.StreamTokenizer;
import java.io.StringReader;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import java.net.URLEncoder;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.text.Normalizer;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.RandomStringUtils;
import org.apache.commons.lang3.StringEscapeUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.math.NumberUtils;
import org.apache.commons.mail.EmailException;
import org.neo4j.graphdb.Direction;
import org.neo4j.graphdb.DynamicRelationshipType;
import org.structr.common.GraphObjectComparator;
import org.structr.common.MailHelper;
import org.structr.common.Permission;
import org.structr.common.Permissions;
import org.structr.common.SecurityContext;
import org.structr.common.error.ErrorToken;
import org.structr.common.error.FrameworkException;
import org.structr.common.error.SemanticErrorToken;
import org.structr.common.geo.GeoCodingResult;
import org.structr.common.geo.GeoHelper;
import org.structr.core.GraphObject;
import org.structr.core.GraphObjectMap;
import org.structr.core.Services;
import org.structr.core.app.App;
import org.structr.core.app.Query;
import org.structr.core.app.StructrApp;
import org.structr.core.converter.PropertyConverter;
import org.structr.core.entity.AbstractNode;
import org.structr.core.entity.AbstractRelationship;
import org.structr.core.entity.MailTemplate;
import org.structr.core.entity.Principal;
import org.structr.core.graph.NodeInterface;
import org.structr.core.graph.RelationshipFactory;
import org.structr.core.graph.RelationshipInterface;
import org.structr.core.property.DateProperty;
import org.structr.core.property.PropertyKey;
import org.structr.core.property.PropertyMap;
import org.structr.core.property.StringProperty;
import org.structr.core.script.Scripting;
import org.structr.schema.ConfigurationProvider;
import org.structr.schema.action.ActionContext;
import org.structr.schema.action.Actions;
import org.structr.schema.action.Function;
import org.structr.schema.parser.DatePropertyParser;
import org.w3c.dom.Document;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;


public class Functions {

	private static final Logger logger = Logger.getLogger(Functions.class.getName());
	public static final Map<String, Function<Object, Object>> functions = new LinkedHashMap<>();

	public static final String NULL_STRING = "___NULL___";

	public static final String ERROR_MESSAGE_MD5 = "Usage: ${md5(string)}. Example: ${md5(this.email)}";
	public static final String ERROR_MESSAGE_ERROR = "Usage: ${error(...)}. Example: ${error(\"base\", \"must_equal\", int(5))}";
	public static final String ERROR_MESSAGE_UPPER = "Usage: ${upper(string)}. Example: ${upper(this.nickName)}";
	public static final String ERROR_MESSAGE_LOWER = "Usage: ${lower(string)}. Example: ${lower(this.email)}";
	public static final String ERROR_MESSAGE_JOIN = "Usage: ${join(collection, separator)}. Example: ${join(this.names, \",\")}";
	public static final String ERROR_MESSAGE_CONCAT = "Usage: ${concat(values...)}. Example: ${concat(this.firstName, this.lastName)}";
	public static final String ERROR_MESSAGE_SPLIT = "Usage: ${split(value)}. Example: ${split(this.commaSeparatedItems)}";
	public static final String ERROR_MESSAGE_ABBR = "Usage: ${abbr(longString, maxLength)}. Example: ${abbr(this.title, 20)}";
	public static final String ERROR_MESSAGE_CAPITALIZE = "Usage: ${capitalize(string)}. Example: ${capitalize(this.nickName)}";
	public static final String ERROR_MESSAGE_TITLEIZE = "Usage: ${titleize(string, separator}. (Default separator is \" \") Example: ${titleize(this.lowerCamelCaseString, \"_\")}";
	public static final String ERROR_MESSAGE_NUM = "Usage: ${num(string)}. Example: ${num(this.numericalStringValue)}";
	public static final String ERROR_MESSAGE_INT = "Usage: ${int(string)}. Example: ${int(this.numericalStringValue)}";
	public static final String ERROR_MESSAGE_RANDOM = "Usage: ${random(num)}. Example: ${set(this, \"password\", random(8))}";
	public static final String ERROR_MESSAGE_RINT = "Usage: ${rint(range)}. Example: ${rint(1000)}";
	public static final String ERROR_MESSAGE_INDEX_OF = "Usage: ${index_of(string, word)}. Example: ${index_of(this.name, \"the\")}";
	public static final String ERROR_MESSAGE_CONTAINS = "Usage: ${contains(string, word)}. Example: ${contains(this.name, \"the\")}";
	public static final String ERROR_MESSAGE_SUBSTRING = "Usage: ${substring(string, start, length)}. Example: ${substring(this.name, 19, 3)}";
	public static final String ERROR_MESSAGE_LENGTH = "Usage: ${length(string)}. Example: ${length(this.name)}";
	public static final String ERROR_MESSAGE_REPLACE = "Usage: ${replace(template, source)}. Example: ${replace(\"${this.id}\", this)}";
	public static final String ERROR_MESSAGE_CLEAN = "Usage: ${clean(string)}. Example: ${clean(this.stringWithNonWordChars)}";
	public static final String ERROR_MESSAGE_URLENCODE = "Usage: ${urlencode(string)}. Example: ${urlencode(this.email)}";
	public static final String ERROR_MESSAGE_ESCAPE_JS = "Usage: ${escape_javascript(string)}. Example: ${escape_javascript(this.name)}";
	public static final String ERROR_MESSAGE_ESCAPE_JSON = "Usage: ${escape_json(string)}. Example: ${escape_json(this.name)}";
	public static final String ERROR_MESSAGE_IF = "Usage: ${if(condition, trueValue, falseValue)}. Example: ${if(empty(this.name), this.nickName, this.name)}";
	public static final String ERROR_MESSAGE_EMPTY = "Usage: ${empty(string)}. Example: ${if(empty(possibleEmptyString), \"empty\", \"non-empty\")}";
	public static final String ERROR_MESSAGE_EQUAL = "Usage: ${equal(value1, value2)}. Example: ${equal(this.children.size, 0)}";
	public static final String ERROR_MESSAGE_ADD = "Usage: ${add(values...)}. Example: ${add(1, 2, 3, this.children.size)}";
	public static final String ERROR_MESSAGE_INT_SUM = "Usage: ${int_sum(list)}. Example: ${int_sum(extract(this.children, \"number\"))}";
	public static final String ERROR_MESSAGE_DOUBLE_SUM = "Usage: ${double_sum(list)}. Example: ${double_sum(extract(this.children, \"amount\"))}";
	public static final String ERROR_MESSAGE_IS_COLLECTION = "Usage: ${is_collection(value)}. Example: ${is_collection(this)}";
	public static final String ERROR_MESSAGE_IS_ENTITY = "Usage: ${is_entity(value)}. Example: ${is_entity(this)}";
	public static final String ERROR_MESSAGE_EXTRACT = "Usage: ${extract(list, propertyName)}. Example: ${extract(this.children, \"amount\")}";
	public static final String ERROR_MESSAGE_FILTER = "Usage: ${filter(list, expression)}. Example: ${filter(this.children, gt(size(data.children), 0))}";
	public static final String ERROR_MESSAGE_MERGE = "Usage: ${merge(list1, list2, list3, ...)}. Example: ${merge(this.children, this.siblings)}";
	public static final String ERROR_MESSAGE_COMPLEMENT = "Usage: ${complement(list1, list2, list3, ...)}. (The resulting list contains no duplicates) Example: ${complement(allUsers, me)} => List of all users except myself";
	public static final String ERROR_MESSAGE_UNWIND = "Usage: ${unwind(list1, ...)}. Example: ${unwind(this.children)}";
	public static final String ERROR_MESSAGE_SORT = "Usage: ${sort(list1, key [, true])}. Example: ${sort(this.children, \"name\")}";
	public static final String ERROR_MESSAGE_LT = "Usage: ${lt(value1, value2)}. Example: ${if(lt(this.children, 2), \"Less than two\", \"Equal to or more than two\")}";
	public static final String ERROR_MESSAGE_GT = "Usage: ${gt(value1, value2)}. Example: ${if(gt(this.children, 2), \"More than two\", \"Equal to or less than two\")}";
	public static final String ERROR_MESSAGE_LTE = "Usage: ${lte(value1, value2)}. Example: ${if(lte(this.children, 2), \"Equal to or less than two\", \"More than two\")}";
	public static final String ERROR_MESSAGE_GTE = "Usage: ${gte(value1, value2)}. Example: ${if(gte(this.children, 2), \"Equal to or more than two\", \"Less than two\")}";
	public static final String ERROR_MESSAGE_SUBT = "Usage: ${subt(value1, value)}. Example: ${subt(5, 2)}";
	public static final String ERROR_MESSAGE_MULT = "Usage: ${mult(value1, value)}. Example: ${mult(5, 2)}";
	public static final String ERROR_MESSAGE_QUOT = "Usage: ${quot(value1, value)}. Example: ${quot(5, 2)}";
	public static final String ERROR_MESSAGE_ROUND = "Usage: ${round(value1 [, decimalPlaces])}. Example: ${round(2.345678, 2)}";
	public static final String ERROR_MESSAGE_MAX = "Usage: ${max(value1, value2)}. Example: ${max(this.children, 10)}";
	public static final String ERROR_MESSAGE_MIN = "Usage: ${min(value1, value2)}. Example: ${min(this.children, 5)}";
	public static final String ERROR_MESSAGE_CONFIG = "Usage: ${config(keyFromStructrConf)}. Example: ${config(\"base.path\")}";
	public static final String ERROR_MESSAGE_CONFIG_JS = "Usage: ${{Structr.config(keyFromStructrConf)}}. Example: ${{Structr.config(\"base.path\")}}";
	public static final String ERROR_MESSAGE_DATE_FORMAT = "Usage: ${date_format(value, pattern)}. Example: ${date_format(this.creationDate, \"yyyy-MM-dd'T'HH:mm:ssZ\")}";
	public static final String ERROR_MESSAGE_DATE_FORMAT_JS = "Usage: ${{Structr.date_format(value, pattern)}}. Example: ${{Structr.date_format(Structr.get('this').creationDate, \"yyyy-MM-dd'T'HH:mm:ssZ\")}";
	public static final String ERROR_MESSAGE_PARSE_DATE = "Usage: ${parse_date(value, pattern)}. Example: ${parse_format(\"2014-01-01\", \"yyyy-MM-dd\")}";
	public static final String ERROR_MESSAGE_PARSE_DATE_JS = "Usage: ${{Structr.parse_date(value, pattern)}}. Example: ${{Structr.parse_format(\"2014-01-01\", \"yyyy-MM-dd\")}}";
	public static final String ERROR_MESSAGE_NUMBER_FORMAT = "Usage: ${number_format(value, ISO639LangCode, pattern)}. Example: ${number_format(12345.6789, 'en', '#,##0.00')}";
	public static final String ERROR_MESSAGE_NUMBER_FORMAT_JS = "Usage: ${{Structr.number_format(value, ISO639LangCode, pattern)}}. Example: ${{Structr.number_format(12345.6789, 'en', '#,##0.00')}}";
	public static final String ERROR_MESSAGE_TEMPLATE = "Usage: ${{Structr.template(name, locale, source)}}. Example: ${{Structr.template(\"TEXT_TEMPLATE_1\", \"en_EN\", Structr.get('this'))}}";
	public static final String ERROR_MESSAGE_TEMPLATE_JS = "Usage: ${template(name, locale, source)}. Example: ${template(\"TEXT_TEMPLATE_1\", \"en_EN\", this)}";
	public static final String ERROR_MESSAGE_NOT = "Usage: ${not(bool1, bool2)}. Example: ${not(\"true\", \"true\")}";
	public static final String ERROR_MESSAGE_AND = "Usage: ${and(bool1, bool2)}. Example: ${and(\"true\", \"true\")}";
	public static final String ERROR_MESSAGE_OR = "Usage: ${or(bool1, bool2)}. Example: ${or(\"true\", \"true\")}";
	public static final String ERROR_MESSAGE_GET = "Usage: ${get(entity, propertyKey)}. Example: ${get(this, \"children\")}";
	public static final String ERROR_MESSAGE_GET_ENTITY = "Cannot evaluate first argument to entity, must be entity or single element list of entities.";
	public static final String ERROR_MESSAGE_SIZE = "Usage: ${size(collection)}. Example: ${size(this.children)}";
	public static final String ERROR_MESSAGE_FIRST = "Usage: ${first(collection)}. Example: ${first(this.children)}";
	public static final String ERROR_MESSAGE_LAST = "Usage: ${last(collection)}. Example: ${last(this.children)}";
	public static final String ERROR_MESSAGE_NTH = "Usage: ${nth(collection)}. Example: ${nth(this.children, 2)}";
	public static final String ERROR_MESSAGE_GET_COUNTER = "Usage: ${get_counter(level)}. Example: ${get_counter(1)}";
	public static final String ERROR_MESSAGE_INC_COUNTER = "Usage: ${inc_counter(level, [resetLowerLevels])}. Example: ${inc_counter(1, true)}";
	public static final String ERROR_MESSAGE_RESET_COUNTER = "Usage: ${reset_counter(level)}. Example: ${reset_counter(1)}";
	public static final String ERROR_MESSAGE_MERGE_PROPERTIES = "Usage: ${merge_properties(source, target , mergeKeys...)}. Example: ${merge_properties(this, parent, \"eMail\")}";
	public static final String ERROR_MESSAGE_KEYS = "Usage: ${keys(entity, viewName)}. Example: ${keys(this, \"ui\")}";
	public static final String ERROR_MESSAGE_EACH = "Usage: ${each(collection, expression)}. Example: ${each(this.children, \"set(this, \"email\", lower(get(this.email))))\")}";
	public static final String ERROR_MESSAGE_STORE = "Usage: ${store(key, value)}. Example: ${store('tmpUser', this.owner)}";
	public static final String ERROR_MESSAGE_STORE_JS = "Usage: ${{Structr.store(key, value)}}. Example: ${{Structr.store('tmpUser', Structr.get('this').owner)}}";
	public static final String ERROR_MESSAGE_RETRIEVE = "Usage: ${retrieve(key)}. Example: ${retrieve('tmpUser')}";
	public static final String ERROR_MESSAGE_RETRIEVE_JS = "Usage: ${{Structr.retrieve(key)}}. Example: ${{retrieve('tmpUser')}}";
	public static final String ERROR_MESSAGE_PRINT = "Usage: ${print(objects...)}. Example: ${print(this.name, \"test\")}";
	public static final String ERROR_MESSAGE_PRINT_JS = "Usage: ${{Structr.print(objects...)}}. Example: ${{Structr.print(Structr.get('this').name, \"test\")}}";
	public static final String ERROR_MESSAGE_READ = "Usage: ${read(filename)}. Example: ${read(\"text.xml\")}";
	public static final String ERROR_MESSAGE_WRITE = "Usage: ${write(filename, value)}. Example: ${write(\"text.txt\", this.name)}";
	public static final String ERROR_MESSAGE_APPEND = "Usage: ${append(filename, value)}. Example: ${append(\"test.txt\", this.name)}";
	public static final String ERROR_MESSAGE_XML = "Usage: ${xml(xmlSource)}. Example: ${xpath(xml(this.xmlSource), \"/test/testValue\")}";
	public static final String ERROR_MESSAGE_XPATH = "Usage: ${xpath(xmlDocument, expression)}. Example: ${xpath(xml(this.xmlSource), \"/test/testValue\")}";
	public static final String ERROR_MESSAGE_SET = "Usage: ${set(entity, propertyKey, value)}. Example: ${set(this, \"email\", lower(this.email))}";
	public static final String ERROR_MESSAGE_SET_PRIVILEGED = "Usage: ${set_privileged(entity, propertyKey, value)}. Example: ${set_privileged(this, \"email\", lower(this.email))}";
	public static final String ERROR_MESSAGE_SET_PRIVILEGED_JS = "Usage: ${setPrvileged(entity, propertyKey, value)}. Example: ${Structr.setPrivileged(this, \"email\", lower(this.email))}";
	public static final String ERROR_MESSAGE_SEND_PLAINTEXT_MAIL = "Usage: ${send_plaintext_mail(fromAddress, fromName, toAddress, toName, subject, content)}.";
	public static final String ERROR_MESSAGE_SEND_HTML_MAIL = "Usage: ${send_html_mail(fromAddress, fromName, toAddress, toName, subject, content)}.";
	public static final String ERROR_MESSAGE_GEOCODE = "Usage: ${geocode(street, city, country)}. Example: ${set(this, geocode(this.street, this.city, this.country))}";
	public static final String ERROR_MESSAGE_FIND = "Usage: ${find(type, key, value)}. Example: ${find(\"User\", \"email\", \"tester@test.com\"}";
	public static final String ERROR_MESSAGE_SEARCH = "Usage: ${search(type, key, value)}. Example: ${search(\"User\", \"name\", \"abc\"}";
	public static final String ERROR_MESSAGE_CREATE = "Usage: ${create(type, key, value)}. Example: ${create(\"Feedback\", \"text\", this.text)}";
	public static final String ERROR_MESSAGE_DELETE = "Usage: ${delete(entity)}. Example: ${delete(this)}";
	public static final String ERROR_MESSAGE_CACHE = "Usage: ${cache(key, timeout, valueExpression)}. Example: ${cache('value', 60, GET('http:
	public static final String ERROR_MESSAGE_GRANT = "Usage: ${grant(principal, node, permissions)}. Example: ${grant(me, this, 'read, write, delete'))}";
	public static final String ERROR_MESSAGE_GRANT_JS = "Usage: ${Structr.grant(principal, node, permissions)}. Example: ${Structr.grant(Structr.get('me'), Structr.this, 'read, write, delete'))}";
	public static final String ERROR_MESSAGE_REVOKE = "Usage: ${revoke(principal, node, permissions)}. Example: ${revoke(me, this, 'write, delete'))}";
	public static final String ERROR_MESSAGE_REVOKE_JS = "Usage: ${Structr.revoke(principal, node, permissions)}. Example: ${Structr.revoke(Structr.('me'), Structr.this, 'write, delete'))}";
	public static final String ERROR_MESSAGE_UNLOCK_READONLY_PROPERTIES_ONCE = "Usage: ${unlock_readonly_properties_once(node)}. Example ${unlock_readonly_properties_once, this}";
	public static final String ERROR_MESSAGE_UNLOCK_READONLY_PROPERTIES_ONCE_JS = "Usage: ${Structr.unlock_readonly_properties_once(node)}. Example ${Structr.unlock_readonly_properties_once, Structr.get('this')}";
	public static final String ERROR_MESSAGE_CALL = "Usage: ${call(key [, payloads...]}. Example ${call('myEvent')}";
	public static final String ERROR_MESSAGE_CALL_JS = "Usage: ${Structr.call(key [, payloads...]}. Example ${Structr.call('myEvent')}";
	public static final String ERROR_MESSAGE_IS_LOCALE = "Usage: ${is_locale(locales...)}";
	public static final String ERROR_MESSAGE_IS_LOCALE_JS = "Usage: ${Structr.isLocale(locales...}. Example ${Structr.isLocale('de_DE', 'de_AT', 'de_CH')}";
	public static final String ERROR_MESSAGE_CYPHER = "Usage: ${cypher('MATCH (n) RETURN n')}";
	public static final String ERROR_MESSAGE_CYPHER_JS = "Usage: ${Structr.cypher(query)}. Example ${Structr.cypher('MATCH (n) RETURN n')}";

	
	public static final String ERROR_MESSAGE_INCOMING = "Usage: ${incoming(entity [, relType])}. Example: ${incoming(this, 'PARENT_OF')}";
	public static final String ERROR_MESSAGE_INCOMING_JS = "Usage: ${Structr.incoming(entity [, relType])}. Example: ${Structr.incoming(Structr.this, 'PARENT_OF')}";
	public static final String ERROR_MESSAGE_OUTGOING = "Usage: ${outgoing(entity [, relType])}. Example: ${outgoing(this, 'PARENT_OF')}";
	public static final String ERROR_MESSAGE_OUTGOING_JS = "Usage: ${Structr.outgoing(entity [, relType])}. Example: ${outgoing(Structr.this, 'PARENT_OF')}";
	public static final String ERROR_MESSAGE_HAS_RELATIONSHIP = "Usage: ${has_relationship(entity1, entity2 [, relType])}. Example: ${has_relationship(me, user, 'FOLLOWS')} (ignores direction of the relationship)";
	public static final String ERROR_MESSAGE_HAS_RELATIONSHIP_JS = "Usage: ${Structr.has_relationship(entity1, entity2 [, relType])}. Example: ${Structr.has_relationship(Structr.get('me'), user, 'FOLLOWS')} (ignores direction of the relationship)";
	public static final String ERROR_MESSAGE_HAS_OUTGOING_RELATIONSHIP = "Usage: ${has_outgoing_relationship(from, to [, relType])}. Example: ${has_outgoing_relationship(me, user, 'FOLLOWS')}";
	public static final String ERROR_MESSAGE_HAS_OUTGOING_RELATIONSHIP_JS = "Usage: ${Structr.has_outgoing_relationship(from, to [, relType])}. Example: ${Structr.has_outgoing_relationship(Structr.get('me'), user, 'FOLLOWS')}";
	public static final String ERROR_MESSAGE_HAS_INCOMING_RELATIONSHIP = "Usage: ${has_incoming_relationship(from, to [, relType])}. Example: ${has_incoming_relationship(me, user, 'FOLLOWS')}";
	public static final String ERROR_MESSAGE_HAS_INCOMING_RELATIONSHIP_JS = "Usage: ${Structr.has_incoming_relationship(from, to [, relType])}. Example: ${Structr.has_incoming_relationship(Structr.get('me'), user, 'FOLLOWS')}";
	public static final String ERROR_MESSAGE_GET_RELATIONSHIPS = "Usage: ${get_relationships(entity1, entity2 [, relType])}. Example: ${get_relationships(me, user, 'FOLLOWS')}  (ignores direction of the relationship)";
	public static final String ERROR_MESSAGE_GET_RELATIONSHIPS_JS = "Usage: ${Structr.get_relationships(entity1, entity2 [, relType])}. Example: ${Structr.get_relationships(Structr.get('me'), user, 'FOLLOWS')}  (ignores direction of the relationship)";
	public static final String ERROR_MESSAGE_GET_OUTGOING_RELATIONSHIPS = "Usage: ${get_outgoing_relationships(from, to [, relType])}. Example: ${get_outgoing_relationships(me, user, 'FOLLOWS')}";
	public static final String ERROR_MESSAGE_GET_OUTGOING_RELATIONSHIPS_JS = "Usage: ${Structr.get_outgoing_relationships(from, to [, relType])}. Example: ${Structr.get_outgoing_relationships(Structr.get('me'), user, 'FOLLOWS')}";
	public static final String ERROR_MESSAGE_GET_INCOMING_RELATIONSHIPS = "Usage: ${get_incoming_relationships(from, to [, relType])}. Example: ${get_incoming_relationships(me, user, 'FOLLOWS')}";
	public static final String ERROR_MESSAGE_GET_INCOMING_RELATIONSHIPS_JS = "Usage: ${Structr.get_incoming_relationships(from, to [, relType])}. Example: ${Structr.get_incoming_relationships(Structr.get('me'), user, 'FOLLOWS')}";
	public static final String ERROR_MESSAGE_CREATE_RELATIONSHIP = "Usage: ${create_relationship(from, to, relType)}. Example: ${create_relationship(me, user, 'FOLLOWS')} (Relationshiptype has to exist)";
	public static final String ERROR_MESSAGE_CREATE_RELATIONSHIP_JS = "Usage: ${Structr.create_relationship(from, to, relType)}. Example: ${Structr.create_relationship(Structr.get('me'), user, 'FOLLOWS')} (Relationshiptype has to exist)";

	public static Function<Object, Object> get(final String name) {
		return functions.get(name);
	}

	public static Object evaluate(final ActionContext actionContext, final GraphObject entity, final String expression) throws FrameworkException {

		final String expressionWithoutNewlines = expression.replace('\n', ' ');
		final StreamTokenizer tokenizer = new StreamTokenizer(new StringReader(expressionWithoutNewlines));
		tokenizer.eolIsSignificant(true);
		tokenizer.ordinaryChar('.');
		tokenizer.wordChars('_', '_');
		tokenizer.wordChars('.', '.');
		tokenizer.wordChars('!', '!');

		Expression root = new RootExpression();
		Expression current = root;
		Expression next = null;
		String lastToken = null;
		int token = 0;
		int level = 0;

		while (token != StreamTokenizer.TT_EOF) {

			token = nextToken(tokenizer);

			switch (token) {

				case StreamTokenizer.TT_EOF:
					break;

				case StreamTokenizer.TT_EOL:
					break;

				case StreamTokenizer.TT_NUMBER:
					if (current == null) {
						throw new FrameworkException(422, "Invalid expression: mismatched opening bracket before NUMBER");
					}
					next = new ConstantExpression(tokenizer.nval);
					current.add(next);
					lastToken += "NUMBER";
					break;

				case StreamTokenizer.TT_WORD:
					if (current == null) {
						throw new FrameworkException(422, "Invalid expression: mismatched opening bracket before " + tokenizer.sval);
					}
					next = checkReservedWords(tokenizer.sval);
					current.add(next);
					lastToken = tokenizer.sval;
					break;

				case '(':
					if (((current == null || current instanceof RootExpression) && next == null) || current == next) {

						
						
						next = new GroupExpression();
						current.add(next);
					}

					current = next;
					lastToken += "(";
					level++;
					break;

				case ')':
					if (current == null) {
						throw new FrameworkException(422, "Invalid expression: mismatched opening bracket before " + lastToken);
					}
					current = current.getParent();
					if (current == null) {
						throw new FrameworkException(422, "Invalid expression: mismatched closing bracket after " + lastToken);
					}
					lastToken += ")";
					level--;
					break;

				case '[':
					
					next = new ArrayExpression();
					current.add(next);
					current = next;
					lastToken += "[";
					level++;
					break;

				case ']':

					if (current == null) {
						throw new FrameworkException(422, "Invalid expression: mismatched closing bracket before " + lastToken);
					}
					current = current.getParent();
					if (current == null) {
						throw new FrameworkException(422, "Invalid expression: mismatched closing bracket after " + lastToken);
					}
					lastToken += "]";
					level--;
					break;

				case ';':
					next = null;
					lastToken += ";";
					break;

				case ',':
					next = current;
					lastToken += ",";
					break;

				default:
					if (current == null) {
						throw new FrameworkException(422, "Invalid expression: mismatched opening bracket before " + tokenizer.sval);
					}
					current.add(new ConstantExpression(tokenizer.sval));
					lastToken = tokenizer.sval;

			}
		}

		if (level > 0) {
			throw new FrameworkException(422, "Invalid expression: mismatched closing bracket after " + lastToken);
		}

		return root.evaluate(actionContext, entity);
	}

	private static Expression checkReservedWords(final String word) throws FrameworkException {

		if (word == null) {
			return new NullExpression();
		}

		switch (word) {

			case "cache":
				return new CacheExpression();

			case "true":
				return new ConstantExpression(true);

			case "false":
				return new ConstantExpression(false);

			case "if":
				return new IfExpression();

			case "each":
				return new EachExpression();

			case "filter":
				return new FilterExpression();

			case "data":
				return new ValueExpression("data");

			case "null":
				return new ConstantExpression(NULL_STRING);
		}

		
		final Function<Object, Object> function = Functions.get(word);
		if (function != null) {

			return new FunctionExpression(word, function);

		} else {

			return new ValueExpression(word);
		}
	}

	public static int nextToken(final StreamTokenizer tokenizer) {

		try {

			return tokenizer.nextToken();

		} catch (IOException ioex) {
		}

		return StreamTokenizer.TT_EOF;
	}

	static {

		functions.put("error", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				final Class entityType;
				final String type;

				if (entity != null) {

					entityType = entity.getClass();
					type       = entity.getType();

				} else {

					entityType = GraphObject.class;
					type       = "Base";

				}

				if (arrayHasLengthAndAllElementsNotNull(sources, 2)) {

					final PropertyKey key = StructrApp.getConfiguration().getPropertyKeyForJSONName(entityType, sources[0].toString());
					ctx.raiseError(type, new ErrorToken(422, key) {

						@Override
						public JsonElement getContent() {
							return new JsonPrimitive(getErrorToken());
						}

						@Override
						public String getErrorToken() {
							return sources[1].toString();
						}
					});

				} else if (arrayHasLengthAndAllElementsNotNull(sources, 3)) {

					final PropertyKey key = StructrApp.getConfiguration().getPropertyKeyForJSONName(entityType, sources[0].toString());
					ctx.raiseError(type, new SemanticErrorToken(key) {

						@Override
						public JsonElement getContent() {

							JsonObject obj = new JsonObject();

							if (sources[2] instanceof Number) {

								obj.add(getErrorToken(), new JsonPrimitive((Number) sources[2]));

							} else if (sources[2] instanceof Boolean) {

								obj.add(getErrorToken(), new JsonPrimitive((Boolean) sources[2]));

							} else {

								obj.add(getErrorToken(), new JsonPrimitive(sources[2].toString()));
							}

							return obj;
						}

						@Override
						public String getErrorToken() {
							return sources[1].toString();
						}
					});
				}

				return null;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_ERROR;
			}
		});
		functions.put("md5", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				return (arrayHasMinLengthAndAllElementsNotNull(sources, 1))
					? DigestUtils.md5Hex(sources[0].toString())
					: "";

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_MD5;
			}
		});
		functions.put("upper", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				return (arrayHasMinLengthAndAllElementsNotNull(sources, 1))
					? sources[0].toString().toUpperCase()
					: "";

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_UPPER;
			}

		});
		functions.put("lower", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				return (arrayHasMinLengthAndAllElementsNotNull(sources, 1))
					? sources[0].toString().toLowerCase()
					: "";

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_LOWER;
			}

		});
		functions.put("join", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 2)) {

					if (sources[0] instanceof Collection) {

						return StringUtils.join((Collection) sources[0], sources[1].toString());
					}

					if (sources[0].getClass().isArray()) {

						return StringUtils.join((Object[]) sources[0], sources[1].toString());
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_JOIN;
			}

		});
		functions.put("concat", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				final List list = new ArrayList();
				for (final Object source : sources) {

					
					if (source != null) {

						if (source instanceof Collection) {

							list.addAll((Collection) source);

						} else if (source.getClass().isArray()) {

							list.addAll(Arrays.asList((Object[]) source));

						} else {

							list.add(source);
						}
					}
				}

				return StringUtils.join(list, "");
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_CONCAT;
			}

		});
		functions.put("split", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 1)) {

					final String toSplit = sources[0].toString();
					String splitExpr = "[,;]+";

					if (sources.length >= 2) {
						splitExpr = sources[1].toString();
					}

					return Arrays.asList(toSplit.split(splitExpr));
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_SPLIT;
			}

		});
		functions.put("abbr", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 2)) {

					try {
						int maxLength = Double.valueOf(sources[1].toString()).intValue();

						if (sources[0].toString().length() > maxLength) {

							return StringUtils.substringBeforeLast(StringUtils.substring(sources[0].toString(), 0, maxLength), " ").concat("");

						} else {

							return sources[0];
						}

					} catch (NumberFormatException nfe) {

						return nfe.getMessage();

					}

				}

				return "";

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_ABBR;
			}

		});
		functions.put("capitalize", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				return (arrayHasMinLengthAndAllElementsNotNull(sources, 1))
					? StringUtils.capitalize(sources[0].toString())
					: "";

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_CAPITALIZE;
			}
		});
		functions.put("titleize", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (sources == null || sources[0] == null) {
					return null;
				}

				if (StringUtils.isBlank(sources[0].toString())) {
					return "";
				}

				final String separator;
				if (sources.length < 2) {
					separator = " ";
				} else {
					separator = sources[1].toString();
				}

				String[] in = StringUtils.split(sources[0].toString(), separator);
				String[] out = new String[in.length];
				for (int i = 0; i < in.length; i++) {
					out[i] = StringUtils.capitalize(in[i]);
				}
				return StringUtils.join(out, " ");

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_TITLEIZE;
			}

		});
		functions.put("num", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 1)) {

					try {
						return getDoubleOrNull(sources[0]);

					} catch (Throwable t) {
						
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_NUM;
			}
		});
		functions.put("int", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 1)) {

					if (sources[0] instanceof Number) {
						return ((Number) sources[0]).intValue();
					}

					try {
						return getDoubleOrNull(sources[0]).intValue();

					} catch (Throwable t) {
						
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_INT;
			}
		});
		functions.put("random", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 1) && sources[0] instanceof Number) {

					try {
						return RandomStringUtils.randomAlphanumeric(((Number) sources[0]).intValue());

					} catch (Throwable t) {
						
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_RANDOM;
			}
		});
		functions.put("rint", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 1) && sources[0] instanceof Number) {

					try {
						return new Random(System.currentTimeMillis()).nextInt(((Number) sources[0]).intValue());

					} catch (Throwable t) {
						
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_RINT;
			}
		});
		functions.put("index_of", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 2)) {

					final String source = sources[0].toString();
					final String part = sources[1].toString();

					return source.indexOf(part);
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_INDEX_OF;
			}
		});
		functions.put("contains", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 2)) {

					if (sources[0] instanceof String && sources[1] instanceof String) {

						final String source = sources[0].toString();
						final String part = sources[1].toString();

						return source.contains(part);

					} else if (sources[0] instanceof Collection && sources[1] instanceof GraphObject) {

						final Collection collection = (Collection) sources[0];
						final GraphObject obj = (GraphObject) sources[1];

						return collection.contains(obj);

					} else if (sources[0].getClass().isArray()) {

						return ArrayUtils.contains((Object[]) sources[0], sources[1]);
					}
				}

				return false;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_CONTAINS;
			}
		});
		functions.put("substring", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 2)) {

					final String source = sources[0].toString();
					final int sourceLength = source.length();
					final int start = parseInt(sources[1]);
					final int length = sources.length >= 3 ? parseInt(sources[2]) : sourceLength - start;
					final int end = start + length;

					if (start >= 0 && start < sourceLength && end >= 0 && end <= sourceLength && start <= end) {

						return source.substring(start, end);
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_SUBSTRING;
			}
		});
		functions.put("length", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 1)) {

					return sources[0].toString().length();
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_SUBSTRING;
			}
		});
		functions.put("replace", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 2)) {

					final String template = sources[0].toString();
					AbstractNode node = null;

					if (sources[1] instanceof AbstractNode) {
						node = (AbstractNode) sources[1];
					}

					if (sources[1] instanceof List) {

						final List list = (List) sources[1];
						if (list.size() == 1 && list.get(0) instanceof AbstractNode) {

							node = (AbstractNode) list.get(0);
						}
					}

					if (node != null) {

						
						return Scripting.replaceVariables(ctx, node, template);
					}

					return "";
				}

				return usage(ctx.isJavaScriptContext());

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_REPLACE;
			}
		});
		functions.put("clean", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 1)) {

					if (StringUtils.isBlank(sources[0].toString())) {
						return "";
					}

					return cleanString(sources[0]);
				}

				return null;

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_CLEAN;
			}

		});
		functions.put("urlencode", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				return (arrayHasMinLengthAndAllElementsNotNull(sources, 1))
					? encodeURL(sources[0].toString())
					: "";

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_URLENCODE;
			}

		});
		functions.put("escape_javascript", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				return (arrayHasMinLengthAndAllElementsNotNull(sources, 1))
					? StringEscapeUtils.escapeEcmaScript(sources[0].toString())
					: "";

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_ESCAPE_JS;
			}

		});
		functions.put("escape_json", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				return (arrayHasMinLengthAndAllElementsNotNull(sources, 1))
					? StringEscapeUtils.escapeJson(sources[0].toString())
					: "";

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_ESCAPE_JSON;
			}

		});
		functions.put("if", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (sources[0] == null || sources.length < 3) {

					return "";
				}

				if ("true".equals(sources[0]) || Boolean.TRUE.equals(sources[0])) {

					return sources[1];

				} else {

					return sources[2];
				}

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_IF;
			}

		});
		functions.put("empty", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (sources.length == 0 || sources[0] == null || StringUtils.isEmpty(sources[0].toString())) {

					return true;

				} else {
					return false;
				}

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_EMPTY;
			}

		});
		functions.put("equal", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				logger.log(Level.FINE, "Length: {0}", sources.length);

				if (sources.length < 2) {

					return true;
				}

				logger.log(Level.FINE, "Comparing {0} to {1}", new java.lang.Object[]{sources[0], sources[1]});

				if (sources[0] == null && sources[1] == null) {
					return true;
				}

				if (sources[0] == null || sources[1] == null) {
					return false;
				}

				return valueEquals(sources[0], sources[1]);
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_EQUAL;
			}

		});
		functions.put("eq", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				return functions.get("equal").apply(ctx, entity, sources);
			}

			@Override
			public String usage(boolean inJavaScriptContext) {

				return functions.get("equal").usage(inJavaScriptContext);
			}

		});
		functions.put("add", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				Double result = 0.0;

				if (sources != null) {

					for (Object i : sources) {

						if (i != null) {

							try {

								result += Double.parseDouble(i.toString());

							} catch (Throwable t) {

								return t.getMessage();

							}

						} else {

							result += 0.0;
						}
					}

				}

				return result;

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_ADD;
			}

		});
		functions.put("double_sum", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				double result = 0.0;

				if (arrayHasLengthAndAllElementsNotNull(sources, 1)) {

					if (sources[0] instanceof Collection) {

						for (final Number num : (Collection<Number>) sources[0]) {

							result += num.doubleValue();
						}
					}
				}

				return result;

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_DOUBLE_SUM;
			}

		});
		functions.put("int_sum", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				int result = 0;

				if (arrayHasLengthAndAllElementsNotNull(sources, 1)) {

					if (sources[0] instanceof Collection) {

						for (final Number num : (Collection<Number>) sources[0]) {

							result += num.intValue();
						}
					}
				}

				return result;

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_INT_SUM;
			}

		});
		functions.put("is_collection", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 1)) {
					return (sources[0] instanceof Collection);
				} else {
					return false;
				}

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_IS_COLLECTION;
			}

		});
		functions.put("is_entity", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 1)) {
					return (sources[0] instanceof GraphObject);
				} else {
					return false;
				}

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_IS_ENTITY;
			}

		});
		functions.put("extract", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 1)) {

					
					if (sources[0] instanceof Collection) {

						final List extraction = new LinkedList();

						for (final Object obj : (Collection) sources[0]) {

							if (obj instanceof Collection) {

								extraction.addAll((Collection) obj);
							}
						}

						return extraction;
					}

				} else if (arrayHasLengthAndAllElementsNotNull(sources, 2)) {

					if (sources[0] instanceof Collection && sources[1] instanceof String) {

						final ConfigurationProvider config = StructrApp.getConfiguration();
						final List extraction = new LinkedList();
						final String keyName = (String) sources[1];

						for (final Object obj : (Collection) sources[0]) {

							if (obj instanceof GraphObject) {

								final PropertyKey key = config.getPropertyKeyForJSONName(obj.getClass(), keyName);
								final Object value = ((GraphObject) obj).getProperty(key);
								if (value != null) {

									extraction.add(value);
								}
							}
						}

						return extraction;
					}
				}

				return null;

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_EXTRACT;
			}

		});
		functions.put("merge", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				final List list = new ArrayList();
				for (final Object source : sources) {

					if (source instanceof Collection) {

						
						for (Object obj : (Collection) source) {

							if (obj != null) {

								list.add(obj);
							}
						}

					} else if (source != null) {

						list.add(source);
					}
				}

				return list;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_MERGE;
			}

		});
		functions.put("complement", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				final Set sourceSet = new HashSet();

				if (sources[0] instanceof Collection) {

					sourceSet.addAll((Collection) sources[0]);

					for (int cnt = 1; cnt < sources.length; cnt++) {

						final Object source = sources[cnt];

						if (source instanceof Collection) {

							sourceSet.removeAll((Collection) source);

						} else if (source != null) {

							sourceSet.remove(source);
						}
					}

				} else {

					return "Argument 1 for complement must be a Collection";
				}

				return sourceSet;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_COMPLEMENT;
			}

		});
		functions.put("unwind", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				final List list = new ArrayList();
				for (final Object source : sources) {

					if (source instanceof Collection) {

						
						for (Object obj : (Collection) source) {
							if (obj != null) {

								if (obj instanceof Collection) {

									for (final Object elem : (Collection) obj) {

										if (elem != null) {

											list.add(elem);
										}
									}

								} else {

									list.add(obj);
								}
							}
						}

					} else if (source != null) {

						list.add(source);
					}
				}

				return list;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_UNWIND;
			}

		});
		functions.put("sort", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 2)) {

					if (sources[0] instanceof List && sources[1] instanceof String) {

						final List list = (List) sources[0];
						final String sortKey = sources[1].toString();
						final Iterator iterator = list.iterator();

						if (iterator.hasNext()) {

							final Object firstElement = iterator.next();
							if (firstElement instanceof GraphObject) {

								final Class type = firstElement.getClass();
								final PropertyKey key = StructrApp.getConfiguration().getPropertyKeyForJSONName(type, sortKey);
								final boolean descending = sources.length == 3 && sources[2] != null && "true".equals(sources[2].toString());

								if (key != null) {

									List<GraphObject> sortCollection = (List<GraphObject>) list;
									Collections.sort(sortCollection, new GraphObjectComparator(key, descending));

									return sortCollection;
								}
							}

						}
					}
				}

				return sources[0];
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_SORT;
			}

		});
		functions.put("lt", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				String result = "";

				if (arrayHasLengthAndAllElementsNotNull(sources, 2)) {

					return lt(sources[0], sources[1]);
				}

				return result;

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_LT;
			}
		});
		functions.put("gt", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				String result = "";

				if (arrayHasLengthAndAllElementsNotNull(sources, 2)) {

					return gt(sources[0], sources[1]);
				}

				return result;

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_GT;
			}
		});
		functions.put("lte", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				String result = "";

				if (arrayHasLengthAndAllElementsNotNull(sources, 2)) {

					return lte(sources[0], sources[1]);
				}

				return result;

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_LTE;
			}
		});
		functions.put("gte", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				String result = "";

				if (arrayHasLengthAndAllElementsNotNull(sources, 2)) {

					return gte(sources[0], sources[1]);

				}

				return result;

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_GTE;
			}
		});
		functions.put("subt", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 2)) {

					try {

						Double result = Double.parseDouble(sources[0].toString());

						for (int i = 1; i < sources.length; i++) {

							result -= Double.parseDouble(sources[i].toString());

						}

						return result;

					} catch (Throwable t) {

						return t.getMessage();

					}
				}

				return "";

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_SUBT;
			}
		});
		functions.put("mult", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				Double result = 1.0d;

				if (sources != null) {

					for (Object i : sources) {

						try {

							result *= Double.parseDouble(i.toString());

						} catch (Throwable t) {

							return t.getMessage();

						}
					}

				}

				return result;

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_MULT;
			}
		});
		functions.put("quot", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 2)) {

					try {

						return Double.parseDouble(sources[0].toString()) / Double.parseDouble(sources[1].toString());

					} catch (Throwable t) {

						return t.getMessage();

					}

				} else {

					if (sources != null) {

						if (sources.length > 0 && sources[0] != null) {
							return Double.valueOf(sources[0].toString());
						}

						return "";
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_QUOT;
			}
		});
		functions.put("round", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 2)) {

					if (StringUtils.isBlank(sources[0].toString())) {
						return "";
					}

					try {

						Double f1 = Double.parseDouble(sources[0].toString());
						double f2 = Math.pow(10, (Double.parseDouble(sources[1].toString())));
						long r = Math.round(f1 * f2);

						return (double) r / f2;

					} catch (Throwable t) {

						return t.getMessage();

					}

				} else {

					return "";
				}
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_ROUND;
			}
		});
		functions.put("max", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				Object result = "";
				String errorMsg = "ERROR! Usage: ${max(val1, val2)}. Example: ${max(5,10)}";

				if (arrayHasLengthAndAllElementsNotNull(sources, 2)) {

					try {
						result = Math.max(Double.parseDouble(sources[0].toString()), Double.parseDouble(sources[1].toString()));

					} catch (Throwable t) {

						logger.log(Level.WARNING, "Could not determine max() of {0} and {1}", new Object[]{sources[0], sources[1]});
						result = errorMsg;
					}

				} else {

					result = "";
				}

				return result;

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_MAX;
			}
		});
		functions.put("min", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				Object result = "";
				String errorMsg = "ERROR! Usage: ${min(val1, val2)}. Example: ${min(5,10)}";

				if (arrayHasLengthAndAllElementsNotNull(sources, 2)) {

					try {
						result = Math.min(Double.parseDouble(sources[0].toString()), Double.parseDouble(sources[1].toString()));

					} catch (Throwable t) {

						logger.log(Level.WARNING, "Could not determine min() of {0} and {1}", new Object[]{sources[0], sources[1]});
						result = errorMsg;
					}

				} else {

					result = "";
				}

				return result;

			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_MIN;
			}
		});
		functions.put("config", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 1)) {

					final String configKey = sources[0].toString();
					final String defaultValue = sources.length >= 2 ? sources[1].toString() : "";

					return StructrApp.getConfigurationValue(configKey, defaultValue);
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_CONFIG_JS : ERROR_MESSAGE_CONFIG);
			}
		});
		functions.put("date_format", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (sources == null || sources != null && sources.length != 2) {
					return usage(ctx.isJavaScriptContext());
				}

				if (arrayHasLengthAndAllElementsNotNull(sources, 2)) {

					Date date = null;

					if (sources[0] instanceof Date) {

						date = (Date) sources[0];

					} else if (sources[0] instanceof Number) {

						date = new Date(((Number) sources[0]).longValue());

					} else {

						try {

							
							date = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").parse(sources[0].toString());

						} catch (ParseException ex) {
							ex.printStackTrace();
						}

					}

					
					return new SimpleDateFormat(sources[1].toString()).format(date);
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_DATE_FORMAT_JS : ERROR_MESSAGE_DATE_FORMAT);
			}
		});
		functions.put("parse_date", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (sources == null || sources != null && sources.length != 2) {
					return usage(ctx.isJavaScriptContext());
				}

				if (arrayHasLengthAndAllElementsNotNull(sources, 2)) {

					String dateString = sources[0].toString();

					if (StringUtils.isBlank(dateString)) {
						return "";
					}

					String pattern = sources[1].toString();

					try {
						
						return new SimpleDateFormat(pattern).parse(dateString);

					} catch (ParseException ex) {
						logger.log(Level.WARNING, "Could not parse date " + dateString + " and format it to pattern " + pattern, ex);
					}

				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_PARSE_DATE_JS : ERROR_MESSAGE_PARSE_DATE);
			}
		});
		functions.put("number_format", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (sources == null || sources != null && sources.length != 3) {
					return usage(ctx.isJavaScriptContext());
				}

				if (arrayHasLengthAndAllElementsNotNull(sources, 3)) {

					if (StringUtils.isBlank(sources[0].toString())) {
						return "";
					}

					try {

						Double val = Double.parseDouble(sources[0].toString());
						String langCode = sources[1].toString();
						String pattern = sources[2].toString();

						return new DecimalFormat(pattern, DecimalFormatSymbols.getInstance(Locale.forLanguageTag(langCode))).format(val);

					} catch (Throwable t) {
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_NUMBER_FORMAT_JS : ERROR_MESSAGE_NUMBER_FORMAT);
			}
		});
		functions.put("template", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (sources == null || sources != null && sources.length != 3) {
					return usage(ctx.isJavaScriptContext());
				}

				if (arrayHasLengthAndAllElementsNotNull(sources, 3) && sources[2] instanceof AbstractNode) {

					final App app = StructrApp.getInstance(entity != null ? entity.getSecurityContext() : ctx.getSecurityContext());
					final String name = sources[0].toString();
					final String locale = sources[1].toString();
					final MailTemplate template = app.nodeQuery(MailTemplate.class).andName(name).and(MailTemplate.locale, locale).getFirst();
					final AbstractNode templateInstance = (AbstractNode) sources[2];

					if (template != null) {

						final String text = template.getProperty(MailTemplate.text);
						if (text != null) {

							
							return Scripting.replaceVariables(ctx, templateInstance, text);
						}
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_TEMPLATE_JS : ERROR_MESSAGE_TEMPLATE);
			}
		});
		functions.put("not", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 1)) {

					return !("true".equals(sources[0].toString()) || Boolean.TRUE.equals(sources[0]));

				}

				return true;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_NOT;
			}

		});
		functions.put("and", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				boolean result = true;

				if (sources != null) {

					if (sources.length < 2) {
						return usage(ctx.isJavaScriptContext());
					}

					for (Object i : sources) {

						if (i != null) {

							try {

								result &= "true".equals(i.toString()) || Boolean.TRUE.equals(i);

							} catch (Throwable t) {

								return t.getMessage();

							}

						} else {

							
							return false;
						}
					}

				}

				return result;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_AND;
			}

		});
		functions.put("or", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				boolean result = false;

				if (sources != null) {

					if (sources.length < 2) {
						return usage(ctx.isJavaScriptContext());
					}

					for (Object i : sources) {

						if (i != null) {

							try {

								result |= "true".equals(i.toString()) || Boolean.TRUE.equals(i);

							} catch (Throwable t) {

								return t.getMessage();

							}

						} else {

							
							result |= false;
						}
					}

				}

				return result;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_OR;
			}
		});
		functions.put("get", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				final SecurityContext securityContext = entity != null ? entity.getSecurityContext() : ctx.getSecurityContext();
				if (arrayHasLengthAndAllElementsNotNull(sources, 2)) {

					GraphObject dataObject = null;

					if (sources[0] instanceof GraphObject) {
						dataObject = (GraphObject) sources[0];
					}

					if (sources[0] instanceof List) {

						final List list = (List) sources[0];
						if (list.size() == 1 && list.get(0) instanceof GraphObject) {

							dataObject = (GraphObject) list.get(0);
						}
					}

					if (dataObject != null) {

						final String keyName = sources[1].toString();
						final PropertyKey key = StructrApp.getConfiguration().getPropertyKeyForJSONName(dataObject.getClass(), keyName);

						if (key != null) {

							final PropertyConverter inputConverter = key.inputConverter(securityContext);
							Object value = dataObject.getProperty(key);

							if (inputConverter != null) {
								return inputConverter.revert(value);
							}

							return dataObject.getProperty(key);
						}

						return "";

					} else {

						return ERROR_MESSAGE_GET_ENTITY;
					}
				}

				return usage(ctx.isJavaScriptContext());
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_GET;
			}
		});
		functions.put("size", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				final List list = new ArrayList();
				for (final Object source : sources) {

					if (source != null) {

						if (source instanceof Collection) {

							
							for (Object obj : (Collection) source) {
								if (obj != null && !NULL_STRING.equals(obj)) {

									list.add(obj);
								}
							}

						} else if (source.getClass().isArray()) {

							list.addAll(Arrays.asList((Object[]) source));

						} else if (source != null && !NULL_STRING.equals(source)) {

							list.add(source);
						}

						return list.size();
					}
				}

				return 0;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_SIZE;
			}
		});
		functions.put("first", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 1)) {

					if (sources[0] instanceof List && !((List) sources[0]).isEmpty()) {
						return ((List) sources[0]).get(0);
					}

					if (sources[0].getClass().isArray()) {

						final Object[] arr = (Object[]) sources[0];
						if (arr.length > 0) {

							return arr[0];
						}
					}
				}

				return null;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_FIRST;
			}
		});
		functions.put("last", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 1)) {

					if (sources[0] instanceof List && !((List) sources[0]).isEmpty()) {

						final List list = (List) sources[0];
						return list.get(list.size() - 1);
					}

					if (sources[0].getClass().isArray()) {

						final Object[] arr = (Object[]) sources[0];
						if (arr.length > 0) {

							return arr[arr.length - 1];
						}
					}

				}

				return null;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_LAST;
			}
		});
		functions.put("nth", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 2)) {

					final int pos = Double.valueOf(sources[1].toString()).intValue();

					if (sources[0] instanceof List && !((List) sources[0]).isEmpty()) {

						final List list = (List) sources[0];
						final int size = list.size();

						if (pos >= size) {

							return null;

						}

						return list.get(Math.min(Math.max(0, pos), size - 1));
					}

					if (sources[0].getClass().isArray()) {

						final Object[] arr = (Object[]) sources[0];
						if (pos <= arr.length) {

							return arr[pos];
						}
					}
				}

				return null;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_NTH;
			}
		});
		functions.put("get_counter", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 1)) {

					return ctx.getCounter(parseInt(sources[0]));
				}

				return 0;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_GET_COUNTER;
			}
		});
		functions.put("inc_counter", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 1)) {

					final int level = parseInt(sources[0]);

					ctx.incrementCounter(level);

					
					if (sources.length == 2 && "true".equals(sources[1].toString())) {

						
						for (int i = level + 1; i < 10; i++) {
							ctx.resetCounter(i);
						}
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_INC_COUNTER;
			}
		});
		functions.put("reset_counter", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 1)) {

					ctx.resetCounter(parseInt(sources[0]));
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_RESET_COUNTER;
			}
		});
		functions.put("merge_properties", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 2) && sources[0] instanceof GraphObject && sources[1] instanceof GraphObject) {

					final ConfigurationProvider config = StructrApp.getConfiguration();
					final Set<PropertyKey> mergeKeys = new LinkedHashSet<>();
					final GraphObject source = (GraphObject) sources[0];
					final GraphObject target = (GraphObject) sources[1];
					final int paramCount = sources.length;

					for (int i = 2; i < paramCount; i++) {

						final String keyName = sources[i].toString();
						final PropertyKey key = config.getPropertyKeyForJSONName(target.getClass(), keyName);

						mergeKeys.add(key);
					}

					for (final PropertyKey key : mergeKeys) {

						final Object sourceValue = source.getProperty(key);
						if (sourceValue != null) {

							target.setProperty(key, sourceValue);
						}

					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_MERGE_PROPERTIES;
			}
		});
		functions.put("keys", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 2) && sources[0] instanceof GraphObject) {

					final Set<String> keys = new LinkedHashSet<>();
					final GraphObject source = (GraphObject) sources[0];

					for (final PropertyKey key : source.getPropertyKeys(sources[1].toString())) {
						keys.add(key.jsonName());
					}

					return new LinkedList<>(keys);

				} else if (arrayHasMinLengthAndAllElementsNotNull(sources, 1) && sources[0] instanceof GraphObjectMap) {

					return new LinkedList<>(((GraphObjectMap) sources[0]).keySet());

				} else if (arrayHasMinLengthAndAllElementsNotNull(sources, 1) && sources[0] instanceof Map) {

					return new LinkedList<>(((Map) sources[0]).keySet());

				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_KEYS;
			}
		});

		
		functions.put("retrieve", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 1) && sources[0] instanceof String) {

					return ctx.retrieve(sources[0].toString());

				} else {

					return usage(ctx.isJavaScriptContext());
				}
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_RETRIEVE_JS : ERROR_MESSAGE_RETRIEVE);
			}
		});
		functions.put("store", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 2) && sources[0] instanceof String) {

					ctx.store(sources[0].toString(), sources[1]);

				} else {

					return usage(ctx.isJavaScriptContext());
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_STORE_JS : ERROR_MESSAGE_STORE);
			}
		});
		functions.put("print", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (sources != null) {

					for (Object i : sources) {

						System.out.print(i);
					}

					System.out.println();
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_PRINT;
			}
		});
		functions.put("read", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 1)) {

					try {
						final String sandboxFilename = getSandboxFileName(sources[0].toString());
						if (sandboxFilename != null) {

							final File file = new File(sandboxFilename);
							if (file.exists() && file.length() < 10000000) {

								try (final FileInputStream fis = new FileInputStream(file)) {

									return IOUtils.toString(fis, "utf-8");
								}
							}
						}

					} catch (IOException ioex) {
						ioex.printStackTrace();
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_READ;
			}
		});
		functions.put("write", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 1)) {

					try {
						final String sandboxFilename = getSandboxFileName(sources[0].toString());
						if (sandboxFilename != null) {

							final File file = new File(sandboxFilename);
							if (!file.exists()) {

								try (final Writer writer = new OutputStreamWriter(new FileOutputStream(file, false))) {

									for (int i = 1; i < sources.length; i++) {
										if (sources[i] != null) {
											IOUtils.write(sources[i].toString(), writer);
										}
									}

									writer.flush();
								}

							} else {

								logger.log(Level.SEVERE, "Trying to overwrite an existing file, please use append() for that purpose.");
							}
						}

					} catch (IOException ioex) {
						ioex.printStackTrace();
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_WRITE;
			}
		});
		functions.put("append", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 1)) {

					try {
						final String sandboxFilename = getSandboxFileName(sources[0].toString());
						if (sandboxFilename != null) {

							final File file = new File(sandboxFilename);

							try (final Writer writer = new OutputStreamWriter(new FileOutputStream(file, true))) {

								for (int i = 1; i < sources.length; i++) {
									IOUtils.write(sources[i].toString(), writer);
								}

								writer.flush();
							}
						}

					} catch (IOException ioex) {
						ioex.printStackTrace();
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_APPEND;
			}
		});
		functions.put("xml", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 1) && sources[0] instanceof String) {

					try {

						final DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
						if (builder != null) {

							final String xml = (String) sources[0];
							final StringReader reader = new StringReader(xml);
							final InputSource src = new InputSource(reader);

							return builder.parse(src);
						}

					} catch (IOException | SAXException | ParserConfigurationException ex) {
						ex.printStackTrace();
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_XML;
			}
		});
		functions.put("xpath", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 2) && sources[0] instanceof Document) {

					try {

						XPath xpath = XPathFactory.newInstance().newXPath();
						return xpath.evaluate(sources[1].toString(), sources[0], XPathConstants.STRING);

					} catch (XPathExpressionException ioex) {
						ioex.printStackTrace();
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_XPATH;
			}
		});
		functions.put("set", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 2)) {

					if (sources[0] instanceof GraphObject) {

						final GraphObject source = (GraphObject) sources[0];
						final Map<String, Object> properties = new LinkedHashMap<>();
						final SecurityContext securityContext = source.getSecurityContext();
						final Gson gson = new GsonBuilder().create();
						final Class type = source.getClass();
						final int sourceCount = sources.length;

						if (sources.length == 3 && sources[2] != null && sources[1].toString().matches("[a-zA-Z0-9_]+")) {

							properties.put(sources[1].toString(), sources[2]);

						} else {

							
							for (int i = 1; i < sourceCount; i++) {

								final Map<String, Object> values = deserialize(gson, sources[i].toString());
								if (values != null) {

									properties.putAll(values);
								}
							}
						}

						
						final PropertyMap map = PropertyMap.inputTypeToJavaType(securityContext, type, properties);
						for (final Map.Entry<PropertyKey, Object> entry : map.entrySet()) {

							source.setProperty(entry.getKey(), entry.getValue());
						}

					} else {

						throw new FrameworkException(422, "Invalid use of builtin method set, usage: set(entity, params..)");
					}

				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_SET;
			}
		});
		functions.put("send_plaintext_mail", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 6)) {

					final String from = sources[0].toString();
					final String fromName = sources[1].toString();
					final String to = sources[2].toString();
					final String toName = sources[3].toString();
					final String subject = sources[4].toString();
					final String textContent = sources[5].toString();

					try {
						return MailHelper.sendSimpleMail(from, fromName, to, toName, null, null, from, subject, textContent);

					} catch (EmailException eex) {
						eex.printStackTrace();
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_SEND_PLAINTEXT_MAIL;
			}
		});
		functions.put("send_html_mail", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 6)) {

					final String from = sources[0].toString();
					final String fromName = sources[1].toString();
					final String to = sources[2].toString();
					final String toName = sources[3].toString();
					final String subject = sources[4].toString();
					final String htmlContent = sources[5].toString();
					String textContent = "";

					if (sources.length == 7) {
						textContent = sources[6].toString();
					}

					try {
						return MailHelper.sendHtmlMail(from, fromName, to, toName, null, null, from, subject, htmlContent, textContent);

					} catch (EmailException eex) {
						eex.printStackTrace();
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_SEND_HTML_MAIL;
			}
		});
		functions.put("geocode", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 3)) {

					final Gson gson = new GsonBuilder().create();
					final String street = sources[0].toString();
					final String city = sources[1].toString();
					final String country = sources[2].toString();

					GeoCodingResult result = GeoHelper.geocode(street, null, null, city, null, country);
					if (result != null) {

						final Map<String, Object> map = new LinkedHashMap<>();

						map.put("latitude", result.getLatitude());
						map.put("longitude", result.getLongitude());

						return serialize(gson, map);
					}

				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_GEOCODE;
			}
		});
		functions.put("find", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (sources != null) {

					final SecurityContext securityContext = ctx.getSecurityContext();
					final ConfigurationProvider config = StructrApp.getConfiguration();
					final Query query = StructrApp.getInstance(securityContext).nodeQuery().sort(GraphObject.createdDate).order(false);

					
					Class type = null;

					if (sources.length >= 1 && sources[0] != null) {

						type = config.getNodeEntityClass(sources[0].toString());

						if (type != null) {

							query.andTypes(type);
						}
					}

					
					if (sources.length == 2 && sources[1] instanceof Map) {

						query.and(PropertyMap.inputTypeToJavaType(securityContext, type, (Map) sources[1]));

					} else {

						final Integer parameter_count = sources.length;

						if (parameter_count % 2 == 0) {

							throw new FrameworkException(400, "Invalid number of parameters: " + parameter_count + ". Should be uneven: " + ERROR_MESSAGE_FIND);
						}

						for (Integer c = 1; c < parameter_count; c += 2) {

							final PropertyKey key = config.getPropertyKeyForJSONName(type, sources[c].toString());

							if (key != null) {

								
								if (!key.isSearchable()) {

									throw new FrameworkException(400, "Search key " + key.jsonName() + " is not indexed.");
								}

								final PropertyConverter inputConverter = key.inputConverter(securityContext);
								Object value = sources[c + 1];

								if (inputConverter != null) {

									value = inputConverter.convert(value);
								}

								query.and(key, value);
							}
						}
					}

					return query.getAsList();
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_FIND;
			}
		});
		functions.put("search", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (sources != null) {

					final SecurityContext securityContext = entity != null ? entity.getSecurityContext() : ctx.getSecurityContext();
					final ConfigurationProvider config = StructrApp.getConfiguration();
					final Query query = StructrApp.getInstance(securityContext).nodeQuery();
					Class type = null;

					if (sources.length >= 1 && sources[0] != null) {

						type = config.getNodeEntityClass(sources[0].toString());

						if (type != null) {

							query.andTypes(type);
						}
					}

					
					if (sources.length == 2 && sources[1] instanceof Map) {

						final PropertyMap map = PropertyMap.inputTypeToJavaType(securityContext, type, (Map) sources[1]);
						for (final Entry<PropertyKey, Object> entry : map.entrySet()) {

							query.and(entry.getKey(), entry.getValue(), false);
						}

					} else {

						final Integer parameter_count = sources.length;

						if (parameter_count % 2 == 0) {

							throw new FrameworkException(400, "Invalid number of parameters: " + parameter_count + ". Should be uneven: " + ERROR_MESSAGE_FIND);
						}

						for (Integer c = 1; c < parameter_count; c += 2) {

							final PropertyKey key = config.getPropertyKeyForJSONName(type, sources[c].toString());

							if (key != null) {

								
								if (!key.isSearchable()) {

									throw new FrameworkException(400, "Search key " + key.jsonName() + " is not indexed.");
								}

								final PropertyConverter inputConverter = key.inputConverter(securityContext);
								Object value = sources[c + 1];

								if (inputConverter != null) {

									value = inputConverter.convert(value);
								}

								query.and(key, value, false);
							}

						}
					}

					final Object x = query.getAsList();

					
					return x;
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_SEARCH;
			}
		});
		functions.put("create", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (sources != null) {

					final SecurityContext securityContext = entity != null ? entity.getSecurityContext() : ctx.getSecurityContext();
					final App app = StructrApp.getInstance(securityContext);
					final ConfigurationProvider config = StructrApp.getConfiguration();
					PropertyMap propertyMap = null;
					Class type = null;

					if (sources.length >= 1 && sources[0] != null) {

						type = config.getNodeEntityClass(sources[0].toString());

						if (entity != null && type.equals(entity.getClass())) {

							throw new FrameworkException(422, "Cannot create() entity of the same type in save action.");
						}
					}

					
					if (sources.length == 2 && sources[1] instanceof Map) {

						propertyMap = PropertyMap.inputTypeToJavaType(securityContext, type, (Map) sources[1]);

					} else {

						propertyMap = new PropertyMap();
						final Integer parameter_count = sources.length;

						if (parameter_count % 2 == 0) {

							throw new FrameworkException(400, "Invalid number of parameters: " + parameter_count + ". Should be uneven: " + ERROR_MESSAGE_CREATE);
						}

						for (Integer c = 1; c < parameter_count; c += 2) {

							final PropertyKey key = config.getPropertyKeyForJSONName(type, sources[c].toString());

							if (key != null) {

								final PropertyConverter inputConverter = key.inputConverter(securityContext);
								Object value = sources[c + 1];

								if (inputConverter != null) {

									value = inputConverter.convert(value);
								}

								propertyMap.put(key, value);

							}

						}
					}

					if (type != null) {

						return app.create(type, propertyMap);

					} else {

						throw new FrameworkException(422, "Unknown type in create() save action.");
					}

				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_CREATE;
			}
		});
		functions.put("delete", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (sources != null) {

					final App app = StructrApp.getInstance(entity != null ? entity.getSecurityContext() : ctx.getSecurityContext());
					for (final Object obj : sources) {

						if (obj instanceof NodeInterface) {

							app.delete((NodeInterface) obj);
							continue;
						}

						if (obj instanceof RelationshipInterface) {

							app.delete((RelationshipInterface) obj);
							continue;
						}
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return ERROR_MESSAGE_DELETE;
			}
		});
		functions.put("incoming", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 1)) {

					final RelationshipFactory factory = new RelationshipFactory(entity != null ? entity.getSecurityContext() : ctx.getSecurityContext());
					final Object source = sources[0];

					if (source instanceof NodeInterface) {

						final NodeInterface node = (NodeInterface) source;
						if (sources.length > 1) {

							final Object relType = sources[1];
							if (relType != null && relType instanceof String) {

								final String relTypeName = (String) relType;
								return factory.instantiate(node.getNode().getRelationships(Direction.INCOMING, DynamicRelationshipType.withName(relTypeName)));
							}

						} else {

							return factory.instantiate(node.getNode().getRelationships(Direction.INCOMING));
						}

					} else {

						return "Error: entity is not a node.";
					}
				}
				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_INCOMING_JS : ERROR_MESSAGE_INCOMING);
			}
		});
		functions.put("outgoing", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 1)) {

					final RelationshipFactory factory = new RelationshipFactory(entity != null ? entity.getSecurityContext() : ctx.getSecurityContext());
					final Object source = sources[0];

					if (source instanceof NodeInterface) {

						final NodeInterface node = (NodeInterface) source;
						if (sources.length > 1) {

							final Object relType = sources[1];
							if (relType != null && relType instanceof String) {

								final String relTypeName = (String) relType;
								return factory.instantiate(node.getNode().getRelationships(Direction.OUTGOING, DynamicRelationshipType.withName(relTypeName)));
							}

						} else {

							return factory.instantiate(node.getNode().getRelationships(Direction.OUTGOING));
						}

					} else {

						return "Error: entity is not a node.";
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_OUTGOING_JS : ERROR_MESSAGE_OUTGOING);
			}
		});
		functions.put("has_relationship", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 2)) {

					final Object source = sources[0];
					final Object target = sources[1];

					AbstractNode sourceNode = null;
					AbstractNode targetNode = null;

					if (source instanceof AbstractNode && target instanceof AbstractNode) {

						sourceNode = (AbstractNode) source;
						targetNode = (AbstractNode) target;

					} else {

						return "Error: entities are not nodes.";
					}

					if (sources.length == 2) {

						for (final AbstractRelationship rel : sourceNode.getRelationships()) {

							final NodeInterface s = rel.getSourceNode();
							final NodeInterface t = rel.getTargetNode();

							
							if (s != null & t != null
								&& ((s.equals(sourceNode) && t.equals(targetNode)) || (s.equals(targetNode) && t.equals(sourceNode)))) {
								return true;
							}
						}

					} else if (sources.length == 3) {

						
						final String relType = (String) sources[2];

						for (final AbstractRelationship rel : sourceNode.getRelationships()) {

							final NodeInterface s = rel.getSourceNode();
							final NodeInterface t = rel.getTargetNode();

							
							if (s != null & t != null
								&& rel.getRelType().name().equals(relType)
								&& ((s.equals(sourceNode) && t.equals(targetNode)) || (s.equals(targetNode) && t.equals(sourceNode)))) {
								return true;
							}
						}

					}

				}

				return false;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_HAS_RELATIONSHIP_JS : ERROR_MESSAGE_HAS_RELATIONSHIP);
			}
		});
		functions.put("has_outgoing_relationship", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 2)) {

					final Object source = sources[0];
					final Object target = sources[1];

					AbstractNode sourceNode = null;
					AbstractNode targetNode = null;

					if (source instanceof AbstractNode && target instanceof AbstractNode) {

						sourceNode = (AbstractNode) source;
						targetNode = (AbstractNode) target;

					} else {

						return "Error: entities are not nodes.";
					}

					if (sources.length == 2) {

						for (final AbstractRelationship rel : sourceNode.getOutgoingRelationships()) {

							final NodeInterface s = rel.getSourceNode();
							final NodeInterface t = rel.getTargetNode();

							
							if (s != null & t != null
								&& s.equals(sourceNode) && t.equals(targetNode)) {
								return true;
							}
						}

					} else if (sources.length == 3) {

						
						final String relType = (String) sources[2];

						for (final AbstractRelationship rel : sourceNode.getOutgoingRelationships()) {

							final NodeInterface s = rel.getSourceNode();
							final NodeInterface t = rel.getTargetNode();

							
							if (s != null & t != null
								&& rel.getRelType().name().equals(relType)
								&& s.equals(sourceNode) && t.equals(targetNode)) {
								return true;
							}
						}

					}

				}

				return false;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_HAS_OUTGOING_RELATIONSHIP_JS : ERROR_MESSAGE_HAS_OUTGOING_RELATIONSHIP);
			}
		});
		functions.put("has_incoming_relationship", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 2)) {

					final Object source = sources[0];
					final Object target = sources[1];

					AbstractNode sourceNode = null;
					AbstractNode targetNode = null;

					if (source instanceof AbstractNode && target instanceof AbstractNode) {

						sourceNode = (AbstractNode) source;
						targetNode = (AbstractNode) target;

					} else {

						return "Error: entities are not nodes.";
					}

					if (sources.length == 2) {

						for (final AbstractRelationship rel : sourceNode.getIncomingRelationships()) {

							final NodeInterface s = rel.getSourceNode();
							final NodeInterface t = rel.getTargetNode();

							
							if (s != null & t != null
								&& s.equals(targetNode) && t.equals(sourceNode)) {
								return true;
							}
						}

					} else if (sources.length == 3) {

						
						final String relType = (String) sources[2];

						for (final AbstractRelationship rel : sourceNode.getIncomingRelationships()) {

							final NodeInterface s = rel.getSourceNode();
							final NodeInterface t = rel.getTargetNode();

							
							if (s != null & t != null
								&& rel.getRelType().name().equals(relType)
								&& s.equals(targetNode) && t.equals(sourceNode)) {
								return true;
							}
						}

					}

				}

				return false;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_HAS_INCOMING_RELATIONSHIP_JS : ERROR_MESSAGE_HAS_INCOMING_RELATIONSHIP);
			}
		});
		functions.put("get_relationships", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				final List<AbstractRelationship> list = new ArrayList<>();

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 2)) {

					final Object source = sources[0];
					final Object target = sources[1];

					NodeInterface sourceNode = null;
					NodeInterface targetNode = null;

					if (source instanceof NodeInterface && target instanceof NodeInterface) {

						sourceNode = (NodeInterface) source;
						targetNode = (NodeInterface) target;

					} else {

						return "Error: Entities are not nodes.";
					}

					if (sources.length == 2) {

						for (final AbstractRelationship rel : sourceNode.getRelationships()) {

							final NodeInterface s = rel.getSourceNode();
							final NodeInterface t = rel.getTargetNode();

							
							if (s != null && t != null
								&& ((s.equals(sourceNode) && t.equals(targetNode)) || (s.equals(targetNode) && t.equals(sourceNode)))) {
								list.add(rel);
							}
						}

					} else if (sources.length == 3) {

						
						final String relType = (String) sources[2];

						for (final AbstractRelationship rel : sourceNode.getRelationships()) {

							final NodeInterface s = rel.getSourceNode();
							final NodeInterface t = rel.getTargetNode();

							
							if (s != null && t != null
								&& rel.getRelType().name().equals(relType)
								&& ((s.equals(sourceNode) && t.equals(targetNode)) || (s.equals(targetNode) && t.equals(sourceNode)))) {
								list.add(rel);
							}
						}

					}
				}

				return list;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_GET_RELATIONSHIPS_JS : ERROR_MESSAGE_GET_RELATIONSHIPS);
			}
		});
		functions.put("get_outgoing_relationships", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				final List<AbstractRelationship> list = new ArrayList<>();

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 2)) {

					final Object source = sources[0];
					final Object target = sources[1];

					AbstractNode sourceNode = null;
					AbstractNode targetNode = null;

					if (source instanceof AbstractNode && target instanceof AbstractNode) {

						sourceNode = (AbstractNode) source;
						targetNode = (AbstractNode) target;

					} else {

						return "Error: entities are not nodes.";
					}

					if (sources.length == 2) {

						for (final AbstractRelationship rel : sourceNode.getOutgoingRelationships()) {

							final NodeInterface s = rel.getSourceNode();
							final NodeInterface t = rel.getTargetNode();

							
							if (s != null && t != null
								&& s.equals(sourceNode) && t.equals(targetNode)) {
								list.add(rel);
							}
						}

					} else if (sources.length == 3) {

						
						final String relType = (String) sources[2];

						for (final AbstractRelationship rel : sourceNode.getOutgoingRelationships()) {

							final NodeInterface s = rel.getSourceNode();
							final NodeInterface t = rel.getTargetNode();

							
							if (s != null && t != null
								&& rel.getRelType().name().equals(relType)
								&& s.equals(sourceNode) && t.equals(targetNode)) {
								list.add(rel);
							}
						}

					}
				}

				return list;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_GET_OUTGOING_RELATIONSHIPS_JS : ERROR_MESSAGE_GET_OUTGOING_RELATIONSHIPS);
			}
		});
		functions.put("get_incoming_relationships", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				final List<AbstractRelationship> list = new ArrayList<>();

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 2)) {

					final Object source = sources[0];
					final Object target = sources[1];

					AbstractNode sourceNode = null;
					AbstractNode targetNode = null;

					if (source instanceof AbstractNode && target instanceof AbstractNode) {

						sourceNode = (AbstractNode) source;
						targetNode = (AbstractNode) target;

					} else {

						return "Error: entities are not nodes.";
					}

					if (sources.length == 2) {

						for (final AbstractRelationship rel : sourceNode.getIncomingRelationships()) {

							final NodeInterface s = rel.getSourceNode();
							final NodeInterface t = rel.getTargetNode();

							
							if (s != null && t != null
								&& s.equals(targetNode) && t.equals(sourceNode)) {
								list.add(rel);
							}
						}

					} else if (sources.length == 3) {

						
						final String relType = (String) sources[2];

						for (final AbstractRelationship rel : sourceNode.getIncomingRelationships()) {

							final NodeInterface s = rel.getSourceNode();
							final NodeInterface t = rel.getTargetNode();

							
							if (s != null && t != null
								&& rel.getRelType().name().equals(relType)
								&& s.equals(targetNode) && t.equals(sourceNode)) {
								list.add(rel);
							}
						}

					}
				}

				return list;
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_GET_INCOMING_RELATIONSHIPS_JS : ERROR_MESSAGE_GET_INCOMING_RELATIONSHIPS);
			}
		});
		functions.put("create_relationship", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasLengthAndAllElementsNotNull(sources, 3)) {

					final Object source = sources[0];
					final Object target = sources[1];
					final String relType = (String) sources[2];

					AbstractNode sourceNode = null;
					AbstractNode targetNode = null;

					if (source instanceof AbstractNode && target instanceof AbstractNode) {

						sourceNode = (AbstractNode) source;
						targetNode = (AbstractNode) target;

					} else {

						return "Error: entities are not nodes.";
					}

					final Class relClass = StructrApp.getConfiguration().getRelationClassForCombinedType(sourceNode.getType(), relType, targetNode.getType());

					if (relClass != null) {

						StructrApp.getInstance(sourceNode.getSecurityContext()).create(sourceNode, targetNode, relClass);

					} else {

						return "Error: Unknown relationship type";
					}

				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_CREATE_RELATIONSHIP_JS : ERROR_MESSAGE_CREATE_RELATIONSHIP);
			}
		});
		functions.put("grant", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 3)) {

					if (sources[0] instanceof Principal) {

						final Principal principal = (Principal) sources[0];

						if (sources[1] instanceof AbstractNode) {

							final AbstractNode node = (AbstractNode) sources[1];

							if (sources[2] instanceof String) {

								final String[] parts = ((String) sources[2]).split("[,]+");
								for (final String part : parts) {

									final String trimmedPart = part.trim();
									if (trimmedPart.length() > 0) {

										final Permission permission = Permissions.valueOf(trimmedPart);
										if (permission != null) {

											node.grant(permission, principal);

										} else {

											return "Error: unknown permission " + trimmedPart;
										}
									}
								}

								return "";

							} else {

								return "Error: third argument is not a string.";
							}

						} else {

							return "Error: second argument is not a node.";
						}

					} else {

						return "Error: first argument is not of type Principal.";
					}

				} else {

					return usage(ctx.isJavaScriptContext());
				}
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_GRANT_JS : ERROR_MESSAGE_GRANT);
			}
		});
		functions.put("revoke", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 3)) {

					if (sources[0] instanceof Principal) {

						final Principal principal = (Principal) sources[0];

						if (sources[1] instanceof AbstractNode) {

							final AbstractNode node = (AbstractNode) sources[1];

							if (sources[2] instanceof String) {

								final String[] parts = ((String) sources[2]).split("[,]+");
								for (final String part : parts) {

									final String trimmedPart = part.trim();
									if (trimmedPart.length() > 0) {

										final Permission permission = Permissions.valueOf(trimmedPart);
										if (permission != null) {

											node.revoke(permission, principal);

										} else {

											return "Error: unknown permission " + trimmedPart;
										}
									}
								}

								return "";

							} else {

								return "Error: third argument is not a string.";
							}

						} else {

							return "Error: second argument is not a node.";
						}

					} else {

						return "Error: first argument is not of type Principal.";
					}

				} else {

					return usage(ctx.isJavaScriptContext());
				}
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_REVOKE_JS : ERROR_MESSAGE_REVOKE);
			}
		});
		functions.put("unlock_readonly_properties_once", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 1)) {

					if (sources[0] instanceof AbstractNode) {

						((AbstractNode) sources[0]).unlockReadOnlyPropertiesOnce();

					} else {

						return usage(ctx.isJavaScriptContext());

					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_UNLOCK_READONLY_PROPERTIES_ONCE_JS : ERROR_MESSAGE_UNLOCK_READONLY_PROPERTIES_ONCE);
			}
		});
		functions.put("call", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 1)) {

					final String key = sources[0].toString();

					if (sources.length > 1) {

						Actions.call(key, Arrays.copyOfRange(sources, 1, sources.length));

					} else {

						Actions.call(key);
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_UNLOCK_READONLY_PROPERTIES_ONCE_JS : ERROR_MESSAGE_UNLOCK_READONLY_PROPERTIES_ONCE);
			}
		});
		functions.put("set_privileged", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				Function<Object, Object> set = functions.get("set");
				if (set != null) {

					synchronized (entity) {

						final SecurityContext previousSecurityContext = entity.getSecurityContext();
						entity.setSecurityContext(SecurityContext.getSuperUserInstance());

						try {

							set.apply(ctx, entity, sources);

						} finally {

							entity.setSecurityContext(previousSecurityContext);
						}
					}
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_SET_PRIVILEGED_JS : ERROR_MESSAGE_SET_PRIVILEGED);
			}
		});
		functions.put("cypher", new Function<Object, Object>() {

			@Override
			public Object apply(final ActionContext ctx, final GraphObject entity, final Object[] sources) throws FrameworkException {

				if (arrayHasMinLengthAndAllElementsNotNull(sources, 1)) {

					final Map<String, Object> params = new LinkedHashMap<>();
					final String query               = sources[0].toString();

					
					if (sources.length > 1 && sources[1] != null && sources[1] instanceof Map) {
						params.putAll((Map)sources[1]);
					}

					return StructrApp.getInstance(ctx.getSecurityContext()).cypher(query, params);
				}

				return "";
			}

			@Override
			public String usage(boolean inJavaScriptContext) {
				return (inJavaScriptContext ? ERROR_MESSAGE_SET_PRIVILEGED_JS : ERROR_MESSAGE_SET_PRIVILEGED);
			}
		});
	}

	
	public static boolean arrayHasMinLengthAndAllElementsNotNull(final Object[] array, final Integer minLength) {

		if (array == null) {
			return false;
		}

		for (final Object element : array) {

			if (element == null) {
				return false;
			}

		}

		return minLength != null ? array.length >= minLength : true;

	}

	
	public static boolean arrayHasLengthAndAllElementsNotNull(final Object[] array, final Integer length) {

		if (array == null) {
			return false;
		}

		for (final Object element : array) {

			if (element == null) {
				return false;
			}

		}

		return length != null ? array.length == length : true;

	}

	protected static String serialize(final Gson gson, final Map<String, Object> map) {
		return gson.toJson(map, new TypeToken<Map<String, String>>() {
		}.getType());
	}

	protected static Map<String, Object> deserialize(final Gson gson, final String source) {
		return gson.fromJson(source, new TypeToken<Map<String, Object>>() {
		}.getType());
	}

	protected static Integer parseInt(final Object source) {

		if (source instanceof Integer) {

			return ((Integer) source);
		}

		if (source instanceof Number) {

			return ((Number) source).intValue();
		}

		if (source instanceof String) {

			return Integer.parseInt((String) source);
		}

		return null;
	}

	protected static String encodeURL(final String source) {

		try {
			return URLEncoder.encode(source, "UTF-8");

		} catch (UnsupportedEncodingException ex) {

			logger.log(Level.WARNING, "Unsupported Encoding", ex);
		}

		
		return source;
	}

	protected static double getDoubleForComparison(final Object obj) {

		if (obj instanceof Number) {

			return ((Number) obj).doubleValue();

		} else {

			try {
				return Double.valueOf(obj.toString());

			} catch (Throwable t) {

				t.printStackTrace();
			}
		}

		return 0.0;
	}

	protected static Double getDoubleOrNull(final Object obj) {

		try {

			if (obj instanceof Date) {

				return (double) ((Date) obj).getTime();

			} else if (obj instanceof Number) {

				return ((Number) obj).doubleValue();

			} else {

				Date date = DatePropertyParser.parseISO8601DateString(obj.toString());

				if (date != null) {

					return (double) (date).getTime();
				}

				return Double.parseDouble(obj.toString());

			}

		} catch (Throwable t) {

			t.printStackTrace();
		}

		return null;
	}

	protected static boolean valueEquals(final Object obj1, final Object obj2) {

		if (obj1 instanceof Enum || obj2 instanceof Enum) {

			return obj1.toString().equals(obj2.toString());

		}

		return eq(obj1, obj2);
	}

	protected static String getSandboxFileName(final String source) throws IOException {

		final File sandboxFile = new File(source);
		final String fileName = sandboxFile.getName();
		final String basePath = StructrApp.getConfigurationValue(Services.BASE_PATH);

		if (!basePath.isEmpty()) {

			final String defaultExchangePath = basePath.endsWith("/") ? basePath.concat("exchange") : basePath.concat("/exchange");
			String exchangeDir = StructrApp.getConfigurationValue(Services.DATA_EXCHANGE_PATH, defaultExchangePath);

			if (!exchangeDir.endsWith("/")) {
				exchangeDir = exchangeDir.concat("/");
			}

			
			final File dir = new File(exchangeDir);
			if (!dir.exists()) {

				dir.mkdirs();
			}

			
			return exchangeDir.concat(fileName);

		} else {

			logger.log(Level.WARNING, "Unable to determine base.path from structr.conf, no data input/output possible.");
		}

		return null;
	}

	public static String cleanString(final Object input) {

		if (input == null) {

			return "";

		}

		String normalized = Normalizer.normalize(input.toString(), Normalizer.Form.NFD)
			.replaceAll("\\<", "")
			.replaceAll("\\>", "")
			.replaceAll("\\.", "")
			.replaceAll("\\'", "-")
			.replaceAll("\\?", "")
			.replaceAll("\\(", "")
			.replaceAll("\\)", "")
			.replaceAll("\\{", "")
			.replaceAll("\\}", "")
			.replaceAll("\\[", "")
			.replaceAll("\\]", "")
			.replaceAll("\\+", "-")
			.replaceAll("/", "-")
			.replaceAll("", "-")
			.replaceAll("\\\\", "-")
			.replaceAll("\\|", "-")
			.replaceAll("'", "-")
			.replaceAll("!", "")
			.replaceAll(",", "")
			.replaceAll("-", " ")
			.replaceAll("_", " ")
			.replaceAll("`", "-");

		String result = normalized.replaceAll("-", " ");
		result = StringUtils.normalizeSpace(result.toLowerCase());
		result = result.replaceAll("[^\\p{ASCII}]", "").replaceAll("\\p{P}", "-").replaceAll("\\-(\\s+\\-)+", "-");
		result = result.replaceAll(" ", "-");

		return result;

	}

	public static void recursivelyConvertMapToGraphObjectMap(final GraphObjectMap destination, final Map<String, Object> source, final int depth) {

		if (depth > 20) {
			return;
		}

		for (final Map.Entry<String, Object> entry : source.entrySet()) {

			final String key = entry.getKey();
			final Object value = entry.getValue();

			if (value instanceof Map) {

				final Map<String, Object> map = (Map<String, Object>) value;
				final GraphObjectMap obj = new GraphObjectMap();

				destination.put(new StringProperty(key), obj);

				recursivelyConvertMapToGraphObjectMap(obj, map, depth + 1);

			} else if (value instanceof Collection) {

				final List list = new LinkedList();
				final Collection collection = (Collection) value;

				for (final Object obj : collection) {

					if (obj instanceof Map) {

						final GraphObjectMap container = new GraphObjectMap();
						list.add(container);

						recursivelyConvertMapToGraphObjectMap(container, (Map<String, Object>) obj, depth + 1);

					} else {

						list.add(obj);
					}
				}

				destination.put(new StringProperty(key), list);

			} else {

				destination.put(new StringProperty(key), value);
			}
		}
	}

	public static Object numberOrString(final String value) {

		if (value != null) {

			if ("true".equals(value.toLowerCase())) {
				return true;
			}

			if ("false".equals(value.toLowerCase())) {
				return false;
			}

			if (NumberUtils.isNumber(value)) {
				return NumberUtils.createNumber(value);
			}
		}

		return value;
	}

	private static int compareBooleanBoolean(final Object o1, final Object o2) {

		final Boolean value1 = (Boolean) o1;
		final Boolean value2 = (Boolean) o2;

		return value1.compareTo(value2);
	}

	private static int compareNumberNumber(final Object o1, final Object o2) {

		final Double value1 = getDoubleForComparison(o1);
		final Double value2 = getDoubleForComparison(o2);

		return value1.compareTo(value2);
	}

	private static int compareStringString(final Object o1, final Object o2) {

		final String value1 = (String) o1;
		final String value2 = (String) o2;

		return value1.compareTo(value2);
	}

	private static int compareDateDate(final Object o1, final Object o2) {

		final Date value1 = (Date) o1;
		final Date value2 = (Date) o2;

		return value1.compareTo(value2);
	}

	private static int compareDateString(final Object o1, final Object o2) {

		final String value1 = DatePropertyParser.format((Date) o1, DateProperty.DEFAULT_FORMAT);
		final String value2 = (String) o2;

		return value1.compareTo(value2);
	}

	private static int compareStringDate(final Object o1, final Object o2) {

		final String value1 = (String) o1;
		final String value2 = DatePropertyParser.format((Date) o2, DateProperty.DEFAULT_FORMAT);

		return value1.compareTo(value2);
	}

	private static int compareBooleanString(final Object o1, final Object o2) {

		return -1;
	}

	private static int compareStringBoolean(final Object o1, final Object o2) {

		return -1;
	}

	private static int compareNumberString(final Object o1, final Object o2) {

		final Double value1 = getDoubleForComparison(o1);
		final Double value2 = Double.parseDouble((String) o2);

		return (value1.compareTo(value2) == 0 ? -1 : value1.compareTo(value2));
	}

	private static int compareStringNumber(final Object o1, final Object o2) {

		final Double value1 = Double.parseDouble((String) o1);
		final Double value2 = getDoubleForComparison(o2);

		return (value1.compareTo(value2) == 0 ? -1 : value1.compareTo(value2));
	}

	private static boolean gt(final Object o1, final Object o2) {

		if (o1 instanceof Number && o2 instanceof Number) {

			return compareNumberNumber(o1, o2) > 0;

		} else if (o1 instanceof String && o2 instanceof String) {

			return compareStringString(o1, o2) > 0;

		} else if (o1 instanceof Date && o2 instanceof Date) {

			return compareDateDate(o1, o2) > 0;

		} else if (o1 instanceof Date && o2 instanceof String) {

			return compareDateString(o1, o2) > 0;

		} else if (o1 instanceof String && o2 instanceof Date) {

			return compareStringDate(o1, o2) > 0;

		} else if (o1 instanceof Boolean && o2 instanceof String) {

			return compareBooleanString(o1, o2) > 0;

		} else if (o1 instanceof String && o2 instanceof Boolean) {

			return compareStringBoolean(o1, o2) > 0;

		} else if (o1 instanceof Number && o2 instanceof String) {

			return compareNumberString(o1, o2) > 0;

		} else if (o1 instanceof String && o2 instanceof Number) {

			return compareStringNumber(o1, o2) > 0;

		} else {

			return compareStringString(o1.toString(), o2.toString()) > 0;

		}
	}

	private static boolean lt(final Object o1, final Object o2) {

		if (o1 instanceof Number && o2 instanceof Number) {

			return compareNumberNumber(o1, o2) < 0;

		} else if (o1 instanceof String && o2 instanceof String) {

			return compareStringString(o1, o2) < 0;

		} else if (o1 instanceof Date && o2 instanceof Date) {

			return compareDateDate(o1, o2) < 0;

		} else if (o1 instanceof Date && o2 instanceof String) {

			return compareDateString(o1, o2) < 0;

		} else if (o1 instanceof String && o2 instanceof Date) {

			return compareStringDate(o1, o2) < 0;

		} else if (o1 instanceof Boolean && o2 instanceof String) {

			return compareBooleanString(o1, o2) < 0;

		} else if (o1 instanceof String && o2 instanceof Boolean) {

			return compareStringBoolean(o1, o2) < 0;

		} else if (o1 instanceof Number && o2 instanceof String) {

			return compareNumberString(o1, o2) < 0;

		} else if (o1 instanceof String && o2 instanceof Number) {

			return compareStringNumber(o1, o2) < 0;

		} else {

			return compareStringString(o1.toString(), o2.toString()) < 0;

		}
	}

	private static boolean eq(final Object o1, final Object o2) {

		if (o1 instanceof Number && o2 instanceof Number) {

			return compareNumberNumber(o1, o2) == 0;

		} else if (o1 instanceof String && o2 instanceof String) {

			return compareStringString(o1, o2) == 0;

		} else if (o1 instanceof Date && o2 instanceof Date) {

			return compareDateDate(o1, o2) == 0;

		} else if (o1 instanceof Date && o2 instanceof String) {

			return compareDateString(o1, o2) == 0;

		} else if (o1 instanceof String && o2 instanceof Date) {

			return compareStringDate(o1, o2) == 0;

		} else if (o1 instanceof Boolean && o2 instanceof String) {

			return compareBooleanString(o1, o2) == 0;

		} else if (o1 instanceof String && o2 instanceof Boolean) {

			return compareStringBoolean(o1, o2) == 0;

		} else if (o1 instanceof Number && o2 instanceof String) {

			return compareNumberString(o1, o2) == 0;

		} else if (o1 instanceof String && o2 instanceof Number) {

			return compareStringNumber(o1, o2) == 0;

		} else {

			return compareStringString(o1.toString(), o2.toString()) == 0;

		}
	}

	private static boolean gte(final Object o1, final Object o2) {
		return eq(o1, o2) || gt(o1, o2);
	}

	private static boolean lte(final Object o1, final Object o2) {
		return eq(o1, o2) || lt(o1, o2);
	}

}

<code block>



package org.structr.schema;

import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.structr.common.StructrConf;
import org.structr.common.error.ErrorBuffer;
import org.structr.common.error.FrameworkException;
import org.structr.core.Command;
import org.structr.core.Service;
import org.structr.core.app.App;
import org.structr.core.app.StructrApp;
import org.structr.core.entity.SchemaNode;
import org.structr.core.entity.SchemaRelationshipNode;
import org.structr.core.graph.Tx;
import org.structr.core.graph.search.SearchCommand;
import org.structr.schema.compiler.NodeExtender;


public class SchemaService implements Service {

	private static final Logger logger                            = Logger.getLogger(SchemaService.class.getName());
	private static final AtomicBoolean compiling                  = new AtomicBoolean(false);
	private static final Map<String, String> builtinTypeMap       = new LinkedHashMap<>();

	@Override
	public void injectArguments(final Command command) {
	}

	@Override
	public void initialize(final StructrConf config) {
		reloadSchema(new ErrorBuffer());
	}

	public static void registerBuiltinTypeOverride(final String type, final String fqcn) {
		builtinTypeMap.put(type, fqcn);
	}

	public static boolean reloadSchema(final ErrorBuffer errorBuffer) {

		final ConfigurationProvider config = StructrApp.getConfiguration();
		boolean success = true;

		
		if (compiling.compareAndSet(false, true)) {

			try {

				final Set<String> dynamicViews  = new LinkedHashSet<>();
				final NodeExtender nodeExtender = new NodeExtender();

				try (final Tx tx = StructrApp.getInstance().tx()) {

					SchemaService.ensureBuiltinTypesExist();

					
					final List<SchemaNode> schemaNodes = StructrApp.getInstance().nodeQuery(SchemaNode.class).getAsList();
					for (final SchemaNode schemaNode : schemaNodes) {

						nodeExtender.addClass(schemaNode.getClassName(), schemaNode.getSource(errorBuffer));

						final String auxSource = schemaNode.getAuxiliarySource();
						if (auxSource != null) {

							nodeExtender.addClass("_" + schemaNode.getClassName() + "Helper", auxSource);
						}

						dynamicViews.addAll(schemaNode.getViews());
					}

					
					for (final SchemaRelationshipNode schemaRelationship : StructrApp.getInstance().nodeQuery(SchemaRelationshipNode.class).getAsList()) {

						nodeExtender.addClass(schemaRelationship.getClassName(), schemaRelationship.getSource(errorBuffer));

						final String auxSource = schemaRelationship.getAuxiliarySource();
						if (auxSource != null) {

							nodeExtender.addClass("_" + schemaRelationship.getClassName() + "Helper", auxSource);
						}

						dynamicViews.addAll(schemaRelationship.getViews());
					}

					
					synchronized (SchemaService.class) {

						
						Map<String, Class> newTypes = nodeExtender.compile(errorBuffer);

						for (final Class newType : newTypes.values()) {

							
							config.registerEntityType(newType);

							
							
							try { newType.newInstance(); } catch (Throwable t) {}
						}
					}

					
					for (final SchemaNode schemaNode : StructrApp.getInstance().nodeQuery(SchemaNode.class).getAsList()) {
						schemaNode.createBuiltInSchemaEntities(errorBuffer);
					}

					
					SearchCommand.clearInheritanceMap();

					success = !errorBuffer.hasError();

					
					if (success) {

						config.registerDynamicViews(dynamicViews);
						tx.success();
					}

				} catch (Throwable t) {

					logger.log(Level.SEVERE, "Unable to compile dynamic schema.", t);
					t.printStackTrace();

					success = false;
				}

				calculateHierarchy();

			} finally {

				
				compiling.set(false);

			}
		}

		return success;
	}

	@Override
	public void initialized() {
	}

	@Override
	public void shutdown() {
	}

	@Override
	public String getName() {
		return SchemaService.class.getName();
	}

	@Override
	public boolean isRunning() {
		return true;
	}

	public static void ensureBuiltinTypesExist() throws FrameworkException {

		final App app = StructrApp.getInstance();

		for (final Entry<String, String> entry : builtinTypeMap.entrySet()) {

			final String type = entry.getKey();
			final String fqcn = entry.getValue();

			SchemaNode schemaNode = app.nodeQuery(SchemaNode.class).andName(type).getFirst();
			if (schemaNode == null) {

				schemaNode = app.create(SchemaNode.class, type);
			}

			schemaNode.setProperty(SchemaNode.extendsClass, fqcn);
			schemaNode.unlockReadOnlyPropertiesOnce();
			schemaNode.setProperty(SchemaNode.isBuiltinType, true);
		}
	}

	@Override
	public boolean isVital() {
		return true;
	}

	
	private static void calculateHierarchy() {

		try (final Tx tx = StructrApp.getInstance().tx()) {

			final List<SchemaNode> schemaNodes  = StructrApp.getInstance().nodeQuery(SchemaNode.class).getAsList();
			final Set<String> alreadyCalculated = new HashSet<>();
			final Map<String, SchemaNode> map   = new LinkedHashMap<>();

			
			for (final SchemaNode schemaNode : schemaNodes) {
				map.put(schemaNode.getName(), schemaNode);
			}

			
			for (final SchemaNode schemaNode : schemaNodes) {

				final int relCount = schemaNode.getProperty(SchemaNode.relatedFrom).size() + schemaNode.getProperty(SchemaNode.relatedTo).size();
				final int level    = recursiveGetHierarchyLevel(map, alreadyCalculated, schemaNode);

				schemaNode.setProperty(SchemaNode.hierarchyLevel, level);
				schemaNode.setProperty(SchemaNode.relCount, relCount);
			}

			tx.success();

		} catch (FrameworkException fex) {
			fex.printStackTrace();
		}
	}

	private static int recursiveGetHierarchyLevel(final Map<String, SchemaNode> map, final Set<String> alreadyCalculated, final SchemaNode schemaNode) {

		String superclass = schemaNode.getProperty(SchemaNode.extendsClass);
		if (superclass == null) {

			return 0;

		} else if (superclass.startsWith("org.structr.dynamic.")) {

			
			superclass = superclass.substring(superclass.lastIndexOf(".") + 1);

			
			final SchemaNode superSchemaNode = map.get(superclass);
			if (superSchemaNode != null) {

				return recursiveGetHierarchyLevel(map, alreadyCalculated, superSchemaNode) + 1;
			}
		}

		return 0;
	}
}
