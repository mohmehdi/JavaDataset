
package org.springframework.security.messaging.access.expression;

import org.springframework.expression.Expression;
import org.springframework.security.access.ConfigAttribute;
import org.springframework.security.messaging.access.intercept.DefaultMessageSecurityMetadataSource;
import org.springframework.security.messaging.access.intercept.MessageSecurityMetadataSource;
import org.springframework.security.messaging.util.matcher.MessageMatcher;

import java.util.Arrays;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.Map;


public final class ExpressionBasedMessageSecurityMetadataSourceFactory {


	public static MessageSecurityMetadataSource createExpressionMessageMetadataSource(
			LinkedHashMap<MessageMatcher<?>, String> matcherToExpression) {
		DefaultMessageSecurityExpressionHandler<Object> handler = new DefaultMessageSecurityExpressionHandler<Object>();

		LinkedHashMap<MessageMatcher<?>, Collection<ConfigAttribute>> matcherToAttrs = new LinkedHashMap<MessageMatcher<?>, Collection<ConfigAttribute>>();

		for (Map.Entry<MessageMatcher<?>, String> entry : matcherToExpression.entrySet()) {
			MessageMatcher<?> matcher = entry.getKey();
			String rawExpression = entry.getValue();
			Expression expression = handler.getExpressionParser().parseExpression(
					rawExpression);
			ConfigAttribute attribute = new MessageExpressionConfigAttribute(expression);
			matcherToAttrs.put(matcher, Arrays.asList(attribute));
		}
		return new DefaultMessageSecurityMetadataSource(matcherToAttrs);
	}

	private ExpressionBasedMessageSecurityMetadataSourceFactory() {
	}
}
<code block>

package org.springframework.security.messaging.access.expression;

import org.springframework.messaging.Message;
import org.springframework.security.access.expression.SecurityExpressionRoot;
import org.springframework.security.core.Authentication;


public final class MessageSecurityExpressionRoot extends SecurityExpressionRoot {

	public final Message<?> message;

	public MessageSecurityExpressionRoot(Authentication authentication, Message<?> message) {
		super(authentication);
		this.message = message;
	}
}

<code block>

package org.springframework.security.config.annotation.web.messaging;

import org.springframework.messaging.Message;
import org.springframework.messaging.simp.SimpMessageType;
import org.springframework.security.config.annotation.web.configurers.RememberMeConfigurer;
import org.springframework.security.messaging.access.expression.ExpressionBasedMessageSecurityMetadataSourceFactory;
import org.springframework.security.messaging.access.intercept.MessageSecurityMetadataSource;
import org.springframework.security.messaging.util.matcher.MessageMatcher;
import org.springframework.security.messaging.util.matcher.SimpDestinationMessageMatcher;
import org.springframework.security.messaging.util.matcher.SimpMessageTypeMatcher;
import org.springframework.util.AntPathMatcher;
import org.springframework.util.Assert;
import org.springframework.util.PathMatcher;
import org.springframework.util.StringUtils;

import java.util.*;


public class MessageSecurityMetadataSourceRegistry {
	private static final String permitAll = "permitAll";
	private static final String denyAll = "denyAll";
	private static final String anonymous = "anonymous";
	private static final String authenticated = "authenticated";
	private static final String fullyAuthenticated = "fullyAuthenticated";
	private static final String rememberMe = "rememberMe";

	private final LinkedHashMap<MatcherBuilder, String> matcherToExpression = new LinkedHashMap<MatcherBuilder, String>();

	private DelegatingPathMatcher pathMatcher = new DelegatingPathMatcher();

	private boolean defaultPathMatcher = true;


	public Constraint anyMessage() {
		return matchers(MessageMatcher.ANY_MESSAGE);
	}


	public Constraint nullDestMatcher() {
		return matchers(SimpDestinationMessageMatcher.NULL_DESTINATION_MATCHER);
	}


	public Constraint simpTypeMatchers(SimpMessageType... typesToMatch) {
		MessageMatcher<?>[] typeMatchers = new MessageMatcher<?>[typesToMatch.length];
		for (int i = 0; i < typesToMatch.length; i++) {
			SimpMessageType typeToMatch = typesToMatch[i];
			typeMatchers[i] = new SimpMessageTypeMatcher(typeToMatch);
		}
		return matchers(typeMatchers);
	}


	public Constraint simpDestMatchers(String... patterns) {
		return simpDestMatchers(null, patterns);
	}


	public Constraint simpMessageDestMatchers(String... patterns) {
		return simpDestMatchers(SimpMessageType.MESSAGE, patterns);
	}


	public Constraint simpSubscribeDestMatchers(String... patterns) {
		return simpDestMatchers(SimpMessageType.SUBSCRIBE, patterns);
	}


	private Constraint simpDestMatchers(SimpMessageType type, String... patterns) {
		List<MatcherBuilder> matchers = new ArrayList<MatcherBuilder>(patterns.length);
		for (String pattern : patterns) {
			matchers.add(new PathMatcherMessageMatcherBuilder(pattern, type));
		}
		return new Constraint(matchers);
	}


	public MessageSecurityMetadataSourceRegistry simpDestPathMatcher(
			PathMatcher pathMatcher) {
		Assert.notNull(pathMatcher, "pathMatcher cannot be null");
		this.pathMatcher.setPathMatcher(pathMatcher);
		this.defaultPathMatcher = false;
		return this;
	}


	protected boolean isSimpDestPathMatcherConfigured() {
		return !this.defaultPathMatcher;
	}


	public Constraint matchers(MessageMatcher<?>... matchers) {
		List<MatcherBuilder> builders = new ArrayList<MatcherBuilder>(matchers.length);
		for (MessageMatcher<?> matcher : matchers) {
			builders.add(new PreBuiltMatcherBuilder(matcher));
		}
		return new Constraint(builders);
	}


	protected MessageSecurityMetadataSource createMetadataSource() {
		LinkedHashMap<MessageMatcher<?>, String> matcherToExpression = new LinkedHashMap<MessageMatcher<?>, String>();
		for (Map.Entry<MatcherBuilder, String> entry : this.matcherToExpression
				.entrySet()) {
			matcherToExpression.put(entry.getKey().build(), entry.getValue());
		}
		return ExpressionBasedMessageSecurityMetadataSourceFactory
				.createExpressionMessageMetadataSource(matcherToExpression);
	}


	protected boolean containsMapping() {
		return !this.matcherToExpression.isEmpty();
	}


	public class Constraint {
		private final List<? extends MatcherBuilder> messageMatchers;


		private Constraint(List<? extends MatcherBuilder> messageMatchers) {
			Assert.notEmpty(messageMatchers, "messageMatchers cannot be null or empty");
			this.messageMatchers = messageMatchers;
		}


		public MessageSecurityMetadataSourceRegistry hasRole(String role) {
			return access(MessageSecurityMetadataSourceRegistry.hasRole(role));
		}


		public MessageSecurityMetadataSourceRegistry hasAnyRole(String... roles) {
			return access(MessageSecurityMetadataSourceRegistry.hasAnyRole(roles));
		}


		public MessageSecurityMetadataSourceRegistry hasAuthority(String authority) {
			return access(MessageSecurityMetadataSourceRegistry.hasAuthority(authority));
		}


		public MessageSecurityMetadataSourceRegistry hasAnyAuthority(
				String... authorities) {
			return access(MessageSecurityMetadataSourceRegistry
					.hasAnyAuthority(authorities));
		}


		public MessageSecurityMetadataSourceRegistry permitAll() {
			return access(permitAll);
		}


		public MessageSecurityMetadataSourceRegistry anonymous() {
			return access(anonymous);
		}


		public MessageSecurityMetadataSourceRegistry rememberMe() {
			return access(rememberMe);
		}


		public MessageSecurityMetadataSourceRegistry denyAll() {
			return access(denyAll);
		}


		public MessageSecurityMetadataSourceRegistry authenticated() {
			return access(authenticated);
		}


		public MessageSecurityMetadataSourceRegistry fullyAuthenticated() {
			return access(fullyAuthenticated);
		}


		public MessageSecurityMetadataSourceRegistry access(String attribute) {
			for (MatcherBuilder messageMatcher : messageMatchers) {
				matcherToExpression.put(messageMatcher, attribute);
			}
			return MessageSecurityMetadataSourceRegistry.this;
		}
	}

	private static String hasAnyRole(String... authorities) {
		String anyAuthorities = StringUtils.arrayToDelimitedString(authorities,
				"','ROLE_");
		return "hasAnyRole('ROLE_" + anyAuthorities + "')";
	}

	private static String hasRole(String role) {
		Assert.notNull(role, "role cannot be null");
		if (role.startsWith("ROLE_")) {
			throw new IllegalArgumentException(
					"role should not start with 'ROLE_' since it is automatically inserted. Got '"
							+ role + "'");
		}
		return "hasRole('ROLE_" + role + "')";
	}

	private static String hasAuthority(String authority) {
		return "hasAuthority('" + authority + "')";
	}

	private static String hasAnyAuthority(String... authorities) {
		String anyAuthorities = StringUtils.arrayToDelimitedString(authorities, "','");
		return "hasAnyAuthority('" + anyAuthorities + "')";
	}

	private static class PreBuiltMatcherBuilder implements MatcherBuilder {
		private MessageMatcher<?> matcher;

		private PreBuiltMatcherBuilder(MessageMatcher<?> matcher) {
			this.matcher = matcher;
		}

		public MessageMatcher<?> build() {
			return matcher;
		}
	}

	private class PathMatcherMessageMatcherBuilder implements MatcherBuilder {
		private final String pattern;
		private final SimpMessageType type;

		private PathMatcherMessageMatcherBuilder(String pattern, SimpMessageType type) {
			this.pattern = pattern;
			this.type = type;
		}

		public MessageMatcher<?> build() {
			if (type == null) {
				return new SimpDestinationMessageMatcher(pattern, pathMatcher);
			}
			else if (SimpMessageType.MESSAGE == type) {
				return SimpDestinationMessageMatcher.createMessageMatcher(pattern,
						pathMatcher);
			}
			else if (SimpMessageType.SUBSCRIBE == type) {
				return SimpDestinationMessageMatcher.createSubscribeMatcher(pattern,
						pathMatcher);
			}
			throw new IllegalStateException(type
					+ " is not supported since it does not have a destination");
		}
	}

	private interface MatcherBuilder {
		MessageMatcher<?> build();
	}


	static class DelegatingPathMatcher implements PathMatcher {

		private PathMatcher delegate = new AntPathMatcher();

		public boolean isPattern(String path) {
			return delegate.isPattern(path);
		}

		public boolean match(String pattern, String path) {
			return delegate.match(pattern, path);
		}

		public boolean matchStart(String pattern, String path) {
			return delegate.matchStart(pattern, path);
		}

		public String extractPathWithinPattern(String pattern, String path) {
			return delegate.extractPathWithinPattern(pattern, path);
		}

		public Map<String, String> extractUriTemplateVariables(String pattern, String path) {
			return delegate.extractUriTemplateVariables(pattern, path);
		}

		public Comparator<String> getPatternComparator(String path) {
			return delegate.getPatternComparator(path);
		}

		public String combine(String pattern1, String pattern2) {
			return delegate.combine(pattern1, pattern2);
		}

		void setPathMatcher(PathMatcher pathMatcher) {
			this.delegate = pathMatcher;
		}
	}
}

<code block>

package org.springframework.security.config.annotation.web.socket;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import org.springframework.beans.factory.NoSuchBeanDefinitionException;
import org.springframework.beans.factory.SmartInitializingSingleton;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.messaging.handler.invocation.HandlerMethodArgumentResolver;
import org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler;
import org.springframework.messaging.simp.config.ChannelRegistration;
import org.springframework.security.access.AccessDecisionVoter;
import org.springframework.security.access.vote.AffirmativeBased;
import org.springframework.security.config.annotation.web.messaging.MessageSecurityMetadataSourceRegistry;
import org.springframework.security.messaging.access.expression.MessageExpressionVoter;
import org.springframework.security.messaging.access.intercept.ChannelSecurityInterceptor;
import org.springframework.security.messaging.access.intercept.MessageSecurityMetadataSource;
import org.springframework.security.messaging.context.AuthenticationPrincipalArgumentResolver;
import org.springframework.security.messaging.context.SecurityContextChannelInterceptor;
import org.springframework.security.messaging.web.csrf.CsrfChannelInterceptor;
import org.springframework.security.messaging.web.socket.server.CsrfTokenHandshakeInterceptor;
import org.springframework.util.AntPathMatcher;
import org.springframework.util.PathMatcher;
import org.springframework.web.servlet.handler.SimpleUrlHandlerMapping;
import org.springframework.web.socket.config.annotation.AbstractWebSocketMessageBrokerConfigurer;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
import org.springframework.web.socket.server.HandshakeInterceptor;
import org.springframework.web.socket.server.support.WebSocketHttpRequestHandler;
import org.springframework.web.socket.sockjs.SockJsService;
import org.springframework.web.socket.sockjs.support.SockJsHttpRequestHandler;
import org.springframework.web.socket.sockjs.transport.TransportHandlingSockJsService;


@Order(Ordered.HIGHEST_PRECEDENCE + 100)
public abstract class AbstractSecurityWebSocketMessageBrokerConfigurer extends
		AbstractWebSocketMessageBrokerConfigurer implements SmartInitializingSingleton {
	private final WebSocketMessageSecurityMetadataSourceRegistry inboundRegistry = new WebSocketMessageSecurityMetadataSourceRegistry();

	private ApplicationContext context;

	public void registerStompEndpoints(StompEndpointRegistry registry) {
	}

	@Override
	public void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {
		argumentResolvers.add(new AuthenticationPrincipalArgumentResolver());
	}

	@Override
	public final void configureClientInboundChannel(ChannelRegistration registration) {
		ChannelSecurityInterceptor inboundChannelSecurity = inboundChannelSecurity();
		registration.setInterceptors(securityContextChannelInterceptor());
		if (!sameOriginDisabled()) {
			registration.setInterceptors(csrfChannelInterceptor());
		}
		if (inboundRegistry.containsMapping()) {
			registration.setInterceptors(inboundChannelSecurity);
		}
		customizeClientInboundChannel(registration);
	}

	private PathMatcher getDefaultPathMatcher() {
		try {
			return context.getBean(SimpAnnotationMethodMessageHandler.class).getPathMatcher();
		} catch(NoSuchBeanDefinitionException e) {
			return new AntPathMatcher();
		}
	}


	protected boolean sameOriginDisabled() {
		return false;
	}


	protected void customizeClientInboundChannel(ChannelRegistration registration) {
	}

	@Bean
	public CsrfChannelInterceptor csrfChannelInterceptor() {
		return new CsrfChannelInterceptor();
	}

	@Bean
	public ChannelSecurityInterceptor inboundChannelSecurity() {
		ChannelSecurityInterceptor channelSecurityInterceptor = new ChannelSecurityInterceptor(
				inboundMessageSecurityMetadataSource());
		List<AccessDecisionVoter<? extends Object>> voters = new ArrayList<AccessDecisionVoter<? extends Object>>();
		voters.add(new MessageExpressionVoter<Object>());
		AffirmativeBased manager = new AffirmativeBased(voters);
		channelSecurityInterceptor.setAccessDecisionManager(manager);
		return channelSecurityInterceptor;
	}

	@Bean
	public SecurityContextChannelInterceptor securityContextChannelInterceptor() {
		return new SecurityContextChannelInterceptor();
	}

	@Bean
	public MessageSecurityMetadataSource inboundMessageSecurityMetadataSource() {
		configureInbound(inboundRegistry);
		return inboundRegistry.createMetadataSource();
	}


	protected void configureInbound(MessageSecurityMetadataSourceRegistry messages) {
	}

	private static class WebSocketMessageSecurityMetadataSourceRegistry extends
			MessageSecurityMetadataSourceRegistry {
		@Override
		public MessageSecurityMetadataSource createMetadataSource() {
			return super.createMetadataSource();
		}

		@Override
		protected boolean containsMapping() {
			return super.containsMapping();
		}

		@Override
		protected boolean isSimpDestPathMatcherConfigured() {
			return super.isSimpDestPathMatcherConfigured();
		}
	}

	@Autowired
	public void setApplicationContext(ApplicationContext context) {
		this.context = context;
	}

	public void afterSingletonsInstantiated() {
		if (sameOriginDisabled()) {
			return;
		}

		String beanName = "stompWebSocketHandlerMapping";
		SimpleUrlHandlerMapping mapping = context.getBean(beanName,
				SimpleUrlHandlerMapping.class);
		Map<String, Object> mappings = mapping.getHandlerMap();
		for (Object object : mappings.values()) {
			if (object instanceof SockJsHttpRequestHandler) {
				SockJsHttpRequestHandler sockjsHandler = (SockJsHttpRequestHandler) object;
				SockJsService sockJsService = sockjsHandler.getSockJsService();
				if (!(sockJsService instanceof TransportHandlingSockJsService)) {
					throw new IllegalStateException(
							"sockJsService must be instance of TransportHandlingSockJsService got "
									+ sockJsService);
				}

				TransportHandlingSockJsService transportHandlingSockJsService = (TransportHandlingSockJsService) sockJsService;
				List<HandshakeInterceptor> handshakeInterceptors = transportHandlingSockJsService
						.getHandshakeInterceptors();
				List<HandshakeInterceptor> interceptorsToSet = new ArrayList<HandshakeInterceptor>(
						handshakeInterceptors.size() + 1);
				interceptorsToSet.add(new CsrfTokenHandshakeInterceptor());
				interceptorsToSet.addAll(handshakeInterceptors);

				transportHandlingSockJsService
						.setHandshakeInterceptors(interceptorsToSet);
			}
			else if (object instanceof WebSocketHttpRequestHandler) {
				WebSocketHttpRequestHandler handler = (WebSocketHttpRequestHandler) object;
				List<HandshakeInterceptor> handshakeInterceptors = handler
						.getHandshakeInterceptors();
				List<HandshakeInterceptor> interceptorsToSet = new ArrayList<HandshakeInterceptor>(
						handshakeInterceptors.size() + 1);
				interceptorsToSet.add(new CsrfTokenHandshakeInterceptor());
				interceptorsToSet.addAll(handshakeInterceptors);

				handler.setHandshakeInterceptors(interceptorsToSet);
			}
			else {
				throw new IllegalStateException(
						"Bean "
								+ beanName
								+ " is expected to contain mappings to either a SockJsHttpRequestHandler or a WebSocketHttpRequestHandler but got "
								+ object);
			}
		}

		if (inboundRegistry.containsMapping() && !inboundRegistry.isSimpDestPathMatcherConfigured()) {
			PathMatcher pathMatcher = getDefaultPathMatcher();
			inboundRegistry.simpDestPathMatcher(pathMatcher);
		}
	}
}
<code block>

package org.springframework.security.config.websocket;

import java.util.Comparator;
import java.util.List;
import java.util.Map;

import org.springframework.beans.BeansException;
import org.springframework.beans.PropertyValue;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.config.BeanReference;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
import org.springframework.beans.factory.config.RuntimeBeanReference;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.support.BeanDefinitionRegistry;
import org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor;
import org.springframework.beans.factory.support.ManagedList;
import org.springframework.beans.factory.support.ManagedMap;
import org.springframework.beans.factory.support.RootBeanDefinition;
import org.springframework.beans.factory.xml.BeanDefinitionParser;
import org.springframework.beans.factory.xml.ParserContext;
import org.springframework.beans.factory.xml.XmlReaderContext;
import org.springframework.messaging.simp.SimpMessageType;
import org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler;
import org.springframework.security.access.vote.ConsensusBased;
import org.springframework.security.config.Elements;
import org.springframework.security.messaging.access.expression.ExpressionBasedMessageSecurityMetadataSourceFactory;
import org.springframework.security.messaging.access.expression.MessageExpressionVoter;
import org.springframework.security.messaging.access.intercept.ChannelSecurityInterceptor;
import org.springframework.security.messaging.context.AuthenticationPrincipalArgumentResolver;
import org.springframework.security.messaging.context.SecurityContextChannelInterceptor;
import org.springframework.security.messaging.util.matcher.SimpDestinationMessageMatcher;
import org.springframework.security.messaging.util.matcher.SimpMessageTypeMatcher;
import org.springframework.security.messaging.web.csrf.CsrfChannelInterceptor;
import org.springframework.security.messaging.web.socket.server.CsrfTokenHandshakeInterceptor;
import org.springframework.util.AntPathMatcher;
import org.springframework.util.PathMatcher;
import org.springframework.util.StringUtils;
import org.springframework.util.xml.DomUtils;
import org.w3c.dom.Element;


public final class WebSocketMessageBrokerSecurityBeanDefinitionParser implements
		BeanDefinitionParser {
	private static final String ID_ATTR = "id";

	private static final String DISABLED_ATTR = "same-origin-disabled";

	private static final String PATTERN_ATTR = "pattern";

	private static final String ACCESS_ATTR = "access";

	private static final String TYPE_ATTR = "type";

	private static final String PATH_MATCHER_BEAN_NAME = "springSecurityMessagePathMatcher";


	public BeanDefinition parse(Element element, ParserContext parserContext) {
		BeanDefinitionRegistry registry = parserContext.getRegistry();
		XmlReaderContext context = parserContext.getReaderContext();

		ManagedMap<BeanDefinition, String> matcherToExpression = new ManagedMap<BeanDefinition, String>();

		String id = element.getAttribute(ID_ATTR);
		boolean sameOriginDisabled = Boolean.parseBoolean(element
				.getAttribute(DISABLED_ATTR));

		List<Element> interceptMessages = DomUtils.getChildElementsByTagName(element,
				Elements.INTERCEPT_MESSAGE);
		for (Element interceptMessage : interceptMessages) {
			String matcherPattern = interceptMessage.getAttribute(PATTERN_ATTR);
			String accessExpression = interceptMessage.getAttribute(ACCESS_ATTR);
			String messageType = interceptMessage.getAttribute(TYPE_ATTR);

			BeanDefinition matcher = createMatcher(matcherPattern, messageType,
					parserContext, interceptMessage);
			matcherToExpression.put(matcher, accessExpression);
		}

		BeanDefinitionBuilder mds = BeanDefinitionBuilder
				.rootBeanDefinition(ExpressionBasedMessageSecurityMetadataSourceFactory.class);
		mds.setFactoryMethod("createExpressionMessageMetadataSource");
		mds.addConstructorArgValue(matcherToExpression);

		String mdsId = context.registerWithGeneratedName(mds.getBeanDefinition());

		ManagedList<BeanDefinition> voters = new ManagedList<BeanDefinition>();
		voters.add(new RootBeanDefinition(MessageExpressionVoter.class));
		BeanDefinitionBuilder adm = BeanDefinitionBuilder
				.rootBeanDefinition(ConsensusBased.class);
		adm.addConstructorArgValue(voters);

		BeanDefinitionBuilder inboundChannelSecurityInterceptor = BeanDefinitionBuilder
				.rootBeanDefinition(ChannelSecurityInterceptor.class);
		inboundChannelSecurityInterceptor.addConstructorArgValue(registry
				.getBeanDefinition(mdsId));
		inboundChannelSecurityInterceptor.addPropertyValue("accessDecisionManager",
				adm.getBeanDefinition());
		String inSecurityInterceptorName = context
				.registerWithGeneratedName(inboundChannelSecurityInterceptor
						.getBeanDefinition());

		if (StringUtils.hasText(id)) {
			registry.registerAlias(inSecurityInterceptorName, id);

			if(!registry.containsBeanDefinition(PATH_MATCHER_BEAN_NAME)) {
				registry.registerBeanDefinition(PATH_MATCHER_BEAN_NAME, new RootBeanDefinition(AntPathMatcher.class));
			}
		}
		else {
			BeanDefinitionBuilder mspp = BeanDefinitionBuilder
					.rootBeanDefinition(MessageSecurityPostProcessor.class);
			mspp.addConstructorArgValue(inSecurityInterceptorName);
			mspp.addConstructorArgValue(sameOriginDisabled);
			context.registerWithGeneratedName(mspp.getBeanDefinition());
		}

		return null;
	}

	private BeanDefinition createMatcher(String matcherPattern, String messageType,
			ParserContext parserContext, Element interceptMessage) {
		boolean hasPattern = StringUtils.hasText(matcherPattern);
		boolean hasMessageType = StringUtils.hasText(messageType);
		if (!hasPattern) {
			BeanDefinitionBuilder matcher = BeanDefinitionBuilder
					.rootBeanDefinition(SimpMessageTypeMatcher.class);
			matcher.addConstructorArgValue(messageType);
			return matcher.getBeanDefinition();
		}

		String factoryName = null;
		if (hasPattern && hasMessageType) {
			SimpMessageType type = SimpMessageType.valueOf(messageType);
			if (SimpMessageType.MESSAGE == type) {
				factoryName = "createMessageMatcher";
			}
			else if (SimpMessageType.SUBSCRIBE == type) {
				factoryName = "createSubscribeMatcher";
			}
			else {
				parserContext
						.getReaderContext()
						.error("Cannot use intercept-websocket@message-type="
								+ messageType
								+ " with a pattern because the type does not have a destination.",
								interceptMessage);
			}
		}

		BeanDefinitionBuilder matcher = BeanDefinitionBuilder
				.rootBeanDefinition(SimpDestinationMessageMatcher.class);
		matcher.setFactoryMethod(factoryName);
		matcher.addConstructorArgValue(matcherPattern);
		matcher.addConstructorArgValue(new RuntimeBeanReference("springSecurityMessagePathMatcher"));
		return matcher.getBeanDefinition();
	}

	static class MessageSecurityPostProcessor implements
			BeanDefinitionRegistryPostProcessor {


		private static final String WEB_SOCKET_AMMH_CLASS_NAME = "org.springframework.web.socket.messaging.WebSocketAnnotationMethodMessageHandler";

		private static final String CLIENT_INBOUND_CHANNEL_BEAN_ID = "clientInboundChannel";

		private static final String INTERCEPTORS_PROP = "interceptors";

		private static final String CUSTOM_ARG_RESOLVERS_PROP = "customArgumentResolvers";

		private final String inboundSecurityInterceptorId;

		private final boolean sameOriginDisabled;

		public MessageSecurityPostProcessor(String inboundSecurityInterceptorId,
				boolean sameOriginDisabled) {
			this.inboundSecurityInterceptorId = inboundSecurityInterceptorId;
			this.sameOriginDisabled = sameOriginDisabled;
		}

		public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)
				throws BeansException {
			String[] beanNames = registry.getBeanDefinitionNames();
			for (String beanName : beanNames) {
				BeanDefinition bd = registry.getBeanDefinition(beanName);
				String beanClassName = bd.getBeanClassName();
				if (beanClassName.equals(SimpAnnotationMethodMessageHandler.class
						.getName()) || beanClassName.equals(WEB_SOCKET_AMMH_CLASS_NAME)) {
					PropertyValue current = bd.getPropertyValues().getPropertyValue(
							CUSTOM_ARG_RESOLVERS_PROP);
					ManagedList<Object> argResolvers = new ManagedList<Object>();
					if (current != null) {
						argResolvers.addAll((ManagedList<?>) current.getValue());
					}
					argResolvers.add(new RootBeanDefinition(
							AuthenticationPrincipalArgumentResolver.class));
					bd.getPropertyValues().add(CUSTOM_ARG_RESOLVERS_PROP, argResolvers);

					if(!registry.containsBeanDefinition(PATH_MATCHER_BEAN_NAME)) {
						PropertyValue pathMatcherProp = bd.getPropertyValues().getPropertyValue("pathMatcher");
						Object pathMatcher = pathMatcherProp == null ? null : pathMatcherProp.getValue();
						if(pathMatcher instanceof BeanReference) {
							registry.registerAlias(((BeanReference) pathMatcher).getBeanName(), PATH_MATCHER_BEAN_NAME);
						}
					}
				}
				else if (beanClassName
						.equals("org.springframework.web.socket.server.support.WebSocketHttpRequestHandler")) {
					addCsrfTokenHandshakeInterceptor(bd);
				}
				else if (beanClassName
						.equals("org.springframework.web.socket.sockjs.transport.TransportHandlingSockJsService")) {
					addCsrfTokenHandshakeInterceptor(bd);
				}
				else if (beanClassName
						.equals("org.springframework.web.socket.sockjs.transport.handler.DefaultSockJsService")) {
					addCsrfTokenHandshakeInterceptor(bd);
				}
			}

			if (!registry.containsBeanDefinition(CLIENT_INBOUND_CHANNEL_BEAN_ID)) {
				return;
			}
			ManagedList<Object> interceptors = new ManagedList();
			interceptors.add(new RootBeanDefinition(
					SecurityContextChannelInterceptor.class));
			if (!sameOriginDisabled) {
				interceptors.add(new RootBeanDefinition(CsrfChannelInterceptor.class));
			}
			interceptors.add(registry.getBeanDefinition(inboundSecurityInterceptorId));

			BeanDefinition inboundChannel = registry
					.getBeanDefinition(CLIENT_INBOUND_CHANNEL_BEAN_ID);
			PropertyValue currentInterceptorsPv = inboundChannel.getPropertyValues()
					.getPropertyValue(INTERCEPTORS_PROP);
			if (currentInterceptorsPv != null) {
				ManagedList<?> currentInterceptors = (ManagedList<?>) currentInterceptorsPv
						.getValue();
				interceptors.addAll(currentInterceptors);
			}

			inboundChannel.getPropertyValues().add(INTERCEPTORS_PROP, interceptors);

			if(!registry.containsBeanDefinition(PATH_MATCHER_BEAN_NAME)) {
				registry.registerBeanDefinition(PATH_MATCHER_BEAN_NAME, new RootBeanDefinition(AntPathMatcher.class));
			}
		}

		private void addCsrfTokenHandshakeInterceptor(BeanDefinition bd) {
			if (sameOriginDisabled) {
				return;
			}
			String interceptorPropertyName = "handshakeInterceptors";
			ManagedList<? super Object> interceptors = new ManagedList<Object>();
			interceptors.add(new RootBeanDefinition(CsrfTokenHandshakeInterceptor.class));
			interceptors.addAll((ManagedList<Object>) bd.getPropertyValues().get(
					interceptorPropertyName));
			bd.getPropertyValues().add(interceptorPropertyName, interceptors);
		}

		public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)
				throws BeansException {

		}
	}

	static class DelegatingPathMatcher implements PathMatcher {

		private PathMatcher delegate = new AntPathMatcher();

		public boolean isPattern(String path) {
			return delegate.isPattern(path);
		}

		public boolean match(String pattern, String path) {
			return delegate.match(pattern, path);
		}

		public boolean matchStart(String pattern, String path) {
			return delegate.matchStart(pattern, path);
		}

		public String extractPathWithinPattern(String pattern, String path) {
			return delegate.extractPathWithinPattern(pattern, path);
		}

		public Map<String, String> extractUriTemplateVariables(String pattern, String path) {
			return delegate.extractUriTemplateVariables(pattern, path);
		}

		public Comparator<String> getPatternComparator(String path) {
			return delegate.getPatternComparator(path);
		}

		public String combine(String pattern1, String pattern2) {
			return delegate.combine(pattern1, pattern2);
		}

		void setPathMatcher(PathMatcher pathMatcher) {
			this.delegate = pathMatcher;
		}
	}
}
<code block>

package org.springframework.security.config.annotation.web.socket;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.core.MethodParameter;
import org.springframework.http.server.ServerHttpRequest;
import org.springframework.http.server.ServerHttpResponse;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageChannel;
import org.springframework.messaging.MessageDeliveryException;
import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.messaging.handler.invocation.HandlerMethodArgumentResolver;
import org.springframework.messaging.simp.SimpMessageHeaderAccessor;
import org.springframework.messaging.simp.SimpMessageType;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.messaging.support.GenericMessage;
import org.springframework.mock.web.MockHttpServletRequest;
import org.springframework.mock.web.MockHttpServletResponse;
import org.springframework.mock.web.MockServletConfig;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.authentication.TestingAuthenticationToken;
import org.springframework.security.config.annotation.web.messaging.MessageSecurityMetadataSourceRegistry;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.web.csrf.CsrfToken;
import org.springframework.security.web.csrf.DefaultCsrfToken;
import org.springframework.security.web.csrf.MissingCsrfTokenException;
import org.springframework.stereotype.Controller;
import org.springframework.test.util.ReflectionTestUtils;
import org.springframework.util.AntPathMatcher;
import org.springframework.web.HttpRequestHandler;
import org.springframework.web.context.support.AnnotationConfigWebApplicationContext;
import org.springframework.web.servlet.HandlerMapping;
import org.springframework.web.socket.WebSocketHandler;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
import org.springframework.web.socket.server.HandshakeFailureException;
import org.springframework.web.socket.server.HandshakeHandler;
import org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor;
import org.springframework.web.socket.sockjs.transport.handler.SockJsWebSocketHandler;
import org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession;

import javax.servlet.http.HttpServletRequest;

import java.util.HashMap;
import java.util.Map;

import static org.fest.assertions.Assertions.assertThat;
import static org.junit.Assert.fail;

public class AbstractSecurityWebSocketMessageBrokerConfigurerTests {
	AnnotationConfigWebApplicationContext context;

	TestingAuthenticationToken messageUser;

	CsrfToken token;

	String sessionAttr;

	@Before
	public void setup() {
		token = new DefaultCsrfToken("header", "param", "token");
		sessionAttr = "sessionAttr";
		messageUser = new TestingAuthenticationToken("user", "pass", "ROLE_USER");
	}

	@After
	public void cleanup() {
		if (context != null) {
			context.close();
		}
	}

	@Test
	public void simpleRegistryMappings() {
		loadConfig(SockJsSecurityConfig.class);

		clientInboundChannel().send(message("/permitAll"));

		try {
			clientInboundChannel().send(message("/denyAll"));
			fail("Expected Exception");
		}
		catch (MessageDeliveryException expected) {
			assertThat(expected.getCause()).isInstanceOf(AccessDeniedException.class);
		}
	}

	@Test
	public void annonymousSupported() {
		loadConfig(SockJsSecurityConfig.class);

		messageUser = null;
		clientInboundChannel().send(message("/permitAll"));
	}

	@Test
	public void addsAuthenticationPrincipalResolver() throws InterruptedException {
		loadConfig(SockJsSecurityConfig.class);

		MessageChannel messageChannel = clientInboundChannel();
		Message<String> message = message("/permitAll/authentication");
		messageChannel.send(message);

		assertThat(context.getBean(MyController.class).authenticationPrincipal)
				.isEqualTo((String) messageUser.getPrincipal());
	}

	@Test
	public void addsAuthenticationPrincipalResolverWhenNoAuthorization()
			throws InterruptedException {
		loadConfig(NoInboundSecurityConfig.class);

		MessageChannel messageChannel = clientInboundChannel();
		Message<String> message = message("/permitAll/authentication");
		messageChannel.send(message);

		assertThat(context.getBean(MyController.class).authenticationPrincipal)
				.isEqualTo((String) messageUser.getPrincipal());
	}

	@Test
	public void addsCsrfProtectionWhenNoAuthorization() throws InterruptedException {
		loadConfig(NoInboundSecurityConfig.class);

		SimpMessageHeaderAccessor headers = SimpMessageHeaderAccessor
				.create(SimpMessageType.CONNECT);
		Message<?> message = message(headers, "/authentication");
		MessageChannel messageChannel = clientInboundChannel();

		try {
			messageChannel.send(message);
			fail("Expected Exception");
		}
		catch (MessageDeliveryException success) {
			assertThat(success.getCause()).isInstanceOf(MissingCsrfTokenException.class);
		}
	}

	@Test
	public void csrfProtectionForConnect() throws InterruptedException {
		loadConfig(SockJsSecurityConfig.class);

		SimpMessageHeaderAccessor headers = SimpMessageHeaderAccessor
				.create(SimpMessageType.CONNECT);
		Message<?> message = message(headers, "/authentication");
		MessageChannel messageChannel = clientInboundChannel();

		try {
			messageChannel.send(message);
			fail("Expected Exception");
		}
		catch (MessageDeliveryException success) {
			assertThat(success.getCause()).isInstanceOf(MissingCsrfTokenException.class);
		}
	}

	@Test
	public void csrfProtectionDisabledForConnect() throws InterruptedException {
		loadConfig(CsrfDisabledSockJsSecurityConfig.class);

		SimpMessageHeaderAccessor headers = SimpMessageHeaderAccessor
				.create(SimpMessageType.CONNECT);
		Message<?> message = message(headers, "/permitAll/connect");
		MessageChannel messageChannel = clientInboundChannel();

		messageChannel.send(message);
	}

	@Test
	public void messagesConnectUseCsrfTokenHandshakeInterceptor() throws Exception {

		loadConfig(SockJsSecurityConfig.class);

		SimpMessageHeaderAccessor headers = SimpMessageHeaderAccessor
				.create(SimpMessageType.CONNECT);
		Message<?> message = message(headers, "/authentication");
		MockHttpServletRequest request = sockjsHttpRequest("/chat");
		HttpRequestHandler handler = handler(request);

		handler.handleRequest(request, new MockHttpServletResponse());

		assertHandshake(request);
	}

	@Test
	public void messagesConnectUseCsrfTokenHandshakeInterceptorMultipleMappings()
			throws Exception {
		loadConfig(SockJsSecurityConfig.class);

		SimpMessageHeaderAccessor headers = SimpMessageHeaderAccessor
				.create(SimpMessageType.CONNECT);
		Message<?> message = message(headers, "/authentication");
		MockHttpServletRequest request = sockjsHttpRequest("/other");
		HttpRequestHandler handler = handler(request);

		handler.handleRequest(request, new MockHttpServletResponse());

		assertHandshake(request);
	}

	@Test
	public void messagesConnectWebSocketUseCsrfTokenHandshakeInterceptor()
			throws Exception {
		loadConfig(WebSocketSecurityConfig.class);

		SimpMessageHeaderAccessor headers = SimpMessageHeaderAccessor
				.create(SimpMessageType.CONNECT);
		Message<?> message = message(headers, "/authentication");
		MockHttpServletRequest request = websocketHttpRequest("/websocket");
		HttpRequestHandler handler = handler(request);

		handler.handleRequest(request, new MockHttpServletResponse());

		assertHandshake(request);
	}

	@Test
	public void msmsRegistryCustomPatternMatcher()
			throws Exception {
		loadConfig(MsmsRegistryCustomPatternMatcherConfig.class);

		clientInboundChannel().send(message("/app/a.b"));

		try {
			clientInboundChannel().send(message("/app/a.b.c"));
			fail("Expected Exception");
		}
		catch (MessageDeliveryException expected) {
			assertThat(expected.getCause()).isInstanceOf(AccessDeniedException.class);
		}
	}

	@Configuration
	@EnableWebSocketMessageBroker
	@Import(SyncExecutorConfig.class)
	static class MsmsRegistryCustomPatternMatcherConfig extends
			AbstractSecurityWebSocketMessageBrokerConfigurer {


		public void registerStompEndpoints(StompEndpointRegistry registry) {
			registry
				.addEndpoint("/other")
				.setHandshakeHandler(testHandshakeHandler());
		}



		@Override
		protected void configureInbound(MessageSecurityMetadataSourceRegistry messages) {
			messages
				.simpDestMatchers("/app/a.*").permitAll()
				.anyMessage().denyAll();
		}


		@Override
		public void configureMessageBroker(MessageBrokerRegistry registry) {
			registry.setPathMatcher(new AntPathMatcher("."));
			registry.enableSimpleBroker("/queue/", "/topic/");
			registry.setApplicationDestinationPrefixes("/app");
		}

		@Bean
		public TestHandshakeHandler testHandshakeHandler() {
			return new TestHandshakeHandler();
		}
	}

	@Test
	public void overrideMsmsRegistryCustomPatternMatcher()
			throws Exception {
		loadConfig(OverrideMsmsRegistryCustomPatternMatcherConfig.class);

		clientInboundChannel().send(message("/app/a/b"));

		try {
			clientInboundChannel().send(message("/app/a/b/c"));
			fail("Expected Exception");
		}
		catch (MessageDeliveryException expected) {
			assertThat(expected.getCause()).isInstanceOf(AccessDeniedException.class);
		}
	}

	@Configuration
	@EnableWebSocketMessageBroker
	@Import(SyncExecutorConfig.class)
	static class OverrideMsmsRegistryCustomPatternMatcherConfig extends
			AbstractSecurityWebSocketMessageBrokerConfigurer {


		public void registerStompEndpoints(StompEndpointRegistry registry) {
			registry
				.addEndpoint("/other")
				.setHandshakeHandler(testHandshakeHandler());
		}




		@Override
		protected void configureInbound(MessageSecurityMetadataSourceRegistry messages) {
			messages
				.simpDestPathMatcher(new AntPathMatcher())
				.simpDestMatchers("/app/a/*").permitAll()
				.anyMessage().denyAll();
		}


		@Override
		public void configureMessageBroker(MessageBrokerRegistry registry) {
			registry.setPathMatcher(new AntPathMatcher("."));
			registry.enableSimpleBroker("/queue/", "/topic/");
			registry.setApplicationDestinationPrefixes("/app");
		}

		@Bean
		public TestHandshakeHandler testHandshakeHandler() {
			return new TestHandshakeHandler();
		}
	}

	@Test
	public void defaultPatternMatcher()
			throws Exception {
		loadConfig(DefaultPatternMatcherConfig.class);

		clientInboundChannel().send(message("/app/a/b"));

		try {
			clientInboundChannel().send(message("/app/a/b/c"));
			fail("Expected Exception");
		}
		catch (MessageDeliveryException expected) {
			assertThat(expected.getCause()).isInstanceOf(AccessDeniedException.class);
		}
	}

	@Configuration
	@EnableWebSocketMessageBroker
	@Import(SyncExecutorConfig.class)
	static class DefaultPatternMatcherConfig extends
			AbstractSecurityWebSocketMessageBrokerConfigurer {


		public void registerStompEndpoints(StompEndpointRegistry registry) {
			registry
				.addEndpoint("/other")
				.setHandshakeHandler(testHandshakeHandler());
		}



		@Override
		protected void configureInbound(MessageSecurityMetadataSourceRegistry messages) {
			messages
				.simpDestMatchers("/app/a/*").permitAll()
				.anyMessage().denyAll();
		}


		@Override
		public void configureMessageBroker(MessageBrokerRegistry registry) {
			registry.enableSimpleBroker("/queue/", "/topic/");
			registry.setApplicationDestinationPrefixes("/app");
		}

		@Bean
		public TestHandshakeHandler testHandshakeHandler() {
			return new TestHandshakeHandler();
		}
	}

	private void assertHandshake(HttpServletRequest request) {
		TestHandshakeHandler handshakeHandler = context
				.getBean(TestHandshakeHandler.class);
		assertThat(handshakeHandler.attributes.get(CsrfToken.class.getName())).isSameAs(
				token);
		assertThat(handshakeHandler.attributes.get(sessionAttr)).isEqualTo(
				request.getSession().getAttribute(sessionAttr));
	}

	private HttpRequestHandler handler(HttpServletRequest request) throws Exception {
		HandlerMapping handlerMapping = context.getBean(HandlerMapping.class);
		return (HttpRequestHandler) handlerMapping.getHandler(request).getHandler();
	}

	private MockHttpServletRequest websocketHttpRequest(String mapping) {
		MockHttpServletRequest request = sockjsHttpRequest(mapping);
		request.setRequestURI(mapping);
		return request;
	}

	private MockHttpServletRequest sockjsHttpRequest(String mapping) {
		MockHttpServletRequest request = new MockHttpServletRequest();
		request.setMethod("GET");
		request.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE,
				"/289/tpyx6mde/websocket");
		request.setRequestURI(mapping + "/289/tpyx6mde/websocket");
		request.getSession().setAttribute(sessionAttr, "sessionValue");

		request.setAttribute(CsrfToken.class.getName(), token);
		return request;
	}

	private Message<String> message(String destination) {
		SimpMessageHeaderAccessor headers = SimpMessageHeaderAccessor.create();
		return message(headers, destination);
	}

	private Message<String> message(SimpMessageHeaderAccessor headers, String destination) {
		headers.setSessionId("123");
		headers.setSessionAttributes(new HashMap<String, Object>());
		if (destination != null) {
			headers.setDestination(destination);
		}
		if (messageUser != null) {
			headers.setUser(messageUser);
		}
		return new GenericMessage<String>("hi", headers.getMessageHeaders());
	}

	private MessageChannel clientInboundChannel() {
		return context.getBean("clientInboundChannel", MessageChannel.class);
	}

	private void loadConfig(Class<?>... configs) {
		context = new AnnotationConfigWebApplicationContext();
		context.register(configs);
		context.setServletConfig(new MockServletConfig());
		context.refresh();
	}

	@Controller
	static class MyController {

		String authenticationPrincipal;
		MyCustomArgument myCustomArgument;

		@MessageMapping("/authentication")
		public void authentication(@AuthenticationPrincipal String un) {
			this.authenticationPrincipal = un;
		}

		@MessageMapping("/myCustom")
		public void myCustom(MyCustomArgument myCustomArgument) {
			this.myCustomArgument = myCustomArgument;
		}
	}

	static class MyCustomArgument {
		MyCustomArgument(String notDefaultConstr) {
		}
	}

	static class MyCustomArgumentResolver implements HandlerMethodArgumentResolver {

		public boolean supportsParameter(MethodParameter parameter) {
			return parameter.getParameterType().isAssignableFrom(MyCustomArgument.class);
		}

		public Object resolveArgument(MethodParameter parameter, Message<?> message)
				throws Exception {
			return new MyCustomArgument("");
		}
	}

	static class TestHandshakeHandler implements HandshakeHandler {
		Map<String, Object> attributes;

		public boolean doHandshake(ServerHttpRequest request,
				ServerHttpResponse response, WebSocketHandler wsHandler,
				Map<String, Object> attributes) throws HandshakeFailureException {
			this.attributes = attributes;
			if (wsHandler instanceof SockJsWebSocketHandler) {

				SockJsWebSocketHandler sockJs = (SockJsWebSocketHandler) wsHandler;
				WebSocketServerSockJsSession session = (WebSocketServerSockJsSession) ReflectionTestUtils
						.getField(sockJs, "sockJsSession");
				this.attributes = session.getAttributes();
			}
			return true;
		}
	}

	@Configuration
	@EnableWebSocketMessageBroker
	@Import(SyncExecutorConfig.class)
	static class SockJsSecurityConfig extends
			AbstractSecurityWebSocketMessageBrokerConfigurer {

		public void registerStompEndpoints(StompEndpointRegistry registry) {
			registry.addEndpoint("/other").setHandshakeHandler(testHandshakeHandler())
					.withSockJS().setInterceptors(new HttpSessionHandshakeInterceptor());

			registry.addEndpoint("/chat").setHandshakeHandler(testHandshakeHandler())
					.withSockJS().setInterceptors(new HttpSessionHandshakeInterceptor());
		}


		@Override
		protected void configureInbound(MessageSecurityMetadataSourceRegistry messages) {
			messages
				.simpDestMatchers("/permitAll/**").permitAll()
				.anyMessage().denyAll();
		}


		@Override
		public void configureMessageBroker(MessageBrokerRegistry registry) {
			registry.enableSimpleBroker("/queue/", "/topic/");
			registry.setApplicationDestinationPrefixes("/permitAll", "/denyAll");
		}

		@Bean
		public MyController myController() {
			return new MyController();
		}

		@Bean
		public TestHandshakeHandler testHandshakeHandler() {
			return new TestHandshakeHandler();
		}
	}

	@Configuration
	@EnableWebSocketMessageBroker
	@Import(SyncExecutorConfig.class)
	static class NoInboundSecurityConfig extends
			AbstractSecurityWebSocketMessageBrokerConfigurer {

		public void registerStompEndpoints(StompEndpointRegistry registry) {
			registry.addEndpoint("/other").withSockJS()
					.setInterceptors(new HttpSessionHandshakeInterceptor());

			registry.addEndpoint("/chat").withSockJS()
					.setInterceptors(new HttpSessionHandshakeInterceptor());
		}

		@Override
		protected void configureInbound(MessageSecurityMetadataSourceRegistry messages) {
		}

		@Override
		public void configureMessageBroker(MessageBrokerRegistry registry) {
			registry.enableSimpleBroker("/queue/", "/topic/");
			registry.setApplicationDestinationPrefixes("/permitAll", "/denyAll");
		}

		@Bean
		public MyController myController() {
			return new MyController();
		}
	}

	@Configuration
	static class CsrfDisabledSockJsSecurityConfig extends SockJsSecurityConfig {

		@Override
		protected boolean sameOriginDisabled() {
			return true;
		}
	}

	@Configuration
	@EnableWebSocketMessageBroker
	@Import(SyncExecutorConfig.class)
	static class WebSocketSecurityConfig extends
			AbstractSecurityWebSocketMessageBrokerConfigurer {

		public void registerStompEndpoints(StompEndpointRegistry registry) {
			registry.addEndpoint("/websocket")
					.setHandshakeHandler(testHandshakeHandler())
					.addInterceptors(new HttpSessionHandshakeInterceptor());
		}


		@Override
		protected void configureInbound(MessageSecurityMetadataSourceRegistry messages) {
			messages
				.simpDestMatchers("/permitAll/**").permitAll()
				.anyMessage().denyAll();
		}


		@Bean
		public TestHandshakeHandler testHandshakeHandler() {
			return new TestHandshakeHandler();
		}
	}

	@Configuration
	static class SyncExecutorConfig {
		@Bean
		public static SyncExecutorSubscribableChannelPostProcessor postProcessor() {
			return new SyncExecutorSubscribableChannelPostProcessor();
		}
	}
}
<code block>

package org.springframework.security.messaging.access.expression;

import java.util.Arrays;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.Map;

import org.springframework.expression.Expression;
import org.springframework.messaging.Message;
import org.springframework.security.access.ConfigAttribute;
import org.springframework.security.access.expression.SecurityExpressionHandler;
import org.springframework.security.messaging.access.intercept.DefaultMessageSecurityMetadataSource;
import org.springframework.security.messaging.access.intercept.MessageSecurityMetadataSource;
import org.springframework.security.messaging.util.matcher.MessageMatcher;


public final class ExpressionBasedMessageSecurityMetadataSourceFactory {


	public static MessageSecurityMetadataSource createExpressionMessageMetadataSource(
			LinkedHashMap<MessageMatcher<?>, String> matcherToExpression) {
		return createExpressionMessageMetadataSource(matcherToExpression, new DefaultMessageSecurityExpressionHandler<Object>());
	}


	public static MessageSecurityMetadataSource createExpressionMessageMetadataSource(
			LinkedHashMap<MessageMatcher<?>, String> matcherToExpression, SecurityExpressionHandler<Message<Object>> handler) {

		LinkedHashMap<MessageMatcher<?>, Collection<ConfigAttribute>> matcherToAttrs = new LinkedHashMap<MessageMatcher<?>, Collection<ConfigAttribute>>();

		for (Map.Entry<MessageMatcher<?>, String> entry : matcherToExpression.entrySet()) {
			MessageMatcher<?> matcher = entry.getKey();
			String rawExpression = entry.getValue();
			Expression expression = handler.getExpressionParser().parseExpression(
					rawExpression);
			ConfigAttribute attribute = new MessageExpressionConfigAttribute(expression);
			matcherToAttrs.put(matcher, Arrays.asList(attribute));
		}
		return new DefaultMessageSecurityMetadataSource(matcherToAttrs);
	}

	private ExpressionBasedMessageSecurityMetadataSourceFactory() {
	}
}
<code block>

package org.springframework.security.messaging.access.expression;

import org.springframework.messaging.Message;
import org.springframework.security.access.expression.SecurityExpressionRoot;
import org.springframework.security.core.Authentication;


public class MessageSecurityExpressionRoot extends SecurityExpressionRoot {

	public final Message<?> message;

	public MessageSecurityExpressionRoot(Authentication authentication, Message<?> message) {
		super(authentication);
		this.message = message;
	}
}

<code block>

package org.springframework.security.config.annotation.web.messaging;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.springframework.messaging.Message;
import org.springframework.messaging.simp.SimpMessageType;
import org.springframework.security.access.expression.SecurityExpressionHandler;
import org.springframework.security.config.annotation.web.configurers.RememberMeConfigurer;
import org.springframework.security.messaging.access.expression.DefaultMessageSecurityExpressionHandler;
import org.springframework.security.messaging.access.expression.ExpressionBasedMessageSecurityMetadataSourceFactory;
import org.springframework.security.messaging.access.intercept.MessageSecurityMetadataSource;
import org.springframework.security.messaging.util.matcher.MessageMatcher;
import org.springframework.security.messaging.util.matcher.SimpDestinationMessageMatcher;
import org.springframework.security.messaging.util.matcher.SimpMessageTypeMatcher;
import org.springframework.util.AntPathMatcher;
import org.springframework.util.Assert;
import org.springframework.util.PathMatcher;
import org.springframework.util.StringUtils;


public class MessageSecurityMetadataSourceRegistry {
	private static final String permitAll = "permitAll";
	private static final String denyAll = "denyAll";
	private static final String anonymous = "anonymous";
	private static final String authenticated = "authenticated";
	private static final String fullyAuthenticated = "fullyAuthenticated";
	private static final String rememberMe = "rememberMe";

	private SecurityExpressionHandler<Message<Object>> expressionHandler = new DefaultMessageSecurityExpressionHandler<Object>();

	private final LinkedHashMap<MatcherBuilder, String> matcherToExpression = new LinkedHashMap<MatcherBuilder, String>();

	private DelegatingPathMatcher pathMatcher = new DelegatingPathMatcher();

	private boolean defaultPathMatcher = true;


	public Constraint anyMessage() {
		return matchers(MessageMatcher.ANY_MESSAGE);
	}


	public Constraint nullDestMatcher() {
		return matchers(SimpDestinationMessageMatcher.NULL_DESTINATION_MATCHER);
	}


	public Constraint simpTypeMatchers(SimpMessageType... typesToMatch) {
		MessageMatcher<?>[] typeMatchers = new MessageMatcher<?>[typesToMatch.length];
		for (int i = 0; i < typesToMatch.length; i++) {
			SimpMessageType typeToMatch = typesToMatch[i];
			typeMatchers[i] = new SimpMessageTypeMatcher(typeToMatch);
		}
		return matchers(typeMatchers);
	}


	public Constraint simpDestMatchers(String... patterns) {
		return simpDestMatchers(null, patterns);
	}


	public Constraint simpMessageDestMatchers(String... patterns) {
		return simpDestMatchers(SimpMessageType.MESSAGE, patterns);
	}


	public Constraint simpSubscribeDestMatchers(String... patterns) {
		return simpDestMatchers(SimpMessageType.SUBSCRIBE, patterns);
	}


	private Constraint simpDestMatchers(SimpMessageType type, String... patterns) {
		List<MatcherBuilder> matchers = new ArrayList<MatcherBuilder>(patterns.length);
		for (String pattern : patterns) {
			matchers.add(new PathMatcherMessageMatcherBuilder(pattern, type));
		}
		return new Constraint(matchers);
	}


	public MessageSecurityMetadataSourceRegistry simpDestPathMatcher(
			PathMatcher pathMatcher) {
		Assert.notNull(pathMatcher, "pathMatcher cannot be null");
		this.pathMatcher.setPathMatcher(pathMatcher);
		this.defaultPathMatcher = false;
		return this;
	}


	protected boolean isSimpDestPathMatcherConfigured() {
		return !this.defaultPathMatcher;
	}


	public Constraint matchers(MessageMatcher<?>... matchers) {
		List<MatcherBuilder> builders = new ArrayList<MatcherBuilder>(matchers.length);
		for (MessageMatcher<?> matcher : matchers) {
			builders.add(new PreBuiltMatcherBuilder(matcher));
		}
		return new Constraint(builders);
	}


	public MessageSecurityMetadataSourceRegistry expressionHandler(SecurityExpressionHandler<Message<Object>> expressionHandler) {
		Assert.notNull(expressionHandler, "expressionHandler cannot be null");
		this.expressionHandler = expressionHandler;
		return this;
	}


	protected MessageSecurityMetadataSource createMetadataSource() {
		LinkedHashMap<MessageMatcher<?>, String> matcherToExpression = new LinkedHashMap<MessageMatcher<?>, String>();
		for (Map.Entry<MatcherBuilder, String> entry : this.matcherToExpression
				.entrySet()) {
			matcherToExpression.put(entry.getKey().build(), entry.getValue());
		}
		return ExpressionBasedMessageSecurityMetadataSourceFactory
				.createExpressionMessageMetadataSource(matcherToExpression, expressionHandler);
	}


	protected boolean containsMapping() {
		return !this.matcherToExpression.isEmpty();
	}


	public class Constraint {
		private final List<? extends MatcherBuilder> messageMatchers;


		private Constraint(List<? extends MatcherBuilder> messageMatchers) {
			Assert.notEmpty(messageMatchers, "messageMatchers cannot be null or empty");
			this.messageMatchers = messageMatchers;
		}


		public MessageSecurityMetadataSourceRegistry hasRole(String role) {
			return access(MessageSecurityMetadataSourceRegistry.hasRole(role));
		}


		public MessageSecurityMetadataSourceRegistry hasAnyRole(String... roles) {
			return access(MessageSecurityMetadataSourceRegistry.hasAnyRole(roles));
		}


		public MessageSecurityMetadataSourceRegistry hasAuthority(String authority) {
			return access(MessageSecurityMetadataSourceRegistry.hasAuthority(authority));
		}


		public MessageSecurityMetadataSourceRegistry hasAnyAuthority(
				String... authorities) {
			return access(MessageSecurityMetadataSourceRegistry
					.hasAnyAuthority(authorities));
		}


		public MessageSecurityMetadataSourceRegistry permitAll() {
			return access(permitAll);
		}


		public MessageSecurityMetadataSourceRegistry anonymous() {
			return access(anonymous);
		}


		public MessageSecurityMetadataSourceRegistry rememberMe() {
			return access(rememberMe);
		}


		public MessageSecurityMetadataSourceRegistry denyAll() {
			return access(denyAll);
		}


		public MessageSecurityMetadataSourceRegistry authenticated() {
			return access(authenticated);
		}


		public MessageSecurityMetadataSourceRegistry fullyAuthenticated() {
			return access(fullyAuthenticated);
		}


		public MessageSecurityMetadataSourceRegistry access(String attribute) {
			for (MatcherBuilder messageMatcher : messageMatchers) {
				matcherToExpression.put(messageMatcher, attribute);
			}
			return MessageSecurityMetadataSourceRegistry.this;
		}
	}

	private static String hasAnyRole(String... authorities) {
		String anyAuthorities = StringUtils.arrayToDelimitedString(authorities,
				"','ROLE_");
		return "hasAnyRole('ROLE_" + anyAuthorities + "')";
	}

	private static String hasRole(String role) {
		Assert.notNull(role, "role cannot be null");
		if (role.startsWith("ROLE_")) {
			throw new IllegalArgumentException(
					"role should not start with 'ROLE_' since it is automatically inserted. Got '"
							+ role + "'");
		}
		return "hasRole('ROLE_" + role + "')";
	}

	private static String hasAuthority(String authority) {
		return "hasAuthority('" + authority + "')";
	}

	private static String hasAnyAuthority(String... authorities) {
		String anyAuthorities = StringUtils.arrayToDelimitedString(authorities, "','");
		return "hasAnyAuthority('" + anyAuthorities + "')";
	}

	private static class PreBuiltMatcherBuilder implements MatcherBuilder {
		private MessageMatcher<?> matcher;

		private PreBuiltMatcherBuilder(MessageMatcher<?> matcher) {
			this.matcher = matcher;
		}

		public MessageMatcher<?> build() {
			return matcher;
		}
	}

	private class PathMatcherMessageMatcherBuilder implements MatcherBuilder {
		private final String pattern;
		private final SimpMessageType type;

		private PathMatcherMessageMatcherBuilder(String pattern, SimpMessageType type) {
			this.pattern = pattern;
			this.type = type;
		}

		public MessageMatcher<?> build() {
			if (type == null) {
				return new SimpDestinationMessageMatcher(pattern, pathMatcher);
			}
			else if (SimpMessageType.MESSAGE == type) {
				return SimpDestinationMessageMatcher.createMessageMatcher(pattern,
						pathMatcher);
			}
			else if (SimpMessageType.SUBSCRIBE == type) {
				return SimpDestinationMessageMatcher.createSubscribeMatcher(pattern,
						pathMatcher);
			}
			throw new IllegalStateException(type
					+ " is not supported since it does not have a destination");
		}
	}

	private interface MatcherBuilder {
		MessageMatcher<?> build();
	}


	static class DelegatingPathMatcher implements PathMatcher {

		private PathMatcher delegate = new AntPathMatcher();

		public boolean isPattern(String path) {
			return delegate.isPattern(path);
		}

		public boolean match(String pattern, String path) {
			return delegate.match(pattern, path);
		}

		public boolean matchStart(String pattern, String path) {
			return delegate.matchStart(pattern, path);
		}

		public String extractPathWithinPattern(String pattern, String path) {
			return delegate.extractPathWithinPattern(pattern, path);
		}

		public Map<String, String> extractUriTemplateVariables(String pattern, String path) {
			return delegate.extractUriTemplateVariables(pattern, path);
		}

		public Comparator<String> getPatternComparator(String path) {
			return delegate.getPatternComparator(path);
		}

		public String combine(String pattern1, String pattern2) {
			return delegate.combine(pattern1, pattern2);
		}

		void setPathMatcher(PathMatcher pathMatcher) {
			this.delegate = pathMatcher;
		}
	}
}

<code block>

package org.springframework.security.config.annotation.web.socket;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import org.springframework.beans.factory.NoSuchBeanDefinitionException;
import org.springframework.beans.factory.SmartInitializingSingleton;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.messaging.Message;
import org.springframework.messaging.handler.invocation.HandlerMethodArgumentResolver;
import org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler;
import org.springframework.messaging.simp.config.ChannelRegistration;
import org.springframework.security.access.AccessDecisionVoter;
import org.springframework.security.access.expression.SecurityExpressionHandler;
import org.springframework.security.access.vote.AffirmativeBased;
import org.springframework.security.config.annotation.web.messaging.MessageSecurityMetadataSourceRegistry;
import org.springframework.security.messaging.access.expression.MessageExpressionVoter;
import org.springframework.security.messaging.access.intercept.ChannelSecurityInterceptor;
import org.springframework.security.messaging.access.intercept.MessageSecurityMetadataSource;
import org.springframework.security.messaging.context.AuthenticationPrincipalArgumentResolver;
import org.springframework.security.messaging.context.SecurityContextChannelInterceptor;
import org.springframework.security.messaging.web.csrf.CsrfChannelInterceptor;
import org.springframework.security.messaging.web.socket.server.CsrfTokenHandshakeInterceptor;
import org.springframework.util.AntPathMatcher;
import org.springframework.util.PathMatcher;
import org.springframework.web.servlet.handler.SimpleUrlHandlerMapping;
import org.springframework.web.socket.config.annotation.AbstractWebSocketMessageBrokerConfigurer;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
import org.springframework.web.socket.server.HandshakeInterceptor;
import org.springframework.web.socket.server.support.WebSocketHttpRequestHandler;
import org.springframework.web.socket.sockjs.SockJsService;
import org.springframework.web.socket.sockjs.support.SockJsHttpRequestHandler;
import org.springframework.web.socket.sockjs.transport.TransportHandlingSockJsService;


@Order(Ordered.HIGHEST_PRECEDENCE + 100)
public abstract class AbstractSecurityWebSocketMessageBrokerConfigurer extends
		AbstractWebSocketMessageBrokerConfigurer implements SmartInitializingSingleton {
	private final WebSocketMessageSecurityMetadataSourceRegistry inboundRegistry = new WebSocketMessageSecurityMetadataSourceRegistry();

	private SecurityExpressionHandler<Message<Object>> expressionHandler;

	private ApplicationContext context;

	public void registerStompEndpoints(StompEndpointRegistry registry) {
	}

	@Override
	public void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {
		argumentResolvers.add(new AuthenticationPrincipalArgumentResolver());
	}

	@Override
	public final void configureClientInboundChannel(ChannelRegistration registration) {
		ChannelSecurityInterceptor inboundChannelSecurity = inboundChannelSecurity();
		registration.setInterceptors(securityContextChannelInterceptor());
		if (!sameOriginDisabled()) {
			registration.setInterceptors(csrfChannelInterceptor());
		}
		if (inboundRegistry.containsMapping()) {
			registration.setInterceptors(inboundChannelSecurity);
		}
		customizeClientInboundChannel(registration);
	}

	private PathMatcher getDefaultPathMatcher() {
		try {
			return context.getBean(SimpAnnotationMethodMessageHandler.class).getPathMatcher();
		} catch(NoSuchBeanDefinitionException e) {
			return new AntPathMatcher();
		}
	}


	protected boolean sameOriginDisabled() {
		return false;
	}


	protected void customizeClientInboundChannel(ChannelRegistration registration) {
	}

	@Bean
	public CsrfChannelInterceptor csrfChannelInterceptor() {
		return new CsrfChannelInterceptor();
	}

	@Bean
	public ChannelSecurityInterceptor inboundChannelSecurity() {
		ChannelSecurityInterceptor channelSecurityInterceptor = new ChannelSecurityInterceptor(
				inboundMessageSecurityMetadataSource());
		MessageExpressionVoter<Object> voter = new MessageExpressionVoter<Object>();
		if(expressionHandler != null) {
			voter.setExpressionHandler(expressionHandler);
		}

		List<AccessDecisionVoter<? extends Object>> voters = new ArrayList<AccessDecisionVoter<? extends Object>>();
		voters.add(voter);

		AffirmativeBased manager = new AffirmativeBased(voters);
		channelSecurityInterceptor.setAccessDecisionManager(manager);
		return channelSecurityInterceptor;
	}

	@Bean
	public SecurityContextChannelInterceptor securityContextChannelInterceptor() {
		return new SecurityContextChannelInterceptor();
	}

	@Bean
	public MessageSecurityMetadataSource inboundMessageSecurityMetadataSource() {
		if(expressionHandler != null) {
			inboundRegistry.expressionHandler(expressionHandler);
		}
		configureInbound(inboundRegistry);
		return inboundRegistry.createMetadataSource();
	}


	protected void configureInbound(MessageSecurityMetadataSourceRegistry messages) {
	}

	private static class WebSocketMessageSecurityMetadataSourceRegistry extends
			MessageSecurityMetadataSourceRegistry {
		@Override
		public MessageSecurityMetadataSource createMetadataSource() {
			return super.createMetadataSource();
		}

		@Override
		protected boolean containsMapping() {
			return super.containsMapping();
		}

		@Override
		protected boolean isSimpDestPathMatcherConfigured() {
			return super.isSimpDestPathMatcherConfigured();
		}
	}

	@Autowired
	public void setApplicationContext(ApplicationContext context) {
		this.context = context;
	}

	@Autowired(required = false)
	public void setMessageExpessionHandler(List<SecurityExpressionHandler<Message<Object>>> expressionHandlers) {
		if(expressionHandlers.size() == 1) {
			this.expressionHandler = expressionHandlers.get(0);
		}
	}

	public void afterSingletonsInstantiated() {
		if (sameOriginDisabled()) {
			return;
		}

		String beanName = "stompWebSocketHandlerMapping";
		SimpleUrlHandlerMapping mapping = context.getBean(beanName,
				SimpleUrlHandlerMapping.class);
		Map<String, Object> mappings = mapping.getHandlerMap();
		for (Object object : mappings.values()) {
			if (object instanceof SockJsHttpRequestHandler) {
				SockJsHttpRequestHandler sockjsHandler = (SockJsHttpRequestHandler) object;
				SockJsService sockJsService = sockjsHandler.getSockJsService();
				if (!(sockJsService instanceof TransportHandlingSockJsService)) {
					throw new IllegalStateException(
							"sockJsService must be instance of TransportHandlingSockJsService got "
									+ sockJsService);
				}

				TransportHandlingSockJsService transportHandlingSockJsService = (TransportHandlingSockJsService) sockJsService;
				List<HandshakeInterceptor> handshakeInterceptors = transportHandlingSockJsService
						.getHandshakeInterceptors();
				List<HandshakeInterceptor> interceptorsToSet = new ArrayList<HandshakeInterceptor>(
						handshakeInterceptors.size() + 1);
				interceptorsToSet.add(new CsrfTokenHandshakeInterceptor());
				interceptorsToSet.addAll(handshakeInterceptors);

				transportHandlingSockJsService
						.setHandshakeInterceptors(interceptorsToSet);
			}
			else if (object instanceof WebSocketHttpRequestHandler) {
				WebSocketHttpRequestHandler handler = (WebSocketHttpRequestHandler) object;
				List<HandshakeInterceptor> handshakeInterceptors = handler
						.getHandshakeInterceptors();
				List<HandshakeInterceptor> interceptorsToSet = new ArrayList<HandshakeInterceptor>(
						handshakeInterceptors.size() + 1);
				interceptorsToSet.add(new CsrfTokenHandshakeInterceptor());
				interceptorsToSet.addAll(handshakeInterceptors);

				handler.setHandshakeInterceptors(interceptorsToSet);
			}
			else {
				throw new IllegalStateException(
						"Bean "
								+ beanName
								+ " is expected to contain mappings to either a SockJsHttpRequestHandler or a WebSocketHttpRequestHandler but got "
								+ object);
			}
		}

		if (inboundRegistry.containsMapping() && !inboundRegistry.isSimpDestPathMatcherConfigured()) {
			PathMatcher pathMatcher = getDefaultPathMatcher();
			inboundRegistry.simpDestPathMatcher(pathMatcher);
		}
	}
}
<code block>

package org.springframework.security.config.websocket;

import static org.springframework.security.config.Elements.*;

import java.util.Comparator;
import java.util.List;
import java.util.Map;

import org.springframework.beans.BeansException;
import org.springframework.beans.PropertyValue;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.config.BeanReference;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
import org.springframework.beans.factory.config.RuntimeBeanReference;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.support.BeanDefinitionRegistry;
import org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor;
import org.springframework.beans.factory.support.ManagedList;
import org.springframework.beans.factory.support.ManagedMap;
import org.springframework.beans.factory.support.RootBeanDefinition;
import org.springframework.beans.factory.xml.BeanDefinitionParser;
import org.springframework.beans.factory.xml.ParserContext;
import org.springframework.beans.factory.xml.XmlReaderContext;
import org.springframework.messaging.simp.SimpMessageType;
import org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler;
import org.springframework.security.access.vote.ConsensusBased;
import org.springframework.security.config.Elements;
import org.springframework.security.messaging.access.expression.ExpressionBasedMessageSecurityMetadataSourceFactory;
import org.springframework.security.messaging.access.expression.MessageExpressionVoter;
import org.springframework.security.messaging.access.intercept.ChannelSecurityInterceptor;
import org.springframework.security.messaging.context.AuthenticationPrincipalArgumentResolver;
import org.springframework.security.messaging.context.SecurityContextChannelInterceptor;
import org.springframework.security.messaging.util.matcher.SimpDestinationMessageMatcher;
import org.springframework.security.messaging.util.matcher.SimpMessageTypeMatcher;
import org.springframework.security.messaging.web.csrf.CsrfChannelInterceptor;
import org.springframework.security.messaging.web.socket.server.CsrfTokenHandshakeInterceptor;
import org.springframework.util.AntPathMatcher;
import org.springframework.util.PathMatcher;
import org.springframework.util.StringUtils;
import org.springframework.util.xml.DomUtils;
import org.w3c.dom.Element;


public final class WebSocketMessageBrokerSecurityBeanDefinitionParser implements
		BeanDefinitionParser {
	private static final String ID_ATTR = "id";

	private static final String DISABLED_ATTR = "same-origin-disabled";

	private static final String PATTERN_ATTR = "pattern";

	private static final String ACCESS_ATTR = "access";

	private static final String TYPE_ATTR = "type";

	private static final String PATH_MATCHER_BEAN_NAME = "springSecurityMessagePathMatcher";


	public BeanDefinition parse(Element element, ParserContext parserContext) {
		BeanDefinitionRegistry registry = parserContext.getRegistry();
		XmlReaderContext context = parserContext.getReaderContext();

		ManagedMap<BeanDefinition, String> matcherToExpression = new ManagedMap<BeanDefinition, String>();

		String id = element.getAttribute(ID_ATTR);
		Element expressionHandlerElt = DomUtils.getChildElementByTagName(element,
				EXPRESSION_HANDLER);
		String expressionHandlerRef = expressionHandlerElt == null ? null : expressionHandlerElt.getAttribute("ref");
		boolean expressionHandlerDefined = StringUtils.hasText(expressionHandlerRef);

		boolean sameOriginDisabled = Boolean.parseBoolean(element
				.getAttribute(DISABLED_ATTR));

		List<Element> interceptMessages = DomUtils.getChildElementsByTagName(element,
				Elements.INTERCEPT_MESSAGE);
		for (Element interceptMessage : interceptMessages) {
			String matcherPattern = interceptMessage.getAttribute(PATTERN_ATTR);
			String accessExpression = interceptMessage.getAttribute(ACCESS_ATTR);
			String messageType = interceptMessage.getAttribute(TYPE_ATTR);

			BeanDefinition matcher = createMatcher(matcherPattern, messageType,
					parserContext, interceptMessage);
			matcherToExpression.put(matcher, accessExpression);
		}

		BeanDefinitionBuilder mds = BeanDefinitionBuilder
				.rootBeanDefinition(ExpressionBasedMessageSecurityMetadataSourceFactory.class);
		mds.setFactoryMethod("createExpressionMessageMetadataSource");
		mds.addConstructorArgValue(matcherToExpression);
		if(expressionHandlerDefined) {
			mds.addConstructorArgReference(expressionHandlerRef);
		}

		String mdsId = context.registerWithGeneratedName(mds.getBeanDefinition());

		ManagedList<BeanDefinition> voters = new ManagedList<BeanDefinition>();
		BeanDefinitionBuilder messageExpressionVoterBldr = BeanDefinitionBuilder.rootBeanDefinition(MessageExpressionVoter.class);
		if(expressionHandlerDefined) {
			messageExpressionVoterBldr.addPropertyReference("expressionHandler", expressionHandlerRef);
		}
		voters.add(messageExpressionVoterBldr.getBeanDefinition());
		BeanDefinitionBuilder adm = BeanDefinitionBuilder
				.rootBeanDefinition(ConsensusBased.class);
		adm.addConstructorArgValue(voters);

		BeanDefinitionBuilder inboundChannelSecurityInterceptor = BeanDefinitionBuilder
				.rootBeanDefinition(ChannelSecurityInterceptor.class);
		inboundChannelSecurityInterceptor.addConstructorArgValue(registry
				.getBeanDefinition(mdsId));
		inboundChannelSecurityInterceptor.addPropertyValue("accessDecisionManager",
				adm.getBeanDefinition());
		String inSecurityInterceptorName = context
				.registerWithGeneratedName(inboundChannelSecurityInterceptor
						.getBeanDefinition());

		if (StringUtils.hasText(id)) {
			registry.registerAlias(inSecurityInterceptorName, id);

			if(!registry.containsBeanDefinition(PATH_MATCHER_BEAN_NAME)) {
				registry.registerBeanDefinition(PATH_MATCHER_BEAN_NAME, new RootBeanDefinition(AntPathMatcher.class));
			}
		}
		else {
			BeanDefinitionBuilder mspp = BeanDefinitionBuilder
					.rootBeanDefinition(MessageSecurityPostProcessor.class);
			mspp.addConstructorArgValue(inSecurityInterceptorName);
			mspp.addConstructorArgValue(sameOriginDisabled);
			context.registerWithGeneratedName(mspp.getBeanDefinition());
		}

		return null;
	}

	private BeanDefinition createMatcher(String matcherPattern, String messageType,
			ParserContext parserContext, Element interceptMessage) {
		boolean hasPattern = StringUtils.hasText(matcherPattern);
		boolean hasMessageType = StringUtils.hasText(messageType);
		if (!hasPattern) {
			BeanDefinitionBuilder matcher = BeanDefinitionBuilder
					.rootBeanDefinition(SimpMessageTypeMatcher.class);
			matcher.addConstructorArgValue(messageType);
			return matcher.getBeanDefinition();
		}

		String factoryName = null;
		if (hasPattern && hasMessageType) {
			SimpMessageType type = SimpMessageType.valueOf(messageType);
			if (SimpMessageType.MESSAGE == type) {
				factoryName = "createMessageMatcher";
			}
			else if (SimpMessageType.SUBSCRIBE == type) {
				factoryName = "createSubscribeMatcher";
			}
			else {
				parserContext
						.getReaderContext()
						.error("Cannot use intercept-websocket@message-type="
								+ messageType
								+ " with a pattern because the type does not have a destination.",
								interceptMessage);
			}
		}

		BeanDefinitionBuilder matcher = BeanDefinitionBuilder
				.rootBeanDefinition(SimpDestinationMessageMatcher.class);
		matcher.setFactoryMethod(factoryName);
		matcher.addConstructorArgValue(matcherPattern);
		matcher.addConstructorArgValue(new RuntimeBeanReference("springSecurityMessagePathMatcher"));
		return matcher.getBeanDefinition();
	}

	static class MessageSecurityPostProcessor implements
			BeanDefinitionRegistryPostProcessor {


		private static final String WEB_SOCKET_AMMH_CLASS_NAME = "org.springframework.web.socket.messaging.WebSocketAnnotationMethodMessageHandler";

		private static final String CLIENT_INBOUND_CHANNEL_BEAN_ID = "clientInboundChannel";

		private static final String INTERCEPTORS_PROP = "interceptors";

		private static final String CUSTOM_ARG_RESOLVERS_PROP = "customArgumentResolvers";

		private final String inboundSecurityInterceptorId;

		private final boolean sameOriginDisabled;

		public MessageSecurityPostProcessor(String inboundSecurityInterceptorId,
				boolean sameOriginDisabled) {
			this.inboundSecurityInterceptorId = inboundSecurityInterceptorId;
			this.sameOriginDisabled = sameOriginDisabled;
		}

		public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)
				throws BeansException {
			String[] beanNames = registry.getBeanDefinitionNames();
			for (String beanName : beanNames) {
				BeanDefinition bd = registry.getBeanDefinition(beanName);
				String beanClassName = bd.getBeanClassName();
				if (beanClassName.equals(SimpAnnotationMethodMessageHandler.class
						.getName()) || beanClassName.equals(WEB_SOCKET_AMMH_CLASS_NAME)) {
					PropertyValue current = bd.getPropertyValues().getPropertyValue(
							CUSTOM_ARG_RESOLVERS_PROP);
					ManagedList<Object> argResolvers = new ManagedList<Object>();
					if (current != null) {
						argResolvers.addAll((ManagedList<?>) current.getValue());
					}
					argResolvers.add(new RootBeanDefinition(
							AuthenticationPrincipalArgumentResolver.class));
					bd.getPropertyValues().add(CUSTOM_ARG_RESOLVERS_PROP, argResolvers);

					if(!registry.containsBeanDefinition(PATH_MATCHER_BEAN_NAME)) {
						PropertyValue pathMatcherProp = bd.getPropertyValues().getPropertyValue("pathMatcher");
						Object pathMatcher = pathMatcherProp == null ? null : pathMatcherProp.getValue();
						if(pathMatcher instanceof BeanReference) {
							registry.registerAlias(((BeanReference) pathMatcher).getBeanName(), PATH_MATCHER_BEAN_NAME);
						}
					}
				}
				else if (beanClassName
						.equals("org.springframework.web.socket.server.support.WebSocketHttpRequestHandler")) {
					addCsrfTokenHandshakeInterceptor(bd);
				}
				else if (beanClassName
						.equals("org.springframework.web.socket.sockjs.transport.TransportHandlingSockJsService")) {
					addCsrfTokenHandshakeInterceptor(bd);
				}
				else if (beanClassName
						.equals("org.springframework.web.socket.sockjs.transport.handler.DefaultSockJsService")) {
					addCsrfTokenHandshakeInterceptor(bd);
				}
			}

			if (!registry.containsBeanDefinition(CLIENT_INBOUND_CHANNEL_BEAN_ID)) {
				return;
			}
			ManagedList<Object> interceptors = new ManagedList();
			interceptors.add(new RootBeanDefinition(
					SecurityContextChannelInterceptor.class));
			if (!sameOriginDisabled) {
				interceptors.add(new RootBeanDefinition(CsrfChannelInterceptor.class));
			}
			interceptors.add(registry.getBeanDefinition(inboundSecurityInterceptorId));

			BeanDefinition inboundChannel = registry
					.getBeanDefinition(CLIENT_INBOUND_CHANNEL_BEAN_ID);
			PropertyValue currentInterceptorsPv = inboundChannel.getPropertyValues()
					.getPropertyValue(INTERCEPTORS_PROP);
			if (currentInterceptorsPv != null) {
				ManagedList<?> currentInterceptors = (ManagedList<?>) currentInterceptorsPv
						.getValue();
				interceptors.addAll(currentInterceptors);
			}

			inboundChannel.getPropertyValues().add(INTERCEPTORS_PROP, interceptors);

			if(!registry.containsBeanDefinition(PATH_MATCHER_BEAN_NAME)) {
				registry.registerBeanDefinition(PATH_MATCHER_BEAN_NAME, new RootBeanDefinition(AntPathMatcher.class));
			}
		}

		private void addCsrfTokenHandshakeInterceptor(BeanDefinition bd) {
			if (sameOriginDisabled) {
				return;
			}
			String interceptorPropertyName = "handshakeInterceptors";
			ManagedList<? super Object> interceptors = new ManagedList<Object>();
			interceptors.add(new RootBeanDefinition(CsrfTokenHandshakeInterceptor.class));
			interceptors.addAll((ManagedList<Object>) bd.getPropertyValues().get(
					interceptorPropertyName));
			bd.getPropertyValues().add(interceptorPropertyName, interceptors);
		}

		public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)
				throws BeansException {

		}
	}

	static class DelegatingPathMatcher implements PathMatcher {

		private PathMatcher delegate = new AntPathMatcher();

		public boolean isPattern(String path) {
			return delegate.isPattern(path);
		}

		public boolean match(String pattern, String path) {
			return delegate.match(pattern, path);
		}

		public boolean matchStart(String pattern, String path) {
			return delegate.matchStart(pattern, path);
		}

		public String extractPathWithinPattern(String pattern, String path) {
			return delegate.extractPathWithinPattern(pattern, path);
		}

		public Map<String, String> extractUriTemplateVariables(String pattern, String path) {
			return delegate.extractUriTemplateVariables(pattern, path);
		}

		public Comparator<String> getPatternComparator(String path) {
			return delegate.getPatternComparator(path);
		}

		public String combine(String pattern1, String pattern2) {
			return delegate.combine(pattern1, pattern2);
		}

		void setPathMatcher(PathMatcher pathMatcher) {
			this.delegate = pathMatcher;
		}
	}
}
<code block>

package org.springframework.security.config.annotation.web.socket;

import static org.fest.assertions.Assertions.assertThat;
import static org.junit.Assert.fail;

import java.util.HashMap;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.core.MethodParameter;
import org.springframework.http.server.ServerHttpRequest;
import org.springframework.http.server.ServerHttpResponse;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageChannel;
import org.springframework.messaging.MessageDeliveryException;
import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.messaging.handler.invocation.HandlerMethodArgumentResolver;
import org.springframework.messaging.simp.SimpMessageHeaderAccessor;
import org.springframework.messaging.simp.SimpMessageType;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.messaging.support.GenericMessage;
import org.springframework.mock.web.MockHttpServletRequest;
import org.springframework.mock.web.MockHttpServletResponse;
import org.springframework.mock.web.MockServletConfig;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.access.expression.SecurityExpressionHandler;
import org.springframework.security.access.expression.SecurityExpressionOperations;
import org.springframework.security.authentication.TestingAuthenticationToken;
import org.springframework.security.config.annotation.web.messaging.MessageSecurityMetadataSourceRegistry;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.messaging.access.expression.DefaultMessageSecurityExpressionHandler;
import org.springframework.security.messaging.access.expression.MessageSecurityExpressionRoot;
import org.springframework.security.web.csrf.CsrfToken;
import org.springframework.security.web.csrf.DefaultCsrfToken;
import org.springframework.security.web.csrf.MissingCsrfTokenException;
import org.springframework.stereotype.Controller;
import org.springframework.test.util.ReflectionTestUtils;
import org.springframework.util.AntPathMatcher;
import org.springframework.web.HttpRequestHandler;
import org.springframework.web.context.support.AnnotationConfigWebApplicationContext;
import org.springframework.web.servlet.HandlerMapping;
import org.springframework.web.socket.WebSocketHandler;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
import org.springframework.web.socket.server.HandshakeFailureException;
import org.springframework.web.socket.server.HandshakeHandler;
import org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor;
import org.springframework.web.socket.sockjs.transport.handler.SockJsWebSocketHandler;
import org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession;

public class AbstractSecurityWebSocketMessageBrokerConfigurerTests {
	AnnotationConfigWebApplicationContext context;

	TestingAuthenticationToken messageUser;

	CsrfToken token;

	String sessionAttr;

	@Before
	public void setup() {
		token = new DefaultCsrfToken("header", "param", "token");
		sessionAttr = "sessionAttr";
		messageUser = new TestingAuthenticationToken("user", "pass", "ROLE_USER");
	}

	@After
	public void cleanup() {
		if (context != null) {
			context.close();
		}
	}

	@Test
	public void simpleRegistryMappings() {
		loadConfig(SockJsSecurityConfig.class);

		clientInboundChannel().send(message("/permitAll"));

		try {
			clientInboundChannel().send(message("/denyAll"));
			fail("Expected Exception");
		}
		catch (MessageDeliveryException expected) {
			assertThat(expected.getCause()).isInstanceOf(AccessDeniedException.class);
		}
	}

	@Test
	public void annonymousSupported() {
		loadConfig(SockJsSecurityConfig.class);

		messageUser = null;
		clientInboundChannel().send(message("/permitAll"));
	}

	@Test
	public void addsAuthenticationPrincipalResolver() throws InterruptedException {
		loadConfig(SockJsSecurityConfig.class);

		MessageChannel messageChannel = clientInboundChannel();
		Message<String> message = message("/permitAll/authentication");
		messageChannel.send(message);

		assertThat(context.getBean(MyController.class).authenticationPrincipal)
				.isEqualTo((String) messageUser.getPrincipal());
	}

	@Test
	public void addsAuthenticationPrincipalResolverWhenNoAuthorization()
			throws InterruptedException {
		loadConfig(NoInboundSecurityConfig.class);

		MessageChannel messageChannel = clientInboundChannel();
		Message<String> message = message("/permitAll/authentication");
		messageChannel.send(message);

		assertThat(context.getBean(MyController.class).authenticationPrincipal)
				.isEqualTo((String) messageUser.getPrincipal());
	}

	@Test
	public void addsCsrfProtectionWhenNoAuthorization() throws InterruptedException {
		loadConfig(NoInboundSecurityConfig.class);

		SimpMessageHeaderAccessor headers = SimpMessageHeaderAccessor
				.create(SimpMessageType.CONNECT);
		Message<?> message = message(headers, "/authentication");
		MessageChannel messageChannel = clientInboundChannel();

		try {
			messageChannel.send(message);
			fail("Expected Exception");
		}
		catch (MessageDeliveryException success) {
			assertThat(success.getCause()).isInstanceOf(MissingCsrfTokenException.class);
		}
	}

	@Test
	public void csrfProtectionForConnect() throws InterruptedException {
		loadConfig(SockJsSecurityConfig.class);

		SimpMessageHeaderAccessor headers = SimpMessageHeaderAccessor
				.create(SimpMessageType.CONNECT);
		Message<?> message = message(headers, "/authentication");
		MessageChannel messageChannel = clientInboundChannel();

		try {
			messageChannel.send(message);
			fail("Expected Exception");
		}
		catch (MessageDeliveryException success) {
			assertThat(success.getCause()).isInstanceOf(MissingCsrfTokenException.class);
		}
	}

	@Test
	public void csrfProtectionDisabledForConnect() throws InterruptedException {
		loadConfig(CsrfDisabledSockJsSecurityConfig.class);

		SimpMessageHeaderAccessor headers = SimpMessageHeaderAccessor
				.create(SimpMessageType.CONNECT);
		Message<?> message = message(headers, "/permitAll/connect");
		MessageChannel messageChannel = clientInboundChannel();

		messageChannel.send(message);
	}

	@Test
	public void messagesConnectUseCsrfTokenHandshakeInterceptor() throws Exception {

		loadConfig(SockJsSecurityConfig.class);

		SimpMessageHeaderAccessor headers = SimpMessageHeaderAccessor
				.create(SimpMessageType.CONNECT);
		Message<?> message = message(headers, "/authentication");
		MockHttpServletRequest request = sockjsHttpRequest("/chat");
		HttpRequestHandler handler = handler(request);

		handler.handleRequest(request, new MockHttpServletResponse());

		assertHandshake(request);
	}

	@Test
	public void messagesConnectUseCsrfTokenHandshakeInterceptorMultipleMappings()
			throws Exception {
		loadConfig(SockJsSecurityConfig.class);

		SimpMessageHeaderAccessor headers = SimpMessageHeaderAccessor
				.create(SimpMessageType.CONNECT);
		Message<?> message = message(headers, "/authentication");
		MockHttpServletRequest request = sockjsHttpRequest("/other");
		HttpRequestHandler handler = handler(request);

		handler.handleRequest(request, new MockHttpServletResponse());

		assertHandshake(request);
	}

	@Test
	public void messagesConnectWebSocketUseCsrfTokenHandshakeInterceptor()
			throws Exception {
		loadConfig(WebSocketSecurityConfig.class);

		SimpMessageHeaderAccessor headers = SimpMessageHeaderAccessor
				.create(SimpMessageType.CONNECT);
		Message<?> message = message(headers, "/authentication");
		MockHttpServletRequest request = websocketHttpRequest("/websocket");
		HttpRequestHandler handler = handler(request);

		handler.handleRequest(request, new MockHttpServletResponse());

		assertHandshake(request);
	}

	@Test
	public void msmsRegistryCustomPatternMatcher()
			throws Exception {
		loadConfig(MsmsRegistryCustomPatternMatcherConfig.class);

		clientInboundChannel().send(message("/app/a.b"));

		try {
			clientInboundChannel().send(message("/app/a.b.c"));
			fail("Expected Exception");
		}
		catch (MessageDeliveryException expected) {
			assertThat(expected.getCause()).isInstanceOf(AccessDeniedException.class);
		}
	}

	@Configuration
	@EnableWebSocketMessageBroker
	@Import(SyncExecutorConfig.class)
	static class MsmsRegistryCustomPatternMatcherConfig extends
			AbstractSecurityWebSocketMessageBrokerConfigurer {


		public void registerStompEndpoints(StompEndpointRegistry registry) {
			registry
				.addEndpoint("/other")
				.setHandshakeHandler(testHandshakeHandler());
		}



		@Override
		protected void configureInbound(MessageSecurityMetadataSourceRegistry messages) {
			messages
				.simpDestMatchers("/app/a.*").permitAll()
				.anyMessage().denyAll();
		}


		@Override
		public void configureMessageBroker(MessageBrokerRegistry registry) {
			registry.setPathMatcher(new AntPathMatcher("."));
			registry.enableSimpleBroker("/queue/", "/topic/");
			registry.setApplicationDestinationPrefixes("/app");
		}

		@Bean
		public TestHandshakeHandler testHandshakeHandler() {
			return new TestHandshakeHandler();
		}
	}

	@Test
	public void overrideMsmsRegistryCustomPatternMatcher()
			throws Exception {
		loadConfig(OverrideMsmsRegistryCustomPatternMatcherConfig.class);

		clientInboundChannel().send(message("/app/a/b"));

		try {
			clientInboundChannel().send(message("/app/a/b/c"));
			fail("Expected Exception");
		}
		catch (MessageDeliveryException expected) {
			assertThat(expected.getCause()).isInstanceOf(AccessDeniedException.class);
		}
	}

	@Configuration
	@EnableWebSocketMessageBroker
	@Import(SyncExecutorConfig.class)
	static class OverrideMsmsRegistryCustomPatternMatcherConfig extends
			AbstractSecurityWebSocketMessageBrokerConfigurer {


		public void registerStompEndpoints(StompEndpointRegistry registry) {
			registry
				.addEndpoint("/other")
				.setHandshakeHandler(testHandshakeHandler());
		}




		@Override
		protected void configureInbound(MessageSecurityMetadataSourceRegistry messages) {
			messages
				.simpDestPathMatcher(new AntPathMatcher())
				.simpDestMatchers("/app/a/*").permitAll()
				.anyMessage().denyAll();
		}


		@Override
		public void configureMessageBroker(MessageBrokerRegistry registry) {
			registry.setPathMatcher(new AntPathMatcher("."));
			registry.enableSimpleBroker("/queue/", "/topic/");
			registry.setApplicationDestinationPrefixes("/app");
		}

		@Bean
		public TestHandshakeHandler testHandshakeHandler() {
			return new TestHandshakeHandler();
		}
	}

	@Test
	public void defaultPatternMatcher()
			throws Exception {
		loadConfig(DefaultPatternMatcherConfig.class);

		clientInboundChannel().send(message("/app/a/b"));

		try {
			clientInboundChannel().send(message("/app/a/b/c"));
			fail("Expected Exception");
		}
		catch (MessageDeliveryException expected) {
			assertThat(expected.getCause()).isInstanceOf(AccessDeniedException.class);
		}
	}

	@Configuration
	@EnableWebSocketMessageBroker
	@Import(SyncExecutorConfig.class)
	static class DefaultPatternMatcherConfig extends
			AbstractSecurityWebSocketMessageBrokerConfigurer {


		public void registerStompEndpoints(StompEndpointRegistry registry) {
			registry
				.addEndpoint("/other")
				.setHandshakeHandler(testHandshakeHandler());
		}



		@Override
		protected void configureInbound(MessageSecurityMetadataSourceRegistry messages) {
			messages
				.simpDestMatchers("/app/a/*").permitAll()
				.anyMessage().denyAll();
		}


		@Override
		public void configureMessageBroker(MessageBrokerRegistry registry) {
			registry.enableSimpleBroker("/queue/", "/topic/");
			registry.setApplicationDestinationPrefixes("/app");
		}

		@Bean
		public TestHandshakeHandler testHandshakeHandler() {
			return new TestHandshakeHandler();
		}
	}

	@Test
	public void customExpression()
			throws Exception {
		loadConfig(CustomExpressionConfig.class);

		clientInboundChannel().send(message("/denyRob"));

		this.messageUser = new TestingAuthenticationToken("rob", "password", "ROLE_USER");
		try {
			clientInboundChannel().send(message("/denyRob"));
			fail("Expected Exception");
		}
		catch (MessageDeliveryException expected) {
			assertThat(expected.getCause()).isInstanceOf(AccessDeniedException.class);
		}
	}

	@Configuration
	@EnableWebSocketMessageBroker
	@Import(SyncExecutorConfig.class)
	static class CustomExpressionConfig extends
			AbstractSecurityWebSocketMessageBrokerConfigurer {


		public void registerStompEndpoints(StompEndpointRegistry registry) {
			registry
				.addEndpoint("/other")
				.setHandshakeHandler(testHandshakeHandler());
		}



		@Override
		protected void configureInbound(MessageSecurityMetadataSourceRegistry messages) {
			messages
				.anyMessage().access("denyRob()");
		}


		@Bean
		public SecurityExpressionHandler<Message<Object>> messageSecurityExpressionHandler() {
			return new DefaultMessageSecurityExpressionHandler<Object>() {
				@Override
				protected SecurityExpressionOperations createSecurityExpressionRoot(
						Authentication authentication,
						Message<Object> invocation) {
					return new MessageSecurityExpressionRoot(authentication, invocation) {
						public boolean denyRob() {
							Authentication auth = getAuthentication();
							return auth != null && !"rob".equals(auth.getName());
						}
					};
				}
			};
		}

		@Override
		public void configureMessageBroker(MessageBrokerRegistry registry) {
			registry.enableSimpleBroker("/queue/", "/topic/");
			registry.setApplicationDestinationPrefixes("/app");
		}

		@Bean
		public TestHandshakeHandler testHandshakeHandler() {
			return new TestHandshakeHandler();
		}
	}

	private void assertHandshake(HttpServletRequest request) {
		TestHandshakeHandler handshakeHandler = context
				.getBean(TestHandshakeHandler.class);
		assertThat(handshakeHandler.attributes.get(CsrfToken.class.getName())).isSameAs(
				token);
		assertThat(handshakeHandler.attributes.get(sessionAttr)).isEqualTo(
				request.getSession().getAttribute(sessionAttr));
	}

	private HttpRequestHandler handler(HttpServletRequest request) throws Exception {
		HandlerMapping handlerMapping = context.getBean(HandlerMapping.class);
		return (HttpRequestHandler) handlerMapping.getHandler(request).getHandler();
	}

	private MockHttpServletRequest websocketHttpRequest(String mapping) {
		MockHttpServletRequest request = sockjsHttpRequest(mapping);
		request.setRequestURI(mapping);
		return request;
	}

	private MockHttpServletRequest sockjsHttpRequest(String mapping) {
		MockHttpServletRequest request = new MockHttpServletRequest();
		request.setMethod("GET");
		request.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE,
				"/289/tpyx6mde/websocket");
		request.setRequestURI(mapping + "/289/tpyx6mde/websocket");
		request.getSession().setAttribute(sessionAttr, "sessionValue");

		request.setAttribute(CsrfToken.class.getName(), token);
		return request;
	}

	private Message<String> message(String destination) {
		SimpMessageHeaderAccessor headers = SimpMessageHeaderAccessor.create();
		return message(headers, destination);
	}

	private Message<String> message(SimpMessageHeaderAccessor headers, String destination) {
		headers.setSessionId("123");
		headers.setSessionAttributes(new HashMap<String, Object>());
		if (destination != null) {
			headers.setDestination(destination);
		}
		if (messageUser != null) {
			headers.setUser(messageUser);
		}
		return new GenericMessage<String>("hi", headers.getMessageHeaders());
	}

	private MessageChannel clientInboundChannel() {
		return context.getBean("clientInboundChannel", MessageChannel.class);
	}

	private void loadConfig(Class<?>... configs) {
		context = new AnnotationConfigWebApplicationContext();
		context.register(configs);
		context.setServletConfig(new MockServletConfig());
		context.refresh();
	}

	@Controller
	static class MyController {

		String authenticationPrincipal;
		MyCustomArgument myCustomArgument;

		@MessageMapping("/authentication")
		public void authentication(@AuthenticationPrincipal String un) {
			this.authenticationPrincipal = un;
		}

		@MessageMapping("/myCustom")
		public void myCustom(MyCustomArgument myCustomArgument) {
			this.myCustomArgument = myCustomArgument;
		}
	}

	static class MyCustomArgument {
		MyCustomArgument(String notDefaultConstr) {
		}
	}

	static class MyCustomArgumentResolver implements HandlerMethodArgumentResolver {

		public boolean supportsParameter(MethodParameter parameter) {
			return parameter.getParameterType().isAssignableFrom(MyCustomArgument.class);
		}

		public Object resolveArgument(MethodParameter parameter, Message<?> message)
				throws Exception {
			return new MyCustomArgument("");
		}
	}

	static class TestHandshakeHandler implements HandshakeHandler {
		Map<String, Object> attributes;

		public boolean doHandshake(ServerHttpRequest request,
				ServerHttpResponse response, WebSocketHandler wsHandler,
				Map<String, Object> attributes) throws HandshakeFailureException {
			this.attributes = attributes;
			if (wsHandler instanceof SockJsWebSocketHandler) {

				SockJsWebSocketHandler sockJs = (SockJsWebSocketHandler) wsHandler;
				WebSocketServerSockJsSession session = (WebSocketServerSockJsSession) ReflectionTestUtils
						.getField(sockJs, "sockJsSession");
				this.attributes = session.getAttributes();
			}
			return true;
		}
	}

	@Configuration
	@EnableWebSocketMessageBroker
	@Import(SyncExecutorConfig.class)
	static class SockJsSecurityConfig extends
			AbstractSecurityWebSocketMessageBrokerConfigurer {

		public void registerStompEndpoints(StompEndpointRegistry registry) {
			registry.addEndpoint("/other").setHandshakeHandler(testHandshakeHandler())
					.withSockJS().setInterceptors(new HttpSessionHandshakeInterceptor());

			registry.addEndpoint("/chat").setHandshakeHandler(testHandshakeHandler())
					.withSockJS().setInterceptors(new HttpSessionHandshakeInterceptor());
		}


		@Override
		protected void configureInbound(MessageSecurityMetadataSourceRegistry messages) {
			messages
				.simpDestMatchers("/permitAll/**").permitAll()
				.anyMessage().denyAll();
		}


		@Override
		public void configureMessageBroker(MessageBrokerRegistry registry) {
			registry.enableSimpleBroker("/queue/", "/topic/");
			registry.setApplicationDestinationPrefixes("/permitAll", "/denyAll");
		}

		@Bean
		public MyController myController() {
			return new MyController();
		}

		@Bean
		public TestHandshakeHandler testHandshakeHandler() {
			return new TestHandshakeHandler();
		}
	}

	@Configuration
	@EnableWebSocketMessageBroker
	@Import(SyncExecutorConfig.class)
	static class NoInboundSecurityConfig extends
			AbstractSecurityWebSocketMessageBrokerConfigurer {

		public void registerStompEndpoints(StompEndpointRegistry registry) {
			registry.addEndpoint("/other").withSockJS()
					.setInterceptors(new HttpSessionHandshakeInterceptor());

			registry.addEndpoint("/chat").withSockJS()
					.setInterceptors(new HttpSessionHandshakeInterceptor());
		}

		@Override
		protected void configureInbound(MessageSecurityMetadataSourceRegistry messages) {
		}

		@Override
		public void configureMessageBroker(MessageBrokerRegistry registry) {
			registry.enableSimpleBroker("/queue/", "/topic/");
			registry.setApplicationDestinationPrefixes("/permitAll", "/denyAll");
		}

		@Bean
		public MyController myController() {
			return new MyController();
		}
	}

	@Configuration
	static class CsrfDisabledSockJsSecurityConfig extends SockJsSecurityConfig {

		@Override
		protected boolean sameOriginDisabled() {
			return true;
		}
	}

	@Configuration
	@EnableWebSocketMessageBroker
	@Import(SyncExecutorConfig.class)
	static class WebSocketSecurityConfig extends
			AbstractSecurityWebSocketMessageBrokerConfigurer {

		public void registerStompEndpoints(StompEndpointRegistry registry) {
			registry.addEndpoint("/websocket")
					.setHandshakeHandler(testHandshakeHandler())
					.addInterceptors(new HttpSessionHandshakeInterceptor());
		}


		@Override
		protected void configureInbound(MessageSecurityMetadataSourceRegistry messages) {
			messages
				.simpDestMatchers("/permitAll/**").permitAll()
				.simpDestMatchers("/customExpression/**").access("denyRob")
				.anyMessage().denyAll();
		}


		@Bean
		public TestHandshakeHandler testHandshakeHandler() {
			return new TestHandshakeHandler();
		}
	}

	@Configuration
	static class SyncExecutorConfig {
		@Bean
		public static SyncExecutorSubscribableChannelPostProcessor postProcessor() {
			return new SyncExecutorSubscribableChannelPostProcessor();
		}
	}
}
<code block>

package org.springframework.security.web.context;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.Locale;

import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpServletResponseWrapper;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;


public abstract class SaveContextOnUpdateOrErrorResponseWrapper extends HttpServletResponseWrapper {
    private final Log logger = LogFactory.getLog(getClass());

    private boolean disableSaveOnResponseCommitted;

    private boolean contextSaved = false;

    private final boolean disableUrlRewriting;


    public SaveContextOnUpdateOrErrorResponseWrapper(HttpServletResponse response, boolean disableUrlRewriting) {
        super(response);
        this.disableUrlRewriting = disableUrlRewriting;
    }


    public void disableSaveOnResponseCommitted() {
        this.disableSaveOnResponseCommitted = true;
    }


    protected abstract void saveContext(SecurityContext context);


    @Override
    public final void sendError(int sc) throws IOException {
        doSaveContext();
        super.sendError(sc);
    }


    @Override
    public final void sendError(int sc, String msg) throws IOException {
        doSaveContext();
        super.sendError(sc, msg);
    }


    @Override
    public final void sendRedirect(String location) throws IOException {
        doSaveContext();
        super.sendRedirect(location);
    }


    @Override
    public ServletOutputStream getOutputStream() throws IOException {
        return new SaveContextServletOutputStream(super.getOutputStream());
    }


    @Override
    public PrintWriter getWriter() throws IOException {
        return new SaveContextPrintWriter(super.getWriter());
    }


    @Override
    public void flushBuffer() throws IOException {
        doSaveContext();
        super.flushBuffer();
    }


    private void doSaveContext() {
        if(!disableSaveOnResponseCommitted) {
            saveContext(SecurityContextHolder.getContext());
            contextSaved = true;
        } else if(logger.isDebugEnabled()){
            logger.debug("Skip saving SecurityContext since saving on response commited is disabled");
        }
    }

    @Override
    public final String encodeRedirectUrl(String url) {
        if (disableUrlRewriting) {
            return url;
        }
        return super.encodeRedirectUrl(url);
    }

    @Override
    public final String encodeRedirectURL(String url) {
        if (disableUrlRewriting) {
            return url;
        }
        return super.encodeRedirectURL(url);
    }

    @Override
    public final String encodeUrl(String url) {
        if (disableUrlRewriting) {
            return url;
        }
        return super.encodeUrl(url);
    }

    @Override
    public final String encodeURL(String url) {
        if (disableUrlRewriting) {
            return url;
        }
        return super.encodeURL(url);
    }


    public final boolean isContextSaved() {
        return contextSaved;
    }


    private class SaveContextPrintWriter extends PrintWriter {
        private final PrintWriter delegate;

        public SaveContextPrintWriter(PrintWriter delegate) {
            super(delegate);
            this.delegate = delegate;
        }

        public void flush() {
            doSaveContext();
            delegate.flush();
        }

        public void close() {
            doSaveContext();
            delegate.close();
        }

        public int hashCode() {
            return delegate.hashCode();
        }

        public boolean equals(Object obj) {
            return delegate.equals(obj);
        }

        public String toString() {
            return getClass().getName() + "[delegate=" + delegate.toString() + "]";
        }

        public boolean checkError() {
            return delegate.checkError();
        }

        public void write(int c) {
            delegate.write(c);
        }

        public void write(char[] buf, int off, int len) {
            delegate.write(buf, off, len);
        }

        public void write(char[] buf) {
            delegate.write(buf);
        }

        public void write(String s, int off, int len) {
            delegate.write(s, off, len);
        }

        public void write(String s) {
            delegate.write(s);
        }

        public void print(boolean b) {
            delegate.print(b);
        }

        public void print(char c) {
            delegate.print(c);
        }

        public void print(int i) {
            delegate.print(i);
        }

        public void print(long l) {
            delegate.print(l);
        }

        public void print(float f) {
            delegate.print(f);
        }

        public void print(double d) {
            delegate.print(d);
        }

        public void print(char[] s) {
            delegate.print(s);
        }

        public void print(String s) {
            delegate.print(s);
        }

        public void print(Object obj) {
            delegate.print(obj);
        }

        public void println() {
            delegate.println();
        }

        public void println(boolean x) {
            delegate.println(x);
        }

        public void println(char x) {
            delegate.println(x);
        }

        public void println(int x) {
            delegate.println(x);
        }

        public void println(long x) {
            delegate.println(x);
        }

        public void println(float x) {
            delegate.println(x);
        }

        public void println(double x) {
            delegate.println(x);
        }

        public void println(char[] x) {
            delegate.println(x);
        }

        public void println(String x) {
            delegate.println(x);
        }

        public void println(Object x) {
            delegate.println(x);
        }

        public PrintWriter printf(String format, Object... args) {
            return delegate.printf(format, args);
        }

        public PrintWriter printf(Locale l, String format, Object... args) {
            return delegate.printf(l, format, args);
        }

        public PrintWriter format(String format, Object... args) {
            return delegate.format(format, args);
        }

        public PrintWriter format(Locale l, String format, Object... args) {
            return delegate.format(l, format, args);
        }

        public PrintWriter append(CharSequence csq) {
            return delegate.append(csq);
        }

        public PrintWriter append(CharSequence csq, int start, int end) {
            return delegate.append(csq, start, end);
        }

        public PrintWriter append(char c) {
            return delegate.append(c);
        }
    }


    private class SaveContextServletOutputStream extends ServletOutputStream {
        private final ServletOutputStream delegate;

        public SaveContextServletOutputStream(ServletOutputStream delegate) {
            this.delegate = delegate;
        }

        public void write(int b) throws IOException {
            this.delegate.write(b);
        }

        public void flush() throws IOException {
            doSaveContext();
            delegate.flush();
        }

        public void close() throws IOException {
            doSaveContext();
            delegate.close();
        }

        public int hashCode() {
            return delegate.hashCode();
        }

        public boolean equals(Object obj) {
            return delegate.equals(obj);
        }

        public void print(boolean b) throws IOException {
            delegate.print(b);
        }

        public void print(char c) throws IOException {
            delegate.print(c);
        }

        public void print(double d) throws IOException {
            delegate.print(d);
        }

        public void print(float f) throws IOException {
            delegate.print(f);
        }

        public void print(int i) throws IOException {
            delegate.print(i);
        }

        public void print(long l) throws IOException {
            delegate.print(l);
        }

        public void print(String arg0) throws IOException {
            delegate.print(arg0);
        }

        public void println() throws IOException {
            delegate.println();
        }

        public void println(boolean b) throws IOException {
            delegate.println(b);
        }

        public void println(char c) throws IOException {
            delegate.println(c);
        }

        public void println(double d) throws IOException {
            delegate.println(d);
        }

        public void println(float f) throws IOException {
            delegate.println(f);
        }

        public void println(int i) throws IOException {
            delegate.println(i);
        }

        public void println(long l) throws IOException {
            delegate.println(l);
        }

        public void println(String s) throws IOException {
            delegate.println(s);
        }

        public void write(byte[] b) throws IOException {
            delegate.write(b);
        }

        public void write(byte[] b, int off, int len) throws IOException {
            delegate.write(b, off, len);
        }

        public String toString() {
            return getClass().getName() + "[delegate=" + delegate.toString() + "]";
        }
    }
}

<code block>

package org.springframework.security.web.context;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpServletResponseWrapper;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Locale;


abstract class OnCommittedResponseWrapper extends HttpServletResponseWrapper {
    private final Log logger = LogFactory.getLog(getClass());

    private boolean disableOnCommitted;


    private long contentLength;


    private long contentWritten;


    public OnCommittedResponseWrapper(HttpServletResponse response) {
        super(response);
    }

    @Override
    public void addHeader(String name, String value) {
        if("Content-Length".equalsIgnoreCase(name)) {
            setContentLength(Long.parseLong(value));
        }
        super.addHeader(name, value);
    }

    @Override
    public void setContentLength(int len) {
        setContentLength((long) len);
        super.setContentLength(len);
    }

    private void setContentLength(long len) {
        this.contentLength = len;
        checkContentLength(0);
    }


    public void disableOnResponseCommitted() {
        this.disableOnCommitted = true;
    }


    protected abstract void onResponseCommitted();


    @Override
    public final void sendError(int sc) throws IOException {
        doOnResponseCommitted();
        super.sendError(sc);
    }


    @Override
    public final void sendError(int sc, String msg) throws IOException {
        doOnResponseCommitted();
        super.sendError(sc, msg);
    }


    @Override
    public final void sendRedirect(String location) throws IOException {
        doOnResponseCommitted();
        super.sendRedirect(location);
    }


    @Override
    public ServletOutputStream getOutputStream() throws IOException {
        return new SaveContextServletOutputStream(super.getOutputStream());
    }


    @Override
    public PrintWriter getWriter() throws IOException {
        return new SaveContextPrintWriter(super.getWriter());
    }


    @Override
    public void flushBuffer() throws IOException {
        doOnResponseCommitted();
        super.flushBuffer();
    }

    private void trackContentLength(boolean content) {
        checkContentLength(content ? 4 : 5); 
    }

    private void trackContentLength(char content) {
        checkContentLength(1);
    }

    private void trackContentLength(Object content) {
        trackContentLength(String.valueOf(content));
    }

    private void trackContentLength(byte[] content) {
        checkContentLength(content == null ? 0 : content.length);
    }

    private void trackContentLength(char[] content) {
        checkContentLength(content == null ? 0 : content.length);
    }

    private void trackContentLength(int content) {
        trackContentLength(String.valueOf(content));
    }

    private void trackContentLength(float content) {
        trackContentLength(String.valueOf(content));
    }

    private void trackContentLength(double content) {
        trackContentLength(String.valueOf(content));
    }

    private void trackContentLengthLn() {
        trackContentLength("\r\n");
    }

    private void trackContentLength(String content) {
        checkContentLength(content.length());
    }


    private void checkContentLength(long contentLengthToWrite) {
        contentWritten += contentLengthToWrite;
        boolean isBodyFullyWritten = contentLength > 0  && contentWritten >= contentLength;
        int bufferSize = getBufferSize();
        boolean requiresFlush = bufferSize > 0 && contentWritten >= bufferSize;
        if(isBodyFullyWritten || requiresFlush) {
            doOnResponseCommitted();
        }
    }


    private void doOnResponseCommitted() {
        if(!disableOnCommitted) {
            onResponseCommitted();
            disableOnResponseCommitted();
        } else if(logger.isDebugEnabled()){
            logger.debug("Skip invoking on");
        }
    }


    private class SaveContextPrintWriter extends PrintWriter {
        private final PrintWriter delegate;

        public SaveContextPrintWriter(PrintWriter delegate) {
            super(delegate);
            this.delegate = delegate;
        }

        public void flush() {
            doOnResponseCommitted();
            delegate.flush();
        }

        public void close() {
            doOnResponseCommitted();
            delegate.close();
        }

        public int hashCode() {
            return delegate.hashCode();
        }

        public boolean equals(Object obj) {
            return delegate.equals(obj);
        }

        public String toString() {
            return getClass().getName() + "[delegate=" + delegate.toString() + "]";
        }

        public boolean checkError() {
            return delegate.checkError();
        }

        public void write(int c) {
            trackContentLength(c);
            delegate.write(c);
        }

        public void write(char[] buf, int off, int len) {
            checkContentLength(len);
            delegate.write(buf, off, len);
        }

        public void write(char[] buf) {
            trackContentLength(buf);
            delegate.write(buf);
        }

        public void write(String s, int off, int len) {
            checkContentLength(len);
            delegate.write(s, off, len);
        }

        public void write(String s) {
            trackContentLength(s);
            delegate.write(s);
        }

        public void print(boolean b) {
            trackContentLength(b);
            delegate.print(b);
        }

        public void print(char c) {
            trackContentLength(c);
            delegate.print(c);
        }

        public void print(int i) {
            trackContentLength(i);
            delegate.print(i);
        }

        public void print(long l) {
            trackContentLength(l);
            delegate.print(l);
        }

        public void print(float f) {
            trackContentLength(f);
            delegate.print(f);
        }

        public void print(double d) {
            trackContentLength(d);
            delegate.print(d);
        }

        public void print(char[] s) {
            trackContentLength(s);
            delegate.print(s);
        }

        public void print(String s) {
            trackContentLength(s);
            delegate.print(s);
        }

        public void print(Object obj) {
            trackContentLength(obj);
            delegate.print(obj);
        }

        public void println() {
            trackContentLengthLn();
            delegate.println();
        }

        public void println(boolean x) {
            trackContentLength(x);
            trackContentLengthLn();
            delegate.println(x);
        }

        public void println(char x) {
            trackContentLength(x);
            trackContentLengthLn();
            delegate.println(x);
        }

        public void println(int x) {
            trackContentLength(x);
            trackContentLengthLn();
            delegate.println(x);
        }

        public void println(long x) {
            trackContentLength(x);
            trackContentLengthLn();
            delegate.println(x);
        }

        public void println(float x) {
            trackContentLength(x);
            trackContentLengthLn();
            delegate.println(x);
        }

        public void println(double x) {
            trackContentLength(x);
            trackContentLengthLn();
            delegate.println(x);
        }

        public void println(char[] x) {
            trackContentLength(x);
            trackContentLengthLn();
            delegate.println(x);
        }

        public void println(String x) {
            trackContentLength(x);
            trackContentLengthLn();
            delegate.println(x);
        }

        public void println(Object x) {
            trackContentLength(x);
            trackContentLengthLn();
            delegate.println(x);
        }

        public PrintWriter printf(String format, Object... args) {
            return delegate.printf(format, args);
        }

        public PrintWriter printf(Locale l, String format, Object... args) {
            return delegate.printf(l, format, args);
        }

        public PrintWriter format(String format, Object... args) {
            return delegate.format(format, args);
        }

        public PrintWriter format(Locale l, String format, Object... args) {
            return delegate.format(l, format, args);
        }

        public PrintWriter append(CharSequence csq) {
            checkContentLength(csq.length());
            return delegate.append(csq);
        }

        public PrintWriter append(CharSequence csq, int start, int end) {
            checkContentLength(end - start);
            return delegate.append(csq, start, end);
        }

        public PrintWriter append(char c) {
            trackContentLength(c);
            return delegate.append(c);
        }
    }


    private class SaveContextServletOutputStream extends ServletOutputStream {
        private final ServletOutputStream delegate;

        public SaveContextServletOutputStream(ServletOutputStream delegate) {
            this.delegate = delegate;
        }

        public void write(int b) throws IOException {
            trackContentLength(b);
            this.delegate.write(b);
        }

        public void flush() throws IOException {
            doOnResponseCommitted();
            delegate.flush();
        }

        public void close() throws IOException {
            doOnResponseCommitted();
            delegate.close();
        }

        public int hashCode() {
            return delegate.hashCode();
        }

        public boolean equals(Object obj) {
            return delegate.equals(obj);
        }

        public void print(boolean b) throws IOException {
            trackContentLength(b);
            delegate.print(b);
        }

        public void print(char c) throws IOException {
            trackContentLength(c);
            delegate.print(c);
        }

        public void print(double d) throws IOException {
            trackContentLength(d);
            delegate.print(d);
        }

        public void print(float f) throws IOException {
            trackContentLength(f);
            delegate.print(f);
        }

        public void print(int i) throws IOException {
            trackContentLength(i);
            delegate.print(i);
        }

        public void print(long l) throws IOException {
            trackContentLength(l);
            delegate.print(l);
        }

        public void print(String s) throws IOException {
            trackContentLength(s);
            delegate.print(s);
        }

        public void println() throws IOException {
            trackContentLengthLn();
            delegate.println();
        }

        public void println(boolean b) throws IOException {
            trackContentLength(b);
            trackContentLengthLn();
            delegate.println(b);
        }

        public void println(char c) throws IOException {
            trackContentLength(c);
            trackContentLengthLn();
            delegate.println(c);
        }

        public void println(double d) throws IOException {
            trackContentLength(d);
            trackContentLengthLn();
            delegate.println(d);
        }

        public void println(float f) throws IOException {
            trackContentLength(f);
            trackContentLengthLn();
            delegate.println(f);
        }

        public void println(int i) throws IOException {
            trackContentLength(i);
            trackContentLengthLn();
            delegate.println(i);
        }

        public void println(long l) throws IOException {
            trackContentLength(l);
            trackContentLengthLn();
            delegate.println(l);
        }

        public void println(String s) throws IOException {
            trackContentLength(s);
            trackContentLengthLn();
            delegate.println(s);
        }

        public void write(byte[] b) throws IOException {
            trackContentLength(b);
            delegate.write(b);
        }

        public void write(byte[] b, int off, int len) throws IOException {
            checkContentLength(len);
            delegate.write(b, off, len);
        }

        public String toString() {
            return getClass().getName() + "[delegate=" + delegate.toString() + "]";
        }
    }
}
<code block>

package org.springframework.security.web.context;

import javax.servlet.http.HttpServletResponse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;


public abstract class SaveContextOnUpdateOrErrorResponseWrapper extends
        OnCommittedResponseWrapper {
    private final Log logger = LogFactory.getLog(getClass());


    private boolean contextSaved = false;

    private final boolean disableUrlRewriting;


    public SaveContextOnUpdateOrErrorResponseWrapper(HttpServletResponse response,
            boolean disableUrlRewriting) {
        super(response);
        this.disableUrlRewriting = disableUrlRewriting;
    }


    public void disableSaveOnResponseCommitted() {
        disableOnResponseCommitted();
    }


    protected abstract void saveContext(SecurityContext context);


    @Override
    protected void onResponseCommitted() {
        saveContext(SecurityContextHolder.getContext());
        contextSaved = true;
    }

    @Override
    public final String encodeRedirectUrl(String url) {
        if (disableUrlRewriting) {
            return url;
        }
        return super.encodeRedirectUrl(url);
    }

    @Override
    public final String encodeRedirectURL(String url) {
        if (disableUrlRewriting) {
            return url;
        }
        return super.encodeRedirectURL(url);
    }

    @Override
    public final String encodeUrl(String url) {
        if (disableUrlRewriting) {
            return url;
        }
        return super.encodeUrl(url);
    }

    @Override
    public final String encodeURL(String url) {
        if (disableUrlRewriting) {
            return url;
        }
        return super.encodeURL(url);
    }


    public final boolean isContextSaved() {
        return contextSaved;
    }
}

<code block>

package org.springframework.security.web.context;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.Locale;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;

import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletResponse;

import static org.fest.assertions.Assertions.assertThat;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class OnCommittedResponseWrapperTests {
    private static final String NL = "\r\n";

    @Mock
    HttpServletResponse delegate;
    @Mock
    PrintWriter writer;
    @Mock
    ServletOutputStream out;

    OnCommittedResponseWrapper response;

    boolean committed;

    @Before
    public void setup() throws Exception {
        response = new OnCommittedResponseWrapper(delegate) {
            @Override
            protected void onResponseCommitted() {
                committed = true;
            }
        };
        when(delegate.getWriter()).thenReturn(writer);
        when(delegate.getOutputStream()).thenReturn(out);
    }




    @Test
    public void printWriterHashCode() throws Exception {
        int expected = writer.hashCode();

        assertThat(response.getWriter().hashCode()).isEqualTo(expected);
    }

    @Test
    public void printWriterCheckError() throws Exception {
        boolean expected = true;
        when(writer.checkError()).thenReturn(expected);

        assertThat(response.getWriter().checkError()).isEqualTo(expected);
    }

    @Test
    public void printWriterWriteInt() throws Exception {
        int expected = 1;

        response.getWriter().write(expected);

        verify(writer).write(expected);
    }

    @Test
    public void printWriterWriteCharIntInt() throws Exception {
        char[] buff = new char[0];
        int off = 2;
        int len = 3;

        response.getWriter().write(buff,off,len);

        verify(writer).write(buff,off,len);
    }

    @Test
    public void printWriterWriteChar() throws Exception {
        char[] buff = new char[0];

        response.getWriter().write(buff);

        verify(writer).write(buff);
    }

    @Test
    public void printWriterWriteStringIntInt() throws Exception {
        String s = "";
        int off = 2;
        int len = 3;

        response.getWriter().write(s,off,len);

        verify(writer).write(s,off,len);
    }

    @Test
    public void printWriterWriteString() throws Exception {
        String s = "";

        response.getWriter().write(s);

        verify(writer).write(s);
    }

    @Test
    public void printWriterPrintBoolean() throws Exception {
        boolean b = true;

        response.getWriter().print(b);

        verify(writer).print(b);
    }

    @Test
    public void printWriterPrintChar() throws Exception {
        char c = 1;

        response.getWriter().print(c);

        verify(writer).print(c);
    }

    @Test
    public void printWriterPrintInt() throws Exception {
        int i = 1;

        response.getWriter().print(i);

        verify(writer).print(i);
    }

    @Test
    public void printWriterPrintLong() throws Exception {
        long l = 1;

        response.getWriter().print(l);

        verify(writer).print(l);
    }

    @Test
    public void printWriterPrintFloat() throws Exception {
        float f = 1;

        response.getWriter().print(f);

        verify(writer).print(f);
    }

    @Test
    public void printWriterPrintDouble() throws Exception {
        double x = 1;

        response.getWriter().print(x);

        verify(writer).print(x);
    }

    @Test
    public void printWriterPrintCharArray() throws Exception {
        char[] x = new char[0];

        response.getWriter().print(x);

        verify(writer).print(x);
    }

    @Test
    public void printWriterPrintString() throws Exception {
        String x = "1";

        response.getWriter().print(x);

        verify(writer).print(x);
    }

    @Test
    public void printWriterPrintObject() throws Exception {
        Object x = "1";

        response.getWriter().print(x);

        verify(writer).print(x);
    }

    @Test
    public void printWriterPrintln() throws Exception {
        response.getWriter().println();

        verify(writer).println();
    }

    @Test
    public void printWriterPrintlnBoolean() throws Exception {
        boolean b = true;

        response.getWriter().println(b);

        verify(writer).println(b);
    }

    @Test
    public void printWriterPrintlnChar() throws Exception {
        char c = 1;

        response.getWriter().println(c);

        verify(writer).println(c);
    }

    @Test
    public void printWriterPrintlnInt() throws Exception {
        int i = 1;

        response.getWriter().println(i);

        verify(writer).println(i);
    }

    @Test
    public void printWriterPrintlnLong() throws Exception {
        long l = 1;

        response.getWriter().println(l);

        verify(writer).println(l);
    }

    @Test
    public void printWriterPrintlnFloat() throws Exception {
        float f = 1;

        response.getWriter().println(f);

        verify(writer).println(f);
    }

    @Test
    public void printWriterPrintlnDouble() throws Exception {
        double x = 1;

        response.getWriter().println(x);

        verify(writer).println(x);
    }

    @Test
    public void printWriterPrintlnCharArray() throws Exception {
        char[] x = new char[0];

        response.getWriter().println(x);

        verify(writer).println(x);
    }

    @Test
    public void printWriterPrintlnString() throws Exception {
        String x = "1";

        response.getWriter().println(x);

        verify(writer).println(x);
    }

    @Test
    public void printWriterPrintlnObject() throws Exception {
        Object x = "1";

        response.getWriter().println(x);

        verify(writer).println(x);
    }

    @Test
    public void printWriterPrintfStringObjectVargs() throws Exception {
        String format = "format";
        Object[] args = new Object[] { "1" };

        response.getWriter().printf(format, args);

        verify(writer).printf(format, args);
    }

    @Test
    public void printWriterPrintfLocaleStringObjectVargs() throws Exception {
        Locale l = Locale.US;
        String format = "format";
        Object[] args = new Object[] { "1" };

        response.getWriter().printf(l, format, args);

        verify(writer).printf(l, format, args);
    }

    @Test
    public void printWriterFormatStringObjectVargs() throws Exception {
        String format = "format";
        Object[] args = new Object[] { "1" };

        response.getWriter().format(format, args);

        verify(writer).format(format, args);
    }

    @Test
    public void printWriterFormatLocaleStringObjectVargs() throws Exception {
        Locale l = Locale.US;
        String format = "format";
        Object[] args = new Object[] { "1" };

        response.getWriter().format(l, format, args);

        verify(writer).format(l, format, args);
    }


    @Test
    public void printWriterAppendCharSequence() throws Exception {
        String x = "a";

        response.getWriter().append(x);

        verify(writer).append(x);
    }

    @Test
    public void printWriterAppendCharSequenceIntInt() throws Exception {
        String x = "abcdef";
        int start = 1;
        int end = 3;

        response.getWriter().append(x, start, end);

        verify(writer).append(x, start, end);
    }


    @Test
    public void printWriterAppendChar() throws Exception {
        char x = 1;

        response.getWriter().append(x);

        verify(writer).append(x);
    }




    @Test
    public void outputStreamHashCode() throws Exception {
        int expected = out.hashCode();

        assertThat(response.getOutputStream().hashCode()).isEqualTo(expected);
    }

    @Test
    public void outputStreamWriteInt() throws Exception {
        int expected = 1;

        response.getOutputStream().write(expected);

        verify(out).write(expected);
    }

    @Test
    public void outputStreamWriteByte() throws Exception {
        byte[] expected = new byte[0];

        response.getOutputStream().write(expected);

        verify(out).write(expected);
    }

    @Test
    public void outputStreamWriteByteIntInt() throws Exception {
        int start = 1;
        int end = 2;
        byte[] expected = new byte[0];

        response.getOutputStream().write(expected, start, end);

        verify(out).write(expected, start, end);
    }

    @Test
    public void outputStreamPrintBoolean() throws Exception {
        boolean b = true;

        response.getOutputStream().print(b);

        verify(out).print(b);
    }

    @Test
    public void outputStreamPrintChar() throws Exception {
        char c = 1;

        response.getOutputStream().print(c);

        verify(out).print(c);
    }

    @Test
    public void outputStreamPrintInt() throws Exception {
        int i = 1;

        response.getOutputStream().print(i);

        verify(out).print(i);
    }

    @Test
    public void outputStreamPrintLong() throws Exception {
        long l = 1;

        response.getOutputStream().print(l);

        verify(out).print(l);
    }

    @Test
    public void outputStreamPrintFloat() throws Exception {
        float f = 1;

        response.getOutputStream().print(f);

        verify(out).print(f);
    }

    @Test
    public void outputStreamPrintDouble() throws Exception {
        double x = 1;

        response.getOutputStream().print(x);

        verify(out).print(x);
    }

    @Test
    public void outputStreamPrintString() throws Exception {
        String x = "1";

        response.getOutputStream().print(x);

        verify(out).print(x);
    }

    @Test
    public void outputStreamPrintln() throws Exception {
        response.getOutputStream().println();

        verify(out).println();
    }

    @Test
    public void outputStreamPrintlnBoolean() throws Exception {
        boolean b = true;

        response.getOutputStream().println(b);

        verify(out).println(b);
    }

    @Test
    public void outputStreamPrintlnChar() throws Exception {
        char c = 1;

        response.getOutputStream().println(c);

        verify(out).println(c);
    }

    @Test
    public void outputStreamPrintlnInt() throws Exception {
        int i = 1;

        response.getOutputStream().println(i);

        verify(out).println(i);
    }

    @Test
    public void outputStreamPrintlnLong() throws Exception {
        long l = 1;

        response.getOutputStream().println(l);

        verify(out).println(l);
    }

    @Test
    public void outputStreamPrintlnFloat() throws Exception {
        float f = 1;

        response.getOutputStream().println(f);

        verify(out).println(f);
    }

    @Test
    public void outputStreamPrintlnDouble() throws Exception {
        double x = 1;

        response.getOutputStream().println(x);

        verify(out).println(x);
    }

    @Test
    public void outputStreamPrintlnString() throws Exception {
        String x = "1";

        response.getOutputStream().println(x);

        verify(out).println(x);
    }




    @Test
    public void contentLengthPrintWriterWriteIntCommits() throws Exception {
        int expected = 1;
        response.setContentLength(String.valueOf(expected).length());

        response.getWriter().write(expected);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthPrintWriterWriteIntMultiDigitCommits() throws Exception {
        int expected = 10000;
        response.setContentLength(String.valueOf(expected).length());

        response.getWriter().write(expected);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthPlus1PrintWriterWriteIntMultiDigitCommits() throws Exception {
        int expected = 10000;
        response.setContentLength(String.valueOf(expected).length() + 1);

        response.getWriter().write(expected);

        assertThat(committed).isFalse();

        response.getWriter().write(1);

        assertThat(committed).isTrue();
    }


    @Test
    public void contentLengthPrintWriterWriteCharIntIntCommits() throws Exception {
        char[] buff = new char[0];
        int off = 2;
        int len = 3;
        response.setContentLength(3);

        response.getWriter().write(buff,off,len);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthPrintWriterWriteCharCommits() throws Exception {
        char[] buff = new char[4];
        response.setContentLength(buff.length);

        response.getWriter().write(buff);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthPrintWriterWriteStringIntIntCommits() throws Exception {
        String s = "";
        int off = 2;
        int len = 3;
        response.setContentLength(3);

        response.getWriter().write(s,off,len);

        assertThat(committed).isTrue();
    }


    @Test
    public void contentLengthPrintWriterWriteStringCommits() throws IOException {
        String body = "something";
        response.setContentLength(body.length());

        response.getWriter().write(body);

        assertThat(committed).isTrue();
    }

    @Test
    public void printWriterWriteStringContentLengthCommits() throws IOException {
        String body = "something";
        response.getWriter().write(body);

        response.setContentLength(body.length());

        assertThat(committed).isTrue();
    }

    @Test
    public void printWriterWriteStringDoesNotCommit() throws IOException {
        String body = "something";

        response.getWriter().write(body);

        assertThat(committed).isFalse();
    }

    @Test
    public void contentLengthPrintWriterPrintBooleanCommits() throws Exception {
        boolean b = true;
        response.setContentLength(1);

        response.getWriter().print(b);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthPrintWriterPrintCharCommits() throws Exception {
        char c = 1;
        response.setContentLength(1);

        response.getWriter().print(c);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthPrintWriterPrintIntCommits() throws Exception {
        int i = 1234;
        response.setContentLength(String.valueOf(i).length());

        response.getWriter().print(i);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthPrintWriterPrintLongCommits() throws Exception {
        long l = 12345;
        response.setContentLength(String.valueOf(l).length());

        response.getWriter().print(l);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthPrintWriterPrintFloatCommits() throws Exception {
        float f = 12345;
        response.setContentLength(String.valueOf(f).length());

        response.getWriter().print(f);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthPrintWriterPrintDoubleCommits() throws Exception {
        double x = 1.2345;
        response.setContentLength(String.valueOf(x).length());

        response.getWriter().print(x);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthPrintWriterPrintCharArrayCommits() throws Exception {
        char[] x = new char[10];
        response.setContentLength(x.length);

        response.getWriter().print(x);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthPrintWriterPrintStringCommits() throws Exception {
        String x = "12345";
        response.setContentLength(x.length());

        response.getWriter().print(x);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthPrintWriterPrintObjectCommits() throws Exception {
        Object x = "12345";
        response.setContentLength(String.valueOf(x).length());

        response.getWriter().print(x);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthPrintWriterPrintlnCommits() throws Exception {
        response.setContentLength(NL.length());

        response.getWriter().println();

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthPrintWriterPrintlnBooleanCommits() throws Exception {
        boolean b = true;
        response.setContentLength(1);

        response.getWriter().println(b);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthPrintWriterPrintlnCharCommits() throws Exception {
        char c = 1;
        response.setContentLength(1);

        response.getWriter().println(c);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthPrintWriterPrintlnIntCommits() throws Exception {
        int i = 12345;
        response.setContentLength(String.valueOf(i).length());

        response.getWriter().println(i);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthPrintWriterPrintlnLongCommits() throws Exception {
        long l = 12345678;
        response.setContentLength(String.valueOf(l).length());

        response.getWriter().println(l);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthPrintWriterPrintlnFloatCommits() throws Exception {
        float f = 1234;
        response.setContentLength(String.valueOf(f).length());

        response.getWriter().println(f);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthPrintWriterPrintlnDoubleCommits() throws Exception {
        double x = 1;
        response.setContentLength(String.valueOf(x).length());

        response.getWriter().println(x);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthPrintWriterPrintlnCharArrayCommits() throws Exception {
        char[] x = new char[20];
        response.setContentLength(x.length);

        response.getWriter().println(x);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthPrintWriterPrintlnStringCommits() throws Exception {
        String x = "1";
        response.setContentLength(String.valueOf(x).length());

        response.getWriter().println(x);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthPrintWriterPrintlnObjectCommits() throws Exception {
        Object x = "1";
        response.setContentLength(String.valueOf(x).length());

        response.getWriter().println(x);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthPrintWriterAppendCharSequenceCommits() throws Exception {
        String x = "a";
        response.setContentLength(String.valueOf(x).length());

        response.getWriter().append(x);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthPrintWriterAppendCharSequenceIntIntCommits() throws Exception {
        String x = "abcdef";
        int start = 1;
        int end = 3;
        response.setContentLength(end - start);

        response.getWriter().append(x, start, end);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthPrintWriterAppendCharCommits() throws Exception {
        char x = 1;
        response.setContentLength(1);

        response.getWriter().append(x);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthOutputStreamWriteIntCommits() throws Exception {
        int expected = 1;
        response.setContentLength(String.valueOf(expected).length());

        response.getOutputStream().write(expected);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthOutputStreamWriteIntMultiDigitCommits() throws Exception {
        int expected = 10000;
        response.setContentLength(String.valueOf(expected).length());

        response.getOutputStream().write(expected);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthPlus1OutputStreamWriteIntMultiDigitCommits() throws Exception {
        int expected = 10000;
        response.setContentLength(String.valueOf(expected).length() + 1);

        response.getOutputStream().write(expected);

        assertThat(committed).isFalse();

        response.getOutputStream().write(1);

        assertThat(committed).isTrue();
    }


    @Test
    public void contentLengthPlus1OutputStreamWriteByteArrayMultiDigitCommits() throws Exception {
        String expected = "{\n" +
                "  \"parameterName\" : \"_csrf\",\n" +
                "  \"token\" : \"06300b65-c4aa-4c8f-8cda-39ee17f545a0\",\n" +
                "  \"headerName\" : \"X-CSRF-TOKEN\"\n" +
                "}";
        response.setContentLength(expected.length() + 1);

        response.getOutputStream().write(expected.getBytes());

        assertThat(committed).isFalse();

        response.getOutputStream().write("1".getBytes("UTF-8"));

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthOutputStreamPrintBooleanCommits() throws Exception {
        boolean b = true;
        response.setContentLength(1);

        response.getOutputStream().print(b);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthOutputStreamPrintCharCommits() throws Exception {
        char c = 1;
        response.setContentLength(1);

        response.getOutputStream().print(c);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthOutputStreamPrintIntCommits() throws Exception {
        int i = 1234;
        response.setContentLength(String.valueOf(i).length());

        response.getOutputStream().print(i);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthOutputStreamPrintLongCommits() throws Exception {
        long l = 12345;
        response.setContentLength(String.valueOf(l).length());

        response.getOutputStream().print(l);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthOutputStreamPrintFloatCommits() throws Exception {
        float f = 12345;
        response.setContentLength(String.valueOf(f).length());

        response.getOutputStream().print(f);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthOutputStreamPrintDoubleCommits() throws Exception {
        double x = 1.2345;
        response.setContentLength(String.valueOf(x).length());

        response.getOutputStream().print(x);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthOutputStreamPrintStringCommits() throws Exception {
        String x = "12345";
        response.setContentLength(x.length());

        response.getOutputStream().print(x);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthOutputStreamPrintlnCommits() throws Exception {
        response.setContentLength(NL.length());

        response.getOutputStream().println();

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthOutputStreamPrintlnBooleanCommits() throws Exception {
        boolean b = true;
        response.setContentLength(1);

        response.getOutputStream().println(b);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthOutputStreamPrintlnCharCommits() throws Exception {
        char c = 1;
        response.setContentLength(1);

        response.getOutputStream().println(c);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthOutputStreamPrintlnIntCommits() throws Exception {
        int i = 12345;
        response.setContentLength(String.valueOf(i).length());

        response.getOutputStream().println(i);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthOutputStreamPrintlnLongCommits() throws Exception {
        long l = 12345678;
        response.setContentLength(String.valueOf(l).length());

        response.getOutputStream().println(l);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthOutputStreamPrintlnFloatCommits() throws Exception {
        float f = 1234;
        response.setContentLength(String.valueOf(f).length());

        response.getOutputStream().println(f);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthOutputStreamPrintlnDoubleCommits() throws Exception {
        double x = 1;
        response.setContentLength(String.valueOf(x).length());

        response.getOutputStream().println(x);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthOutputStreamPrintlnStringCommits() throws Exception {
        String x = "1";
        response.setContentLength(String.valueOf(x).length());

        response.getOutputStream().println(x);

        assertThat(committed).isTrue();
    }

    @Test
    public void contentLengthDoesNotCommit() throws IOException {
        String body = "something";

        response.setContentLength(body.length());

        assertThat(committed).isFalse();
    }

    @Test
    public void contentLengthOutputStreamWriteStringCommits() throws IOException {
        String body = "something";
        response.setContentLength(body.length());

        response.getOutputStream().print(body);

        assertThat(committed).isTrue();
    }

    @Test
    public void addHeaderContentLengthPrintWriterWriteStringCommits() throws Exception {
        int expected = 1234;
        response.addHeader("Content-Length",String.valueOf(String.valueOf(expected).length()));

        response.getWriter().write(expected);

        assertThat(committed).isTrue();
    }

    @Test
    public void bufferSizePrintWriterWriteCommits() throws Exception {
        String expected = "1234567890";
        when(response.getBufferSize()).thenReturn(expected.length());

        response.getWriter().write(expected);

        assertThat(committed).isTrue();
    }

    @Test
    public void bufferSizeCommitsOnce() throws Exception {
        String expected = "1234567890";
        when(response.getBufferSize()).thenReturn(expected.length());

        response.getWriter().write(expected);

        assertThat(committed).isTrue();

        committed = false;

        response.getWriter().write(expected);

        assertThat(committed).isFalse();
    }
}
<code block>

package org.springframework.security.web.context;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.Locale;

import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpServletResponseWrapper;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;


public abstract class SaveContextOnUpdateOrErrorResponseWrapper extends
		HttpServletResponseWrapper {
	private final Log logger = LogFactory.getLog(getClass());

	private boolean disableSaveOnResponseCommitted;

	private boolean contextSaved = false;

	private final boolean disableUrlRewriting;


	public SaveContextOnUpdateOrErrorResponseWrapper(HttpServletResponse response,
			boolean disableUrlRewriting) {
		super(response);
		this.disableUrlRewriting = disableUrlRewriting;
	}


	public void disableSaveOnResponseCommitted() {
		this.disableSaveOnResponseCommitted = true;
	}


	protected abstract void saveContext(SecurityContext context);


	@Override
	public final void sendError(int sc) throws IOException {
		doSaveContext();
		super.sendError(sc);
	}


	@Override
	public final void sendError(int sc, String msg) throws IOException {
		doSaveContext();
		super.sendError(sc, msg);
	}


	@Override
	public final void sendRedirect(String location) throws IOException {
		doSaveContext();
		super.sendRedirect(location);
	}


	@Override
	public ServletOutputStream getOutputStream() throws IOException {
		return new SaveContextServletOutputStream(super.getOutputStream());
	}


	@Override
	public PrintWriter getWriter() throws IOException {
		return new SaveContextPrintWriter(super.getWriter());
	}


	@Override
	public void flushBuffer() throws IOException {
		doSaveContext();
		super.flushBuffer();
	}


	private void doSaveContext() {
		if (!disableSaveOnResponseCommitted) {
			saveContext(SecurityContextHolder.getContext());
			contextSaved = true;
		}
		else if (logger.isDebugEnabled()) {
			logger.debug("Skip saving SecurityContext since saving on response commited is disabled");
		}
	}

	@Override
	public final String encodeRedirectUrl(String url) {
		if (disableUrlRewriting) {
			return url;
		}
		return super.encodeRedirectUrl(url);
	}

	@Override
	public final String encodeRedirectURL(String url) {
		if (disableUrlRewriting) {
			return url;
		}
		return super.encodeRedirectURL(url);
	}

	@Override
	public final String encodeUrl(String url) {
		if (disableUrlRewriting) {
			return url;
		}
		return super.encodeUrl(url);
	}

	@Override
	public final String encodeURL(String url) {
		if (disableUrlRewriting) {
			return url;
		}
		return super.encodeURL(url);
	}


	public final boolean isContextSaved() {
		return contextSaved;
	}


	private class SaveContextPrintWriter extends PrintWriter {
		private final PrintWriter delegate;

		public SaveContextPrintWriter(PrintWriter delegate) {
			super(delegate);
			this.delegate = delegate;
		}

		public void flush() {
			doSaveContext();
			delegate.flush();
		}

		public void close() {
			doSaveContext();
			delegate.close();
		}

		public int hashCode() {
			return delegate.hashCode();
		}

		public boolean equals(Object obj) {
			return delegate.equals(obj);
		}

		public String toString() {
			return getClass().getName() + "[delegate=" + delegate.toString() + "]";
		}

		public boolean checkError() {
			return delegate.checkError();
		}

		public void write(int c) {
			delegate.write(c);
		}

		public void write(char[] buf, int off, int len) {
			delegate.write(buf, off, len);
		}

		public void write(char[] buf) {
			delegate.write(buf);
		}

		public void write(String s, int off, int len) {
			delegate.write(s, off, len);
		}

		public void write(String s) {
			delegate.write(s);
		}

		public void print(boolean b) {
			delegate.print(b);
		}

		public void print(char c) {
			delegate.print(c);
		}

		public void print(int i) {
			delegate.print(i);
		}

		public void print(long l) {
			delegate.print(l);
		}

		public void print(float f) {
			delegate.print(f);
		}

		public void print(double d) {
			delegate.print(d);
		}

		public void print(char[] s) {
			delegate.print(s);
		}

		public void print(String s) {
			delegate.print(s);
		}

		public void print(Object obj) {
			delegate.print(obj);
		}

		public void println() {
			delegate.println();
		}

		public void println(boolean x) {
			delegate.println(x);
		}

		public void println(char x) {
			delegate.println(x);
		}

		public void println(int x) {
			delegate.println(x);
		}

		public void println(long x) {
			delegate.println(x);
		}

		public void println(float x) {
			delegate.println(x);
		}

		public void println(double x) {
			delegate.println(x);
		}

		public void println(char[] x) {
			delegate.println(x);
		}

		public void println(String x) {
			delegate.println(x);
		}

		public void println(Object x) {
			delegate.println(x);
		}

		public PrintWriter printf(String format, Object... args) {
			return delegate.printf(format, args);
		}

		public PrintWriter printf(Locale l, String format, Object... args) {
			return delegate.printf(l, format, args);
		}

		public PrintWriter format(String format, Object... args) {
			return delegate.format(format, args);
		}

		public PrintWriter format(Locale l, String format, Object... args) {
			return delegate.format(l, format, args);
		}

		public PrintWriter append(CharSequence csq) {
			return delegate.append(csq);
		}

		public PrintWriter append(CharSequence csq, int start, int end) {
			return delegate.append(csq, start, end);
		}

		public PrintWriter append(char c) {
			return delegate.append(c);
		}
	}


	private class SaveContextServletOutputStream extends ServletOutputStream {
		private final ServletOutputStream delegate;

		public SaveContextServletOutputStream(ServletOutputStream delegate) {
			this.delegate = delegate;
		}

		public void write(int b) throws IOException {
			this.delegate.write(b);
		}

		public void flush() throws IOException {
			doSaveContext();
			delegate.flush();
		}

		public void close() throws IOException {
			doSaveContext();
			delegate.close();
		}

		public int hashCode() {
			return delegate.hashCode();
		}

		public boolean equals(Object obj) {
			return delegate.equals(obj);
		}

		public void print(boolean b) throws IOException {
			delegate.print(b);
		}

		public void print(char c) throws IOException {
			delegate.print(c);
		}

		public void print(double d) throws IOException {
			delegate.print(d);
		}

		public void print(float f) throws IOException {
			delegate.print(f);
		}

		public void print(int i) throws IOException {
			delegate.print(i);
		}

		public void print(long l) throws IOException {
			delegate.print(l);
		}

		public void print(String arg0) throws IOException {
			delegate.print(arg0);
		}

		public void println() throws IOException {
			delegate.println();
		}

		public void println(boolean b) throws IOException {
			delegate.println(b);
		}

		public void println(char c) throws IOException {
			delegate.println(c);
		}

		public void println(double d) throws IOException {
			delegate.println(d);
		}

		public void println(float f) throws IOException {
			delegate.println(f);
		}

		public void println(int i) throws IOException {
			delegate.println(i);
		}

		public void println(long l) throws IOException {
			delegate.println(l);
		}

		public void println(String s) throws IOException {
			delegate.println(s);
		}

		public void write(byte[] b) throws IOException {
			delegate.write(b);
		}

		public void write(byte[] b, int off, int len) throws IOException {
			delegate.write(b, off, len);
		}

		public String toString() {
			return getClass().getName() + "[delegate=" + delegate.toString() + "]";
		}
	}
}

<code block>

package org.springframework.security.web.context;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpServletResponseWrapper;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Locale;


abstract class OnCommittedResponseWrapper extends HttpServletResponseWrapper {
	private final Log logger = LogFactory.getLog(getClass());

	private boolean disableOnCommitted;


	private long contentLength;


	private long contentWritten;


	public OnCommittedResponseWrapper(HttpServletResponse response) {
		super(response);
	}

	@Override
	public void addHeader(String name, String value) {
		if("Content-Length".equalsIgnoreCase(name)) {
			setContentLength(Long.parseLong(value));
		}
		super.addHeader(name, value);
	}

	@Override
	public void setContentLength(int len) {
		setContentLength((long) len);
		super.setContentLength(len);
	}

	private void setContentLength(long len) {
		this.contentLength = len;
		checkContentLength(0);
	}


	public void disableOnResponseCommitted() {
		this.disableOnCommitted = true;
	}


	protected abstract void onResponseCommitted();


	@Override
	public final void sendError(int sc) throws IOException {
		doOnResponseCommitted();
		super.sendError(sc);
	}


	@Override
	public final void sendError(int sc, String msg) throws IOException {
		doOnResponseCommitted();
		super.sendError(sc, msg);
	}


	@Override
	public final void sendRedirect(String location) throws IOException {
		doOnResponseCommitted();
		super.sendRedirect(location);
	}


	@Override
	public ServletOutputStream getOutputStream() throws IOException {
		return new SaveContextServletOutputStream(super.getOutputStream());
	}


	@Override
	public PrintWriter getWriter() throws IOException {
		return new SaveContextPrintWriter(super.getWriter());
	}


	@Override
	public void flushBuffer() throws IOException {
		doOnResponseCommitted();
		super.flushBuffer();
	}

	private void trackContentLength(boolean content) {
		checkContentLength(content ? 4 : 5); 
	}

	private void trackContentLength(char content) {
		checkContentLength(1);
	}

	private void trackContentLength(Object content) {
		trackContentLength(String.valueOf(content));
	}

	private void trackContentLength(byte[] content) {
		checkContentLength(content == null ? 0 : content.length);
	}

	private void trackContentLength(char[] content) {
		checkContentLength(content == null ? 0 : content.length);
	}

	private void trackContentLength(int content) {
		trackContentLength(String.valueOf(content));
	}

	private void trackContentLength(float content) {
		trackContentLength(String.valueOf(content));
	}

	private void trackContentLength(double content) {
		trackContentLength(String.valueOf(content));
	}

	private void trackContentLengthLn() {
		trackContentLength("\r\n");
	}

	private void trackContentLength(String content) {
		checkContentLength(content.length());
	}


	private void checkContentLength(long contentLengthToWrite) {
		contentWritten += contentLengthToWrite;
		boolean isBodyFullyWritten = contentLength > 0  && contentWritten >= contentLength;
		int bufferSize = getBufferSize();
		boolean requiresFlush = bufferSize > 0 && contentWritten >= bufferSize;
		if(isBodyFullyWritten || requiresFlush) {
			doOnResponseCommitted();
		}
	}


	private void doOnResponseCommitted() {
		if(!disableOnCommitted) {
			onResponseCommitted();
			disableOnResponseCommitted();
		} else if(logger.isDebugEnabled()){
			logger.debug("Skip invoking on");
		}
	}


	private class SaveContextPrintWriter extends PrintWriter {
		private final PrintWriter delegate;

		public SaveContextPrintWriter(PrintWriter delegate) {
			super(delegate);
			this.delegate = delegate;
		}

		public void flush() {
			doOnResponseCommitted();
			delegate.flush();
		}

		public void close() {
			doOnResponseCommitted();
			delegate.close();
		}

		public int hashCode() {
			return delegate.hashCode();
		}

		public boolean equals(Object obj) {
			return delegate.equals(obj);
		}

		public String toString() {
			return getClass().getName() + "[delegate=" + delegate.toString() + "]";
		}

		public boolean checkError() {
			return delegate.checkError();
		}

		public void write(int c) {
			trackContentLength(c);
			delegate.write(c);
		}

		public void write(char[] buf, int off, int len) {
			checkContentLength(len);
			delegate.write(buf, off, len);
		}

		public void write(char[] buf) {
			trackContentLength(buf);
			delegate.write(buf);
		}

		public void write(String s, int off, int len) {
			checkContentLength(len);
			delegate.write(s, off, len);
		}

		public void write(String s) {
			trackContentLength(s);
			delegate.write(s);
		}

		public void print(boolean b) {
			trackContentLength(b);
			delegate.print(b);
		}

		public void print(char c) {
			trackContentLength(c);
			delegate.print(c);
		}

		public void print(int i) {
			trackContentLength(i);
			delegate.print(i);
		}

		public void print(long l) {
			trackContentLength(l);
			delegate.print(l);
		}

		public void print(float f) {
			trackContentLength(f);
			delegate.print(f);
		}

		public void print(double d) {
			trackContentLength(d);
			delegate.print(d);
		}

		public void print(char[] s) {
			trackContentLength(s);
			delegate.print(s);
		}

		public void print(String s) {
			trackContentLength(s);
			delegate.print(s);
		}

		public void print(Object obj) {
			trackContentLength(obj);
			delegate.print(obj);
		}

		public void println() {
			trackContentLengthLn();
			delegate.println();
		}

		public void println(boolean x) {
			trackContentLength(x);
			trackContentLengthLn();
			delegate.println(x);
		}

		public void println(char x) {
			trackContentLength(x);
			trackContentLengthLn();
			delegate.println(x);
		}

		public void println(int x) {
			trackContentLength(x);
			trackContentLengthLn();
			delegate.println(x);
		}

		public void println(long x) {
			trackContentLength(x);
			trackContentLengthLn();
			delegate.println(x);
		}

		public void println(float x) {
			trackContentLength(x);
			trackContentLengthLn();
			delegate.println(x);
		}

		public void println(double x) {
			trackContentLength(x);
			trackContentLengthLn();
			delegate.println(x);
		}

		public void println(char[] x) {
			trackContentLength(x);
			trackContentLengthLn();
			delegate.println(x);
		}

		public void println(String x) {
			trackContentLength(x);
			trackContentLengthLn();
			delegate.println(x);
		}

		public void println(Object x) {
			trackContentLength(x);
			trackContentLengthLn();
			delegate.println(x);
		}

		public PrintWriter printf(String format, Object... args) {
			return delegate.printf(format, args);
		}

		public PrintWriter printf(Locale l, String format, Object... args) {
			return delegate.printf(l, format, args);
		}

		public PrintWriter format(String format, Object... args) {
			return delegate.format(format, args);
		}

		public PrintWriter format(Locale l, String format, Object... args) {
			return delegate.format(l, format, args);
		}

		public PrintWriter append(CharSequence csq) {
			checkContentLength(csq.length());
			return delegate.append(csq);
		}

		public PrintWriter append(CharSequence csq, int start, int end) {
			checkContentLength(end - start);
			return delegate.append(csq, start, end);
		}

		public PrintWriter append(char c) {
			trackContentLength(c);
			return delegate.append(c);
		}
	}


	private class SaveContextServletOutputStream extends ServletOutputStream {
		private final ServletOutputStream delegate;

		public SaveContextServletOutputStream(ServletOutputStream delegate) {
			this.delegate = delegate;
		}

		public void write(int b) throws IOException {
			trackContentLength(b);
			this.delegate.write(b);
		}

		public void flush() throws IOException {
			doOnResponseCommitted();
			delegate.flush();
		}

		public void close() throws IOException {
			doOnResponseCommitted();
			delegate.close();
		}

		public int hashCode() {
			return delegate.hashCode();
		}

		public boolean equals(Object obj) {
			return delegate.equals(obj);
		}

		public void print(boolean b) throws IOException {
			trackContentLength(b);
			delegate.print(b);
		}

		public void print(char c) throws IOException {
			trackContentLength(c);
			delegate.print(c);
		}

		public void print(double d) throws IOException {
			trackContentLength(d);
			delegate.print(d);
		}

		public void print(float f) throws IOException {
			trackContentLength(f);
			delegate.print(f);
		}

		public void print(int i) throws IOException {
			trackContentLength(i);
			delegate.print(i);
		}

		public void print(long l) throws IOException {
			trackContentLength(l);
			delegate.print(l);
		}

		public void print(String s) throws IOException {
			trackContentLength(s);
			delegate.print(s);
		}

		public void println() throws IOException {
			trackContentLengthLn();
			delegate.println();
		}

		public void println(boolean b) throws IOException {
			trackContentLength(b);
			trackContentLengthLn();
			delegate.println(b);
		}

		public void println(char c) throws IOException {
			trackContentLength(c);
			trackContentLengthLn();
			delegate.println(c);
		}

		public void println(double d) throws IOException {
			trackContentLength(d);
			trackContentLengthLn();
			delegate.println(d);
		}

		public void println(float f) throws IOException {
			trackContentLength(f);
			trackContentLengthLn();
			delegate.println(f);
		}

		public void println(int i) throws IOException {
			trackContentLength(i);
			trackContentLengthLn();
			delegate.println(i);
		}

		public void println(long l) throws IOException {
			trackContentLength(l);
			trackContentLengthLn();
			delegate.println(l);
		}

		public void println(String s) throws IOException {
			trackContentLength(s);
			trackContentLengthLn();
			delegate.println(s);
		}

		public void write(byte[] b) throws IOException {
			trackContentLength(b);
			delegate.write(b);
		}

		public void write(byte[] b, int off, int len) throws IOException {
			checkContentLength(len);
			delegate.write(b, off, len);
		}

		public String toString() {
			return getClass().getName() + "[delegate=" + delegate.toString() + "]";
		}
	}
}
<code block>

package org.springframework.security.web.context;

import javax.servlet.http.HttpServletResponse;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;


public abstract class SaveContextOnUpdateOrErrorResponseWrapper extends
		OnCommittedResponseWrapper {
	private final Log logger = LogFactory.getLog(getClass());


	private boolean contextSaved = false;

	private final boolean disableUrlRewriting;


	public SaveContextOnUpdateOrErrorResponseWrapper(HttpServletResponse response,
			boolean disableUrlRewriting) {
		super(response);
		this.disableUrlRewriting = disableUrlRewriting;
	}


	public void disableSaveOnResponseCommitted() {
		disableOnResponseCommitted();
	}


	protected abstract void saveContext(SecurityContext context);


	@Override
	protected void onResponseCommitted() {
		saveContext(SecurityContextHolder.getContext());
		contextSaved = true;
	}

	@Override
	public final String encodeRedirectUrl(String url) {
		if (disableUrlRewriting) {
			return url;
		}
		return super.encodeRedirectUrl(url);
	}

	@Override
	public final String encodeRedirectURL(String url) {
		if (disableUrlRewriting) {
			return url;
		}
		return super.encodeRedirectURL(url);
	}

	@Override
	public final String encodeUrl(String url) {
		if (disableUrlRewriting) {
			return url;
		}
		return super.encodeUrl(url);
	}

	@Override
	public final String encodeURL(String url) {
		if (disableUrlRewriting) {
			return url;
		}
		return super.encodeURL(url);
	}


	public final boolean isContextSaved() {
		return contextSaved;
	}
}

<code block>

package org.springframework.security.web.context;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.Locale;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;

import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletResponse;

import static org.fest.assertions.Assertions.assertThat;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class OnCommittedResponseWrapperTests {
	private static final String NL = "\r\n";

	@Mock
	HttpServletResponse delegate;
	@Mock
	PrintWriter writer;
	@Mock
	ServletOutputStream out;

	OnCommittedResponseWrapper response;

	boolean committed;

	@Before
	public void setup() throws Exception {
		response = new OnCommittedResponseWrapper(delegate) {
			@Override
			protected void onResponseCommitted() {
				committed = true;
			}
		};
		when(delegate.getWriter()).thenReturn(writer);
		when(delegate.getOutputStream()).thenReturn(out);
	}




	@Test
	public void printWriterHashCode() throws Exception {
		int expected = writer.hashCode();

		assertThat(response.getWriter().hashCode()).isEqualTo(expected);
	}

	@Test
	public void printWriterCheckError() throws Exception {
		boolean expected = true;
		when(writer.checkError()).thenReturn(expected);

		assertThat(response.getWriter().checkError()).isEqualTo(expected);
	}

	@Test
	public void printWriterWriteInt() throws Exception {
		int expected = 1;

		response.getWriter().write(expected);

		verify(writer).write(expected);
	}

	@Test
	public void printWriterWriteCharIntInt() throws Exception {
		char[] buff = new char[0];
		int off = 2;
		int len = 3;

		response.getWriter().write(buff,off,len);

		verify(writer).write(buff,off,len);
	}

	@Test
	public void printWriterWriteChar() throws Exception {
		char[] buff = new char[0];

		response.getWriter().write(buff);

		verify(writer).write(buff);
	}

	@Test
	public void printWriterWriteStringIntInt() throws Exception {
		String s = "";
		int off = 2;
		int len = 3;

		response.getWriter().write(s,off,len);

		verify(writer).write(s,off,len);
	}

	@Test
	public void printWriterWriteString() throws Exception {
		String s = "";

		response.getWriter().write(s);

		verify(writer).write(s);
	}

	@Test
	public void printWriterPrintBoolean() throws Exception {
		boolean b = true;

		response.getWriter().print(b);

		verify(writer).print(b);
	}

	@Test
	public void printWriterPrintChar() throws Exception {
		char c = 1;

		response.getWriter().print(c);

		verify(writer).print(c);
	}

	@Test
	public void printWriterPrintInt() throws Exception {
		int i = 1;

		response.getWriter().print(i);

		verify(writer).print(i);
	}

	@Test
	public void printWriterPrintLong() throws Exception {
		long l = 1;

		response.getWriter().print(l);

		verify(writer).print(l);
	}

	@Test
	public void printWriterPrintFloat() throws Exception {
		float f = 1;

		response.getWriter().print(f);

		verify(writer).print(f);
	}

	@Test
	public void printWriterPrintDouble() throws Exception {
		double x = 1;

		response.getWriter().print(x);

		verify(writer).print(x);
	}

	@Test
	public void printWriterPrintCharArray() throws Exception {
		char[] x = new char[0];

		response.getWriter().print(x);

		verify(writer).print(x);
	}

	@Test
	public void printWriterPrintString() throws Exception {
		String x = "1";

		response.getWriter().print(x);

		verify(writer).print(x);
	}

	@Test
	public void printWriterPrintObject() throws Exception {
		Object x = "1";

		response.getWriter().print(x);

		verify(writer).print(x);
	}

	@Test
	public void printWriterPrintln() throws Exception {
		response.getWriter().println();

		verify(writer).println();
	}

	@Test
	public void printWriterPrintlnBoolean() throws Exception {
		boolean b = true;

		response.getWriter().println(b);

		verify(writer).println(b);
	}

	@Test
	public void printWriterPrintlnChar() throws Exception {
		char c = 1;

		response.getWriter().println(c);

		verify(writer).println(c);
	}

	@Test
	public void printWriterPrintlnInt() throws Exception {
		int i = 1;

		response.getWriter().println(i);

		verify(writer).println(i);
	}

	@Test
	public void printWriterPrintlnLong() throws Exception {
		long l = 1;

		response.getWriter().println(l);

		verify(writer).println(l);
	}

	@Test
	public void printWriterPrintlnFloat() throws Exception {
		float f = 1;

		response.getWriter().println(f);

		verify(writer).println(f);
	}

	@Test
	public void printWriterPrintlnDouble() throws Exception {
		double x = 1;

		response.getWriter().println(x);

		verify(writer).println(x);
	}

	@Test
	public void printWriterPrintlnCharArray() throws Exception {
		char[] x = new char[0];

		response.getWriter().println(x);

		verify(writer).println(x);
	}

	@Test
	public void printWriterPrintlnString() throws Exception {
		String x = "1";

		response.getWriter().println(x);

		verify(writer).println(x);
	}

	@Test
	public void printWriterPrintlnObject() throws Exception {
		Object x = "1";

		response.getWriter().println(x);

		verify(writer).println(x);
	}

	@Test
	public void printWriterPrintfStringObjectVargs() throws Exception {
		String format = "format";
		Object[] args = new Object[] { "1" };

		response.getWriter().printf(format, args);

		verify(writer).printf(format, args);
	}

	@Test
	public void printWriterPrintfLocaleStringObjectVargs() throws Exception {
		Locale l = Locale.US;
		String format = "format";
		Object[] args = new Object[] { "1" };

		response.getWriter().printf(l, format, args);

		verify(writer).printf(l, format, args);
	}

	@Test
	public void printWriterFormatStringObjectVargs() throws Exception {
		String format = "format";
		Object[] args = new Object[] { "1" };

		response.getWriter().format(format, args);

		verify(writer).format(format, args);
	}

	@Test
	public void printWriterFormatLocaleStringObjectVargs() throws Exception {
		Locale l = Locale.US;
		String format = "format";
		Object[] args = new Object[] { "1" };

		response.getWriter().format(l, format, args);

		verify(writer).format(l, format, args);
	}


	@Test
	public void printWriterAppendCharSequence() throws Exception {
		String x = "a";

		response.getWriter().append(x);

		verify(writer).append(x);
	}

	@Test
	public void printWriterAppendCharSequenceIntInt() throws Exception {
		String x = "abcdef";
		int start = 1;
		int end = 3;

		response.getWriter().append(x, start, end);

		verify(writer).append(x, start, end);
	}


	@Test
	public void printWriterAppendChar() throws Exception {
		char x = 1;

		response.getWriter().append(x);

		verify(writer).append(x);
	}




	@Test
	public void outputStreamHashCode() throws Exception {
		int expected = out.hashCode();

		assertThat(response.getOutputStream().hashCode()).isEqualTo(expected);
	}

	@Test
	public void outputStreamWriteInt() throws Exception {
		int expected = 1;

		response.getOutputStream().write(expected);

		verify(out).write(expected);
	}

	@Test
	public void outputStreamWriteByte() throws Exception {
		byte[] expected = new byte[0];

		response.getOutputStream().write(expected);

		verify(out).write(expected);
	}

	@Test
	public void outputStreamWriteByteIntInt() throws Exception {
		int start = 1;
		int end = 2;
		byte[] expected = new byte[0];

		response.getOutputStream().write(expected, start, end);

		verify(out).write(expected, start, end);
	}

	@Test
	public void outputStreamPrintBoolean() throws Exception {
		boolean b = true;

		response.getOutputStream().print(b);

		verify(out).print(b);
	}

	@Test
	public void outputStreamPrintChar() throws Exception {
		char c = 1;

		response.getOutputStream().print(c);

		verify(out).print(c);
	}

	@Test
	public void outputStreamPrintInt() throws Exception {
		int i = 1;

		response.getOutputStream().print(i);

		verify(out).print(i);
	}

	@Test
	public void outputStreamPrintLong() throws Exception {
		long l = 1;

		response.getOutputStream().print(l);

		verify(out).print(l);
	}

	@Test
	public void outputStreamPrintFloat() throws Exception {
		float f = 1;

		response.getOutputStream().print(f);

		verify(out).print(f);
	}

	@Test
	public void outputStreamPrintDouble() throws Exception {
		double x = 1;

		response.getOutputStream().print(x);

		verify(out).print(x);
	}

	@Test
	public void outputStreamPrintString() throws Exception {
		String x = "1";

		response.getOutputStream().print(x);

		verify(out).print(x);
	}

	@Test
	public void outputStreamPrintln() throws Exception {
		response.getOutputStream().println();

		verify(out).println();
	}

	@Test
	public void outputStreamPrintlnBoolean() throws Exception {
		boolean b = true;

		response.getOutputStream().println(b);

		verify(out).println(b);
	}

	@Test
	public void outputStreamPrintlnChar() throws Exception {
		char c = 1;

		response.getOutputStream().println(c);

		verify(out).println(c);
	}

	@Test
	public void outputStreamPrintlnInt() throws Exception {
		int i = 1;

		response.getOutputStream().println(i);

		verify(out).println(i);
	}

	@Test
	public void outputStreamPrintlnLong() throws Exception {
		long l = 1;

		response.getOutputStream().println(l);

		verify(out).println(l);
	}

	@Test
	public void outputStreamPrintlnFloat() throws Exception {
		float f = 1;

		response.getOutputStream().println(f);

		verify(out).println(f);
	}

	@Test
	public void outputStreamPrintlnDouble() throws Exception {
		double x = 1;

		response.getOutputStream().println(x);

		verify(out).println(x);
	}

	@Test
	public void outputStreamPrintlnString() throws Exception {
		String x = "1";

		response.getOutputStream().println(x);

		verify(out).println(x);
	}




	@Test
	public void contentLengthPrintWriterWriteIntCommits() throws Exception {
		int expected = 1;
		response.setContentLength(String.valueOf(expected).length());

		response.getWriter().write(expected);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthPrintWriterWriteIntMultiDigitCommits() throws Exception {
		int expected = 10000;
		response.setContentLength(String.valueOf(expected).length());

		response.getWriter().write(expected);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthPlus1PrintWriterWriteIntMultiDigitCommits() throws Exception {
		int expected = 10000;
		response.setContentLength(String.valueOf(expected).length() + 1);

		response.getWriter().write(expected);

		assertThat(committed).isFalse();

		response.getWriter().write(1);

		assertThat(committed).isTrue();
	}


	@Test
	public void contentLengthPrintWriterWriteCharIntIntCommits() throws Exception {
		char[] buff = new char[0];
		int off = 2;
		int len = 3;
		response.setContentLength(3);

		response.getWriter().write(buff,off,len);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthPrintWriterWriteCharCommits() throws Exception {
		char[] buff = new char[4];
		response.setContentLength(buff.length);

		response.getWriter().write(buff);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthPrintWriterWriteStringIntIntCommits() throws Exception {
		String s = "";
		int off = 2;
		int len = 3;
		response.setContentLength(3);

		response.getWriter().write(s,off,len);

		assertThat(committed).isTrue();
	}


	@Test
	public void contentLengthPrintWriterWriteStringCommits() throws IOException {
		String body = "something";
		response.setContentLength(body.length());

		response.getWriter().write(body);

		assertThat(committed).isTrue();
	}

	@Test
	public void printWriterWriteStringContentLengthCommits() throws IOException {
		String body = "something";
		response.getWriter().write(body);

		response.setContentLength(body.length());

		assertThat(committed).isTrue();
	}

	@Test
	public void printWriterWriteStringDoesNotCommit() throws IOException {
		String body = "something";

		response.getWriter().write(body);

		assertThat(committed).isFalse();
	}

	@Test
	public void contentLengthPrintWriterPrintBooleanCommits() throws Exception {
		boolean b = true;
		response.setContentLength(1);

		response.getWriter().print(b);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthPrintWriterPrintCharCommits() throws Exception {
		char c = 1;
		response.setContentLength(1);

		response.getWriter().print(c);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthPrintWriterPrintIntCommits() throws Exception {
		int i = 1234;
		response.setContentLength(String.valueOf(i).length());

		response.getWriter().print(i);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthPrintWriterPrintLongCommits() throws Exception {
		long l = 12345;
		response.setContentLength(String.valueOf(l).length());

		response.getWriter().print(l);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthPrintWriterPrintFloatCommits() throws Exception {
		float f = 12345;
		response.setContentLength(String.valueOf(f).length());

		response.getWriter().print(f);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthPrintWriterPrintDoubleCommits() throws Exception {
		double x = 1.2345;
		response.setContentLength(String.valueOf(x).length());

		response.getWriter().print(x);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthPrintWriterPrintCharArrayCommits() throws Exception {
		char[] x = new char[10];
		response.setContentLength(x.length);

		response.getWriter().print(x);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthPrintWriterPrintStringCommits() throws Exception {
		String x = "12345";
		response.setContentLength(x.length());

		response.getWriter().print(x);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthPrintWriterPrintObjectCommits() throws Exception {
		Object x = "12345";
		response.setContentLength(String.valueOf(x).length());

		response.getWriter().print(x);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthPrintWriterPrintlnCommits() throws Exception {
		response.setContentLength(NL.length());

		response.getWriter().println();

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthPrintWriterPrintlnBooleanCommits() throws Exception {
		boolean b = true;
		response.setContentLength(1);

		response.getWriter().println(b);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthPrintWriterPrintlnCharCommits() throws Exception {
		char c = 1;
		response.setContentLength(1);

		response.getWriter().println(c);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthPrintWriterPrintlnIntCommits() throws Exception {
		int i = 12345;
		response.setContentLength(String.valueOf(i).length());

		response.getWriter().println(i);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthPrintWriterPrintlnLongCommits() throws Exception {
		long l = 12345678;
		response.setContentLength(String.valueOf(l).length());

		response.getWriter().println(l);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthPrintWriterPrintlnFloatCommits() throws Exception {
		float f = 1234;
		response.setContentLength(String.valueOf(f).length());

		response.getWriter().println(f);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthPrintWriterPrintlnDoubleCommits() throws Exception {
		double x = 1;
		response.setContentLength(String.valueOf(x).length());

		response.getWriter().println(x);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthPrintWriterPrintlnCharArrayCommits() throws Exception {
		char[] x = new char[20];
		response.setContentLength(x.length);

		response.getWriter().println(x);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthPrintWriterPrintlnStringCommits() throws Exception {
		String x = "1";
		response.setContentLength(String.valueOf(x).length());

		response.getWriter().println(x);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthPrintWriterPrintlnObjectCommits() throws Exception {
		Object x = "1";
		response.setContentLength(String.valueOf(x).length());

		response.getWriter().println(x);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthPrintWriterAppendCharSequenceCommits() throws Exception {
		String x = "a";
		response.setContentLength(String.valueOf(x).length());

		response.getWriter().append(x);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthPrintWriterAppendCharSequenceIntIntCommits() throws Exception {
		String x = "abcdef";
		int start = 1;
		int end = 3;
		response.setContentLength(end - start);

		response.getWriter().append(x, start, end);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthPrintWriterAppendCharCommits() throws Exception {
		char x = 1;
		response.setContentLength(1);

		response.getWriter().append(x);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthOutputStreamWriteIntCommits() throws Exception {
		int expected = 1;
		response.setContentLength(String.valueOf(expected).length());

		response.getOutputStream().write(expected);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthOutputStreamWriteIntMultiDigitCommits() throws Exception {
		int expected = 10000;
		response.setContentLength(String.valueOf(expected).length());

		response.getOutputStream().write(expected);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthPlus1OutputStreamWriteIntMultiDigitCommits() throws Exception {
		int expected = 10000;
		response.setContentLength(String.valueOf(expected).length() + 1);

		response.getOutputStream().write(expected);

		assertThat(committed).isFalse();

		response.getOutputStream().write(1);

		assertThat(committed).isTrue();
	}


	@Test
	public void contentLengthPlus1OutputStreamWriteByteArrayMultiDigitCommits() throws Exception {
		String expected = "{\n" +
				"  \"parameterName\" : \"_csrf\",\n" +
				"  \"token\" : \"06300b65-c4aa-4c8f-8cda-39ee17f545a0\",\n" +
				"  \"headerName\" : \"X-CSRF-TOKEN\"\n" +
				"}";
		response.setContentLength(expected.length() + 1);

		response.getOutputStream().write(expected.getBytes());

		assertThat(committed).isFalse();

		response.getOutputStream().write("1".getBytes("UTF-8"));

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthOutputStreamPrintBooleanCommits() throws Exception {
		boolean b = true;
		response.setContentLength(1);

		response.getOutputStream().print(b);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthOutputStreamPrintCharCommits() throws Exception {
		char c = 1;
		response.setContentLength(1);

		response.getOutputStream().print(c);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthOutputStreamPrintIntCommits() throws Exception {
		int i = 1234;
		response.setContentLength(String.valueOf(i).length());

		response.getOutputStream().print(i);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthOutputStreamPrintLongCommits() throws Exception {
		long l = 12345;
		response.setContentLength(String.valueOf(l).length());

		response.getOutputStream().print(l);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthOutputStreamPrintFloatCommits() throws Exception {
		float f = 12345;
		response.setContentLength(String.valueOf(f).length());

		response.getOutputStream().print(f);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthOutputStreamPrintDoubleCommits() throws Exception {
		double x = 1.2345;
		response.setContentLength(String.valueOf(x).length());

		response.getOutputStream().print(x);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthOutputStreamPrintStringCommits() throws Exception {
		String x = "12345";
		response.setContentLength(x.length());

		response.getOutputStream().print(x);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthOutputStreamPrintlnCommits() throws Exception {
		response.setContentLength(NL.length());

		response.getOutputStream().println();

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthOutputStreamPrintlnBooleanCommits() throws Exception {
		boolean b = true;
		response.setContentLength(1);

		response.getOutputStream().println(b);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthOutputStreamPrintlnCharCommits() throws Exception {
		char c = 1;
		response.setContentLength(1);

		response.getOutputStream().println(c);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthOutputStreamPrintlnIntCommits() throws Exception {
		int i = 12345;
		response.setContentLength(String.valueOf(i).length());

		response.getOutputStream().println(i);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthOutputStreamPrintlnLongCommits() throws Exception {
		long l = 12345678;
		response.setContentLength(String.valueOf(l).length());

		response.getOutputStream().println(l);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthOutputStreamPrintlnFloatCommits() throws Exception {
		float f = 1234;
		response.setContentLength(String.valueOf(f).length());

		response.getOutputStream().println(f);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthOutputStreamPrintlnDoubleCommits() throws Exception {
		double x = 1;
		response.setContentLength(String.valueOf(x).length());

		response.getOutputStream().println(x);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthOutputStreamPrintlnStringCommits() throws Exception {
		String x = "1";
		response.setContentLength(String.valueOf(x).length());

		response.getOutputStream().println(x);

		assertThat(committed).isTrue();
	}

	@Test
	public void contentLengthDoesNotCommit() throws IOException {
		String body = "something";

		response.setContentLength(body.length());

		assertThat(committed).isFalse();
	}

	@Test
	public void contentLengthOutputStreamWriteStringCommits() throws IOException {
		String body = "something";
		response.setContentLength(body.length());

		response.getOutputStream().print(body);

		assertThat(committed).isTrue();
	}

	@Test
	public void addHeaderContentLengthPrintWriterWriteStringCommits() throws Exception {
		int expected = 1234;
		response.addHeader("Content-Length",String.valueOf(String.valueOf(expected).length()));

		response.getWriter().write(expected);

		assertThat(committed).isTrue();
	}

	@Test
	public void bufferSizePrintWriterWriteCommits() throws Exception {
		String expected = "1234567890";
		when(response.getBufferSize()).thenReturn(expected.length());

		response.getWriter().write(expected);

		assertThat(committed).isTrue();
	}

	@Test
	public void bufferSizeCommitsOnce() throws Exception {
		String expected = "1234567890";
		when(response.getBufferSize()).thenReturn(expected.length());

		response.getWriter().write(expected);

		assertThat(committed).isTrue();

		committed = false;

		response.getWriter().write(expected);

		assertThat(committed).isFalse();
	}
}