package org.mongodb.morphia.mapping;


import com.mongodb.DBObject;
import org.mongodb.morphia.ObjectFactory;
import org.mongodb.morphia.annotations.ConstructorArgs;
import org.mongodb.morphia.logging.Logger;
import org.mongodb.morphia.logging.MorphiaLoggerFactory;

import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;



public class DefaultCreator implements ObjectFactory {
    private static final Logger LOG = MorphiaLoggerFactory.get(DefaultCreator.class);


    private <T> T newInstance(final Constructor<T> tryMe, final Class<T> fallbackType) {
        if (tryMe != null) {
            tryMe.setAccessible(true);
            try {
                return tryMe.newInstance();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
        return createInst(fallbackType);
    }

    private static <T> Constructor<T> getNoArgsConstructor(final Class<T> type) {
        try {
            final Constructor<T> constructor = type.getDeclaredConstructor();
            constructor.setAccessible(true);
            return constructor;
        } catch (NoSuchMethodException e) {
            throw new MappingException("No usable constructor for " + type.getName(), e);
        }
    }

    @Override
    public <T> T createInstance(final Class<T> clazz) {
        return createInst(clazz);
    }

    @Override
    public <T> T createInstance(final Class<T> clazz, final DBObject dbObj) {
        Class<T> c = getClass(dbObj);
        if (c == null) {
            c = clazz;
        }
        return createInstance(c);
    }

    @Override
    @SuppressWarnings("unchecked")
    public Object createInstance(final Mapper mapper, final MappedField mf, final DBObject dbObj) {
        Class c = getClass(dbObj);
        if (c == null) {
            c = mf.isSingleValue() ? mf.getConcreteType() : mf.getSubClass();
        }
        try {
            return createInstance(c, dbObj);
        } catch (RuntimeException e) {
            final ConstructorArgs argAnn = mf.getAnnotation(ConstructorArgs.class);
            if (argAnn == null) {
                throw e;
            }

            final Object[] args = new Object[argAnn.value().length];
            final Class[] argTypes = new Class[argAnn.value().length];
            for (int i = 0; i < argAnn.value().length; i++) {


                final Object val = dbObj.get(argAnn.value()[i]);
                args[i] = val;
                argTypes[i] = val.getClass();
            }
            try {
                final Constructor constructor = c.getDeclaredConstructor(argTypes);
                constructor.setAccessible(true);
                return constructor.newInstance(args);
            } catch (Exception ex) {
                throw new RuntimeException(ex);
            }
        }
    }

    @Override
    @SuppressWarnings("unchecked")
    public Map createMap(final MappedField mf) {
        return newInstance(mf != null ? mf.getCTor() : null, HashMap.class);
    }

    @Override
    @SuppressWarnings("unchecked")
    public List createList(final MappedField mf) {
        return newInstance(mf != null ? mf.getCTor() : null, ArrayList.class);
    }

    @Override
    @SuppressWarnings("unchecked")
    public Set createSet(final MappedField mf) {
        return newInstance(mf != null ? mf.getCTor() : null, HashSet.class);
    }

    @SuppressWarnings("unchecked")
    private <T> Class<T> getClass(final DBObject dbObj) {

        Class c = null;
        if (dbObj.containsField(Mapper.CLASS_NAME_FIELDNAME)) {
            final String className = (String) dbObj.get(Mapper.CLASS_NAME_FIELDNAME);


            try {
                c = Class.forName(className, true, getClassLoaderForClass());
            } catch (ClassNotFoundException e) {
                if (LOG.isWarningEnabled()) {
                    LOG.warning("Class not found defined in dbObj: ", e);
                }
            }
        }
        return c;
    }

    protected ClassLoader getClassLoaderForClass() {
        return Thread.currentThread().getContextClassLoader();
    }

    @SuppressWarnings("unchecked")
    public <T> T createInst(final Class<T> clazz) {
        try {
            return getNoArgsConstructor(clazz).newInstance();
        } catch (Exception e) {
            if (Collection.class.isAssignableFrom(clazz)) {
                return (T) createList(null);
            } else if (Map.class.isAssignableFrom(clazz)) {
                return (T) createMap(null);
            } else if (Set.class.isAssignableFrom(clazz)) {
                return (T) createSet(null);
            }
            throw new MappingException("No usable constructor for " + clazz.getName(), e);
        }
    }
}

<code block>
package org.mongodb.morphia.mapping;


import org.mongodb.morphia.ObjectFactory;
import org.mongodb.morphia.mapping.lazy.DatastoreProvider;
import org.mongodb.morphia.mapping.lazy.DefaultDatastoreProvider;



public class MapperOptions {
    private boolean actLikeSerializer;
    private boolean ignoreFinals; 
    private boolean storeNulls;
    private boolean storeEmpties;
    private boolean useLowerCaseCollectionNames;
    private ObjectFactory objectFactory = new DefaultCreator();
    private CustomMapper embeddedMapper = new EmbeddedMapper();
    private CustomMapper defaultMapper = embeddedMapper;
    private CustomMapper referenceMapper = new ReferenceMapper();
    private CustomMapper valueMapper = new ValueMapper();
    private DatastoreProvider datastoreProvider = new DefaultDatastoreProvider();

    public CustomMapper getDefaultMapper() {
        return defaultMapper;
    }

    public void setDefaultMapper(final CustomMapper pDefaultMapper) {
        defaultMapper = pDefaultMapper;
    }

    public CustomMapper getEmbeddedMapper() {
        return embeddedMapper;
    }

    public void setEmbeddedMapper(final CustomMapper pEmbeddedMapper) {
        embeddedMapper = pEmbeddedMapper;
    }

    public ObjectFactory getObjectFactory() {
        return objectFactory;
    }


    public void setObjectFactory(final ObjectFactory objectFactory) {
        this.objectFactory = objectFactory;
    }

    public CustomMapper getReferenceMapper() {
        return referenceMapper;
    }

    public void setReferenceMapper(final CustomMapper pReferenceMapper) {
        referenceMapper = pReferenceMapper;
    }

    public CustomMapper getValueMapper() {
        return valueMapper;
    }

    public void setValueMapper(final CustomMapper pValueMapper) {
        valueMapper = pValueMapper;
    }

    public boolean isActLikeSerializer() {
        return actLikeSerializer;
    }


    public void setActLikeSerializer(final boolean actLikeSerializer) {
        this.actLikeSerializer = actLikeSerializer;
    }

    public boolean isIgnoreFinals() {
        return ignoreFinals;
    }


    public void setIgnoreFinals(final boolean ignoreFinals) {
        this.ignoreFinals = ignoreFinals;
    }

    public boolean isStoreEmpties() {
        return storeEmpties;
    }


    public void setStoreEmpties(final boolean storeEmpties) {
        this.storeEmpties = storeEmpties;
    }

    public boolean isStoreNulls() {
        return storeNulls;
    }


    public void setStoreNulls(final boolean storeNulls) {
        this.storeNulls = storeNulls;
    }

    public boolean isUseLowerCaseCollectionNames() {
        return useLowerCaseCollectionNames;
    }


    public void setUseLowerCaseCollectionNames(final boolean useLowerCaseCollectionNames) {
        this.useLowerCaseCollectionNames = useLowerCaseCollectionNames;
    }

    public DatastoreProvider getDatastoreProvider() {
        return datastoreProvider;
    }

    public void setDatastoreProvider(final DatastoreProvider datastoreProvider) {
        datastoreProvider.register(this.getDatastoreProvider().get());
        this.datastoreProvider = datastoreProvider;
    }
}

<code block>
package org.mongodb.morphia.mapping;


import com.mongodb.DBObject;
import org.mongodb.morphia.EntityInterceptor;
import org.mongodb.morphia.annotations.Converters;
import org.mongodb.morphia.annotations.Embedded;
import org.mongodb.morphia.annotations.Entity;
import org.mongodb.morphia.annotations.EntityListeners;
import org.mongodb.morphia.annotations.Field;
import org.mongodb.morphia.annotations.Id;
import org.mongodb.morphia.annotations.IndexOptions;
import org.mongodb.morphia.annotations.Indexes;
import org.mongodb.morphia.annotations.Polymorphic;
import org.mongodb.morphia.annotations.PostLoad;
import org.mongodb.morphia.annotations.PostPersist;
import org.mongodb.morphia.annotations.PreLoad;
import org.mongodb.morphia.annotations.PrePersist;
import org.mongodb.morphia.annotations.PreSave;
import org.mongodb.morphia.annotations.Property;
import org.mongodb.morphia.annotations.Reference;
import org.mongodb.morphia.annotations.Serialized;
import org.mongodb.morphia.annotations.Transient;
import org.mongodb.morphia.annotations.Version;
import org.mongodb.morphia.logging.Logger;
import org.mongodb.morphia.logging.MorphiaLoggerFactory;
import org.mongodb.morphia.mapping.validation.MappingValidator;
import org.mongodb.morphia.utils.ReflectionUtils;

import java.io.Serializable;
import java.lang.annotation.Annotation;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static java.lang.String.format;
import static java.util.Arrays.asList;



public class MappedClass {
    private static class ClassMethodPair {
        private final Class<?> clazz;
        private final Method method;

        public ClassMethodPair(final Class<?> c, final Method m) {
            clazz = c;
            method = m;
        }
    }

    private static final Logger LOG = MorphiaLoggerFactory.get(MappedClass.class);


    private static final List<Class<? extends Annotation>> INTERESTING_ANNOTATIONS = new ArrayList<Class<? extends Annotation>>();

    static {
        INTERESTING_ANNOTATIONS.add(Embedded.class);
        INTERESTING_ANNOTATIONS.add(Entity.class);
        INTERESTING_ANNOTATIONS.add(Polymorphic.class);
        INTERESTING_ANNOTATIONS.add(EntityListeners.class);
        INTERESTING_ANNOTATIONS.add(Version.class);
        INTERESTING_ANNOTATIONS.add(Converters.class);
        INTERESTING_ANNOTATIONS.add(Indexes.class);
        INTERESTING_ANNOTATIONS.add(Field.class);
        INTERESTING_ANNOTATIONS.add(IndexOptions.class);
    }


    private java.lang.reflect.Field idField;


    private Entity entityAn;
    private Embedded embeddedAn;


    @SuppressWarnings("unchecked")
    private static final List<Class<? extends Annotation>> LIFECYCLE_ANNOTATIONS = asList(PrePersist.class,
                                                                                          PreSave.class,
                                                                                          PreLoad.class,
                                                                                          PostPersist.class,
                                                                                          PostLoad.class);

    private final Map<Class<? extends Annotation>, List<Annotation>> foundAnnotations = 
        new HashMap<Class<? extends Annotation>, List<Annotation>>();


    private final Map<Class<? extends Annotation>, List<ClassMethodPair>> lifecycleMethods = 
        new HashMap<Class<? extends Annotation>, List<ClassMethodPair>>();


    private final List<MappedField> persistenceFields = new ArrayList<MappedField>();


    private final Class<?> clazz;

    private final Mapper mapper;

    public static void addInterestingAnnotation(final Class<? extends Annotation> annotation) {
        INTERESTING_ANNOTATIONS.add(annotation);
    }


    public MappedClass(final Class<?> clazz, final Mapper mapper) {
        this.mapper = mapper;
        this.clazz = clazz;

        if (LOG.isTraceEnabled()) {
            LOG.trace("Creating MappedClass for " + clazz);
        }

        basicValidate();
        discover();

        if (LOG.isDebugEnabled()) {
            LOG.debug("MappedClass done: " + toString());
        }
    }

    protected void basicValidate() {
        final boolean isStatic = Modifier.isStatic(clazz.getModifiers());
        if (!isStatic && clazz.isMemberClass()) {
            throw new MappingException("Cannot use non-static inner class: " + clazz + ". Please make static.");
        }
    }



    public void update() {
        embeddedAn = (Embedded) getAnnotation(Embedded.class);
        entityAn = (Entity) getFirstAnnotation(Entity.class);

        final List<MappedField> fields = getFieldsAnnotatedWith(Id.class);
        if (fields != null && !fields.isEmpty()) {
            idField = fields.get(0).getField();
        }
    }


    protected void discover() {
        for (final Class<? extends Annotation> c : INTERESTING_ANNOTATIONS) {
            addAnnotation(c);
        }

        final List<Class<?>> lifecycleClasses = new ArrayList<Class<?>>();
        lifecycleClasses.add(clazz);

        final EntityListeners entityLisAnn = (EntityListeners) getAnnotation(EntityListeners.class);
        if (entityLisAnn != null && entityLisAnn.value() != null && entityLisAnn.value().length != 0) {
            Collections.addAll(lifecycleClasses, entityLisAnn.value());
        }

        for (final Class<?> cls : lifecycleClasses) {
            for (final Method m : ReflectionUtils.getDeclaredAndInheritedMethods(cls)) {
                for (final Class<? extends Annotation> c : LIFECYCLE_ANNOTATIONS) {
                    if (m.isAnnotationPresent(c)) {
                        addLifecycleEventMethod(c, m, cls.equals(clazz) ? null : cls);
                    }
                }
            }
        }

        update();

        for (final java.lang.reflect.Field field : ReflectionUtils.getDeclaredAndInheritedFields(clazz, true)) {
            field.setAccessible(true);
            final int fieldMods = field.getModifiers();
            if (!isIgnorable(field, fieldMods)) {
                if (field.isAnnotationPresent(Id.class)) {
                    persistenceFields.add(new MappedField(field, clazz, getMapper()));
                    update();
                } else if (field.isAnnotationPresent(Property.class)
                           || field.isAnnotationPresent(Reference.class)
                           || field.isAnnotationPresent(Embedded.class)
                           || field.isAnnotationPresent(Serialized.class)
                           || isSupportedType(field.getType())
                           || ReflectionUtils.implementsInterface(field.getType(), Serializable.class)) {
                    persistenceFields.add(new MappedField(field, clazz, getMapper()));
                } else {
                    if (mapper.getOptions().getDefaultMapper() != null) {
                        persistenceFields.add(new MappedField(field, clazz, getMapper()));
                    } else if (LOG.isWarningEnabled()) {
                        LOG.warning(format("Ignoring (will not persist) field: %s.%s [type:%s]", clazz.getName(), field.getName(),
                                           field.getType().getName()));
                    }
                }
            }
        }
    }

    private boolean isIgnorable(final java.lang.reflect.Field field, final int fieldMods) {
        return field.isAnnotationPresent(Transient.class)
            || field.isSynthetic() && (fieldMods & Modifier.TRANSIENT) == Modifier.TRANSIENT
            || mapper.getOptions().isActLikeSerializer() && ((fieldMods & Modifier.TRANSIENT) == Modifier.TRANSIENT)
            || mapper.getOptions().isIgnoreFinals() && ((fieldMods & Modifier.FINAL) == Modifier.FINAL);
    }

    private void addLifecycleEventMethod(final Class<? extends Annotation> lceClazz, final Method m, final Class<?> clazz) {
        final ClassMethodPair cm = new ClassMethodPair(clazz, m);
        if (lifecycleMethods.containsKey(lceClazz)) {
            lifecycleMethods.get(lceClazz).add(cm);
        } else {
            final List<ClassMethodPair> methods = new ArrayList<ClassMethodPair>();
            methods.add(cm);
            lifecycleMethods.put(lceClazz, methods);
        }
    }


    public void addAnnotation(final Class<? extends Annotation> clazz, final Annotation ann) {
        if (ann == null || clazz == null) {
            return;
        }

        if (!foundAnnotations.containsKey(clazz)) {
            foundAnnotations.put(clazz, new ArrayList<Annotation>());
        }

        foundAnnotations.get(clazz).add(ann);
    }

    public List<ClassMethodPair> getLifecycleMethods(final Class<Annotation> clazz) {
        return lifecycleMethods.get(clazz);
    }


    private void addAnnotation(final Class<? extends Annotation> clazz) {
        final List<? extends Annotation> annotations = ReflectionUtils.getAnnotations(getClazz(), clazz);
        for (final Annotation ann : annotations) {
            addAnnotation(clazz, ann);
        }
    }

    @Override
    public String toString() {
        return "MappedClass - kind:" + getCollectionName() + " for " + getClazz().getName() + " fields:" + persistenceFields;
    }


    public List<MappedField> getFieldsAnnotatedWith(final Class<? extends Annotation> clazz) {
        final List<MappedField> results = new ArrayList<MappedField>();
        for (final MappedField mf : persistenceFields) {
            if (mf.getAnnotations().containsKey(clazz)) {
                results.add(mf);
            }
        }
        return results;
    }


    public MappedField getMappedField(final String storedName) {
        for (final MappedField mf : persistenceFields) {
            for (final String n : mf.getLoadNames()) {
                if (storedName.equals(n)) {
                    return mf;
                }
            }
        }

        return null;
    }


    public boolean containsJavaFieldName(final String name) {
        return getMappedField(name) != null;
    }


    public MappedField getMappedFieldByJavaField(final String name) {
        for (final MappedField mf : persistenceFields) {
            if (name.equals(mf.getJavaFieldName())) {
                return mf;
            }
        }

        return null;
    }


    public static boolean isSupportedType(final Class<?> clazz) {
        if (ReflectionUtils.isPropertyType(clazz)) {
            return true;
        }
        if (clazz.isArray() || Map.class.isAssignableFrom(clazz) || Iterable.class.isAssignableFrom(clazz)) {
            Class<?> subType;
            if (clazz.isArray()) {
                subType = clazz.getComponentType();
            } else {
                subType = ReflectionUtils.getParameterizedClass(clazz);
            }


            if (subType != null && subType != Object.class && !ReflectionUtils.isPropertyType(subType)) {
                return false;
            }


            return true;
        }
        return false;
    }

    @SuppressWarnings("deprecation")
    public void validate() {
        new MappingValidator().validate(this);
    }

    @Override
    public boolean equals(final Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        final MappedClass that = (MappedClass) o;

        return clazz.equals(that.clazz);

    }

    @Override
    public int hashCode() {
        return clazz.hashCode();
    }


    @SuppressWarnings({"WMI", "unchecked"})
    public DBObject callLifecycleMethods(final Class<? extends Annotation> event, final Object entity, final DBObject dbObj) {
        final List<ClassMethodPair> methodPairs = getLifecycleMethods((Class<Annotation>) event);
        DBObject retDbObj = dbObj;
        try {
            Object tempObj;
            if (methodPairs != null) {
                final HashMap<Class<?>, Object> toCall = new HashMap<Class<?>, Object>((int) (methodPairs.size() * 1.3));
                for (final ClassMethodPair cm : methodPairs) {
                    toCall.put(cm.clazz, null);
                }
                for (final Class<?> c : toCall.keySet()) {
                    if (c != null) {
                        toCall.put(c, getOrCreateInstance(c));
                    }
                }

                for (final ClassMethodPair cm : methodPairs) {
                    final Method method = cm.method;
                    final Object inst = toCall.get(cm.clazz);
                    method.setAccessible(true);

                    if (LOG.isDebugEnabled()) {
                        LOG.debug(format("Calling lifecycle method(@%s %s) on %s", event.getSimpleName(), method, inst));
                    }

                    if (inst == null) {
                        if (method.getParameterTypes().length == 0) {
                            tempObj = method.invoke(entity);
                        } else {
                            tempObj = method.invoke(entity, retDbObj);
                        }
                    } else if (method.getParameterTypes().length == 0) {
                        tempObj = method.invoke(inst);
                    } else if (method.getParameterTypes().length == 1) {
                        tempObj = method.invoke(inst, entity);
                    } else {
                        tempObj = method.invoke(inst, entity, retDbObj);
                    }

                    if (tempObj != null) {
                        retDbObj = (DBObject) tempObj;
                    }
                }
            }

            callGlobalInterceptors(event, entity, dbObj, mapper.getInterceptors());
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        } catch (InvocationTargetException e) {
            throw new RuntimeException(e);
        }

        return retDbObj;
    }

    private Object getOrCreateInstance(final Class<?> clazz) {
        if (mapper.getInstanceCache().containsKey(clazz)) {
            return mapper.getInstanceCache().get(clazz);
        }

        final Object o = mapper.getOptions().getObjectFactory().createInstance(clazz);
        final Object nullO = mapper.getInstanceCache().put(clazz, o);
        if (nullO != null) {
            if (LOG.isErrorEnabled()) {
                LOG.error("Race-condition, created duplicate class: " + clazz);
            }
        }

        return o;

    }

    private void callGlobalInterceptors(final Class<? extends Annotation> event, final Object entity, final DBObject dbObj,
                                        final Collection<EntityInterceptor> interceptors) {
        for (final EntityInterceptor ei : interceptors) {
            if (LOG.isDebugEnabled()) {
                LOG.debug("Calling interceptor method " + event.getSimpleName() + " on " + ei);
            }

            if (event.equals(PreLoad.class)) {
                ei.preLoad(entity, dbObj, mapper);
            } else if (event.equals(PostLoad.class)) {
                ei.postLoad(entity, dbObj, mapper);
            } else if (event.equals(PrePersist.class)) {
                ei.prePersist(entity, dbObj, mapper);
            } else if (event.equals(PreSave.class)) {
                ei.preSave(entity, dbObj, mapper);
            } else if (event.equals(PostPersist.class)) {
                ei.postPersist(entity, dbObj, mapper);
            }
        }
    }


    public java.lang.reflect.Field getIdField() {
        return idField;
    }


    public Entity getEntityAnnotation() {
        return entityAn;
    }


    public Embedded getEmbeddedAnnotation() {
        return embeddedAn;
    }


    public Map<Class<? extends Annotation>, List<Annotation>> getRelevantAnnotations() {
        return foundAnnotations;
    }


    public Annotation getFirstAnnotation(final Class<? extends Annotation> clazz) {
        final List<Annotation> found = foundAnnotations.get(clazz);
        return found == null || found.isEmpty() ? null : found.get(0);
    }


    public Annotation getAnnotation(final Class<? extends Annotation> clazz) {
        final List<Annotation> found = foundAnnotations.get(clazz);
        return found == null || found.isEmpty() ? null : found.get(found.size() - 1);
    }


    public List<Annotation> getAnnotations(final Class<? extends Annotation> clazz) {
        return foundAnnotations.get(clazz);
    }


    public List<MappedField> getPersistenceFields() {
        return persistenceFields;
    }


    public String getCollectionName() {
        if (entityAn == null || entityAn.value().equals(Mapper.IGNORED_FIELDNAME)) {
            return mapper.getOptions().isUseLowerCaseCollectionNames() ? clazz.getSimpleName().toLowerCase() : clazz.getSimpleName();
        }
        return entityAn.value();
    }


    public Class<?> getClazz() {
        return clazz;
    }


    public Mapper getMapper() {
        return mapper;
    }

    public MappedField getMappedIdField() {
        List<MappedField> fields = getFieldsAnnotatedWith(Id.class);
        return fields.isEmpty() ? null : fields.get(0);
    }

}
<code block>
package org.mongodb.morphia.mapping.validation;

import org.mongodb.morphia.annotations.Embedded;
import org.mongodb.morphia.annotations.Property;
import org.mongodb.morphia.annotations.Reference;
import org.mongodb.morphia.annotations.Serialized;
import org.mongodb.morphia.logging.Logger;
import org.mongodb.morphia.logging.MorphiaLoggerFactory;
import org.mongodb.morphia.mapping.MappedClass;
import org.mongodb.morphia.mapping.validation.ConstraintViolation.Level;
import org.mongodb.morphia.mapping.validation.classrules.DuplicatedAttributeNames;
import org.mongodb.morphia.mapping.validation.classrules.EmbeddedAndId;
import org.mongodb.morphia.mapping.validation.classrules.EmbeddedAndValue;
import org.mongodb.morphia.mapping.validation.classrules.EntityAndEmbed;
import org.mongodb.morphia.mapping.validation.classrules.EntityCannotBeMapOrIterable;
import org.mongodb.morphia.mapping.validation.classrules.MultipleId;
import org.mongodb.morphia.mapping.validation.classrules.MultipleVersions;
import org.mongodb.morphia.mapping.validation.classrules.NoId;
import org.mongodb.morphia.mapping.validation.fieldrules.ContradictingFieldAnnotation;
import org.mongodb.morphia.mapping.validation.fieldrules.LazyReferenceMissingDependencies;
import org.mongodb.morphia.mapping.validation.fieldrules.LazyReferenceOnArray;
import org.mongodb.morphia.mapping.validation.fieldrules.MapKeyDifferentFromString;
import org.mongodb.morphia.mapping.validation.fieldrules.MapNotSerializable;
import org.mongodb.morphia.mapping.validation.fieldrules.MisplacedProperty;
import org.mongodb.morphia.mapping.validation.fieldrules.ReferenceToUnidentifiable;
import org.mongodb.morphia.mapping.validation.fieldrules.VersionMisuse;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import static java.lang.String.format;



public class MappingValidator {

    private static final Logger LOG = MorphiaLoggerFactory.get(MappingValidator.class);

    public void validate(final List<MappedClass> classes) {
        final Set<ConstraintViolation> ve = new TreeSet<ConstraintViolation>(new Comparator<ConstraintViolation>() {

            public int compare(final ConstraintViolation o1, final ConstraintViolation o2) {
                return o1.getLevel().ordinal() > o2.getLevel().ordinal() ? -1 : 1;
            }
        });

        final List<ClassConstraint> rules = getConstraints();
        for (final MappedClass c : classes) {
            for (final ClassConstraint v : rules) {
                v.check(c, ve);
            }
        }

        if (!ve.isEmpty()) {
            final ConstraintViolation worst = ve.iterator().next();
            final Level maxLevel = worst.getLevel();
            if (maxLevel.ordinal() >= Level.FATAL.ordinal()) {
                throw new ConstraintViolationException(ve);
            }


            final List<LogLine> l = new ArrayList<LogLine>();
            for (final ConstraintViolation v : ve) {
                l.add(new LogLine(v));
            }
            Collections.sort(l);

            for (final LogLine line : l) {
                line.log(LOG);
            }
        }
    }

    private List<ClassConstraint> getConstraints() {
        final List<ClassConstraint> constraints = new ArrayList<ClassConstraint>(32);





        constraints.add(new MultipleId());
        constraints.add(new MultipleVersions());
        constraints.add(new NoId());
        constraints.add(new EmbeddedAndId());
        constraints.add(new EntityAndEmbed());
        constraints.add(new EmbeddedAndValue());
        constraints.add(new EntityCannotBeMapOrIterable());
        constraints.add(new DuplicatedAttributeNames());


        constraints.add(new MisplacedProperty());
        constraints.add(new ReferenceToUnidentifiable());
        constraints.add(new LazyReferenceMissingDependencies());
        constraints.add(new LazyReferenceOnArray());
        constraints.add(new MapKeyDifferentFromString());
        constraints.add(new MapNotSerializable());
        constraints.add(new VersionMisuse());

        constraints.add(new ContradictingFieldAnnotation(Reference.class, Serialized.class));
        constraints.add(new ContradictingFieldAnnotation(Reference.class, Property.class));
        constraints.add(new ContradictingFieldAnnotation(Reference.class, Embedded.class));

        constraints.add(new ContradictingFieldAnnotation(Embedded.class, Serialized.class));
        constraints.add(new ContradictingFieldAnnotation(Embedded.class, Property.class));

        constraints.add(new ContradictingFieldAnnotation(Property.class, Serialized.class));

        return constraints;
    }

    static class LogLine implements Comparable<LogLine> {
        private final ConstraintViolation v;

        LogLine(final ConstraintViolation v) {
            this.v = v;
        }

        void log(final Logger logger) {
            switch (v.getLevel()) {
                case SEVERE:
                    logger.error(v.render());
                    break;
                case WARNING:
                    logger.warning(v.render());
                    break;
                case INFO:
                    logger.info(v.render());
                    break;
                case MINOR:
                    logger.debug(v.render());
                    break;
                default:
                    throw new IllegalStateException(format("Cannot log %s of Level %s", ConstraintViolation.class.getSimpleName(),
                                                           v.getLevel()));
            }
        }

        @Override
        public boolean equals(final Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }

            final LogLine logLine = (LogLine) o;

            return v.equals(logLine.v);

        }

        @Override
        public int hashCode() {
            return v.hashCode();
        }

        public int compareTo(final LogLine o) {
            return v.getPrefix().compareTo(o.v.getPrefix());
        }
    }


    @Deprecated
    public void validate(final MappedClass mappedClass) {
        validate(Arrays.asList(mappedClass));
    }
}

<code block>
package org.mongodb.morphia.mapping.validation.fieldrules;


import java.util.Set;

import org.mongodb.morphia.annotations.Version;
import org.mongodb.morphia.mapping.DefaultCreator;
import org.mongodb.morphia.mapping.MappedClass;
import org.mongodb.morphia.mapping.MappedField;
import org.mongodb.morphia.mapping.validation.ConstraintViolation;
import org.mongodb.morphia.mapping.validation.ConstraintViolation.Level;



public class VersionMisuse extends FieldConstraint {

  @Override
  protected void check(final MappedClass mc, final MappedField mf, final Set<ConstraintViolation> ve) {
    if (mf.hasAnnotation(Version.class)) {
      final Class<?> type = mf.getType();
      if (Long.class.equals(type) || long.class.equals(type)) {


        final Object testInstance = new DefaultCreator().createInst(mc.getClazz());


        if (Long.class.equals(type)) {
          if (mf.getFieldValue(testInstance) != null) {
            ve.add(new ConstraintViolation(Level.FATAL, mc, mf, getClass(),
              "When using @" + Version.class.getSimpleName() + " on a Long field, it must be initialized to null."));
          }
        } else if (long.class.equals(type)) {
          if ((Long) mf.getFieldValue(testInstance) != 0L) {
            ve.add(new ConstraintViolation(Level.FATAL, mc, mf, getClass(),
              "When using @" + Version.class.getSimpleName() + " on a long field, it must be initialized to 0."));
          }
        }
      } else {
        ve.add(new ConstraintViolation(Level.FATAL, mc, mf, getClass(),
          "@" + Version.class.getSimpleName() + " can only be used on a Long/long field."));
      }
    }
  }

}

<code block>



package org.mongodb.morphia;


import com.mongodb.BasicDBObject;
import com.mongodb.BasicDBObjectBuilder;
import com.mongodb.DBCollection;
import com.mongodb.DBObject;
import com.mongodb.DBRef;
import org.bson.types.ObjectId;
import org.junit.Ignore;
import org.junit.Test;
import org.mongodb.morphia.TestInheritanceMappings.MapLike;
import org.mongodb.morphia.annotations.AlsoLoad;
import org.mongodb.morphia.annotations.Embedded;
import org.mongodb.morphia.annotations.Entity;
import org.mongodb.morphia.annotations.Id;
import org.mongodb.morphia.annotations.Serialized;
import org.mongodb.morphia.mapping.Mapper;
import org.mongodb.morphia.mapping.MappingException;
import org.mongodb.morphia.mapping.cache.DefaultEntityCache;
import org.mongodb.morphia.testmodel.Address;
import org.mongodb.morphia.testmodel.Article;
import org.mongodb.morphia.testmodel.Circle;
import org.mongodb.morphia.testmodel.Hotel;
import org.mongodb.morphia.testmodel.PhoneNumber;
import org.mongodb.morphia.testmodel.Rectangle;
import org.mongodb.morphia.testmodel.RecursiveChild;
import org.mongodb.morphia.testmodel.RecursiveParent;
import org.mongodb.morphia.testmodel.Translation;
import org.mongodb.morphia.testmodel.TravelAgency;

import java.io.Serializable;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.Vector;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;



public class TestMapping extends TestBase {

    public abstract static class BaseEntity implements Serializable {
        @Id
        private ObjectId id;

        public String getId() {
            return id.toString();
        }

        public void setId(final String id) {
            this.id = new ObjectId(id);
        }
    }


    @Entity
    public static class MissingId {
        private String  id;
    }

    private static class MissingIdStill {
        private String id;
    }

    @Entity("no-id")
    private static class MissingIdRenamed {
        private String id;
    }

    @Embedded
    private static class IdOnEmbedded {
        @Id
        private ObjectId id;
    }

    @Embedded("no-id")
    private static class RenamedEmbedded {
        private String name;
    }

    private static class StrangelyNamedIdField {

        @Id
        private ObjectId id_ = new ObjectId();

    }

    private static class ContainsEmbeddedArray {
        @Id
        private ObjectId id = new ObjectId();
        private RenamedEmbedded[] res;
    }

    private static class NotEmbeddable {
        private String noImNot = "no, I'm not";
    }

    private static class SerializableClass implements Serializable {
        private final String someString = "hi, from the ether.";
    }

    private static class ContainsRef {
        @Id
        private ObjectId id;
        private DBRef rect;
    }

    private static class HasFinalFieldId {
        @Id
        private final long id;
        private String name = "some string";


        protected HasFinalFieldId() {
            id = -1;
        }

        public HasFinalFieldId(final long id) {
            this.id = id;
        }
    }

    private static class ContainsFinalField {
        @Id
        private ObjectId id;
        private final String name;

        protected ContainsFinalField() {
            name = "foo";
        }

        public ContainsFinalField(final String name) {
            this.name = name;
        }
    }

    private static class ContainsTimestamp {
        @Id
        private
        ObjectId id;
        private final Timestamp ts = new Timestamp(System.currentTimeMillis());
    }

    private static class ContainsDBObject {
        @Id
        private ObjectId id;
        private DBObject dbObj = BasicDBObjectBuilder.start("field", "val").get();
    }

    private static class ContainsByteArray {
        @Id
        private ObjectId id;
        private final byte[] bytes = "Scott".getBytes();
    }

    private static class ContainsSerializedData {
        @Id
        private ObjectId id;
        @Serialized
        private final SerializableClass data = new SerializableClass();
    }

    private static class ContainsLongAndStringArray {
        @Id
        private ObjectId id;
        private Long[] longs = {0L, 1L, 2L};
        private String[] strings = {"Scott", "Rocks"};
    }

    private static final class ContainsCollection {
        @Id
        private ObjectId id;
        private final Collection<String> coll = new ArrayList<String>();

        private ContainsCollection() {
            coll.add("hi");
            coll.add("Scott");
        }
    }

    private static class ContainsPrimitiveMap {
        @Id
        private ObjectId id;
        @Embedded
        private final Map<String, Long> embeddedValues = new HashMap<String, Long>();
        private final Map<String, Long> values = new HashMap<String, Long>();
    }

    private interface Foo {
    }

    private static class Foo1 implements Foo {
        private String s;
    }

    private static class Foo2 implements Foo {
        private int i;
    }

    private static class ContainsMapWithEmbeddedInterface {
        @Id
        private ObjectId id;
        @Embedded
        private final Map<String, Foo> embeddedValues = new HashMap<String, Foo>();
    }

    private static class ContainsEmbeddedEntity {
        @Id
        private final ObjectId id = new ObjectId();
        @Embedded
        private ContainsIntegerList cil = new ContainsIntegerList();
    }

    public enum Enum1 {
        A,
        B
    }

    @Entity(value = "cil", noClassnameStored = true)
    private static class ContainsIntegerList {
        @Id
        private ObjectId id;
        private List<Integer> intList = new ArrayList<Integer>();
    }

    private static class ContainsIntegerListNewAndOld {
        @Id
        private ObjectId id;
        private List<Integer> intList = new ArrayList<Integer>();
        private List<Integer> integers = new ArrayList<Integer>();
    }

    @Entity(value = "cil", noClassnameStored = true)
    private static class ContainsIntegerListNew {
        @Id
        private ObjectId id;
        @AlsoLoad("intList")
        private final List<Integer> integers = new ArrayList<Integer>();
    }

    @Entity(noClassnameStored = true)
    private static class ContainsUUID {
        @Id
        private ObjectId id;
        private final UUID uuid = UUID.randomUUID();
    }

    @Entity(noClassnameStored = true)
    private static class ContainsUuidId {
        @Id
        private final UUID id = UUID.randomUUID();
    }

    private static class ContainsEnum1KeyMap {
        @Id
        private ObjectId id;
        private final Map<Enum1, String> values = new HashMap<Enum1, String>();
        @Embedded
        private final Map<Enum1, String> embeddedValues = new HashMap<Enum1, String>();
    }

    private static class ContainsIntKeyMap {
        @Id
        private ObjectId id;
        private final Map<Integer, String> values = new HashMap<Integer, String>();
    }

    private static class ContainsIntKeySetStringMap {
        @Id
        private ObjectId id;
        @Embedded
        private final Map<Integer, Set<String>> values = new HashMap<Integer, Set<String>>();
    }

    private static class ContainsObjectIdKeyMap {
        @Id
        private ObjectId id;
        private final Map<ObjectId, String> values = new HashMap<ObjectId, String>();
    }

    private static class ContainsXKeyMap<T> {
        @Id
        private ObjectId id;
        private final Map<T, String> values = new HashMap<T, String>();
    }

    private static class ContainsMapLike {
        @Id
        private ObjectId id;
        private final MapLike m = new MapLike();
    }

    @Entity
    private static class UsesBaseEntity extends BaseEntity {

    }

    private static class MapSubclass extends LinkedHashMap<String, Object> {
        @Id
        private ObjectId id;
    }

    private class NonStaticInnerClass {
        @Id
        private long id = 1;
    }

    @Test
    public void testUUID() throws Exception {

        final ContainsUUID uuid = new ContainsUUID();
        final UUID before = uuid.uuid;
        getDs().save(uuid);
        final ContainsUUID loaded = getDs().find(ContainsUUID.class).get();
        assertNotNull(loaded);
        assertNotNull(loaded.id);
        assertNotNull(loaded.uuid);
        assertEquals(before, loaded.uuid);
    }

    @Test
    public void testEmbeddedDBObject() throws Exception {
        getMorphia().map(ContainsDBObject.class);
        getDs().save(new ContainsDBObject());
        assertNotNull(getDs().find(ContainsDBObject.class).get());
    }

    @Test
    public void testUuidId() throws Exception {
        getMorphia().map(ContainsUuidId.class);
        final ContainsUuidId uuidId = new ContainsUuidId();
        final UUID before = uuidId.id;
        getDs().save(uuidId);
        final ContainsUuidId loaded = getDs().get(ContainsUuidId.class, before);
        assertNotNull(loaded);
        assertNotNull(loaded.id);
        assertEquals(before, loaded.id);
    }

    @Test
    public void testEmbeddedEntity() throws Exception {
        getMorphia().map(ContainsEmbeddedEntity.class);
        getDs().save(new ContainsEmbeddedEntity());
        final ContainsEmbeddedEntity ceeLoaded = getDs().find(ContainsEmbeddedEntity.class).get();
        assertNotNull(ceeLoaded);
        assertNotNull(ceeLoaded.id);
        assertNotNull(ceeLoaded.cil);
        assertNull(ceeLoaded.cil.id);

    }

    @Test
    public void testEmbeddedArrayElementHasNoClassname() throws Exception {
        getMorphia().map(ContainsEmbeddedArray.class);
        final ContainsEmbeddedArray cea = new ContainsEmbeddedArray();
        cea.res = new RenamedEmbedded[]{new RenamedEmbedded()};

        final DBObject dbObj = getMorphia().toDBObject(cea);
        assertTrue(!((DBObject) ((List) dbObj.get("res")).get(0)).containsField(Mapper.CLASS_NAME_FIELDNAME));
    }

    @Test
    public void testEmbeddedEntityDBObjectHasNoClassname() throws Exception {
        getMorphia().map(ContainsEmbeddedEntity.class);
        final ContainsEmbeddedEntity cee = new ContainsEmbeddedEntity();
        cee.cil = new ContainsIntegerList();
        cee.cil.intList = Collections.singletonList(1);
        final DBObject dbObj = getMorphia().toDBObject(cee);
        assertTrue(!((DBObject) dbObj.get("cil")).containsField(Mapper.CLASS_NAME_FIELDNAME));
    }

    @Test
    public void testEnumKeyedMap() throws Exception {
        final ContainsEnum1KeyMap map = new ContainsEnum1KeyMap();
        map.values.put(Enum1.A, "I'm a");
        map.values.put(Enum1.B, "I'm b");
        map.embeddedValues.put(Enum1.A, "I'm a");
        map.embeddedValues.put(Enum1.B, "I'm b");

        final Key<?> mapKey = getDs().save(map);

        final ContainsEnum1KeyMap mapLoaded = getDs().get(ContainsEnum1KeyMap.class, mapKey.getId());

        assertNotNull(mapLoaded);
        assertEquals(2, mapLoaded.values.size());
        assertNotNull(mapLoaded.values.get(Enum1.A));
        assertNotNull(mapLoaded.values.get(Enum1.B));
        assertEquals(2, mapLoaded.embeddedValues.size());
        assertNotNull(mapLoaded.embeddedValues.get(Enum1.A));
        assertNotNull(mapLoaded.embeddedValues.get(Enum1.B));
    }

    @Test
    public void testAlsoLoad() throws Exception {
        final ContainsIntegerList cil = new ContainsIntegerList();
        cil.intList.add(1);
        getDs().save(cil);
        final ContainsIntegerList cilLoaded = getDs().get(cil);
        assertNotNull(cilLoaded);
        assertNotNull(cilLoaded.intList);
        assertEquals(cilLoaded.intList.size(), cil.intList.size());
        assertEquals(cilLoaded.intList.get(0), cil.intList.get(0));

        final ContainsIntegerListNew cilNew = getDs().get(ContainsIntegerListNew.class, cil.id);
        assertNotNull(cilNew);
        assertNotNull(cilNew.integers);
        assertEquals(1, cilNew.integers.size());
        assertEquals(1, (int) cil.intList.get(0));
    }

    @Test
    public void testIntLists() throws Exception {
        ContainsIntegerList cil = new ContainsIntegerList();
        getDs().save(cil);
        ContainsIntegerList cilLoaded = getDs().get(cil);
        assertNotNull(cilLoaded);
        assertNotNull(cilLoaded.intList);
        assertEquals(cilLoaded.intList.size(), cil.intList.size());


        cil = new ContainsIntegerList();
        cil.intList = null;
        getDs().save(cil);
        cilLoaded = getDs().get(cil);
        assertNotNull(cilLoaded);
        assertNotNull(cilLoaded.intList);
        assertEquals(0, cilLoaded.intList.size());

        cil = new ContainsIntegerList();
        cil.intList.add(1);
        getDs().save(cil);
        cilLoaded = getDs().get(cil);
        assertNotNull(cilLoaded);
        assertNotNull(cilLoaded.intList);
        assertEquals(1, cilLoaded.intList.size());
        assertEquals(1, (int) cilLoaded.intList.get(0));
    }

    @Test
    public void testObjectIdKeyedMap() throws Exception {
        getMorphia().map(ContainsObjectIdKeyMap.class);
        final ContainsObjectIdKeyMap map = new ContainsObjectIdKeyMap();
        final ObjectId o1 = new ObjectId("111111111111111111111111");
        final ObjectId o2 = new ObjectId("222222222222222222222222");
        map.values.put(o1, "I'm 1s");
        map.values.put(o2, "I'm 2s");

        final Key<?> mapKey = getDs().save(map);

        final ContainsObjectIdKeyMap mapLoaded = getDs().get(ContainsObjectIdKeyMap.class, mapKey.getId());

        assertNotNull(mapLoaded);
        assertEquals(2, mapLoaded.values.size());
        assertNotNull(mapLoaded.values.get(o1));
        assertNotNull(mapLoaded.values.get(o2));

        assertNotNull(getDs().find(ContainsIntKeyMap.class).field("values.111111111111111111111111").exists());
        assertEquals(0, getDs().find(ContainsIntKeyMap.class).field("values.111111111111111111111111").doesNotExist().countAll());
        assertNotNull(getDs().find(ContainsIntKeyMap.class).field("values.4").doesNotExist());
        assertEquals(0, getDs().find(ContainsIntKeyMap.class).field("values.4").exists().countAll());
    }

    @Test
    public void testIntKeyedMap() throws Exception {
        final ContainsIntKeyMap map = new ContainsIntKeyMap();
        map.values.put(1, "I'm 1");
        map.values.put(2, "I'm 2");

        final Key<?> mapKey = getDs().save(map);

        final ContainsIntKeyMap mapLoaded = getDs().get(ContainsIntKeyMap.class, mapKey.getId());

        assertNotNull(mapLoaded);
        assertEquals(2, mapLoaded.values.size());
        assertNotNull(mapLoaded.values.get(1));
        assertNotNull(mapLoaded.values.get(2));

        assertNotNull(getDs().find(ContainsIntKeyMap.class).field("values.2").exists());
        assertEquals(0, getDs().find(ContainsIntKeyMap.class).field("values.2").doesNotExist().countAll());
        assertNotNull(getDs().find(ContainsIntKeyMap.class).field("values.4").doesNotExist());
        assertEquals(0, getDs().find(ContainsIntKeyMap.class).field("values.4").exists().countAll());
    }

    @Test
    public void testIntKeySetStringMap() throws Exception {
        final ContainsIntKeySetStringMap map = new ContainsIntKeySetStringMap();
        map.values.put(1, Collections.singleton("I'm 1"));
        map.values.put(2, Collections.singleton("I'm 2"));

        final Key<?> mapKey = getDs().save(map);

        final ContainsIntKeySetStringMap mapLoaded = getDs().get(ContainsIntKeySetStringMap.class, mapKey.getId());

        assertNotNull(mapLoaded);
        assertEquals(2, mapLoaded.values.size());
        assertNotNull(mapLoaded.values.get(1));
        assertNotNull(mapLoaded.values.get(2));
        assertEquals(1, mapLoaded.values.get(1).size());

        assertNotNull(getDs().find(ContainsIntKeyMap.class).field("values.2").exists());
        assertEquals(0, getDs().find(ContainsIntKeyMap.class).field("values.2").doesNotExist().countAll());
        assertNotNull(getDs().find(ContainsIntKeyMap.class).field("values.4").doesNotExist());
        assertEquals(0, getDs().find(ContainsIntKeyMap.class).field("values.4").exists().countAll());
    }

    @Test
    @Ignore("need to add this feature")
    @SuppressWarnings("unchecked")
    public void testGenericKeyedMap() throws Exception {
        final ContainsXKeyMap<Integer> map = new ContainsXKeyMap<Integer>();
        map.values.put(1, "I'm 1");
        map.values.put(2, "I'm 2");

        final Key<ContainsXKeyMap<Integer>> mapKey = getDs().save(map);

        final ContainsXKeyMap<Integer> mapLoaded = getDs().get(ContainsXKeyMap.class, mapKey.getId());

        assertNotNull(mapLoaded);
        assertEquals(2, mapLoaded.values.size());
        assertNotNull(mapLoaded.values.get(1));
        assertNotNull(mapLoaded.values.get(2));
    }

    @Test
    public void testMapLike() throws Exception {
        final ContainsMapLike ml = new ContainsMapLike();
        ml.m.put("first", "test");
        getDs().save(ml);
        final ContainsMapLike mlLoaded = getDs().find(ContainsMapLike.class).get();
        assertNotNull(mlLoaded);
        assertNotNull(mlLoaded.m);
        assertNotNull(mlLoaded.m.containsKey("first"));
    }

    @Test
    public void testPrimMap() throws Exception {
        final ContainsPrimitiveMap primMap = new ContainsPrimitiveMap();
        primMap.embeddedValues.put("first", 1L);
        primMap.embeddedValues.put("second", 2L);
        primMap.values.put("first", 1L);
        primMap.values.put("second", 2L);
        final Key<ContainsPrimitiveMap> primMapKey = getDs().save(primMap);

        final ContainsPrimitiveMap primMapLoaded = getDs().get(ContainsPrimitiveMap.class, primMapKey.getId());

        assertNotNull(primMapLoaded);
        assertEquals(2, primMapLoaded.embeddedValues.size());
        assertEquals(2, primMapLoaded.values.size());
    }

    @Test
    public void testPrimMapWithNullValue() throws Exception {
        final ContainsPrimitiveMap primMap = new ContainsPrimitiveMap();
        primMap.embeddedValues.put("first", null);
        primMap.embeddedValues.put("second", 2L);
        primMap.values.put("first", null);
        primMap.values.put("second", 2L);
        final Key<ContainsPrimitiveMap> primMapKey = getDs().save(primMap);

        final ContainsPrimitiveMap primMapLoaded = getDs().get(ContainsPrimitiveMap.class, primMapKey.getId());

        assertNotNull(primMapLoaded);
        assertEquals(2, primMapLoaded.embeddedValues.size());
        assertEquals(2, primMapLoaded.values.size());
    }

    @Test
    public void testMapWithEmbeddedInterface() throws Exception {
        final ContainsMapWithEmbeddedInterface aMap = new ContainsMapWithEmbeddedInterface();
        final Foo f1 = new Foo1();
        final Foo f2 = new Foo2();

        aMap.embeddedValues.put("first", f1);
        aMap.embeddedValues.put("second", f2);
        getDs().save(aMap);

        final ContainsMapWithEmbeddedInterface mapLoaded = getDs().find(ContainsMapWithEmbeddedInterface.class).get();

        assertNotNull(mapLoaded);
        assertEquals(2, mapLoaded.embeddedValues.size());
        assertTrue(mapLoaded.embeddedValues.get("first") instanceof Foo1);
        assertTrue(mapLoaded.embeddedValues.get("second") instanceof Foo2);

    }

    @Test
    public void testIdFieldWithUnderscore() throws Exception {
        getMorphia().map(StrangelyNamedIdField.class);
    }

    @Test
    public void testFinalIdField() throws Exception {
        getMorphia().map(HasFinalFieldId.class);
        final Key<HasFinalFieldId> savedKey = getDs().save(new HasFinalFieldId(12));
        final HasFinalFieldId loaded = getDs().get(HasFinalFieldId.class, savedKey.getId());
        assertNotNull(loaded);
        assertNotNull(loaded.id);
        assertEquals(12, loaded.id);
    }

    @Test
    public void testFinalField() throws Exception {
        getMorphia().map(ContainsFinalField.class);
        final Key<ContainsFinalField> savedKey = getDs().save(new ContainsFinalField("blah"));
        final ContainsFinalField loaded = getDs().get(ContainsFinalField.class, savedKey.getId());
        assertNotNull(loaded);
        assertNotNull(loaded.name);
        assertEquals("blah", loaded.name);
    }

    @Test
    public void testFinalFieldNotPersisted() throws Exception {
        ((DatastoreImpl) getDs()).getMapper().getOptions().setIgnoreFinals(true);
        getMorphia().map(ContainsFinalField.class);
        final Key<ContainsFinalField> savedKey = getDs().save(new ContainsFinalField("blah"));
        final ContainsFinalField loaded = getDs().get(ContainsFinalField.class, savedKey.getId());
        assertNotNull(loaded);
        assertNotNull(loaded.name);
        assertEquals("foo", loaded.name);
    }

    @Test
    public void testTimestampMapping() throws Exception {
        getMorphia().map(ContainsTimestamp.class);
        final ContainsTimestamp cts = new ContainsTimestamp();
        final Key<ContainsTimestamp> savedKey = getDs().save(cts);
        final ContainsTimestamp loaded = getDs().get(ContainsTimestamp.class, savedKey.getId());
        assertNotNull(loaded.ts);
        assertEquals(loaded.ts.getTime(), cts.ts.getTime());

    }

    @Test
    public void testCollectionMapping() throws Exception {
        getMorphia().map(ContainsCollection.class);
        final Key<ContainsCollection> savedKey = getDs().save(new ContainsCollection());
        final ContainsCollection loaded = getDs().get(ContainsCollection.class, savedKey.getId());
        assertEquals(loaded.coll, (new ContainsCollection()).coll);
        assertNotNull(loaded.id);
    }

    @Test
    public void testByteArrayMapping() throws Exception {
        getMorphia().map(ContainsByteArray.class);
        final Key<ContainsByteArray> savedKey = getDs().save(new ContainsByteArray());
        final ContainsByteArray loaded = getDs().get(ContainsByteArray.class, savedKey.getId());
        assertEquals(new String((new ContainsByteArray()).bytes), new String(loaded.bytes));
        assertNotNull(loaded.id);
    }

    @Test
    public void testBaseEntityValidity() throws Exception {
        getMorphia().map(UsesBaseEntity.class);
    }

    @Test
    public void testSerializedMapping() throws Exception {
        getMorphia().map(ContainsSerializedData.class);
        final Key<ContainsSerializedData> savedKey = getDs().save(new ContainsSerializedData());
        final ContainsSerializedData loaded = getDs().get(ContainsSerializedData.class, savedKey.getId());
        assertNotNull(loaded.data);
        assertEquals(loaded.data.someString, (new ContainsSerializedData()).data.someString);
        assertNotNull(loaded.id);
    }

    @SuppressWarnings("deprecation")
    @Test
    public void testLongArrayMapping() throws Exception {
        getMorphia().map(ContainsLongAndStringArray.class);
        getDs().save(new ContainsLongAndStringArray());
        ContainsLongAndStringArray loaded = getDs().<ContainsLongAndStringArray>find(ContainsLongAndStringArray.class).get();
        assertEquals(loaded.longs, (new ContainsLongAndStringArray()).longs);
        assertEquals(loaded.strings, (new ContainsLongAndStringArray()).strings);

        final ContainsLongAndStringArray array = new ContainsLongAndStringArray();
        array.strings = new String[]{"a", "B", "c"};
        array.longs = new Long[]{4L, 5L, 4L};
        final Key<ContainsLongAndStringArray> k1 = getDs().save(array);
        loaded = getDs().getByKey(ContainsLongAndStringArray.class, k1);
        assertEquals(loaded.longs, array.longs);
        assertEquals(loaded.strings, array.strings);

        assertNotNull(loaded.id);
    }

    @Test
    public void testDbRefMapping() throws Exception {
        getMorphia().map(ContainsRef.class).map(Rectangle.class);
        final DBCollection stuff = getDb().getCollection("stuff");
        final DBCollection rectangles = getDb().getCollection("rectangles");

        assertTrue("'ne' field should not be persisted!", !getMorphia().getMapper().getMCMap().get(ContainsRef.class.getName())
                                                               .containsJavaFieldName("ne"));

        final Rectangle r = new Rectangle(1, 1);
        final DBObject rDbObject = getMorphia().toDBObject(r);
        rDbObject.put("_ns", rectangles.getName());
        rectangles.save(rDbObject);

        final ContainsRef cRef = new ContainsRef();
        cRef.rect = new DBRef((String) rDbObject.get("_ns"), rDbObject.get("_id"));
        final DBObject cRefDbObject = getMorphia().toDBObject(cRef);
        stuff.save(cRefDbObject);
        final BasicDBObject cRefDbObjectLoaded = (BasicDBObject) stuff.findOne(BasicDBObjectBuilder.start("_id", cRefDbObject.get("_id"))
                                                                                                   .get());
        final ContainsRef cRefLoaded = getMorphia().fromDBObject(ContainsRef.class, cRefDbObjectLoaded, new DefaultEntityCache());
        assertNotNull(cRefLoaded);
        assertNotNull(cRefLoaded.rect);
        assertNotNull(cRefLoaded.rect.getId());
        assertNotNull(cRefLoaded.rect.getCollectionName());
        assertEquals(cRefLoaded.rect.getId(), cRef.rect.getId());
        assertEquals(cRefLoaded.rect.getCollectionName(), cRef.rect.getCollectionName());
    }

    @Test
    public void testBadMappings() throws Exception {
        try {
            getMorphia().map(MissingId.class);
            fail("Validation: Missing @Id field not caught");
        } catch (MappingException e) {

        }

        try {
            getMorphia().map(IdOnEmbedded.class);
            fail("Validation: @Id field on @Embedded not caught");
        } catch (MappingException e) {

        }

        try {
            getMorphia().map(RenamedEmbedded.class);
            fail("Validation: @Embedded(\"name\") not caught on Class");
        } catch (MappingException e) {

        }

        try {
            getMorphia().map(MissingIdStill.class);
            fail("Validation: Missing @Id field not not caught");
        } catch (MappingException e) {

        }

        try {
            getMorphia().map(MissingIdRenamed.class);
            fail("Validation: Missing @Id field not not caught");
        } catch (MappingException e) {

        }

        try {
            getMorphia().map(NonStaticInnerClass.class);
            fail("Validation: Non-static inner class allowed");
        } catch (MappingException e) {

        }
    }


    @Test
    public void testBasicMapping() throws Exception {
        final DBCollection hotels = getDb().getCollection("hotels");
        final DBCollection agencies = getDb().getCollection("agencies");

        getMorphia().map(Hotel.class);
        getMorphia().map(TravelAgency.class);

        final Hotel borg = new Hotel();
        borg.setName("Hotel Borg");
        borg.setStars(4);
        borg.setTakesCreditCards(true);
        borg.setStartDate(new Date());
        borg.setType(Hotel.Type.LEISURE);
        borg.getTags().add("Swimming pool");
        borg.getTags().add("Room service");
        borg.setTemp("A temporary transient value");
        borg.getPhoneNumbers().add(new PhoneNumber(354, 5152233, PhoneNumber.Type.PHONE));
        borg.getPhoneNumbers().add(new PhoneNumber(354, 5152244, PhoneNumber.Type.FAX));

        final Address address = new Address();
        address.setStreet("Posthusstraeti 11");
        address.setPostCode("101");
        borg.setAddress(address);

        BasicDBObject hotelDbObj = (BasicDBObject) getMorphia().toDBObject(borg);
        assertTrue(!(((DBObject) ((List) hotelDbObj.get("phoneNumbers")).get(0)).containsField(Mapper.CLASS_NAME_FIELDNAME)));


        hotels.save(hotelDbObj);

        Hotel borgLoaded = getMorphia().fromDBObject(Hotel.class, hotelDbObj, new DefaultEntityCache());

        assertEquals(borg.getName(), borgLoaded.getName());
        assertEquals(borg.getStars(), borgLoaded.getStars());
        assertEquals(borg.getStartDate(), borgLoaded.getStartDate());
        assertEquals(borg.getType(), borgLoaded.getType());
        assertEquals(borg.getAddress().getStreet(), borgLoaded.getAddress().getStreet());
        assertEquals(borg.getTags().size(), borgLoaded.getTags().size());
        assertEquals(borg.getTags(), borgLoaded.getTags());
        assertEquals(borg.getPhoneNumbers().size(), borgLoaded.getPhoneNumbers().size());
        assertEquals(borg.getPhoneNumbers().get(1), borgLoaded.getPhoneNumbers().get(1));
        assertNull(borgLoaded.getTemp());
        assertTrue(borgLoaded.getPhoneNumbers() instanceof Vector);
        assertNotNull(borgLoaded.getId());

        final TravelAgency agency = new TravelAgency();
        agency.setName("Lastminute.com");
        agency.getHotels().add(borgLoaded);

        final BasicDBObject agencyDbObj = (BasicDBObject) getMorphia().toDBObject(agency);
        agencies.save(agencyDbObj);

        final TravelAgency agencyLoaded = getMorphia().fromDBObject(TravelAgency.class,
                                                                    agencies.findOne(new BasicDBObject(Mapper.ID_KEY,
                                                                                                       agencyDbObj.get(Mapper.ID_KEY))),
                                                                    new DefaultEntityCache());

        assertEquals(agency.getName(), agencyLoaded.getName());
        assertEquals(1, agency.getHotels().size());
        assertEquals(agency.getHotels().get(0).getName(), borg.getName());


        borgLoaded.setAddress(null);
        borgLoaded.getPhoneNumbers().clear();
        borgLoaded.setName(null);

        hotelDbObj = (BasicDBObject) getMorphia().toDBObject(borgLoaded);
        hotels.save(hotelDbObj);

        hotelDbObj = (BasicDBObject) hotels.findOne(new BasicDBObject(Mapper.ID_KEY, hotelDbObj.get(Mapper.ID_KEY)));

        borgLoaded = getMorphia().fromDBObject(Hotel.class, hotelDbObj, new DefaultEntityCache());
        assertNull(borgLoaded.getAddress());
        assertEquals(0, borgLoaded.getPhoneNumbers().size());
        assertNull(borgLoaded.getName());
    }

    @Test
    public void testMaps() throws Exception {
        final DBCollection articles = getDb().getCollection("articles");
        getMorphia().map(Article.class).map(Translation.class).map(Circle.class);

        final Article related = new Article();
        final BasicDBObject relatedDbObj = (BasicDBObject) getMorphia().toDBObject(related);
        articles.save(relatedDbObj);

        final Article relatedLoaded = getMorphia().fromDBObject(Article.class,
                                                                articles.findOne(new BasicDBObject(Mapper.ID_KEY,
                                                                                                   relatedDbObj.get(Mapper.ID_KEY))),
                                                                new DefaultEntityCache());

        final Article article = new Article();
        article.setTranslation("en", new Translation("Hello World", "Just a test"));
        article.setTranslation("is", new Translation("HallÃ³ heimur", "Bara aÃ° prÃ³fa"));

        article.setAttribute("myDate", new Date());
        article.setAttribute("myString", "Test");
        article.setAttribute("myInt", 123);

        article.putRelated("test", relatedLoaded);

        final BasicDBObject articleDbObj = (BasicDBObject) getMorphia().toDBObject(article);
        articles.save(articleDbObj);

        final Article articleLoaded = getMorphia().fromDBObject(Article.class,
                                                                articles.findOne(
                                                                                    new BasicDBObject(Mapper.ID_KEY,
                                                                                                      articleDbObj.get(Mapper.ID_KEY))),
                                                                new DefaultEntityCache());

        assertEquals(article.getTranslations().size(), articleLoaded.getTranslations().size());
        assertEquals(article.getTranslation("en").getTitle(), articleLoaded.getTranslation("en").getTitle());
        assertEquals(article.getTranslation("is").getBody(), articleLoaded.getTranslation("is").getBody());
        assertEquals(article.getAttributes().size(), articleLoaded.getAttributes().size());
        assertEquals(article.getAttribute("myDate"), articleLoaded.getAttribute("myDate"));
        assertEquals(article.getAttribute("myString"), articleLoaded.getAttribute("myString"));
        assertEquals(article.getAttribute("myInt"), articleLoaded.getAttribute("myInt"));
        assertEquals(article.getRelated().size(), articleLoaded.getRelated().size());
        assertEquals(article.getRelated("test").getId(), articleLoaded.getRelated("test").getId());
    }


    @Test(expected = MappingException.class)
    public void testReferenceWithoutIdValue() throws Exception {
        final RecursiveParent parent = new RecursiveParent();
        final RecursiveChild child = new RecursiveChild();
        child.setId(null);
        parent.setChild(child);
        getDs().save(parent);

    }

    @Test
    public void testRecursiveReference() throws Exception {
        final DBCollection stuff = getDb().getCollection("stuff");

        getMorphia().map(RecursiveParent.class).map(RecursiveChild.class);

        final RecursiveParent parent = new RecursiveParent();
        final DBObject parentDbObj = getMorphia().toDBObject(parent);
        stuff.save(parentDbObj);

        final RecursiveChild child = new RecursiveChild();
        final DBObject childDbObj = getMorphia().toDBObject(child);
        stuff.save(childDbObj);

        final RecursiveParent parentLoaded = getMorphia().fromDBObject(RecursiveParent.class,
                                                                       stuff.findOne(new BasicDBObject(Mapper.ID_KEY,
                                                                                                       parentDbObj.get(Mapper.ID_KEY))),
                                                                       new DefaultEntityCache());
        final RecursiveChild childLoaded = getMorphia().fromDBObject(RecursiveChild.class,
                                                                     stuff.findOne(new BasicDBObject(Mapper.ID_KEY,
                                                                                                     childDbObj.get(Mapper.ID_KEY))),
                                                                     new DefaultEntityCache());

        parentLoaded.setChild(childLoaded);
        childLoaded.setParent(parentLoaded);

        stuff.save(getMorphia().toDBObject(parentLoaded));
        stuff.save(getMorphia().toDBObject(childLoaded));

        final RecursiveParent finalParentLoaded = getMorphia().fromDBObject(RecursiveParent.class,
                                                                            stuff.findOne(new BasicDBObject(Mapper.ID_KEY,
                                                                                                            parentDbObj.get(Mapper
                                                                                                                                .ID_KEY))),
                                                                            new DefaultEntityCache());
        final RecursiveChild finalChildLoaded = getMorphia().fromDBObject(RecursiveChild.class,
                                                                          stuff.findOne(new BasicDBObject(Mapper.ID_KEY,
                                                                                                          childDbObj.get(Mapper.ID_KEY))),
                                                                          new DefaultEntityCache());

        assertNotNull(finalParentLoaded.getChild());
        assertNotNull(finalChildLoaded.getParent());
    }
}

<code block>
package org.mongodb.morphia.mapping;


import com.mongodb.DBObject;
import org.mongodb.morphia.ObjectFactory;
import org.mongodb.morphia.annotations.ConstructorArgs;
import org.mongodb.morphia.logging.Logger;
import org.mongodb.morphia.logging.MorphiaLoggerFactory;

import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;



public class DefaultCreator implements ObjectFactory {

    private static final Logger LOG = MorphiaLoggerFactory.get(DefaultCreator.class);

    private Map<String, Class> classNameCache = new ConcurrentHashMap<String, Class>();

    private MapperOptions options = null;

    public DefaultCreator() {
    }

    public DefaultCreator(final MapperOptions options) {
        this.options = options;
    }


    private <T> T newInstance(final Constructor<T> tryMe, final Class<T> fallbackType) {
        if (tryMe != null) {
            tryMe.setAccessible(true);
            try {
                return tryMe.newInstance();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
        return createInst(fallbackType);
    }

    private static <T> Constructor<T> getNoArgsConstructor(final Class<T> type) {
        try {
            final Constructor<T> constructor = type.getDeclaredConstructor();
            constructor.setAccessible(true);
            return constructor;
        } catch (NoSuchMethodException e) {
            throw new MappingException("No usable constructor for " + type.getName(), e);
        }
    }

    @Override
    public <T> T createInstance(final Class<T> clazz) {
        return createInst(clazz);
    }

    @Override
    public <T> T createInstance(final Class<T> clazz, final DBObject dbObj) {
        Class<T> c = getClass(dbObj);
        if (c == null) {
            c = clazz;
        }
        return createInstance(c);
    }

    @Override
    @SuppressWarnings("unchecked")
    public Object createInstance(final Mapper mapper, final MappedField mf, final DBObject dbObj) {
        Class c = getClass(dbObj);
        if (c == null) {
            c = mf.isSingleValue() ? mf.getConcreteType() : mf.getSubClass();
        }
        try {
            return createInstance(c, dbObj);
        } catch (RuntimeException e) {
            final ConstructorArgs argAnn = mf.getAnnotation(ConstructorArgs.class);
            if (argAnn == null) {
                throw e;
            }

            final Object[] args = new Object[argAnn.value().length];
            final Class[] argTypes = new Class[argAnn.value().length];
            for (int i = 0; i < argAnn.value().length; i++) {


                final Object val = dbObj.get(argAnn.value()[i]);
                args[i] = val;
                argTypes[i] = val.getClass();
            }
            try {
                final Constructor constructor = c.getDeclaredConstructor(argTypes);
                constructor.setAccessible(true);
                return constructor.newInstance(args);
            } catch (Exception ex) {
                throw new RuntimeException(ex);
            }
        }
    }

    @Override
    @SuppressWarnings("unchecked")
    public Map createMap(final MappedField mf) {
        return newInstance(mf != null ? mf.getCTor() : null, HashMap.class);
    }

    @Override
    @SuppressWarnings("unchecked")
    public List createList(final MappedField mf) {
        return newInstance(mf != null ? mf.getCTor() : null, ArrayList.class);
    }

    @Override
    @SuppressWarnings("unchecked")
    public Set createSet(final MappedField mf) {
        return newInstance(mf != null ? mf.getCTor() : null, HashSet.class);
    }

    @SuppressWarnings("unchecked")
    private <T> Class<T> getClass(final DBObject dbObj) {

        Class c = null;
        if (dbObj.containsField(Mapper.CLASS_NAME_FIELDNAME)) {
            final String className = (String) dbObj.get(Mapper.CLASS_NAME_FIELDNAME);


            try {
                if (options != null && options.isCacheClassLookups()) {
                    c = classNameCache.get(className);
                    if (c == null) {
                        c = Class.forName(className, true, getClassLoaderForClass());
                        classNameCache.put(className, c);
                    }
                } else {
                    c = Class.forName(className, true, getClassLoaderForClass());
                }
            } catch (ClassNotFoundException e) {
                if (LOG.isWarningEnabled()) {
                    LOG.warning("Class not found defined in dbObj: ", e);
                }
            }
        }
        return c;
    }

    protected ClassLoader getClassLoaderForClass() {
        return Thread.currentThread().getContextClassLoader();
    }

    @SuppressWarnings("unchecked")
    public <T> T createInst(final Class<T> clazz) {
        try {
            return getNoArgsConstructor(clazz).newInstance();
        } catch (Exception e) {
            if (Collection.class.isAssignableFrom(clazz)) {
                return (T) createList(null);
            } else if (Map.class.isAssignableFrom(clazz)) {
                return (T) createMap(null);
            } else if (Set.class.isAssignableFrom(clazz)) {
                return (T) createSet(null);
            }
            throw new MappingException("No usable constructor for " + clazz.getName(), e);
        }
    }

    public Map<String, Class> getClassNameCache() {
        HashMap<String, Class> copy = new HashMap<String, Class>();
        copy.putAll(classNameCache);
        return copy;
    }

}

<code block>
package org.mongodb.morphia.mapping;


import org.mongodb.morphia.ObjectFactory;
import org.mongodb.morphia.mapping.lazy.DatastoreProvider;
import org.mongodb.morphia.mapping.lazy.DefaultDatastoreProvider;



public class MapperOptions {
    private boolean actLikeSerializer;
    private boolean ignoreFinals; 
    private boolean storeNulls;
    private boolean storeEmpties;
    private boolean useLowerCaseCollectionNames;
    private boolean cacheClassLookups = false;
    private ObjectFactory objectFactory = new DefaultCreator(this);
    private CustomMapper embeddedMapper = new EmbeddedMapper();
    private CustomMapper defaultMapper = embeddedMapper;
    private CustomMapper referenceMapper = new ReferenceMapper();
    private CustomMapper valueMapper = new ValueMapper();
    private DatastoreProvider datastoreProvider = new DefaultDatastoreProvider();

    public CustomMapper getDefaultMapper() {
        return defaultMapper;
    }

    public void setDefaultMapper(final CustomMapper pDefaultMapper) {
        defaultMapper = pDefaultMapper;
    }

    public CustomMapper getEmbeddedMapper() {
        return embeddedMapper;
    }

    public void setEmbeddedMapper(final CustomMapper pEmbeddedMapper) {
        embeddedMapper = pEmbeddedMapper;
    }

    public ObjectFactory getObjectFactory() {
        return objectFactory;
    }


    public void setObjectFactory(final ObjectFactory objectFactory) {
        this.objectFactory = objectFactory;
    }

    public CustomMapper getReferenceMapper() {
        return referenceMapper;
    }

    public void setReferenceMapper(final CustomMapper pReferenceMapper) {
        referenceMapper = pReferenceMapper;
    }

    public CustomMapper getValueMapper() {
        return valueMapper;
    }

    public void setValueMapper(final CustomMapper pValueMapper) {
        valueMapper = pValueMapper;
    }

    public boolean isActLikeSerializer() {
        return actLikeSerializer;
    }


    public void setActLikeSerializer(final boolean actLikeSerializer) {
        this.actLikeSerializer = actLikeSerializer;
    }

    public boolean isIgnoreFinals() {
        return ignoreFinals;
    }


    public void setIgnoreFinals(final boolean ignoreFinals) {
        this.ignoreFinals = ignoreFinals;
    }

    public boolean isStoreEmpties() {
        return storeEmpties;
    }


    public void setStoreEmpties(final boolean storeEmpties) {
        this.storeEmpties = storeEmpties;
    }

    public boolean isStoreNulls() {
        return storeNulls;
    }


    public void setStoreNulls(final boolean storeNulls) {
        this.storeNulls = storeNulls;
    }

    public boolean isUseLowerCaseCollectionNames() {
        return useLowerCaseCollectionNames;
    }


    public void setUseLowerCaseCollectionNames(final boolean useLowerCaseCollectionNames) {
        this.useLowerCaseCollectionNames = useLowerCaseCollectionNames;
    }

    public DatastoreProvider getDatastoreProvider() {
        return datastoreProvider;
    }

    public void setDatastoreProvider(final DatastoreProvider datastoreProvider) {
        datastoreProvider.register(this.getDatastoreProvider().get());
        this.datastoreProvider = datastoreProvider;
    }

    public boolean isCacheClassLookups() {
        return cacheClassLookups;
    }

    public void setCacheClassLookups(final boolean cacheClassLookups) {
        this.cacheClassLookups = cacheClassLookups;
    }
}

<code block>
package org.mongodb.morphia.mapping;


import com.mongodb.DBObject;
import org.mongodb.morphia.EntityInterceptor;
import org.mongodb.morphia.annotations.Converters;
import org.mongodb.morphia.annotations.Embedded;
import org.mongodb.morphia.annotations.Entity;
import org.mongodb.morphia.annotations.EntityListeners;
import org.mongodb.morphia.annotations.Field;
import org.mongodb.morphia.annotations.Id;
import org.mongodb.morphia.annotations.IndexOptions;
import org.mongodb.morphia.annotations.Indexes;
import org.mongodb.morphia.annotations.Polymorphic;
import org.mongodb.morphia.annotations.PostLoad;
import org.mongodb.morphia.annotations.PostPersist;
import org.mongodb.morphia.annotations.PreLoad;
import org.mongodb.morphia.annotations.PrePersist;
import org.mongodb.morphia.annotations.PreSave;
import org.mongodb.morphia.annotations.Property;
import org.mongodb.morphia.annotations.Reference;
import org.mongodb.morphia.annotations.Serialized;
import org.mongodb.morphia.annotations.Transient;
import org.mongodb.morphia.annotations.Version;
import org.mongodb.morphia.logging.Logger;
import org.mongodb.morphia.logging.MorphiaLoggerFactory;
import org.mongodb.morphia.mapping.validation.MappingValidator;
import org.mongodb.morphia.utils.ReflectionUtils;

import java.io.Serializable;
import java.lang.annotation.Annotation;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static java.lang.String.format;
import static java.util.Arrays.asList;



public class MappedClass {
    private static class ClassMethodPair {
        private final Class<?> clazz;
        private final Method method;

        public ClassMethodPair(final Class<?> c, final Method m) {
            clazz = c;
            method = m;
        }
    }

    private static final Logger LOG = MorphiaLoggerFactory.get(MappedClass.class);


    private static final List<Class<? extends Annotation>> INTERESTING_ANNOTATIONS = new ArrayList<Class<? extends Annotation>>();

    static {
        INTERESTING_ANNOTATIONS.add(Embedded.class);
        INTERESTING_ANNOTATIONS.add(Entity.class);
        INTERESTING_ANNOTATIONS.add(Polymorphic.class);
        INTERESTING_ANNOTATIONS.add(EntityListeners.class);
        INTERESTING_ANNOTATIONS.add(Version.class);
        INTERESTING_ANNOTATIONS.add(Converters.class);
        INTERESTING_ANNOTATIONS.add(Indexes.class);
        INTERESTING_ANNOTATIONS.add(Field.class);
        INTERESTING_ANNOTATIONS.add(IndexOptions.class);
    }


    private java.lang.reflect.Field idField;


    private Entity entityAn;
    private Embedded embeddedAn;


    @SuppressWarnings("unchecked")
    private static final List<Class<? extends Annotation>> LIFECYCLE_ANNOTATIONS = asList(PrePersist.class,
                                                                                          PreSave.class,
                                                                                          PreLoad.class,
                                                                                          PostPersist.class,
                                                                                          PostLoad.class);

    private final Map<Class<? extends Annotation>, List<Annotation>> foundAnnotations = 
        new HashMap<Class<? extends Annotation>, List<Annotation>>();


    private final Map<Class<? extends Annotation>, List<ClassMethodPair>> lifecycleMethods = 
        new HashMap<Class<? extends Annotation>, List<ClassMethodPair>>();


    private final List<MappedField> persistenceFields = new ArrayList<MappedField>();


    private final Class<?> clazz;

    private final Mapper mapper;

    public static void addInterestingAnnotation(final Class<? extends Annotation> annotation) {
        INTERESTING_ANNOTATIONS.add(annotation);
    }


    public MappedClass(final Class<?> clazz, final Mapper mapper) {
        this.mapper = mapper;
        this.clazz = clazz;

        if (LOG.isTraceEnabled()) {
            LOG.trace("Creating MappedClass for " + clazz);
        }

        basicValidate();
        discover();

        if (LOG.isDebugEnabled()) {
            LOG.debug("MappedClass done: " + toString());
        }
    }

    protected void basicValidate() {
        final boolean isStatic = Modifier.isStatic(clazz.getModifiers());
        if (!isStatic && clazz.isMemberClass()) {
            throw new MappingException("Cannot use non-static inner class: " + clazz + ". Please make static.");
        }
    }



    public void update() {
        embeddedAn = (Embedded) getAnnotation(Embedded.class);
        entityAn = (Entity) getFirstAnnotation(Entity.class);

        final List<MappedField> fields = getFieldsAnnotatedWith(Id.class);
        if (fields != null && !fields.isEmpty()) {
            idField = fields.get(0).getField();
        }
    }


    protected void discover() {
        for (final Class<? extends Annotation> c : INTERESTING_ANNOTATIONS) {
            addAnnotation(c);
        }

        final List<Class<?>> lifecycleClasses = new ArrayList<Class<?>>();
        lifecycleClasses.add(clazz);

        final EntityListeners entityLisAnn = (EntityListeners) getAnnotation(EntityListeners.class);
        if (entityLisAnn != null && entityLisAnn.value() != null && entityLisAnn.value().length != 0) {
            Collections.addAll(lifecycleClasses, entityLisAnn.value());
        }

        for (final Class<?> cls : lifecycleClasses) {
            for (final Method m : ReflectionUtils.getDeclaredAndInheritedMethods(cls)) {
                for (final Class<? extends Annotation> c : LIFECYCLE_ANNOTATIONS) {
                    if (m.isAnnotationPresent(c)) {
                        addLifecycleEventMethod(c, m, cls.equals(clazz) ? null : cls);
                    }
                }
            }
        }

        update();

        for (final java.lang.reflect.Field field : ReflectionUtils.getDeclaredAndInheritedFields(clazz, true)) {
            field.setAccessible(true);
            final int fieldMods = field.getModifiers();
            if (!isIgnorable(field, fieldMods)) {
                if (field.isAnnotationPresent(Id.class)) {
                    persistenceFields.add(new MappedField(field, clazz, getMapper()));
                    update();
                } else if (field.isAnnotationPresent(Property.class)
                           || field.isAnnotationPresent(Reference.class)
                           || field.isAnnotationPresent(Embedded.class)
                           || field.isAnnotationPresent(Serialized.class)
                           || isSupportedType(field.getType())
                           || ReflectionUtils.implementsInterface(field.getType(), Serializable.class)) {
                    persistenceFields.add(new MappedField(field, clazz, getMapper()));
                } else {
                    if (mapper.getOptions().getDefaultMapper() != null) {
                        persistenceFields.add(new MappedField(field, clazz, getMapper()));
                    } else if (LOG.isWarningEnabled()) {
                        LOG.warning(format("Ignoring (will not persist) field: %s.%s [type:%s]", clazz.getName(), field.getName(),
                                           field.getType().getName()));
                    }
                }
            }
        }
    }

    private boolean isIgnorable(final java.lang.reflect.Field field, final int fieldMods) {
        return field.isAnnotationPresent(Transient.class)
            || field.isSynthetic() && (fieldMods & Modifier.TRANSIENT) == Modifier.TRANSIENT
            || mapper.getOptions().isActLikeSerializer() && ((fieldMods & Modifier.TRANSIENT) == Modifier.TRANSIENT)
            || mapper.getOptions().isIgnoreFinals() && ((fieldMods & Modifier.FINAL) == Modifier.FINAL);
    }

    private void addLifecycleEventMethod(final Class<? extends Annotation> lceClazz, final Method m, final Class<?> clazz) {
        final ClassMethodPair cm = new ClassMethodPair(clazz, m);
        if (lifecycleMethods.containsKey(lceClazz)) {
            lifecycleMethods.get(lceClazz).add(cm);
        } else {
            final List<ClassMethodPair> methods = new ArrayList<ClassMethodPair>();
            methods.add(cm);
            lifecycleMethods.put(lceClazz, methods);
        }
    }


    public void addAnnotation(final Class<? extends Annotation> clazz, final Annotation ann) {
        if (ann == null || clazz == null) {
            return;
        }

        if (!foundAnnotations.containsKey(clazz)) {
            foundAnnotations.put(clazz, new ArrayList<Annotation>());
        }

        foundAnnotations.get(clazz).add(ann);
    }

    public List<ClassMethodPair> getLifecycleMethods(final Class<Annotation> clazz) {
        return lifecycleMethods.get(clazz);
    }


    private void addAnnotation(final Class<? extends Annotation> clazz) {
        final List<? extends Annotation> annotations = ReflectionUtils.getAnnotations(getClazz(), clazz);
        for (final Annotation ann : annotations) {
            addAnnotation(clazz, ann);
        }
    }

    @Override
    public String toString() {
        return "MappedClass - kind:" + getCollectionName() + " for " + getClazz().getName() + " fields:" + persistenceFields;
    }


    public List<MappedField> getFieldsAnnotatedWith(final Class<? extends Annotation> clazz) {
        final List<MappedField> results = new ArrayList<MappedField>();
        for (final MappedField mf : persistenceFields) {
            if (mf.getAnnotations().containsKey(clazz)) {
                results.add(mf);
            }
        }
        return results;
    }


    public MappedField getMappedField(final String storedName) {
        for (final MappedField mf : persistenceFields) {
            for (final String n : mf.getLoadNames()) {
                if (storedName.equals(n)) {
                    return mf;
                }
            }
        }

        return null;
    }


    public boolean containsJavaFieldName(final String name) {
        return getMappedField(name) != null;
    }


    public MappedField getMappedFieldByJavaField(final String name) {
        for (final MappedField mf : persistenceFields) {
            if (name.equals(mf.getJavaFieldName())) {
                return mf;
            }
        }

        return null;
    }


    public static boolean isSupportedType(final Class<?> clazz) {
        if (ReflectionUtils.isPropertyType(clazz)) {
            return true;
        }
        if (clazz.isArray() || Map.class.isAssignableFrom(clazz) || Iterable.class.isAssignableFrom(clazz)) {
            Class<?> subType;
            if (clazz.isArray()) {
                subType = clazz.getComponentType();
            } else {
                subType = ReflectionUtils.getParameterizedClass(clazz);
            }


            if (subType != null && subType != Object.class && !ReflectionUtils.isPropertyType(subType)) {
                return false;
            }


            return true;
        }
        return false;
    }

    @SuppressWarnings("deprecation")
    public void validate() {
        new MappingValidator(mapper.getOptions().getObjectFactory()).validate(this);
    }

    @Override
    public boolean equals(final Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        final MappedClass that = (MappedClass) o;

        return clazz.equals(that.clazz);

    }

    @Override
    public int hashCode() {
        return clazz.hashCode();
    }


    @SuppressWarnings({"WMI", "unchecked"})
    public DBObject callLifecycleMethods(final Class<? extends Annotation> event, final Object entity, final DBObject dbObj) {
        final List<ClassMethodPair> methodPairs = getLifecycleMethods((Class<Annotation>) event);
        DBObject retDbObj = dbObj;
        try {
            Object tempObj;
            if (methodPairs != null) {
                final HashMap<Class<?>, Object> toCall = new HashMap<Class<?>, Object>((int) (methodPairs.size() * 1.3));
                for (final ClassMethodPair cm : methodPairs) {
                    toCall.put(cm.clazz, null);
                }
                for (final Class<?> c : toCall.keySet()) {
                    if (c != null) {
                        toCall.put(c, getOrCreateInstance(c));
                    }
                }

                for (final ClassMethodPair cm : methodPairs) {
                    final Method method = cm.method;
                    final Object inst = toCall.get(cm.clazz);
                    method.setAccessible(true);

                    if (LOG.isDebugEnabled()) {
                        LOG.debug(format("Calling lifecycle method(@%s %s) on %s", event.getSimpleName(), method, inst));
                    }

                    if (inst == null) {
                        if (method.getParameterTypes().length == 0) {
                            tempObj = method.invoke(entity);
                        } else {
                            tempObj = method.invoke(entity, retDbObj);
                        }
                    } else if (method.getParameterTypes().length == 0) {
                        tempObj = method.invoke(inst);
                    } else if (method.getParameterTypes().length == 1) {
                        tempObj = method.invoke(inst, entity);
                    } else {
                        tempObj = method.invoke(inst, entity, retDbObj);
                    }

                    if (tempObj != null) {
                        retDbObj = (DBObject) tempObj;
                    }
                }
            }

            callGlobalInterceptors(event, entity, dbObj, mapper.getInterceptors());
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        } catch (InvocationTargetException e) {
            throw new RuntimeException(e);
        }

        return retDbObj;
    }

    private Object getOrCreateInstance(final Class<?> clazz) {
        if (mapper.getInstanceCache().containsKey(clazz)) {
            return mapper.getInstanceCache().get(clazz);
        }

        final Object o = mapper.getOptions().getObjectFactory().createInstance(clazz);
        final Object nullO = mapper.getInstanceCache().put(clazz, o);
        if (nullO != null) {
            if (LOG.isErrorEnabled()) {
                LOG.error("Race-condition, created duplicate class: " + clazz);
            }
        }

        return o;

    }

    private void callGlobalInterceptors(final Class<? extends Annotation> event, final Object entity, final DBObject dbObj,
                                        final Collection<EntityInterceptor> interceptors) {
        for (final EntityInterceptor ei : interceptors) {
            if (LOG.isDebugEnabled()) {
                LOG.debug("Calling interceptor method " + event.getSimpleName() + " on " + ei);
            }

            if (event.equals(PreLoad.class)) {
                ei.preLoad(entity, dbObj, mapper);
            } else if (event.equals(PostLoad.class)) {
                ei.postLoad(entity, dbObj, mapper);
            } else if (event.equals(PrePersist.class)) {
                ei.prePersist(entity, dbObj, mapper);
            } else if (event.equals(PreSave.class)) {
                ei.preSave(entity, dbObj, mapper);
            } else if (event.equals(PostPersist.class)) {
                ei.postPersist(entity, dbObj, mapper);
            }
        }
    }


    public java.lang.reflect.Field getIdField() {
        return idField;
    }


    public Entity getEntityAnnotation() {
        return entityAn;
    }


    public Embedded getEmbeddedAnnotation() {
        return embeddedAn;
    }


    public Map<Class<? extends Annotation>, List<Annotation>> getRelevantAnnotations() {
        return foundAnnotations;
    }


    public Annotation getFirstAnnotation(final Class<? extends Annotation> clazz) {
        final List<Annotation> found = foundAnnotations.get(clazz);
        return found == null || found.isEmpty() ? null : found.get(0);
    }


    public Annotation getAnnotation(final Class<? extends Annotation> clazz) {
        final List<Annotation> found = foundAnnotations.get(clazz);
        return found == null || found.isEmpty() ? null : found.get(found.size() - 1);
    }


    public List<Annotation> getAnnotations(final Class<? extends Annotation> clazz) {
        return foundAnnotations.get(clazz);
    }


    public List<MappedField> getPersistenceFields() {
        return persistenceFields;
    }


    public String getCollectionName() {
        if (entityAn == null || entityAn.value().equals(Mapper.IGNORED_FIELDNAME)) {
            return mapper.getOptions().isUseLowerCaseCollectionNames() ? clazz.getSimpleName().toLowerCase() : clazz.getSimpleName();
        }
        return entityAn.value();
    }


    public Class<?> getClazz() {
        return clazz;
    }


    public Mapper getMapper() {
        return mapper;
    }

    public MappedField getMappedIdField() {
        List<MappedField> fields = getFieldsAnnotatedWith(Id.class);
        return fields.isEmpty() ? null : fields.get(0);
    }

}
<code block>
package org.mongodb.morphia.mapping.validation;

import org.mongodb.morphia.ObjectFactory;
import org.mongodb.morphia.annotations.Embedded;
import org.mongodb.morphia.annotations.Property;
import org.mongodb.morphia.annotations.Reference;
import org.mongodb.morphia.annotations.Serialized;
import org.mongodb.morphia.logging.Logger;
import org.mongodb.morphia.logging.MorphiaLoggerFactory;
import org.mongodb.morphia.mapping.MappedClass;
import org.mongodb.morphia.mapping.validation.ConstraintViolation.Level;
import org.mongodb.morphia.mapping.validation.classrules.DuplicatedAttributeNames;
import org.mongodb.morphia.mapping.validation.classrules.EmbeddedAndId;
import org.mongodb.morphia.mapping.validation.classrules.EmbeddedAndValue;
import org.mongodb.morphia.mapping.validation.classrules.EntityAndEmbed;
import org.mongodb.morphia.mapping.validation.classrules.EntityCannotBeMapOrIterable;
import org.mongodb.morphia.mapping.validation.classrules.MultipleId;
import org.mongodb.morphia.mapping.validation.classrules.MultipleVersions;
import org.mongodb.morphia.mapping.validation.classrules.NoId;
import org.mongodb.morphia.mapping.validation.fieldrules.ContradictingFieldAnnotation;
import org.mongodb.morphia.mapping.validation.fieldrules.LazyReferenceMissingDependencies;
import org.mongodb.morphia.mapping.validation.fieldrules.LazyReferenceOnArray;
import org.mongodb.morphia.mapping.validation.fieldrules.MapKeyDifferentFromString;
import org.mongodb.morphia.mapping.validation.fieldrules.MapNotSerializable;
import org.mongodb.morphia.mapping.validation.fieldrules.MisplacedProperty;
import org.mongodb.morphia.mapping.validation.fieldrules.ReferenceToUnidentifiable;
import org.mongodb.morphia.mapping.validation.fieldrules.VersionMisuse;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import static java.lang.String.format;



public class MappingValidator {

    private static final Logger LOG = MorphiaLoggerFactory.get(MappingValidator.class);
    private ObjectFactory creator;

    public MappingValidator(final ObjectFactory objectFactory) {
        creator = objectFactory;
    }

    public void validate(final List<MappedClass> classes) {
        final Set<ConstraintViolation> ve = new TreeSet<ConstraintViolation>(new Comparator<ConstraintViolation>() {

            public int compare(final ConstraintViolation o1, final ConstraintViolation o2) {
                return o1.getLevel().ordinal() > o2.getLevel().ordinal() ? -1 : 1;
            }
        });

        final List<ClassConstraint> rules = getConstraints();
        for (final MappedClass c : classes) {
            for (final ClassConstraint v : rules) {
                v.check(c, ve);
            }
        }

        if (!ve.isEmpty()) {
            final ConstraintViolation worst = ve.iterator().next();
            final Level maxLevel = worst.getLevel();
            if (maxLevel.ordinal() >= Level.FATAL.ordinal()) {
                throw new ConstraintViolationException(ve);
            }


            final List<LogLine> l = new ArrayList<LogLine>();
            for (final ConstraintViolation v : ve) {
                l.add(new LogLine(v));
            }
            Collections.sort(l);

            for (final LogLine line : l) {
                line.log(LOG);
            }
        }
    }

    private List<ClassConstraint> getConstraints() {
        final List<ClassConstraint> constraints = new ArrayList<ClassConstraint>(32);





        constraints.add(new MultipleId());
        constraints.add(new MultipleVersions());
        constraints.add(new NoId());
        constraints.add(new EmbeddedAndId());
        constraints.add(new EntityAndEmbed());
        constraints.add(new EmbeddedAndValue());
        constraints.add(new EntityCannotBeMapOrIterable());
        constraints.add(new DuplicatedAttributeNames());


        constraints.add(new MisplacedProperty());
        constraints.add(new ReferenceToUnidentifiable());
        constraints.add(new LazyReferenceMissingDependencies());
        constraints.add(new LazyReferenceOnArray());
        constraints.add(new MapKeyDifferentFromString());
        constraints.add(new MapNotSerializable());
        constraints.add(new VersionMisuse(creator));

        constraints.add(new ContradictingFieldAnnotation(Reference.class, Serialized.class));
        constraints.add(new ContradictingFieldAnnotation(Reference.class, Property.class));
        constraints.add(new ContradictingFieldAnnotation(Reference.class, Embedded.class));

        constraints.add(new ContradictingFieldAnnotation(Embedded.class, Serialized.class));
        constraints.add(new ContradictingFieldAnnotation(Embedded.class, Property.class));

        constraints.add(new ContradictingFieldAnnotation(Property.class, Serialized.class));

        return constraints;
    }

    static class LogLine implements Comparable<LogLine> {
        private final ConstraintViolation v;

        LogLine(final ConstraintViolation v) {
            this.v = v;
        }

        void log(final Logger logger) {
            switch (v.getLevel()) {
                case SEVERE:
                    logger.error(v.render());
                    break;
                case WARNING:
                    logger.warning(v.render());
                    break;
                case INFO:
                    logger.info(v.render());
                    break;
                case MINOR:
                    logger.debug(v.render());
                    break;
                default:
                    throw new IllegalStateException(format("Cannot log %s of Level %s", ConstraintViolation.class.getSimpleName(),
                                                           v.getLevel()));
            }
        }

        @Override
        public boolean equals(final Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }

            final LogLine logLine = (LogLine) o;

            return v.equals(logLine.v);

        }

        @Override
        public int hashCode() {
            return v.hashCode();
        }

        public int compareTo(final LogLine o) {
            return v.getPrefix().compareTo(o.v.getPrefix());
        }
    }


    @Deprecated
    public void validate(final MappedClass mappedClass) {
        validate(Arrays.asList(mappedClass));
    }
}

<code block>
package org.mongodb.morphia.mapping.validation.fieldrules;


import org.mongodb.morphia.ObjectFactory;
import org.mongodb.morphia.annotations.Version;
import org.mongodb.morphia.mapping.MappedClass;
import org.mongodb.morphia.mapping.MappedField;
import org.mongodb.morphia.mapping.validation.ConstraintViolation;
import org.mongodb.morphia.mapping.validation.ConstraintViolation.Level;

import java.util.Set;



public class VersionMisuse extends FieldConstraint {

  private ObjectFactory creator;

  public VersionMisuse(final ObjectFactory creator) {
    this.creator = creator;
  }

  @Override
  protected void check(final MappedClass mc, final MappedField mf, final Set<ConstraintViolation> ve) {
    if (mf.hasAnnotation(Version.class)) {
      final Class<?> type = mf.getType();
      if (Long.class.equals(type) || long.class.equals(type)) {


        final Object testInstance = creator.createInstance(mc.getClazz());


        if (Long.class.equals(type)) {
          if (mf.getFieldValue(testInstance) != null) {
            ve.add(new ConstraintViolation(Level.FATAL, mc, mf, getClass(),
              "When using @" + Version.class.getSimpleName() + " on a Long field, it must be initialized to null."));
          }
        } else if (long.class.equals(type)) {
          if ((Long) mf.getFieldValue(testInstance) != 0L) {
            ve.add(new ConstraintViolation(Level.FATAL, mc, mf, getClass(),
              "When using @" + Version.class.getSimpleName() + " on a long field, it must be initialized to 0."));
          }
        }
      } else {
        ve.add(new ConstraintViolation(Level.FATAL, mc, mf, getClass(),
          "@" + Version.class.getSimpleName() + " can only be used on a Long/long field."));
      }
    }
  }

}

<code block>



package org.mongodb.morphia;


import com.mongodb.BasicDBObject;
import com.mongodb.BasicDBObjectBuilder;
import com.mongodb.DBCollection;
import com.mongodb.DBObject;
import com.mongodb.DBRef;
import org.bson.types.ObjectId;
import org.junit.Ignore;
import org.junit.Test;
import org.mongodb.morphia.TestInheritanceMappings.MapLike;
import org.mongodb.morphia.annotations.AlsoLoad;
import org.mongodb.morphia.annotations.Embedded;
import org.mongodb.morphia.annotations.Entity;
import org.mongodb.morphia.annotations.Id;
import org.mongodb.morphia.annotations.Serialized;
import org.mongodb.morphia.mapping.DefaultCreator;
import org.mongodb.morphia.mapping.Mapper;
import org.mongodb.morphia.mapping.MappingException;
import org.mongodb.morphia.mapping.cache.DefaultEntityCache;
import org.mongodb.morphia.testmodel.Address;
import org.mongodb.morphia.testmodel.Article;
import org.mongodb.morphia.testmodel.Circle;
import org.mongodb.morphia.testmodel.Hotel;
import org.mongodb.morphia.testmodel.PhoneNumber;
import org.mongodb.morphia.testmodel.Rectangle;
import org.mongodb.morphia.testmodel.RecursiveChild;
import org.mongodb.morphia.testmodel.RecursiveParent;
import org.mongodb.morphia.testmodel.Translation;
import org.mongodb.morphia.testmodel.TravelAgency;

import java.io.Serializable;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.Vector;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;



public class TestMapping extends TestBase {

    public abstract static class BaseEntity implements Serializable {
        @Id
        private ObjectId id;

        public String getId() {
            return id.toString();
        }

        public void setId(final String id) {
            this.id = new ObjectId(id);
        }
    }


    @Entity
    public static class MissingId {
        private String  id;
    }

    private static class MissingIdStill {
        private String id;
    }

    @Entity("no-id")
    private static class MissingIdRenamed {
        private String id;
    }

    @Embedded
    private static class IdOnEmbedded {
        @Id
        private ObjectId id;
    }

    @Embedded("no-id")
    private static class RenamedEmbedded {
        private String name;
    }

    private static class StrangelyNamedIdField {

        @Id
        private ObjectId id_ = new ObjectId();

    }

    private static class ContainsEmbeddedArray {
        @Id
        private ObjectId id = new ObjectId();
        private RenamedEmbedded[] res;
    }

    private static class NotEmbeddable {
        private String noImNot = "no, I'm not";
    }

    private static class SerializableClass implements Serializable {
        private final String someString = "hi, from the ether.";
    }

    private static class ContainsRef {
        @Id
        private ObjectId id;
        private DBRef rect;
    }

    private static class HasFinalFieldId {
        @Id
        private final long id;
        private String name = "some string";


        protected HasFinalFieldId() {
            id = -1;
        }

        public HasFinalFieldId(final long id) {
            this.id = id;
        }
    }

    private static class ContainsFinalField {
        @Id
        private ObjectId id;
        private final String name;

        protected ContainsFinalField() {
            name = "foo";
        }

        public ContainsFinalField(final String name) {
            this.name = name;
        }
    }

    private static class ContainsTimestamp {
        @Id
        private
        ObjectId id;
        private final Timestamp ts = new Timestamp(System.currentTimeMillis());
    }

    private static class ContainsDBObject {
        @Id
        private ObjectId id;
        private DBObject dbObj = BasicDBObjectBuilder.start("field", "val").get();
    }

    private static class ContainsByteArray {
        @Id
        private ObjectId id;
        private final byte[] bytes = "Scott".getBytes();
    }

    private static class ContainsSerializedData {
        @Id
        private ObjectId id;
        @Serialized
        private final SerializableClass data = new SerializableClass();
    }

    private static class ContainsLongAndStringArray {
        @Id
        private ObjectId id;
        private Long[] longs = {0L, 1L, 2L};
        private String[] strings = {"Scott", "Rocks"};
    }

    private static final class ContainsCollection {
        @Id
        private ObjectId id;
        private final Collection<String> coll = new ArrayList<String>();

        private ContainsCollection() {
            coll.add("hi");
            coll.add("Scott");
        }
    }

    private static class ContainsPrimitiveMap {
        @Id
        private ObjectId id;
        @Embedded
        private final Map<String, Long> embeddedValues = new HashMap<String, Long>();
        private final Map<String, Long> values = new HashMap<String, Long>();
    }

    private interface Foo {
    }

    private static class Foo1 implements Foo {
        private String s;
    }

    private static class Foo2 implements Foo {
        private int i;
    }

    private static class ContainsMapWithEmbeddedInterface {
        @Id
        private ObjectId id;
        @Embedded
        private final Map<String, Foo> embeddedValues = new HashMap<String, Foo>();
    }

    private static class ContainsEmbeddedEntity {
        @Id
        private final ObjectId id = new ObjectId();
        @Embedded
        private ContainsIntegerList cil = new ContainsIntegerList();
    }

    public enum Enum1 {
        A,
        B
    }

    @Entity(value = "cil", noClassnameStored = true)
    private static class ContainsIntegerList {
        @Id
        private ObjectId id;
        private List<Integer> intList = new ArrayList<Integer>();
    }

    private static class ContainsIntegerListNewAndOld {
        @Id
        private ObjectId id;
        private List<Integer> intList = new ArrayList<Integer>();
        private List<Integer> integers = new ArrayList<Integer>();
    }

    @Entity(value = "cil", noClassnameStored = true)
    private static class ContainsIntegerListNew {
        @Id
        private ObjectId id;
        @AlsoLoad("intList")
        private final List<Integer> integers = new ArrayList<Integer>();
    }

    @Entity(noClassnameStored = true)
    private static class ContainsUUID {
        @Id
        private ObjectId id;
        private final UUID uuid = UUID.randomUUID();
    }

    @Entity(noClassnameStored = true)
    private static class ContainsUuidId {
        @Id
        private final UUID id = UUID.randomUUID();
    }

    private static class ContainsEnum1KeyMap {
        @Id
        private ObjectId id;
        private final Map<Enum1, String> values = new HashMap<Enum1, String>();
        @Embedded
        private final Map<Enum1, String> embeddedValues = new HashMap<Enum1, String>();
    }

    private static class ContainsIntKeyMap {
        @Id
        private ObjectId id;
        private final Map<Integer, String> values = new HashMap<Integer, String>();
    }

    private static class ContainsIntKeySetStringMap {
        @Id
        private ObjectId id;
        @Embedded
        private final Map<Integer, Set<String>> values = new HashMap<Integer, Set<String>>();
    }

    private static class ContainsObjectIdKeyMap {
        @Id
        private ObjectId id;
        private final Map<ObjectId, String> values = new HashMap<ObjectId, String>();
    }

    private static class ContainsXKeyMap<T> {
        @Id
        private ObjectId id;
        private final Map<T, String> values = new HashMap<T, String>();
    }

    private static class ContainsMapLike {
        @Id
        private ObjectId id;
        private final MapLike m = new MapLike();
    }

    @Entity
    private static class UsesBaseEntity extends BaseEntity {

    }

    private static class MapSubclass extends LinkedHashMap<String, Object> {
        @Id
        private ObjectId id;
    }

    private class NonStaticInnerClass {
        @Id
        private long id = 1;
    }

    @Test
    public void testUUID() throws Exception {

        final ContainsUUID uuid = new ContainsUUID();
        final UUID before = uuid.uuid;
        getDs().save(uuid);
        final ContainsUUID loaded = getDs().find(ContainsUUID.class).get();
        assertNotNull(loaded);
        assertNotNull(loaded.id);
        assertNotNull(loaded.uuid);
        assertEquals(before, loaded.uuid);
    }

    @Test
    public void testEmbeddedDBObject() throws Exception {
        getMorphia().map(ContainsDBObject.class);
        getDs().save(new ContainsDBObject());
        assertNotNull(getDs().find(ContainsDBObject.class).get());
    }

    @Test
    public void testUuidId() throws Exception {
        getMorphia().map(ContainsUuidId.class);
        final ContainsUuidId uuidId = new ContainsUuidId();
        final UUID before = uuidId.id;
        getDs().save(uuidId);
        final ContainsUuidId loaded = getDs().get(ContainsUuidId.class, before);
        assertNotNull(loaded);
        assertNotNull(loaded.id);
        assertEquals(before, loaded.id);
    }

    @Test
    public void testEmbeddedEntity() throws Exception {
        getMorphia().map(ContainsEmbeddedEntity.class);
        getDs().save(new ContainsEmbeddedEntity());
        final ContainsEmbeddedEntity ceeLoaded = getDs().find(ContainsEmbeddedEntity.class).get();
        assertNotNull(ceeLoaded);
        assertNotNull(ceeLoaded.id);
        assertNotNull(ceeLoaded.cil);
        assertNull(ceeLoaded.cil.id);

    }

    @Test
    public void testEmbeddedArrayElementHasNoClassname() throws Exception {
        getMorphia().map(ContainsEmbeddedArray.class);
        final ContainsEmbeddedArray cea = new ContainsEmbeddedArray();
        cea.res = new RenamedEmbedded[]{new RenamedEmbedded()};

        final DBObject dbObj = getMorphia().toDBObject(cea);
        assertTrue(!((DBObject) ((List) dbObj.get("res")).get(0)).containsField(Mapper.CLASS_NAME_FIELDNAME));
    }

    @Test
    public void testEmbeddedEntityDBObjectHasNoClassname() throws Exception {
        getMorphia().map(ContainsEmbeddedEntity.class);
        final ContainsEmbeddedEntity cee = new ContainsEmbeddedEntity();
        cee.cil = new ContainsIntegerList();
        cee.cil.intList = Collections.singletonList(1);
        final DBObject dbObj = getMorphia().toDBObject(cee);
        assertTrue(!((DBObject) dbObj.get("cil")).containsField(Mapper.CLASS_NAME_FIELDNAME));
    }

    @Test
    public void testEnumKeyedMap() throws Exception {
        final ContainsEnum1KeyMap map = new ContainsEnum1KeyMap();
        map.values.put(Enum1.A, "I'm a");
        map.values.put(Enum1.B, "I'm b");
        map.embeddedValues.put(Enum1.A, "I'm a");
        map.embeddedValues.put(Enum1.B, "I'm b");

        final Key<?> mapKey = getDs().save(map);

        final ContainsEnum1KeyMap mapLoaded = getDs().get(ContainsEnum1KeyMap.class, mapKey.getId());

        assertNotNull(mapLoaded);
        assertEquals(2, mapLoaded.values.size());
        assertNotNull(mapLoaded.values.get(Enum1.A));
        assertNotNull(mapLoaded.values.get(Enum1.B));
        assertEquals(2, mapLoaded.embeddedValues.size());
        assertNotNull(mapLoaded.embeddedValues.get(Enum1.A));
        assertNotNull(mapLoaded.embeddedValues.get(Enum1.B));
    }

    @Test
    public void testAlsoLoad() throws Exception {
        final ContainsIntegerList cil = new ContainsIntegerList();
        cil.intList.add(1);
        getDs().save(cil);
        final ContainsIntegerList cilLoaded = getDs().get(cil);
        assertNotNull(cilLoaded);
        assertNotNull(cilLoaded.intList);
        assertEquals(cilLoaded.intList.size(), cil.intList.size());
        assertEquals(cilLoaded.intList.get(0), cil.intList.get(0));

        final ContainsIntegerListNew cilNew = getDs().get(ContainsIntegerListNew.class, cil.id);
        assertNotNull(cilNew);
        assertNotNull(cilNew.integers);
        assertEquals(1, cilNew.integers.size());
        assertEquals(1, (int) cil.intList.get(0));
    }

    @Test
    public void testIntLists() throws Exception {
        ContainsIntegerList cil = new ContainsIntegerList();
        getDs().save(cil);
        ContainsIntegerList cilLoaded = getDs().get(cil);
        assertNotNull(cilLoaded);
        assertNotNull(cilLoaded.intList);
        assertEquals(cilLoaded.intList.size(), cil.intList.size());


        cil = new ContainsIntegerList();
        cil.intList = null;
        getDs().save(cil);
        cilLoaded = getDs().get(cil);
        assertNotNull(cilLoaded);
        assertNotNull(cilLoaded.intList);
        assertEquals(0, cilLoaded.intList.size());

        cil = new ContainsIntegerList();
        cil.intList.add(1);
        getDs().save(cil);
        cilLoaded = getDs().get(cil);
        assertNotNull(cilLoaded);
        assertNotNull(cilLoaded.intList);
        assertEquals(1, cilLoaded.intList.size());
        assertEquals(1, (int) cilLoaded.intList.get(0));
    }

    @Test
    public void testObjectIdKeyedMap() throws Exception {
        getMorphia().map(ContainsObjectIdKeyMap.class);
        final ContainsObjectIdKeyMap map = new ContainsObjectIdKeyMap();
        final ObjectId o1 = new ObjectId("111111111111111111111111");
        final ObjectId o2 = new ObjectId("222222222222222222222222");
        map.values.put(o1, "I'm 1s");
        map.values.put(o2, "I'm 2s");

        final Key<?> mapKey = getDs().save(map);

        final ContainsObjectIdKeyMap mapLoaded = getDs().get(ContainsObjectIdKeyMap.class, mapKey.getId());

        assertNotNull(mapLoaded);
        assertEquals(2, mapLoaded.values.size());
        assertNotNull(mapLoaded.values.get(o1));
        assertNotNull(mapLoaded.values.get(o2));

        assertNotNull(getDs().find(ContainsIntKeyMap.class).field("values.111111111111111111111111").exists());
        assertEquals(0, getDs().find(ContainsIntKeyMap.class).field("values.111111111111111111111111").doesNotExist().countAll());
        assertNotNull(getDs().find(ContainsIntKeyMap.class).field("values.4").doesNotExist());
        assertEquals(0, getDs().find(ContainsIntKeyMap.class).field("values.4").exists().countAll());
    }

    @Test
    public void testIntKeyedMap() throws Exception {
        final ContainsIntKeyMap map = new ContainsIntKeyMap();
        map.values.put(1, "I'm 1");
        map.values.put(2, "I'm 2");

        final Key<?> mapKey = getDs().save(map);

        final ContainsIntKeyMap mapLoaded = getDs().get(ContainsIntKeyMap.class, mapKey.getId());

        assertNotNull(mapLoaded);
        assertEquals(2, mapLoaded.values.size());
        assertNotNull(mapLoaded.values.get(1));
        assertNotNull(mapLoaded.values.get(2));

        assertNotNull(getDs().find(ContainsIntKeyMap.class).field("values.2").exists());
        assertEquals(0, getDs().find(ContainsIntKeyMap.class).field("values.2").doesNotExist().countAll());
        assertNotNull(getDs().find(ContainsIntKeyMap.class).field("values.4").doesNotExist());
        assertEquals(0, getDs().find(ContainsIntKeyMap.class).field("values.4").exists().countAll());
    }

    @Test
    public void testIntKeySetStringMap() throws Exception {
        final ContainsIntKeySetStringMap map = new ContainsIntKeySetStringMap();
        map.values.put(1, Collections.singleton("I'm 1"));
        map.values.put(2, Collections.singleton("I'm 2"));

        final Key<?> mapKey = getDs().save(map);

        final ContainsIntKeySetStringMap mapLoaded = getDs().get(ContainsIntKeySetStringMap.class, mapKey.getId());

        assertNotNull(mapLoaded);
        assertEquals(2, mapLoaded.values.size());
        assertNotNull(mapLoaded.values.get(1));
        assertNotNull(mapLoaded.values.get(2));
        assertEquals(1, mapLoaded.values.get(1).size());

        assertNotNull(getDs().find(ContainsIntKeyMap.class).field("values.2").exists());
        assertEquals(0, getDs().find(ContainsIntKeyMap.class).field("values.2").doesNotExist().countAll());
        assertNotNull(getDs().find(ContainsIntKeyMap.class).field("values.4").doesNotExist());
        assertEquals(0, getDs().find(ContainsIntKeyMap.class).field("values.4").exists().countAll());
    }

    @Test
    @Ignore("need to add this feature")
    @SuppressWarnings("unchecked")
    public void testGenericKeyedMap() throws Exception {
        final ContainsXKeyMap<Integer> map = new ContainsXKeyMap<Integer>();
        map.values.put(1, "I'm 1");
        map.values.put(2, "I'm 2");

        final Key<ContainsXKeyMap<Integer>> mapKey = getDs().save(map);

        final ContainsXKeyMap<Integer> mapLoaded = getDs().get(ContainsXKeyMap.class, mapKey.getId());

        assertNotNull(mapLoaded);
        assertEquals(2, mapLoaded.values.size());
        assertNotNull(mapLoaded.values.get(1));
        assertNotNull(mapLoaded.values.get(2));
    }

    @Test
    public void testMapLike() throws Exception {
        final ContainsMapLike ml = new ContainsMapLike();
        ml.m.put("first", "test");
        getDs().save(ml);
        final ContainsMapLike mlLoaded = getDs().find(ContainsMapLike.class).get();
        assertNotNull(mlLoaded);
        assertNotNull(mlLoaded.m);
        assertNotNull(mlLoaded.m.containsKey("first"));
    }

    @Test
    public void testPrimMap() throws Exception {
        final ContainsPrimitiveMap primMap = new ContainsPrimitiveMap();
        primMap.embeddedValues.put("first", 1L);
        primMap.embeddedValues.put("second", 2L);
        primMap.values.put("first", 1L);
        primMap.values.put("second", 2L);
        final Key<ContainsPrimitiveMap> primMapKey = getDs().save(primMap);

        final ContainsPrimitiveMap primMapLoaded = getDs().get(ContainsPrimitiveMap.class, primMapKey.getId());

        assertNotNull(primMapLoaded);
        assertEquals(2, primMapLoaded.embeddedValues.size());
        assertEquals(2, primMapLoaded.values.size());
    }

    @Test
    public void testPrimMapWithNullValue() throws Exception {
        final ContainsPrimitiveMap primMap = new ContainsPrimitiveMap();
        primMap.embeddedValues.put("first", null);
        primMap.embeddedValues.put("second", 2L);
        primMap.values.put("first", null);
        primMap.values.put("second", 2L);
        final Key<ContainsPrimitiveMap> primMapKey = getDs().save(primMap);

        final ContainsPrimitiveMap primMapLoaded = getDs().get(ContainsPrimitiveMap.class, primMapKey.getId());

        assertNotNull(primMapLoaded);
        assertEquals(2, primMapLoaded.embeddedValues.size());
        assertEquals(2, primMapLoaded.values.size());
    }

    @Test
    public void testMapWithEmbeddedInterface() throws Exception {
        final ContainsMapWithEmbeddedInterface aMap = new ContainsMapWithEmbeddedInterface();
        final Foo f1 = new Foo1();
        final Foo f2 = new Foo2();

        aMap.embeddedValues.put("first", f1);
        aMap.embeddedValues.put("second", f2);
        getDs().save(aMap);

        final ContainsMapWithEmbeddedInterface mapLoaded = getDs().find(ContainsMapWithEmbeddedInterface.class).get();

        assertNotNull(mapLoaded);
        assertEquals(2, mapLoaded.embeddedValues.size());
        assertTrue(mapLoaded.embeddedValues.get("first") instanceof Foo1);
        assertTrue(mapLoaded.embeddedValues.get("second") instanceof Foo2);

    }

    @Test
    public void testIdFieldWithUnderscore() throws Exception {
        getMorphia().map(StrangelyNamedIdField.class);
    }

    @Test
    public void testFinalIdField() throws Exception {
        getMorphia().map(HasFinalFieldId.class);
        final Key<HasFinalFieldId> savedKey = getDs().save(new HasFinalFieldId(12));
        final HasFinalFieldId loaded = getDs().get(HasFinalFieldId.class, savedKey.getId());
        assertNotNull(loaded);
        assertNotNull(loaded.id);
        assertEquals(12, loaded.id);
    }

    @Test
    public void testFinalField() throws Exception {
        getMorphia().map(ContainsFinalField.class);
        final Key<ContainsFinalField> savedKey = getDs().save(new ContainsFinalField("blah"));
        final ContainsFinalField loaded = getDs().get(ContainsFinalField.class, savedKey.getId());
        assertNotNull(loaded);
        assertNotNull(loaded.name);
        assertEquals("blah", loaded.name);
    }

    @Test
    public void testFinalFieldNotPersisted() throws Exception {
        ((DatastoreImpl) getDs()).getMapper().getOptions().setIgnoreFinals(true);
        getMorphia().map(ContainsFinalField.class);
        final Key<ContainsFinalField> savedKey = getDs().save(new ContainsFinalField("blah"));
        final ContainsFinalField loaded = getDs().get(ContainsFinalField.class, savedKey.getId());
        assertNotNull(loaded);
        assertNotNull(loaded.name);
        assertEquals("foo", loaded.name);
    }

    @Test
    public void testTimestampMapping() throws Exception {
        getMorphia().map(ContainsTimestamp.class);
        final ContainsTimestamp cts = new ContainsTimestamp();
        final Key<ContainsTimestamp> savedKey = getDs().save(cts);
        final ContainsTimestamp loaded = getDs().get(ContainsTimestamp.class, savedKey.getId());
        assertNotNull(loaded.ts);
        assertEquals(loaded.ts.getTime(), cts.ts.getTime());

    }

    @Test
    public void testCollectionMapping() throws Exception {
        getMorphia().map(ContainsCollection.class);
        final Key<ContainsCollection> savedKey = getDs().save(new ContainsCollection());
        final ContainsCollection loaded = getDs().get(ContainsCollection.class, savedKey.getId());
        assertEquals(loaded.coll, (new ContainsCollection()).coll);
        assertNotNull(loaded.id);
    }

    @Test
    public void testByteArrayMapping() throws Exception {
        getMorphia().map(ContainsByteArray.class);
        final Key<ContainsByteArray> savedKey = getDs().save(new ContainsByteArray());
        final ContainsByteArray loaded = getDs().get(ContainsByteArray.class, savedKey.getId());
        assertEquals(new String((new ContainsByteArray()).bytes), new String(loaded.bytes));
        assertNotNull(loaded.id);
    }

    @Test
    public void testBaseEntityValidity() throws Exception {
        getMorphia().map(UsesBaseEntity.class);
    }

    @Test
    public void testSerializedMapping() throws Exception {
        getMorphia().map(ContainsSerializedData.class);
        final Key<ContainsSerializedData> savedKey = getDs().save(new ContainsSerializedData());
        final ContainsSerializedData loaded = getDs().get(ContainsSerializedData.class, savedKey.getId());
        assertNotNull(loaded.data);
        assertEquals(loaded.data.someString, (new ContainsSerializedData()).data.someString);
        assertNotNull(loaded.id);
    }

    @SuppressWarnings("deprecation")
    @Test
    public void testLongArrayMapping() throws Exception {
        getMorphia().map(ContainsLongAndStringArray.class);
        getDs().save(new ContainsLongAndStringArray());
        ContainsLongAndStringArray loaded = getDs().<ContainsLongAndStringArray>find(ContainsLongAndStringArray.class).get();
        assertEquals(loaded.longs, (new ContainsLongAndStringArray()).longs);
        assertEquals(loaded.strings, (new ContainsLongAndStringArray()).strings);

        final ContainsLongAndStringArray array = new ContainsLongAndStringArray();
        array.strings = new String[]{"a", "B", "c"};
        array.longs = new Long[]{4L, 5L, 4L};
        final Key<ContainsLongAndStringArray> k1 = getDs().save(array);
        loaded = getDs().getByKey(ContainsLongAndStringArray.class, k1);
        assertEquals(loaded.longs, array.longs);
        assertEquals(loaded.strings, array.strings);

        assertNotNull(loaded.id);
    }

    @Test
    public void testDbRefMapping() throws Exception {
        getMorphia().map(ContainsRef.class).map(Rectangle.class);
        final DBCollection stuff = getDb().getCollection("stuff");
        final DBCollection rectangles = getDb().getCollection("rectangles");

        assertTrue("'ne' field should not be persisted!", !getMorphia().getMapper().getMCMap().get(ContainsRef.class.getName())
                                                               .containsJavaFieldName("ne"));

        final Rectangle r = new Rectangle(1, 1);
        final DBObject rDbObject = getMorphia().toDBObject(r);
        rDbObject.put("_ns", rectangles.getName());
        rectangles.save(rDbObject);

        final ContainsRef cRef = new ContainsRef();
        cRef.rect = new DBRef((String) rDbObject.get("_ns"), rDbObject.get("_id"));
        final DBObject cRefDbObject = getMorphia().toDBObject(cRef);
        stuff.save(cRefDbObject);
        final BasicDBObject cRefDbObjectLoaded = (BasicDBObject) stuff.findOne(BasicDBObjectBuilder.start("_id", cRefDbObject.get("_id"))
                                                                                                   .get());
        final ContainsRef cRefLoaded = getMorphia().fromDBObject(ContainsRef.class, cRefDbObjectLoaded, new DefaultEntityCache());
        assertNotNull(cRefLoaded);
        assertNotNull(cRefLoaded.rect);
        assertNotNull(cRefLoaded.rect.getId());
        assertNotNull(cRefLoaded.rect.getCollectionName());
        assertEquals(cRefLoaded.rect.getId(), cRef.rect.getId());
        assertEquals(cRefLoaded.rect.getCollectionName(), cRef.rect.getCollectionName());
    }

    @Test
    public void testBadMappings() throws Exception {
        try {
            getMorphia().map(MissingId.class);
            fail("Validation: Missing @Id field not caught");
        } catch (MappingException e) {

        }

        try {
            getMorphia().map(IdOnEmbedded.class);
            fail("Validation: @Id field on @Embedded not caught");
        } catch (MappingException e) {

        }

        try {
            getMorphia().map(RenamedEmbedded.class);
            fail("Validation: @Embedded(\"name\") not caught on Class");
        } catch (MappingException e) {

        }

        try {
            getMorphia().map(MissingIdStill.class);
            fail("Validation: Missing @Id field not not caught");
        } catch (MappingException e) {

        }

        try {
            getMorphia().map(MissingIdRenamed.class);
            fail("Validation: Missing @Id field not not caught");
        } catch (MappingException e) {

        }

        try {
            getMorphia().map(NonStaticInnerClass.class);
            fail("Validation: Non-static inner class allowed");
        } catch (MappingException e) {

        }
    }


    @Test
    public void testBasicMapping() throws Exception {
        performBasicMappingTest();
        assertTrue(
            ((DefaultCreator) getMorphia().getMapper().getOptions().getObjectFactory()).getClassNameCache()
                .isEmpty()
        );
    }

    @Test
    public void testBasicMappingWithCachedClasses() throws Exception {
        getMorphia().getMapper().getOptions().setCacheClassLookups(true);
        try {
            performBasicMappingTest();
            assertTrue(
                ((DefaultCreator) getMorphia().getMapper().getOptions().getObjectFactory()).getClassNameCache()
                    .containsKey(Hotel.class.getName())
            );
            assertTrue(
                ((DefaultCreator) getMorphia().getMapper().getOptions().getObjectFactory()).getClassNameCache()
                    .containsKey(TravelAgency.class.getName())
            );
        } finally {
            getMorphia().getMapper().getOptions().setCacheClassLookups(false);
        }
    }

    private void performBasicMappingTest() {
        final DBCollection hotels = getDb().getCollection("hotels");
        final DBCollection agencies = getDb().getCollection("agencies");

        getMorphia().map(Hotel.class);
        getMorphia().map(TravelAgency.class);

        final Hotel borg = new Hotel();
        borg.setName("Hotel Borg");
        borg.setStars(4);
        borg.setTakesCreditCards(true);
        borg.setStartDate(new Date());
        borg.setType(Hotel.Type.LEISURE);
        borg.getTags().add("Swimming pool");
        borg.getTags().add("Room service");
        borg.setTemp("A temporary transient value");
        borg.getPhoneNumbers().add(new PhoneNumber(354, 5152233, PhoneNumber.Type.PHONE));
        borg.getPhoneNumbers().add(new PhoneNumber(354, 5152244, PhoneNumber.Type.FAX));

        final Address address = new Address();
        address.setStreet("Posthusstraeti 11");
        address.setPostCode("101");
        borg.setAddress(address);

        BasicDBObject hotelDbObj = (BasicDBObject) getMorphia().toDBObject(borg);
        assertTrue(!(((DBObject) ((List) hotelDbObj.get("phoneNumbers")).get(0)).containsField(Mapper.CLASS_NAME_FIELDNAME)));


        hotels.save(hotelDbObj);

        Hotel borgLoaded = getMorphia().fromDBObject(Hotel.class, hotelDbObj, new DefaultEntityCache());

        assertEquals(borg.getName(), borgLoaded.getName());
        assertEquals(borg.getStars(), borgLoaded.getStars());
        assertEquals(borg.getStartDate(), borgLoaded.getStartDate());
        assertEquals(borg.getType(), borgLoaded.getType());
        assertEquals(borg.getAddress().getStreet(), borgLoaded.getAddress().getStreet());
        assertEquals(borg.getTags().size(), borgLoaded.getTags().size());
        assertEquals(borg.getTags(), borgLoaded.getTags());
        assertEquals(borg.getPhoneNumbers().size(), borgLoaded.getPhoneNumbers().size());
        assertEquals(borg.getPhoneNumbers().get(1), borgLoaded.getPhoneNumbers().get(1));
        assertNull(borgLoaded.getTemp());
        assertTrue(borgLoaded.getPhoneNumbers() instanceof Vector);
        assertNotNull(borgLoaded.getId());

        final TravelAgency agency = new TravelAgency();
        agency.setName("Lastminute.com");
        agency.getHotels().add(borgLoaded);

        final BasicDBObject agencyDbObj = (BasicDBObject) getMorphia().toDBObject(agency);
        agencies.save(agencyDbObj);

        final TravelAgency agencyLoaded = getMorphia().fromDBObject(TravelAgency.class,
                                                                    agencies.findOne(new BasicDBObject(Mapper.ID_KEY,
                                                                                                       agencyDbObj.get(Mapper.ID_KEY))),
                                                                    new DefaultEntityCache());

        assertEquals(agency.getName(), agencyLoaded.getName());
        assertEquals(1, agency.getHotels().size());
        assertEquals(agency.getHotels().get(0).getName(), borg.getName());


        borgLoaded.setAddress(null);
        borgLoaded.getPhoneNumbers().clear();
        borgLoaded.setName(null);

        hotelDbObj = (BasicDBObject) getMorphia().toDBObject(borgLoaded);
        hotels.save(hotelDbObj);

        hotelDbObj = (BasicDBObject) hotels.findOne(new BasicDBObject(Mapper.ID_KEY, hotelDbObj.get(Mapper.ID_KEY)));

        borgLoaded = getMorphia().fromDBObject(Hotel.class, hotelDbObj, new DefaultEntityCache());
        assertNull(borgLoaded.getAddress());
        assertEquals(0, borgLoaded.getPhoneNumbers().size());
        assertNull(borgLoaded.getName());
    }

    @Test
    public void testMaps() throws Exception {
        final DBCollection articles = getDb().getCollection("articles");
        getMorphia().map(Article.class).map(Translation.class).map(Circle.class);

        final Article related = new Article();
        final BasicDBObject relatedDbObj = (BasicDBObject) getMorphia().toDBObject(related);
        articles.save(relatedDbObj);

        final Article relatedLoaded = getMorphia().fromDBObject(Article.class,
                                                                articles.findOne(new BasicDBObject(Mapper.ID_KEY,
                                                                                                   relatedDbObj.get(Mapper.ID_KEY))),
                                                                new DefaultEntityCache());

        final Article article = new Article();
        article.setTranslation("en", new Translation("Hello World", "Just a test"));
        article.setTranslation("is", new Translation("HallÃ³ heimur", "Bara aÃ° prÃ³fa"));

        article.setAttribute("myDate", new Date());
        article.setAttribute("myString", "Test");
        article.setAttribute("myInt", 123);

        article.putRelated("test", relatedLoaded);

        final BasicDBObject articleDbObj = (BasicDBObject) getMorphia().toDBObject(article);
        articles.save(articleDbObj);

        final Article articleLoaded = getMorphia().fromDBObject(Article.class,
                                                                articles.findOne(
                                                                                    new BasicDBObject(Mapper.ID_KEY,
                                                                                                      articleDbObj.get(Mapper.ID_KEY))),
                                                                new DefaultEntityCache());

        assertEquals(article.getTranslations().size(), articleLoaded.getTranslations().size());
        assertEquals(article.getTranslation("en").getTitle(), articleLoaded.getTranslation("en").getTitle());
        assertEquals(article.getTranslation("is").getBody(), articleLoaded.getTranslation("is").getBody());
        assertEquals(article.getAttributes().size(), articleLoaded.getAttributes().size());
        assertEquals(article.getAttribute("myDate"), articleLoaded.getAttribute("myDate"));
        assertEquals(article.getAttribute("myString"), articleLoaded.getAttribute("myString"));
        assertEquals(article.getAttribute("myInt"), articleLoaded.getAttribute("myInt"));
        assertEquals(article.getRelated().size(), articleLoaded.getRelated().size());
        assertEquals(article.getRelated("test").getId(), articleLoaded.getRelated("test").getId());
    }


    @Test(expected = MappingException.class)
    public void testReferenceWithoutIdValue() throws Exception {
        final RecursiveParent parent = new RecursiveParent();
        final RecursiveChild child = new RecursiveChild();
        child.setId(null);
        parent.setChild(child);
        getDs().save(parent);

    }

    @Test
    public void testRecursiveReference() throws Exception {
        final DBCollection stuff = getDb().getCollection("stuff");

        getMorphia().map(RecursiveParent.class).map(RecursiveChild.class);

        final RecursiveParent parent = new RecursiveParent();
        final DBObject parentDbObj = getMorphia().toDBObject(parent);
        stuff.save(parentDbObj);

        final RecursiveChild child = new RecursiveChild();
        final DBObject childDbObj = getMorphia().toDBObject(child);
        stuff.save(childDbObj);

        final RecursiveParent parentLoaded = getMorphia().fromDBObject(RecursiveParent.class,
                                                                       stuff.findOne(new BasicDBObject(Mapper.ID_KEY,
                                                                                                       parentDbObj.get(Mapper.ID_KEY))),
                                                                       new DefaultEntityCache());
        final RecursiveChild childLoaded = getMorphia().fromDBObject(RecursiveChild.class,
                                                                     stuff.findOne(new BasicDBObject(Mapper.ID_KEY,
                                                                                                     childDbObj.get(Mapper.ID_KEY))),
                                                                     new DefaultEntityCache());

        parentLoaded.setChild(childLoaded);
        childLoaded.setParent(parentLoaded);

        stuff.save(getMorphia().toDBObject(parentLoaded));
        stuff.save(getMorphia().toDBObject(childLoaded));

        final RecursiveParent finalParentLoaded = getMorphia().fromDBObject(RecursiveParent.class,
                                                                            stuff.findOne(new BasicDBObject(Mapper.ID_KEY,
                                                                                                            parentDbObj.get(Mapper
                                                                                                                                .ID_KEY))),
                                                                            new DefaultEntityCache());
        final RecursiveChild finalChildLoaded = getMorphia().fromDBObject(RecursiveChild.class,
                                                                          stuff.findOne(new BasicDBObject(Mapper.ID_KEY,
                                                                                                          childDbObj.get(Mapper.ID_KEY))),
                                                                          new DefaultEntityCache());

        assertNotNull(finalParentLoaded.getChild());
        assertNotNull(finalChildLoaded.getParent());
    }
}

<code block>
package org.mongodb.morphia.mapping;


import com.mongodb.DBObject;
import org.mongodb.morphia.ObjectFactory;
import org.mongodb.morphia.annotations.ConstructorArgs;
import org.mongodb.morphia.logging.Logger;
import org.mongodb.morphia.logging.MorphiaLoggerFactory;

import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;



public class DefaultCreator implements ObjectFactory {
    private static final Logger LOG = MorphiaLoggerFactory.get(DefaultCreator.class);


    private <T> T newInstance(final Constructor<T> tryMe, final Class<T> fallbackType) {
        if (tryMe != null) {
            tryMe.setAccessible(true);
            try {
                return tryMe.newInstance();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
        return createInst(fallbackType);
    }

    private static <T> Constructor<T> getNoArgsConstructor(final Class<T> type) {
        try {
            final Constructor<T> constructor = type.getDeclaredConstructor();
            constructor.setAccessible(true);
            return constructor;
        } catch (NoSuchMethodException e) {
            throw new MappingException("No usable constructor for " + type.getName(), e);
        }
    }

    @Override
    public <T> T createInstance(final Class<T> clazz) {
        return createInst(clazz);
    }

    @Override
    public <T> T createInstance(final Class<T> clazz, final DBObject dbObj) {
        Class<T> c = getClass(dbObj);
        if (c == null) {
            c = clazz;
        }
        return createInstance(c);
    }

    @Override
    @SuppressWarnings("unchecked")
    public Object createInstance(final Mapper mapper, final MappedField mf, final DBObject dbObj) {
        Class c = getClass(dbObj);
        if (c == null) {
            c = mf.isSingleValue() ? mf.getConcreteType() : mf.getSubClass();
        }
        try {
            return createInstance(c, dbObj);
        } catch (RuntimeException e) {
            final ConstructorArgs argAnn = mf.getAnnotation(ConstructorArgs.class);
            if (argAnn == null) {
                throw e;
            }

            final Object[] args = new Object[argAnn.value().length];
            final Class[] argTypes = new Class[argAnn.value().length];
            for (int i = 0; i < argAnn.value().length; i++) {


                final Object val = dbObj.get(argAnn.value()[i]);
                args[i] = val;
                argTypes[i] = val.getClass();
            }
            try {
                final Constructor constructor = c.getDeclaredConstructor(argTypes);
                constructor.setAccessible(true);
                return constructor.newInstance(args);
            } catch (Exception ex) {
                throw new RuntimeException(ex);
            }
        }
    }

    @Override
    @SuppressWarnings("unchecked")
    public Map createMap(final MappedField mf) {
        return newInstance(mf != null ? mf.getCTor() : null, HashMap.class);
    }

    @Override
    @SuppressWarnings("unchecked")
    public List createList(final MappedField mf) {
        return newInstance(mf != null ? mf.getCTor() : null, ArrayList.class);
    }

    @Override
    @SuppressWarnings("unchecked")
    public Set createSet(final MappedField mf) {
        return newInstance(mf != null ? mf.getCTor() : null, HashSet.class);
    }

    @SuppressWarnings("unchecked")
    private <T> Class<T> getClass(final DBObject dbObj) {

        Class c = null;
        if (dbObj.containsField(Mapper.CLASS_NAME_FIELDNAME)) {
            final String className = (String) dbObj.get(Mapper.CLASS_NAME_FIELDNAME);


            try {
                c = Class.forName(className, true, getClassLoaderForClass());
            } catch (ClassNotFoundException e) {
                if (LOG.isWarningEnabled()) {
                    LOG.warning("Class not found defined in dbObj: ", e);
                }
            }
        }
        return c;
    }

    protected ClassLoader getClassLoaderForClass() {
        return Thread.currentThread().getContextClassLoader();
    }

    @SuppressWarnings("unchecked")
    public <T> T createInst(final Class<T> clazz) {
        try {
            return getNoArgsConstructor(clazz).newInstance();
        } catch (Exception e) {
            if (Collection.class.isAssignableFrom(clazz)) {
                return (T) createList(null);
            } else if (Map.class.isAssignableFrom(clazz)) {
                return (T) createMap(null);
            } else if (Set.class.isAssignableFrom(clazz)) {
                return (T) createSet(null);
            }
            throw new MappingException("No usable constructor for " + clazz.getName(), e);
        }
    }
}

<code block>
package org.mongodb.morphia.mapping;


import org.mongodb.morphia.ObjectFactory;
import org.mongodb.morphia.mapping.lazy.DatastoreProvider;
import org.mongodb.morphia.mapping.lazy.DefaultDatastoreProvider;



public class MapperOptions {
    private boolean actLikeSerializer;
    private boolean ignoreFinals; 
    private boolean storeNulls;
    private boolean storeEmpties;
    private boolean useLowerCaseCollectionNames;
    private ObjectFactory objectFactory = new DefaultCreator();
    private CustomMapper embeddedMapper = new EmbeddedMapper();
    private CustomMapper defaultMapper = embeddedMapper;
    private CustomMapper referenceMapper = new ReferenceMapper();
    private CustomMapper valueMapper = new ValueMapper();
    private DatastoreProvider datastoreProvider = new DefaultDatastoreProvider();

    public CustomMapper getDefaultMapper() {
        return defaultMapper;
    }

    public void setDefaultMapper(final CustomMapper pDefaultMapper) {
        defaultMapper = pDefaultMapper;
    }

    public CustomMapper getEmbeddedMapper() {
        return embeddedMapper;
    }

    public void setEmbeddedMapper(final CustomMapper pEmbeddedMapper) {
        embeddedMapper = pEmbeddedMapper;
    }

    public ObjectFactory getObjectFactory() {
        return objectFactory;
    }


    public void setObjectFactory(final ObjectFactory objectFactory) {
        this.objectFactory = objectFactory;
    }

    public CustomMapper getReferenceMapper() {
        return referenceMapper;
    }

    public void setReferenceMapper(final CustomMapper pReferenceMapper) {
        referenceMapper = pReferenceMapper;
    }

    public CustomMapper getValueMapper() {
        return valueMapper;
    }

    public void setValueMapper(final CustomMapper pValueMapper) {
        valueMapper = pValueMapper;
    }

    public boolean isActLikeSerializer() {
        return actLikeSerializer;
    }


    public void setActLikeSerializer(final boolean actLikeSerializer) {
        this.actLikeSerializer = actLikeSerializer;
    }

    public boolean isIgnoreFinals() {
        return ignoreFinals;
    }


    public void setIgnoreFinals(final boolean ignoreFinals) {
        this.ignoreFinals = ignoreFinals;
    }

    public boolean isStoreEmpties() {
        return storeEmpties;
    }


    public void setStoreEmpties(final boolean storeEmpties) {
        this.storeEmpties = storeEmpties;
    }

    public boolean isStoreNulls() {
        return storeNulls;
    }


    public void setStoreNulls(final boolean storeNulls) {
        this.storeNulls = storeNulls;
    }

    public boolean isUseLowerCaseCollectionNames() {
        return useLowerCaseCollectionNames;
    }


    public void setUseLowerCaseCollectionNames(final boolean useLowerCaseCollectionNames) {
        this.useLowerCaseCollectionNames = useLowerCaseCollectionNames;
    }

    public DatastoreProvider getDatastoreProvider() {
        return datastoreProvider;
    }

    public void setDatastoreProvider(final DatastoreProvider datastoreProvider) {
        datastoreProvider.register(this.getDatastoreProvider().get());
        this.datastoreProvider = datastoreProvider;
    }
}

<code block>



package org.mongodb.morphia;


import com.mongodb.BasicDBObject;
import com.mongodb.BasicDBObjectBuilder;
import com.mongodb.DBCollection;
import com.mongodb.DBObject;
import com.mongodb.DBRef;
import org.bson.types.ObjectId;
import org.junit.Ignore;
import org.junit.Test;
import org.mongodb.morphia.TestInheritanceMappings.MapLike;
import org.mongodb.morphia.annotations.AlsoLoad;
import org.mongodb.morphia.annotations.Embedded;
import org.mongodb.morphia.annotations.Entity;
import org.mongodb.morphia.annotations.Id;
import org.mongodb.morphia.annotations.Serialized;
import org.mongodb.morphia.mapping.Mapper;
import org.mongodb.morphia.mapping.MappingException;
import org.mongodb.morphia.mapping.cache.DefaultEntityCache;
import org.mongodb.morphia.testmodel.Address;
import org.mongodb.morphia.testmodel.Article;
import org.mongodb.morphia.testmodel.Circle;
import org.mongodb.morphia.testmodel.Hotel;
import org.mongodb.morphia.testmodel.PhoneNumber;
import org.mongodb.morphia.testmodel.Rectangle;
import org.mongodb.morphia.testmodel.RecursiveChild;
import org.mongodb.morphia.testmodel.RecursiveParent;
import org.mongodb.morphia.testmodel.Translation;
import org.mongodb.morphia.testmodel.TravelAgency;

import java.io.Serializable;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.Vector;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;



public class TestMapping extends TestBase {

    public abstract static class BaseEntity implements Serializable {
        @Id
        private ObjectId id;

        public String getId() {
            return id.toString();
        }

        public void setId(final String id) {
            this.id = new ObjectId(id);
        }
    }


    @Entity
    public static class MissingId {
        private String  id;
    }

    private static class MissingIdStill {
        private String id;
    }

    @Entity("no-id")
    private static class MissingIdRenamed {
        private String id;
    }

    @Embedded
    private static class IdOnEmbedded {
        @Id
        private ObjectId id;
    }

    @Embedded("no-id")
    private static class RenamedEmbedded {
        private String name;
    }

    private static class StrangelyNamedIdField {

        @Id
        private ObjectId id_ = new ObjectId();

    }

    private static class ContainsEmbeddedArray {
        @Id
        private ObjectId id = new ObjectId();
        private RenamedEmbedded[] res;
    }

    private static class NotEmbeddable {
        private String noImNot = "no, I'm not";
    }

    private static class SerializableClass implements Serializable {
        private final String someString = "hi, from the ether.";
    }

    private static class ContainsRef {
        @Id
        private ObjectId id;
        private DBRef rect;
    }

    private static class HasFinalFieldId {
        @Id
        private final long id;
        private String name = "some string";


        protected HasFinalFieldId() {
            id = -1;
        }

        public HasFinalFieldId(final long id) {
            this.id = id;
        }
    }

    private static class ContainsFinalField {
        @Id
        private ObjectId id;
        private final String name;

        protected ContainsFinalField() {
            name = "foo";
        }

        public ContainsFinalField(final String name) {
            this.name = name;
        }
    }

    private static class ContainsTimestamp {
        @Id
        private
        ObjectId id;
        private final Timestamp ts = new Timestamp(System.currentTimeMillis());
    }

    private static class ContainsDBObject {
        @Id
        private ObjectId id;
        private DBObject dbObj = BasicDBObjectBuilder.start("field", "val").get();
    }

    private static class ContainsByteArray {
        @Id
        private ObjectId id;
        private final byte[] bytes = "Scott".getBytes();
    }

    private static class ContainsSerializedData {
        @Id
        private ObjectId id;
        @Serialized
        private final SerializableClass data = new SerializableClass();
    }

    private static class ContainsLongAndStringArray {
        @Id
        private ObjectId id;
        private Long[] longs = {0L, 1L, 2L};
        private String[] strings = {"Scott", "Rocks"};
    }

    private static final class ContainsCollection {
        @Id
        private ObjectId id;
        private final Collection<String> coll = new ArrayList<String>();

        private ContainsCollection() {
            coll.add("hi");
            coll.add("Scott");
        }
    }

    private static class ContainsPrimitiveMap {
        @Id
        private ObjectId id;
        @Embedded
        private final Map<String, Long> embeddedValues = new HashMap<String, Long>();
        private final Map<String, Long> values = new HashMap<String, Long>();
    }

    private interface Foo {
    }

    private static class Foo1 implements Foo {
        private String s;
    }

    private static class Foo2 implements Foo {
        private int i;
    }

    private static class ContainsMapWithEmbeddedInterface {
        @Id
        private ObjectId id;
        @Embedded
        private final Map<String, Foo> embeddedValues = new HashMap<String, Foo>();
    }

    private static class ContainsEmbeddedEntity {
        @Id
        private final ObjectId id = new ObjectId();
        @Embedded
        private ContainsIntegerList cil = new ContainsIntegerList();
    }

    public enum Enum1 {
        A,
        B
    }

    @Entity(value = "cil", noClassnameStored = true)
    private static class ContainsIntegerList {
        @Id
        private ObjectId id;
        private List<Integer> intList = new ArrayList<Integer>();
    }

    private static class ContainsIntegerListNewAndOld {
        @Id
        private ObjectId id;
        private List<Integer> intList = new ArrayList<Integer>();
        private List<Integer> integers = new ArrayList<Integer>();
    }

    @Entity(value = "cil", noClassnameStored = true)
    private static class ContainsIntegerListNew {
        @Id
        private ObjectId id;
        @AlsoLoad("intList")
        private final List<Integer> integers = new ArrayList<Integer>();
    }

    @Entity(noClassnameStored = true)
    private static class ContainsUUID {
        @Id
        private ObjectId id;
        private final UUID uuid = UUID.randomUUID();
    }

    @Entity(noClassnameStored = true)
    private static class ContainsUuidId {
        @Id
        private final UUID id = UUID.randomUUID();
    }

    private static class ContainsEnum1KeyMap {
        @Id
        private ObjectId id;
        private final Map<Enum1, String> values = new HashMap<Enum1, String>();
        @Embedded
        private final Map<Enum1, String> embeddedValues = new HashMap<Enum1, String>();
    }

    private static class ContainsIntKeyMap {
        @Id
        private ObjectId id;
        private final Map<Integer, String> values = new HashMap<Integer, String>();
    }

    private static class ContainsIntKeySetStringMap {
        @Id
        private ObjectId id;
        @Embedded
        private final Map<Integer, Set<String>> values = new HashMap<Integer, Set<String>>();
    }

    private static class ContainsObjectIdKeyMap {
        @Id
        private ObjectId id;
        private final Map<ObjectId, String> values = new HashMap<ObjectId, String>();
    }

    private static class ContainsXKeyMap<T> {
        @Id
        private ObjectId id;
        private final Map<T, String> values = new HashMap<T, String>();
    }

    private static class ContainsMapLike {
        @Id
        private ObjectId id;
        private final MapLike m = new MapLike();
    }

    @Entity
    private static class UsesBaseEntity extends BaseEntity {

    }

    private static class MapSubclass extends LinkedHashMap<String, Object> {
        @Id
        private ObjectId id;
    }

    private class NonStaticInnerClass {
        @Id
        private long id = 1;
    }

    @Test
    public void testUUID() throws Exception {

        final ContainsUUID uuid = new ContainsUUID();
        final UUID before = uuid.uuid;
        getDs().save(uuid);
        final ContainsUUID loaded = getDs().find(ContainsUUID.class).get();
        assertNotNull(loaded);
        assertNotNull(loaded.id);
        assertNotNull(loaded.uuid);
        assertEquals(before, loaded.uuid);
    }

    @Test
    public void testEmbeddedDBObject() throws Exception {
        getMorphia().map(ContainsDBObject.class);
        getDs().save(new ContainsDBObject());
        assertNotNull(getDs().find(ContainsDBObject.class).get());
    }

    @Test
    public void testUuidId() throws Exception {
        getMorphia().map(ContainsUuidId.class);
        final ContainsUuidId uuidId = new ContainsUuidId();
        final UUID before = uuidId.id;
        getDs().save(uuidId);
        final ContainsUuidId loaded = getDs().get(ContainsUuidId.class, before);
        assertNotNull(loaded);
        assertNotNull(loaded.id);
        assertEquals(before, loaded.id);
    }

    @Test
    public void testEmbeddedEntity() throws Exception {
        getMorphia().map(ContainsEmbeddedEntity.class);
        getDs().save(new ContainsEmbeddedEntity());
        final ContainsEmbeddedEntity ceeLoaded = getDs().find(ContainsEmbeddedEntity.class).get();
        assertNotNull(ceeLoaded);
        assertNotNull(ceeLoaded.id);
        assertNotNull(ceeLoaded.cil);
        assertNull(ceeLoaded.cil.id);

    }

    @Test
    public void testEmbeddedArrayElementHasNoClassname() throws Exception {
        getMorphia().map(ContainsEmbeddedArray.class);
        final ContainsEmbeddedArray cea = new ContainsEmbeddedArray();
        cea.res = new RenamedEmbedded[]{new RenamedEmbedded()};

        final DBObject dbObj = getMorphia().toDBObject(cea);
        assertTrue(!((DBObject) ((List) dbObj.get("res")).get(0)).containsField(Mapper.CLASS_NAME_FIELDNAME));
    }

    @Test
    public void testEmbeddedEntityDBObjectHasNoClassname() throws Exception {
        getMorphia().map(ContainsEmbeddedEntity.class);
        final ContainsEmbeddedEntity cee = new ContainsEmbeddedEntity();
        cee.cil = new ContainsIntegerList();
        cee.cil.intList = Collections.singletonList(1);
        final DBObject dbObj = getMorphia().toDBObject(cee);
        assertTrue(!((DBObject) dbObj.get("cil")).containsField(Mapper.CLASS_NAME_FIELDNAME));
    }

    @Test
    public void testEnumKeyedMap() throws Exception {
        final ContainsEnum1KeyMap map = new ContainsEnum1KeyMap();
        map.values.put(Enum1.A, "I'm a");
        map.values.put(Enum1.B, "I'm b");
        map.embeddedValues.put(Enum1.A, "I'm a");
        map.embeddedValues.put(Enum1.B, "I'm b");

        final Key<?> mapKey = getDs().save(map);

        final ContainsEnum1KeyMap mapLoaded = getDs().get(ContainsEnum1KeyMap.class, mapKey.getId());

        assertNotNull(mapLoaded);
        assertEquals(2, mapLoaded.values.size());
        assertNotNull(mapLoaded.values.get(Enum1.A));
        assertNotNull(mapLoaded.values.get(Enum1.B));
        assertEquals(2, mapLoaded.embeddedValues.size());
        assertNotNull(mapLoaded.embeddedValues.get(Enum1.A));
        assertNotNull(mapLoaded.embeddedValues.get(Enum1.B));
    }

    @Test
    public void testAlsoLoad() throws Exception {
        final ContainsIntegerList cil = new ContainsIntegerList();
        cil.intList.add(1);
        getDs().save(cil);
        final ContainsIntegerList cilLoaded = getDs().get(cil);
        assertNotNull(cilLoaded);
        assertNotNull(cilLoaded.intList);
        assertEquals(cilLoaded.intList.size(), cil.intList.size());
        assertEquals(cilLoaded.intList.get(0), cil.intList.get(0));

        final ContainsIntegerListNew cilNew = getDs().get(ContainsIntegerListNew.class, cil.id);
        assertNotNull(cilNew);
        assertNotNull(cilNew.integers);
        assertEquals(1, cilNew.integers.size());
        assertEquals(1, (int) cil.intList.get(0));
    }

    @Test
    public void testIntLists() throws Exception {
        ContainsIntegerList cil = new ContainsIntegerList();
        getDs().save(cil);
        ContainsIntegerList cilLoaded = getDs().get(cil);
        assertNotNull(cilLoaded);
        assertNotNull(cilLoaded.intList);
        assertEquals(cilLoaded.intList.size(), cil.intList.size());


        cil = new ContainsIntegerList();
        cil.intList = null;
        getDs().save(cil);
        cilLoaded = getDs().get(cil);
        assertNotNull(cilLoaded);
        assertNotNull(cilLoaded.intList);
        assertEquals(0, cilLoaded.intList.size());

        cil = new ContainsIntegerList();
        cil.intList.add(1);
        getDs().save(cil);
        cilLoaded = getDs().get(cil);
        assertNotNull(cilLoaded);
        assertNotNull(cilLoaded.intList);
        assertEquals(1, cilLoaded.intList.size());
        assertEquals(1, (int) cilLoaded.intList.get(0));
    }

    @Test
    public void testObjectIdKeyedMap() throws Exception {
        getMorphia().map(ContainsObjectIdKeyMap.class);
        final ContainsObjectIdKeyMap map = new ContainsObjectIdKeyMap();
        final ObjectId o1 = new ObjectId("111111111111111111111111");
        final ObjectId o2 = new ObjectId("222222222222222222222222");
        map.values.put(o1, "I'm 1s");
        map.values.put(o2, "I'm 2s");

        final Key<?> mapKey = getDs().save(map);

        final ContainsObjectIdKeyMap mapLoaded = getDs().get(ContainsObjectIdKeyMap.class, mapKey.getId());

        assertNotNull(mapLoaded);
        assertEquals(2, mapLoaded.values.size());
        assertNotNull(mapLoaded.values.get(o1));
        assertNotNull(mapLoaded.values.get(o2));

        assertNotNull(getDs().find(ContainsIntKeyMap.class).field("values.111111111111111111111111").exists());
        assertEquals(0, getDs().find(ContainsIntKeyMap.class).field("values.111111111111111111111111").doesNotExist().countAll());
        assertNotNull(getDs().find(ContainsIntKeyMap.class).field("values.4").doesNotExist());
        assertEquals(0, getDs().find(ContainsIntKeyMap.class).field("values.4").exists().countAll());
    }

    @Test
    public void testIntKeyedMap() throws Exception {
        final ContainsIntKeyMap map = new ContainsIntKeyMap();
        map.values.put(1, "I'm 1");
        map.values.put(2, "I'm 2");

        final Key<?> mapKey = getDs().save(map);

        final ContainsIntKeyMap mapLoaded = getDs().get(ContainsIntKeyMap.class, mapKey.getId());

        assertNotNull(mapLoaded);
        assertEquals(2, mapLoaded.values.size());
        assertNotNull(mapLoaded.values.get(1));
        assertNotNull(mapLoaded.values.get(2));

        assertNotNull(getDs().find(ContainsIntKeyMap.class).field("values.2").exists());
        assertEquals(0, getDs().find(ContainsIntKeyMap.class).field("values.2").doesNotExist().countAll());
        assertNotNull(getDs().find(ContainsIntKeyMap.class).field("values.4").doesNotExist());
        assertEquals(0, getDs().find(ContainsIntKeyMap.class).field("values.4").exists().countAll());
    }

    @Test
    public void testIntKeySetStringMap() throws Exception {
        final ContainsIntKeySetStringMap map = new ContainsIntKeySetStringMap();
        map.values.put(1, Collections.singleton("I'm 1"));
        map.values.put(2, Collections.singleton("I'm 2"));

        final Key<?> mapKey = getDs().save(map);

        final ContainsIntKeySetStringMap mapLoaded = getDs().get(ContainsIntKeySetStringMap.class, mapKey.getId());

        assertNotNull(mapLoaded);
        assertEquals(2, mapLoaded.values.size());
        assertNotNull(mapLoaded.values.get(1));
        assertNotNull(mapLoaded.values.get(2));
        assertEquals(1, mapLoaded.values.get(1).size());

        assertNotNull(getDs().find(ContainsIntKeyMap.class).field("values.2").exists());
        assertEquals(0, getDs().find(ContainsIntKeyMap.class).field("values.2").doesNotExist().countAll());
        assertNotNull(getDs().find(ContainsIntKeyMap.class).field("values.4").doesNotExist());
        assertEquals(0, getDs().find(ContainsIntKeyMap.class).field("values.4").exists().countAll());
    }

    @Test
    @Ignore("need to add this feature")
    @SuppressWarnings("unchecked")
    public void testGenericKeyedMap() throws Exception {
        final ContainsXKeyMap<Integer> map = new ContainsXKeyMap<Integer>();
        map.values.put(1, "I'm 1");
        map.values.put(2, "I'm 2");

        final Key<ContainsXKeyMap<Integer>> mapKey = getDs().save(map);

        final ContainsXKeyMap<Integer> mapLoaded = getDs().get(ContainsXKeyMap.class, mapKey.getId());

        assertNotNull(mapLoaded);
        assertEquals(2, mapLoaded.values.size());
        assertNotNull(mapLoaded.values.get(1));
        assertNotNull(mapLoaded.values.get(2));
    }

    @Test
    public void testMapLike() throws Exception {
        final ContainsMapLike ml = new ContainsMapLike();
        ml.m.put("first", "test");
        getDs().save(ml);
        final ContainsMapLike mlLoaded = getDs().find(ContainsMapLike.class).get();
        assertNotNull(mlLoaded);
        assertNotNull(mlLoaded.m);
        assertNotNull(mlLoaded.m.containsKey("first"));
    }

    @Test
    public void testPrimMap() throws Exception {
        final ContainsPrimitiveMap primMap = new ContainsPrimitiveMap();
        primMap.embeddedValues.put("first", 1L);
        primMap.embeddedValues.put("second", 2L);
        primMap.values.put("first", 1L);
        primMap.values.put("second", 2L);
        final Key<ContainsPrimitiveMap> primMapKey = getDs().save(primMap);

        final ContainsPrimitiveMap primMapLoaded = getDs().get(ContainsPrimitiveMap.class, primMapKey.getId());

        assertNotNull(primMapLoaded);
        assertEquals(2, primMapLoaded.embeddedValues.size());
        assertEquals(2, primMapLoaded.values.size());
    }

    @Test
    public void testPrimMapWithNullValue() throws Exception {
        final ContainsPrimitiveMap primMap = new ContainsPrimitiveMap();
        primMap.embeddedValues.put("first", null);
        primMap.embeddedValues.put("second", 2L);
        primMap.values.put("first", null);
        primMap.values.put("second", 2L);
        final Key<ContainsPrimitiveMap> primMapKey = getDs().save(primMap);

        final ContainsPrimitiveMap primMapLoaded = getDs().get(ContainsPrimitiveMap.class, primMapKey.getId());

        assertNotNull(primMapLoaded);
        assertEquals(2, primMapLoaded.embeddedValues.size());
        assertEquals(2, primMapLoaded.values.size());
    }

    @Test
    public void testMapWithEmbeddedInterface() throws Exception {
        final ContainsMapWithEmbeddedInterface aMap = new ContainsMapWithEmbeddedInterface();
        final Foo f1 = new Foo1();
        final Foo f2 = new Foo2();

        aMap.embeddedValues.put("first", f1);
        aMap.embeddedValues.put("second", f2);
        getDs().save(aMap);

        final ContainsMapWithEmbeddedInterface mapLoaded = getDs().find(ContainsMapWithEmbeddedInterface.class).get();

        assertNotNull(mapLoaded);
        assertEquals(2, mapLoaded.embeddedValues.size());
        assertTrue(mapLoaded.embeddedValues.get("first") instanceof Foo1);
        assertTrue(mapLoaded.embeddedValues.get("second") instanceof Foo2);

    }

    @Test
    public void testIdFieldWithUnderscore() throws Exception {
        getMorphia().map(StrangelyNamedIdField.class);
    }

    @Test
    public void testFinalIdField() throws Exception {
        getMorphia().map(HasFinalFieldId.class);
        final Key<HasFinalFieldId> savedKey = getDs().save(new HasFinalFieldId(12));
        final HasFinalFieldId loaded = getDs().get(HasFinalFieldId.class, savedKey.getId());
        assertNotNull(loaded);
        assertNotNull(loaded.id);
        assertEquals(12, loaded.id);
    }

    @Test
    public void testFinalField() throws Exception {
        getMorphia().map(ContainsFinalField.class);
        final Key<ContainsFinalField> savedKey = getDs().save(new ContainsFinalField("blah"));
        final ContainsFinalField loaded = getDs().get(ContainsFinalField.class, savedKey.getId());
        assertNotNull(loaded);
        assertNotNull(loaded.name);
        assertEquals("blah", loaded.name);
    }

    @Test
    public void testFinalFieldNotPersisted() throws Exception {
        ((DatastoreImpl) getDs()).getMapper().getOptions().setIgnoreFinals(true);
        getMorphia().map(ContainsFinalField.class);
        final Key<ContainsFinalField> savedKey = getDs().save(new ContainsFinalField("blah"));
        final ContainsFinalField loaded = getDs().get(ContainsFinalField.class, savedKey.getId());
        assertNotNull(loaded);
        assertNotNull(loaded.name);
        assertEquals("foo", loaded.name);
    }

    @Test
    public void testTimestampMapping() throws Exception {
        getMorphia().map(ContainsTimestamp.class);
        final ContainsTimestamp cts = new ContainsTimestamp();
        final Key<ContainsTimestamp> savedKey = getDs().save(cts);
        final ContainsTimestamp loaded = getDs().get(ContainsTimestamp.class, savedKey.getId());
        assertNotNull(loaded.ts);
        assertEquals(loaded.ts.getTime(), cts.ts.getTime());

    }

    @Test
    public void testCollectionMapping() throws Exception {
        getMorphia().map(ContainsCollection.class);
        final Key<ContainsCollection> savedKey = getDs().save(new ContainsCollection());
        final ContainsCollection loaded = getDs().get(ContainsCollection.class, savedKey.getId());
        assertEquals(loaded.coll, (new ContainsCollection()).coll);
        assertNotNull(loaded.id);
    }

    @Test
    public void testByteArrayMapping() throws Exception {
        getMorphia().map(ContainsByteArray.class);
        final Key<ContainsByteArray> savedKey = getDs().save(new ContainsByteArray());
        final ContainsByteArray loaded = getDs().get(ContainsByteArray.class, savedKey.getId());
        assertEquals(new String((new ContainsByteArray()).bytes), new String(loaded.bytes));
        assertNotNull(loaded.id);
    }

    @Test
    public void testBaseEntityValidity() throws Exception {
        getMorphia().map(UsesBaseEntity.class);
    }

    @Test
    public void testSerializedMapping() throws Exception {
        getMorphia().map(ContainsSerializedData.class);
        final Key<ContainsSerializedData> savedKey = getDs().save(new ContainsSerializedData());
        final ContainsSerializedData loaded = getDs().get(ContainsSerializedData.class, savedKey.getId());
        assertNotNull(loaded.data);
        assertEquals(loaded.data.someString, (new ContainsSerializedData()).data.someString);
        assertNotNull(loaded.id);
    }

    @SuppressWarnings("deprecation")
    @Test
    public void testLongArrayMapping() throws Exception {
        getMorphia().map(ContainsLongAndStringArray.class);
        getDs().save(new ContainsLongAndStringArray());
        ContainsLongAndStringArray loaded = getDs().<ContainsLongAndStringArray>find(ContainsLongAndStringArray.class).get();
        assertEquals(loaded.longs, (new ContainsLongAndStringArray()).longs);
        assertEquals(loaded.strings, (new ContainsLongAndStringArray()).strings);

        final ContainsLongAndStringArray array = new ContainsLongAndStringArray();
        array.strings = new String[]{"a", "B", "c"};
        array.longs = new Long[]{4L, 5L, 4L};
        final Key<ContainsLongAndStringArray> k1 = getDs().save(array);
        loaded = getDs().getByKey(ContainsLongAndStringArray.class, k1);
        assertEquals(loaded.longs, array.longs);
        assertEquals(loaded.strings, array.strings);

        assertNotNull(loaded.id);
    }

    @Test
    public void testDbRefMapping() throws Exception {
        getMorphia().map(ContainsRef.class).map(Rectangle.class);
        final DBCollection stuff = getDb().getCollection("stuff");
        final DBCollection rectangles = getDb().getCollection("rectangles");

        assertTrue("'ne' field should not be persisted!", !getMorphia().getMapper().getMCMap().get(ContainsRef.class.getName())
                                                               .containsJavaFieldName("ne"));

        final Rectangle r = new Rectangle(1, 1);
        final DBObject rDbObject = getMorphia().toDBObject(r);
        rDbObject.put("_ns", rectangles.getName());
        rectangles.save(rDbObject);

        final ContainsRef cRef = new ContainsRef();
        cRef.rect = new DBRef((String) rDbObject.get("_ns"), rDbObject.get("_id"));
        final DBObject cRefDbObject = getMorphia().toDBObject(cRef);
        stuff.save(cRefDbObject);
        final BasicDBObject cRefDbObjectLoaded = (BasicDBObject) stuff.findOne(BasicDBObjectBuilder.start("_id", cRefDbObject.get("_id"))
                                                                                                   .get());
        final ContainsRef cRefLoaded = getMorphia().fromDBObject(ContainsRef.class, cRefDbObjectLoaded, new DefaultEntityCache());
        assertNotNull(cRefLoaded);
        assertNotNull(cRefLoaded.rect);
        assertNotNull(cRefLoaded.rect.getId());
        assertNotNull(cRefLoaded.rect.getCollectionName());
        assertEquals(cRefLoaded.rect.getId(), cRef.rect.getId());
        assertEquals(cRefLoaded.rect.getCollectionName(), cRef.rect.getCollectionName());
    }

    @Test
    public void testBadMappings() throws Exception {
        try {
            getMorphia().map(MissingId.class);
            fail("Validation: Missing @Id field not caught");
        } catch (MappingException e) {

        }

        try {
            getMorphia().map(IdOnEmbedded.class);
            fail("Validation: @Id field on @Embedded not caught");
        } catch (MappingException e) {

        }

        try {
            getMorphia().map(RenamedEmbedded.class);
            fail("Validation: @Embedded(\"name\") not caught on Class");
        } catch (MappingException e) {

        }

        try {
            getMorphia().map(MissingIdStill.class);
            fail("Validation: Missing @Id field not not caught");
        } catch (MappingException e) {

        }

        try {
            getMorphia().map(MissingIdRenamed.class);
            fail("Validation: Missing @Id field not not caught");
        } catch (MappingException e) {

        }

        try {
            getMorphia().map(NonStaticInnerClass.class);
            fail("Validation: Non-static inner class allowed");
        } catch (MappingException e) {

        }
    }


    @Test
    public void testBasicMapping() throws Exception {
        final DBCollection hotels = getDb().getCollection("hotels");
        final DBCollection agencies = getDb().getCollection("agencies");

        getMorphia().map(Hotel.class);
        getMorphia().map(TravelAgency.class);

        final Hotel borg = new Hotel();
        borg.setName("Hotel Borg");
        borg.setStars(4);
        borg.setTakesCreditCards(true);
        borg.setStartDate(new Date());
        borg.setType(Hotel.Type.LEISURE);
        borg.getTags().add("Swimming pool");
        borg.getTags().add("Room service");
        borg.setTemp("A temporary transient value");
        borg.getPhoneNumbers().add(new PhoneNumber(354, 5152233, PhoneNumber.Type.PHONE));
        borg.getPhoneNumbers().add(new PhoneNumber(354, 5152244, PhoneNumber.Type.FAX));

        final Address address = new Address();
        address.setStreet("Posthusstraeti 11");
        address.setPostCode("101");
        borg.setAddress(address);

        BasicDBObject hotelDbObj = (BasicDBObject) getMorphia().toDBObject(borg);
        assertTrue(!(((DBObject) ((List) hotelDbObj.get("phoneNumbers")).get(0)).containsField(Mapper.CLASS_NAME_FIELDNAME)));


        hotels.save(hotelDbObj);

        Hotel borgLoaded = getMorphia().fromDBObject(Hotel.class, hotelDbObj, new DefaultEntityCache());

        assertEquals(borg.getName(), borgLoaded.getName());
        assertEquals(borg.getStars(), borgLoaded.getStars());
        assertEquals(borg.getStartDate(), borgLoaded.getStartDate());
        assertEquals(borg.getType(), borgLoaded.getType());
        assertEquals(borg.getAddress().getStreet(), borgLoaded.getAddress().getStreet());
        assertEquals(borg.getTags().size(), borgLoaded.getTags().size());
        assertEquals(borg.getTags(), borgLoaded.getTags());
        assertEquals(borg.getPhoneNumbers().size(), borgLoaded.getPhoneNumbers().size());
        assertEquals(borg.getPhoneNumbers().get(1), borgLoaded.getPhoneNumbers().get(1));
        assertNull(borgLoaded.getTemp());
        assertTrue(borgLoaded.getPhoneNumbers() instanceof Vector);
        assertNotNull(borgLoaded.getId());

        final TravelAgency agency = new TravelAgency();
        agency.setName("Lastminute.com");
        agency.getHotels().add(borgLoaded);

        final BasicDBObject agencyDbObj = (BasicDBObject) getMorphia().toDBObject(agency);
        agencies.save(agencyDbObj);

        final TravelAgency agencyLoaded = getMorphia().fromDBObject(TravelAgency.class,
                                                                    agencies.findOne(new BasicDBObject(Mapper.ID_KEY,
                                                                                                       agencyDbObj.get(Mapper.ID_KEY))),
                                                                    new DefaultEntityCache());

        assertEquals(agency.getName(), agencyLoaded.getName());
        assertEquals(1, agency.getHotels().size());
        assertEquals(agency.getHotels().get(0).getName(), borg.getName());


        borgLoaded.setAddress(null);
        borgLoaded.getPhoneNumbers().clear();
        borgLoaded.setName(null);

        hotelDbObj = (BasicDBObject) getMorphia().toDBObject(borgLoaded);
        hotels.save(hotelDbObj);

        hotelDbObj = (BasicDBObject) hotels.findOne(new BasicDBObject(Mapper.ID_KEY, hotelDbObj.get(Mapper.ID_KEY)));

        borgLoaded = getMorphia().fromDBObject(Hotel.class, hotelDbObj, new DefaultEntityCache());
        assertNull(borgLoaded.getAddress());
        assertEquals(0, borgLoaded.getPhoneNumbers().size());
        assertNull(borgLoaded.getName());
    }

    @Test
    public void testMaps() throws Exception {
        final DBCollection articles = getDb().getCollection("articles");
        getMorphia().map(Article.class).map(Translation.class).map(Circle.class);

        final Article related = new Article();
        final BasicDBObject relatedDbObj = (BasicDBObject) getMorphia().toDBObject(related);
        articles.save(relatedDbObj);

        final Article relatedLoaded = getMorphia().fromDBObject(Article.class,
                                                                articles.findOne(new BasicDBObject(Mapper.ID_KEY,
                                                                                                   relatedDbObj.get(Mapper.ID_KEY))),
                                                                new DefaultEntityCache());

        final Article article = new Article();
        article.setTranslation("en", new Translation("Hello World", "Just a test"));
        article.setTranslation("is", new Translation("HallÃ³ heimur", "Bara aÃ° prÃ³fa"));

        article.setAttribute("myDate", new Date());
        article.setAttribute("myString", "Test");
        article.setAttribute("myInt", 123);

        article.putRelated("test", relatedLoaded);

        final BasicDBObject articleDbObj = (BasicDBObject) getMorphia().toDBObject(article);
        articles.save(articleDbObj);

        final Article articleLoaded = getMorphia().fromDBObject(Article.class,
                                                                articles.findOne(
                                                                                    new BasicDBObject(Mapper.ID_KEY,
                                                                                                      articleDbObj.get(Mapper.ID_KEY))),
                                                                new DefaultEntityCache());

        assertEquals(article.getTranslations().size(), articleLoaded.getTranslations().size());
        assertEquals(article.getTranslation("en").getTitle(), articleLoaded.getTranslation("en").getTitle());
        assertEquals(article.getTranslation("is").getBody(), articleLoaded.getTranslation("is").getBody());
        assertEquals(article.getAttributes().size(), articleLoaded.getAttributes().size());
        assertEquals(article.getAttribute("myDate"), articleLoaded.getAttribute("myDate"));
        assertEquals(article.getAttribute("myString"), articleLoaded.getAttribute("myString"));
        assertEquals(article.getAttribute("myInt"), articleLoaded.getAttribute("myInt"));
        assertEquals(article.getRelated().size(), articleLoaded.getRelated().size());
        assertEquals(article.getRelated("test").getId(), articleLoaded.getRelated("test").getId());
    }


    @Test(expected = MappingException.class)
    public void testReferenceWithoutIdValue() throws Exception {
        final RecursiveParent parent = new RecursiveParent();
        final RecursiveChild child = new RecursiveChild();
        child.setId(null);
        parent.setChild(child);
        getDs().save(parent);

    }

    @Test
    public void testRecursiveReference() throws Exception {
        final DBCollection stuff = getDb().getCollection("stuff");

        getMorphia().map(RecursiveParent.class).map(RecursiveChild.class);

        final RecursiveParent parent = new RecursiveParent();
        final DBObject parentDbObj = getMorphia().toDBObject(parent);
        stuff.save(parentDbObj);

        final RecursiveChild child = new RecursiveChild();
        final DBObject childDbObj = getMorphia().toDBObject(child);
        stuff.save(childDbObj);

        final RecursiveParent parentLoaded = getMorphia().fromDBObject(RecursiveParent.class,
                                                                       stuff.findOne(new BasicDBObject(Mapper.ID_KEY,
                                                                                                       parentDbObj.get(Mapper.ID_KEY))),
                                                                       new DefaultEntityCache());
        final RecursiveChild childLoaded = getMorphia().fromDBObject(RecursiveChild.class,
                                                                     stuff.findOne(new BasicDBObject(Mapper.ID_KEY,
                                                                                                     childDbObj.get(Mapper.ID_KEY))),
                                                                     new DefaultEntityCache());

        parentLoaded.setChild(childLoaded);
        childLoaded.setParent(parentLoaded);

        stuff.save(getMorphia().toDBObject(parentLoaded));
        stuff.save(getMorphia().toDBObject(childLoaded));

        final RecursiveParent finalParentLoaded = getMorphia().fromDBObject(RecursiveParent.class,
                                                                            stuff.findOne(new BasicDBObject(Mapper.ID_KEY,
                                                                                                            parentDbObj.get(Mapper
                                                                                                                                .ID_KEY))),
                                                                            new DefaultEntityCache());
        final RecursiveChild finalChildLoaded = getMorphia().fromDBObject(RecursiveChild.class,
                                                                          stuff.findOne(new BasicDBObject(Mapper.ID_KEY,
                                                                                                          childDbObj.get(Mapper.ID_KEY))),
                                                                          new DefaultEntityCache());

        assertNotNull(finalParentLoaded.getChild());
        assertNotNull(finalChildLoaded.getParent());
    }
}

<code block>
package org.mongodb.morphia.mapping;


import com.mongodb.DBObject;
import org.mongodb.morphia.ObjectFactory;
import org.mongodb.morphia.annotations.ConstructorArgs;
import org.mongodb.morphia.logging.Logger;
import org.mongodb.morphia.logging.MorphiaLoggerFactory;

import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;



public class DefaultCreator implements ObjectFactory {

    private static final Logger LOG = MorphiaLoggerFactory.get(DefaultCreator.class);

    private Map<String, Class> classNameCache = new ConcurrentHashMap<String, Class>();

    private MapperOptions options = null;

    public DefaultCreator() {
    }

    public DefaultCreator(MapperOptions options) {
        this.options = options;
    }


    private <T> T newInstance(final Constructor<T> tryMe, final Class<T> fallbackType) {
        if (tryMe != null) {
            tryMe.setAccessible(true);
            try {
                return tryMe.newInstance();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
        return createInst(fallbackType);
    }

    private static <T> Constructor<T> getNoArgsConstructor(final Class<T> type) {
        try {
            final Constructor<T> constructor = type.getDeclaredConstructor();
            constructor.setAccessible(true);
            return constructor;
        } catch (NoSuchMethodException e) {
            throw new MappingException("No usable constructor for " + type.getName(), e);
        }
    }

    @Override
    public <T> T createInstance(final Class<T> clazz) {
        return createInst(clazz);
    }

    @Override
    public <T> T createInstance(final Class<T> clazz, final DBObject dbObj) {
        Class<T> c = getClass(dbObj);
        if (c == null) {
            c = clazz;
        }
        return createInstance(c);
    }

    @Override
    @SuppressWarnings("unchecked")
    public Object createInstance(final Mapper mapper, final MappedField mf, final DBObject dbObj) {
        Class c = getClass(dbObj);
        if (c == null) {
            c = mf.isSingleValue() ? mf.getConcreteType() : mf.getSubClass();
        }
        try {
            return createInstance(c, dbObj);
        } catch (RuntimeException e) {
            final ConstructorArgs argAnn = mf.getAnnotation(ConstructorArgs.class);
            if (argAnn == null) {
                throw e;
            }

            final Object[] args = new Object[argAnn.value().length];
            final Class[] argTypes = new Class[argAnn.value().length];
            for (int i = 0; i < argAnn.value().length; i++) {


                final Object val = dbObj.get(argAnn.value()[i]);
                args[i] = val;
                argTypes[i] = val.getClass();
            }
            try {
                final Constructor constructor = c.getDeclaredConstructor(argTypes);
                constructor.setAccessible(true);
                return constructor.newInstance(args);
            } catch (Exception ex) {
                throw new RuntimeException(ex);
            }
        }
    }

    @Override
    @SuppressWarnings("unchecked")
    public Map createMap(final MappedField mf) {
        return newInstance(mf != null ? mf.getCTor() : null, HashMap.class);
    }

    @Override
    @SuppressWarnings("unchecked")
    public List createList(final MappedField mf) {
        return newInstance(mf != null ? mf.getCTor() : null, ArrayList.class);
    }

    @Override
    @SuppressWarnings("unchecked")
    public Set createSet(final MappedField mf) {
        return newInstance(mf != null ? mf.getCTor() : null, HashSet.class);
    }

    @SuppressWarnings("unchecked")
    private <T> Class<T> getClass(final DBObject dbObj) {

        Class c = null;
        if (dbObj.containsField(Mapper.CLASS_NAME_FIELDNAME)) {
            final String className = (String) dbObj.get(Mapper.CLASS_NAME_FIELDNAME);


            try {
                if (options != null && options.isCacheClassLookups()) {
                    c = classNameCache.get(className);
                    if (c == null) {
                        c = Class.forName(className, true, getClassLoaderForClass());
                        classNameCache.put(className, c);
                    }
                } else {
                    c = Class.forName(className, true, getClassLoaderForClass());
                }
            } catch (ClassNotFoundException e) {
                if (LOG.isWarningEnabled()) {
                    LOG.warning("Class not found defined in dbObj: ", e);
                }
            }
        }
        return c;
    }

    protected ClassLoader getClassLoaderForClass() {
        return Thread.currentThread().getContextClassLoader();
    }

    @SuppressWarnings("unchecked")
    public <T> T createInst(final Class<T> clazz) {
        try {
            return getNoArgsConstructor(clazz).newInstance();
        } catch (Exception e) {
            if (Collection.class.isAssignableFrom(clazz)) {
                return (T) createList(null);
            } else if (Map.class.isAssignableFrom(clazz)) {
                return (T) createMap(null);
            } else if (Set.class.isAssignableFrom(clazz)) {
                return (T) createSet(null);
            }
            throw new MappingException("No usable constructor for " + clazz.getName(), e);
        }
    }

    public Map<String, Class> getClassNameCache() {
        HashMap<String, Class> copy = new HashMap<String, Class>();
        copy.putAll(classNameCache);
        return copy;
    }

}

<code block>
package org.mongodb.morphia.mapping;


import org.mongodb.morphia.ObjectFactory;
import org.mongodb.morphia.mapping.lazy.DatastoreProvider;
import org.mongodb.morphia.mapping.lazy.DefaultDatastoreProvider;



public class MapperOptions {
    private boolean actLikeSerializer;
    private boolean ignoreFinals; 
    private boolean storeNulls;
    private boolean storeEmpties;
    private boolean useLowerCaseCollectionNames;
    private boolean cacheClassLookups = false;
    private ObjectFactory objectFactory = new DefaultCreator(this);
    private CustomMapper embeddedMapper = new EmbeddedMapper();
    private CustomMapper defaultMapper = embeddedMapper;
    private CustomMapper referenceMapper = new ReferenceMapper();
    private CustomMapper valueMapper = new ValueMapper();
    private DatastoreProvider datastoreProvider = new DefaultDatastoreProvider();

    public CustomMapper getDefaultMapper() {
        return defaultMapper;
    }

    public void setDefaultMapper(final CustomMapper pDefaultMapper) {
        defaultMapper = pDefaultMapper;
    }

    public CustomMapper getEmbeddedMapper() {
        return embeddedMapper;
    }

    public void setEmbeddedMapper(final CustomMapper pEmbeddedMapper) {
        embeddedMapper = pEmbeddedMapper;
    }

    public ObjectFactory getObjectFactory() {
        return objectFactory;
    }


    public void setObjectFactory(final ObjectFactory objectFactory) {
        this.objectFactory = objectFactory;
    }

    public CustomMapper getReferenceMapper() {
        return referenceMapper;
    }

    public void setReferenceMapper(final CustomMapper pReferenceMapper) {
        referenceMapper = pReferenceMapper;
    }

    public CustomMapper getValueMapper() {
        return valueMapper;
    }

    public void setValueMapper(final CustomMapper pValueMapper) {
        valueMapper = pValueMapper;
    }

    public boolean isActLikeSerializer() {
        return actLikeSerializer;
    }


    public void setActLikeSerializer(final boolean actLikeSerializer) {
        this.actLikeSerializer = actLikeSerializer;
    }

    public boolean isIgnoreFinals() {
        return ignoreFinals;
    }


    public void setIgnoreFinals(final boolean ignoreFinals) {
        this.ignoreFinals = ignoreFinals;
    }

    public boolean isStoreEmpties() {
        return storeEmpties;
    }


    public void setStoreEmpties(final boolean storeEmpties) {
        this.storeEmpties = storeEmpties;
    }

    public boolean isStoreNulls() {
        return storeNulls;
    }


    public void setStoreNulls(final boolean storeNulls) {
        this.storeNulls = storeNulls;
    }

    public boolean isUseLowerCaseCollectionNames() {
        return useLowerCaseCollectionNames;
    }


    public void setUseLowerCaseCollectionNames(final boolean useLowerCaseCollectionNames) {
        this.useLowerCaseCollectionNames = useLowerCaseCollectionNames;
    }

    public DatastoreProvider getDatastoreProvider() {
        return datastoreProvider;
    }

    public void setDatastoreProvider(final DatastoreProvider datastoreProvider) {
        datastoreProvider.register(this.getDatastoreProvider().get());
        this.datastoreProvider = datastoreProvider;
    }

    public boolean isCacheClassLookups() {
        return cacheClassLookups;
    }

    public void setCacheClassLookups(final boolean cacheClassLookups) {
        this.cacheClassLookups = cacheClassLookups;
    }
}

<code block>



package org.mongodb.morphia;


import com.mongodb.BasicDBObject;
import com.mongodb.BasicDBObjectBuilder;
import com.mongodb.DBCollection;
import com.mongodb.DBObject;
import com.mongodb.DBRef;
import org.bson.types.ObjectId;
import org.junit.Ignore;
import org.junit.Test;
import org.mongodb.morphia.TestInheritanceMappings.MapLike;
import org.mongodb.morphia.annotations.AlsoLoad;
import org.mongodb.morphia.annotations.Embedded;
import org.mongodb.morphia.annotations.Entity;
import org.mongodb.morphia.annotations.Id;
import org.mongodb.morphia.annotations.Serialized;
import org.mongodb.morphia.mapping.DefaultCreator;
import org.mongodb.morphia.mapping.Mapper;
import org.mongodb.morphia.mapping.MappingException;
import org.mongodb.morphia.mapping.cache.DefaultEntityCache;
import org.mongodb.morphia.testmodel.Address;
import org.mongodb.morphia.testmodel.Article;
import org.mongodb.morphia.testmodel.Circle;
import org.mongodb.morphia.testmodel.Hotel;
import org.mongodb.morphia.testmodel.PhoneNumber;
import org.mongodb.morphia.testmodel.Rectangle;
import org.mongodb.morphia.testmodel.RecursiveChild;
import org.mongodb.morphia.testmodel.RecursiveParent;
import org.mongodb.morphia.testmodel.Translation;
import org.mongodb.morphia.testmodel.TravelAgency;

import java.io.Serializable;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.Vector;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;



public class TestMapping extends TestBase {

    public abstract static class BaseEntity implements Serializable {
        @Id
        private ObjectId id;

        public String getId() {
            return id.toString();
        }

        public void setId(final String id) {
            this.id = new ObjectId(id);
        }
    }


    @Entity
    public static class MissingId {
        private String  id;
    }

    private static class MissingIdStill {
        private String id;
    }

    @Entity("no-id")
    private static class MissingIdRenamed {
        private String id;
    }

    @Embedded
    private static class IdOnEmbedded {
        @Id
        private ObjectId id;
    }

    @Embedded("no-id")
    private static class RenamedEmbedded {
        private String name;
    }

    private static class StrangelyNamedIdField {

        @Id
        private ObjectId id_ = new ObjectId();

    }

    private static class ContainsEmbeddedArray {
        @Id
        private ObjectId id = new ObjectId();
        private RenamedEmbedded[] res;
    }

    private static class NotEmbeddable {
        private String noImNot = "no, I'm not";
    }

    private static class SerializableClass implements Serializable {
        private final String someString = "hi, from the ether.";
    }

    private static class ContainsRef {
        @Id
        private ObjectId id;
        private DBRef rect;
    }

    private static class HasFinalFieldId {
        @Id
        private final long id;
        private String name = "some string";


        protected HasFinalFieldId() {
            id = -1;
        }

        public HasFinalFieldId(final long id) {
            this.id = id;
        }
    }

    private static class ContainsFinalField {
        @Id
        private ObjectId id;
        private final String name;

        protected ContainsFinalField() {
            name = "foo";
        }

        public ContainsFinalField(final String name) {
            this.name = name;
        }
    }

    private static class ContainsTimestamp {
        @Id
        private
        ObjectId id;
        private final Timestamp ts = new Timestamp(System.currentTimeMillis());
    }

    private static class ContainsDBObject {
        @Id
        private ObjectId id;
        private DBObject dbObj = BasicDBObjectBuilder.start("field", "val").get();
    }

    private static class ContainsByteArray {
        @Id
        private ObjectId id;
        private final byte[] bytes = "Scott".getBytes();
    }

    private static class ContainsSerializedData {
        @Id
        private ObjectId id;
        @Serialized
        private final SerializableClass data = new SerializableClass();
    }

    private static class ContainsLongAndStringArray {
        @Id
        private ObjectId id;
        private Long[] longs = {0L, 1L, 2L};
        private String[] strings = {"Scott", "Rocks"};
    }

    private static final class ContainsCollection {
        @Id
        private ObjectId id;
        private final Collection<String> coll = new ArrayList<String>();

        private ContainsCollection() {
            coll.add("hi");
            coll.add("Scott");
        }
    }

    private static class ContainsPrimitiveMap {
        @Id
        private ObjectId id;
        @Embedded
        private final Map<String, Long> embeddedValues = new HashMap<String, Long>();
        private final Map<String, Long> values = new HashMap<String, Long>();
    }

    private interface Foo {
    }

    private static class Foo1 implements Foo {
        private String s;
    }

    private static class Foo2 implements Foo {
        private int i;
    }

    private static class ContainsMapWithEmbeddedInterface {
        @Id
        private ObjectId id;
        @Embedded
        private final Map<String, Foo> embeddedValues = new HashMap<String, Foo>();
    }

    private static class ContainsEmbeddedEntity {
        @Id
        private final ObjectId id = new ObjectId();
        @Embedded
        private ContainsIntegerList cil = new ContainsIntegerList();
    }

    public enum Enum1 {
        A,
        B
    }

    @Entity(value = "cil", noClassnameStored = true)
    private static class ContainsIntegerList {
        @Id
        private ObjectId id;
        private List<Integer> intList = new ArrayList<Integer>();
    }

    private static class ContainsIntegerListNewAndOld {
        @Id
        private ObjectId id;
        private List<Integer> intList = new ArrayList<Integer>();
        private List<Integer> integers = new ArrayList<Integer>();
    }

    @Entity(value = "cil", noClassnameStored = true)
    private static class ContainsIntegerListNew {
        @Id
        private ObjectId id;
        @AlsoLoad("intList")
        private final List<Integer> integers = new ArrayList<Integer>();
    }

    @Entity(noClassnameStored = true)
    private static class ContainsUUID {
        @Id
        private ObjectId id;
        private final UUID uuid = UUID.randomUUID();
    }

    @Entity(noClassnameStored = true)
    private static class ContainsUuidId {
        @Id
        private final UUID id = UUID.randomUUID();
    }

    private static class ContainsEnum1KeyMap {
        @Id
        private ObjectId id;
        private final Map<Enum1, String> values = new HashMap<Enum1, String>();
        @Embedded
        private final Map<Enum1, String> embeddedValues = new HashMap<Enum1, String>();
    }

    private static class ContainsIntKeyMap {
        @Id
        private ObjectId id;
        private final Map<Integer, String> values = new HashMap<Integer, String>();
    }

    private static class ContainsIntKeySetStringMap {
        @Id
        private ObjectId id;
        @Embedded
        private final Map<Integer, Set<String>> values = new HashMap<Integer, Set<String>>();
    }

    private static class ContainsObjectIdKeyMap {
        @Id
        private ObjectId id;
        private final Map<ObjectId, String> values = new HashMap<ObjectId, String>();
    }

    private static class ContainsXKeyMap<T> {
        @Id
        private ObjectId id;
        private final Map<T, String> values = new HashMap<T, String>();
    }

    private static class ContainsMapLike {
        @Id
        private ObjectId id;
        private final MapLike m = new MapLike();
    }

    @Entity
    private static class UsesBaseEntity extends BaseEntity {

    }

    private static class MapSubclass extends LinkedHashMap<String, Object> {
        @Id
        private ObjectId id;
    }

    private class NonStaticInnerClass {
        @Id
        private long id = 1;
    }

    @Test
    public void testUUID() throws Exception {

        final ContainsUUID uuid = new ContainsUUID();
        final UUID before = uuid.uuid;
        getDs().save(uuid);
        final ContainsUUID loaded = getDs().find(ContainsUUID.class).get();
        assertNotNull(loaded);
        assertNotNull(loaded.id);
        assertNotNull(loaded.uuid);
        assertEquals(before, loaded.uuid);
    }

    @Test
    public void testEmbeddedDBObject() throws Exception {
        getMorphia().map(ContainsDBObject.class);
        getDs().save(new ContainsDBObject());
        assertNotNull(getDs().find(ContainsDBObject.class).get());
    }

    @Test
    public void testUuidId() throws Exception {
        getMorphia().map(ContainsUuidId.class);
        final ContainsUuidId uuidId = new ContainsUuidId();
        final UUID before = uuidId.id;
        getDs().save(uuidId);
        final ContainsUuidId loaded = getDs().get(ContainsUuidId.class, before);
        assertNotNull(loaded);
        assertNotNull(loaded.id);
        assertEquals(before, loaded.id);
    }

    @Test
    public void testEmbeddedEntity() throws Exception {
        getMorphia().map(ContainsEmbeddedEntity.class);
        getDs().save(new ContainsEmbeddedEntity());
        final ContainsEmbeddedEntity ceeLoaded = getDs().find(ContainsEmbeddedEntity.class).get();
        assertNotNull(ceeLoaded);
        assertNotNull(ceeLoaded.id);
        assertNotNull(ceeLoaded.cil);
        assertNull(ceeLoaded.cil.id);

    }

    @Test
    public void testEmbeddedArrayElementHasNoClassname() throws Exception {
        getMorphia().map(ContainsEmbeddedArray.class);
        final ContainsEmbeddedArray cea = new ContainsEmbeddedArray();
        cea.res = new RenamedEmbedded[]{new RenamedEmbedded()};

        final DBObject dbObj = getMorphia().toDBObject(cea);
        assertTrue(!((DBObject) ((List) dbObj.get("res")).get(0)).containsField(Mapper.CLASS_NAME_FIELDNAME));
    }

    @Test
    public void testEmbeddedEntityDBObjectHasNoClassname() throws Exception {
        getMorphia().map(ContainsEmbeddedEntity.class);
        final ContainsEmbeddedEntity cee = new ContainsEmbeddedEntity();
        cee.cil = new ContainsIntegerList();
        cee.cil.intList = Collections.singletonList(1);
        final DBObject dbObj = getMorphia().toDBObject(cee);
        assertTrue(!((DBObject) dbObj.get("cil")).containsField(Mapper.CLASS_NAME_FIELDNAME));
    }

    @Test
    public void testEnumKeyedMap() throws Exception {
        final ContainsEnum1KeyMap map = new ContainsEnum1KeyMap();
        map.values.put(Enum1.A, "I'm a");
        map.values.put(Enum1.B, "I'm b");
        map.embeddedValues.put(Enum1.A, "I'm a");
        map.embeddedValues.put(Enum1.B, "I'm b");

        final Key<?> mapKey = getDs().save(map);

        final ContainsEnum1KeyMap mapLoaded = getDs().get(ContainsEnum1KeyMap.class, mapKey.getId());

        assertNotNull(mapLoaded);
        assertEquals(2, mapLoaded.values.size());
        assertNotNull(mapLoaded.values.get(Enum1.A));
        assertNotNull(mapLoaded.values.get(Enum1.B));
        assertEquals(2, mapLoaded.embeddedValues.size());
        assertNotNull(mapLoaded.embeddedValues.get(Enum1.A));
        assertNotNull(mapLoaded.embeddedValues.get(Enum1.B));
    }

    @Test
    public void testAlsoLoad() throws Exception {
        final ContainsIntegerList cil = new ContainsIntegerList();
        cil.intList.add(1);
        getDs().save(cil);
        final ContainsIntegerList cilLoaded = getDs().get(cil);
        assertNotNull(cilLoaded);
        assertNotNull(cilLoaded.intList);
        assertEquals(cilLoaded.intList.size(), cil.intList.size());
        assertEquals(cilLoaded.intList.get(0), cil.intList.get(0));

        final ContainsIntegerListNew cilNew = getDs().get(ContainsIntegerListNew.class, cil.id);
        assertNotNull(cilNew);
        assertNotNull(cilNew.integers);
        assertEquals(1, cilNew.integers.size());
        assertEquals(1, (int) cil.intList.get(0));
    }

    @Test
    public void testIntLists() throws Exception {
        ContainsIntegerList cil = new ContainsIntegerList();
        getDs().save(cil);
        ContainsIntegerList cilLoaded = getDs().get(cil);
        assertNotNull(cilLoaded);
        assertNotNull(cilLoaded.intList);
        assertEquals(cilLoaded.intList.size(), cil.intList.size());


        cil = new ContainsIntegerList();
        cil.intList = null;
        getDs().save(cil);
        cilLoaded = getDs().get(cil);
        assertNotNull(cilLoaded);
        assertNotNull(cilLoaded.intList);
        assertEquals(0, cilLoaded.intList.size());

        cil = new ContainsIntegerList();
        cil.intList.add(1);
        getDs().save(cil);
        cilLoaded = getDs().get(cil);
        assertNotNull(cilLoaded);
        assertNotNull(cilLoaded.intList);
        assertEquals(1, cilLoaded.intList.size());
        assertEquals(1, (int) cilLoaded.intList.get(0));
    }

    @Test
    public void testObjectIdKeyedMap() throws Exception {
        getMorphia().map(ContainsObjectIdKeyMap.class);
        final ContainsObjectIdKeyMap map = new ContainsObjectIdKeyMap();
        final ObjectId o1 = new ObjectId("111111111111111111111111");
        final ObjectId o2 = new ObjectId("222222222222222222222222");
        map.values.put(o1, "I'm 1s");
        map.values.put(o2, "I'm 2s");

        final Key<?> mapKey = getDs().save(map);

        final ContainsObjectIdKeyMap mapLoaded = getDs().get(ContainsObjectIdKeyMap.class, mapKey.getId());

        assertNotNull(mapLoaded);
        assertEquals(2, mapLoaded.values.size());
        assertNotNull(mapLoaded.values.get(o1));
        assertNotNull(mapLoaded.values.get(o2));

        assertNotNull(getDs().find(ContainsIntKeyMap.class).field("values.111111111111111111111111").exists());
        assertEquals(0, getDs().find(ContainsIntKeyMap.class).field("values.111111111111111111111111").doesNotExist().countAll());
        assertNotNull(getDs().find(ContainsIntKeyMap.class).field("values.4").doesNotExist());
        assertEquals(0, getDs().find(ContainsIntKeyMap.class).field("values.4").exists().countAll());
    }

    @Test
    public void testIntKeyedMap() throws Exception {
        final ContainsIntKeyMap map = new ContainsIntKeyMap();
        map.values.put(1, "I'm 1");
        map.values.put(2, "I'm 2");

        final Key<?> mapKey = getDs().save(map);

        final ContainsIntKeyMap mapLoaded = getDs().get(ContainsIntKeyMap.class, mapKey.getId());

        assertNotNull(mapLoaded);
        assertEquals(2, mapLoaded.values.size());
        assertNotNull(mapLoaded.values.get(1));
        assertNotNull(mapLoaded.values.get(2));

        assertNotNull(getDs().find(ContainsIntKeyMap.class).field("values.2").exists());
        assertEquals(0, getDs().find(ContainsIntKeyMap.class).field("values.2").doesNotExist().countAll());
        assertNotNull(getDs().find(ContainsIntKeyMap.class).field("values.4").doesNotExist());
        assertEquals(0, getDs().find(ContainsIntKeyMap.class).field("values.4").exists().countAll());
    }

    @Test
    public void testIntKeySetStringMap() throws Exception {
        final ContainsIntKeySetStringMap map = new ContainsIntKeySetStringMap();
        map.values.put(1, Collections.singleton("I'm 1"));
        map.values.put(2, Collections.singleton("I'm 2"));

        final Key<?> mapKey = getDs().save(map);

        final ContainsIntKeySetStringMap mapLoaded = getDs().get(ContainsIntKeySetStringMap.class, mapKey.getId());

        assertNotNull(mapLoaded);
        assertEquals(2, mapLoaded.values.size());
        assertNotNull(mapLoaded.values.get(1));
        assertNotNull(mapLoaded.values.get(2));
        assertEquals(1, mapLoaded.values.get(1).size());

        assertNotNull(getDs().find(ContainsIntKeyMap.class).field("values.2").exists());
        assertEquals(0, getDs().find(ContainsIntKeyMap.class).field("values.2").doesNotExist().countAll());
        assertNotNull(getDs().find(ContainsIntKeyMap.class).field("values.4").doesNotExist());
        assertEquals(0, getDs().find(ContainsIntKeyMap.class).field("values.4").exists().countAll());
    }

    @Test
    @Ignore("need to add this feature")
    @SuppressWarnings("unchecked")
    public void testGenericKeyedMap() throws Exception {
        final ContainsXKeyMap<Integer> map = new ContainsXKeyMap<Integer>();
        map.values.put(1, "I'm 1");
        map.values.put(2, "I'm 2");

        final Key<ContainsXKeyMap<Integer>> mapKey = getDs().save(map);

        final ContainsXKeyMap<Integer> mapLoaded = getDs().get(ContainsXKeyMap.class, mapKey.getId());

        assertNotNull(mapLoaded);
        assertEquals(2, mapLoaded.values.size());
        assertNotNull(mapLoaded.values.get(1));
        assertNotNull(mapLoaded.values.get(2));
    }

    @Test
    public void testMapLike() throws Exception {
        final ContainsMapLike ml = new ContainsMapLike();
        ml.m.put("first", "test");
        getDs().save(ml);
        final ContainsMapLike mlLoaded = getDs().find(ContainsMapLike.class).get();
        assertNotNull(mlLoaded);
        assertNotNull(mlLoaded.m);
        assertNotNull(mlLoaded.m.containsKey("first"));
    }

    @Test
    public void testPrimMap() throws Exception {
        final ContainsPrimitiveMap primMap = new ContainsPrimitiveMap();
        primMap.embeddedValues.put("first", 1L);
        primMap.embeddedValues.put("second", 2L);
        primMap.values.put("first", 1L);
        primMap.values.put("second", 2L);
        final Key<ContainsPrimitiveMap> primMapKey = getDs().save(primMap);

        final ContainsPrimitiveMap primMapLoaded = getDs().get(ContainsPrimitiveMap.class, primMapKey.getId());

        assertNotNull(primMapLoaded);
        assertEquals(2, primMapLoaded.embeddedValues.size());
        assertEquals(2, primMapLoaded.values.size());
    }

    @Test
    public void testPrimMapWithNullValue() throws Exception {
        final ContainsPrimitiveMap primMap = new ContainsPrimitiveMap();
        primMap.embeddedValues.put("first", null);
        primMap.embeddedValues.put("second", 2L);
        primMap.values.put("first", null);
        primMap.values.put("second", 2L);
        final Key<ContainsPrimitiveMap> primMapKey = getDs().save(primMap);

        final ContainsPrimitiveMap primMapLoaded = getDs().get(ContainsPrimitiveMap.class, primMapKey.getId());

        assertNotNull(primMapLoaded);
        assertEquals(2, primMapLoaded.embeddedValues.size());
        assertEquals(2, primMapLoaded.values.size());
    }

    @Test
    public void testMapWithEmbeddedInterface() throws Exception {
        final ContainsMapWithEmbeddedInterface aMap = new ContainsMapWithEmbeddedInterface();
        final Foo f1 = new Foo1();
        final Foo f2 = new Foo2();

        aMap.embeddedValues.put("first", f1);
        aMap.embeddedValues.put("second", f2);
        getDs().save(aMap);

        final ContainsMapWithEmbeddedInterface mapLoaded = getDs().find(ContainsMapWithEmbeddedInterface.class).get();

        assertNotNull(mapLoaded);
        assertEquals(2, mapLoaded.embeddedValues.size());
        assertTrue(mapLoaded.embeddedValues.get("first") instanceof Foo1);
        assertTrue(mapLoaded.embeddedValues.get("second") instanceof Foo2);

    }

    @Test
    public void testIdFieldWithUnderscore() throws Exception {
        getMorphia().map(StrangelyNamedIdField.class);
    }

    @Test
    public void testFinalIdField() throws Exception {
        getMorphia().map(HasFinalFieldId.class);
        final Key<HasFinalFieldId> savedKey = getDs().save(new HasFinalFieldId(12));
        final HasFinalFieldId loaded = getDs().get(HasFinalFieldId.class, savedKey.getId());
        assertNotNull(loaded);
        assertNotNull(loaded.id);
        assertEquals(12, loaded.id);
    }

    @Test
    public void testFinalField() throws Exception {
        getMorphia().map(ContainsFinalField.class);
        final Key<ContainsFinalField> savedKey = getDs().save(new ContainsFinalField("blah"));
        final ContainsFinalField loaded = getDs().get(ContainsFinalField.class, savedKey.getId());
        assertNotNull(loaded);
        assertNotNull(loaded.name);
        assertEquals("blah", loaded.name);
    }

    @Test
    public void testFinalFieldNotPersisted() throws Exception {
        ((DatastoreImpl) getDs()).getMapper().getOptions().setIgnoreFinals(true);
        getMorphia().map(ContainsFinalField.class);
        final Key<ContainsFinalField> savedKey = getDs().save(new ContainsFinalField("blah"));
        final ContainsFinalField loaded = getDs().get(ContainsFinalField.class, savedKey.getId());
        assertNotNull(loaded);
        assertNotNull(loaded.name);
        assertEquals("foo", loaded.name);
    }

    @Test
    public void testTimestampMapping() throws Exception {
        getMorphia().map(ContainsTimestamp.class);
        final ContainsTimestamp cts = new ContainsTimestamp();
        final Key<ContainsTimestamp> savedKey = getDs().save(cts);
        final ContainsTimestamp loaded = getDs().get(ContainsTimestamp.class, savedKey.getId());
        assertNotNull(loaded.ts);
        assertEquals(loaded.ts.getTime(), cts.ts.getTime());

    }

    @Test
    public void testCollectionMapping() throws Exception {
        getMorphia().map(ContainsCollection.class);
        final Key<ContainsCollection> savedKey = getDs().save(new ContainsCollection());
        final ContainsCollection loaded = getDs().get(ContainsCollection.class, savedKey.getId());
        assertEquals(loaded.coll, (new ContainsCollection()).coll);
        assertNotNull(loaded.id);
    }

    @Test
    public void testByteArrayMapping() throws Exception {
        getMorphia().map(ContainsByteArray.class);
        final Key<ContainsByteArray> savedKey = getDs().save(new ContainsByteArray());
        final ContainsByteArray loaded = getDs().get(ContainsByteArray.class, savedKey.getId());
        assertEquals(new String((new ContainsByteArray()).bytes), new String(loaded.bytes));
        assertNotNull(loaded.id);
    }

    @Test
    public void testBaseEntityValidity() throws Exception {
        getMorphia().map(UsesBaseEntity.class);
    }

    @Test
    public void testSerializedMapping() throws Exception {
        getMorphia().map(ContainsSerializedData.class);
        final Key<ContainsSerializedData> savedKey = getDs().save(new ContainsSerializedData());
        final ContainsSerializedData loaded = getDs().get(ContainsSerializedData.class, savedKey.getId());
        assertNotNull(loaded.data);
        assertEquals(loaded.data.someString, (new ContainsSerializedData()).data.someString);
        assertNotNull(loaded.id);
    }

    @SuppressWarnings("deprecation")
    @Test
    public void testLongArrayMapping() throws Exception {
        getMorphia().map(ContainsLongAndStringArray.class);
        getDs().save(new ContainsLongAndStringArray());
        ContainsLongAndStringArray loaded = getDs().<ContainsLongAndStringArray>find(ContainsLongAndStringArray.class).get();
        assertEquals(loaded.longs, (new ContainsLongAndStringArray()).longs);
        assertEquals(loaded.strings, (new ContainsLongAndStringArray()).strings);

        final ContainsLongAndStringArray array = new ContainsLongAndStringArray();
        array.strings = new String[]{"a", "B", "c"};
        array.longs = new Long[]{4L, 5L, 4L};
        final Key<ContainsLongAndStringArray> k1 = getDs().save(array);
        loaded = getDs().getByKey(ContainsLongAndStringArray.class, k1);
        assertEquals(loaded.longs, array.longs);
        assertEquals(loaded.strings, array.strings);

        assertNotNull(loaded.id);
    }

    @Test
    public void testDbRefMapping() throws Exception {
        getMorphia().map(ContainsRef.class).map(Rectangle.class);
        final DBCollection stuff = getDb().getCollection("stuff");
        final DBCollection rectangles = getDb().getCollection("rectangles");

        assertTrue("'ne' field should not be persisted!", !getMorphia().getMapper().getMCMap().get(ContainsRef.class.getName())
                                                               .containsJavaFieldName("ne"));

        final Rectangle r = new Rectangle(1, 1);
        final DBObject rDbObject = getMorphia().toDBObject(r);
        rDbObject.put("_ns", rectangles.getName());
        rectangles.save(rDbObject);

        final ContainsRef cRef = new ContainsRef();
        cRef.rect = new DBRef((String) rDbObject.get("_ns"), rDbObject.get("_id"));
        final DBObject cRefDbObject = getMorphia().toDBObject(cRef);
        stuff.save(cRefDbObject);
        final BasicDBObject cRefDbObjectLoaded = (BasicDBObject) stuff.findOne(BasicDBObjectBuilder.start("_id", cRefDbObject.get("_id"))
                                                                                                   .get());
        final ContainsRef cRefLoaded = getMorphia().fromDBObject(ContainsRef.class, cRefDbObjectLoaded, new DefaultEntityCache());
        assertNotNull(cRefLoaded);
        assertNotNull(cRefLoaded.rect);
        assertNotNull(cRefLoaded.rect.getId());
        assertNotNull(cRefLoaded.rect.getCollectionName());
        assertEquals(cRefLoaded.rect.getId(), cRef.rect.getId());
        assertEquals(cRefLoaded.rect.getCollectionName(), cRef.rect.getCollectionName());
    }

    @Test
    public void testBadMappings() throws Exception {
        try {
            getMorphia().map(MissingId.class);
            fail("Validation: Missing @Id field not caught");
        } catch (MappingException e) {

        }

        try {
            getMorphia().map(IdOnEmbedded.class);
            fail("Validation: @Id field on @Embedded not caught");
        } catch (MappingException e) {

        }

        try {
            getMorphia().map(RenamedEmbedded.class);
            fail("Validation: @Embedded(\"name\") not caught on Class");
        } catch (MappingException e) {

        }

        try {
            getMorphia().map(MissingIdStill.class);
            fail("Validation: Missing @Id field not not caught");
        } catch (MappingException e) {

        }

        try {
            getMorphia().map(MissingIdRenamed.class);
            fail("Validation: Missing @Id field not not caught");
        } catch (MappingException e) {

        }

        try {
            getMorphia().map(NonStaticInnerClass.class);
            fail("Validation: Non-static inner class allowed");
        } catch (MappingException e) {

        }
    }


    @Test
    public void testBasicMapping() throws Exception {
        performBasicMappingTest();
        assertTrue(((DefaultCreator)getMorphia().getMapper().getOptions().getObjectFactory()).getClassNameCache().isEmpty());
    }

    @Test
    public void testBasicMappingWithCachedClasses() throws Exception {
        getMorphia().getMapper().getOptions().setCacheClassLookups(true);
        try {
            performBasicMappingTest();
            assertTrue(((DefaultCreator)getMorphia().getMapper().getOptions().getObjectFactory()).getClassNameCache().containsKey(Hotel.class.getName()));
            assertTrue(((DefaultCreator)getMorphia().getMapper().getOptions().getObjectFactory()).getClassNameCache().containsKey(TravelAgency.class.getName()));
        } finally {
            getMorphia().getMapper().getOptions().setCacheClassLookups(false);
        }
    }

    private void performBasicMappingTest() {
        final DBCollection hotels = getDb().getCollection("hotels");
        final DBCollection agencies = getDb().getCollection("agencies");

        getMorphia().map(Hotel.class);
        getMorphia().map(TravelAgency.class);

        final Hotel borg = new Hotel();
        borg.setName("Hotel Borg");
        borg.setStars(4);
        borg.setTakesCreditCards(true);
        borg.setStartDate(new Date());
        borg.setType(Hotel.Type.LEISURE);
        borg.getTags().add("Swimming pool");
        borg.getTags().add("Room service");
        borg.setTemp("A temporary transient value");
        borg.getPhoneNumbers().add(new PhoneNumber(354, 5152233, PhoneNumber.Type.PHONE));
        borg.getPhoneNumbers().add(new PhoneNumber(354, 5152244, PhoneNumber.Type.FAX));

        final Address address = new Address();
        address.setStreet("Posthusstraeti 11");
        address.setPostCode("101");
        borg.setAddress(address);

        BasicDBObject hotelDbObj = (BasicDBObject) getMorphia().toDBObject(borg);
        assertTrue(!(((DBObject) ((List) hotelDbObj.get("phoneNumbers")).get(0)).containsField(Mapper.CLASS_NAME_FIELDNAME)));


        hotels.save(hotelDbObj);

        Hotel borgLoaded = getMorphia().fromDBObject(Hotel.class, hotelDbObj, new DefaultEntityCache());

        assertEquals(borg.getName(), borgLoaded.getName());
        assertEquals(borg.getStars(), borgLoaded.getStars());
        assertEquals(borg.getStartDate(), borgLoaded.getStartDate());
        assertEquals(borg.getType(), borgLoaded.getType());
        assertEquals(borg.getAddress().getStreet(), borgLoaded.getAddress().getStreet());
        assertEquals(borg.getTags().size(), borgLoaded.getTags().size());
        assertEquals(borg.getTags(), borgLoaded.getTags());
        assertEquals(borg.getPhoneNumbers().size(), borgLoaded.getPhoneNumbers().size());
        assertEquals(borg.getPhoneNumbers().get(1), borgLoaded.getPhoneNumbers().get(1));
        assertNull(borgLoaded.getTemp());
        assertTrue(borgLoaded.getPhoneNumbers() instanceof Vector);
        assertNotNull(borgLoaded.getId());

        final TravelAgency agency = new TravelAgency();
        agency.setName("Lastminute.com");
        agency.getHotels().add(borgLoaded);

        final BasicDBObject agencyDbObj = (BasicDBObject) getMorphia().toDBObject(agency);
        agencies.save(agencyDbObj);

        final TravelAgency agencyLoaded = getMorphia().fromDBObject(TravelAgency.class,
                                                                    agencies.findOne(new BasicDBObject(Mapper.ID_KEY,
                                                                                                       agencyDbObj.get(Mapper.ID_KEY))),
                                                                    new DefaultEntityCache());

        assertEquals(agency.getName(), agencyLoaded.getName());
        assertEquals(1, agency.getHotels().size());
        assertEquals(agency.getHotels().get(0).getName(), borg.getName());


        borgLoaded.setAddress(null);
        borgLoaded.getPhoneNumbers().clear();
        borgLoaded.setName(null);

        hotelDbObj = (BasicDBObject) getMorphia().toDBObject(borgLoaded);
        hotels.save(hotelDbObj);

        hotelDbObj = (BasicDBObject) hotels.findOne(new BasicDBObject(Mapper.ID_KEY, hotelDbObj.get(Mapper.ID_KEY)));

        borgLoaded = getMorphia().fromDBObject(Hotel.class, hotelDbObj, new DefaultEntityCache());
        assertNull(borgLoaded.getAddress());
        assertEquals(0, borgLoaded.getPhoneNumbers().size());
        assertNull(borgLoaded.getName());
    }

    @Test
    public void testMaps() throws Exception {
        final DBCollection articles = getDb().getCollection("articles");
        getMorphia().map(Article.class).map(Translation.class).map(Circle.class);

        final Article related = new Article();
        final BasicDBObject relatedDbObj = (BasicDBObject) getMorphia().toDBObject(related);
        articles.save(relatedDbObj);

        final Article relatedLoaded = getMorphia().fromDBObject(Article.class,
                                                                articles.findOne(new BasicDBObject(Mapper.ID_KEY,
                                                                                                   relatedDbObj.get(Mapper.ID_KEY))),
                                                                new DefaultEntityCache());

        final Article article = new Article();
        article.setTranslation("en", new Translation("Hello World", "Just a test"));
        article.setTranslation("is", new Translation("HallÃ³ heimur", "Bara aÃ° prÃ³fa"));

        article.setAttribute("myDate", new Date());
        article.setAttribute("myString", "Test");
        article.setAttribute("myInt", 123);

        article.putRelated("test", relatedLoaded);

        final BasicDBObject articleDbObj = (BasicDBObject) getMorphia().toDBObject(article);
        articles.save(articleDbObj);

        final Article articleLoaded = getMorphia().fromDBObject(Article.class,
                                                                articles.findOne(
                                                                                    new BasicDBObject(Mapper.ID_KEY,
                                                                                                      articleDbObj.get(Mapper.ID_KEY))),
                                                                new DefaultEntityCache());

        assertEquals(article.getTranslations().size(), articleLoaded.getTranslations().size());
        assertEquals(article.getTranslation("en").getTitle(), articleLoaded.getTranslation("en").getTitle());
        assertEquals(article.getTranslation("is").getBody(), articleLoaded.getTranslation("is").getBody());
        assertEquals(article.getAttributes().size(), articleLoaded.getAttributes().size());
        assertEquals(article.getAttribute("myDate"), articleLoaded.getAttribute("myDate"));
        assertEquals(article.getAttribute("myString"), articleLoaded.getAttribute("myString"));
        assertEquals(article.getAttribute("myInt"), articleLoaded.getAttribute("myInt"));
        assertEquals(article.getRelated().size(), articleLoaded.getRelated().size());
        assertEquals(article.getRelated("test").getId(), articleLoaded.getRelated("test").getId());
    }


    @Test(expected = MappingException.class)
    public void testReferenceWithoutIdValue() throws Exception {
        final RecursiveParent parent = new RecursiveParent();
        final RecursiveChild child = new RecursiveChild();
        child.setId(null);
        parent.setChild(child);
        getDs().save(parent);

    }

    @Test
    public void testRecursiveReference() throws Exception {
        final DBCollection stuff = getDb().getCollection("stuff");

        getMorphia().map(RecursiveParent.class).map(RecursiveChild.class);

        final RecursiveParent parent = new RecursiveParent();
        final DBObject parentDbObj = getMorphia().toDBObject(parent);
        stuff.save(parentDbObj);

        final RecursiveChild child = new RecursiveChild();
        final DBObject childDbObj = getMorphia().toDBObject(child);
        stuff.save(childDbObj);

        final RecursiveParent parentLoaded = getMorphia().fromDBObject(RecursiveParent.class,
                                                                       stuff.findOne(new BasicDBObject(Mapper.ID_KEY,
                                                                                                       parentDbObj.get(Mapper.ID_KEY))),
                                                                       new DefaultEntityCache());
        final RecursiveChild childLoaded = getMorphia().fromDBObject(RecursiveChild.class,
                                                                     stuff.findOne(new BasicDBObject(Mapper.ID_KEY,
                                                                                                     childDbObj.get(Mapper.ID_KEY))),
                                                                     new DefaultEntityCache());

        parentLoaded.setChild(childLoaded);
        childLoaded.setParent(parentLoaded);

        stuff.save(getMorphia().toDBObject(parentLoaded));
        stuff.save(getMorphia().toDBObject(childLoaded));

        final RecursiveParent finalParentLoaded = getMorphia().fromDBObject(RecursiveParent.class,
                                                                            stuff.findOne(new BasicDBObject(Mapper.ID_KEY,
                                                                                                            parentDbObj.get(Mapper
                                                                                                                                .ID_KEY))),
                                                                            new DefaultEntityCache());
        final RecursiveChild finalChildLoaded = getMorphia().fromDBObject(RecursiveChild.class,
                                                                          stuff.findOne(new BasicDBObject(Mapper.ID_KEY,
                                                                                                          childDbObj.get(Mapper.ID_KEY))),
                                                                          new DefaultEntityCache());

        assertNotNull(finalParentLoaded.getChild());
        assertNotNull(finalChildLoaded.getParent());
    }
}
