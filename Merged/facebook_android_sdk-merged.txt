

package com.facebook;

final class FacebookSdkVersion {
    public static final String BUILD = "4.4.0";
}

<code block>


package com.facebook;

import android.content.Context;
import android.graphics.Bitmap;
import android.location.Location;
import android.net.Uri;
import android.os.*;
import android.text.TextUtils;
import android.util.Log;
import android.util.Pair;

import com.facebook.internal.*;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.*;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLEncoder;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.zip.GZIPOutputStream;


public class GraphRequest {
    
    public static final int MAXIMUM_BATCH_SIZE = 50;

    public static final String TAG = GraphRequest.class.getSimpleName();

    private static final String VIDEOS_SUFFIX = "/videos";
    private static final String ME = "me";
    private static final String MY_FRIENDS = "me/friends";
    private static final String MY_PHOTOS = "me/photos";
    private static final String SEARCH = "search";
    private static final String USER_AGENT_BASE = "FBAndroidSDK";
    private static final String USER_AGENT_HEADER = "User-Agent";
    private static final String CONTENT_TYPE_HEADER = "Content-Type";
    private static final String ACCEPT_LANGUAGE_HEADER = "Accept-Language";
    private static final String CONTENT_ENCODING_HEADER = "Content-Encoding";

    
    private static final String FORMAT_PARAM = "format";
    private static final String FORMAT_JSON = "json";
    private static final String SDK_PARAM = "sdk";
    private static final String SDK_ANDROID = "android";
    private static final String ACCESS_TOKEN_PARAM = "access_token";
    private static final String BATCH_ENTRY_NAME_PARAM = "name";
    private static final String BATCH_ENTRY_OMIT_RESPONSE_ON_SUCCESS_PARAM =
            "omit_response_on_success";
    private static final String BATCH_ENTRY_DEPENDS_ON_PARAM = "depends_on";
    private static final String BATCH_APP_ID_PARAM = "batch_app_id";
    private static final String BATCH_RELATIVE_URL_PARAM = "relative_url";
    private static final String BATCH_BODY_PARAM = "body";
    private static final String BATCH_METHOD_PARAM = "method";
    private static final String BATCH_PARAM = "batch";
    private static final String ATTACHMENT_FILENAME_PREFIX = "file";
    private static final String ATTACHED_FILES_PARAM = "attached_files";
    private static final String ISO_8601_FORMAT_STRING = "yyyy-MM-dd'T'HH:mm:ssZ";
    private static final String DEBUG_PARAM = "debug";
    private static final String DEBUG_SEVERITY_INFO = "info";
    private static final String DEBUG_SEVERITY_WARNING = "warning";
    private static final String DEBUG_KEY = "__debug__";
    private static final String DEBUG_MESSAGES_KEY = "messages";
    private static final String DEBUG_MESSAGE_KEY = "message";
    private static final String DEBUG_MESSAGE_TYPE_KEY = "type";
    private static final String DEBUG_MESSAGE_LINK_KEY = "link";
    private static final String PICTURE_PARAM = "picture";
    private static final String CAPTION_PARAM = "caption";

    private static final String MIME_BOUNDARY = "3i2ndDfv2rTHiSisAbouNdArYfORhtTPEefj3q2f";

    private static String defaultBatchApplicationId;

    
    private static Pattern versionPattern = Pattern.compile("^/?v\\d+\\.\\d+/(.*)");

    private AccessToken accessToken;
    private HttpMethod httpMethod;
    private String graphPath;
    private JSONObject graphObject;
    private String batchEntryName;
    private String batchEntryDependsOn;
    private boolean batchEntryOmitResultOnSuccess = true;
    private Bundle parameters;
    private Callback callback;
    private String overriddenURL;
    private Object tag;
    private String version;
    private boolean skipClientToken = false;

    
    public GraphRequest() {
        this(null, null, null, null, null);
    }

    
    public GraphRequest(AccessToken accessToken, String graphPath) {
        this(accessToken, graphPath, null, null, null);
    }

    
    public GraphRequest(
            AccessToken accessToken,
            String graphPath,
            Bundle parameters,
            HttpMethod httpMethod) {
        this(accessToken, graphPath, parameters, httpMethod, null);
    }

    
    public GraphRequest(
            AccessToken accessToken,
            String graphPath,
            Bundle parameters,
            HttpMethod httpMethod,
            Callback callback) {
        this(accessToken, graphPath, parameters, httpMethod, callback, null);
    }

    
    public GraphRequest(
            AccessToken accessToken,
            String graphPath,
            Bundle parameters,
            HttpMethod httpMethod,
            Callback callback,
            String version) {
        this.accessToken = accessToken;
        this.graphPath = graphPath;
        this.version = version;

        setCallback(callback);
        setHttpMethod(httpMethod);

        if (parameters != null) {
            this.parameters = new Bundle(parameters);
        } else {
            this.parameters = new Bundle();
        }

        if (this.version == null) {
            this.version = ServerProtocol.getAPIVersion();
        }
    }

    GraphRequest(AccessToken accessToken, URL overriddenURL) {
        this.accessToken = accessToken;
        this.overriddenURL = overriddenURL.toString();

        setHttpMethod(HttpMethod.GET);

        this.parameters = new Bundle();
    }

    
    public static GraphRequest newDeleteObjectRequest(
            AccessToken accessToken,
            String id,
            Callback callback) {
        return new GraphRequest(accessToken, id, null, HttpMethod.DELETE, callback);
    }

    
    public static GraphRequest newMeRequest(
            AccessToken accessToken,
            final GraphJSONObjectCallback callback) {
        Callback wrapper = new Callback() {
            @Override
            public void onCompleted(GraphResponse response) {
                if (callback != null) {
                    callback.onCompleted(response.getJSONObject(), response);
                }
            }
        };
        return new GraphRequest(accessToken, ME, null, null, wrapper);
    }

    
    public static GraphRequest newPostRequest(
            AccessToken accessToken,
            String graphPath,
            JSONObject graphObject,
            Callback callback) {
        GraphRequest request = new GraphRequest(
                accessToken,
                graphPath,
                null,
                HttpMethod.POST,
                callback);
        request.setGraphObject(graphObject);
        return request;
    }

    
    public static GraphRequest newMyFriendsRequest(
            AccessToken accessToken,
            final GraphJSONArrayCallback callback) {
        Callback wrapper = new Callback() {
            @Override
            public void onCompleted(GraphResponse response) {
                if (callback != null) {
                    JSONObject result = response.getJSONObject();
                    JSONArray data = result != null ? result.optJSONArray("data") : null;
                    callback.onCompleted(data, response);
                }
            }
        };
        return new GraphRequest(accessToken, MY_FRIENDS, null, null, wrapper);
    }

    
    public static GraphRequest newGraphPathRequest(
            AccessToken accessToken,
            String graphPath,
            Callback callback) {
        return new GraphRequest(accessToken, graphPath, null, null, callback);
    }

    
    public static GraphRequest newPlacesSearchRequest(
            AccessToken accessToken,
            Location location,
            int radiusInMeters,
            int resultsLimit,
            String searchText,
            final GraphJSONArrayCallback callback) {
        if (location == null && Utility.isNullOrEmpty(searchText)) {
            throw new FacebookException("Either location or searchText must be specified.");
        }

        Bundle parameters = new Bundle(5);
        parameters.putString("type", "place");
        parameters.putInt("limit", resultsLimit);
        if (location != null) {
            parameters.putString("center",
                    String.format(
                            Locale.US,
                            "%f,%f",
                            location.getLatitude(),
                            location.getLongitude()));
            parameters.putInt("distance", radiusInMeters);
        }
        if (!Utility.isNullOrEmpty(searchText)) {
            parameters.putString("q", searchText);
        }

        Callback wrapper = new Callback() {
            @Override
            public void onCompleted(GraphResponse response) {
                if (callback != null) {
                    JSONObject result = response.getJSONObject();
                    JSONArray data = result != null ? result.optJSONArray("data") : null;
                    callback.onCompleted(data, response);
                }
            }
        };

        return new GraphRequest(accessToken, SEARCH, parameters, HttpMethod.GET, wrapper);
    }


    
    public static GraphRequest newUploadPhotoRequest(
            AccessToken accessToken,
            String graphPath,
            Bitmap image,
            String caption,
            Bundle params,
            Callback callback) {
        graphPath = getDefaultPhotoPathIfNull(graphPath);
        Bundle parameters = new Bundle();
        if (params != null) {
            parameters.putAll(params);
        }
        parameters.putParcelable(PICTURE_PARAM, image);
        if (caption != null && !caption.isEmpty()) {
            parameters.putString(CAPTION_PARAM, caption);
        }

        return new GraphRequest(accessToken, graphPath, parameters, HttpMethod.POST, callback);
    }

    
    public static GraphRequest newUploadPhotoRequest(
            AccessToken accessToken,
            String graphPath,
            File file,
            String caption,
            Bundle params,
            Callback callback
    ) throws FileNotFoundException {
        graphPath = getDefaultPhotoPathIfNull(graphPath);
        ParcelFileDescriptor descriptor =
                ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
        Bundle parameters = new Bundle();
        if (params != null) {
            parameters.putAll(params);
        }
        parameters.putParcelable(PICTURE_PARAM, descriptor);
        if (caption != null && !caption.isEmpty()) {
            parameters.putString(CAPTION_PARAM, caption);
        }

        return new GraphRequest(accessToken, graphPath, parameters, HttpMethod.POST, callback);
    }

    
    public static GraphRequest newUploadPhotoRequest(
            AccessToken accessToken,
            String graphPath,
            Uri photoUri,
            String caption,
            Bundle params,
            Callback callback)
            throws FileNotFoundException {
        graphPath = getDefaultPhotoPathIfNull(graphPath);
        if (Utility.isFileUri(photoUri)) {
            return newUploadPhotoRequest(
                    accessToken,
                    graphPath,
                    new File(photoUri.getPath()),
                    caption,
                    params,
                    callback);
        } else if (!Utility.isContentUri(photoUri)) {
            throw new FacebookException("The photo Uri must be either a file:
        }

        Bundle parameters = new Bundle();
        if (params != null) {
            parameters.putAll(params);
        }
        parameters.putParcelable(PICTURE_PARAM, photoUri);

        return new GraphRequest(accessToken, graphPath, parameters, HttpMethod.POST, callback);
    }


    
    public static GraphRequest newCustomAudienceThirdPartyIdRequest(AccessToken accessToken,
                                                                    Context context,
                                                                    String applicationId,
                                                                    Callback callback) {

        if (applicationId == null && accessToken != null) {
            applicationId = accessToken.getApplicationId();
        }

        if (applicationId == null) {
            applicationId = Utility.getMetadataApplicationId(context);
        }

        if (applicationId == null) {
            throw new FacebookException("Facebook App ID cannot be determined");
        }

        String endpoint = applicationId + "/custom_audience_third_party_id";
        AttributionIdentifiers attributionIdentifiers =
                AttributionIdentifiers.getAttributionIdentifiers(context);
        Bundle parameters = new Bundle();

        if (accessToken == null) {
            
            
            String udid = attributionIdentifiers.getAttributionId() != null
                    ? attributionIdentifiers.getAttributionId()
                    : attributionIdentifiers.getAndroidAdvertiserId();
            if (attributionIdentifiers.getAttributionId() != null) {
                parameters.putString("udid", udid);
            }
        }

        
        
        if (FacebookSdk.getLimitEventAndDataUsage(context)
                || attributionIdentifiers.isTrackingLimited()) {
            parameters.putString("limit_event_usage", "1");
        }

        return new GraphRequest(accessToken, endpoint, parameters, HttpMethod.GET, callback);
    }

    
    public static GraphRequest newCustomAudienceThirdPartyIdRequest(
            AccessToken accessToken,
            Context context,
            Callback callback) {
        return newCustomAudienceThirdPartyIdRequest(accessToken, context, null, callback);
    }

    
    public final JSONObject getGraphObject() {
        return this.graphObject;
    }

    
    public final void setGraphObject(JSONObject graphObject) {
        this.graphObject = graphObject;
    }

    
    public final String getGraphPath() {
        return this.graphPath;
    }

    
    public final void setGraphPath(String graphPath) {
        this.graphPath = graphPath;
    }

    
    public final HttpMethod getHttpMethod() {
        return this.httpMethod;
    }

    
    public final void setHttpMethod(HttpMethod httpMethod) {
        if (overriddenURL != null && httpMethod != HttpMethod.GET) {
            throw new FacebookException("Can't change HTTP method on request with overridden URL.");
        }
        this.httpMethod = (httpMethod != null) ? httpMethod : HttpMethod.GET;
    }

    
    public final String getVersion() {
        return this.version;
    }

    
    public final void setVersion(String version) {
        this.version = version;
    }

    
    public final void setSkipClientToken(boolean skipClientToken) {
        this.skipClientToken = skipClientToken;
    }

    
    public final Bundle getParameters() {
        return this.parameters;
    }

    
    public final void setParameters(Bundle parameters) {
        this.parameters = parameters;
    }

    
    public final AccessToken getAccessToken() {
        return this.accessToken;
    }

    
    public final void setAccessToken(AccessToken accessToken) {
        this.accessToken = accessToken;
    }

    
    public final String getBatchEntryName() {
        return this.batchEntryName;
    }

    
    public final void setBatchEntryName(String batchEntryName) {
        this.batchEntryName = batchEntryName;
    }

    
    public final String getBatchEntryDependsOn() {
        return this.batchEntryDependsOn;
    }

    
    public final void setBatchEntryDependsOn(String batchEntryDependsOn) {
        this.batchEntryDependsOn = batchEntryDependsOn;
    }


    
    public final boolean getBatchEntryOmitResultOnSuccess() {
        return this.batchEntryOmitResultOnSuccess;
    }

    
    public final void setBatchEntryOmitResultOnSuccess(boolean batchEntryOmitResultOnSuccess) {
        this.batchEntryOmitResultOnSuccess = batchEntryOmitResultOnSuccess;
    }

    
    public static final String getDefaultBatchApplicationId() {
        return GraphRequest.defaultBatchApplicationId;
    }

    
    public static final void setDefaultBatchApplicationId(String applicationId) {
        defaultBatchApplicationId = applicationId;
    }

    
    public final Callback getCallback() {
        return callback;
    }

    
    public final void setCallback(final Callback callback) {
        
        if (FacebookSdk.isLoggingBehaviorEnabled(LoggingBehavior.GRAPH_API_DEBUG_INFO)
                || FacebookSdk.isLoggingBehaviorEnabled(LoggingBehavior.GRAPH_API_DEBUG_WARNING)) {
            Callback wrapper = new Callback() {
                @Override
                public void onCompleted(GraphResponse response) {
                    JSONObject responseObject = response.getJSONObject();
                    JSONObject debug =
                            responseObject != null ? responseObject.optJSONObject(DEBUG_KEY) : null;
                    JSONArray debugMessages =
                            debug != null ? debug.optJSONArray(DEBUG_MESSAGES_KEY) : null;
                    if (debugMessages != null) {
                        for (int i = 0; i < debugMessages.length(); ++i) {
                            JSONObject debugMessageObject = debugMessages.optJSONObject(i);
                            String debugMessage = debugMessageObject != null
                                    ? debugMessageObject.optString(DEBUG_MESSAGE_KEY)
                                    : null;
                            String debugMessageType = debugMessageObject != null
                                    ? debugMessageObject.optString(DEBUG_MESSAGE_TYPE_KEY)
                                    : null;
                            String debugMessageLink = debugMessageObject != null
                                    ? debugMessageObject.optString(DEBUG_MESSAGE_LINK_KEY)
                                    : null;
                            if (debugMessage != null && debugMessageType != null) {
                                LoggingBehavior behavior = LoggingBehavior.GRAPH_API_DEBUG_INFO;
                                if (debugMessageType.equals("warning")) {
                                    behavior = LoggingBehavior.GRAPH_API_DEBUG_WARNING;
                                }
                                if (!Utility.isNullOrEmpty(debugMessageLink)) {
                                    debugMessage += " Link: " + debugMessageLink;
                                }
                                Logger.log(behavior, TAG, debugMessage);
                            }
                        }
                    }
                    if (callback != null) {
                        callback.onCompleted(response);
                    }
                }
            };
            this.callback = wrapper;
        } else {
            this.callback = callback;
        }

    }

    
    public final void setTag(Object tag) {
        this.tag = tag;
    }

    
    public final Object getTag() {
        return tag;
    }

    
    public final GraphResponse executeAndWait() {
        return GraphRequest.executeAndWait(this);
    }

    
    public final GraphRequestAsyncTask executeAsync() {
        return GraphRequest.executeBatchAsync(this);
    }

    
    public static HttpURLConnection toHttpConnection(GraphRequest... requests) {
        return toHttpConnection(Arrays.asList(requests));
    }

    
    public static HttpURLConnection toHttpConnection(Collection<GraphRequest> requests) {
        Validate.notEmptyAndContainsNoNulls(requests, "requests");

        return toHttpConnection(new GraphRequestBatch(requests));
    }

    
    public static HttpURLConnection toHttpConnection(GraphRequestBatch requests) {

        URL url;
        try {
            if (requests.size() == 1) {
                
                GraphRequest request = requests.get(0);
                
                
                url = new URL(request.getUrlForSingleRequest());
            } else {
                
                
                url = new URL(ServerProtocol.getGraphUrlBase());
            }
        } catch (MalformedURLException e) {
            throw new FacebookException("could not construct URL for request", e);
        }

        HttpURLConnection connection;
        try {
            connection = createConnection(url);

            serializeToUrlConnection(requests, connection);
        } catch (IOException e) {
            throw new FacebookException("could not construct request body", e);
        } catch (JSONException e) {
            throw new FacebookException("could not construct request body", e);
        }

        return connection;
    }

    
    public static GraphResponse executeAndWait(GraphRequest request) {
        List<GraphResponse> responses = executeBatchAndWait(request);

        if (responses == null || responses.size() != 1) {
            throw new FacebookException("invalid state: expected a single response");
        }

        return responses.get(0);
    }

    
    public static List<GraphResponse> executeBatchAndWait(GraphRequest... requests) {
        Validate.notNull(requests, "requests");

        return executeBatchAndWait(Arrays.asList(requests));
    }

    
    public static List<GraphResponse> executeBatchAndWait(Collection<GraphRequest> requests) {
        return executeBatchAndWait(new GraphRequestBatch(requests));
    }

    
    public static List<GraphResponse> executeBatchAndWait(GraphRequestBatch requests) {
        Validate.notEmptyAndContainsNoNulls(requests, "requests");

        HttpURLConnection connection = null;
        try {
            connection = toHttpConnection(requests);
        } catch (Exception ex) {
            List<GraphResponse> responses = GraphResponse.constructErrorResponses(
                    requests.getRequests(),
                    null,
                    new FacebookException(ex));
            runCallbacks(requests, responses);
            return responses;
        }

        List<GraphResponse> responses = executeConnectionAndWait(connection, requests);
        return responses;
    }

    
    public static GraphRequestAsyncTask executeBatchAsync(GraphRequest... requests) {
        Validate.notNull(requests, "requests");

        return executeBatchAsync(Arrays.asList(requests));
    }

    
    public static GraphRequestAsyncTask executeBatchAsync(Collection<GraphRequest> requests) {
        return executeBatchAsync(new GraphRequestBatch(requests));
    }

    
    public static GraphRequestAsyncTask executeBatchAsync(GraphRequestBatch requests) {
        Validate.notEmptyAndContainsNoNulls(requests, "requests");

        GraphRequestAsyncTask asyncTask = new GraphRequestAsyncTask(requests);
        asyncTask.executeOnSettingsExecutor();
        return asyncTask;
    }

    
    public static List<GraphResponse> executeConnectionAndWait(
            HttpURLConnection connection,
            Collection<GraphRequest> requests) {
        return executeConnectionAndWait(connection, new GraphRequestBatch(requests));
    }

    
    public static List<GraphResponse> executeConnectionAndWait(
            HttpURLConnection connection,
            GraphRequestBatch requests) {
        List<GraphResponse> responses = GraphResponse.fromHttpConnection(connection, requests);

        Utility.disconnectQuietly(connection);

        int numRequests = requests.size();
        if (numRequests != responses.size()) {
            throw new FacebookException(
                    String.format(Locale.US,
                            "Received %d responses while expecting %d",
                            responses.size(),
                            numRequests));
        }

        runCallbacks(requests, responses);

        
        AccessTokenManager.getInstance().extendAccessTokenIfNeeded();

        return responses;
    }

    
    public static GraphRequestAsyncTask executeConnectionAsync(
            HttpURLConnection connection,
            GraphRequestBatch requests) {
        return executeConnectionAsync(null, connection, requests);
    }

    
    public static GraphRequestAsyncTask executeConnectionAsync(
            Handler callbackHandler,
            HttpURLConnection connection,
            GraphRequestBatch requests) {
        Validate.notNull(connection, "connection");

        GraphRequestAsyncTask asyncTask = new GraphRequestAsyncTask(connection, requests);
        requests.setCallbackHandler(callbackHandler);
        asyncTask.executeOnSettingsExecutor();
        return asyncTask;
    }

    
    @Override
    public String toString() {
        return new StringBuilder()
                .append("{Request: ")
                .append(" accessToken: ")
                .append(accessToken == null ? "null" : accessToken)
                .append(", graphPath: ")
                .append(graphPath)
                .append(", graphObject: ")
                .append(graphObject)
                .append(", httpMethod: ")
                .append(httpMethod)
                .append(", parameters: ")
                .append(parameters)
                .append("}")
                .toString();
    }

    static void runCallbacks(final GraphRequestBatch requests, List<GraphResponse> responses) {
        int numRequests = requests.size();

        
        
        final ArrayList<Pair<Callback, GraphResponse>> callbacks = new ArrayList<Pair<Callback, GraphResponse>>();
        for (int i = 0; i < numRequests; ++i) {
            GraphRequest request = requests.get(i);
            if (request.callback != null) {
                callbacks.add(
                        new Pair<Callback, GraphResponse>(request.callback, responses.get(i)));
            }
        }

        if (callbacks.size() > 0) {
            Runnable runnable = new Runnable() {
                public void run() {
                    for (Pair<Callback, GraphResponse> pair : callbacks) {
                        pair.first.onCompleted(pair.second);
                    }

                    List<GraphRequestBatch.Callback> batchCallbacks = requests.getCallbacks();
                    for (GraphRequestBatch.Callback batchCallback : batchCallbacks) {
                        batchCallback.onBatchCompleted(requests);
                    }
                }
            };

            Handler callbackHandler = requests.getCallbackHandler();
            if (callbackHandler == null) {
                
                runnable.run();
            } else {
                
                callbackHandler.post(runnable);
            }
        }
    }

    private static String getDefaultPhotoPathIfNull(String graphPath) {
        return graphPath == null ? MY_PHOTOS : graphPath;
    }

    private static HttpURLConnection createConnection(URL url) throws IOException {
        HttpURLConnection connection;
        connection = (HttpURLConnection) url.openConnection();

        connection.setRequestProperty(USER_AGENT_HEADER, getUserAgent());
        connection.setRequestProperty(ACCEPT_LANGUAGE_HEADER, Locale.getDefault().toString());

        connection.setChunkedStreamingMode(0);
        return connection;
    }


    private void addCommonParameters() {
        if (this.accessToken != null) {
            if (!this.parameters.containsKey(ACCESS_TOKEN_PARAM)) {
                String token = accessToken.getToken();
                Logger.registerAccessToken(token);
                this.parameters.putString(ACCESS_TOKEN_PARAM, token);
            }
        } else if (!skipClientToken && !this.parameters.containsKey(ACCESS_TOKEN_PARAM)) {
            String appID = FacebookSdk.getApplicationId();
            String clientToken = FacebookSdk.getClientToken();
            if (!Utility.isNullOrEmpty(appID) && !Utility.isNullOrEmpty(clientToken)) {
                String accessToken = appID + "|" + clientToken;
                this.parameters.putString(ACCESS_TOKEN_PARAM, accessToken);
            } else {
                Log.d(TAG, "Warning: Request without access token missing application ID or" +
                        " client token.");
            }
        }
        this.parameters.putString(SDK_PARAM, SDK_ANDROID);
        this.parameters.putString(FORMAT_PARAM, FORMAT_JSON);

        if (FacebookSdk.isLoggingBehaviorEnabled(LoggingBehavior.GRAPH_API_DEBUG_INFO)) {
            this.parameters.putString(DEBUG_PARAM, DEBUG_SEVERITY_INFO);
        } else if (FacebookSdk.isLoggingBehaviorEnabled(LoggingBehavior.GRAPH_API_DEBUG_WARNING)) {
            this.parameters.putString(DEBUG_PARAM, DEBUG_SEVERITY_WARNING);
        }
    }

    private String appendParametersToBaseUrl(String baseUrl) {
        Uri.Builder uriBuilder = new Uri.Builder().encodedPath(baseUrl);

        Set<String> keys = this.parameters.keySet();
        for (String key : keys) {
            Object value = this.parameters.get(key);

            if (value == null) {
                value = "";
            }

            if (isSupportedParameterType(value)) {
                value = parameterToString(value);
            } else {
                if (httpMethod == HttpMethod.GET) {
                    throw new IllegalArgumentException(
                            String.format(
                                    Locale.US,
                                    "Unsupported parameter type for GET request: %s",
                                    value.getClass().getSimpleName()));
                }
                continue;
            }

            uriBuilder.appendQueryParameter(key, value.toString());
        }

        return uriBuilder.toString();
    }

    final String getUrlForBatchedRequest() {
        if (overriddenURL != null) {
            throw new FacebookException("Can't override URL for a batch request");
        }

        String baseUrl = getGraphPathWithVersion();
        addCommonParameters();
        return appendParametersToBaseUrl(baseUrl);
    }

    final String getUrlForSingleRequest() {
        if (overriddenURL != null) {
            return overriddenURL.toString();
        }

        String graphBaseUrlBase;
        if (this.getHttpMethod() == HttpMethod.POST
                && graphPath != null
                && graphPath.endsWith(VIDEOS_SUFFIX)) {
            graphBaseUrlBase = ServerProtocol.getGraphVideoUrlBase();
        } else {
            graphBaseUrlBase = ServerProtocol.getGraphUrlBase();
        }
        String baseUrl = String.format("%s/%s", graphBaseUrlBase, getGraphPathWithVersion());

        addCommonParameters();
        return appendParametersToBaseUrl(baseUrl);
    }

    private String getGraphPathWithVersion() {
        Matcher matcher = versionPattern.matcher(this.graphPath);
        if (matcher.matches()) {
            return this.graphPath;
        }
        return String.format("%s/%s", this.version, this.graphPath);
    }

    private static class Attachment {
        private final GraphRequest request;
        private final Object value;

        public Attachment(GraphRequest request, Object value) {
            this.request = request;
            this.value = value;
        }

        public GraphRequest getRequest() {
            return request;
        }

        public Object getValue() {
            return value;
        }
    }

    private void serializeToBatch(
            JSONArray batch,
            Map<String, Attachment> attachments
    ) throws JSONException, IOException {
        JSONObject batchEntry = new JSONObject();

        if (this.batchEntryName != null) {
            batchEntry.put(BATCH_ENTRY_NAME_PARAM, this.batchEntryName);
            batchEntry.put(
                    BATCH_ENTRY_OMIT_RESPONSE_ON_SUCCESS_PARAM,
                    this.batchEntryOmitResultOnSuccess);
        }
        if (this.batchEntryDependsOn != null) {
            batchEntry.put(BATCH_ENTRY_DEPENDS_ON_PARAM, this.batchEntryDependsOn);
        }

        String relativeURL = getUrlForBatchedRequest();
        batchEntry.put(BATCH_RELATIVE_URL_PARAM, relativeURL);
        batchEntry.put(BATCH_METHOD_PARAM, httpMethod);
        if (this.accessToken != null) {
            String token = this.accessToken.getToken();
            Logger.registerAccessToken(token);
        }

        
        ArrayList<String> attachmentNames = new ArrayList<String>();
        Set<String> keys = this.parameters.keySet();
        for (String key : keys) {
            Object value = this.parameters.get(key);
            if (isSupportedAttachmentType(value)) {
                
                String name = String.format(
                        Locale.ROOT,
                        "%s%d",
                        ATTACHMENT_FILENAME_PREFIX,
                        attachments.size());
                attachmentNames.add(name);
                attachments.put(name, new Attachment(this, value));
            }
        }

        if (!attachmentNames.isEmpty()) {
            String attachmentNamesString = TextUtils.join(",", attachmentNames);
            batchEntry.put(ATTACHED_FILES_PARAM, attachmentNamesString);
        }

        if (this.graphObject != null) {
            
            final ArrayList<String> keysAndValues = new ArrayList<String>();
            processGraphObject(this.graphObject, relativeURL, new KeyValueSerializer() {
                @Override
                public void writeString(String key, String value) throws IOException {
                    keysAndValues.add(String.format(
                            Locale.US,
                            "%s=%s",
                            key,
                            URLEncoder.encode(value, "UTF-8")));
                }
            });
            String bodyValue = TextUtils.join("&", keysAndValues);
            batchEntry.put(BATCH_BODY_PARAM, bodyValue);
        }

        batch.put(batchEntry);
    }

    private static boolean hasOnProgressCallbacks(GraphRequestBatch requests) {
        for (GraphRequestBatch.Callback callback : requests.getCallbacks()) {
            if (callback instanceof GraphRequestBatch.OnProgressCallback) {
                return true;
            }
        }

        for (GraphRequest request : requests) {
            if (request.getCallback() instanceof OnProgressCallback) {
                return true;
            }
        }

        return false;
    }

    private static void setConnectionContentType(
            HttpURLConnection connection,
            boolean shouldUseGzip) {
        if (shouldUseGzip) {
            connection.setRequestProperty(CONTENT_TYPE_HEADER, "application/x-www-form-urlencoded");
            connection.setRequestProperty(CONTENT_ENCODING_HEADER, "gzip");
        } else {
            connection.setRequestProperty(CONTENT_TYPE_HEADER, getMimeContentType());
        }
    }

    private static boolean isGzipCompressible(GraphRequestBatch requests) {
        for (GraphRequest request : requests) {
            for (String key : request.parameters.keySet()) {
                Object value = request.parameters.get(key);
                if (isSupportedAttachmentType(value)) {
                    return false;
                }
            }
        }
        return true;
    }

    final static void serializeToUrlConnection(
            GraphRequestBatch requests,
            HttpURLConnection connection
    ) throws IOException, JSONException {
        Logger logger = new Logger(LoggingBehavior.REQUESTS, "Request");

        int numRequests = requests.size();
        boolean shouldUseGzip = isGzipCompressible(requests);

        HttpMethod connectionHttpMethod =
                (numRequests == 1) ? requests.get(0).httpMethod : HttpMethod.POST;
        connection.setRequestMethod(connectionHttpMethod.name());
        setConnectionContentType(connection, shouldUseGzip);

        URL url = connection.getURL();
        logger.append("Request:\n");
        logger.appendKeyValue("Id", requests.getId());
        logger.appendKeyValue("URL", url);
        logger.appendKeyValue("Method", connection.getRequestMethod());
        logger.appendKeyValue("User-Agent", connection.getRequestProperty("User-Agent"));
        logger.appendKeyValue("Content-Type", connection.getRequestProperty("Content-Type"));

        connection.setConnectTimeout(requests.getTimeout());
        connection.setReadTimeout(requests.getTimeout());

        
        
        boolean isPost = (connectionHttpMethod == HttpMethod.POST);
        if (!isPost) {
            logger.log();
            return;
        }

        connection.setDoOutput(true);

        OutputStream outputStream = null;
        try {
            outputStream = new BufferedOutputStream(connection.getOutputStream());
            if (shouldUseGzip) {
                outputStream = new GZIPOutputStream(outputStream);
            }

            if (hasOnProgressCallbacks(requests)) {
                ProgressNoopOutputStream countingStream = null;
                countingStream = new ProgressNoopOutputStream(requests.getCallbackHandler());
                processRequest(requests, null, numRequests, url, countingStream, shouldUseGzip);

                int max = countingStream.getMaxProgress();
                Map<GraphRequest, RequestProgress> progressMap = countingStream.getProgressMap();

                outputStream = new ProgressOutputStream(outputStream, requests, progressMap, max);
            }

            processRequest(requests, logger, numRequests, url, outputStream, shouldUseGzip);
        } finally {
            if (outputStream != null) {
                outputStream.close();
            }
        }

        logger.log();
    }

    private static void processRequest(GraphRequestBatch requests, Logger logger, int numRequests,
                                       URL url, OutputStream outputStream, boolean shouldUseGzip)
            throws IOException, JSONException {
        Serializer serializer = new Serializer(outputStream, logger, shouldUseGzip);

        if (numRequests == 1) {
            GraphRequest request = requests.get(0);

            Map<String, Attachment> attachments = new HashMap<String, Attachment>();
            for (String key : request.parameters.keySet()) {
                Object value = request.parameters.get(key);
                if (isSupportedAttachmentType(value)) {
                    attachments.put(key, new Attachment(request, value));
                }
            }

            if (logger != null) {
                logger.append("  Parameters:\n");
            }
            serializeParameters(request.parameters, serializer, request);

            if (logger != null) {
                logger.append("  Attachments:\n");
            }
            serializeAttachments(attachments, serializer);

            if (request.graphObject != null) {
                processGraphObject(request.graphObject, url.getPath(), serializer);
            }
        } else {
            String batchAppID = getBatchAppId(requests);
            if (Utility.isNullOrEmpty(batchAppID)) {
                throw new FacebookException(
                        "App ID was not specified at the request or Settings.");
            }

            serializer.writeString(BATCH_APP_ID_PARAM, batchAppID);

            
            
            Map<String, Attachment> attachments = new HashMap<String, Attachment>();
            serializeRequestsAsJSON(serializer, requests, attachments);

            if (logger != null) {
                logger.append("  Attachments:\n");
            }
            serializeAttachments(attachments, serializer);
        }
    }

    private static boolean isMeRequest(String path) {
        Matcher matcher = versionPattern.matcher(path);
        if (matcher.matches()) {
            
            path = matcher.group(1);
        }
        if (path.startsWith("me/") || path.startsWith("/me/")) {
            return true;
        }
        return false;
    }

    private static void processGraphObject(
            JSONObject graphObject,
            String path,
            KeyValueSerializer serializer
    ) throws IOException {
        
        
        
        
        
        
        boolean isOGAction = false;
        if (isMeRequest(path)) {
            int colonLocation = path.indexOf(":");
            int questionMarkLocation = path.indexOf("?");
            isOGAction = colonLocation > 3
                    && (questionMarkLocation == -1 || colonLocation < questionMarkLocation);
        }

        Iterator<String> keyIterator = graphObject.keys();
        while (keyIterator.hasNext()) {
            String key = keyIterator.next();
            Object value = graphObject.opt(key);
            boolean passByValue = isOGAction && key.equalsIgnoreCase("image");
            processGraphObjectProperty(key, value, serializer, passByValue);
        }
    }

    private static void processGraphObjectProperty(
            String key,
            Object value,
            KeyValueSerializer serializer,
            boolean passByValue
    ) throws IOException {
        Class<?> valueClass = value.getClass();

        if (JSONObject.class.isAssignableFrom(valueClass)) {
            JSONObject jsonObject = (JSONObject) value;
            if (passByValue) {
                
                @SuppressWarnings("unchecked")
                Iterator<String> keys = jsonObject.keys();
                while (keys.hasNext()) {
                    String propertyName = keys.next();
                    String subKey = String.format("%s[%s]", key, propertyName);
                    processGraphObjectProperty(
                            subKey,
                            jsonObject.opt(propertyName),
                            serializer,
                            passByValue);
                }
            } else {
                
                
                if (jsonObject.has("id")) {
                    processGraphObjectProperty(
                            key,
                            jsonObject.optString("id"),
                            serializer,
                            passByValue);
                } else if (jsonObject.has("url")) {
                    processGraphObjectProperty(
                            key,
                            jsonObject.optString("url"),
                            serializer,
                            passByValue);
                } else if (jsonObject.has(NativeProtocol.OPEN_GRAPH_CREATE_OBJECT_KEY)) {
                    processGraphObjectProperty(key, jsonObject.toString(), serializer, passByValue);
                }
            }
        } else if (JSONArray.class.isAssignableFrom(valueClass)) {
            JSONArray jsonArray = (JSONArray) value;
            int length = jsonArray.length();
            for (int i = 0; i < length; ++i) {
                String subKey = String.format(Locale.ROOT, "%s[%d]", key, i);
                processGraphObjectProperty(subKey, jsonArray.opt(i), serializer, passByValue);
            }
        } else if (String.class.isAssignableFrom(valueClass) ||
                Number.class.isAssignableFrom(valueClass) ||
                Boolean.class.isAssignableFrom(valueClass)) {
            serializer.writeString(key, value.toString());
        } else if (Date.class.isAssignableFrom(valueClass)) {
            Date date = (Date) value;
            
            
            
            
            
            
            final SimpleDateFormat iso8601DateFormat = new SimpleDateFormat(
                    ISO_8601_FORMAT_STRING,
                    Locale.US);
            serializer.writeString(key, iso8601DateFormat.format(date));
        }
    }

    private static void serializeParameters(
            Bundle bundle,
            Serializer serializer,
            GraphRequest request
    ) throws IOException {
        Set<String> keys = bundle.keySet();

        for (String key : keys) {
            Object value = bundle.get(key);
            if (isSupportedParameterType(value)) {
                serializer.writeObject(key, value, request);
            }
        }
    }

    private static void serializeAttachments(
            Map<String, Attachment> attachments,
            Serializer serializer
    ) throws IOException {
        Set<String> keys = attachments.keySet();

        for (String key : keys) {
            Attachment attachment = attachments.get(key);
            if (isSupportedAttachmentType(attachment.getValue())) {
                serializer.writeObject(key, attachment.getValue(), attachment.getRequest());
            }
        }
    }

    private static void serializeRequestsAsJSON(
            Serializer serializer,
            Collection<GraphRequest> requests,
            Map<String, Attachment> attachments
    ) throws JSONException, IOException {
        JSONArray batch = new JSONArray();
        for (GraphRequest request : requests) {
            request.serializeToBatch(batch, attachments);
        }

        serializer.writeRequestsAsJson(BATCH_PARAM, batch, requests);
    }

    private static String getMimeContentType() {
        return String.format("multipart/form-data; boundary=%s", MIME_BOUNDARY);
    }

    private static volatile String userAgent;

    private static String getUserAgent() {
        if (userAgent == null) {
            userAgent = String.format("%s.%s", USER_AGENT_BASE, FacebookSdkVersion.BUILD);

            
            String customUserAgent = InternalSettings.getCustomUserAgent();
            if (!Utility.isNullOrEmpty(customUserAgent)) {
                userAgent = String.format(
                        Locale.ROOT,
                        "%s/%s",
                        userAgent,
                        customUserAgent);
            }
        }

        return userAgent;
    }

    private static String getBatchAppId(GraphRequestBatch batch) {
        if (!Utility.isNullOrEmpty(batch.getBatchApplicationId())) {
            return batch.getBatchApplicationId();
        }

        for (GraphRequest request : batch) {
            AccessToken accessToken = request.accessToken;
            if (accessToken != null) {
                String applicationId = accessToken.getApplicationId();
                if (applicationId != null) {
                    return applicationId;
                }
            }
        }
        if (!Utility.isNullOrEmpty(GraphRequest.defaultBatchApplicationId)) {
            return GraphRequest.defaultBatchApplicationId;
        }
        return FacebookSdk.getApplicationId();
    }

    private static boolean isSupportedAttachmentType(Object value) {
        return value instanceof Bitmap ||
                value instanceof byte[] ||
                value instanceof Uri ||
                value instanceof ParcelFileDescriptor ||
                value instanceof ParcelableResourceWithMimeType;
    }

    private static boolean isSupportedParameterType(Object value) {
        return value instanceof String || value instanceof Boolean || value instanceof Number ||
                value instanceof Date;
    }

    private static String parameterToString(Object value) {
        if (value instanceof String) {
            return (String) value;
        } else if (value instanceof Boolean || value instanceof Number) {
            return value.toString();
        } else if (value instanceof Date) {
            final SimpleDateFormat iso8601DateFormat = new SimpleDateFormat(
                    ISO_8601_FORMAT_STRING, Locale.US);
            return iso8601DateFormat.format(value);
        }
        throw new IllegalArgumentException("Unsupported parameter type.");
    }

    private interface KeyValueSerializer {
        void writeString(String key, String value) throws IOException;
    }

    private static class Serializer implements KeyValueSerializer {
        private final OutputStream outputStream;
        private final Logger logger;
        private boolean firstWrite = true;
        private boolean useUrlEncode = false;

        public Serializer(OutputStream outputStream, Logger logger, boolean useUrlEncode) {
            this.outputStream = outputStream;
            this.logger = logger;
            this.useUrlEncode = useUrlEncode;
        }

        public void writeObject(String key, Object value, GraphRequest request) throws IOException {
            if (outputStream instanceof RequestOutputStream) {
                ((RequestOutputStream) outputStream).setCurrentRequest(request);
            }

            if (isSupportedParameterType(value)) {
                writeString(key, parameterToString(value));
            } else if (value instanceof Bitmap) {
                writeBitmap(key, (Bitmap) value);
            } else if (value instanceof byte[]) {
                writeBytes(key, (byte[]) value);
            } else if (value instanceof Uri) {
                writeContentUri(key, (Uri) value, null);
            } else if (value instanceof ParcelFileDescriptor) {
                writeFile(key, (ParcelFileDescriptor) value, null);
            } else if (value instanceof ParcelableResourceWithMimeType) {
                ParcelableResourceWithMimeType resourceWithMimeType =
                        (ParcelableResourceWithMimeType) value;
                Parcelable resource = resourceWithMimeType.getResource();
                String mimeType = resourceWithMimeType.getMimeType();
                if (resource instanceof ParcelFileDescriptor) {
                    writeFile(key, (ParcelFileDescriptor) resource, mimeType);
                } else if (resource instanceof Uri) {
                    writeContentUri(key, (Uri) resource, mimeType);
                } else {
                    throw getInvalidTypeError();
                }
            } else {
                throw getInvalidTypeError();
            }
        }

        private RuntimeException getInvalidTypeError() {
            return new IllegalArgumentException("value is not a supported type.");
        }

        public void writeRequestsAsJson(
                String key,
                JSONArray requestJsonArray,
                Collection<GraphRequest> requests
        ) throws IOException, JSONException {
            if (!(outputStream instanceof RequestOutputStream)) {
                writeString(key, requestJsonArray.toString());
                return;
            }

            RequestOutputStream requestOutputStream = (RequestOutputStream) outputStream;
            writeContentDisposition(key, null, null);
            write("[");
            int i = 0;
            for (GraphRequest request : requests) {
                JSONObject requestJson = requestJsonArray.getJSONObject(i);
                requestOutputStream.setCurrentRequest(request);
                if (i > 0) {
                    write(",%s", requestJson.toString());
                } else {
                    write("%s", requestJson.toString());
                }
                i++;
            }
            write("]");
            if (logger != null) {
                logger.appendKeyValue("    " + key, requestJsonArray.toString());
            }
        }

        public void writeString(String key, String value) throws IOException {
            writeContentDisposition(key, null, null);
            writeLine("%s", value);
            writeRecordBoundary();
            if (logger != null) {
                logger.appendKeyValue("    " + key, value);
            }
        }

        public void writeBitmap(String key, Bitmap bitmap) throws IOException {
            writeContentDisposition(key, key, "image/png");
            
            bitmap.compress(Bitmap.CompressFormat.PNG, 100, outputStream);
            writeLine("");
            writeRecordBoundary();
            if (logger != null) {
                logger.appendKeyValue("    " + key, "<Image>");
            }
        }

        public void writeBytes(String key, byte[] bytes) throws IOException {
            writeContentDisposition(key, key, "content/unknown");
            this.outputStream.write(bytes);
            writeLine("");
            writeRecordBoundary();
            if (logger != null) {
                logger.appendKeyValue(
                        "    " + key,
                        String.format(Locale.ROOT, "<Data: %d>", bytes.length));
            }
        }

        public void writeContentUri(String key, Uri contentUri, String mimeType)
                throws IOException {
            if (mimeType == null) {
                mimeType = "content/unknown";
            }
            writeContentDisposition(key, key, mimeType);

            InputStream inputStream = FacebookSdk
                    .getApplicationContext()
                    .getContentResolver()
                    .openInputStream(contentUri);

            int totalBytes = 0;
            if (outputStream instanceof ProgressNoopOutputStream) {
                
                long contentSize = Utility.getContentSize(contentUri);

                ((ProgressNoopOutputStream) outputStream).addProgress(contentSize);
            } else {
                totalBytes += Utility.copyAndCloseInputStream(inputStream, outputStream);
            }

            writeLine("");
            writeRecordBoundary();
            if (logger != null) {
                logger.appendKeyValue(
                        "    " + key,
                        String.format(Locale.ROOT, "<Data: %d>", totalBytes));
            }
        }

        public void writeFile(
                String key,
                ParcelFileDescriptor descriptor,
                String mimeType
        ) throws IOException {
            if (mimeType == null) {
                mimeType = "content/unknown";
            }
            writeContentDisposition(key, key, mimeType);

            int totalBytes = 0;

            if (outputStream instanceof ProgressNoopOutputStream) {
                
                ((ProgressNoopOutputStream) outputStream).addProgress(descriptor.getStatSize());
            } else {
                ParcelFileDescriptor.AutoCloseInputStream inputStream =
                        new ParcelFileDescriptor.AutoCloseInputStream(descriptor);
                totalBytes += Utility.copyAndCloseInputStream(inputStream, outputStream);
            }
            writeLine("");
            writeRecordBoundary();
            if (logger != null) {
                logger.appendKeyValue(
                        "    " + key,
                        String.format(Locale.ROOT, "<Data: %d>", totalBytes));
            }
        }

        public void writeRecordBoundary() throws IOException {
            if (!useUrlEncode) {
                writeLine("--%s", MIME_BOUNDARY);
            } else {
                this.outputStream.write("&".getBytes());
            }
        }

        public void writeContentDisposition(
                String name,
                String filename,
                String contentType
        ) throws IOException {
            if (!useUrlEncode) {
                write("Content-Disposition: form-data; name=\"%s\"", name);
                if (filename != null) {
                    write("; filename=\"%s\"", filename);
                }
                writeLine(""); 
                if (contentType != null) {
                    writeLine("%s: %s", CONTENT_TYPE_HEADER, contentType);
                }
                writeLine(""); 
            } else {
                this.outputStream.write(String.format("%s=", name).getBytes());
            }
        }

        public void write(String format, Object... args) throws IOException {
            if (!useUrlEncode) {
                if (firstWrite) {
                    
                    this.outputStream.write("--".getBytes());
                    this.outputStream.write(MIME_BOUNDARY.getBytes());
                    this.outputStream.write("\r\n".getBytes());
                    firstWrite = false;
                }
                this.outputStream.write(String.format(format, args).getBytes());
            } else {
                this.outputStream.write(
                        URLEncoder.encode(
                                String.format(Locale.US, format, args), "UTF-8").getBytes());
            }
        }

        public void writeLine(String format, Object... args) throws IOException {
            write(format, args);
            if (!useUrlEncode) {
                write("\r\n");
            }
        }

    }

    
    public interface Callback {
        
        void onCompleted(GraphResponse response);
    }

    
    public interface OnProgressCallback extends Callback {
        
        void onProgress(long current, long max);
    }

    
    public interface GraphJSONArrayCallback {
        
        void onCompleted(JSONArray objects, GraphResponse response);
    }

    
    public interface GraphJSONObjectCallback {
        
        void onCompleted(JSONObject object, GraphResponse response);
    }

    
    public static class ParcelableResourceWithMimeType<RESOURCE extends Parcelable>
            implements Parcelable {
        private final String mimeType;
        private final RESOURCE resource;

        public String getMimeType() {
            return mimeType;
        }

        public RESOURCE getResource() {
            return resource;
        }

        public int describeContents() {
            return CONTENTS_FILE_DESCRIPTOR;
        }

        public void writeToParcel(Parcel out, int flags) {
            out.writeString(mimeType);
            out.writeParcelable(resource, flags);
        }

        @SuppressWarnings("unused")
        public static final Parcelable.Creator<ParcelableResourceWithMimeType> CREATOR
                = new Parcelable.Creator<ParcelableResourceWithMimeType>() {
            public ParcelableResourceWithMimeType createFromParcel(Parcel in) {
                return new ParcelableResourceWithMimeType(in);
            }

            public ParcelableResourceWithMimeType[] newArray(int size) {
                return new ParcelableResourceWithMimeType[size];
            }
        };

        
        public ParcelableResourceWithMimeType(
                RESOURCE resource,
                String mimeType
        ) {
            this.mimeType = mimeType;
            this.resource = resource;
        }

        private ParcelableResourceWithMimeType(Parcel in) {
            mimeType = in.readString();
            resource = in.readParcelable(FacebookSdk.getApplicationContext().getClassLoader());
        }
    }
}

<code block>


package com.facebook;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.Signature;
import android.os.AsyncTask;
import android.util.Base64;
import android.util.Log;

import com.facebook.appevents.AppEventsLogger;
import com.facebook.internal.AppEventsLoggerUtility;
import com.facebook.internal.BoltsMeasurementEventListener;
import com.facebook.internal.AttributionIdentifiers;
import com.facebook.internal.NativeProtocol;
import com.facebook.internal.Utility;
import com.facebook.internal.Validate;

import org.json.JSONException;
import org.json.JSONObject;

import java.io.File;
import java.lang.reflect.Field;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;


public final class FacebookSdk {
    private static final String TAG = FacebookSdk.class.getCanonicalName();
    private static final HashSet<LoggingBehavior> loggingBehaviors =
            new HashSet<LoggingBehavior>(Arrays.asList(LoggingBehavior.DEVELOPER_ERRORS));
    private static volatile Executor executor;
    private static volatile String applicationId;
    private static volatile String applicationName;
    private static volatile String appClientToken;
    private static volatile int webDialogTheme;
    private static final String FACEBOOK_COM = "facebook.com";
    private static volatile String facebookDomain = FACEBOOK_COM;
    private static AtomicLong onProgressThreshold = new AtomicLong(65536);
    private static volatile boolean isDebugEnabled = BuildConfig.DEBUG;
    private static boolean isLegacyTokenUpgradeSupported = false;
    private static File cacheDir;
    private static Context applicationContext;
    private static final int DEFAULT_CORE_POOL_SIZE = 5;
    private static final int DEFAULT_MAXIMUM_POOL_SIZE = 128;
    private static final int DEFAULT_KEEP_ALIVE = 1;
    private static int callbackRequestCodeOffset = 0xface;
    private static final Object LOCK = new Object();

    private static final int MAX_REQUEST_CODE_RANGE = 100;

    private static final String ATTRIBUTION_PREFERENCES = "com.facebook.sdk.attributionTracking";
    private static final String PUBLISH_ACTIVITY_PATH = "%s/activities";

    private static final BlockingQueue<Runnable> DEFAULT_WORK_QUEUE =
            new LinkedBlockingQueue<Runnable>(10);

    private static final ThreadFactory DEFAULT_THREAD_FACTORY = new ThreadFactory() {
        private final AtomicInteger counter = new AtomicInteger(0);

        public Thread newThread(Runnable runnable) {
            return new Thread(runnable, "FacebookSdk #" + counter.incrementAndGet());
        }
    };

    static final String CALLBACK_OFFSET_CHANGED_AFTER_INIT =
            "The callback request code offset can't be updated once the SDK is initialized.";

    static final String CALLBACK_OFFSET_NEGATIVE =
            "The callback request code offset can't be negative.";


    
    public static final String APPLICATION_ID_PROPERTY = "com.facebook.sdk.ApplicationId";

    
    public static final String APPLICATION_NAME_PROPERTY = "com.facebook.sdk.ApplicationName";

    
    public static final String CLIENT_TOKEN_PROPERTY = "com.facebook.sdk.ClientToken";

    
    public static final String WEB_DIALOG_THEME = "com.facebook.sdk.WebDialogTheme";

    private static Boolean sdkInitialized = false;

    
    public static synchronized void sdkInitialize(
            Context applicationContext,
            int callbackRequestCodeOffset) {
        sdkInitialize(applicationContext, callbackRequestCodeOffset, null);
    }

    
    public static synchronized void sdkInitialize(
            Context applicationContext,
            int callbackRequestCodeOffset,
            final InitializeCallback callback) {
        if (sdkInitialized && callbackRequestCodeOffset != FacebookSdk.callbackRequestCodeOffset) {
            throw new FacebookException(CALLBACK_OFFSET_CHANGED_AFTER_INIT);
        }
        if (callbackRequestCodeOffset < 0) {
            throw new FacebookException(CALLBACK_OFFSET_NEGATIVE);
        }
        FacebookSdk.callbackRequestCodeOffset = callbackRequestCodeOffset;
        sdkInitialize(applicationContext);
    }

    
    public static synchronized void sdkInitialize(Context applicationContext) {
        FacebookSdk.sdkInitialize(applicationContext, null);
    }

    
    public static synchronized void sdkInitialize(
            Context applicationContext,
            final InitializeCallback callback) {
        if (sdkInitialized) {
            if (callback != null) {
                callback.onInitialized();
            }
            return;
        }

        Validate.notNull(applicationContext, "applicationContext");

        
        
        Validate.hasFacebookActivity(applicationContext, false);
        Validate.hasInternetPermissions(applicationContext, false);

        FacebookSdk.applicationContext = applicationContext.getApplicationContext();

        
        FacebookSdk.loadDefaultsFromMetadata(FacebookSdk.applicationContext);
        
        Utility.loadAppSettingsAsync(FacebookSdk.applicationContext, applicationId);
        
        NativeProtocol.updateAllAvailableProtocolVersionsAsync();

        BoltsMeasurementEventListener.getInstance(FacebookSdk.applicationContext);

        cacheDir = FacebookSdk.applicationContext.getCacheDir();

        FutureTask<Void> accessTokenLoadFutureTask =
                new FutureTask<Void>(new Callable<Void>() {
                    @Override
                    public Void call() throws Exception {
                        AccessTokenManager.getInstance().loadCurrentAccessToken();
                        ProfileManager.getInstance().loadCurrentProfile();
                        if (AccessToken.getCurrentAccessToken() != null &&
                                Profile.getCurrentProfile() == null) {
                            
                            
                            Profile.fetchProfileForCurrentAccessToken();
                        }

                        if (callback != null) {
                            callback.onInitialized();
                        }
                        return null;
                    }
                });
        getExecutor().execute(accessTokenLoadFutureTask);

        sdkInitialized = true;
    }

    
    public static synchronized boolean isInitialized() {
        return sdkInitialized;
    }

    
    public static Set<LoggingBehavior> getLoggingBehaviors() {
        synchronized (loggingBehaviors) {
            return Collections.unmodifiableSet(new HashSet<LoggingBehavior>(loggingBehaviors));
        }
    }

    
    public static void addLoggingBehavior(LoggingBehavior behavior) {
        synchronized (loggingBehaviors) {
            loggingBehaviors.add(behavior);
            updateGraphDebugBehavior();
        }
    }

    
    public static void removeLoggingBehavior(LoggingBehavior behavior) {
        synchronized (loggingBehaviors) {
            loggingBehaviors.remove(behavior);
        }
    }

    
    public static void clearLoggingBehaviors() {
        synchronized (loggingBehaviors) {
            loggingBehaviors.clear();
        }
    }

    
    public static boolean isLoggingBehaviorEnabled(LoggingBehavior behavior) {
        synchronized (loggingBehaviors) {
            return FacebookSdk.isDebugEnabled() && loggingBehaviors.contains(behavior);
        }
    }

    
    public static boolean isDebugEnabled() {
        return isDebugEnabled;
    }

    
    public static void setIsDebugEnabled(boolean enabled) {
        isDebugEnabled = enabled;
    }

    
    public static boolean isLegacyTokenUpgradeSupported() {
        return isLegacyTokenUpgradeSupported;
    }

    private static void updateGraphDebugBehavior() {
        if (loggingBehaviors.contains(LoggingBehavior.GRAPH_API_DEBUG_INFO)
           && !loggingBehaviors.contains(LoggingBehavior.GRAPH_API_DEBUG_WARNING)) {
            loggingBehaviors.add(LoggingBehavior.GRAPH_API_DEBUG_WARNING);
        }
    }

    
    public static void setLegacyTokenUpgradeSupported(boolean supported) {
        isLegacyTokenUpgradeSupported = supported;
    }

    
    public static Executor getExecutor() {
        synchronized (LOCK) {
            if (FacebookSdk.executor == null) {
                Executor executor = getAsyncTaskExecutor();
                if (executor == null) {
                    executor = new ThreadPoolExecutor(
                            DEFAULT_CORE_POOL_SIZE, DEFAULT_MAXIMUM_POOL_SIZE, DEFAULT_KEEP_ALIVE,
                            TimeUnit.SECONDS, DEFAULT_WORK_QUEUE, DEFAULT_THREAD_FACTORY);
                }
                FacebookSdk.executor = executor;
            }
        }
        return FacebookSdk.executor;
    }

    
    public static void setExecutor(Executor executor) {
        Validate.notNull(executor, "executor");
        synchronized (LOCK) {
            FacebookSdk.executor = executor;
        }
    }

    
    public static String getFacebookDomain() {
        return facebookDomain;
    }

    
    public static void setFacebookDomain(String facebookDomain) {
        if (!BuildConfig.DEBUG) {
            Log.w(TAG, "WARNING: Calling setFacebookDomain from non-DEBUG code.");
        }

        FacebookSdk.facebookDomain = facebookDomain;
    }

    
    public static Context getApplicationContext() {
        Validate.sdkInitialized();
        return applicationContext;
    }

    private static Executor getAsyncTaskExecutor() {
        Field executorField = null;
        try {
            executorField = AsyncTask.class.getField("THREAD_POOL_EXECUTOR");
        } catch (NoSuchFieldException e) {
            return null;
        }

        Object executorObject = null;
        try {
            executorObject = executorField.get(null);
        } catch (IllegalAccessException e) {
            return null;
        }

        if (executorObject == null) {
            return null;
        }

        if (!(executorObject instanceof Executor)) {
            return null;
        }

        return (Executor) executorObject;
    }

    
    public static void publishInstallAsync(final Context context, final String applicationId) {
        
        
        final Context applicationContext = context.getApplicationContext();
        FacebookSdk.getExecutor().execute(new Runnable() {
            @Override
            public void run() {
                FacebookSdk.publishInstallAndWaitForResponse(applicationContext, applicationId);
            }
        });
    }

    static GraphResponse publishInstallAndWaitForResponse(
            final Context context,
            final String applicationId) {
        try {
            if (context == null || applicationId == null) {
                throw new IllegalArgumentException("Both context and applicationId must be non-null");
            }
            AttributionIdentifiers identifiers = AttributionIdentifiers.getAttributionIdentifiers(context);
            SharedPreferences preferences = context.getSharedPreferences(ATTRIBUTION_PREFERENCES, Context.MODE_PRIVATE);
            String pingKey = applicationId+"ping";
            String jsonKey = applicationId+"json";
            long lastPing = preferences.getLong(pingKey, 0);
            String lastResponseJSON = preferences.getString(jsonKey, null);

            JSONObject publishParams;
            try {
                publishParams = AppEventsLoggerUtility.getJSONObjectForGraphAPICall(
                        AppEventsLoggerUtility.GraphAPIActivityType.MOBILE_INSTALL_EVENT,
                        identifiers,
                        AppEventsLogger.getAnonymousAppDeviceGUID(context),
                        getLimitEventAndDataUsage(context),
                        context);
            } catch (JSONException e) {
                throw new FacebookException("An error occurred while publishing install.", e);
            }

            String publishUrl = String.format(PUBLISH_ACTIVITY_PATH, applicationId);
            GraphRequest publishRequest = GraphRequest.newPostRequest(null, publishUrl, publishParams, null);

            if (lastPing != 0) {
                JSONObject graphObject = null;
                try {
                    if (lastResponseJSON != null) {
                        graphObject = new JSONObject(lastResponseJSON);
                    }
                }
                catch (JSONException je) {
                    
                }
                if (graphObject == null) {
                    return GraphResponse.createResponsesFromString(
                            "true",
                            null,
                            new GraphRequestBatch(publishRequest)
                    ).get(0);
                } else {
                    return new GraphResponse(null, null, null, graphObject);
                }

            } else {

                GraphResponse publishResponse = publishRequest.executeAndWait();

                
                SharedPreferences.Editor editor = preferences.edit();
                lastPing = System.currentTimeMillis();
                editor.putLong(pingKey, lastPing);

                
                if (publishResponse.getJSONObject() != null) {
                    editor.putString(jsonKey, publishResponse.getJSONObject().toString());
                }
                editor.apply();

                return publishResponse;
            }
        } catch (Exception e) {
            
            Utility.logd("Facebook-publish", e);
            return new GraphResponse(null, null, new FacebookRequestError(null, e));
        }
    }

    
    public static String getSdkVersion() {
        return FacebookSdkVersion.BUILD;
    }

    
    public static boolean getLimitEventAndDataUsage(Context context) {
        Validate.sdkInitialized();
        SharedPreferences preferences = context.getSharedPreferences(
                AppEventsLogger.APP_EVENT_PREFERENCES, Context.MODE_PRIVATE);
        return preferences.getBoolean("limitEventUsage", false);
    }

    
    public static void setLimitEventAndDataUsage(Context context, boolean limitEventUsage) {
        context.getSharedPreferences(AppEventsLogger.APP_EVENT_PREFERENCES, Context.MODE_PRIVATE)
            .edit()
            .putBoolean("limitEventUsage", limitEventUsage)
            .apply();
    }

    
    public static long getOnProgressThreshold() {
        Validate.sdkInitialized();
        return onProgressThreshold.get();
    }

    
    public static void setOnProgressThreshold(long threshold) {
        onProgressThreshold.set(threshold);
    }

    
    static void loadDefaultsFromMetadata(Context context) {
        if (context == null) {
            return;
        }

        ApplicationInfo ai = null;
        try {
            ai = context.getPackageManager().getApplicationInfo(
                    context.getPackageName(), PackageManager.GET_META_DATA);
        } catch (PackageManager.NameNotFoundException e) {
            return;
        }

        if (ai == null || ai.metaData == null) {
            return;
        }

        if (applicationId == null) {
            Object appId = ai.metaData.get(APPLICATION_ID_PROPERTY);
            if (appId instanceof String) {
                applicationId = (String) appId;
            } else if (appId instanceof Integer) {
                applicationId = appId.toString();
            }
        }

        if (applicationName == null) {
            applicationName = ai.metaData.getString(APPLICATION_NAME_PROPERTY);
        }

        if (appClientToken == null) {
            appClientToken = ai.metaData.getString(CLIENT_TOKEN_PROPERTY);
        }

        if (webDialogTheme == 0) {
            setWebDialogTheme(ai.metaData.getInt(WEB_DIALOG_THEME));
        }
    }

    
    public static String getApplicationSignature(Context context) {
        Validate.sdkInitialized();
        if (context == null) {
            return null;
        }
        PackageManager packageManager = context.getPackageManager();
        if (packageManager == null) {
            return null;
        }

        String packageName = context.getPackageName();
        PackageInfo pInfo;
        try {
            pInfo = packageManager.getPackageInfo(packageName, PackageManager.GET_SIGNATURES);
        } catch (PackageManager.NameNotFoundException e) {
            return null;
        }

        Signature[] signatures = pInfo.signatures;
        if (signatures == null || signatures.length == 0) {
            return null;
        }

        MessageDigest md;
        try {
            md = MessageDigest.getInstance("SHA-1");
        } catch (NoSuchAlgorithmException e) {
            return null;
        }

        md.update(pInfo.signatures[0].toByteArray());
        return Base64.encodeToString(md.digest(),  Base64.URL_SAFE | Base64.NO_PADDING);
    }

    
    public static String getApplicationId() {
        Validate.sdkInitialized();
        return applicationId;
    }

    
    public static void setApplicationId(String applicationId) {
        FacebookSdk.applicationId = applicationId;
    }

    
    public static String getApplicationName() {
        Validate.sdkInitialized();
        return applicationName;
    }

    
    public static void setApplicationName(String applicationName) {
        FacebookSdk.applicationName = applicationName;
    }

    
    public static String getClientToken() {
        Validate.sdkInitialized();
        return appClientToken;
    }

    
    public static void setClientToken(String clientToken) {
        appClientToken = clientToken;
    }

    
    public static int getWebDialogTheme() {
        Validate.sdkInitialized();
        return webDialogTheme;
    }

    
    public static void setWebDialogTheme(int theme) {
        webDialogTheme = theme;
    }

    
    public static File getCacheDir() {
        Validate.sdkInitialized();
        return cacheDir;
    }

    
    public static void setCacheDir(File cacheDir) {
        FacebookSdk.cacheDir = cacheDir;
    }

    
    public static int getCallbackRequestCodeOffset() {
        Validate.sdkInitialized();
        return callbackRequestCodeOffset;
    }

    
    public static boolean isFacebookRequestCode(int requestCode) {
        return requestCode >= callbackRequestCodeOffset
                && requestCode < callbackRequestCodeOffset + MAX_REQUEST_CODE_RANGE;
    }

    
    public interface InitializeCallback {
        
        void onInitialized();
    }
}

<code block>


package com.facebook.internal;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.database.Cursor;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.os.Environment;
import android.os.Parcel;
import android.os.StatFs;
import android.provider.OpenableColumns;
import android.telephony.TelephonyManager;
import android.text.TextUtils;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.Display;
import android.view.WindowManager;
import android.webkit.CookieManager;
import android.webkit.CookieSyncManager;

import com.facebook.AccessToken;
import com.facebook.FacebookException;
import com.facebook.FacebookSdk;
import com.facebook.GraphRequest;
import com.facebook.GraphResponse;
import com.facebook.HttpMethod;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.json.JSONTokener;

import java.io.*;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.HttpURLConnection;
import java.net.URLConnection;

import java.net.URLDecoder;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.regex.Pattern;


public final class Utility {
    static final String LOG_TAG = "FacebookSDK";
    private static final String HASH_ALGORITHM_MD5 = "MD5";
    private static final String HASH_ALGORITHM_SHA1 = "SHA-1";
    private static final String URL_SCHEME = "https";
    private static final String APP_SETTINGS_PREFS_STORE =
            "com.facebook.internal.preferences.APP_SETTINGS";
    private static final String APP_SETTINGS_PREFS_KEY_FORMAT =
            "com.facebook.internal.APP_SETTINGS.%s";
    private static final String APP_SETTING_SUPPORTS_IMPLICIT_SDK_LOGGING =
            "supports_implicit_sdk_logging";
    private static final String APP_SETTING_NUX_CONTENT = "gdpv4_nux_content";
    private static final String APP_SETTING_NUX_ENABLED = "gdpv4_nux_enabled";
    private static final String APP_SETTING_DIALOG_CONFIGS = "android_dialog_configs";
    private static final String APP_SETTING_ANDROID_SDK_ERROR_CATEGORIES =
            "android_sdk_error_categories";
    private static final String EXTRA_APP_EVENTS_INFO_FORMAT_VERSION = "a2";
    private static final String DIALOG_CONFIG_DIALOG_NAME_FEATURE_NAME_SEPARATOR = "\\|";
    private static final String DIALOG_CONFIG_NAME_KEY = "name";
    private static final String DIALOG_CONFIG_VERSIONS_KEY = "versions";
    private static final String DIALOG_CONFIG_URL_KEY = "url";

    private final static String UTF8 = "UTF-8";

    private static final String[] APP_SETTING_FIELDS = new String[]{
            APP_SETTING_SUPPORTS_IMPLICIT_SDK_LOGGING,
            APP_SETTING_NUX_CONTENT,
            APP_SETTING_NUX_ENABLED,
            APP_SETTING_DIALOG_CONFIGS,
            APP_SETTING_ANDROID_SDK_ERROR_CATEGORIES
    };
    private static final String APPLICATION_FIELDS = "fields";

    
    
    public static final int DEFAULT_STREAM_BUFFER_SIZE = 8192;

    
    private static final int REFRESH_TIME_FOR_EXTENDED_DEVICE_INFO_MILLIS = 30 * 60 * 1000;

    private static final String noCarrierConstant = "NoCarrier";

    private static final int GINGERBREAD_MR1 = 10;

    private static Map<String, FetchedAppSettings> fetchedAppSettings =
            new ConcurrentHashMap<String, FetchedAppSettings>();

    private static AtomicBoolean loadingSettings = new AtomicBoolean(false);

    private static int numCPUCores = 0;

    private static long timestampOfLastCheck = -1;
    private static long totalExternalStorageGB = -1;
    private static long availableExternalStorageGB = -1;
    private static String deviceTimezone = "";
    private static String carrierName = noCarrierConstant;

    public static class FetchedAppSettings {
        private boolean supportsImplicitLogging;
        private String nuxContent;
        private boolean nuxEnabled;
        private Map<String, Map<String, DialogFeatureConfig>> dialogConfigMap;
        private FacebookRequestErrorClassification errorClassification;

        private FetchedAppSettings(boolean supportsImplicitLogging,
                                   String nuxContent,
                                   boolean nuxEnabled,
                                   Map<String, Map<String, DialogFeatureConfig>> dialogConfigMap,
                                   FacebookRequestErrorClassification errorClassification) {
            this.supportsImplicitLogging = supportsImplicitLogging;
            this.nuxContent = nuxContent;
            this.nuxEnabled = nuxEnabled;
            this.dialogConfigMap = dialogConfigMap;
            this.errorClassification = errorClassification;
        }

        public boolean supportsImplicitLogging() {
            return supportsImplicitLogging;
        }

        public String getNuxContent() {
            return nuxContent;
        }

        public boolean getNuxEnabled() {
            return nuxEnabled;
        }

        public Map<String, Map<String, DialogFeatureConfig>> getDialogConfigurations() {
            return dialogConfigMap;
        }

        public FacebookRequestErrorClassification getErrorClassification() {
            return errorClassification;
        }
    }

    public static class DialogFeatureConfig {
        private static DialogFeatureConfig parseDialogConfig(JSONObject dialogConfigJSON) {
            String dialogNameWithFeature = dialogConfigJSON.optString(DIALOG_CONFIG_NAME_KEY);
            if (Utility.isNullOrEmpty(dialogNameWithFeature)) {
                return null;
            }

            String[] components = dialogNameWithFeature.split(
                    DIALOG_CONFIG_DIALOG_NAME_FEATURE_NAME_SEPARATOR);
            if (components.length != 2) {
                
                
                return null;
            }

            String dialogName = components[0];
            String featureName = components[1];
            if (isNullOrEmpty(dialogName) || isNullOrEmpty(featureName)) {
                return null;
            }

            String urlString = dialogConfigJSON.optString(DIALOG_CONFIG_URL_KEY);
            Uri fallbackUri = null;
            if (!Utility.isNullOrEmpty(urlString)) {
                fallbackUri = Uri.parse(urlString);
            }

            JSONArray versionsJSON = dialogConfigJSON.optJSONArray(DIALOG_CONFIG_VERSIONS_KEY);

            int[] featureVersionSpec = parseVersionSpec(versionsJSON);

            return new DialogFeatureConfig(
                    dialogName, featureName, fallbackUri, featureVersionSpec);
        }

        private static int[] parseVersionSpec(JSONArray versionsJSON) {
            
            
            
            int[] versionSpec = null;
            if (versionsJSON != null) {
                int numVersions = versionsJSON.length();
                versionSpec = new int[numVersions];
                for (int i = 0; i < numVersions; i++) {
                    
                    int version = versionsJSON.optInt(i, NativeProtocol.NO_PROTOCOL_AVAILABLE);
                    if (version == NativeProtocol.NO_PROTOCOL_AVAILABLE) {
                        
                        
                        String versionString = versionsJSON.optString(i);
                        if (!isNullOrEmpty(versionString)) {
                            try {
                                version = Integer.parseInt(versionString);
                            } catch (NumberFormatException nfe) {
                                logd(LOG_TAG, nfe);
                                version = NativeProtocol.NO_PROTOCOL_AVAILABLE;
                            }
                        }
                    }

                    versionSpec[i] = version;
                }
            }

            return versionSpec;
        }

        private String dialogName;
        private String featureName;
        private Uri fallbackUrl;
        private int[] featureVersionSpec;

        private DialogFeatureConfig(
                String dialogName,
                String featureName,
                Uri fallbackUrl,
                int[] featureVersionSpec) {
            this.dialogName = dialogName;
            this.featureName = featureName;
            this.fallbackUrl = fallbackUrl;
            this.featureVersionSpec = featureVersionSpec;
        }

        public String getDialogName() {
            return dialogName;
        }

        public String getFeatureName() {
            return featureName;
        }

        public Uri getFallbackUrl() {
            return fallbackUrl;
        }

        public int[] getVersionSpec() {
            return featureVersionSpec;
        }
    }

    
    public static int[] intersectRanges(int[] range1, int[] range2) {
        if (range1 == null) {
            return range2;
        } else if (range2 == null) {
            return range1;
        }

        int[] outputRange = new int[range1.length + range2.length];
        int outputIndex = 0;
        int index1 = 0, lower1, upper1;
        int index2 = 0, lower2, upper2;
        while (index1 < range1.length && index2 < range2.length) {
            int newRangeLower = Integer.MIN_VALUE, newRangeUpper = Integer.MAX_VALUE;
            lower1 = range1[index1];
            upper1 = Integer.MAX_VALUE;

            lower2 = range2[index2];
            upper2 = Integer.MAX_VALUE;

            if (index1 < range1.length - 1) {
                upper1 = range1[index1 + 1];
            }
            if (index2 < range2.length - 1) {
                upper2 = range2[index2 + 1];
            }

            if (lower1 < lower2) {
                if (upper1 > lower2) {
                    newRangeLower = lower2;
                    if (upper1 > upper2) {
                        newRangeUpper = upper2;
                        index2 += 2;
                    } else {
                        newRangeUpper = upper1;
                        index1 += 2;
                    }
                } else {
                    index1 += 2;
                }
            } else {
                if (upper2 > lower1) {
                    newRangeLower = lower1;
                    if (upper2 > upper1) {
                        newRangeUpper = upper1;
                        index1 += 2;
                    } else {
                        newRangeUpper = upper2;
                        index2 += 2;
                    }
                } else {
                    index2 += 2;
                }
            }

            if (newRangeLower != Integer.MIN_VALUE) {
                outputRange[outputIndex++] = newRangeLower;
                if (newRangeUpper != Integer.MAX_VALUE) {
                    outputRange[outputIndex++] = newRangeUpper;
                } else {
                    
                    break;
                }
            }
        }

        return Arrays.copyOf(outputRange, outputIndex);
    }

    
    
    
    public static <T> boolean isSubset(Collection<T> subset, Collection<T> superset) {
        if ((superset == null) || (superset.size() == 0)) {
            return ((subset == null) || (subset.size() == 0));
        }

        HashSet<T> hash = new HashSet<T>(superset);
        for (T t : subset) {
            if (!hash.contains(t)) {
                return false;
            }
        }
        return true;
    }

    public static <T> boolean isNullOrEmpty(Collection<T> c) {
        return (c == null) || (c.size() == 0);
    }

    public static boolean isNullOrEmpty(String s) {
        return (s == null) || (s.length() == 0);
    }

    
    public static String coerceValueIfNullOrEmpty(String s, String valueIfNullOrEmpty) {
        if (isNullOrEmpty(s)) {
            return valueIfNullOrEmpty;
        }

        return s;
    }

    public static <T> Collection<T> unmodifiableCollection(T... ts) {
        return Collections.unmodifiableCollection(Arrays.asList(ts));
    }

    public static <T> ArrayList<T> arrayList(T... ts) {
        ArrayList<T> arrayList = new ArrayList<T>(ts.length);
        for (T t : ts) {
            arrayList.add(t);
        }
        return arrayList;
    }

    public static <T> HashSet<T> hashSet(T... ts) {
        HashSet<T> hashSet = new HashSet<T>(ts.length);
        for (T t : ts) {
            hashSet.add(t);
        }
        return hashSet;
    }

    public static String md5hash(String key) {
        return hashWithAlgorithm(HASH_ALGORITHM_MD5, key);
    }

    public static String sha1hash(String key) {
        return hashWithAlgorithm(HASH_ALGORITHM_SHA1, key);
    }

    public static String sha1hash(byte[] bytes) {
        return hashWithAlgorithm(HASH_ALGORITHM_SHA1, bytes);
    }

    private static String hashWithAlgorithm(String algorithm, String key) {
        return hashWithAlgorithm(algorithm, key.getBytes());
    }

    private static String hashWithAlgorithm(String algorithm, byte[] bytes) {
        MessageDigest hash;
        try {
            hash = MessageDigest.getInstance(algorithm);
        } catch (NoSuchAlgorithmException e) {
            return null;
        }
        return hashBytes(hash, bytes);
    }

    private static String hashBytes(MessageDigest hash, byte[] bytes) {
        hash.update(bytes);
        byte[] digest = hash.digest();
        StringBuilder builder = new StringBuilder();
        for (int b : digest) {
            builder.append(Integer.toHexString((b >> 4) & 0xf));
            builder.append(Integer.toHexString((b >> 0) & 0xf));
        }
        return builder.toString();
    }

    public static Uri buildUri(String authority, String path, Bundle parameters) {
        Uri.Builder builder = new Uri.Builder();
        builder.scheme(URL_SCHEME);
        builder.authority(authority);
        builder.path(path);
        if (parameters != null) {
            for (String key : parameters.keySet()) {
                Object parameter = parameters.get(key);
                if (parameter instanceof String) {
                    builder.appendQueryParameter(key, (String) parameter);
                }
            }
        }
        return builder.build();
    }

    public static Bundle parseUrlQueryString(String queryString) {
        Bundle params = new Bundle();
        if (!isNullOrEmpty(queryString)) {
            String array[] = queryString.split("&");
            for (String parameter : array) {
                String keyValuePair[] = parameter.split("=");

                try {
                    if (keyValuePair.length == 2) {
                        params.putString(
                                URLDecoder.decode(keyValuePair[0], UTF8),
                                URLDecoder.decode(keyValuePair[1], UTF8));
                    } else if (keyValuePair.length == 1) {
                        params.putString(
                                URLDecoder.decode(keyValuePair[0], UTF8),
                                "");
                    }
                } catch (UnsupportedEncodingException e) {
                    
                    logd(LOG_TAG, e);
                }
            }
        }
        return params;
    }

    public static void putNonEmptyString(Bundle b, String key, String value) {
        if (!Utility.isNullOrEmpty(value)) {
            b.putString(key, value);
        }
    }

    public static void putCommaSeparatedStringList(Bundle b, String key, ArrayList<String> list) {
        if (list != null) {
            StringBuilder builder = new StringBuilder();
            for (String string : list) {
                builder.append(string);
                builder.append(",");
            }
            String commaSeparated = "";
            if (builder.length() > 0) {
                commaSeparated = builder.substring(0, builder.length() - 1);
            }
            b.putString(key, commaSeparated);
        }
    }

    public static void putUri(Bundle b, String key, Uri uri) {
        if (uri != null) {
            Utility.putNonEmptyString(b, key, uri.toString());
        }
    }

    public static boolean putJSONValueInBundle(Bundle bundle, String key, Object value) {
        if (value == null) {
            bundle.remove(key);
        } else if (value instanceof Boolean) {
            bundle.putBoolean(key, (boolean) value);
        } else if (value instanceof boolean[]) {
            bundle.putBooleanArray(key, (boolean[]) value);
        } else if (value instanceof Double) {
            bundle.putDouble(key, (double) value);
        } else if (value instanceof double[]) {
            bundle.putDoubleArray(key, (double[]) value);
        } else if (value instanceof Integer) {
            bundle.putInt(key, (int) value);
        } else if (value instanceof int[]) {
            bundle.putIntArray(key, (int[]) value);
        } else if (value instanceof Long) {
            bundle.putLong(key, (long) value);
        } else if (value instanceof long[]) {
            bundle.putLongArray(key, (long[]) value);
        } else if (value instanceof String) {
            bundle.putString(key, (String) value);
        } else if (value instanceof JSONArray) {
            bundle.putString(key, ((JSONArray) value).toString());
        } else if (value instanceof JSONObject) {
            bundle.putString(key, ((JSONObject) value).toString());
        } else {
            return false;
        }
        return true;
    }

    public static void closeQuietly(Closeable closeable) {
        try {
            if (closeable != null) {
                closeable.close();
            }
        } catch (IOException ioe) {
            
        }
    }

    public static void disconnectQuietly(URLConnection connection) {
        if (connection instanceof HttpURLConnection) {
            ((HttpURLConnection) connection).disconnect();
        }
    }

    public static String getMetadataApplicationId(Context context) {
        Validate.notNull(context, "context");

        FacebookSdk.sdkInitialize(context);

        return FacebookSdk.getApplicationId();
    }

    static Map<String, Object> convertJSONObjectToHashMap(JSONObject jsonObject) {
        HashMap<String, Object> map = new HashMap<String, Object>();
        JSONArray keys = jsonObject.names();
        for (int i = 0; i < keys.length(); ++i) {
            String key;
            try {
                key = keys.getString(i);
                Object value = jsonObject.get(key);
                if (value instanceof JSONObject) {
                    value = convertJSONObjectToHashMap((JSONObject) value);
                }
                map.put(key, value);
            } catch (JSONException e) {
            }
        }
        return map;
    }

    
    
    public static Object getStringPropertyAsJSON(
            JSONObject jsonObject,
            String key,
            String nonJSONPropertyKey
    ) throws JSONException {
        Object value = jsonObject.opt(key);
        if (value != null && value instanceof String) {
            JSONTokener tokener = new JSONTokener((String) value);
            value = tokener.nextValue();
        }

        if (value != null && !(value instanceof JSONObject || value instanceof JSONArray)) {
            if (nonJSONPropertyKey != null) {
                
                
                
                
                jsonObject = new JSONObject();
                jsonObject.putOpt(nonJSONPropertyKey, value);
                return jsonObject;
            } else {
                throw new FacebookException("Got an unexpected non-JSON object.");
            }
        }

        return value;

    }

    public static String readStreamToString(InputStream inputStream) throws IOException {
        BufferedInputStream bufferedInputStream = null;
        InputStreamReader reader = null;
        try {
            bufferedInputStream = new BufferedInputStream(inputStream);
            reader = new InputStreamReader(bufferedInputStream);
            StringBuilder stringBuilder = new StringBuilder();

            final int bufferSize = 1024 * 2;
            char[] buffer = new char[bufferSize];
            int n = 0;
            while ((n = reader.read(buffer)) != -1) {
                stringBuilder.append(buffer, 0, n);
            }

            return stringBuilder.toString();
        } finally {
            closeQuietly(bufferedInputStream);
            closeQuietly(reader);
        }
    }

    public static int copyAndCloseInputStream(InputStream inputStream, OutputStream outputStream)
            throws IOException {
        BufferedInputStream bufferedInputStream = null;
        int totalBytes = 0;
        try {
            bufferedInputStream = new BufferedInputStream(inputStream);

            byte[] buffer = new byte[8192];
            int bytesRead;
            while ((bytesRead = bufferedInputStream.read(buffer)) != -1) {
                outputStream.write(buffer, 0, bytesRead);
                totalBytes += bytesRead;
            }
        } finally {
            if (bufferedInputStream != null) {
                bufferedInputStream.close();
            }
            if (inputStream != null) {
                inputStream.close();
            }
        }

        return totalBytes;
    }

    public static boolean stringsEqualOrEmpty(String a, String b) {
        boolean aEmpty = TextUtils.isEmpty(a);
        boolean bEmpty = TextUtils.isEmpty(b);

        if (aEmpty && bEmpty) {
            
            return true;
        }
        if (!aEmpty && !bEmpty) {
            
            return a.equals(b);
        }
        
        return false;
    }

    private static void clearCookiesForDomain(Context context, String domain) {
        
        
        CookieSyncManager syncManager = CookieSyncManager.createInstance(context);
        syncManager.sync();

        CookieManager cookieManager = CookieManager.getInstance();

        String cookies = cookieManager.getCookie(domain);
        if (cookies == null) {
            return;
        }

        String[] splitCookies = cookies.split(";");
        for (String cookie : splitCookies) {
            String[] cookieParts = cookie.split("=");
            if (cookieParts.length > 0) {
                String newCookie = cookieParts[0].trim() +
                        "=;expires=Sat, 1 Jan 2000 00:00:01 UTC;";
                cookieManager.setCookie(domain, newCookie);
            }
        }
        cookieManager.removeExpiredCookie();
    }

    public static void clearFacebookCookies(Context context) {
        
        
        
        clearCookiesForDomain(context, "facebook.com");
        clearCookiesForDomain(context, ".facebook.com");
        clearCookiesForDomain(context, "https:
        clearCookiesForDomain(context, "https:
    }

    public static void logd(String tag, Exception e) {
        if (FacebookSdk.isDebugEnabled() && tag != null && e != null) {
            Log.d(tag, e.getClass().getSimpleName() + ": " + e.getMessage());
        }
    }

    public static void logd(String tag, String msg) {
        if (FacebookSdk.isDebugEnabled() && tag != null && msg != null) {
            Log.d(tag, msg);
        }
    }

    public static void logd(String tag, String msg, Throwable t) {
        if (FacebookSdk.isDebugEnabled() && !isNullOrEmpty(tag)) {
            Log.d(tag, msg, t);
        }
    }

    public static <T> boolean areObjectsEqual(T a, T b) {
        if (a == null) {
            return b == null;
        }
        return a.equals(b);
    }

    public static boolean hasSameId(JSONObject a, JSONObject b) {
        if (a == null || b == null || !a.has("id") || !b.has("id")) {
            return false;
        }
        if (a.equals(b)) {
            return true;
        }
        String idA = a.optString("id");
        String idB = b.optString("id");
        if (idA == null || idB == null) {
            return false;
        }
        return idA.equals(idB);
    }

    public static void loadAppSettingsAsync(
            final Context context,
            final String applicationId
    ) {
        boolean canStartLoading = loadingSettings.compareAndSet(false, true);
        if (Utility.isNullOrEmpty(applicationId) ||
                fetchedAppSettings.containsKey(applicationId) ||
                !canStartLoading) {
            return;
        }

        final String settingsKey = String.format(APP_SETTINGS_PREFS_KEY_FORMAT, applicationId);

        FacebookSdk.getExecutor().execute(new Runnable() {
            @Override
            public void run() {
                JSONObject resultJSON = getAppSettingsQueryResponse(applicationId);
                if (resultJSON != null) {
                    parseAppSettingsFromJSON(applicationId, resultJSON);

                    SharedPreferences sharedPrefs = context.getSharedPreferences(
                            APP_SETTINGS_PREFS_STORE,
                            Context.MODE_PRIVATE);
                    sharedPrefs.edit()
                            .putString(settingsKey, resultJSON.toString())
                            .apply();
                }

                loadingSettings.set(false);
            }
        });

        
        SharedPreferences sharedPrefs = context.getSharedPreferences(
                APP_SETTINGS_PREFS_STORE,
                Context.MODE_PRIVATE);
        String settingsJSONString = sharedPrefs.getString(settingsKey, null);
        if (!isNullOrEmpty(settingsJSONString)) {
            JSONObject settingsJSON = null;
            try {
                settingsJSON = new JSONObject(settingsJSONString);
            } catch (JSONException je) {
                logd(LOG_TAG, je);
            }
            if (settingsJSON != null) {
                parseAppSettingsFromJSON(applicationId, settingsJSON);
            }
        }
    }

    
    public static FetchedAppSettings getAppSettingsWithoutQuery(final String applicationId) {
        return applicationId != null ? fetchedAppSettings.get(applicationId) : null;
    }

    
    
    public static FetchedAppSettings queryAppSettings(
            final String applicationId,
            final boolean forceRequery) {
        
        if (!forceRequery && fetchedAppSettings.containsKey(applicationId)) {
            return fetchedAppSettings.get(applicationId);
        }

        JSONObject response = getAppSettingsQueryResponse(applicationId);
        if (response == null) {
            return null;
        }

        return parseAppSettingsFromJSON(applicationId, response);
    }

    private static FetchedAppSettings parseAppSettingsFromJSON(
            String applicationId,
            JSONObject settingsJSON) {
        JSONArray errorClassificationJSON =
                settingsJSON.optJSONArray(APP_SETTING_ANDROID_SDK_ERROR_CATEGORIES);
        FacebookRequestErrorClassification errorClassification =
                errorClassificationJSON == null
                        ? FacebookRequestErrorClassification.getDefaultErrorClassification()
                        : FacebookRequestErrorClassification.createFromJSON(
                        errorClassificationJSON
                );
        FetchedAppSettings result = new FetchedAppSettings(
                settingsJSON.optBoolean(APP_SETTING_SUPPORTS_IMPLICIT_SDK_LOGGING, false),
                settingsJSON.optString(APP_SETTING_NUX_CONTENT, ""),
                settingsJSON.optBoolean(APP_SETTING_NUX_ENABLED, false),
                parseDialogConfigurations(settingsJSON.optJSONObject(APP_SETTING_DIALOG_CONFIGS)),
                errorClassification
        );

        fetchedAppSettings.put(applicationId, result);

        return result;
    }

    
    
    private static JSONObject getAppSettingsQueryResponse(String applicationId) {
        Bundle appSettingsParams = new Bundle();
        appSettingsParams.putString(APPLICATION_FIELDS, TextUtils.join(",", APP_SETTING_FIELDS));

        GraphRequest request = GraphRequest.newGraphPathRequest(null, applicationId, null);
        request.setSkipClientToken(true);
        request.setParameters(appSettingsParams);

        return request.executeAndWait().getJSONObject();
    }

    public static DialogFeatureConfig getDialogFeatureConfig(
            String applicationId,
            String actionName,
            String featureName) {
        if (Utility.isNullOrEmpty(actionName) || Utility.isNullOrEmpty(featureName)) {
            return null;
        }

        FetchedAppSettings settings = fetchedAppSettings.get(applicationId);
        if (settings != null) {
            Map<String, DialogFeatureConfig> featureMap =
                    settings.getDialogConfigurations().get(actionName);
            if (featureMap != null) {
                return featureMap.get(featureName);
            }
        }
        return null;
    }

    private static Map<String, Map<String, DialogFeatureConfig>> parseDialogConfigurations(
            JSONObject dialogConfigResponse) {
        HashMap<String, Map<String, DialogFeatureConfig>> dialogConfigMap = new HashMap<String, Map<String, DialogFeatureConfig>>();

        if (dialogConfigResponse != null) {
            JSONArray dialogConfigData = dialogConfigResponse.optJSONArray("data");
            if (dialogConfigData != null) {
                for (int i = 0; i < dialogConfigData.length(); i++) {
                    DialogFeatureConfig dialogConfig = DialogFeatureConfig.parseDialogConfig(
                            dialogConfigData.optJSONObject(i));
                    if (dialogConfig == null) {
                        continue;
                    }

                    String dialogName = dialogConfig.getDialogName();
                    Map<String, DialogFeatureConfig> featureMap = dialogConfigMap.get(dialogName);
                    if (featureMap == null) {
                        featureMap = new HashMap<String, DialogFeatureConfig>();
                        dialogConfigMap.put(dialogName, featureMap);
                    }
                    featureMap.put(dialogConfig.getFeatureName(), dialogConfig);
                }
            }
        }

        return dialogConfigMap;
    }

    public static String safeGetStringFromResponse(JSONObject response, String propertyName) {
        return response != null ? response.optString(propertyName, "") : "";
    }

    public static JSONObject tryGetJSONObjectFromResponse(JSONObject response, String propertyKey) {
        return response != null ? response.optJSONObject(propertyKey) : null;
    }

    public static JSONArray tryGetJSONArrayFromResponse(JSONObject response, String propertyKey) {
        return response != null ? response.optJSONArray(propertyKey) : null;
    }

    public static void clearCaches(Context context) {
        ImageDownloader.clearCache(context);
    }

    public static void deleteDirectory(File directoryOrFile) {
        if (!directoryOrFile.exists()) {
            return;
        }

        if (directoryOrFile.isDirectory()) {
            for (File child : directoryOrFile.listFiles()) {
                deleteDirectory(child);
            }
        }
        directoryOrFile.delete();
    }

    public static <T> List<T> asListNoNulls(T... array) {
        ArrayList<T> result = new ArrayList<T>();
        for (T t : array) {
            if (t != null) {
                result.add(t);
            }
        }
        return result;
    }

    public static List<String> jsonArrayToStringList(JSONArray jsonArray) throws JSONException {
        ArrayList<String> result = new ArrayList<>();

        for (int i = 0; i < jsonArray.length(); i++) {
            result.add(jsonArray.getString(i));
        }

        return result;
    }

    public static Set<String> jsonArrayToSet(JSONArray jsonArray) throws JSONException {
        Set<String> result = new HashSet<>();
        for (int i = 0; i < jsonArray.length(); i++) {
            result.add(jsonArray.getString(i));
        }

        return result;
    }

    public static void setAppEventAttributionParameters(
            JSONObject params,
            AttributionIdentifiers attributionIdentifiers,
            String anonymousAppDeviceGUID,
            boolean limitEventUsage) throws JSONException {
        if (attributionIdentifiers != null && attributionIdentifiers.getAttributionId() != null) {
            params.put("attribution", attributionIdentifiers.getAttributionId());
        }

        if (attributionIdentifiers != null &&
                attributionIdentifiers.getAndroidAdvertiserId() != null) {
            params.put("advertiser_id", attributionIdentifiers.getAndroidAdvertiserId());
            params.put("advertiser_tracking_enabled", !attributionIdentifiers.isTrackingLimited());
        }

        if (attributionIdentifiers != null &&
                attributionIdentifiers.getAndroidInstallerPackage() != null) {
            params.put("installer_package", attributionIdentifiers.getAndroidInstallerPackage());
        }

        params.put("anon_id", anonymousAppDeviceGUID);
        params.put("application_tracking_enabled", !limitEventUsage);
    }

    public static void setAppEventExtendedDeviceInfoParameters(
            JSONObject params,
            Context appContext
    ) throws JSONException {
        JSONArray extraInfoArray = new JSONArray();
        extraInfoArray.put(EXTRA_APP_EVENTS_INFO_FORMAT_VERSION);

        Utility.refreshPeriodicExtendedDeviceInfo(appContext);

        
        String pkgName = appContext.getPackageName();
        int versionCode = -1;
        String versionName = "";

        try {
            PackageInfo pi = appContext.getPackageManager().getPackageInfo(pkgName, 0);
            versionCode = pi.versionCode;
            versionName = pi.versionName;
        } catch (PackageManager.NameNotFoundException e) {
            
        }

        
        extraInfoArray.put(pkgName);
        extraInfoArray.put(versionCode);
        extraInfoArray.put(versionName);

        
        extraInfoArray.put(Build.VERSION.RELEASE);
        extraInfoArray.put(Build.MODEL);

        
        Locale locale = null;
        try {
            locale = appContext.getResources().getConfiguration().locale;
        } catch (Exception e) {
            locale = Locale.getDefault();
        }
        extraInfoArray.put(locale.getLanguage() + "_" + locale.getCountry());

        
        extraInfoArray.put(deviceTimezone);

        
        extraInfoArray.put(carrierName);

        
        int width = 0;
        int height = 0;
        double density = 0;
        try {
            WindowManager wm = (WindowManager) appContext.getSystemService(Context.WINDOW_SERVICE);
            if (wm != null) {
                Display display = wm.getDefaultDisplay();
                DisplayMetrics displayMetrics = new DisplayMetrics();
                display.getMetrics(displayMetrics);
                width = displayMetrics.widthPixels;
                height = displayMetrics.heightPixels;
                density = displayMetrics.density;
            }
        } catch (Exception e) {
            
        }
        extraInfoArray.put(width);
        extraInfoArray.put(height);
        extraInfoArray.put(String.format("%.2f", density));

        
        extraInfoArray.put(refreshBestGuessNumberOfCPUCores());

        
        extraInfoArray.put(totalExternalStorageGB);
        extraInfoArray.put(availableExternalStorageGB);

        params.put("extinfo", extraInfoArray.toString());
    }

    public static Method getMethodQuietly(
            Class<?> clazz,
            String methodName,
            Class<?>... parameterTypes) {
        try {
            return clazz.getMethod(methodName, parameterTypes);
        } catch (NoSuchMethodException ex) {
            return null;
        }
    }

    public static Method getMethodQuietly(
            String className,
            String methodName,
            Class<?>... parameterTypes) {
        try {
            Class<?> clazz = Class.forName(className);
            return getMethodQuietly(clazz, methodName, parameterTypes);
        } catch (ClassNotFoundException ex) {
            return null;
        }
    }

    public static Object invokeMethodQuietly(Object receiver, Method method, Object... args) {
        try {
            return method.invoke(receiver, args);
        } catch (IllegalAccessException ex) {
            return null;
        } catch (InvocationTargetException ex) {
            return null;
        }
    }

    
    public static String getActivityName(Context context) {
        if (context == null) {
            return "null";
        } else if (context == context.getApplicationContext()) {
            return "unknown";
        } else {
            return context.getClass().getSimpleName();
        }
    }

    public interface Predicate<T> {
        public boolean apply(T item);
    }

    public static <T> List<T> filter(final List<T> target, final Predicate<T> predicate) {
        if (target == null) {
            return null;
        }
        final List<T> list = new ArrayList<T>();
        for (T item : target) {
            if (predicate.apply(item)) {
                list.add(item);
            }
        }
        return (list.size() == 0 ? null : list);
    }

    public interface Mapper<T, K> {
        public K apply(T item);
    }

    public static <T, K> List<K> map(final List<T> target, final Mapper<T, K> mapper) {
        if (target == null) {
            return null;
        }
        final List<K> list = new ArrayList<K>();
        for (T item : target) {
            final K mappedItem = mapper.apply(item);
            if (mappedItem != null) {
                list.add(mappedItem);
            }
        }
        return (list.size() == 0 ? null : list);
    }

    public static String getUriString(final Uri uri) {
        return (uri == null ? null : uri.toString());
    }

    public static boolean isWebUri(final Uri uri) {
        return (uri != null)
                && ("http".equalsIgnoreCase(uri.getScheme())
                || "https".equalsIgnoreCase(uri.getScheme()));
    }

    public static boolean isContentUri(final Uri uri) {
        return (uri != null) && ("content".equalsIgnoreCase(uri.getScheme()));
    }

    public static boolean isFileUri(final Uri uri) {
        return (uri != null) && ("file".equalsIgnoreCase(uri.getScheme()));
    }

    public static long getContentSize(final Uri contentUri) {
        Cursor cursor = null;
        try {
            cursor = FacebookSdk
                    .getApplicationContext()
                    .getContentResolver()
                    .query(contentUri, null, null, null, null);
            int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);

            cursor.moveToFirst();
            return cursor.getLong(sizeIndex);
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
    }

    public static Date getBundleLongAsDate(Bundle bundle, String key, Date dateBase) {
        if (bundle == null) {
            return null;
        }

        long secondsFromBase = Long.MIN_VALUE;

        Object secondsObject = bundle.get(key);
        if (secondsObject instanceof Long) {
            secondsFromBase = (Long) secondsObject;
        } else if (secondsObject instanceof String) {
            try {
                secondsFromBase = Long.parseLong((String) secondsObject);
            } catch (NumberFormatException e) {
                return null;
            }
        } else {
            return null;
        }

        if (secondsFromBase == 0) {
            return new Date(Long.MAX_VALUE);
        } else {
            return new Date(dateBase.getTime() + (secondsFromBase * 1000L));
        }
    }

    public static void writeStringMapToParcel(Parcel parcel, final Map<String, String> map) {
        if (map == null) {
            
            parcel.writeInt(-1);
        } else {
            parcel.writeInt(map.size());
            for (Map.Entry<String, String> entry : map.entrySet()) {
                parcel.writeString(entry.getKey());
                parcel.writeString(entry.getValue());
            }
        }
    }

    public static Map<String, String> readStringMapFromParcel(Parcel parcel) {
        int size = parcel.readInt();
        if (size < 0) {
            return null;
        }
        Map<String, String> map = new HashMap<>();
        for (int i = 0; i < size; i++) {
            map.put(parcel.readString(), parcel.readString());
        }
        return map;
    }

    public static boolean isCurrentAccessToken(AccessToken token) {
        return token != null ? token.equals(AccessToken.getCurrentAccessToken()) : false;
    }

    public interface GraphMeRequestWithCacheCallback {
        void onSuccess(JSONObject userInfo);

        void onFailure(FacebookException error);
    }

    public static void getGraphMeRequestWithCacheAsync(
            final String accessToken,
            final GraphMeRequestWithCacheCallback callback) {
        JSONObject cachedValue = ProfileInformationCache.getProfileInformation(accessToken);
        if (cachedValue != null) {
            callback.onSuccess(cachedValue);
            return;
        }

        GraphRequest.Callback graphCallback = new GraphRequest.Callback() {
            @Override
            public void onCompleted(GraphResponse response) {
                if (response.getError() != null) {
                    callback.onFailure(response.getError().getException());
                } else {
                    ProfileInformationCache.putProfileInformation(
                            accessToken,
                            response.getJSONObject());
                    callback.onSuccess(response.getJSONObject());
                }
            }
        };
        GraphRequest graphRequest = getGraphMeRequestWithCache(accessToken);
        graphRequest.setCallback(graphCallback);
        graphRequest.executeAsync();
    }

    public static JSONObject awaitGetGraphMeRequestWithCache(
            final String accessToken) {
        JSONObject cachedValue = ProfileInformationCache.getProfileInformation(accessToken);
        if (cachedValue != null) {
            return cachedValue;
        }

        GraphRequest graphRequest = getGraphMeRequestWithCache(accessToken);
        GraphResponse response = graphRequest.executeAndWait();
        if (response.getError() != null) {
            return null;
        }

        return response.getJSONObject();
    }

    private static GraphRequest getGraphMeRequestWithCache(
            final String accessToken) {
        Bundle parameters = new Bundle();
        parameters.putString("fields", "id,name,first_name,middle_name,last_name,link");
        parameters.putString("access_token", accessToken);
        GraphRequest graphRequest = new GraphRequest(
                null,
                "me",
                parameters,
                HttpMethod.GET,
                null);
        return graphRequest;
    }

    
    private static int refreshBestGuessNumberOfCPUCores() {
        
        if (numCPUCores > 0) {
            return numCPUCores;
        }

        
        
        if (Build.VERSION.SDK_INT <= Utility.GINGERBREAD_MR1) {
            numCPUCores = 1;
            return numCPUCores;
        }

        
        try {
            int res = 0;
            File cpuDir = new File("/sys/devices/system/cpu/");
            File[] cpuFiles = cpuDir.listFiles(new FilenameFilter() {
                @Override
                public boolean accept(File dir, String fileName) {
                    return Pattern.matches("cpu[0-9]+", fileName);
                }
            });

            numCPUCores = cpuFiles.length;
        } catch (Exception e) {
        }

        
        
        if (numCPUCores <= 0) {
            numCPUCores = Math.max(Runtime.getRuntime().availableProcessors(), 1);
        }
        return numCPUCores;
    }

    private static void refreshPeriodicExtendedDeviceInfo(Context appContext) {
        if (timestampOfLastCheck == -1 ||
                (System.currentTimeMillis() - timestampOfLastCheck) >=
                        Utility.REFRESH_TIME_FOR_EXTENDED_DEVICE_INFO_MILLIS) {
            timestampOfLastCheck = System.currentTimeMillis();
            Utility.refreshTimezone();
            Utility.refreshCarrierName(appContext);
            Utility.refreshTotalExternalStorage();
            Utility.refreshAvailableExternalStorage();
        }
    }

    private static void refreshTimezone() {
        try {
            TimeZone tz = TimeZone.getDefault();
            deviceTimezone = tz.getDisplayName(tz.inDaylightTime(new Date()), TimeZone.SHORT);
        } catch (Exception e) {
        }
    }

    
    private static void refreshCarrierName(Context appContext) {
        if (carrierName.equals(noCarrierConstant)) {
            try {
                TelephonyManager telephonyManager =
                        ((TelephonyManager) appContext.getSystemService(Context.TELEPHONY_SERVICE));
                carrierName = telephonyManager.getNetworkOperatorName();
            } catch (Exception e) {
            }
        }
    }

    
    private static boolean externalStorageExists() {
        return Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState());
    }

    
    @SuppressWarnings("deprecation")
    private static void refreshAvailableExternalStorage() {
        try {
            if (externalStorageExists()) {
                File path = Environment.getExternalStorageDirectory();
                StatFs stat = new StatFs(path.getPath());
                availableExternalStorageGB =
                        (long)stat.getAvailableBlocks() * (long)stat.getBlockSize();
            }
            availableExternalStorageGB =
                    Utility.convertBytesToGB(availableExternalStorageGB);
        } catch (Exception e) {
            
        }
    }

    
    @SuppressWarnings("deprecation")
    private static void refreshTotalExternalStorage() {
        try {
            if (externalStorageExists()) {
                File path = Environment.getExternalStorageDirectory();
                StatFs stat = new StatFs(path.getPath());
                totalExternalStorageGB = (long)stat.getBlockCount() * (long)stat.getBlockSize();
            }
            totalExternalStorageGB = Utility.convertBytesToGB(totalExternalStorageGB);
        } catch (Exception e) {
            
        }
    }

    private static long convertBytesToGB(double bytes) {
        return Math.round(bytes / (1024.0 * 1024.0 * 1024.0));
    }
}

<code block>


package com.facebook.internal;

import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.content.pm.PackageManager;
import android.database.Cursor;
import android.net.Uri;
import android.os.Binder;
import android.os.IBinder;
import android.os.IInterface;
import android.os.Looper;
import android.os.Parcel;
import android.os.RemoteException;
import android.support.annotation.Nullable;
import android.util.Log;

import com.facebook.FacebookException;

import java.lang.reflect.Method;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.atomic.AtomicBoolean;


public class AttributionIdentifiers {
    private static final String TAG = AttributionIdentifiers.class.getCanonicalName();
    private static final String ATTRIBUTION_ID_CONTENT_PROVIDER =
            "com.facebook.katana.provider.AttributionIdProvider";
    private static final String ATTRIBUTION_ID_CONTENT_PROVIDER_WAKIZASHI =
            "com.facebook.wakizashi.provider.AttributionIdProvider";
    private static final String ATTRIBUTION_ID_COLUMN_NAME = "aid";
    private static final String ANDROID_ID_COLUMN_NAME = "androidid";
    private static final String LIMIT_TRACKING_COLUMN_NAME = "limit_tracking";

    
    private static final int CONNECTION_RESULT_SUCCESS = 0;

    private static final long IDENTIFIER_REFRESH_INTERVAL_MILLIS = 3600 * 1000;

    private String attributionId;
    private String androidAdvertiserId;
    private String androidInstallerPackage;
    private boolean limitTracking;
    private long fetchTime;

    private static AttributionIdentifiers recentlyFetchedIdentifiers;

    private static AttributionIdentifiers getAndroidId(Context context) {
        AttributionIdentifiers identifiers = getAndroidIdViaReflection(context);
        if (identifiers == null) {
            identifiers = getAndroidIdViaService(context);
            if (identifiers == null) {
                identifiers = new AttributionIdentifiers();
            }
        }
        return identifiers;
    }

    private static AttributionIdentifiers getAndroidIdViaReflection(Context context) {
        try {
            
            
            if (Looper.myLooper() == Looper.getMainLooper()) {
              throw new FacebookException("getAndroidId cannot be called on the main thread.");
            }
            Method isGooglePlayServicesAvailable = Utility.getMethodQuietly(
                    "com.google.android.gms.common.GooglePlayServicesUtil",
                    "isGooglePlayServicesAvailable",
                    Context.class
            );

            if (isGooglePlayServicesAvailable == null) {
                return null;
            }

            Object connectionResult = Utility.invokeMethodQuietly(
                    null, isGooglePlayServicesAvailable, context);
            if (!(connectionResult instanceof Integer)
                    || (Integer) connectionResult != CONNECTION_RESULT_SUCCESS) {
                return null;
            }

            Method getAdvertisingIdInfo = Utility.getMethodQuietly(
                    "com.google.android.gms.ads.identifier.AdvertisingIdClient",
                    "getAdvertisingIdInfo",
                    Context.class
            );
            if (getAdvertisingIdInfo == null) {
                return null;
            }
            Object advertisingInfo = Utility.invokeMethodQuietly(
                    null, getAdvertisingIdInfo, context);
            if (advertisingInfo == null) {
                return null;
            }

            Method getId = Utility.getMethodQuietly(advertisingInfo.getClass(), "getId");
            Method isLimitAdTrackingEnabled = Utility.getMethodQuietly(
                    advertisingInfo.getClass(),
                    "isLimitAdTrackingEnabled");
            if (getId == null || isLimitAdTrackingEnabled == null) {
                return null;
            }

            AttributionIdentifiers identifiers = new AttributionIdentifiers();
            identifiers.androidAdvertiserId =
                    (String) Utility.invokeMethodQuietly(advertisingInfo, getId);
            identifiers.limitTracking = (Boolean) Utility.invokeMethodQuietly(
                    advertisingInfo,
                    isLimitAdTrackingEnabled);
        } catch (Exception e) {
            Utility.logd("android_id", e);
        }
        return null;
    }

    private static AttributionIdentifiers getAndroidIdViaService(Context context) {
        GoogleAdServiceConnection connection = new GoogleAdServiceConnection();
        Intent intent = new Intent("com.google.android.gms.ads.identifier.service.START");
        intent.setPackage("com.google.android.gms");
        if(context.bindService(intent, connection, Context.BIND_AUTO_CREATE)) {
            try {
                GoogleAdInfo adInfo = new GoogleAdInfo(connection.getBinder());
                AttributionIdentifiers identifiers = new AttributionIdentifiers();
                identifiers.androidAdvertiserId = adInfo.getAdvertiserId();
                identifiers.limitTracking = adInfo.isTrackingLimited();
                return identifiers;
            } catch (Exception exception) {
                Utility.logd("android_id", exception);
            } finally {
                context.unbindService(connection);
            }
        }
        return null;
    }

    public static AttributionIdentifiers getAttributionIdentifiers(Context context) {
        if (recentlyFetchedIdentifiers != null &&
            System.currentTimeMillis() - recentlyFetchedIdentifiers.fetchTime <
                    IDENTIFIER_REFRESH_INTERVAL_MILLIS) {
            return recentlyFetchedIdentifiers;
        }

        AttributionIdentifiers identifiers = getAndroidId(context);
        Cursor c = null;
        try {
            String [] projection = {
                    ATTRIBUTION_ID_COLUMN_NAME,
                    ANDROID_ID_COLUMN_NAME,
                    LIMIT_TRACKING_COLUMN_NAME};
            Uri providerUri = null;
            if (context.getPackageManager().resolveContentProvider(
                    ATTRIBUTION_ID_CONTENT_PROVIDER, 0) != null) {
                providerUri = Uri.parse("content:
            } else if (context.getPackageManager().resolveContentProvider(
                    ATTRIBUTION_ID_CONTENT_PROVIDER_WAKIZASHI, 0) != null) {
                providerUri = Uri.parse("content:
            }
            String installerPackageName = getInstallerPackageName(context);
            if (installerPackageName != null) {
                identifiers.androidInstallerPackage = installerPackageName;
            }
            if (providerUri == null) {
                return identifiers;
            }
            c = context.getContentResolver().query(providerUri, projection, null, null, null);
            if (c == null || !c.moveToFirst()) {
                return identifiers;
            }
            int attributionColumnIndex = c.getColumnIndex(ATTRIBUTION_ID_COLUMN_NAME);
            int androidIdColumnIndex = c.getColumnIndex(ANDROID_ID_COLUMN_NAME);
            int limitTrackingColumnIndex = c.getColumnIndex(LIMIT_TRACKING_COLUMN_NAME);

            identifiers.attributionId = c.getString(attributionColumnIndex);

            
            
            if (androidIdColumnIndex > 0 && limitTrackingColumnIndex > 0 &&
                    identifiers.getAndroidAdvertiserId() == null) {
                identifiers.androidAdvertiserId = c.getString(androidIdColumnIndex);
                identifiers.limitTracking =
                        Boolean.parseBoolean(c.getString(limitTrackingColumnIndex));
            }
        } catch (Exception e) {
            Log.d(TAG, "Caught unexpected exception in getAttributionId(): " + e.toString());
            return null;
        } finally {
            if (c != null) {
                c.close();
            }
        }

        identifiers.fetchTime = System.currentTimeMillis();
        recentlyFetchedIdentifiers = identifiers;
        return identifiers;
    }

    public String getAttributionId() {
        return attributionId;
    }

    public String getAndroidAdvertiserId() {
        return androidAdvertiserId;
    }

    public String getAndroidInstallerPackage() {
        return androidInstallerPackage;
    }

    public boolean isTrackingLimited() {
        return limitTracking;
    }

    @Nullable
    private static String getInstallerPackageName(Context context) {
        PackageManager packageManager = context.getPackageManager();
        if (packageManager != null) {
            return packageManager.getInstallerPackageName(context.getPackageName());
        }
        return null;
    }

    private static final class GoogleAdServiceConnection implements ServiceConnection {
        private AtomicBoolean consumed = new AtomicBoolean(false);
        private final BlockingQueue<IBinder> queue = new LinkedBlockingDeque<>();

        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            try {
                queue.put(service);
            } catch (InterruptedException e) {
            }
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
        }

        public IBinder getBinder() throws InterruptedException {
            if (consumed.compareAndSet(true, true)) {
                throw new IllegalStateException("Binder already consumed");
            }
            return queue.take();
        }
    }

    private static final class GoogleAdInfo implements IInterface {
        private static final int FIRST_TRANSACTION_CODE = Binder.FIRST_CALL_TRANSACTION;
        private static final int SECOND_TRANSACTION_CODE = FIRST_TRANSACTION_CODE + 1;

        private IBinder binder;

        GoogleAdInfo(IBinder binder) {
            this.binder = binder;
        }

        @Override
        public IBinder asBinder() {
            return binder;
        }

        public String getAdvertiserId() throws RemoteException {
            Parcel data = Parcel.obtain();
            Parcel reply = Parcel.obtain();
            String id;
            try {
                data.writeInterfaceToken(
                        "com.google.android.gms.ads.identifier.internal.IAdvertisingIdService");
                binder.transact(FIRST_TRANSACTION_CODE, data, reply, 0);
                reply.readException();
                id = reply.readString();
            } finally {
                reply.recycle();
                data.recycle();
            }
            return id;
        }

        public boolean isTrackingLimited() throws RemoteException {
            Parcel data = Parcel.obtain();
            Parcel reply = Parcel.obtain();
            boolean limitAdTracking;
            try {
                data.writeInterfaceToken(
                        "com.google.android.gms.ads.identifier.internal.IAdvertisingIdService");
                data.writeInt(1);
                binder.transact(SECOND_TRANSACTION_CODE, data, reply, 0);
                reply.readException();
                limitAdTracking = 0 != reply.readInt();
            } finally {
                reply.recycle();
                data.recycle();
            }
            return limitAdTracking;
        }
    }
}

<code block>


package com.facebook.internal;

import android.content.Context;
import android.os.Bundle;
import android.util.Log;

import com.facebook.FacebookSdk;
import com.facebook.LoggingBehavior;

import org.json.JSONException;
import org.json.JSONObject;

import java.util.Collection;


public final class ServerProtocol {
    private static final String TAG = ServerProtocol.class.getName();

    private static final String DIALOG_AUTHORITY_FORMAT = "m.%s";
    public static final String DIALOG_PATH = "dialog/";
    public static final String DIALOG_PARAM_ACCESS_TOKEN = "access_token";
    public static final String DIALOG_PARAM_APP_ID = "app_id";
    public static final String DIALOG_PARAM_AUTH_TYPE = "auth_type";
    public static final String DIALOG_PARAM_CLIENT_ID = "client_id";
    public static final String DIALOG_PARAM_DISPLAY = "display";
    public static final String DIALOG_PARAM_DISPLAY_TOUCH = "touch";
    public static final String DIALOG_PARAM_E2E = "e2e";
    public static final String DIALOG_PARAM_LEGACY_OVERRIDE = "legacy_override";
    public static final String DIALOG_PARAM_REDIRECT_URI = "redirect_uri";
    public static final String DIALOG_PARAM_RESPONSE_TYPE = "response_type";
    public static final String DIALOG_PARAM_RETURN_SCOPES = "return_scopes";
    public static final String DIALOG_PARAM_SCOPE = "scope";
    public static final String DIALOG_PARAM_DEFAULT_AUDIENCE = "default_audience";
    public static final String DIALOG_REREQUEST_AUTH_TYPE = "rerequest";
    public static final String DIALOG_RESPONSE_TYPE_TOKEN_AND_SIGNED_REQUEST
            = "token,signed_request";
    public static final String DIALOG_RETURN_SCOPES_TRUE = "true";
    public static final String DIALOG_REDIRECT_URI = "fbconnect:
    public static final String DIALOG_CANCEL_URI = "fbconnect:

    public static final String FALLBACK_DIALOG_PARAM_APP_ID = "app_id";
    public static final String FALLBACK_DIALOG_PARAM_BRIDGE_ARGS = "bridge_args";
    public static final String FALLBACK_DIALOG_PARAM_KEY_HASH = "android_key_hash";
    public static final String FALLBACK_DIALOG_PARAM_METHOD_ARGS = "method_args";
    public static final String FALLBACK_DIALOG_PARAM_METHOD_RESULTS = "method_results";
    public static final String FALLBACK_DIALOG_PARAM_VERSION = "version";
    public static final String FALLBACK_DIALOG_DISPLAY_VALUE_TOUCH = "touch";

    
    private static final String GRAPH_VIDEO_URL_FORMAT = "https:
    private static final String GRAPH_URL_FORMAT = "https:
    public static final String GRAPH_API_VERSION = "v2.4";

    public static final Collection<String> errorsProxyAuthDisabled =
            Utility.unmodifiableCollection("service_disabled", "AndroidAuthKillSwitchException");
    public static final Collection<String> errorsUserCanceled =
            Utility.unmodifiableCollection("access_denied", "OAuthAccessDeniedException");
    public static final String errorConnectionFailure = "CONNECTION_FAILURE";

    public static final String getDialogAuthority() {
        return String.format(DIALOG_AUTHORITY_FORMAT, FacebookSdk.getFacebookDomain());
    }

    public static final String getGraphUrlBase() {
        return String.format(GRAPH_URL_FORMAT, FacebookSdk.getFacebookDomain());
    }

    public static final String getGraphVideoUrlBase() {
        return String.format(GRAPH_VIDEO_URL_FORMAT, FacebookSdk.getFacebookDomain());
    }

    public static final String getAPIVersion() {
        return GRAPH_API_VERSION;
    }

    public static Bundle getQueryParamsForPlatformActivityIntentWebFallback(
            String callId,
            int version,
            Bundle methodArgs) {

        Context context = FacebookSdk.getApplicationContext();
        String keyHash = FacebookSdk.getApplicationSignature(context);
        if (Utility.isNullOrEmpty(keyHash)) {
            return null;
        }

        Bundle webParams = new Bundle();

        webParams.putString(FALLBACK_DIALOG_PARAM_KEY_HASH, keyHash);
        webParams.putString(FALLBACK_DIALOG_PARAM_APP_ID, FacebookSdk.getApplicationId());
        webParams.putInt(FALLBACK_DIALOG_PARAM_VERSION, version);
        webParams.putString(DIALOG_PARAM_DISPLAY, FALLBACK_DIALOG_DISPLAY_VALUE_TOUCH);

        Bundle bridgeArguments = new Bundle();
        bridgeArguments.putString(NativeProtocol.BRIDGE_ARG_ACTION_ID_STRING, callId);

        methodArgs = (methodArgs == null) ? new Bundle() : methodArgs;

        try {
            JSONObject bridgeArgsJSON = BundleJSONConverter.convertToJSON(bridgeArguments);
            JSONObject methodArgsJSON = BundleJSONConverter.convertToJSON(methodArgs);

            if (bridgeArgsJSON == null || methodArgsJSON == null) {
                return null;
            }

            webParams.putString(FALLBACK_DIALOG_PARAM_BRIDGE_ARGS, bridgeArgsJSON.toString());
            webParams.putString(FALLBACK_DIALOG_PARAM_METHOD_ARGS, methodArgsJSON.toString());
        } catch (JSONException je) {
            webParams = null;
            Logger.log(LoggingBehavior.DEVELOPER_ERRORS, Log.ERROR, TAG,
                    "Error creating Url -- " + je);
        }

        return webParams;
    }
}

<code block>


package com.facebook.share;

import android.graphics.Bitmap;
import android.net.Uri;
import android.os.Bundle;
import android.text.TextUtils;
import android.util.Log;

import com.facebook.AccessToken;
import com.facebook.FacebookCallback;
import com.facebook.FacebookException;
import com.facebook.FacebookGraphResponseException;
import com.facebook.FacebookRequestError;
import com.facebook.GraphRequest;
import com.facebook.GraphResponse;
import com.facebook.HttpMethod;
import com.facebook.internal.CollectionMapper;
import com.facebook.internal.Mutable;
import com.facebook.internal.Utility;
import com.facebook.share.internal.ShareContentValidation;
import com.facebook.share.internal.ShareInternalUtility;
import com.facebook.share.internal.VideoUploader;
import com.facebook.share.model.*;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.FileNotFoundException;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.*;


public final class ShareApi {
    private static final String TAG = "ShareApi";
    private static final String DEFAULT_GRAPH_NODE = "me";
    private static final String PHOTOS_EDGE = "photos";
    private static final String GRAPH_PATH_FORMAT = "%s/%s";
    private static final String DEFAULT_CHARSET = "UTF-8";

    private String message;
    private String graphNode;
    private final ShareContent shareContent;

    
    public static void share(
            final ShareContent shareContent,
            final FacebookCallback<Sharer.Result> callback) {
        new ShareApi(shareContent)
                .share(callback);
    }

    
    public ShareApi(final ShareContent shareContent) {
        this.shareContent = shareContent;
        this.graphNode = DEFAULT_GRAPH_NODE;
    }

    
    public String getMessage() {
        return this.message;
    }

    
    public void setMessage(final String message) {
        this.message = message;
    }

    
    public String getGraphNode() {
        return this.graphNode;
    }

    
    public void setGraphNode(final String graphNode) {
        this.graphNode = graphNode;
    }

    
    public ShareContent getShareContent() {
        return this.shareContent;
    }

    
    public boolean canShare() {
        if (this.getShareContent() == null) {
            return false;
        }
        final AccessToken accessToken = AccessToken.getCurrentAccessToken();
        if (accessToken == null) {
            return false;
        }
        final Set<String> permissions = accessToken.getPermissions();
        if (permissions == null || !permissions.contains("publish_actions")) {
            Log.w(TAG, "The publish_actions permissions are missing, the share will fail unless" +
                    " this app was authorized to publish in another installation.");
        }

        return true;
    }

    
    public void share(FacebookCallback<Sharer.Result> callback) {
        if (!this.canShare()) {
            ShareInternalUtility.invokeCallbackWithError(
                    callback, "Insufficient permissions for sharing content via Api.");
            return;
        }
        final ShareContent shareContent = this.getShareContent();

        
        try {
            ShareContentValidation.validateForApiShare(shareContent);
        } catch (FacebookException ex) {
            ShareInternalUtility.invokeCallbackWithException(callback, ex);
            return;
        }

        if (shareContent instanceof ShareLinkContent) {
            this.shareLinkContent((ShareLinkContent) shareContent, callback);
        } else if (shareContent instanceof SharePhotoContent) {
            this.sharePhotoContent((SharePhotoContent) shareContent, callback);
        } else if (shareContent instanceof ShareVideoContent) {
            this.shareVideoContent((ShareVideoContent) shareContent, callback);
        } else if (shareContent instanceof ShareOpenGraphContent) {
            this.shareOpenGraphContent((ShareOpenGraphContent) shareContent, callback);
        }
    }

    
    private String getGraphPath(final String pathAfterGraphNode) {
        try {
            return String.format(
                    Locale.ROOT, GRAPH_PATH_FORMAT,
                    URLEncoder.encode(getGraphNode(), DEFAULT_CHARSET),
                    pathAfterGraphNode);
        } catch (UnsupportedEncodingException e) {
            return null;
        }
    }

    private void addCommonParameters(final Bundle bundle, ShareContent shareContent) {
        final List<String> peopleIds = shareContent.getPeopleIds();
        if (!Utility.isNullOrEmpty(peopleIds)) {
            bundle.putString("tags", TextUtils.join(", ", peopleIds));
        }

        if (!Utility.isNullOrEmpty(shareContent.getPlaceId())) {
            bundle.putString("place", shareContent.getPlaceId());
        }

        if (!Utility.isNullOrEmpty(shareContent.getRef())) {
            bundle.putString("ref", shareContent.getRef());
        }
    }

    private void shareOpenGraphContent(final ShareOpenGraphContent openGraphContent,
                                       final FacebookCallback<Sharer.Result> callback) {
        
        
        
        
        
        final GraphRequest.Callback requestCallback = new GraphRequest.Callback() {
            @Override
            public void onCompleted(GraphResponse response) {
                final JSONObject data = response.getJSONObject();
                final String postId = (data == null ? null : data.optString("id"));
                ShareInternalUtility.invokeCallbackWithResults(callback, postId, response);
            }
        };
        final ShareOpenGraphAction action = openGraphContent.getAction();
        final Bundle parameters = action.getBundle();
        this.addCommonParameters(parameters, openGraphContent);
        if (!Utility.isNullOrEmpty(this.getMessage())) {
            parameters.putString("message", this.getMessage());
        }

        final CollectionMapper.OnMapperCompleteListener stageCallback = new CollectionMapper
                .OnMapperCompleteListener() {
            @Override
            public void onComplete() {
                try {
                    handleImagesOnAction(parameters);

                    new GraphRequest(
                            AccessToken.getCurrentAccessToken(),
                            getGraphPath(
                                    URLEncoder.encode(action.getActionType(), DEFAULT_CHARSET)),
                            parameters,
                            HttpMethod.POST,
                            requestCallback).executeAsync();
                } catch (final UnsupportedEncodingException ex) {
                    ShareInternalUtility.invokeCallbackWithException(callback, ex);
                }
            }

            @Override
            public void onError(FacebookException exception) {
                ShareInternalUtility.invokeCallbackWithException(callback, exception);
            }
        };
        this.stageOpenGraphAction(parameters, stageCallback);
    }

    private static void handleImagesOnAction(Bundle parameters) {
        
        
        
        String imageStr = parameters.getString("image");
        if (imageStr != null) {
            try {
                
                JSONArray images = new JSONArray(imageStr);
                for (int i = 0; i < images.length(); ++i) {
                    JSONObject jsonImage = images.optJSONObject(i);
                    if(jsonImage != null) {
                        putImageInBundleWithArrayFormat(parameters, i, jsonImage);
                    } else {
                        
                        String url = images.getString(i);
                        parameters.putString(String.format(Locale.ROOT, "image[%d][url]", i), url);
                    }
                }
                parameters.remove("image");
                return;
            } catch (JSONException ex) {
                
            }

            
            try {
                JSONObject image = new JSONObject(imageStr);
                putImageInBundleWithArrayFormat(parameters, 0, image);
                parameters.remove("image");
            } catch (JSONException exception) {
                
                
            }
        }
    }

    private static void putImageInBundleWithArrayFormat(
            Bundle parameters,
            int index,
            JSONObject image) throws JSONException{
        Iterator<String> keys = image.keys();
        while (keys.hasNext()) {
            String property = keys.next();
            String key = String.format(Locale.ROOT, "image[%d][%s]", index, property);
            parameters.putString(key, image.get(property).toString());
        }
    }

    private void sharePhotoContent(final SharePhotoContent photoContent,
                                   final FacebookCallback<Sharer.Result> callback) {
        final Mutable<Integer> requestCount = new Mutable<Integer>(0);
        final AccessToken accessToken = AccessToken.getCurrentAccessToken();
        final ArrayList<GraphRequest> requests = new ArrayList<GraphRequest>();
        final ArrayList<JSONObject> results = new ArrayList<JSONObject>();
        final ArrayList<GraphResponse> errorResponses = new ArrayList<GraphResponse>();
        final GraphRequest.Callback requestCallback = new GraphRequest.Callback() {
            @Override
            public void onCompleted(GraphResponse response) {
                final JSONObject result = response.getJSONObject();
                if (result != null) {
                    results.add(result);
                }
                if (response.getError() != null) {
                    errorResponses.add(response);
                }
                requestCount.value -= 1;
                if (requestCount.value == 0) {
                    if (!errorResponses.isEmpty()) {
                        ShareInternalUtility.invokeCallbackWithResults(
                                callback,
                                null,
                                errorResponses.get(0));
                    } else if (!results.isEmpty()) {
                        final String postId = results.get(0).optString("id");
                        ShareInternalUtility.invokeCallbackWithResults(
                                callback,
                                postId,
                                response);
                    }
                }
            }
        };
        try {
            for (SharePhoto photo : photoContent.getPhotos()) {
                final Bitmap bitmap = photo.getBitmap();
                final Uri photoUri = photo.getImageUrl();
                String caption = photo.getCaption();
                if (caption == null) {
                    caption = this.getMessage();
                }
                if (bitmap != null) {
                    requests.add(GraphRequest.newUploadPhotoRequest(
                            accessToken,
                            getGraphPath(PHOTOS_EDGE),
                            bitmap,
                            caption,
                            photo.getParameters(),
                            requestCallback));
                } else if (photoUri != null) {
                    requests.add(GraphRequest.newUploadPhotoRequest(
                            accessToken,
                            getGraphPath(PHOTOS_EDGE),
                            photoUri,
                            caption,
                            photo.getParameters(),
                            requestCallback));
                }
            }
            requestCount.value += requests.size();
            for (GraphRequest request : requests) {
                request.executeAsync();
            }
        } catch (final FileNotFoundException ex) {
            ShareInternalUtility.invokeCallbackWithException(callback, ex);
        }
    }

    private void shareLinkContent(final ShareLinkContent linkContent,
                                  final FacebookCallback<Sharer.Result> callback) {
        final GraphRequest.Callback requestCallback = new GraphRequest.Callback() {
            @Override
            public void onCompleted(GraphResponse response) {
                final JSONObject data = response.getJSONObject();
                final String postId = (data == null ? null : data.optString("id"));
                ShareInternalUtility.invokeCallbackWithResults(callback, postId, response);
            }
        };
        final Bundle parameters = new Bundle();
        this.addCommonParameters(parameters, linkContent);
        parameters.putString("message", this.getMessage());
        parameters.putString("link", Utility.getUriString(linkContent.getContentUrl()));
        parameters.putString("picture", Utility.getUriString(linkContent.getImageUrl()));
        parameters.putString("name", linkContent.getContentTitle());
        parameters.putString("description", linkContent.getContentDescription());
        parameters.putString("ref", linkContent.getRef());
        new GraphRequest(
                AccessToken.getCurrentAccessToken(),
                getGraphPath("feed"),
                parameters,
                HttpMethod.POST,
                requestCallback).executeAsync();
    }

    private void shareVideoContent(final ShareVideoContent videoContent,
                                   final FacebookCallback<Sharer.Result> callback) {
        try {
            VideoUploader.uploadAsync(videoContent, getGraphNode(), callback);
        } catch (final FileNotFoundException ex) {
            ShareInternalUtility.invokeCallbackWithException(callback, ex);
        }
    }

    private void stageArrayList(final ArrayList arrayList,
                                       final CollectionMapper.OnMapValueCompleteListener
                                               onArrayListStagedListener) {
        final JSONArray stagedObject = new JSONArray();
        final CollectionMapper.Collection<Integer> collection = new CollectionMapper
                .Collection<Integer>() {
            @Override
            public Iterator<Integer> keyIterator() {
                final int size = arrayList.size();
                final Mutable<Integer> current = new Mutable<Integer>(0);
                return new Iterator<Integer>() {
                    @Override
                    public boolean hasNext() {
                        return current.value < size;
                    }

                    @Override
                    public Integer next() {
                        return current.value++;
                    }

                    @Override
                    public void remove() {
                    }
                };
            }

            @Override
            public Object get(Integer key) {
                return arrayList.get(key);
            }

            @Override
            public void set(Integer key,
                            Object value,
                            CollectionMapper.OnErrorListener onErrorListener) {
                try {
                    stagedObject.put(key, value);
                } catch (final JSONException ex) {
                    String message = ex.getLocalizedMessage();
                    if (message == null) {
                        message = "Error staging object.";
                    }
                    onErrorListener.onError(new FacebookException(message));
                }
            }
        };
        final CollectionMapper.OnMapperCompleteListener onStagedArrayMapperCompleteListener =
                new CollectionMapper.OnMapperCompleteListener() {
                    @Override
                    public void onComplete() {
                        onArrayListStagedListener.onComplete(stagedObject);
                    }

                    @Override
                    public void onError(FacebookException exception) {
                        onArrayListStagedListener.onError(exception);
                    }
                };
        stageCollectionValues(collection, onStagedArrayMapperCompleteListener);
    }

    private <T> void stageCollectionValues(final CollectionMapper.Collection<T> collection,
                                                  final CollectionMapper.OnMapperCompleteListener
                                                          onCollectionValuesStagedListener) {
        final CollectionMapper.ValueMapper valueMapper = new CollectionMapper.ValueMapper() {
            @Override
            public void mapValue(Object value,
                                 CollectionMapper.OnMapValueCompleteListener
                                         onMapValueCompleteListener) {
                if (value instanceof ArrayList) {
                    stageArrayList((ArrayList) value, onMapValueCompleteListener);
                } else if (value instanceof ShareOpenGraphObject) {
                    stageOpenGraphObject(
                            (ShareOpenGraphObject) value,
                            onMapValueCompleteListener);
                } else if (value instanceof SharePhoto) {
                    stagePhoto((SharePhoto) value, onMapValueCompleteListener);
                } else {
                    onMapValueCompleteListener.onComplete(value);
                }
            }
        };
        CollectionMapper.iterate(collection, valueMapper, onCollectionValuesStagedListener);
    }

    private void stageOpenGraphAction(final Bundle parameters,
                                             final CollectionMapper.OnMapperCompleteListener
                                                     onOpenGraphActionStagedListener) {
        final CollectionMapper.Collection<String> collection = new CollectionMapper
                .Collection<String>() {
            @Override
            public Iterator<String> keyIterator() {
                return parameters.keySet().iterator();
            }

            @Override
            public Object get(String key) {
                return parameters.get(key);
            }

            @Override
            public void set(String key,
                            Object value,
                            CollectionMapper.OnErrorListener onErrorListener) {
                if (!Utility.putJSONValueInBundle(parameters, key, value)) {
                    onErrorListener.onError(
                            new FacebookException("Unexpected value: " + value.toString()));
                }
            }
        };
        stageCollectionValues(collection, onOpenGraphActionStagedListener);
    }

    private void stageOpenGraphObject(final ShareOpenGraphObject object,
                                             final CollectionMapper.OnMapValueCompleteListener
                                                     onOpenGraphObjectStagedListener) {
        String type = object.getString("type");
        if (type == null) {
            type = object.getString("og:type");
        }

        if (type == null) {
            onOpenGraphObjectStagedListener.onError(
                    new FacebookException("Open Graph objects must contain a type value."));
            return;
        }
        final JSONObject stagedObject = new JSONObject();
        final CollectionMapper.Collection<String> collection = new CollectionMapper
                .Collection<String>() {
            @Override
            public Iterator<String> keyIterator() {
                return object.keySet().iterator();
            }

            @Override
            public Object get(String key) {
                return object.get(key);
            }

            @Override
            public void set(String key,
                            Object value,
                            CollectionMapper.OnErrorListener onErrorListener) {
                try {
                    stagedObject.put(key, value);
                } catch (final JSONException ex) {
                    String message = ex.getLocalizedMessage();
                    if (message == null) {
                        message = "Error staging object.";
                    }
                    onErrorListener.onError(new FacebookException(message));
                }
            }
        };
        final GraphRequest.Callback requestCallback = new GraphRequest.Callback() {
            @Override
            public void onCompleted(GraphResponse response) {
                final FacebookRequestError error = response.getError();
                if (error != null) {
                    String message = error.getErrorMessage();
                    if (message == null) {
                        message = "Error staging Open Graph object.";
                    }
                    onOpenGraphObjectStagedListener.onError(
                            new FacebookGraphResponseException(response, message));
                    return;
                }
                final JSONObject data = response.getJSONObject();
                if (data == null) {
                    onOpenGraphObjectStagedListener.onError(
                            new FacebookGraphResponseException(response,
                                    "Error staging Open Graph object."));
                    return;
                }
                final String stagedObjectId = data.optString("id");
                if (stagedObjectId == null) {
                    onOpenGraphObjectStagedListener.onError(
                            new FacebookGraphResponseException(response,
                                    "Error staging Open Graph object."));
                    return;
                }
                onOpenGraphObjectStagedListener.onComplete(stagedObjectId);
            }
        };
        final String ogType = type;
        final CollectionMapper.OnMapperCompleteListener onMapperCompleteListener =
                new CollectionMapper.OnMapperCompleteListener() {
                    @Override
                    public void onComplete() {
                        final String objectString = stagedObject.toString();
                        final Bundle parameters = new Bundle();
                        parameters.putString("object", objectString);
                        try {
                            new GraphRequest(
                                    AccessToken.getCurrentAccessToken(),
                                    getGraphPath(
                                            "objects/" +
                                                    URLEncoder.encode(ogType, DEFAULT_CHARSET)),
                                    parameters,
                                    HttpMethod.POST,
                                    requestCallback).executeAsync();
                        } catch (final UnsupportedEncodingException ex) {
                            String message = ex.getLocalizedMessage();
                            if (message == null) {
                                message = "Error staging Open Graph object.";
                            }
                            onOpenGraphObjectStagedListener.onError(new FacebookException(message));
                        }
                    }

                    @Override
                    public void onError(FacebookException exception) {
                        onOpenGraphObjectStagedListener.onError(exception);
                    }
                };
        stageCollectionValues(collection, onMapperCompleteListener);
    }

    private void stagePhoto(final SharePhoto photo,
                                   final CollectionMapper.OnMapValueCompleteListener
                                           onPhotoStagedListener) {
        final Bitmap bitmap = photo.getBitmap();
        final Uri imageUrl = photo.getImageUrl();
        if ((bitmap != null) || (imageUrl != null)) {
            final GraphRequest.Callback requestCallback = new GraphRequest.Callback() {
                @Override
                public void onCompleted(GraphResponse response) {
                    final FacebookRequestError error = response.getError();
                    if (error != null) {
                        String message = error.getErrorMessage();
                        if (message == null) {
                            message = "Error staging photo.";
                        }
                        onPhotoStagedListener.onError(
                                new FacebookGraphResponseException(response, message));
                        return;
                    }
                    final JSONObject data = response.getJSONObject();
                    if (data == null) {
                        onPhotoStagedListener.onError(
                                new FacebookException("Error staging photo."));
                        return;
                    }
                    final String stagedImageUri = data.optString("uri");
                    if (stagedImageUri == null) {
                        onPhotoStagedListener.onError(
                                new FacebookException("Error staging photo."));
                        return;
                    }

                    final JSONObject stagedObject = new JSONObject();
                    try {
                        stagedObject.put("url", stagedImageUri);
                        stagedObject.put("user_generated", photo.getUserGenerated());
                    } catch (final JSONException ex) {
                        String message = ex.getLocalizedMessage();
                        if (message == null) {
                            message = "Error staging photo.";
                        }
                        onPhotoStagedListener.onError(new FacebookException(message));
                        return;
                    }
                    onPhotoStagedListener.onComplete(stagedObject);
                }
            };
            if (bitmap != null) {
                ShareInternalUtility.newUploadStagingResourceWithImageRequest(
                        AccessToken.getCurrentAccessToken(),
                        bitmap,
                        requestCallback).executeAsync();
            } else {
                try {
                    ShareInternalUtility.newUploadStagingResourceWithImageRequest(
                            AccessToken.getCurrentAccessToken(),
                            imageUrl,
                            requestCallback).executeAsync();
                } catch (final FileNotFoundException ex) {
                    String message = ex.getLocalizedMessage();
                    if (message == null) {
                        message = "Error staging photo.";
                    }
                    onPhotoStagedListener.onError(new FacebookException(message));
                }
            }
        } else {
            onPhotoStagedListener.onError(
                    new FacebookException("Photos must have an imageURL or bitmap."));
        }
    }
}

<code block>


package com.facebook.share.widget;

import android.app.Activity;
import android.content.Context;
import android.os.Bundle;
import android.support.v4.app.Fragment;

import com.facebook.FacebookCallback;
import com.facebook.appevents.AppEventsLogger;
import com.facebook.internal.AnalyticsEvents;
import com.facebook.internal.AppCall;
import com.facebook.internal.CallbackManagerImpl;
import com.facebook.internal.DialogFeature;
import com.facebook.internal.DialogPresenter;
import com.facebook.internal.FacebookDialogBase;
import com.facebook.share.internal.ShareFeedContent;
import com.facebook.share.Sharer;
import com.facebook.share.internal.LegacyNativeDialogParameters;
import com.facebook.share.internal.NativeDialogParameters;
import com.facebook.share.internal.OpenGraphActionDialogFeature;
import com.facebook.share.internal.ShareContentValidation;
import com.facebook.share.internal.ShareDialogFeature;
import com.facebook.share.internal.ShareInternalUtility;
import com.facebook.share.internal.WebDialogParameters;
import com.facebook.share.model.*;

import java.util.ArrayList;
import java.util.List;


public final class ShareDialog
        extends FacebookDialogBase<ShareContent, Sharer.Result>
        implements Sharer {

    
    public enum Mode {
        
        AUTOMATIC,
        
        NATIVE,
        
        WEB,
        
        FEED
    }

    private static final String FEED_DIALOG = "feed";
    private static final String WEB_SHARE_DIALOG = "share";
    private static final String WEB_OG_SHARE_DIALOG = "share_open_graph";

    private static final int DEFAULT_REQUEST_CODE =
            CallbackManagerImpl.RequestCodeOffset.Share.toRequestCode();

    private  boolean shouldFailOnDataError = false;
    
    private boolean isAutomaticMode = true;

    
    public static void show(
            final Activity activity,
            final ShareContent shareContent) {
        new ShareDialog(activity).show(shareContent);
    }

    
    public static void show(
            final Fragment fragment,
            final ShareContent shareContent) {
        new ShareDialog(fragment).show(shareContent);
    }

    
    public static boolean canShow(Class<? extends ShareContent> contentType) {
        return canShowWebTypeCheck(contentType) || canShowNative(contentType);
    }

    private static boolean canShowNative(Class<? extends ShareContent> contentType) {
        DialogFeature feature = getFeature(contentType);

        return feature != null && DialogPresenter.canPresentNativeDialogWithFeature(feature);
    }

    private static boolean canShowWebTypeCheck(Class<? extends ShareContent> contentType) {
        
        
        
        

        return ShareLinkContent.class.isAssignableFrom(contentType)
                || ShareOpenGraphContent.class.isAssignableFrom(contentType);
    }

    
    public ShareDialog(Activity activity) {
        super(activity, DEFAULT_REQUEST_CODE);

        ShareInternalUtility.registerStaticShareCallback(DEFAULT_REQUEST_CODE);
    }

    
    public ShareDialog(Fragment fragment) {
        super(fragment, DEFAULT_REQUEST_CODE);

        ShareInternalUtility.registerStaticShareCallback(DEFAULT_REQUEST_CODE);
    }

    
    ShareDialog(Activity activity, int requestCode) {
        super(activity, requestCode);

        ShareInternalUtility.registerStaticShareCallback(requestCode);
    }

    
    ShareDialog(Fragment fragment, int requestCode) {
        super(fragment, requestCode);

        ShareInternalUtility.registerStaticShareCallback(requestCode);
    }

    @Override
    protected void registerCallbackImpl(
            final CallbackManagerImpl callbackManager,
            final FacebookCallback<Result> callback) {
        ShareInternalUtility.registerSharerCallback(
                getRequestCode(), callbackManager, callback);
    }

    @Override
    public boolean getShouldFailOnDataError() {
        return this.shouldFailOnDataError;
    }

    @Override
    public void setShouldFailOnDataError(boolean shouldFailOnDataError) {
        this.shouldFailOnDataError = shouldFailOnDataError;
    }

    
    public boolean canShow(ShareContent content, Mode mode) {
        return canShowImpl(content, (mode == Mode.AUTOMATIC) ? BASE_AUTOMATIC_MODE : mode);
    }

    
    public void show(ShareContent content, Mode mode) {
        isAutomaticMode = (mode == Mode.AUTOMATIC);

        showImpl(content, isAutomaticMode ? BASE_AUTOMATIC_MODE : mode);
    }

    @Override
    protected AppCall createBaseAppCall() {
        return new AppCall(getRequestCode());
    }

    @Override
    protected List<ModeHandler> getOrderedModeHandlers() {
        ArrayList<ModeHandler> handlers = new ArrayList<>();
        handlers.add(new NativeHandler());
        handlers.add(new FeedHandler()); 
        handlers.add(new WebShareHandler());

        return handlers;
    }

    private class NativeHandler extends ModeHandler {
        @Override
        public Object getMode() {
            return Mode.NATIVE;
        }

        @Override
        public boolean canShow(final ShareContent content) {
            return content != null && ShareDialog.canShowNative(content.getClass());
        }

        @Override
        public AppCall createAppCall(final ShareContent content) {
            logDialogShare(getActivityContext(), content, Mode.NATIVE);

            ShareContentValidation.validateForNativeShare(content);

            final AppCall appCall = createBaseAppCall();
            final boolean shouldFailOnDataError = getShouldFailOnDataError();

            DialogPresenter.setupAppCallForNativeDialog(
                    appCall,
                    new DialogPresenter.ParameterProvider() {
                        @Override
                        public Bundle getParameters() {
                            return NativeDialogParameters.create(
                                    appCall.getCallId(),
                                    content,
                                    shouldFailOnDataError);
                        }

                        @Override
                        public Bundle getLegacyParameters() {
                            return LegacyNativeDialogParameters.create(
                                    appCall.getCallId(),
                                    content,
                                    shouldFailOnDataError);
                        }
                    },
                    getFeature(content.getClass()));

            return appCall;
        }
    }

    private class WebShareHandler extends ModeHandler {
        @Override
        public Object getMode() {
            return Mode.WEB;
        }

        @Override
        public boolean canShow(final ShareContent content) {
            return (content != null) && ShareDialog.canShowWebTypeCheck(content.getClass());
        }

        @Override
        public AppCall createAppCall(final ShareContent content) {
            logDialogShare(getActivityContext(), content, Mode.WEB);

            final AppCall appCall = createBaseAppCall();

            ShareContentValidation.validateForWebShare(content);

            Bundle params;
            if (content instanceof ShareLinkContent) {
                params = WebDialogParameters.create((ShareLinkContent)content);
            } else {
                params = WebDialogParameters.create((ShareOpenGraphContent)content);
            }

            DialogPresenter.setupAppCallForWebDialog(
                    appCall,
                    getActionName(content),
                    params);

            return appCall;
        }

        private String getActionName(ShareContent shareContent) {
            if (shareContent instanceof ShareLinkContent) {
                return WEB_SHARE_DIALOG;
            } else if (shareContent instanceof ShareOpenGraphContent) {
                return WEB_OG_SHARE_DIALOG;
            }

            return null;
        }
    }

    private class FeedHandler extends ModeHandler {
        @Override
        public Object getMode() {
            return Mode.FEED;
        }

        @Override
        public boolean canShow(final ShareContent content) {
            return (content instanceof ShareLinkContent)
                    || (content instanceof ShareFeedContent);
        }

        @Override
        public AppCall createAppCall(final ShareContent content) {
            logDialogShare(getActivityContext(), content, Mode.FEED);
            AppCall appCall = createBaseAppCall();
            Bundle params;
            if (content instanceof ShareLinkContent) {
                ShareLinkContent linkContent = (ShareLinkContent)content;
                ShareContentValidation.validateForWebShare(linkContent);
                params = WebDialogParameters.createForFeed(linkContent);
            } else {
                ShareFeedContent feedContent = (ShareFeedContent)content;
                params = WebDialogParameters.createForFeed(feedContent);
            }

            DialogPresenter.setupAppCallForWebDialog(
                    appCall,
                    FEED_DIALOG,
                    params);

            return appCall;
        }
    }

    private static DialogFeature getFeature(
            Class<? extends ShareContent> contentType) {
        if (ShareLinkContent.class.isAssignableFrom(contentType)) {
            return ShareDialogFeature.SHARE_DIALOG;
        } else if (SharePhotoContent.class.isAssignableFrom(contentType)) {
            return ShareDialogFeature.PHOTOS;
        } else if (ShareVideoContent.class.isAssignableFrom(contentType)) {
            return ShareDialogFeature.VIDEO;
        } else if (ShareOpenGraphContent.class.isAssignableFrom(contentType)) {
            return OpenGraphActionDialogFeature.OG_ACTION_DIALOG;
        }
        return null;
    }

    private void logDialogShare(Context context, ShareContent content, Mode mode) {
        String displayType;
        if (isAutomaticMode) {
            mode = Mode.AUTOMATIC;
        }

        switch (mode) {
            case AUTOMATIC:
                displayType = AnalyticsEvents.PARAMETER_SHARE_DIALOG_SHOW_AUTOMATIC;
                break;
            case WEB:
                displayType = AnalyticsEvents.PARAMETER_SHARE_DIALOG_SHOW_WEB;
                break;
            case NATIVE:
                displayType = AnalyticsEvents.PARAMETER_SHARE_DIALOG_SHOW_NATIVE;
                break;
            default:
                displayType = AnalyticsEvents.PARAMETER_SHARE_DIALOG_SHOW_UNKNOWN;
                break;
        }

        String contentType;
        DialogFeature dialogFeature = getFeature(content.getClass());
        if (dialogFeature == ShareDialogFeature.SHARE_DIALOG) {
            contentType = AnalyticsEvents.PARAMETER_SHARE_DIALOG_CONTENT_STATUS;
        } else if (dialogFeature == ShareDialogFeature.PHOTOS) {
            contentType = AnalyticsEvents.PARAMETER_SHARE_DIALOG_CONTENT_PHOTO;
        } else if (dialogFeature == ShareDialogFeature.VIDEO) {
            contentType = AnalyticsEvents.PARAMETER_SHARE_DIALOG_CONTENT_VIDEO;
        } else if (dialogFeature == OpenGraphActionDialogFeature.OG_ACTION_DIALOG) {
            contentType = AnalyticsEvents.PARAMETER_SHARE_DIALOG_CONTENT_OPENGRAPH;
        } else {
            contentType = AnalyticsEvents.PARAMETER_SHARE_DIALOG_CONTENT_UNKNOWN;
        }

        AppEventsLogger logger = AppEventsLogger.newLogger(context);
        Bundle parameters = new Bundle();
        parameters.putString(
                AnalyticsEvents.PARAMETER_SHARE_DIALOG_SHOW,
                displayType
        );
        parameters.putString(
                AnalyticsEvents.PARAMETER_SHARE_DIALOG_CONTENT_TYPE,
                contentType
        );
        logger.logSdkEvent(AnalyticsEvents.EVENT_SHARE_DIALOG_SHOW, null, parameters);
    }
}

<code block>


package com.facebook.share.internal;

import android.os.Parcel;
import android.os.Parcelable;

import com.facebook.share.model.ShareContent;

import java.util.HashMap;
import java.util.Map;



public class ShareFeedContent
        extends ShareContent<ShareFeedContent, ShareFeedContent.Builder> {
    private final String toId;
    private final String link;
    private final String linkName;
    private final String linkCaption;
    private final String linkDescription;
    private final String picture;
    private final String mediaSource;

    private ShareFeedContent(final Builder builder) {
        super(builder);
        this.toId = builder.toId;
        this.link = builder.link;
        this.linkName = builder.linkName;
        this.linkCaption = builder.linkCaption;
        this.linkDescription = builder.linkDescription;
        this.picture = builder.picture;
        this.mediaSource = builder.mediaSource;
    }

    ShareFeedContent(final Parcel in) {
        super(in);
        this.toId = in.readString();
        this.link = in.readString();
        this.linkName = in.readString();
        this.linkCaption = in.readString();
        this.linkDescription = in.readString();
        this.picture = in.readString();
        this.mediaSource = in.readString();
    }

    public String getToId() {
        return toId;
    }

    public String getLink() {
        return link;
    }

    public String getLinkName() {
        return linkName;
    }

    public String getLinkCaption() {
        return linkCaption;
    }

    public String getLinkDescription() {
        return linkDescription;
    }

    public String getPicture() {
        return picture;
    }

    public String getMediaSource() {
        return mediaSource;
    }

    public int describeContents() {
        return 0;
    }

    public void writeToParcel(final Parcel out, final int flags) {
        super.writeToParcel(out, flags);
        out.writeString(this.toId);
        out.writeString(this.link);
        out.writeString(this.linkName);
        out.writeString(this.linkCaption);
        out.writeString(this.linkDescription);
        out.writeString(this.picture);
        out.writeString(this.mediaSource);
    }

    @SuppressWarnings("unused")
    public static final Parcelable.Creator<ShareFeedContent> CREATOR =
            new Parcelable.Creator<ShareFeedContent>() {
                public ShareFeedContent createFromParcel(final Parcel in) {
                    return new ShareFeedContent(in);
                }

                public ShareFeedContent[] newArray(final int size) {
                    return new ShareFeedContent[size];
                }
            };

    
    public static final class Builder
            extends ShareContent.Builder<ShareFeedContent, Builder> {
        private String toId;
        private String link;
        private String linkName;
        private String linkCaption;
        private String linkDescription;
        private String picture;
        private String mediaSource;

        public ShareFeedContent.Builder setToId(String toId) {
            this.toId = toId;
            return this;
        }

        public ShareFeedContent.Builder setLink(String link) {
            this.link = link;
            return this;
        }

        public ShareFeedContent.Builder setLinkName(String linkName) {
            this.linkName = linkName;
            return this;
        }

        public ShareFeedContent.Builder setLinkCaption(String linkCaption) {
            this.linkCaption = linkCaption;
            return this;
        }

        public ShareFeedContent.Builder setLinkDescription(String linkDescription) {
            this.linkDescription = linkDescription;
            return this;
        }

        public ShareFeedContent.Builder setPicture(String picture) {
            this.picture = picture;
            return this;
        }

        public ShareFeedContent.Builder setMediaSource(String mediaSource) {
            this.mediaSource = mediaSource;
            return this;
        }

        @Override
        public ShareFeedContent build() {
            return new ShareFeedContent(this);
        }

        @Override
        public Builder readFrom(final ShareFeedContent model) {
            if (model == null) {
                return this;
            }
            return super
                    .readFrom(model)
                    .setToId(model.getToId())
                    .setLink(model.getLink())
                    .setLinkName(model.getLinkName())
                    .setLinkCaption(model.getLinkCaption())
                    .setLinkDescription(model.getLinkDescription())
                    .setPicture(model.getPicture())
                    .setMediaSource(model.getMediaSource())
                    ;
        }

        @Override
        public Builder readFrom(final Parcel parcel) {
            return this.readFrom(
                    (ShareFeedContent) parcel.readParcelable(
                            ShareFeedContent.class.getClassLoader()));
        }

    }
}

<code block>


package com.facebook.share.internal;

import android.os.Bundle;
import android.support.annotation.NonNull;

import com.facebook.FacebookException;
import com.facebook.internal.Utility;
import com.facebook.internal.WebDialog;
import com.facebook.share.model.AppGroupCreationContent;
import com.facebook.share.model.GameRequestContent;
import com.facebook.share.model.ShareLinkContent;
import com.facebook.share.model.ShareOpenGraphContent;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.util.Collection;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.Set;


public class WebDialogParameters {

    public static Bundle create(AppGroupCreationContent appGroupCreationContent) {
        Bundle webParams = new Bundle();

        Utility.putNonEmptyString(
                webParams,
                ShareConstants.WEB_DIALOG_PARAM_NAME,
                appGroupCreationContent.getName());

        Utility.putNonEmptyString(
                webParams,
                ShareConstants.WEB_DIALOG_PARAM_DESCRIPTION,
                appGroupCreationContent.getDescription());

        Utility.putNonEmptyString(
                webParams,
                ShareConstants.WEB_DIALOG_PARAM_PRIVACY,
                appGroupCreationContent
                        .getAppGroupPrivacy().toString().toLowerCase(Locale.ENGLISH));

        return webParams;
    }

    public static Bundle create(GameRequestContent gameRequestContent) {
        Bundle webParams = new Bundle();

        Utility.putNonEmptyString(
                webParams,
                ShareConstants.WEB_DIALOG_PARAM_MESSAGE,
                gameRequestContent.getMessage());
        Utility.putNonEmptyString(
                webParams,
                ShareConstants.WEB_DIALOG_PARAM_TO,
                gameRequestContent.getTo());
        Utility.putNonEmptyString(
                webParams,
                ShareConstants.WEB_DIALOG_PARAM_TITLE,
                gameRequestContent.getTitle());
        Utility.putNonEmptyString(
                webParams,
                ShareConstants.WEB_DIALOG_PARAM_DATA,
                gameRequestContent.getData());
        if (gameRequestContent.getActionType() != null) {
            Utility.putNonEmptyString(
                    webParams,
                    ShareConstants.WEB_DIALOG_PARAM_ACTION_TYPE,
                    gameRequestContent.getActionType().toString().toLowerCase(Locale.ENGLISH));
        }
        Utility.putNonEmptyString(
                webParams,
                ShareConstants.WEB_DIALOG_PARAM_OBJECT_ID,
                gameRequestContent.getObjectId());
        if (gameRequestContent.getFilters() != null) {
            Utility.putNonEmptyString(
                    webParams,
                    ShareConstants.WEB_DIALOG_PARAM_FILTERS,
                    gameRequestContent.getFilters().toString().toLowerCase(Locale.ENGLISH));
        }
        Utility.putCommaSeparatedStringList(
                webParams,
                ShareConstants.WEB_DIALOG_PARAM_SUGGESTIONS,
                gameRequestContent.getSuggestions());
        return webParams;
    }

    public static Bundle create(ShareLinkContent shareLinkContent) {
        Bundle params = new Bundle();
        Utility.putUri(
                params,
                ShareConstants.WEB_DIALOG_PARAM_HREF,
                shareLinkContent.getContentUrl());

        return params;
    }

    public static Bundle create(ShareOpenGraphContent shareOpenGraphContent) {
        Bundle params = new Bundle();

        Utility.putNonEmptyString(
                params,
                ShareConstants.WEB_DIALOG_PARAM_ACTION_TYPE,
                shareOpenGraphContent.getAction().getActionType());

        try {
            JSONObject ogJSON = ShareInternalUtility.toJSONObjectForWeb(shareOpenGraphContent);
            ogJSON = ShareInternalUtility.removeNamespacesFromOGJsonObject(ogJSON, false);
            if (ogJSON != null) {
                Utility.putNonEmptyString(
                        params,
                        ShareConstants.WEB_DIALOG_PARAM_ACTION_PROPERTIES,
                        ogJSON.toString());
            }
        } catch (JSONException e) {
            throw new FacebookException("Unable to serialize the ShareOpenGraphContent to JSON", e);
        }

        return params;
    }

    public static Bundle createForFeed(ShareLinkContent shareLinkContent) {
        Bundle webParams = new Bundle();

        Utility.putNonEmptyString(
                webParams,
                ShareConstants.WEB_DIALOG_PARAM_NAME,
                shareLinkContent.getContentTitle());

        Utility.putNonEmptyString(
                webParams,
                ShareConstants.WEB_DIALOG_PARAM_DESCRIPTION,
                shareLinkContent.getContentDescription());

        Utility.putNonEmptyString(
                webParams,
                ShareConstants.WEB_DIALOG_PARAM_LINK,
                Utility.getUriString(shareLinkContent.getContentUrl()));

        Utility.putNonEmptyString(
                webParams,
                ShareConstants.WEB_DIALOG_PARAM_PICTURE,
                Utility.getUriString(shareLinkContent.getImageUrl()));

        return webParams;
    }

    public static Bundle createForFeed(ShareFeedContent shareFeedContent) {
        Bundle webParams = new Bundle();

        Utility.putNonEmptyString(
                webParams,
                ShareConstants.FEED_TO_PARAM,
                shareFeedContent.getToId());

        Utility.putNonEmptyString(
                webParams,
                ShareConstants.FEED_LINK_PARAM,
                shareFeedContent.getLink());

        Utility.putNonEmptyString(
                webParams,
                ShareConstants.FEED_PICTURE_PARAM,
                shareFeedContent.getPicture());

        Utility.putNonEmptyString(
                webParams,
                ShareConstants.FEED_SOURCE_PARAM,
                shareFeedContent.getMediaSource());

        Utility.putNonEmptyString(
                webParams,
                ShareConstants.FEED_NAME_PARAM,
                shareFeedContent.getLinkName());

        Utility.putNonEmptyString(
                webParams,
                ShareConstants.FEED_CAPTION_PARAM,
                shareFeedContent.getLinkCaption());

        Utility.putNonEmptyString(
                webParams,
                ShareConstants.FEED_DESCRIPTION_PARAM,
                shareFeedContent.getLinkDescription());

        return webParams;
    }
}

<code block>


package com.facebook.share.internal;


public class ShareConstants {

    public static final int MIN_API_VERSION_FOR_WEB_FALLBACK_DIALOGS = 14;

    public static final String WEB_DIALOG_PARAM_DATA = "data";
    public static final String WEB_DIALOG_PARAM_MESSAGE = "message";
    public static final String WEB_DIALOG_PARAM_TO = "to";
    public static final String WEB_DIALOG_PARAM_TITLE = "title";
    public static final String WEB_DIALOG_PARAM_ACTION_TYPE = "action_type";
    public static final String WEB_DIALOG_PARAM_OBJECT_ID = "object_id";
    public static final String WEB_DIALOG_PARAM_FILTERS = "filters";
    public static final String WEB_DIALOG_PARAM_SUGGESTIONS = "suggestions";

    public static final String WEB_DIALOG_PARAM_HREF = "href";
    public static final String WEB_DIALOG_PARAM_ACTION_PROPERTIES = "action_properties";

    public static final String WEB_DIALOG_PARAM_LINK = "link";
    public static final String WEB_DIALOG_PARAM_PICTURE = "picture";
    public static final String WEB_DIALOG_PARAM_NAME = "name";
    public static final String WEB_DIALOG_PARAM_DESCRIPTION = "description";

    public static final String WEB_DIALOG_PARAM_ID = "id";

    public static final String WEB_DIALOG_PARAM_PRIVACY = "privacy";

    public static final String WEB_DIALOG_RESULT_PARAM_POST_ID = "post_id";
    public static final String WEB_DIALOG_RESULT_PARAM_REQUEST_ID = "request";
    public static final String WEB_DIALOG_RESULT_PARAM_TO_ARRAY_MEMBER = "to[%d]";

    
    public static final String LEGACY_PLACE_TAG = "com.facebook.platform.extra.PLACE";
    public static final String LEGACY_FRIEND_TAGS = "com.facebook.platform.extra.FRIENDS";
    public static final String LEGACY_LINK = "com.facebook.platform.extra.LINK";
    public static final String LEGACY_IMAGE = "com.facebook.platform.extra.IMAGE";
    public static final String LEGACY_TITLE = "com.facebook.platform.extra.TITLE";
    public static final String LEGACY_DESCRIPTION = "com.facebook.platform.extra.DESCRIPTION";
    public static final String LEGACY_REF = "com.facebook.platform.extra.REF";
    public static final String LEGACY_DATA_FAILURES_FATAL =
            "com.facebook.platform.extra.DATA_FAILURES_FATAL";
    public static final String LEGACY_PHOTOS = "com.facebook.platform.extra.PHOTOS";

    public static final String PLACE_ID = "PLACE";
    public static final String PEOPLE_IDS = "FRIENDS";
    public static final String CONTENT_URL = "LINK";
    public static final String IMAGE_URL = "IMAGE";
    public static final String TITLE = "TITLE";
    public static final String DESCRIPTION = "DESCRIPTION";
    public static final String REF = "REF";
    public static final String DATA_FAILURES_FATAL = "DATA_FAILURES_FATAL";
    public static final String PHOTOS = "PHOTOS";
    public static final String VIDEO_URL = "VIDEO";

    
    public static final String LEGACY_ACTION = "com.facebook.platform.extra.ACTION";
    public static final String LEGACY_ACTION_TYPE = "com.facebook.platform.extra.ACTION_TYPE";
    public static final String LEGACY_PREVIEW_PROPERTY_NAME =
            "com.facebook.platform.extra.PREVIEW_PROPERTY_NAME";

    public static final String ACTION = "ACTION";
    public static final String ACTION_TYPE = "ACTION_TYPE";
    public static final String PREVIEW_PROPERTY_NAME = "PREVIEW_PROPERTY_NAME";

    
    public static final String OBJECT_ID = "object_id";
    public static final String OBJECT_TYPE = "object_type";

    
    public static final String APPLINK_URL = "app_link_url";
    public static final String PREVIEW_IMAGE_URL = "preview_image_url";

    
    public static final String EXTRA_OBJECT_ID = "com.facebook.platform.extra.OBJECT_ID";

    
    public static final String EXTRA_OBJECT_IS_LIKED =
            "com.facebook.platform.extra.OBJECT_IS_LIKED";
    public static final String EXTRA_LIKE_COUNT_STRING_WITH_LIKE =
            "com.facebook.platform.extra.LIKE_COUNT_STRING_WITH_LIKE";
    public static final String EXTRA_LIKE_COUNT_STRING_WITHOUT_LIKE =
            "com.facebook.platform.extra.LIKE_COUNT_STRING_WITHOUT_LIKE";
    public static final String EXTRA_SOCIAL_SENTENCE_WITH_LIKE =
            "com.facebook.platform.extra.SOCIAL_SENTENCE_WITH_LIKE";
    public static final String EXTRA_SOCIAL_SENTENCE_WITHOUT_LIKE =
            "com.facebook.platform.extra.SOCIAL_SENTENCE_WITHOUT_LIKE";
    public static final String EXTRA_UNLIKE_TOKEN = "com.facebook.platform.extra.UNLIKE_TOKEN";

    
    public static final String EXTRA_RESULT_POST_ID = "com.facebook.platform.extra.POST_ID";
    public static final String RESULT_POST_ID = "postId";

    public static final int MAXIMUM_PHOTO_COUNT = 6;
    static final String MY_VIDEOS = "me/videos";

    
    public static final String FEED_TO_PARAM = "to";
    public static final String FEED_LINK_PARAM = "link";
    public static final String FEED_PICTURE_PARAM = "picture";
    public static final String FEED_SOURCE_PARAM = "source";
    public static final String FEED_NAME_PARAM = "name";
    public static final String FEED_CAPTION_PARAM = "caption";
    public static final String FEED_DESCRIPTION_PARAM = "description";
}

<code block>


package com.facebook.share.internal;

import android.content.Context;
import android.content.Intent;
import android.graphics.Bitmap;
import android.net.Uri;
import android.os.Bundle;
import android.os.ParcelFileDescriptor;
import android.support.annotation.Nullable;
import android.util.Pair;

import com.facebook.AccessToken;
import com.facebook.CallbackManager;
import com.facebook.FacebookCallback;
import com.facebook.FacebookException;
import com.facebook.FacebookGraphResponseException;
import com.facebook.FacebookOperationCanceledException;
import com.facebook.FacebookRequestError;
import com.facebook.FacebookSdk;
import com.facebook.GraphRequest;
import com.facebook.GraphRequest.Callback;
import com.facebook.GraphResponse;
import com.facebook.HttpMethod;
import com.facebook.appevents.AppEventsLogger;
import com.facebook.internal.AnalyticsEvents;
import com.facebook.internal.AppCall;
import com.facebook.internal.CallbackManagerImpl;
import com.facebook.internal.NativeAppCallAttachmentStore;
import com.facebook.internal.NativeProtocol;
import com.facebook.internal.Utility;
import com.facebook.share.Sharer;
import com.facebook.share.model.ShareOpenGraphAction;
import com.facebook.share.model.ShareOpenGraphContent;
import com.facebook.share.model.SharePhoto;
import com.facebook.share.model.SharePhotoContent;
import com.facebook.share.model.ShareVideoContent;
import com.facebook.share.widget.LikeView;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.UUID;


public final class ShareInternalUtility {
    public static final String MY_PHOTOS = "me/photos";
    private static final String MY_STAGING_RESOURCES = "me/staging_resources";

    
    private static final String STAGING_PARAM = "file";

    public static void invokeCallbackWithException(
            FacebookCallback<Sharer.Result> callback,
            final Exception exception) {
        if (exception instanceof FacebookException) {
            invokeOnErrorCallback(callback, (FacebookException) exception);
            return;
        }
        invokeCallbackWithError(
                callback,
                "Error preparing share content: " + exception.getLocalizedMessage());
    }

    public static void invokeCallbackWithError(
            FacebookCallback<Sharer.Result> callback,
            String error) {
        invokeOnErrorCallback(callback, error);
    }

    public static void invokeCallbackWithResults(
            FacebookCallback<Sharer.Result> callback,
            final String postId,
            final GraphResponse graphResponse) {
        FacebookRequestError requestError = graphResponse.getError();
        if (requestError != null) {
            String errorMessage = requestError.getErrorMessage();
            if (Utility.isNullOrEmpty(errorMessage)) {
                errorMessage = "Unexpected error sharing.";
            }
            invokeOnErrorCallback(callback, graphResponse, errorMessage);
        } else {
            invokeOnSuccessCallback(callback, postId);
        }
    }

    
    public static String getNativeDialogCompletionGesture(Bundle result) {
        if (result.containsKey(NativeProtocol.RESULT_ARGS_DIALOG_COMPLETION_GESTURE_KEY)) {
            return result.getString(NativeProtocol.RESULT_ARGS_DIALOG_COMPLETION_GESTURE_KEY);
        }
        return result.getString(NativeProtocol.EXTRA_DIALOG_COMPLETION_GESTURE_KEY);
    }

    
    public static String getShareDialogPostId(Bundle result) {
        if (result.containsKey(ShareConstants.RESULT_POST_ID)) {
            return result.getString(ShareConstants.RESULT_POST_ID);
        }
        if (result.containsKey(ShareConstants.EXTRA_RESULT_POST_ID)) {
            return result.getString(ShareConstants.EXTRA_RESULT_POST_ID);
        }
        return result.getString(ShareConstants.WEB_DIALOG_RESULT_PARAM_POST_ID);
    }

    public static boolean handleActivityResult(
            int requestCode,
            int resultCode,
            Intent data,
            ResultProcessor resultProcessor) {
        AppCall appCall = getAppCallFromActivityResult(requestCode, resultCode, data);
        if (appCall == null) {
            return false;
        }

        NativeAppCallAttachmentStore.cleanupAttachmentsForCall(appCall.getCallId());
        if (resultProcessor == null) {
            return true;
        }

        FacebookException exception = NativeProtocol.getExceptionFromErrorData(
                NativeProtocol.getErrorDataFromResultIntent(data));
        if (exception != null) {
            if (exception instanceof FacebookOperationCanceledException) {
                resultProcessor.onCancel(appCall);
            } else {
                resultProcessor.onError(appCall, exception);
            }
        } else {
            
            Bundle results = NativeProtocol.getSuccessResultsFromIntent(data);
            resultProcessor.onSuccess(appCall, results);
        }

        return true;
    }

    
    public static ResultProcessor getShareResultProcessor(
            final FacebookCallback<Sharer.Result> callback) {
        return new ResultProcessor(callback) {
            @Override
            public void onSuccess(AppCall appCall, Bundle results) {
                if (results != null) {
                    final String gesture = getNativeDialogCompletionGesture(results);
                    if (gesture == null || "post".equalsIgnoreCase(gesture)) {
                        String postId = getShareDialogPostId(results);
                        invokeOnSuccessCallback(callback, postId);
                    } else if ("cancel".equalsIgnoreCase(gesture)) {
                        invokeOnCancelCallback(callback);
                    } else {
                        invokeOnErrorCallback(
                                callback,
                                new FacebookException(NativeProtocol.ERROR_UNKNOWN_ERROR));
                    }
                }
            }

            @Override
            public void onCancel(AppCall appCall) {
                invokeOnCancelCallback(callback);
            }

            @Override
            public void onError(AppCall appCall, FacebookException error) {
                invokeOnErrorCallback(callback, error);
            }
        };
    }

    private static AppCall getAppCallFromActivityResult(int requestCode,
                                                        int resultCode,
                                                        Intent data) {
        UUID callId = NativeProtocol.getCallIdFromIntent(data);
        if (callId == null) {
            return null;
        }

        return AppCall.finishPendingCall(callId, requestCode);
    }

    public static void registerStaticShareCallback(
            final int requestCode) {
        CallbackManagerImpl.registerStaticCallback(
                requestCode,
                new CallbackManagerImpl.Callback() {
                    @Override
                    public boolean onActivityResult(int resultCode, Intent data) {
                        return handleActivityResult(
                                requestCode,
                                resultCode,
                                data,
                                getShareResultProcessor(null));
                    }
                }
        );
    }

    public static void registerSharerCallback(
            final int requestCode,
            final CallbackManager callbackManager,
            final FacebookCallback<Sharer.Result> callback) {
        if (!(callbackManager instanceof CallbackManagerImpl)) {
            throw new FacebookException("Unexpected CallbackManager, " +
                    "please use the provided Factory.");
        }

        ((CallbackManagerImpl) callbackManager).registerCallback(
                requestCode,
                new CallbackManagerImpl.Callback() {
                    @Override
                    public boolean onActivityResult(int resultCode, Intent data) {
                        return handleActivityResult(
                                requestCode,
                                resultCode,
                                data,
                                getShareResultProcessor(callback));
                    }
                });
    }

    public static List<String> getPhotoUrls(
            final SharePhotoContent photoContent,
            final UUID appCallId) {
        List<SharePhoto> photos;
        if (photoContent == null || (photos = photoContent.getPhotos()) == null) {
            return null;
        }

        List<NativeAppCallAttachmentStore.Attachment> attachments = Utility.map(
                photos,
                new Utility.Mapper<SharePhoto, NativeAppCallAttachmentStore.Attachment>() {
                    @Override
                    public NativeAppCallAttachmentStore.Attachment apply(SharePhoto item) {
                        return getAttachment(appCallId, item);
                    }
                });

        List<String> attachmentUrls = Utility.map(
                attachments,
                new Utility.Mapper<NativeAppCallAttachmentStore.Attachment, String>() {
                    @Override
                    public String apply(NativeAppCallAttachmentStore.Attachment item) {
                        return item.getAttachmentUrl();
                    }
                });

        NativeAppCallAttachmentStore.addAttachments(attachments);

        return attachmentUrls;
    }

    public static String getVideoUrl(final ShareVideoContent videoContent, final UUID appCallId) {
        if (videoContent == null || videoContent.getVideo() == null) {
            return null;
        }

        NativeAppCallAttachmentStore.Attachment attachment =
                NativeAppCallAttachmentStore.createAttachment(
                        appCallId,
                        videoContent.getVideo().getLocalUrl());

        ArrayList<NativeAppCallAttachmentStore.Attachment> attachments = new ArrayList<>(1);
        attachments.add(attachment);
        NativeAppCallAttachmentStore.addAttachments(attachments);

        return attachment.getAttachmentUrl();
    }

    public static JSONObject toJSONObjectForCall(
            final UUID callId,
            final ShareOpenGraphContent content)
            throws JSONException {
        final ShareOpenGraphAction action = content.getAction();
        final ArrayList<NativeAppCallAttachmentStore.Attachment> attachments = new ArrayList<>();
        JSONObject actionJSON = OpenGraphJSONUtility.toJSONObject(
                action,
                new OpenGraphJSONUtility.PhotoJSONProcessor() {
                    @Override
                    public JSONObject toJSONObject(SharePhoto photo) {
                        NativeAppCallAttachmentStore.Attachment attachment = getAttachment(
                                callId,
                                photo);

                        if (attachment == null) {
                            return null;
                        }

                        attachments.add(attachment);

                        JSONObject photoJSONObject = new JSONObject();
                        try {
                            photoJSONObject.put(
                                    NativeProtocol.IMAGE_URL_KEY, attachment.getAttachmentUrl());
                            if (photo.getUserGenerated()) {
                                photoJSONObject.put(NativeProtocol.IMAGE_USER_GENERATED_KEY, true);
                            }
                        } catch (JSONException e) {
                            throw new FacebookException("Unable to attach images", e);
                        }
                        return photoJSONObject;
                    }
                });

        NativeAppCallAttachmentStore.addAttachments(attachments);
        
        if (content.getPlaceId() != null) {
            String placeTag = actionJSON.optString("place");

            
            
            if (Utility.isNullOrEmpty(placeTag)) {
                actionJSON.put("place", content.getPlaceId());
            }
        }

        if (content.getPeopleIds() != null) {
            JSONArray peopleTags = actionJSON.optJSONArray("tags");
            Set<String> peopleIdSet = peopleTags == null
                    ? new HashSet<String>()
                    : Utility.jsonArrayToSet(peopleTags);

            for (String peopleId : content.getPeopleIds()) {
                peopleIdSet.add(peopleId);
            }
            actionJSON.put("tags", new ArrayList<>(peopleIdSet));
        }

        return actionJSON;
    }

    public static JSONObject toJSONObjectForWeb(
            final ShareOpenGraphContent shareOpenGraphContent)
            throws JSONException {
        ShareOpenGraphAction action = shareOpenGraphContent.getAction();

        return OpenGraphJSONUtility.toJSONObject(
                action,
                new OpenGraphJSONUtility.PhotoJSONProcessor() {
                    @Override
                    public JSONObject toJSONObject(SharePhoto photo) {
                        Uri photoUri = photo.getImageUrl();
                        JSONObject photoJSONObject = new JSONObject();
                        try {
                            photoJSONObject.put(
                                    NativeProtocol.IMAGE_URL_KEY, photoUri.toString());
                        } catch (JSONException e) {
                            throw new FacebookException("Unable to attach images", e);
                        }
                        return photoJSONObject;
                    }
                });
    }

    public static JSONArray removeNamespacesFromOGJsonArray(
            JSONArray jsonArray,
            boolean requireNamespace) throws JSONException {
        JSONArray newArray = new JSONArray();
        for (int i = 0; i < jsonArray.length(); ++i) {
            Object value = jsonArray.get(i);
            if (value instanceof JSONArray) {
                value = removeNamespacesFromOGJsonArray((JSONArray) value, requireNamespace);
            } else if (value instanceof JSONObject) {
                value = removeNamespacesFromOGJsonObject((JSONObject) value, requireNamespace);
            }
            newArray.put(value);
        }

        return newArray;
    }

    public static JSONObject removeNamespacesFromOGJsonObject(
            JSONObject jsonObject,
            boolean requireNamespace) {
        if (jsonObject == null) {
            return null;
        }

        try {
            JSONObject newJsonObject = new JSONObject();
            JSONObject data = new JSONObject();
            JSONArray names = jsonObject.names();
            for (int i = 0; i < names.length(); ++i) {
                String key = names.getString(i);
                Object value = null;
                value = jsonObject.get(key);
                if (value instanceof JSONObject) {
                    value = removeNamespacesFromOGJsonObject((JSONObject) value, true);
                } else if (value instanceof JSONArray) {
                    value = removeNamespacesFromOGJsonArray((JSONArray) value, true);
                }

                Pair<String, String> fieldNameAndNamespace = getFieldNameAndNamespaceFromFullName(
                        key);
                String namespace = fieldNameAndNamespace.first;
                String fieldName = fieldNameAndNamespace.second;

                if (requireNamespace) {
                    if (namespace != null && namespace.equals("fbsdk")) {
                        newJsonObject.put(key, value);
                    } else if (namespace == null || namespace.equals("og")) {
                        newJsonObject.put(fieldName, value);
                    } else {
                        data.put(fieldName, value);
                    }
                } else if (namespace != null && namespace.equals("fb")) {
                    newJsonObject.put(key, value);
                } else {
                    newJsonObject.put(fieldName, value);
                }
            }

            if (data.length() > 0) {
                newJsonObject.put("data", data);
            }

            return newJsonObject;
        } catch (JSONException e) {
            throw new FacebookException("Failed to create json object from share content");
        }
    }

    public static Pair<String, String> getFieldNameAndNamespaceFromFullName(String fullName) {
        String namespace = null;
        String fieldName;
        int index = fullName.indexOf(':');
        if (index != -1 && fullName.length() > index + 1) {
            namespace = fullName.substring(0, index);
            fieldName = fullName.substring(index + 1);
        } else {
            fieldName = fullName;
        }
        return new Pair<>(namespace, fieldName);
    }

    private static NativeAppCallAttachmentStore.Attachment getAttachment(
            UUID callId,
            SharePhoto photo) {
        Bitmap bitmap = photo.getBitmap();
        Uri photoUri = photo.getImageUrl();
        NativeAppCallAttachmentStore.Attachment attachment = null;
        if (bitmap != null) {
            attachment = NativeAppCallAttachmentStore.createAttachment(
                    callId,
                    bitmap);
        } else if (photoUri != null) {
            attachment = NativeAppCallAttachmentStore.createAttachment(
                    callId,
                    photoUri);
        }

        return attachment;
    }

    static void invokeOnCancelCallback(FacebookCallback<Sharer.Result> callback) {
        logShareResult(AnalyticsEvents.PARAMETER_SHARE_OUTCOME_CANCELLED, null);
        if (callback != null) {
            callback.onCancel();
        }
    }

    static void invokeOnSuccessCallback(
            FacebookCallback<Sharer.Result> callback,
            String postId) {
        logShareResult(AnalyticsEvents.PARAMETER_SHARE_OUTCOME_SUCCEEDED, null);
        if (callback != null) {
            callback.onSuccess(new Sharer.Result(postId));
        }
    }

    static void invokeOnErrorCallback(
            FacebookCallback<Sharer.Result> callback,
            GraphResponse response,
            String message) {
        logShareResult(AnalyticsEvents.PARAMETER_SHARE_OUTCOME_ERROR, message);
        if (callback != null) {
            callback.onError(new FacebookGraphResponseException(response, message));
        }
    }


    static void invokeOnErrorCallback(
            FacebookCallback<Sharer.Result> callback,
            String message) {
        logShareResult(AnalyticsEvents.PARAMETER_SHARE_OUTCOME_ERROR, message);
        if (callback != null) {
            callback.onError(new FacebookException(message));
        }
    }

    static void invokeOnErrorCallback(
            FacebookCallback<Sharer.Result> callback,
            FacebookException ex) {
        logShareResult(AnalyticsEvents.PARAMETER_SHARE_OUTCOME_ERROR, ex.getMessage());
        if (callback != null) {
            callback.onError(ex);
        }
    }

    private static void logShareResult(String shareOutcome, String errorMessage) {
        Context context = FacebookSdk.getApplicationContext();
        AppEventsLogger logger = AppEventsLogger.newLogger(context);
        Bundle parameters = new Bundle();
        parameters.putString(
                AnalyticsEvents.PARAMETER_SHARE_OUTCOME,
                shareOutcome
        );

        if (errorMessage != null) {
            parameters.putString(AnalyticsEvents.PARAMETER_SHARE_ERROR_MESSAGE, errorMessage);
        }
        logger.logSdkEvent(AnalyticsEvents.EVENT_SHARE_RESULT, null, parameters);
    }

    
    public static GraphRequest newUploadStagingResourceWithImageRequest(
            AccessToken accessToken,
            Bitmap image,
            Callback callback) {
        Bundle parameters = new Bundle(1);
        parameters.putParcelable(STAGING_PARAM, image);

        return new GraphRequest(
                accessToken,
                MY_STAGING_RESOURCES,
                parameters,
                HttpMethod.POST,
                callback);
    }

    
    public static GraphRequest newUploadStagingResourceWithImageRequest(
            AccessToken accessToken,
            File file,
            Callback callback
    ) throws FileNotFoundException {
        ParcelFileDescriptor descriptor =
                ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
        GraphRequest.ParcelableResourceWithMimeType<ParcelFileDescriptor> resourceWithMimeType =
                new GraphRequest.ParcelableResourceWithMimeType<>(descriptor, "image/png");
        Bundle parameters = new Bundle(1);
        parameters.putParcelable(STAGING_PARAM, resourceWithMimeType);

        return new GraphRequest(
                accessToken,
                MY_STAGING_RESOURCES,
                parameters,
                HttpMethod.POST,
                callback);
    }

    
    public static GraphRequest newUploadStagingResourceWithImageRequest(
            AccessToken accessToken,
            Uri imageUri,
            Callback callback
    ) throws FileNotFoundException {
        if (Utility.isFileUri(imageUri)) {
            return newUploadStagingResourceWithImageRequest(
                    accessToken,
                    new File(imageUri.getPath()),
                    callback);
        } else if (!Utility.isContentUri(imageUri)) {
            throw new FacebookException("The image Uri must be either a file:
        }

        GraphRequest.ParcelableResourceWithMimeType<Uri> resourceWithMimeType =
                new GraphRequest.ParcelableResourceWithMimeType<>(imageUri, "image/png");
        Bundle parameters = new Bundle(1);
        parameters.putParcelable(STAGING_PARAM, resourceWithMimeType);

        return new GraphRequest(
                accessToken,
                MY_STAGING_RESOURCES,
                parameters,
                HttpMethod.POST,
                callback);
    }

    @Nullable
    public static LikeView.ObjectType getMostSpecificObjectType(
            LikeView.ObjectType objectType1,
            LikeView.ObjectType objectType2) {
        if (objectType1 == objectType2) {
            return objectType1;
        }

        if (objectType1 == LikeView.ObjectType.UNKNOWN) {
            return objectType2;
        } else if (objectType2 == LikeView.ObjectType.UNKNOWN) {
            return objectType1;
        } else {
            
            return null;
        }
    }
}

<code block>


package com.facebook.share.model;

import android.net.Uri;
import android.os.Parcel;
import android.support.annotation.Nullable;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;


public abstract class ShareContent<P extends ShareContent, E extends ShareContent.Builder>
        implements ShareModel {
    private final Uri contentUrl;
    private final List<String> peopleIds;
    private final String placeId;
    private final String ref;

    protected ShareContent(final Builder builder) {
        super();
        this.contentUrl = builder.contentUrl;
        this.peopleIds = builder.peopleIds;
        this.placeId = builder.placeId;
        this.ref = builder.ref;
    }

    protected ShareContent(final Parcel in) {
        this.contentUrl = in.readParcelable(Uri.class.getClassLoader());
        this.peopleIds = readUnmodifiableStringList(in);
        this.placeId = in.readString();
        this.ref = in.readString();
    }

    
    @Nullable
    public Uri getContentUrl() {
        return this.contentUrl;
    }

    
    @Nullable
    public List<String> getPeopleIds() {
        return this.peopleIds;
    }

    
    @Nullable
    public String getPlaceId() {
        return this.placeId;
    }

    
    @Nullable
    public String getRef() {
        return this.ref;
    }

    public int describeContents() {
        return 0;
    }

    public void writeToParcel(final Parcel out, final int flags) {
        out.writeParcelable(this.contentUrl, 0);
        out.writeStringList(this.peopleIds);
        out.writeString(this.placeId);
        out.writeString(this.ref);
    }

    private List<String> readUnmodifiableStringList(final Parcel in) {
        final List<String> list = new ArrayList<String>();
        in.readStringList(list);
        return (list.size() == 0 ? null : Collections.unmodifiableList(list));
    }

    
    public abstract static class Builder<P extends ShareContent, E extends Builder>
            implements ShareModelBuilder<P, E> {
        private Uri contentUrl;
        private List<String> peopleIds;
        private String placeId;
        private String ref;

        
        public E setContentUrl(@Nullable final Uri contentUrl) {
            this.contentUrl = contentUrl;
            return (E) this;
        }

        
        public E setPeopleIds(@Nullable final List<String> peopleIds) {
            this.peopleIds = (peopleIds == null ? null : Collections.unmodifiableList(peopleIds));
            return (E) this;
        }

        
        public E setPlaceId(@Nullable final String placeId) {
            this.placeId = placeId;
            return (E) this;
        }

        
        public E setRef(@Nullable final String ref) {
            this.ref = ref;
            return (E) this;
        }

        @Override
        public E readFrom(final P content) {
            if (content == null) {
                return (E) this;
            }
            return (E) this
                    .setContentUrl(content.getContentUrl())
                    .setPeopleIds(content.getPeopleIds())
                    .setPlaceId(content.getPlaceId())
                    .setRef(content.getRef());
        }
    }
}

<code block>


package com.facebook.login;


public enum LoginBehavior {
    
    NATIVE_WITH_FALLBACK(true, true),

    
    NATIVE_ONLY(true, false),

    
    WEB_ONLY(false, true);

    private final boolean allowsKatanaAuth;
    private final boolean allowsWebViewAuth;

    private LoginBehavior(boolean allowsKatanaAuth, boolean allowsWebViewAuth) {
        this.allowsKatanaAuth = allowsKatanaAuth;
        this.allowsWebViewAuth = allowsWebViewAuth;
    }

    boolean allowsKatanaAuth() {
        return allowsKatanaAuth;
    }

    boolean allowsWebViewAuth() {
        return allowsWebViewAuth;
    }
}

<code block>


package com.facebook.login;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.Intent;
import android.content.pm.ResolveInfo;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.content.Context;

import com.facebook.AccessToken;
import com.facebook.CallbackManager;
import com.facebook.FacebookActivity;
import com.facebook.FacebookAuthorizationException;
import com.facebook.FacebookCallback;
import com.facebook.FacebookException;
import com.facebook.FacebookSdk;
import com.facebook.GraphResponse;
import com.facebook.Profile;
import com.facebook.internal.CallbackManagerImpl;
import com.facebook.internal.Validate;
import com.facebook.appevents.AppEventsConstants;

import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.UUID;


public class LoginManager {
    private static final String PUBLISH_PERMISSION_PREFIX = "publish";
    private static final String MANAGE_PERMISSION_PREFIX = "manage";
    private static final Set<String> OTHER_PUBLISH_PERMISSIONS = getOtherPublishPermissions();

    private static volatile LoginManager instance;

    private LoginBehavior loginBehavior = LoginBehavior.NATIVE_WITH_FALLBACK;
    private DefaultAudience defaultAudience = DefaultAudience.FRIENDS;
    private LoginClient.Request pendingLoginRequest;
    private HashMap<String, String> pendingLoggingExtras;
    private LoginLogger loginLogger;

    LoginManager() {
        Validate.sdkInitialized();
    }

    
    public static LoginManager getInstance() {
        if (instance == null) {
            synchronized (LoginManager.class) {
                if (instance == null) {
                    instance = new LoginManager();
                }
            }
        }

        return instance;
    }

    
    public void resolveError(final Activity activity, final GraphResponse response) {
        startLogin(
                new ActivityStartActivityDelegate(activity),
                createLoginRequestFromResponse(response)
        );
    }

    
    public void resolveError(final Fragment fragment, final GraphResponse response) {
        startLogin(
                new FragmentStartActivityDelegate(fragment),
                createLoginRequestFromResponse(response)
        );
    }

    private LoginClient.Request createLoginRequestFromResponse(final GraphResponse response) {
        Validate.notNull(response, "response");
        AccessToken failedToken = response.getRequest().getAccessToken();
        return createLoginRequest(failedToken != null ? failedToken.getPermissions() : null);
    }

    
    public void registerCallback(
            final CallbackManager callbackManager,
            final FacebookCallback<LoginResult> callback) {
        if (!(callbackManager instanceof CallbackManagerImpl)) {
            throw new FacebookException("Unexpected CallbackManager, " +
                    "please use the provided Factory.");
        }
        ((CallbackManagerImpl) callbackManager).registerCallback(
                CallbackManagerImpl.RequestCodeOffset.Login.toRequestCode(),
                new CallbackManagerImpl.Callback() {
                    @Override
                    public boolean onActivityResult(int resultCode, Intent data) {
                        return LoginManager.this.onActivityResult(
                                resultCode,
                                data,
                                callback);
                    }
                }
        );
    }

    boolean onActivityResult(int resultCode, Intent data) {
        return onActivityResult(resultCode, data, null);
    }

    boolean onActivityResult(int resultCode, Intent data, FacebookCallback<LoginResult>  callback) {

        if (pendingLoginRequest == null) {
            return false;
        }

        FacebookException exception = null;
        AccessToken newToken = null;
        LoginClient.Result.Code code = LoginClient.Result.Code.ERROR;
        Map<String, String> loggingExtras = null;

        boolean isCanceled = false;
        if (data != null) {
            LoginClient.Result result = (LoginClient.Result)
                    data.getParcelableExtra(LoginFragment.RESULT_KEY);
            if (result != null) {
                code = result.code;
                if (resultCode == Activity.RESULT_OK) {
                    if (result.code == LoginClient.Result.Code.SUCCESS) {
                        newToken = result.token;
                    } else {
                        exception = new FacebookAuthorizationException(result.errorMessage);
                    }
                } else if (resultCode == Activity.RESULT_CANCELED) {
                    isCanceled = true;
                }
                loggingExtras = result.loggingExtras;
            }
        } else if (resultCode == Activity.RESULT_CANCELED) {
            isCanceled = true;
            code = LoginClient.Result.Code.CANCEL;
        }

        if (exception == null && newToken == null && !isCanceled) {
            exception = new FacebookException("Unexpected call to LoginManager.onActivityResult");
        }

        logCompleteLogin(code, loggingExtras, exception);

        finishLogin(newToken, exception, isCanceled, callback);

        return true;
    }

    
    public LoginBehavior getLoginBehavior() {
        return loginBehavior;
    }

    
    public LoginManager setLoginBehavior(LoginBehavior loginBehavior) {
        this.loginBehavior = loginBehavior;
        return this;
    }

    
    public DefaultAudience getDefaultAudience() {
        return defaultAudience;
    }

    
    public LoginManager setDefaultAudience(DefaultAudience defaultAudience) {
        this.defaultAudience = defaultAudience;
        return this;
    }

    
    public void logOut() {
        AccessToken.setCurrentAccessToken(null);
        Profile.setCurrentProfile(null);
    }

    
    public void logInWithReadPermissions(Fragment fragment, Collection<String> permissions) {
        validateReadPermissions(permissions);

        LoginClient.Request loginRequest = createLoginRequest(permissions);
        startLogin(new FragmentStartActivityDelegate(fragment), loginRequest);
    }

    
    public void logInWithReadPermissions(Activity activity, Collection<String> permissions) {
        validateReadPermissions(permissions);

        LoginClient.Request loginRequest = createLoginRequest(permissions);
        startLogin(new ActivityStartActivityDelegate(activity), loginRequest);
    }

    
    public void logInWithPublishPermissions(Fragment fragment, Collection<String> permissions) {
        validatePublishPermissions(permissions);

        LoginClient.Request loginRequest = createLoginRequest(permissions);
        startLogin(new FragmentStartActivityDelegate(fragment), loginRequest);
    }

    
    public void logInWithPublishPermissions(Activity activity, Collection<String> permissions) {
        validatePublishPermissions(permissions);

        LoginClient.Request loginRequest = createLoginRequest(permissions);
        startLogin(new ActivityStartActivityDelegate(activity), loginRequest);
    }

    LoginClient.Request getPendingLoginRequest() {
        return pendingLoginRequest;
    }

    private void validateReadPermissions(Collection<String> permissions) {
        if (permissions == null) {
            return;
        }
        for (String permission : permissions) {
            if (isPublishPermission(permission)) {
                throw new FacebookException(
                    String.format(
                        "Cannot pass a publish or manage permission (%s) to a request for read " +
                                "authorization",
                        permission));
            }
        }
    }

    private void validatePublishPermissions(Collection<String> permissions) {
        if (permissions == null) {
            return;
        }
        for (String permission : permissions) {
            if (!isPublishPermission(permission)) {
                throw new FacebookException(
                    String.format(
                        "Cannot pass a read permission (%s) to a request for publish authorization",
                        permission));
            }
        }
    }

    static boolean isPublishPermission(String permission) {
        return permission != null &&
            (permission.startsWith(PUBLISH_PERMISSION_PREFIX) ||
                permission.startsWith(MANAGE_PERMISSION_PREFIX) ||
                OTHER_PUBLISH_PERMISSIONS.contains(permission));
    }

    private static Set<String> getOtherPublishPermissions() {
        HashSet<String> set = new HashSet<String>() {{
            add("ads_management");
            add("create_event");
            add("rsvp_event");
        }};
        return Collections.unmodifiableSet(set);
    }

    private LoginClient.Request createLoginRequest(Collection<String> permissions) {
        LoginClient.Request request = new LoginClient.Request(
                loginBehavior,
                Collections.unmodifiableSet(
                        permissions != null ? new HashSet(permissions) : new HashSet<String>()),
                defaultAudience,
                FacebookSdk.getApplicationId(),
                UUID.randomUUID().toString()
        );
        request.setRerequest(AccessToken.getCurrentAccessToken() != null);
        return request;
    }

    private void startLogin(
            StartActivityDelegate startActivityDelegate,
            LoginClient.Request request
    ) throws FacebookException {

        this.pendingLoginRequest = request;
        this.pendingLoggingExtras = new HashMap<>();
        this.loginLogger = getLoggerForContext(startActivityDelegate.getActivityContext());

        logStartLogin();

        
        CallbackManagerImpl.registerStaticCallback(
                CallbackManagerImpl.RequestCodeOffset.Login.toRequestCode(),
                new CallbackManagerImpl.Callback() {
                    @Override
                    public boolean onActivityResult(int resultCode, Intent data) {
                        return LoginManager.this.onActivityResult(resultCode, data);
                    }
                }
        );

        boolean started = tryFacebookActivity(startActivityDelegate, request);

        pendingLoggingExtras.put(
                LoginLogger.EVENT_EXTRAS_TRY_LOGIN_ACTIVITY,
                started ?
                AppEventsConstants.EVENT_PARAM_VALUE_YES : AppEventsConstants.EVENT_PARAM_VALUE_NO
        );

        if (!started) {
            FacebookException exception = new FacebookException(
                    "Log in attempt failed: FacebookActivity could not be started." +
                            " Please make sure you added FacebookActivity to the AndroidManifest.");
            logCompleteLogin(LoginClient.Result.Code.ERROR, null, exception);
            this.pendingLoginRequest = null;
            throw exception;
        }
    }

    private LoginLogger getLoggerForContext(Context context) {
        if (context == null || pendingLoginRequest == null) {
            return null;
        }

        LoginLogger logger = this.loginLogger;
        if (logger == null ||
                !logger.getApplicationId().equals(pendingLoginRequest.getApplicationId())) {
            logger = new LoginLogger(context, pendingLoginRequest.getApplicationId());
        }
        return logger;
    }

    private void logStartLogin() {
        if (loginLogger != null && pendingLoginRequest != null) {
            loginLogger.logStartLogin(pendingLoginRequest);
        }
    }

    private void logCompleteLogin(LoginClient.Result.Code result, Map<String, String> resultExtras,
                                  Exception exception) {
        if (loginLogger == null) {
            return;
        }
        if (pendingLoginRequest == null) {
            
            loginLogger.logUnexpectedError(
                    LoginLogger.EVENT_NAME_LOGIN_COMPLETE,
                    "Unexpected call to logCompleteLogin with null pendingAuthorizationRequest."
            );
        } else {
            loginLogger.logCompleteLogin(
                    pendingLoginRequest.getAuthId(),
                    pendingLoggingExtras,
                    result,
                    resultExtras,
                    exception);
        }
    }

    private boolean tryFacebookActivity(
            StartActivityDelegate startActivityDelegate,
            LoginClient.Request request) {

        Intent intent = getFacebookActivityIntent(request);

        if (!resolveIntent(intent)) {
            return false;
        }

        try {
            startActivityDelegate.startActivityForResult(
                    intent,
                    LoginClient.getLoginRequestCode());
        } catch (ActivityNotFoundException e) {
            return false;
        }

        return true;
    }

    private boolean resolveIntent(Intent intent) {
        ResolveInfo resolveInfo = FacebookSdk.getApplicationContext().getPackageManager()
            .resolveActivity(intent, 0);
        if (resolveInfo == null) {
            return false;
        }
        return true;
    }

    private Intent getFacebookActivityIntent(LoginClient.Request request) {
        Intent intent = new Intent();
        intent.setClass(FacebookSdk.getApplicationContext(), FacebookActivity.class);
        intent.setAction(request.getLoginBehavior().toString());

        
        LoginClient.Request authClientRequest = request;
        Bundle extras = LoginFragment.populateIntentExtras(authClientRequest);
        intent.putExtras(extras);

        return intent;
    }

    static LoginResult computeLoginResult(
            final LoginClient.Request request,
            final AccessToken newToken
    ) {
        Set<String> requestedPermissions = request.getPermissions();
        Set<String> grantedPermissions = new HashSet<String>(newToken.getPermissions());

        
        
        if (request.isRerequest()) {
            grantedPermissions.retainAll(requestedPermissions);
        }

        Set<String> deniedPermissions = new HashSet<String>(requestedPermissions);
        deniedPermissions.removeAll(grantedPermissions);
        return new LoginResult(newToken, grantedPermissions, deniedPermissions);
    }

    private void finishLogin(
            AccessToken newToken,
            FacebookException exception,
            boolean isCanceled,
            FacebookCallback<LoginResult>  callback) {
        if (newToken != null) {
            AccessToken.setCurrentAccessToken(newToken);
            Profile.fetchProfileForCurrentAccessToken();
        }

        if (callback != null) {
            LoginResult loginResult = newToken != null
                    ? computeLoginResult(pendingLoginRequest, newToken)
                    : null;
            
            if (isCanceled
                    || (loginResult != null
                           && loginResult.getRecentlyGrantedPermissions().size() == 0)) {
                callback.onCancel();
            } else if (exception != null) {
                callback.onError(exception);
            } else if (newToken != null) {
                callback.onSuccess(loginResult);
            }
        }

        this.pendingLoginRequest = null;
        this.loginLogger = null;
    }

    private static class ActivityStartActivityDelegate implements StartActivityDelegate {
        private final Activity activity;

        ActivityStartActivityDelegate(final Activity activity) {
            Validate.notNull(activity, "activity");
            this.activity = activity;
        }

        @Override
        public void startActivityForResult(Intent intent, int requestCode) {
            activity.startActivityForResult(intent, requestCode);
        }

        @Override
        public Activity getActivityContext() {
            return activity;
        }
    }

    private static class FragmentStartActivityDelegate implements StartActivityDelegate {
        private final Fragment fragment;

        FragmentStartActivityDelegate(final Fragment fragment) {
            Validate.notNull(fragment, "fragment");
            this.fragment = fragment;
        }

        @Override
        public void startActivityForResult(Intent intent, int requestCode) {
            fragment.startActivityForResult(intent, requestCode);
        }

        @Override
        public Activity getActivityContext() {
            return fragment.getActivity();
        }
    }
}

<code block>


package com.facebook.login;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.Intent;
import android.os.Bundle;
import android.os.Parcel;
import android.os.Parcelable;

import com.facebook.AccessToken;
import com.facebook.AccessTokenSource;
import com.facebook.FacebookException;
import com.facebook.internal.CallbackManagerImpl;
import com.facebook.internal.NativeProtocol;
import com.facebook.internal.ServerProtocol;
import com.facebook.internal.Utility;

class KatanaProxyLoginMethodHandler extends LoginMethodHandler {

    KatanaProxyLoginMethodHandler(LoginClient loginClient) {
        super(loginClient);
    }

    @Override
    String getNameForLogging() {
        return "katana_proxy_auth";
    }

    @Override
    boolean tryAuthorize(LoginClient.Request request) {
        String e2e = LoginClient.getE2E();
        Intent intent = NativeProtocol.createProxyAuthIntent(
                loginClient.getActivity(),
                request.getApplicationId(),
                request.getPermissions(),
                e2e,
                request.isRerequest(),
                request.hasPublishPermission(),
                request.getDefaultAudience());

        addLoggingExtra(ServerProtocol.DIALOG_PARAM_E2E, e2e);

        return tryIntent(intent, LoginClient.getLoginRequestCode());
    }

    @Override
    boolean onActivityResult(int requestCode, int resultCode, Intent data) {
        
        LoginClient.Result outcome;

        LoginClient.Request request = loginClient.getPendingRequest();

        if (data == null) {
            
            outcome = LoginClient.Result.createCancelResult(request, "Operation canceled");
        } else if (resultCode == Activity.RESULT_CANCELED) {
            outcome = handleResultCancel(request, data);
        } else if (resultCode != Activity.RESULT_OK) {
            outcome = LoginClient.Result.createErrorResult(request,
                    "Unexpected resultCode from authorization.", null);
        } else {
            outcome = handleResultOk(request, data);
        }

        if (outcome != null) {
            loginClient.completeAndValidate(outcome);
        } else {
            loginClient.tryNextHandler();
        }
        return true;
    }

    private LoginClient.Result handleResultOk(LoginClient.Request request, Intent data) {
        Bundle extras = data.getExtras();
        String error = getError(extras);
        String errorCode = extras.getString("error_code");
        String errorMessage = getErrorMessage(extras);

        String e2e = extras.getString(NativeProtocol.FACEBOOK_PROXY_AUTH_E2E_KEY);
        if (!Utility.isNullOrEmpty(e2e)) {
            logWebLoginCompleted(e2e);
        }

        if (error == null && errorCode == null && errorMessage == null) {
            try {
                AccessToken token = createAccessTokenFromWebBundle(request.getPermissions(),
                        extras, AccessTokenSource.FACEBOOK_APPLICATION_WEB,
                        request.getApplicationId());
                return LoginClient.Result.createTokenResult(request, token);
            } catch (FacebookException ex) {
                return LoginClient.Result.createErrorResult(request, null, ex.getMessage());
            }
        } else if (ServerProtocol.errorsProxyAuthDisabled.contains(error)) {
            return null;
        } else if (ServerProtocol.errorsUserCanceled.contains(error)) {
            return LoginClient.Result.createCancelResult(request, null);
        } else {
            return LoginClient.Result.createErrorResult(request, error, errorMessage, errorCode);
        }
    }

    private LoginClient.Result handleResultCancel(LoginClient.Request request, Intent data) {
        Bundle extras = data.getExtras();
        String error = getError(extras);
        String errorCode = extras.getString("error_code");

        
        
        
        if (ServerProtocol.errorConnectionFailure.equals(errorCode)) {
            String errorMessage = getErrorMessage(extras);

            return LoginClient.Result.createErrorResult(request, error, errorMessage, errorCode);
        }

        return LoginClient.Result.createCancelResult(request, error);
    }

    private String getError(Bundle extras) {
        String error = extras.getString("error");
        if (error == null) {
            error = extras.getString("error_type");
        }
        return error;
    }

    private String getErrorMessage(Bundle extras) {
        String errorMessage = extras.getString("error_message");
        if (errorMessage == null) {
            errorMessage = extras.getString("error_description");
        }
        return errorMessage;
    }

    protected boolean tryIntent(Intent intent, int requestCode) {
        if (intent == null) {
            return false;
        }

        try {
            loginClient.getFragment().startActivityForResult(intent, requestCode);
        } catch (ActivityNotFoundException e) {
            
            
            return false;
        }

        return true;
    }

    KatanaProxyLoginMethodHandler(Parcel source) {
        super(source);
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        super.writeToParcel(dest, flags);
    }

    public static final Parcelable.Creator<KatanaProxyLoginMethodHandler> CREATOR =
            new Parcelable.Creator() {

                @Override
                public KatanaProxyLoginMethodHandler createFromParcel(Parcel source) {
                    return new KatanaProxyLoginMethodHandler(source);
                }

                @Override
                public KatanaProxyLoginMethodHandler[] newArray(int size) {
                    return new KatanaProxyLoginMethodHandler[size];
                }
            };
}

<code block>


package com.facebook.login.widget;

import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.res.Resources;
import android.content.res.TypedArray;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.os.Bundle;
import android.util.AttributeSet;
import android.view.View;
import com.facebook.*;
import com.facebook.appevents.AppEventsLogger;
import com.facebook.internal.AnalyticsEvents;
import com.facebook.internal.CallbackManagerImpl;
import com.facebook.internal.LoginAuthorizationType;
import com.facebook.internal.Utility;
import com.facebook.internal.Utility.FetchedAppSettings;
import com.facebook.login.DefaultAudience;
import com.facebook.login.LoginBehavior;
import com.facebook.login.LoginManager;
import com.facebook.login.LoginResult;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;


public class LoginButton extends FacebookButtonBase {

    
    
    

    
    public enum ToolTipMode {
        
        AUTOMATIC("automatic", 0),

        
        DISPLAY_ALWAYS("display_always", 1),

        
        NEVER_DISPLAY("never_display", 2);

        public static ToolTipMode DEFAULT = AUTOMATIC;

        public static ToolTipMode fromInt(int enumValue) {
            for (ToolTipMode mode : values()) {
                if (mode.getValue() == enumValue) {
                    return mode;
                }
            }

            return null;
        }

        private String stringValue;
        private int intValue;
        ToolTipMode(String stringValue, int value) {
            this.stringValue = stringValue;
            this.intValue = value;
        }

        @Override
        public String toString() {
            return stringValue;
        }

        public int getValue() {
            return intValue;
        }
    }

    private static final String TAG = LoginButton.class.getName();
    private boolean confirmLogout;
    private String loginText;
    private String logoutText;
    private LoginButtonProperties properties = new LoginButtonProperties();
    private String loginLogoutEventName = AnalyticsEvents.EVENT_LOGIN_VIEW_USAGE;
    private boolean toolTipChecked;
    private ToolTipPopup.Style toolTipStyle = ToolTipPopup.Style.BLUE;
    private ToolTipMode toolTipMode;
    private long toolTipDisplayTime = ToolTipPopup.DEFAULT_POPUP_DISPLAY_TIME;
    private ToolTipPopup toolTipPopup;
    private AccessTokenTracker accessTokenTracker;
    private LoginManager loginManager;

    static class LoginButtonProperties {
        private DefaultAudience defaultAudience = DefaultAudience.FRIENDS;
        private List<String> permissions = Collections.<String>emptyList();
        private LoginAuthorizationType authorizationType = null;
        private LoginBehavior loginBehavior = LoginBehavior.NATIVE_WITH_FALLBACK;

        public void setDefaultAudience(DefaultAudience defaultAudience) {
            this.defaultAudience = defaultAudience;
        }

        public DefaultAudience getDefaultAudience() {
            return defaultAudience;
        }

        public void setReadPermissions(List<String> permissions) {

            if (LoginAuthorizationType.PUBLISH.equals(authorizationType)) {
                throw new UnsupportedOperationException("Cannot call setReadPermissions after " +
                        "setPublishPermissions has been called.");
            }
            this.permissions = permissions;
            authorizationType = LoginAuthorizationType.READ;
        }

        public void setPublishPermissions(List<String> permissions) {

            if (LoginAuthorizationType.READ.equals(authorizationType)) {
                throw new UnsupportedOperationException("Cannot call setPublishPermissions after " +
                        "setReadPermissions has been called.");
            }
            if (Utility.isNullOrEmpty(permissions)) {
                throw new IllegalArgumentException(
                        "Permissions for publish actions cannot be null or empty.");
            }
            this.permissions = permissions;
            authorizationType = LoginAuthorizationType.PUBLISH;
        }

        List<String> getPermissions() {
            return permissions;
        }

        public void clearPermissions() {
            permissions = null;
            authorizationType = null;
        }

        public void setLoginBehavior(LoginBehavior loginBehavior) {
            this.loginBehavior = loginBehavior;
        }

        public LoginBehavior getLoginBehavior() {
            return loginBehavior;
        }
    }

    
    public LoginButton(Context context) {
        super(
                context,
                null,
                0,
                0,
                AnalyticsEvents.EVENT_LOGIN_BUTTON_CREATE);
    }

    
    public LoginButton(Context context, AttributeSet attrs) {
        super(
                context,
                attrs,
                0,
                0,
                AnalyticsEvents.EVENT_LOGIN_BUTTON_CREATE);
    }

    
    public LoginButton(Context context, AttributeSet attrs, int defStyle) {
        super(
                context,
                attrs,
                defStyle,
                0,
                AnalyticsEvents.EVENT_LOGIN_BUTTON_CREATE);
    }

    
    public void setDefaultAudience(DefaultAudience defaultAudience) {
        properties.setDefaultAudience(defaultAudience);
    }

    
    public DefaultAudience getDefaultAudience() {
        return properties.getDefaultAudience();
    }

    
    public void setReadPermissions(List<String> permissions) {
        properties.setReadPermissions(permissions);
    }

    
    public void setReadPermissions(String... permissions) {
        properties.setReadPermissions(Arrays.asList(permissions));
    }


    
    public void setPublishPermissions(List<String> permissions) {
        properties.setPublishPermissions(permissions);
    }

    
    public void setPublishPermissions(String... permissions) {
        properties.setPublishPermissions(Arrays.asList(permissions));
    }


    
    public void clearPermissions() {
        properties.clearPermissions();
    }

    
    public void setLoginBehavior(LoginBehavior loginBehavior) {
        properties.setLoginBehavior(loginBehavior);
    }

    
    public LoginBehavior getLoginBehavior() {
        return properties.getLoginBehavior();
    }

    
    public void setToolTipStyle(ToolTipPopup.Style toolTipStyle) {
        this.toolTipStyle = toolTipStyle;
    }

    
    public void setToolTipMode(ToolTipMode toolTipMode) {
        this.toolTipMode = toolTipMode;
    }

    
    public ToolTipMode getToolTipMode() {
        return toolTipMode;
    }

    
    public void setToolTipDisplayTime(long displayTime) {
        this.toolTipDisplayTime = displayTime;
    }

    
    public long getToolTipDisplayTime() {
        return toolTipDisplayTime;
    }

    
    public void dismissToolTip() {
        if (toolTipPopup != null) {
            toolTipPopup.dismiss();
            toolTipPopup = null;
        }
    }

    
    public void registerCallback(
            final CallbackManager callbackManager,
            final FacebookCallback<LoginResult> callback) {
        getLoginManager().registerCallback(callbackManager, callback);
    }

    @Override
    protected void onAttachedToWindow() {
        super.onAttachedToWindow();
        if (accessTokenTracker != null && !accessTokenTracker.isTracking()) {
            accessTokenTracker.startTracking();
            setButtonText();
        }
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);

        if (!toolTipChecked && !isInEditMode()) {
            toolTipChecked = true;
            checkToolTipSettings();
        }
    }

    private void showToolTipPerSettings(FetchedAppSettings settings) {
        if (settings != null && settings.getNuxEnabled() && getVisibility() == View.VISIBLE) {
            String toolTipString = settings.getNuxContent();
            displayToolTip(toolTipString);
        }
    }

    private void displayToolTip(String toolTipString) {
        toolTipPopup = new ToolTipPopup(toolTipString, this);
        toolTipPopup.setStyle(toolTipStyle);
        toolTipPopup.setNuxDisplayTime(toolTipDisplayTime);
        toolTipPopup.show();
    }

    private void checkToolTipSettings() {
        switch (toolTipMode) {
            case AUTOMATIC:
                
                final String appId = Utility.getMetadataApplicationId(getContext());
                FacebookSdk.getExecutor().execute(new Runnable() {
                    @Override
                    public void run() {
                        final FetchedAppSettings settings = Utility.queryAppSettings(appId, false);
                        getActivity().runOnUiThread(new Runnable() {
                            @Override
                            public void run() {
                                showToolTipPerSettings(settings);
                            }
                        });
                    }
                });
                break;
            case DISPLAY_ALWAYS:
                String toolTipString = getResources().getString(
                        R.string.com_facebook_tooltip_default);
                displayToolTip(toolTipString);
                break;
            case NEVER_DISPLAY:
                break;
        }
    }

    @Override
    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
        super.onLayout(changed, left, top, right, bottom);
        setButtonText();
    }

    @Override
    protected void onDetachedFromWindow() {
        super.onDetachedFromWindow();
        if (accessTokenTracker != null) {
            accessTokenTracker.stopTracking();
        }
        dismissToolTip();
    }

    @Override
    protected void onVisibilityChanged(View changedView, int visibility) {
        super.onVisibilityChanged(changedView, visibility);
        
        if (visibility != VISIBLE) {
            dismissToolTip();
        }
    }

    
    List<String> getPermissions() {
        return properties.getPermissions();
    }

    void setProperties(LoginButtonProperties properties) {
        this.properties = properties;
    }

    @Override
    protected void configureButton(
            final Context context,
            final AttributeSet attrs,
            final int defStyleAttr,
            final int defStyleRes) {
        super.configureButton(context, attrs, defStyleAttr, defStyleRes);
        setInternalOnClickListener(new LoginClickListener());

        parseLoginButtonAttributes(context, attrs, defStyleAttr, defStyleRes);

        if (isInEditMode()) {
            
            
            setBackgroundColor(getResources().getColor(R.color.com_facebook_blue));
            
            
            loginText = "Log in with Facebook";
        } else {
            accessTokenTracker = new AccessTokenTracker() {
                @Override
                protected void onCurrentAccessTokenChanged(
                        AccessToken oldAccessToken,
                        AccessToken currentAccessToken) {
                    setButtonText();
                }
            };
        }

        setButtonText();
    }

    @Override
    protected int getDefaultStyleResource() {
        return R.style.com_facebook_loginview_default_style;
    }

    private void parseLoginButtonAttributes(
            final Context context,
            final AttributeSet attrs,
            final int defStyleAttr,
            final int defStyleRes) {
        this.toolTipMode = ToolTipMode.DEFAULT;
        final TypedArray a = context.getTheme().obtainStyledAttributes(
                attrs,
                R.styleable.com_facebook_login_view,
                defStyleAttr,
                defStyleRes);
        try {
            confirmLogout = a.getBoolean(R.styleable.com_facebook_login_view_com_facebook_confirm_logout, true);
            loginText = a.getString(R.styleable.com_facebook_login_view_com_facebook_login_text);
            logoutText = a.getString(R.styleable.com_facebook_login_view_com_facebook_logout_text);
            toolTipMode = ToolTipMode.fromInt(a.getInt(
                    R.styleable.com_facebook_login_view_com_facebook_tooltip_mode,
                    ToolTipMode.DEFAULT.getValue()));
        } finally {
            a.recycle();
        }
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        Paint.FontMetrics fontMetrics = getPaint().getFontMetrics();
        int height = (getCompoundPaddingTop() +
                (int)Math.ceil(Math.abs(fontMetrics.top) + Math.abs(fontMetrics.bottom)) +
                getCompoundPaddingBottom());

        final Resources resources = getResources();
        String text = loginText;
        int logInWidth;
        int width;
        if (text == null) {
            text = resources.getString(R.string.com_facebook_loginview_log_in_button_long);
            logInWidth = measureButtonWidth(text);
            width = resolveSize(logInWidth, widthMeasureSpec);
            if (width < logInWidth) {
                text = resources.getString(R.string.com_facebook_loginview_log_in_button);
            }
        }
        logInWidth = measureButtonWidth(text);

        text = logoutText;
        if (text == null) {
            text = resources.getString(R.string.com_facebook_loginview_log_out_button);
        }
        int logOutWidth = measureButtonWidth(text);

        width = resolveSize(Math.max(logInWidth, logOutWidth), widthMeasureSpec);
        setMeasuredDimension(width, height);
    }

    private int measureButtonWidth(final String text) {
        int textWidth = measureTextWidth(text);
        int width = (getCompoundPaddingLeft() +
                getCompoundDrawablePadding() +
                textWidth +
                getCompoundPaddingRight());
        return width;
    }

    private void setButtonText() {
        final Resources resources = getResources();
        if (!isInEditMode() && AccessToken.getCurrentAccessToken() != null) {
            setText((logoutText != null) ?
                    logoutText :
                    resources.getString(R.string.com_facebook_loginview_log_out_button));
        } else {
            if (loginText != null) {
                setText(loginText);
            } else {
                String text = resources.getString(
                        R.string.com_facebook_loginview_log_in_button_long);
                int width = getWidth();
                
                if (width != 0) {
                    
                    int measuredWidth = measureButtonWidth(text);
                    if (measuredWidth > width) {
                        
                        text = resources.getString(R.string.com_facebook_loginview_log_in_button);
                    }
                }
                setText(text);
            }
        }
    }

    @Override
    protected int getDefaultRequestCode() {
        return CallbackManagerImpl.RequestCodeOffset.Login.toRequestCode();
    }

    private class LoginClickListener implements OnClickListener {

        @Override
        public void onClick(View v) {
            callExternalOnClickListener(v);

            Context context = getContext();

            AccessToken accessToken = AccessToken.getCurrentAccessToken();

            if (accessToken != null) {
                
                if (confirmLogout) {
                    
                    String logout = getResources().getString(
                            R.string.com_facebook_loginview_log_out_action);
                    String cancel = getResources().getString(
                            R.string.com_facebook_loginview_cancel_action);
                    String message;
                    Profile profile = Profile.getCurrentProfile();
                    if (profile != null && profile.getName() != null) {
                        message = String.format(
                                getResources().getString(
                                        R.string.com_facebook_loginview_logged_in_as),
                                profile.getName());
                    } else {
                        message = getResources().getString(
                                R.string.com_facebook_loginview_logged_in_using_facebook);
                    }
                    AlertDialog.Builder builder = new AlertDialog.Builder(context);
                    builder.setMessage(message)
                            .setCancelable(true)
                            .setPositiveButton(logout, new DialogInterface.OnClickListener() {
                                public void onClick(DialogInterface dialog, int which) {
                                    getLoginManager().logOut();
                                }
                            })
                            .setNegativeButton(cancel, null);
                    builder.create().show();
                } else {
                    getLoginManager().logOut();
                }
            } else {
                LoginManager loginManager = getLoginManager();
                loginManager.setDefaultAudience(getDefaultAudience());
                loginManager.setLoginBehavior(getLoginBehavior());

                if (LoginAuthorizationType.PUBLISH.equals(properties.authorizationType)) {
                    if (LoginButton.this.getFragment() != null) {
                        loginManager.logInWithPublishPermissions(
                                LoginButton.this.getFragment(),
                                properties.permissions);
                    } else {
                        loginManager.logInWithPublishPermissions(
                                LoginButton.this.getActivity(),
                                properties.permissions);
                    }
                } else {
                    if (LoginButton.this.getFragment() != null) {
                        loginManager.logInWithReadPermissions(
                                LoginButton.this.getFragment(),
                                properties.permissions);
                    } else {
                        loginManager.logInWithReadPermissions(
                                LoginButton.this.getActivity(),
                                properties.permissions);
                    }
                }
            }

            AppEventsLogger logger = AppEventsLogger.newLogger(getContext());

            Bundle parameters = new Bundle();
            parameters.putInt("logging_in", (accessToken != null) ? 0 : 1);

            logger.logSdkEvent(loginLogoutEventName, null, parameters);
        }
    }

    LoginManager getLoginManager() {
        if (loginManager == null) {
            loginManager = LoginManager.getInstance();
        }
        return loginManager;
    }

    void setLoginManager(LoginManager loginManager) {
        this.loginManager = loginManager;
    }
}

<code block>


package com.facebook;

import android.app.Activity;

import com.facebook.junittests.MainActivity;

import org.junit.Before;
import org.junit.Test;
import org.robolectric.Robolectric;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

import static org.junit.Assert.*;

public class ApplicationTest extends FacebookTestCase {
    @Test
    public void testCreateActivity() throws Exception {
        Activity activity = Robolectric.buildActivity(MainActivity.class).create().get();
        assertTrue(activity != null);
    }

    @Test
    public void testSdkInitializeCallback() throws Exception{
        final CountDownLatch lock = new CountDownLatch(1);
        Activity activity = Robolectric.buildActivity(MainActivity.class).create().get();
        final AtomicBoolean initialized = new AtomicBoolean(false);
        FacebookSdk.sdkInitialize(activity, new FacebookSdk.InitializeCallback() {
            @Override
            public void onInitialized() {
                initialized.set(true);
                lock.countDown();
            }
        });

        lock.await(100, TimeUnit.MILLISECONDS);

        assertTrue(initialized.get());
    }
}

<code block>


package com.facebook;

import android.graphics.Bitmap;
import android.location.Location;
import android.net.Uri;
import android.os.Bundle;

import com.facebook.internal.GraphUtil;
import com.facebook.internal.ServerProtocol;
import com.facebook.share.internal.ShareInternalUtility;

import org.json.JSONException;
import org.json.JSONObject;
import org.junit.Before;
import org.junit.Test;
import org.powermock.core.classloader.annotations.PrepareForTest;

import java.net.HttpURLConnection;

import static org.junit.Assert.*;
import static org.powermock.api.mockito.PowerMockito.mockStatic;
import static org.powermock.api.mockito.PowerMockito.when;

@PrepareForTest( { FacebookSdk.class, AccessTokenManager.class })
public class GraphRequestTest extends FacebookPowerMockTestCase {

    @Before
    public void before() {
        mockStatic(FacebookSdk.class);
        when(FacebookSdk.isInitialized()).thenReturn(true);
        when(FacebookSdk.getApplicationId()).thenReturn("1234");
        when(FacebookSdk.getClientToken()).thenReturn("5678");
    }

    @Test
    public void testCreateRequest() {
        GraphRequest request = new GraphRequest();
        assertTrue(request != null);
        assertEquals(HttpMethod.GET, request.getHttpMethod());
    }

    @Test
    public void testCreatePostRequest() {
        JSONObject graphObject = new JSONObject();
        GraphRequest request = GraphRequest.newPostRequest(null, "me/statuses", graphObject, null);
        assertTrue(request != null);
        assertEquals(HttpMethod.POST, request.getHttpMethod());
        assertEquals("me/statuses", request.getGraphPath());
        assertEquals(graphObject, request.getGraphObject());
    }

    @Test
    public void testCreateMeRequest() {
        GraphRequest request = GraphRequest.newMeRequest(null, null);
        assertTrue(request != null);
        assertEquals(HttpMethod.GET, request.getHttpMethod());
        assertEquals("me", request.getGraphPath());
    }

    @Test
    public void testCreateMyFriendsRequest() {
        GraphRequest request = GraphRequest.newMyFriendsRequest(null, null);
        assertTrue(request != null);
        assertEquals(HttpMethod.GET, request.getHttpMethod());
        assertEquals("me/friends", request.getGraphPath());
    }

    @Test
    public void testCreateUploadPhotoRequest() {
        Bitmap image = Bitmap.createBitmap(128, 128, Bitmap.Config.ALPHA_8);

        GraphRequest request =
                GraphRequest.newUploadPhotoRequest(
                        null,
                        ShareInternalUtility.MY_PHOTOS,
                        image,
                        null,
                        null,
                        null);
        assertTrue(request != null);

        Bundle parameters = request.getParameters();
        assertTrue(parameters != null);

        assertTrue(parameters.containsKey("picture"));
        assertEquals(image, parameters.getParcelable("picture"));
        assertEquals("me/photos", request.getGraphPath());
    }

    @Test
    public void testCreatePlacesSearchRequestWithLocation() {
        Location location = new Location("");
        location.setLatitude(47.6204);
        location.setLongitude(-122.3491);

        GraphRequest request = GraphRequest.newPlacesSearchRequest(null, location, 1000, 50, null, null);

        assertTrue(request != null);
        assertEquals(HttpMethod.GET, request.getHttpMethod());
        assertEquals("search", request.getGraphPath());
    }

    @Test
    public void testCreatePlacesSearchRequestWithSearchText() {
        GraphRequest request = GraphRequest.newPlacesSearchRequest(null, null, 1000, 50, "Starbucks", null);

        assertTrue(request != null);
        assertEquals(HttpMethod.GET, request.getHttpMethod());
        assertEquals("search", request.getGraphPath());
    }

    @Test
    public void testCreatePlacesSearchRequestRequiresLocationOrSearchText() {
        try {
            GraphRequest.newPlacesSearchRequest(null, null, 1000, 50, null, null);
            fail("expected exception");
        } catch (FacebookException exception) {
            
        }
    }

    @Test
    public void testSetHttpMethodToNilGivesDefault() {
        GraphRequest request = new GraphRequest();
        assertEquals(HttpMethod.GET, request.getHttpMethod());

        request.setHttpMethod(null);
        assertEquals(HttpMethod.GET, request.getHttpMethod());
    }

    @Test
    public void testExecuteBatchWithNullRequestsThrows() {
        try {
            GraphRequest.executeBatchAndWait((GraphRequest[]) null);
            fail("expected NullPointerException");
        } catch (NullPointerException exception) {
        }
    }

    @Test
    public void testExecuteBatchWithZeroRequestsThrows() {
        try {
            GraphRequest.executeBatchAndWait(new GraphRequest[]{});
            fail("expected IllegalArgumentException");
        } catch (IllegalArgumentException exception) {
        }
    }

    @Test
    public void testExecuteBatchWithNullRequestThrows() {
        try {
            GraphRequest.executeBatchAndWait(new GraphRequest[]{null});
            fail("expected NullPointerException");
        } catch (NullPointerException exception) {
        }
    }

    @Test
    public void testToHttpConnectionWithNullRequestsThrows() {
        try {
            GraphRequest.toHttpConnection((GraphRequest[]) null);
            fail("expected NullPointerException");
        } catch (NullPointerException exception) {
        }
    }

    @Test
    public void testToHttpConnectionWithZeroRequestsThrows() {
        try {
            GraphRequest.toHttpConnection(new GraphRequest[]{});
            fail("expected IllegalArgumentException");
        } catch (IllegalArgumentException exception) {
        }
    }

    @Test
    public void testToHttpConnectionWithNullRequestThrows() {
        try {
            GraphRequest.toHttpConnection(new GraphRequest[]{null});
            fail("expected NullPointerException");
        } catch (NullPointerException exception) {
        }
    }

    @Test
    public void testSingleGetToHttpRequest() throws Exception {
        GraphRequest requestMe = new GraphRequest(null, "TourEiffel");
        HttpURLConnection connection = GraphRequest.toHttpConnection(requestMe);

        assertTrue(connection != null);

        assertEquals("GET", connection.getRequestMethod());
        assertEquals("/" + ServerProtocol.getAPIVersion() + "/TourEiffel",
            connection.getURL().getPath());

        assertTrue(connection.getRequestProperty("User-Agent").startsWith("FBAndroidSDK"));

        Uri uri = Uri.parse(connection.getURL().toString());
        assertEquals("android", uri.getQueryParameter("sdk"));
        assertEquals("json", uri.getQueryParameter("format"));
    }

    @Test
    public void testBuildsClientTokenIfNeeded() throws Exception {
        GraphRequest requestMe = new GraphRequest(null, "TourEiffel");
        HttpURLConnection connection = GraphRequest.toHttpConnection(requestMe);

        assertTrue(connection != null);

        Uri uri = Uri.parse(connection.getURL().toString());
        String accessToken = uri.getQueryParameter("access_token");
        assertNotNull(accessToken);
        assertTrue(accessToken.contains(FacebookSdk.getApplicationId()));
        assertTrue(accessToken.contains(FacebookSdk.getClientToken()));
    }
}

<code block>


package com.facebook.login;

import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentActivity;

import com.facebook.AccessToken;
import com.facebook.FacebookPowerMockTestCase;
import com.facebook.FacebookSdk;
import com.facebook.TestUtils;

import org.junit.Before;
import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.robolectric.Robolectric;
import org.robolectric.RuntimeEnvironment;

import java.util.Arrays;
import java.util.HashSet;

import static org.junit.Assert.*;
import static org.mockito.Mockito.verify;
import static org.powermock.api.mockito.PowerMockito.mock;
import static org.powermock.api.mockito.PowerMockito.when;

@PrepareForTest({ LoginClient.class })
public class LoginClientTest extends FacebookPowerMockTestCase {

    private static final String ACCESS_TOKEN = "An access token for user 1";
    private static final String USER_ID = "1001";
    private static final String APP_ID = "2002";


    private static final long EXPIRES_IN_DELTA = 3600 * 24 * 60;
    private static final HashSet<String> PERMISSIONS = new HashSet<String>(
        Arrays.asList("go outside", "come back in"));
    private static final String ERROR_MESSAGE = "This is bad!";

    @Mock private Fragment mockFragment;

    @Before
    public void before() throws Exception {
        FragmentActivity activity =
            Robolectric.buildActivity(FragmentActivity.class).create().get();
        when(mockFragment.getActivity()).thenReturn(activity);
    }

    @Test
    public void testReauthorizationWithSameFbidSucceeds() throws Exception {
        FacebookSdk.sdkInitialize(RuntimeEnvironment.application);
        LoginClient.Request request = createRequest(ACCESS_TOKEN);

        AccessToken token = new AccessToken(
                ACCESS_TOKEN,
                APP_ID,
                USER_ID,
                PERMISSIONS,
                null,
                null,
                null,
                null);
        LoginClient.Result result = LoginClient.Result.createTokenResult(request, token);

        LoginClient.OnCompletedListener listener = mock(LoginClient.OnCompletedListener.class);

        LoginClient client = new LoginClient(mockFragment);
        client.setOnCompletedListener(listener);

        client.completeAndValidate(result);

        ArgumentCaptor<LoginClient.Result> resultArgumentCaptor =
            ArgumentCaptor.forClass(LoginClient.Result.class);

        verify(listener).onCompleted(resultArgumentCaptor.capture());

        result = resultArgumentCaptor.getValue();

        assertNotNull(result);
        assertEquals(LoginClient.Result.Code.SUCCESS, result.code);

        AccessToken resultToken = result.token;
        assertNotNull(resultToken);
        assertEquals(ACCESS_TOKEN, resultToken.getToken());

        
        assertEquals(PERMISSIONS, resultToken.getPermissions());
    }

    @Test
    public void testRequestParceling() {
        LoginClient.Request request = createRequest(ACCESS_TOKEN);

        LoginClient.Request unparceledRequest = TestUtils.parcelAndUnparcel(request);

        assertEquals(LoginBehavior.NATIVE_WITH_FALLBACK, unparceledRequest.getLoginBehavior());
        assertEquals(new HashSet<String>(PERMISSIONS), unparceledRequest.getPermissions());
        assertEquals(DefaultAudience.FRIENDS, unparceledRequest.getDefaultAudience());
        assertEquals("1234", unparceledRequest.getApplicationId());
        assertEquals("5678", unparceledRequest.getAuthId());
        assertFalse(unparceledRequest.isRerequest());
    }

    @Test
    public void testResultParceling() {
        LoginClient.Request request = new LoginClient.Request(
                LoginBehavior.WEB_ONLY,
                null,
                DefaultAudience.EVERYONE,
                null,
                null);
        request.setRerequest(true);
        AccessToken token1 = new AccessToken(
                "Token2",
                "12345",
                "1000",
                null,
                null,
                null,
                null,
                null);
        LoginClient.Result result = new LoginClient.Result(
                request,
                LoginClient.Result.Code.SUCCESS,
                token1,
                "error 1",
                "123"
        );

        LoginClient.Result unparceledResult = TestUtils.parcelAndUnparcel(result);
        LoginClient.Request unparceledRequest = unparceledResult.request;

        assertEquals(LoginBehavior.WEB_ONLY, unparceledRequest.getLoginBehavior());
        assertEquals(new HashSet<String>(), unparceledRequest.getPermissions());
        assertEquals(DefaultAudience.EVERYONE, unparceledRequest.getDefaultAudience());
        assertEquals(null, unparceledRequest.getApplicationId());
        assertEquals(null, unparceledRequest.getAuthId());
        assertTrue(unparceledRequest.isRerequest());

        assertEquals(LoginClient.Result.Code.SUCCESS, unparceledResult.code);
        assertEquals(token1, unparceledResult.token);
        assertEquals("error 1", unparceledResult.errorMessage);
        assertEquals("123", unparceledResult.errorCode);
    }


    protected LoginClient.Request createRequest(String previousAccessTokenString) {
        return new LoginClient.Request(
                LoginBehavior.NATIVE_WITH_FALLBACK,
                new HashSet<String>(PERMISSIONS),
                DefaultAudience.FRIENDS,
                "1234",
                "5678");
    }

}

<code block>


package com.facebook.login;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentActivity;

import com.facebook.AccessToken;
import com.facebook.AccessTokenSource;
import com.facebook.FacebookActivity;
import com.facebook.FacebookCallback;
import com.facebook.FacebookException;
import com.facebook.FacebookPowerMockTestCase;
import com.facebook.FacebookSdk;
import com.facebook.FacebookSdkNotInitializedException;
import com.facebook.Profile;

import org.apache.maven.profiles.ProfileManager;
import org.junit.Before;
import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.powermock.core.classloader.annotations.PrepareForTest;

import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ThreadPoolExecutor;

import static org.junit.Assert.*;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.eq;
import static org.mockito.Matchers.isA;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.powermock.api.mockito.PowerMockito.*;

@PrepareForTest({ FacebookSdk.class, AccessToken.class, Profile.class})
public class LoginManagerTest extends FacebookPowerMockTestCase {

    private static final String MOCK_APP_ID = "1234";
    private static final String USER_ID = "1000";
    private final String TOKEN_STRING = "A token of my esteem";
    private final List<String> PERMISSIONS = Arrays.asList("walk", "chew gum");
    private final Date EXPIRES = new Date(2025, 5, 3);
    private final Date LAST_REFRESH = new Date(2023, 8, 15);

    @Mock private Activity mockActivity;
    @Mock private Fragment mockFragment;
    @Mock private Context mockApplicationContext;
    @Mock private PackageManager mockPackageManager;
    @Mock private FacebookCallback<LoginResult> mockCallback;
    @Mock private ThreadPoolExecutor threadExecutor;
    @Mock private FragmentActivity mockFragmentActivity;

    @Before
    public void before() throws Exception {
        mockStatic(FacebookSdk.class);
        stub(method(AccessToken.class, "getCurrentAccessToken")).toReturn(null);
        stub(method(AccessToken.class, "setCurrentAccessToken")).toReturn(null);
        stub(method(Profile.class, "fetchProfileForCurrentAccessToken")).toReturn(null);

        when(FacebookSdk.isInitialized()).thenReturn(true);
        when(FacebookSdk.getApplicationId()).thenReturn(MOCK_APP_ID);
        when(FacebookSdk.getApplicationContext()).thenReturn(mockApplicationContext);
        when(FacebookSdk.getExecutor()).thenReturn(threadExecutor);
        when(mockFragment.getActivity()).thenReturn(mockFragmentActivity);

        
        
        ResolveInfo resolveInfo = new ResolveInfo();
        when(mockApplicationContext.getPackageManager()).thenReturn(mockPackageManager);
        when(mockPackageManager.resolveActivity(any(Intent.class), anyInt()))
                .thenReturn(resolveInfo);
    }

    @Test
    public void testRequiresSdkToBeInitialized() {
        try {
            when(FacebookSdk.isInitialized()).thenReturn(false);

            LoginManager loginManager = new LoginManager();

            fail();
        } catch (FacebookSdkNotInitializedException exception) {
        }
    }

    @Test
    public void testGetInstance() {
        LoginManager loginManager = LoginManager.getInstance();
        assertNotNull(loginManager);
    }

    @Test
    public void testLoginBehaviorDefaultsToSsoWithFallback() {
        LoginManager loginManager = new LoginManager();
        assertEquals(LoginBehavior.NATIVE_WITH_FALLBACK, loginManager.getLoginBehavior());
    }

    @Test
    public void testCanChangeLoginBehavior() {
        LoginManager loginManager = new LoginManager();
        loginManager.setLoginBehavior(LoginBehavior.NATIVE_ONLY);
        assertEquals(LoginBehavior.NATIVE_ONLY, loginManager.getLoginBehavior());
    }

    @Test
    public void testDefaultAudienceDefaultsToFriends() {
        LoginManager loginManager = new LoginManager();
        assertEquals(DefaultAudience.FRIENDS, loginManager.getDefaultAudience());
    }

    @Test
    public void testCanChangeDefaultAudience() {
        LoginManager loginManager = new LoginManager();
        loginManager.setDefaultAudience(DefaultAudience.EVERYONE);
        assertEquals(DefaultAudience.EVERYONE, loginManager.getDefaultAudience());
    }

    @Test
    public void testLogInWithReadAndActivityThrowsIfPublishPermissionGiven() {
        LoginManager loginManager = new LoginManager();
        try {
            loginManager.logInWithReadPermissions(mockActivity,
                Arrays.asList("public_profile", "publish_actions"));
            fail();
        } catch(FacebookException exception) {
        }
    }

    @Test
    public void testLogInWithPublishAndActivityThrowsIfPublishPermissionGiven() {
        LoginManager loginManager = new LoginManager();
        try {
            loginManager.logInWithPublishPermissions(mockActivity,
                Arrays.asList("public_profile", "publish_actions"));
            fail();
        } catch(FacebookException exception) {
        }
    }

    @Test
    public void testLogInThrowsIfCannotResolveFacebookActivity() {
        when(mockPackageManager.resolveActivity(any(Intent.class), anyInt())).thenReturn(null);

        LoginManager loginManager = new LoginManager();

        try {
            loginManager.logInWithReadPermissions(mockActivity,
                Arrays.asList("public_profile", "user_friends"));
            fail();
        } catch(FacebookException exception) {
        }
    }

    @Test
    public void testLogInThrowsIfCannotStartFacebookActivity() {
        doThrow(new ActivityNotFoundException()).when(mockActivity)
            .startActivityForResult(any(Intent.class), anyInt());

        LoginManager loginManager = new LoginManager();

        try {
            loginManager.logInWithReadPermissions(mockActivity,
                Arrays.asList("public_profile", "user_friends"));
            fail();
        } catch(FacebookException exception) {
        }
    }

    @Test
    public void testRequiresNonNullActivity() {
        try {
            LoginManager loginManager = new LoginManager();
            loginManager.logInWithReadPermissions((Activity) null,
                Arrays.asList("public_profile", "user_friends"));
            fail();
        } catch (NullPointerException exception) {
        }
    }

    @Test
    public void testRequiresNonNullFragment() {
        try {
            LoginManager loginManager = new LoginManager();
            loginManager.logInWithReadPermissions((Fragment) null,
                    Arrays.asList("public_profile", "user_friends"));
            fail();
        } catch (NullPointerException exception) {
        }
    }

    @Test
    public void testLogInWithReadDoesNotThrowWithReadPermissions() {
        LoginManager loginManager = new LoginManager();
        loginManager.logInWithReadPermissions(mockActivity,
            Arrays.asList("public_profile", "user_friends"));
    }

    @Test
    public void testLogInWithReadListCreatesPendingRequestWithCorrectValues() {
        LoginManager loginManager = new LoginManager();
        
        loginManager.setLoginBehavior(LoginBehavior.NATIVE_ONLY);
        loginManager.setDefaultAudience(DefaultAudience.EVERYONE);
        loginManager.logInWithReadPermissions(mockActivity,
            Arrays.asList("public_profile", "user_friends"));

        implTestLogInCreatesPendingRequestWithCorrectValues(loginManager,
                Arrays.asList("public_profile", "user_friends"));
    }

    @Test
    public void testLogInWithReadAndAccessTokenCreatesReauthRequest() {
        AccessToken accessToken = createAccessToken();
        stub(method(AccessToken.class, "getCurrentAccessToken")).toReturn(accessToken);

        LoginManager loginManager = new LoginManager();
        loginManager.logInWithReadPermissions(mockActivity,
            Arrays.asList("public_profile", "user_friends"));

        LoginClient.Request request = loginManager.getPendingLoginRequest();
        assertNotNull(loginManager.getPendingLoginRequest());
    }

    public void implTestLogInCreatesPendingRequestWithCorrectValues(
            LoginManager loginManager,
            Collection<String> expectedPermissions) {

        LoginClient.Request request = loginManager.getPendingLoginRequest();

        assertNotNull(request);

        assertEquals(MOCK_APP_ID, request.getApplicationId());
        assertEquals(LoginBehavior.NATIVE_ONLY, request.getLoginBehavior());
        assertEquals(DefaultAudience.EVERYONE, request.getDefaultAudience());

        Set<String> permissions = request.getPermissions();
        for (String permission : expectedPermissions) {
            assertTrue(permissions.contains(permission));

        }
    }

    @Test
    public void testLogInWithReadAndActivityStartsFacebookActivityWithCorrectRequest() {

        LoginManager loginManager = new LoginManager();
        loginManager.logInWithReadPermissions(mockActivity,
            Arrays.asList("public_profile", "user_friends"));

        ArgumentCaptor<Intent> intentArgumentCaptor = ArgumentCaptor.forClass(Intent.class);
        verify(mockActivity).startActivityForResult(intentArgumentCaptor.capture(), anyInt());
        Intent intent = intentArgumentCaptor.getValue();

        ComponentName componentName = intent.getComponent();
        assertEquals(FacebookActivity.class.getName(), componentName.getClassName());
        assertEquals(LoginBehavior.NATIVE_WITH_FALLBACK.name(), intent.getAction());
    }

    @Test
    public void testLogInWithReadAndFragmentStartsFacebookActivityWithCorrectRequest() {

        LoginManager loginManager = new LoginManager();
        loginManager.logInWithReadPermissions(mockFragment,
                Arrays.asList("public_profile", "user_friends"));

        ArgumentCaptor<Intent> intentArgumentCaptor = ArgumentCaptor.forClass(Intent.class);
        verify(mockFragment).startActivityForResult(intentArgumentCaptor.capture(), anyInt());
        Intent intent = intentArgumentCaptor.getValue();

        ComponentName componentName = intent.getComponent();
        assertEquals(FacebookActivity.class.getName(), componentName.getClassName());
        assertEquals(LoginBehavior.NATIVE_WITH_FALLBACK.name(), intent.getAction());
    }

    @Test
    public void testLogInWitPublishDoesNotThrowWithPublishPermissions() {
        LoginManager loginManager = new LoginManager();
        loginManager.logInWithPublishPermissions(mockActivity,
            Arrays.asList("publish_actions", "publish_stream"));
    }

    @Test
    public void testLogInWithPublishListCreatesPendingRequestWithCorrectValues() {
        LoginManager loginManager = new LoginManager();
        
        loginManager.setLoginBehavior(LoginBehavior.NATIVE_ONLY);
        loginManager.setDefaultAudience(DefaultAudience.EVERYONE);
        loginManager.logInWithPublishPermissions(mockActivity,
            Arrays.asList("publish_actions", "publish_stream"));

        implTestLogInCreatesPendingRequestWithCorrectValues(loginManager,
            Arrays.asList("publish_actions", "publish_stream"));
    }

    @Test
    public void testLogInWithPublishAndAccessTokenCreatesReauthRequest() {
        AccessToken accessToken = createAccessToken();
        stub(method(AccessToken.class, "getCurrentAccessToken")).toReturn(accessToken);

        LoginManager loginManager = new LoginManager();
        loginManager.logInWithPublishPermissions(mockActivity,
            Arrays.asList("publish_actions", "publish_stream"));

        assertNotNull(loginManager.getPendingLoginRequest());
    }

    @Test
    public void testOnActivityResultReturnsFalseIfNoPendingRequest() {
        LoginManager loginManager = new LoginManager();

        Intent intent = createSuccessResultIntent();

        boolean result = loginManager.onActivityResult(0, intent);

        assertFalse(result);
    }

    @Test
    public void testOnActivityResultReturnsTrueAndCallsCallbackOnCancelResultCode() {
        LoginManager loginManager = new LoginManager();
        loginManager.logInWithReadPermissions(mockActivity,
            Arrays.asList("public_profile", "user_friends"));

        boolean result = loginManager.onActivityResult(
                Activity.RESULT_CANCELED, null, mockCallback);

        assertTrue(result);
        verify(mockCallback, times(1)).onCancel();
        verify(mockCallback, never()).onSuccess(isA(LoginResult.class));
    }

    @Test
    public void testOnActivityResultReturnsTrueAndCallsCallbackOnCancelResultCodeEvenWithData() {
        LoginManager loginManager = new LoginManager();
        loginManager.logInWithReadPermissions(mockActivity,
            Arrays.asList("public_profile", "user_friends"));

        Intent intent = createSuccessResultIntent();
        boolean result = loginManager.onActivityResult(
                Activity.RESULT_CANCELED, intent, mockCallback);

        assertTrue(result);
        verify(mockCallback, times(1)).onCancel();
        verify(mockCallback, never()).onSuccess(isA(LoginResult.class));
    }

    @Test
    public void testOnActivityResultDoesNotModifyCurrentAccessTokenOnCancelResultCode() {
        LoginManager loginManager = new LoginManager();
        loginManager.logInWithReadPermissions(mockActivity,
                Arrays.asList("public_profile", "user_friends"));

        loginManager.onActivityResult(Activity.RESULT_CANCELED, null, mockCallback);

        verifyStatic(never());
        AccessToken.setCurrentAccessToken(any(AccessToken.class));
    }

    @Test
    public void testOnActivityResultHandlesMissingCallbackOnCancelResultCode() {
        LoginManager loginManager = new LoginManager();
        loginManager.logInWithReadPermissions(mockActivity,
            Arrays.asList("public_profile", "user_friends"));

        boolean result = loginManager.onActivityResult(
                Activity.RESULT_CANCELED,
                null);

        assertTrue(result);
    }

    @Test
    public void testOnActivityResultReturnsTrueAndCallsCallbackOnNullData() {
        LoginManager loginManager = new LoginManager();
        loginManager.logInWithReadPermissions(mockActivity,
            Arrays.asList("public_profile", "user_friends"));

        boolean result = loginManager.onActivityResult(
                Activity.RESULT_OK, null, mockCallback);

        assertTrue(result);
        verify(mockCallback, times(1)).onError(isA(FacebookException.class));
        verify(mockCallback, never()).onSuccess(isA(LoginResult.class));
    }

    @Test
    public void testOnActivityResultReturnsTrueAndCallsCallbackOnMissingResult() {
        LoginManager loginManager = new LoginManager();
        loginManager.logInWithReadPermissions(mockActivity,
            Arrays.asList("public_profile", "user_friends"));

        Intent intent = createSuccessResultIntent();
        intent.removeExtra(LoginFragment.RESULT_KEY);
        boolean result = loginManager.onActivityResult(
                Activity.RESULT_OK, intent, mockCallback);

        assertTrue(result);
        verify(mockCallback, times(1)).onError(isA(FacebookException.class));
        verify(mockCallback, never()).onSuccess(isA(LoginResult.class));
    }

    @Test
    public void testOnActivityResultReturnsTrueAndCallsCallbackOnErrorResult() {
        LoginManager loginManager = new LoginManager();
        loginManager.logInWithReadPermissions(mockActivity,
            Arrays.asList("public_profile", "user_friends"));

        boolean result = loginManager.onActivityResult(
                Activity.RESULT_OK, createErrorResultIntent(), mockCallback);

        ArgumentCaptor<FacebookException> exceptionArgumentCaptor =
                ArgumentCaptor.forClass(FacebookException.class);

        assertTrue(result);
        verify(mockCallback, times(1)).onError(exceptionArgumentCaptor.capture());
        verify(mockCallback, never()).onSuccess(isA(LoginResult.class));
        assertEquals("foo: bar", exceptionArgumentCaptor.getValue().getMessage());
    }

    @Test
    public void testOnActivityResultReturnsTrueAndCallsCallbackOnCancelResult() {
        LoginManager loginManager = new LoginManager();
        loginManager.logInWithReadPermissions(mockActivity,
            Arrays.asList("public_profile", "user_friends"));

        boolean result = loginManager.onActivityResult(
                Activity.RESULT_CANCELED, createCancelResultIntent(), mockCallback);

        assertTrue(result);
        verify(mockCallback, times(1)).onCancel();
        verify(mockCallback, never()).onSuccess(isA(LoginResult.class));
    }

    @Test
    public void testOnActivityResultDoesNotModifyCurrentAccessTokenOnErrorResultCode() {
        LoginManager loginManager = new LoginManager();
        loginManager.logInWithReadPermissions(mockActivity,
            Arrays.asList("public_profile", "user_friends"));

        loginManager.onActivityResult(
                Activity.RESULT_CANCELED,
                createErrorResultIntent(),
                mockCallback);

        verifyStatic(never());
        AccessToken.setCurrentAccessToken(any(AccessToken.class));
    }

    @Test
    public void testOnActivityResultReturnsTrueAndCallsCallbackOnSuccessResult() {
        LoginManager loginManager = new LoginManager();
        loginManager.logInWithReadPermissions(mockActivity,
            Arrays.asList("public_profile", "user_friends"));

        boolean result = loginManager.onActivityResult(
                Activity.RESULT_OK, createSuccessResultIntent(), mockCallback);

        assertTrue(result);
        verify(mockCallback, never()).onError(any(FacebookException.class));
        verify(mockCallback, times(1)).onSuccess(isA(LoginResult.class));
    }

    @Test
    public void testOnHandlesMissingCallbackkOnSuccessResult() {
        LoginManager loginManager = new LoginManager();
        loginManager.logInWithReadPermissions(mockActivity,
            Arrays.asList("public_profile", "user_friends"));

        boolean result = loginManager.onActivityResult(
                Activity.RESULT_OK, createSuccessResultIntent(), null);

        assertTrue(result);
    }

    @Test
    public void testOnActivityResultSetsCurrentAccessTokenOnSuccessResult() {
        LoginManager loginManager = new LoginManager();
        loginManager.logInWithReadPermissions(mockActivity,
            Arrays.asList("public_profile", "user_friends"));

        boolean result = loginManager.onActivityResult(
                Activity.RESULT_OK, createSuccessResultIntent(), mockCallback);

        verifyStatic(times(1));
        AccessToken.setCurrentAccessToken(eq(createAccessToken()));
    }

    private Intent createSuccessResultIntent() {
        Intent intent = new Intent();

        LoginClient.Request request = mock(LoginClient.Request.class);

        AccessToken accessToken = createAccessToken();
        LoginClient.Result result = LoginClient.Result.createTokenResult(request, accessToken);
        intent.putExtra(LoginFragment.RESULT_KEY, result);

        return intent;
    }

    private Intent createErrorResultIntent() {
        Intent intent = new Intent();

        LoginClient.Request request = mock(LoginClient.Request.class);

        LoginClient.Result result = LoginClient.Result.createErrorResult(request, "foo", "bar");
        intent.putExtra(LoginFragment.RESULT_KEY, result);

        return intent;
    }

    private Intent createCancelResultIntent() {
        Intent intent = new Intent();

        LoginClient.Request request = mock(LoginClient.Request.class);

        LoginClient.Result result = LoginClient.Result.createCancelResult(request, null);
        intent.putExtra(LoginFragment.RESULT_KEY, result);

        return intent;
    }

    private AccessToken createAccessToken() {
        return new AccessToken(
                TOKEN_STRING,
                MOCK_APP_ID,
                USER_ID,
                PERMISSIONS,
                null,
                AccessTokenSource.WEB_VIEW,
                EXPIRES,
                LAST_REFRESH);
    }
}

<code block>


package com.facebook.login;

import com.facebook.AccessToken;
import com.facebook.FacebookSdk;
import com.facebook.FacebookTestCase;

import org.junit.Before;
import org.junit.Test;
import org.robolectric.Robolectric;
import org.robolectric.RuntimeEnvironment;

import java.util.HashSet;
import java.util.Set;

import static org.junit.Assert.*;

public class LoginResultTest extends FacebookTestCase {

    private final Set<String> EMAIL_SET = new HashSet<String>(){{ add("email"); }};
    private final Set<String> LIKES_EMAIL_SET = new HashSet<String>(){{
        add("user_likes");
        add("email");
    }};
    private final Set<String> PROFILE_EMAIL_SET = new HashSet<String>(){{
        add("user_profile");
        add("email");
    }};

    @Before
    public void before() throws Exception {
        FacebookSdk.sdkInitialize(RuntimeEnvironment.application);
    }

    @Test
    public void testInitialLogin() {
        LoginClient.Request request = createRequest(EMAIL_SET, false);
        AccessToken accessToken = createAccessToken(PROFILE_EMAIL_SET, new HashSet<String>());
        LoginResult result = LoginManager.computeLoginResult(request, accessToken);
        assertEquals(accessToken, result.getAccessToken());
        assertEquals(PROFILE_EMAIL_SET, result.getRecentlyGrantedPermissions());
        assertEquals(0, result.getRecentlyDeniedPermissions().size());
    }

    @Test
    public void testReAuth() {
        LoginClient.Request request = createRequest(EMAIL_SET, true);
        AccessToken accessToken = createAccessToken(PROFILE_EMAIL_SET, new HashSet<String>());
        LoginResult result = LoginManager.computeLoginResult(request, accessToken);
        assertEquals(accessToken, result.getAccessToken());
        assertEquals(EMAIL_SET, result.getRecentlyGrantedPermissions());
        assertEquals(0, result.getRecentlyDeniedPermissions().size());
    }

    @Test
    public void testDeniedPermissions() {
        LoginClient.Request request = createRequest(LIKES_EMAIL_SET, true);
        AccessToken accessToken = createAccessToken(EMAIL_SET, new HashSet<String>());
        LoginResult result = LoginManager.computeLoginResult(request, accessToken);
        assertEquals(accessToken, result.getAccessToken());
        assertEquals(EMAIL_SET, result.getRecentlyGrantedPermissions());
        assertEquals(
                new HashSet<String>(){{ add("user_likes"); }},
                result.getRecentlyDeniedPermissions());
    }


    private AccessToken createAccessToken(Set<String> permissions,
                                          Set<String> declinedPermissions) {
        return new AccessToken(
            "token",
            "123",
            "234",
            permissions,
            declinedPermissions,
            null,
            null,
            null
        );
    }

    private LoginClient.Request createRequest(Set<String> permissions, boolean isRerequest) {
        LoginClient.Request request = new LoginClient.Request(
                LoginBehavior.NATIVE_WITH_FALLBACK,
                permissions,
                DefaultAudience.EVERYONE,
                "123",
                "authid"
        );
        request.setRerequest(isRerequest);
        return request;
    }
}

<code block>


package com.facebook.login;

import android.support.v4.app.FragmentActivity;

import com.facebook.FacebookPowerMockTestCase;

import org.junit.Before;
import org.robolectric.Robolectric;

import java.util.Arrays;
import java.util.Date;
import java.util.HashSet;

import static org.junit.Assert.assertTrue;
import static org.powermock.api.mockito.PowerMockito.mock;
import static org.powermock.api.mockito.PowerMockito.when;

public abstract class LoginHandlerTestCase extends FacebookPowerMockTestCase {
    protected static final String ACCESS_TOKEN = "An access token";
    protected static final String USER_ID = "1000";
    protected static final long EXPIRES_IN_DELTA = 3600 * 24 * 60;
    protected static final HashSet<String> PERMISSIONS = new HashSet<String>(
            Arrays.asList("go outside", "come back in"));
    protected static final String ERROR_MESSAGE = "This is bad!";

    protected FragmentActivity activity;
    protected LoginClient mockLoginClient;

    @Before
    public void before() throws Exception {
        mockLoginClient = mock(LoginClient.class);
        activity = Robolectric.buildActivity(FragmentActivity.class).create().get();
        when(mockLoginClient.getActivity()).thenReturn(activity);
    }

    protected LoginClient.Request createRequest() {
        return createRequest(null);
    }

    protected LoginClient.Request createRequest(String previousAccessTokenString) {

        return new LoginClient.Request(
                LoginBehavior.NATIVE_WITH_FALLBACK,
                new HashSet<String>(PERMISSIONS),
                DefaultAudience.FRIENDS,
                "1234",
                "5678");
    }

    protected void assertDateDiffersWithinDelta(Date expected, Date actual, long expectedDifference,
                                                long deltaInMsec) {

        long delta = Math.abs(expected.getTime() - actual.getTime()) - expectedDifference;
        assertTrue(delta < deltaInMsec);
    }
}

<code block>


package com.facebook;

import android.graphics.Bitmap;
import android.os.Bundle;
import android.test.suitebuilder.annotation.LargeTest;

import com.facebook.share.internal.ShareInternalUtility;

import org.json.JSONObject;

import java.io.IOException;
import java.lang.Override;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

public class BatchRequestTests extends FacebookTestCase {
    protected void setUp() throws Exception {
        super.setUp();

        
        GraphRequest.setDefaultBatchApplicationId(null);
    }

    protected String[] getDefaultPermissions()
    {
        return new String[] { "email", "publish_actions", "read_stream" };
    };

    @LargeTest
    public void testCreateNonemptyRequestBatch() {
        GraphRequest meRequest = GraphRequest.newMeRequest(null, null);

        GraphRequestBatch batch = new GraphRequestBatch(new GraphRequest[] { meRequest, meRequest });
        assertEquals(2, batch.size());
        assertEquals(meRequest, batch.get(0));
        assertEquals(meRequest, batch.get(1));
    }

    @LargeTest
    public void testBatchWithoutAppIDIsError() {
        GraphRequest request1 = new GraphRequest(null, "TourEiffel", null, null, new ExpectFailureCallback());
        GraphRequest request2 = new GraphRequest(null, "SpaceNeedle", null, null, new ExpectFailureCallback());
        GraphRequest.executeBatchAndWait(request1, request2);
    }

    @LargeTest
    public void testExecuteBatchRequestsPathEncoding() throws IOException {
        
        

        final AccessToken accessToken = getAccessTokenForSharedUser();

        Bundle parameters = new Bundle();
        parameters.putString("fields", "location");

        GraphRequest request1 = new GraphRequest(
                accessToken,
                "TourEiffel",
                parameters,
                null);
        request1.setBatchEntryName("eiffel");
        request1.setBatchEntryOmitResultOnSuccess(false);
        GraphRequest request2 = new GraphRequest(
                accessToken,
                "{result=eiffel:$.id}",
                parameters,
                null);

        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(request1, request2);
        assertEquals(2, responses.size());
        assertTrue(responses.get(0).getError() == null);
        assertTrue(responses.get(1).getError() == null);

        JSONObject eiffelTower1 = responses.get(0).getJSONObject();
        JSONObject eiffelTower2 = responses.get(1).getJSONObject();
        assertTrue(eiffelTower1 != null);
        assertTrue(eiffelTower2 != null);

        assertEquals("Paris", eiffelTower1.optJSONObject("location").optString("city"));
        assertEquals("Paris", eiffelTower2.optJSONObject("location").optString("city"));
    }

    @LargeTest
    public void testExecuteBatchedGets() throws IOException {
        final AccessToken accessToken = getAccessTokenForSharedUser();

        Bundle parameters = new Bundle();
        parameters.putString("fields", "location");

        GraphRequest request1 = new GraphRequest(
                accessToken,
                "TourEiffel",
                parameters,
                null);
        GraphRequest request2 = new GraphRequest(
                accessToken,
                "SpaceNeedle",
                parameters,
                null);

        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(request1, request2);
        assertEquals(2, responses.size());
        assertTrue(responses.get(0).getError() == null);
        assertTrue(responses.get(1).getError() == null);

        JSONObject eiffelTower = responses.get(0).getJSONObject();
        JSONObject spaceNeedle = responses.get(1).getJSONObject();
        assertTrue(eiffelTower != null);
        assertTrue(spaceNeedle != null);

        assertEquals("Paris", eiffelTower.optJSONObject("location").optString("city"));
        assertEquals("Seattle", spaceNeedle.optJSONObject("location").optString("city"));
    }

    @LargeTest
    public void testFacebookErrorResponsesCreateErrors() {
        setBatchApplicationIdForTestApp();

        GraphRequest request1 = new GraphRequest(null, "somestringthatshouldneverbeavalidfobjectid");
        GraphRequest request2 = new GraphRequest(null, "someotherstringthatshouldneverbeavalidfobjectid");
        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(request1, request2);

        assertEquals(2, responses.size());
        assertTrue(responses.get(0).getError() != null);
        assertTrue(responses.get(1).getError() != null);

        FacebookRequestError error = responses.get(0).getError();
        assertTrue(error.getException() instanceof FacebookServiceException);
        assertTrue(error.getErrorType() != null);
        assertTrue(error.getErrorCode() != FacebookRequestError.INVALID_ERROR_CODE);
    }

    @LargeTest
    public void testBatchPostStatusUpdate() {
        final AccessToken accessToken = getAccessTokenForSharedUser();

        Bundle parameters = new Bundle();
        parameters.putString("fields", "message");

        JSONObject statusUpdate1 = createStatusUpdate("1");
        JSONObject statusUpdate2 = createStatusUpdate("2");

        GraphRequest postRequest1 = GraphRequest.newPostRequest(
                accessToken,
                "me/feed",
                statusUpdate1,
                null);
        postRequest1.setBatchEntryName("postRequest1");
        postRequest1.setBatchEntryOmitResultOnSuccess(false);
        GraphRequest postRequest2 = GraphRequest.newPostRequest(
                accessToken,
                "me/feed",
                statusUpdate2,
                null);
        postRequest2.setBatchEntryName("postRequest2");
        postRequest2.setBatchEntryOmitResultOnSuccess(false);
        GraphRequest getRequest1 = new GraphRequest(
                accessToken,
                "{result=postRequest1:$.id}",
                parameters,
                null);
        GraphRequest getRequest2 = new GraphRequest(
                accessToken,
                "{result=postRequest2:$.id}",
                parameters,
                null);

        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(postRequest1, postRequest2, getRequest1, getRequest2);
        assertNotNull(responses);
        assertEquals(4, responses.size());
        assertNoErrors(responses);

        JSONObject retrievedStatusUpdate1 = responses.get(2).getJSONObject();
        JSONObject retrievedStatusUpdate2 = responses.get(3).getJSONObject();
        assertNotNull(retrievedStatusUpdate1);
        assertNotNull(retrievedStatusUpdate2);

        assertEquals(statusUpdate1.optString("message"), retrievedStatusUpdate1.optString("message"));
        assertEquals(statusUpdate2.optString("message"), retrievedStatusUpdate2.optString("message"));
    }

    @LargeTest
    public void testTwoDifferentAccessTokens() {
        final AccessToken accessToken1 = getAccessTokenForSharedUser();
        final AccessToken accessToken2 = getAccessTokenForSharedUser(SECOND_TEST_USER_TAG);

        GraphRequest request1 = GraphRequest.newMeRequest(accessToken1, null);
        GraphRequest request2 = GraphRequest.newMeRequest(accessToken2, null);

        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(request1, request2);
        assertNotNull(responses);
        assertEquals(2, responses.size());

        JSONObject user1 = responses.get(0).getJSONObject();
        JSONObject user2 = responses.get(1).getJSONObject();

        assertNotNull(user1);
        assertNotNull(user2);

        assertFalse(user1.optString("id").equals(user2.optString("id")));
        assertEquals(accessToken1.getUserId(), user1.optString("id"));
        assertEquals(accessToken2.getUserId(), user2.optString("id"));
    }

    @LargeTest
    public void testBatchWithValidSessionAndNoSession() {
        final AccessToken accessToken = getAccessTokenForSharedUser();

        GraphRequest request1 = new GraphRequest(accessToken, "me");
        GraphRequest request2 = new GraphRequest(null, "me");

        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(request1, request2);
        assertNotNull(responses);
        assertEquals(2, responses.size());

        JSONObject user1 = responses.get(0).getJSONObject();
        JSONObject user2 = responses.get(1).getJSONObject();

        assertNotNull(user1);
        assertNull(user2);

        assertEquals(accessToken.getUserId(), user1.optString("id"));
    }

    @LargeTest
    public void testBatchWithNoSessionAndValidSession() {
        final AccessToken accessToken = getAccessTokenForSharedUser();

        GraphRequest request1 = new GraphRequest(null, "me");
        GraphRequest request2 = new GraphRequest(accessToken, "me");

        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(request1, request2);
        assertNotNull(responses);
        assertEquals(2, responses.size());

        JSONObject user1 = responses.get(0).getJSONObject();
        JSONObject user2 = responses.get(1).getJSONObject();

        assertNull(user1);
        assertNotNull(user2);

        assertEquals(accessToken.getUserId(), user2.optString("id"));
    }

    @LargeTest
    public void testMixedSuccessAndFailure() {
        final AccessToken accessToken = getAccessTokenForSharedUser();

        final int NUM_REQUESTS = 8;
        GraphRequest[] requests = new GraphRequest[NUM_REQUESTS];
        for (int i = 0; i < NUM_REQUESTS; ++i) {
            boolean shouldSucceed = (i % 2) == 1;
            requests[i] = new GraphRequest(accessToken, shouldSucceed ? "me" : "-1");
        }

        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(requests);
        assertNotNull(responses);
        assertEquals(NUM_REQUESTS, responses.size());

        for (int i = 0; i < NUM_REQUESTS; ++i) {
            boolean shouldSucceed = (i % 2) == 1;

            GraphResponse response = responses.get(i);
            assertNotNull(response);
            if (shouldSucceed) {
                assertNull(response.getError());
                assertNotNull(response.getJSONObject());
            } else {
                assertNotNull(response.getError());
                assertNull(response.getJSONObject());
            }
        }
    }

    @LargeTest
    public void testBatchUploadPhoto() {
        final AccessToken accessToken = getAccessTokenForSharedUserWithPermissions(null,
                "user_photos", "publish_actions");

        final int image1Size = 120;
        final int image2Size = 150;

        Bitmap bitmap1 = createTestBitmap(image1Size);
        Bitmap bitmap2 = createTestBitmap(image2Size);

        Bundle parameters = new Bundle();
        parameters.putString("fields", "width");

        GraphRequest uploadRequest1 = GraphRequest.newUploadPhotoRequest(
                accessToken,
                ShareInternalUtility.MY_PHOTOS,
                bitmap1,
                null,
                null,
                null);
        uploadRequest1.setBatchEntryName("uploadRequest1");
        GraphRequest uploadRequest2 = GraphRequest.newUploadPhotoRequest(
                accessToken,
                ShareInternalUtility.MY_PHOTOS,
                bitmap2,
                null,
                null,
                null);
        uploadRequest2.setBatchEntryName("uploadRequest2");
        GraphRequest getRequest1 = new GraphRequest(
                accessToken,
                "{result=uploadRequest1:$.id}",
                parameters,
                null);
        GraphRequest getRequest2 = new GraphRequest(
                accessToken,
                "{result=uploadRequest2:$.id}",
                parameters,
                null);

        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(
                uploadRequest1,
                uploadRequest2,
                getRequest1,
                getRequest2);
        assertNotNull(responses);
        assertEquals(4, responses.size());
        assertNoErrors(responses);

        JSONObject retrievedPhoto1 = responses.get(2).getJSONObject();
        JSONObject retrievedPhoto2 = responses.get(3).getJSONObject();
        assertNotNull(retrievedPhoto1);
        assertNotNull(retrievedPhoto2);

        assertEquals(image1Size, retrievedPhoto1.optInt("width"));
        assertEquals(image2Size, retrievedPhoto2.optInt("width"));
    }

    @LargeTest
    public void testCallbacksAreCalled() {
        setBatchApplicationIdForTestApp();

        ArrayList<GraphRequest> requests = new ArrayList<GraphRequest>();
        final ArrayList<Boolean> calledBack = new ArrayList<Boolean>();

        final int NUM_REQUESTS = 4;
        for (int i = 0; i < NUM_REQUESTS; ++i) {
            GraphRequest request = new GraphRequest(null, "4");

            request.setCallback(new GraphRequest.Callback() {
                @Override
                public void onCompleted(GraphResponse response) {
                    calledBack.add(true);
                }
            });

            requests.add(request);
        }

        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(requests);
        assertNotNull(responses);
        assertTrue(calledBack.size() == NUM_REQUESTS);
    }


    @LargeTest
    public void testExplicitDependencyDefaultsToOmitFirstResponse() {
        final AccessToken accessToken = getAccessTokenForSharedUser();

        GraphRequest requestMe = GraphRequest.newMeRequest(accessToken, null);
        requestMe.setBatchEntryName("me_request");

        GraphRequest requestMyFriends = GraphRequest.newMyFriendsRequest(accessToken, null);
        requestMyFriends.setBatchEntryDependsOn("me_request");

        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(requestMe, requestMyFriends);

        GraphResponse meResponse = responses.get(0);
        GraphResponse myFriendsResponse = responses.get(1);

        assertNull(meResponse.getJSONObject());
        assertNotNull(myFriendsResponse.getJSONObject());
    }

    @LargeTest
    public void testExplicitDependencyCanIncludeFirstResponse() {
        final AccessToken accessToken = getAccessTokenForSharedUser();

        GraphRequest requestMe = GraphRequest.newMeRequest(accessToken, null);
        requestMe.setBatchEntryName("me_request");
        requestMe.setBatchEntryOmitResultOnSuccess(false);

        GraphRequest requestMyFriends = GraphRequest.newMyFriendsRequest(accessToken, null);
        requestMyFriends.setBatchEntryDependsOn("me_request");

        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(requestMe, requestMyFriends);

        GraphResponse meResponse = responses.get(0);
        GraphResponse myFriendsResponse = responses.get(1);

        assertNotNull(meResponse.getJSONObject());
        assertNotNull(myFriendsResponse.getJSONObject());
    }

    @LargeTest
    public void testAddAndRemoveBatchCallbacks() {
        GraphRequestBatch batch = new GraphRequestBatch();

        GraphRequestBatch.Callback callback1 = new GraphRequestBatch.Callback() {
            @Override
            public void onBatchCompleted(GraphRequestBatch batch) {
            }
        };

        GraphRequestBatch.Callback callback2 = new GraphRequestBatch.Callback() {
            @Override
            public void onBatchCompleted(GraphRequestBatch batch) {
            }
        };

        batch.addCallback(callback1);
        batch.addCallback(callback2);

        assertEquals(2, batch.getCallbacks().size());

        batch.removeCallback(callback1);
        batch.removeCallback(callback2);

        assertEquals(0, batch.getCallbacks().size());
    }

    @LargeTest
    public void testBatchCallbackIsCalled() {
        final AtomicInteger count = new AtomicInteger();
        GraphRequest request1 = GraphRequest.newGraphPathRequest(null, "4", new GraphRequest.Callback() {
            @Override
            public void onCompleted(GraphResponse response) {
                count.incrementAndGet();
            }
        });
        GraphRequest request2 = GraphRequest.newGraphPathRequest(null, "4", new GraphRequest.Callback() {
            @Override
            public void onCompleted(GraphResponse response) {
                count.incrementAndGet();
            }
        });

        GraphRequestBatch batch = new GraphRequestBatch(request1, request2);
        batch.addCallback(new GraphRequestBatch.Callback() {
            @Override
            public void onBatchCompleted(GraphRequestBatch batch) {
                count.incrementAndGet();
            }
        });

        batch.executeAndWait();
        assertEquals(3, count.get());
    }

    @LargeTest
    public void testBatchOnProgressCallbackIsCalled() {
        final AtomicInteger count = new AtomicInteger();

        final AccessToken accessToken = getAccessTokenForSharedUser();

        String appId = getApplicationId();
        GraphRequest.setDefaultBatchApplicationId(appId);

        GraphRequest request1 = GraphRequest.newGraphPathRequest(accessToken, "4", null);
        assertNotNull(request1);
        GraphRequest request2 = GraphRequest.newGraphPathRequest(accessToken, "4", null);
        assertNotNull(request2);

        GraphRequestBatch batch = new GraphRequestBatch(request1, request2);
        batch.addCallback(new GraphRequestBatch.OnProgressCallback() {
            @Override
            public void onBatchCompleted(GraphRequestBatch batch) {
            }

            @Override
            public void onBatchProgress(GraphRequestBatch batch, long current, long max) {
                count.incrementAndGet();
            }
        });

        batch.executeAndWait();
        assertEquals(1, count.get());
    }

    @LargeTest
    public void testBatchLastOnProgressCallbackIsCalledOnce() {
        final AtomicInteger count = new AtomicInteger();

        final AccessToken accessToken = getAccessTokenForSharedUser();

        String appId = getApplicationId();
        GraphRequest.setDefaultBatchApplicationId(appId);

        GraphRequest request1 = GraphRequest.newGraphPathRequest(accessToken, "4", null);
        assertNotNull(request1);
        GraphRequest request2 = GraphRequest.newGraphPathRequest(accessToken, "4", null);
        assertNotNull(request2);

        GraphRequestBatch batch = new GraphRequestBatch(request1, request2);
        batch.addCallback(new GraphRequestBatch.OnProgressCallback() {
            @Override
            public void onBatchCompleted(GraphRequestBatch batch) {
            }

            @Override
            public void onBatchProgress(GraphRequestBatch batch, long current, long max) {
                if (current == max) {
                    count.incrementAndGet();
                }
                else if (current > max) {
                    count.set(0);
                }
            }
        });

        batch.executeAndWait();
        assertEquals(1, count.get());
    }


    @LargeTest
    public void testMixedBatchCallbacks() {
        final AtomicInteger requestProgressCount = new AtomicInteger();
        final AtomicInteger requestCompletedCount = new AtomicInteger();
        final AtomicInteger batchProgressCount = new AtomicInteger();
        final AtomicInteger batchCompletedCount = new AtomicInteger();

        final AccessToken accessToken = getAccessTokenForSharedUser();

        String appId = getApplicationId();
        GraphRequest.setDefaultBatchApplicationId(appId);

        GraphRequest request1 = GraphRequest.newGraphPathRequest(
                null, "4", new GraphRequest.OnProgressCallback() {
            @Override
            public void onCompleted(GraphResponse response) {
                requestCompletedCount.incrementAndGet();
            }

            @Override
            public void onProgress(long current, long max) {
                if (current == max) {
                    requestProgressCount.incrementAndGet();
                }
                else if (current > max) {
                    requestProgressCount.set(0);
                }
            }
        });
        assertNotNull(request1);

        GraphRequest request2 = GraphRequest.newGraphPathRequest(null, "4", null);
        assertNotNull(request2);

        GraphRequestBatch batch = new GraphRequestBatch(request1, request2);
        batch.addCallback(new GraphRequestBatch.OnProgressCallback() {
            @Override
            public void onBatchCompleted(GraphRequestBatch batch) {
                batchCompletedCount.incrementAndGet();
            }

            @Override
            public void onBatchProgress(GraphRequestBatch batch, long current, long max) {
                if (current == max) {
                    batchProgressCount.incrementAndGet();
                } else if (current > max) {
                    batchProgressCount.set(0);
                }
            }
        });

        batch.executeAndWait();
        
        assertEquals(1, requestProgressCount.get());
        assertEquals(1, requestCompletedCount.get());
        assertEquals(1, batchProgressCount.get());
        assertEquals(1, batchCompletedCount.get());
    }
}

<code block>


package com.facebook;

import android.graphics.Bitmap;
import android.os.Bundle;
import android.test.suitebuilder.annotation.LargeTest;
import android.test.suitebuilder.annotation.MediumTest;
import android.test.suitebuilder.annotation.SmallTest;

import com.facebook.internal.BundleJSONConverter;
import com.facebook.share.internal.ShareInternalUtility;

import org.json.JSONArray;
import org.json.JSONObject;

import java.net.HttpURLConnection;
import java.util.Arrays;

public class AsyncRequestTests extends FacebookTestCase {

    @SmallTest
    @MediumTest
    @LargeTest
    public void testCanLaunchAsyncRequestFromUiThread() {
        GraphRequest request = GraphRequest.newPostRequest(null, "me/feeds", null, null);
        try {
            TestGraphRequestAsyncTask task = createAsyncTaskOnUiThread(request);
            assertNotNull(task);
        } catch (Throwable throwable) {
            assertNull(throwable);
        }
    }

    @SmallTest
    @MediumTest
    @LargeTest
    public void testExecuteWithNullRequestsThrows() throws Exception {
        try {
            TestGraphRequestAsyncTask task = new TestGraphRequestAsyncTask((GraphRequest[]) null);

            task.executeOnBlockerThread();

            waitAndAssertSuccessOrRethrow(1);

            fail("expected NullPointerException");
        } catch (NullPointerException exception) {
        }
    }

    @SmallTest
    @MediumTest
    @LargeTest
    public void testExecuteBatchWithZeroRequestsThrows() throws Exception {
        try {
            TestGraphRequestAsyncTask task = new TestGraphRequestAsyncTask(new GraphRequest[] {});

            task.executeOnBlockerThread();

            waitAndAssertSuccessOrRethrow(1);

            fail("expected IllegalArgumentException");
        } catch (IllegalArgumentException exception) {
        }
    }

    @SmallTest
    @MediumTest
    @LargeTest
    public void testExecuteBatchWithNullRequestThrows() throws Exception {
        try {
            TestGraphRequestAsyncTask task = new TestGraphRequestAsyncTask(
                    new GraphRequest[] { null });

            task.executeOnBlockerThread();

            waitAndAssertSuccessOrRethrow(1);

            fail("expected NullPointerException");
        } catch (NullPointerException exception) {
        }

    }

    @MediumTest
    @LargeTest
    public void testExecuteSingleGet() {
        final AccessToken accessToken = getAccessTokenForSharedUser();
        Bundle parameters = new Bundle();
        parameters.putString("fields", "location");
        GraphRequest request = new GraphRequest(
                accessToken,
                "TourEiffel",
                parameters,
                null,
                new ExpectSuccessCallback() {
                    @Override
                    protected void performAsserts(GraphResponse response) {
                        assertNotNull(response);
                        JSONObject graphPlace = response.getJSONObject();
                        assertEquals(
                                "Paris",
                                graphPlace.optJSONObject("location").optString("city"));
                    }
                });

        TestGraphRequestAsyncTask task = new TestGraphRequestAsyncTask(request);

        task.executeOnBlockerThread();

        
        waitAndAssertSuccess(2);
    }

    @MediumTest
    @LargeTest
    public void testExecuteSingleGetUsingHttpURLConnection() {
        final AccessToken accessToken = getAccessTokenForSharedUser();
        Bundle parameters = new Bundle();
        parameters.putString("fields", "location");
        GraphRequest request = new GraphRequest(
                accessToken,
                "TourEiffel",
                parameters,
                null,
                new ExpectSuccessCallback() {
                    @Override
                    protected void performAsserts(GraphResponse response) {
                        assertNotNull(response);
                        JSONObject graphPlace = response.getJSONObject();
                        assertEquals(
                                "Paris",
                                graphPlace.optJSONObject("location").optString("city"));
                    }
                });
        HttpURLConnection connection = GraphRequest.toHttpConnection(request);

        TestGraphRequestAsyncTask task = new TestGraphRequestAsyncTask(
                connection,
                Arrays.asList(new GraphRequest[] { request }));

        task.executeOnBlockerThread();

        
        waitAndAssertSuccess(2);
    }

    @MediumTest
    @LargeTest
    public void testExecuteSingleGetFailureCase() {
        final AccessToken accessToken = getAccessTokenForSharedUser();
        GraphRequest request = new GraphRequest(accessToken, "-1", null, null,
                new ExpectFailureCallback());

        TestGraphRequestAsyncTask task = new TestGraphRequestAsyncTask(request);

        task.executeOnBlockerThread();

        
        waitAndAssertSuccess(2);
    }

    @SmallTest
    @MediumTest
    @LargeTest
    public void testBatchWithoutAppIDIsError() throws Throwable {
        GraphRequest request1 = new GraphRequest(null, "TourEiffel", null, null, new ExpectFailureCallback());
        GraphRequest request2 = new GraphRequest(null, "SpaceNeedle", null, null, new ExpectFailureCallback());

        TestGraphRequestAsyncTask task = new TestGraphRequestAsyncTask(request1, request2);

        task.executeOnBlockerThread();

        
        waitAndAssertSuccessOrRethrow(3);
    }

    @LargeTest
    public void testMixedSuccessAndFailure() {
        final AccessToken accessToken = getAccessTokenForSharedUser();

        final int NUM_REQUESTS = 8;
        GraphRequest[] requests = new GraphRequest[NUM_REQUESTS];
        for (int i = 0; i < NUM_REQUESTS; ++i) {
            boolean shouldSucceed = (i % 2) == 1;
            if (shouldSucceed) {
                requests[i] = new GraphRequest(accessToken, "me", null, null,
                        new ExpectSuccessCallback());
            } else {
                requests[i] = new GraphRequest(accessToken, "-1", null, null,
                        new ExpectFailureCallback());
            }
        }

        TestGraphRequestAsyncTask task = new TestGraphRequestAsyncTask(requests);

        task.executeOnBlockerThread();

        
        waitAndAssertSuccess(NUM_REQUESTS + 1);
    }

    @MediumTest
    @LargeTest
    public void testStaticExecuteMeAsync() {
        final AccessToken accessToken = getAccessTokenForSharedUser();

        class MeCallback extends ExpectSuccessCallback implements GraphRequest.GraphJSONObjectCallback {
            @Override
            public void onCompleted(JSONObject me, GraphResponse response) {
                assertNotNull(me);
                assertEquals(accessToken.getUserId(), me.optString("id"));
                RequestTests.validateMeResponse(accessToken, response);
                onCompleted(response);
            }
        }

        runOnBlockerThread(new Runnable() {
            @Override
            public void run() {
                GraphRequest.newMeRequest(accessToken, new MeCallback()).executeAsync();
            }
        }, false);
        waitAndAssertSuccess(1);
    }

    @MediumTest
    @LargeTest
    public void testStaticExecuteMyFriendsAsync() {
        final AccessToken accessToken = getAccessTokenForSharedUser();

        class FriendsCallback extends ExpectSuccessCallback implements GraphRequest.GraphJSONArrayCallback {
            @Override
            public void onCompleted(JSONArray friends, GraphResponse response) {
                assertNotNull(friends);
                RequestTests.validateMyFriendsResponse(response);
                onCompleted(response);
            }
        }

        runOnBlockerThread(new Runnable() {
            @Override
            public void run() {
                GraphRequest.newMyFriendsRequest(accessToken, new FriendsCallback()).executeAsync();
            }
        }, false);
        waitAndAssertSuccess(1);
    }

    @LargeTest
    public void testBatchUploadPhoto() {
        final AccessToken accessToken = getAccessTokenForSharedUserWithPermissions(null,
                "user_photos", "publish_actions");

        final int image1Size = 120;
        final int image2Size = 150;

        Bitmap bitmap1 = createTestBitmap(image1Size);
        Bitmap bitmap2 = createTestBitmap(image2Size);

        Bundle parameters = new Bundle();
        parameters.putString("fields", "width");

        GraphRequest uploadRequest1 = GraphRequest.newUploadPhotoRequest(
                accessToken,
                ShareInternalUtility.MY_PHOTOS,
                bitmap1,
                null,
                null,
                null);
        uploadRequest1.setBatchEntryName("uploadRequest1");
        GraphRequest uploadRequest2 = GraphRequest.newUploadPhotoRequest(
                accessToken,
                ShareInternalUtility.MY_PHOTOS,
                bitmap2,
                null,
                null,
                null);
        uploadRequest2.setBatchEntryName("uploadRequest2");
        GraphRequest getRequest1 = new GraphRequest(
                accessToken,
                "{result=uploadRequest1:$.id}",
                parameters,
                null,
                new ExpectSuccessCallback() {
                    @Override
                    protected void performAsserts(GraphResponse response) {
                        assertNotNull(response);
                        JSONObject retrievedPhoto = response.getJSONObject();
                        assertNotNull(retrievedPhoto);
                        assertEquals(image1Size, retrievedPhoto.optInt("width"));
                    }
                });
        GraphRequest getRequest2 = new GraphRequest(
                accessToken,
                "{result=uploadRequest2:$.id}",
                parameters,
                null,
                new ExpectSuccessCallback() {
                    @Override
                    protected void performAsserts(GraphResponse response) {
                        assertNotNull(response);
                        JSONObject retrievedPhoto = response.getJSONObject();
                        assertNotNull(retrievedPhoto);
                        assertEquals(image2Size, retrievedPhoto.optInt("width"));
                    }
                });

        TestGraphRequestAsyncTask task = new TestGraphRequestAsyncTask(
                uploadRequest1,
                uploadRequest2,
                getRequest1,
                getRequest2);
        task.executeOnBlockerThread();

        
        waitAndAssertSuccess(3);
    }

    @MediumTest
    @LargeTest
    public void testShortTimeoutCausesFailure() {
        final AccessToken accessToken = getAccessTokenForSharedUser();

        GraphRequest request = new GraphRequest(accessToken, "me/likes", null, null,
                new ExpectFailureCallback());

        GraphRequestBatch requestBatch = new GraphRequestBatch(request);

        
        requestBatch.setTimeout(1);

        TestGraphRequestAsyncTask task = new TestGraphRequestAsyncTask(requestBatch);
        task.executeOnBlockerThread();

        
        waitAndAssertSuccess(2);
    }

    @LargeTest
    public void testLongTimeoutAllowsSuccess() {
        final AccessToken accessToken = getAccessTokenForSharedUser();

        GraphRequest request = new GraphRequest(accessToken, "me", null, null,
                new ExpectSuccessCallback());

        GraphRequestBatch requestBatch = new GraphRequestBatch(request);

        
        requestBatch.setTimeout(10000);

        TestGraphRequestAsyncTask task = new TestGraphRequestAsyncTask(requestBatch);
        task.executeOnBlockerThread();

        
        waitAndAssertSuccess(2);
    }
}

<code block>


package com.facebook;

import android.app.Activity;
import android.content.res.AssetManager;
import android.graphics.Bitmap;
import android.graphics.Color;
import android.os.Bundle;
import android.os.ConditionVariable;
import android.os.Handler;
import android.test.ActivityInstrumentationTestCase2;
import android.util.Log;
import com.facebook.internal.Utility;
import junit.framework.AssertionFailedError;
import org.json.JSONException;
import org.json.JSONObject;
import org.json.JSONTokener;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.HttpURLConnection;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

public class FacebookActivityTestCase<T extends Activity> extends ActivityInstrumentationTestCase2<T> {
    private static final String TAG = FacebookActivityTestCase.class.getSimpleName();

    private static String applicationId;
    private static String applicationSecret;
    private static String clientToken;
    private static TestUserManager testUserManager;

    public final static String SECOND_TEST_USER_TAG = "Second";
    public final static String THIRD_TEST_USER_TAG = "Third";

    private TestBlocker testBlocker;

    protected synchronized TestBlocker getTestBlocker() {
        if (testBlocker == null) {
            testBlocker = TestBlocker.createTestBlocker();
        }
        return testBlocker;
    }

    public FacebookActivityTestCase(Class<T> activityClass) {
        super("", activityClass);
    }

    protected String[] getDefaultPermissions() { return null; };

    protected AccessToken getAccessTokenForSharedUser() {
        return getAccessTokenForSharedUser(null);
    }

    protected AccessToken getAccessTokenForSharedUser(String sessionUniqueUserTag) {
        return getAccessTokenForSharedUserWithPermissions(sessionUniqueUserTag,
                getDefaultPermissions());
    }

    protected AccessToken getAccessTokenForSharedUserWithPermissions(String sessionUniqueUserTag,
        List<String> permissions) {
        return getTestUserManager().getAccessTokenForSharedUser(permissions, sessionUniqueUserTag);
    }

    protected AccessToken getAccessTokenForSharedUserWithPermissions(String sessionUniqueUserTag,
                                                                      String... permissions) {
        List<String> permissionList = (permissions != null) ? Arrays.asList(permissions) : null;
        return getAccessTokenForSharedUserWithPermissions(sessionUniqueUserTag, permissionList);
    }

    protected TestUserManager getTestUserManager() {
        if (testUserManager == null) {
            synchronized (FacebookActivityTestCase.class) {
                if (testUserManager == null) {
                    readApplicationIdAndSecret();
                    testUserManager = new TestUserManager(applicationSecret, applicationId);
                }
            }
        }

        return testUserManager;
    }

    
    protected void waitAndAssertSuccess(TestBlocker testBlocker, int numSignals) {
        try {
            testBlocker.waitForSignalsAndAssertSuccess(numSignals);
        } catch (AssertionFailedError e) {
            throw e;
        } catch (Exception e) {
            fail("Got exception: " + e.getMessage());
        }
    }

    protected void waitAndAssertSuccess(int numSignals) {
        waitAndAssertSuccess(getTestBlocker(), numSignals);
    }

    protected void waitAndAssertSuccessOrRethrow(int numSignals) throws Exception {
        getTestBlocker().waitForSignalsAndAssertSuccess(numSignals);
    }

    protected void runAndBlockOnUiThread(final int expectedSignals, final Runnable runnable) throws Throwable {
        final TestBlocker blocker = getTestBlocker();
        runTestOnUiThread(new Runnable() {
            @Override
            public void run() {
                runnable.run();
                blocker.signal();
            }
        });
        
        blocker.waitForSignals(1 + expectedSignals);
        
        
        getInstrumentation().waitForIdleSync();
    }

    protected synchronized void readApplicationIdAndSecret() {
        synchronized (FacebookTestCase.class) {
            if (applicationId != null && applicationSecret != null && clientToken != null) {
                return;
            }

            AssetManager assets = getInstrumentation().getTargetContext().getResources().getAssets();
            InputStream stream = null;
            final String errorMessage = "could not read applicationId and applicationSecret from config.json; ensure "
                    + "you have run 'configure_unit_tests.sh'. Error: ";
            try {
                stream = assets.open("config.json");
                String string = Utility.readStreamToString(stream);

                JSONTokener tokener = new JSONTokener(string);
                Object obj = tokener.nextValue();
                if (!(obj instanceof JSONObject)) {
                    fail(errorMessage + "could not deserialize a JSONObject");
                }
                JSONObject jsonObject = (JSONObject) obj;

                applicationId = jsonObject.optString("applicationId");
                applicationSecret = jsonObject.optString("applicationSecret");
                clientToken = jsonObject.optString("clientToken");

                if (Utility.isNullOrEmpty(applicationId) || Utility.isNullOrEmpty(applicationSecret) ||
                        Utility.isNullOrEmpty(clientToken)) {
                    fail(errorMessage + "config values are missing");
                }
            } catch (IOException e) {
                fail(errorMessage + e.toString());
            } catch (JSONException e) {
                fail(errorMessage + e.toString());
            } finally {
                if (stream != null) {
                    try {
                        stream.close();
                    } catch (IOException e) {
                        fail(errorMessage + e.toString());
                    }
                }
            }
        }
    }

    protected static String getApplicationId() {
        return applicationId;
    }

    protected static String getApplicationSecret() {
        return applicationSecret;
    }

    protected void setUp() throws Exception {
        super.setUp();

        
        FacebookSdk.setIsDebugEnabled(true);

        
        readApplicationIdAndSecret();

        FacebookSdk.sdkInitialize(getInstrumentation().getTargetContext());
        FacebookSdk.setApplicationId(applicationId);
        FacebookSdk.setClientToken(clientToken);

        
        FacebookSdk.addLoggingBehavior(LoggingBehavior.REQUESTS);
        FacebookSdk.addLoggingBehavior(LoggingBehavior.INCLUDE_ACCESS_TOKENS);

        
        
        

        
        System.setProperty("dexmaker.dexcache",
                getInstrumentation().getTargetContext().getCacheDir().getPath());
    }

    protected void tearDown() throws Exception {
        super.tearDown();

        synchronized (this) {
            if (testBlocker != null) {
                testBlocker.quit();
            }
        }
    }

    protected Bundle getNativeLinkingExtras(String token, String userId) {
        readApplicationIdAndSecret();

        Bundle extras = new Bundle();
        String extraLaunchUriString = String
                .format("fbrpc:
                        applicationId, token);
        extras.putString("extra_launch_uri", extraLaunchUriString);
        extras.putString("expires_in", "3600");
        extras.putLong("app_id", Long.parseLong(applicationId));
        extras.putString("access_token", token);
        if(userId != null && !userId.isEmpty()) {
            extras.putString("user_id", userId);
        }

        return extras;
    }

    protected JSONObject getAndAssert(AccessToken accessToken, String id) {
        Bundle parameters = new Bundle();
        parameters.putString("fields", "message");

        GraphRequest request = new GraphRequest(accessToken, id, parameters, null);
        GraphResponse response = request.executeAndWait();
        assertNotNull(response);

        assertNull(response.getError());

        JSONObject result = response.getJSONObject();
        assertNotNull(result);

        return result;
    }

    protected JSONObject postGetAndAssert(AccessToken accessToken, String path,
                                          JSONObject graphObject) {
        GraphRequest request = GraphRequest.newPostRequest(accessToken, path, graphObject, null);
        GraphResponse response = request.executeAndWait();
        assertNotNull(response);

        assertNull(response.getError());

        JSONObject result = response.getJSONObject();
        assertNotNull(result);
        assertNotNull(result.optString("id"));

        return getAndAssert(accessToken, result.optString("id"));
    }

    protected void setBatchApplicationIdForTestApp() {
        readApplicationIdAndSecret();
        GraphRequest.setDefaultBatchApplicationId(applicationId);
    }

    protected JSONObject batchCreateAndGet(AccessToken accessToken, String graphPath,
                                           JSONObject graphObject, String fields) {
        GraphRequest create = GraphRequest.newPostRequest(accessToken, graphPath, graphObject,
                new ExpectSuccessCallback());
        create.setBatchEntryName("create");
        GraphRequest get = GraphRequest.newGraphPathRequest(accessToken, "{result=create:$.id}",
                new ExpectSuccessCallback());
        if (fields != null) {
            Bundle parameters = new Bundle();
            parameters.putString("fields", fields);
            get.setParameters(parameters);
        }

        return batchPostAndGet(create, get);
    }

    protected JSONObject batchUpdateAndGet(AccessToken accessToken, String graphPath,
                                           JSONObject graphObject, String fields) {
        GraphRequest update = GraphRequest.newPostRequest(accessToken, graphPath, graphObject,
                new ExpectSuccessCallback());
        GraphRequest get = GraphRequest.newGraphPathRequest(accessToken, graphPath,
                new ExpectSuccessCallback());
        if (fields != null) {
            Bundle parameters = new Bundle();
            parameters.putString("fields", fields);
            get.setParameters(parameters);
        }

        return batchPostAndGet(update, get);
    }

    protected JSONObject batchPostAndGet(GraphRequest post, GraphRequest get) {
        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(post, get);
        assertEquals(2, responses.size());

        JSONObject resultGraphObject = responses.get(1).getJSONObject();
        assertNotNull(resultGraphObject);
        return resultGraphObject;
    }

    protected JSONObject createStatusUpdate(String unique) {
        JSONObject statusUpdate = new JSONObject();
        String message = String.format(
                "Check out my awesome new status update posted at: %s. Some chars for you: +\"[]:,%s", new Date(),
                unique);
        try {
            statusUpdate.put("message", message);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        return statusUpdate;
    }

    protected Bitmap createTestBitmap(int size) {
        Bitmap image = Bitmap.createBitmap(size, size, Bitmap.Config.RGB_565);
        image.eraseColor(Color.BLUE);
        return image;
    }

    protected void assertDateEqualsWithinDelta(Date expected, Date actual, long deltaInMsec) {
        long delta = Math.abs(expected.getTime() - actual.getTime());
        assertTrue(delta < deltaInMsec);
    }

    protected void assertDateDiffersWithinDelta(Date expected, Date actual, long expectedDifference, long deltaInMsec) {
        long delta = Math.abs(expected.getTime() - actual.getTime()) - expectedDifference;
        assertTrue(delta < deltaInMsec);
    }

    protected void assertNoErrors(List<GraphResponse> responses) {
        for (int i = 0; i < responses.size(); ++i) {
            GraphResponse response = responses.get(i);
            assertNotNull(response);
            assertNull(response.getError());
        }
    }

    protected File createTempFileFromAsset(String assetPath) throws IOException {
        InputStream inputStream = null;
        FileOutputStream outStream = null;

        try {
            AssetManager assets = getActivity().getResources().getAssets();
            inputStream = assets.open(assetPath);

            File outputDir = getActivity().getCacheDir(); 
            File outputFile = File.createTempFile("prefix", assetPath, outputDir);
            outStream = new FileOutputStream(outputFile);

            final int bufferSize = 1024 * 2;
            byte[] buffer = new byte[bufferSize];
            int n = 0;
            while ((n = inputStream.read(buffer)) != -1) {
                outStream.write(buffer, 0, n);
            }

            return outputFile;
        } finally {
            Utility.closeQuietly(outStream);
            Utility.closeQuietly(inputStream);
        }
    }

    protected void runOnBlockerThread(final Runnable runnable, boolean waitForCompletion) {
        Runnable runnableToPost = runnable;
        final ConditionVariable condition = waitForCompletion ? new ConditionVariable(!waitForCompletion) : null;

        if (waitForCompletion) {
            runnableToPost = new Runnable() {
                @Override
                public void run() {
                    runnable.run();
                    condition.open();
                }
            };
        }

        TestBlocker blocker = getTestBlocker();
        Handler handler = blocker.getHandler();
        handler.post(runnableToPost);

        if (waitForCompletion) {
            boolean success = condition.block(10000);
            assertTrue(success);
        }
    }

    protected void closeBlockerAndAssertSuccess() {
        TestBlocker blocker;
        synchronized (this) {
            blocker = getTestBlocker();
            testBlocker = null;
        }

        blocker.quit();

        boolean joined = false;
        while (!joined) {
            try {
                blocker.join();
                joined = true;
            } catch (InterruptedException e) {
            }
        }

        try {
            blocker.assertSuccess();
        } catch (Exception e) {
            fail(e.toString());
        }
    }

    protected TestGraphRequestAsyncTask createAsyncTaskOnUiThread(final GraphRequest... requests) throws Throwable {
        final ArrayList<TestGraphRequestAsyncTask> result = new ArrayList<TestGraphRequestAsyncTask>();
        runTestOnUiThread(new Runnable() {
            @Override
            public void run() {
                result.add(new TestGraphRequestAsyncTask(requests));
            }
        });
        return result.isEmpty() ? null : result.get(0);
    }

    

    
    
    protected class TestGraphRequestAsyncTask extends GraphRequestAsyncTask {
        private final TestBlocker blocker = FacebookActivityTestCase.this.getTestBlocker();

        public TestGraphRequestAsyncTask(GraphRequest... requests) {
            super(requests);
        }

        public TestGraphRequestAsyncTask(List<GraphRequest> requests) {
            super(requests);
        }

        public TestGraphRequestAsyncTask(GraphRequestBatch requests) {
            super(requests);
        }

        public TestGraphRequestAsyncTask(HttpURLConnection connection, GraphRequest... requests) {
            super(connection, requests);
        }

        public TestGraphRequestAsyncTask(HttpURLConnection connection, List<GraphRequest> requests) {
            super(connection, requests);
        }

        public TestGraphRequestAsyncTask(HttpURLConnection connection, GraphRequestBatch requests) {
            super(connection, requests);
        }

        public final TestBlocker getBlocker() {
            return blocker;
        }

        public final Exception getThrowable() {
            return getException();
        }

        protected void onPostExecute(List<GraphResponse> result) {
            try {
                super.onPostExecute(result);

                if (getException() != null) {
                    blocker.setException(getException());
                }
            } finally {
                Log.d("TestRequestAsyncTask", "signaling blocker");
                blocker.signal();
            }
        }

        
        
        
        public void executeOnBlockerThread() {
            ensureAsyncTaskLoaded();

            Runnable runnable = new Runnable() {
                public void run() {
                    execute();
                }
            };
            Handler handler = new Handler(blocker.getLooper());
            handler.post(runnable);
        }

        private void ensureAsyncTaskLoaded() {
            
            try {
                runAndBlockOnUiThread(0, new Runnable() {
                    @Override
                    public void run() {
                        try {
                            Class.forName("android.os.AsyncTask");
                        } catch (ClassNotFoundException e) {
                        }
                    }
                });
            } catch (Throwable throwable) {
            }
        }
    }

    
    
    protected class TestCallback implements GraphRequest.Callback {
        private final TestBlocker blocker;
        private final boolean expectSuccess;

        public TestCallback(TestBlocker blocker, boolean expectSuccess) {
            this.blocker = blocker;
            this.expectSuccess = expectSuccess;
        }

        public TestCallback(boolean expectSuccess) {
            this(FacebookActivityTestCase.this.getTestBlocker(), expectSuccess);
        }

        @Override
        public void onCompleted(GraphResponse response) {
            try {
                
                if (Thread.currentThread() != blocker) {
                    throw new FacebookException("Invalid thread " + Thread.currentThread().getId()
                            + "; expected to be called on thread " + blocker.getId());
                }

                
                if (expectSuccess && response.getError() != null) {
                    throw response.getError().getException();
                } else if (!expectSuccess && response.getError() == null) {
                    throw new FacebookException("Expected failure case, received no error");
                }

                
                performAsserts(response);
            } catch (Exception e) {
                blocker.setException(e);
            } finally {
                
                blocker.signal();
            }
        }

        protected void performAsserts(GraphResponse response) {
        }
    }

    
    protected class ExpectSuccessCallback extends TestCallback {
        public ExpectSuccessCallback() {
            super(true);
        }
    }

    
    protected class ExpectFailureCallback extends TestCallback {
        public ExpectFailureCallback() {
            super(false);
        }
    }

    public static abstract class MockGraphRequest extends GraphRequest {
        public abstract GraphResponse createResponse();
    }

    public static class MockGraphRequestBatch extends GraphRequestBatch {
        public MockGraphRequestBatch(MockGraphRequest... requests) {
            super(requests);
        }

        
        public MockGraphRequestBatch(GraphRequestBatch requests) {
            super(requests);
        }

        @Override
        List<GraphResponse> executeAndWaitImpl() {
            List<GraphRequest> requests = getRequests();

            List<GraphResponse> responses = new ArrayList<GraphResponse>();
            for (GraphRequest request : requests) {
                MockGraphRequest mockRequest = (MockGraphRequest) request;
                responses.add(mockRequest.createResponse());
            }

            GraphRequest.runCallbacks(this, responses);

            return responses;
        }
    }

    private AtomicBoolean strictModeOnForUiThread = new AtomicBoolean();

    protected void turnOnStrictModeForUiThread() {
        
        
        if (strictModeOnForUiThread.get() == false) {
            try {
                runTestOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        
                        if (strictModeOnForUiThread.compareAndSet(false, true)) {
                            turnOnStrictModeForThisThread();
                        }
                    }
                });
            } catch (Throwable throwable) {
            }
        }
    }

    protected void turnOnStrictModeForThisThread() {
        
        
        
        try {
            ClassLoader loader = Thread.currentThread().getContextClassLoader();
            Class<?> strictModeClass = Class.forName("android.os.StrictMode", true, loader);
            Class<?> threadPolicyClass = Class.forName(
                    "android.os.StrictMode$ThreadPolicy",
                    true,
                    loader);
            Class<?> threadPolicyBuilderClass = Class.forName(
                    "android.os.StrictMode$ThreadPolicy$Builder",
                    true,
                    loader);

            Object threadPolicyBuilder = threadPolicyBuilderClass.getConstructor().newInstance();
            threadPolicyBuilder = threadPolicyBuilderClass.getMethod("detectAll").invoke(
                    threadPolicyBuilder);
            threadPolicyBuilder = threadPolicyBuilderClass.getMethod("penaltyDeath").invoke(
                    threadPolicyBuilder);

            Object threadPolicy = threadPolicyBuilderClass.getMethod("build").invoke(
                    threadPolicyBuilder);
            strictModeClass.getMethod("setThreadPolicy", threadPolicyClass).invoke(
                    strictModeClass,
                    threadPolicy);
        } catch (Exception ex) {
        }
    }
}

<code block>


package com.facebook;

import android.graphics.Bitmap;
import android.location.Location;
import android.net.Uri;
import android.os.Bundle;
import android.test.suitebuilder.annotation.LargeTest;

import com.facebook.internal.GraphUtil;
import com.facebook.share.ShareApi;
import com.facebook.share.Sharer;
import com.facebook.share.internal.ShareInternalUtility;
import com.facebook.share.model.ShareOpenGraphAction;
import com.facebook.share.model.ShareOpenGraphContent;
import com.facebook.share.model.ShareOpenGraphObject;
import com.facebook.share.model.SharePhoto;
import com.facebook.share.model.SharePhotoContent;
import com.facebook.share.model.ShareVideo;
import com.facebook.share.model.ShareVideoContent;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.net.HttpURLConnection;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;

public class RequestTests extends FacebookTestCase {
    private static final String TEST_OG_OBJECT_TYPE = "facebooksdktests:test";
    private static final String TEST_OG_ACTION_TYPE = "facebooksdktests:run";
    private static final long REQUEST_TIMEOUT_MILLIS = 10000;

    protected String[] getDefaultPermissions()
    {
        return new String[] {
                "email",
                "publish_actions",
                "read_stream",
                "user_photos",
                "user_videos" };
    };

    @Override
    public void setUp() throws Exception {
        super.setUp();
        AccessToken.setCurrentAccessToken(getAccessTokenForSharedUser());
    }

    @Override
    public void tearDown() throws Exception {
        AccessToken.setCurrentAccessToken(null);
        super.tearDown();
    }

    @LargeTest
    public void testExecuteSingleGet() {
        Bundle parameters = new Bundle();
        parameters.putString("fields", "location");

        GraphRequest request = new GraphRequest(
                AccessToken.getCurrentAccessToken(),
                "TourEiffel",
                parameters,
                null);
        GraphResponse response = request.executeAndWait();

        assertTrue(response != null);
        assertTrue(response.getError() == null);
        assertNotNull(response.getJSONObject());
        assertNotNull(response.getRawResponse());

        JSONObject graphPlace = response.getJSONObject();
        assertEquals("Paris", graphPlace.optJSONObject("location").optString("city"));
    }

    @LargeTest
    public void testBuildsUploadPhotoHttpURLConnection() throws Exception {
        Bitmap image = createTestBitmap(128);

        GraphRequest request = GraphRequest.newUploadPhotoRequest(
                AccessToken.getCurrentAccessToken(),
                ShareInternalUtility.MY_PHOTOS,
                image,
                "Test photo messsage",
                null,
                null);
        HttpURLConnection connection = GraphRequest.toHttpConnection(request);

        assertTrue(connection != null);
        assertNotSame("gzip", connection.getRequestProperty("Content-Encoding"));
        assertNotSame("application/x-www-form-urlencoded", connection.getRequestProperty("Content-Type"));
    }

    @LargeTest
    public void testExecuteSingleGetUsingHttpURLConnection() throws IOException {
        Bundle parameters = new Bundle();
        parameters.putString("fields", "location");

        GraphRequest request = new GraphRequest(
                AccessToken.getCurrentAccessToken(),
                "TourEiffel",
                parameters,
                null);
        HttpURLConnection connection = GraphRequest.toHttpConnection(request);

        assertEquals("gzip", connection.getRequestProperty("Content-Encoding"));
        assertEquals(
                "application/x-www-form-urlencoded",
                connection.getRequestProperty("Content-Type"));

        List<GraphResponse> responses = GraphRequest.executeConnectionAndWait(
                connection,
                Arrays.asList(new GraphRequest[]{request}));
        assertNotNull(responses);
        assertEquals(1, responses.size());

        GraphResponse response = responses.get(0);

        assertTrue(response != null);
        assertTrue(response.getError() == null);
        assertNotNull(response.getJSONObject());
        assertNotNull(response.getRawResponse());

        JSONObject graphPlace = response.getJSONObject();
        assertEquals("Paris", graphPlace.optJSONObject("location").optString("city"));

        
        int code = connection.getResponseCode();
        assertEquals(200, code);
        assertTrue(connection.getHeaderFields().keySet().contains("Content-Type"));
        connection.disconnect();
    }

    @LargeTest
    public void testFacebookErrorResponseCreatesError() {
        GraphRequest request = new GraphRequest(null, "somestringthatshouldneverbeavalidfobjectid");
        GraphResponse response = request.executeAndWait();

        assertTrue(response != null);

        FacebookRequestError error = response.getError();
        assertNotNull(error);
        FacebookException exception = error.getException();
        assertNotNull(exception);

        assertTrue(exception instanceof FacebookServiceException);
        assertNotNull(error.getErrorType());
        assertTrue(error.getErrorCode() != FacebookRequestError.INVALID_ERROR_CODE);
        assertNotNull(error.getRequestResultBody());
    }

    @LargeTest
    public void testRequestWithNoTokenFails() {
        GraphRequest request = new GraphRequest(null, "me");
        GraphResponse response = request.executeAndWait();

        assertNotNull(response.getError());
    }

    @LargeTest
    public void testExecuteRequestMe() {
        GraphRequest request = GraphRequest.newMeRequest(AccessToken.getCurrentAccessToken(), null);
        GraphResponse response = request.executeAndWait();

        validateMeResponse(AccessToken.getCurrentAccessToken(), response);
    }

    static void validateMeResponse(AccessToken accessToken, GraphResponse response) {
        assertNull(response.getError());

        JSONObject me = response.getJSONObject();
        assertNotNull(me);
        assertEquals(accessToken.getUserId(), me.optString("id"));
        assertNotNull(response.getRawResponse());
    }

    @LargeTest
    public void testExecuteMyFriendsRequest() {
        GraphRequest request =
                GraphRequest.newMyFriendsRequest(AccessToken.getCurrentAccessToken(), null);
        GraphResponse response = request.executeAndWait();

        validateMyFriendsResponse(response);
    }

    static void validateMyFriendsResponse(GraphResponse response) {
        assertNotNull(response);

        assertNull(response.getError());

        JSONObject graphResult = response.getJSONObject();
        assertNotNull(graphResult);

        JSONArray results = graphResult.optJSONArray("data");
        assertNotNull(results);

        assertNotNull(response.getRawResponse());
    }

    @LargeTest
    public void testExecutePlaceRequestWithLocation() {
        Location location = new Location("");
        location.setLatitude(47.6204);
        location.setLongitude(-122.3491);

        GraphRequest request = GraphRequest.newPlacesSearchRequest(
                AccessToken.getCurrentAccessToken(),
                location,
                5,
                5,
                null,
                null);
        GraphResponse response = request.executeAndWait();
        assertNotNull(response);

        assertNull(response.getError());

        JSONObject graphResult = response.getJSONObject();
        assertNotNull(graphResult);

        JSONArray results = graphResult.optJSONArray("data");
        assertNotNull(results);

        assertNotNull(response.getRawResponse());
    }

    @LargeTest
    public void testExecutePlaceRequestWithSearchText() {
        
        GraphRequest request = GraphRequest.newPlacesSearchRequest(
                AccessToken.getCurrentAccessToken(),
                null,
                1000,
                5,
                "Starbucks",
                null);
        GraphResponse response = request.executeAndWait();
        assertNotNull(response);

        assertNull(response.getError());

        JSONObject graphResult = response.getJSONObject();
        assertNotNull(graphResult);

        JSONArray results = graphResult.optJSONArray("data");
        assertNotNull(results);

        assertNotNull(response.getRawResponse());
    }

    @LargeTest
    public void testExecutePlaceRequestWithLocationAndSearchText() {
        Location location = new Location("");
        location.setLatitude(47.6204);
        location.setLongitude(-122.3491);

        GraphRequest request = GraphRequest.newPlacesSearchRequest(
                AccessToken.getCurrentAccessToken(),
                location,
                1000,
                5,
                "Starbucks",
                null);
        GraphResponse response = request.executeAndWait();
        assertNotNull(response);

        assertNull(response.getError());

        JSONObject graphResult = response.getJSONObject();
        assertNotNull(graphResult);

        JSONArray results = graphResult.optJSONArray("data");
        assertNotNull(results);

        assertNotNull(response.getRawResponse());
    }

    @LargeTest
    public void testShareOpenGraphContent() throws Exception {
        ShareOpenGraphObject ogObject = new ShareOpenGraphObject.Builder()
                .putString("og:title", "a title")
                .putString("og:type", TEST_OG_OBJECT_TYPE)
                .putString("og:description", "a description")
                .build();

        ShareOpenGraphAction ogAction = new ShareOpenGraphAction.Builder()
                .setActionType(TEST_OG_ACTION_TYPE)
                .putObject("test", ogObject)
                .build();

        ShareOpenGraphContent content = new ShareOpenGraphContent.Builder()
                .setAction(ogAction)
                .setPreviewPropertyName("test")
                .build();

        final ShareApi shareApi = new ShareApi(content);
        final AtomicReference<String> actionId = new AtomicReference<>(null);

        getActivity().runOnUiThread(new Runnable() {
            @Override
            public void run() {
                shareApi.share(new FacebookCallback<Sharer.Result>() {
                    @Override
                    public void onSuccess(Sharer.Result result) {
                        actionId.set(result.getPostId());
                        notifyShareFinished();
                    }

                    @Override
                    public void onCancel() {
                        notifyShareFinished();
                    }

                    @Override
                    public void onError(FacebookException error) {
                        notifyShareFinished();
                    }

                    private void notifyShareFinished() {
                        synchronized (shareApi) {
                            shareApi.notifyAll();
                        }
                    }
                });
            }
        });

        synchronized (shareApi) {
            shareApi.wait(REQUEST_TIMEOUT_MILLIS);
        }
        assertNotNull(actionId.get());
    }

    @LargeTest
    public void testShareOpenGraphContentWithBadType() throws Exception {
        ShareOpenGraphObject ogObject = new ShareOpenGraphObject.Builder()
                .putString("og:title", "a title")
                .putString("og:type", TEST_OG_OBJECT_TYPE)
                .putString("og:description", "a description")
                .build();

        ShareOpenGraphAction ogAction = new ShareOpenGraphAction.Builder()
                .setActionType(TEST_OG_ACTION_TYPE+"bad")
                .putObject("test", ogObject)
                .build();

        ShareOpenGraphContent content = new ShareOpenGraphContent.Builder()
                .setAction(ogAction)
                .setPreviewPropertyName("test")
                .build();

        final ShareApi shareApi = new ShareApi(content);
        final AtomicReference<String> actionId = new AtomicReference<>(null);
        final AtomicBoolean errorOccurred = new AtomicBoolean(false);

        getActivity().runOnUiThread(new Runnable() {
            @Override
            public void run() {
                shareApi.share(new FacebookCallback<Sharer.Result>() {
                    @Override
                    public void onSuccess(Sharer.Result result) {
                        actionId.set(result.getPostId());
                        notifyShareFinished();
                    }

                    @Override
                    public void onCancel() {
                        notifyShareFinished();
                    }

                    @Override
                    public void onError(FacebookException error) {
                        errorOccurred.set(true);
                        notifyShareFinished();
                    }

                    private void notifyShareFinished() {
                        synchronized (shareApi) {
                            shareApi.notifyAll();
                        }
                    }
                });
            }
        });

        synchronized (shareApi) {
            shareApi.wait(REQUEST_TIMEOUT_MILLIS);
        }
        assertNull(actionId.get());
        assertTrue(errorOccurred.get());
    }

    private String executePostOpenGraphRequest() {
        JSONObject data = new JSONObject();
        try {
            data.put("a_property", "hello");
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }

        JSONObject ogObject = GraphUtil.createOpenGraphObjectForPost(
                TEST_OG_OBJECT_TYPE,
                "a title",
                "http:
                "http:
                "a description",
                data,
                null);

        Bundle bundle = new Bundle();
        bundle.putString("object", ogObject.toString());
        GraphRequest request = new GraphRequest(
                AccessToken.getCurrentAccessToken(),
                "/me/objects/" + TEST_OG_OBJECT_TYPE,
                bundle,
                HttpMethod.POST,
                null);

        GraphResponse response = request.executeAndWait();
        assertNotNull(response);

        assertNull(response.getError());

        JSONObject graphResult = response.getJSONObject();
        assertNotNull(graphResult);
        assertNotNull(graphResult.optString("id"));

        assertNotNull(response.getRawResponse());

        return graphResult.optString("id");
    }

    @LargeTest
    public void testExecutePostOpenGraphRequest() {
        executePostOpenGraphRequest();
    }

    @LargeTest
    public void testDeleteObjectRequest() {
        String id = executePostOpenGraphRequest();

        GraphRequest request = GraphRequest.newDeleteObjectRequest(
                AccessToken.getCurrentAccessToken(),
                id,
                null);
        GraphResponse response = request.executeAndWait();
        assertNotNull(response);

        assertNull(response.getError());

        JSONObject result = response.getJSONObject();
        assertNotNull(result);

        assertTrue(result.optBoolean(GraphResponse.SUCCESS_KEY));
        assertNotNull(response.getRawResponse());
    }

    @LargeTest
    public void testUpdateOpenGraphObjectRequest() throws JSONException {
        String id = executePostOpenGraphRequest();

        JSONObject data = new JSONObject();
        data.put("a_property", "goodbye");

        JSONObject ogObject = GraphUtil.createOpenGraphObjectForPost(
                TEST_OG_OBJECT_TYPE,
                "another title",
                null,
                "http:
                "another description",
                data,
                null);
        Bundle bundle = new Bundle();
        bundle.putString("object", ogObject.toString());
        GraphRequest request = new GraphRequest(
                AccessToken.getCurrentAccessToken(),
                id,
                bundle,
                HttpMethod.POST,
                null);
        GraphResponse response = request.executeAndWait();
        assertNotNull(response);

        assertNull(response.getError());

        JSONObject result = response.getJSONObject();
        assertNotNull(result);
        assertEquals("another title", result.optString("title"));
        assertNotNull(response.getRawResponse());
    }

    @LargeTest
    public void testExecuteUploadPhoto() {
        Bitmap image = createTestBitmap(128);

        GraphRequest request = GraphRequest.newUploadPhotoRequest(
                AccessToken.getCurrentAccessToken(),
                ShareInternalUtility.MY_PHOTOS,
                image,
                "Test photo message",
                null,
                null);
        GraphResponse response = request.executeAndWait();
        assertNotNull(response);

        assertNull(response.getError());

        JSONObject result = response.getJSONObject();
        assertNotNull(result);
        assertNotNull(response.getRawResponse());
    }

    @LargeTest
    public void testExecuteUploadPhotoViaFile() throws IOException {
        File outputFile = null;
        FileOutputStream outStream = null;

        try {
            Bitmap image = createTestBitmap(128);

            File outputDir = getActivity().getCacheDir(); 
            outputFile = File.createTempFile("prefix", "extension", outputDir);

            outStream = new FileOutputStream(outputFile);
            image.compress(Bitmap.CompressFormat.PNG, 100, outStream);
            outStream.close();
            outStream = null;

            GraphRequest request = GraphRequest.newUploadPhotoRequest(
                    AccessToken.getCurrentAccessToken(),
                    ShareInternalUtility.MY_PHOTOS,
                    outputFile,
                    "Test photo message",
                    null,
                    null);
            GraphResponse response = request.executeAndWait();
            assertNotNull(response);

            assertNull(response.getError());

            JSONObject result = response.getJSONObject();
            assertNotNull(result);
            assertNotNull(response.getRawResponse());
        } finally {
            if (outStream != null) {
                outStream.close();
            }
            if (outputFile != null) {
                outputFile.delete();
            }
        }
    }

    @LargeTest
    public void testExecuteUploadPhotoToAlbum() throws InterruptedException, JSONException {
        
        Bundle params = new Bundle();
        params.putString("name", "Foo");
        GraphRequest request =
                new GraphRequest(
                        AccessToken.getCurrentAccessToken(),
                        "me/albums",
                        params,
                        HttpMethod.POST);

        GraphResponse response = request.executeAndWait();
        JSONObject jsonResponse = response.getJSONObject();
        assertNotNull(jsonResponse);
        String albumId = jsonResponse.optString("id");
        assertNotNull(albumId);

        
        Bitmap image = createTestBitmap(128);
        SharePhoto photo = new SharePhoto.Builder()
                .setBitmap(image)
                .setUserGenerated(true)
                .build();
        SharePhotoContent content = new SharePhotoContent.Builder().addPhoto(photo).build();
        final ShareApi shareApi = new ShareApi(content);
        shareApi.setGraphNode(albumId);
        final AtomicReference<String> imageId = new AtomicReference<>(null);
        getActivity().runOnUiThread(new Runnable() {
            @Override
            public void run() {
                shareApi.share(new FacebookCallback<Sharer.Result>() {
                    @Override
                    public void onSuccess(Sharer.Result result) {
                        imageId.set(result.getPostId());
                        notifyShareFinished();
                    }

                    @Override
                    public void onCancel() {
                        notifyShareFinished();
                    }

                    @Override
                    public void onError(FacebookException error) {
                        notifyShareFinished();
                    }

                    private void notifyShareFinished() {
                        synchronized (shareApi) {
                            shareApi.notifyAll();
                        }
                    }
                });
            }
        });

        synchronized (shareApi) {
            shareApi.wait(REQUEST_TIMEOUT_MILLIS);
        }
        assertNotNull(imageId.get());

        
        GraphRequest listRequest =
                new GraphRequest(AccessToken.getCurrentAccessToken(), albumId + "/photos");

        GraphResponse listResponse = listRequest.executeAndWait();
        JSONObject listObject = listResponse.getJSONObject();
        assertNotNull(listObject);
        JSONArray jsonList = listObject.optJSONArray("data");
        assertNotNull(jsonList);

        boolean found = false;
        for (int i = 0; i < jsonList.length(); i++) {
            JSONObject imageObject = jsonList.getJSONObject(i);
            if (imageId.get().equals(imageObject.optString("id"))) {
                found = true;
            }
        }
        assertTrue(found);
    }

    @LargeTest
    public void testUploadVideoFile() throws IOException, URISyntaxException {
        File tempFile = null;
        try {
            tempFile = createTempFileFromAsset("DarkScreen.mov");
            ShareVideo video = new ShareVideo.Builder()
                    .setLocalUrl(Uri.fromFile(tempFile))
                    .build();
            ShareVideoContent content = new ShareVideoContent.Builder().setVideo(video).build();
            final ShareApi shareApi = new ShareApi(content);
            final AtomicReference<String> videoId = new AtomicReference<>(null);
            getActivity().runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    shareApi.share(new FacebookCallback<Sharer.Result>() {
                        @Override
                        public void onSuccess(Sharer.Result result) {
                            videoId.set(result.getPostId());
                            notifyShareFinished();
                        }

                        @Override
                        public void onCancel() {
                            notifyShareFinished();
                        }

                        @Override
                        public void onError(FacebookException error) {
                            notifyShareFinished();
                        }

                        private void notifyShareFinished() {
                            synchronized (shareApi) {
                                shareApi.notifyAll();
                            }
                        }
                    });
                }
            });

            synchronized (shareApi) {
                shareApi.wait(REQUEST_TIMEOUT_MILLIS);
            }
            assertNotNull(videoId.get());
        } catch (Exception ex) {
            fail();
        } finally {
            if (tempFile != null) {
                tempFile.delete();
            }
        }
    }

    @LargeTest
    public void testUploadVideoFileToUserId() throws IOException, URISyntaxException {
        File tempFile = null;
        try {
            GraphRequest meRequest =
                    GraphRequest.newMeRequest(AccessToken.getCurrentAccessToken(), null);
            GraphResponse meResponse = meRequest.executeAndWait();
            JSONObject meJson = meResponse.getJSONObject();
            assertNotNull(meJson);

            String userId = meJson.optString("id");
            assertNotNull(userId);

            tempFile = createTempFileFromAsset("DarkScreen.mov");
            ShareVideo video = new ShareVideo.Builder()
                    .setLocalUrl(Uri.fromFile(tempFile))
                    .build();
            ShareVideoContent content = new ShareVideoContent.Builder().setVideo(video).build();
            final ShareApi shareApi = new ShareApi(content);
            shareApi.setGraphNode(userId);
            final AtomicReference<String> videoId = new AtomicReference<>(null);
            getActivity().runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    shareApi.share(new FacebookCallback<Sharer.Result>() {
                        @Override
                        public void onSuccess(Sharer.Result result) {
                            videoId.set(result.getPostId());
                            notifyShareFinished();
                        }

                        @Override
                        public void onCancel() {
                            notifyShareFinished();
                        }

                        @Override
                        public void onError(FacebookException error) {
                            notifyShareFinished();
                        }

                        private void notifyShareFinished() {
                            synchronized (shareApi) {
                                shareApi.notifyAll();
                            }
                        }
                    });
                }
            });

            synchronized (shareApi) {
                shareApi.wait(REQUEST_TIMEOUT_MILLIS);
            }
            assertNotNull(videoId.get());
        } catch (Exception ex) {
            fail();
        } finally {
            if (tempFile != null) {
                tempFile.delete();
            }
        }
    }

    @LargeTest
    public void testPostStatusUpdate() {
        JSONObject statusUpdate = createStatusUpdate("");

        JSONObject retrievedStatusUpdate = postGetAndAssert(
                AccessToken.getCurrentAccessToken(),
                "me/feed",
                statusUpdate);

        assertEquals(statusUpdate.optString("message"), retrievedStatusUpdate.optString("message"));
    }

    @LargeTest
    public void testCallbackIsCalled() {
        GraphRequest request = new GraphRequest(null, "4");

        final ArrayList<Boolean> calledBack = new ArrayList<Boolean>();
        request.setCallback(new GraphRequest.Callback() {
            @Override
            public void onCompleted(GraphResponse response) {
                calledBack.add(true);
            }
        });

        GraphResponse response = request.executeAndWait();
        assertNotNull(response);
        assertTrue(calledBack.size() == 1);
    }

    @LargeTest
    public void testOnProgressCallbackIsCalled() {
        Bitmap image = Bitmap.createBitmap(128, 128, Bitmap.Config.ALPHA_8);

        GraphRequest request = GraphRequest.newUploadPhotoRequest(
                null,
                ShareInternalUtility.MY_PHOTOS,
                image,
                null,
                null,
                null);
        assertTrue(request != null);

        final ArrayList<Boolean> calledBack = new ArrayList<Boolean>();
        request.setCallback(new GraphRequest.OnProgressCallback() {
            @Override
            public void onCompleted(GraphResponse response) {
            }

            @Override
            public void onProgress(long current, long max) {
                calledBack.add(true);
            }
        });

        GraphResponse response = request.executeAndWait();
        assertNotNull(response);
        assertFalse(calledBack.isEmpty());
    }

    @LargeTest
    public void testLastOnProgressCallbackIsCalledOnce() {
        Bitmap image = Bitmap.createBitmap(128, 128, Bitmap.Config.ALPHA_8);

        GraphRequest request = GraphRequest.newUploadPhotoRequest(
                null,
                ShareInternalUtility.MY_PHOTOS,
                image,
                null,
                null,
                null);
        assertTrue(request != null);

        final ArrayList<Boolean> calledBack = new ArrayList<Boolean>();
        request.setCallback(new GraphRequest.OnProgressCallback() {
            @Override
            public void onCompleted(GraphResponse response) {
            }

            @Override
            public void onProgress(long current, long max) {
                if (current == max) calledBack.add(true);
                else if (current > max) calledBack.clear();
            }
        });

        GraphResponse response = request.executeAndWait();
        assertNotNull(response);
        assertEquals(1, calledBack.size());
    }

    @LargeTest
    public void testBatchTimeoutIsApplied() {
        GraphRequest request = new GraphRequest(null, "me");
        GraphRequestBatch batch = new GraphRequestBatch(request);

        
        batch.setTimeout(1);

        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(batch);
        assertNotNull(responses);
        assertTrue(responses.size() == 1);
        GraphResponse response = responses.get(0);
        assertNotNull(response);
        assertNotNull(response.getError());
    }

    @LargeTest
    public void testBatchTimeoutCantBeNegative() {
        try {
            GraphRequestBatch batch = new GraphRequestBatch();
            batch.setTimeout(-1);
            fail();
        } catch (IllegalArgumentException ex) {
        }
    }

    @LargeTest
    public void testCantUseComplexParameterInGetRequest() {
        Bundle parameters = new Bundle();
        parameters.putShortArray("foo", new short[1]);

        GraphRequest request = new GraphRequest(
                AccessToken.getCurrentAccessToken(),
                "me",
                parameters,
                HttpMethod.GET,
                new ExpectFailureCallback());
        GraphResponse response = request.executeAndWait();

        FacebookRequestError error = response.getError();
        assertNotNull(error);
        FacebookException exception = error.getException();
        assertNotNull(exception);
        assertTrue(exception.getMessage().contains("short[]"));
    }

    private final Location SEATTLE_LOCATION = new Location("") {
        {
            setLatitude(47.6097);
            setLongitude(-122.3331);
        }
    };

    @LargeTest
    public void testPaging() {
        final List<JSONObject> returnedPlaces = new ArrayList<JSONObject>();
        GraphRequest request = GraphRequest
                .newPlacesSearchRequest(
                        AccessToken.getCurrentAccessToken(),
                        SEATTLE_LOCATION,
                        1000,
                        3,
                        null,
                        new GraphRequest.GraphJSONArrayCallback() {
                            @Override
                            public void onCompleted(JSONArray places, GraphResponse response) {
                                if (places == null) {
                                    assertNotNull(places);
                                }
                                for (int i = 0; i < places.length(); ++i) {
                                    returnedPlaces.add(places.optJSONObject(i));
                                }
                            }
                        });
        GraphResponse response = request.executeAndWait();

        assertNull(response.getError());
        assertNotNull(response.getJSONObject());
        assertNotSame(0, returnedPlaces.size());

        returnedPlaces.clear();

        GraphRequest nextRequest = response.getRequestForPagedResults(GraphResponse.PagingDirection.NEXT);
        assertNotNull(nextRequest);

        nextRequest.setCallback(request.getCallback());
        response = nextRequest.executeAndWait();

        assertNull(response.getError());
        assertNotNull(response.getJSONObject());
        assertNotSame(0, returnedPlaces.size());

        returnedPlaces.clear();

        GraphRequest previousRequest = response.getRequestForPagedResults(GraphResponse.PagingDirection.PREVIOUS);
        assertNotNull(previousRequest);

        previousRequest.setCallback(request.getCallback());
        response = previousRequest.executeAndWait();

        assertNull(response.getError());
        assertNotNull(response.getJSONObject());
        assertNotSame(0, returnedPlaces.size());
    }
}

<code block>


package com.facebook.login;

import android.support.v4.app.Fragment;
import android.test.suitebuilder.annotation.LargeTest;

import com.facebook.AccessToken;
import com.facebook.FacebookTestCase;
import com.facebook.TestBlocker;

import java.util.*;

public class LoginClientTests extends FacebookTestCase {
    private static final Set<String> PERMISSIONS = new HashSet<String>(
            Arrays.asList("go outside", "come back in"));

    class MockLoginClient extends LoginClient {
        Result result;
        boolean triedNextHandler = false;

        MockLoginClient(Fragment fragment) {
            super(fragment);
        }

        Request getRequest() {
            return pendingRequest;
        }

        void setRequest(Request request) {
            pendingRequest = request;
        }

        @Override
        void complete(Result result) {
            this.result = result;
        }

        @Override
        void tryNextHandler() {
            triedNextHandler = true;
        }
    }

    LoginClient.Request createRequest() {
        return new LoginClient.Request(
                LoginBehavior.NATIVE_WITH_FALLBACK,
                PERMISSIONS,
                DefaultAudience.FRIENDS,
                "1234",
                null
        );
    }

    class MockValidatingLoginClient extends MockLoginClient {
        private final HashMap<String, String> mapAccessTokenToFbid = new HashMap<String, String>();
        private Set<String> permissionsToReport = new HashSet<String>();
        private TestBlocker blocker;

        public MockValidatingLoginClient(Fragment fragment, TestBlocker blocker) {
            super(fragment);
            this.blocker = blocker;
        }

        public void addAccessTokenToFbidMapping(String accessToken, String fbid) {
            mapAccessTokenToFbid.put(accessToken, fbid);
        }

        public void setPermissionsToReport(Set<String> permissionsToReport) {
            this.permissionsToReport = permissionsToReport;
        }

        @Override
        void complete(Result result) {
            super.complete(result);
            blocker.signal();
        }
    }

    static final String USER_1_FBID = "user1";
    static final String USER_1_ACCESS_TOKEN = "An access token for user 1";
    static final String USER_2_FBID = "user2";
    static final String USER_2_ACCESS_TOKEN = "An access token for user 2";
    static final String APP_ID = "1234";

    LoginClient.Request createNewPermissionRequest() {
        return new LoginClient.Request(
                LoginBehavior.NATIVE_WITH_FALLBACK,
                PERMISSIONS,
                DefaultAudience.FRIENDS,
                "1234",
                null
        );
    }

    @LargeTest
    public void testReauthorizationWithSameFbidSucceeds() throws Exception {
        TestBlocker blocker = getTestBlocker();

        MockValidatingLoginClient client = new MockValidatingLoginClient(null, blocker);
        client.addAccessTokenToFbidMapping(USER_1_ACCESS_TOKEN, USER_1_FBID);
        client.addAccessTokenToFbidMapping(USER_2_ACCESS_TOKEN, USER_2_FBID);
        client.setPermissionsToReport(PERMISSIONS);

        LoginClient.Request request = createNewPermissionRequest();
        client.setRequest(request);

        AccessToken token = new AccessToken(
                USER_1_ACCESS_TOKEN,
                APP_ID,
                USER_1_FBID,
                PERMISSIONS,
                null,
                null,
                null,
                null);
        AccessToken.setCurrentAccessToken(token);
        LoginClient.Result result = LoginClient.Result.createTokenResult(request, token);

        client.completeAndValidate(result);

        blocker.waitForSignals(1);

        assertNotNull(client.result);
        assertEquals(LoginClient.Result.Code.SUCCESS, client.result.code);

        AccessToken resultToken = client.result.token;
        assertNotNull(resultToken);
        assertEquals(USER_1_ACCESS_TOKEN, resultToken.getToken());

        
        assertEquals(new HashSet<String>(PERMISSIONS), new HashSet<String>(resultToken.getPermissions()));
    }

    @LargeTest
    public void testReauthorizationWithDifferentFbidsFails() throws Exception {
        TestBlocker blocker = getTestBlocker();

        MockValidatingLoginClient client = new MockValidatingLoginClient(null, blocker);
        client.addAccessTokenToFbidMapping(USER_1_ACCESS_TOKEN, USER_1_FBID);
        client.addAccessTokenToFbidMapping(USER_2_ACCESS_TOKEN, USER_2_FBID);
        client.setPermissionsToReport(PERMISSIONS);

        LoginClient.Request request = createNewPermissionRequest();
        client.setRequest(request);

        AccessToken userOneToken = new AccessToken(
                USER_1_ACCESS_TOKEN,
                APP_ID,
                USER_1_FBID,
                PERMISSIONS,
                null,
                null,
                null,
                null);
        AccessToken.setCurrentAccessToken(userOneToken);

        AccessToken userTwoToken = new AccessToken(
                USER_2_ACCESS_TOKEN,
                APP_ID,
                USER_2_FBID,
                PERMISSIONS,
                null,
                null,
                null,
                null);
        LoginClient.Result result = LoginClient.Result.createTokenResult(request, userTwoToken);

        client.completeAndValidate(result);

        blocker.waitForSignals(1);

        assertNotNull(client.result);
        assertEquals(LoginClient.Result.Code.ERROR, client.result.code);

        assertNull(client.result.token);
        assertNotNull(client.result.errorMessage);
    }
}

<code block>


package com.example.switchuser;

import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.graphics.Color;
import android.os.Bundle;
import android.support.v4.app.ListFragment;
import android.view.*;
import android.widget.*;

import com.facebook.AccessToken;
import com.facebook.CallbackManager;
import com.facebook.FacebookCallback;
import com.facebook.FacebookException;
import com.facebook.FacebookSdk;
import com.facebook.Profile;
import com.facebook.ProfileTracker;
import com.facebook.login.LoginBehavior;
import com.facebook.login.LoginManager;
import com.facebook.login.LoginResult;
import com.facebook.login.widget.ProfilePictureView;

import java.util.ArrayList;
import java.util.Arrays;

public class SettingsFragment extends ListFragment {

    public static final String TAG = "SettingsFragment";
    private static final String CURRENT_SLOT_KEY = "CurrentSlot";

    private SlotManager slotManager;
    private Menu optionsMenu;
    private CallbackManager callbackManager;
    private ProfileTracker profileTracker;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        slotManager = new SlotManager();
        slotManager.restore(
                getActivity(),
                savedInstanceState != null ?
                        savedInstanceState.getInt(CURRENT_SLOT_KEY, SlotManager.NO_SLOT) :
                        SlotManager.NO_SLOT);
        ArrayList<Slot> slotList = new ArrayList<Slot>(
                Arrays.asList(slotManager.getAllSlots()));

        Slot currentSlot = slotManager.getSelectedSlot();
        if (currentSlot != null && currentSlot.getAccessToken() != null) {
            AccessToken.setCurrentAccessToken(currentSlot.getAccessToken());
        }

        setListAdapter(new SlotAdapter(slotList));
        setHasOptionsMenu(true);
        setUpCallbacks();
        currentUserChanged();
    }

    @Override
    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
        super.onCreateOptionsMenu(menu, inflater);
        inflater.inflate(R.menu.context_settings, menu);
        optionsMenu = menu;
        updateMenuVisibility();
    }

    private void setUpCallbacks() {
        callbackManager = CallbackManager.Factory.create();
        LoginManager manager = LoginManager.getInstance();
        manager.registerCallback(callbackManager, new FacebookCallback<LoginResult>() {
            @Override
            public void onSuccess(LoginResult loginResult) {
                Profile.fetchProfileForCurrentAccessToken();
            }

            @Override
            public void onError(FacebookException exception) {
                AccessToken.setCurrentAccessToken(null);
                currentUserChanged();
            }

            @Override
            public void onCancel() {
                AccessToken.setCurrentAccessToken(null);
                currentUserChanged();
            }
        });

        profileTracker = new ProfileTracker() {
            @Override
            protected void onCurrentProfileChanged(Profile oldProfile, Profile currentProfile) {
                Slot currentSlot = slotManager.getSelectedSlot();
                AccessToken currentAccessToken = AccessToken.getCurrentAccessToken();
                if(currentSlot != null && currentAccessToken != null && currentProfile != null) {
                    currentSlot.setUserInfo(
                            new UserInfo(currentProfile.getName(), currentAccessToken));
                    currentUserChanged();
                }
            }
        };
    }

    @Override
    public void onListItemClick(ListView l, View view, int position, long id) {
        slotManager.setCurrentUserSlot(position);
        Slot newSlot = slotManager.getSelectedSlot();
        if (newSlot.getAccessToken() == null) {
            final LoginManager manager = LoginManager.getInstance();
            manager.setLoginBehavior(newSlot.getLoginBehavior());
            manager.logInWithReadPermissions(this, null);
        } else {
            AccessToken.setCurrentAccessToken(newSlot.getAccessToken());
        }
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        Slot slot = slotManager.getSelectedSlot();

        if (item.getItemId() == R.id.menu_item_clear_slot) {
            if (slot.getUserId() != null) {
                
                
                
                slot.clear();
                if (slot == slotManager.getSelectedSlot()) {
                    slotManager.setCurrentUserSlot(SlotManager.NO_SLOT);
                }

                currentUserChanged();
            }
            return true;
        }

        return super.onContextItemSelected(item);
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        outState.putInt(CURRENT_SLOT_KEY, slotManager.getSelectedSlotNumber());
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        callbackManager.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        profileTracker.stopTracking();
    }

    private void updateMenuVisibility() {
        if (optionsMenu != null) {
            if (slotManager.getSelectedSlot() == null) {
                optionsMenu.setGroupVisible(0, false);
            } else if (optionsMenu != null) {
                optionsMenu.setGroupVisible(0, true);
            }
        }
    }

    private void currentUserChanged() {
        if (slotManager == null) {
            
            return;
        }

        updateMenuVisibility();
        updateListView();
        Slot currentSlot = slotManager.getSelectedSlot();
        AccessToken currentToken = (currentSlot != null) ? currentSlot.getAccessToken() : null;
        AccessToken.setCurrentAccessToken(currentToken);
    }

    private void updateListView() {
        SlotAdapter adapter = (SlotAdapter) getListAdapter();

        
        if (adapter != null) {
            adapter.notifyDataSetChanged();
        }
    }

    private class SlotManager {
        static final int NO_SLOT = -1;

        private final static int MAX_SLOTS = 4;

        private static final String SETTINGS_CURRENT_SLOT_KEY = "CurrentSlot";
        private static final String SETTINGS_NAME = "UserManagerSettings";

        private SharedPreferences settings;
        private int selectedSlotNumber = NO_SLOT;

        private Slot[] slots;

        public void restore(Context context, int oldSelectedSlot) {
            if (context == null) {
                throw new IllegalArgumentException("context cannot be null");
            }

            slots = new Slot[MAX_SLOTS];
            for (int i = 0; i < MAX_SLOTS; i++) {
                LoginBehavior loginBehavior = (i == 0) ?
                        LoginBehavior.NATIVE_WITH_FALLBACK :
                        LoginBehavior.WEB_ONLY;
                slots[i] = new Slot(i, loginBehavior);
            }

            
            settings = FacebookSdk.getApplicationContext().getSharedPreferences(
                    SETTINGS_NAME, Context.MODE_PRIVATE);
            int savedSlotNumber = settings.getInt(SETTINGS_CURRENT_SLOT_KEY, NO_SLOT);
            if (savedSlotNumber != NO_SLOT && savedSlotNumber != oldSelectedSlot) {
                
                setCurrentUserSlot(savedSlotNumber);
            } else {
                
                
                
                setCurrentUserSlot(savedSlotNumber);
            }
        }

        public Slot getSelectedSlot() {
            if (selectedSlotNumber == NO_SLOT) {
                return null;
            } else {
                return getSlot(selectedSlotNumber);
            }
        }

        public int getSelectedSlotNumber() {
            return selectedSlotNumber;
        }

        public void setCurrentUserSlot(int slot) {
            if (slot != selectedSlotNumber) {
                
                settings.edit().putInt(SETTINGS_CURRENT_SLOT_KEY, slot).apply();
                selectedSlotNumber = slot;
                currentUserChanged();
            }
        }

        private Slot[] getAllSlots() {
            return slots;
        }

        private Slot getSlot(int slot) {
            validateSlot(slot);
            return slots[slot];
        }

        private void validateSlot(int slot) {
            if (slot <= NO_SLOT || slot >= MAX_SLOTS) {
                throw new IllegalArgumentException(
                        String.format("Choose a slot between 0 and %d inclusively", MAX_SLOTS - 1));
            }
        }
    }

    private class SlotAdapter extends ArrayAdapter<Slot> {

        public SlotAdapter(ArrayList<Slot> slots) {
            super(getActivity(), android.R.layout.simple_list_item_1, slots);
        }

        @Override
        public View getView(final int position, View convertView, ViewGroup parent) {
            if (null == convertView) {
                convertView = getActivity().getLayoutInflater()
                        .inflate(R.layout.list_item_user, parent, false);
            }

            Slot slot = getItem(position);
            if (slot.getLoginBehavior() != LoginBehavior.WEB_ONLY) {
                convertView.setBackgroundColor(Color.argb(50, 255, 255, 255));
            }

            String userName = slot.getUserName();
            if (userName == null) {
                userName = getString(R.string.empty_slot);
            }

            String userId = slot.getUserId();
            ProfilePictureView profilePic = (ProfilePictureView) convertView.findViewById(
                    R.id.slotPic);
            if (userId != null) {
                profilePic.setProfileId(userId);
            } else {
                profilePic.setProfileId(null);
            }

            TextView userNameTextView = (TextView) convertView.findViewById(
                    R.id.slotUserName);
            userNameTextView.setText(userName);

            final CheckBox currentUserCheckBox = (CheckBox) convertView.findViewById(
                    R.id.currentUserIndicator);
            currentUserCheckBox.setChecked(
                    slotManager.getSelectedSlot() == slot
                            && slot.getUserInfo() != null);
            currentUserCheckBox.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    if (currentUserCheckBox.isChecked()) {
                        slotManager.setCurrentUserSlot(position);
                    } else {
                        slotManager.setCurrentUserSlot(SlotManager.NO_SLOT);
                    }
                    SlotAdapter adapter = (SlotAdapter) getListAdapter();
                    adapter.notifyDataSetChanged();
                }
            });

            currentUserCheckBox.setEnabled(slot.getAccessToken() != null);

            return convertView;
        }

    }
}

<code block>


package com.facebook;

final class FacebookSdkVersion {
    public static final String BUILD = "4.3.0";
}

<code block>


package com.facebook;

import android.content.Context;
import android.graphics.Bitmap;
import android.location.Location;
import android.net.Uri;
import android.os.*;
import android.text.TextUtils;
import android.util.Log;
import android.util.Pair;

import com.facebook.internal.*;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.*;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLEncoder;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.zip.GZIPOutputStream;


public class GraphRequest {
    
    public static final int MAXIMUM_BATCH_SIZE = 50;

    public static final String TAG = GraphRequest.class.getSimpleName();

    private static final String VIDEOS_SUFFIX = "/videos";
    private static final String ME = "me";
    private static final String MY_FRIENDS = "me/friends";
    private static final String SEARCH = "search";
    private static final String USER_AGENT_BASE = "FBAndroidSDK";
    private static final String USER_AGENT_HEADER = "User-Agent";
    private static final String CONTENT_TYPE_HEADER = "Content-Type";
    private static final String ACCEPT_LANGUAGE_HEADER = "Accept-Language";
    private static final String CONTENT_ENCODING_HEADER = "Content-Encoding";

    
    private static final String FORMAT_PARAM = "format";
    private static final String FORMAT_JSON = "json";
    private static final String SDK_PARAM = "sdk";
    private static final String SDK_ANDROID = "android";
    private static final String ACCESS_TOKEN_PARAM = "access_token";
    private static final String BATCH_ENTRY_NAME_PARAM = "name";
    private static final String BATCH_ENTRY_OMIT_RESPONSE_ON_SUCCESS_PARAM =
            "omit_response_on_success";
    private static final String BATCH_ENTRY_DEPENDS_ON_PARAM = "depends_on";
    private static final String BATCH_APP_ID_PARAM = "batch_app_id";
    private static final String BATCH_RELATIVE_URL_PARAM = "relative_url";
    private static final String BATCH_BODY_PARAM = "body";
    private static final String BATCH_METHOD_PARAM = "method";
    private static final String BATCH_PARAM = "batch";
    private static final String ATTACHMENT_FILENAME_PREFIX = "file";
    private static final String ATTACHED_FILES_PARAM = "attached_files";
    private static final String ISO_8601_FORMAT_STRING = "yyyy-MM-dd'T'HH:mm:ssZ";
    private static final String DEBUG_PARAM = "debug";
    private static final String DEBUG_SEVERITY_INFO = "info";
    private static final String DEBUG_SEVERITY_WARNING = "warning";
    private static final String DEBUG_KEY = "__debug__";
    private static final String DEBUG_MESSAGES_KEY = "messages";
    private static final String DEBUG_MESSAGE_KEY = "message";
    private static final String DEBUG_MESSAGE_TYPE_KEY = "type";
    private static final String DEBUG_MESSAGE_LINK_KEY = "link";

    private static final String MIME_BOUNDARY = "3i2ndDfv2rTHiSisAbouNdArYfORhtTPEefj3q2f";

    private static String defaultBatchApplicationId;

    
    private static Pattern versionPattern = Pattern.compile("^/?v\\d+\\.\\d+/(.*)");

    private AccessToken accessToken;
    private HttpMethod httpMethod;
    private String graphPath;
    private JSONObject graphObject;
    private String batchEntryName;
    private String batchEntryDependsOn;
    private boolean batchEntryOmitResultOnSuccess = true;
    private Bundle parameters;
    private Callback callback;
    private String overriddenURL;
    private Object tag;
    private String version;
    private boolean skipClientToken = false;

    
    public GraphRequest() {
        this(null, null, null, null, null);
    }

    
    public GraphRequest(AccessToken accessToken, String graphPath) {
        this(accessToken, graphPath, null, null, null);
    }

    
    public GraphRequest(
            AccessToken accessToken,
            String graphPath,
            Bundle parameters,
            HttpMethod httpMethod) {
        this(accessToken, graphPath, parameters, httpMethod, null);
    }

    
    public GraphRequest(
            AccessToken accessToken,
            String graphPath,
            Bundle parameters,
            HttpMethod httpMethod,
            Callback callback) {
        this(accessToken, graphPath, parameters, httpMethod, callback, null);
    }

    
    public GraphRequest(
            AccessToken accessToken,
            String graphPath,
            Bundle parameters,
            HttpMethod httpMethod,
            Callback callback,
            String version) {
        this.accessToken = accessToken;
        this.graphPath = graphPath;
        this.version = version;

        setCallback(callback);
        setHttpMethod(httpMethod);

        if (parameters != null) {
            this.parameters = new Bundle(parameters);
        } else {
            this.parameters = new Bundle();
        }

        if (this.version == null) {
            this.version = ServerProtocol.getAPIVersion();
        }
    }

    GraphRequest(AccessToken accessToken, URL overriddenURL) {
        this.accessToken = accessToken;
        this.overriddenURL = overriddenURL.toString();

        setHttpMethod(HttpMethod.GET);

        this.parameters = new Bundle();
    }

    
    public static GraphRequest newDeleteObjectRequest(
            AccessToken accessToken,
            String id,
            Callback callback) {
        return new GraphRequest(accessToken, id, null, HttpMethod.DELETE, callback);
    }

    
    public static GraphRequest newMeRequest(
            AccessToken accessToken,
            final GraphJSONObjectCallback callback) {
        Callback wrapper = new Callback() {
            @Override
            public void onCompleted(GraphResponse response) {
                if (callback != null) {
                    callback.onCompleted(response.getJSONObject(), response);
                }
            }
        };
        return new GraphRequest(accessToken, ME, null, null, wrapper);
    }

    
    public static GraphRequest newPostRequest(
            AccessToken accessToken,
            String graphPath,
            JSONObject graphObject,
            Callback callback) {
        GraphRequest request = new GraphRequest(
                accessToken,
                graphPath,
                null,
                HttpMethod.POST,
                callback);
        request.setGraphObject(graphObject);
        return request;
    }

    
    public static GraphRequest newMyFriendsRequest(
            AccessToken accessToken,
            final GraphJSONArrayCallback callback) {
        Callback wrapper = new Callback() {
            @Override
            public void onCompleted(GraphResponse response) {
                if (callback != null) {
                    JSONObject result = response.getJSONObject();
                    JSONArray data = result != null ? result.optJSONArray("data") : null;
                    callback.onCompleted(data, response);
                }
            }
        };
        return new GraphRequest(accessToken, MY_FRIENDS, null, null, wrapper);
    }

    
    public static GraphRequest newGraphPathRequest(
            AccessToken accessToken,
            String graphPath,
            Callback callback) {
        return new GraphRequest(accessToken, graphPath, null, null, callback);
    }

    
    public static GraphRequest newPlacesSearchRequest(
            AccessToken accessToken,
            Location location,
            int radiusInMeters,
            int resultsLimit,
            String searchText,
            final GraphJSONArrayCallback callback) {
        if (location == null && Utility.isNullOrEmpty(searchText)) {
            throw new FacebookException("Either location or searchText must be specified.");
        }

        Bundle parameters = new Bundle(5);
        parameters.putString("type", "place");
        parameters.putInt("limit", resultsLimit);
        if (location != null) {
            parameters.putString("center",
                    String.format(
                            Locale.US,
                            "%f,%f",
                            location.getLatitude(),
                            location.getLongitude()));
            parameters.putInt("distance", radiusInMeters);
        }
        if (!Utility.isNullOrEmpty(searchText)) {
            parameters.putString("q", searchText);
        }

        Callback wrapper = new Callback() {
            @Override
            public void onCompleted(GraphResponse response) {
                if (callback != null) {
                    JSONObject result = response.getJSONObject();
                    JSONArray data = result != null ? result.optJSONArray("data") : null;
                    callback.onCompleted(data, response);
                }
            }
        };

        return new GraphRequest(accessToken, SEARCH, parameters, HttpMethod.GET, wrapper);
    }


    
    public static GraphRequest newCustomAudienceThirdPartyIdRequest(AccessToken accessToken,
                                                                    Context context,
                                                                    String applicationId,
                                                                    Callback callback) {

        if (applicationId == null && accessToken != null) {
            applicationId = accessToken.getApplicationId();
        }

        if (applicationId == null) {
            applicationId = Utility.getMetadataApplicationId(context);
        }

        if (applicationId == null) {
            throw new FacebookException("Facebook App ID cannot be determined");
        }

        String endpoint = applicationId + "/custom_audience_third_party_id";
        AttributionIdentifiers attributionIdentifiers =
                AttributionIdentifiers.getAttributionIdentifiers(context);
        Bundle parameters = new Bundle();

        if (accessToken == null) {
            
            
            String udid = attributionIdentifiers.getAttributionId() != null
                    ? attributionIdentifiers.getAttributionId()
                    : attributionIdentifiers.getAndroidAdvertiserId();
            if (attributionIdentifiers.getAttributionId() != null) {
                parameters.putString("udid", udid);
            }
        }

        
        
        if (FacebookSdk.getLimitEventAndDataUsage(context)
                || attributionIdentifiers.isTrackingLimited()) {
            parameters.putString("limit_event_usage", "1");
        }

        return new GraphRequest(accessToken, endpoint, parameters, HttpMethod.GET, callback);
    }

    
    public static GraphRequest newCustomAudienceThirdPartyIdRequest(
            AccessToken accessToken,
            Context context,
            Callback callback) {
        return newCustomAudienceThirdPartyIdRequest(accessToken, context, null, callback);
    }

    
    public final JSONObject getGraphObject() {
        return this.graphObject;
    }

    
    public final void setGraphObject(JSONObject graphObject) {
        this.graphObject = graphObject;
    }

    
    public final String getGraphPath() {
        return this.graphPath;
    }

    
    public final void setGraphPath(String graphPath) {
        this.graphPath = graphPath;
    }

    
    public final HttpMethod getHttpMethod() {
        return this.httpMethod;
    }

    
    public final void setHttpMethod(HttpMethod httpMethod) {
        if (overriddenURL != null && httpMethod != HttpMethod.GET) {
            throw new FacebookException("Can't change HTTP method on request with overridden URL.");
        }
        this.httpMethod = (httpMethod != null) ? httpMethod : HttpMethod.GET;
    }

    
    public final String getVersion() {
        return this.version;
    }

    
    public final void setVersion(String version) {
        this.version = version;
    }

    
    public final void setSkipClientToken(boolean skipClientToken) {
        this.skipClientToken = skipClientToken;
    }

    
    public final Bundle getParameters() {
        return this.parameters;
    }

    
    public final void setParameters(Bundle parameters) {
        this.parameters = parameters;
    }

    
    public final AccessToken getAccessToken() {
        return this.accessToken;
    }

    
    public final void setAccessToken(AccessToken accessToken) {
        this.accessToken = accessToken;
    }

    
    public final String getBatchEntryName() {
        return this.batchEntryName;
    }

    
    public final void setBatchEntryName(String batchEntryName) {
        this.batchEntryName = batchEntryName;
    }

    
    public final String getBatchEntryDependsOn() {
        return this.batchEntryDependsOn;
    }

    
    public final void setBatchEntryDependsOn(String batchEntryDependsOn) {
        this.batchEntryDependsOn = batchEntryDependsOn;
    }


    
    public final boolean getBatchEntryOmitResultOnSuccess() {
        return this.batchEntryOmitResultOnSuccess;
    }

    
    public final void setBatchEntryOmitResultOnSuccess(boolean batchEntryOmitResultOnSuccess) {
        this.batchEntryOmitResultOnSuccess = batchEntryOmitResultOnSuccess;
    }

    
    public static final String getDefaultBatchApplicationId() {
        return GraphRequest.defaultBatchApplicationId;
    }

    
    public static final void setDefaultBatchApplicationId(String applicationId) {
        defaultBatchApplicationId = applicationId;
    }

    
    public final Callback getCallback() {
        return callback;
    }

    
    public final void setCallback(final Callback callback) {
        
        if (FacebookSdk.isLoggingBehaviorEnabled(LoggingBehavior.GRAPH_API_DEBUG_INFO)
                || FacebookSdk.isLoggingBehaviorEnabled(LoggingBehavior.GRAPH_API_DEBUG_WARNING)) {
            Callback wrapper = new Callback() {
                @Override
                public void onCompleted(GraphResponse response) {
                    JSONObject responseObject = response.getJSONObject();
                    JSONObject debug =
                            responseObject != null ? responseObject.optJSONObject(DEBUG_KEY) : null;
                    JSONArray debugMessages =
                            debug != null ? debug.optJSONArray(DEBUG_MESSAGES_KEY) : null;
                    if (debugMessages != null) {
                        for (int i = 0; i < debugMessages.length(); ++i) {
                            JSONObject debugMessageObject = debugMessages.optJSONObject(i);
                            String debugMessage = debugMessageObject != null
                                    ? debugMessageObject.optString(DEBUG_MESSAGE_KEY)
                                    : null;
                            String debugMessageType = debugMessageObject != null
                                    ? debugMessageObject.optString(DEBUG_MESSAGE_TYPE_KEY)
                                    : null;
                            String debugMessageLink = debugMessageObject != null
                                    ? debugMessageObject.optString(DEBUG_MESSAGE_LINK_KEY)
                                    : null;
                            if (debugMessage != null && debugMessageType != null) {
                                LoggingBehavior behavior = LoggingBehavior.GRAPH_API_DEBUG_INFO;
                                if (debugMessageType.equals("warning")) {
                                    behavior = LoggingBehavior.GRAPH_API_DEBUG_WARNING;
                                }
                                if (!Utility.isNullOrEmpty(debugMessageLink)) {
                                    debugMessage += " Link: " + debugMessageLink;
                                }
                                Logger.log(behavior, TAG, debugMessage);
                            }
                        }
                    }
                    if (callback != null) {
                        callback.onCompleted(response);
                    }
                }
            };
            this.callback = wrapper;
        } else {
            this.callback = callback;
        }

    }

    
    public final void setTag(Object tag) {
        this.tag = tag;
    }

    
    public final Object getTag() {
        return tag;
    }

    
    public final GraphResponse executeAndWait() {
        return GraphRequest.executeAndWait(this);
    }

    
    public final GraphRequestAsyncTask executeAsync() {
        return GraphRequest.executeBatchAsync(this);
    }

    
    public static HttpURLConnection toHttpConnection(GraphRequest... requests) {
        return toHttpConnection(Arrays.asList(requests));
    }

    
    public static HttpURLConnection toHttpConnection(Collection<GraphRequest> requests) {
        Validate.notEmptyAndContainsNoNulls(requests, "requests");

        return toHttpConnection(new GraphRequestBatch(requests));
    }

    
    public static HttpURLConnection toHttpConnection(GraphRequestBatch requests) {

        URL url;
        try {
            if (requests.size() == 1) {
                
                GraphRequest request = requests.get(0);
                
                
                url = new URL(request.getUrlForSingleRequest());
            } else {
                
                
                url = new URL(ServerProtocol.getGraphUrlBase());
            }
        } catch (MalformedURLException e) {
            throw new FacebookException("could not construct URL for request", e);
        }

        HttpURLConnection connection;
        try {
            connection = createConnection(url);

            serializeToUrlConnection(requests, connection);
        } catch (IOException e) {
            throw new FacebookException("could not construct request body", e);
        } catch (JSONException e) {
            throw new FacebookException("could not construct request body", e);
        }

        return connection;
    }

    
    public static GraphResponse executeAndWait(GraphRequest request) {
        List<GraphResponse> responses = executeBatchAndWait(request);

        if (responses == null || responses.size() != 1) {
            throw new FacebookException("invalid state: expected a single response");
        }

        return responses.get(0);
    }

    
    public static List<GraphResponse> executeBatchAndWait(GraphRequest... requests) {
        Validate.notNull(requests, "requests");

        return executeBatchAndWait(Arrays.asList(requests));
    }

    
    public static List<GraphResponse> executeBatchAndWait(Collection<GraphRequest> requests) {
        return executeBatchAndWait(new GraphRequestBatch(requests));
    }

    
    public static List<GraphResponse> executeBatchAndWait(GraphRequestBatch requests) {
        Validate.notEmptyAndContainsNoNulls(requests, "requests");

        HttpURLConnection connection = null;
        try {
            connection = toHttpConnection(requests);
        } catch (Exception ex) {
            List<GraphResponse> responses = GraphResponse.constructErrorResponses(
                    requests.getRequests(),
                    null,
                    new FacebookException(ex));
            runCallbacks(requests, responses);
            return responses;
        }

        List<GraphResponse> responses = executeConnectionAndWait(connection, requests);
        return responses;
    }

    
    public static GraphRequestAsyncTask executeBatchAsync(GraphRequest... requests) {
        Validate.notNull(requests, "requests");

        return executeBatchAsync(Arrays.asList(requests));
    }

    
    public static GraphRequestAsyncTask executeBatchAsync(Collection<GraphRequest> requests) {
        return executeBatchAsync(new GraphRequestBatch(requests));
    }

    
    public static GraphRequestAsyncTask executeBatchAsync(GraphRequestBatch requests) {
        Validate.notEmptyAndContainsNoNulls(requests, "requests");

        GraphRequestAsyncTask asyncTask = new GraphRequestAsyncTask(requests);
        asyncTask.executeOnSettingsExecutor();
        return asyncTask;
    }

    
    public static List<GraphResponse> executeConnectionAndWait(
            HttpURLConnection connection,
            Collection<GraphRequest> requests) {
        return executeConnectionAndWait(connection, new GraphRequestBatch(requests));
    }

    
    public static List<GraphResponse> executeConnectionAndWait(
            HttpURLConnection connection,
            GraphRequestBatch requests) {
        List<GraphResponse> responses = GraphResponse.fromHttpConnection(connection, requests);

        Utility.disconnectQuietly(connection);

        int numRequests = requests.size();
        if (numRequests != responses.size()) {
            throw new FacebookException(
                    String.format(Locale.US,
                            "Received %d responses while expecting %d",
                            responses.size(),
                            numRequests));
        }

        runCallbacks(requests, responses);

        
        AccessTokenManager.getInstance().extendAccessTokenIfNeeded();

        return responses;
    }

    
    public static GraphRequestAsyncTask executeConnectionAsync(
            HttpURLConnection connection,
            GraphRequestBatch requests) {
        return executeConnectionAsync(null, connection, requests);
    }

    
    public static GraphRequestAsyncTask executeConnectionAsync(
            Handler callbackHandler,
            HttpURLConnection connection,
            GraphRequestBatch requests) {
        Validate.notNull(connection, "connection");

        GraphRequestAsyncTask asyncTask = new GraphRequestAsyncTask(connection, requests);
        requests.setCallbackHandler(callbackHandler);
        asyncTask.executeOnSettingsExecutor();
        return asyncTask;
    }

    
    @Override
    public String toString() {
        return new StringBuilder()
                .append("{Request: ")
                .append(" accessToken: ")
                .append(accessToken == null ? "null" : accessToken)
                .append(", graphPath: ")
                .append(graphPath)
                .append(", graphObject: ")
                .append(graphObject)
                .append(", httpMethod: ")
                .append(httpMethod)
                .append(", parameters: ")
                .append(parameters)
                .append("}")
                .toString();
    }

    static void runCallbacks(final GraphRequestBatch requests, List<GraphResponse> responses) {
        int numRequests = requests.size();

        
        
        final ArrayList<Pair<Callback, GraphResponse>> callbacks = new ArrayList<Pair<Callback, GraphResponse>>();
        for (int i = 0; i < numRequests; ++i) {
            GraphRequest request = requests.get(i);
            if (request.callback != null) {
                callbacks.add(
                        new Pair<Callback, GraphResponse>(request.callback, responses.get(i)));
            }
        }

        if (callbacks.size() > 0) {
            Runnable runnable = new Runnable() {
                public void run() {
                    for (Pair<Callback, GraphResponse> pair : callbacks) {
                        pair.first.onCompleted(pair.second);
                    }

                    List<GraphRequestBatch.Callback> batchCallbacks = requests.getCallbacks();
                    for (GraphRequestBatch.Callback batchCallback : batchCallbacks) {
                        batchCallback.onBatchCompleted(requests);
                    }
                }
            };

            Handler callbackHandler = requests.getCallbackHandler();
            if (callbackHandler == null) {
                
                runnable.run();
            } else {
                
                callbackHandler.post(runnable);
            }
        }
    }

    private static HttpURLConnection createConnection(URL url) throws IOException {
        HttpURLConnection connection;
        connection = (HttpURLConnection) url.openConnection();

        connection.setRequestProperty(USER_AGENT_HEADER, getUserAgent());
        connection.setRequestProperty(ACCEPT_LANGUAGE_HEADER, Locale.getDefault().toString());

        connection.setChunkedStreamingMode(0);
        return connection;
    }


    private void addCommonParameters() {
        if (this.accessToken != null) {
            if (!this.parameters.containsKey(ACCESS_TOKEN_PARAM)) {
                String token = accessToken.getToken();
                Logger.registerAccessToken(token);
                this.parameters.putString(ACCESS_TOKEN_PARAM, token);
            }
        } else if (!skipClientToken && !this.parameters.containsKey(ACCESS_TOKEN_PARAM)) {
            String appID = FacebookSdk.getApplicationId();
            String clientToken = FacebookSdk.getClientToken();
            if (!Utility.isNullOrEmpty(appID) && !Utility.isNullOrEmpty(clientToken)) {
                String accessToken = appID + "|" + clientToken;
                this.parameters.putString(ACCESS_TOKEN_PARAM, accessToken);
            } else {
                Log.d(TAG, "Warning: Request without access token missing application ID or" +
                        " client token.");
            }
        }
        this.parameters.putString(SDK_PARAM, SDK_ANDROID);
        this.parameters.putString(FORMAT_PARAM, FORMAT_JSON);

        if (FacebookSdk.isLoggingBehaviorEnabled(LoggingBehavior.GRAPH_API_DEBUG_INFO)) {
            this.parameters.putString(DEBUG_PARAM, DEBUG_SEVERITY_INFO);
        } else if (FacebookSdk.isLoggingBehaviorEnabled(LoggingBehavior.GRAPH_API_DEBUG_WARNING)) {
            this.parameters.putString(DEBUG_PARAM, DEBUG_SEVERITY_WARNING);
        }
    }

    private String appendParametersToBaseUrl(String baseUrl) {
        Uri.Builder uriBuilder = new Uri.Builder().encodedPath(baseUrl);

        Set<String> keys = this.parameters.keySet();
        for (String key : keys) {
            Object value = this.parameters.get(key);

            if (value == null) {
                value = "";
            }

            if (isSupportedParameterType(value)) {
                value = parameterToString(value);
            } else {
                if (httpMethod == HttpMethod.GET) {
                    throw new IllegalArgumentException(
                            String.format(
                                    Locale.US,
                                    "Unsupported parameter type for GET request: %s",
                                    value.getClass().getSimpleName()));
                }
                continue;
            }

            uriBuilder.appendQueryParameter(key, value.toString());
        }

        return uriBuilder.toString();
    }

    final String getUrlForBatchedRequest() {
        if (overriddenURL != null) {
            throw new FacebookException("Can't override URL for a batch request");
        }

        String baseUrl = getGraphPathWithVersion();
        addCommonParameters();
        return appendParametersToBaseUrl(baseUrl);
    }

    final String getUrlForSingleRequest() {
        if (overriddenURL != null) {
            return overriddenURL.toString();
        }

        String graphBaseUrlBase;
        if (this.getHttpMethod() == HttpMethod.POST
                && graphPath != null
                && graphPath.endsWith(VIDEOS_SUFFIX)) {
            graphBaseUrlBase = ServerProtocol.getGraphVideoUrlBase();
        } else {
            graphBaseUrlBase = ServerProtocol.getGraphUrlBase();
        }
        String baseUrl = String.format("%s/%s", graphBaseUrlBase, getGraphPathWithVersion());

        addCommonParameters();
        return appendParametersToBaseUrl(baseUrl);
    }

    private String getGraphPathWithVersion() {
        Matcher matcher = versionPattern.matcher(this.graphPath);
        if (matcher.matches()) {
            return this.graphPath;
        }
        return String.format("%s/%s", this.version, this.graphPath);
    }

    private static class Attachment {
        private final GraphRequest request;
        private final Object value;

        public Attachment(GraphRequest request, Object value) {
            this.request = request;
            this.value = value;
        }

        public GraphRequest getRequest() {
            return request;
        }

        public Object getValue() {
            return value;
        }
    }

    private void serializeToBatch(
            JSONArray batch,
            Map<String, Attachment> attachments
    ) throws JSONException, IOException {
        JSONObject batchEntry = new JSONObject();

        if (this.batchEntryName != null) {
            batchEntry.put(BATCH_ENTRY_NAME_PARAM, this.batchEntryName);
            batchEntry.put(
                    BATCH_ENTRY_OMIT_RESPONSE_ON_SUCCESS_PARAM,
                    this.batchEntryOmitResultOnSuccess);
        }
        if (this.batchEntryDependsOn != null) {
            batchEntry.put(BATCH_ENTRY_DEPENDS_ON_PARAM, this.batchEntryDependsOn);
        }

        String relativeURL = getUrlForBatchedRequest();
        batchEntry.put(BATCH_RELATIVE_URL_PARAM, relativeURL);
        batchEntry.put(BATCH_METHOD_PARAM, httpMethod);
        if (this.accessToken != null) {
            String token = this.accessToken.getToken();
            Logger.registerAccessToken(token);
        }

        
        ArrayList<String> attachmentNames = new ArrayList<String>();
        Set<String> keys = this.parameters.keySet();
        for (String key : keys) {
            Object value = this.parameters.get(key);
            if (isSupportedAttachmentType(value)) {
                
                String name = String.format(
                        Locale.ROOT,
                        "%s%d",
                        ATTACHMENT_FILENAME_PREFIX,
                        attachments.size());
                attachmentNames.add(name);
                attachments.put(name, new Attachment(this, value));
            }
        }

        if (!attachmentNames.isEmpty()) {
            String attachmentNamesString = TextUtils.join(",", attachmentNames);
            batchEntry.put(ATTACHED_FILES_PARAM, attachmentNamesString);
        }

        if (this.graphObject != null) {
            
            final ArrayList<String> keysAndValues = new ArrayList<String>();
            processGraphObject(this.graphObject, relativeURL, new KeyValueSerializer() {
                @Override
                public void writeString(String key, String value) throws IOException {
                    keysAndValues.add(String.format(
                            Locale.US,
                            "%s=%s",
                            key,
                            URLEncoder.encode(value, "UTF-8")));
                }
            });
            String bodyValue = TextUtils.join("&", keysAndValues);
            batchEntry.put(BATCH_BODY_PARAM, bodyValue);
        }

        batch.put(batchEntry);
    }

    private static boolean hasOnProgressCallbacks(GraphRequestBatch requests) {
        for (GraphRequestBatch.Callback callback : requests.getCallbacks()) {
            if (callback instanceof GraphRequestBatch.OnProgressCallback) {
                return true;
            }
        }

        for (GraphRequest request : requests) {
            if (request.getCallback() instanceof OnProgressCallback) {
                return true;
            }
        }

        return false;
    }

    private static void setConnectionContentType(
            HttpURLConnection connection,
            boolean shouldUseGzip) {
        if (shouldUseGzip) {
            connection.setRequestProperty(CONTENT_TYPE_HEADER, "application/x-www-form-urlencoded");
            connection.setRequestProperty(CONTENT_ENCODING_HEADER, "gzip");
        } else {
            connection.setRequestProperty(CONTENT_TYPE_HEADER, getMimeContentType());
        }
    }

    private static boolean isGzipCompressible(GraphRequestBatch requests) {
        for (GraphRequest request : requests) {
            for (String key : request.parameters.keySet()) {
                Object value = request.parameters.get(key);
                if (isSupportedAttachmentType(value)) {
                    return false;
                }
            }
        }
        return true;
    }

    final static void serializeToUrlConnection(
            GraphRequestBatch requests,
            HttpURLConnection connection
    ) throws IOException, JSONException {
        Logger logger = new Logger(LoggingBehavior.REQUESTS, "Request");

        int numRequests = requests.size();
        boolean shouldUseGzip = isGzipCompressible(requests);

        HttpMethod connectionHttpMethod =
                (numRequests == 1) ? requests.get(0).httpMethod : HttpMethod.POST;
        connection.setRequestMethod(connectionHttpMethod.name());
        setConnectionContentType(connection, shouldUseGzip);

        URL url = connection.getURL();
        logger.append("Request:\n");
        logger.appendKeyValue("Id", requests.getId());
        logger.appendKeyValue("URL", url);
        logger.appendKeyValue("Method", connection.getRequestMethod());
        logger.appendKeyValue("User-Agent", connection.getRequestProperty("User-Agent"));
        logger.appendKeyValue("Content-Type", connection.getRequestProperty("Content-Type"));

        connection.setConnectTimeout(requests.getTimeout());
        connection.setReadTimeout(requests.getTimeout());

        
        
        boolean isPost = (connectionHttpMethod == HttpMethod.POST);
        if (!isPost) {
            logger.log();
            return;
        }

        connection.setDoOutput(true);

        OutputStream outputStream = null;
        try {
            outputStream = new BufferedOutputStream(connection.getOutputStream());
            if (shouldUseGzip) {
                outputStream = new GZIPOutputStream(outputStream);
            }

            if (hasOnProgressCallbacks(requests)) {
                ProgressNoopOutputStream countingStream = null;
                countingStream = new ProgressNoopOutputStream(requests.getCallbackHandler());
                processRequest(requests, null, numRequests, url, countingStream, shouldUseGzip);

                int max = countingStream.getMaxProgress();
                Map<GraphRequest, RequestProgress> progressMap = countingStream.getProgressMap();

                outputStream = new ProgressOutputStream(outputStream, requests, progressMap, max);
            }

            processRequest(requests, logger, numRequests, url, outputStream, shouldUseGzip);
        } finally {
            if (outputStream != null) {
                outputStream.close();
            }
        }

        logger.log();
    }

    private static void processRequest(GraphRequestBatch requests, Logger logger, int numRequests,
                                       URL url, OutputStream outputStream, boolean shouldUseGzip)
            throws IOException, JSONException {
        Serializer serializer = new Serializer(outputStream, logger, shouldUseGzip);

        if (numRequests == 1) {
            GraphRequest request = requests.get(0);

            Map<String, Attachment> attachments = new HashMap<String, Attachment>();
            for (String key : request.parameters.keySet()) {
                Object value = request.parameters.get(key);
                if (isSupportedAttachmentType(value)) {
                    attachments.put(key, new Attachment(request, value));
                }
            }

            if (logger != null) {
                logger.append("  Parameters:\n");
            }
            serializeParameters(request.parameters, serializer, request);

            if (logger != null) {
                logger.append("  Attachments:\n");
            }
            serializeAttachments(attachments, serializer);

            if (request.graphObject != null) {
                processGraphObject(request.graphObject, url.getPath(), serializer);
            }
        } else {
            String batchAppID = getBatchAppId(requests);
            if (Utility.isNullOrEmpty(batchAppID)) {
                throw new FacebookException(
                        "App ID was not specified at the request or Settings.");
            }

            serializer.writeString(BATCH_APP_ID_PARAM, batchAppID);

            
            
            Map<String, Attachment> attachments = new HashMap<String, Attachment>();
            serializeRequestsAsJSON(serializer, requests, attachments);

            if (logger != null) {
                logger.append("  Attachments:\n");
            }
            serializeAttachments(attachments, serializer);
        }
    }

    private static boolean isMeRequest(String path) {
        Matcher matcher = versionPattern.matcher(path);
        if (matcher.matches()) {
            
            path = matcher.group(1);
        }
        if (path.startsWith("me/") || path.startsWith("/me/")) {
            return true;
        }
        return false;
    }

    private static void processGraphObject(
            JSONObject graphObject,
            String path,
            KeyValueSerializer serializer
    ) throws IOException {
        
        
        
        
        
        
        boolean isOGAction = false;
        if (isMeRequest(path)) {
            int colonLocation = path.indexOf(":");
            int questionMarkLocation = path.indexOf("?");
            isOGAction = colonLocation > 3
                    && (questionMarkLocation == -1 || colonLocation < questionMarkLocation);
        }

        Iterator<String> keyIterator = graphObject.keys();
        while (keyIterator.hasNext()) {
            String key = keyIterator.next();
            Object value = graphObject.opt(key);
            boolean passByValue = isOGAction && key.equalsIgnoreCase("image");
            processGraphObjectProperty(key, value, serializer, passByValue);
        }
    }

    private static void processGraphObjectProperty(
            String key,
            Object value,
            KeyValueSerializer serializer,
            boolean passByValue
    ) throws IOException {
        Class<?> valueClass = value.getClass();

        if (JSONObject.class.isAssignableFrom(valueClass)) {
            JSONObject jsonObject = (JSONObject) value;
            if (passByValue) {
                
                @SuppressWarnings("unchecked")
                Iterator<String> keys = jsonObject.keys();
                while (keys.hasNext()) {
                    String propertyName = keys.next();
                    String subKey = String.format("%s[%s]", key, propertyName);
                    processGraphObjectProperty(
                            subKey,
                            jsonObject.opt(propertyName),
                            serializer,
                            passByValue);
                }
            } else {
                
                
                if (jsonObject.has("id")) {
                    processGraphObjectProperty(
                            key,
                            jsonObject.optString("id"),
                            serializer,
                            passByValue);
                } else if (jsonObject.has("url")) {
                    processGraphObjectProperty(
                            key,
                            jsonObject.optString("url"),
                            serializer,
                            passByValue);
                } else if (jsonObject.has(NativeProtocol.OPEN_GRAPH_CREATE_OBJECT_KEY)) {
                    processGraphObjectProperty(key, jsonObject.toString(), serializer, passByValue);
                }
            }
        } else if (JSONArray.class.isAssignableFrom(valueClass)) {
            JSONArray jsonArray = (JSONArray) value;
            int length = jsonArray.length();
            for (int i = 0; i < length; ++i) {
                String subKey = String.format(Locale.ROOT, "%s[%d]", key, i);
                processGraphObjectProperty(subKey, jsonArray.opt(i), serializer, passByValue);
            }
        } else if (String.class.isAssignableFrom(valueClass) ||
                Number.class.isAssignableFrom(valueClass) ||
                Boolean.class.isAssignableFrom(valueClass)) {
            serializer.writeString(key, value.toString());
        } else if (Date.class.isAssignableFrom(valueClass)) {
            Date date = (Date) value;
            
            
            
            
            
            
            final SimpleDateFormat iso8601DateFormat = new SimpleDateFormat(
                    ISO_8601_FORMAT_STRING,
                    Locale.US);
            serializer.writeString(key, iso8601DateFormat.format(date));
        }
    }

    private static void serializeParameters(
            Bundle bundle,
            Serializer serializer,
            GraphRequest request
    ) throws IOException {
        Set<String> keys = bundle.keySet();

        for (String key : keys) {
            Object value = bundle.get(key);
            if (isSupportedParameterType(value)) {
                serializer.writeObject(key, value, request);
            }
        }
    }

    private static void serializeAttachments(
            Map<String, Attachment> attachments,
            Serializer serializer
    ) throws IOException {
        Set<String> keys = attachments.keySet();

        for (String key : keys) {
            Attachment attachment = attachments.get(key);
            if (isSupportedAttachmentType(attachment.getValue())) {
                serializer.writeObject(key, attachment.getValue(), attachment.getRequest());
            }
        }
    }

    private static void serializeRequestsAsJSON(
            Serializer serializer,
            Collection<GraphRequest> requests,
            Map<String, Attachment> attachments
    ) throws JSONException, IOException {
        JSONArray batch = new JSONArray();
        for (GraphRequest request : requests) {
            request.serializeToBatch(batch, attachments);
        }

        serializer.writeRequestsAsJson(BATCH_PARAM, batch, requests);
    }

    private static String getMimeContentType() {
        return String.format("multipart/form-data; boundary=%s", MIME_BOUNDARY);
    }

    private static volatile String userAgent;

    private static String getUserAgent() {
        if (userAgent == null) {
            userAgent = String.format("%s.%s", USER_AGENT_BASE, FacebookSdkVersion.BUILD);

            
            String customUserAgent = InternalSettings.getCustomUserAgent();
            if (!Utility.isNullOrEmpty(customUserAgent)) {
                userAgent = String.format(
                        Locale.ROOT,
                        "%s/%s",
                        userAgent,
                        customUserAgent);
            }
        }

        return userAgent;
    }

    private static String getBatchAppId(GraphRequestBatch batch) {
        if (!Utility.isNullOrEmpty(batch.getBatchApplicationId())) {
            return batch.getBatchApplicationId();
        }

        for (GraphRequest request : batch) {
            AccessToken accessToken = request.accessToken;
            if (accessToken != null) {
                String applicationId = accessToken.getApplicationId();
                if (applicationId != null) {
                    return applicationId;
                }
            }
        }
        if (!Utility.isNullOrEmpty(GraphRequest.defaultBatchApplicationId)) {
            return GraphRequest.defaultBatchApplicationId;
        }
        return FacebookSdk.getApplicationId();
    }

    private static boolean isSupportedAttachmentType(Object value) {
        return value instanceof Bitmap ||
                value instanceof byte[] ||
                value instanceof Uri ||
                value instanceof ParcelFileDescriptor ||
                value instanceof ParcelableResourceWithMimeType;
    }

    private static boolean isSupportedParameterType(Object value) {
        return value instanceof String || value instanceof Boolean || value instanceof Number ||
                value instanceof Date;
    }

    private static String parameterToString(Object value) {
        if (value instanceof String) {
            return (String) value;
        } else if (value instanceof Boolean || value instanceof Number) {
            return value.toString();
        } else if (value instanceof Date) {
            final SimpleDateFormat iso8601DateFormat = new SimpleDateFormat(
                    ISO_8601_FORMAT_STRING, Locale.US);
            return iso8601DateFormat.format(value);
        }
        throw new IllegalArgumentException("Unsupported parameter type.");
    }

    private interface KeyValueSerializer {
        void writeString(String key, String value) throws IOException;
    }

    private static class Serializer implements KeyValueSerializer {
        private final OutputStream outputStream;
        private final Logger logger;
        private boolean firstWrite = true;
        private boolean useUrlEncode = false;

        public Serializer(OutputStream outputStream, Logger logger, boolean useUrlEncode) {
            this.outputStream = outputStream;
            this.logger = logger;
            this.useUrlEncode = useUrlEncode;
        }

        public void writeObject(String key, Object value, GraphRequest request) throws IOException {
            if (outputStream instanceof RequestOutputStream) {
                ((RequestOutputStream) outputStream).setCurrentRequest(request);
            }

            if (isSupportedParameterType(value)) {
                writeString(key, parameterToString(value));
            } else if (value instanceof Bitmap) {
                writeBitmap(key, (Bitmap) value);
            } else if (value instanceof byte[]) {
                writeBytes(key, (byte[]) value);
            } else if (value instanceof Uri) {
                writeContentUri(key, (Uri) value, null);
            } else if (value instanceof ParcelFileDescriptor) {
                writeFile(key, (ParcelFileDescriptor) value, null);
            } else if (value instanceof ParcelableResourceWithMimeType) {
                ParcelableResourceWithMimeType resourceWithMimeType =
                        (ParcelableResourceWithMimeType) value;
                Parcelable resource = resourceWithMimeType.getResource();
                String mimeType = resourceWithMimeType.getMimeType();
                if (resource instanceof ParcelFileDescriptor) {
                    writeFile(key, (ParcelFileDescriptor) resource, mimeType);
                } else if (resource instanceof Uri) {
                    writeContentUri(key, (Uri) resource, mimeType);
                } else {
                    throw getInvalidTypeError();
                }
            } else {
                throw getInvalidTypeError();
            }
        }

        private RuntimeException getInvalidTypeError() {
            return new IllegalArgumentException("value is not a supported type.");
        }

        public void writeRequestsAsJson(
                String key,
                JSONArray requestJsonArray,
                Collection<GraphRequest> requests
        ) throws IOException, JSONException {
            if (!(outputStream instanceof RequestOutputStream)) {
                writeString(key, requestJsonArray.toString());
                return;
            }

            RequestOutputStream requestOutputStream = (RequestOutputStream) outputStream;
            writeContentDisposition(key, null, null);
            write("[");
            int i = 0;
            for (GraphRequest request : requests) {
                JSONObject requestJson = requestJsonArray.getJSONObject(i);
                requestOutputStream.setCurrentRequest(request);
                if (i > 0) {
                    write(",%s", requestJson.toString());
                } else {
                    write("%s", requestJson.toString());
                }
                i++;
            }
            write("]");
            if (logger != null) {
                logger.appendKeyValue("    " + key, requestJsonArray.toString());
            }
        }

        public void writeString(String key, String value) throws IOException {
            writeContentDisposition(key, null, null);
            writeLine("%s", value);
            writeRecordBoundary();
            if (logger != null) {
                logger.appendKeyValue("    " + key, value);
            }
        }

        public void writeBitmap(String key, Bitmap bitmap) throws IOException {
            writeContentDisposition(key, key, "image/png");
            
            bitmap.compress(Bitmap.CompressFormat.PNG, 100, outputStream);
            writeLine("");
            writeRecordBoundary();
            if (logger != null) {
                logger.appendKeyValue("    " + key, "<Image>");
            }
        }

        public void writeBytes(String key, byte[] bytes) throws IOException {
            writeContentDisposition(key, key, "content/unknown");
            this.outputStream.write(bytes);
            writeLine("");
            writeRecordBoundary();
            if (logger != null) {
                logger.appendKeyValue(
                        "    " + key,
                        String.format(Locale.ROOT, "<Data: %d>", bytes.length));
            }
        }

        public void writeContentUri(String key, Uri contentUri, String mimeType)
                throws IOException {
            if (mimeType == null) {
                mimeType = "content/unknown";
            }
            writeContentDisposition(key, key, mimeType);

            InputStream inputStream = FacebookSdk
                    .getApplicationContext()
                    .getContentResolver()
                    .openInputStream(contentUri);

            int totalBytes = 0;
            if (outputStream instanceof ProgressNoopOutputStream) {
                
                long contentSize = Utility.getContentSize(contentUri);

                ((ProgressNoopOutputStream) outputStream).addProgress(contentSize);
            } else {
                totalBytes += Utility.copyAndCloseInputStream(inputStream, outputStream);
            }

            writeLine("");
            writeRecordBoundary();
            if (logger != null) {
                logger.appendKeyValue(
                        "    " + key,
                        String.format(Locale.ROOT, "<Data: %d>", totalBytes));
            }
        }

        public void writeFile(
                String key,
                ParcelFileDescriptor descriptor,
                String mimeType
        ) throws IOException {
            if (mimeType == null) {
                mimeType = "content/unknown";
            }
            writeContentDisposition(key, key, mimeType);

            int totalBytes = 0;

            if (outputStream instanceof ProgressNoopOutputStream) {
                
                ((ProgressNoopOutputStream) outputStream).addProgress(descriptor.getStatSize());
            } else {
                ParcelFileDescriptor.AutoCloseInputStream inputStream =
                        new ParcelFileDescriptor.AutoCloseInputStream(descriptor);
                totalBytes += Utility.copyAndCloseInputStream(inputStream, outputStream);
            }
            writeLine("");
            writeRecordBoundary();
            if (logger != null) {
                logger.appendKeyValue(
                        "    " + key,
                        String.format(Locale.ROOT, "<Data: %d>", totalBytes));
            }
        }

        public void writeRecordBoundary() throws IOException {
            if (!useUrlEncode) {
                writeLine("--%s", MIME_BOUNDARY);
            } else {
                this.outputStream.write("&".getBytes());
            }
        }

        public void writeContentDisposition(
                String name,
                String filename,
                String contentType
        ) throws IOException {
            if (!useUrlEncode) {
                write("Content-Disposition: form-data; name=\"%s\"", name);
                if (filename != null) {
                    write("; filename=\"%s\"", filename);
                }
                writeLine(""); 
                if (contentType != null) {
                    writeLine("%s: %s", CONTENT_TYPE_HEADER, contentType);
                }
                writeLine(""); 
            } else {
                this.outputStream.write(String.format("%s=", name).getBytes());
            }
        }

        public void write(String format, Object... args) throws IOException {
            if (!useUrlEncode) {
                if (firstWrite) {
                    
                    this.outputStream.write("--".getBytes());
                    this.outputStream.write(MIME_BOUNDARY.getBytes());
                    this.outputStream.write("\r\n".getBytes());
                    firstWrite = false;
                }
                this.outputStream.write(String.format(format, args).getBytes());
            } else {
                this.outputStream.write(
                        URLEncoder.encode(
                                String.format(Locale.US, format, args), "UTF-8").getBytes());
            }
        }

        public void writeLine(String format, Object... args) throws IOException {
            write(format, args);
            if (!useUrlEncode) {
                write("\r\n");
            }
        }

    }

    
    public interface Callback {
        
        void onCompleted(GraphResponse response);
    }

    
    public interface OnProgressCallback extends Callback {
        
        void onProgress(long current, long max);
    }

    
    public interface GraphJSONArrayCallback {
        
        void onCompleted(JSONArray objects, GraphResponse response);
    }

    
    public interface GraphJSONObjectCallback {
        
        void onCompleted(JSONObject object, GraphResponse response);
    }

    
    public static class ParcelableResourceWithMimeType<RESOURCE extends Parcelable>
            implements Parcelable {
        private final String mimeType;
        private final RESOURCE resource;

        public String getMimeType() {
            return mimeType;
        }

        public RESOURCE getResource() {
            return resource;
        }

        public int describeContents() {
            return CONTENTS_FILE_DESCRIPTOR;
        }

        public void writeToParcel(Parcel out, int flags) {
            out.writeString(mimeType);
            out.writeParcelable(resource, flags);
        }

        @SuppressWarnings("unused")
        public static final Parcelable.Creator<ParcelableResourceWithMimeType> CREATOR
                = new Parcelable.Creator<ParcelableResourceWithMimeType>() {
            public ParcelableResourceWithMimeType createFromParcel(Parcel in) {
                return new ParcelableResourceWithMimeType(in);
            }

            public ParcelableResourceWithMimeType[] newArray(int size) {
                return new ParcelableResourceWithMimeType[size];
            }
        };

        
        public ParcelableResourceWithMimeType(
                RESOURCE resource,
                String mimeType
        ) {
            this.mimeType = mimeType;
            this.resource = resource;
        }

        private ParcelableResourceWithMimeType(Parcel in) {
            mimeType = in.readString();
            resource = in.readParcelable(FacebookSdk.getApplicationContext().getClassLoader());
        }
    }
}

<code block>


package com.facebook;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.Signature;
import android.os.AsyncTask;
import android.util.Base64;
import android.util.Log;

import com.facebook.appevents.AppEventsLogger;
import com.facebook.internal.AppEventsLoggerUtility;
import com.facebook.internal.BoltsMeasurementEventListener;
import com.facebook.internal.AttributionIdentifiers;
import com.facebook.internal.NativeProtocol;
import com.facebook.internal.Utility;
import com.facebook.internal.Validate;

import org.json.JSONException;
import org.json.JSONObject;

import java.io.File;
import java.lang.reflect.Field;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;


public final class FacebookSdk {
    private static final String TAG = FacebookSdk.class.getCanonicalName();
    private static final HashSet<LoggingBehavior> loggingBehaviors =
            new HashSet<LoggingBehavior>(Arrays.asList(LoggingBehavior.DEVELOPER_ERRORS));
    private static volatile Executor executor;
    private static volatile String applicationId;
    private static volatile String applicationName;
    private static volatile String appClientToken;
    private static volatile int webDialogTheme;
    private static final String FACEBOOK_COM = "facebook.com";
    private static volatile String facebookDomain = FACEBOOK_COM;
    private static AtomicLong onProgressThreshold = new AtomicLong(65536);
    private static volatile boolean isDebugEnabled = BuildConfig.DEBUG;
    private static boolean isLegacyTokenUpgradeSupported = false;
    private static File cacheDir;
    private static Context applicationContext;
    private static final int DEFAULT_CORE_POOL_SIZE = 5;
    private static final int DEFAULT_MAXIMUM_POOL_SIZE = 128;
    private static final int DEFAULT_KEEP_ALIVE = 1;
    private static int callbackRequestCodeOffset = 0xface;
    private static final Object LOCK = new Object();

    private static final int MAX_REQUEST_CODE_RANGE = 100;

    private static final String ATTRIBUTION_PREFERENCES = "com.facebook.sdk.attributionTracking";
    private static final String PUBLISH_ACTIVITY_PATH = "%s/activities";

    private static final BlockingQueue<Runnable> DEFAULT_WORK_QUEUE =
            new LinkedBlockingQueue<Runnable>(10);

    private static final ThreadFactory DEFAULT_THREAD_FACTORY = new ThreadFactory() {
        private final AtomicInteger counter = new AtomicInteger(0);

        public Thread newThread(Runnable runnable) {
            return new Thread(runnable, "FacebookSdk #" + counter.incrementAndGet());
        }
    };

    static final String CALLBACK_OFFSET_CHANGED_AFTER_INIT =
            "The callback request code offset can't be updated once the SDK is initialized.";

    static final String CALLBACK_OFFSET_NEGATIVE =
            "The callback request code offset can't be negative.";


    
    public static final String APPLICATION_ID_PROPERTY = "com.facebook.sdk.ApplicationId";

    
    public static final String APPLICATION_NAME_PROPERTY = "com.facebook.sdk.ApplicationName";

    
    public static final String CLIENT_TOKEN_PROPERTY = "com.facebook.sdk.ClientToken";

    
    public static final String WEB_DIALOG_THEME = "com.facebook.sdk.WebDialogTheme";

    private static Boolean sdkInitialized = false;

    
    public static synchronized void sdkInitialize(
            Context applicationContext,
            int callbackRequestCodeOffset) {
        if (sdkInitialized && callbackRequestCodeOffset != FacebookSdk.callbackRequestCodeOffset) {
            throw new FacebookException(CALLBACK_OFFSET_CHANGED_AFTER_INIT);
        }
        if (callbackRequestCodeOffset < 0) {
            throw new FacebookException(CALLBACK_OFFSET_NEGATIVE);
        }
        FacebookSdk.callbackRequestCodeOffset = callbackRequestCodeOffset;
        sdkInitialize(applicationContext);
    }


    
    public static synchronized void sdkInitialize(Context applicationContext) {
        if (sdkInitialized == true) {
          return;
        }

        Validate.notNull(applicationContext, "applicationContext");

        
        
        Validate.hasFacebookActivity(applicationContext, false);
        Validate.hasInternetPermissions(applicationContext, false);

        FacebookSdk.applicationContext = applicationContext.getApplicationContext();

        
        FacebookSdk.loadDefaultsFromMetadata(FacebookSdk.applicationContext);
        
        Utility.loadAppSettingsAsync(FacebookSdk.applicationContext, applicationId);
        
        NativeProtocol.updateAllAvailableProtocolVersionsAsync();

        BoltsMeasurementEventListener.getInstance(FacebookSdk.applicationContext);

        cacheDir = FacebookSdk.applicationContext.getCacheDir();

        FutureTask<Void> accessTokenLoadFutureTask =
                new FutureTask<Void>(new Callable<Void>() {
                    @Override
                    public Void call() throws Exception {
                        AccessTokenManager.getInstance().loadCurrentAccessToken();
                        ProfileManager.getInstance().loadCurrentProfile();
                        if (AccessToken.getCurrentAccessToken() != null &&
                                Profile.getCurrentProfile() == null) {
                            
                            
                            Profile.fetchProfileForCurrentAccessToken();
                        }
                        return null;
                    }
                });
        getExecutor().execute(accessTokenLoadFutureTask);

        sdkInitialized = true;
    }

    
    public static synchronized boolean isInitialized() {
        return sdkInitialized;
    }

    
    public static Set<LoggingBehavior> getLoggingBehaviors() {
        synchronized (loggingBehaviors) {
            return Collections.unmodifiableSet(new HashSet<LoggingBehavior>(loggingBehaviors));
        }
    }

    
    public static void addLoggingBehavior(LoggingBehavior behavior) {
        synchronized (loggingBehaviors) {
            loggingBehaviors.add(behavior);
            updateGraphDebugBehavior();
        }
    }

    
    public static void removeLoggingBehavior(LoggingBehavior behavior) {
        synchronized (loggingBehaviors) {
            loggingBehaviors.remove(behavior);
        }
    }

    
    public static void clearLoggingBehaviors() {
        synchronized (loggingBehaviors) {
            loggingBehaviors.clear();
        }
    }

    
    public static boolean isLoggingBehaviorEnabled(LoggingBehavior behavior) {
        synchronized (loggingBehaviors) {
            return FacebookSdk.isDebugEnabled() && loggingBehaviors.contains(behavior);
        }
    }

    
    public static boolean isDebugEnabled() {
        return isDebugEnabled;
    }

    
    public static void setIsDebugEnabled(boolean enabled) {
        isDebugEnabled = enabled;
    }

    
    public static boolean isLegacyTokenUpgradeSupported() {
        return isLegacyTokenUpgradeSupported;
    }

    private static void updateGraphDebugBehavior() {
        if (loggingBehaviors.contains(LoggingBehavior.GRAPH_API_DEBUG_INFO)
           && !loggingBehaviors.contains(LoggingBehavior.GRAPH_API_DEBUG_WARNING)) {
            loggingBehaviors.add(LoggingBehavior.GRAPH_API_DEBUG_WARNING);
        }
    }

    
    public static void setLegacyTokenUpgradeSupported(boolean supported) {
        isLegacyTokenUpgradeSupported = supported;
    }

    
    public static Executor getExecutor() {
        synchronized (LOCK) {
            if (FacebookSdk.executor == null) {
                Executor executor = getAsyncTaskExecutor();
                if (executor == null) {
                    executor = new ThreadPoolExecutor(
                            DEFAULT_CORE_POOL_SIZE, DEFAULT_MAXIMUM_POOL_SIZE, DEFAULT_KEEP_ALIVE,
                            TimeUnit.SECONDS, DEFAULT_WORK_QUEUE, DEFAULT_THREAD_FACTORY);
                }
                FacebookSdk.executor = executor;
            }
        }
        return FacebookSdk.executor;
    }

    
    public static void setExecutor(Executor executor) {
        Validate.notNull(executor, "executor");
        synchronized (LOCK) {
            FacebookSdk.executor = executor;
        }
    }

    
    public static String getFacebookDomain() {
        return facebookDomain;
    }

    
    public static void setFacebookDomain(String facebookDomain) {
        if (!BuildConfig.DEBUG) {
            Log.w(TAG, "WARNING: Calling setFacebookDomain from non-DEBUG code.");
        }

        FacebookSdk.facebookDomain = facebookDomain;
    }

    
    public static Context getApplicationContext() {
        Validate.sdkInitialized();
        return applicationContext;
    }

    private static Executor getAsyncTaskExecutor() {
        Field executorField = null;
        try {
            executorField = AsyncTask.class.getField("THREAD_POOL_EXECUTOR");
        } catch (NoSuchFieldException e) {
            return null;
        }

        Object executorObject = null;
        try {
            executorObject = executorField.get(null);
        } catch (IllegalAccessException e) {
            return null;
        }

        if (executorObject == null) {
            return null;
        }

        if (!(executorObject instanceof Executor)) {
            return null;
        }

        return (Executor) executorObject;
    }

    
    public static void publishInstallAsync(final Context context, final String applicationId) {
        
        
        final Context applicationContext = context.getApplicationContext();
        FacebookSdk.getExecutor().execute(new Runnable() {
            @Override
            public void run() {
                FacebookSdk.publishInstallAndWaitForResponse(applicationContext, applicationId);
            }
        });
    }

    static GraphResponse publishInstallAndWaitForResponse(
            final Context context,
            final String applicationId) {
        try {
            if (context == null || applicationId == null) {
                throw new IllegalArgumentException("Both context and applicationId must be non-null");
            }
            AttributionIdentifiers identifiers = AttributionIdentifiers.getAttributionIdentifiers(context);
            SharedPreferences preferences = context.getSharedPreferences(ATTRIBUTION_PREFERENCES, Context.MODE_PRIVATE);
            String pingKey = applicationId+"ping";
            String jsonKey = applicationId+"json";
            long lastPing = preferences.getLong(pingKey, 0);
            String lastResponseJSON = preferences.getString(jsonKey, null);

            JSONObject publishParams;
            try {
                publishParams = AppEventsLoggerUtility.getJSONObjectForGraphAPICall(
                        AppEventsLoggerUtility.GraphAPIActivityType.MOBILE_INSTALL_EVENT,
                        identifiers,
                        AppEventsLogger.getAnonymousAppDeviceGUID(context),
                        getLimitEventAndDataUsage(context),
                        context);
            } catch (JSONException e) {
                throw new FacebookException("An error occurred while publishing install.", e);
            }

            String publishUrl = String.format(PUBLISH_ACTIVITY_PATH, applicationId);
            GraphRequest publishRequest = GraphRequest.newPostRequest(null, publishUrl, publishParams, null);

            if (lastPing != 0) {
                JSONObject graphObject = null;
                try {
                    if (lastResponseJSON != null) {
                        graphObject = new JSONObject(lastResponseJSON);
                    }
                }
                catch (JSONException je) {
                    
                }
                if (graphObject == null) {
                    return GraphResponse.createResponsesFromString(
                            "true",
                            null,
                            new GraphRequestBatch(publishRequest)
                    ).get(0);
                } else {
                    return new GraphResponse(null, null, null, graphObject);
                }

            } else {

                GraphResponse publishResponse = publishRequest.executeAndWait();

                
                SharedPreferences.Editor editor = preferences.edit();
                lastPing = System.currentTimeMillis();
                editor.putLong(pingKey, lastPing);

                
                if (publishResponse.getJSONObject() != null) {
                    editor.putString(jsonKey, publishResponse.getJSONObject().toString());
                }
                editor.apply();

                return publishResponse;
            }
        } catch (Exception e) {
            
            Utility.logd("Facebook-publish", e);
            return new GraphResponse(null, null, new FacebookRequestError(null, e));
        }
    }

    
    public static String getSdkVersion() {
        return FacebookSdkVersion.BUILD;
    }

    
    public static boolean getLimitEventAndDataUsage(Context context) {
        Validate.sdkInitialized();
        SharedPreferences preferences = context.getSharedPreferences(
                AppEventsLogger.APP_EVENT_PREFERENCES, Context.MODE_PRIVATE);
        return preferences.getBoolean("limitEventUsage", false);
    }

    
    public static void setLimitEventAndDataUsage(Context context, boolean limitEventUsage) {
        context.getSharedPreferences(AppEventsLogger.APP_EVENT_PREFERENCES, Context.MODE_PRIVATE)
            .edit()
            .putBoolean("limitEventUsage", limitEventUsage)
            .apply();
    }

    
    public static long getOnProgressThreshold() {
        Validate.sdkInitialized();
        return onProgressThreshold.get();
    }

    
    public static void setOnProgressThreshold(long threshold) {
        onProgressThreshold.set(threshold);
    }

    
    static void loadDefaultsFromMetadata(Context context) {
        if (context == null) {
            return;
        }

        ApplicationInfo ai = null;
        try {
            ai = context.getPackageManager().getApplicationInfo(
                    context.getPackageName(), PackageManager.GET_META_DATA);
        } catch (PackageManager.NameNotFoundException e) {
            return;
        }

        if (ai == null || ai.metaData == null) {
            return;
        }

        if (applicationId == null) {
            Object appId = ai.metaData.get(APPLICATION_ID_PROPERTY);
            if (appId instanceof String) {
                applicationId = (String) appId;
            } else if (appId instanceof Integer) {
                applicationId = appId.toString();
            }
        }

        if (applicationName == null) {
            applicationName = ai.metaData.getString(APPLICATION_NAME_PROPERTY);
        }

        if (appClientToken == null) {
            appClientToken = ai.metaData.getString(CLIENT_TOKEN_PROPERTY);
        }

        if (webDialogTheme == 0) {
            setWebDialogTheme(ai.metaData.getInt(WEB_DIALOG_THEME));
        }
    }

    
    public static String getApplicationSignature(Context context) {
        Validate.sdkInitialized();
        if (context == null) {
            return null;
        }
        PackageManager packageManager = context.getPackageManager();
        if (packageManager == null) {
            return null;
        }

        String packageName = context.getPackageName();
        PackageInfo pInfo;
        try {
            pInfo = packageManager.getPackageInfo(packageName, PackageManager.GET_SIGNATURES);
        } catch (PackageManager.NameNotFoundException e) {
            return null;
        }

        Signature[] signatures = pInfo.signatures;
        if (signatures == null || signatures.length == 0) {
            return null;
        }

        MessageDigest md;
        try {
            md = MessageDigest.getInstance("SHA-1");
        } catch (NoSuchAlgorithmException e) {
            return null;
        }

        md.update(pInfo.signatures[0].toByteArray());
        return Base64.encodeToString(md.digest(),  Base64.URL_SAFE | Base64.NO_PADDING);
    }

    
    public static String getApplicationId() {
        Validate.sdkInitialized();
        return applicationId;
    }

    
    public static void setApplicationId(String applicationId) {
        FacebookSdk.applicationId = applicationId;
    }

    
    public static String getApplicationName() {
        Validate.sdkInitialized();
        return applicationName;
    }

    
    public static void setApplicationName(String applicationName) {
        FacebookSdk.applicationName = applicationName;
    }

    
    public static String getClientToken() {
        Validate.sdkInitialized();
        return appClientToken;
    }

    
    public static void setClientToken(String clientToken) {
        appClientToken = clientToken;
    }

    
    public static int getWebDialogTheme() {
        Validate.sdkInitialized();
        return webDialogTheme;
    }

    
    public static void setWebDialogTheme(int theme) {
        webDialogTheme = theme;
    }

    
    public static File getCacheDir() {
        Validate.sdkInitialized();
        return cacheDir;
    }

    
    public static void setCacheDir(File cacheDir) {
        FacebookSdk.cacheDir = cacheDir;
    }

    
    public static int getCallbackRequestCodeOffset() {
        Validate.sdkInitialized();
        return callbackRequestCodeOffset;
    }

    
    public static boolean isFacebookRequestCode(int requestCode) {
        return requestCode >= callbackRequestCodeOffset
                && requestCode < callbackRequestCodeOffset + MAX_REQUEST_CODE_RANGE;
    }
}

<code block>


package com.facebook.internal;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.database.Cursor;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.os.Environment;
import android.os.Parcel;
import android.os.StatFs;
import android.provider.OpenableColumns;
import android.telephony.TelephonyManager;
import android.text.TextUtils;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.Display;
import android.view.WindowManager;
import android.webkit.CookieManager;
import android.webkit.CookieSyncManager;

import com.facebook.AccessToken;
import com.facebook.FacebookException;
import com.facebook.FacebookSdk;
import com.facebook.GraphRequest;
import com.facebook.GraphResponse;
import com.facebook.HttpMethod;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.json.JSONTokener;

import java.io.*;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.HttpURLConnection;
import java.net.URLConnection;

import java.net.URLDecoder;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.regex.Pattern;


public final class Utility {
    static final String LOG_TAG = "FacebookSDK";
    private static final String HASH_ALGORITHM_MD5 = "MD5";
    private static final String HASH_ALGORITHM_SHA1 = "SHA-1";
    private static final String URL_SCHEME = "https";
    private static final String APP_SETTINGS_PREFS_STORE =
            "com.facebook.internal.preferences.APP_SETTINGS";
    private static final String APP_SETTINGS_PREFS_KEY_FORMAT =
            "com.facebook.internal.APP_SETTINGS.%s";
    private static final String APP_SETTING_SUPPORTS_IMPLICIT_SDK_LOGGING =
            "supports_implicit_sdk_logging";
    private static final String APP_SETTING_NUX_CONTENT = "gdpv4_nux_content";
    private static final String APP_SETTING_NUX_ENABLED = "gdpv4_nux_enabled";
    private static final String APP_SETTING_DIALOG_CONFIGS = "android_dialog_configs";
    private static final String APP_SETTING_ANDROID_SDK_ERROR_CATEGORIES =
            "android_sdk_error_categories";
    private static final String EXTRA_APP_EVENTS_INFO_FORMAT_VERSION = "a2";
    private static final String DIALOG_CONFIG_DIALOG_NAME_FEATURE_NAME_SEPARATOR = "\\|";
    private static final String DIALOG_CONFIG_NAME_KEY = "name";
    private static final String DIALOG_CONFIG_VERSIONS_KEY = "versions";
    private static final String DIALOG_CONFIG_URL_KEY = "url";

    private final static String UTF8 = "UTF-8";

    private static final String[] APP_SETTING_FIELDS = new String[]{
            APP_SETTING_SUPPORTS_IMPLICIT_SDK_LOGGING,
            APP_SETTING_NUX_CONTENT,
            APP_SETTING_NUX_ENABLED,
            APP_SETTING_DIALOG_CONFIGS,
            APP_SETTING_ANDROID_SDK_ERROR_CATEGORIES
    };
    private static final String APPLICATION_FIELDS = "fields";

    
    
    public static final int DEFAULT_STREAM_BUFFER_SIZE = 8192;

    
    private static final int REFRESH_TIME_FOR_EXTENDED_DEVICE_INFO_MILLIS = 30 * 60 * 1000;

    private static final String noCarrierConstant = "NoCarrier";

    private static final int GINGERBREAD_MR1 = 10;

    private static Map<String, FetchedAppSettings> fetchedAppSettings =
            new ConcurrentHashMap<String, FetchedAppSettings>();

    private static AtomicBoolean loadingSettings = new AtomicBoolean(false);

    private static int numCPUCores = 0;

    private static long timestampOfLastCheck = -1;
    private static long totalExternalStorageGB = -1;
    private static long availableExternalStorageGB = -1;
    private static String deviceTimezone = "";
    private static String carrierName = noCarrierConstant;

    public static class FetchedAppSettings {
        private boolean supportsImplicitLogging;
        private String nuxContent;
        private boolean nuxEnabled;
        private Map<String, Map<String, DialogFeatureConfig>> dialogConfigMap;
        private FacebookRequestErrorClassification errorClassification;

        private FetchedAppSettings(boolean supportsImplicitLogging,
                                   String nuxContent,
                                   boolean nuxEnabled,
                                   Map<String, Map<String, DialogFeatureConfig>> dialogConfigMap,
                                   FacebookRequestErrorClassification errorClassification) {
            this.supportsImplicitLogging = supportsImplicitLogging;
            this.nuxContent = nuxContent;
            this.nuxEnabled = nuxEnabled;
            this.dialogConfigMap = dialogConfigMap;
            this.errorClassification = errorClassification;
        }

        public boolean supportsImplicitLogging() {
            return supportsImplicitLogging;
        }

        public String getNuxContent() {
            return nuxContent;
        }

        public boolean getNuxEnabled() {
            return nuxEnabled;
        }

        public Map<String, Map<String, DialogFeatureConfig>> getDialogConfigurations() {
            return dialogConfigMap;
        }

        public FacebookRequestErrorClassification getErrorClassification() {
            return errorClassification;
        }
    }

    public static class DialogFeatureConfig {
        private static DialogFeatureConfig parseDialogConfig(JSONObject dialogConfigJSON) {
            String dialogNameWithFeature = dialogConfigJSON.optString(DIALOG_CONFIG_NAME_KEY);
            if (Utility.isNullOrEmpty(dialogNameWithFeature)) {
                return null;
            }

            String[] components = dialogNameWithFeature.split(
                    DIALOG_CONFIG_DIALOG_NAME_FEATURE_NAME_SEPARATOR);
            if (components.length != 2) {
                
                
                return null;
            }

            String dialogName = components[0];
            String featureName = components[1];
            if (isNullOrEmpty(dialogName) || isNullOrEmpty(featureName)) {
                return null;
            }

            String urlString = dialogConfigJSON.optString(DIALOG_CONFIG_URL_KEY);
            Uri fallbackUri = null;
            if (!Utility.isNullOrEmpty(urlString)) {
                fallbackUri = Uri.parse(urlString);
            }

            JSONArray versionsJSON = dialogConfigJSON.optJSONArray(DIALOG_CONFIG_VERSIONS_KEY);

            int[] featureVersionSpec = parseVersionSpec(versionsJSON);

            return new DialogFeatureConfig(
                    dialogName, featureName, fallbackUri, featureVersionSpec);
        }

        private static int[] parseVersionSpec(JSONArray versionsJSON) {
            
            
            
            int[] versionSpec = null;
            if (versionsJSON != null) {
                int numVersions = versionsJSON.length();
                versionSpec = new int[numVersions];
                for (int i = 0; i < numVersions; i++) {
                    
                    int version = versionsJSON.optInt(i, NativeProtocol.NO_PROTOCOL_AVAILABLE);
                    if (version == NativeProtocol.NO_PROTOCOL_AVAILABLE) {
                        
                        
                        String versionString = versionsJSON.optString(i);
                        if (!isNullOrEmpty(versionString)) {
                            try {
                                version = Integer.parseInt(versionString);
                            } catch (NumberFormatException nfe) {
                                logd(LOG_TAG, nfe);
                                version = NativeProtocol.NO_PROTOCOL_AVAILABLE;
                            }
                        }
                    }

                    versionSpec[i] = version;
                }
            }

            return versionSpec;
        }

        private String dialogName;
        private String featureName;
        private Uri fallbackUrl;
        private int[] featureVersionSpec;

        private DialogFeatureConfig(
                String dialogName,
                String featureName,
                Uri fallbackUrl,
                int[] featureVersionSpec) {
            this.dialogName = dialogName;
            this.featureName = featureName;
            this.fallbackUrl = fallbackUrl;
            this.featureVersionSpec = featureVersionSpec;
        }

        public String getDialogName() {
            return dialogName;
        }

        public String getFeatureName() {
            return featureName;
        }

        public Uri getFallbackUrl() {
            return fallbackUrl;
        }

        public int[] getVersionSpec() {
            return featureVersionSpec;
        }
    }

    
    public static int[] intersectRanges(int[] range1, int[] range2) {
        if (range1 == null) {
            return range2;
        } else if (range2 == null) {
            return range1;
        }

        int[] outputRange = new int[range1.length + range2.length];
        int outputIndex = 0;
        int index1 = 0, lower1, upper1;
        int index2 = 0, lower2, upper2;
        while (index1 < range1.length && index2 < range2.length) {
            int newRangeLower = Integer.MIN_VALUE, newRangeUpper = Integer.MAX_VALUE;
            lower1 = range1[index1];
            upper1 = Integer.MAX_VALUE;

            lower2 = range2[index2];
            upper2 = Integer.MAX_VALUE;

            if (index1 < range1.length - 1) {
                upper1 = range1[index1 + 1];
            }
            if (index2 < range2.length - 1) {
                upper2 = range2[index2 + 1];
            }

            if (lower1 < lower2) {
                if (upper1 > lower2) {
                    newRangeLower = lower2;
                    if (upper1 > upper2) {
                        newRangeUpper = upper2;
                        index2 += 2;
                    } else {
                        newRangeUpper = upper1;
                        index1 += 2;
                    }
                } else {
                    index1 += 2;
                }
            } else {
                if (upper2 > lower1) {
                    newRangeLower = lower1;
                    if (upper2 > upper1) {
                        newRangeUpper = upper1;
                        index1 += 2;
                    } else {
                        newRangeUpper = upper2;
                        index2 += 2;
                    }
                } else {
                    index2 += 2;
                }
            }

            if (newRangeLower != Integer.MIN_VALUE) {
                outputRange[outputIndex++] = newRangeLower;
                if (newRangeUpper != Integer.MAX_VALUE) {
                    outputRange[outputIndex++] = newRangeUpper;
                } else {
                    
                    break;
                }
            }
        }

        return Arrays.copyOf(outputRange, outputIndex);
    }

    
    
    
    public static <T> boolean isSubset(Collection<T> subset, Collection<T> superset) {
        if ((superset == null) || (superset.size() == 0)) {
            return ((subset == null) || (subset.size() == 0));
        }

        HashSet<T> hash = new HashSet<T>(superset);
        for (T t : subset) {
            if (!hash.contains(t)) {
                return false;
            }
        }
        return true;
    }

    public static <T> boolean isNullOrEmpty(Collection<T> c) {
        return (c == null) || (c.size() == 0);
    }

    public static boolean isNullOrEmpty(String s) {
        return (s == null) || (s.length() == 0);
    }

    
    public static String coerceValueIfNullOrEmpty(String s, String valueIfNullOrEmpty) {
        if (isNullOrEmpty(s)) {
            return valueIfNullOrEmpty;
        }

        return s;
    }

    public static <T> Collection<T> unmodifiableCollection(T... ts) {
        return Collections.unmodifiableCollection(Arrays.asList(ts));
    }

    public static <T> ArrayList<T> arrayList(T... ts) {
        ArrayList<T> arrayList = new ArrayList<T>(ts.length);
        for (T t : ts) {
            arrayList.add(t);
        }
        return arrayList;
    }

    public static <T> HashSet<T> hashSet(T... ts) {
        HashSet<T> hashSet = new HashSet<T>(ts.length);
        for (T t : ts) {
            hashSet.add(t);
        }
        return hashSet;
    }

    public static String md5hash(String key) {
        return hashWithAlgorithm(HASH_ALGORITHM_MD5, key);
    }

    public static String sha1hash(String key) {
        return hashWithAlgorithm(HASH_ALGORITHM_SHA1, key);
    }

    public static String sha1hash(byte[] bytes) {
        return hashWithAlgorithm(HASH_ALGORITHM_SHA1, bytes);
    }

    private static String hashWithAlgorithm(String algorithm, String key) {
        return hashWithAlgorithm(algorithm, key.getBytes());
    }

    private static String hashWithAlgorithm(String algorithm, byte[] bytes) {
        MessageDigest hash;
        try {
            hash = MessageDigest.getInstance(algorithm);
        } catch (NoSuchAlgorithmException e) {
            return null;
        }
        return hashBytes(hash, bytes);
    }

    private static String hashBytes(MessageDigest hash, byte[] bytes) {
        hash.update(bytes);
        byte[] digest = hash.digest();
        StringBuilder builder = new StringBuilder();
        for (int b : digest) {
            builder.append(Integer.toHexString((b >> 4) & 0xf));
            builder.append(Integer.toHexString((b >> 0) & 0xf));
        }
        return builder.toString();
    }

    public static Uri buildUri(String authority, String path, Bundle parameters) {
        Uri.Builder builder = new Uri.Builder();
        builder.scheme(URL_SCHEME);
        builder.authority(authority);
        builder.path(path);
        if (parameters != null) {
            for (String key : parameters.keySet()) {
                Object parameter = parameters.get(key);
                if (parameter instanceof String) {
                    builder.appendQueryParameter(key, (String) parameter);
                }
            }
        }
        return builder.build();
    }

    public static Bundle parseUrlQueryString(String queryString) {
        Bundle params = new Bundle();
        if (!isNullOrEmpty(queryString)) {
            String array[] = queryString.split("&");
            for (String parameter : array) {
                String keyValuePair[] = parameter.split("=");

                try {
                    if (keyValuePair.length == 2) {
                        params.putString(
                                URLDecoder.decode(keyValuePair[0], UTF8),
                                URLDecoder.decode(keyValuePair[1], UTF8));
                    } else if (keyValuePair.length == 1) {
                        params.putString(
                                URLDecoder.decode(keyValuePair[0], UTF8),
                                "");
                    }
                } catch (UnsupportedEncodingException e) {
                    
                    logd(LOG_TAG, e);
                }
            }
        }
        return params;
    }

    public static void putNonEmptyString(Bundle b, String key, String value) {
        if (!Utility.isNullOrEmpty(value)) {
            b.putString(key, value);
        }
    }

    public static void putCommaSeparatedStringList(Bundle b, String key, ArrayList<String> list) {
        if (list != null) {
            StringBuilder builder = new StringBuilder();
            for (String string : list) {
                builder.append(string);
                builder.append(",");
            }
            String commaSeparated = "";
            if (builder.length() > 0) {
                commaSeparated = builder.substring(0, builder.length() - 1);
            }
            b.putString(key, commaSeparated);
        }
    }

    public static void putUri(Bundle b, String key, Uri uri) {
        if (uri != null) {
            Utility.putNonEmptyString(b, key, uri.toString());
        }
    }

    public static boolean putJSONValueInBundle(Bundle bundle, String key, Object value) {
        if (value == null) {
            bundle.remove(key);
        } else if (value instanceof Boolean) {
            bundle.putBoolean(key, (boolean) value);
        } else if (value instanceof boolean[]) {
            bundle.putBooleanArray(key, (boolean[]) value);
        } else if (value instanceof Double) {
            bundle.putDouble(key, (double) value);
        } else if (value instanceof double[]) {
            bundle.putDoubleArray(key, (double[]) value);
        } else if (value instanceof Integer) {
            bundle.putInt(key, (int) value);
        } else if (value instanceof int[]) {
            bundle.putIntArray(key, (int[]) value);
        } else if (value instanceof Long) {
            bundle.putLong(key, (long) value);
        } else if (value instanceof long[]) {
            bundle.putLongArray(key, (long[]) value);
        } else if (value instanceof String) {
            bundle.putString(key, (String) value);
        } else if (value instanceof JSONArray) {
            bundle.putString(key, ((JSONArray) value).toString());
        } else if (value instanceof JSONObject) {
            bundle.putString(key, ((JSONObject) value).toString());
        } else {
            return false;
        }
        return true;
    }

    public static void closeQuietly(Closeable closeable) {
        try {
            if (closeable != null) {
                closeable.close();
            }
        } catch (IOException ioe) {
            
        }
    }

    public static void disconnectQuietly(URLConnection connection) {
        if (connection instanceof HttpURLConnection) {
            ((HttpURLConnection) connection).disconnect();
        }
    }

    public static String getMetadataApplicationId(Context context) {
        Validate.notNull(context, "context");

        FacebookSdk.sdkInitialize(context);

        return FacebookSdk.getApplicationId();
    }

    static Map<String, Object> convertJSONObjectToHashMap(JSONObject jsonObject) {
        HashMap<String, Object> map = new HashMap<String, Object>();
        JSONArray keys = jsonObject.names();
        for (int i = 0; i < keys.length(); ++i) {
            String key;
            try {
                key = keys.getString(i);
                Object value = jsonObject.get(key);
                if (value instanceof JSONObject) {
                    value = convertJSONObjectToHashMap((JSONObject) value);
                }
                map.put(key, value);
            } catch (JSONException e) {
            }
        }
        return map;
    }

    
    
    public static Object getStringPropertyAsJSON(
            JSONObject jsonObject,
            String key,
            String nonJSONPropertyKey
    ) throws JSONException {
        Object value = jsonObject.opt(key);
        if (value != null && value instanceof String) {
            JSONTokener tokener = new JSONTokener((String) value);
            value = tokener.nextValue();
        }

        if (value != null && !(value instanceof JSONObject || value instanceof JSONArray)) {
            if (nonJSONPropertyKey != null) {
                
                
                
                
                jsonObject = new JSONObject();
                jsonObject.putOpt(nonJSONPropertyKey, value);
                return jsonObject;
            } else {
                throw new FacebookException("Got an unexpected non-JSON object.");
            }
        }

        return value;

    }

    public static String readStreamToString(InputStream inputStream) throws IOException {
        BufferedInputStream bufferedInputStream = null;
        InputStreamReader reader = null;
        try {
            bufferedInputStream = new BufferedInputStream(inputStream);
            reader = new InputStreamReader(bufferedInputStream);
            StringBuilder stringBuilder = new StringBuilder();

            final int bufferSize = 1024 * 2;
            char[] buffer = new char[bufferSize];
            int n = 0;
            while ((n = reader.read(buffer)) != -1) {
                stringBuilder.append(buffer, 0, n);
            }

            return stringBuilder.toString();
        } finally {
            closeQuietly(bufferedInputStream);
            closeQuietly(reader);
        }
    }

    public static int copyAndCloseInputStream(InputStream inputStream, OutputStream outputStream)
            throws IOException {
        BufferedInputStream bufferedInputStream = null;
        int totalBytes = 0;
        try {
            bufferedInputStream = new BufferedInputStream(inputStream);

            byte[] buffer = new byte[8192];
            int bytesRead;
            while ((bytesRead = bufferedInputStream.read(buffer)) != -1) {
                outputStream.write(buffer, 0, bytesRead);
                totalBytes += bytesRead;
            }
        } finally {
            if (bufferedInputStream != null) {
                bufferedInputStream.close();
            }
            if (inputStream != null) {
                inputStream.close();
            }
        }

        return totalBytes;
    }

    public static boolean stringsEqualOrEmpty(String a, String b) {
        boolean aEmpty = TextUtils.isEmpty(a);
        boolean bEmpty = TextUtils.isEmpty(b);

        if (aEmpty && bEmpty) {
            
            return true;
        }
        if (!aEmpty && !bEmpty) {
            
            return a.equals(b);
        }
        
        return false;
    }

    private static void clearCookiesForDomain(Context context, String domain) {
        
        
        CookieSyncManager syncManager = CookieSyncManager.createInstance(context);
        syncManager.sync();

        CookieManager cookieManager = CookieManager.getInstance();

        String cookies = cookieManager.getCookie(domain);
        if (cookies == null) {
            return;
        }

        String[] splitCookies = cookies.split(";");
        for (String cookie : splitCookies) {
            String[] cookieParts = cookie.split("=");
            if (cookieParts.length > 0) {
                String newCookie = cookieParts[0].trim() +
                        "=;expires=Sat, 1 Jan 2000 00:00:01 UTC;";
                cookieManager.setCookie(domain, newCookie);
            }
        }
        cookieManager.removeExpiredCookie();
    }

    public static void clearFacebookCookies(Context context) {
        
        
        
        clearCookiesForDomain(context, "facebook.com");
        clearCookiesForDomain(context, ".facebook.com");
        clearCookiesForDomain(context, "https:
        clearCookiesForDomain(context, "https:
    }

    public static void logd(String tag, Exception e) {
        if (FacebookSdk.isDebugEnabled() && tag != null && e != null) {
            Log.d(tag, e.getClass().getSimpleName() + ": " + e.getMessage());
        }
    }

    public static void logd(String tag, String msg) {
        if (FacebookSdk.isDebugEnabled() && tag != null && msg != null) {
            Log.d(tag, msg);
        }
    }

    public static void logd(String tag, String msg, Throwable t) {
        if (FacebookSdk.isDebugEnabled() && !isNullOrEmpty(tag)) {
            Log.d(tag, msg, t);
        }
    }

    public static <T> boolean areObjectsEqual(T a, T b) {
        if (a == null) {
            return b == null;
        }
        return a.equals(b);
    }

    public static boolean hasSameId(JSONObject a, JSONObject b) {
        if (a == null || b == null || !a.has("id") || !b.has("id")) {
            return false;
        }
        if (a.equals(b)) {
            return true;
        }
        String idA = a.optString("id");
        String idB = b.optString("id");
        if (idA == null || idB == null) {
            return false;
        }
        return idA.equals(idB);
    }

    public static void loadAppSettingsAsync(
            final Context context,
            final String applicationId
    ) {
        boolean canStartLoading = loadingSettings.compareAndSet(false, true);
        if (Utility.isNullOrEmpty(applicationId) ||
                fetchedAppSettings.containsKey(applicationId) ||
                !canStartLoading) {
            return;
        }

        final String settingsKey = String.format(APP_SETTINGS_PREFS_KEY_FORMAT, applicationId);

        FacebookSdk.getExecutor().execute(new Runnable() {
            @Override
            public void run() {
                JSONObject resultJSON = getAppSettingsQueryResponse(applicationId);
                if (resultJSON != null) {
                    parseAppSettingsFromJSON(applicationId, resultJSON);

                    SharedPreferences sharedPrefs = context.getSharedPreferences(
                            APP_SETTINGS_PREFS_STORE,
                            Context.MODE_PRIVATE);
                    sharedPrefs.edit()
                            .putString(settingsKey, resultJSON.toString())
                            .apply();
                }

                loadingSettings.set(false);
            }
        });

        
        SharedPreferences sharedPrefs = context.getSharedPreferences(
                APP_SETTINGS_PREFS_STORE,
                Context.MODE_PRIVATE);
        String settingsJSONString = sharedPrefs.getString(settingsKey, null);
        if (!isNullOrEmpty(settingsJSONString)) {
            JSONObject settingsJSON = null;
            try {
                settingsJSON = new JSONObject(settingsJSONString);
            } catch (JSONException je) {
                logd(LOG_TAG, je);
            }
            if (settingsJSON != null) {
                parseAppSettingsFromJSON(applicationId, settingsJSON);
            }
        }
    }

    
    public static FetchedAppSettings getAppSettingsWithoutQuery(final String applicationId) {
        return applicationId != null ? fetchedAppSettings.get(applicationId) : null;
    }

    
    
    public static FetchedAppSettings queryAppSettings(
            final String applicationId,
            final boolean forceRequery) {
        
        if (!forceRequery && fetchedAppSettings.containsKey(applicationId)) {
            return fetchedAppSettings.get(applicationId);
        }

        JSONObject response = getAppSettingsQueryResponse(applicationId);
        if (response == null) {
            return null;
        }

        return parseAppSettingsFromJSON(applicationId, response);
    }

    private static FetchedAppSettings parseAppSettingsFromJSON(
            String applicationId,
            JSONObject settingsJSON) {
        JSONArray errorClassificationJSON =
                settingsJSON.optJSONArray(APP_SETTING_ANDROID_SDK_ERROR_CATEGORIES);
        FacebookRequestErrorClassification errorClassification =
                errorClassificationJSON == null
                        ? FacebookRequestErrorClassification.getDefaultErrorClassification()
                        : FacebookRequestErrorClassification.createFromJSON(
                        errorClassificationJSON
                );
        FetchedAppSettings result = new FetchedAppSettings(
                settingsJSON.optBoolean(APP_SETTING_SUPPORTS_IMPLICIT_SDK_LOGGING, false),
                settingsJSON.optString(APP_SETTING_NUX_CONTENT, ""),
                settingsJSON.optBoolean(APP_SETTING_NUX_ENABLED, false),
                parseDialogConfigurations(settingsJSON.optJSONObject(APP_SETTING_DIALOG_CONFIGS)),
                errorClassification
        );

        fetchedAppSettings.put(applicationId, result);

        return result;
    }

    
    
    private static JSONObject getAppSettingsQueryResponse(String applicationId) {
        Bundle appSettingsParams = new Bundle();
        appSettingsParams.putString(APPLICATION_FIELDS, TextUtils.join(",", APP_SETTING_FIELDS));

        GraphRequest request = GraphRequest.newGraphPathRequest(null, applicationId, null);
        request.setSkipClientToken(true);
        request.setParameters(appSettingsParams);

        return request.executeAndWait().getJSONObject();
    }

    public static DialogFeatureConfig getDialogFeatureConfig(
            String applicationId,
            String actionName,
            String featureName) {
        if (Utility.isNullOrEmpty(actionName) || Utility.isNullOrEmpty(featureName)) {
            return null;
        }

        FetchedAppSettings settings = fetchedAppSettings.get(applicationId);
        if (settings != null) {
            Map<String, DialogFeatureConfig> featureMap =
                    settings.getDialogConfigurations().get(actionName);
            if (featureMap != null) {
                return featureMap.get(featureName);
            }
        }
        return null;
    }

    private static Map<String, Map<String, DialogFeatureConfig>> parseDialogConfigurations(
            JSONObject dialogConfigResponse) {
        HashMap<String, Map<String, DialogFeatureConfig>> dialogConfigMap = new HashMap<String, Map<String, DialogFeatureConfig>>();

        if (dialogConfigResponse != null) {
            JSONArray dialogConfigData = dialogConfigResponse.optJSONArray("data");
            if (dialogConfigData != null) {
                for (int i = 0; i < dialogConfigData.length(); i++) {
                    DialogFeatureConfig dialogConfig = DialogFeatureConfig.parseDialogConfig(
                            dialogConfigData.optJSONObject(i));
                    if (dialogConfig == null) {
                        continue;
                    }

                    String dialogName = dialogConfig.getDialogName();
                    Map<String, DialogFeatureConfig> featureMap = dialogConfigMap.get(dialogName);
                    if (featureMap == null) {
                        featureMap = new HashMap<String, DialogFeatureConfig>();
                        dialogConfigMap.put(dialogName, featureMap);
                    }
                    featureMap.put(dialogConfig.getFeatureName(), dialogConfig);
                }
            }
        }

        return dialogConfigMap;
    }

    public static String safeGetStringFromResponse(JSONObject response, String propertyName) {
        return response != null ? response.optString(propertyName, "") : "";
    }

    public static JSONObject tryGetJSONObjectFromResponse(JSONObject response, String propertyKey) {
        return response != null ? response.optJSONObject(propertyKey) : null;
    }

    public static JSONArray tryGetJSONArrayFromResponse(JSONObject response, String propertyKey) {
        return response != null ? response.optJSONArray(propertyKey) : null;
    }

    public static void clearCaches(Context context) {
        ImageDownloader.clearCache(context);
    }

    public static void deleteDirectory(File directoryOrFile) {
        if (!directoryOrFile.exists()) {
            return;
        }

        if (directoryOrFile.isDirectory()) {
            for (File child : directoryOrFile.listFiles()) {
                deleteDirectory(child);
            }
        }
        directoryOrFile.delete();
    }

    public static <T> List<T> asListNoNulls(T... array) {
        ArrayList<T> result = new ArrayList<T>();
        for (T t : array) {
            if (t != null) {
                result.add(t);
            }
        }
        return result;
    }

    public static List<String> jsonArrayToStringList(JSONArray jsonArray) throws JSONException {
        ArrayList<String> result = new ArrayList<>();

        for (int i = 0; i < jsonArray.length(); i++) {
            result.add(jsonArray.getString(i));
        }

        return result;
    }

    public static Set<String> jsonArrayToSet(JSONArray jsonArray) throws JSONException {
        Set<String> result = new HashSet<>();
        for (int i = 0; i < jsonArray.length(); i++) {
            result.add(jsonArray.getString(i));
        }

        return result;
    }

    public static void setAppEventAttributionParameters(
            JSONObject params,
            AttributionIdentifiers attributionIdentifiers,
            String anonymousAppDeviceGUID,
            boolean limitEventUsage) throws JSONException {
        if (attributionIdentifiers != null && attributionIdentifiers.getAttributionId() != null) {
            params.put("attribution", attributionIdentifiers.getAttributionId());
        }

        if (attributionIdentifiers != null &&
                attributionIdentifiers.getAndroidAdvertiserId() != null) {
            params.put("advertiser_id", attributionIdentifiers.getAndroidAdvertiserId());
            params.put("advertiser_tracking_enabled", !attributionIdentifiers.isTrackingLimited());
        }

        params.put("anon_id", anonymousAppDeviceGUID);
        params.put("application_tracking_enabled", !limitEventUsage);
    }

    public static void setAppEventExtendedDeviceInfoParameters(
            JSONObject params,
            Context appContext
    ) throws JSONException {
        JSONArray extraInfoArray = new JSONArray();
        extraInfoArray.put(EXTRA_APP_EVENTS_INFO_FORMAT_VERSION);

        Utility.refreshPeriodicExtendedDeviceInfo(appContext);

        
        String pkgName = appContext.getPackageName();
        int versionCode = -1;
        String versionName = "";

        try {
            PackageInfo pi = appContext.getPackageManager().getPackageInfo(pkgName, 0);
            versionCode = pi.versionCode;
            versionName = pi.versionName;
        } catch (PackageManager.NameNotFoundException e) {
            
        }

        
        extraInfoArray.put(pkgName);
        extraInfoArray.put(versionCode);
        extraInfoArray.put(versionName);

        
        extraInfoArray.put(Build.VERSION.RELEASE);
        extraInfoArray.put(Build.MODEL);

        
        Locale locale = null;
        try {
            locale = appContext.getResources().getConfiguration().locale;
        } catch (Exception e) {
            locale = Locale.getDefault();
        }
        extraInfoArray.put(locale.getLanguage() + "_" + locale.getCountry());

        
        extraInfoArray.put(deviceTimezone);

        
        extraInfoArray.put(carrierName);

        
        int width = 0;
        int height = 0;
        double density = 0;
        try {
            WindowManager wm = (WindowManager) appContext.getSystemService(Context.WINDOW_SERVICE);
            if (wm != null) {
                Display display = wm.getDefaultDisplay();
                DisplayMetrics displayMetrics = new DisplayMetrics();
                display.getMetrics(displayMetrics);
                width = displayMetrics.widthPixels;
                height = displayMetrics.heightPixels;
                density = displayMetrics.density;
            }
        } catch (Exception e) {
            
        }
        extraInfoArray.put(width);
        extraInfoArray.put(height);
        extraInfoArray.put(String.format("%.2f", density));

        
        extraInfoArray.put(refreshBestGuessNumberOfCPUCores());

        
        extraInfoArray.put(totalExternalStorageGB);
        extraInfoArray.put(availableExternalStorageGB);

        params.put("extinfo", extraInfoArray.toString());
    }

    public static Method getMethodQuietly(
            Class<?> clazz,
            String methodName,
            Class<?>... parameterTypes) {
        try {
            return clazz.getMethod(methodName, parameterTypes);
        } catch (NoSuchMethodException ex) {
            return null;
        }
    }

    public static Method getMethodQuietly(
            String className,
            String methodName,
            Class<?>... parameterTypes) {
        try {
            Class<?> clazz = Class.forName(className);
            return getMethodQuietly(clazz, methodName, parameterTypes);
        } catch (ClassNotFoundException ex) {
            return null;
        }
    }

    public static Object invokeMethodQuietly(Object receiver, Method method, Object... args) {
        try {
            return method.invoke(receiver, args);
        } catch (IllegalAccessException ex) {
            return null;
        } catch (InvocationTargetException ex) {
            return null;
        }
    }

    
    public static String getActivityName(Context context) {
        if (context == null) {
            return "null";
        } else if (context == context.getApplicationContext()) {
            return "unknown";
        } else {
            return context.getClass().getSimpleName();
        }
    }

    public interface Predicate<T> {
        public boolean apply(T item);
    }

    public static <T> List<T> filter(final List<T> target, final Predicate<T> predicate) {
        if (target == null) {
            return null;
        }
        final List<T> list = new ArrayList<T>();
        for (T item : target) {
            if (predicate.apply(item)) {
                list.add(item);
            }
        }
        return (list.size() == 0 ? null : list);
    }

    public interface Mapper<T, K> {
        public K apply(T item);
    }

    public static <T, K> List<K> map(final List<T> target, final Mapper<T, K> mapper) {
        if (target == null) {
            return null;
        }
        final List<K> list = new ArrayList<K>();
        for (T item : target) {
            final K mappedItem = mapper.apply(item);
            if (mappedItem != null) {
                list.add(mappedItem);
            }
        }
        return (list.size() == 0 ? null : list);
    }

    public static String getUriString(final Uri uri) {
        return (uri == null ? null : uri.toString());
    }

    public static boolean isWebUri(final Uri uri) {
        return (uri != null)
                && ("http".equalsIgnoreCase(uri.getScheme())
                || "https".equalsIgnoreCase(uri.getScheme()));
    }

    public static boolean isContentUri(final Uri uri) {
        return (uri != null) && ("content".equalsIgnoreCase(uri.getScheme()));
    }

    public static boolean isFileUri(final Uri uri) {
        return (uri != null) && ("file".equalsIgnoreCase(uri.getScheme()));
    }

    public static long getContentSize(final Uri contentUri) {
        Cursor cursor = null;
        try {
            cursor = FacebookSdk
                    .getApplicationContext()
                    .getContentResolver()
                    .query(contentUri, null, null, null, null);
            int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);

            cursor.moveToFirst();
            return cursor.getLong(sizeIndex);
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
    }

    public static Date getBundleLongAsDate(Bundle bundle, String key, Date dateBase) {
        if (bundle == null) {
            return null;
        }

        long secondsFromBase = Long.MIN_VALUE;

        Object secondsObject = bundle.get(key);
        if (secondsObject instanceof Long) {
            secondsFromBase = (Long) secondsObject;
        } else if (secondsObject instanceof String) {
            try {
                secondsFromBase = Long.parseLong((String) secondsObject);
            } catch (NumberFormatException e) {
                return null;
            }
        } else {
            return null;
        }

        if (secondsFromBase == 0) {
            return new Date(Long.MAX_VALUE);
        } else {
            return new Date(dateBase.getTime() + (secondsFromBase * 1000L));
        }
    }

    public static void writeStringMapToParcel(Parcel parcel, final Map<String, String> map) {
        if (map == null) {
            
            parcel.writeInt(-1);
        } else {
            parcel.writeInt(map.size());
            for (Map.Entry<String, String> entry : map.entrySet()) {
                parcel.writeString(entry.getKey());
                parcel.writeString(entry.getValue());
            }
        }
    }

    public static Map<String, String> readStringMapFromParcel(Parcel parcel) {
        int size = parcel.readInt();
        if (size < 0) {
            return null;
        }
        Map<String, String> map = new HashMap<>();
        for (int i = 0; i < size; i++) {
            map.put(parcel.readString(), parcel.readString());
        }
        return map;
    }

    public static boolean isCurrentAccessToken(AccessToken token) {
        return token != null ? token.equals(AccessToken.getCurrentAccessToken()) : false;
    }

    public interface GraphMeRequestWithCacheCallback {
        void onSuccess(JSONObject userInfo);

        void onFailure(FacebookException error);
    }

    public static void getGraphMeRequestWithCacheAsync(
            final String accessToken,
            final GraphMeRequestWithCacheCallback callback) {
        JSONObject cachedValue = ProfileInformationCache.getProfileInformation(accessToken);
        if (cachedValue != null) {
            callback.onSuccess(cachedValue);
            return;
        }

        GraphRequest.Callback graphCallback = new GraphRequest.Callback() {
            @Override
            public void onCompleted(GraphResponse response) {
                if (response.getError() != null) {
                    callback.onFailure(response.getError().getException());
                } else {
                    ProfileInformationCache.putProfileInformation(
                            accessToken,
                            response.getJSONObject());
                    callback.onSuccess(response.getJSONObject());
                }
            }
        };
        GraphRequest graphRequest = getGraphMeRequestWithCache(accessToken);
        graphRequest.setCallback(graphCallback);
        graphRequest.executeAsync();
    }

    public static JSONObject awaitGetGraphMeRequestWithCache(
            final String accessToken) {
        JSONObject cachedValue = ProfileInformationCache.getProfileInformation(accessToken);
        if (cachedValue != null) {
            return cachedValue;
        }

        GraphRequest graphRequest = getGraphMeRequestWithCache(accessToken);
        GraphResponse response = graphRequest.executeAndWait();
        if (response.getError() != null) {
            return null;
        }

        return response.getJSONObject();
    }

    private static GraphRequest getGraphMeRequestWithCache(
            final String accessToken) {
        Bundle parameters = new Bundle();
        parameters.putString("fields", "id,name,first_name,middle_name,last_name,link");
        parameters.putString("access_token", accessToken);
        GraphRequest graphRequest = new GraphRequest(
                null,
                "me",
                parameters,
                HttpMethod.GET,
                null);
        return graphRequest;
    }

    
    private static int refreshBestGuessNumberOfCPUCores() {
        
        if (numCPUCores > 0) {
            return numCPUCores;
        }

        
        
        if (Build.VERSION.SDK_INT <= Utility.GINGERBREAD_MR1) {
            numCPUCores = 1;
            return numCPUCores;
        }

        
        try {
            int res = 0;
            File cpuDir = new File("/sys/devices/system/cpu/");
            File[] cpuFiles = cpuDir.listFiles(new FilenameFilter() {
                @Override
                public boolean accept(File dir, String fileName) {
                    return Pattern.matches("cpu[0-9]+", fileName);
                }
            });

            numCPUCores = cpuFiles.length;
        } catch (Exception e) {
        }

        
        
        if (numCPUCores <= 0) {
            numCPUCores = Math.max(Runtime.getRuntime().availableProcessors(), 1);
        }
        return numCPUCores;
    }

    private static void refreshPeriodicExtendedDeviceInfo(Context appContext) {
        if (timestampOfLastCheck == -1 ||
                (System.currentTimeMillis() - timestampOfLastCheck) >=
                        Utility.REFRESH_TIME_FOR_EXTENDED_DEVICE_INFO_MILLIS) {
            timestampOfLastCheck = System.currentTimeMillis();
            Utility.refreshTimezone();
            Utility.refreshCarrierName(appContext);
            Utility.refreshTotalExternalStorage();
            Utility.refreshAvailableExternalStorage();
        }
    }

    private static void refreshTimezone() {
        try {
            TimeZone tz = TimeZone.getDefault();
            deviceTimezone = tz.getDisplayName(tz.inDaylightTime(new Date()), TimeZone.SHORT);
        } catch (Exception e) {
        }
    }

    
    private static void refreshCarrierName(Context appContext) {
        if (carrierName.equals(noCarrierConstant)) {
            try {
                TelephonyManager telephonyManager =
                        ((TelephonyManager) appContext.getSystemService(Context.TELEPHONY_SERVICE));
                carrierName = telephonyManager.getNetworkOperatorName();
            } catch (Exception e) {
            }
        }
    }

    
    private static boolean externalStorageExists() {
        return Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState());
    }

    
    @SuppressWarnings("deprecation")
    private static void refreshAvailableExternalStorage() {
        try {
            if (externalStorageExists()) {
                File path = Environment.getExternalStorageDirectory();
                StatFs stat = new StatFs(path.getPath());
                availableExternalStorageGB =
                        (long)stat.getAvailableBlocks() * (long)stat.getBlockSize();
            }
            availableExternalStorageGB =
                    Utility.convertBytesToGB(availableExternalStorageGB);
        } catch (Exception e) {
            
        }
    }

    
    @SuppressWarnings("deprecation")
    private static void refreshTotalExternalStorage() {
        try {
            if (externalStorageExists()) {
                File path = Environment.getExternalStorageDirectory();
                StatFs stat = new StatFs(path.getPath());
                totalExternalStorageGB = (long)stat.getBlockCount() * (long)stat.getBlockSize();
            }
            totalExternalStorageGB = Utility.convertBytesToGB(totalExternalStorageGB);
        } catch (Exception e) {
            
        }
    }

    private static long convertBytesToGB(double bytes) {
        return Math.round(bytes / (1024.0 * 1024.0 * 1024.0));
    }
}

<code block>


package com.facebook.internal;

import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.database.Cursor;
import android.net.Uri;
import android.os.Binder;
import android.os.IBinder;
import android.os.IInterface;
import android.os.Looper;
import android.os.Parcel;
import android.os.RemoteException;
import android.util.Log;

import com.facebook.FacebookException;

import java.lang.reflect.Method;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.atomic.AtomicBoolean;


public class AttributionIdentifiers {
    private static final String TAG = AttributionIdentifiers.class.getCanonicalName();
    private static final String ATTRIBUTION_ID_CONTENT_PROVIDER =
            "com.facebook.katana.provider.AttributionIdProvider";
    private static final String ATTRIBUTION_ID_CONTENT_PROVIDER_WAKIZASHI =
            "com.facebook.wakizashi.provider.AttributionIdProvider";
    private static final String ATTRIBUTION_ID_COLUMN_NAME = "aid";
    private static final String ANDROID_ID_COLUMN_NAME = "androidid";
    private static final String LIMIT_TRACKING_COLUMN_NAME = "limit_tracking";

    
    private static final int CONNECTION_RESULT_SUCCESS = 0;

    private static final long IDENTIFIER_REFRESH_INTERVAL_MILLIS = 3600 * 1000;

    private String attributionId;
    private String androidAdvertiserId;
    private boolean limitTracking;
    private long fetchTime;

    private static AttributionIdentifiers recentlyFetchedIdentifiers;

    private static AttributionIdentifiers getAndroidId(Context context) {
        AttributionIdentifiers identifiers = getAndroidIdViaReflection(context);
        if (identifiers == null) {
            identifiers = getAndroidIdViaService(context);
            if (identifiers == null) {
                identifiers = new AttributionIdentifiers();
            }
        }
        return identifiers;
    }

    private static AttributionIdentifiers getAndroidIdViaReflection(Context context) {
        try {
            
            
            if (Looper.myLooper() == Looper.getMainLooper()) {
              throw new FacebookException("getAndroidId cannot be called on the main thread.");
            }
            Method isGooglePlayServicesAvailable = Utility.getMethodQuietly(
                    "com.google.android.gms.common.GooglePlayServicesUtil",
                    "isGooglePlayServicesAvailable",
                    Context.class
            );

            if (isGooglePlayServicesAvailable == null) {
                return null;
            }

            Object connectionResult = Utility.invokeMethodQuietly(
                    null, isGooglePlayServicesAvailable, context);
            if (!(connectionResult instanceof Integer)
                    || (Integer) connectionResult != CONNECTION_RESULT_SUCCESS) {
                return null;
            }

            Method getAdvertisingIdInfo = Utility.getMethodQuietly(
                    "com.google.android.gms.ads.identifier.AdvertisingIdClient",
                    "getAdvertisingIdInfo",
                    Context.class
            );
            if (getAdvertisingIdInfo == null) {
                return null;
            }
            Object advertisingInfo = Utility.invokeMethodQuietly(
                    null, getAdvertisingIdInfo, context);
            if (advertisingInfo == null) {
                return null;
            }

            Method getId = Utility.getMethodQuietly(advertisingInfo.getClass(), "getId");
            Method isLimitAdTrackingEnabled = Utility.getMethodQuietly(
                    advertisingInfo.getClass(),
                    "isLimitAdTrackingEnabled");
            if (getId == null || isLimitAdTrackingEnabled == null) {
                return null;
            }

            AttributionIdentifiers identifiers = new AttributionIdentifiers();
            identifiers.androidAdvertiserId =
                    (String) Utility.invokeMethodQuietly(advertisingInfo, getId);
            identifiers.limitTracking = (Boolean) Utility.invokeMethodQuietly(
                    advertisingInfo,
                    isLimitAdTrackingEnabled);
        } catch (Exception e) {
            Utility.logd("android_id", e);
        }
        return null;
    }

    private static AttributionIdentifiers getAndroidIdViaService(Context context) {
        GoogleAdServiceConnection connection = new GoogleAdServiceConnection();
        Intent intent = new Intent("com.google.android.gms.ads.identifier.service.START");
        intent.setPackage("com.google.android.gms");
        if(context.bindService(intent, connection, Context.BIND_AUTO_CREATE)) {
            try {
                GoogleAdInfo adInfo = new GoogleAdInfo(connection.getBinder());
                AttributionIdentifiers identifiers = new AttributionIdentifiers();
                identifiers.androidAdvertiserId = adInfo.getAdvertiserId();
                identifiers.limitTracking = adInfo.isTrackingLimited();
                return identifiers;
            } catch (Exception exception) {
                Utility.logd("android_id", exception);
            } finally {
                context.unbindService(connection);
            }
        }
        return null;
    }

    public static AttributionIdentifiers getAttributionIdentifiers(Context context) {
        if (recentlyFetchedIdentifiers != null &&
            System.currentTimeMillis() - recentlyFetchedIdentifiers.fetchTime <
                    IDENTIFIER_REFRESH_INTERVAL_MILLIS) {
            return recentlyFetchedIdentifiers;
        }

        AttributionIdentifiers identifiers = getAndroidId(context);
        Cursor c = null;
        try {
            String [] projection = {
                    ATTRIBUTION_ID_COLUMN_NAME,
                    ANDROID_ID_COLUMN_NAME,
                    LIMIT_TRACKING_COLUMN_NAME};
            Uri providerUri = null;
            if (context.getPackageManager().resolveContentProvider(
                    ATTRIBUTION_ID_CONTENT_PROVIDER, 0) != null) {
                providerUri = Uri.parse("content:
            } else if (context.getPackageManager().resolveContentProvider(
                    ATTRIBUTION_ID_CONTENT_PROVIDER_WAKIZASHI, 0) != null) {
                providerUri = Uri.parse("content:
            }
            if (providerUri == null) {
                return identifiers;
            }
            c = context.getContentResolver().query(providerUri, projection, null, null, null);
            if (c == null || !c.moveToFirst()) {
                return identifiers;
            }
            int attributionColumnIndex = c.getColumnIndex(ATTRIBUTION_ID_COLUMN_NAME);
            int androidIdColumnIndex = c.getColumnIndex(ANDROID_ID_COLUMN_NAME);
            int limitTrackingColumnIndex = c.getColumnIndex(LIMIT_TRACKING_COLUMN_NAME);

            identifiers.attributionId = c.getString(attributionColumnIndex);

            
            
            if (androidIdColumnIndex > 0 && limitTrackingColumnIndex > 0 &&
                    identifiers.getAndroidAdvertiserId() == null) {
                identifiers.androidAdvertiserId = c.getString(androidIdColumnIndex);
                identifiers.limitTracking =
                        Boolean.parseBoolean(c.getString(limitTrackingColumnIndex));
            }
        } catch (Exception e) {
            Log.d(TAG, "Caught unexpected exception in getAttributionId(): " + e.toString());
            return null;
        } finally {
            if (c != null) {
                c.close();
            }
        }

        identifiers.fetchTime = System.currentTimeMillis();
        recentlyFetchedIdentifiers = identifiers;
        return identifiers;
    }

    public String getAttributionId() {
        return attributionId;
    }

    public String getAndroidAdvertiserId() {
        return androidAdvertiserId;
    }

    public boolean isTrackingLimited() {
        return limitTracking;
    }

    private static final class GoogleAdServiceConnection implements ServiceConnection {
        private AtomicBoolean consumed = new AtomicBoolean(false);
        private final BlockingQueue<IBinder> queue = new LinkedBlockingDeque<>();

        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            try {
                queue.put(service);
            } catch (InterruptedException e) {
            }
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
        }

        public IBinder getBinder() throws InterruptedException {
            if (consumed.compareAndSet(true, true)) {
                throw new IllegalStateException("Binder already consumed");
            }
            return queue.take();
        }
    }

    private static final class GoogleAdInfo implements IInterface {
        private static final int FIRST_TRANSACTION_CODE = Binder.FIRST_CALL_TRANSACTION;
        private static final int SECOND_TRANSACTION_CODE = FIRST_TRANSACTION_CODE + 1;

        private IBinder binder;

        GoogleAdInfo(IBinder binder) {
            this.binder = binder;
        }

        @Override
        public IBinder asBinder() {
            return binder;
        }

        public String getAdvertiserId() throws RemoteException {
            Parcel data = Parcel.obtain();
            Parcel reply = Parcel.obtain();
            String id;
            try {
                data.writeInterfaceToken(
                        "com.google.android.gms.ads.identifier.internal.IAdvertisingIdService");
                binder.transact(FIRST_TRANSACTION_CODE, data, reply, 0);
                reply.readException();
                id = reply.readString();
            } finally {
                reply.recycle();
                data.recycle();
            }
            return id;
        }

        public boolean isTrackingLimited() throws RemoteException {
            Parcel data = Parcel.obtain();
            Parcel reply = Parcel.obtain();
            boolean limitAdTracking;
            try {
                data.writeInterfaceToken(
                        "com.google.android.gms.ads.identifier.internal.IAdvertisingIdService");
                data.writeInt(1);
                binder.transact(SECOND_TRANSACTION_CODE, data, reply, 0);
                reply.readException();
                limitAdTracking = 0 != reply.readInt();
            } finally {
                reply.recycle();
                data.recycle();
            }
            return limitAdTracking;
        }
    }
}

<code block>


package com.facebook.internal;

import android.content.Context;
import android.os.Bundle;
import android.util.Log;

import com.facebook.FacebookSdk;
import com.facebook.LoggingBehavior;

import org.json.JSONException;
import org.json.JSONObject;

import java.util.Collection;


public final class ServerProtocol {
    private static final String TAG = ServerProtocol.class.getName();

    private static final String DIALOG_AUTHORITY_FORMAT = "m.%s";
    public static final String DIALOG_PATH = "dialog/";
    public static final String DIALOG_PARAM_ACCESS_TOKEN = "access_token";
    public static final String DIALOG_PARAM_APP_ID = "app_id";
    public static final String DIALOG_PARAM_AUTH_TYPE = "auth_type";
    public static final String DIALOG_PARAM_CLIENT_ID = "client_id";
    public static final String DIALOG_PARAM_DISPLAY = "display";
    public static final String DIALOG_PARAM_DISPLAY_TOUCH = "touch";
    public static final String DIALOG_PARAM_E2E = "e2e";
    public static final String DIALOG_PARAM_LEGACY_OVERRIDE = "legacy_override";
    public static final String DIALOG_PARAM_REDIRECT_URI = "redirect_uri";
    public static final String DIALOG_PARAM_RESPONSE_TYPE = "response_type";
    public static final String DIALOG_PARAM_RETURN_SCOPES = "return_scopes";
    public static final String DIALOG_PARAM_SCOPE = "scope";
    public static final String DIALOG_PARAM_DEFAULT_AUDIENCE = "default_audience";
    public static final String DIALOG_REREQUEST_AUTH_TYPE = "rerequest";
    public static final String DIALOG_RESPONSE_TYPE_TOKEN_AND_SIGNED_REQUEST
            = "token,signed_request";
    public static final String DIALOG_RETURN_SCOPES_TRUE = "true";
    public static final String DIALOG_REDIRECT_URI = "fbconnect:
    public static final String DIALOG_CANCEL_URI = "fbconnect:

    public static final String FALLBACK_DIALOG_PARAM_APP_ID = "app_id";
    public static final String FALLBACK_DIALOG_PARAM_BRIDGE_ARGS = "bridge_args";
    public static final String FALLBACK_DIALOG_PARAM_KEY_HASH = "android_key_hash";
    public static final String FALLBACK_DIALOG_PARAM_METHOD_ARGS = "method_args";
    public static final String FALLBACK_DIALOG_PARAM_METHOD_RESULTS = "method_results";
    public static final String FALLBACK_DIALOG_PARAM_VERSION = "version";
    public static final String FALLBACK_DIALOG_DISPLAY_VALUE_TOUCH = "touch";

    
    private static final String GRAPH_VIDEO_URL_FORMAT = "https:
    private static final String GRAPH_URL_FORMAT = "https:
    public static final String GRAPH_API_VERSION = "v2.3";

    public static final Collection<String> errorsProxyAuthDisabled =
            Utility.unmodifiableCollection("service_disabled", "AndroidAuthKillSwitchException");
    public static final Collection<String> errorsUserCanceled =
            Utility.unmodifiableCollection("access_denied", "OAuthAccessDeniedException");

    public static final String getDialogAuthority() {
        return String.format(DIALOG_AUTHORITY_FORMAT, FacebookSdk.getFacebookDomain());
    }

    public static final String getGraphUrlBase() {
        return String.format(GRAPH_URL_FORMAT, FacebookSdk.getFacebookDomain());
    }

    public static final String getGraphVideoUrlBase() {
        return String.format(GRAPH_VIDEO_URL_FORMAT, FacebookSdk.getFacebookDomain());
    }

    public static final String getAPIVersion() {
        return GRAPH_API_VERSION;
    }

    public static Bundle getQueryParamsForPlatformActivityIntentWebFallback(
            String callId,
            int version,
            Bundle methodArgs) {

        Context context = FacebookSdk.getApplicationContext();
        String keyHash = FacebookSdk.getApplicationSignature(context);
        if (Utility.isNullOrEmpty(keyHash)) {
            return null;
        }

        Bundle webParams = new Bundle();

        webParams.putString(FALLBACK_DIALOG_PARAM_KEY_HASH, keyHash);
        webParams.putString(FALLBACK_DIALOG_PARAM_APP_ID, FacebookSdk.getApplicationId());
        webParams.putInt(FALLBACK_DIALOG_PARAM_VERSION, version);
        webParams.putString(DIALOG_PARAM_DISPLAY, FALLBACK_DIALOG_DISPLAY_VALUE_TOUCH);

        Bundle bridgeArguments = new Bundle();
        bridgeArguments.putString(NativeProtocol.BRIDGE_ARG_ACTION_ID_STRING, callId);

        methodArgs = (methodArgs == null) ? new Bundle() : methodArgs;

        try {
            JSONObject bridgeArgsJSON = BundleJSONConverter.convertToJSON(bridgeArguments);
            JSONObject methodArgsJSON = BundleJSONConverter.convertToJSON(methodArgs);

            if (bridgeArgsJSON == null || methodArgsJSON == null) {
                return null;
            }

            webParams.putString(FALLBACK_DIALOG_PARAM_BRIDGE_ARGS, bridgeArgsJSON.toString());
            webParams.putString(FALLBACK_DIALOG_PARAM_METHOD_ARGS, methodArgsJSON.toString());
        } catch (JSONException je) {
            webParams = null;
            Logger.log(LoggingBehavior.DEVELOPER_ERRORS, Log.ERROR, TAG,
                    "Error creating Url -- " + je);
        }

        return webParams;
    }
}

<code block>


package com.facebook.share;

import android.graphics.Bitmap;
import android.net.Uri;
import android.os.Bundle;
import android.text.TextUtils;
import android.util.Log;

import com.facebook.AccessToken;
import com.facebook.FacebookCallback;
import com.facebook.FacebookException;
import com.facebook.FacebookGraphResponseException;
import com.facebook.FacebookRequestError;
import com.facebook.GraphRequest;
import com.facebook.GraphResponse;
import com.facebook.HttpMethod;
import com.facebook.internal.CollectionMapper;
import com.facebook.internal.Mutable;
import com.facebook.internal.Utility;
import com.facebook.share.internal.ShareContentValidation;
import com.facebook.share.internal.ShareInternalUtility;
import com.facebook.share.internal.VideoUploader;
import com.facebook.share.model.*;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.FileNotFoundException;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.*;


public final class ShareApi {
    private static final String TAG = "ShareApi";
    private static final String DEFAULT_GRAPH_NODE = "me";
    private static final String PHOTOS_EDGE = "photos";
    private static final String GRAPH_PATH_FORMAT = "%s/%s";
    private static final String DEFAULT_CHARSET = "UTF-8";

    private String message;
    private String graphNode;
    private final ShareContent shareContent;

    
    public static void share(
            final ShareContent shareContent,
            final FacebookCallback<Sharer.Result> callback) {
        new ShareApi(shareContent)
                .share(callback);
    }

    
    public ShareApi(final ShareContent shareContent) {
        this.shareContent = shareContent;
        this.graphNode = DEFAULT_GRAPH_NODE;
    }

    
    public String getMessage() {
        return this.message;
    }

    
    public void setMessage(final String message) {
        this.message = message;
    }

    
    public String getGraphNode() {
        return this.graphNode;
    }

    
    public void setGraphNode(final String graphNode) {
        this.graphNode = graphNode;
    }

    
    public ShareContent getShareContent() {
        return this.shareContent;
    }

    
    public boolean canShare() {
        if (this.getShareContent() == null) {
            return false;
        }
        final AccessToken accessToken = AccessToken.getCurrentAccessToken();
        if (accessToken == null) {
            return false;
        }
        final Set<String> permissions = accessToken.getPermissions();
        if (permissions == null || !permissions.contains("publish_actions")) {
            Log.w(TAG, "The publish_actions permissions are missing, the share will fail unless" +
                    " this app was authorized to publish in another installation.");
        }

        return true;
    }

    
    public void share(FacebookCallback<Sharer.Result> callback) {
        if (!this.canShare()) {
            ShareInternalUtility.invokeCallbackWithError(
                    callback, "Insufficient permissions for sharing content via Api.");
            return;
        }
        final ShareContent shareContent = this.getShareContent();

        
        try {
            ShareContentValidation.validateForApiShare(shareContent);
        } catch (FacebookException ex) {
            ShareInternalUtility.invokeCallbackWithException(callback, ex);
            return;
        }

        if (shareContent instanceof ShareLinkContent) {
            this.shareLinkContent((ShareLinkContent) shareContent, callback);
        } else if (shareContent instanceof SharePhotoContent) {
            this.sharePhotoContent((SharePhotoContent) shareContent, callback);
        } else if (shareContent instanceof ShareVideoContent) {
            this.shareVideoContent((ShareVideoContent) shareContent, callback);
        } else if (shareContent instanceof ShareOpenGraphContent) {
            this.shareOpenGraphContent((ShareOpenGraphContent) shareContent, callback);
        }
    }

    
    private String getGraphPath(final String pathAfterGraphNode) {
        try {
            return String.format(
                    Locale.ROOT, GRAPH_PATH_FORMAT,
                    URLEncoder.encode(getGraphNode(), DEFAULT_CHARSET),
                    pathAfterGraphNode);
        } catch (UnsupportedEncodingException e) {
            return null;
        }
    }

    private void addCommonParameters(final Bundle bundle, ShareContent shareContent) {
        final List<String> peopleIds = shareContent.getPeopleIds();
        if (!Utility.isNullOrEmpty(peopleIds)) {
            bundle.putString("tags", TextUtils.join(", ", peopleIds));
        }

        if (!Utility.isNullOrEmpty(shareContent.getPlaceId())) {
            bundle.putString("place", shareContent.getPlaceId());
        }

        if (!Utility.isNullOrEmpty(shareContent.getRef())) {
            bundle.putString("ref", shareContent.getRef());
        }
    }

    private void shareOpenGraphContent(final ShareOpenGraphContent openGraphContent,
                                       final FacebookCallback<Sharer.Result> callback) {
        
        
        
        
        
        final GraphRequest.Callback requestCallback = new GraphRequest.Callback() {
            @Override
            public void onCompleted(GraphResponse response) {
                final JSONObject data = response.getJSONObject();
                final String postId = (data == null ? null : data.optString("id"));
                ShareInternalUtility.invokeCallbackWithResults(callback, postId, response);
            }
        };
        final ShareOpenGraphAction action = openGraphContent.getAction();
        final Bundle parameters = action.getBundle();
        this.addCommonParameters(parameters, openGraphContent);
        if (!Utility.isNullOrEmpty(this.getMessage())) {
            parameters.putString("message", this.getMessage());
        }

        final CollectionMapper.OnMapperCompleteListener stageCallback = new CollectionMapper
                .OnMapperCompleteListener() {
            @Override
            public void onComplete() {
                try {
                    handleImagesOnAction(parameters);

                    new GraphRequest(
                            AccessToken.getCurrentAccessToken(),
                            getGraphPath(
                                    URLEncoder.encode(action.getActionType(), DEFAULT_CHARSET)),
                            parameters,
                            HttpMethod.POST,
                            requestCallback).executeAsync();
                } catch (final UnsupportedEncodingException ex) {
                    ShareInternalUtility.invokeCallbackWithException(callback, ex);
                }
            }

            @Override
            public void onError(FacebookException exception) {
                ShareInternalUtility.invokeCallbackWithException(callback, exception);
            }
        };
        this.stageOpenGraphAction(parameters, stageCallback);
    }

    private static void handleImagesOnAction(Bundle parameters) {
        
        
        
        String imageStr = parameters.getString("image");
        if (imageStr != null) {
            try {
                
                JSONArray images = new JSONArray(imageStr);
                for (int i = 0; i < images.length(); ++i) {
                    JSONObject jsonImage = images.optJSONObject(i);
                    if(jsonImage != null) {
                        putImageInBundleWithArrayFormat(parameters, i, jsonImage);
                    } else {
                        
                        String url = images.getString(i);
                        parameters.putString(String.format(Locale.ROOT, "image[%d][url]", i), url);
                    }
                }
                parameters.remove("image");
                return;
            } catch (JSONException ex) {
                
            }

            
            try {
                JSONObject image = new JSONObject(imageStr);
                putImageInBundleWithArrayFormat(parameters, 0, image);
                parameters.remove("image");
            } catch (JSONException exception) {
                
                
            }
        }
    }

    private static void putImageInBundleWithArrayFormat(
            Bundle parameters,
            int index,
            JSONObject image) throws JSONException{
        Iterator<String> keys = image.keys();
        while (keys.hasNext()) {
            String property = keys.next();
            String key = String.format(Locale.ROOT, "image[%d][%s]", index, property);
            parameters.putString(key, image.get(property).toString());
        }
    }

    private void sharePhotoContent(final SharePhotoContent photoContent,
                                   final FacebookCallback<Sharer.Result> callback) {
        final Mutable<Integer> requestCount = new Mutable<Integer>(0);
        final AccessToken accessToken = AccessToken.getCurrentAccessToken();
        final ArrayList<GraphRequest> requests = new ArrayList<GraphRequest>();
        final ArrayList<JSONObject> results = new ArrayList<JSONObject>();
        final ArrayList<GraphResponse> errorResponses = new ArrayList<GraphResponse>();
        final GraphRequest.Callback requestCallback = new GraphRequest.Callback() {
            @Override
            public void onCompleted(GraphResponse response) {
                final JSONObject result = response.getJSONObject();
                if (result != null) {
                    results.add(result);
                }
                if (response.getError() != null) {
                    errorResponses.add(response);
                }
                requestCount.value -= 1;
                if (requestCount.value == 0) {
                    if (!errorResponses.isEmpty()) {
                        ShareInternalUtility.invokeCallbackWithResults(
                                callback,
                                null,
                                errorResponses.get(0));
                    } else if (!results.isEmpty()) {
                        final String postId = results.get(0).optString("id");
                        ShareInternalUtility.invokeCallbackWithResults(
                                callback,
                                postId,
                                response);
                    }
                }
            }
        };
        try {
            for (SharePhoto photo : photoContent.getPhotos()) {
                final Bitmap bitmap = photo.getBitmap();
                final Uri photoUri = photo.getImageUrl();
                String caption = photo.getCaption();
                if (caption == null) {
                    caption = this.getMessage();
                }
                if (bitmap != null) {
                    requests.add(ShareInternalUtility.newUploadPhotoRequest(
                            getGraphPath(PHOTOS_EDGE),
                            accessToken,
                            bitmap,
                            caption,
                            photo.getParameters(),
                            requestCallback));
                } else if (photoUri != null) {
                    requests.add(ShareInternalUtility.newUploadPhotoRequest(
                            getGraphPath(PHOTOS_EDGE),
                            accessToken,
                            photoUri,
                            caption,
                            photo.getParameters(),
                            requestCallback));
                }
            }
            requestCount.value += requests.size();
            for (GraphRequest request : requests) {
                request.executeAsync();
            }
        } catch (final FileNotFoundException ex) {
            ShareInternalUtility.invokeCallbackWithException(callback, ex);
        }
    }

    private void shareLinkContent(final ShareLinkContent linkContent,
                                  final FacebookCallback<Sharer.Result> callback) {
        final GraphRequest.Callback requestCallback = new GraphRequest.Callback() {
            @Override
            public void onCompleted(GraphResponse response) {
                final JSONObject data = response.getJSONObject();
                final String postId = (data == null ? null : data.optString("id"));
                ShareInternalUtility.invokeCallbackWithResults(callback, postId, response);
            }
        };
        final Bundle parameters = new Bundle();
        this.addCommonParameters(parameters, linkContent);
        parameters.putString("message", this.getMessage());
        parameters.putString("link", Utility.getUriString(linkContent.getContentUrl()));
        parameters.putString("picture", Utility.getUriString(linkContent.getImageUrl()));
        parameters.putString("name", linkContent.getContentTitle());
        parameters.putString("description", linkContent.getContentDescription());
        parameters.putString("ref", linkContent.getRef());
        new GraphRequest(
                AccessToken.getCurrentAccessToken(),
                getGraphPath("feed"),
                parameters,
                HttpMethod.POST,
                requestCallback).executeAsync();
    }

    private void shareVideoContent(final ShareVideoContent videoContent,
                                   final FacebookCallback<Sharer.Result> callback) {
        try {
            VideoUploader.uploadAsync(videoContent, getGraphNode(), callback);
        } catch (final FileNotFoundException ex) {
            ShareInternalUtility.invokeCallbackWithException(callback, ex);
        }
    }

    private void stageArrayList(final ArrayList arrayList,
                                       final CollectionMapper.OnMapValueCompleteListener
                                               onArrayListStagedListener) {
        final JSONArray stagedObject = new JSONArray();
        final CollectionMapper.Collection<Integer> collection = new CollectionMapper
                .Collection<Integer>() {
            @Override
            public Iterator<Integer> keyIterator() {
                final int size = arrayList.size();
                final Mutable<Integer> current = new Mutable<Integer>(0);
                return new Iterator<Integer>() {
                    @Override
                    public boolean hasNext() {
                        return current.value < size;
                    }

                    @Override
                    public Integer next() {
                        return current.value++;
                    }

                    @Override
                    public void remove() {
                    }
                };
            }

            @Override
            public Object get(Integer key) {
                return arrayList.get(key);
            }

            @Override
            public void set(Integer key,
                            Object value,
                            CollectionMapper.OnErrorListener onErrorListener) {
                try {
                    stagedObject.put(key, value);
                } catch (final JSONException ex) {
                    String message = ex.getLocalizedMessage();
                    if (message == null) {
                        message = "Error staging object.";
                    }
                    onErrorListener.onError(new FacebookException(message));
                }
            }
        };
        final CollectionMapper.OnMapperCompleteListener onStagedArrayMapperCompleteListener =
                new CollectionMapper.OnMapperCompleteListener() {
                    @Override
                    public void onComplete() {
                        onArrayListStagedListener.onComplete(stagedObject);
                    }

                    @Override
                    public void onError(FacebookException exception) {
                        onArrayListStagedListener.onError(exception);
                    }
                };
        stageCollectionValues(collection, onStagedArrayMapperCompleteListener);
    }

    private <T> void stageCollectionValues(final CollectionMapper.Collection<T> collection,
                                                  final CollectionMapper.OnMapperCompleteListener
                                                          onCollectionValuesStagedListener) {
        final CollectionMapper.ValueMapper valueMapper = new CollectionMapper.ValueMapper() {
            @Override
            public void mapValue(Object value,
                                 CollectionMapper.OnMapValueCompleteListener
                                         onMapValueCompleteListener) {
                if (value instanceof ArrayList) {
                    stageArrayList((ArrayList) value, onMapValueCompleteListener);
                } else if (value instanceof ShareOpenGraphObject) {
                    stageOpenGraphObject(
                            (ShareOpenGraphObject) value,
                            onMapValueCompleteListener);
                } else if (value instanceof SharePhoto) {
                    stagePhoto((SharePhoto) value, onMapValueCompleteListener);
                } else {
                    onMapValueCompleteListener.onComplete(value);
                }
            }
        };
        CollectionMapper.iterate(collection, valueMapper, onCollectionValuesStagedListener);
    }

    private void stageOpenGraphAction(final Bundle parameters,
                                             final CollectionMapper.OnMapperCompleteListener
                                                     onOpenGraphActionStagedListener) {
        final CollectionMapper.Collection<String> collection = new CollectionMapper
                .Collection<String>() {
            @Override
            public Iterator<String> keyIterator() {
                return parameters.keySet().iterator();
            }

            @Override
            public Object get(String key) {
                return parameters.get(key);
            }

            @Override
            public void set(String key,
                            Object value,
                            CollectionMapper.OnErrorListener onErrorListener) {
                if (!Utility.putJSONValueInBundle(parameters, key, value)) {
                    onErrorListener.onError(
                            new FacebookException("Unexpected value: " + value.toString()));
                }
            }
        };
        stageCollectionValues(collection, onOpenGraphActionStagedListener);
    }

    private void stageOpenGraphObject(final ShareOpenGraphObject object,
                                             final CollectionMapper.OnMapValueCompleteListener
                                                     onOpenGraphObjectStagedListener) {
        String type = object.getString("type");
        if (type == null) {
            type = object.getString("og:type");
        }

        if (type == null) {
            onOpenGraphObjectStagedListener.onError(
                    new FacebookException("Open Graph objects must contain a type value."));
            return;
        }
        final JSONObject stagedObject = new JSONObject();
        final CollectionMapper.Collection<String> collection = new CollectionMapper
                .Collection<String>() {
            @Override
            public Iterator<String> keyIterator() {
                return object.keySet().iterator();
            }

            @Override
            public Object get(String key) {
                return object.get(key);
            }

            @Override
            public void set(String key,
                            Object value,
                            CollectionMapper.OnErrorListener onErrorListener) {
                try {
                    stagedObject.put(key, value);
                } catch (final JSONException ex) {
                    String message = ex.getLocalizedMessage();
                    if (message == null) {
                        message = "Error staging object.";
                    }
                    onErrorListener.onError(new FacebookException(message));
                }
            }
        };
        final GraphRequest.Callback requestCallback = new GraphRequest.Callback() {
            @Override
            public void onCompleted(GraphResponse response) {
                final FacebookRequestError error = response.getError();
                if (error != null) {
                    String message = error.getErrorMessage();
                    if (message == null) {
                        message = "Error staging Open Graph object.";
                    }
                    onOpenGraphObjectStagedListener.onError(
                            new FacebookGraphResponseException(response, message));
                    return;
                }
                final JSONObject data = response.getJSONObject();
                if (data == null) {
                    onOpenGraphObjectStagedListener.onError(
                            new FacebookGraphResponseException(response,
                                    "Error staging Open Graph object."));
                    return;
                }
                final String stagedObjectId = data.optString("id");
                if (stagedObjectId == null) {
                    onOpenGraphObjectStagedListener.onError(
                            new FacebookGraphResponseException(response,
                                    "Error staging Open Graph object."));
                    return;
                }
                onOpenGraphObjectStagedListener.onComplete(stagedObjectId);
            }
        };
        final String ogType = type;
        final CollectionMapper.OnMapperCompleteListener onMapperCompleteListener =
                new CollectionMapper.OnMapperCompleteListener() {
                    @Override
                    public void onComplete() {
                        final String objectString = stagedObject.toString();
                        final Bundle parameters = new Bundle();
                        parameters.putString("object", objectString);
                        try {
                            new GraphRequest(
                                    AccessToken.getCurrentAccessToken(),
                                    getGraphPath(
                                            "objects/" +
                                                    URLEncoder.encode(ogType, DEFAULT_CHARSET)),
                                    parameters,
                                    HttpMethod.POST,
                                    requestCallback).executeAsync();
                        } catch (final UnsupportedEncodingException ex) {
                            String message = ex.getLocalizedMessage();
                            if (message == null) {
                                message = "Error staging Open Graph object.";
                            }
                            onOpenGraphObjectStagedListener.onError(new FacebookException(message));
                        }
                    }

                    @Override
                    public void onError(FacebookException exception) {
                        onOpenGraphObjectStagedListener.onError(exception);
                    }
                };
        stageCollectionValues(collection, onMapperCompleteListener);
    }

    private void stagePhoto(final SharePhoto photo,
                                   final CollectionMapper.OnMapValueCompleteListener
                                           onPhotoStagedListener) {
        final Bitmap bitmap = photo.getBitmap();
        final Uri imageUrl = photo.getImageUrl();
        if ((bitmap != null) || (imageUrl != null)) {
            final GraphRequest.Callback requestCallback = new GraphRequest.Callback() {
                @Override
                public void onCompleted(GraphResponse response) {
                    final FacebookRequestError error = response.getError();
                    if (error != null) {
                        String message = error.getErrorMessage();
                        if (message == null) {
                            message = "Error staging photo.";
                        }
                        onPhotoStagedListener.onError(
                                new FacebookGraphResponseException(response, message));
                        return;
                    }
                    final JSONObject data = response.getJSONObject();
                    if (data == null) {
                        onPhotoStagedListener.onError(
                                new FacebookException("Error staging photo."));
                        return;
                    }
                    final String stagedImageUri = data.optString("uri");
                    if (stagedImageUri == null) {
                        onPhotoStagedListener.onError(
                                new FacebookException("Error staging photo."));
                        return;
                    }

                    final JSONObject stagedObject = new JSONObject();
                    try {
                        stagedObject.put("url", stagedImageUri);
                        stagedObject.put("user_generated", photo.getUserGenerated());
                    } catch (final JSONException ex) {
                        String message = ex.getLocalizedMessage();
                        if (message == null) {
                            message = "Error staging photo.";
                        }
                        onPhotoStagedListener.onError(new FacebookException(message));
                        return;
                    }
                    onPhotoStagedListener.onComplete(stagedObject);
                }
            };
            if (bitmap != null) {
                ShareInternalUtility.newUploadStagingResourceWithImageRequest(
                        AccessToken.getCurrentAccessToken(),
                        bitmap,
                        requestCallback).executeAsync();
            } else {
                try {
                    ShareInternalUtility.newUploadStagingResourceWithImageRequest(
                            AccessToken.getCurrentAccessToken(),
                            imageUrl,
                            requestCallback).executeAsync();
                } catch (final FileNotFoundException ex) {
                    String message = ex.getLocalizedMessage();
                    if (message == null) {
                        message = "Error staging photo.";
                    }
                    onPhotoStagedListener.onError(new FacebookException(message));
                }
            }
        } else {
            onPhotoStagedListener.onError(
                    new FacebookException("Photos must have an imageURL or bitmap."));
        }
    }
}

<code block>


package com.facebook.share.widget;

import android.app.Activity;
import android.content.Context;
import android.net.Uri;
import android.os.Bundle;
import android.support.v4.app.Fragment;

import com.facebook.FacebookCallback;
import com.facebook.FacebookException;
import com.facebook.appevents.AppEventsLogger;
import com.facebook.internal.AnalyticsEvents;
import com.facebook.internal.AppCall;
import com.facebook.internal.CallbackManagerImpl;
import com.facebook.internal.DialogFeature;
import com.facebook.internal.DialogPresenter;
import com.facebook.internal.FacebookDialogBase;
import com.facebook.internal.Utility;
import com.facebook.share.Sharer;
import com.facebook.share.internal.LegacyNativeDialogParameters;
import com.facebook.share.internal.NativeDialogParameters;
import com.facebook.share.internal.OpenGraphActionDialogFeature;
import com.facebook.share.internal.ShareContentValidation;
import com.facebook.share.internal.ShareDialogFeature;
import com.facebook.share.internal.ShareInternalUtility;
import com.facebook.share.internal.WebDialogParameters;
import com.facebook.share.model.*;

import java.util.ArrayList;
import java.util.List;


public final class ShareDialog
        extends FacebookDialogBase<ShareContent, Sharer.Result>
        implements Sharer {

    
    public enum Mode {
        
        AUTOMATIC,
        
        NATIVE,
        
        WEB,
        
        FEED
    }

    private static final String FEED_DIALOG = "feed";
    private static final String WEB_SHARE_DIALOG = "share";
    private static final String WEB_OG_SHARE_DIALOG = "share_open_graph";

    private static final int DEFAULT_REQUEST_CODE =
            CallbackManagerImpl.RequestCodeOffset.Share.toRequestCode();

    private  boolean shouldFailOnDataError = false;
    
    private boolean isAutomaticMode = true;

    
    public static void show(
            final Activity activity,
            final ShareContent shareContent) {
        new ShareDialog(activity).show(shareContent);
    }

    
    public static void show(
            final Fragment fragment,
            final ShareContent shareContent) {
        new ShareDialog(fragment).show(shareContent);
    }

    
    public static boolean canShow(Class<? extends ShareContent> contentType) {
        return canShowWebTypeCheck(contentType) || canShowNative(contentType);
    }

    private static boolean canShowNative(Class<? extends ShareContent> contentType) {
        DialogFeature feature = getFeature(contentType);

        return feature != null && DialogPresenter.canPresentNativeDialogWithFeature(feature);
    }

    private static boolean canShowWebTypeCheck(Class<? extends ShareContent> contentType) {
        
        
        
        

        return ShareLinkContent.class.isAssignableFrom(contentType)
                || ShareOpenGraphContent.class.isAssignableFrom(contentType);
    }

    
    public ShareDialog(Activity activity) {
        super(activity, DEFAULT_REQUEST_CODE);

        ShareInternalUtility.registerStaticShareCallback(DEFAULT_REQUEST_CODE);
    }

    
    public ShareDialog(Fragment fragment) {
        super(fragment, DEFAULT_REQUEST_CODE);

        ShareInternalUtility.registerStaticShareCallback(DEFAULT_REQUEST_CODE);
    }

    
    ShareDialog(Activity activity, int requestCode) {
        super(activity, requestCode);

        ShareInternalUtility.registerStaticShareCallback(requestCode);
    }

    
    ShareDialog(Fragment fragment, int requestCode) {
        super(fragment, requestCode);

        ShareInternalUtility.registerStaticShareCallback(requestCode);
    }

    @Override
    protected void registerCallbackImpl(
            final CallbackManagerImpl callbackManager,
            final FacebookCallback<Result> callback) {
        ShareInternalUtility.registerSharerCallback(
                getRequestCode(), callbackManager, callback);
    }

    @Override
    public boolean getShouldFailOnDataError() {
        return this.shouldFailOnDataError;
    }

    @Override
    public void setShouldFailOnDataError(boolean shouldFailOnDataError) {
        this.shouldFailOnDataError = shouldFailOnDataError;
    }

    
    public boolean canShow(ShareContent content, Mode mode) {
        return canShowImpl(content, (mode == Mode.AUTOMATIC) ? BASE_AUTOMATIC_MODE : mode);
    }

    
    public void show(ShareContent content, Mode mode) {
        isAutomaticMode = (mode == Mode.AUTOMATIC);

        showImpl(content, isAutomaticMode ? BASE_AUTOMATIC_MODE : mode);
    }

    @Override
    protected AppCall createBaseAppCall() {
        return new AppCall(getRequestCode());
    }

    @Override
    protected List<ModeHandler> getOrderedModeHandlers() {
        ArrayList<ModeHandler> handlers = new ArrayList<>();
        handlers.add(new NativeHandler());
        handlers.add(new FeedHandler()); 
        handlers.add(new WebShareHandler());

        return handlers;
    }

    private class NativeHandler extends ModeHandler {
        @Override
        public Object getMode() {
            return Mode.NATIVE;
        }

        @Override
        public boolean canShow(final ShareContent content) {
            return content != null && ShareDialog.canShowNative(content.getClass());
        }

        @Override
        public AppCall createAppCall(final ShareContent content) {
            logDialogShare(getActivityContext(), content, Mode.NATIVE);

            ShareContentValidation.validateForNativeShare(content);

            final AppCall appCall = createBaseAppCall();
            final boolean shouldFailOnDataError = getShouldFailOnDataError();

            DialogPresenter.setupAppCallForNativeDialog(
                    appCall,
                    new DialogPresenter.ParameterProvider() {
                        @Override
                        public Bundle getParameters() {
                            return NativeDialogParameters.create(
                                    appCall.getCallId(),
                                    content,
                                    shouldFailOnDataError);
                        }

                        @Override
                        public Bundle getLegacyParameters() {
                            return LegacyNativeDialogParameters.create(
                                    appCall.getCallId(),
                                    content,
                                    shouldFailOnDataError);
                        }
                    },
                    getFeature(content.getClass()));

            return appCall;
        }
    }

    private class WebShareHandler extends ModeHandler {
        @Override
        public Object getMode() {
            return Mode.WEB;
        }

        @Override
        public boolean canShow(final ShareContent content) {
            return (content != null) && ShareDialog.canShowWebTypeCheck(content.getClass());
        }

        @Override
        public AppCall createAppCall(final ShareContent content) {
            logDialogShare(getActivityContext(), content, Mode.WEB);

            final AppCall appCall = createBaseAppCall();

            ShareContentValidation.validateForWebShare(content);

            Bundle params;
            if (content instanceof ShareLinkContent) {
                params = WebDialogParameters.create((ShareLinkContent)content);
            } else {
                params = WebDialogParameters.create((ShareOpenGraphContent)content);
            }

            DialogPresenter.setupAppCallForWebDialog(
                    appCall,
                    getActionName(content),
                    params);

            return appCall;
        }

        private String getActionName(ShareContent shareContent) {
            if (shareContent instanceof ShareLinkContent) {
                return WEB_SHARE_DIALOG;
            } else if (shareContent instanceof ShareOpenGraphContent) {
                return WEB_OG_SHARE_DIALOG;
            }

            return null;
        }
    }

    private class FeedHandler extends ModeHandler {
        @Override
        public Object getMode() {
            return Mode.FEED;
        }

        @Override
        public boolean canShow(final ShareContent content) {
            return (content instanceof ShareLinkContent);
        }

        @Override
        public AppCall createAppCall(final ShareContent content) {
            logDialogShare(getActivityContext(), content, Mode.FEED);

            final ShareLinkContent linkContent = (ShareLinkContent)content;
            final AppCall appCall = createBaseAppCall();

            ShareContentValidation.validateForWebShare(linkContent);

            DialogPresenter.setupAppCallForWebDialog(
                    appCall,
                    FEED_DIALOG,
                    WebDialogParameters.createForFeed(linkContent));

            return appCall;
        }
    }

    private static DialogFeature getFeature(
            Class<? extends ShareContent> contentType) {
        if (ShareLinkContent.class.isAssignableFrom(contentType)) {
            return ShareDialogFeature.SHARE_DIALOG;
        } else if (SharePhotoContent.class.isAssignableFrom(contentType)) {
            return ShareDialogFeature.PHOTOS;
        } else if (ShareVideoContent.class.isAssignableFrom(contentType)) {
            return ShareDialogFeature.VIDEO;
        } else if (ShareOpenGraphContent.class.isAssignableFrom(contentType)) {
            return OpenGraphActionDialogFeature.OG_ACTION_DIALOG;
        }
        return null;
    }

    private void logDialogShare(Context context, ShareContent content, Mode mode) {
        String displayType;
        if (isAutomaticMode) {
            mode = Mode.AUTOMATIC;
        }

        switch (mode) {
            case AUTOMATIC:
                displayType = AnalyticsEvents.PARAMETER_SHARE_DIALOG_SHOW_AUTOMATIC;
                break;
            case WEB:
                displayType = AnalyticsEvents.PARAMETER_SHARE_DIALOG_SHOW_WEB;
                break;
            case NATIVE:
                displayType = AnalyticsEvents.PARAMETER_SHARE_DIALOG_SHOW_NATIVE;
                break;
            default:
                displayType = AnalyticsEvents.PARAMETER_SHARE_DIALOG_SHOW_UNKNOWN;
                break;
        }

        String contentType;
        DialogFeature dialogFeature = getFeature(content.getClass());
        if (dialogFeature == ShareDialogFeature.SHARE_DIALOG) {
            contentType = AnalyticsEvents.PARAMETER_SHARE_DIALOG_CONTENT_STATUS;
        } else if (dialogFeature == ShareDialogFeature.PHOTOS) {
            contentType = AnalyticsEvents.PARAMETER_SHARE_DIALOG_CONTENT_PHOTO;
        } else if (dialogFeature == ShareDialogFeature.VIDEO) {
            contentType = AnalyticsEvents.PARAMETER_SHARE_DIALOG_CONTENT_VIDEO;
        } else if (dialogFeature == OpenGraphActionDialogFeature.OG_ACTION_DIALOG) {
            contentType = AnalyticsEvents.PARAMETER_SHARE_DIALOG_CONTENT_OPENGRAPH;
        } else {
            contentType = AnalyticsEvents.PARAMETER_SHARE_DIALOG_CONTENT_UNKNOWN;
        }

        AppEventsLogger logger = AppEventsLogger.newLogger(context);
        Bundle parameters = new Bundle();
        parameters.putString(
                AnalyticsEvents.PARAMETER_SHARE_DIALOG_SHOW,
                displayType
        );
        parameters.putString(
                AnalyticsEvents.PARAMETER_SHARE_DIALOG_CONTENT_TYPE,
                contentType
        );
        logger.logSdkEvent(AnalyticsEvents.EVENT_SHARE_DIALOG_SHOW, null, parameters);
    }
}

<code block>


package com.facebook.share.internal;

import android.os.Bundle;

import com.facebook.FacebookException;
import com.facebook.internal.Utility;
import com.facebook.share.model.AppGroupCreationContent;
import com.facebook.share.model.GameRequestContent;
import com.facebook.share.model.ShareLinkContent;
import com.facebook.share.model.ShareOpenGraphContent;

import org.json.JSONException;
import org.json.JSONObject;

import java.util.Locale;


public class WebDialogParameters {

    public static Bundle create(AppGroupCreationContent appGroupCreationContent) {
        Bundle webParams = new Bundle();

        Utility.putNonEmptyString(
                webParams,
                ShareConstants.WEB_DIALOG_PARAM_NAME,
                appGroupCreationContent.getName());

        Utility.putNonEmptyString(
                webParams,
                ShareConstants.WEB_DIALOG_PARAM_DESCRIPTION,
                appGroupCreationContent.getDescription());

        Utility.putNonEmptyString(
                webParams,
                ShareConstants.WEB_DIALOG_PARAM_PRIVACY,
                appGroupCreationContent
                        .getAppGroupPrivacy().toString().toLowerCase(Locale.ENGLISH));

        return webParams;
    }

    public static Bundle create(GameRequestContent gameRequestContent) {
        Bundle webParams = new Bundle();

        Utility.putNonEmptyString(
                webParams,
                ShareConstants.WEB_DIALOG_PARAM_MESSAGE,
                gameRequestContent.getMessage());
        Utility.putNonEmptyString(
                webParams,
                ShareConstants.WEB_DIALOG_PARAM_TO,
                gameRequestContent.getTo());
        Utility.putNonEmptyString(
                webParams,
                ShareConstants.WEB_DIALOG_PARAM_TITLE,
                gameRequestContent.getTitle());
        Utility.putNonEmptyString(
                webParams,
                ShareConstants.WEB_DIALOG_PARAM_DATA,
                gameRequestContent.getData());
        if (gameRequestContent.getActionType() != null) {
            Utility.putNonEmptyString(
                    webParams,
                    ShareConstants.WEB_DIALOG_PARAM_ACTION_TYPE,
                    gameRequestContent.getActionType().toString().toLowerCase(Locale.ENGLISH));
        }
        Utility.putNonEmptyString(
                webParams,
                ShareConstants.WEB_DIALOG_PARAM_OBJECT_ID,
                gameRequestContent.getObjectId());
        if (gameRequestContent.getFilters() != null) {
            Utility.putNonEmptyString(
                    webParams,
                    ShareConstants.WEB_DIALOG_PARAM_FILTERS,
                    gameRequestContent.getFilters().toString().toLowerCase(Locale.ENGLISH));
        }
        Utility.putCommaSeparatedStringList(
                webParams,
                ShareConstants.WEB_DIALOG_PARAM_SUGGESTIONS,
                gameRequestContent.getSuggestions());
        return webParams;
    }

    public static Bundle create(ShareLinkContent shareLinkContent) {
        Bundle params = new Bundle();
        Utility.putUri(
                params,
                ShareConstants.WEB_DIALOG_PARAM_HREF,
                shareLinkContent.getContentUrl());

        return params;
    }

    public static Bundle create(ShareOpenGraphContent shareOpenGraphContent) {
        Bundle params = new Bundle();

        Utility.putNonEmptyString(
                params,
                ShareConstants.WEB_DIALOG_PARAM_ACTION_TYPE,
                shareOpenGraphContent.getAction().getActionType());

        try {
            JSONObject ogJSON = ShareInternalUtility.toJSONObjectForWeb(shareOpenGraphContent);
            ogJSON = ShareInternalUtility.removeNamespacesFromOGJsonObject(ogJSON, false);
            if (ogJSON != null) {
                Utility.putNonEmptyString(
                        params,
                        ShareConstants.WEB_DIALOG_PARAM_ACTION_PROPERTIES,
                        ogJSON.toString());
            }
        } catch (JSONException e) {
            throw new FacebookException("Unable to serialize the ShareOpenGraphContent to JSON", e);
        }

        return params;
    }

    public static Bundle createForFeed(ShareLinkContent shareLinkContent) {
        Bundle webParams = new Bundle();

        Utility.putNonEmptyString(
                webParams,
                ShareConstants.WEB_DIALOG_PARAM_NAME,
                shareLinkContent.getContentTitle());

        Utility.putNonEmptyString(
                webParams,
                ShareConstants.WEB_DIALOG_PARAM_DESCRIPTION,
                shareLinkContent.getContentDescription());

        Utility.putNonEmptyString(
                webParams,
                ShareConstants.WEB_DIALOG_PARAM_LINK,
                Utility.getUriString(shareLinkContent.getContentUrl()));

        Utility.putNonEmptyString(
                webParams,
                ShareConstants.WEB_DIALOG_PARAM_PICTURE,
                Utility.getUriString(shareLinkContent.getImageUrl()));

        return webParams;
    }
}

<code block>


package com.facebook.share.internal;


public class ShareConstants {

    public static final int MIN_API_VERSION_FOR_WEB_FALLBACK_DIALOGS = 14;

    public static final String WEB_DIALOG_PARAM_DATA = "data";
    public static final String WEB_DIALOG_PARAM_MESSAGE = "message";
    public static final String WEB_DIALOG_PARAM_TO = "to";
    public static final String WEB_DIALOG_PARAM_TITLE = "title";
    public static final String WEB_DIALOG_PARAM_ACTION_TYPE = "action_type";
    public static final String WEB_DIALOG_PARAM_OBJECT_ID = "object_id";
    public static final String WEB_DIALOG_PARAM_FILTERS = "filters";
    public static final String WEB_DIALOG_PARAM_SUGGESTIONS = "suggestions";

    public static final String WEB_DIALOG_PARAM_HREF = "href";
    public static final String WEB_DIALOG_PARAM_ACTION_PROPERTIES = "action_properties";

    public static final String WEB_DIALOG_PARAM_LINK = "link";
    public static final String WEB_DIALOG_PARAM_PICTURE = "picture";
    public static final String WEB_DIALOG_PARAM_NAME = "name";
    public static final String WEB_DIALOG_PARAM_DESCRIPTION = "description";

    public static final String WEB_DIALOG_PARAM_ID = "id";

    public static final String WEB_DIALOG_PARAM_PRIVACY = "privacy";

    public static final String WEB_DIALOG_RESULT_PARAM_POST_ID = "post_id";
    public static final String WEB_DIALOG_RESULT_PARAM_REQUEST_ID = "request";
    public static final String WEB_DIALOG_RESULT_PARAM_TO_ARRAY_MEMBER = "to[%d]";

    
    public static final String LEGACY_PLACE_TAG = "com.facebook.platform.extra.PLACE";
    public static final String LEGACY_FRIEND_TAGS = "com.facebook.platform.extra.FRIENDS";
    public static final String LEGACY_LINK = "com.facebook.platform.extra.LINK";
    public static final String LEGACY_IMAGE = "com.facebook.platform.extra.IMAGE";
    public static final String LEGACY_TITLE = "com.facebook.platform.extra.TITLE";
    public static final String LEGACY_DESCRIPTION = "com.facebook.platform.extra.DESCRIPTION";
    public static final String LEGACY_REF = "com.facebook.platform.extra.REF";
    public static final String LEGACY_DATA_FAILURES_FATAL =
            "com.facebook.platform.extra.DATA_FAILURES_FATAL";
    public static final String LEGACY_PHOTOS = "com.facebook.platform.extra.PHOTOS";

    public static final String PLACE_ID = "PLACE";
    public static final String PEOPLE_IDS = "FRIENDS";
    public static final String CONTENT_URL = "LINK";
    public static final String IMAGE_URL = "IMAGE";
    public static final String TITLE = "TITLE";
    public static final String DESCRIPTION = "DESCRIPTION";
    public static final String REF = "REF";
    public static final String DATA_FAILURES_FATAL = "DATA_FAILURES_FATAL";
    public static final String PHOTOS = "PHOTOS";
    public static final String VIDEO_URL = "VIDEO";

    
    public static final String LEGACY_ACTION = "com.facebook.platform.extra.ACTION";
    public static final String LEGACY_ACTION_TYPE = "com.facebook.platform.extra.ACTION_TYPE";
    public static final String LEGACY_PREVIEW_PROPERTY_NAME =
            "com.facebook.platform.extra.PREVIEW_PROPERTY_NAME";

    public static final String ACTION = "ACTION";
    public static final String ACTION_TYPE = "ACTION_TYPE";
    public static final String PREVIEW_PROPERTY_NAME = "PREVIEW_PROPERTY_NAME";

    
    public static final String OBJECT_ID = "object_id";
    public static final String OBJECT_TYPE = "object_type";

    
    public static final String APPLINK_URL = "app_link_url";
    public static final String PREVIEW_IMAGE_URL = "preview_image_url";

    
    public static final String EXTRA_OBJECT_ID = "com.facebook.platform.extra.OBJECT_ID";

    
    public static final String EXTRA_OBJECT_IS_LIKED =
            "com.facebook.platform.extra.OBJECT_IS_LIKED";
    public static final String EXTRA_LIKE_COUNT_STRING_WITH_LIKE =
            "com.facebook.platform.extra.LIKE_COUNT_STRING_WITH_LIKE";
    public static final String EXTRA_LIKE_COUNT_STRING_WITHOUT_LIKE =
            "com.facebook.platform.extra.LIKE_COUNT_STRING_WITHOUT_LIKE";
    public static final String EXTRA_SOCIAL_SENTENCE_WITH_LIKE =
            "com.facebook.platform.extra.SOCIAL_SENTENCE_WITH_LIKE";
    public static final String EXTRA_SOCIAL_SENTENCE_WITHOUT_LIKE =
            "com.facebook.platform.extra.SOCIAL_SENTENCE_WITHOUT_LIKE";
    public static final String EXTRA_UNLIKE_TOKEN = "com.facebook.platform.extra.UNLIKE_TOKEN";

    
    public static final String EXTRA_RESULT_POST_ID = "com.facebook.platform.extra.POST_ID";
    public static final String RESULT_POST_ID = "postId";

    public static final int MAXIMUM_PHOTO_COUNT = 6;
    static final String MY_VIDEOS = "me/videos";
}

<code block>


package com.facebook.share.internal;

import android.content.Context;
import android.content.Intent;
import android.graphics.Bitmap;
import android.net.Uri;
import android.os.Bundle;
import android.os.ParcelFileDescriptor;
import android.support.annotation.Nullable;
import android.text.TextUtils;
import android.util.Pair;

import com.facebook.AccessToken;
import com.facebook.CallbackManager;
import com.facebook.FacebookCallback;
import com.facebook.FacebookException;
import com.facebook.FacebookGraphResponseException;
import com.facebook.FacebookOperationCanceledException;
import com.facebook.FacebookRequestError;
import com.facebook.FacebookSdk;
import com.facebook.GraphRequest;
import com.facebook.GraphRequest.Callback;
import com.facebook.GraphResponse;
import com.facebook.internal.GraphUtil;
import com.facebook.HttpMethod;
import com.facebook.appevents.AppEventsLogger;
import com.facebook.internal.AnalyticsEvents;
import com.facebook.internal.AppCall;
import com.facebook.internal.CallbackManagerImpl;
import com.facebook.internal.NativeAppCallAttachmentStore;
import com.facebook.internal.NativeProtocol;
import com.facebook.internal.Utility;
import com.facebook.share.Sharer;
import com.facebook.share.model.ShareOpenGraphAction;
import com.facebook.share.model.ShareOpenGraphContent;
import com.facebook.share.model.SharePhoto;
import com.facebook.share.model.SharePhotoContent;
import com.facebook.share.model.ShareVideoContent;
import com.facebook.share.widget.LikeView;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.UUID;


public final class ShareInternalUtility {
    private static final String OBJECT_PARAM = "object";
    public static final String MY_PHOTOS = "me/photos";
    private static final String MY_FEED = "me/feed";
    private static final String MY_STAGING_RESOURCES = "me/staging_resources";
    private static final String MY_OBJECTS_FORMAT = "me/objects/%s";
    private static final String MY_ACTION_FORMAT = "me/%s";

    
    private static final String PICTURE_PARAM = "picture";
    private static final String CAPTION_PARAM = "caption";
    private static final String STAGING_PARAM = "file";

    public static void invokeCallbackWithException(
            FacebookCallback<Sharer.Result> callback,
            final Exception exception) {
        if (exception instanceof FacebookException) {
            invokeOnErrorCallback(callback, (FacebookException) exception);
            return;
        }
        invokeCallbackWithError(
                callback,
                "Error preparing share content: " + exception.getLocalizedMessage());
    }

    public static void invokeCallbackWithError(
            FacebookCallback<Sharer.Result> callback,
            String error) {
        invokeOnErrorCallback(callback, error);
    }

    public static void invokeCallbackWithResults(
            FacebookCallback<Sharer.Result> callback,
            final String postId,
            final GraphResponse graphResponse) {
        FacebookRequestError requestError = graphResponse.getError();
        if (requestError != null) {
            String errorMessage = requestError.getErrorMessage();
            if (Utility.isNullOrEmpty(errorMessage)) {
                errorMessage = "Unexpected error sharing.";
            }
            invokeOnErrorCallback(callback, graphResponse, errorMessage);
        } else {
            invokeOnSuccessCallback(callback, postId);
        }
    }

    
    public static boolean getNativeDialogDidComplete(Bundle result) {
        if (result.containsKey(NativeProtocol.RESULT_ARGS_DIALOG_COMPLETE_KEY)) {
            return result.getBoolean(NativeProtocol.RESULT_ARGS_DIALOG_COMPLETE_KEY);
        }
        return result.getBoolean(NativeProtocol.EXTRA_DIALOG_COMPLETE_KEY, false);
    }

    
    public static String getNativeDialogCompletionGesture(Bundle result) {
        if (result.containsKey(NativeProtocol.RESULT_ARGS_DIALOG_COMPLETION_GESTURE_KEY)) {
            return result.getString(NativeProtocol.RESULT_ARGS_DIALOG_COMPLETION_GESTURE_KEY);
        }
        return result.getString(NativeProtocol.EXTRA_DIALOG_COMPLETION_GESTURE_KEY);
    }

    
    public static String getShareDialogPostId(Bundle result) {
        if (result.containsKey(ShareConstants.RESULT_POST_ID)) {
            return result.getString(ShareConstants.RESULT_POST_ID);
        }
        if (result.containsKey(ShareConstants.EXTRA_RESULT_POST_ID)) {
            return result.getString(ShareConstants.EXTRA_RESULT_POST_ID);
        }
        return result.getString(ShareConstants.WEB_DIALOG_RESULT_PARAM_POST_ID);
    }

    public static boolean handleActivityResult(
            int requestCode,
            int resultCode,
            Intent data,
            ResultProcessor resultProcessor) {
        AppCall appCall = getAppCallFromActivityResult(requestCode, resultCode, data);
        if (appCall == null) {
            return false;
        }

        NativeAppCallAttachmentStore.cleanupAttachmentsForCall(appCall.getCallId());
        if (resultProcessor == null) {
            return true;
        }

        FacebookException exception = NativeProtocol.getExceptionFromErrorData(
                NativeProtocol.getErrorDataFromResultIntent(data));
        if (exception != null) {
            if (exception instanceof FacebookOperationCanceledException) {
                resultProcessor.onCancel(appCall);
            } else {
                resultProcessor.onError(appCall, exception);
            }
        } else {
            
            Bundle results = NativeProtocol.getSuccessResultsFromIntent(data);
            resultProcessor.onSuccess(appCall, results);
        }

        return true;
    }

    
    public static ResultProcessor getShareResultProcessor(
            final FacebookCallback<Sharer.Result> callback) {
        return new ResultProcessor(callback) {
            @Override
            public void onSuccess(AppCall appCall, Bundle results) {
                if (results != null) {
                    final String gesture = getNativeDialogCompletionGesture(results);
                    if (gesture == null || "post".equalsIgnoreCase(gesture)) {
                        String postId = getShareDialogPostId(results);
                        invokeOnSuccessCallback(callback, postId);
                    } else if ("cancel".equalsIgnoreCase(gesture)) {
                        invokeOnCancelCallback(callback);
                    } else {
                        invokeOnErrorCallback(
                                callback,
                                new FacebookException(NativeProtocol.ERROR_UNKNOWN_ERROR));
                    }
                }
            }

            @Override
            public void onCancel(AppCall appCall) {
                invokeOnCancelCallback(callback);
            }

            @Override
            public void onError(AppCall appCall, FacebookException error) {
                invokeOnErrorCallback(callback, error);
            }
        };
    }

    private static AppCall getAppCallFromActivityResult(int requestCode,
                                                        int resultCode,
                                                        Intent data) {
        UUID callId = NativeProtocol.getCallIdFromIntent(data);
        if (callId == null) {
            return null;
        }

        return AppCall.finishPendingCall(callId, requestCode);
    }

    public static void registerStaticShareCallback(
            final int requestCode) {
        CallbackManagerImpl.registerStaticCallback(
                requestCode,
                new CallbackManagerImpl.Callback() {
                    @Override
                    public boolean onActivityResult(int resultCode, Intent data) {
                        return handleActivityResult(
                                requestCode,
                                resultCode,
                                data,
                                getShareResultProcessor(null));
                    }
                }
        );
    }

    public static void registerSharerCallback(
            final int requestCode,
            final CallbackManager callbackManager,
            final FacebookCallback<Sharer.Result> callback) {
        if (!(callbackManager instanceof CallbackManagerImpl)) {
            throw new FacebookException("Unexpected CallbackManager, " +
                    "please use the provided Factory.");
        }

        ((CallbackManagerImpl) callbackManager).registerCallback(
                requestCode,
                new CallbackManagerImpl.Callback() {
                    @Override
                    public boolean onActivityResult(int resultCode, Intent data) {
                        return handleActivityResult(
                                requestCode,
                                resultCode,
                                data,
                                getShareResultProcessor(callback));
                    }
                });
    }

    public static List<String> getPhotoUrls(
            final SharePhotoContent photoContent,
            final UUID appCallId) {
        List<SharePhoto> photos;
        if (photoContent == null || (photos = photoContent.getPhotos()) == null) {
            return null;
        }

        List<NativeAppCallAttachmentStore.Attachment> attachments = Utility.map(
                photos,
                new Utility.Mapper<SharePhoto, NativeAppCallAttachmentStore.Attachment>() {
                    @Override
                    public NativeAppCallAttachmentStore.Attachment apply(SharePhoto item) {
                        return getAttachment(appCallId, item);
                    }
                });

        List<String> attachmentUrls = Utility.map(
                attachments,
                new Utility.Mapper<NativeAppCallAttachmentStore.Attachment, String>() {
                    @Override
                    public String apply(NativeAppCallAttachmentStore.Attachment item) {
                        return item.getAttachmentUrl();
                    }
                });

        NativeAppCallAttachmentStore.addAttachments(attachments);

        return attachmentUrls;
    }

    public static String getVideoUrl(final ShareVideoContent videoContent, final UUID appCallId) {
        if (videoContent == null || videoContent.getVideo() == null) {
            return null;
        }

        NativeAppCallAttachmentStore.Attachment attachment =
                NativeAppCallAttachmentStore.createAttachment(
                        appCallId,
                        videoContent.getVideo().getLocalUrl());

        ArrayList<NativeAppCallAttachmentStore.Attachment> attachments = new ArrayList<>(1);
        attachments.add(attachment);
        NativeAppCallAttachmentStore.addAttachments(attachments);

        return attachment.getAttachmentUrl();
    }

    public static JSONObject toJSONObjectForCall(
            final UUID callId,
            final ShareOpenGraphContent content)
            throws JSONException {
        final ShareOpenGraphAction action = content.getAction();
        final ArrayList<NativeAppCallAttachmentStore.Attachment> attachments = new ArrayList<>();
        JSONObject actionJSON = OpenGraphJSONUtility.toJSONObject(
                action,
                new OpenGraphJSONUtility.PhotoJSONProcessor() {
                    @Override
                    public JSONObject toJSONObject(SharePhoto photo) {
                        NativeAppCallAttachmentStore.Attachment attachment = getAttachment(
                                callId,
                                photo);

                        if (attachment == null) {
                            return null;
                        }

                        attachments.add(attachment);

                        JSONObject photoJSONObject = new JSONObject();
                        try {
                            photoJSONObject.put(
                                    NativeProtocol.IMAGE_URL_KEY, attachment.getAttachmentUrl());
                            if (photo.getUserGenerated()) {
                                photoJSONObject.put(NativeProtocol.IMAGE_USER_GENERATED_KEY, true);
                            }
                        } catch (JSONException e) {
                            throw new FacebookException("Unable to attach images", e);
                        }
                        return photoJSONObject;
                    }
                });

        NativeAppCallAttachmentStore.addAttachments(attachments);
        
        if (content.getPlaceId() != null) {
            String placeTag = actionJSON.optString("place");

            
            
            if (Utility.isNullOrEmpty(placeTag)) {
                actionJSON.put("place", content.getPlaceId());
            }
        }

        if (content.getPeopleIds() != null) {
            JSONArray peopleTags = actionJSON.optJSONArray("tags");
            Set<String> peopleIdSet = peopleTags == null
                    ? new HashSet<String>()
                    : Utility.jsonArrayToSet(peopleTags);

            for (String peopleId : content.getPeopleIds()) {
                peopleIdSet.add(peopleId);
            }
            actionJSON.put("tags", new ArrayList<>(peopleIdSet));
        }

        return actionJSON;
    }

    public static JSONObject toJSONObjectForWeb(
            final ShareOpenGraphContent shareOpenGraphContent)
            throws JSONException {
        ShareOpenGraphAction action = shareOpenGraphContent.getAction();

        return OpenGraphJSONUtility.toJSONObject(
                action,
                new OpenGraphJSONUtility.PhotoJSONProcessor() {
                    @Override
                    public JSONObject toJSONObject(SharePhoto photo) {
                        Uri photoUri = photo.getImageUrl();
                        JSONObject photoJSONObject = new JSONObject();
                        try {
                            photoJSONObject.put(
                                    NativeProtocol.IMAGE_URL_KEY, photoUri.toString());
                        } catch (JSONException e) {
                            throw new FacebookException("Unable to attach images", e);
                        }
                        return photoJSONObject;
                    }
                });
    }

    public static JSONArray removeNamespacesFromOGJsonArray(
            JSONArray jsonArray,
            boolean requireNamespace) throws JSONException {
        JSONArray newArray = new JSONArray();
        for (int i = 0; i < jsonArray.length(); ++i) {
            Object value = jsonArray.get(i);
            if (value instanceof JSONArray) {
                value = removeNamespacesFromOGJsonArray((JSONArray) value, requireNamespace);
            } else if (value instanceof JSONObject) {
                value = removeNamespacesFromOGJsonObject((JSONObject) value, requireNamespace);
            }
            newArray.put(value);
        }

        return newArray;
    }

    public static JSONObject removeNamespacesFromOGJsonObject(
            JSONObject jsonObject,
            boolean requireNamespace) {
        if (jsonObject == null) {
            return null;
        }

        try {
            JSONObject newJsonObject = new JSONObject();
            JSONObject data = new JSONObject();
            JSONArray names = jsonObject.names();
            for (int i = 0; i < names.length(); ++i) {
                String key = names.getString(i);
                Object value = null;
                value = jsonObject.get(key);
                if (value instanceof JSONObject) {
                    value = removeNamespacesFromOGJsonObject((JSONObject) value, true);
                } else if (value instanceof JSONArray) {
                    value = removeNamespacesFromOGJsonArray((JSONArray) value, true);
                }

                Pair<String, String> fieldNameAndNamespace = getFieldNameAndNamespaceFromFullName(
                        key);
                String namespace = fieldNameAndNamespace.first;
                String fieldName = fieldNameAndNamespace.second;

                if (requireNamespace) {
                    if (namespace != null && namespace.equals("fbsdk")) {
                        newJsonObject.put(key, value);
                    } else if (namespace == null || namespace.equals("og")) {
                        newJsonObject.put(fieldName, value);
                    } else {
                        data.put(fieldName, value);
                    }
                } else if (namespace != null && namespace.equals("fb")) {
                    newJsonObject.put(key, value);
                } else {
                    newJsonObject.put(fieldName, value);
                }
            }

            if (data.length() > 0) {
                newJsonObject.put("data", data);
            }

            return newJsonObject;
        } catch (JSONException e) {
            throw new FacebookException("Failed to create json object from share content");
        }
    }

    public static Pair<String, String> getFieldNameAndNamespaceFromFullName(String fullName) {
        String namespace = null;
        String fieldName;
        int index = fullName.indexOf(':');
        if (index != -1 && fullName.length() > index + 1) {
            namespace = fullName.substring(0, index);
            fieldName = fullName.substring(index + 1);
        } else {
            fieldName = fullName;
        }
        return new Pair<>(namespace, fieldName);
    }

    ;

    private ShareInternalUtility() {
    }

    private static NativeAppCallAttachmentStore.Attachment getAttachment(
            UUID callId,
            SharePhoto photo) {
        Bitmap bitmap = photo.getBitmap();
        Uri photoUri = photo.getImageUrl();
        NativeAppCallAttachmentStore.Attachment attachment = null;
        if (bitmap != null) {
            attachment = NativeAppCallAttachmentStore.createAttachment(
                    callId,
                    bitmap);
        } else if (photoUri != null) {
            attachment = NativeAppCallAttachmentStore.createAttachment(
                    callId,
                    photoUri);
        }

        return attachment;
    }

    static void invokeOnCancelCallback(FacebookCallback<Sharer.Result> callback) {
        logShareResult(AnalyticsEvents.PARAMETER_SHARE_OUTCOME_CANCELLED, null);
        if (callback != null) {
            callback.onCancel();
        }
    }

    static void invokeOnSuccessCallback(
            FacebookCallback<Sharer.Result> callback,
            String postId) {
        logShareResult(AnalyticsEvents.PARAMETER_SHARE_OUTCOME_SUCCEEDED, null);
        if (callback != null) {
            callback.onSuccess(new Sharer.Result(postId));
        }
    }

    static void invokeOnErrorCallback(
            FacebookCallback<Sharer.Result> callback,
            GraphResponse response,
            String message) {
        logShareResult(AnalyticsEvents.PARAMETER_SHARE_OUTCOME_ERROR, message);
        if (callback != null) {
            callback.onError(new FacebookGraphResponseException(response, message));
        }
    }


    static void invokeOnErrorCallback(
            FacebookCallback<Sharer.Result> callback,
            String message) {
        logShareResult(AnalyticsEvents.PARAMETER_SHARE_OUTCOME_ERROR, message);
        if (callback != null) {
            callback.onError(new FacebookException(message));
        }
    }

    static void invokeOnErrorCallback(
            FacebookCallback<Sharer.Result> callback,
            FacebookException ex) {
        logShareResult(AnalyticsEvents.PARAMETER_SHARE_OUTCOME_ERROR, ex.getMessage());
        if (callback != null) {
            callback.onError(ex);
        }
    }

    private static void logShareResult(String shareOutcome, String errorMessage) {
        Context context = FacebookSdk.getApplicationContext();
        AppEventsLogger logger = AppEventsLogger.newLogger(context);
        Bundle parameters = new Bundle();
        parameters.putString(
                AnalyticsEvents.PARAMETER_SHARE_OUTCOME,
                shareOutcome
        );

        if (errorMessage != null) {
            parameters.putString(AnalyticsEvents.PARAMETER_SHARE_ERROR_MESSAGE, errorMessage);
        }
        logger.logSdkEvent(AnalyticsEvents.EVENT_SHARE_RESULT, null, parameters);
    }

    
    public static GraphRequest newPostOpenGraphObjectRequest(
            AccessToken accessToken,
            JSONObject openGraphObject,
            Callback callback) {
        if (openGraphObject == null) {
            throw new FacebookException("openGraphObject cannot be null");
        }
        if (Utility.isNullOrEmpty(openGraphObject.optString("type"))) {
            throw new FacebookException("openGraphObject must have non-null 'type' property");
        }
        if (Utility.isNullOrEmpty(openGraphObject.optString("title"))) {
            throw new FacebookException("openGraphObject must have non-null 'title' property");
        }

        String path = String.format(MY_OBJECTS_FORMAT, openGraphObject.optString("type"));
        Bundle bundle = new Bundle();
        bundle.putString(OBJECT_PARAM, openGraphObject.toString());
        return new GraphRequest(accessToken, path, bundle, HttpMethod.POST, callback);
    }

    
    public static GraphRequest newPostOpenGraphObjectRequest(
            AccessToken accessToken,
            String type,
            String title,
            String imageUrl,
            String url,
            String description,
            JSONObject objectProperties,
            Callback callback) {
        JSONObject openGraphObject = GraphUtil.createOpenGraphObjectForPost(
                type, title, imageUrl, url, description, objectProperties, null);
        return newPostOpenGraphObjectRequest(accessToken, openGraphObject, callback);
    }

    
    public static GraphRequest newPostOpenGraphActionRequest(
            AccessToken accessToken,
            JSONObject openGraphAction,
            Callback callback) {
        if (openGraphAction == null) {
            throw new FacebookException("openGraphAction cannot be null");
        }
        String type = openGraphAction.optString("type");
        if (Utility.isNullOrEmpty(type)) {
            throw new FacebookException("openGraphAction must have non-null 'type' property");
        }

        String path = String.format(MY_ACTION_FORMAT, type);
        return GraphRequest.newPostRequest(accessToken, path, openGraphAction, callback);
    }

    
    public static GraphRequest newUpdateOpenGraphObjectRequest(
            AccessToken accessToken,
            JSONObject openGraphObject,
            Callback callback) {
        if (openGraphObject == null) {
            throw new FacebookException("openGraphObject cannot be null");
        }

        String path = openGraphObject.optString("id");
        if (path == null) {
            throw new FacebookException("openGraphObject must have an id");
        }

        Bundle bundle = new Bundle();
        bundle.putString(OBJECT_PARAM, openGraphObject.toString());
        return new GraphRequest(accessToken, path, bundle, HttpMethod.POST, callback);
    }

    
    public static GraphRequest newUpdateOpenGraphObjectRequest(
            AccessToken accessToken,
            String id,
            String title,
            String imageUrl,
            String url,
            String description,
            JSONObject objectProperties,
            Callback callback) {
        JSONObject openGraphObject = GraphUtil.createOpenGraphObjectForPost(
                null, title, imageUrl, url, description, objectProperties, id);
        return newUpdateOpenGraphObjectRequest(accessToken, openGraphObject, callback);
    }

    
    public static GraphRequest newUploadPhotoRequest(
            String graphPath,
            AccessToken accessToken,
            Bitmap image,
            String caption,
            Bundle params,
            Callback callback) {
        Bundle parameters = new Bundle();
        if (params != null) {
            parameters.putAll(params);
        }
        parameters.putParcelable(PICTURE_PARAM, image);
        if (caption != null && !caption.isEmpty()) {
            parameters.putString(CAPTION_PARAM, caption);
        }

        return new GraphRequest(accessToken, graphPath, parameters, HttpMethod.POST, callback);
    }

    
    public static GraphRequest newUploadPhotoRequest(
            String graphPath,
            AccessToken accessToken,
            File file,
            String caption,
            Bundle params,
            Callback callback
    ) throws FileNotFoundException {
        ParcelFileDescriptor descriptor =
                ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
        Bundle parameters = new Bundle();
        if (params != null) {
            parameters.putAll(params);
        }
        parameters.putParcelable(PICTURE_PARAM, descriptor);
        if (caption != null && !caption.isEmpty()) {
            parameters.putString(CAPTION_PARAM, caption);
        }

        return new GraphRequest(accessToken, graphPath, parameters, HttpMethod.POST, callback);
    }

    
    public static GraphRequest newUploadPhotoRequest(
            String graphPath,
            AccessToken accessToken,
            Uri photoUri,
            String caption,
            Bundle params,
            Callback callback)
            throws FileNotFoundException {
        if (Utility.isFileUri(photoUri)) {
            return newUploadPhotoRequest(
                    graphPath,
                    accessToken,
                    new File(photoUri.getPath()),
                    caption,
                    params,
                    callback);
        } else if (!Utility.isContentUri(photoUri)) {
            throw new FacebookException("The photo Uri must be either a file:
        }

        Bundle parameters = new Bundle();
        if (params != null) {
            parameters.putAll(params);
        }
        parameters.putParcelable(PICTURE_PARAM, photoUri);

        return new GraphRequest(accessToken, graphPath, parameters, HttpMethod.POST, callback);
    }

    
    public static GraphRequest newStatusUpdateRequest(
            AccessToken accessToken,
            String message,
            Callback callback) {
        return newStatusUpdateRequest(accessToken, message, (String) null, null, callback);
    }

    
    private static GraphRequest newStatusUpdateRequest(
            AccessToken accessToken,
            String message,
            String placeId,
            List<String> tagIds,
            Callback callback) {

        Bundle parameters = new Bundle();
        parameters.putString("message", message);

        if (placeId != null) {
            parameters.putString("place", placeId);
        }

        if (tagIds != null && tagIds.size() > 0) {
            String tags = TextUtils.join(",", tagIds);
            parameters.putString("tags", tags);
        }

        return new GraphRequest(accessToken, MY_FEED, parameters, HttpMethod.POST, callback);
    }

    
    public static GraphRequest newStatusUpdateRequest(
            AccessToken accessToken,
            String message,
            JSONObject place,
            List<JSONObject> tags,
            Callback callback) {

        List<String> tagIds = null;
        if (tags != null) {
            tagIds = new ArrayList<String>(tags.size());
            for (JSONObject tag : tags) {
                tagIds.add(tag.optString("id"));
            }
        }
        String placeId = place == null ? null : place.optString("id");
        return newStatusUpdateRequest(accessToken, message, placeId, tagIds, callback);
    }


    
    public static GraphRequest newUploadStagingResourceWithImageRequest(
            AccessToken accessToken,
            Bitmap image,
            Callback callback) {
        Bundle parameters = new Bundle(1);
        parameters.putParcelable(STAGING_PARAM, image);

        return new GraphRequest(
                accessToken,
                MY_STAGING_RESOURCES,
                parameters,
                HttpMethod.POST,
                callback);
    }

    
    public static GraphRequest newUploadStagingResourceWithImageRequest(
            AccessToken accessToken,
            File file,
            Callback callback
    ) throws FileNotFoundException {
        ParcelFileDescriptor descriptor =
                ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
        GraphRequest.ParcelableResourceWithMimeType<ParcelFileDescriptor> resourceWithMimeType =
                new GraphRequest.ParcelableResourceWithMimeType<>(descriptor, "image/png");
        Bundle parameters = new Bundle(1);
        parameters.putParcelable(STAGING_PARAM, resourceWithMimeType);

        return new GraphRequest(
                accessToken,
                MY_STAGING_RESOURCES,
                parameters,
                HttpMethod.POST,
                callback);
    }

    
    public static GraphRequest newUploadStagingResourceWithImageRequest(
            AccessToken accessToken,
            Uri imageUri,
            Callback callback
    ) throws FileNotFoundException {
        if (Utility.isFileUri(imageUri)) {
            return newUploadStagingResourceWithImageRequest(
                    accessToken,
                    new File(imageUri.getPath()),
                    callback);
        } else if (!Utility.isContentUri(imageUri)) {
            throw new FacebookException("The image Uri must be either a file:
        }

        GraphRequest.ParcelableResourceWithMimeType<Uri> resourceWithMimeType =
                new GraphRequest.ParcelableResourceWithMimeType<>(imageUri, "image/png");
        Bundle parameters = new Bundle(1);
        parameters.putParcelable(STAGING_PARAM, resourceWithMimeType);

        return new GraphRequest(
                accessToken,
                MY_STAGING_RESOURCES,
                parameters,
                HttpMethod.POST,
                callback);
    }

    @Nullable
    public static LikeView.ObjectType getMostSpecificObjectType(
            LikeView.ObjectType objectType1,
            LikeView.ObjectType objectType2) {
        if (objectType1 == objectType2) {
            return objectType1;
        }

        if (objectType1 == LikeView.ObjectType.UNKNOWN) {
            return objectType2;
        } else if (objectType2 == LikeView.ObjectType.UNKNOWN) {
            return objectType1;
        } else {
            
            return null;
        }
    }
}

<code block>


package com.facebook.share.model;

import android.net.Uri;
import android.os.Parcel;
import android.support.annotation.Nullable;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;


public abstract class ShareContent<P extends ShareContent, E extends ShareContent.Builder>
        implements ShareModel {
    private final Uri contentUrl;
    private final List<String> peopleIds;
    private final String placeId;
    private final String ref;

    protected ShareContent(final Builder builder) {
        super();
        this.contentUrl = builder.contentUrl;
        this.peopleIds = builder.peopleIds;
        this.placeId = builder.placeId;
        this.ref = builder.ref;
    }

    ShareContent(final Parcel in) {
        this.contentUrl = in.readParcelable(Uri.class.getClassLoader());
        this.peopleIds = readUnmodifiableStringList(in);
        this.placeId = in.readString();
        this.ref = in.readString();
    }

    
    @Nullable
    public Uri getContentUrl() {
        return this.contentUrl;
    }

    
    @Nullable
    public List<String> getPeopleIds() {
        return this.peopleIds;
    }

    
    @Nullable
    public String getPlaceId() {
        return this.placeId;
    }

    
    @Nullable
    public String getRef() {
        return this.ref;
    }

    public int describeContents() {
        return 0;
    }

    public void writeToParcel(final Parcel out, final int flags) {
        out.writeParcelable(this.contentUrl, 0);
        out.writeStringList(this.peopleIds);
        out.writeString(this.placeId);
        out.writeString(this.ref);
    }

    private List<String> readUnmodifiableStringList(final Parcel in) {
        final List<String> list = new ArrayList<String>();
        in.readStringList(list);
        return (list.size() == 0 ? null : Collections.unmodifiableList(list));
    }

    
    public abstract static class Builder<P extends ShareContent, E extends Builder>
            implements ShareModelBuilder<P, E> {
        private Uri contentUrl;
        private List<String> peopleIds;
        private String placeId;
        private String ref;

        
        public E setContentUrl(@Nullable final Uri contentUrl) {
            this.contentUrl = contentUrl;
            return (E) this;
        }

        
        public E setPeopleIds(@Nullable final List<String> peopleIds) {
            this.peopleIds = (peopleIds == null ? null : Collections.unmodifiableList(peopleIds));
            return (E) this;
        }

        
        public E setPlaceId(@Nullable final String placeId) {
            this.placeId = placeId;
            return (E) this;
        }

        
        public E setRef(@Nullable final String ref) {
            this.ref = ref;
            return (E) this;
        }

        @Override
        public E readFrom(final P content) {
            if (content == null) {
                return (E) this;
            }
            return (E) this
                    .setContentUrl(content.getContentUrl())
                    .setPeopleIds(content.getPeopleIds())
                    .setPlaceId(content.getPlaceId())
                    .setRef(content.getRef());
        }
    }
}

<code block>


package com.facebook.login;


public enum LoginBehavior {
    
    SSO_WITH_FALLBACK(true, true),

    
    SSO_ONLY(true, false),

    
    SUPPRESS_SSO(false, true);

    private final boolean allowsKatanaAuth;
    private final boolean allowsWebViewAuth;

    private LoginBehavior(boolean allowsKatanaAuth, boolean allowsWebViewAuth) {
        this.allowsKatanaAuth = allowsKatanaAuth;
        this.allowsWebViewAuth = allowsWebViewAuth;
    }

    boolean allowsKatanaAuth() {
        return allowsKatanaAuth;
    }

    boolean allowsWebViewAuth() {
        return allowsWebViewAuth;
    }
}

<code block>


package com.facebook.login;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.Intent;
import android.content.pm.ResolveInfo;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.content.Context;

import com.facebook.AccessToken;
import com.facebook.CallbackManager;
import com.facebook.FacebookActivity;
import com.facebook.FacebookAuthorizationException;
import com.facebook.FacebookCallback;
import com.facebook.FacebookException;
import com.facebook.FacebookSdk;
import com.facebook.GraphResponse;
import com.facebook.Profile;
import com.facebook.internal.CallbackManagerImpl;
import com.facebook.internal.Validate;
import com.facebook.appevents.AppEventsConstants;

import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.UUID;


public class LoginManager {
    private static final String PUBLISH_PERMISSION_PREFIX = "publish";
    private static final String MANAGE_PERMISSION_PREFIX = "manage";
    private static final Set<String> OTHER_PUBLISH_PERMISSIONS = getOtherPublishPermissions();

    private static volatile LoginManager instance;

    private LoginBehavior loginBehavior = LoginBehavior.SSO_WITH_FALLBACK;
    private DefaultAudience defaultAudience = DefaultAudience.FRIENDS;
    private LoginClient.Request pendingLoginRequest;
    private HashMap<String, String> pendingLoggingExtras;
    private LoginLogger loginLogger;

    LoginManager() {
        Validate.sdkInitialized();
    }

    
    public static LoginManager getInstance() {
        if (instance == null) {
            synchronized (LoginManager.class) {
                if (instance == null) {
                    instance = new LoginManager();
                }
            }
        }

        return instance;
    }

    
    public void resolveError(final Activity activity, final GraphResponse response) {
        startLogin(
                new ActivityStartActivityDelegate(activity),
                createLoginRequestFromResponse(response)
        );
    }

    
    public void resolveError(final Fragment fragment, final GraphResponse response) {
        startLogin(
                new FragmentStartActivityDelegate(fragment),
                createLoginRequestFromResponse(response)
        );
    }

    private LoginClient.Request createLoginRequestFromResponse(final GraphResponse response) {
        Validate.notNull(response, "response");
        AccessToken failedToken = response.getRequest().getAccessToken();
        return createLoginRequest(failedToken != null ? failedToken.getPermissions() : null);
    }

    
    public void registerCallback(
            final CallbackManager callbackManager,
            final FacebookCallback<LoginResult> callback) {
        if (!(callbackManager instanceof CallbackManagerImpl)) {
            throw new FacebookException("Unexpected CallbackManager, " +
                    "please use the provided Factory.");
        }
        ((CallbackManagerImpl) callbackManager).registerCallback(
                CallbackManagerImpl.RequestCodeOffset.Login.toRequestCode(),
                new CallbackManagerImpl.Callback() {
                    @Override
                    public boolean onActivityResult(int resultCode, Intent data) {
                        return LoginManager.this.onActivityResult(
                                resultCode,
                                data,
                                callback);
                    }
                }
        );
    }

    boolean onActivityResult(int resultCode, Intent data) {
        return onActivityResult(resultCode, data, null);
    }

    boolean onActivityResult(int resultCode, Intent data, FacebookCallback<LoginResult>  callback) {

        if (pendingLoginRequest == null) {
            return false;
        }

        FacebookException exception = null;
        AccessToken newToken = null;
        LoginClient.Result.Code code = LoginClient.Result.Code.ERROR;
        Map<String, String> loggingExtras = null;

        boolean isCanceled = false;
        if (data != null) {
            LoginClient.Result result = (LoginClient.Result)
                    data.getParcelableExtra(LoginFragment.RESULT_KEY);
            if (result != null) {
                code = result.code;
                if (resultCode == Activity.RESULT_OK) {
                    if (result.code == LoginClient.Result.Code.SUCCESS) {
                        newToken = result.token;
                    } else {
                        exception = new FacebookAuthorizationException(result.errorMessage);
                    }
                } else if (resultCode == Activity.RESULT_CANCELED) {
                    isCanceled = true;
                }
                loggingExtras = result.loggingExtras;
            }
        } else if (resultCode == Activity.RESULT_CANCELED) {
            isCanceled = true;
            code = LoginClient.Result.Code.CANCEL;
        }

        if (exception == null && newToken == null && !isCanceled) {
            exception = new FacebookException("Unexpected call to LoginManager.onActivityResult");
        }

        logCompleteLogin(code, loggingExtras, exception);

        finishLogin(newToken, exception, isCanceled, callback);

        return true;
    }

    
    public LoginBehavior getLoginBehavior() {
        return loginBehavior;
    }

    
    public LoginManager setLoginBehavior(LoginBehavior loginBehavior) {
        this.loginBehavior = loginBehavior;
        return this;
    }

    
    public DefaultAudience getDefaultAudience() {
        return defaultAudience;
    }

    
    public LoginManager setDefaultAudience(DefaultAudience defaultAudience) {
        this.defaultAudience = defaultAudience;
        return this;
    }

    
    public void logOut() {
        AccessToken.setCurrentAccessToken(null);
        Profile.setCurrentProfile(null);
    }

    
    public void logInWithReadPermissions(Fragment fragment, Collection<String> permissions) {
        validateReadPermissions(permissions);

        LoginClient.Request loginRequest = createLoginRequest(permissions);
        startLogin(new FragmentStartActivityDelegate(fragment), loginRequest);
    }

    
    public void logInWithReadPermissions(Activity activity, Collection<String> permissions) {
        validateReadPermissions(permissions);

        LoginClient.Request loginRequest = createLoginRequest(permissions);
        startLogin(new ActivityStartActivityDelegate(activity), loginRequest);
    }

    
    public void logInWithPublishPermissions(Fragment fragment, Collection<String> permissions) {
        validatePublishPermissions(permissions);

        LoginClient.Request loginRequest = createLoginRequest(permissions);
        startLogin(new FragmentStartActivityDelegate(fragment), loginRequest);
    }

    
    public void logInWithPublishPermissions(Activity activity, Collection<String> permissions) {
        validatePublishPermissions(permissions);

        LoginClient.Request loginRequest = createLoginRequest(permissions);
        startLogin(new ActivityStartActivityDelegate(activity), loginRequest);
    }

    LoginClient.Request getPendingLoginRequest() {
        return pendingLoginRequest;
    }

    private void validateReadPermissions(Collection<String> permissions) {
        if (permissions == null) {
            return;
        }
        for (String permission : permissions) {
            if (isPublishPermission(permission)) {
                throw new FacebookException(
                    String.format(
                        "Cannot pass a publish or manage permission (%s) to a request for read " +
                                "authorization",
                        permission));
            }
        }
    }

    private void validatePublishPermissions(Collection<String> permissions) {
        if (permissions == null) {
            return;
        }
        for (String permission : permissions) {
            if (!isPublishPermission(permission)) {
                throw new FacebookException(
                    String.format(
                        "Cannot pass a read permission (%s) to a request for publish authorization",
                        permission));
            }
        }
    }

    static boolean isPublishPermission(String permission) {
        return permission != null &&
            (permission.startsWith(PUBLISH_PERMISSION_PREFIX) ||
                permission.startsWith(MANAGE_PERMISSION_PREFIX) ||
                OTHER_PUBLISH_PERMISSIONS.contains(permission));
    }

    private static Set<String> getOtherPublishPermissions() {
        HashSet<String> set = new HashSet<String>() {{
            add("ads_management");
            add("create_event");
            add("rsvp_event");
        }};
        return Collections.unmodifiableSet(set);
    }

    private LoginClient.Request createLoginRequest(Collection<String> permissions) {
        LoginClient.Request request = new LoginClient.Request(
                loginBehavior,
                Collections.unmodifiableSet(
                        permissions != null ? new HashSet(permissions) : new HashSet<String>()),
                defaultAudience,
                FacebookSdk.getApplicationId(),
                UUID.randomUUID().toString()
        );
        request.setRerequest(AccessToken.getCurrentAccessToken() != null);
        return request;
    }

    private void startLogin(
            StartActivityDelegate startActivityDelegate,
            LoginClient.Request request
    ) throws FacebookException {

        this.pendingLoginRequest = request;
        this.pendingLoggingExtras = new HashMap<>();
        this.loginLogger = getLoggerForContext(startActivityDelegate.getActivityContext());

        logStartLogin();

        
        CallbackManagerImpl.registerStaticCallback(
                CallbackManagerImpl.RequestCodeOffset.Login.toRequestCode(),
                new CallbackManagerImpl.Callback() {
                    @Override
                    public boolean onActivityResult(int resultCode, Intent data) {
                        return LoginManager.this.onActivityResult(resultCode, data);
                    }
                }
        );

        boolean started = tryFacebookActivity(startActivityDelegate, request);

        pendingLoggingExtras.put(
                LoginLogger.EVENT_EXTRAS_TRY_LOGIN_ACTIVITY,
                started ?
                AppEventsConstants.EVENT_PARAM_VALUE_YES : AppEventsConstants.EVENT_PARAM_VALUE_NO
        );

        if (!started) {
            FacebookException exception = new FacebookException(
                    "Log in attempt failed: FacebookActivity could not be started." +
                            " Please make sure you added FacebookActivity to the AndroidManifest.");
            logCompleteLogin(LoginClient.Result.Code.ERROR, null, exception);
            this.pendingLoginRequest = null;
            throw exception;
        }
    }

    private LoginLogger getLoggerForContext(Context context) {
        if (context == null || pendingLoginRequest == null) {
            return null;
        }

        LoginLogger logger = this.loginLogger;
        if (logger == null ||
                !logger.getApplicationId().equals(pendingLoginRequest.getApplicationId())) {
            logger = new LoginLogger(context, pendingLoginRequest.getApplicationId());
        }
        return logger;
    }

    private void logStartLogin() {
        if (loginLogger != null && pendingLoginRequest != null) {
            loginLogger.logStartLogin(pendingLoginRequest);
        }
    }

    private void logCompleteLogin(LoginClient.Result.Code result, Map<String, String> resultExtras,
                                  Exception exception) {
        if (loginLogger == null) {
            return;
        }
        if (pendingLoginRequest == null) {
            
            loginLogger.logUnexpectedError(
                    LoginLogger.EVENT_NAME_LOGIN_COMPLETE,
                    "Unexpected call to logCompleteLogin with null pendingAuthorizationRequest."
            );
        } else {
            loginLogger.logCompleteLogin(
                    pendingLoginRequest.getAuthId(),
                    pendingLoggingExtras,
                    result,
                    resultExtras,
                    exception);
        }
    }

    private boolean tryFacebookActivity(
            StartActivityDelegate startActivityDelegate,
            LoginClient.Request request) {

        Intent intent = getFacebookActivityIntent(request);

        if (!resolveIntent(intent)) {
            return false;
        }

        try {
            startActivityDelegate.startActivityForResult(
                    intent,
                    LoginClient.getLoginRequestCode());
        } catch (ActivityNotFoundException e) {
            return false;
        }

        return true;
    }

    private boolean resolveIntent(Intent intent) {
        ResolveInfo resolveInfo = FacebookSdk.getApplicationContext().getPackageManager()
            .resolveActivity(intent, 0);
        if (resolveInfo == null) {
            return false;
        }
        return true;
    }

    private Intent getFacebookActivityIntent(LoginClient.Request request) {
        Intent intent = new Intent();
        intent.setClass(FacebookSdk.getApplicationContext(), FacebookActivity.class);
        intent.setAction(request.getLoginBehavior().toString());

        
        LoginClient.Request authClientRequest = request;
        Bundle extras = LoginFragment.populateIntentExtras(authClientRequest);
        intent.putExtras(extras);

        return intent;
    }

    static LoginResult computeLoginResult(
            final LoginClient.Request request,
            final AccessToken newToken
    ) {
        Set<String> requestedPermissions = request.getPermissions();
        Set<String> grantedPermissions = new HashSet<String>(newToken.getPermissions());

        
        
        if (request.isRerequest()) {
            grantedPermissions.retainAll(requestedPermissions);
        }

        Set<String> deniedPermissions = new HashSet<String>(requestedPermissions);
        deniedPermissions.removeAll(grantedPermissions);
        return new LoginResult(newToken, grantedPermissions, deniedPermissions);
    }

    private void finishLogin(
            AccessToken newToken,
            FacebookException exception,
            boolean isCanceled,
            FacebookCallback<LoginResult>  callback) {
        if (newToken != null) {
            AccessToken.setCurrentAccessToken(newToken);
            Profile.fetchProfileForCurrentAccessToken();
        }

        if (callback != null) {
            LoginResult loginResult = newToken != null
                    ? computeLoginResult(pendingLoginRequest, newToken)
                    : null;
            
            if (isCanceled
                    || (loginResult != null
                           && loginResult.getRecentlyGrantedPermissions().size() == 0)) {
                callback.onCancel();
            } else if (exception != null) {
                callback.onError(exception);
            } else if (newToken != null) {
                callback.onSuccess(loginResult);
            }
        }

        this.pendingLoginRequest = null;
        this.loginLogger = null;
    }

    private static class ActivityStartActivityDelegate implements StartActivityDelegate {
        private final Activity activity;

        ActivityStartActivityDelegate(final Activity activity) {
            Validate.notNull(activity, "activity");
            this.activity = activity;
        }

        @Override
        public void startActivityForResult(Intent intent, int requestCode) {
            activity.startActivityForResult(intent, requestCode);
        }

        @Override
        public Activity getActivityContext() {
            return activity;
        }
    }

    private static class FragmentStartActivityDelegate implements StartActivityDelegate {
        private final Fragment fragment;

        FragmentStartActivityDelegate(final Fragment fragment) {
            Validate.notNull(fragment, "fragment");
            this.fragment = fragment;
        }

        @Override
        public void startActivityForResult(Intent intent, int requestCode) {
            fragment.startActivityForResult(intent, requestCode);
        }

        @Override
        public Activity getActivityContext() {
            return fragment.getActivity();
        }
    }
}

<code block>


package com.facebook.login;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.Intent;
import android.os.Bundle;
import android.os.Parcel;
import android.os.Parcelable;

import com.facebook.AccessToken;
import com.facebook.AccessTokenSource;
import com.facebook.FacebookException;
import com.facebook.internal.CallbackManagerImpl;
import com.facebook.internal.NativeProtocol;
import com.facebook.internal.ServerProtocol;
import com.facebook.internal.Utility;

class KatanaProxyLoginMethodHandler extends LoginMethodHandler {

    KatanaProxyLoginMethodHandler(LoginClient loginClient) {
        super(loginClient);
    }

    @Override
    String getNameForLogging() {
        return "katana_proxy_auth";
    }

    @Override
    boolean tryAuthorize(LoginClient.Request request) {
        String e2e = LoginClient.getE2E();
        Intent intent = NativeProtocol.createProxyAuthIntent(
                loginClient.getActivity(),
                request.getApplicationId(),
                request.getPermissions(),
                e2e,
                request.isRerequest(),
                request.hasPublishPermission(),
                request.getDefaultAudience());

        addLoggingExtra(ServerProtocol.DIALOG_PARAM_E2E, e2e);

        return tryIntent(intent, LoginClient.getLoginRequestCode());
    }

    @Override
    boolean onActivityResult(int requestCode, int resultCode, Intent data) {
        
        LoginClient.Result outcome;

        LoginClient.Request request = loginClient.getPendingRequest();

        if (data == null) {
            
            outcome = LoginClient.Result.createCancelResult(request, "Operation canceled");
        } else if (resultCode == Activity.RESULT_CANCELED) {
            outcome = LoginClient.Result.createCancelResult(request, data.getStringExtra("error"));
        } else if (resultCode != Activity.RESULT_OK) {
            outcome = LoginClient.Result.createErrorResult(request,
                    "Unexpected resultCode from authorization.", null);
        } else {
            outcome = handleResultOk(request, data);
        }

        if (outcome != null) {
            loginClient.completeAndValidate(outcome);
        } else {
            loginClient.tryNextHandler();
        }
        return true;
    }

    private LoginClient.Result handleResultOk(LoginClient.Request request, Intent data) {
        Bundle extras = data.getExtras();
        String error = extras.getString("error");
        if (error == null) {
            error = extras.getString("error_type");
        }
        String errorCode = extras.getString("error_code");
        String errorMessage = extras.getString("error_message");
        if (errorMessage == null) {
            errorMessage = extras.getString("error_description");
        }

        String e2e = extras.getString(NativeProtocol.FACEBOOK_PROXY_AUTH_E2E_KEY);
        if (!Utility.isNullOrEmpty(e2e)) {
            logWebLoginCompleted(e2e);
        }

        if (error == null && errorCode == null && errorMessage == null) {
            try {
                AccessToken token = createAccessTokenFromWebBundle(request.getPermissions(),
                        extras, AccessTokenSource.FACEBOOK_APPLICATION_WEB,
                        request.getApplicationId());
                return LoginClient.Result.createTokenResult(request, token);
            } catch (FacebookException ex) {
                return LoginClient.Result.createErrorResult(request, null, ex.getMessage());
            }
        } else if (ServerProtocol.errorsProxyAuthDisabled.contains(error)) {
            return null;
        } else if (ServerProtocol.errorsUserCanceled.contains(error)) {
            return LoginClient.Result.createCancelResult(request, null);
        } else {
            return LoginClient.Result.createErrorResult(request, error, errorMessage, errorCode);
        }
    }

    protected boolean tryIntent(Intent intent, int requestCode) {
        if (intent == null) {
            return false;
        }

        try {
            loginClient.getFragment().startActivityForResult(intent, requestCode);
        } catch (ActivityNotFoundException e) {
            
            
            return false;
        }

        return true;
    }

    KatanaProxyLoginMethodHandler(Parcel source) {
        super(source);
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        super.writeToParcel(dest, flags);
    }

    public static final Parcelable.Creator<KatanaProxyLoginMethodHandler> CREATOR =
            new Parcelable.Creator() {

                @Override
                public KatanaProxyLoginMethodHandler createFromParcel(Parcel source) {
                    return new KatanaProxyLoginMethodHandler(source);
                }

                @Override
                public KatanaProxyLoginMethodHandler[] newArray(int size) {
                    return new KatanaProxyLoginMethodHandler[size];
                }
            };
}

<code block>


package com.facebook.login.widget;

import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.res.Resources;
import android.content.res.TypedArray;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.os.Bundle;
import android.util.AttributeSet;
import android.view.View;
import com.facebook.*;
import com.facebook.appevents.AppEventsLogger;
import com.facebook.internal.AnalyticsEvents;
import com.facebook.internal.CallbackManagerImpl;
import com.facebook.internal.LoginAuthorizationType;
import com.facebook.internal.Utility;
import com.facebook.internal.Utility.FetchedAppSettings;
import com.facebook.login.DefaultAudience;
import com.facebook.login.LoginBehavior;
import com.facebook.login.LoginManager;
import com.facebook.login.LoginResult;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;


public class LoginButton extends FacebookButtonBase {

    
    
    

    
    public enum ToolTipMode {
        
        AUTOMATIC("automatic", 0),

        
        DISPLAY_ALWAYS("display_always", 1),

        
        NEVER_DISPLAY("never_display", 2);

        public static ToolTipMode DEFAULT = AUTOMATIC;

        public static ToolTipMode fromInt(int enumValue) {
            for (ToolTipMode mode : values()) {
                if (mode.getValue() == enumValue) {
                    return mode;
                }
            }

            return null;
        }

        private String stringValue;
        private int intValue;
        ToolTipMode(String stringValue, int value) {
            this.stringValue = stringValue;
            this.intValue = value;
        }

        @Override
        public String toString() {
            return stringValue;
        }

        public int getValue() {
            return intValue;
        }
    }

    private static final String TAG = LoginButton.class.getName();
    private boolean confirmLogout;
    private String loginText;
    private String logoutText;
    private LoginButtonProperties properties = new LoginButtonProperties();
    private String loginLogoutEventName = AnalyticsEvents.EVENT_LOGIN_VIEW_USAGE;
    private boolean toolTipChecked;
    private ToolTipPopup.Style toolTipStyle = ToolTipPopup.Style.BLUE;
    private ToolTipMode toolTipMode;
    private long toolTipDisplayTime = ToolTipPopup.DEFAULT_POPUP_DISPLAY_TIME;
    private ToolTipPopup toolTipPopup;
    private AccessTokenTracker accessTokenTracker;
    private LoginManager loginManager;

    static class LoginButtonProperties {
        private DefaultAudience defaultAudience = DefaultAudience.FRIENDS;
        private List<String> permissions = Collections.<String>emptyList();
        private LoginAuthorizationType authorizationType = null;
        private LoginBehavior loginBehavior = LoginBehavior.SSO_WITH_FALLBACK;

        public void setDefaultAudience(DefaultAudience defaultAudience) {
            this.defaultAudience = defaultAudience;
        }

        public DefaultAudience getDefaultAudience() {
            return defaultAudience;
        }

        public void setReadPermissions(List<String> permissions) {

            if (LoginAuthorizationType.PUBLISH.equals(authorizationType)) {
                throw new UnsupportedOperationException("Cannot call setReadPermissions after " +
                        "setPublishPermissions has been called.");
            }
            this.permissions = permissions;
            authorizationType = LoginAuthorizationType.READ;
        }

        public void setPublishPermissions(List<String> permissions) {

            if (LoginAuthorizationType.READ.equals(authorizationType)) {
                throw new UnsupportedOperationException("Cannot call setPublishPermissions after " +
                        "setReadPermissions has been called.");
            }
            if (Utility.isNullOrEmpty(permissions)) {
                throw new IllegalArgumentException(
                        "Permissions for publish actions cannot be null or empty.");
            }
            this.permissions = permissions;
            authorizationType = LoginAuthorizationType.PUBLISH;
        }

        List<String> getPermissions() {
            return permissions;
        }

        public void clearPermissions() {
            permissions = null;
            authorizationType = null;
        }

        public void setLoginBehavior(LoginBehavior loginBehavior) {
            this.loginBehavior = loginBehavior;
        }

        public LoginBehavior getLoginBehavior() {
            return loginBehavior;
        }
    }

    
    public LoginButton(Context context) {
        super(
                context,
                null,
                0,
                0,
                AnalyticsEvents.EVENT_LOGIN_BUTTON_CREATE);
    }

    
    public LoginButton(Context context, AttributeSet attrs) {
        super(
                context,
                attrs,
                0,
                0,
                AnalyticsEvents.EVENT_LOGIN_BUTTON_CREATE);
    }

    
    public LoginButton(Context context, AttributeSet attrs, int defStyle) {
        super(
                context,
                attrs,
                defStyle,
                0,
                AnalyticsEvents.EVENT_LOGIN_BUTTON_CREATE);
    }

    
    public void setDefaultAudience(DefaultAudience defaultAudience) {
        properties.setDefaultAudience(defaultAudience);
    }

    
    public DefaultAudience getDefaultAudience() {
        return properties.getDefaultAudience();
    }

    
    public void setReadPermissions(List<String> permissions) {
        properties.setReadPermissions(permissions);
    }

    
    public void setReadPermissions(String... permissions) {
        properties.setReadPermissions(Arrays.asList(permissions));
    }


    
    public void setPublishPermissions(List<String> permissions) {
        properties.setPublishPermissions(permissions);
    }

    
    public void setPublishPermissions(String... permissions) {
        properties.setPublishPermissions(Arrays.asList(permissions));
    }


    
    public void clearPermissions() {
        properties.clearPermissions();
    }

    
    public void setLoginBehavior(LoginBehavior loginBehavior) {
        properties.setLoginBehavior(loginBehavior);
    }

    
    public LoginBehavior getLoginBehavior() {
        return properties.getLoginBehavior();
    }

    
    public void setToolTipStyle(ToolTipPopup.Style toolTipStyle) {
        this.toolTipStyle = toolTipStyle;
    }

    
    public void setToolTipMode(ToolTipMode toolTipMode) {
        this.toolTipMode = toolTipMode;
    }

    
    public ToolTipMode getToolTipMode() {
        return toolTipMode;
    }

    
    public void setToolTipDisplayTime(long displayTime) {
        this.toolTipDisplayTime = displayTime;
    }

    
    public long getToolTipDisplayTime() {
        return toolTipDisplayTime;
    }

    
    public void dismissToolTip() {
        if (toolTipPopup != null) {
            toolTipPopup.dismiss();
            toolTipPopup = null;
        }
    }

    
    public void registerCallback(
            final CallbackManager callbackManager,
            final FacebookCallback<LoginResult> callback) {
        getLoginManager().registerCallback(callbackManager, callback);
    }

    @Override
    protected void onAttachedToWindow() {
        super.onAttachedToWindow();
        if (accessTokenTracker != null && !accessTokenTracker.isTracking()) {
            accessTokenTracker.startTracking();
            setButtonText();
        }
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);

        if (!toolTipChecked && !isInEditMode()) {
            toolTipChecked = true;
            checkToolTipSettings();
        }
    }

    private void showToolTipPerSettings(FetchedAppSettings settings) {
        if (settings != null && settings.getNuxEnabled() && getVisibility() == View.VISIBLE) {
            String toolTipString = settings.getNuxContent();
            displayToolTip(toolTipString);
        }
    }

    private void displayToolTip(String toolTipString) {
        toolTipPopup = new ToolTipPopup(toolTipString, this);
        toolTipPopup.setStyle(toolTipStyle);
        toolTipPopup.setNuxDisplayTime(toolTipDisplayTime);
        toolTipPopup.show();
    }

    private void checkToolTipSettings() {
        switch (toolTipMode) {
            case AUTOMATIC:
                
                final String appId = Utility.getMetadataApplicationId(getContext());
                FacebookSdk.getExecutor().execute(new Runnable() {
                    @Override
                    public void run() {
                        final FetchedAppSettings settings = Utility.queryAppSettings(appId, false);
                        getActivity().runOnUiThread(new Runnable() {
                            @Override
                            public void run() {
                                showToolTipPerSettings(settings);
                            }
                        });
                    }
                });
                break;
            case DISPLAY_ALWAYS:
                String toolTipString = getResources().getString(
                        R.string.com_facebook_tooltip_default);
                displayToolTip(toolTipString);
                break;
            case NEVER_DISPLAY:
                break;
        }
    }

    @Override
    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
        super.onLayout(changed, left, top, right, bottom);
        setButtonText();
    }

    @Override
    protected void onDetachedFromWindow() {
        super.onDetachedFromWindow();
        if (accessTokenTracker != null) {
            accessTokenTracker.stopTracking();
        }
        dismissToolTip();
    }

    @Override
    protected void onVisibilityChanged(View changedView, int visibility) {
        super.onVisibilityChanged(changedView, visibility);
        
        if (visibility != VISIBLE) {
            dismissToolTip();
        }
    }

    
    List<String> getPermissions() {
        return properties.getPermissions();
    }

    void setProperties(LoginButtonProperties properties) {
        this.properties = properties;
    }

    @Override
    protected void configureButton(
            final Context context,
            final AttributeSet attrs,
            final int defStyleAttr,
            final int defStyleRes) {
        super.configureButton(context, attrs, defStyleAttr, defStyleRes);
        setInternalOnClickListener(new LoginClickListener());

        parseLoginButtonAttributes(context, attrs, defStyleAttr, defStyleRes);

        if (isInEditMode()) {
            
            
            setBackgroundColor(getResources().getColor(R.color.com_facebook_blue));
            
            
            loginText = "Log in with Facebook";
        } else {
            accessTokenTracker = new AccessTokenTracker() {
                @Override
                protected void onCurrentAccessTokenChanged(
                        AccessToken oldAccessToken,
                        AccessToken currentAccessToken) {
                    setButtonText();
                }
            };
        }

        setButtonText();
    }

    @Override
    protected int getDefaultStyleResource() {
        return R.style.com_facebook_loginview_default_style;
    }

    private void parseLoginButtonAttributes(
            final Context context,
            final AttributeSet attrs,
            final int defStyleAttr,
            final int defStyleRes) {
        this.toolTipMode = ToolTipMode.DEFAULT;
        final TypedArray a = context.getTheme().obtainStyledAttributes(
                attrs,
                R.styleable.com_facebook_login_view,
                defStyleAttr,
                defStyleRes);
        try {
            confirmLogout = a.getBoolean(R.styleable.com_facebook_login_view_com_facebook_confirm_logout, true);
            loginText = a.getString(R.styleable.com_facebook_login_view_com_facebook_login_text);
            logoutText = a.getString(R.styleable.com_facebook_login_view_com_facebook_logout_text);
            toolTipMode = ToolTipMode.fromInt(a.getInt(
                    R.styleable.com_facebook_login_view_com_facebook_tooltip_mode,
                    ToolTipMode.DEFAULT.getValue()));
        } finally {
            a.recycle();
        }
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        Paint.FontMetrics fontMetrics = getPaint().getFontMetrics();
        int height = (getCompoundPaddingTop() +
                (int)Math.ceil(Math.abs(fontMetrics.top) + Math.abs(fontMetrics.bottom)) +
                getCompoundPaddingBottom());

        final Resources resources = getResources();
        String text = loginText;
        int logInWidth;
        int width;
        if (text == null) {
            text = resources.getString(R.string.com_facebook_loginview_log_in_button_long);
            logInWidth = measureButtonWidth(text);
            width = resolveSize(logInWidth, widthMeasureSpec);
            if (width < logInWidth) {
                text = resources.getString(R.string.com_facebook_loginview_log_in_button);
            }
        }
        logInWidth = measureButtonWidth(text);

        text = logoutText;
        if (text == null) {
            text = resources.getString(R.string.com_facebook_loginview_log_out_button);
        }
        int logOutWidth = measureButtonWidth(text);

        width = resolveSize(Math.max(logInWidth, logOutWidth), widthMeasureSpec);
        setMeasuredDimension(width, height);
    }

    private int measureButtonWidth(final String text) {
        int textWidth = measureTextWidth(text);
        int width = (getCompoundPaddingLeft() +
                getCompoundDrawablePadding() +
                textWidth +
                getCompoundPaddingRight());
        return width;
    }

    private void setButtonText() {
        final Resources resources = getResources();
        if (!isInEditMode() && AccessToken.getCurrentAccessToken() != null) {
            setText((logoutText != null) ?
                    logoutText :
                    resources.getString(R.string.com_facebook_loginview_log_out_button));
        } else {
            if (loginText != null) {
                setText(loginText);
            } else {
                String text = resources.getString(
                        R.string.com_facebook_loginview_log_in_button_long);
                int width = getWidth();
                
                if (width != 0) {
                    
                    int measuredWidth = measureButtonWidth(text);
                    if (measuredWidth > width) {
                        
                        text = resources.getString(R.string.com_facebook_loginview_log_in_button);
                    }
                }
                setText(text);
            }
        }
    }

    @Override
    protected int getDefaultRequestCode() {
        return CallbackManagerImpl.RequestCodeOffset.Login.toRequestCode();
    }

    private class LoginClickListener implements OnClickListener {

        @Override
        public void onClick(View v) {
            callExternalOnClickListener(v);

            Context context = getContext();

            AccessToken accessToken = AccessToken.getCurrentAccessToken();

            if (accessToken != null) {
                
                if (confirmLogout) {
                    
                    String logout = getResources().getString(
                            R.string.com_facebook_loginview_log_out_action);
                    String cancel = getResources().getString(
                            R.string.com_facebook_loginview_cancel_action);
                    String message;
                    Profile profile = Profile.getCurrentProfile();
                    if (profile != null && profile.getName() != null) {
                        message = String.format(
                                getResources().getString(
                                        R.string.com_facebook_loginview_logged_in_as),
                                profile.getName());
                    } else {
                        message = getResources().getString(
                                R.string.com_facebook_loginview_logged_in_using_facebook);
                    }
                    AlertDialog.Builder builder = new AlertDialog.Builder(context);
                    builder.setMessage(message)
                            .setCancelable(true)
                            .setPositiveButton(logout, new DialogInterface.OnClickListener() {
                                public void onClick(DialogInterface dialog, int which) {
                                    getLoginManager().logOut();
                                }
                            })
                            .setNegativeButton(cancel, null);
                    builder.create().show();
                } else {
                    getLoginManager().logOut();
                }
            } else {
                LoginManager loginManager = getLoginManager();
                loginManager.setDefaultAudience(getDefaultAudience());
                loginManager.setLoginBehavior(getLoginBehavior());

                if (LoginAuthorizationType.PUBLISH.equals(properties.authorizationType)) {
                    if (LoginButton.this.getFragment() != null) {
                        loginManager.logInWithPublishPermissions(
                                LoginButton.this.getFragment(),
                                properties.permissions);
                    } else {
                        loginManager.logInWithPublishPermissions(
                                LoginButton.this.getActivity(),
                                properties.permissions);
                    }
                } else {
                    if (LoginButton.this.getFragment() != null) {
                        loginManager.logInWithReadPermissions(
                                LoginButton.this.getFragment(),
                                properties.permissions);
                    } else {
                        loginManager.logInWithReadPermissions(
                                LoginButton.this.getActivity(),
                                properties.permissions);
                    }
                }
            }

            AppEventsLogger logger = AppEventsLogger.newLogger(getContext());

            Bundle parameters = new Bundle();
            parameters.putInt("logging_in", (accessToken != null) ? 0 : 1);

            logger.logSdkEvent(loginLogoutEventName, null, parameters);
        }
    }

    LoginManager getLoginManager() {
        if (loginManager == null) {
            loginManager = LoginManager.getInstance();
        }
        return loginManager;
    }

    void setLoginManager(LoginManager loginManager) {
        this.loginManager = loginManager;
    }
}

<code block>


package com.facebook;

import android.app.Activity;

import com.facebook.junittests.MainActivity;

import org.junit.Test;
import org.robolectric.Robolectric;

import static org.junit.Assert.*;

public class ApplicationTest extends FacebookTestCase {
    @Test
    public void testCreateActivity() throws Exception {
        Activity activity = Robolectric.buildActivity(MainActivity.class).create().get();
        assertTrue(activity != null);
    }
}

<code block>


package com.facebook;

import android.graphics.Bitmap;
import android.location.Location;
import android.net.Uri;
import android.os.Bundle;

import com.facebook.internal.GraphUtil;
import com.facebook.internal.ServerProtocol;
import com.facebook.share.internal.ShareInternalUtility;

import org.json.JSONException;
import org.json.JSONObject;
import org.junit.Before;
import org.junit.Test;
import org.powermock.core.classloader.annotations.PrepareForTest;

import java.net.HttpURLConnection;

import static org.junit.Assert.*;
import static org.powermock.api.mockito.PowerMockito.mockStatic;
import static org.powermock.api.mockito.PowerMockito.when;

@PrepareForTest( { FacebookSdk.class, AccessTokenManager.class })
public class GraphRequestTest extends FacebookPowerMockTestCase {

    @Before
    public void before() {
        mockStatic(FacebookSdk.class);
        when(FacebookSdk.isInitialized()).thenReturn(true);
        when(FacebookSdk.getApplicationId()).thenReturn("1234");
        when(FacebookSdk.getClientToken()).thenReturn("5678");
    }

    @Test
    public void testCreateRequest() {
        GraphRequest request = new GraphRequest();
        assertTrue(request != null);
        assertEquals(HttpMethod.GET, request.getHttpMethod());
    }

    @Test
    public void testCreatePostRequest() {
        JSONObject graphObject = new JSONObject();
        GraphRequest request = GraphRequest.newPostRequest(null, "me/statuses", graphObject, null);
        assertTrue(request != null);
        assertEquals(HttpMethod.POST, request.getHttpMethod());
        assertEquals("me/statuses", request.getGraphPath());
        assertEquals(graphObject, request.getGraphObject());
    }

    @Test
    public void testCreateMeRequest() {
        GraphRequest request = GraphRequest.newMeRequest(null, null);
        assertTrue(request != null);
        assertEquals(HttpMethod.GET, request.getHttpMethod());
        assertEquals("me", request.getGraphPath());
    }

    @Test
    public void testCreateMyFriendsRequest() {
        GraphRequest request = GraphRequest.newMyFriendsRequest(null, null);
        assertTrue(request != null);
        assertEquals(HttpMethod.GET, request.getHttpMethod());
        assertEquals("me/friends", request.getGraphPath());
    }

    @Test
    public void testCreateUploadPhotoRequest() {
        Bitmap image = Bitmap.createBitmap(128, 128, Bitmap.Config.ALPHA_8);

        GraphRequest request =
                ShareInternalUtility.newUploadPhotoRequest(
                        ShareInternalUtility.MY_PHOTOS,
                        null,
                        image,
                        null,
                        null,
                        null);
        assertTrue(request != null);

        Bundle parameters = request.getParameters();
        assertTrue(parameters != null);

        assertTrue(parameters.containsKey("picture"));
        assertEquals(image, parameters.getParcelable("picture"));
        assertEquals("me/photos", request.getGraphPath());
    }

    @Test
    public void testCreatePlacesSearchRequestWithLocation() {
        Location location = new Location("");
        location.setLatitude(47.6204);
        location.setLongitude(-122.3491);

        GraphRequest request = GraphRequest.newPlacesSearchRequest(null, location, 1000, 50, null, null);

        assertTrue(request != null);
        assertEquals(HttpMethod.GET, request.getHttpMethod());
        assertEquals("search", request.getGraphPath());
    }

    @Test
    public void testCreatePlacesSearchRequestWithSearchText() {
        GraphRequest request = GraphRequest.newPlacesSearchRequest(null, null, 1000, 50, "Starbucks", null);

        assertTrue(request != null);
        assertEquals(HttpMethod.GET, request.getHttpMethod());
        assertEquals("search", request.getGraphPath());
    }

    @Test
    public void testCreatePlacesSearchRequestRequiresLocationOrSearchText() {
        try {
            GraphRequest.newPlacesSearchRequest(null, null, 1000, 50, null, null);
            fail("expected exception");
        } catch (FacebookException exception) {
            
        }
    }

    @Test
    public void testNewPostOpenGraphObjectRequestRequiresObject() {
        try {
            ShareInternalUtility.newPostOpenGraphObjectRequest(null, null, null);
            fail("expected exception");
        } catch (FacebookException exception) {
            
        }
    }

    @Test
    public void testNewPostOpenGraphObjectRequestRequiresObjectType() {
        try {
            JSONObject object = GraphUtil.createOpenGraphObjectForPost(null);
            ShareInternalUtility.newPostOpenGraphObjectRequest(null, object, null);
            fail("expected exception");
        } catch (FacebookException exception) {
            
        }
    }

    @Test
    public void testNewPostOpenGraphObjectRequestRequiresNonEmptyObjectType() throws JSONException {
        try {
            JSONObject object = GraphUtil.createOpenGraphObjectForPost("");
            object.put("title", "bar");
            ShareInternalUtility.newPostOpenGraphObjectRequest(null, object, null);
            fail("expected exception");
        } catch (FacebookException exception) {
            
        }
    }

    @Test
    public void testNewPostOpenGraphObjectRequestRequiresTitle() {
        try {
            JSONObject object = GraphUtil.createOpenGraphObjectForPost("foo");
            ShareInternalUtility.newPostOpenGraphObjectRequest(null, object, null);
            fail("expected exception");
        } catch (FacebookException exception) {
            
        }
    }

    @Test
    public void testNewPostOpenGraphObjectRequestRequiresNonEmptyTitle() throws JSONException {
        try {
            JSONObject object = GraphUtil.createOpenGraphObjectForPost("foo");
            object.put("title", "");
            ShareInternalUtility.newPostOpenGraphObjectRequest(null, object, null);
            fail("expected exception");
        } catch (FacebookException exception) {
            
        }
    }

    @Test
    public void testNewPostOpenGraphObjectRequest() throws JSONException {
        JSONObject object = GraphUtil.createOpenGraphObjectForPost("foo");
        object.put("title", "bar");
        GraphRequest request = ShareInternalUtility.newPostOpenGraphObjectRequest(
                null,
                object,
                null);
        assertNotNull(request);
    }

    @Test
    public void testNewPostOpenGraphActionRequestRequiresAction() {
        try {
            ShareInternalUtility.newPostOpenGraphActionRequest(null, null, null);
            fail("expected exception");
        } catch (FacebookException exception) {
            
        }
    }

    @Test
    public void testNewPostOpenGraphActionRequestRequiresActionType() {
        try {
            JSONObject action = GraphUtil.createOpenGraphActionForPost(null);
            ShareInternalUtility.newPostOpenGraphActionRequest(null, action, null);
            fail("expected exception");
        } catch (FacebookException exception) {
            
        }
    }

    @Test
    public void testNewPostOpenGraphActionRequestRequiresNonEmptyActionType() {
        try {
            JSONObject action = GraphUtil.createOpenGraphActionForPost("");
            ShareInternalUtility.newPostOpenGraphActionRequest(null, action, null);
            fail("expected exception");
        } catch (FacebookException exception) {
            
        }
    }

    @Test
    public void testNewPostOpenGraphActionRequest() {
        JSONObject action = GraphUtil.createOpenGraphActionForPost("foo");
        GraphRequest request = ShareInternalUtility.newPostOpenGraphActionRequest(
                null,
                action,
                null);
        assertNotNull(request);
    }

    @Test
    public void testSetHttpMethodToNilGivesDefault() {
        GraphRequest request = new GraphRequest();
        assertEquals(HttpMethod.GET, request.getHttpMethod());

        request.setHttpMethod(null);
        assertEquals(HttpMethod.GET, request.getHttpMethod());
    }

    @Test
    public void testExecuteBatchWithNullRequestsThrows() {
        try {
            GraphRequest.executeBatchAndWait((GraphRequest[]) null);
            fail("expected NullPointerException");
        } catch (NullPointerException exception) {
        }
    }

    @Test
    public void testExecuteBatchWithZeroRequestsThrows() {
        try {
            GraphRequest.executeBatchAndWait(new GraphRequest[]{});
            fail("expected IllegalArgumentException");
        } catch (IllegalArgumentException exception) {
        }
    }

    @Test
    public void testExecuteBatchWithNullRequestThrows() {
        try {
            GraphRequest.executeBatchAndWait(new GraphRequest[]{null});
            fail("expected NullPointerException");
        } catch (NullPointerException exception) {
        }
    }

    @Test
    public void testToHttpConnectionWithNullRequestsThrows() {
        try {
            GraphRequest.toHttpConnection((GraphRequest[]) null);
            fail("expected NullPointerException");
        } catch (NullPointerException exception) {
        }
    }

    @Test
    public void testToHttpConnectionWithZeroRequestsThrows() {
        try {
            GraphRequest.toHttpConnection(new GraphRequest[]{});
            fail("expected IllegalArgumentException");
        } catch (IllegalArgumentException exception) {
        }
    }

    @Test
    public void testToHttpConnectionWithNullRequestThrows() {
        try {
            GraphRequest.toHttpConnection(new GraphRequest[]{null});
            fail("expected NullPointerException");
        } catch (NullPointerException exception) {
        }
    }

    @Test
    public void testSingleGetToHttpRequest() throws Exception {
        GraphRequest requestMe = new GraphRequest(null, "TourEiffel");
        HttpURLConnection connection = GraphRequest.toHttpConnection(requestMe);

        assertTrue(connection != null);

        assertEquals("GET", connection.getRequestMethod());
        assertEquals("/" + ServerProtocol.getAPIVersion() + "/TourEiffel",
            connection.getURL().getPath());

        assertTrue(connection.getRequestProperty("User-Agent").startsWith("FBAndroidSDK"));

        Uri uri = Uri.parse(connection.getURL().toString());
        assertEquals("android", uri.getQueryParameter("sdk"));
        assertEquals("json", uri.getQueryParameter("format"));
    }

    @Test
    public void testBuildsClientTokenIfNeeded() throws Exception {
        GraphRequest requestMe = new GraphRequest(null, "TourEiffel");
        HttpURLConnection connection = GraphRequest.toHttpConnection(requestMe);

        assertTrue(connection != null);

        Uri uri = Uri.parse(connection.getURL().toString());
        String accessToken = uri.getQueryParameter("access_token");
        assertNotNull(accessToken);
        assertTrue(accessToken.contains(FacebookSdk.getApplicationId()));
        assertTrue(accessToken.contains(FacebookSdk.getClientToken()));
    }
}

<code block>


package com.facebook.login;

import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentActivity;

import com.facebook.AccessToken;
import com.facebook.FacebookPowerMockTestCase;
import com.facebook.FacebookSdk;
import com.facebook.TestUtils;

import org.junit.Before;
import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.robolectric.Robolectric;
import org.robolectric.RuntimeEnvironment;

import java.util.Arrays;
import java.util.HashSet;

import static org.junit.Assert.*;
import static org.mockito.Mockito.verify;
import static org.powermock.api.mockito.PowerMockito.mock;
import static org.powermock.api.mockito.PowerMockito.when;

@PrepareForTest({ LoginClient.class })
public class LoginClientTest extends FacebookPowerMockTestCase {

    private static final String ACCESS_TOKEN = "An access token for user 1";
    private static final String USER_ID = "1001";
    private static final String APP_ID = "2002";


    private static final long EXPIRES_IN_DELTA = 3600 * 24 * 60;
    private static final HashSet<String> PERMISSIONS = new HashSet<String>(
        Arrays.asList("go outside", "come back in"));
    private static final String ERROR_MESSAGE = "This is bad!";

    @Mock private Fragment mockFragment;

    @Before
    public void before() throws Exception {
        FragmentActivity activity =
            Robolectric.buildActivity(FragmentActivity.class).create().get();
        when(mockFragment.getActivity()).thenReturn(activity);
    }

    @Test
    public void testReauthorizationWithSameFbidSucceeds() throws Exception {
        FacebookSdk.sdkInitialize(RuntimeEnvironment.application);
        LoginClient.Request request = createRequest(ACCESS_TOKEN);

        AccessToken token = new AccessToken(
                ACCESS_TOKEN,
                APP_ID,
                USER_ID,
                PERMISSIONS,
                null,
                null,
                null,
                null);
        LoginClient.Result result = LoginClient.Result.createTokenResult(request, token);

        LoginClient.OnCompletedListener listener = mock(LoginClient.OnCompletedListener.class);

        LoginClient client = new LoginClient(mockFragment);
        client.setOnCompletedListener(listener);

        client.completeAndValidate(result);

        ArgumentCaptor<LoginClient.Result> resultArgumentCaptor =
            ArgumentCaptor.forClass(LoginClient.Result.class);

        verify(listener).onCompleted(resultArgumentCaptor.capture());

        result = resultArgumentCaptor.getValue();

        assertNotNull(result);
        assertEquals(LoginClient.Result.Code.SUCCESS, result.code);

        AccessToken resultToken = result.token;
        assertNotNull(resultToken);
        assertEquals(ACCESS_TOKEN, resultToken.getToken());

        
        assertEquals(PERMISSIONS, resultToken.getPermissions());
    }

    @Test
    public void testRequestParceling() {
        LoginClient.Request request = createRequest(ACCESS_TOKEN);

        LoginClient.Request unparceledRequest = TestUtils.parcelAndUnparcel(request);

        assertEquals(LoginBehavior.SSO_WITH_FALLBACK, unparceledRequest.getLoginBehavior());
        assertEquals(new HashSet<String>(PERMISSIONS), unparceledRequest.getPermissions());
        assertEquals(DefaultAudience.FRIENDS, unparceledRequest.getDefaultAudience());
        assertEquals("1234", unparceledRequest.getApplicationId());
        assertEquals("5678", unparceledRequest.getAuthId());
        assertFalse(unparceledRequest.isRerequest());
    }

    @Test
    public void testResultParceling() {
        LoginClient.Request request = new LoginClient.Request(
                LoginBehavior.SUPPRESS_SSO,
                null,
                DefaultAudience.EVERYONE,
                null,
                null);
        request.setRerequest(true);
        AccessToken token1 = new AccessToken(
                "Token2",
                "12345",
                "1000",
                null,
                null,
                null,
                null,
                null);
        LoginClient.Result result = new LoginClient.Result(
                request,
                LoginClient.Result.Code.SUCCESS,
                token1,
                "error 1",
                "123"
        );

        LoginClient.Result unparceledResult = TestUtils.parcelAndUnparcel(result);
        LoginClient.Request unparceledRequest = unparceledResult.request;

        assertEquals(LoginBehavior.SUPPRESS_SSO, unparceledRequest.getLoginBehavior());
        assertEquals(new HashSet<String>(), unparceledRequest.getPermissions());
        assertEquals(DefaultAudience.EVERYONE, unparceledRequest.getDefaultAudience());
        assertEquals(null, unparceledRequest.getApplicationId());
        assertEquals(null, unparceledRequest.getAuthId());
        assertTrue(unparceledRequest.isRerequest());

        assertEquals(LoginClient.Result.Code.SUCCESS, unparceledResult.code);
        assertEquals(token1, unparceledResult.token);
        assertEquals("error 1", unparceledResult.errorMessage);
        assertEquals("123", unparceledResult.errorCode);
    }


    protected LoginClient.Request createRequest(String previousAccessTokenString) {
        return new LoginClient.Request(
                LoginBehavior.SSO_WITH_FALLBACK,
                new HashSet<String>(PERMISSIONS),
                DefaultAudience.FRIENDS,
                "1234",
                "5678");
    }

}

<code block>


package com.facebook.login;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentActivity;

import com.facebook.AccessToken;
import com.facebook.AccessTokenSource;
import com.facebook.FacebookActivity;
import com.facebook.FacebookCallback;
import com.facebook.FacebookException;
import com.facebook.FacebookPowerMockTestCase;
import com.facebook.FacebookSdk;
import com.facebook.FacebookSdkNotInitializedException;
import com.facebook.Profile;

import org.apache.maven.profiles.ProfileManager;
import org.junit.Before;
import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.powermock.core.classloader.annotations.PrepareForTest;

import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ThreadPoolExecutor;

import static org.junit.Assert.*;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.eq;
import static org.mockito.Matchers.isA;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.powermock.api.mockito.PowerMockito.*;

@PrepareForTest({ FacebookSdk.class, AccessToken.class, Profile.class})
public class LoginManagerTest extends FacebookPowerMockTestCase {

    private static final String MOCK_APP_ID = "1234";
    private static final String USER_ID = "1000";
    private final String TOKEN_STRING = "A token of my esteem";
    private final List<String> PERMISSIONS = Arrays.asList("walk", "chew gum");
    private final Date EXPIRES = new Date(2025, 5, 3);
    private final Date LAST_REFRESH = new Date(2023, 8, 15);

    @Mock private Activity mockActivity;
    @Mock private Fragment mockFragment;
    @Mock private Context mockApplicationContext;
    @Mock private PackageManager mockPackageManager;
    @Mock private FacebookCallback<LoginResult> mockCallback;
    @Mock private ThreadPoolExecutor threadExecutor;
    @Mock private FragmentActivity mockFragmentActivity;

    @Before
    public void before() throws Exception {
        mockStatic(FacebookSdk.class);
        stub(method(AccessToken.class, "getCurrentAccessToken")).toReturn(null);
        stub(method(AccessToken.class, "setCurrentAccessToken")).toReturn(null);
        stub(method(Profile.class, "fetchProfileForCurrentAccessToken")).toReturn(null);

        when(FacebookSdk.isInitialized()).thenReturn(true);
        when(FacebookSdk.getApplicationId()).thenReturn(MOCK_APP_ID);
        when(FacebookSdk.getApplicationContext()).thenReturn(mockApplicationContext);
        when(FacebookSdk.getExecutor()).thenReturn(threadExecutor);
        when(mockFragment.getActivity()).thenReturn(mockFragmentActivity);

        
        
        ResolveInfo resolveInfo = new ResolveInfo();
        when(mockApplicationContext.getPackageManager()).thenReturn(mockPackageManager);
        when(mockPackageManager.resolveActivity(any(Intent.class), anyInt()))
                .thenReturn(resolveInfo);
    }

    @Test
    public void testRequiresSdkToBeInitialized() {
        try {
            when(FacebookSdk.isInitialized()).thenReturn(false);

            LoginManager loginManager = new LoginManager();

            fail();
        } catch (FacebookSdkNotInitializedException exception) {
        }
    }

    @Test
    public void testGetInstance() {
        LoginManager loginManager = LoginManager.getInstance();
        assertNotNull(loginManager);
    }

    @Test
    public void testLoginBehaviorDefaultsToSsoWithFallback() {
        LoginManager loginManager = new LoginManager();
        assertEquals(LoginBehavior.SSO_WITH_FALLBACK, loginManager.getLoginBehavior());
    }

    @Test
    public void testCanChangeLoginBehavior() {
        LoginManager loginManager = new LoginManager();
        loginManager.setLoginBehavior(LoginBehavior.SSO_ONLY);
        assertEquals(LoginBehavior.SSO_ONLY, loginManager.getLoginBehavior());
    }

    @Test
    public void testDefaultAudienceDefaultsToFriends() {
        LoginManager loginManager = new LoginManager();
        assertEquals(DefaultAudience.FRIENDS, loginManager.getDefaultAudience());
    }

    @Test
    public void testCanChangeDefaultAudience() {
        LoginManager loginManager = new LoginManager();
        loginManager.setDefaultAudience(DefaultAudience.EVERYONE);
        assertEquals(DefaultAudience.EVERYONE, loginManager.getDefaultAudience());
    }

    @Test
    public void testLogInWithReadAndActivityThrowsIfPublishPermissionGiven() {
        LoginManager loginManager = new LoginManager();
        try {
            loginManager.logInWithReadPermissions(mockActivity,
                Arrays.asList("public_profile", "publish_actions"));
            fail();
        } catch(FacebookException exception) {
        }
    }

    @Test
    public void testLogInWithPublishAndActivityThrowsIfPublishPermissionGiven() {
        LoginManager loginManager = new LoginManager();
        try {
            loginManager.logInWithPublishPermissions(mockActivity,
                Arrays.asList("public_profile", "publish_actions"));
            fail();
        } catch(FacebookException exception) {
        }
    }

    @Test
    public void testLogInThrowsIfCannotResolveFacebookActivity() {
        when(mockPackageManager.resolveActivity(any(Intent.class), anyInt())).thenReturn(null);

        LoginManager loginManager = new LoginManager();

        try {
            loginManager.logInWithReadPermissions(mockActivity,
                Arrays.asList("public_profile", "user_friends"));
            fail();
        } catch(FacebookException exception) {
        }
    }

    @Test
    public void testLogInThrowsIfCannotStartFacebookActivity() {
        doThrow(new ActivityNotFoundException()).when(mockActivity)
            .startActivityForResult(any(Intent.class), anyInt());

        LoginManager loginManager = new LoginManager();

        try {
            loginManager.logInWithReadPermissions(mockActivity,
                Arrays.asList("public_profile", "user_friends"));
            fail();
        } catch(FacebookException exception) {
        }
    }

    @Test
    public void testRequiresNonNullActivity() {
        try {
            LoginManager loginManager = new LoginManager();
            loginManager.logInWithReadPermissions((Activity) null,
                Arrays.asList("public_profile", "user_friends"));
            fail();
        } catch (NullPointerException exception) {
        }
    }

    @Test
    public void testRequiresNonNullFragment() {
        try {
            LoginManager loginManager = new LoginManager();
            loginManager.logInWithReadPermissions((Fragment) null,
                    Arrays.asList("public_profile", "user_friends"));
            fail();
        } catch (NullPointerException exception) {
        }
    }

    @Test
    public void testLogInWithReadDoesNotThrowWithReadPermissions() {
        LoginManager loginManager = new LoginManager();
        loginManager.logInWithReadPermissions(mockActivity,
            Arrays.asList("public_profile", "user_friends"));
    }

    @Test
    public void testLogInWithReadListCreatesPendingRequestWithCorrectValues() {
        LoginManager loginManager = new LoginManager();
        
        loginManager.setLoginBehavior(LoginBehavior.SSO_ONLY);
        loginManager.setDefaultAudience(DefaultAudience.EVERYONE);
        loginManager.logInWithReadPermissions(mockActivity,
            Arrays.asList("public_profile", "user_friends"));

        implTestLogInCreatesPendingRequestWithCorrectValues(loginManager,
                Arrays.asList("public_profile", "user_friends"));
    }

    @Test
    public void testLogInWithReadAndAccessTokenCreatesReauthRequest() {
        AccessToken accessToken = createAccessToken();
        stub(method(AccessToken.class, "getCurrentAccessToken")).toReturn(accessToken);

        LoginManager loginManager = new LoginManager();
        loginManager.logInWithReadPermissions(mockActivity,
            Arrays.asList("public_profile", "user_friends"));

        LoginClient.Request request = loginManager.getPendingLoginRequest();
        assertNotNull(loginManager.getPendingLoginRequest());
    }

    public void implTestLogInCreatesPendingRequestWithCorrectValues(
            LoginManager loginManager,
            Collection<String> expectedPermissions) {

        LoginClient.Request request = loginManager.getPendingLoginRequest();

        assertNotNull(request);

        assertEquals(MOCK_APP_ID, request.getApplicationId());
        assertEquals(LoginBehavior.SSO_ONLY, request.getLoginBehavior());
        assertEquals(DefaultAudience.EVERYONE, request.getDefaultAudience());

        Set<String> permissions = request.getPermissions();
        for (String permission : expectedPermissions) {
            assertTrue(permissions.contains(permission));

        }
    }

    @Test
    public void testLogInWithReadAndActivityStartsFacebookActivityWithCorrectRequest() {

        LoginManager loginManager = new LoginManager();
        loginManager.logInWithReadPermissions(mockActivity,
            Arrays.asList("public_profile", "user_friends"));

        ArgumentCaptor<Intent> intentArgumentCaptor = ArgumentCaptor.forClass(Intent.class);
        verify(mockActivity).startActivityForResult(intentArgumentCaptor.capture(), anyInt());
        Intent intent = intentArgumentCaptor.getValue();

        ComponentName componentName = intent.getComponent();
        assertEquals(FacebookActivity.class.getName(), componentName.getClassName());
        assertEquals(LoginBehavior.SSO_WITH_FALLBACK.name(), intent.getAction());
    }

    @Test
    public void testLogInWithReadAndFragmentStartsFacebookActivityWithCorrectRequest() {

        LoginManager loginManager = new LoginManager();
        loginManager.logInWithReadPermissions(mockFragment,
                Arrays.asList("public_profile", "user_friends"));

        ArgumentCaptor<Intent> intentArgumentCaptor = ArgumentCaptor.forClass(Intent.class);
        verify(mockFragment).startActivityForResult(intentArgumentCaptor.capture(), anyInt());
        Intent intent = intentArgumentCaptor.getValue();

        ComponentName componentName = intent.getComponent();
        assertEquals(FacebookActivity.class.getName(), componentName.getClassName());
        assertEquals(LoginBehavior.SSO_WITH_FALLBACK.name(), intent.getAction());
    }

    @Test
    public void testLogInWitPublishDoesNotThrowWithPublishPermissions() {
        LoginManager loginManager = new LoginManager();
        loginManager.logInWithPublishPermissions(mockActivity,
            Arrays.asList("publish_actions", "publish_stream"));
    }

    @Test
    public void testLogInWithPublishListCreatesPendingRequestWithCorrectValues() {
        LoginManager loginManager = new LoginManager();
        
        loginManager.setLoginBehavior(LoginBehavior.SSO_ONLY);
        loginManager.setDefaultAudience(DefaultAudience.EVERYONE);
        loginManager.logInWithPublishPermissions(mockActivity,
            Arrays.asList("publish_actions", "publish_stream"));

        implTestLogInCreatesPendingRequestWithCorrectValues(loginManager,
            Arrays.asList("publish_actions", "publish_stream"));
    }

    @Test
    public void testLogInWithPublishAndAccessTokenCreatesReauthRequest() {
        AccessToken accessToken = createAccessToken();
        stub(method(AccessToken.class, "getCurrentAccessToken")).toReturn(accessToken);

        LoginManager loginManager = new LoginManager();
        loginManager.logInWithPublishPermissions(mockActivity,
            Arrays.asList("publish_actions", "publish_stream"));

        assertNotNull(loginManager.getPendingLoginRequest());
    }

    @Test
    public void testOnActivityResultReturnsFalseIfNoPendingRequest() {
        LoginManager loginManager = new LoginManager();

        Intent intent = createSuccessResultIntent();

        boolean result = loginManager.onActivityResult(0, intent);

        assertFalse(result);
    }

    @Test
    public void testOnActivityResultReturnsTrueAndCallsCallbackOnCancelResultCode() {
        LoginManager loginManager = new LoginManager();
        loginManager.logInWithReadPermissions(mockActivity,
            Arrays.asList("public_profile", "user_friends"));

        boolean result = loginManager.onActivityResult(
                Activity.RESULT_CANCELED, null, mockCallback);

        assertTrue(result);
        verify(mockCallback, times(1)).onCancel();
        verify(mockCallback, never()).onSuccess(isA(LoginResult.class));
    }

    @Test
    public void testOnActivityResultReturnsTrueAndCallsCallbackOnCancelResultCodeEvenWithData() {
        LoginManager loginManager = new LoginManager();
        loginManager.logInWithReadPermissions(mockActivity,
            Arrays.asList("public_profile", "user_friends"));

        Intent intent = createSuccessResultIntent();
        boolean result = loginManager.onActivityResult(
                Activity.RESULT_CANCELED, intent, mockCallback);

        assertTrue(result);
        verify(mockCallback, times(1)).onCancel();
        verify(mockCallback, never()).onSuccess(isA(LoginResult.class));
    }

    @Test
    public void testOnActivityResultDoesNotModifyCurrentAccessTokenOnCancelResultCode() {
        LoginManager loginManager = new LoginManager();
        loginManager.logInWithReadPermissions(mockActivity,
                Arrays.asList("public_profile", "user_friends"));

        loginManager.onActivityResult(Activity.RESULT_CANCELED, null, mockCallback);

        verifyStatic(never());
        AccessToken.setCurrentAccessToken(any(AccessToken.class));
    }

    @Test
    public void testOnActivityResultHandlesMissingCallbackOnCancelResultCode() {
        LoginManager loginManager = new LoginManager();
        loginManager.logInWithReadPermissions(mockActivity,
            Arrays.asList("public_profile", "user_friends"));

        boolean result = loginManager.onActivityResult(
                Activity.RESULT_CANCELED,
                null);

        assertTrue(result);
    }

    @Test
    public void testOnActivityResultReturnsTrueAndCallsCallbackOnNullData() {
        LoginManager loginManager = new LoginManager();
        loginManager.logInWithReadPermissions(mockActivity,
            Arrays.asList("public_profile", "user_friends"));

        boolean result = loginManager.onActivityResult(
                Activity.RESULT_OK, null, mockCallback);

        assertTrue(result);
        verify(mockCallback, times(1)).onError(isA(FacebookException.class));
        verify(mockCallback, never()).onSuccess(isA(LoginResult.class));
    }

    @Test
    public void testOnActivityResultReturnsTrueAndCallsCallbackOnMissingResult() {
        LoginManager loginManager = new LoginManager();
        loginManager.logInWithReadPermissions(mockActivity,
            Arrays.asList("public_profile", "user_friends"));

        Intent intent = createSuccessResultIntent();
        intent.removeExtra(LoginFragment.RESULT_KEY);
        boolean result = loginManager.onActivityResult(
                Activity.RESULT_OK, intent, mockCallback);

        assertTrue(result);
        verify(mockCallback, times(1)).onError(isA(FacebookException.class));
        verify(mockCallback, never()).onSuccess(isA(LoginResult.class));
    }

    @Test
    public void testOnActivityResultReturnsTrueAndCallsCallbackOnErrorResult() {
        LoginManager loginManager = new LoginManager();
        loginManager.logInWithReadPermissions(mockActivity,
            Arrays.asList("public_profile", "user_friends"));

        boolean result = loginManager.onActivityResult(
                Activity.RESULT_OK, createErrorResultIntent(), mockCallback);

        ArgumentCaptor<FacebookException> exceptionArgumentCaptor =
                ArgumentCaptor.forClass(FacebookException.class);

        assertTrue(result);
        verify(mockCallback, times(1)).onError(exceptionArgumentCaptor.capture());
        verify(mockCallback, never()).onSuccess(isA(LoginResult.class));
        assertEquals("foo: bar", exceptionArgumentCaptor.getValue().getMessage());
    }

    @Test
    public void testOnActivityResultReturnsTrueAndCallsCallbackOnCancelResult() {
        LoginManager loginManager = new LoginManager();
        loginManager.logInWithReadPermissions(mockActivity,
            Arrays.asList("public_profile", "user_friends"));

        boolean result = loginManager.onActivityResult(
                Activity.RESULT_CANCELED, createCancelResultIntent(), mockCallback);

        assertTrue(result);
        verify(mockCallback, times(1)).onCancel();
        verify(mockCallback, never()).onSuccess(isA(LoginResult.class));
    }

    @Test
    public void testOnActivityResultDoesNotModifyCurrentAccessTokenOnErrorResultCode() {
        LoginManager loginManager = new LoginManager();
        loginManager.logInWithReadPermissions(mockActivity,
            Arrays.asList("public_profile", "user_friends"));

        loginManager.onActivityResult(
                Activity.RESULT_CANCELED,
                createErrorResultIntent(),
                mockCallback);

        verifyStatic(never());
        AccessToken.setCurrentAccessToken(any(AccessToken.class));
    }

    @Test
    public void testOnActivityResultReturnsTrueAndCallsCallbackOnSuccessResult() {
        LoginManager loginManager = new LoginManager();
        loginManager.logInWithReadPermissions(mockActivity,
            Arrays.asList("public_profile", "user_friends"));

        boolean result = loginManager.onActivityResult(
                Activity.RESULT_OK, createSuccessResultIntent(), mockCallback);

        assertTrue(result);
        verify(mockCallback, never()).onError(any(FacebookException.class));
        verify(mockCallback, times(1)).onSuccess(isA(LoginResult.class));
    }

    @Test
    public void testOnHandlesMissingCallbackkOnSuccessResult() {
        LoginManager loginManager = new LoginManager();
        loginManager.logInWithReadPermissions(mockActivity,
            Arrays.asList("public_profile", "user_friends"));

        boolean result = loginManager.onActivityResult(
                Activity.RESULT_OK, createSuccessResultIntent(), null);

        assertTrue(result);
    }

    @Test
    public void testOnActivityResultSetsCurrentAccessTokenOnSuccessResult() {
        LoginManager loginManager = new LoginManager();
        loginManager.logInWithReadPermissions(mockActivity,
            Arrays.asList("public_profile", "user_friends"));

        boolean result = loginManager.onActivityResult(
                Activity.RESULT_OK, createSuccessResultIntent(), mockCallback);

        verifyStatic(times(1));
        AccessToken.setCurrentAccessToken(eq(createAccessToken()));
    }

    private Intent createSuccessResultIntent() {
        Intent intent = new Intent();

        LoginClient.Request request = mock(LoginClient.Request.class);

        AccessToken accessToken = createAccessToken();
        LoginClient.Result result = LoginClient.Result.createTokenResult(request, accessToken);
        intent.putExtra(LoginFragment.RESULT_KEY, result);

        return intent;
    }

    private Intent createErrorResultIntent() {
        Intent intent = new Intent();

        LoginClient.Request request = mock(LoginClient.Request.class);

        LoginClient.Result result = LoginClient.Result.createErrorResult(request, "foo", "bar");
        intent.putExtra(LoginFragment.RESULT_KEY, result);

        return intent;
    }

    private Intent createCancelResultIntent() {
        Intent intent = new Intent();

        LoginClient.Request request = mock(LoginClient.Request.class);

        LoginClient.Result result = LoginClient.Result.createCancelResult(request, null);
        intent.putExtra(LoginFragment.RESULT_KEY, result);

        return intent;
    }

    private AccessToken createAccessToken() {
        return new AccessToken(
                TOKEN_STRING,
                MOCK_APP_ID,
                USER_ID,
                PERMISSIONS,
                null,
                AccessTokenSource.WEB_VIEW,
                EXPIRES,
                LAST_REFRESH);
    }
}

<code block>


package com.facebook.login;

import com.facebook.AccessToken;
import com.facebook.FacebookSdk;
import com.facebook.FacebookTestCase;

import org.junit.Before;
import org.junit.Test;
import org.robolectric.Robolectric;
import org.robolectric.RuntimeEnvironment;

import java.util.HashSet;
import java.util.Set;

import static org.junit.Assert.*;

public class LoginResultTest extends FacebookTestCase {

    private final Set<String> EMAIL_SET = new HashSet<String>(){{ add("email"); }};
    private final Set<String> LIKES_EMAIL_SET = new HashSet<String>(){{
        add("user_likes");
        add("email");
    }};
    private final Set<String> PROFILE_EMAIL_SET = new HashSet<String>(){{
        add("user_profile");
        add("email");
    }};

    @Before
    public void before() throws Exception {
        FacebookSdk.sdkInitialize(RuntimeEnvironment.application);
    }

    @Test
    public void testInitialLogin() {
        LoginClient.Request request = createRequest(EMAIL_SET, false);
        AccessToken accessToken = createAccessToken(PROFILE_EMAIL_SET, new HashSet<String>());
        LoginResult result = LoginManager.computeLoginResult(request, accessToken);
        assertEquals(accessToken, result.getAccessToken());
        assertEquals(PROFILE_EMAIL_SET, result.getRecentlyGrantedPermissions());
        assertEquals(0, result.getRecentlyDeniedPermissions().size());
    }

    @Test
    public void testReAuth() {
        LoginClient.Request request = createRequest(EMAIL_SET, true);
        AccessToken accessToken = createAccessToken(PROFILE_EMAIL_SET, new HashSet<String>());
        LoginResult result = LoginManager.computeLoginResult(request, accessToken);
        assertEquals(accessToken, result.getAccessToken());
        assertEquals(EMAIL_SET, result.getRecentlyGrantedPermissions());
        assertEquals(0, result.getRecentlyDeniedPermissions().size());
    }

    @Test
    public void testDeniedPermissions() {
        LoginClient.Request request = createRequest(LIKES_EMAIL_SET, true);
        AccessToken accessToken = createAccessToken(EMAIL_SET, new HashSet<String>());
        LoginResult result = LoginManager.computeLoginResult(request, accessToken);
        assertEquals(accessToken, result.getAccessToken());
        assertEquals(EMAIL_SET, result.getRecentlyGrantedPermissions());
        assertEquals(
                new HashSet<String>(){{ add("user_likes"); }},
                result.getRecentlyDeniedPermissions());
    }


    private AccessToken createAccessToken(Set<String> permissions,
                                          Set<String> declinedPermissions) {
        return new AccessToken(
            "token",
            "123",
            "234",
            permissions,
            declinedPermissions,
            null,
            null,
            null
        );
    }

    private LoginClient.Request createRequest(Set<String> permissions, boolean isRerequest) {
        LoginClient.Request request = new LoginClient.Request(
                LoginBehavior.SSO_WITH_FALLBACK,
                permissions,
                DefaultAudience.EVERYONE,
                "123",
                "authid"
        );
        request.setRerequest(isRerequest);
        return request;
    }
}

<code block>


package com.facebook.login;

import android.app.Activity;
import android.support.v4.app.FragmentActivity;

import com.facebook.FacebookPowerMockTestCase;

import org.junit.Before;
import org.robolectric.Robolectric;

import java.util.Arrays;
import java.util.Date;
import java.util.HashSet;

import static org.junit.Assert.assertTrue;
import static org.powermock.api.mockito.PowerMockito.mock;
import static org.powermock.api.mockito.PowerMockito.when;

public abstract class LoginHandlerTestCase extends FacebookPowerMockTestCase {
    protected static final String ACCESS_TOKEN = "An access token";
    protected static final String USER_ID = "1000";
    protected static final long EXPIRES_IN_DELTA = 3600 * 24 * 60;
    protected static final HashSet<String> PERMISSIONS = new HashSet<String>(
            Arrays.asList("go outside", "come back in"));
    protected static final String ERROR_MESSAGE = "This is bad!";

    protected FragmentActivity activity;
    protected LoginClient mockLoginClient;

    @Before
    public void before() throws Exception {
        mockLoginClient = mock(LoginClient.class);
        activity = Robolectric.buildActivity(FragmentActivity.class).create().get();
        when(mockLoginClient.getActivity()).thenReturn(activity);
    }

    protected LoginClient.Request createRequest() {
        return createRequest(null);
    }

    protected LoginClient.Request createRequest(String previousAccessTokenString) {

        return new LoginClient.Request(
                LoginBehavior.SSO_WITH_FALLBACK,
                new HashSet<String>(PERMISSIONS),
                DefaultAudience.FRIENDS,
                "1234",
                "5678");
    }

    protected void assertDateDiffersWithinDelta(Date expected, Date actual, long expectedDifference,
                                                long deltaInMsec) {

        long delta = Math.abs(expected.getTime() - actual.getTime()) - expectedDifference;
        assertTrue(delta < deltaInMsec);
    }
}

<code block>


package com.facebook;

import android.graphics.Bitmap;
import android.test.suitebuilder.annotation.LargeTest;

import com.facebook.share.internal.ShareInternalUtility;

import org.json.JSONObject;

import java.io.IOException;
import java.lang.Override;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

public class BatchRequestTests extends FacebookTestCase {
    protected void setUp() throws Exception {
        super.setUp();

        
        GraphRequest.setDefaultBatchApplicationId(null);
    }

    protected String[] getDefaultPermissions()
    {
        return new String[] { "email", "publish_actions", "read_stream" };
    };

    @LargeTest
    public void testCreateNonemptyRequestBatch() {
        GraphRequest meRequest = GraphRequest.newMeRequest(null, null);

        GraphRequestBatch batch = new GraphRequestBatch(new GraphRequest[] { meRequest, meRequest });
        assertEquals(2, batch.size());
        assertEquals(meRequest, batch.get(0));
        assertEquals(meRequest, batch.get(1));
    }

    @LargeTest
    public void testBatchWithoutAppIDIsError() {
        GraphRequest request1 = new GraphRequest(null, "TourEiffel", null, null, new ExpectFailureCallback());
        GraphRequest request2 = new GraphRequest(null, "SpaceNeedle", null, null, new ExpectFailureCallback());
        GraphRequest.executeBatchAndWait(request1, request2);
    }

    @LargeTest
    public void testExecuteBatchRequestsPathEncoding() throws IOException {
        
        

        final AccessToken accessToken = getAccessTokenForSharedUser();

        GraphRequest request1 = new GraphRequest(accessToken, "TourEiffel");
        request1.setBatchEntryName("eiffel");
        request1.setBatchEntryOmitResultOnSuccess(false);
        GraphRequest request2 = new GraphRequest(accessToken, "{result=eiffel:$.id}");

        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(request1, request2);
        assertEquals(2, responses.size());
        assertTrue(responses.get(0).getError() == null);
        assertTrue(responses.get(1).getError() == null);

        JSONObject eiffelTower1 = responses.get(0).getJSONObject();
        JSONObject eiffelTower2 = responses.get(1).getJSONObject();
        assertTrue(eiffelTower1 != null);
        assertTrue(eiffelTower2 != null);

        assertEquals("Paris", eiffelTower1.optJSONObject("location").optString("city"));
        assertEquals("Paris", eiffelTower2.optJSONObject("location").optString("city"));
    }

    @LargeTest
    public void testExecuteBatchedGets() throws IOException {
        final AccessToken accessToken = getAccessTokenForSharedUser();

        GraphRequest request1 = new GraphRequest(accessToken, "TourEiffel");
        GraphRequest request2 = new GraphRequest(accessToken, "SpaceNeedle");

        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(request1, request2);
        assertEquals(2, responses.size());
        assertTrue(responses.get(0).getError() == null);
        assertTrue(responses.get(1).getError() == null);

        JSONObject eiffelTower = responses.get(0).getJSONObject();
        JSONObject spaceNeedle = responses.get(1).getJSONObject();
        assertTrue(eiffelTower != null);
        assertTrue(spaceNeedle != null);

        assertEquals("Paris", eiffelTower.optJSONObject("location").optString("city"));
        assertEquals("Seattle", spaceNeedle.optJSONObject("location").optString("city"));
    }

    @LargeTest
    public void testFacebookErrorResponsesCreateErrors() {
        setBatchApplicationIdForTestApp();

        GraphRequest request1 = new GraphRequest(null, "somestringthatshouldneverbeavalidfobjectid");
        GraphRequest request2 = new GraphRequest(null, "someotherstringthatshouldneverbeavalidfobjectid");
        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(request1, request2);

        assertEquals(2, responses.size());
        assertTrue(responses.get(0).getError() != null);
        assertTrue(responses.get(1).getError() != null);

        FacebookRequestError error = responses.get(0).getError();
        assertTrue(error.getException() instanceof FacebookServiceException);
        assertTrue(error.getErrorType() != null);
        assertTrue(error.getErrorCode() != FacebookRequestError.INVALID_ERROR_CODE);
    }

    @LargeTest
    public void testBatchPostStatusUpdate() {
        final AccessToken accessToken = getAccessTokenForSharedUser();

        JSONObject statusUpdate1 = createStatusUpdate("1");
        JSONObject statusUpdate2 = createStatusUpdate("2");

        GraphRequest postRequest1 = GraphRequest.newPostRequest(accessToken, "me/feed", statusUpdate1, null);
        postRequest1.setBatchEntryName("postRequest1");
        postRequest1.setBatchEntryOmitResultOnSuccess(false);
        GraphRequest postRequest2 = GraphRequest.newPostRequest(accessToken, "me/feed", statusUpdate2, null);
        postRequest2.setBatchEntryName("postRequest2");
        postRequest2.setBatchEntryOmitResultOnSuccess(false);
        GraphRequest getRequest1 = new GraphRequest(accessToken, "{result=postRequest1:$.id}");
        GraphRequest getRequest2 = new GraphRequest(accessToken, "{result=postRequest2:$.id}");

        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(postRequest1, postRequest2, getRequest1, getRequest2);
        assertNotNull(responses);
        assertEquals(4, responses.size());
        assertNoErrors(responses);

        JSONObject retrievedStatusUpdate1 = responses.get(2).getJSONObject();
        JSONObject retrievedStatusUpdate2 = responses.get(3).getJSONObject();
        assertNotNull(retrievedStatusUpdate1);
        assertNotNull(retrievedStatusUpdate2);

        assertEquals(statusUpdate1.optString("message"), retrievedStatusUpdate1.optString("message"));
        assertEquals(statusUpdate2.optString("message"), retrievedStatusUpdate2.optString("message"));
    }

    @LargeTest
    public void testTwoDifferentAccessTokens() {
        final AccessToken accessToken1 = getAccessTokenForSharedUser();
        final AccessToken accessToken2 = getAccessTokenForSharedUser(SECOND_TEST_USER_TAG);

        GraphRequest request1 = GraphRequest.newMeRequest(accessToken1, null);
        GraphRequest request2 = GraphRequest.newMeRequest(accessToken2, null);

        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(request1, request2);
        assertNotNull(responses);
        assertEquals(2, responses.size());

        JSONObject user1 = responses.get(0).getJSONObject();
        JSONObject user2 = responses.get(1).getJSONObject();

        assertNotNull(user1);
        assertNotNull(user2);

        assertFalse(user1.optString("id").equals(user2.optString("id")));
        assertEquals(accessToken1.getUserId(), user1.optString("id"));
        assertEquals(accessToken2.getUserId(), user2.optString("id"));
    }

    @LargeTest
    public void testBatchWithValidSessionAndNoSession() {
        final AccessToken accessToken = getAccessTokenForSharedUser();

        GraphRequest request1 = new GraphRequest(accessToken, "me");
        GraphRequest request2 = new GraphRequest(null, "me");

        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(request1, request2);
        assertNotNull(responses);
        assertEquals(2, responses.size());

        JSONObject user1 = responses.get(0).getJSONObject();
        JSONObject user2 = responses.get(1).getJSONObject();

        assertNotNull(user1);
        assertNull(user2);

        assertEquals(accessToken.getUserId(), user1.optString("id"));
    }

    @LargeTest
    public void testBatchWithNoSessionAndValidSession() {
        final AccessToken accessToken = getAccessTokenForSharedUser();

        GraphRequest request1 = new GraphRequest(null, "me");
        GraphRequest request2 = new GraphRequest(accessToken, "me");

        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(request1, request2);
        assertNotNull(responses);
        assertEquals(2, responses.size());

        JSONObject user1 = responses.get(0).getJSONObject();
        JSONObject user2 = responses.get(1).getJSONObject();

        assertNull(user1);
        assertNotNull(user2);

        assertEquals(accessToken.getUserId(), user2.optString("id"));
    }

    @LargeTest
    public void testMixedSuccessAndFailure() {
        final AccessToken accessToken = getAccessTokenForSharedUser();

        final int NUM_REQUESTS = 8;
        GraphRequest[] requests = new GraphRequest[NUM_REQUESTS];
        for (int i = 0; i < NUM_REQUESTS; ++i) {
            boolean shouldSucceed = (i % 2) == 1;
            requests[i] = new GraphRequest(accessToken, shouldSucceed ? "me" : "-1");
        }

        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(requests);
        assertNotNull(responses);
        assertEquals(NUM_REQUESTS, responses.size());

        for (int i = 0; i < NUM_REQUESTS; ++i) {
            boolean shouldSucceed = (i % 2) == 1;

            GraphResponse response = responses.get(i);
            assertNotNull(response);
            if (shouldSucceed) {
                assertNull(response.getError());
                assertNotNull(response.getJSONObject());
            } else {
                assertNotNull(response.getError());
                assertNull(response.getJSONObject());
            }
        }
    }

    @LargeTest
    public void testBatchUploadPhoto() {
        final AccessToken accessToken = getAccessTokenForSharedUserWithPermissions(null,
                "user_photos", "publish_actions");

        final int image1Size = 120;
        final int image2Size = 150;

        Bitmap bitmap1 = createTestBitmap(image1Size);
        Bitmap bitmap2 = createTestBitmap(image2Size);

        GraphRequest uploadRequest1 = ShareInternalUtility.newUploadPhotoRequest(
                ShareInternalUtility.MY_PHOTOS,
                accessToken,
                bitmap1,
                null,
                null,
                null);
        uploadRequest1.setBatchEntryName("uploadRequest1");
        GraphRequest uploadRequest2 = ShareInternalUtility.newUploadPhotoRequest(
                ShareInternalUtility.MY_PHOTOS,
                accessToken,
                bitmap2,
                null,
                null,
                null);
        uploadRequest2.setBatchEntryName("uploadRequest2");
        GraphRequest getRequest1 = new GraphRequest(accessToken, "{result=uploadRequest1:$.id}");
        GraphRequest getRequest2 = new GraphRequest(accessToken, "{result=uploadRequest2:$.id}");

        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(
                uploadRequest1,
                uploadRequest2,
                getRequest1,
                getRequest2);
        assertNotNull(responses);
        assertEquals(4, responses.size());
        assertNoErrors(responses);

        JSONObject retrievedPhoto1 = responses.get(2).getJSONObject();
        JSONObject retrievedPhoto2 = responses.get(3).getJSONObject();
        assertNotNull(retrievedPhoto1);
        assertNotNull(retrievedPhoto2);

        assertEquals(image1Size, retrievedPhoto1.optInt("width"));
        assertEquals(image2Size, retrievedPhoto2.optInt("width"));
    }

    @LargeTest
    public void testCallbacksAreCalled() {
        setBatchApplicationIdForTestApp();

        ArrayList<GraphRequest> requests = new ArrayList<GraphRequest>();
        final ArrayList<Boolean> calledBack = new ArrayList<Boolean>();

        final int NUM_REQUESTS = 4;
        for (int i = 0; i < NUM_REQUESTS; ++i) {
            GraphRequest request = new GraphRequest(null, "4");

            request.setCallback(new GraphRequest.Callback() {
                @Override
                public void onCompleted(GraphResponse response) {
                    calledBack.add(true);
                }
            });

            requests.add(request);
        }

        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(requests);
        assertNotNull(responses);
        assertTrue(calledBack.size() == NUM_REQUESTS);
    }


    @LargeTest
    public void testExplicitDependencyDefaultsToOmitFirstResponse() {
        final AccessToken accessToken = getAccessTokenForSharedUser();

        GraphRequest requestMe = GraphRequest.newMeRequest(accessToken, null);
        requestMe.setBatchEntryName("me_request");

        GraphRequest requestMyFriends = GraphRequest.newMyFriendsRequest(accessToken, null);
        requestMyFriends.setBatchEntryDependsOn("me_request");

        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(requestMe, requestMyFriends);

        GraphResponse meResponse = responses.get(0);
        GraphResponse myFriendsResponse = responses.get(1);

        assertNull(meResponse.getJSONObject());
        assertNotNull(myFriendsResponse.getJSONObject());
    }

    @LargeTest
    public void testExplicitDependencyCanIncludeFirstResponse() {
        final AccessToken accessToken = getAccessTokenForSharedUser();

        GraphRequest requestMe = GraphRequest.newMeRequest(accessToken, null);
        requestMe.setBatchEntryName("me_request");
        requestMe.setBatchEntryOmitResultOnSuccess(false);

        GraphRequest requestMyFriends = GraphRequest.newMyFriendsRequest(accessToken, null);
        requestMyFriends.setBatchEntryDependsOn("me_request");

        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(requestMe, requestMyFriends);

        GraphResponse meResponse = responses.get(0);
        GraphResponse myFriendsResponse = responses.get(1);

        assertNotNull(meResponse.getJSONObject());
        assertNotNull(myFriendsResponse.getJSONObject());
    }

    @LargeTest
    public void testAddAndRemoveBatchCallbacks() {
        GraphRequestBatch batch = new GraphRequestBatch();

        GraphRequestBatch.Callback callback1 = new GraphRequestBatch.Callback() {
            @Override
            public void onBatchCompleted(GraphRequestBatch batch) {
            }
        };

        GraphRequestBatch.Callback callback2 = new GraphRequestBatch.Callback() {
            @Override
            public void onBatchCompleted(GraphRequestBatch batch) {
            }
        };

        batch.addCallback(callback1);
        batch.addCallback(callback2);

        assertEquals(2, batch.getCallbacks().size());

        batch.removeCallback(callback1);
        batch.removeCallback(callback2);

        assertEquals(0, batch.getCallbacks().size());
    }

    @LargeTest
    public void testBatchCallbackIsCalled() {
        final AtomicInteger count = new AtomicInteger();
        GraphRequest request1 = GraphRequest.newGraphPathRequest(null, "4", new GraphRequest.Callback() {
            @Override
            public void onCompleted(GraphResponse response) {
                count.incrementAndGet();
            }
        });
        GraphRequest request2 = GraphRequest.newGraphPathRequest(null, "4", new GraphRequest.Callback() {
            @Override
            public void onCompleted(GraphResponse response) {
                count.incrementAndGet();
            }
        });

        GraphRequestBatch batch = new GraphRequestBatch(request1, request2);
        batch.addCallback(new GraphRequestBatch.Callback() {
            @Override
            public void onBatchCompleted(GraphRequestBatch batch) {
                count.incrementAndGet();
            }
        });

        batch.executeAndWait();
        assertEquals(3, count.get());
    }

    @LargeTest
    public void testBatchOnProgressCallbackIsCalled() {
        final AtomicInteger count = new AtomicInteger();

        final AccessToken accessToken = getAccessTokenForSharedUser();

        String appId = getApplicationId();
        GraphRequest.setDefaultBatchApplicationId(appId);

        GraphRequest request1 = GraphRequest.newGraphPathRequest(accessToken, "4", null);
        assertNotNull(request1);
        GraphRequest request2 = GraphRequest.newGraphPathRequest(accessToken, "4", null);
        assertNotNull(request2);

        GraphRequestBatch batch = new GraphRequestBatch(request1, request2);
        batch.addCallback(new GraphRequestBatch.OnProgressCallback() {
            @Override
            public void onBatchCompleted(GraphRequestBatch batch) {
            }

            @Override
            public void onBatchProgress(GraphRequestBatch batch, long current, long max) {
                count.incrementAndGet();
            }
        });

        batch.executeAndWait();
        assertEquals(1, count.get());
    }

    @LargeTest
    public void testBatchLastOnProgressCallbackIsCalledOnce() {
        final AtomicInteger count = new AtomicInteger();

        final AccessToken accessToken = getAccessTokenForSharedUser();

        String appId = getApplicationId();
        GraphRequest.setDefaultBatchApplicationId(appId);

        GraphRequest request1 = GraphRequest.newGraphPathRequest(accessToken, "4", null);
        assertNotNull(request1);
        GraphRequest request2 = GraphRequest.newGraphPathRequest(accessToken, "4", null);
        assertNotNull(request2);

        GraphRequestBatch batch = new GraphRequestBatch(request1, request2);
        batch.addCallback(new GraphRequestBatch.OnProgressCallback() {
            @Override
            public void onBatchCompleted(GraphRequestBatch batch) {
            }

            @Override
            public void onBatchProgress(GraphRequestBatch batch, long current, long max) {
                if (current == max) {
                    count.incrementAndGet();
                }
                else if (current > max) {
                    count.set(0);
                }
            }
        });

        batch.executeAndWait();
        assertEquals(1, count.get());
    }


    @LargeTest
    public void testMixedBatchCallbacks() {
        final AtomicInteger requestProgressCount = new AtomicInteger();
        final AtomicInteger requestCompletedCount = new AtomicInteger();
        final AtomicInteger batchProgressCount = new AtomicInteger();
        final AtomicInteger batchCompletedCount = new AtomicInteger();

        final AccessToken accessToken = getAccessTokenForSharedUser();

        String appId = getApplicationId();
        GraphRequest.setDefaultBatchApplicationId(appId);

        GraphRequest request1 = GraphRequest.newGraphPathRequest(
                null, "4", new GraphRequest.OnProgressCallback() {
            @Override
            public void onCompleted(GraphResponse response) {
                requestCompletedCount.incrementAndGet();
            }

            @Override
            public void onProgress(long current, long max) {
                if (current == max) {
                    requestProgressCount.incrementAndGet();
                }
                else if (current > max) {
                    requestProgressCount.set(0);
                }
            }
        });
        assertNotNull(request1);

        GraphRequest request2 = GraphRequest.newGraphPathRequest(null, "4", null);
        assertNotNull(request2);

        GraphRequestBatch batch = new GraphRequestBatch(request1, request2);
        batch.addCallback(new GraphRequestBatch.OnProgressCallback() {
            @Override
            public void onBatchCompleted(GraphRequestBatch batch) {
                batchCompletedCount.incrementAndGet();
            }

            @Override
            public void onBatchProgress(GraphRequestBatch batch, long current, long max) {
                if (current == max) {
                    batchProgressCount.incrementAndGet();
                } else if (current > max) {
                    batchProgressCount.set(0);
                }
            }
        });

        batch.executeAndWait();
        
        assertEquals(1, requestProgressCount.get());
        assertEquals(1, requestCompletedCount.get());
        assertEquals(1, batchProgressCount.get());
        assertEquals(1, batchCompletedCount.get());
    }
}

<code block>


package com.facebook;

import android.graphics.Bitmap;
import android.test.suitebuilder.annotation.LargeTest;
import android.test.suitebuilder.annotation.MediumTest;
import android.test.suitebuilder.annotation.SmallTest;

import com.facebook.share.internal.ShareInternalUtility;

import org.json.JSONArray;
import org.json.JSONObject;

import java.net.HttpURLConnection;
import java.util.Arrays;

public class AsyncRequestTests extends FacebookTestCase {

    @SmallTest
    @MediumTest
    @LargeTest
    public void testCanLaunchAsyncRequestFromUiThread() {
        GraphRequest request = GraphRequest.newPostRequest(null, "me/feeds", null, null);
        try {
            TestGraphRequestAsyncTask task = createAsyncTaskOnUiThread(request);
            assertNotNull(task);
        } catch (Throwable throwable) {
            assertNull(throwable);
        }
    }

    @SmallTest
    @MediumTest
    @LargeTest
    public void testExecuteWithNullRequestsThrows() throws Exception {
        try {
            TestGraphRequestAsyncTask task = new TestGraphRequestAsyncTask((GraphRequest[]) null);

            task.executeOnBlockerThread();

            waitAndAssertSuccessOrRethrow(1);

            fail("expected NullPointerException");
        } catch (NullPointerException exception) {
        }
    }

    @SmallTest
    @MediumTest
    @LargeTest
    public void testExecuteBatchWithZeroRequestsThrows() throws Exception {
        try {
            TestGraphRequestAsyncTask task = new TestGraphRequestAsyncTask(new GraphRequest[] {});

            task.executeOnBlockerThread();

            waitAndAssertSuccessOrRethrow(1);

            fail("expected IllegalArgumentException");
        } catch (IllegalArgumentException exception) {
        }
    }

    @SmallTest
    @MediumTest
    @LargeTest
    public void testExecuteBatchWithNullRequestThrows() throws Exception {
        try {
            TestGraphRequestAsyncTask task = new TestGraphRequestAsyncTask(
                    new GraphRequest[] { null });

            task.executeOnBlockerThread();

            waitAndAssertSuccessOrRethrow(1);

            fail("expected NullPointerException");
        } catch (NullPointerException exception) {
        }

    }

    @MediumTest
    @LargeTest
    public void testExecuteSingleGet() {
        final AccessToken accessToken = getAccessTokenForSharedUser();
        GraphRequest request = new GraphRequest(accessToken, "TourEiffel", null, null,
                new ExpectSuccessCallback() {
            @Override
            protected void performAsserts(GraphResponse response) {
                assertNotNull(response);
                JSONObject graphPlace = response.getJSONObject();
                assertEquals("Paris", graphPlace.optJSONObject("location").optString("city"));
            }
        });

        TestGraphRequestAsyncTask task = new TestGraphRequestAsyncTask(request);

        task.executeOnBlockerThread();

        
        waitAndAssertSuccess(2);
    }

    @MediumTest
    @LargeTest
    public void testExecuteSingleGetUsingHttpURLConnection() {
        final AccessToken accessToken = getAccessTokenForSharedUser();
        GraphRequest request = new GraphRequest(accessToken, "TourEiffel", null, null,
                new ExpectSuccessCallback() {
            @Override
            protected void performAsserts(GraphResponse response) {
                assertNotNull(response);
                JSONObject graphPlace = response.getJSONObject();
                assertEquals("Paris", graphPlace.optJSONObject("location").optString("city"));
            }
        });
        HttpURLConnection connection = GraphRequest.toHttpConnection(request);

        TestGraphRequestAsyncTask task = new TestGraphRequestAsyncTask(connection, Arrays.asList(new GraphRequest[] { request }));

        task.executeOnBlockerThread();

        
        waitAndAssertSuccess(2);
    }

    @MediumTest
    @LargeTest
    public void testExecuteSingleGetFailureCase() {
        final AccessToken accessToken = getAccessTokenForSharedUser();
        GraphRequest request = new GraphRequest(accessToken, "-1", null, null,
                new ExpectFailureCallback());

        TestGraphRequestAsyncTask task = new TestGraphRequestAsyncTask(request);

        task.executeOnBlockerThread();

        
        waitAndAssertSuccess(2);
    }

    @SmallTest
    @MediumTest
    @LargeTest
    public void testBatchWithoutAppIDIsError() throws Throwable {
        GraphRequest request1 = new GraphRequest(null, "TourEiffel", null, null, new ExpectFailureCallback());
        GraphRequest request2 = new GraphRequest(null, "SpaceNeedle", null, null, new ExpectFailureCallback());

        TestGraphRequestAsyncTask task = new TestGraphRequestAsyncTask(request1, request2);

        task.executeOnBlockerThread();

        
        waitAndAssertSuccessOrRethrow(3);
    }

    @LargeTest
    public void testMixedSuccessAndFailure() {
        final AccessToken accessToken = getAccessTokenForSharedUser();

        final int NUM_REQUESTS = 8;
        GraphRequest[] requests = new GraphRequest[NUM_REQUESTS];
        for (int i = 0; i < NUM_REQUESTS; ++i) {
            boolean shouldSucceed = (i % 2) == 1;
            if (shouldSucceed) {
                requests[i] = new GraphRequest(accessToken, "me", null, null,
                        new ExpectSuccessCallback());
            } else {
                requests[i] = new GraphRequest(accessToken, "-1", null, null,
                        new ExpectFailureCallback());
            }
        }

        TestGraphRequestAsyncTask task = new TestGraphRequestAsyncTask(requests);

        task.executeOnBlockerThread();

        
        waitAndAssertSuccess(NUM_REQUESTS + 1);
    }

    @MediumTest
    @LargeTest
    public void testStaticExecuteMeAsync() {
        final AccessToken accessToken = getAccessTokenForSharedUser();

        class MeCallback extends ExpectSuccessCallback implements GraphRequest.GraphJSONObjectCallback {
            @Override
            public void onCompleted(JSONObject me, GraphResponse response) {
                assertNotNull(me);
                assertEquals(accessToken.getUserId(), me.optString("id"));
                RequestTests.validateMeResponse(accessToken, response);
                onCompleted(response);
            }
        }

        runOnBlockerThread(new Runnable() {
            @Override
            public void run() {
                GraphRequest.newMeRequest(accessToken, new MeCallback()).executeAsync();
            }
        }, false);
        waitAndAssertSuccess(1);
    }

    @MediumTest
    @LargeTest
    public void testStaticExecuteMyFriendsAsync() {
        final AccessToken accessToken = getAccessTokenForSharedUser();

        class FriendsCallback extends ExpectSuccessCallback implements GraphRequest.GraphJSONArrayCallback {
            @Override
            public void onCompleted(JSONArray friends, GraphResponse response) {
                assertNotNull(friends);
                RequestTests.validateMyFriendsResponse(response);
                onCompleted(response);
            }
        }

        runOnBlockerThread(new Runnable() {
            @Override
            public void run() {
                GraphRequest.newMyFriendsRequest(accessToken, new FriendsCallback()).executeAsync();
            }
        }, false);
        waitAndAssertSuccess(1);
    }

    @LargeTest
    public void testBatchUploadPhoto() {
        final AccessToken accessToken = getAccessTokenForSharedUserWithPermissions(null,
                "user_photos", "publish_actions");

        final int image1Size = 120;
        final int image2Size = 150;

        Bitmap bitmap1 = createTestBitmap(image1Size);
        Bitmap bitmap2 = createTestBitmap(image2Size);

        GraphRequest uploadRequest1 = ShareInternalUtility.newUploadPhotoRequest(
                ShareInternalUtility.MY_PHOTOS,
                accessToken,
                bitmap1,
                null,
                null,
                null);
        uploadRequest1.setBatchEntryName("uploadRequest1");
        GraphRequest uploadRequest2 = ShareInternalUtility.newUploadPhotoRequest(
                ShareInternalUtility.MY_PHOTOS,
                accessToken,
                bitmap2,
                null,
                null,
                null);
        uploadRequest2.setBatchEntryName("uploadRequest2");
        GraphRequest getRequest1 = new GraphRequest(
                accessToken,
                "{result=uploadRequest1:$.id}",
                null,
                null,
                new ExpectSuccessCallback() {
                    @Override
                    protected void performAsserts(GraphResponse response) {
                        assertNotNull(response);
                        JSONObject retrievedPhoto = response.getJSONObject();
                        assertNotNull(retrievedPhoto);
                        assertEquals(image1Size, retrievedPhoto.optInt("width"));
                    }
                });
        GraphRequest getRequest2 = new GraphRequest(
                accessToken,
                "{result=uploadRequest2:$.id}",
                null,
                null,
                new ExpectSuccessCallback() {
                    @Override
                    protected void performAsserts(GraphResponse response) {
                        assertNotNull(response);
                        JSONObject retrievedPhoto = response.getJSONObject();
                        assertNotNull(retrievedPhoto);
                        assertEquals(image2Size, retrievedPhoto.optInt("width"));
                    }
                });

        TestGraphRequestAsyncTask task = new TestGraphRequestAsyncTask(
                uploadRequest1,
                uploadRequest2,
                getRequest1,
                getRequest2);
        task.executeOnBlockerThread();

        
        waitAndAssertSuccess(3);
    }

    @MediumTest
    @LargeTest
    public void testShortTimeoutCausesFailure() {
        final AccessToken accessToken = getAccessTokenForSharedUser();

        GraphRequest request = new GraphRequest(accessToken, "me/likes", null, null,
                new ExpectFailureCallback());

        GraphRequestBatch requestBatch = new GraphRequestBatch(request);

        
        requestBatch.setTimeout(1);

        TestGraphRequestAsyncTask task = new TestGraphRequestAsyncTask(requestBatch);
        task.executeOnBlockerThread();

        
        waitAndAssertSuccess(2);
    }

    @LargeTest
    public void testLongTimeoutAllowsSuccess() {
        final AccessToken accessToken = getAccessTokenForSharedUser();

        GraphRequest request = new GraphRequest(accessToken, "me", null, null,
                new ExpectSuccessCallback());

        GraphRequestBatch requestBatch = new GraphRequestBatch(request);

        
        requestBatch.setTimeout(10000);

        TestGraphRequestAsyncTask task = new TestGraphRequestAsyncTask(requestBatch);
        task.executeOnBlockerThread();

        
        waitAndAssertSuccess(2);
    }
}

<code block>


package com.facebook;

import android.app.Activity;
import android.content.res.AssetManager;
import android.graphics.Bitmap;
import android.graphics.Color;
import android.os.Bundle;
import android.os.ConditionVariable;
import android.os.Handler;
import android.test.ActivityInstrumentationTestCase2;
import android.util.Log;
import com.facebook.internal.Utility;
import junit.framework.AssertionFailedError;
import org.json.JSONException;
import org.json.JSONObject;
import org.json.JSONTokener;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.HttpURLConnection;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

public class FacebookActivityTestCase<T extends Activity> extends ActivityInstrumentationTestCase2<T> {
    private static final String TAG = FacebookActivityTestCase.class.getSimpleName();

    private static String applicationId;
    private static String applicationSecret;
    private static String clientToken;
    private static TestUserManager testUserManager;

    public final static String SECOND_TEST_USER_TAG = "Second";
    public final static String THIRD_TEST_USER_TAG = "Third";

    private TestBlocker testBlocker;

    protected synchronized TestBlocker getTestBlocker() {
        if (testBlocker == null) {
            testBlocker = TestBlocker.createTestBlocker();
        }
        return testBlocker;
    }

    public FacebookActivityTestCase(Class<T> activityClass) {
        super("", activityClass);
    }

    protected String[] getDefaultPermissions() { return null; };

    protected AccessToken getAccessTokenForSharedUser() {
        return getAccessTokenForSharedUser(null);
    }

    protected AccessToken getAccessTokenForSharedUser(String sessionUniqueUserTag) {
        return getAccessTokenForSharedUserWithPermissions(sessionUniqueUserTag,
                getDefaultPermissions());
    }

    protected AccessToken getAccessTokenForSharedUserWithPermissions(String sessionUniqueUserTag,
        List<String> permissions) {
        return getTestUserManager().getAccessTokenForSharedUser(permissions, sessionUniqueUserTag);
    }

    protected AccessToken getAccessTokenForSharedUserWithPermissions(String sessionUniqueUserTag,
                                                                      String... permissions) {
        List<String> permissionList = (permissions != null) ? Arrays.asList(permissions) : null;
        return getAccessTokenForSharedUserWithPermissions(sessionUniqueUserTag, permissionList);
    }

    protected TestUserManager getTestUserManager() {
        if (testUserManager == null) {
            synchronized (FacebookActivityTestCase.class) {
                if (testUserManager == null) {
                    readApplicationIdAndSecret();
                    testUserManager = new TestUserManager(applicationSecret, applicationId);
                }
            }
        }

        return testUserManager;
    }

    
    protected void waitAndAssertSuccess(TestBlocker testBlocker, int numSignals) {
        try {
            testBlocker.waitForSignalsAndAssertSuccess(numSignals);
        } catch (AssertionFailedError e) {
            throw e;
        } catch (Exception e) {
            fail("Got exception: " + e.getMessage());
        }
    }

    protected void waitAndAssertSuccess(int numSignals) {
        waitAndAssertSuccess(getTestBlocker(), numSignals);
    }

    protected void waitAndAssertSuccessOrRethrow(int numSignals) throws Exception {
        getTestBlocker().waitForSignalsAndAssertSuccess(numSignals);
    }

    protected void runAndBlockOnUiThread(final int expectedSignals, final Runnable runnable) throws Throwable {
        final TestBlocker blocker = getTestBlocker();
        runTestOnUiThread(new Runnable() {
            @Override
            public void run() {
                runnable.run();
                blocker.signal();
            }
        });
        
        blocker.waitForSignals(1 + expectedSignals);
        
        
        getInstrumentation().waitForIdleSync();
    }

    protected synchronized void readApplicationIdAndSecret() {
        synchronized (FacebookTestCase.class) {
            if (applicationId != null && applicationSecret != null && clientToken != null) {
                return;
            }

            AssetManager assets = getInstrumentation().getTargetContext().getResources().getAssets();
            InputStream stream = null;
            final String errorMessage = "could not read applicationId and applicationSecret from config.json; ensure "
                    + "you have run 'configure_unit_tests.sh'. Error: ";
            try {
                stream = assets.open("config.json");
                String string = Utility.readStreamToString(stream);

                JSONTokener tokener = new JSONTokener(string);
                Object obj = tokener.nextValue();
                if (!(obj instanceof JSONObject)) {
                    fail(errorMessage + "could not deserialize a JSONObject");
                }
                JSONObject jsonObject = (JSONObject) obj;

                applicationId = jsonObject.optString("applicationId");
                applicationSecret = jsonObject.optString("applicationSecret");
                clientToken = jsonObject.optString("clientToken");

                if (Utility.isNullOrEmpty(applicationId) || Utility.isNullOrEmpty(applicationSecret) ||
                        Utility.isNullOrEmpty(clientToken)) {
                    fail(errorMessage + "config values are missing");
                }
            } catch (IOException e) {
                fail(errorMessage + e.toString());
            } catch (JSONException e) {
                fail(errorMessage + e.toString());
            } finally {
                if (stream != null) {
                    try {
                        stream.close();
                    } catch (IOException e) {
                        fail(errorMessage + e.toString());
                    }
                }
            }
        }
    }

    protected static String getApplicationId() {
        return applicationId;
    }

    protected static String getApplicationSecret() {
        return applicationSecret;
    }

    protected void setUp() throws Exception {
        super.setUp();

        
        FacebookSdk.setIsDebugEnabled(true);

        
        readApplicationIdAndSecret();

        FacebookSdk.sdkInitialize(getInstrumentation().getTargetContext());
        FacebookSdk.setApplicationId(applicationId);
        FacebookSdk.setClientToken(clientToken);

        
        FacebookSdk.addLoggingBehavior(LoggingBehavior.REQUESTS);
        FacebookSdk.addLoggingBehavior(LoggingBehavior.INCLUDE_ACCESS_TOKENS);

        
        
        

        
        System.setProperty("dexmaker.dexcache",
                getInstrumentation().getTargetContext().getCacheDir().getPath());
    }

    protected void tearDown() throws Exception {
        super.tearDown();

        synchronized (this) {
            if (testBlocker != null) {
                testBlocker.quit();
            }
        }
    }

    protected Bundle getNativeLinkingExtras(String token, String userId) {
        readApplicationIdAndSecret();

        Bundle extras = new Bundle();
        String extraLaunchUriString = String
                .format("fbrpc:
                        applicationId, token);
        extras.putString("extra_launch_uri", extraLaunchUriString);
        extras.putString("expires_in", "3600");
        extras.putLong("app_id", Long.parseLong(applicationId));
        extras.putString("access_token", token);
        if(userId != null && !userId.isEmpty()) {
            extras.putString("user_id", userId);
        }

        return extras;
    }

    protected JSONObject getAndAssert(AccessToken accessToken, String id) {
        GraphRequest request = new GraphRequest(accessToken, id);
        GraphResponse response = request.executeAndWait();
        assertNotNull(response);

        assertNull(response.getError());

        JSONObject result = response.getJSONObject();
        assertNotNull(result);

        return result;
    }

    protected JSONObject postGetAndAssert(AccessToken accessToken, String path,
                                          JSONObject graphObject) {
        GraphRequest request = GraphRequest.newPostRequest(accessToken, path, graphObject, null);
        GraphResponse response = request.executeAndWait();
        assertNotNull(response);

        assertNull(response.getError());

        JSONObject result = response.getJSONObject();
        assertNotNull(result);
        assertNotNull(result.optString("id"));

        return getAndAssert(accessToken, result.optString("id"));
    }

    protected void setBatchApplicationIdForTestApp() {
        readApplicationIdAndSecret();
        GraphRequest.setDefaultBatchApplicationId(applicationId);
    }

    protected JSONObject batchCreateAndGet(AccessToken accessToken, String graphPath,
                                           JSONObject graphObject, String fields) {
        GraphRequest create = GraphRequest.newPostRequest(accessToken, graphPath, graphObject,
                new ExpectSuccessCallback());
        create.setBatchEntryName("create");
        GraphRequest get = GraphRequest.newGraphPathRequest(accessToken, "{result=create:$.id}",
                new ExpectSuccessCallback());
        if (fields != null) {
            Bundle parameters = new Bundle();
            parameters.putString("fields", fields);
            get.setParameters(parameters);
        }

        return batchPostAndGet(create, get);
    }

    protected JSONObject batchUpdateAndGet(AccessToken accessToken, String graphPath,
                                           JSONObject graphObject, String fields) {
        GraphRequest update = GraphRequest.newPostRequest(accessToken, graphPath, graphObject,
                new ExpectSuccessCallback());
        GraphRequest get = GraphRequest.newGraphPathRequest(accessToken, graphPath,
                new ExpectSuccessCallback());
        if (fields != null) {
            Bundle parameters = new Bundle();
            parameters.putString("fields", fields);
            get.setParameters(parameters);
        }

        return batchPostAndGet(update, get);
    }

    protected JSONObject batchPostAndGet(GraphRequest post, GraphRequest get) {
        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(post, get);
        assertEquals(2, responses.size());

        JSONObject resultGraphObject = responses.get(1).getJSONObject();
        assertNotNull(resultGraphObject);
        return resultGraphObject;
    }

    protected JSONObject createStatusUpdate(String unique) {
        JSONObject statusUpdate = new JSONObject();
        String message = String.format(
                "Check out my awesome new status update posted at: %s. Some chars for you: +\"[]:,%s", new Date(),
                unique);
        try {
            statusUpdate.put("message", message);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        return statusUpdate;
    }

    protected Bitmap createTestBitmap(int size) {
        Bitmap image = Bitmap.createBitmap(size, size, Bitmap.Config.RGB_565);
        image.eraseColor(Color.BLUE);
        return image;
    }

    protected void assertDateEqualsWithinDelta(Date expected, Date actual, long deltaInMsec) {
        long delta = Math.abs(expected.getTime() - actual.getTime());
        assertTrue(delta < deltaInMsec);
    }

    protected void assertDateDiffersWithinDelta(Date expected, Date actual, long expectedDifference, long deltaInMsec) {
        long delta = Math.abs(expected.getTime() - actual.getTime()) - expectedDifference;
        assertTrue(delta < deltaInMsec);
    }

    protected void assertNoErrors(List<GraphResponse> responses) {
        for (int i = 0; i < responses.size(); ++i) {
            GraphResponse response = responses.get(i);
            assertNotNull(response);
            assertNull(response.getError());
        }
    }

    protected File createTempFileFromAsset(String assetPath) throws IOException {
        InputStream inputStream = null;
        FileOutputStream outStream = null;

        try {
            AssetManager assets = getActivity().getResources().getAssets();
            inputStream = assets.open(assetPath);

            File outputDir = getActivity().getCacheDir(); 
            File outputFile = File.createTempFile("prefix", assetPath, outputDir);
            outStream = new FileOutputStream(outputFile);

            final int bufferSize = 1024 * 2;
            byte[] buffer = new byte[bufferSize];
            int n = 0;
            while ((n = inputStream.read(buffer)) != -1) {
                outStream.write(buffer, 0, n);
            }

            return outputFile;
        } finally {
            Utility.closeQuietly(outStream);
            Utility.closeQuietly(inputStream);
        }
    }

    protected void runOnBlockerThread(final Runnable runnable, boolean waitForCompletion) {
        Runnable runnableToPost = runnable;
        final ConditionVariable condition = waitForCompletion ? new ConditionVariable(!waitForCompletion) : null;

        if (waitForCompletion) {
            runnableToPost = new Runnable() {
                @Override
                public void run() {
                    runnable.run();
                    condition.open();
                }
            };
        }

        TestBlocker blocker = getTestBlocker();
        Handler handler = blocker.getHandler();
        handler.post(runnableToPost);

        if (waitForCompletion) {
            boolean success = condition.block(10000);
            assertTrue(success);
        }
    }

    protected void closeBlockerAndAssertSuccess() {
        TestBlocker blocker;
        synchronized (this) {
            blocker = getTestBlocker();
            testBlocker = null;
        }

        blocker.quit();

        boolean joined = false;
        while (!joined) {
            try {
                blocker.join();
                joined = true;
            } catch (InterruptedException e) {
            }
        }

        try {
            blocker.assertSuccess();
        } catch (Exception e) {
            fail(e.toString());
        }
    }

    protected TestGraphRequestAsyncTask createAsyncTaskOnUiThread(final GraphRequest... requests) throws Throwable {
        final ArrayList<TestGraphRequestAsyncTask> result = new ArrayList<TestGraphRequestAsyncTask>();
        runTestOnUiThread(new Runnable() {
            @Override
            public void run() {
                result.add(new TestGraphRequestAsyncTask(requests));
            }
        });
        return result.isEmpty() ? null : result.get(0);
    }

    

    
    
    protected class TestGraphRequestAsyncTask extends GraphRequestAsyncTask {
        private final TestBlocker blocker = FacebookActivityTestCase.this.getTestBlocker();

        public TestGraphRequestAsyncTask(GraphRequest... requests) {
            super(requests);
        }

        public TestGraphRequestAsyncTask(List<GraphRequest> requests) {
            super(requests);
        }

        public TestGraphRequestAsyncTask(GraphRequestBatch requests) {
            super(requests);
        }

        public TestGraphRequestAsyncTask(HttpURLConnection connection, GraphRequest... requests) {
            super(connection, requests);
        }

        public TestGraphRequestAsyncTask(HttpURLConnection connection, List<GraphRequest> requests) {
            super(connection, requests);
        }

        public TestGraphRequestAsyncTask(HttpURLConnection connection, GraphRequestBatch requests) {
            super(connection, requests);
        }

        public final TestBlocker getBlocker() {
            return blocker;
        }

        public final Exception getThrowable() {
            return getException();
        }

        protected void onPostExecute(List<GraphResponse> result) {
            try {
                super.onPostExecute(result);

                if (getException() != null) {
                    blocker.setException(getException());
                }
            } finally {
                Log.d("TestRequestAsyncTask", "signaling blocker");
                blocker.signal();
            }
        }

        
        
        
        public void executeOnBlockerThread() {
            ensureAsyncTaskLoaded();

            Runnable runnable = new Runnable() {
                public void run() {
                    execute();
                }
            };
            Handler handler = new Handler(blocker.getLooper());
            handler.post(runnable);
        }

        private void ensureAsyncTaskLoaded() {
            
            try {
                runAndBlockOnUiThread(0, new Runnable() {
                    @Override
                    public void run() {
                        try {
                            Class.forName("android.os.AsyncTask");
                        } catch (ClassNotFoundException e) {
                        }
                    }
                });
            } catch (Throwable throwable) {
            }
        }
    }

    
    
    protected class TestCallback implements GraphRequest.Callback {
        private final TestBlocker blocker;
        private final boolean expectSuccess;

        public TestCallback(TestBlocker blocker, boolean expectSuccess) {
            this.blocker = blocker;
            this.expectSuccess = expectSuccess;
        }

        public TestCallback(boolean expectSuccess) {
            this(FacebookActivityTestCase.this.getTestBlocker(), expectSuccess);
        }

        @Override
        public void onCompleted(GraphResponse response) {
            try {
                
                if (Thread.currentThread() != blocker) {
                    throw new FacebookException("Invalid thread " + Thread.currentThread().getId()
                            + "; expected to be called on thread " + blocker.getId());
                }

                
                if (expectSuccess && response.getError() != null) {
                    throw response.getError().getException();
                } else if (!expectSuccess && response.getError() == null) {
                    throw new FacebookException("Expected failure case, received no error");
                }

                
                performAsserts(response);
            } catch (Exception e) {
                blocker.setException(e);
            } finally {
                
                blocker.signal();
            }
        }

        protected void performAsserts(GraphResponse response) {
        }
    }

    
    protected class ExpectSuccessCallback extends TestCallback {
        public ExpectSuccessCallback() {
            super(true);
        }
    }

    
    protected class ExpectFailureCallback extends TestCallback {
        public ExpectFailureCallback() {
            super(false);
        }
    }

    public static abstract class MockGraphRequest extends GraphRequest {
        public abstract GraphResponse createResponse();
    }

    public static class MockGraphRequestBatch extends GraphRequestBatch {
        public MockGraphRequestBatch(MockGraphRequest... requests) {
            super(requests);
        }

        
        public MockGraphRequestBatch(GraphRequestBatch requests) {
            super(requests);
        }

        @Override
        List<GraphResponse> executeAndWaitImpl() {
            List<GraphRequest> requests = getRequests();

            List<GraphResponse> responses = new ArrayList<GraphResponse>();
            for (GraphRequest request : requests) {
                MockGraphRequest mockRequest = (MockGraphRequest) request;
                responses.add(mockRequest.createResponse());
            }

            GraphRequest.runCallbacks(this, responses);

            return responses;
        }
    }

    private AtomicBoolean strictModeOnForUiThread = new AtomicBoolean();

    protected void turnOnStrictModeForUiThread() {
        
        
        if (strictModeOnForUiThread.get() == false) {
            try {
                runTestOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        
                        if (strictModeOnForUiThread.compareAndSet(false, true)) {
                            turnOnStrictModeForThisThread();
                        }
                    }
                });
            } catch (Throwable throwable) {
            }
        }
    }

    protected void turnOnStrictModeForThisThread() {
        
        
        
        try {
            ClassLoader loader = Thread.currentThread().getContextClassLoader();
            Class<?> strictModeClass = Class.forName("android.os.StrictMode", true, loader);
            Class<?> threadPolicyClass = Class.forName(
                    "android.os.StrictMode$ThreadPolicy",
                    true,
                    loader);
            Class<?> threadPolicyBuilderClass = Class.forName(
                    "android.os.StrictMode$ThreadPolicy$Builder",
                    true,
                    loader);

            Object threadPolicyBuilder = threadPolicyBuilderClass.getConstructor().newInstance();
            threadPolicyBuilder = threadPolicyBuilderClass.getMethod("detectAll").invoke(
                    threadPolicyBuilder);
            threadPolicyBuilder = threadPolicyBuilderClass.getMethod("penaltyDeath").invoke(
                    threadPolicyBuilder);

            Object threadPolicy = threadPolicyBuilderClass.getMethod("build").invoke(
                    threadPolicyBuilder);
            strictModeClass.getMethod("setThreadPolicy", threadPolicyClass).invoke(
                    strictModeClass,
                    threadPolicy);
        } catch (Exception ex) {
        }
    }
}

<code block>


package com.facebook;

import android.graphics.Bitmap;
import android.location.Location;
import android.net.Uri;
import android.os.Bundle;
import android.test.suitebuilder.annotation.LargeTest;

import com.facebook.share.ShareApi;
import com.facebook.share.Sharer;
import com.facebook.share.internal.ShareInternalUtility;
import com.facebook.share.model.SharePhoto;
import com.facebook.share.model.SharePhotoContent;
import com.facebook.share.model.ShareVideo;
import com.facebook.share.model.ShareVideoContent;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.net.HttpURLConnection;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;

public class RequestTests extends FacebookTestCase {
    private static final String TEST_OG_TYPE = "facebooksdktests:test";
    private static final long REQUEST_TIMEOUT_MILLIS = 10000;

    protected String[] getDefaultPermissions()
    {
        return new String[] {
                "email",
                "publish_actions",
                "read_stream",
                "user_photos",
                "user_videos" };
    };

    @Override
    public void setUp() throws Exception {
        super.setUp();
        AccessToken.setCurrentAccessToken(getAccessTokenForSharedUser());
    }

    @Override
    public void tearDown() throws Exception {
        AccessToken.setCurrentAccessToken(null);
        super.tearDown();
    }

    @LargeTest
    public void testExecuteSingleGet() {
        GraphRequest request = new GraphRequest(AccessToken.getCurrentAccessToken(), "TourEiffel");
        GraphResponse response = request.executeAndWait();

        assertTrue(response != null);
        assertTrue(response.getError() == null);
        assertNotNull(response.getJSONObject());
        assertNotNull(response.getRawResponse());

        JSONObject graphPlace = response.getJSONObject();
        assertEquals("Paris", graphPlace.optJSONObject("location").optString("city"));
    }

    @LargeTest
    public void testBuildsUploadPhotoHttpURLConnection() throws Exception {
        Bitmap image = createTestBitmap(128);

        GraphRequest request = ShareInternalUtility.newUploadPhotoRequest(
                ShareInternalUtility.MY_PHOTOS,
                AccessToken.getCurrentAccessToken(),
                image,
                "Test photo messsage",
                null,
                null);
        HttpURLConnection connection = GraphRequest.toHttpConnection(request);

        assertTrue(connection != null);
        assertNotSame("gzip", connection.getRequestProperty("Content-Encoding"));
        assertNotSame("application/x-www-form-urlencoded", connection.getRequestProperty("Content-Type"));
    }

    @LargeTest
    public void testExecuteSingleGetUsingHttpURLConnection() throws IOException {
        GraphRequest request = new GraphRequest(AccessToken.getCurrentAccessToken(), "TourEiffel");
        HttpURLConnection connection = GraphRequest.toHttpConnection(request);

        assertEquals("gzip", connection.getRequestProperty("Content-Encoding"));
        assertEquals("application/x-www-form-urlencoded", connection.getRequestProperty("Content-Type"));

        List<GraphResponse> responses = GraphRequest.executeConnectionAndWait(connection, Arrays.asList(new GraphRequest[]{request}));
        assertNotNull(responses);
        assertEquals(1, responses.size());

        GraphResponse response = responses.get(0);

        assertTrue(response != null);
        assertTrue(response.getError() == null);
        assertNotNull(response.getJSONObject());
        assertNotNull(response.getRawResponse());

        JSONObject graphPlace = response.getJSONObject();
        assertEquals("Paris", graphPlace.optJSONObject("location").optString("city"));

        
        int code = connection.getResponseCode();
        assertEquals(200, code);
        assertTrue(connection.getHeaderFields().keySet().contains("Content-Type"));
        connection.disconnect();
    }

    @LargeTest
    public void testFacebookErrorResponseCreatesError() {
        GraphRequest request = new GraphRequest(null, "somestringthatshouldneverbeavalidfobjectid");
        GraphResponse response = request.executeAndWait();

        assertTrue(response != null);

        FacebookRequestError error = response.getError();
        assertNotNull(error);
        FacebookException exception = error.getException();
        assertNotNull(exception);

        assertTrue(exception instanceof FacebookServiceException);
        assertNotNull(error.getErrorType());
        assertTrue(error.getErrorCode() != FacebookRequestError.INVALID_ERROR_CODE);
        assertNotNull(error.getRequestResultBody());
    }

    @LargeTest
    public void testRequestWithNoTokenFails() {
        GraphRequest request = new GraphRequest(null, "me");
        GraphResponse response = request.executeAndWait();

        assertNotNull(response.getError());
    }

    @LargeTest
    public void testExecuteRequestMe() {
        GraphRequest request = GraphRequest.newMeRequest(AccessToken.getCurrentAccessToken(), null);
        GraphResponse response = request.executeAndWait();

        validateMeResponse(AccessToken.getCurrentAccessToken(), response);
    }

    static void validateMeResponse(AccessToken accessToken, GraphResponse response) {
        assertNull(response.getError());

        JSONObject me = response.getJSONObject();
        assertNotNull(me);
        assertEquals(accessToken.getUserId(), me.optString("id"));
        assertNotNull(response.getRawResponse());
    }

    @LargeTest
    public void testExecuteMyFriendsRequest() {
        GraphRequest request =
                GraphRequest.newMyFriendsRequest(AccessToken.getCurrentAccessToken(), null);
        GraphResponse response = request.executeAndWait();

        validateMyFriendsResponse(response);
    }

    static void validateMyFriendsResponse(GraphResponse response) {
        assertNotNull(response);

        assertNull(response.getError());

        JSONObject graphResult = response.getJSONObject();
        assertNotNull(graphResult);

        JSONArray results = graphResult.optJSONArray("data");
        assertNotNull(results);

        assertNotNull(response.getRawResponse());
    }

    @LargeTest
    public void testExecutePlaceRequestWithLocation() {
        Location location = new Location("");
        location.setLatitude(47.6204);
        location.setLongitude(-122.3491);

        GraphRequest request = GraphRequest.newPlacesSearchRequest(
                AccessToken.getCurrentAccessToken(),
                location,
                5,
                5,
                null,
                null);
        GraphResponse response = request.executeAndWait();
        assertNotNull(response);

        assertNull(response.getError());

        JSONObject graphResult = response.getJSONObject();
        assertNotNull(graphResult);

        JSONArray results = graphResult.optJSONArray("data");
        assertNotNull(results);

        assertNotNull(response.getRawResponse());
    }

    @LargeTest
    public void testExecutePlaceRequestWithSearchText() {
        
        GraphRequest request = GraphRequest.newPlacesSearchRequest(
                AccessToken.getCurrentAccessToken(),
                null,
                1000,
                5,
                "Starbucks",
                null);
        GraphResponse response = request.executeAndWait();
        assertNotNull(response);

        assertNull(response.getError());

        JSONObject graphResult = response.getJSONObject();
        assertNotNull(graphResult);

        JSONArray results = graphResult.optJSONArray("data");
        assertNotNull(results);

        assertNotNull(response.getRawResponse());
    }

    @LargeTest
    public void testExecutePlaceRequestWithLocationAndSearchText() {
        Location location = new Location("");
        location.setLatitude(47.6204);
        location.setLongitude(-122.3491);

        GraphRequest request = GraphRequest.newPlacesSearchRequest(
                AccessToken.getCurrentAccessToken(),
                location,
                1000,
                5,
                "Starbucks",
                null);
        GraphResponse response = request.executeAndWait();
        assertNotNull(response);

        assertNull(response.getError());

        JSONObject graphResult = response.getJSONObject();
        assertNotNull(graphResult);

        JSONArray results = graphResult.optJSONArray("data");
        assertNotNull(results);

        assertNotNull(response.getRawResponse());
    }

    private String executePostOpenGraphRequest() {
        JSONObject data = new JSONObject();
        try {
            data.put("a_property", "hello");
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }

        GraphRequest request = ShareInternalUtility.newPostOpenGraphObjectRequest(
                AccessToken.getCurrentAccessToken(),
                TEST_OG_TYPE,
                "a title",
                "http:
                "http:
                "a description",
                data,
                null);
        GraphResponse response = request.executeAndWait();
        assertNotNull(response);

        assertNull(response.getError());

        JSONObject graphResult = response.getJSONObject();
        assertNotNull(graphResult);
        assertNotNull(graphResult.optString("id"));

        assertNotNull(response.getRawResponse());

        return (String) graphResult.optString("id");
    }

    @LargeTest
    public void testExecutePostOpenGraphRequest() {
        executePostOpenGraphRequest();
    }

    @LargeTest
    public void testDeleteObjectRequest() {
        String id = executePostOpenGraphRequest();

        GraphRequest request = GraphRequest.newDeleteObjectRequest(
                AccessToken.getCurrentAccessToken(),
                id,
                null);
        GraphResponse response = request.executeAndWait();
        assertNotNull(response);

        assertNull(response.getError());

        JSONObject result = response.getJSONObject();
        assertNotNull(result);

        assertTrue(result.optBoolean(GraphResponse.SUCCESS_KEY));
        assertNotNull(response.getRawResponse());
    }

    @LargeTest
    public void testUpdateOpenGraphObjectRequest() throws JSONException {
        String id = executePostOpenGraphRequest();

        JSONObject data = new JSONObject();
        data.put("a_property", "goodbye");

        GraphRequest request = ShareInternalUtility.newUpdateOpenGraphObjectRequest(
                AccessToken.getCurrentAccessToken(),
                id,
                "another title",
                null,
                "http:
                "another description",
                data,
                null);
        GraphResponse response = request.executeAndWait();
        assertNotNull(response);

        assertNull(response.getError());

        JSONObject result = response.getJSONObject();
        assertNotNull(result);
        assertNotNull(response.getRawResponse());
    }

    @LargeTest
    public void testExecuteUploadPhoto() {
        Bitmap image = createTestBitmap(128);

        GraphRequest request = ShareInternalUtility.newUploadPhotoRequest(
                ShareInternalUtility.MY_PHOTOS,
                AccessToken.getCurrentAccessToken(),
                image,
                "Test photo message",
                null,
                null);
        GraphResponse response = request.executeAndWait();
        assertNotNull(response);

        assertNull(response.getError());

        JSONObject result = response.getJSONObject();
        assertNotNull(result);
        assertNotNull(response.getRawResponse());
    }

    @LargeTest
    public void testExecuteUploadPhotoViaFile() throws IOException {
        File outputFile = null;
        FileOutputStream outStream = null;

        try {
            Bitmap image = createTestBitmap(128);

            File outputDir = getActivity().getCacheDir(); 
            outputFile = File.createTempFile("prefix", "extension", outputDir);

            outStream = new FileOutputStream(outputFile);
            image.compress(Bitmap.CompressFormat.PNG, 100, outStream);
            outStream.close();
            outStream = null;

            GraphRequest request = ShareInternalUtility.newUploadPhotoRequest(
                    ShareInternalUtility.MY_PHOTOS,
                    AccessToken.getCurrentAccessToken(),
                    outputFile,
                    "Test photo message",
                    null,
                    null);
            GraphResponse response = request.executeAndWait();
            assertNotNull(response);

            assertNull(response.getError());

            JSONObject result = response.getJSONObject();
            assertNotNull(result);
            assertNotNull(response.getRawResponse());
        } finally {
            if (outStream != null) {
                outStream.close();
            }
            if (outputFile != null) {
                outputFile.delete();
            }
        }
    }

    @LargeTest
    public void testExecuteUploadPhotoToAlbum() throws InterruptedException, JSONException {
        
        Bundle params = new Bundle();
        params.putString("name", "Foo");
        GraphRequest request =
                new GraphRequest(
                        AccessToken.getCurrentAccessToken(),
                        "me/albums",
                        params,
                        HttpMethod.POST);

        GraphResponse response = request.executeAndWait();
        JSONObject jsonResponse = response.getJSONObject();
        assertNotNull(jsonResponse);
        String albumId = jsonResponse.optString("id");
        assertNotNull(albumId);

        
        Bitmap image = createTestBitmap(128);
        SharePhoto photo = new SharePhoto.Builder()
                .setBitmap(image)
                .setUserGenerated(true)
                .setParameter("caption", "Caption")
                .build();
        SharePhotoContent content = new SharePhotoContent.Builder().addPhoto(photo).build();
        final ShareApi shareApi = new ShareApi(content);
        shareApi.setGraphNode(albumId);
        final AtomicReference<String> imageId = new AtomicReference<>(null);
        getActivity().runOnUiThread(new Runnable() {
            @Override
            public void run() {
                shareApi.share(new FacebookCallback<Sharer.Result>() {
                    @Override
                    public void onSuccess(Sharer.Result result) {
                        imageId.set(result.getPostId());
                        notifyShareFinished();
                    }

                    @Override
                    public void onCancel() {
                        notifyShareFinished();
                    }

                    @Override
                    public void onError(FacebookException error) {
                        notifyShareFinished();
                    }

                    private void notifyShareFinished() {
                        synchronized (shareApi) {
                            shareApi.notifyAll();
                        }
                    }
                });
            }
        });

        synchronized (shareApi) {
            shareApi.wait(REQUEST_TIMEOUT_MILLIS);
        }
        assertNotNull(imageId.get());

        
        GraphRequest listRequest =
                new GraphRequest(AccessToken.getCurrentAccessToken(), albumId + "/photos");

        GraphResponse listResponse = listRequest.executeAndWait();
        JSONObject listObject = listResponse.getJSONObject();
        assertNotNull(listObject);
        JSONArray jsonList = listObject.optJSONArray("data");
        assertNotNull(jsonList);

        boolean found = false;
        for (int i = 0; i < jsonList.length(); i++) {
            JSONObject imageObject = jsonList.getJSONObject(i);
            if (imageId.get().equals(imageObject.optString("id"))) {
                found = true;
            }
        }
        assertTrue(found);
    }

    @LargeTest
    public void testUploadVideoFile() throws IOException, URISyntaxException {
        File tempFile = null;
        try {
            tempFile = createTempFileFromAsset("DarkScreen.mov");
            ShareVideo video = new ShareVideo.Builder()
                    .setLocalUrl(Uri.fromFile(tempFile))
                    .setParameter("caption", "Caption")
                    .build();
            ShareVideoContent content = new ShareVideoContent.Builder().setVideo(video).build();
            final ShareApi shareApi = new ShareApi(content);
            final AtomicReference<String> videoId = new AtomicReference<>(null);
            getActivity().runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    shareApi.share(new FacebookCallback<Sharer.Result>() {
                        @Override
                        public void onSuccess(Sharer.Result result) {
                            videoId.set(result.getPostId());
                            notifyShareFinished();
                        }

                        @Override
                        public void onCancel() {
                            notifyShareFinished();
                        }

                        @Override
                        public void onError(FacebookException error) {
                            notifyShareFinished();
                        }

                        private void notifyShareFinished() {
                            synchronized (shareApi) {
                                shareApi.notifyAll();
                            }
                        }
                    });
                }
            });

            synchronized (shareApi) {
                shareApi.wait(REQUEST_TIMEOUT_MILLIS);
            }
            assertNotNull(videoId.get());
        } catch (Exception ex) {
            fail();
        } finally {
            if (tempFile != null) {
                tempFile.delete();
            }
        }
    }

    @LargeTest
    public void testUploadVideoFileToUserId() throws IOException, URISyntaxException {
        File tempFile = null;
        try {
            GraphRequest meRequest =
                    GraphRequest.newMeRequest(AccessToken.getCurrentAccessToken(), null);
            GraphResponse meResponse = meRequest.executeAndWait();
            JSONObject meJson = meResponse.getJSONObject();
            assertNotNull(meJson);

            String userId = meJson.optString("id");
            assertNotNull(userId);

            tempFile = createTempFileFromAsset("DarkScreen.mov");
            ShareVideo video = new ShareVideo.Builder()
                    .setLocalUrl(Uri.fromFile(tempFile))
                    .setParameter("caption", "Caption")
                    .build();
            ShareVideoContent content = new ShareVideoContent.Builder().setVideo(video).build();
            final ShareApi shareApi = new ShareApi(content);
            shareApi.setGraphNode(userId);
            final AtomicReference<String> videoId = new AtomicReference<>(null);
            getActivity().runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    shareApi.share(new FacebookCallback<Sharer.Result>() {
                        @Override
                        public void onSuccess(Sharer.Result result) {
                            videoId.set(result.getPostId());
                            notifyShareFinished();
                        }

                        @Override
                        public void onCancel() {
                            notifyShareFinished();
                        }

                        @Override
                        public void onError(FacebookException error) {
                            notifyShareFinished();
                        }

                        private void notifyShareFinished() {
                            synchronized (shareApi) {
                                shareApi.notifyAll();
                            }
                        }
                    });
                }
            });

            synchronized (shareApi) {
                shareApi.wait(REQUEST_TIMEOUT_MILLIS);
            }
            assertNotNull(videoId.get());
        } catch (Exception ex) {
            fail();
        } finally {
            if (tempFile != null) {
                tempFile.delete();
            }
        }
    }

    @LargeTest
    public void testPostStatusUpdate() {
        JSONObject statusUpdate = createStatusUpdate("");

        JSONObject retrievedStatusUpdate = postGetAndAssert(
                AccessToken.getCurrentAccessToken(),
                "me/feed",
                statusUpdate);

        assertEquals(statusUpdate.optString("message"), retrievedStatusUpdate.optString("message"));
    }

    @LargeTest
    public void testCallbackIsCalled() {
        GraphRequest request = new GraphRequest(null, "4");

        final ArrayList<Boolean> calledBack = new ArrayList<Boolean>();
        request.setCallback(new GraphRequest.Callback() {
            @Override
            public void onCompleted(GraphResponse response) {
                calledBack.add(true);
            }
        });

        GraphResponse response = request.executeAndWait();
        assertNotNull(response);
        assertTrue(calledBack.size() == 1);
    }

    @LargeTest
    public void testOnProgressCallbackIsCalled() {
        Bitmap image = Bitmap.createBitmap(128, 128, Bitmap.Config.ALPHA_8);

        GraphRequest request = ShareInternalUtility.newUploadPhotoRequest(
                ShareInternalUtility.MY_PHOTOS,
                null,
                image,
                null,
                null,
                null);
        assertTrue(request != null);

        final ArrayList<Boolean> calledBack = new ArrayList<Boolean>();
        request.setCallback(new GraphRequest.OnProgressCallback() {
            @Override
            public void onCompleted(GraphResponse response) {
            }

            @Override
            public void onProgress(long current, long max) {
                calledBack.add(true);
            }
        });

        GraphResponse response = request.executeAndWait();
        assertNotNull(response);
        assertFalse(calledBack.isEmpty());
    }

    @LargeTest
    public void testLastOnProgressCallbackIsCalledOnce() {
        Bitmap image = Bitmap.createBitmap(128, 128, Bitmap.Config.ALPHA_8);

        GraphRequest request = ShareInternalUtility.newUploadPhotoRequest(
                ShareInternalUtility.MY_PHOTOS,
                null,
                image,
                null,
                null,
                null);
        assertTrue(request != null);

        final ArrayList<Boolean> calledBack = new ArrayList<Boolean>();
        request.setCallback(new GraphRequest.OnProgressCallback() {
            @Override
            public void onCompleted(GraphResponse response) {
            }

            @Override
            public void onProgress(long current, long max) {
                if (current == max) calledBack.add(true);
                else if (current > max) calledBack.clear();
            }
        });

        GraphResponse response = request.executeAndWait();
        assertNotNull(response);
        assertEquals(1, calledBack.size());
    }

    @LargeTest
    public void testBatchTimeoutIsApplied() {
        GraphRequest request = new GraphRequest(null, "me");
        GraphRequestBatch batch = new GraphRequestBatch(request);

        
        batch.setTimeout(1);

        List<GraphResponse> responses = GraphRequest.executeBatchAndWait(batch);
        assertNotNull(responses);
        assertTrue(responses.size() == 1);
        GraphResponse response = responses.get(0);
        assertNotNull(response);
        assertNotNull(response.getError());
    }

    @LargeTest
    public void testBatchTimeoutCantBeNegative() {
        try {
            GraphRequestBatch batch = new GraphRequestBatch();
            batch.setTimeout(-1);
            fail();
        } catch (IllegalArgumentException ex) {
        }
    }

    @LargeTest
    public void testCantUseComplexParameterInGetRequest() {
        Bundle parameters = new Bundle();
        parameters.putShortArray("foo", new short[1]);

        GraphRequest request = new GraphRequest(
                AccessToken.getCurrentAccessToken(),
                "me",
                parameters,
                HttpMethod.GET,
                new ExpectFailureCallback());
        GraphResponse response = request.executeAndWait();

        FacebookRequestError error = response.getError();
        assertNotNull(error);
        FacebookException exception = error.getException();
        assertNotNull(exception);
        assertTrue(exception.getMessage().contains("short[]"));
    }

    private final Location SEATTLE_LOCATION = new Location("") {
        {
            setLatitude(47.6097);
            setLongitude(-122.3331);
        }
    };

    @LargeTest
    public void testPaging() {
        final List<JSONObject> returnedPlaces = new ArrayList<JSONObject>();
        GraphRequest request = GraphRequest
                .newPlacesSearchRequest(
                        AccessToken.getCurrentAccessToken(),
                        SEATTLE_LOCATION,
                        1000,
                        3,
                        null,
                        new GraphRequest.GraphJSONArrayCallback() {
                            @Override
                            public void onCompleted(JSONArray places, GraphResponse response) {
                                if (places == null) {
                                    assertNotNull(places);
                                }
                                for (int i = 0; i < places.length(); ++i) {
                                    returnedPlaces.add(places.optJSONObject(i));
                                }
                            }
                        });
        GraphResponse response = request.executeAndWait();

        assertNull(response.getError());
        assertNotNull(response.getJSONObject());
        assertNotSame(0, returnedPlaces.size());

        returnedPlaces.clear();

        GraphRequest nextRequest = response.getRequestForPagedResults(GraphResponse.PagingDirection.NEXT);
        assertNotNull(nextRequest);

        nextRequest.setCallback(request.getCallback());
        response = nextRequest.executeAndWait();

        assertNull(response.getError());
        assertNotNull(response.getJSONObject());
        assertNotSame(0, returnedPlaces.size());

        returnedPlaces.clear();

        GraphRequest previousRequest = response.getRequestForPagedResults(GraphResponse.PagingDirection.PREVIOUS);
        assertNotNull(previousRequest);

        previousRequest.setCallback(request.getCallback());
        response = previousRequest.executeAndWait();

        assertNull(response.getError());
        assertNotNull(response.getJSONObject());
        assertNotSame(0, returnedPlaces.size());
    }
}

<code block>


package com.facebook.login;

import android.support.v4.app.Fragment;
import android.test.suitebuilder.annotation.LargeTest;
import android.test.suitebuilder.annotation.MediumTest;

import com.facebook.AccessToken;
import com.facebook.FacebookTestCase;
import com.facebook.GraphRequest;
import com.facebook.GraphRequestBatch;
import com.facebook.GraphRequestBatchBridge;
import com.facebook.GraphResponse;
import com.facebook.GraphResponseBridge;
import com.facebook.TestBlocker;
import com.facebook.TestUtils;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.*;
import java.util.*;

public class LoginClientTests extends FacebookTestCase {
    private static final Set<String> PERMISSIONS = new HashSet<String>(
            Arrays.asList("go outside", "come back in"));

    class MockLoginClient extends LoginClient {
        Result result;
        boolean triedNextHandler = false;

        MockLoginClient(Fragment fragment) {
            super(fragment);
        }

        Request getRequest() {
            return pendingRequest;
        }

        void setRequest(Request request) {
            pendingRequest = request;
        }

        @Override
        void complete(Result result) {
            this.result = result;
        }

        @Override
        void tryNextHandler() {
            triedNextHandler = true;
        }
    }

    LoginClient.Request createRequest() {
        return new LoginClient.Request(
                LoginBehavior.SSO_WITH_FALLBACK,
                PERMISSIONS,
                DefaultAudience.FRIENDS,
                "1234",
                null
        );
    }

    class MockValidatingLoginClient extends MockLoginClient {
        private final HashMap<String, String> mapAccessTokenToFbid = new HashMap<String, String>();
        private Set<String> permissionsToReport = new HashSet<String>();
        private TestBlocker blocker;

        public MockValidatingLoginClient(Fragment fragment, TestBlocker blocker) {
            super(fragment);
            this.blocker = blocker;
        }

        public void addAccessTokenToFbidMapping(String accessToken, String fbid) {
            mapAccessTokenToFbid.put(accessToken, fbid);
        }

        public void setPermissionsToReport(Set<String> permissionsToReport) {
            this.permissionsToReport = permissionsToReport;
        }

        @Override
        void complete(Result result) {
            super.complete(result);
            blocker.signal();
        }
    }

    static final String USER_1_FBID = "user1";
    static final String USER_1_ACCESS_TOKEN = "An access token for user 1";
    static final String USER_2_FBID = "user2";
    static final String USER_2_ACCESS_TOKEN = "An access token for user 2";
    static final String APP_ID = "1234";

    LoginClient.Request createNewPermissionRequest() {
        return new LoginClient.Request(
                LoginBehavior.SSO_WITH_FALLBACK,
                PERMISSIONS,
                DefaultAudience.FRIENDS,
                "1234",
                null
        );
    }

    @LargeTest
    public void testReauthorizationWithSameFbidSucceeds() throws Exception {
        TestBlocker blocker = getTestBlocker();

        MockValidatingLoginClient client = new MockValidatingLoginClient(null, blocker);
        client.addAccessTokenToFbidMapping(USER_1_ACCESS_TOKEN, USER_1_FBID);
        client.addAccessTokenToFbidMapping(USER_2_ACCESS_TOKEN, USER_2_FBID);
        client.setPermissionsToReport(PERMISSIONS);

        LoginClient.Request request = createNewPermissionRequest();
        client.setRequest(request);

        AccessToken token = new AccessToken(
                USER_1_ACCESS_TOKEN,
                APP_ID,
                USER_1_FBID,
                PERMISSIONS,
                null,
                null,
                null,
                null);
        AccessToken.setCurrentAccessToken(token);
        LoginClient.Result result = LoginClient.Result.createTokenResult(request, token);

        client.completeAndValidate(result);

        blocker.waitForSignals(1);

        assertNotNull(client.result);
        assertEquals(LoginClient.Result.Code.SUCCESS, client.result.code);

        AccessToken resultToken = client.result.token;
        assertNotNull(resultToken);
        assertEquals(USER_1_ACCESS_TOKEN, resultToken.getToken());

        
        assertEquals(new HashSet<String>(PERMISSIONS), new HashSet<String>(resultToken.getPermissions()));
    }

    @LargeTest
    public void testReauthorizationWithDifferentFbidsFails() throws Exception {
        TestBlocker blocker = getTestBlocker();

        MockValidatingLoginClient client = new MockValidatingLoginClient(null, blocker);
        client.addAccessTokenToFbidMapping(USER_1_ACCESS_TOKEN, USER_1_FBID);
        client.addAccessTokenToFbidMapping(USER_2_ACCESS_TOKEN, USER_2_FBID);
        client.setPermissionsToReport(PERMISSIONS);

        LoginClient.Request request = createNewPermissionRequest();
        client.setRequest(request);

        AccessToken userOneToken = new AccessToken(
                USER_1_ACCESS_TOKEN,
                APP_ID,
                USER_1_FBID,
                PERMISSIONS,
                null,
                null,
                null,
                null);
        AccessToken.setCurrentAccessToken(userOneToken);

        AccessToken userTwoToken = new AccessToken(
                USER_2_ACCESS_TOKEN,
                APP_ID,
                USER_2_FBID,
                PERMISSIONS,
                null,
                null,
                null,
                null);
        LoginClient.Result result = LoginClient.Result.createTokenResult(request, userTwoToken);

        client.completeAndValidate(result);

        blocker.waitForSignals(1);

        assertNotNull(client.result);
        assertEquals(LoginClient.Result.Code.ERROR, client.result.code);

        assertNull(client.result.token);
        assertNotNull(client.result.errorMessage);
    }
}

<code block>


package com.example.switchuser;

import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.graphics.Color;
import android.os.Bundle;
import android.support.v4.app.ListFragment;
import android.view.*;
import android.widget.*;

import com.facebook.AccessToken;
import com.facebook.CallbackManager;
import com.facebook.FacebookCallback;
import com.facebook.FacebookException;
import com.facebook.FacebookSdk;
import com.facebook.Profile;
import com.facebook.ProfileTracker;
import com.facebook.login.LoginBehavior;
import com.facebook.login.LoginManager;
import com.facebook.login.LoginResult;
import com.facebook.login.widget.ProfilePictureView;

import java.util.ArrayList;
import java.util.Arrays;

public class SettingsFragment extends ListFragment {

    public static final String TAG = "SettingsFragment";
    private static final String CURRENT_SLOT_KEY = "CurrentSlot";

    private SlotManager slotManager;
    private Menu optionsMenu;
    private CallbackManager callbackManager;
    private ProfileTracker profileTracker;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        slotManager = new SlotManager();
        slotManager.restore(
                getActivity(),
                savedInstanceState != null ?
                        savedInstanceState.getInt(CURRENT_SLOT_KEY, SlotManager.NO_SLOT) :
                        SlotManager.NO_SLOT);
        ArrayList<Slot> slotList = new ArrayList<Slot>(
                Arrays.asList(slotManager.getAllSlots()));

        Slot currentSlot = slotManager.getSelectedSlot();
        if (currentSlot != null && currentSlot.getAccessToken() != null) {
            AccessToken.setCurrentAccessToken(currentSlot.getAccessToken());
        }

        setListAdapter(new SlotAdapter(slotList));
        setHasOptionsMenu(true);
        setUpCallbacks();
        currentUserChanged();
    }

    @Override
    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
        super.onCreateOptionsMenu(menu, inflater);
        inflater.inflate(R.menu.context_settings, menu);
        optionsMenu = menu;
        updateMenuVisibility();
    }

    private void setUpCallbacks() {
        callbackManager = CallbackManager.Factory.create();
        LoginManager manager = LoginManager.getInstance();
        manager.registerCallback(callbackManager, new FacebookCallback<LoginResult>() {
            @Override
            public void onSuccess(LoginResult loginResult) {
                Profile.fetchProfileForCurrentAccessToken();
            }

            @Override
            public void onError(FacebookException exception) {
                AccessToken.setCurrentAccessToken(null);
                currentUserChanged();
            }

            @Override
            public void onCancel() {
                AccessToken.setCurrentAccessToken(null);
                currentUserChanged();
            }
        });

        profileTracker = new ProfileTracker() {
            @Override
            protected void onCurrentProfileChanged(Profile oldProfile, Profile currentProfile) {
                Slot currentSlot = slotManager.getSelectedSlot();
                AccessToken currentAccessToken = AccessToken.getCurrentAccessToken();
                if(currentSlot != null && currentAccessToken != null && currentProfile != null) {
                    currentSlot.setUserInfo(
                            new UserInfo(currentProfile.getName(), currentAccessToken));
                    currentUserChanged();
                }
            }
        };
    }

    @Override
    public void onListItemClick(ListView l, View view, int position, long id) {
        slotManager.setCurrentUserSlot(position);
        Slot newSlot = slotManager.getSelectedSlot();
        if (newSlot.getAccessToken() == null) {
            final LoginManager manager = LoginManager.getInstance();
            manager.setLoginBehavior(newSlot.getLoginBehavior());
            manager.logInWithReadPermissions(this, null);
        } else {
            AccessToken.setCurrentAccessToken(newSlot.getAccessToken());
        }
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        Slot slot = slotManager.getSelectedSlot();

        if (item.getItemId() == R.id.menu_item_clear_slot) {
            if (slot.getUserId() != null) {
                
                
                
                slot.clear();
                if (slot == slotManager.getSelectedSlot()) {
                    slotManager.setCurrentUserSlot(SlotManager.NO_SLOT);
                }

                currentUserChanged();
            }
            return true;
        }

        return super.onContextItemSelected(item);
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        outState.putInt(CURRENT_SLOT_KEY, slotManager.getSelectedSlotNumber());
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        callbackManager.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        profileTracker.stopTracking();
    }

    private void updateMenuVisibility() {
        if (optionsMenu != null) {
            if (slotManager.getSelectedSlot() == null) {
                optionsMenu.setGroupVisible(0, false);
            } else if (optionsMenu != null) {
                optionsMenu.setGroupVisible(0, true);
            }
        }
    }

    private void currentUserChanged() {
        if (slotManager == null) {
            
            return;
        }

        updateMenuVisibility();
        updateListView();
        Slot currentSlot = slotManager.getSelectedSlot();
        AccessToken currentToken = (currentSlot != null) ? currentSlot.getAccessToken() : null;
        AccessToken.setCurrentAccessToken(currentToken);
    }

    private void updateListView() {
        SlotAdapter adapter = (SlotAdapter) getListAdapter();

        
        if (adapter != null) {
            adapter.notifyDataSetChanged();
        }
    }

    private class SlotManager {
        static final int NO_SLOT = -1;

        private final static int MAX_SLOTS = 4;

        private static final String SETTINGS_CURRENT_SLOT_KEY = "CurrentSlot";
        private static final String SETTINGS_NAME = "UserManagerSettings";

        private SharedPreferences settings;
        private int selectedSlotNumber = NO_SLOT;

        private Slot[] slots;

        public void restore(Context context, int oldSelectedSlot) {
            if (context == null) {
                throw new IllegalArgumentException("context cannot be null");
            }

            slots = new Slot[MAX_SLOTS];
            for (int i = 0; i < MAX_SLOTS; i++) {
                LoginBehavior loginBehavior = (i == 0) ?
                        LoginBehavior.SSO_WITH_FALLBACK :
                        LoginBehavior.SUPPRESS_SSO;
                slots[i] = new Slot(i, loginBehavior);
            }

            
            settings = FacebookSdk.getApplicationContext().getSharedPreferences(
                    SETTINGS_NAME, Context.MODE_PRIVATE);
            int savedSlotNumber = settings.getInt(SETTINGS_CURRENT_SLOT_KEY, NO_SLOT);
            if (savedSlotNumber != NO_SLOT && savedSlotNumber != oldSelectedSlot) {
                
                setCurrentUserSlot(savedSlotNumber);
            } else {
                
                
                
                setCurrentUserSlot(savedSlotNumber);
            }
        }

        public Slot getSelectedSlot() {
            if (selectedSlotNumber == NO_SLOT) {
                return null;
            } else {
                return getSlot(selectedSlotNumber);
            }
        }

        public int getSelectedSlotNumber() {
            return selectedSlotNumber;
        }

        public void setCurrentUserSlot(int slot) {
            if (slot != selectedSlotNumber) {
                
                settings.edit().putInt(SETTINGS_CURRENT_SLOT_KEY, slot).apply();
                selectedSlotNumber = slot;
                currentUserChanged();
            }
        }

        private Slot[] getAllSlots() {
            return slots;
        }

        private Slot getSlot(int slot) {
            validateSlot(slot);
            return slots[slot];
        }

        private void validateSlot(int slot) {
            if (slot <= NO_SLOT || slot >= MAX_SLOTS) {
                throw new IllegalArgumentException(
                        String.format("Choose a slot between 0 and %d inclusively", MAX_SLOTS - 1));
            }
        }
    }

    private class SlotAdapter extends ArrayAdapter<Slot> {

        public SlotAdapter(ArrayList<Slot> slots) {
            super(getActivity(), android.R.layout.simple_list_item_1, slots);
        }

        @Override
        public View getView(final int position, View convertView, ViewGroup parent) {
            if (null == convertView) {
                convertView = getActivity().getLayoutInflater()
                        .inflate(R.layout.list_item_user, parent, false);
            }

            Slot slot = getItem(position);
            if (slot.getLoginBehavior() != LoginBehavior.SUPPRESS_SSO) {
                convertView.setBackgroundColor(Color.argb(50, 255, 255, 255));
            }

            String userName = slot.getUserName();
            if (userName == null) {
                userName = getString(R.string.empty_slot);
            }

            String userId = slot.getUserId();
            ProfilePictureView profilePic = (ProfilePictureView) convertView.findViewById(
                    R.id.slotPic);
            if (userId != null) {
                profilePic.setProfileId(userId);
            } else {
                profilePic.setProfileId(null);
            }

            TextView userNameTextView = (TextView) convertView.findViewById(
                    R.id.slotUserName);
            userNameTextView.setText(userName);

            final CheckBox currentUserCheckBox = (CheckBox) convertView.findViewById(
                    R.id.currentUserIndicator);
            currentUserCheckBox.setChecked(
                    slotManager.getSelectedSlot() == slot
                            && slot.getUserInfo() != null);
            currentUserCheckBox.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    if (currentUserCheckBox.isChecked()) {
                        slotManager.setCurrentUserSlot(position);
                    } else {
                        slotManager.setCurrentUserSlot(SlotManager.NO_SLOT);
                    }
                    SlotAdapter adapter = (SlotAdapter) getListAdapter();
                    adapter.notifyDataSetChanged();
                }
            });

            currentUserCheckBox.setEnabled(slot.getAccessToken() != null);

            return convertView;
        }

    }
}

<code block>


package com.facebook;

final class FacebookSdkVersion {
    public static final String BUILD = "4.3.0";
}

<code block>


package com.facebook;

import android.content.Context;
import android.graphics.Bitmap;
import android.location.Location;
import android.net.Uri;
import android.os.*;
import android.text.TextUtils;
import android.util.Log;
import android.util.Pair;

import com.facebook.internal.*;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.*;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLEncoder;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.zip.GZIPOutputStream;


public class GraphRequest {
    
    public static final int MAXIMUM_BATCH_SIZE = 50;

    public static final String TAG = GraphRequest.class.getSimpleName();

    private static final String VIDEOS_SUFFIX = "/videos";
    private static final String ME = "me";
    private static final String MY_FRIENDS = "me/friends";
    private static final String SEARCH = "search";
    private static final String USER_AGENT_BASE = "FBAndroidSDK";
    private static final String USER_AGENT_HEADER = "User-Agent";
    private static final String CONTENT_TYPE_HEADER = "Content-Type";
    private static final String ACCEPT_LANGUAGE_HEADER = "Accept-Language";
    private static final String CONTENT_ENCODING_HEADER = "Content-Encoding";

    
    private static final String FORMAT_PARAM = "format";
    private static final String FORMAT_JSON = "json";
    private static final String SDK_PARAM = "sdk";
    private static final String SDK_ANDROID = "android";
    private static final String ACCESS_TOKEN_PARAM = "access_token";
    private static final String BATCH_ENTRY_NAME_PARAM = "name";
    private static final String BATCH_ENTRY_OMIT_RESPONSE_ON_SUCCESS_PARAM =
            "omit_response_on_success";
    private static final String BATCH_ENTRY_DEPENDS_ON_PARAM = "depends_on";
    private static final String BATCH_APP_ID_PARAM = "batch_app_id";
    private static final String BATCH_RELATIVE_URL_PARAM = "relative_url";
    private static final String BATCH_BODY_PARAM = "body";
    private static final String BATCH_METHOD_PARAM = "method";
    private static final String BATCH_PARAM = "batch";
    private static final String ATTACHMENT_FILENAME_PREFIX = "file";
    private static final String ATTACHED_FILES_PARAM = "attached_files";
    private static final String ISO_8601_FORMAT_STRING = "yyyy-MM-dd'T'HH:mm:ssZ";
    private static final String DEBUG_PARAM = "debug";
    private static final String DEBUG_SEVERITY_INFO = "info";
    private static final String DEBUG_SEVERITY_WARNING = "warning";
    private static final String DEBUG_KEY = "__debug__";
    private static final String DEBUG_MESSAGES_KEY = "messages";
    private static final String DEBUG_MESSAGE_KEY = "message";
    private static final String DEBUG_MESSAGE_TYPE_KEY = "type";
    private static final String DEBUG_MESSAGE_LINK_KEY = "link";

    private static final String MIME_BOUNDARY = "3i2ndDfv2rTHiSisAbouNdArYfORhtTPEefj3q2f";

    private static String defaultBatchApplicationId;

    
    private static Pattern versionPattern = Pattern.compile("^/?v\\d+\\.\\d+/(.*)");

    private AccessToken accessToken;
    private HttpMethod httpMethod;
    private String graphPath;
    private JSONObject graphObject;
    private String batchEntryName;
    private String batchEntryDependsOn;
    private boolean batchEntryOmitResultOnSuccess = true;
    private Bundle parameters;
    private Callback callback;
    private String overriddenURL;
    private Object tag;
    private String version;
    private boolean skipClientToken = false;

    
    public GraphRequest() {
        this(null, null, null, null, null);
    }

    
    public GraphRequest(AccessToken accessToken, String graphPath) {
        this(accessToken, graphPath, null, null, null);
    }

    
    public GraphRequest(
            AccessToken accessToken,
            String graphPath,
            Bundle parameters,
            HttpMethod httpMethod) {
        this(accessToken, graphPath, parameters, httpMethod, null);
    }

    
    public GraphRequest(
            AccessToken accessToken,
            String graphPath,
            Bundle parameters,
            HttpMethod httpMethod,
            Callback callback) {
        this(accessToken, graphPath, parameters, httpMethod, callback, null);
    }

    
    public GraphRequest(
            AccessToken accessToken,
            String graphPath,
            Bundle parameters,
            HttpMethod httpMethod,
            Callback callback,
            String version) {
        this.accessToken = accessToken;
        this.graphPath = graphPath;
        this.version = version;

        setCallback(callback);
        setHttpMethod(httpMethod);

        if (parameters != null) {
            this.parameters = new Bundle(parameters);
        } else {
            this.parameters = new Bundle();
        }

        if (this.version == null) {
            this.version = ServerProtocol.getAPIVersion();
        }
    }

    GraphRequest(AccessToken accessToken, URL overriddenURL) {
        this.accessToken = accessToken;
        this.overriddenURL = overriddenURL.toString();

        setHttpMethod(HttpMethod.GET);

        this.parameters = new Bundle();
    }

    
    public static GraphRequest newDeleteObjectRequest(
            AccessToken accessToken,
            String id,
            Callback callback) {
        return new GraphRequest(accessToken, id, null, HttpMethod.DELETE, callback);
    }

    
    public static GraphRequest newMeRequest(
            AccessToken accessToken,
            final GraphJSONObjectCallback callback) {
        Callback wrapper = new Callback() {
            @Override
            public void onCompleted(GraphResponse response) {
                if (callback != null) {
                    callback.onCompleted(response.getJSONObject(), response);
                }
            }
        };
        return new GraphRequest(accessToken, ME, null, null, wrapper);
    }

    
    public static GraphRequest newPostRequest(
            AccessToken accessToken,
            String graphPath,
            JSONObject graphObject,
            Callback callback) {
        GraphRequest request = new GraphRequest(
                accessToken,
                graphPath,
                null,
                HttpMethod.POST,
                callback);
        request.setGraphObject(graphObject);
        return request;
    }

    
    public static GraphRequest newMyFriendsRequest(
            AccessToken accessToken,
            final GraphJSONArrayCallback callback) {
        Callback wrapper = new Callback() {
            @Override
            public void onCompleted(GraphResponse response) {
                if (callback != null) {
                    JSONObject result = response.getJSONObject();
                    JSONArray data = result != null ? result.optJSONArray("data") : null;
                    callback.onCompleted(data, response);
                }
            }
        };
        return new GraphRequest(accessToken, MY_FRIENDS, null, null, wrapper);
    }

    
    public static GraphRequest newGraphPathRequest(
            AccessToken accessToken,
            String graphPath,
            Callback callback) {
        return new GraphRequest(accessToken, graphPath, null, null, callback);
    }

    
    public static GraphRequest newPlacesSearchRequest(
            AccessToken accessToken,
            Location location,
            int radiusInMeters,
            int resultsLimit,
            String searchText,
            final GraphJSONArrayCallback callback) {
        if (location == null && Utility.isNullOrEmpty(searchText)) {
            throw new FacebookException("Either location or searchText must be specified.");
        }

        Bundle parameters = new Bundle(5);
        parameters.putString("type", "place");
        parameters.putInt("limit", resultsLimit);
        if (location != null) {
            parameters.putString("center",
                    String.format(
                            Locale.US,
                            "%f,%f",
                            location.getLatitude(),
                            location.getLongitude()));
            parameters.putInt("distance", radiusInMeters);
        }
        if (!Utility.isNullOrEmpty(searchText)) {
            parameters.putString("q", searchText);
        }

        Callback wrapper = new Callback() {
            @Override
            public void onCompleted(GraphResponse response) {
                if (callback != null) {
                    JSONObject result = response.getJSONObject();
                    JSONArray data = result != null ? result.optJSONArray("data") : null;
                    callback.onCompleted(data, response);
                }
            }
        };

        return new GraphRequest(accessToken, SEARCH, parameters, HttpMethod.GET, wrapper);
    }


    
    public static GraphRequest newCustomAudienceThirdPartyIdRequest(AccessToken accessToken,
                                                                    Context context,
                                                                    String applicationId,
                                                                    Callback callback) {

        if (applicationId == null && accessToken != null) {
            applicationId = accessToken.getApplicationId();
        }

        if (applicationId == null) {
            applicationId = Utility.getMetadataApplicationId(context);
        }

        if (applicationId == null) {
            throw new FacebookException("Facebook App ID cannot be determined");
        }

        String endpoint = applicationId + "/custom_audience_third_party_id";
        AttributionIdentifiers attributionIdentifiers =
                AttributionIdentifiers.getAttributionIdentifiers(context);
        Bundle parameters = new Bundle();

        if (accessToken == null) {
            
            
            String udid = attributionIdentifiers.getAttributionId() != null
                    ? attributionIdentifiers.getAttributionId()
                    : attributionIdentifiers.getAndroidAdvertiserId();
            if (attributionIdentifiers.getAttributionId() != null) {
                parameters.putString("udid", udid);
            }
        }

        
        
        if (FacebookSdk.getLimitEventAndDataUsage(context)
                || attributionIdentifiers.isTrackingLimited()) {
            parameters.putString("limit_event_usage", "1");
        }

        return new GraphRequest(accessToken, endpoint, parameters, HttpMethod.GET, callback);
    }

    
    public static GraphRequest newCustomAudienceThirdPartyIdRequest(
            AccessToken accessToken,
            Context context,
            Callback callback) {
        return newCustomAudienceThirdPartyIdRequest(accessToken, context, null, callback);
    }

    
    public final JSONObject getGraphObject() {
        return this.graphObject;
    }

    
    public final void setGraphObject(JSONObject graphObject) {
        this.graphObject = graphObject;
    }

    
    public final String getGraphPath() {
        return this.graphPath;
    }

    
    public final void setGraphPath(String graphPath) {
        this.graphPath = graphPath;
    }

    
    public final HttpMethod getHttpMethod() {
        return this.httpMethod;
    }

    
    public final void setHttpMethod(HttpMethod httpMethod) {
        if (overriddenURL != null && httpMethod != HttpMethod.GET) {
            throw new FacebookException("Can't change HTTP method on request with overridden URL.");
        }
        this.httpMethod = (httpMethod != null) ? httpMethod : HttpMethod.GET;
    }

    
    public final String getVersion() {
        return this.version;
    }

    
    public final void setVersion(String version) {
        this.version = version;
    }

    
    public final void setSkipClientToken(boolean skipClientToken) {
        this.skipClientToken = skipClientToken;
    }

    
    public final Bundle getParameters() {
        return this.parameters;
    }

    
    public final void setParameters(Bundle parameters) {
        this.parameters = parameters;
    }

    
    public final AccessToken getAccessToken() {
        return this.accessToken;
    }

    
    public final void setAccessToken(AccessToken accessToken) {
        this.accessToken = accessToken;
    }

    
    public final String getBatchEntryName() {
        return this.batchEntryName;
    }

    
    public final void setBatchEntryName(String batchEntryName) {
        this.batchEntryName = batchEntryName;
    }

    
    public final String getBatchEntryDependsOn() {
        return this.batchEntryDependsOn;
    }

    
    public final void setBatchEntryDependsOn(String batchEntryDependsOn) {
        this.batchEntryDependsOn = batchEntryDependsOn;
    }


    
    public final boolean getBatchEntryOmitResultOnSuccess() {
        return this.batchEntryOmitResultOnSuccess;
    }

    
    public final void setBatchEntryOmitResultOnSuccess(boolean batchEntryOmitResultOnSuccess) {
        this.batchEntryOmitResultOnSuccess = batchEntryOmitResultOnSuccess;
    }

    
    public static final String getDefaultBatchApplicationId() {
        return GraphRequest.defaultBatchApplicationId;
    }

    
    public static final void setDefaultBatchApplicationId(String applicationId) {
        defaultBatchApplicationId = applicationId;
    }

    
    public final Callback getCallback() {
        return callback;
    }

    
    public final void setCallback(final Callback callback) {
        
        if (FacebookSdk.isLoggingBehaviorEnabled(LoggingBehavior.GRAPH_API_DEBUG_INFO)
                || FacebookSdk.isLoggingBehaviorEnabled(LoggingBehavior.GRAPH_API_DEBUG_WARNING)) {
            Callback wrapper = new Callback() {
                @Override
                public void onCompleted(GraphResponse response) {
                    JSONObject responseObject = response.getJSONObject();
                    JSONObject debug =
                            responseObject != null ? responseObject.optJSONObject(DEBUG_KEY) : null;
                    JSONArray debugMessages =
                            debug != null ? debug.optJSONArray(DEBUG_MESSAGES_KEY) : null;
                    if (debugMessages != null) {
                        for (int i = 0; i < debugMessages.length(); ++i) {
                            JSONObject debugMessageObject = debugMessages.optJSONObject(i);
                            String debugMessage = debugMessageObject != null
                                    ? debugMessageObject.optString(DEBUG_MESSAGE_KEY)
                                    : null;
                            String debugMessageType = debugMessageObject != null
                                    ? debugMessageObject.optString(DEBUG_MESSAGE_TYPE_KEY)
                                    : null;
                            String debugMessageLink = debugMessageObject != null
                                    ? debugMessageObject.optString(DEBUG_MESSAGE_LINK_KEY)
                                    : null;
                            if (debugMessage != null && debugMessageType != null) {
                                LoggingBehavior behavior = LoggingBehavior.GRAPH_API_DEBUG_INFO;
                                if (debugMessageType.equals("warning")) {
                                    behavior = LoggingBehavior.GRAPH_API_DEBUG_WARNING;
                                }
                                if (!Utility.isNullOrEmpty(debugMessageLink)) {
                                    debugMessage += " Link: " + debugMessageLink;
                                }
                                Logger.log(behavior, TAG, debugMessage);
                            }
                        }
                    }
                    if (callback != null) {
                        callback.onCompleted(response);
                    }
                }
            };
            this.callback = wrapper;
        } else {
            this.callback = callback;
        }

    }

    
    public final void setTag(Object tag) {
        this.tag = tag;
    }

    
    public final Object getTag() {
        return tag;
    }

    
    public final GraphResponse executeAndWait() {
        return GraphRequest.executeAndWait(this);
    }

    
    public final GraphRequestAsyncTask executeAsync() {
        return GraphRequest.executeBatchAsync(this);
    }

    
    public static HttpURLConnection toHttpConnection(GraphRequest... requests) {
        return toHttpConnection(Arrays.asList(requests));
    }

    
    public static HttpURLConnection toHttpConnection(Collection<GraphRequest> requests) {
        Validate.notEmptyAndContainsNoNulls(requests, "requests");

        return toHttpConnection(new GraphRequestBatch(requests));
    }

    
    public static HttpURLConnection toHttpConnection(GraphRequestBatch requests) {

        URL url;
        try {
            if (requests.size() == 1) {
                
                GraphRequest request = requests.get(0);
                
                
                url = new URL(request.getUrlForSingleRequest());
            } else {
                
                
                url = new URL(ServerProtocol.getGraphUrlBase());
            }
        } catch (MalformedURLException e) {
            throw new FacebookException("could not construct URL for request", e);
        }

        HttpURLConnection connection;
        try {
            connection = createConnection(url);

            serializeToUrlConnection(requests, connection);
        } catch (IOException e) {
            throw new FacebookException("could not construct request body", e);
        } catch (JSONException e) {
            throw new FacebookException("could not construct request body", e);
        }

        return connection;
    }

    
    public static GraphResponse executeAndWait(GraphRequest request) {
        List<GraphResponse> responses = executeBatchAndWait(request);

        if (responses == null || responses.size() != 1) {
            throw new FacebookException("invalid state: expected a single response");
        }

        return responses.get(0);
    }

    
    public static List<GraphResponse> executeBatchAndWait(GraphRequest... requests) {
        Validate.notNull(requests, "requests");

        return executeBatchAndWait(Arrays.asList(requests));
    }

    
    public static List<GraphResponse> executeBatchAndWait(Collection<GraphRequest> requests) {
        return executeBatchAndWait(new GraphRequestBatch(requests));
    }

    
    public static List<GraphResponse> executeBatchAndWait(GraphRequestBatch requests) {
        Validate.notEmptyAndContainsNoNulls(requests, "requests");

        HttpURLConnection connection = null;
        try {
            connection = toHttpConnection(requests);
        } catch (Exception ex) {
            List<GraphResponse> responses = GraphResponse.constructErrorResponses(
                    requests.getRequests(),
                    null,
                    new FacebookException(ex));
            runCallbacks(requests, responses);
            return responses;
        }

        List<GraphResponse> responses = executeConnectionAndWait(connection, requests);
        return responses;
    }

    
    public static GraphRequestAsyncTask executeBatchAsync(GraphRequest... requests) {
        Validate.notNull(requests, "requests");

        return executeBatchAsync(Arrays.asList(requests));
    }

    
    public static GraphRequestAsyncTask executeBatchAsync(Collection<GraphRequest> requests) {
        return executeBatchAsync(new GraphRequestBatch(requests));
    }

    
    public static GraphRequestAsyncTask executeBatchAsync(GraphRequestBatch requests) {
        Validate.notEmptyAndContainsNoNulls(requests, "requests");

        GraphRequestAsyncTask asyncTask = new GraphRequestAsyncTask(requests);
        asyncTask.executeOnSettingsExecutor();
        return asyncTask;
    }

    
    public static List<GraphResponse> executeConnectionAndWait(
            HttpURLConnection connection,
            Collection<GraphRequest> requests) {
        return executeConnectionAndWait(connection, new GraphRequestBatch(requests));
    }

    
    public static List<GraphResponse> executeConnectionAndWait(
            HttpURLConnection connection,
            GraphRequestBatch requests) {
        List<GraphResponse> responses = GraphResponse.fromHttpConnection(connection, requests);

        Utility.disconnectQuietly(connection);

        int numRequests = requests.size();
        if (numRequests != responses.size()) {
            throw new FacebookException(
                    String.format(Locale.US,
                            "Received %d responses while expecting %d",
                            responses.size(),
                            numRequests));
        }

        runCallbacks(requests, responses);

        
        AccessTokenManager.getInstance().extendAccessTokenIfNeeded();

        return responses;
    }

    
    public static GraphRequestAsyncTask executeConnectionAsync(
            HttpURLConnection connection,
            GraphRequestBatch requests) {
        return executeConnectionAsync(null, connection, requests);
    }

    
    public static GraphRequestAsyncTask executeConnectionAsync(
            Handler callbackHandler,
            HttpURLConnection connection,
            GraphRequestBatch requests) {
        Validate.notNull(connection, "connection");

        GraphRequestAsyncTask asyncTask = new GraphRequestAsyncTask(connection, requests);
        requests.setCallbackHandler(callbackHandler);
        asyncTask.executeOnSettingsExecutor();
        return asyncTask;
    }

    
    @Override
    public String toString() {
        return new StringBuilder()
                .append("{Request: ")
                .append(" accessToken: ")
                .append(accessToken == null ? "null" : accessToken)
                .append(", graphPath: ")
                .append(graphPath)
                .append(", graphObject: ")
                .append(graphObject)
                .append(", httpMethod: ")
                .append(httpMethod)
                .append(", parameters: ")
                .append(parameters)
                .append("}")
                .toString();
    }

    static void runCallbacks(final GraphRequestBatch requests, List<GraphResponse> responses) {
        int numRequests = requests.size();

        
        
        final ArrayList<Pair<Callback, GraphResponse>> callbacks = new ArrayList<Pair<Callback, GraphResponse>>();
        for (int i = 0; i < numRequests; ++i) {
            GraphRequest request = requests.get(i);
            if (request.callback != null) {
                callbacks.add(
                        new Pair<Callback, GraphResponse>(request.callback, responses.get(i)));
            }
        }

        if (callbacks.size() > 0) {
            Runnable runnable = new Runnable() {
                public void run() {
                    for (Pair<Callback, GraphResponse> pair : callbacks) {
                        pair.first.onCompleted(pair.second);
                    }

                    List<GraphRequestBatch.Callback> batchCallbacks = requests.getCallbacks();
                    for (GraphRequestBatch.Callback batchCallback : batchCallbacks) {
                        batchCallback.onBatchCompleted(requests);
                    }
                }
            };

            Handler callbackHandler = requests.getCallbackHandler();
            if (callbackHandler == null) {
                
                runnable.run();
            } else {
                
                callbackHandler.post(runnable);
            }
        }
    }

    private static HttpURLConnection createConnection(URL url) throws IOException {
        HttpURLConnection connection;
        connection = (HttpURLConnection) url.openConnection();

        connection.setRequestProperty(USER_AGENT_HEADER, getUserAgent());
        connection.setRequestProperty(ACCEPT_LANGUAGE_HEADER, Locale.getDefault().toString());

        connection.setChunkedStreamingMode(0);
        return connection;
    }


    private void addCommonParameters() {
        if (this.accessToken != null) {
            if (!this.parameters.containsKey(ACCESS_TOKEN_PARAM)) {
                String token = accessToken.getToken();
                Logger.registerAccessToken(token);
                this.parameters.putString(ACCESS_TOKEN_PARAM, token);
            }
        } else if (!skipClientToken && !this.parameters.containsKey(ACCESS_TOKEN_PARAM)) {
            String appID = FacebookSdk.getApplicationId();
            String clientToken = FacebookSdk.getClientToken();
            if (!Utility.isNullOrEmpty(appID) && !Utility.isNullOrEmpty(clientToken)) {
                String accessToken = appID + "|" + clientToken;
                this.parameters.putString(ACCESS_TOKEN_PARAM, accessToken);
            } else {
                Log.d(TAG, "Warning: Request without access token missing application ID or" +
                        " client token.");
            }
        }
        this.parameters.putString(SDK_PARAM, SDK_ANDROID);
        this.parameters.putString(FORMAT_PARAM, FORMAT_JSON);

        if (FacebookSdk.isLoggingBehaviorEnabled(LoggingBehavior.GRAPH_API_DEBUG_INFO)) {
            this.parameters.putString(DEBUG_PARAM, DEBUG_SEVERITY_INFO);
        } else if (FacebookSdk.isLoggingBehaviorEnabled(LoggingBehavior.GRAPH_API_DEBUG_WARNING)) {
            this.parameters.putString(DEBUG_PARAM, DEBUG_SEVERITY_WARNING);
        }
    }

    private String appendParametersToBaseUrl(String baseUrl) {
        Uri.Builder uriBuilder = new Uri.Builder().encodedPath(baseUrl);

        Set<String> keys = this.parameters.keySet();
        for (String key : keys) {
            Object value = this.parameters.get(key);

            if (value == null) {
                value = "";
            }

            if (isSupportedParameterType(value)) {
                value = parameterToString(value);
            } else {
                if (httpMethod == HttpMethod.GET) {
                    throw new IllegalArgumentException(
                            String.format(
                                    Locale.US,
                                    "Unsupported parameter type for GET request: %s",
                                    value.getClass().getSimpleName()));
                }
                continue;
            }

            uriBuilder.appendQueryParameter(key, value.toString());
        }

        return uriBuilder.toString();
    }

    final String getUrlForBatchedRequest() {
        if (overriddenURL != null) {
            throw new FacebookException("Can't override URL for a batch request");
        }

        String baseUrl = getGraphPathWithVersion();
        addCommonParameters();
        return appendParametersToBaseUrl(baseUrl);
    }

    final String getUrlForSingleRequest() {
        if (overriddenURL != null) {
            return overriddenURL.toString();
        }

        String graphBaseUrlBase;
        if (this.getHttpMethod() == HttpMethod.POST
                && graphPath != null
                && graphPath.endsWith(VIDEOS_SUFFIX)) {
            graphBaseUrlBase = ServerProtocol.getGraphVideoUrlBase();
        } else {
            graphBaseUrlBase = ServerProtocol.getGraphUrlBase();
        }
        String baseUrl = String.format("%s/%s", graphBaseUrlBase, getGraphPathWithVersion());

        addCommonParameters();
        return appendParametersToBaseUrl(baseUrl);
    }

    private String getGraphPathWithVersion() {
        Matcher matcher = versionPattern.matcher(this.graphPath);
        if (matcher.matches()) {
            return this.graphPath;
        }
        return String.format("%s/%s", this.version, this.graphPath);
    }

    private static class Attachment {
        private final GraphRequest request;
        private final Object value;

        public Attachment(GraphRequest request, Object value) {
            this.request = request;
            this.value = value;
        }

        public GraphRequest getRequest() {
            return request;
        }

        public Object getValue() {
            return value;
        }
    }

    private void serializeToBatch(
            JSONArray batch,
            Map<String, Attachment> attachments
    ) throws JSONException, IOException {
        JSONObject batchEntry = new JSONObject();

        if (this.batchEntryName != null) {
            batchEntry.put(BATCH_ENTRY_NAME_PARAM, this.batchEntryName);
            batchEntry.put(
                    BATCH_ENTRY_OMIT_RESPONSE_ON_SUCCESS_PARAM,
                    this.batchEntryOmitResultOnSuccess);
        }
        if (this.batchEntryDependsOn != null) {
            batchEntry.put(BATCH_ENTRY_DEPENDS_ON_PARAM, this.batchEntryDependsOn);
        }

        String relativeURL = getUrlForBatchedRequest();
        batchEntry.put(BATCH_RELATIVE_URL_PARAM, relativeURL);
        batchEntry.put(BATCH_METHOD_PARAM, httpMethod);
        if (this.accessToken != null) {
            String token = this.accessToken.getToken();
            Logger.registerAccessToken(token);
        }

        
        ArrayList<String> attachmentNames = new ArrayList<String>();
        Set<String> keys = this.parameters.keySet();
        for (String key : keys) {
            Object value = this.parameters.get(key);
            if (isSupportedAttachmentType(value)) {
                
                String name = String.format(
                        Locale.ROOT,
                        "%s%d",
                        ATTACHMENT_FILENAME_PREFIX,
                        attachments.size());
                attachmentNames.add(name);
                attachments.put(name, new Attachment(this, value));
            }
        }

        if (!attachmentNames.isEmpty()) {
            String attachmentNamesString = TextUtils.join(",", attachmentNames);
            batchEntry.put(ATTACHED_FILES_PARAM, attachmentNamesString);
        }

        if (this.graphObject != null) {
            
            final ArrayList<String> keysAndValues = new ArrayList<String>();
            processGraphObject(this.graphObject, relativeURL, new KeyValueSerializer() {
                @Override
                public void writeString(String key, String value) throws IOException {
                    keysAndValues.add(String.format(
                            Locale.US,
                            "%s=%s",
                            key,
                            URLEncoder.encode(value, "UTF-8")));
                }
            });
            String bodyValue = TextUtils.join("&", keysAndValues);
            batchEntry.put(BATCH_BODY_PARAM, bodyValue);
        }

        batch.put(batchEntry);
    }

    private static boolean hasOnProgressCallbacks(GraphRequestBatch requests) {
        for (GraphRequestBatch.Callback callback : requests.getCallbacks()) {
            if (callback instanceof GraphRequestBatch.OnProgressCallback) {
                return true;
            }
        }

        for (GraphRequest request : requests) {
            if (request.getCallback() instanceof OnProgressCallback) {
                return true;
            }
        }

        return false;
    }

    private static void setConnectionContentType(
            HttpURLConnection connection,
            boolean shouldUseGzip) {
        if (shouldUseGzip) {
            connection.setRequestProperty(CONTENT_TYPE_HEADER, "application/x-www-form-urlencoded");
            connection.setRequestProperty(CONTENT_ENCODING_HEADER, "gzip");
        } else {
            connection.setRequestProperty(CONTENT_TYPE_HEADER, getMimeContentType());
        }
    }

    private static boolean isGzipCompressible(GraphRequestBatch requests) {
        for (GraphRequest request : requests) {
            for (String key : request.parameters.keySet()) {
                Object value = request.parameters.get(key);
                if (isSupportedAttachmentType(value)) {
                    return false;
                }
            }
        }
        return true;
    }

    final static void serializeToUrlConnection(
            GraphRequestBatch requests,
            HttpURLConnection connection
    ) throws IOException, JSONException {
        Logger logger = new Logger(LoggingBehavior.REQUESTS, "Request");

        int numRequests = requests.size();
        boolean shouldUseGzip = isGzipCompressible(requests);

        HttpMethod connectionHttpMethod =
                (numRequests == 1) ? requests.get(0).httpMethod : HttpMethod.POST;
        connection.setRequestMethod(connectionHttpMethod.name());
        setConnectionContentType(connection, shouldUseGzip);

        URL url = connection.getURL();
        logger.append("Request:\n");
        logger.appendKeyValue("Id", requests.getId());
        logger.appendKeyValue("URL", url);
        logger.appendKeyValue("Method", connection.getRequestMethod());
        logger.appendKeyValue("User-Agent", connection.getRequestProperty("User-Agent"));
        logger.appendKeyValue("Content-Type", connection.getRequestProperty("Content-Type"));

        connection.setConnectTimeout(requests.getTimeout());
        connection.setReadTimeout(requests.getTimeout());

        
        
        boolean isPost = (connectionHttpMethod == HttpMethod.POST);
        if (!isPost) {
            logger.log();
            return;
        }

        connection.setDoOutput(true);

        OutputStream outputStream = null;
        try {
            outputStream = new BufferedOutputStream(connection.getOutputStream());
            if (shouldUseGzip) {
                outputStream = new GZIPOutputStream(outputStream);
            }

            if (hasOnProgressCallbacks(requests)) {
                ProgressNoopOutputStream countingStream = null;
                countingStream = new ProgressNoopOutputStream(requests.getCallbackHandler());
                processRequest(requests, null, numRequests, url, countingStream, shouldUseGzip);

                int max = countingStream.getMaxProgress();
                Map<GraphRequest, RequestProgress> progressMap = countingStream.getProgressMap();

                outputStream = new ProgressOutputStream(outputStream, requests, progressMap, max);
            }

            processRequest(requests, logger, numRequests, url, outputStream, shouldUseGzip);
        } finally {
            if (outputStream != null) {
                outputStream.close();
            }
        }

        logger.log();
    }

    private static void processRequest(GraphRequestBatch requests, Logger logger, int numRequests,
                                       URL url, OutputStream outputStream, boolean shouldUseGzip)
            throws IOException, JSONException {
        Serializer serializer = new Serializer(outputStream, logger, shouldUseGzip);

        if (numRequests == 1) {
            GraphRequest request = requests.get(0);

            Map<String, Attachment> attachments = new HashMap<String, Attachment>();
            for (String key : request.parameters.keySet()) {
                Object value = request.parameters.get(key);
                if (isSupportedAttachmentType(value)) {
                    attachments.put(key, new Attachment(request, value));
                }
            }

            if (logger != null) {
                logger.append("  Parameters:\n");
            }
            serializeParameters(request.parameters, serializer, request);

            if (logger != null) {
                logger.append("  Attachments:\n");
            }
            serializeAttachments(attachments, serializer);

            if (request.graphObject != null) {
                processGraphObject(request.graphObject, url.getPath(), serializer);
            }
        } else {
            String batchAppID = getBatchAppId(requests);
            if (Utility.isNullOrEmpty(batchAppID)) {
                throw new FacebookException(
                        "App ID was not specified at the request or Settings.");
            }

            serializer.writeString(BATCH_APP_ID_PARAM, batchAppID);

            
            
            Map<String, Attachment> attachments = new HashMap<String, Attachment>();
            serializeRequestsAsJSON(serializer, requests, attachments);

            if (logger != null) {
                logger.append("  Attachments:\n");
            }
            serializeAttachments(attachments, serializer);
        }
    }

    private static boolean isMeRequest(String path) {
        Matcher matcher = versionPattern.matcher(path);
        if (matcher.matches()) {
            
            path = matcher.group(1);
        }
        if (path.startsWith("me/") || path.startsWith("/me/")) {
            return true;
        }
        return false;
    }

    private static void processGraphObject(
            JSONObject graphObject,
            String path,
            KeyValueSerializer serializer
    ) throws IOException {
        
        
        
        
        
        
        boolean isOGAction = false;
        if (isMeRequest(path)) {
            int colonLocation = path.indexOf(":");
            int questionMarkLocation = path.indexOf("?");
            isOGAction = colonLocation > 3
                    && (questionMarkLocation == -1 || colonLocation < questionMarkLocation);
        }

        Iterator<String> keyIterator = graphObject.keys();
        while (keyIterator.hasNext()) {
            String key = keyIterator.next();
            Object value = graphObject.opt(key);
            boolean passByValue = isOGAction && key.equalsIgnoreCase("image");
            processGraphObjectProperty(key, value, serializer, passByValue);
        }
    }

    private static void processGraphObjectProperty(
            String key,
            Object value,
            KeyValueSerializer serializer,
            boolean passByValue
    ) throws IOException {
        Class<?> valueClass = value.getClass();

        if (JSONObject.class.isAssignableFrom(valueClass)) {
            JSONObject jsonObject = (JSONObject) value;
            if (passByValue) {
                
                @SuppressWarnings("unchecked")
                Iterator<String> keys = jsonObject.keys();
                while (keys.hasNext()) {
                    String propertyName = keys.next();
                    String subKey = String.format("%s[%s]", key, propertyName);
                    processGraphObjectProperty(
                            subKey,
                            jsonObject.opt(propertyName),
                            serializer,
                            passByValue);
                }
            } else {
                
                
                if (jsonObject.has("id")) {
                    processGraphObjectProperty(
                            key,
                            jsonObject.optString("id"),
                            serializer,
                            passByValue);
                } else if (jsonObject.has("url")) {
                    processGraphObjectProperty(
                            key,
                            jsonObject.optString("url"),
                            serializer,
                            passByValue);
                } else if (jsonObject.has(NativeProtocol.OPEN_GRAPH_CREATE_OBJECT_KEY)) {
                    processGraphObjectProperty(key, jsonObject.toString(), serializer, passByValue);
                }
            }
        } else if (JSONArray.class.isAssignableFrom(valueClass)) {
            JSONArray jsonArray = (JSONArray) value;
            int length = jsonArray.length();
            for (int i = 0; i < length; ++i) {
                String subKey = String.format(Locale.ROOT, "%s[%d]", key, i);
                processGraphObjectProperty(subKey, jsonArray.opt(i), serializer, passByValue);
            }
        } else if (String.class.isAssignableFrom(valueClass) ||
                Number.class.isAssignableFrom(valueClass) ||
                Boolean.class.isAssignableFrom(valueClass)) {
            serializer.writeString(key, value.toString());
        } else if (Date.class.isAssignableFrom(valueClass)) {
            Date date = (Date) value;
            
            
            
            
            
            
            final SimpleDateFormat iso8601DateFormat = new SimpleDateFormat(
                    ISO_8601_FORMAT_STRING,
                    Locale.US);
            serializer.writeString(key, iso8601DateFormat.format(date));
        }
    }

    private static void serializeParameters(
            Bundle bundle,
            Serializer serializer,
            GraphRequest request
    ) throws IOException {
        Set<String> keys = bundle.keySet();

        for (String key : keys) {
            Object value = bundle.get(key);
            if (isSupportedParameterType(value)) {
                serializer.writeObject(key, value, request);
            }
        }
    }

    private static void serializeAttachments(
            Map<String, Attachment> attachments,
            Serializer serializer
    ) throws IOException {
        Set<String> keys = attachments.keySet();

        for (String key : keys) {
            Attachment attachment = attachments.get(key);
            if (isSupportedAttachmentType(attachment.getValue())) {
                serializer.writeObject(key, attachment.getValue(), attachment.getRequest());
            }
        }
    }

    private static void serializeRequestsAsJSON(
            Serializer serializer,
            Collection<GraphRequest> requests,
            Map<String, Attachment> attachments
    ) throws JSONException, IOException {
        JSONArray batch = new JSONArray();
        for (GraphRequest request : requests) {
            request.serializeToBatch(batch, attachments);
        }

        serializer.writeRequestsAsJson(BATCH_PARAM, batch, requests);
    }

    private static String getMimeContentType() {
        return String.format("multipart/form-data; boundary=%s", MIME_BOUNDARY);
    }

    private static volatile String userAgent;

    private static String getUserAgent() {
        if (userAgent == null) {
            userAgent = String.format("%s.%s", USER_AGENT_BASE, FacebookSdkVersion.BUILD);

            
            String customUserAgent = InternalSettings.getCustomUserAgent();
            if (!Utility.isNullOrEmpty(customUserAgent)) {
                userAgent = String.format(
                        Locale.ROOT,
                        "%s/%s",
                        userAgent,
                        customUserAgent);
            }
        }

        return userAgent;
    }

    private static String getBatchAppId(GraphRequestBatch batch) {
        if (!Utility.isNullOrEmpty(batch.getBatchApplicationId())) {
            return batch.getBatchApplicationId();
        }

        for (GraphRequest request : batch) {
            AccessToken accessToken = request.accessToken;
            if (accessToken != null) {
                String applicationId = accessToken.getApplicationId();
                if (applicationId != null) {
                    return applicationId;
                }
            }
        }
        if (!Utility.isNullOrEmpty(GraphRequest.defaultBatchApplicationId)) {
            return GraphRequest.defaultBatchApplicationId;
        }
        return FacebookSdk.getApplicationId();
    }

    private static boolean isSupportedAttachmentType(Object value) {
        return value instanceof Bitmap ||
                value instanceof byte[] ||
                value instanceof Uri ||
                value instanceof ParcelFileDescriptor ||
                value instanceof ParcelableResourceWithMimeType;
    }

    private static boolean isSupportedParameterType(Object value) {
        return value instanceof String || value instanceof Boolean || value instanceof Number ||
                value instanceof Date;
    }

    private static String parameterToString(Object value) {
        if (value instanceof String) {
            return (String) value;
        } else if (value instanceof Boolean || value instanceof Number) {
            return value.toString();
        } else if (value instanceof Date) {
            final SimpleDateFormat iso8601DateFormat = new SimpleDateFormat(
                    ISO_8601_FORMAT_STRING, Locale.US);
            return iso8601DateFormat.format(value);
        }
        throw new IllegalArgumentException("Unsupported parameter type.");
    }

    private interface KeyValueSerializer {
        void writeString(String key, String value) throws IOException;
    }

    private static class Serializer implements KeyValueSerializer {
        private final OutputStream outputStream;
        private final Logger logger;
        private boolean firstWrite = true;
        private boolean useUrlEncode = false;

        public Serializer(OutputStream outputStream, Logger logger, boolean useUrlEncode) {
            this.outputStream = outputStream;
            this.logger = logger;
            this.useUrlEncode = useUrlEncode;
        }

        public void writeObject(String key, Object value, GraphRequest request) throws IOException {
            if (outputStream instanceof RequestOutputStream) {
                ((RequestOutputStream) outputStream).setCurrentRequest(request);
            }

            if (isSupportedParameterType(value)) {
                writeString(key, parameterToString(value));
            } else if (value instanceof Bitmap) {
                writeBitmap(key, (Bitmap) value);
            } else if (value instanceof byte[]) {
                writeBytes(key, (byte[]) value);
            } else if (value instanceof Uri) {
                writeContentUri(key, (Uri) value, null);
            } else if (value instanceof ParcelFileDescriptor) {
                writeFile(key, (ParcelFileDescriptor) value, null);
            } else if (value instanceof ParcelableResourceWithMimeType) {
                ParcelableResourceWithMimeType resourceWithMimeType =
                        (ParcelableResourceWithMimeType) value;
                Parcelable resource = resourceWithMimeType.getResource();
                String mimeType = resourceWithMimeType.getMimeType();
                if (resource instanceof ParcelFileDescriptor) {
                    writeFile(key, (ParcelFileDescriptor) resource, mimeType);
                } else if (resource instanceof Uri) {
                    writeContentUri(key, (Uri) resource, mimeType);
                } else {
                    throw getInvalidTypeError();
                }
            } else {
                throw getInvalidTypeError();
            }
        }

        private RuntimeException getInvalidTypeError() {
            return new IllegalArgumentException("value is not a supported type.");
        }

        public void writeRequestsAsJson(
                String key,
                JSONArray requestJsonArray,
                Collection<GraphRequest> requests
        ) throws IOException, JSONException {
            if (!(outputStream instanceof RequestOutputStream)) {
                writeString(key, requestJsonArray.toString());
                return;
            }

            RequestOutputStream requestOutputStream = (RequestOutputStream) outputStream;
            writeContentDisposition(key, null, null);
            write("[");
            int i = 0;
            for (GraphRequest request : requests) {
                JSONObject requestJson = requestJsonArray.getJSONObject(i);
                requestOutputStream.setCurrentRequest(request);
                if (i > 0) {
                    write(",%s", requestJson.toString());
                } else {
                    write("%s", requestJson.toString());
                }
                i++;
            }
            write("]");
            if (logger != null) {
                logger.appendKeyValue("    " + key, requestJsonArray.toString());
            }
        }

        public void writeString(String key, String value) throws IOException {
            writeContentDisposition(key, null, null);
            writeLine("%s", value);
            writeRecordBoundary();
            if (logger != null) {
                logger.appendKeyValue("    " + key, value);
            }
        }

        public void writeBitmap(String key, Bitmap bitmap) throws IOException {
            writeContentDisposition(key, key, "image/png");
            
            bitmap.compress(Bitmap.CompressFormat.PNG, 100, outputStream);
            writeLine("");
            writeRecordBoundary();
            if (logger != null) {
                logger.appendKeyValue("    " + key, "<Image>");
            }
        }

        public void writeBytes(String key, byte[] bytes) throws IOException {
            writeContentDisposition(key, key, "content/unknown");
            this.outputStream.write(bytes);
            writeLine("");
            writeRecordBoundary();
            if (logger != null) {
                logger.appendKeyValue(
                        "    " + key,
                        String.format(Locale.ROOT, "<Data: %d>", bytes.length));
            }
        }

        public void writeContentUri(String key, Uri contentUri, String mimeType)
                throws IOException {
            if (mimeType == null) {
                mimeType = "content/unknown";
            }
            writeContentDisposition(key, key, mimeType);

            InputStream inputStream = FacebookSdk
                    .getApplicationContext()
                    .getContentResolver()
                    .openInputStream(contentUri);

            int totalBytes = 0;
            if (outputStream instanceof ProgressNoopOutputStream) {
                
                long contentSize = Utility.getContentSize(contentUri);

                ((ProgressNoopOutputStream) outputStream).addProgress(contentSize);
            } else {
                totalBytes += Utility.copyAndCloseInputStream(inputStream, outputStream);
            }

            writeLine("");
            writeRecordBoundary();
            if (logger != null) {
                logger.appendKeyValue(
                        "    " + key,
                        String.format(Locale.ROOT, "<Data: %d>", totalBytes));
            }
        }

        public void writeFile(
                String key,
                ParcelFileDescriptor descriptor,
                String mimeType
        ) throws IOException {
            if (mimeType == null) {
                mimeType = "content/unknown";
            }
            writeContentDisposition(key, key, mimeType);

            int totalBytes = 0;

            if (outputStream instanceof ProgressNoopOutputStream) {
                
                ((ProgressNoopOutputStream) outputStream).addProgress(descriptor.getStatSize());
            } else {
                ParcelFileDescriptor.AutoCloseInputStream inputStream =
                        new ParcelFileDescriptor.AutoCloseInputStream(descriptor);
                totalBytes += Utility.copyAndCloseInputStream(inputStream, outputStream);
            }
            writeLine("");
            writeRecordBoundary();
            if (logger != null) {
                logger.appendKeyValue(
                        "    " + key,
                        String.format(Locale.ROOT, "<Data: %d>", totalBytes));
            }
        }

        public void writeRecordBoundary() throws IOException {
            if (!useUrlEncode) {
                writeLine("--%s", MIME_BOUNDARY);
            } else {
                this.outputStream.write("&".getBytes());
            }
        }

        public void writeContentDisposition(
                String name,
                String filename,
                String contentType
        ) throws IOException {
            if (!useUrlEncode) {
                write("Content-Disposition: form-data; name=\"%s\"", name);
                if (filename != null) {
                    write("; filename=\"%s\"", filename);
                }
                writeLine(""); 
                if (contentType != null) {
                    writeLine("%s: %s", CONTENT_TYPE_HEADER, contentType);
                }
                writeLine(""); 
            } else {
                this.outputStream.write(String.format("%s=", name).getBytes());
            }
        }

        public void write(String format, Object... args) throws IOException {
            if (!useUrlEncode) {
                if (firstWrite) {
                    
                    this.outputStream.write("--".getBytes());
                    this.outputStream.write(MIME_BOUNDARY.getBytes());
                    this.outputStream.write("\r\n".getBytes());
                    firstWrite = false;
                }
                this.outputStream.write(String.format(format, args).getBytes());
            } else {
                this.outputStream.write(
                        URLEncoder.encode(
                                String.format(Locale.US, format, args), "UTF-8").getBytes());
            }
        }

        public void writeLine(String format, Object... args) throws IOException {
            write(format, args);
            if (!useUrlEncode) {
                write("\r\n");
            }
        }

    }

    
    public interface Callback {
        
        void onCompleted(GraphResponse response);
    }

    
    public interface OnProgressCallback extends Callback {
        
        void onProgress(long current, long max);
    }

    
    public interface GraphJSONArrayCallback {
        
        void onCompleted(JSONArray objects, GraphResponse response);
    }

    
    public interface GraphJSONObjectCallback {
        
        void onCompleted(JSONObject object, GraphResponse response);
    }

    
    public static class ParcelableResourceWithMimeType<RESOURCE extends Parcelable>
            implements Parcelable {
        private final String mimeType;
        private final RESOURCE resource;

        public String getMimeType() {
            return mimeType;
        }

        public RESOURCE getResource() {
            return resource;
        }

        public int describeContents() {
            return CONTENTS_FILE_DESCRIPTOR;
        }

        public void writeToParcel(Parcel out, int flags) {
            out.writeString(mimeType);
            out.writeParcelable(resource, flags);
        }

        @SuppressWarnings("unused")
        public static final Parcelable.Creator<ParcelableResourceWithMimeType> CREATOR
                = new Parcelable.Creator<ParcelableResourceWithMimeType>() {
            public ParcelableResourceWithMimeType createFromParcel(Parcel in) {
                return new ParcelableResourceWithMimeType(in);
            }

            public ParcelableResourceWithMimeType[] newArray(int size) {
                return new ParcelableResourceWithMimeType[size];
            }
        };

        
        public ParcelableResourceWithMimeType(
                RESOURCE resource,
                String mimeType
        ) {
            this.mimeType = mimeType;
            this.resource = resource;
        }

        private ParcelableResourceWithMimeType(Parcel in) {
            mimeType = in.readString();
            resource = in.readParcelable(FacebookSdk.getApplicationContext().getClassLoader());
        }
    }
}

<code block>


package com.facebook;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.Signature;
import android.os.AsyncTask;
import android.util.Base64;
import android.util.Log;

import com.facebook.appevents.AppEventsLogger;
import com.facebook.internal.AppEventsLoggerUtility;
import com.facebook.internal.BoltsMeasurementEventListener;
import com.facebook.internal.AttributionIdentifiers;
import com.facebook.internal.NativeProtocol;
import com.facebook.internal.Utility;
import com.facebook.internal.Validate;

import org.json.JSONException;
import org.json.JSONObject;

import java.io.File;
import java.lang.reflect.Field;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;


public final class FacebookSdk {
    private static final String TAG = FacebookSdk.class.getCanonicalName();
    private static final HashSet<LoggingBehavior> loggingBehaviors =
            new HashSet<LoggingBehavior>(Arrays.asList(LoggingBehavior.DEVELOPER_ERRORS));
    private static volatile Executor executor;
    private static volatile String applicationId;
    private static volatile String applicationName;
    private static volatile String appClientToken;
    private static volatile int webDialogTheme;
    private static final String FACEBOOK_COM = "facebook.com";
    private static volatile String facebookDomain = FACEBOOK_COM;
    private static AtomicLong onProgressThreshold = new AtomicLong(65536);
    private static volatile boolean isDebugEnabled = BuildConfig.DEBUG;
    private static boolean isLegacyTokenUpgradeSupported = false;
    private static File cacheDir;
    private static Context applicationContext;
    private static final int DEFAULT_CORE_POOL_SIZE = 5;
    private static final int DEFAULT_MAXIMUM_POOL_SIZE = 128;
    private static final int DEFAULT_KEEP_ALIVE = 1;
    private static int callbackRequestCodeOffset = 0xface;
    private static final Object LOCK = new Object();

    private static final int MAX_REQUEST_CODE_RANGE = 100;

    private static final String ATTRIBUTION_PREFERENCES = "com.facebook.sdk.attributionTracking";
    private static final String PUBLISH_ACTIVITY_PATH = "%s/activities";

    private static final BlockingQueue<Runnable> DEFAULT_WORK_QUEUE =
            new LinkedBlockingQueue<Runnable>(10);

    private static final ThreadFactory DEFAULT_THREAD_FACTORY = new ThreadFactory() {
        private final AtomicInteger counter = new AtomicInteger(0);

        public Thread newThread(Runnable runnable) {
            return new Thread(runnable, "FacebookSdk #" + counter.incrementAndGet());
        }
    };

    static final String CALLBACK_OFFSET_CHANGED_AFTER_INIT =
            "The callback request code offset can't be updated once the SDK is initialized.";

    static final String CALLBACK_OFFSET_NEGATIVE =
            "The callback request code offset can't be negative.";


    
    public static final String APPLICATION_ID_PROPERTY = "com.facebook.sdk.ApplicationId";

    
    public static final String APPLICATION_NAME_PROPERTY = "com.facebook.sdk.ApplicationName";

    
    public static final String CLIENT_TOKEN_PROPERTY = "com.facebook.sdk.ClientToken";

    
    public static final String WEB_DIALOG_THEME = "com.facebook.sdk.WebDialogTheme";

    private static Boolean sdkInitialized = false;

    
    public static synchronized void sdkInitialize(
            Context applicationContext,
            int callbackRequestCodeOffset) {
        if (sdkInitialized && callbackRequestCodeOffset != FacebookSdk.callbackRequestCodeOffset) {
            throw new FacebookException(CALLBACK_OFFSET_CHANGED_AFTER_INIT);
        }
        if (callbackRequestCodeOffset < 0) {
            throw new FacebookException(CALLBACK_OFFSET_NEGATIVE);
        }
        FacebookSdk.callbackRequestCodeOffset = callbackRequestCodeOffset;
        sdkInitialize(applicationContext);
    }


    
    public static synchronized void sdkInitialize(Context applicationContext) {
        if (sdkInitialized == true) {
          return;
        }

        Validate.notNull(applicationContext, "applicationContext");

        
        
        Validate.hasFacebookActivity(applicationContext, false);
        Validate.hasInternetPermissions(applicationContext, false);

        FacebookSdk.applicationContext = applicationContext.getApplicationContext();

        
        FacebookSdk.loadDefaultsFromMetadata(FacebookSdk.applicationContext);
        
        Utility.loadAppSettingsAsync(FacebookSdk.applicationContext, applicationId);
        
        NativeProtocol.updateAllAvailableProtocolVersionsAsync();

        BoltsMeasurementEventListener.getInstance(FacebookSdk.applicationContext);

        cacheDir = FacebookSdk.applicationContext.getCacheDir();

        FutureTask<Void> accessTokenLoadFutureTask =
                new FutureTask<Void>(new Callable<Void>() {
                    @Override
                    public Void call() throws Exception {
                        AccessTokenManager.getInstance().loadCurrentAccessToken();
                        ProfileManager.getInstance().loadCurrentProfile();
                        if (AccessToken.getCurrentAccessToken() != null &&
                                Profile.getCurrentProfile() == null) {
                            
                            
                            Profile.fetchProfileForCurrentAccessToken();
                        }
                        return null;
                    }
                });
        getExecutor().execute(accessTokenLoadFutureTask);

        sdkInitialized = true;
    }

    
    public static synchronized boolean isInitialized() {
        return sdkInitialized;
    }

    
    public static Set<LoggingBehavior> getLoggingBehaviors() {
        synchronized (loggingBehaviors) {
            return Collections.unmodifiableSet(new HashSet<LoggingBehavior>(loggingBehaviors));
        }
    }

    
    public static void addLoggingBehavior(LoggingBehavior behavior) {
        synchronized (loggingBehaviors) {
            loggingBehaviors.add(behavior);
            updateGraphDebugBehavior();
        }
    }

    
    public static void removeLoggingBehavior(LoggingBehavior behavior) {
        synchronized (loggingBehaviors) {
            loggingBehaviors.remove(behavior);
        }
    }

    
    public static void clearLoggingBehaviors() {
        synchronized (loggingBehaviors) {
            loggingBehaviors.clear();
        }
    }

    
    public static boolean isLoggingBehaviorEnabled(LoggingBehavior behavior) {
        synchronized (loggingBehaviors) {
            return FacebookSdk.isDebugEnabled() && loggingBehaviors.contains(behavior);
        }
    }

    
    public static boolean isDebugEnabled() {
        return isDebugEnabled;
    }

    
    public static void setIsDebugEnabled(boolean enabled) {
        isDebugEnabled = enabled;
    }

    
    public static boolean isLegacyTokenUpgradeSupported() {
        return isLegacyTokenUpgradeSupported;
    }

    private static void updateGraphDebugBehavior() {
        if (loggingBehaviors.contains(LoggingBehavior.GRAPH_API_DEBUG_INFO)
           && !loggingBehaviors.contains(LoggingBehavior.GRAPH_API_DEBUG_WARNING)) {
            loggingBehaviors.add(LoggingBehavior.GRAPH_API_DEBUG_WARNING);
        }
    }

    
    public static void setLegacyTokenUpgradeSupported(boolean supported) {
        isLegacyTokenUpgradeSupported = supported;
    }

    
    public static Executor getExecutor() {
        synchronized (LOCK) {
            if (FacebookSdk.executor == null) {
                Executor executor = getAsyncTaskExecutor();
                if (executor == null) {
                    executor = new ThreadPoolExecutor(
                            DEFAULT_CORE_POOL_SIZE, DEFAULT_MAXIMUM_POOL_SIZE, DEFAULT_KEEP_ALIVE,
                            TimeUnit.SECONDS, DEFAULT_WORK_QUEUE, DEFAULT_THREAD_FACTORY);
                }
                FacebookSdk.executor = executor;
            }
        }
        return FacebookSdk.executor;
    }

    
    public static void setExecutor(Executor executor) {
        Validate.notNull(executor, "executor");
        synchronized (LOCK) {
            FacebookSdk.executor = executor;
        }
    }

    
    public static String getFacebookDomain() {
        return facebookDomain;
    }

    
    public static void setFacebookDomain(String facebookDomain) {
        if (!BuildConfig.DEBUG) {
            Log.w(TAG, "WARNING: Calling setFacebookDomain from non-DEBUG code.");
        }

        FacebookSdk.facebookDomain = facebookDomain;
    }

    
    public static Context getApplicationContext() {
        Validate.sdkInitialized();
        return applicationContext;
    }

    private static Executor getAsyncTaskExecutor() {
        Field executorField = null;
        try {
            executorField = AsyncTask.class.getField("THREAD_POOL_EXECUTOR");
        } catch (NoSuchFieldException e) {
            return null;
        }

        Object executorObject = null;
        try {
            executorObject = executorField.get(null);
        } catch (IllegalAccessException e) {
            return null;
        }

        if (executorObject == null) {
            return null;
        }

        if (!(executorObject instanceof Executor)) {
            return null;
        }

        return (Executor) executorObject;
    }

    
    public static void publishInstallAsync(final Context context, final String applicationId) {
        
        
        final Context applicationContext = context.getApplicationContext();
        FacebookSdk.getExecutor().execute(new Runnable() {
            @Override
            public void run() {
                FacebookSdk.publishInstallAndWaitForResponse(applicationContext, applicationId);
            }
        });
    }

    static GraphResponse publishInstallAndWaitForResponse(
            final Context context,
            final String applicationId) {
        try {
            if (context == null || applicationId == null) {
                throw new IllegalArgumentException("Both context and applicationId must be non-null");
            }
            AttributionIdentifiers identifiers = AttributionIdentifiers.getAttributionIdentifiers(context);
            SharedPreferences preferences = context.getSharedPreferences(ATTRIBUTION_PREFERENCES, Context.MODE_PRIVATE);
            String pingKey = applicationId+"ping";
            String jsonKey = applicationId+"json";
            long lastPing = preferences.getLong(pingKey, 0);
            String lastResponseJSON = preferences.getString(jsonKey, null);

            JSONObject publishParams;
            try {
                publishParams = AppEventsLoggerUtility.getJSONObjectForGraphAPICall(
                        AppEventsLoggerUtility.GraphAPIActivityType.MOBILE_INSTALL_EVENT,
                        identifiers,
                        AppEventsLogger.getAnonymousAppDeviceGUID(context),
                        getLimitEventAndDataUsage(context),
                        context);
            } catch (JSONException e) {
                throw new FacebookException("An error occurred while publishing install.", e);
            }

            String publishUrl = String.format(PUBLISH_ACTIVITY_PATH, applicationId);
            GraphRequest publishRequest = GraphRequest.newPostRequest(null, publishUrl, publishParams, null);

            if (lastPing != 0) {
                JSONObject graphObject = null;
                try {
                    if (lastResponseJSON != null) {
                        graphObject = new JSONObject(lastResponseJSON);
                    }
                }
                catch (JSONException je) {
                    
                }
                if (graphObject == null) {
                    return GraphResponse.createResponsesFromString(
                            "true",
                            null,
                            new GraphRequestBatch(publishRequest)
                    ).get(0);
                } else {
                    return new GraphResponse(null, null, null, graphObject);
                }

            } else {

                GraphResponse publishResponse = publishRequest.executeAndWait();

                
                SharedPreferences.Editor editor = preferences.edit();
                lastPing = System.currentTimeMillis();
                editor.putLong(pingKey, lastPing);

                
                if (publishResponse.getJSONObject() != null) {
                    editor.putString(jsonKey, publishResponse.getJSONObject().toString());
                }
                editor.apply();

                return publishResponse;
            }
        } catch (Exception e) {
            
            Utility.logd("Facebook-publish", e);
            return new GraphResponse(null, null, new FacebookRequestError(null, e));
        }
    }

    
    public static String getSdkVersion() {
        return FacebookSdkVersion.BUILD;
    }

    
    public static boolean getLimitEventAndDataUsage(Context context) {
        Validate.sdkInitialized();
        SharedPreferences preferences = context.getSharedPreferences(
                AppEventsLogger.APP_EVENT_PREFERENCES, Context.MODE_PRIVATE);
        return preferences.getBoolean("limitEventUsage", false);
    }

    
    public static void setLimitEventAndDataUsage(Context context, boolean limitEventUsage) {
        context.getSharedPreferences(AppEventsLogger.APP_EVENT_PREFERENCES, Context.MODE_PRIVATE)
            .edit()
            .putBoolean("limitEventUsage", limitEventUsage)
            .apply();
    }

    
    public static long getOnProgressThreshold() {
        Validate.sdkInitialized();
        return onProgressThreshold.get();
    }

    
    public static void setOnProgressThreshold(long threshold) {
        onProgressThreshold.set(threshold);
    }

    
    static void loadDefaultsFromMetadata(Context context) {
        if (context == null) {
            return;
        }

        ApplicationInfo ai = null;
        try {
            ai = context.getPackageManager().getApplicationInfo(
                    context.getPackageName(), PackageManager.GET_META_DATA);
        } catch (PackageManager.NameNotFoundException e) {
            return;
        }

        if (ai == null || ai.metaData == null) {
            return;
        }

        if (applicationId == null) {
            Object appId = ai.metaData.get(APPLICATION_ID_PROPERTY);
            if (appId instanceof String) {
                applicationId = (String) appId;
            } else if (appId instanceof Integer) {
                applicationId = appId.toString();
            }
        }

        if (applicationName == null) {
            applicationName = ai.metaData.getString(APPLICATION_NAME_PROPERTY);
        }

        if (appClientToken == null) {
            appClientToken = ai.metaData.getString(CLIENT_TOKEN_PROPERTY);
        }

        if (webDialogTheme == 0) {
            setWebDialogTheme(ai.metaData.getInt(WEB_DIALOG_THEME));
        }
    }

    
    public static String getApplicationSignature(Context context) {
        Validate.sdkInitialized();
        if (context == null) {
            return null;
        }
        PackageManager packageManager = context.getPackageManager();
        if (packageManager == null) {
            return null;
        }

        String packageName = context.getPackageName();
        PackageInfo pInfo;
        try {
            pInfo = packageManager.getPackageInfo(packageName, PackageManager.GET_SIGNATURES);
        } catch (PackageManager.NameNotFoundException e) {
            return null;
        }

        Signature[] signatures = pInfo.signatures;
        if (signatures == null || signatures.length == 0) {
            return null;
        }

        MessageDigest md;
        try {
            md = MessageDigest.getInstance("SHA-1");
        } catch (NoSuchAlgorithmException e) {
            return null;
        }

        md.update(pInfo.signatures[0].toByteArray());
        return Base64.encodeToString(md.digest(),  Base64.URL_SAFE | Base64.NO_PADDING);
    }

    
    public static String getApplicationId() {
        Validate.sdkInitialized();
        return applicationId;
    }

    
    public static void setApplicationId(String applicationId) {
        FacebookSdk.applicationId = applicationId;
    }

    
    public static String getApplicationName() {
        Validate.sdkInitialized();
        return applicationName;
    }

    
    public static void setApplicationName(String applicationName) {
        FacebookSdk.applicationName = applicationName;
    }

    
    public static String getClientToken() {
        Validate.sdkInitialized();
        return appClientToken;
    }

    
    public static void setClientToken(String clientToken) {
        appClientToken = clientToken;
    }

    
    public static int getWebDialogTheme() {
        Validate.sdkInitialized();
        return webDialogTheme;
    }

    
    public static void setWebDialogTheme(int theme) {
        webDialogTheme = theme;
    }

    
    public static File getCacheDir() {
        Validate.sdkInitialized();
        return cacheDir;
    }

    
    public static void setCacheDir(File cacheDir) {
        FacebookSdk.cacheDir = cacheDir;
    }

    
    public static int getCallbackRequestCodeOffset() {
        Validate.sdkInitialized();
        return callbackRequestCodeOffset;
    }

    
    public static boolean isFacebookRequestCode(int requestCode) {
        return requestCode >= callbackRequestCodeOffset
                && requestCode < callbackRequestCodeOffset + MAX_REQUEST_CODE_RANGE;
    }
}

<code block>


package com.facebook.internal;

import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.database.Cursor;
import android.net.Uri;
import android.os.Binder;
import android.os.IBinder;
import android.os.IInterface;
import android.os.Looper;
import android.os.Parcel;
import android.os.RemoteException;
import android.util.Log;

import com.facebook.FacebookException;

import java.lang.reflect.Method;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.atomic.AtomicBoolean;


public class AttributionIdentifiers {
    private static final String TAG = AttributionIdentifiers.class.getCanonicalName();
    private static final String ATTRIBUTION_ID_CONTENT_PROVIDER =
            "com.facebook.katana.provider.AttributionIdProvider";
    private static final String ATTRIBUTION_ID_CONTENT_PROVIDER_WAKIZASHI =
            "com.facebook.wakizashi.provider.AttributionIdProvider";
    private static final String ATTRIBUTION_ID_COLUMN_NAME = "aid";
    private static final String ANDROID_ID_COLUMN_NAME = "androidid";
    private static final String LIMIT_TRACKING_COLUMN_NAME = "limit_tracking";

    
    private static final int CONNECTION_RESULT_SUCCESS = 0;

    private static final long IDENTIFIER_REFRESH_INTERVAL_MILLIS = 3600 * 1000;

    private String attributionId;
    private String androidAdvertiserId;
    private boolean limitTracking;
    private long fetchTime;

    private static AttributionIdentifiers recentlyFetchedIdentifiers;

    private static AttributionIdentifiers getAndroidId(Context context) {
        AttributionIdentifiers identifiers = getAndroidIdViaReflection(context);
        if (identifiers == null) {
            identifiers = getAndroidIdViaService(context);
            if (identifiers == null) {
                identifiers = new AttributionIdentifiers();
            }
        }
        return identifiers;
    }

    private static AttributionIdentifiers getAndroidIdViaReflection(Context context) {
        try {
            
            
            if (Looper.myLooper() == Looper.getMainLooper()) {
              throw new FacebookException("getAndroidId cannot be called on the main thread.");
            }
            Method isGooglePlayServicesAvailable = Utility.getMethodQuietly(
                    "com.google.android.gms.common.GooglePlayServicesUtil",
                    "isGooglePlayServicesAvailable",
                    Context.class
            );

            if (isGooglePlayServicesAvailable == null) {
                return null;
            }

            Object connectionResult = Utility.invokeMethodQuietly(
                    null, isGooglePlayServicesAvailable, context);
            if (!(connectionResult instanceof Integer)
                    || (Integer) connectionResult != CONNECTION_RESULT_SUCCESS) {
                return null;
            }

            Method getAdvertisingIdInfo = Utility.getMethodQuietly(
                    "com.google.android.gms.ads.identifier.AdvertisingIdClient",
                    "getAdvertisingIdInfo",
                    Context.class
            );
            if (getAdvertisingIdInfo == null) {
                return null;
            }
            Object advertisingInfo = Utility.invokeMethodQuietly(
                    null, getAdvertisingIdInfo, context);
            if (advertisingInfo == null) {
                return null;
            }

            Method getId = Utility.getMethodQuietly(advertisingInfo.getClass(), "getId");
            Method isLimitAdTrackingEnabled = Utility.getMethodQuietly(
                    advertisingInfo.getClass(),
                    "isLimitAdTrackingEnabled");
            if (getId == null || isLimitAdTrackingEnabled == null) {
                return null;
            }

            AttributionIdentifiers identifiers = new AttributionIdentifiers();
            identifiers.androidAdvertiserId =
                    (String) Utility.invokeMethodQuietly(advertisingInfo, getId);
            identifiers.limitTracking = (Boolean) Utility.invokeMethodQuietly(
                    advertisingInfo,
                    isLimitAdTrackingEnabled);
        } catch (Exception e) {
            Utility.logd("android_id", e);
        }
        return null;
    }

    private static AttributionIdentifiers getAndroidIdViaService(Context context) {
        GoogleAdServiceConnection connection = new GoogleAdServiceConnection();
        Intent intent = new Intent("com.google.android.gms.ads.identifier.service.START");
        intent.setPackage("com.google.android.gms");
        if(context.bindService(intent, connection, Context.BIND_AUTO_CREATE)) {
            try {
                GoogleAdInfo adInfo = new GoogleAdInfo(connection.getBinder());
                AttributionIdentifiers identifiers = new AttributionIdentifiers();
                identifiers.androidAdvertiserId = adInfo.getAdvertiserId();
                identifiers.limitTracking = adInfo.isTrackingLimited();
                return identifiers;
            } catch (Exception exception) {
                Utility.logd("android_id", exception);
            } finally {
                context.unbindService(connection);
            }
        }
        return null;
    }

    public static AttributionIdentifiers getAttributionIdentifiers(Context context) {
        if (recentlyFetchedIdentifiers != null &&
            System.currentTimeMillis() - recentlyFetchedIdentifiers.fetchTime <
                    IDENTIFIER_REFRESH_INTERVAL_MILLIS) {
            return recentlyFetchedIdentifiers;
        }

        AttributionIdentifiers identifiers = getAndroidId(context);
        Cursor c = null;
        try {
            String [] projection = {
                    ATTRIBUTION_ID_COLUMN_NAME,
                    ANDROID_ID_COLUMN_NAME,
                    LIMIT_TRACKING_COLUMN_NAME};
            Uri providerUri = null;
            if (context.getPackageManager().resolveContentProvider(
                    ATTRIBUTION_ID_CONTENT_PROVIDER, 0) != null) {
                providerUri = Uri.parse("content:
            } else if (context.getPackageManager().resolveContentProvider(
                    ATTRIBUTION_ID_CONTENT_PROVIDER_WAKIZASHI, 0) != null) {
                providerUri = Uri.parse("content:
            }
            if (providerUri == null) {
                return identifiers;
            }
            c = context.getContentResolver().query(providerUri, projection, null, null, null);
            if (c == null || !c.moveToFirst()) {
                return identifiers;
            }
            int attributionColumnIndex = c.getColumnIndex(ATTRIBUTION_ID_COLUMN_NAME);
            int androidIdColumnIndex = c.getColumnIndex(ANDROID_ID_COLUMN_NAME);
            int limitTrackingColumnIndex = c.getColumnIndex(LIMIT_TRACKING_COLUMN_NAME);

            identifiers.attributionId = c.getString(attributionColumnIndex);

            
            
            if (androidIdColumnIndex > 0 && limitTrackingColumnIndex > 0 &&
                    identifiers.getAndroidAdvertiserId() == null) {
                identifiers.androidAdvertiserId = c.getString(androidIdColumnIndex);
                identifiers.limitTracking =
                        Boolean.parseBoolean(c.getString(limitTrackingColumnIndex));
            }
        } catch (Exception e) {
            Log.d(TAG, "Caught unexpected exception in getAttributionId(): " + e.toString());
            return null;
        } finally {
            if (c != null) {
                c.close();
            }
        }

        identifiers.fetchTime = System.currentTimeMillis();
        recentlyFetchedIdentifiers = identifiers;
        return identifiers;
    }

    public String getAttributionId() {
        return attributionId;
    }

    public String getAndroidAdvertiserId() {
        return androidAdvertiserId;
    }

    public boolean isTrackingLimited() {
        return limitTracking;
    }

    private static final class GoogleAdServiceConnection implements ServiceConnection {
        private AtomicBoolean consumed = new AtomicBoolean(false);
        private final BlockingQueue<IBinder> queue = new LinkedBlockingDeque<>();

        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            try {
                queue.put(service);
            } catch (InterruptedException e) {
            }
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
        }

        public IBinder getBinder() throws InterruptedException {
            if (consumed.compareAndSet(true, true)) {
                throw new IllegalStateException("Binder already consumed");
            }
            return queue.take();
        }
    }

    private static final class GoogleAdInfo implements IInterface {
        private static final int FIRST_TRANSACTION_CODE = Binder.FIRST_CALL_TRANSACTION;
        private static final int SECOND_TRANSACTION_CODE = FIRST_TRANSACTION_CODE + 1;

        private IBinder binder;

        GoogleAdInfo(IBinder binder) {
            this.binder = binder;
        }

        @Override
        public IBinder asBinder() {
            return binder;
        }

        public String getAdvertiserId() throws RemoteException {
            Parcel data = Parcel.obtain();
            Parcel reply = Parcel.obtain();
            String id;
            try {
                data.writeInterfaceToken(
                        "com.google.android.gms.ads.identifier.internal.IAdvertisingIdService");
                binder.transact(FIRST_TRANSACTION_CODE, data, reply, 0);
                reply.readException();
                id = reply.readString();
            } finally {
                reply.recycle();
                data.recycle();
            }
            return id;
        }

        public boolean isTrackingLimited() throws RemoteException {
            Parcel data = Parcel.obtain();
            Parcel reply = Parcel.obtain();
            boolean limitAdTracking;
            try {
                data.writeInterfaceToken(
                        "com.google.android.gms.ads.identifier.internal.IAdvertisingIdService");
                data.writeInt(1);
                binder.transact(SECOND_TRANSACTION_CODE, data, reply, 0);
                reply.readException();
                limitAdTracking = 0 != reply.readInt();
            } finally {
                reply.recycle();
                data.recycle();
            }
            return limitAdTracking;
        }
    }
}

<code block>


package com.facebook.internal;

public class InternalSettings {
    
    private static volatile String mCustomUserAgent;

    public static void setCustomUserAgent(String customUserAgent) {
        mCustomUserAgent = customUserAgent;
    }

    public static String getCustomUserAgent() {
        return mCustomUserAgent;
    }
}

<code block>


package com.facebook.appevents;

import android.app.Activity;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.support.v4.content.LocalBroadcastManager;
import android.util.Log;
import bolts.AppLinks;

import com.facebook.AccessToken;
import com.facebook.FacebookException;
import com.facebook.FacebookRequestError;
import com.facebook.FacebookSdk;
import com.facebook.GraphRequest;
import com.facebook.GraphResponse;
import com.facebook.LoggingBehavior;
import com.facebook.internal.AppEventsLoggerUtility;
import com.facebook.internal.AttributionIdentifiers;
import com.facebook.internal.Logger;
import com.facebook.internal.Utility;
import com.facebook.internal.Validate;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.FileNotFoundException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.io.UnsupportedEncodingException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Currency;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;



public class AppEventsLogger {
    

    
    public enum FlushBehavior {
        
        AUTO,

        
        EXPLICIT_ONLY,
    }

    
    private static final String TAG = AppEventsLogger.class.getCanonicalName();

    private static final int NUM_LOG_EVENTS_TO_TRY_TO_FLUSH_AFTER = 100;
    private static final int FLUSH_PERIOD_IN_SECONDS = 15;
    private static final int APP_SUPPORTS_ATTRIBUTION_ID_RECHECK_PERIOD_IN_SECONDS = 60 * 60 * 24;
    private static final int FLUSH_APP_SESSION_INFO_IN_SECONDS = 30;

    public static final String APP_EVENT_PREFERENCES = "com.facebook.sdk.appEventPreferences";

    private static final String SOURCE_APPLICATION_HAS_BEEN_SET_BY_THIS_INTENT =
            "_fbSourceApplicationHasBeenSet";

    
    private final String contextName;
    private final AccessTokenAppIdPair accessTokenAppId;

    private static Map<AccessTokenAppIdPair, SessionEventsState> stateMap =
            new ConcurrentHashMap<AccessTokenAppIdPair, SessionEventsState>();
    private static ScheduledThreadPoolExecutor backgroundExecutor;
    private static FlushBehavior flushBehavior = FlushBehavior.AUTO;
    private static boolean requestInFlight;
    private static Context applicationContext;
    private static Object staticLock = new Object();
    private static String anonymousAppDeviceGUID;
    private static String sourceApplication;
    private static boolean isOpenedByApplink;

    private static class AccessTokenAppIdPair implements Serializable {
        private static final long serialVersionUID = 1L;
        private final String accessTokenString;
        private final String applicationId;

        AccessTokenAppIdPair(AccessToken accessToken) {
            this(accessToken.getToken(), FacebookSdk.getApplicationId());
        }

        AccessTokenAppIdPair(String accessTokenString, String applicationId) {
            this.accessTokenString = Utility.isNullOrEmpty(accessTokenString)
                    ? null
                    : accessTokenString;
            this.applicationId = applicationId;
        }

        String getAccessTokenString() {
            return accessTokenString;
        }

        String getApplicationId() {
            return applicationId;
        }

        @Override
        public int hashCode() {
            return (accessTokenString == null ? 0 : accessTokenString.hashCode()) ^
                    (applicationId == null ? 0 : applicationId.hashCode());
        }

        @Override
        public boolean equals(Object o) {
            if (!(o instanceof AccessTokenAppIdPair)) {
                return false;
            }
            AccessTokenAppIdPair p = (AccessTokenAppIdPair) o;
            return Utility.areObjectsEqual(p.accessTokenString, accessTokenString) &&
                    Utility.areObjectsEqual(p.applicationId, applicationId);
        }

        private static class SerializationProxyV1 implements Serializable {
            private static final long serialVersionUID = -2488473066578201069L;
            private final String accessTokenString;
            private final String appId;

            private SerializationProxyV1(String accessTokenString, String appId) {
                this.accessTokenString = accessTokenString;
                this.appId = appId;
            }

            private Object readResolve() {
                return new AccessTokenAppIdPair(accessTokenString, appId);
            }
        }

        private Object writeReplace() {
            return new SerializationProxyV1(accessTokenString, applicationId);
        }
    }

    
    public static void activateApp(Context context) {
        FacebookSdk.sdkInitialize(context);
        activateApp(context, Utility.getMetadataApplicationId(context));
    }

    
    public static void activateApp(Context context, String applicationId) {
        if (context == null || applicationId == null) {
            throw new IllegalArgumentException("Both context and applicationId must be non-null");
        }

        if ((context instanceof Activity)) {
            setSourceApplication((Activity) context);
        } else {
          
          resetSourceApplication();
          Log.d(AppEventsLogger.class.getName(),
              "To set source application the context of activateApp must be an instance of" +
                      " Activity");
        }

        
        
        
        FacebookSdk.publishInstallAsync(context, applicationId);

        final AppEventsLogger logger = new AppEventsLogger(context, applicationId, null);
        final long eventTime = System.currentTimeMillis();
        final String sourceApplicationInfo = getSourceApplication();
        backgroundExecutor.execute(new Runnable() {
            @Override
            public void run() {
                logger.logAppSessionResumeEvent(eventTime, sourceApplicationInfo);
            }
        });
    }

    
    public static void deactivateApp(Context context) {
        deactivateApp(context, Utility.getMetadataApplicationId(context));
    }

    
    public static void deactivateApp(Context context, String applicationId) {
        if (context == null || applicationId == null) {
            throw new IllegalArgumentException("Both context and applicationId must be non-null");
        }

        resetSourceApplication();

        final AppEventsLogger logger = new AppEventsLogger(context, applicationId, null);
        final long eventTime = System.currentTimeMillis();
        backgroundExecutor.execute(new Runnable() {
            @Override
            public void run() {
                logger.logAppSessionSuspendEvent(eventTime);
            }
        });
    }

    private void logAppSessionResumeEvent(long eventTime, String sourceApplicationInfo) {
        PersistedAppSessionInfo.onResume(
                applicationContext,
                accessTokenAppId,
                this,
                eventTime,
                sourceApplicationInfo);
    }

    private void logAppSessionSuspendEvent(long eventTime) {
        PersistedAppSessionInfo.onSuspend(applicationContext, accessTokenAppId, this, eventTime);
    }

    
    public static AppEventsLogger newLogger(Context context) {
        return new AppEventsLogger(context, null, null);
    }

    
    public static AppEventsLogger newLogger(Context context, AccessToken accessToken) {
        return new AppEventsLogger(context, null, accessToken);
    }

    
    public static AppEventsLogger newLogger(
            Context context,
            String applicationId,
            AccessToken accessToken) {
        return new AppEventsLogger(context, applicationId, accessToken);
    }

    
    public static AppEventsLogger newLogger(Context context, String applicationId) {
        return new AppEventsLogger(context, applicationId, null);
    }

    
    public static final String ACTION_APP_EVENTS_FLUSHED = "com.facebook.sdk.APP_EVENTS_FLUSHED";

    public static final String APP_EVENTS_EXTRA_NUM_EVENTS_FLUSHED =
            "com.facebook.sdk.APP_EVENTS_NUM_EVENTS_FLUSHED";
    public static final String APP_EVENTS_EXTRA_FLUSH_RESULT =
            "com.facebook.sdk.APP_EVENTS_FLUSH_RESULT";

    
    public static FlushBehavior getFlushBehavior() {
        synchronized (staticLock) {
            return flushBehavior;
        }
    }

    
    public static void setFlushBehavior(FlushBehavior flushBehavior) {
        synchronized (staticLock) {
            AppEventsLogger.flushBehavior = flushBehavior;
        }
    }

    
    public void logEvent(String eventName) {
        logEvent(eventName, null);
    }

    
    public void logEvent(String eventName, double valueToSum) {
        logEvent(eventName, valueToSum, null);
    }

    
    public void logEvent(String eventName, Bundle parameters) {
        logEvent(eventName, null, parameters, false);
    }

    
    public void logEvent(String eventName, double valueToSum, Bundle parameters) {
        logEvent(eventName, valueToSum, parameters, false);
    }

    
    public void logPurchase(BigDecimal purchaseAmount, Currency currency) {
        logPurchase(purchaseAmount, currency, null);
    }

    
    public void logPurchase(BigDecimal purchaseAmount, Currency currency, Bundle parameters) {

        if (purchaseAmount == null) {
            notifyDeveloperError("purchaseAmount cannot be null");
            return;
        } else if (currency == null) {
            notifyDeveloperError("currency cannot be null");
            return;
        }

        if (parameters == null) {
            parameters = new Bundle();
        }
        parameters.putString(AppEventsConstants.EVENT_PARAM_CURRENCY, currency.getCurrencyCode());

        logEvent(AppEventsConstants.EVENT_NAME_PURCHASED, purchaseAmount.doubleValue(), parameters);
        eagerFlush();
    }

    
    public void flush() {
        flush(FlushReason.EXPLICIT);
    }

    
    public static void onContextStop() {
        
        PersistedEvents.persistEvents(applicationContext, stateMap);
    }

    
    public boolean isValidForAccessToken(AccessToken accessToken) {
        AccessTokenAppIdPair other = new AccessTokenAppIdPair(accessToken);
        return accessTokenAppId.equals(other);
    }

    
    public void logSdkEvent(String eventName, Double valueToSum, Bundle parameters) {
        logEvent(eventName, valueToSum, parameters, true);
    }

    
    public String getApplicationId() {
        return accessTokenAppId.getApplicationId();
    }

    
    
    

    @SuppressWarnings("UnusedDeclaration")
    private enum FlushReason {
        EXPLICIT,
        TIMER,
        SESSION_CHANGE,
        PERSISTED_EVENTS,
        EVENT_THRESHOLD,
        EAGER_FLUSHING_EVENT,
    }

    @SuppressWarnings("UnusedDeclaration")
    private enum FlushResult {
        SUCCESS,
        SERVER_ERROR,
        NO_CONNECTIVITY,
        UNKNOWN_ERROR
    }

    
    private AppEventsLogger(Context context, String applicationId, AccessToken accessToken) {
        Validate.notNull(context, "context");
        this.contextName = Utility.getActivityName(context);

        if (accessToken == null) {
            accessToken = AccessToken.getCurrentAccessToken();
        }

        
        if (accessToken != null &&
                (applicationId == null || applicationId.equals(accessToken.getApplicationId()))
                ) {
            accessTokenAppId = new AccessTokenAppIdPair(accessToken);
        } else {
            
            if (applicationId == null) {
                applicationId = Utility.getMetadataApplicationId(context);
            }
            accessTokenAppId = new AccessTokenAppIdPair(null, applicationId);
        }

        synchronized (staticLock) {

            if (applicationContext == null) {
                applicationContext = context.getApplicationContext();
            }
        }

        initializeTimersIfNeeded();
    }

    private static void initializeTimersIfNeeded() {
        synchronized (staticLock) {
            if (backgroundExecutor != null) {
                return;
            }
            backgroundExecutor = new ScheduledThreadPoolExecutor(1);
        }

        final Runnable flushRunnable = new Runnable() {
            @Override
            public void run() {
                if (getFlushBehavior() != FlushBehavior.EXPLICIT_ONLY) {
                    flushAndWait(FlushReason.TIMER);
                }
            }
        };

        backgroundExecutor.scheduleAtFixedRate(
                flushRunnable,
                0,
                FLUSH_PERIOD_IN_SECONDS,
                TimeUnit.SECONDS
        );

        final Runnable attributionRecheckRunnable = new Runnable() {
            @Override
            public void run() {
                Set<String> applicationIds = new HashSet<String>();
                synchronized (staticLock) {
                    for (AccessTokenAppIdPair accessTokenAppId : stateMap.keySet()) {
                        applicationIds.add(accessTokenAppId.getApplicationId());
                    }
                }
                for (String applicationId : applicationIds) {
                    Utility.queryAppSettings(applicationId, true);
                }
            }
        };

        backgroundExecutor.scheduleAtFixedRate(
                attributionRecheckRunnable,
                0,
                APP_SUPPORTS_ATTRIBUTION_ID_RECHECK_PERIOD_IN_SECONDS,
                TimeUnit.SECONDS
        );
    }

    private void logEvent(
            String eventName,
            Double valueToSum,
            Bundle parameters,
            boolean isImplicitlyLogged) {
        AppEvent event = new AppEvent(
                this.contextName,
                eventName,
                valueToSum,
                parameters,
                isImplicitlyLogged);
        logEvent(applicationContext, event, accessTokenAppId);
    }

    private static void logEvent(final Context context,
                                 final AppEvent event,
                                 final AccessTokenAppIdPair accessTokenAppId) {
        FacebookSdk.getExecutor().execute(new Runnable() {
            @Override
            public void run() {
                SessionEventsState state = getSessionEventsState(context, accessTokenAppId);
                state.addEvent(event);
                flushIfNecessary();
            }
        });
    }

    static void eagerFlush() {
        if (getFlushBehavior() != FlushBehavior.EXPLICIT_ONLY) {
            flush(FlushReason.EAGER_FLUSHING_EVENT);
        }
    }

    private static void flushIfNecessary() {
        synchronized (staticLock) {
            if (getFlushBehavior() != FlushBehavior.EXPLICIT_ONLY) {
                if (getAccumulatedEventCount() > NUM_LOG_EVENTS_TO_TRY_TO_FLUSH_AFTER) {
                    flush(FlushReason.EVENT_THRESHOLD);
                }
            }
        }
    }

    private static int getAccumulatedEventCount() {
        synchronized (staticLock) {

            int result = 0;
            for (SessionEventsState state : stateMap.values()) {
                result += state.getAccumulatedEventCount();
            }
            return result;
        }
    }

    
    private static SessionEventsState getSessionEventsState(
            Context context,
            AccessTokenAppIdPair accessTokenAppId) {
        
        
        
        SessionEventsState state = stateMap.get(accessTokenAppId);
        AttributionIdentifiers attributionIdentifiers = null;
        if (state == null) {
            
            
            attributionIdentifiers = AttributionIdentifiers.getAttributionIdentifiers(context);
        }

        synchronized (staticLock) {
            
            state = stateMap.get(accessTokenAppId);
            if (state == null) {
                state = new SessionEventsState(
                        attributionIdentifiers,
                        context.getPackageName(),
                        getAnonymousAppDeviceGUID(context));
                stateMap.put(accessTokenAppId, state);
            }
            return state;
        }
    }

    private static SessionEventsState getSessionEventsState(AccessTokenAppIdPair accessTokenAppId) {
        synchronized (staticLock) {
            return stateMap.get(accessTokenAppId);
        }
    }

    private static void flush(final FlushReason reason) {

        FacebookSdk.getExecutor().execute(new Runnable() {
            @Override
            public void run() {
                flushAndWait(reason);
            }
        });
    }

    private static void flushAndWait(final FlushReason reason) {

        Set<AccessTokenAppIdPair> keysToFlush;
        synchronized (staticLock) {
            if (requestInFlight) {
                return;
            }
            requestInFlight = true;
            keysToFlush = new HashSet<AccessTokenAppIdPair>(stateMap.keySet());
        }

        accumulatePersistedEvents();

        FlushStatistics flushResults = null;
        try {
            flushResults = buildAndExecuteRequests(reason, keysToFlush);
        } catch (Exception e) {
            Utility.logd(TAG, "Caught unexpected exception while flushing: ", e);
        }

        synchronized (staticLock) {
            requestInFlight = false;
        }

        if (flushResults != null) {
            final Intent intent = new Intent(ACTION_APP_EVENTS_FLUSHED);
            intent.putExtra(APP_EVENTS_EXTRA_NUM_EVENTS_FLUSHED, flushResults.numEvents);
            intent.putExtra(APP_EVENTS_EXTRA_FLUSH_RESULT, flushResults.result);
            LocalBroadcastManager.getInstance(applicationContext).sendBroadcast(intent);
        }
    }

    private static FlushStatistics buildAndExecuteRequests(
            FlushReason reason,
            Set<AccessTokenAppIdPair> keysToFlush) {
        FlushStatistics flushResults = new FlushStatistics();

        boolean limitEventUsage = FacebookSdk.getLimitEventAndDataUsage(applicationContext);

        List<GraphRequest> requestsToExecute = new ArrayList<GraphRequest>();
        for (AccessTokenAppIdPair accessTokenAppId : keysToFlush) {
            SessionEventsState sessionEventsState = getSessionEventsState(accessTokenAppId);
            if (sessionEventsState == null) {
                continue;
            }

            GraphRequest request = buildRequestForSession(
                    accessTokenAppId,
                    sessionEventsState,
                    limitEventUsage,
                    flushResults);
            if (request != null) {
                requestsToExecute.add(request);
            }
        }

        if (requestsToExecute.size() > 0) {
            Logger.log(LoggingBehavior.APP_EVENTS, TAG, "Flushing %d events due to %s.",
                    flushResults.numEvents,
                    reason.toString());

            for (GraphRequest request : requestsToExecute) {
                
                
                request.executeAndWait();
            }
            return flushResults;
        }

        return null;
    }

    private static class FlushStatistics {
        public int numEvents = 0;
        public FlushResult result = FlushResult.SUCCESS;
    }

    private static GraphRequest buildRequestForSession(
            final AccessTokenAppIdPair accessTokenAppId,
            final SessionEventsState sessionEventsState,
            final boolean limitEventUsage,
            final FlushStatistics flushState) {
        String applicationId = accessTokenAppId.getApplicationId();

        Utility.FetchedAppSettings fetchedAppSettings =
                Utility.queryAppSettings(applicationId, false);

        final GraphRequest postRequest = GraphRequest.newPostRequest(
                null,
                String.format("%s/activities", applicationId),
                null,
                null);

        Bundle requestParameters = postRequest.getParameters();
        if (requestParameters == null) {
            requestParameters = new Bundle();
        }
        requestParameters.putString("access_token", accessTokenAppId.getAccessTokenString());
        postRequest.setParameters(requestParameters);

        if (fetchedAppSettings == null) {
            return null;
        }

        int numEvents = sessionEventsState.populateRequest(
                postRequest,
                fetchedAppSettings.supportsImplicitLogging(),
                limitEventUsage);

        if (numEvents == 0) {
            return null;
        }

        flushState.numEvents += numEvents;

        postRequest.setCallback(new GraphRequest.Callback() {
            @Override
            public void onCompleted(GraphResponse response) {
                handleResponse(accessTokenAppId, postRequest, response, sessionEventsState, flushState);
            }
        });

        return postRequest;
    }

    private static void handleResponse(
            AccessTokenAppIdPair accessTokenAppId,
            GraphRequest request,
            GraphResponse response,
            SessionEventsState sessionEventsState,
            FlushStatistics flushState) {
        FacebookRequestError error = response.getError();
        String resultDescription = "Success";

        FlushResult flushResult = FlushResult.SUCCESS;

        if (error != null) {
            final int NO_CONNECTIVITY_ERROR_CODE = -1;
            if (error.getErrorCode() == NO_CONNECTIVITY_ERROR_CODE) {
                resultDescription = "Failed: No Connectivity";
                flushResult = FlushResult.NO_CONNECTIVITY;
            } else {
                resultDescription = String.format("Failed:\n  Response: %s\n  Error %s",
                        response.toString(),
                        error.toString());
                flushResult = FlushResult.SERVER_ERROR;
            }
        }

        if (FacebookSdk.isLoggingBehaviorEnabled(LoggingBehavior.APP_EVENTS)) {
            String eventsJsonString = (String) request.getTag();
            String prettyPrintedEvents;

            try {
                JSONArray jsonArray = new JSONArray(eventsJsonString);
                prettyPrintedEvents = jsonArray.toString(2);
            } catch (JSONException exc) {
                prettyPrintedEvents = "<Can't encode events for debug logging>";
            }

            Logger.log(LoggingBehavior.APP_EVENTS, TAG,
                    "Flush completed\nParams: %s\n  Result: %s\n  Events JSON: %s",
                    request.getGraphObject().toString(),
                    resultDescription,
                    prettyPrintedEvents);
        }

        sessionEventsState.clearInFlightAndStats(error != null);

        if (flushResult == FlushResult.NO_CONNECTIVITY) {
            
            
            
            
            
            PersistedEvents.persistEvents(applicationContext, accessTokenAppId, sessionEventsState);
        }

        if (flushResult != FlushResult.SUCCESS) {
            
            if (flushState.result != FlushResult.NO_CONNECTIVITY) {
                flushState.result = flushResult;
            }
        }
    }

    private static int accumulatePersistedEvents() {
        PersistedEvents persistedEvents = PersistedEvents.readAndClearStore(applicationContext);

        int result = 0;
        for (AccessTokenAppIdPair accessTokenAppId : persistedEvents.keySet()) {
            SessionEventsState sessionEventsState =
                    getSessionEventsState(applicationContext, accessTokenAppId);

            List<AppEvent> events = persistedEvents.getEvents(accessTokenAppId);
            sessionEventsState.accumulatePersistedEvents(events);
            result += events.size();
        }

        return result;
    }

    
    private static void notifyDeveloperError(String message) {
        Logger.log(LoggingBehavior.DEVELOPER_ERRORS, "AppEvents", message);
    }

    
    private static void setSourceApplication(Activity activity) {

        ComponentName callingApplication = activity.getCallingActivity();
        if (callingApplication != null) {
            String callingApplicationPackage = callingApplication.getPackageName();
            if (callingApplicationPackage.equals(activity.getPackageName())) {
                
                resetSourceApplication();
                return;
            }
            sourceApplication = callingApplicationPackage;
        }

        
        
        
        Intent openIntent = activity.getIntent();
        if (openIntent == null ||
                openIntent.getBooleanExtra(SOURCE_APPLICATION_HAS_BEEN_SET_BY_THIS_INTENT, false)) {
            resetSourceApplication();
            return;
        }

        Bundle applinkData = AppLinks.getAppLinkData(openIntent);

        if (applinkData == null) {
            resetSourceApplication();
            return;
        }

        isOpenedByApplink = true;

        Bundle applinkReferrerData = applinkData.getBundle("referer_app_link");

        if (applinkReferrerData == null) {
            sourceApplication = null;
            return;
        }

        String applinkReferrerPackage = applinkReferrerData.getString("package");
        sourceApplication = applinkReferrerPackage;

        
        openIntent.putExtra(SOURCE_APPLICATION_HAS_BEEN_SET_BY_THIS_INTENT, true);

        return;
    }

    static void setSourceApplication(String applicationPackage, boolean openByAppLink) {
        sourceApplication = applicationPackage;
        isOpenedByApplink = openByAppLink;
    }

    static String getSourceApplication() {
        String openType = "Unclassified";
        if (isOpenedByApplink) {
            openType = "Applink";
        }
        if (sourceApplication != null) {
            return openType + "(" + sourceApplication + ")";
        }
        return openType;
    }

    static void resetSourceApplication() {
        sourceApplication = null;
        isOpenedByApplink = false;
    }

    
    public static String getAnonymousAppDeviceGUID(Context context) {

        if (anonymousAppDeviceGUID == null) {
            synchronized (staticLock) {
                if (anonymousAppDeviceGUID == null) {

                    SharedPreferences preferences = context.getSharedPreferences(
                            APP_EVENT_PREFERENCES,
                            Context.MODE_PRIVATE);
                    anonymousAppDeviceGUID = preferences.getString("anonymousAppDeviceGUID", null);
                    if (anonymousAppDeviceGUID == null) {
                        
                        anonymousAppDeviceGUID = "XZ" + UUID.randomUUID().toString();

                        context.getSharedPreferences(APP_EVENT_PREFERENCES, Context.MODE_PRIVATE)
                                .edit()
                                .putString("anonymousAppDeviceGUID", anonymousAppDeviceGUID)
                                .apply();
                    }
                }
            }
        }

        return anonymousAppDeviceGUID;
    }

    
    
    


    static class SessionEventsState {
        private List<AppEvent> accumulatedEvents = new ArrayList<AppEvent>();
        private List<AppEvent> inFlightEvents = new ArrayList<AppEvent>();
        private int numSkippedEventsDueToFullBuffer;
        private AttributionIdentifiers attributionIdentifiers;
        private String packageName;
        private String anonymousAppDeviceGUID;

        public static final String EVENT_COUNT_KEY = "event_count";
        public static final String ENCODED_EVENTS_KEY = "encoded_events";
        public static final String NUM_SKIPPED_KEY = "num_skipped";

        private final int MAX_ACCUMULATED_LOG_EVENTS = 1000;

        public SessionEventsState(
                AttributionIdentifiers identifiers,
                String packageName,
                String anonymousGUID) {
            this.attributionIdentifiers = identifiers;
            this.packageName = packageName;
            this.anonymousAppDeviceGUID = anonymousGUID;
        }

        
        
        public synchronized void addEvent(AppEvent event) {
            if (accumulatedEvents.size() + inFlightEvents.size() >= MAX_ACCUMULATED_LOG_EVENTS) {
                numSkippedEventsDueToFullBuffer++;
            } else {
                accumulatedEvents.add(event);
            }
        }

        public synchronized int getAccumulatedEventCount() {
            return accumulatedEvents.size();
        }

        public synchronized void clearInFlightAndStats(boolean moveToAccumulated) {
            if (moveToAccumulated) {
                accumulatedEvents.addAll(inFlightEvents);
            }
            inFlightEvents.clear();
            numSkippedEventsDueToFullBuffer = 0;
        }

        public int populateRequest(GraphRequest request, boolean includeImplicitEvents,
                                   boolean limitEventUsage) {

            int numSkipped;
            JSONArray jsonArray;
            synchronized (this) {
                numSkipped = numSkippedEventsDueToFullBuffer;

                
                inFlightEvents.addAll(accumulatedEvents);
                accumulatedEvents.clear();

                jsonArray = new JSONArray();
                for (AppEvent event : inFlightEvents) {
                    if (includeImplicitEvents || !event.getIsImplicit()) {
                        jsonArray.put(event.getJSONObject());
                    }
                }

                if (jsonArray.length() == 0) {
                    return 0;
                }
            }

            populateRequest(request, numSkipped, jsonArray, limitEventUsage);
            return jsonArray.length();
        }

        public synchronized List<AppEvent> getEventsToPersist() {
            
            
            
            List<AppEvent> result = accumulatedEvents;
            accumulatedEvents = new ArrayList<AppEvent>();
            return result;
        }

        public synchronized void accumulatePersistedEvents(List<AppEvent> events) {
            
            
            
            accumulatedEvents.addAll(events);
        }

        private void populateRequest(GraphRequest request, int numSkipped, JSONArray events,
                                     boolean limitEventUsage) {
            JSONObject publishParams = null;
            try {
                publishParams = AppEventsLoggerUtility.getJSONObjectForGraphAPICall(
                        AppEventsLoggerUtility.GraphAPIActivityType.CUSTOM_APP_EVENTS,
                        attributionIdentifiers,
                        anonymousAppDeviceGUID,
                        limitEventUsage,
                        applicationContext);

                if (numSkippedEventsDueToFullBuffer > 0) {
                    publishParams.put("num_skipped_events", numSkipped);
                }
            } catch (JSONException e) {
                
                publishParams = new JSONObject();
            }
            request.setGraphObject(publishParams);

            Bundle requestParameters = request.getParameters();
            if (requestParameters == null) {
                requestParameters = new Bundle();
            }

            String jsonString = events.toString();
            if (jsonString != null) {
                requestParameters.putByteArray(
                        "custom_events_file",
                        getStringAsByteArray(jsonString));
                request.setTag(jsonString);
            }
            request.setParameters(requestParameters);
        }

        private byte[] getStringAsByteArray(String jsonString) {
            byte[] jsonUtf8 = null;
            try {
                jsonUtf8 = jsonString.getBytes("UTF-8");
            } catch (UnsupportedEncodingException e) {
                
                Utility.logd("Encoding exception: ", e);
            }
            return jsonUtf8;
        }
    }

    static class AppEvent implements Serializable {
        private static final long serialVersionUID = 1L;

        private JSONObject jsonObject;
        private boolean isImplicit;
        private static final HashSet<String> validatedIdentifiers = new HashSet<String>();
        private String name;

        public AppEvent(
                String contextName,
                String eventName,
                Double valueToSum,
                Bundle parameters,
                boolean isImplicitlyLogged
        ) {
            try {
                validateIdentifier(eventName);

                this.name = eventName;
                isImplicit = isImplicitlyLogged;
                jsonObject = new JSONObject();

                jsonObject.put("_eventName", eventName);
                jsonObject.put("_logTime", System.currentTimeMillis() / 1000);
                jsonObject.put("_ui", contextName);

                if (valueToSum != null) {
                    jsonObject.put("_valueToSum", valueToSum.doubleValue());
                }

                if (isImplicit) {
                    jsonObject.put("_implicitlyLogged", "1");
                }

                if (parameters != null) {
                    for (String key : parameters.keySet()) {

                        validateIdentifier(key);

                        Object value = parameters.get(key);
                        if (!(value instanceof String) && !(value instanceof Number)) {
                            throw new FacebookException(
                                    String.format(
                                            "Parameter value '%s' for key '%s' should be a string" +
                                                    " or a numeric type.",
                                            value,
                                            key)
                            );
                        }

                        jsonObject.put(key, value.toString());
                    }
                }

                if (!isImplicit) {
                    Logger.log(LoggingBehavior.APP_EVENTS, "AppEvents",
                            "Created app event '%s'", jsonObject.toString());
                }
            } catch (JSONException jsonException) {

                
                Logger.log(LoggingBehavior.APP_EVENTS, "AppEvents",
                        "JSON encoding for app event failed: '%s'", jsonException.toString());
                jsonObject = null;

            } catch (FacebookException e) {
                
                Logger.log(LoggingBehavior.APP_EVENTS, "AppEvents",
                        "Invalid app event name or parameter:", e.toString());
                jsonObject = null;
            }
        }

        public String getName() {
            return name;
        }

        private AppEvent(String jsonString, boolean isImplicit) throws JSONException {
            jsonObject = new JSONObject(jsonString);
            this.isImplicit = isImplicit;
        }

        public boolean getIsImplicit() {
            return isImplicit;
        }

        public JSONObject getJSONObject() {
            return jsonObject;
        }

        
        private void validateIdentifier(String identifier) throws FacebookException {

            
            
            final String regex = "^[0-9a-zA-Z_]+[0-9a-zA-Z _-]*$";

            final int MAX_IDENTIFIER_LENGTH = 40;
            if (identifier == null
                    || identifier.length() == 0
                    || identifier.length() > MAX_IDENTIFIER_LENGTH) {
                if (identifier == null) {
                    identifier = "<None Provided>";
                }
                throw new FacebookException(
                    String.format(
                            Locale.ROOT,
                            "Identifier '%s' must be less than %d characters",
                            identifier,
                            MAX_IDENTIFIER_LENGTH)
                );
            }

            boolean alreadyValidated = false;
            synchronized (validatedIdentifiers) {
                alreadyValidated = validatedIdentifiers.contains(identifier);
            }

            if (!alreadyValidated) {
                if (identifier.matches(regex)) {
                    synchronized (validatedIdentifiers) {
                        validatedIdentifiers.add(identifier);
                    }
                } else {
                    throw new FacebookException(
                            String.format(
                                    "Skipping event named '%s' due to illegal name - must be " +
                                            "under 40 chars and alphanumeric, _, - or space, and " +
                                            "not start with a space or hyphen.",
                                    identifier
                            )
                    );
                }
            }
        }

        private static class SerializationProxyV1 implements Serializable {
            private static final long serialVersionUID = -2488473066578201069L;
            private final String jsonString;
            private final boolean isImplicit;

            private SerializationProxyV1(String jsonString, boolean isImplicit) {
                this.jsonString = jsonString;
                this.isImplicit = isImplicit;
            }

            private Object readResolve() throws JSONException {
                return new AppEvent(jsonString, isImplicit);
            }
        }

        private Object writeReplace() {
            return new SerializationProxyV1(jsonObject.toString(), isImplicit);
        }

        @Override
        public String toString() {
            return String.format(
                    "\"%s\", implicit: %b, json: %s",
                    jsonObject.optString("_eventName"),
                    isImplicit,
                    jsonObject.toString());
        }
    }

    static class PersistedAppSessionInfo {
        private static final String PERSISTED_SESSION_INFO_FILENAME =
                "AppEventsLogger.persistedsessioninfo";

        private static final Object staticLock = new Object();
        private static boolean hasChanges = false;
        private static boolean isLoaded = false;
        private static Map<AccessTokenAppIdPair, FacebookTimeSpentData> appSessionInfoMap;

        private static final Runnable appSessionInfoFlushRunnable = new Runnable() {
            @Override
            public void run() {
                PersistedAppSessionInfo.saveAppSessionInformation(applicationContext);
            }
        };

        @SuppressWarnings("unchecked")
        private static void restoreAppSessionInformation(Context context) {
            ObjectInputStream ois = null;

            synchronized (staticLock) {
                if (!isLoaded) {
                    try {
                        ois =
                                new ObjectInputStream(
                                        context.openFileInput(PERSISTED_SESSION_INFO_FILENAME));
                        appSessionInfoMap = (HashMap<AccessTokenAppIdPair, FacebookTimeSpentData>)
                                ois.readObject();
                        Logger.log(
                                LoggingBehavior.APP_EVENTS,
                                "AppEvents",
                                "App session info loaded");
                    } catch (FileNotFoundException fex) {
                    } catch (Exception e) {
                        Log.d(TAG, "Got unexpected exception: " + e.toString());
                    } finally {
                        Utility.closeQuietly(ois);
                        context.deleteFile(PERSISTED_SESSION_INFO_FILENAME);
                        if (appSessionInfoMap == null) {
                            appSessionInfoMap =
                                    new HashMap<AccessTokenAppIdPair, FacebookTimeSpentData>();
                        }
                        
                        
                        
                        isLoaded = true;
                        hasChanges = false;
                    }
                }
            }
        }

        static void saveAppSessionInformation(Context context) {
            ObjectOutputStream oos = null;

            synchronized (staticLock) {
                if (hasChanges) {
                    try {
                        oos = new ObjectOutputStream(
                                new BufferedOutputStream(
                                        context.openFileOutput(
                                                PERSISTED_SESSION_INFO_FILENAME,
                                                Context.MODE_PRIVATE)
                                )
                        );
                        oos.writeObject(appSessionInfoMap);
                        hasChanges = false;
                        Logger.log(
                                LoggingBehavior.APP_EVENTS,
                                "AppEvents",
                                "App session info saved");
                    } catch (Exception e) {
                        Log.d(TAG, "Got unexpected exception: " + e.toString());
                    } finally {
                        Utility.closeQuietly(oos);
                    }
                }
            }
        }

        static void onResume(
                Context context,
                AccessTokenAppIdPair accessTokenAppId,
                AppEventsLogger logger,
                long eventTime,
                String sourceApplicationInfo
        ) {
            synchronized (staticLock) {
                FacebookTimeSpentData timeSpentData = getTimeSpentData(context, accessTokenAppId);
                timeSpentData.onResume(logger, eventTime, sourceApplicationInfo);
                onTimeSpentDataUpdate();
            }
        }

        static void onSuspend(
                Context context,
                AccessTokenAppIdPair accessTokenAppId,
                AppEventsLogger logger,
                long eventTime
        ) {
            synchronized (staticLock) {
                FacebookTimeSpentData timeSpentData = getTimeSpentData(context, accessTokenAppId);
                timeSpentData.onSuspend(logger, eventTime);
                onTimeSpentDataUpdate();
            }
        }

        private static FacebookTimeSpentData getTimeSpentData(
                Context context,
                AccessTokenAppIdPair accessTokenAppId
        ) {
            restoreAppSessionInformation(context);
            FacebookTimeSpentData result = null;

            result = appSessionInfoMap.get(accessTokenAppId);
            if (result == null) {
                result = new FacebookTimeSpentData();
                appSessionInfoMap.put(accessTokenAppId, result);
            }

            return result;
        }

        private static void onTimeSpentDataUpdate() {
            if (!hasChanges) {
                hasChanges = true;
                backgroundExecutor.schedule(
                        appSessionInfoFlushRunnable,
                        FLUSH_APP_SESSION_INFO_IN_SECONDS,
                        TimeUnit.SECONDS);
            }
        }
    }

    
    
    static class PersistedEvents {
        static final String PERSISTED_EVENTS_FILENAME = "AppEventsLogger.persistedevents";

        private static Object staticLock = new Object();

        private Context context;
        private HashMap<AccessTokenAppIdPair, List<AppEvent>> persistedEvents =
                new HashMap<AccessTokenAppIdPair, List<AppEvent>>();

        private PersistedEvents(Context context) {
            this.context = context;
        }

        public static PersistedEvents readAndClearStore(Context context) {
            synchronized (staticLock) {
                PersistedEvents persistedEvents = new PersistedEvents(context);

                persistedEvents.readAndClearStore();

                return persistedEvents;
            }
        }

        public static void persistEvents(Context context, AccessTokenAppIdPair accessTokenAppId,
                                         SessionEventsState eventsToPersist) {
            Map<AccessTokenAppIdPair, SessionEventsState> map = new HashMap<AccessTokenAppIdPair, SessionEventsState>();
            map.put(accessTokenAppId, eventsToPersist);
            persistEvents(context, map);
        }

        public static void persistEvents(
                Context context,
                Map<AccessTokenAppIdPair,
                        SessionEventsState> eventsToPersist) {
            synchronized (staticLock) {
                
                
                
                
                
                PersistedEvents persistedEvents = readAndClearStore(context);

                for (Map.Entry<AccessTokenAppIdPair, SessionEventsState> entry
                        : eventsToPersist.entrySet()) {
                    List<AppEvent> events = entry.getValue().getEventsToPersist();
                    if (events.size() == 0) {
                        continue;
                    }

                    persistedEvents.addEvents(entry.getKey(), events);
                }

                persistedEvents.write();
            }
        }

        public Set<AccessTokenAppIdPair> keySet() {
            return persistedEvents.keySet();
        }

        public List<AppEvent> getEvents(AccessTokenAppIdPair accessTokenAppId) {
            return persistedEvents.get(accessTokenAppId);
        }

        private void write() {
            ObjectOutputStream oos = null;
            try {
                oos = new ObjectOutputStream(
                        new BufferedOutputStream(
                                context.openFileOutput(PERSISTED_EVENTS_FILENAME, 0)));
                oos.writeObject(persistedEvents);
            } catch (Exception e) {
                Log.d(TAG, "Got unexpected exception: " + e.toString());
            } finally {
                Utility.closeQuietly(oos);
            }
        }

        private void readAndClearStore() {
            ObjectInputStream ois = null;
            try {
                ois = new ObjectInputStream(
                        new BufferedInputStream(context.openFileInput(PERSISTED_EVENTS_FILENAME)));

                @SuppressWarnings("unchecked")
                HashMap<AccessTokenAppIdPair, List<AppEvent>> obj =
                        (HashMap<AccessTokenAppIdPair, List<AppEvent>>) ois.readObject();

                
                
                context.getFileStreamPath(PERSISTED_EVENTS_FILENAME).delete();
                persistedEvents = obj;
            } catch (FileNotFoundException e) {
                
            } catch (Exception e) {
                Log.d(TAG, "Got unexpected exception: " + e.toString());
            } finally {
                Utility.closeQuietly(ois);
            }
        }

        public void addEvents(
                AccessTokenAppIdPair accessTokenAppId,
                List<AppEvent> eventsToPersist) {
            if (!persistedEvents.containsKey(accessTokenAppId)) {
                persistedEvents.put(accessTokenAppId, new ArrayList<AppEvent>());
            }
            persistedEvents.get(accessTokenAppId).addAll(eventsToPersist);
        }
    }
}

<code block>


package com.facebook.share.model;

import android.os.Bundle;
import android.os.Parcel;


public abstract class ShareMedia implements ShareModel {

    private final Bundle params;

    protected ShareMedia(final Builder builder) {
        this.params = new Bundle(builder.params);
    }

    ShareMedia(final Parcel in) {
        this.params = in.readBundle();
    }

    
    @Deprecated
    public Bundle getParameters() {
        return new Bundle(params);
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeBundle(params);
    }

    
    public static abstract class Builder<M extends ShareMedia, B extends Builder>
            implements ShareModelBuilder<M, B> {
        private Bundle params = new Bundle();

        
        @Deprecated
        public B setParameter(final String key, final String value) {
            params.putString(key, value);
            return (B) this;
        }

        
        @Deprecated
        public B setParameters(final Bundle parameters) {
            params.putAll(parameters);
            return (B) this;
        }

        @Override
        public B readFrom(final M model) {
            if (model == null) {
                return (B) this;
            }
            return this.setParameters(model.getParameters());
        }
    }
}

<code block>


package com.facebook.login;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.Intent;
import android.content.pm.ResolveInfo;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.content.Context;

import com.facebook.AccessToken;
import com.facebook.CallbackManager;
import com.facebook.FacebookActivity;
import com.facebook.FacebookAuthorizationException;
import com.facebook.FacebookCallback;
import com.facebook.FacebookException;
import com.facebook.FacebookSdk;
import com.facebook.GraphResponse;
import com.facebook.Profile;
import com.facebook.internal.CallbackManagerImpl;
import com.facebook.internal.Validate;
import com.facebook.appevents.AppEventsConstants;

import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.UUID;


public class LoginManager {
    private static final String PUBLISH_PERMISSION_PREFIX = "publish";
    private static final String MANAGE_PERMISSION_PREFIX = "manage";
    private static final Set<String> OTHER_PUBLISH_PERMISSIONS = getOtherPublishPermissions();

    private static volatile LoginManager instance;

    private LoginBehavior loginBehavior = LoginBehavior.SSO_WITH_FALLBACK;
    private DefaultAudience defaultAudience = DefaultAudience.FRIENDS;
    private LoginClient.Request pendingLoginRequest;
    private HashMap<String, String> pendingLoggingExtras;
    private LoginLogger loginLogger;

    LoginManager() {
        Validate.sdkInitialized();
    }

    
    public static LoginManager getInstance() {
        if (instance == null) {
            synchronized (LoginManager.class) {
                if (instance == null) {
                    instance = new LoginManager();
                }
            }
        }

        return instance;
    }

    
    public void resolveError(final Activity activity, final GraphResponse response) {
        startLogin(
                new ActivityStartActivityDelegate(activity),
                createLoginRequestFromResponse(response)
        );
    }

    
    public void resolveError(final Fragment fragment, final GraphResponse response) {
        startLogin(
                new FragmentStartActivityDelegate(fragment),
                createLoginRequestFromResponse(response)
        );
    }

    private LoginClient.Request createLoginRequestFromResponse(final GraphResponse response) {
        Validate.notNull(response, "response");
        AccessToken failedToken = response.getRequest().getAccessToken();
        return createLoginRequest(failedToken != null ? failedToken.getPermissions() : null);
    }

    
    public void registerCallback(
            final CallbackManager callbackManager,
            final FacebookCallback<LoginResult> callback) {
        if (!(callbackManager instanceof CallbackManagerImpl)) {
            throw new FacebookException("Unexpected CallbackManager, " +
                    "please use the provided Factory.");
        }
        ((CallbackManagerImpl) callbackManager).registerCallback(
                CallbackManagerImpl.RequestCodeOffset.Login.toRequestCode(),
                new CallbackManagerImpl.Callback() {
                    @Override
                    public boolean onActivityResult(int resultCode, Intent data) {
                        return LoginManager.this.onActivityResult(
                                resultCode,
                                data,
                                callback);
                    }
                }
        );
    }

    boolean onActivityResult(int resultCode, Intent data) {
        return onActivityResult(resultCode, data, null);
    }

    boolean onActivityResult(int resultCode, Intent data, FacebookCallback<LoginResult>  callback) {

        if (pendingLoginRequest == null) {
            return false;
        }

        FacebookException exception = null;
        AccessToken newToken = null;
        LoginClient.Result.Code code = LoginClient.Result.Code.ERROR;
        Map<String, String> loggingExtras = null;

        boolean isCanceled = false;
        if (data != null) {
            LoginClient.Result result = (LoginClient.Result)
                    data.getParcelableExtra(LoginFragment.RESULT_KEY);
            if (result != null) {
                code = result.code;
                if (resultCode == Activity.RESULT_OK) {
                    if (result.code == LoginClient.Result.Code.SUCCESS) {
                        newToken = result.token;
                    } else {
                        exception = new FacebookAuthorizationException(result.errorMessage);
                    }
                } else if (resultCode == Activity.RESULT_CANCELED) {
                    isCanceled = true;
                }
                loggingExtras = result.loggingExtras;
            }
        } else if (resultCode == Activity.RESULT_CANCELED) {
            isCanceled = true;
            code = LoginClient.Result.Code.CANCEL;
        }

        if (exception == null && newToken == null && !isCanceled) {
            exception = new FacebookException("Unexpected call to LoginManager.onActivityResult");
        }

        logCompleteLogin(code, loggingExtras, exception);

        finishLogin(newToken, exception, isCanceled, callback);

        return true;
    }

    
    public LoginBehavior getLoginBehavior() {
        return loginBehavior;
    }

    
    public LoginManager setLoginBehavior(LoginBehavior loginBehavior) {
        this.loginBehavior = loginBehavior;
        return this;
    }

    
    public DefaultAudience getDefaultAudience() {
        return defaultAudience;
    }

    
    public LoginManager setDefaultAudience(DefaultAudience defaultAudience) {
        this.defaultAudience = defaultAudience;
        return this;
    }

    
    public void logOut() {
        AccessToken.setCurrentAccessToken(null);
        Profile.setCurrentProfile(null);
    }

    
    public void logInWithReadPermissions(Fragment fragment, Collection<String> permissions) {
        validateReadPermissions(permissions);

        LoginClient.Request loginRequest = createLoginRequest(permissions);
        startLogin(new FragmentStartActivityDelegate(fragment), loginRequest);
    }

    
    public void logInWithReadPermissions(Activity activity, Collection<String> permissions) {
        validateReadPermissions(permissions);

        LoginClient.Request loginRequest = createLoginRequest(permissions);
        startLogin(new ActivityStartActivityDelegate(activity), loginRequest);
    }

    
    public void logInWithPublishPermissions(Fragment fragment, Collection<String> permissions) {
        validatePublishPermissions(permissions);

        LoginClient.Request loginRequest = createLoginRequest(permissions);
        startLogin(new FragmentStartActivityDelegate(fragment), loginRequest);
    }

    
    public void logInWithPublishPermissions(Activity activity, Collection<String> permissions) {
        validatePublishPermissions(permissions);

        LoginClient.Request loginRequest = createLoginRequest(permissions);
        startLogin(new ActivityStartActivityDelegate(activity), loginRequest);
    }

    LoginClient.Request getPendingLoginRequest() {
        return pendingLoginRequest;
    }

    private void validateReadPermissions(Collection<String> permissions) {
        if (permissions == null) {
            return;
        }
        for (String permission : permissions) {
            if (isPublishPermission(permission)) {
                throw new FacebookException(
                    String.format(
                        "Cannot pass a publish or manage permission (%s) to a request for read " +
                                "authorization",
                        permission));
            }
        }
    }

    private void validatePublishPermissions(Collection<String> permissions) {
        if (permissions == null) {
            return;
        }
        for (String permission : permissions) {
            if (!isPublishPermission(permission)) {
                throw new FacebookException(
                    String.format(
                        "Cannot pass a read permission (%s) to a request for publish authorization",
                        permission));
            }
        }
    }

    static boolean isPublishPermission(String permission) {
        return permission != null &&
            (permission.startsWith(PUBLISH_PERMISSION_PREFIX) ||
                permission.startsWith(MANAGE_PERMISSION_PREFIX) ||
                OTHER_PUBLISH_PERMISSIONS.contains(permission));
    }

    private static Set<String> getOtherPublishPermissions() {
        HashSet<String> set = new HashSet<String>() {{
            add("ads_management");
            add("create_event");
            add("rsvp_event");
        }};
        return Collections.unmodifiableSet(set);
    }

    private LoginClient.Request createLoginRequest(Collection<String> permissions) {
        LoginClient.Request request = new LoginClient.Request(
                loginBehavior,
                Collections.unmodifiableSet(
                        permissions != null ? new HashSet(permissions) : new HashSet<String>()),
                defaultAudience,
                FacebookSdk.getApplicationId(),
                UUID.randomUUID().toString()
        );
        request.setRerequest(AccessToken.getCurrentAccessToken() != null);
        return request;
    }

    private void startLogin(
            StartActivityDelegate startActivityDelegate,
            LoginClient.Request request
    ) throws FacebookException {

        this.pendingLoginRequest = request;
        this.pendingLoggingExtras = new HashMap<>();
        this.loginLogger = getLoggerForContext(startActivityDelegate.getActivityContext());

        logStartLogin();

        
        CallbackManagerImpl.registerStaticCallback(
                CallbackManagerImpl.RequestCodeOffset.Login.toRequestCode(),
                new CallbackManagerImpl.Callback() {
                    @Override
                    public boolean onActivityResult(int resultCode, Intent data) {
                        return LoginManager.this.onActivityResult(resultCode, data);
                    }
                }
        );

        boolean started = tryFacebookActivity(startActivityDelegate, request);

        pendingLoggingExtras.put(
                LoginLogger.EVENT_EXTRAS_TRY_LOGIN_ACTIVITY,
                started ?
                AppEventsConstants.EVENT_PARAM_VALUE_YES : AppEventsConstants.EVENT_PARAM_VALUE_NO
        );

        if (!started) {
            FacebookException exception = new FacebookException(
                    "Log in attempt failed: FacebookActivity could not be started." +
                            " Please make sure you added FacebookActivity to the AndroidManifest.");
            logCompleteLogin(LoginClient.Result.Code.ERROR, null, exception);
            this.pendingLoginRequest = null;
            throw exception;
        }
    }

    private LoginLogger getLoggerForContext(Context context) {
        if (context == null || pendingLoginRequest == null) {
            return null;
        }

        LoginLogger logger = this.loginLogger;
        if (logger == null ||
                !logger.getApplicationId().equals(pendingLoginRequest.getApplicationId())) {
            logger = new LoginLogger(context, pendingLoginRequest.getApplicationId());
        }
        return logger;
    }

    private void logStartLogin() {
        if (loginLogger != null && pendingLoginRequest != null) {
            loginLogger.logStartLogin(pendingLoginRequest);
        }
    }

    private void logCompleteLogin(LoginClient.Result.Code result, Map<String, String> resultExtras,
                                  Exception exception) {
        if (loginLogger == null) {
            return;
        }
        if (pendingLoginRequest == null) {
            
            loginLogger.logUnexpectedError(
                    LoginLogger.EVENT_NAME_LOGIN_COMPLETE,
                    "Unexpected call to logCompleteLogin with null pendingAuthorizationRequest."
            );
        } else {
            loginLogger.logCompleteLogin(
                    pendingLoginRequest.getAuthId(),
                    pendingLoggingExtras,
                    result,
                    resultExtras,
                    exception);
        }
    }

    private boolean tryFacebookActivity(
            StartActivityDelegate startActivityDelegate,
            LoginClient.Request request) {

        Intent intent = getFacebookActivityIntent(request);

        if (!resolveIntent(intent)) {
            return false;
        }

        try {
            startActivityDelegate.startActivityForResult(
                    intent,
                    LoginClient.getLoginRequestCode());
        } catch (ActivityNotFoundException e) {
            return false;
        }

        return true;
    }

    private boolean resolveIntent(Intent intent) {
        ResolveInfo resolveInfo = FacebookSdk.getApplicationContext().getPackageManager()
            .resolveActivity(intent, 0);
        if (resolveInfo == null) {
            return false;
        }
        return true;
    }

    private Intent getFacebookActivityIntent(LoginClient.Request request) {
        Intent intent = new Intent();
        intent.setClass(FacebookSdk.getApplicationContext(), FacebookActivity.class);
        intent.setAction(request.getLoginBehavior().toString());

        
        LoginClient.Request authClientRequest = request;
        Bundle extras = LoginFragment.populateIntentExtras(authClientRequest);
        intent.putExtras(extras);

        return intent;
    }

    static LoginResult computeLoginResult(
            final LoginClient.Request request,
            final AccessToken newToken
    ) {
        Set<String> requestedPermissions = request.getPermissions();
        Set<String> grantedPermissions = new HashSet<String>(newToken.getPermissions());

        
        
        if (request.isRerequest()) {
            grantedPermissions.retainAll(requestedPermissions);
        }

        Set<String> deniedPermissions = new HashSet<String>(requestedPermissions);
        deniedPermissions.removeAll(grantedPermissions);
        return new LoginResult(newToken, grantedPermissions, deniedPermissions);
    }

    private void finishLogin(
            AccessToken newToken,
            FacebookException exception,
            boolean isCanceled,
            FacebookCallback<LoginResult>  callback) {
        if (newToken != null) {
            AccessToken.setCurrentAccessToken(newToken);
            Profile.fetchProfileForCurrentAccessToken();
        }

        if (callback != null) {
            LoginResult loginResult = newToken != null
                    ? computeLoginResult(pendingLoginRequest, newToken)
                    : null;
            
            if (isCanceled
                    || (loginResult != null
                           && loginResult.getRecentlyGrantedPermissions().size() == 0)) {
                callback.onCancel();
            } else if (exception != null) {
                callback.onError(exception);
            } else if (newToken != null) {
                callback.onSuccess(loginResult);
            }
        }

        this.pendingLoginRequest = null;
        this.loginLogger = null;
    }

    private static class ActivityStartActivityDelegate implements StartActivityDelegate {
        private final Activity activity;

        ActivityStartActivityDelegate(final Activity activity) {
            Validate.notNull(activity, "activity");
            this.activity = activity;
        }

        @Override
        public void startActivityForResult(Intent intent, int requestCode) {
            activity.startActivityForResult(intent, requestCode);
        }

        @Override
        public Activity getActivityContext() {
            return activity;
        }
    }

    private static class FragmentStartActivityDelegate implements StartActivityDelegate {
        private final Fragment fragment;

        FragmentStartActivityDelegate(final Fragment fragment) {
            Validate.notNull(fragment, "fragment");
            this.fragment = fragment;
        }

        @Override
        public void startActivityForResult(Intent intent, int requestCode) {
            fragment.startActivityForResult(intent, requestCode);
        }

        @Override
        public Activity getActivityContext() {
            return fragment.getActivity();
        }
    }
}

<code block>


package com.facebook.junittests;

import android.support.v4.app.FragmentActivity;
import android.support.v7.app.ActionBarActivity;
import android.os.Bundle;
import android.view.Menu;
import android.view.MenuItem;

import com.facebook.FacebookSdk;


public class MainActivity extends FragmentActivity {
    private static String APP_ID = "1234";
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        FacebookSdk.sdkInitialize(getApplicationContext());
        FacebookSdk.setApplicationId(APP_ID);
        setContentView(R.layout.activity_main);
    }


    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        
        getMenuInflater().inflate(R.menu.menu_main, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        
        
        
        int id = item.getItemId();

        
        if (id == R.id.action_settings) {
            return true;
        }

        return super.onOptionsItemSelected(item);
    }
}

<code block>


package com.facebook;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.robolectric.Robolectric;
import org.robolectric.RuntimeEnvironment;

import java.io.ByteArrayOutputStream;
import java.util.HashMap;
import java.util.Map;

import static org.junit.Assert.*;

public class ProgressOutputStreamTest extends FacebookTestCase {
    private static final int MAX_PROGRESS = 10;

    private GraphRequest r1, r2;
    private Map<GraphRequest, RequestProgress> progressMap;
    private GraphRequestBatch requests;
    private ProgressOutputStream stream;

    @Before
    public void before() throws Exception {
        FacebookSdk.sdkInitialize(RuntimeEnvironment.application);
        r1 = new GraphRequest(null, "4");
        r2 = new GraphRequest(null, "4");

        progressMap = new HashMap<GraphRequest, RequestProgress>();
        progressMap.put(r1, new RequestProgress(null, r1));
        progressMap.get(r1).addToMax(5);
        progressMap.put(r2, new RequestProgress(null, r2));
        progressMap.get(r2).addToMax(5);

        requests = new GraphRequestBatch(r1, r2);

        ByteArrayOutputStream backing = new ByteArrayOutputStream();
        stream = new ProgressOutputStream(backing, requests, progressMap, MAX_PROGRESS);
    }

    @After
    public void after() throws Exception {
        stream.close();
    }

    @Test
    public void testSetup() {
        assertEquals(0, stream.getBatchProgress());
        assertEquals(MAX_PROGRESS, stream.getMaxProgress());

        for (RequestProgress p : progressMap.values()) {
            assertEquals(0, p.getProgress());
            assertEquals(5, p.getMaxProgress());
        }
    }

    @Test
    public void testWriting() {
        try {
            assertEquals(0, stream.getBatchProgress());

            stream.setCurrentRequest(r1);
            stream.write(0);
            assertEquals(1, stream.getBatchProgress());

            final byte[] buf = new byte[4];
            stream.write(buf);
            assertEquals(5, stream.getBatchProgress());

            stream.setCurrentRequest(r2);
            stream.write(buf, 2, 2);
            stream.write(buf, 1, 3);
            assertEquals(MAX_PROGRESS, stream.getBatchProgress());

            assertEquals(stream.getMaxProgress(), stream.getBatchProgress());
            assertEquals(progressMap.get(r1).getMaxProgress(), progressMap.get(r1).getProgress());
            assertEquals(progressMap.get(r2).getMaxProgress(), progressMap.get(r2).getProgress());
        }
        catch (Exception ex) {
            fail(ex.getMessage());
        }
    }
}

<code block>


package com.facebook;

import android.content.Intent;
import android.support.v4.content.LocalBroadcastManager;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.robolectric.Robolectric;
import org.robolectric.RuntimeEnvironment;

import java.util.InputMismatchException;

import static org.junit.Assert.*;
import static org.mockito.Matchers.any;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.powermock.api.mockito.PowerMockito.mock;

@PrepareForTest( { ProfileCache.class })
public class ProfileManagerTest extends FacebookPowerMockTestCase {

    @Before
    public void before() {
        FacebookSdk.sdkInitialize(RuntimeEnvironment.application);
    }

    @Test
    public void testLoadCurrentProfileEmptyCache() {
        ProfileCache profileCache = mock(ProfileCache.class);
        LocalBroadcastManager localBroadcastManager = mock(LocalBroadcastManager.class);
        ProfileManager profileManager = new ProfileManager(
                localBroadcastManager,
                profileCache
        );
        assertFalse(profileManager.loadCurrentProfile());
        verify(profileCache, times(1)).load();
    }

    @Test
    public void testLoadCurrentProfileWithCache() {
        ProfileCache profileCache = mock(ProfileCache.class);
        Profile profile = ProfileTest.createDefaultProfile();
        when(profileCache.load()).thenReturn(profile);
        LocalBroadcastManager localBroadcastManager = mock(LocalBroadcastManager.class);
        ProfileManager profileManager = new ProfileManager(
                localBroadcastManager,
                profileCache
        );
        assertTrue(profileManager.loadCurrentProfile());
        verify(profileCache, times(1)).load();

        
        verify(profileCache, never()).save(any(Profile.class));

        
        verify(localBroadcastManager).sendBroadcast(any(Intent.class));

        
        profileManager.setCurrentProfile(ProfileTest.createDefaultProfile());
        verify(localBroadcastManager, times(1)).sendBroadcast(any(Intent.class));

        
        profileManager.setCurrentProfile(null);
        verify(localBroadcastManager, times(2)).sendBroadcast(any(Intent.class));
    }
}

<code block>


package com.facebook;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.support.v4.content.LocalBroadcastManager;

import com.facebook.internal.Utility;

import org.json.JSONException;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.powermock.api.mockito.PowerMockito;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.robolectric.Robolectric;
import org.robolectric.RuntimeEnvironment;

import java.util.Arrays;
import java.util.Date;
import java.util.List;

import static org.mockito.Mockito.*;
import static org.junit.Assert.*;
import static org.powermock.api.mockito.PowerMockito.mockStatic;
import static org.powermock.api.mockito.PowerMockito.when;
import static org.powermock.api.support.membermodification.MemberMatcher.method;
import static org.powermock.api.support.membermodification.MemberModifier.suppress;

@PrepareForTest({FacebookSdk.class, AccessTokenCache.class, Utility.class})
public class AccessTokenManagerTest extends FacebookPowerMockTestCase {

    private final String TOKEN_STRING = "A token of my esteem";
    private final String USER_ID = "1000";
    private final List<String> PERMISSIONS = Arrays.asList("walk", "chew gum");
    private final Date EXPIRES = new Date(2025, 5, 3);
    private final Date LAST_REFRESH = new Date(2023, 8, 15);
    private final String APP_ID = "1234";

    private LocalBroadcastManager localBroadcastManager;
    private AccessTokenCache accessTokenCache;

    @Before
    public void before() throws Exception {
        mockStatic(FacebookSdk.class);
        when(FacebookSdk.isInitialized()).thenReturn(true);
        when(FacebookSdk.getApplicationContext()).thenReturn(RuntimeEnvironment.application);
        suppress(method(Utility.class, "clearFacebookCookies"));

        localBroadcastManager = LocalBroadcastManager.getInstance(RuntimeEnvironment.application);
        accessTokenCache = mock(AccessTokenCache.class);
    }

    @Test
    public void testRequiresLocalBroadcastManager() {
        try {
            AccessTokenManager accessTokenManager = new AccessTokenManager(null, accessTokenCache);
            fail();
        } catch (NullPointerException ex) {
        }
    }

    @Test
    public void testRequiresTokenCache() {
        try {
            AccessTokenManager accessTokenManager = new AccessTokenManager(localBroadcastManager,
                    null);
            fail();
        } catch (NullPointerException ex) {
        }
    }

    @Test
    public void testDefaultsToNoCurrentAccessToken() {
        AccessTokenManager accessTokenManager = createAccessTokenManager();

        assertNull(accessTokenManager.getCurrentAccessToken());
    }

    @Test
    public void testCanSetCurrentAccessToken() {
        AccessTokenManager accessTokenManager = createAccessTokenManager();

        AccessToken accessToken = createAccessToken();

        accessTokenManager.setCurrentAccessToken(accessToken);

        assertEquals(accessToken, accessTokenManager.getCurrentAccessToken());
    }

    @Test
    public void testChangingAccessTokenSendsBroadcast() {
        AccessTokenManager accessTokenManager = createAccessTokenManager();

        AccessToken accessToken = createAccessToken();

        accessTokenManager.setCurrentAccessToken(accessToken);

        final Intent intents[] = new Intent[1];
        final BroadcastReceiver broadcastReceiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                intents[0] = intent;
            }
        };

        localBroadcastManager.registerReceiver(broadcastReceiver,
                new IntentFilter(AccessTokenManager.ACTION_CURRENT_ACCESS_TOKEN_CHANGED));

        AccessToken anotherAccessToken = createAccessToken("another string", "1000");

        accessTokenManager.setCurrentAccessToken(anotherAccessToken);

        localBroadcastManager.unregisterReceiver(broadcastReceiver);

        Intent intent = intents[0];

        assertNotNull(intent);

        AccessToken oldAccessToken =
                (AccessToken) intent.getParcelableExtra(AccessTokenManager.EXTRA_OLD_ACCESS_TOKEN);
        AccessToken newAccessToken =
                (AccessToken) intent.getParcelableExtra(AccessTokenManager.EXTRA_NEW_ACCESS_TOKEN);

        assertEquals(accessToken.getToken(), oldAccessToken.getToken());
        assertEquals(anotherAccessToken.getToken(), newAccessToken.getToken());
    }

    @Test
    public void testLoadReturnsFalseIfNoCachedToken() {
        AccessTokenManager accessTokenManager = createAccessTokenManager();

        boolean result = accessTokenManager.loadCurrentAccessToken();

        assertFalse(result);
    }

    @Test
    public void testLoadReturnsTrueIfCachedToken() {
        AccessToken accessToken = createAccessToken();
        when(accessTokenCache.load()).thenReturn(accessToken);

        AccessTokenManager accessTokenManager = createAccessTokenManager();

        boolean result = accessTokenManager.loadCurrentAccessToken();

        assertTrue(result);
    }

    @Test
    public void testLoadSetsCurrentTokenIfCached() {
        AccessToken accessToken = createAccessToken();
        when(accessTokenCache.load()).thenReturn(accessToken);

        AccessTokenManager accessTokenManager = createAccessTokenManager();

        accessTokenManager.loadCurrentAccessToken();

        assertEquals(accessToken, accessTokenManager.getCurrentAccessToken());
    }

    @Test
    public void testSaveWritesToCacheIfToken() throws JSONException {
        AccessToken accessToken = createAccessToken();
        AccessTokenManager accessTokenManager = createAccessTokenManager();

        accessTokenManager.setCurrentAccessToken(accessToken);

        verify(accessTokenCache, times(1)).save(any(AccessToken.class));
    }

    @Test
    public void testSetEmptyTokenClearsCache() {
        AccessTokenManager accessTokenManager = createAccessTokenManager();

        accessTokenManager.setCurrentAccessToken(null);

        verify(accessTokenCache, times(1)).clear();
    }

    @Test
    public void testLoadDoesNotSave() {
        AccessToken accessToken = createAccessToken();
        when(accessTokenCache.load()).thenReturn(accessToken);

        AccessTokenManager accessTokenManager = createAccessTokenManager();

        accessTokenManager.loadCurrentAccessToken();

        verify(accessTokenCache, never()).save(any(AccessToken.class));
    }

    private AccessTokenManager createAccessTokenManager() {
        return new AccessTokenManager(localBroadcastManager, accessTokenCache);
    }

    private AccessToken createAccessToken() {
        return createAccessToken(TOKEN_STRING, USER_ID);
    }

    private AccessToken createAccessToken(String tokenString, String userId) {
        return new AccessToken(
                tokenString,
                APP_ID,
                userId,
                PERMISSIONS,
                null,
                AccessTokenSource.WEB_VIEW,
                EXPIRES,
                LAST_REFRESH);
    }
}

<code block>


package com.facebook;

import android.content.Context;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;
import android.os.Bundle;
import android.os.ConditionVariable;

import com.facebook.internal.CallbackManagerImpl;
import com.facebook.internal.ServerProtocol;
import com.facebook.internal.Utility;

import org.junit.Before;
import org.junit.Test;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.powermock.reflect.Whitebox;
import org.robolectric.Robolectric;
import org.robolectric.RuntimeEnvironment;

import java.util.concurrent.Executor;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
import static org.powermock.api.support.membermodification.MemberMatcher.method;
import static org.powermock.api.support.membermodification.MemberModifier.stub;

@PrepareForTest({ FacebookSdk.class, Utility.class })
public final class FacebookSdkPowerMockTest extends FacebookPowerMockTestCase {

    @Before
    public void before() {
        Whitebox.setInternalState(FacebookSdk.class, "callbackRequestCodeOffset", 0xface);
        Whitebox.setInternalState(FacebookSdk.class, "sdkInitialized", false);
        stub(method(Utility.class, "loadAppSettingsAsync")).toReturn(null);

    }

    @Test
    public void testGetExecutor() {
        final ConditionVariable condition = new ConditionVariable();

        FacebookSdk.getExecutor().execute(new Runnable() {
            @Override
            public void run() {
                condition.open();
            }
        });

        boolean success = condition.block(5000);
        assertTrue(success);
    }

    @Test
    public void testSetExecutor() {
        final ConditionVariable condition = new ConditionVariable();

        final Runnable runnable = new Runnable() {
            @Override
            public void run() { }
        };

        final Executor executor = new Executor() {
            @Override
            public void execute(Runnable command) {
                assertEquals(runnable, command);
                command.run();

                condition.open();
            }
        };

        Executor original = FacebookSdk.getExecutor();
        try {
            FacebookSdk.setExecutor(executor);
            FacebookSdk.getExecutor().execute(runnable);

            boolean success = condition.block(5000);
            assertTrue(success);
        } finally {
            FacebookSdk.setExecutor(original);
        }
    }

    @Test
    public void testFacebookDomain() {
        FacebookSdk.setFacebookDomain("beta.facebook.com");

        String graphUrlBase = ServerProtocol.getGraphUrlBase();
        assertEquals("https:

        FacebookSdk.setFacebookDomain("facebook.com");
    }

    @Test
    public void testLoadDefaults() throws Exception {
        stub(method(FacebookSdk.class, "isInitialized")).toReturn(true);
        FacebookSdk.loadDefaultsFromMetadata(mockContextWithAppIdAndClientToken());

        assertEquals("1234", FacebookSdk.getApplicationId());
        assertEquals("abcd", FacebookSdk.getClientToken());
    }


    private Context mockContextWithAppIdAndClientToken() throws Exception {
        Bundle bundle = mock(Bundle.class);

        when(bundle.get(FacebookSdk.APPLICATION_ID_PROPERTY)).thenReturn("1234");
        when(bundle.getString(FacebookSdk.CLIENT_TOKEN_PROPERTY)).thenReturn("abcd");
        ApplicationInfo applicationInfo = mock(ApplicationInfo.class);
        applicationInfo.metaData = bundle;

        PackageManager packageManager = mock(PackageManager.class);
        when(packageManager.getApplicationInfo("packageName", PackageManager.GET_META_DATA))
                .thenReturn(applicationInfo);

        Context context = mock(Context.class);
        when(context.getPackageName()).thenReturn("packageName");
        when(context.getPackageManager()).thenReturn(packageManager);
        return context;
    }

    @Test
    public void testLoadDefaultsDoesNotOverwrite() throws Exception {
        stub(method(FacebookSdk.class, "isInitialized")).toReturn(true);
        FacebookSdk.setApplicationId("hello");
        FacebookSdk.setClientToken("world");

        FacebookSdk.loadDefaultsFromMetadata(mockContextWithAppIdAndClientToken());

        assertEquals("hello", FacebookSdk.getApplicationId());
        assertEquals("world", FacebookSdk.getClientToken());
    }

    @Test
    public void testRequestCodeOffsetAfterInit() throws Exception {
        FacebookSdk.sdkInitialize(RuntimeEnvironment.application);

        try {
            FacebookSdk.sdkInitialize(RuntimeEnvironment.application, 1000);
            fail();
        } catch (FacebookException exception) {
            assertEquals(FacebookSdk.CALLBACK_OFFSET_CHANGED_AFTER_INIT, exception.getMessage());
        }
    }

    @Test
    public void testRequestCodeOffsetNegative() throws Exception {
        try {
            
            FacebookSdk.sdkInitialize(RuntimeEnvironment.application, 0xFACEB00C);
            fail();
        } catch (FacebookException exception) {
            assertEquals(FacebookSdk.CALLBACK_OFFSET_NEGATIVE, exception.getMessage());
        }
    }

    @Test
    public void testRequestCodeOffset() throws Exception {
        FacebookSdk.sdkInitialize(RuntimeEnvironment.application, 1000);
        assertEquals(1000, FacebookSdk.getCallbackRequestCodeOffset());
    }

    @Test
    public void testRequestCodeRange() {
        FacebookSdk.sdkInitialize(RuntimeEnvironment.application, 1000);
        assertTrue(FacebookSdk.isFacebookRequestCode(1000));
        assertTrue(FacebookSdk.isFacebookRequestCode(1099));
        assertFalse(FacebookSdk.isFacebookRequestCode(999));
        assertFalse(FacebookSdk.isFacebookRequestCode(1100));
        assertFalse(FacebookSdk.isFacebookRequestCode(0));
    }
}

<code block>


package com.facebook;

import android.os.Bundle;

import com.facebook.internal.Utility;

import org.json.JSONObject;
import org.junit.Before;
import org.junit.Test;
import org.powermock.api.mockito.PowerMockito;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.robolectric.Robolectric;
import org.robolectric.RuntimeEnvironment;

import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Random;
import java.util.Set;

import static org.junit.Assert.*;
import static org.powermock.api.support.membermodification.MemberModifier.stub;

@PrepareForTest( {Utility.class})
public final class LegacyTokenCacheTest extends FacebookPowerMockTestCase {

    private static final String BOOLEAN_KEY = "booleanKey";
    private static final String BOOLEAN_ARRAY_KEY = "booleanArrayKey";
    private static final String BYTE_KEY = "byteKey";
    private static final String BYTE_ARRAY_KEY = "byteArrayKey";
    private static final String SHORT_KEY = "shortKey";
    private static final String SHORT_ARRAY_KEY = "shortArrayKey";
    private static final String INT_KEY = "intKey";
    private static final String INT_ARRAY_KEY = "intArrayKey";
    private static final String LONG_KEY = "longKey";
    private static final String LONG_ARRAY_KEY = "longArrayKey";
    private static final String FLOAT_ARRAY_KEY = "floatKey";
    private static final String FLOAT_KEY = "floatArrayKey";
    private static final String DOUBLE_KEY = "doubleKey";
    private static final String DOUBLE_ARRAY_KEY = "doubleArrayKey";
    private static final String CHAR_KEY = "charKey";
    private static final String CHAR_ARRAY_KEY = "charArrayKey";
    private static final String STRING_KEY = "stringKey";
    private static final String STRING_LIST_KEY = "stringListKey";
    private static final String SERIALIZABLE_KEY = "serializableKey";

    private static Random random = new Random((new Date()).getTime());

    @Override
    public void setUp() {
        super.setUp();

        FacebookSdk.sdkInitialize(RuntimeEnvironment.application);
    }

    @Before
    public void before() throws Exception {
        stub(PowerMockito.method(Utility.class, "awaitGetGraphMeRequestWithCache")).toReturn(
                new JSONObject().put("id", "1000"));
    }

    @Test
    public void testAllTypes() {
        Bundle originalBundle = new Bundle();

        putBoolean(BOOLEAN_KEY, originalBundle);
        putBooleanArray(BOOLEAN_ARRAY_KEY, originalBundle);
        putByte(BYTE_KEY, originalBundle);
        putByteArray(BYTE_ARRAY_KEY, originalBundle);
        putShort(SHORT_KEY, originalBundle);
        putShortArray(SHORT_ARRAY_KEY, originalBundle);
        putInt(INT_KEY, originalBundle);
        putIntArray(INT_ARRAY_KEY, originalBundle);
        putLong(LONG_KEY, originalBundle);
        putLongArray(LONG_ARRAY_KEY, originalBundle);
        putFloat(FLOAT_KEY, originalBundle);
        putFloatArray(FLOAT_ARRAY_KEY, originalBundle);
        putDouble(DOUBLE_KEY, originalBundle);
        putDoubleArray(DOUBLE_ARRAY_KEY, originalBundle);
        putChar(CHAR_KEY, originalBundle);
        putCharArray(CHAR_ARRAY_KEY, originalBundle);
        putString(STRING_KEY, originalBundle);
        putStringList(STRING_LIST_KEY, originalBundle);
        originalBundle.putSerializable(SERIALIZABLE_KEY, AccessTokenSource.FACEBOOK_APPLICATION_WEB);

        ensureApplicationContext();

        LegacyTokenHelper cache = new LegacyTokenHelper(RuntimeEnvironment.application);
        cache.save(originalBundle);

        LegacyTokenHelper cache2 = new LegacyTokenHelper(RuntimeEnvironment.application);
        Bundle cachedBundle = cache2.load();

        assertEquals(originalBundle.getBoolean(BOOLEAN_KEY), cachedBundle.getBoolean(BOOLEAN_KEY));
        assertArrayEquals(originalBundle.getBooleanArray(BOOLEAN_ARRAY_KEY), cachedBundle.getBooleanArray(BOOLEAN_ARRAY_KEY));
        assertEquals(originalBundle.getByte(BYTE_KEY), cachedBundle.getByte(BYTE_KEY));
        assertArrayEquals(originalBundle.getByteArray(BYTE_ARRAY_KEY), cachedBundle.getByteArray(BYTE_ARRAY_KEY));
        assertEquals(originalBundle.getShort(SHORT_KEY), cachedBundle.getShort(SHORT_KEY));
        assertArrayEquals(originalBundle.getShortArray(SHORT_ARRAY_KEY), cachedBundle.getShortArray(SHORT_ARRAY_KEY));
        assertEquals(originalBundle.getInt(INT_KEY), cachedBundle.getInt(INT_KEY));
        assertArrayEquals(originalBundle.getIntArray(INT_ARRAY_KEY), cachedBundle.getIntArray(INT_ARRAY_KEY));
        assertEquals(originalBundle.getLong(LONG_KEY), cachedBundle.getLong(LONG_KEY));
        assertArrayEquals(originalBundle.getLongArray(LONG_ARRAY_KEY), cachedBundle.getLongArray(LONG_ARRAY_KEY));
        assertEquals(originalBundle.getFloat(FLOAT_KEY), cachedBundle.getFloat(FLOAT_KEY), TestUtils.DOUBLE_EQUALS_DELTA);
        assertArrayEquals(originalBundle.getFloatArray(FLOAT_ARRAY_KEY), cachedBundle.getFloatArray(FLOAT_ARRAY_KEY));
        assertEquals(originalBundle.getDouble(DOUBLE_KEY), cachedBundle.getDouble(DOUBLE_KEY), TestUtils.DOUBLE_EQUALS_DELTA);
        assertArrayEquals(originalBundle.getDoubleArray(DOUBLE_ARRAY_KEY), cachedBundle.getDoubleArray(DOUBLE_ARRAY_KEY));
        assertEquals(originalBundle.getChar(CHAR_KEY), cachedBundle.getChar(CHAR_KEY));
        assertArrayEquals(originalBundle.getCharArray(CHAR_ARRAY_KEY), cachedBundle.getCharArray(CHAR_ARRAY_KEY));
        assertEquals(originalBundle.getString(STRING_KEY), cachedBundle.getString(STRING_KEY));
        assertListEquals(originalBundle.getStringArrayList(STRING_LIST_KEY), cachedBundle.getStringArrayList(
                STRING_LIST_KEY));
        assertEquals(originalBundle.getSerializable(SERIALIZABLE_KEY),
                cachedBundle.getSerializable(SERIALIZABLE_KEY));
    }

    @Test
    public void testMultipleCaches() {
        Bundle bundle1 = new Bundle(), bundle2 = new Bundle();

        bundle1.putInt(INT_KEY, 10);
        bundle1.putString(STRING_KEY, "ABC");
        bundle2.putInt(INT_KEY, 100);
        bundle2.putString(STRING_KEY, "xyz");

        ensureApplicationContext();

        LegacyTokenHelper cache1 = new LegacyTokenHelper(RuntimeEnvironment.application);
        LegacyTokenHelper cache2 = new LegacyTokenHelper(
                RuntimeEnvironment.application,
                "CustomCache");

        cache1.save(bundle1);
        cache2.save(bundle2);

        
        
        cache1 = new LegacyTokenHelper(RuntimeEnvironment.application, "CustomCache");
        cache2 = new LegacyTokenHelper(RuntimeEnvironment.application);

        Bundle newBundle1 = cache1.load(), newBundle2 = cache2.load();

        assertEquals(bundle2.getInt(INT_KEY), newBundle1.getInt(INT_KEY));
        assertEquals(bundle2.getString(STRING_KEY), newBundle1.getString(STRING_KEY));
        assertEquals(bundle1.getInt(INT_KEY), newBundle2.getInt(INT_KEY));
        assertEquals(bundle1.getString(STRING_KEY), newBundle2.getString(STRING_KEY));
    }

    @Test
    public void testCacheRoundtrip() {
        Set<String> permissions = Utility.hashSet("stream_publish", "go_outside_and_play");
        String token = "AnImaginaryTokenValue";
        Date later = TestUtils.nowPlusSeconds(60);
        Date earlier = TestUtils.nowPlusSeconds(-60);
        String applicationId = "1234";

        LegacyTokenHelper cache =
                new LegacyTokenHelper(RuntimeEnvironment.application);
        cache.clear();

        Bundle bundle = new Bundle();
        LegacyTokenHelper.putToken(bundle, token);
        LegacyTokenHelper.putExpirationDate(bundle, later);
        LegacyTokenHelper.putSource(
                bundle,
                AccessTokenSource.FACEBOOK_APPLICATION_NATIVE);
        LegacyTokenHelper.putLastRefreshDate(bundle, earlier);
        LegacyTokenHelper.putPermissions(bundle, permissions);
        LegacyTokenHelper.putDeclinedPermissions(
                bundle,
                Utility.arrayList("whatever"));
        LegacyTokenHelper.putApplicationId(bundle, applicationId);

        cache.save(bundle);
        bundle = cache.load();

        AccessToken accessToken = AccessToken.createFromLegacyCache(bundle);
        TestUtils.assertSamePermissions(permissions, accessToken);
        assertEquals(token, accessToken.getToken());
        assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_NATIVE, accessToken.getSource());
        assertTrue(!accessToken.isExpired());

        Bundle cachedBundle = AccessTokenTestHelper.toLegacyCacheBundle(accessToken);
        TestUtils.assertEqualContentsWithoutOrder(bundle, cachedBundle);
    }

    private static void assertArrayEquals(Object a1, Object a2) {
        assertNotNull(a1);
        assertNotNull(a2);
        assertEquals(a1.getClass(), a2.getClass());
        assertTrue("Not an array", a1.getClass().isArray());

        int length = Array.getLength(a1);
        assertEquals(length, Array.getLength(a2));
        for (int i = 0; i < length; i++) {
            Object a1Value = Array.get(a1, i);
            Object a2Value = Array.get(a2, i);

            assertEquals(a1Value, a2Value);
        }
    }

    private static void assertListEquals(List<?> l1, List<?> l2) {
        assertNotNull(l1);
        assertNotNull(l2);

        Iterator<?> i1 = l1.iterator(), i2 = l2.iterator();
        while (i1.hasNext() && i2.hasNext()) {
            assertEquals(i1.next(), i2.next());
        }

        assertTrue("Lists not of the same length", !i1.hasNext());
        assertTrue("Lists not of the same length", !i2.hasNext());
    }

    private static void putInt(String key, Bundle bundle) {
        bundle.putInt(key, random.nextInt());
    }

    private static void putIntArray(String key, Bundle bundle) {
        int length = random.nextInt(50);
        int[] array = new int[length];
        for (int i = 0; i < length; i++) {
            array[i] = random.nextInt();
        }
        bundle.putIntArray(key, array);
    }

    private static void putShort(String key, Bundle bundle) {
        bundle.putShort(key, (short)random.nextInt());
    }

    private static void putShortArray(String key, Bundle bundle) {
        int length = random.nextInt(50);
        short[] array = new short[length];
        for (int i = 0; i < length; i++) {
            array[i] = (short)random.nextInt();
        }
        bundle.putShortArray(key, array);
    }

    private static void putByte(String key, Bundle bundle) {
        bundle.putByte(key, (byte)random.nextInt());
    }

    private static void putByteArray(String key, Bundle bundle) {
        int length = random.nextInt(50);
        byte[] array = new byte[length];
        random.nextBytes(array);
        bundle.putByteArray(key, array);
    }

    private static void putBoolean(String key, Bundle bundle) {
        bundle.putBoolean(key, random.nextBoolean());
    }

    private static void putBooleanArray(String key, Bundle bundle) {
        int length = random.nextInt(50);
        boolean[] array = new boolean[length];
        for (int i = 0; i < length; i++) {
            array[i] = random.nextBoolean();
        }
        bundle.putBooleanArray(key, array);
    }

    private static void putLong(String key, Bundle bundle) {
        bundle.putLong(key, random.nextLong());
    }

    private static void putLongArray(String key, Bundle bundle) {
        int length = random.nextInt(50);
        long[] array = new long[length];
        for (int i = 0; i < length; i++) {
            array[i] = random.nextLong();
        }
        bundle.putLongArray(key, array);
    }

    private static void putFloat(String key, Bundle bundle) {
        bundle.putFloat(key, random.nextFloat());
    }

    private static void putFloatArray(String key, Bundle bundle) {
        int length = random.nextInt(50);
        float[] array = new float[length];
        for (int i = 0; i < length; i++) {
            array[i] = random.nextFloat();
        }
        bundle.putFloatArray(key, array);
    }

    private static void putDouble(String key, Bundle bundle) {
        bundle.putDouble(key, random.nextDouble());
    }

    private static void putDoubleArray(String key, Bundle bundle) {
        int length = random.nextInt(50);
        double[] array = new double[length];
        for (int i = 0; i < length; i++) {
            array[i] = random.nextDouble();
        }
        bundle.putDoubleArray(key, array);
    }

    private static void putChar(String key, Bundle bundle) {
        bundle.putChar(key, getChar());
    }

    private static void putCharArray(String key, Bundle bundle) {
        bundle.putCharArray(key, getCharArray());
    }

    private static void putString(String key, Bundle bundle) {
        bundle.putString(key, new String(getCharArray()));
    }

    private static void putStringList(String key, Bundle bundle) {
        int length = random.nextInt(50);
        ArrayList<String> stringList = new ArrayList<String>(length);
        while (0 < length--) {
            if (length == 0) {
                stringList.add(null);
            } else {
                stringList.add(new String(getCharArray()));
            }
        }

        bundle.putStringArrayList(key, stringList);
    }

    private static char[] getCharArray() {
        int length = random.nextInt(50);
        char[] array = new char[length];
        for (int i = 0; i < length; i++) {
            array[i] = getChar();
        }

        return array;
    }

    private static char getChar() {
        return (char)random.nextInt(255);
    }

    private void ensureApplicationContext() {
        
        
        long waitedFor = 0;
        try {
            
            while (RuntimeEnvironment.application.getApplicationContext() == null
                    && waitedFor <= 2000) {
                Thread.sleep(50);
                waitedFor += 50;
            }
        }
        catch (InterruptedException e) {
        }
    }

}

<code block>


package com.facebook;

import android.net.Uri;
import android.os.Parcel;

import org.json.JSONObject;
import org.junit.Test;
import org.robolectric.Robolectric;
import org.robolectric.RuntimeEnvironment;

import static org.junit.Assert.*;

public final class ProfileTest extends FacebookTestCase {
    static final String ID = "ID";
    static final String ANOTHER_ID = "ANOTHER_ID";
    static final String FIRST_NAME = "FIRST_NAME";
    static final String MIDDLE_NAME = "MIDDLE_NAME";
    static final String LAST_NAME = "LAST_NAME";
    static final String NAME = "NAME";
    static final Uri LINK_URI = Uri.parse("https:

    public static Profile createDefaultProfile() {
        return new Profile(
                ID,
                FIRST_NAME,
                MIDDLE_NAME,
                LAST_NAME,
                NAME,
                LINK_URI
        );
    }

    static void assertDefaultObjectGetters(Profile profile) {
        assertEquals(ID, profile.getId());
        assertEquals(FIRST_NAME, profile.getFirstName());
        assertEquals(MIDDLE_NAME, profile.getMiddleName());
        assertEquals(LAST_NAME, profile.getLastName());
        assertEquals(NAME, profile.getName());
        assertEquals(LINK_URI, profile.getLinkUri());
    }

    static Profile createMostlyNullsProfile() {
        return new Profile(ANOTHER_ID, null, null, null, null, null);
    }

    static void assertMostlyNullsObjectGetters(Profile profile) {
        assertEquals(ANOTHER_ID, profile.getId());
        assertNull(profile.getFirstName());
        assertNull(profile.getMiddleName());
        assertNull(profile.getLastName());
        assertNull(profile.getName());
        assertNull(profile.getLinkUri());
    }


    @Test
    public void testProfileCtorAndGetters() {
        Profile profile = createDefaultProfile();
        assertDefaultObjectGetters(profile);

        profile = createMostlyNullsProfile();
        assertMostlyNullsObjectGetters(profile);
    }

    @Test
    public void testHashCode() {
        Profile profile1 = createDefaultProfile();
        Profile profile2 = createDefaultProfile();
        assertEquals(profile1.hashCode(), profile2.hashCode());

        Profile profile3 = createMostlyNullsProfile();
        assertNotEquals(profile1.hashCode(), profile3.hashCode());
    }

    @Test
    public void testEquals() {
        Profile profile1 = createDefaultProfile();
        Profile profile2 = createDefaultProfile();
        assertEquals(profile1, profile2);

        Profile profile3 = createMostlyNullsProfile();
        assertNotEquals(profile1, profile3);
    }

    @Test
    public void testJsonSerialization() {
        Profile profile1 = createDefaultProfile();
        JSONObject jsonObject = profile1.toJSONObject();
        Profile profile2 = new Profile(jsonObject);
        assertDefaultObjectGetters(profile2);
        assertEquals(profile1, profile2);

        
        profile1 = createMostlyNullsProfile();
        jsonObject = profile1.toJSONObject();
        profile2 = new Profile(jsonObject);
        assertMostlyNullsObjectGetters(profile2);
        assertEquals(profile1, profile2);
    }

    @Test
    public void testParcelSerialization() {
        Profile profile1 = createDefaultProfile();
        Profile profile2 = TestUtils.parcelAndUnparcel(profile1);

        assertDefaultObjectGetters(profile2);
        assertEquals(profile1, profile2);

        
        profile1 = createMostlyNullsProfile();
        profile2 = TestUtils.parcelAndUnparcel(profile1);
        assertMostlyNullsObjectGetters(profile2);
        assertEquals(profile1, profile2);
    }

    @Test
    public void testGetSetCurrentProfile() {
        FacebookSdk.sdkInitialize(RuntimeEnvironment.application);
        Profile profile1 = createDefaultProfile();
        Profile.setCurrentProfile(profile1);
        assertEquals(ProfileManager.getInstance().getCurrentProfile(), profile1);
        assertEquals(profile1, Profile.getCurrentProfile());

        Profile.setCurrentProfile(null);
        assertNull(ProfileManager.getInstance().getCurrentProfile());
        assertNull(Profile.getCurrentProfile());
    }
}

<code block>


package com.facebook;

import com.facebook.junittests.R;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.junit.Before;
import org.junit.Test;
import org.robolectric.Robolectric;
import org.robolectric.RuntimeEnvironment;

import static org.junit.Assert.*;

public class FacebookGraphRequestErrorTest extends FacebookTestCase {
    public static final String ERROR_SINGLE_RESPONSE =
            "{\n" +
            "  \"error\": {\n" +
            "    \"message\": \"Unknown path components: /unknown\",\n" +
            "    \"type\": \"OAuthException\",\n" +
            "    \"code\": 2500\n" +
            "  }\n" +
            "}";

    public static final String ERROR_BATCH_RESPONSE =
            "[\n" +
            "  {\n" +
            "    \"headers\": [\n" +
            "      {\n" +
            "        \"value\": \"*\",\n" +
            "        \"name\": \"Access-Control-Allow-Origin\"\n" +
            "      },\n" +
            "      {\n" +
            "        \"value\": \"no-store\",\n" +
            "        \"name\": \"Cache-Control\"\n" +
            "      },\n" +
            "      {\n" +
            "        \"value\": \"close\",\n" +
            "        \"name\": \"Connection\"\n" +
            "      },\n" +
            "      {\n" +
            "        \"value\": \"text\\/javascript; charset=UTF-8\",\n" +
            "        \"name\": \"Content-Type\"\n" +
            "      },\n" +
            "      {\n" +
            "        \"value\": \"Sat, 01 Jan 2000 00:00:00 GMT\",\n" +
            "        \"name\": \"Expires\"\n" +
            "      },\n" +
            "      {\n" +
            "        \"value\": \"no-cache\",\n" +
            "        \"name\": \"Pragma\"\n" +
            "      },\n" +
            "      {\n" +
            "        \"value\": \"OAuth \\\"Facebook Platform\\\" \\\"invalid_request\\\" \\\"An active access token must be used to query information about the current user.\\\"\",\n" +
            "        \"name\": \"WWW-Authenticate\"\n" +
            "      }\n" +
            "    ],\n" +
            "    \"body\": \"{\\\"error\\\":{\\\"message\\\":\\\"An active access token must be used to query information about the current user.\\\",\\\"type\\\":\\\"OAuthException\\\",\\\"code\\\":2500}}\",\n" +
            "    \"code\": 400\n" +
            "  },\n" +
            "  {\n" +
            "    \"headers\": [\n" +
            "      {\n" +
            "        \"value\": \"*\",\n" +
            "        \"name\": \"Access-Control-Allow-Origin\"\n" +
            "      },\n" +
            "      {\n" +
            "        \"value\": \"no-store\",\n" +
            "        \"name\": \"Cache-Control\"\n" +
            "      },\n" +
            "      {\n" +
            "        \"value\": \"close\",\n" +
            "        \"name\": \"Connection\"\n" +
            "      },\n" +
            "      {\n" +
            "        \"value\": \"text\\/javascript; charset=UTF-8\",\n" +
            "        \"name\": \"Content-Type\"\n" +
            "      },\n" +
            "      {\n" +
            "        \"value\": \"Sat, 01 Jan 2000 00:00:00 GMT\",\n" +
            "        \"name\": \"Expires\"\n" +
            "      },\n" +
            "      {\n" +
            "        \"value\": \"no-cache\",\n" +
            "        \"name\": \"Pragma\"\n" +
            "      },\n" +
            "      {\n" +
            "        \"value\": \"OAuth \\\"Facebook Platform\\\" \\\"invalid_request\\\" \\\"An active access token must be used to query information about the current user.\\\"\",\n" +
            "        \"name\": \"WWW-Authenticate\"\n" +
            "      }\n" +
            "    ],\n" +
            "    \"body\": \"{\\\"error\\\":{\\\"message\\\":\\\"An active access token must be used to query information about the current user.\\\",\\\"type\\\":\\\"OAuthException\\\",\\\"code\\\":2500}}\",\n" +
            "    \"code\": 400\n" +
            "  }\n" +
            "]";


    public static final String ERROR_SINGLE_RESPONSE_THROTTLE =
            "{\n" +
            "  \"error\": {\n" +
            "    \"message\": \"Application request limit reached\",\n" +
            "    \"code\": 4\n" +
            "  }\n" +
            "}";

    public static final String ERROR_SINGLE_RESPONSE_SERVER =
            "{\n" +
            "  \"error\": {\n" +
            "    \"message\": \"Some Server Error\",\n" +
            "    \"code\": 2\n" +
            "  }\n" +
            "}";

    public static final String ERROR_SINGLE_RESPONSE_PERMISSION =
            "{\n" +
            "  \"error\": {\n" +
            "    \"type\": \"OAuthException\",\n" +
            "    \"message\": \"(#200) Requires extended permission: publish_actions\",\n" +
            "    \"code\": 200\n" +
            "  }\n" +
            "}";

    public static final String ERROR_SINGLE_RESPONSE_WEB_LOGIN =
            "{\n" +
            "  \"error\": {\n" +
            "    \"message\": \"User need to login\",\n" +
            "    \"type\": \"OAuthException\",\n" +
            "    \"code\": 102,\n" +
            "    \"error_subcode\": 459\n" +
            "  }\n" +
            "}";

    public static final String ERROR_SINGLE_RESPONSE_RELOGIN =
            "{\n" +
            "  \"error\": {\n" +
            "    \"message\": \"User need to relogin\",\n" +
            "    \"type\": \"OAuthException\",\n" +
            "    \"code\": 102\n" +
            "  }\n" +
            "}";

    public static final String ERROR_SINGLE_RESPONSE_RELOGIN_DELETED_APP =
            "{\n" +
            "  \"error\": {\n" +
            "    \"message\": \"User need to relogin\",\n" +
            "    \"type\": \"OAuthException\",\n" +
            "    \"code\": 190,\n" +
            "    \"error_subcode\": 458\n" +
            "  }\n" +
            "}";

    @Before
    public void before() throws Exception {
        FacebookSdk.sdkInitialize(RuntimeEnvironment.application);
    }

    @Test
    public void testClientException() {
        final String errorMsg = "some error happened";
        FacebookRequestError error =
                new FacebookRequestError(null, new FacebookException(errorMsg));
        assertEquals(errorMsg, error.getErrorMessage());
        assertEquals(FacebookRequestError.Category.OTHER, error.getCategory());
        assertEquals(FacebookRequestError.INVALID_ERROR_CODE, error.getErrorCode());
        assertEquals(FacebookRequestError.INVALID_HTTP_STATUS_CODE, error.getRequestStatusCode());
    }

    @Test
    public void testSingleRequestWithoutBody() throws JSONException {
        JSONObject withStatusCode = new JSONObject();
        withStatusCode.put("code", 400);
        FacebookRequestError error =
                FacebookRequestError.checkResponseAndCreateError(
                        withStatusCode, withStatusCode, null);
        assertNotNull(error);
        assertEquals(400, error.getRequestStatusCode());
        assertEquals(FacebookRequestError.Category.OTHER, error.getCategory());
    }

    @Test
    public void testSingleErrorWithBody() throws JSONException {
        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE);
        JSONObject withStatusCodeAndBody = new JSONObject();
        withStatusCodeAndBody.put("code", 400);
        withStatusCodeAndBody.put("body", originalResponse);
        FacebookRequestError error =
                FacebookRequestError.checkResponseAndCreateError(
                        withStatusCodeAndBody, originalResponse, null);
        assertNotNull(error);
        assertEquals(400, error.getRequestStatusCode());
        assertEquals("Unknown path components: /unknown", error.getErrorMessage());
        assertEquals("OAuthException", error.getErrorType());
        assertEquals(2500, error.getErrorCode());
        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
        assertEquals(FacebookRequestError.Category.OTHER, error.getCategory());
    }

    @Test
    public void testBatchRequest() throws JSONException {
        JSONArray batchResponse = new JSONArray(ERROR_BATCH_RESPONSE);
        assertEquals(2, batchResponse.length());
        JSONObject firstResponse = (JSONObject) batchResponse.get(0);
        FacebookRequestError error =
                FacebookRequestError.checkResponseAndCreateError(
                        firstResponse, batchResponse, null);
        assertNotNull(error);
        assertEquals(400, error.getRequestStatusCode());
        assertEquals("An active access token must be used to query information about the current user.",
                error.getErrorMessage());
        assertEquals("OAuthException", error.getErrorType());
        assertEquals(2500, error.getErrorCode());
        assertTrue(error.getBatchRequestResult() instanceof  JSONArray);
        assertEquals(FacebookRequestError.Category.OTHER, error.getCategory());
    }

    @Test
    public void testSingleThrottledError() throws JSONException {
        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_THROTTLE);
        JSONObject withStatusCodeAndBody = new JSONObject();
        withStatusCodeAndBody.put("code", 403);
        withStatusCodeAndBody.put("body", originalResponse);
        FacebookRequestError error =
                FacebookRequestError.checkResponseAndCreateError(
                        withStatusCodeAndBody, originalResponse, null);
        assertNotNull(error);
        assertEquals(403, error.getRequestStatusCode());
        assertEquals("Application request limit reached", error.getErrorMessage());
        assertNull(error.getErrorType());
        assertEquals(4, error.getErrorCode());
        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
        assertEquals(FacebookRequestError.Category.TRANSIENT, error.getCategory());
    }

    @Test
    public void testSingleServerError() throws JSONException {
        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_SERVER);
        JSONObject withStatusCodeAndBody = new JSONObject();
        withStatusCodeAndBody.put("code", 500);
        withStatusCodeAndBody.put("body", originalResponse);
        FacebookRequestError error =
                FacebookRequestError.checkResponseAndCreateError(
                        withStatusCodeAndBody, originalResponse, null);
        assertNotNull(error);
        assertEquals(500, error.getRequestStatusCode());
        assertEquals("Some Server Error", error.getErrorMessage());
        assertNull(error.getErrorType());
        assertEquals(2, error.getErrorCode());
        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
        assertEquals(FacebookRequestError.Category.TRANSIENT, error.getCategory());
    }

    @Test
    public void testSinglePermissionError() throws JSONException {
        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_PERMISSION);
        JSONObject withStatusCodeAndBody = new JSONObject();
        withStatusCodeAndBody.put("code", 400);
        withStatusCodeAndBody.put("body", originalResponse);
        FacebookRequestError error =
                FacebookRequestError.checkResponseAndCreateError(
                        withStatusCodeAndBody, originalResponse, null);
        assertNotNull(error);
        assertEquals(400, error.getRequestStatusCode());
        assertEquals(
                "(#200) Requires extended permission: publish_actions",
                error.getErrorMessage());
        assertEquals("OAuthException", error.getErrorType());
        assertEquals(200, error.getErrorCode());
        assertEquals(FacebookRequestError.INVALID_ERROR_CODE, error.getSubErrorCode());
        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
        assertEquals(FacebookRequestError.Category.OTHER, error.getCategory());
    }

    @Test
    public void testSingleWebLoginError() throws JSONException {
        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_WEB_LOGIN);
        JSONObject withStatusCodeAndBody = new JSONObject();
        withStatusCodeAndBody.put("code", 400);
        withStatusCodeAndBody.put("body", originalResponse);
        FacebookRequestError error =
                FacebookRequestError.checkResponseAndCreateError(
                        withStatusCodeAndBody, originalResponse, null);
        assertNotNull(error);
        assertEquals(400, error.getRequestStatusCode());
        assertEquals("User need to login", error.getErrorMessage());
        assertEquals("OAuthException", error.getErrorType());
        assertEquals(102, error.getErrorCode());
        assertEquals(459, error.getSubErrorCode());
        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
        assertEquals(FacebookRequestError.Category.LOGIN_RECOVERABLE, error.getCategory());
    }

    @Test
    public void testSingleReloginError() throws JSONException {
        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_RELOGIN);
        JSONObject withStatusCodeAndBody = new JSONObject();
        withStatusCodeAndBody.put("code", 400);
        withStatusCodeAndBody.put("body", originalResponse);
        FacebookRequestError error =
                FacebookRequestError.checkResponseAndCreateError(
                        withStatusCodeAndBody, originalResponse, null);
        assertNotNull(error);
        assertEquals(400, error.getRequestStatusCode());
        assertEquals("User need to relogin", error.getErrorMessage());
        assertEquals("OAuthException", error.getErrorType());
        assertEquals(102, error.getErrorCode());
        assertEquals(FacebookRequestError.INVALID_ERROR_CODE, error.getSubErrorCode());
        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
        assertEquals(FacebookRequestError.Category.LOGIN_RECOVERABLE, error.getCategory());
    }

    @Test
    public void testSingleReloginDeletedAppError() throws JSONException {
        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_RELOGIN_DELETED_APP);
        JSONObject withStatusCodeAndBody = new JSONObject();
        withStatusCodeAndBody.put("code", 400);
        withStatusCodeAndBody.put("body", originalResponse);
        FacebookRequestError error =
                FacebookRequestError.checkResponseAndCreateError(
                        withStatusCodeAndBody, originalResponse, null);
        assertNotNull(error);
        assertEquals(400, error.getRequestStatusCode());
        assertEquals("User need to relogin", error.getErrorMessage());
        assertEquals("OAuthException", error.getErrorType());
        assertEquals(190, error.getErrorCode());
        assertEquals(458, error.getSubErrorCode());
        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
        assertEquals(FacebookRequestError.Category.LOGIN_RECOVERABLE, error.getCategory());
    }
}

<code block>


package com.facebook;

import com.facebook.internal.FacebookRequestErrorClassification;
import com.facebook.internal.Utility;

import org.json.JSONException;
import org.json.JSONObject;
import org.junit.Before;
import org.junit.Test;
import org.powermock.api.mockito.PowerMockito;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.robolectric.Robolectric;
import org.robolectric.RuntimeEnvironment;

import java.io.IOException;
import java.net.HttpURLConnection;

import static org.junit.Assert.*;
import static org.powermock.api.mockito.PowerMockito.doNothing;
import static org.powermock.api.mockito.PowerMockito.mock;
import static org.powermock.api.mockito.PowerMockito.mockStatic;
import static org.powermock.api.mockito.PowerMockito.when;
import static org.powermock.api.support.membermodification.MemberMatcher.method;
import static org.powermock.api.support.membermodification.MemberModifier.stub;
import static org.powermock.api.support.membermodification.MemberModifier.suppress;

@PrepareForTest( {
        AccessToken.class,
        AccessTokenCache.class,
        FacebookSdk.class,
        GraphRequest.class,
        Utility.class
})
public final class GraphErrorTest extends FacebookPowerMockTestCase {

    @Before
    public void before() throws Exception {
        mockStatic(FacebookSdk.class);
        suppress(method(Utility.class, "clearFacebookCookies"));
        when(FacebookSdk.isInitialized()).thenReturn(true);
        when(FacebookSdk.getApplicationContext()).thenReturn(RuntimeEnvironment.application);
        stub(method(AccessTokenCache.class, "save")).toReturn(null);
    }

    @Test
    public void testAccessTokenResetOnTokenError() throws JSONException, IOException {
        AccessToken accessToken = mock(AccessToken.class);
        AccessToken.setCurrentAccessToken(accessToken);

        JSONObject errorBody = new JSONObject();
        errorBody.put("message", "Invalid OAuth access token.");
        errorBody.put("type", "OAuthException");
        errorBody.put("code", FacebookRequestErrorClassification.EC_INVALID_TOKEN);
        JSONObject error = new JSONObject();
        error.put("error", errorBody);
        String errorString = error.toString();

        HttpURLConnection connection = mock(HttpURLConnection.class);
        when(connection.getResponseCode()).thenReturn(400);

        GraphRequest request = mock(GraphRequest.class);
        when(request.getAccessToken()).thenReturn(accessToken);
        GraphRequestBatch batch = new GraphRequestBatch(request);

        assertNotNull(AccessToken.getCurrentAccessToken());
        GraphResponse.createResponsesFromString(errorString, connection, batch);
        assertNull(AccessToken.getCurrentAccessToken());
    }
}

<code block>


package com.facebook;

import android.content.Intent;
import android.support.v4.content.LocalBroadcastManager;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.robolectric.Robolectric;
import org.robolectric.RuntimeEnvironment;

import java.util.Arrays;
import java.util.Date;
import java.util.List;

import static org.junit.Assert.*;
import static org.powermock.api.mockito.PowerMockito.*;

@PrepareForTest( { FacebookSdk.class })
public class AccessTokenTrackerTest extends FacebookPowerMockTestCase {

    private final List<String> PERMISSIONS = Arrays.asList("walk", "chew gum");
    private final Date EXPIRES = new Date(2025, 5, 3);
    private final Date LAST_REFRESH = new Date(2023, 8, 15);
    private final String APP_ID = "1234";
    private final String USER_ID = "1000";

    private LocalBroadcastManager localBroadcastManager;
    private TestAccessTokenTracker accessTokenTracker = null;

    @Before
    public void before() throws Exception {
        mockStatic(FacebookSdk.class);
        when(FacebookSdk.isInitialized()).thenReturn(true);
        when(FacebookSdk.getApplicationContext()).thenReturn(RuntimeEnvironment.application);

        localBroadcastManager = LocalBroadcastManager.getInstance(RuntimeEnvironment.application);
    }

    @After
    public void after() throws Exception {
        if (accessTokenTracker != null && accessTokenTracker.isTracking()) {
            accessTokenTracker.stopTracking();
        }
    }

    @Test
    public void testRequiresSdkToBeInitialized() {
        try {
            when(FacebookSdk.isInitialized()).thenReturn(false);

            accessTokenTracker = new TestAccessTokenTracker();

            fail();
        } catch (FacebookSdkNotInitializedException exception) {
        }
    }

    @Test
    public void testDefaultsToTracking() {
        accessTokenTracker = new TestAccessTokenTracker();

        assertTrue(accessTokenTracker.isTracking());
    }

    @Test
    public void testCanTurnTrackingOff() {
        accessTokenTracker = new TestAccessTokenTracker();

        accessTokenTracker.stopTracking();

        assertFalse(accessTokenTracker.isTracking());
    }

    @Test
    public void testCanTurnTrackingOn() {
        accessTokenTracker = new TestAccessTokenTracker();

        accessTokenTracker.stopTracking();
        accessTokenTracker.startTracking();

        assertTrue(accessTokenTracker.isTracking());
    }

    @Test
    public void testCallbackCalledOnBroadcastReceived() throws Exception {
        accessTokenTracker = new TestAccessTokenTracker();

        AccessToken oldAccessToken = createAccessToken("I'm old!");
        AccessToken currentAccessToken = createAccessToken("I'm current!");

        sendBroadcast(oldAccessToken, currentAccessToken);


        assertNotNull(accessTokenTracker.currentAccessToken);
        assertEquals(currentAccessToken.getToken(), accessTokenTracker.currentAccessToken.getToken());
        assertNotNull(accessTokenTracker.oldAccessToken);
        assertEquals(oldAccessToken.getToken(), accessTokenTracker.oldAccessToken.getToken());
    }

    private AccessToken createAccessToken(String tokenString) {
        return new AccessToken(
                tokenString,
                APP_ID,
                USER_ID,
                PERMISSIONS,
                null,
                AccessTokenSource.WEB_VIEW,
                EXPIRES,
                LAST_REFRESH);
    }

    private void sendBroadcast(AccessToken oldAccessToken, AccessToken currentAccessToken) {
        Intent intent = new Intent(AccessTokenManager.ACTION_CURRENT_ACCESS_TOKEN_CHANGED);

        intent.putExtra(AccessTokenManager.EXTRA_OLD_ACCESS_TOKEN, oldAccessToken);
        intent.putExtra(AccessTokenManager.EXTRA_NEW_ACCESS_TOKEN, currentAccessToken);

        localBroadcastManager.sendBroadcast(intent);
    }

    class TestAccessTokenTracker extends AccessTokenTracker {

        public AccessToken currentAccessToken;
        public AccessToken oldAccessToken;

        public TestAccessTokenTracker() {
            super();
        }

        @Override
        protected void onCurrentAccessTokenChanged(AccessToken oldAccessToken,
            AccessToken currentAccessToken) {
            this.oldAccessToken = oldAccessToken;
            this.currentAccessToken = currentAccessToken;
        }
    }
}

<code block>


package com.facebook;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.robolectric.Robolectric;
import org.robolectric.RuntimeEnvironment;

import static org.junit.Assert.*;


public class ProgressNoopOutputStreamTest extends FacebookTestCase {
    private ProgressNoopOutputStream stream;

    @Before
    public void before() throws Exception {
        FacebookSdk.sdkInitialize(RuntimeEnvironment.application);
        stream = new ProgressNoopOutputStream(null);
    }

    @After
    public void after() throws Exception {
        stream.close();
    }

    @Test
    public void testSetup() {
        assertEquals(0, stream.getMaxProgress());
        assertTrue(stream.getProgressMap().isEmpty());
    }

    @Test
    public void testWriting() {
        assertEquals(0, stream.getMaxProgress());

        stream.write(0);
        assertEquals(1, stream.getMaxProgress());

        final byte[] buf = new byte[8];

        stream.write(buf);
        assertEquals(9, stream.getMaxProgress());

        stream.write(buf, 2, 2);
        assertEquals(11, stream.getMaxProgress());

        stream.addProgress(16);
        assertEquals(27, stream.getMaxProgress());
    }
}

<code block>


package com.facebook;

import android.content.Intent;
import android.support.v4.content.LocalBroadcastManager;

import org.junit.Test;
import org.robolectric.Robolectric;
import org.robolectric.RuntimeEnvironment;

import static org.junit.Assert.*;

public class ProfileTrackerTest extends FacebookPowerMockTestCase {
    @Test
    public void testStartStopTrackingAndBroadcast() {
        FacebookSdk.sdkInitialize(RuntimeEnvironment.application);
        LocalBroadcastManager localBroadcastManager =
                LocalBroadcastManager.getInstance(RuntimeEnvironment.application);
        TestProfileTracker testProfileTracker = new TestProfileTracker();
        
        assertTrue(testProfileTracker.isTracking());

        testProfileTracker.stopTracking();
        assertFalse(testProfileTracker.isTracking());
        sendBroadcast(localBroadcastManager, null, ProfileTest.createDefaultProfile());
        assertFalse(testProfileTracker.isCallbackCalled);
        testProfileTracker.startTracking();
        assertTrue(testProfileTracker.isTracking());
        Profile profile = ProfileTest.createDefaultProfile();
        sendBroadcast(localBroadcastManager, null, profile);
        assertNull(testProfileTracker.oldProfile);
        assertEquals(profile, testProfileTracker.currentProfile);
        assertTrue(testProfileTracker.isCallbackCalled);

        Profile profile1 = ProfileTest.createMostlyNullsProfile();
        Profile profile2 = ProfileTest.createDefaultProfile();
        sendBroadcast(localBroadcastManager, profile1, profile2);
        ProfileTest.assertMostlyNullsObjectGetters(testProfileTracker.oldProfile);
        ProfileTest.assertDefaultObjectGetters(testProfileTracker.currentProfile);
        assertEquals(profile1, testProfileTracker.oldProfile);
        assertEquals(profile2, testProfileTracker.currentProfile);

        testProfileTracker.stopTracking();
    }

    private static void sendBroadcast(
            LocalBroadcastManager localBroadcastManager,
            Profile oldProfile,
            Profile currentProfile) {
        Intent intent = new Intent(ProfileManager.ACTION_CURRENT_PROFILE_CHANGED);

        intent.putExtra(ProfileManager.EXTRA_OLD_PROFILE, oldProfile);
        intent.putExtra(ProfileManager.EXTRA_NEW_PROFILE, currentProfile);

        localBroadcastManager.sendBroadcast(intent);
    }

    static class TestProfileTracker extends ProfileTracker {
        Profile oldProfile;
        Profile currentProfile;
        boolean isCallbackCalled = false;

        @Override
        protected void onCurrentProfileChanged(Profile oldProfile, Profile currentProfile) {
            this.oldProfile = oldProfile;
            this.currentProfile = currentProfile;
            isCallbackCalled = true;
        }
    }

}

<code block>


package com.facebook;

import android.content.Context;

import org.junit.Before;
import org.junit.Test;
import org.robolectric.Robolectric;
import org.robolectric.RuntimeEnvironment;

import static org.junit.Assert.*;

public final class ProfileCacheTest extends FacebookTestCase {
    @Before
    public void before() throws Exception {
        FacebookSdk.sdkInitialize(RuntimeEnvironment.application);
        RuntimeEnvironment.application.getSharedPreferences(
                ProfileCache.SHARED_PREFERENCES_NAME,
                Context.MODE_PRIVATE)
                .edit().
                clear().
                commit();
    }

    @Test
    public void testEmptyCase() {
        ProfileCache cache = new ProfileCache();
        assertNull(cache.load());
    }

    @Test
    public void testSaveGetAndClear() {
        ProfileCache cache = new ProfileCache();
        Profile profile1 = ProfileTest.createDefaultProfile();
        cache.save(profile1);
        Profile profile2 = cache.load();
        ProfileTest.assertDefaultObjectGetters(profile2);
        assertEquals(profile1, profile2);

        profile1 = ProfileTest.createMostlyNullsProfile();
        cache.save(profile1);
        profile2 = cache.load();
        ProfileTest.assertMostlyNullsObjectGetters(profile2);
        assertEquals(profile1, profile2);

        cache.clear();
        assertNull(cache.load());
    }
}

<code block>


package com.facebook;

import android.os.Bundle;

import com.facebook.internal.Utility;

import org.json.JSONException;
import org.json.JSONObject;
import org.junit.Before;
import org.junit.Test;
import org.powermock.api.mockito.PowerMockito;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.robolectric.Robolectric;
import org.robolectric.RuntimeEnvironment;

import java.io.IOException;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import static org.junit.Assert.*;
import static org.powermock.api.support.membermodification.MemberModifier.stub;

@PrepareForTest( {Utility.class})
public final class AccessTokenTest extends FacebookPowerMockTestCase {

    @Before
    public void before() throws Exception {
        stub(PowerMockito.method(Utility.class, "awaitGetGraphMeRequestWithCache")).toReturn(
                new JSONObject().put("id", "1000"));
    }

    @Test
    public void testNullTokenThrows() {
        try {
            AccessToken token = new AccessToken(
                    null,
                    "1234",
                    "1000",
                    Utility.arrayList("something"),
                    Utility.arrayList("something_else"),
                    AccessTokenSource.CLIENT_TOKEN,
                    new Date(),
                    new Date());
            fail();
        } catch (IllegalArgumentException e) {
        }
    }

    @Test
    public void testEmptyTokenThrows() {
        try {
            AccessToken token = new AccessToken(
                    "",
                    "1234",
                    "1000",
                    Utility.arrayList("something"),
                    Utility.arrayList("something_else"),
                    AccessTokenSource.CLIENT_TOKEN,
                    new Date(),
                    new Date());
            fail();
        } catch (IllegalArgumentException e) {
        }
    }

    @Test
    public void testNullUserIdThrows() {
        try {
            AccessToken token = new AccessToken(
                    "a token",
                    "1234",
                    null,
                    Utility.arrayList("something"),
                    Utility.arrayList("something_else"),
                    AccessTokenSource.CLIENT_TOKEN,
                    new Date(),
                    new Date());
            fail();
        } catch (IllegalArgumentException e) {
        }
    }

    @Test
    public void testEmptyUserIdThrows() {
        try {
            AccessToken token = new AccessToken(
                    "a token",
                    "1234",
                    "",
                    Utility.arrayList("something"),
                    Utility.arrayList("something_else"),
                    AccessTokenSource.CLIENT_TOKEN,
                    new Date(),
                    new Date());
            fail();
        } catch (IllegalArgumentException e) {
        }
    }

    @Test
    public void testCreateFromRefreshFailure() {
        AccessToken accessToken = new AccessToken(
                "a token",
                "1234",
                "1000",
                Utility.arrayList("stream_publish"),
                null,
                AccessTokenSource.WEB_VIEW,
                null,
                null);

        String token = "AnImaginaryTokenValue";

        Bundle bundle = new Bundle();
        bundle.putString("access_token", "AnImaginaryTokenValue");
        bundle.putString("expires_in", "60");

        try {
            AccessToken.createFromRefresh(accessToken, bundle);
            fail("Expected exception");
        } catch (FacebookException ex) {
            assertEquals("Invalid token source: " + AccessTokenSource.WEB_VIEW, ex.getMessage());
        }
    }

    @Test
    public void testCacheRoundtrip() {
        Set<String> permissions = Utility.hashSet("stream_publish", "go_outside_and_play");
        Set<String> declinedPermissions = Utility.hashSet("no you may not", "no soup for you");
        String token = "AnImaginaryTokenValue";
        Date later = TestUtils.nowPlusSeconds(60);
        Date earlier = TestUtils.nowPlusSeconds(-60);
        String applicationId = "1234";

        Bundle bundle = new Bundle();
        LegacyTokenHelper.putToken(bundle, token);
        LegacyTokenHelper.putExpirationDate(bundle, later);
        LegacyTokenHelper.putSource(
                bundle,
                AccessTokenSource.FACEBOOK_APPLICATION_WEB);
        LegacyTokenHelper.putLastRefreshDate(bundle, earlier);
        LegacyTokenHelper.putPermissions(bundle, permissions);
        LegacyTokenHelper.putDeclinedPermissions(bundle, declinedPermissions);
        LegacyTokenHelper.putApplicationId(bundle, applicationId);

        AccessToken accessToken = AccessToken.createFromLegacyCache(bundle);
        TestUtils.assertSamePermissions(permissions, accessToken);
        assertEquals(token, accessToken.getToken());
        assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_WEB, accessToken.getSource());
        assertTrue(!accessToken.isExpired());

        Bundle cache = AccessTokenTestHelper.toLegacyCacheBundle(accessToken);
        TestUtils.assertEqualContentsWithoutOrder(bundle, cache);
    }

    @Test
    public void testFromCacheWithMissingApplicationId() {
        String token = "AnImaginaryTokenValue";
        String applicationId = "1234";

        Bundle bundle = new Bundle();
        LegacyTokenHelper.putToken(bundle, token);
        

        FacebookSdk.sdkInitialize(RuntimeEnvironment.application);
        FacebookSdk.setApplicationId(applicationId);

        AccessToken accessToken = AccessToken.createFromLegacyCache(bundle);

        assertEquals(applicationId, accessToken.getApplicationId());
    }

    @Test
    public void testCachePutGet() {
        Bundle bundle = new Bundle();

        for (String token : new String[] { "", "A completely random token value" }) {
            LegacyTokenHelper.putToken(bundle, token);
            assertEquals(token, LegacyTokenHelper.getToken(bundle));
        }

        for (Date date : new Date[] { new Date(42), new Date() }) {
            LegacyTokenHelper.putExpirationDate(bundle, date);
            assertEquals(date, LegacyTokenHelper.getExpirationDate(bundle));

            LegacyTokenHelper.putLastRefreshDate(bundle, date);
            assertEquals(date, LegacyTokenHelper.getLastRefreshDate(bundle));
        }

        for (long milliseconds : new long[] { 0, -1, System.currentTimeMillis() }) {
            LegacyTokenHelper.putExpirationMilliseconds(bundle, milliseconds);
            assertEquals(
                    milliseconds,
                    LegacyTokenHelper.getExpirationMilliseconds(bundle));

            LegacyTokenHelper.putLastRefreshMilliseconds(bundle, milliseconds);
            assertEquals(
                    milliseconds,
                    LegacyTokenHelper.getLastRefreshMilliseconds(bundle));
        }

        for (AccessTokenSource source : AccessTokenSource.values()) {
            LegacyTokenHelper.putSource(bundle, source);
            assertEquals(source, LegacyTokenHelper.getSource(bundle));
        }

        String userId = "1000";

        List<String> normalList = Arrays.asList("", "Another completely random token value");
        List<String> emptyList = Arrays.asList();
        HashSet<String> normalArrayList = new HashSet<String>(normalList);
        HashSet<String> emptyArrayList = new HashSet<String>();
        @SuppressWarnings("unchecked")
        List<Collection<String>> permissionLists = Arrays
                .asList(normalList, emptyList, normalArrayList, emptyArrayList);
        for (Collection<String> list : permissionLists) {
            LegacyTokenHelper.putPermissions(bundle, list);
            TestUtils.assertSamePermissions(
                    list,
                    LegacyTokenHelper.getPermissions(bundle));
        }
        normalArrayList.add(null);
    }

    @Test
    public void testRoundtripJSONObject() throws JSONException {
        AccessToken accessToken = new AccessToken(
                "a token",
                "1234",
                "1000",
                Arrays.asList("permission_1", "permission_2"),
                Arrays.asList("declined permission_1", "declined permission_2"),
                AccessTokenSource.WEB_VIEW,
                new Date(2015, 3, 3),
                new Date(2015, 1, 1));

        JSONObject jsonObject = accessToken.toJSONObject();

        AccessToken deserializedAccessToken = AccessToken.createFromJSONObject(jsonObject);

        assertEquals(accessToken, deserializedAccessToken);
    }

    @Test
    public void testParceling() throws IOException {
        String token = "a token";
        String appId = "1234";
        String userId = "1000";
        Set<String> permissions = new HashSet<String>(
                Arrays.asList("permission_1", "permission_2"));
        Set<String> declinedPermissions = new HashSet<String>(
                Arrays.asList("permission_3"));
        AccessTokenSource source = AccessTokenSource.WEB_VIEW;
        AccessToken accessToken1 = new AccessToken(
                token,
                appId,
                userId,
                permissions,
                declinedPermissions,
                source,
                null,
                null);

        AccessToken accessToken2 = TestUtils.parcelAndUnparcel(accessToken1);
        assertEquals(accessToken1, accessToken2);
        assertEquals(token, accessToken2.getToken());
        assertEquals(appId, accessToken2.getApplicationId());
        assertEquals(permissions, accessToken2.getPermissions());
        assertEquals(declinedPermissions, accessToken2.getDeclinedPermissions());
        assertEquals(accessToken1.getExpires(), accessToken2.getExpires());
        assertEquals(accessToken1.getLastRefresh(), accessToken2.getLastRefresh());
        assertEquals(accessToken1.getUserId(), accessToken2.getUserId());
    }

    @Test
    public void testPermissionsAreImmutable() {
        Set<String> permissions = Utility.hashSet("go to Jail", "do not pass Go");
        AccessToken accessToken = new AccessToken(
                "some token",
                "1234",
                "1000",
                permissions,
                null,
                AccessTokenSource.FACEBOOK_APPLICATION_WEB,
                new Date(),
                new Date());

        permissions = accessToken.getPermissions();

        try {
            permissions.add("can't touch this");
            fail();
        } catch (UnsupportedOperationException ex) {
        }
    }

    @Test
    public void testCreateFromExistingTokenDefaults() {
        final String token = "A token of my esteem";
        final String applicationId = "1234";
        final String userId = "1000";

        AccessToken accessToken = new AccessToken(
                token,
                applicationId,
                userId,
                null,
                null,
                null,
                null,
                null);

        assertEquals(token, accessToken.getToken());
        assertEquals(new Date(Long.MAX_VALUE), accessToken.getExpires());
        assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_WEB, accessToken.getSource());
        assertEquals(0, accessToken.getPermissions().size());
        assertEquals(applicationId, accessToken.getApplicationId());
        assertEquals(userId, accessToken.getUserId());
        
        long delta = accessToken.getLastRefresh().getTime() - new Date().getTime();
        assertTrue(delta < 1000);
    }

    @Test
    public void testAccessTokenConstructor() {
        final String token = "A token of my esteem";
        final Set<String> permissions = Utility.hashSet("walk", "chew gum");
        final Set<String> declinedPermissions = Utility.hashSet("jump");
        final Date expires = new Date(2025, 5, 3);
        final Date lastRefresh = new Date(2023, 8, 15);
        final AccessTokenSource source = AccessTokenSource.WEB_VIEW;
        final String applicationId = "1234";
        final String userId = "1000";

        AccessToken accessToken = new AccessToken(
                token,
                applicationId,
                userId,
                permissions,
                declinedPermissions,
                source,
                expires,
                lastRefresh);

        assertEquals(token, accessToken.getToken());
        assertEquals(expires, accessToken.getExpires());
        assertEquals(lastRefresh, accessToken.getLastRefresh());
        assertEquals(source, accessToken.getSource());
        assertEquals(permissions, accessToken.getPermissions());
        assertEquals(declinedPermissions, accessToken.getDeclinedPermissions());
        assertEquals(applicationId, accessToken.getApplicationId());
        assertEquals(userId, accessToken.getUserId());
    }
}

<code block>


package com.facebook;

import android.net.Uri;
import android.os.ParcelFileDescriptor;
import android.util.Pair;

import com.facebook.internal.NativeAppCallAttachmentStore;

import org.junit.Before;
import org.junit.Test;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.robolectric.Robolectric;
import org.robolectric.RuntimeEnvironment;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

import static org.junit.Assert.*;
import static org.powermock.api.mockito.PowerMockito.mockStatic;
import static org.powermock.api.mockito.PowerMockito.when;

@PrepareForTest({ NativeAppCallAttachmentStore.class })
public class FacebookContentProviderTest extends FacebookPowerMockTestCase {
    private static final String APP_ID = "12345";
    private static final UUID CALL_ID = UUID.randomUUID();
    private static final String ATTACHMENT_NAME = "attachMe";

    private FacebookContentProvider providerUnderTest;

    @Before
    public void before() throws Exception {
        mockStatic(NativeAppCallAttachmentStore.class);
        providerUnderTest = new FacebookContentProvider();
    }

    @Test
    public void testGetAttachmentUrl() {
        String url = FacebookContentProvider.getAttachmentUrl(APP_ID, CALL_ID, ATTACHMENT_NAME);
        assertEquals("content:
                APP_ID + "/" + CALL_ID + "/" + ATTACHMENT_NAME, url);
    }

    @Test
    public void testOnCreate() throws Exception {
        assertTrue(providerUnderTest.onCreate());
    }

    @Test
    public void testQuery() throws Exception {
        assertNull(providerUnderTest.query(null, null, null, null, null));
    }

    @Test
    public void testGetType() throws Exception {
        assertNull(providerUnderTest.getType(null));
    }

    @Test
    public void testInsert() throws Exception {
        assertNull(providerUnderTest.insert(null, null));
    }

    @Test
    public void testDelete() throws Exception {
        assertEquals(0, providerUnderTest.delete(null, null, null));
    }

    @Test
    public void testUpdate() throws Exception {
        assertEquals(0, providerUnderTest.update(null, null, null, null));
    }

    @SuppressWarnings("unused")
    @Test
    public void testOpenFileWithNullUri() throws Exception {
        try {
            ParcelFileDescriptor pfd = providerUnderTest.openFile(null, "r");
            fail("expected FileNotFoundException");
        } catch (FileNotFoundException e) {
        }
    }

    @SuppressWarnings("unused")
    @Test
    public void testOpenFileWithBadPath() throws Exception {
        try {
            ParcelFileDescriptor pfd = providerUnderTest.openFile(Uri.parse("/"), "r");
            fail("expected FileNotFoundException");
        } catch (FileNotFoundException e) {
        }
    }

    @SuppressWarnings("unused")
    @Test
    public void testOpenFileWithoutCallIdAndAttachment() throws Exception {
        try {
            ParcelFileDescriptor pfd = providerUnderTest.openFile(Uri.parse("/foo"), "r");
            fail("expected FileNotFoundException");
        } catch (FileNotFoundException e) {
        }
    }

    @SuppressWarnings("unused")
    @Test
    public void testOpenFileWithBadCallID() throws Exception {
        try {
            ParcelFileDescriptor pfd = providerUnderTest.openFile(Uri.parse("/foo/bar"), "r");
            fail("expected FileNotFoundException");
        } catch (FileNotFoundException e) {
        }
    }

    @Test
    public void testOpenFileWithUnknownUri() throws Exception {
        try {
            ParcelFileDescriptor pfd = getTestAttachmentParcelFileDescriptor(UUID.randomUUID());
            assertNotNull(pfd);
            pfd.close();

            fail("expected FileNotFoundException");
        } catch (FileNotFoundException e) {
        }
    }

    @Test
    public void testOpenFileWithKnownUri() throws Exception {
        MockAttachmentStore.addAttachment(CALL_ID, ATTACHMENT_NAME);

        ParcelFileDescriptor pfd = getTestAttachmentParcelFileDescriptor(CALL_ID);
        assertNotNull(pfd);
        pfd.close();
    }

    private ParcelFileDescriptor getTestAttachmentParcelFileDescriptor(UUID callId)
            throws Exception {
        when(NativeAppCallAttachmentStore.openAttachment(callId, ATTACHMENT_NAME))
                .thenReturn(MockAttachmentStore.openAttachment(callId, ATTACHMENT_NAME));

        Uri uri = Uri.parse(
                FacebookContentProvider.getAttachmentUrl(APP_ID, callId, ATTACHMENT_NAME));

        return providerUnderTest.openFile(uri, "r");
    }

    static class MockAttachmentStore {
        private static List<Pair<UUID, String>> attachments = new ArrayList<>();
        private static final String DUMMY_FILE_NAME = "dummyfile";

        public static void addAttachment(UUID callId, String attachmentName) {
            attachments.add(new Pair<>(callId, attachmentName));
        }

        public static File openAttachment(UUID callId, String attachmentName)
                throws FileNotFoundException {
            if (attachments.contains(new Pair<>(callId, attachmentName))) {
                File cacheDir = RuntimeEnvironment.application.getCacheDir();
                File dummyFile = new File(cacheDir, DUMMY_FILE_NAME);
                if (!dummyFile.exists()) {
                    try {
                        dummyFile.createNewFile();
                    } catch (IOException e) {
                    }
                }

                return dummyFile;
            }

            throw new FileNotFoundException();
        }
    }
}

<code block>


package com.facebook;

import android.content.Context;
import android.content.SharedPreferences;
import android.os.Bundle;

import com.facebook.internal.Utility;

import org.json.JSONException;
import org.json.JSONObject;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.powermock.api.mockito.PowerMockito;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.robolectric.Robolectric;
import org.robolectric.RuntimeEnvironment;

import java.util.Arrays;
import java.util.Date;
import java.util.List;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.mockito.Matchers.any;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.powermock.api.mockito.PowerMockito.mockStatic;
import static org.powermock.api.mockito.PowerMockito.when;
import static org.powermock.api.mockito.PowerMockito.mock;
import static org.powermock.api.support.membermodification.MemberModifier.stub;

@PrepareForTest( {
        AccessTokenCache.class,
        FacebookSdk.class,
        LegacyTokenHelper.class,
        Utility.class})
public class AccessTokenCacheTest extends FacebookPowerMockTestCase {

    private final String TOKEN_STRING = "A token of my esteem";
    private final String USER_ID = "1000";
    private final List<String> PERMISSIONS = Arrays.asList("walk", "chew gum");
    private final Date EXPIRES = new Date(2025, 5, 3);
    private final Date LAST_REFRESH = new Date(2023, 8, 15);
    private final String APP_ID = "1234";

    private SharedPreferences sharedPreferences;
    @Mock private LegacyTokenHelper cachingStrategy;
    private AccessTokenCache.SharedPreferencesTokenCachingStrategyFactory
            cachingStrategyFactory;

    @Before
    public void before() throws Exception {
        mockStatic(FacebookSdk.class);
        sharedPreferences = RuntimeEnvironment.application.getSharedPreferences(
                AccessTokenManager.SHARED_PREFERENCES_NAME, Context.MODE_PRIVATE);
        sharedPreferences.edit().clear().commit();
        cachingStrategyFactory = mock(
                AccessTokenCache.SharedPreferencesTokenCachingStrategyFactory.class);
        when(cachingStrategyFactory.create()).thenReturn(cachingStrategy);
        stub(PowerMockito.method(Utility.class, "awaitGetGraphMeRequestWithCache")).toReturn(
                new JSONObject().put("id", "1000"));
    }


    @Test
    public void testLoadReturnsFalseIfNoCachedToken() {
        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);

        AccessToken accessToken = cache.load();

        assertNull(accessToken);
        PowerMockito.verifyZeroInteractions(cachingStrategy);
    }

    @Test
    public void testLoadReturnsFalseIfNoCachedOrLegacyToken() {
        when(FacebookSdk.isLegacyTokenUpgradeSupported()).thenReturn(true);

        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);

        AccessToken accessToken = cache.load();

        assertNull(accessToken);
    }

    @Test
    public void testLoadReturnsFalseIfEmptyCachedTokenAndDoesNotCheckLegacy() {

        JSONObject jsonObject = new JSONObject();
        sharedPreferences.edit().putString(AccessTokenCache.CACHED_ACCESS_TOKEN_KEY,
                jsonObject.toString()).commit();

        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);

        AccessToken accessToken = cache.load();

        assertNull(accessToken);
        verifyZeroInteractions(cachingStrategy);
    }

    @Test
    public void testLoadReturnsFalseIfNoCachedTokenAndEmptyLegacyToken() {
        when(FacebookSdk.isLegacyTokenUpgradeSupported()).thenReturn(true);

        when(cachingStrategy.load()).thenReturn(new Bundle());

        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);

        AccessToken accessToken = cache.load();

        assertNull(accessToken);
    }

    @Test
    public void testLoadValidCachedToken() throws JSONException {
        AccessToken accessToken = createAccessToken();
        JSONObject jsonObject = accessToken.toJSONObject();
        sharedPreferences.edit().putString(AccessTokenCache.CACHED_ACCESS_TOKEN_KEY,
                jsonObject.toString()).commit();

        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);

        AccessToken loadedAccessToken = cache.load();

        assertNotNull(loadedAccessToken);
        assertEquals(accessToken, loadedAccessToken);
    }

    @Test
    public void testLoadSetsCurrentTokenIfNoCachedTokenButValidLegacyToken() {
        when(FacebookSdk.isLegacyTokenUpgradeSupported()).thenReturn(true);

        AccessToken accessToken = createAccessToken();
        when(cachingStrategy.load()).thenReturn(
                AccessTokenTestHelper.toLegacyCacheBundle(accessToken));

        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);

        AccessToken loadedAccessToken = cache.load();

        assertNotNull(loadedAccessToken);
        assertEquals(accessToken, loadedAccessToken);
    }

    @Test
    public void testLoadSavesTokenWhenUpgradingFromLegacyToken() throws JSONException {
        when(FacebookSdk.isLegacyTokenUpgradeSupported()).thenReturn(true);

        AccessToken accessToken = createAccessToken();
        when(cachingStrategy.load()).thenReturn(
                AccessTokenTestHelper.toLegacyCacheBundle(accessToken));

        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);
        cache.load();

        assertTrue(sharedPreferences.contains(AccessTokenCache.CACHED_ACCESS_TOKEN_KEY));

        AccessToken savedAccessToken = AccessToken.createFromJSONObject(
                new JSONObject(sharedPreferences.getString(
                        AccessTokenCache.CACHED_ACCESS_TOKEN_KEY, null)));
        assertEquals(accessToken, savedAccessToken);
    }

    @Test
    public void testLoadClearsLegacyCacheWhenUpgradingFromLegacyToken() {
        when(FacebookSdk.isLegacyTokenUpgradeSupported()).thenReturn(true);

        AccessToken accessToken = createAccessToken();
        when(cachingStrategy.load()).thenReturn(
                AccessTokenTestHelper.toLegacyCacheBundle(accessToken));

        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);
        cache.load();

        verify(cachingStrategy, times(1)).clear();
    }

    @Test
    public void testSaveRequiresToken() {
        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);

        try {
            cache.save(null);
            fail();
        } catch (NullPointerException exception) {
        }
    }

    @Test
    public void testSaveWritesToCacheIfToken() throws JSONException {
        AccessToken accessToken = createAccessToken();
        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);

        cache.save(accessToken);

        verify(cachingStrategy, never()).save(any(Bundle.class));
        assertTrue(sharedPreferences.contains(AccessTokenCache.CACHED_ACCESS_TOKEN_KEY));

        AccessToken savedAccessToken = AccessToken.createFromJSONObject(
                new JSONObject(sharedPreferences.getString(
                        AccessTokenCache.CACHED_ACCESS_TOKEN_KEY, null)));
        assertEquals(accessToken, savedAccessToken);
    }

    @Test
    public void testClearCacheClearsCache() {
        AccessToken accessToken = createAccessToken();
        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);

        cache.save(accessToken);

        cache.clear();

        assertFalse(sharedPreferences.contains(AccessTokenCache.CACHED_ACCESS_TOKEN_KEY));
        verify(cachingStrategy, never()).clear();
    }

    @Test
    public void testClearCacheClearsLegacyCache() {
        when(FacebookSdk.isLegacyTokenUpgradeSupported()).thenReturn(true);

        AccessToken accessToken = createAccessToken();
        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);

        cache.save(accessToken);

        cache.clear();

        assertFalse(sharedPreferences.contains(AccessTokenCache.CACHED_ACCESS_TOKEN_KEY));
        verify(cachingStrategy, times(1)).clear();
    }

    private AccessToken createAccessToken() {
        return createAccessToken(TOKEN_STRING, USER_ID);
    }

    private AccessToken createAccessToken(String tokenString, String userId) {
        return new AccessToken(
                tokenString,
                APP_ID,
                userId,
                PERMISSIONS,
                null,
                AccessTokenSource.WEB_VIEW,
                EXPIRES,
                LAST_REFRESH);
    }
}

<code block>


package com.facebook.internal;


import com.facebook.FacebookSdk;
import com.facebook.FacebookTestCase;
import com.facebook.TestUtils;

import org.junit.Before;
import org.junit.Test;
import org.robolectric.Robolectric;
import org.robolectric.RuntimeEnvironment;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Random;

import static org.junit.Assert.*;

public final class FileLruCacheTest extends FacebookTestCase {
    private static final Random random = new Random();

    @Before
    public void before() {
        FacebookSdk.sdkInitialize(RuntimeEnvironment.application);
    }

    @Test
    public void testCacheOutputStream() throws Exception {
        int dataSize = 1024;
        byte[] data = generateBytes(dataSize);
        String key = "a";

        
        FileLruCache cache = new FileLruCache("testCacheOutputStream", limitCacheSize(2*dataSize));

        try {
            put(cache, key, data);
            checkValue(cache, key, data);
        } finally {
            TestUtils.clearAndDeleteLruCacheDirectory(cache);
        }
    }

    @Test
    public void testCacheInputStream() throws Exception {
        int dataSize = 1024;
        byte[] data = generateBytes(dataSize);
        String key = "a";
        InputStream stream = new ByteArrayInputStream(data);

        
        FileLruCache cache = new FileLruCache("testCacheInputStream", limitCacheSize(2*dataSize));
        try {
            TestUtils.clearFileLruCache(cache);

            InputStream wrapped = cache.interceptAndPut(key, stream);
            consumeAndClose(wrapped);
            checkValue(cache, key, data);
        } finally {
            TestUtils.clearAndDeleteLruCacheDirectory(cache);
        }
    }

    @Test
    public void testCacheClear() throws Exception {
        int dataSize = 1024;
        byte[] data = generateBytes(dataSize);
        String key = "a";

        
        FileLruCache cache = new FileLruCache("testCacheClear", limitCacheSize(2*dataSize));
        try {
            TestUtils.clearFileLruCache(cache);

            put(cache, key, data);
            checkValue(cache, key, data);

            TestUtils.clearFileLruCache(cache);
            assertEquals(false, hasValue(cache, key));
            assertEquals(0, cache.sizeInBytesForTest());
        } finally {
            TestUtils.clearAndDeleteLruCacheDirectory(cache);
        }
    }

    @Test
    public void testCacheClearMidBuffer() throws Exception {
        int dataSize = 1024;
        byte[] data = generateBytes(dataSize);
        String key = "a";
        String key2 = "b";

        
        FileLruCache cache = new FileLruCache("testCacheClear", limitCacheSize(2*dataSize));
        try {
            TestUtils.clearFileLruCache(cache);

            put(cache, key, data);
            checkValue(cache, key, data);
            OutputStream stream = cache.openPutStream(key2);
            Thread.sleep(200);

            TestUtils.clearFileLruCache(cache);

            stream.write(data);
            stream.close();

            assertEquals(false, hasValue(cache, key));
            assertEquals(false, hasValue(cache, key2));
            assertEquals(0, cache.sizeInBytesForTest());
        } finally {
            TestUtils.clearAndDeleteLruCacheDirectory(cache);
        }
    }

    @Test
    public void testSizeInBytes() throws Exception {
        int count = 17;
        int dataSize = 53;
        int cacheSize = count * dataSize;
        byte[] data = generateBytes(dataSize);

        
        FileLruCache cache = new FileLruCache("testSizeInBytes", limitCacheSize(2*cacheSize));
        try {
            TestUtils.clearFileLruCache(cache);

            for (int i = 0; i < count; i++) {
                put(cache, i, data);

                
                
                
                
                int totalDataSize = (i + 1) * dataSize;
                assertTrue(cache.sizeInBytesForTest() > totalDataSize);
                assertTrue(cache.sizeInBytesForTest() < 2 * totalDataSize);
            }
            for (int i = 0; i < count; i++) {
                String key = Integer.valueOf(i).toString();
                checkValue(cache, key, data);
            }
        } finally {
            TestUtils.clearAndDeleteLruCacheDirectory(cache);
        }
    }

    @Test
    public void testCacheSizeLimit() throws Exception {
        int count = 64;
        int dataSize = 32;
        int cacheSize = count * dataSize / 2;
        byte[] data = generateBytes(dataSize);

        
        
        FileLruCache cache = new FileLruCache("testCacheSizeLimit", limitCacheSize(cacheSize));
        try {
            TestUtils.clearFileLruCache(cache);

            for (int i = 0; i < count; i++) {
                put(cache, i, data);

                
                
                
                
                int totalDataSize = (i + 1) * dataSize;
                assertTrue(cache.sizeInBytesForTest() > Math.min(totalDataSize, cacheSize / 2));
                assertTrue(cache.sizeInBytesForTest() < Math.min(2 * totalDataSize, cacheSize));
            }

            
            Thread.sleep(200);

            
            boolean hasValueExists = false;
            boolean hasNoValueExists = false;

            for (int i = 0; i < count; i++) {
                String key = Integer.valueOf(i).toString();
                if (hasValue(cache, key)) {
                    hasValueExists = true;
                    checkValue(cache, key, data);
                } else {
                    hasNoValueExists = true;
                }
            }

            assertEquals(true, hasValueExists);
            assertEquals(true, hasNoValueExists);
        } finally {
            TestUtils.clearAndDeleteLruCacheDirectory(cache);
        }
    }

    @Test
    public void testCacheCountLimit() throws Exception {
        int count = 64;
        int dataSize = 32;
        int cacheCount = count / 2;
        byte[] data = generateBytes(dataSize);

        
        FileLruCache cache = new FileLruCache("testCacheCountLimit", limitCacheCount(cacheCount));
        try {
            TestUtils.clearFileLruCache(cache);

            for (int i = 0; i < count; i++) {
                put(cache, i, data);
            }

            
            Thread.sleep(200);

            
            boolean hasValueExists = false;
            boolean hasNoValueExists = false;

            for (int i = 0; i < count; i++) {
                if (hasValue(cache, i)) {
                    hasValueExists = true;
                    checkValue(cache, i, data);
                } else {
                    hasNoValueExists = true;
                }
            }

            assertEquals(true, hasValueExists);
            assertEquals(true, hasNoValueExists);
        } finally {
            TestUtils.clearAndDeleteLruCacheDirectory(cache);
        }
    }

    @Test
    public void testCacheLru() throws IOException, InterruptedException {
        int keepCount = 10;
        int otherCount = 5;
        int dataSize = 64;
        byte[] data = generateBytes(dataSize);

        
        FileLruCache cache = new FileLruCache("testCacheLru", limitCacheCount(keepCount + 1));
        try {
            TestUtils.clearFileLruCache(cache);

            for (int i = 0; i < keepCount; i++) {
                put(cache, i, data);
            }

            
            
            
            Thread.sleep(1000);
            for (int i = 0; i < otherCount; i++) {
                put(cache, keepCount + i, data);
                Thread.sleep(1000);

                
                for (int keepIndex = 0; keepIndex < keepCount; keepIndex++) {
                    checkValue(cache, keepIndex, data);
                }
                Thread.sleep(200);
            }

            
            for (int i = 0; i < (otherCount - 1); i++) {
                String key = Integer.valueOf(keepCount + i).toString();
                assertEquals(false, hasValue(cache, key));
            }
        } finally {
            TestUtils.clearAndDeleteLruCacheDirectory(cache);
        }
    }

    @Test
    public void testConcurrentWritesToSameKey() throws IOException, InterruptedException {
        final int count = 5;
        final int dataSize = 81;
        final int threadCount = 31;
        final int iterationCount = 10;
        final byte[] data = generateBytes(dataSize);

        final FileLruCache cache = new FileLruCache(
                "testConcurrentWritesToSameKey", limitCacheCount(count+1));
        try {
            TestUtils.clearFileLruCache(cache);

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    for (int iterations = 0; iterations < iterationCount; iterations++) {
                        for (int i = 0; i < count; i++) {
                            put(cache, i, data);
                        }
                    }
                }
            };

            
            Thread[] threads = new Thread[threadCount];
            for (int i = 0; i < threads.length; i++) {
                threads[i] = new Thread(run);
            }

            for (Thread thread : threads) {
                thread.start();
            }

            for (Thread thread : threads) {
                thread.join(10 * 1000, 0);
            }

            
            for (int i = 0; i < count; i++) {
                checkValue(cache, i, data);
            }
        } finally {
            TestUtils.clearAndDeleteLruCacheDirectory(cache);
        }
    }

    byte[] generateBytes(int n) {
        byte[] bytes = new byte[n];
        random.nextBytes(bytes);
        return bytes;
    }

    FileLruCache.Limits limitCacheSize(int n) {
        FileLruCache.Limits limits = new FileLruCache.Limits();
        limits.setByteCount(n);
        return limits;
    }

    FileLruCache.Limits limitCacheCount(int n) {
        FileLruCache.Limits limits = new FileLruCache.Limits();
        limits.setFileCount(n);
        return limits;
    }

    void put(FileLruCache cache, int i, byte[] data) {
        put(cache, Integer.valueOf(i).toString(), data);
    }

    void put(FileLruCache cache, String key, byte[] data) {
        try {
            OutputStream stream = cache.openPutStream(key);
            assertNotNull(stream);

            stream.write(data);
            stream.close();
        } catch (IOException e) {
            
            assertNull(e);
        }
    }

    void checkValue(FileLruCache cache, int i, byte[] expected) {
        checkValue(cache, Integer.valueOf(i).toString(), expected);
    }

    void checkValue(FileLruCache cache, String key, byte[] expected) {
        try {
            InputStream stream = cache.get(key);
            assertNotNull(stream);

            checkInputStream(expected, stream);
            stream.close();
        } catch (IOException e) {
            
            assertNull(e);
        }
    }

    boolean hasValue(FileLruCache cache, int i) {
        return hasValue(cache, Integer.valueOf(i).toString());
    }

    boolean hasValue(FileLruCache cache, String key) {
        InputStream stream = null;

        try {
            stream = cache.get(key);
        } catch (IOException e) {
            
            assertNull(e);
        }

        return stream != null;
    }

    void checkInputStream(byte[] expected, InputStream actual) {
        try {
            for (int i = 0; i < expected.length; i++) {
                int b = actual.read();
                assertEquals(((int)expected[i]) & 0xff, b);
            }

            int eof = actual.read();
            assertEquals(-1, eof);
        } catch (IOException e) {
            
            assertNull(e);
        }
    }

    void consumeAndClose(InputStream stream) {
        try {
            byte[] buffer = new byte[1024];
            while (stream.read(buffer) > -1) {
                
            }
            stream.close();
        } catch (IOException e) {
            
            assertNull(e);
        }
    }
}

<code block>


package com.facebook.internal;

import android.content.Intent;

import com.facebook.FacebookPowerMockTestCase;
import com.facebook.FacebookSdk;

import org.junit.Before;
import org.junit.Test;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.powermock.reflect.Whitebox;
import org.robolectric.Robolectric;
import org.robolectric.RuntimeEnvironment;

import java.util.HashMap;

import bolts.Capture;

import static org.junit.Assert.*;

@PrepareForTest({ CallbackManagerImpl.class })
public final class CallbackManagerImplPowerMockTest extends FacebookPowerMockTestCase {

    @Before
    public void before() {
        FacebookSdk.sdkInitialize(RuntimeEnvironment.application);
        
        Whitebox.setInternalState(
                CallbackManagerImpl.class,
                "staticCallbacks",
                new HashMap<Integer, CallbackManagerImpl.Callback>());
    }

    @Test
    public void testStaticRegisterValidations() {
        try {
            CallbackManagerImpl.registerStaticCallback(
                    CallbackManagerImpl.RequestCodeOffset.Login.toRequestCode(), null);
            fail();
        } catch (NullPointerException exception) { }
    }

    @Test
    public void testRegisterValidations() {
        CallbackManagerImpl callbackManagerImpl = new CallbackManagerImpl();
        try {
            callbackManagerImpl.registerCallback(
                    CallbackManagerImpl.RequestCodeOffset.Login.toRequestCode(), null);
            fail();
        } catch (NullPointerException exception) { }
    }

    @Test
    public void testCallbackExecuted() {
        final Capture<Boolean> capture = new Capture(false);

        final CallbackManagerImpl callbackManagerImpl = new CallbackManagerImpl();

        callbackManagerImpl.registerCallback(
                CallbackManagerImpl.RequestCodeOffset.Login.toRequestCode(),
                new CallbackManagerImpl.Callback() {
                    @Override
                    public boolean onActivityResult(int resultCode, Intent data) {
                        capture.set(true);
                        return true;
                    }
                });
        callbackManagerImpl.onActivityResult(
                FacebookSdk.getCallbackRequestCodeOffset(),
                1,
                new Intent());
        assertTrue(capture.get());
    }

    @Test
    public void testRightCallbackExecuted() {
        final Capture<Boolean> capture = new Capture(false);

        final CallbackManagerImpl callbackManagerImpl = new CallbackManagerImpl();

        callbackManagerImpl.registerCallback(
                123,
                new CallbackManagerImpl.Callback() {
                    @Override
                    public boolean onActivityResult(int resultCode, Intent data) {
                        capture.set(true);
                        return true;
                    }
                });
        callbackManagerImpl.registerCallback(
                456,
                new CallbackManagerImpl.Callback() {
                    @Override
                    public boolean onActivityResult(int resultCode, Intent data) {
                        return false;
                    }
                });
        callbackManagerImpl.onActivityResult(
                123,
                1,
                new Intent());
        assertTrue(capture.get());
    }

    @Test
    public void testStaticCallbackExecuted() {
        final Capture<Boolean> capture = new Capture(false);

        final CallbackManagerImpl callbackManagerImpl = new CallbackManagerImpl();

        callbackManagerImpl.registerStaticCallback(
                CallbackManagerImpl.RequestCodeOffset.Login.toRequestCode(),
                new CallbackManagerImpl.Callback() {
                    @Override
                    public boolean onActivityResult(int resultCode, Intent data) {
                        capture.set(true);
                        return true;
                    }
                });
        callbackManagerImpl.onActivityResult(
                FacebookSdk.getCallbackRequestCodeOffset(),
                1,
                new Intent());
        assertTrue(capture.get());
    }

    @Test
    public void testStaticCallbackSkipped() {
        final Capture<Boolean> capture = new Capture(false);
        final Capture<Boolean> captureStatic = new Capture(false);

        final CallbackManagerImpl callbackManagerImpl = new CallbackManagerImpl();

        callbackManagerImpl.registerCallback(
                CallbackManagerImpl.RequestCodeOffset.Login.toRequestCode(),
                new CallbackManagerImpl.Callback() {
                    @Override
                    public boolean onActivityResult(int resultCode, Intent data) {
                        capture.set(true);
                        return true;
                    }
                });
        callbackManagerImpl.registerStaticCallback(
                CallbackManagerImpl.RequestCodeOffset.Login.toRequestCode(),
                new CallbackManagerImpl.Callback() {
                    @Override
                    public boolean onActivityResult(int resultCode, Intent data) {
                        captureStatic.set(true);
                        return true;
                    }
                });
        callbackManagerImpl.onActivityResult(
                FacebookSdk.getCallbackRequestCodeOffset(),
                1,
                new Intent());
        assertTrue(capture.get());
        assertFalse(captureStatic.get());
    }
}

<code block>


package com.facebook.share.internal;

import com.facebook.FacebookTestCase;
import com.facebook.TestUtils;
import com.facebook.share.model.ShareOpenGraphAction;
import com.facebook.share.model.ShareOpenGraphObject;

import org.json.JSONException;
import org.json.JSONObject;
import org.junit.Test;
import org.robolectric.shadows.ShadowApplication;

import java.io.IOException;
import java.util.ArrayList;

public class ShareOpenGraphUtilityTest extends FacebookTestCase {
    private static final String TYPE_KEY = "type";

    @Test
    public void testToJSONObject() throws IOException, JSONException {
        final JSONObject actual = OpenGraphJSONUtility.toJSONObject(this.getAction(), null);
        final JSONObject expected = this.getActionJSONObject();
        TestUtils.assertEquals(expected, actual);
    }

    private static <E> ArrayList<E> createArrayList(E... params) {
        final ArrayList<E> list = new ArrayList<E>();
        for (E item : params) {
            list.add(item);
        }
        return list;
    }

    private ShareOpenGraphAction getAction() {
        return new ShareOpenGraphAction.Builder()
                .putString(TYPE_KEY, "myActionType")
                .putObject(
                        "myObject",
                        new ShareOpenGraphObject.Builder()
                                .putString("myString", "value")
                                .putInt("myInt", 42)
                                .putBoolean("myBoolean", true)
                                .putStringArrayList(
                                        "myStringArray",
                                        createArrayList(
                                                "string1",
                                                "string2",
                                                "string3")
                                )
                                .putObject(
                                        "myObject",
                                        new ShareOpenGraphObject.Builder()
                                                .putDouble("myPi", 3.14)
                                                .build()
                                )
                                .build()).build();
    }

    private JSONObject getActionJSONObject() throws IOException, JSONException {
        return new JSONObject(this.getActionJSONString());
    }

    private String getActionJSONString() throws IOException {
        return TestUtils.getAssetFileStringContents(
                ShadowApplication.getInstance().getApplicationContext(),
                "ShareOpenGraphUtilityTests_actionJSON.json"
        );
    }
}

<code block>


package com.facebook.login;

import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentActivity;

import com.facebook.AccessToken;
import com.facebook.FacebookPowerMockTestCase;
import com.facebook.FacebookSdk;
import com.facebook.TestUtils;

import org.junit.Before;
import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.robolectric.Robolectric;
import org.robolectric.RuntimeEnvironment;

import java.util.Arrays;
import java.util.HashSet;

import static org.junit.Assert.*;
import static org.mockito.Mockito.verify;
import static org.powermock.api.mockito.PowerMockito.mock;
import static org.powermock.api.mockito.PowerMockito.when;

@PrepareForTest({ LoginClient.class })
public class LoginClientTest extends FacebookPowerMockTestCase {

    private static final String ACCESS_TOKEN = "An access token for user 1";
    private static final String USER_ID = "1001";
    private static final String APP_ID = "2002";


    private static final long EXPIRES_IN_DELTA = 3600 * 24 * 60;
    private static final HashSet<String> PERMISSIONS = new HashSet<String>(
        Arrays.asList("go outside", "come back in"));
    private static final String ERROR_MESSAGE = "This is bad!";

    @Mock private Fragment mockFragment;

    @Before
    public void before() throws Exception {
        FragmentActivity activity =
            Robolectric.buildActivity(FragmentActivity.class).create().get();
        when(mockFragment.getActivity()).thenReturn(activity);
    }

    @Test
    public void testReauthorizationWithSameFbidSucceeds() throws Exception {
        FacebookSdk.sdkInitialize(RuntimeEnvironment.application);
        LoginClient.Request request = createRequest(ACCESS_TOKEN);

        AccessToken token = new AccessToken(
                ACCESS_TOKEN,
                APP_ID,
                USER_ID,
                PERMISSIONS,
                null,
                null,
                null,
                null);
        LoginClient.Result result = LoginClient.Result.createTokenResult(request, token);

        LoginClient.OnCompletedListener listener = mock(LoginClient.OnCompletedListener.class);

        LoginClient client = new LoginClient(mockFragment);
        client.setOnCompletedListener(listener);

        client.completeAndValidate(result);

        ArgumentCaptor<LoginClient.Result> resultArgumentCaptor =
            ArgumentCaptor.forClass(LoginClient.Result.class);

        verify(listener).onCompleted(resultArgumentCaptor.capture());

        result = resultArgumentCaptor.getValue();

        assertNotNull(result);
        assertEquals(LoginClient.Result.Code.SUCCESS, result.code);

        AccessToken resultToken = result.token;
        assertNotNull(resultToken);
        assertEquals(ACCESS_TOKEN, resultToken.getToken());

        
        assertEquals(PERMISSIONS, resultToken.getPermissions());
    }

    @Test
    public void testRequestParceling() {
        LoginClient.Request request = createRequest(ACCESS_TOKEN);

        LoginClient.Request unparceledRequest = TestUtils.parcelAndUnparcel(request);

        assertEquals(LoginBehavior.SSO_WITH_FALLBACK, unparceledRequest.getLoginBehavior());
        assertEquals(new HashSet<String>(PERMISSIONS), unparceledRequest.getPermissions());
        assertEquals(DefaultAudience.FRIENDS, unparceledRequest.getDefaultAudience());
        assertEquals("1234", unparceledRequest.getApplicationId());
        assertEquals("5678", unparceledRequest.getAuthId());
        assertFalse(unparceledRequest.isRerequest());
    }

    @Test
    public void testResultParceling() {
        LoginClient.Request request = new LoginClient.Request(
                LoginBehavior.SUPPRESS_SSO,
                null,
                DefaultAudience.EVERYONE,
                null,
                null);
        request.setRerequest(true);
        AccessToken token1 = new AccessToken(
                "Token2",
                "12345",
                "1000",
                null,
                null,
                null,
                null,
                null);
        LoginClient.Result result = new LoginClient.Result(
                request,
                LoginClient.Result.Code.SUCCESS,
                token1,
                "error 1",
                "123"
        );

        LoginClient.Result unparceledResult = TestUtils.parcelAndUnparcel(result);
        LoginClient.Request unparceledRequest = unparceledResult.request;

        assertEquals(LoginBehavior.SUPPRESS_SSO, unparceledRequest.getLoginBehavior());
        assertEquals(new HashSet<String>(), unparceledRequest.getPermissions());
        assertEquals(DefaultAudience.EVERYONE, unparceledRequest.getDefaultAudience());
        assertEquals(null, unparceledRequest.getApplicationId());
        assertEquals(null, unparceledRequest.getAuthId());
        assertTrue(unparceledRequest.isRerequest());

        assertEquals(LoginClient.Result.Code.SUCCESS, unparceledResult.code);
        assertEquals(token1, unparceledResult.token);
        assertEquals("error 1", unparceledResult.errorMessage);
        assertEquals("123", unparceledResult.errorCode);
    }


    protected LoginClient.Request createRequest(String previousAccessTokenString) {
        return new LoginClient.Request(
                LoginBehavior.SSO_WITH_FALLBACK,
                new HashSet<String>(PERMISSIONS),
                DefaultAudience.FRIENDS,
                "1234",
                "5678");
    }

}

<code block>


package com.facebook.login;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;

import com.facebook.AccessToken;
import com.facebook.FacebookSdk;
import com.facebook.TestUtils;

import org.junit.Before;
import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.robolectric.Robolectric;
import org.robolectric.RuntimeEnvironment;

import java.util.Date;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.mockito.Matchers.any;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.powermock.api.mockito.PowerMockito.when;

@PrepareForTest( { LoginClient.class })
public class KatanaProxyLoginMethodHandlerTest extends LoginHandlerTestCase {
    private final static String SIGNED_REQUEST_STR = "ggarbage.eyJhbGdvcml0aG0iOiJITUFDSEEyNTYiLCJ"
            + "jb2RlIjoid2h5bm90IiwiaXNzdWVkX2F0IjoxNDIyNTAyMDkyLCJ1c2VyX2lkIjoiMTIzIn0";

    @Before
    @Override
    public void before() throws Exception {
        super.before();
        FacebookSdk.sdkInitialize(RuntimeEnvironment.application);
    }

    @Test
    public void testProxyAuthHandlesSuccess() {
        Bundle bundle = new Bundle();
        bundle.putLong("expires_in", EXPIRES_IN_DELTA);
        bundle.putString("access_token", ACCESS_TOKEN);
        bundle.putString("signed_request", SIGNED_REQUEST_STR);

        Intent intent = new Intent();
        intent.putExtras(bundle);

        KatanaProxyLoginMethodHandler handler = new KatanaProxyLoginMethodHandler(mockLoginClient);

        LoginClient.Request request = createRequest();
        when(mockLoginClient.getPendingRequest()).thenReturn(request);

        handler.tryAuthorize(request);
        handler.onActivityResult(0, Activity.RESULT_OK, intent);

        ArgumentCaptor<LoginClient.Result> resultArgumentCaptor =
                ArgumentCaptor.forClass(LoginClient.Result.class);
        verify(mockLoginClient, times(1)).completeAndValidate(resultArgumentCaptor.capture());

        LoginClient.Result result = resultArgumentCaptor.getValue();

        assertNotNull(result);
        assertEquals(LoginClient.Result.Code.SUCCESS, result.code);

        AccessToken token = result.token;
        assertNotNull(token);
        assertEquals(ACCESS_TOKEN, token.getToken());
        assertDateDiffersWithinDelta(new Date(), token.getExpires(), EXPIRES_IN_DELTA * 1000, 1000);
        TestUtils.assertSamePermissions(PERMISSIONS, token.getPermissions());
    }

    @Test
    public void testProxyAuthHandlesCancel() {
        Bundle bundle = new Bundle();
        bundle.putString("error", ERROR_MESSAGE);

        Intent intent = new Intent();
        intent.putExtras(bundle);

        KatanaProxyLoginMethodHandler handler = new KatanaProxyLoginMethodHandler(mockLoginClient);

        LoginClient.Request request = createRequest();
        handler.tryAuthorize(request);
        handler.onActivityResult(0, Activity.RESULT_CANCELED, intent);

        ArgumentCaptor<LoginClient.Result> resultArgumentCaptor =
                ArgumentCaptor.forClass(LoginClient.Result.class);
        verify(mockLoginClient, times(1)).completeAndValidate(resultArgumentCaptor.capture());

        LoginClient.Result result = resultArgumentCaptor.getValue();

        assertNotNull(result);
        assertEquals(LoginClient.Result.Code.CANCEL, result.code);

        assertNull(result.token);
        assertNotNull(result.errorMessage);
        assertTrue(result.errorMessage.contains(ERROR_MESSAGE));
    }

    @Test
    public void testProxyAuthHandlesCancelErrorMessage() {
        Bundle bundle = new Bundle();
        bundle.putString("error", "access_denied");

        Intent intent = new Intent();
        intent.putExtras(bundle);

        KatanaProxyLoginMethodHandler handler = new KatanaProxyLoginMethodHandler(mockLoginClient);

        LoginClient.Request request = createRequest();
        handler.tryAuthorize(request);
        handler.onActivityResult(0, Activity.RESULT_CANCELED, intent);

        ArgumentCaptor<LoginClient.Result> resultArgumentCaptor =
                ArgumentCaptor.forClass(LoginClient.Result.class);
        verify(mockLoginClient, times(1)).completeAndValidate(resultArgumentCaptor.capture());

        LoginClient.Result result = resultArgumentCaptor.getValue();

        assertNotNull(result);
        assertEquals(LoginClient.Result.Code.CANCEL, result.code);

        assertNull(result.token);
    }

    @Test
    public void testProxyAuthHandlesDisabled() {
        Bundle bundle = new Bundle();
        bundle.putString("error", "service_disabled");

        Intent intent = new Intent();
        intent.putExtras(bundle);

        KatanaProxyLoginMethodHandler handler = new KatanaProxyLoginMethodHandler(mockLoginClient);

        LoginClient.Request request = createRequest();
        handler.tryAuthorize(request);
        handler.onActivityResult(0, Activity.RESULT_OK, intent);

        verify(mockLoginClient, never()).completeAndValidate(any(LoginClient.Result.class));
        verify(mockLoginClient, times(1)).tryNextHandler();
    }
}

<code block>


package com.facebook.login;

import com.facebook.AccessToken;
import com.facebook.FacebookSdk;
import com.facebook.FacebookTestCase;

import org.junit.Before;
import org.junit.Test;
import org.robolectric.Robolectric;
import org.robolectric.RuntimeEnvironment;

import java.util.HashSet;
import java.util.Set;

import static org.junit.Assert.*;

public class LoginResultTest extends FacebookTestCase {

    private final Set<String> EMAIL_SET = new HashSet<String>(){{ add("email"); }};
    private final Set<String> LIKES_EMAIL_SET = new HashSet<String>(){{
        add("user_likes");
        add("email");
    }};
    private final Set<String> PROFILE_EMAIL_SET = new HashSet<String>(){{
        add("user_profile");
        add("email");
    }};

    @Before
    public void before() throws Exception {
        FacebookSdk.sdkInitialize(RuntimeEnvironment.application);
    }

    @Test
    public void testInitialLogin() {
        LoginClient.Request request = createRequest(EMAIL_SET, false);
        AccessToken accessToken = createAccessToken(PROFILE_EMAIL_SET, new HashSet<String>());
        LoginResult result = LoginManager.computeLoginResult(request, accessToken);
        assertEquals(accessToken, result.getAccessToken());
        assertEquals(PROFILE_EMAIL_SET, result.getRecentlyGrantedPermissions());
        assertEquals(0, result.getRecentlyDeniedPermissions().size());
    }

    @Test
    public void testReAuth() {
        LoginClient.Request request = createRequest(EMAIL_SET, true);
        AccessToken accessToken = createAccessToken(PROFILE_EMAIL_SET, new HashSet<String>());
        LoginResult result = LoginManager.computeLoginResult(request, accessToken);
        assertEquals(accessToken, result.getAccessToken());
        assertEquals(EMAIL_SET, result.getRecentlyGrantedPermissions());
        assertEquals(0, result.getRecentlyDeniedPermissions().size());
    }

    @Test
    public void testDeniedPermissions() {
        LoginClient.Request request = createRequest(LIKES_EMAIL_SET, true);
        AccessToken accessToken = createAccessToken(EMAIL_SET, new HashSet<String>());
        LoginResult result = LoginManager.computeLoginResult(request, accessToken);
        assertEquals(accessToken, result.getAccessToken());
        assertEquals(EMAIL_SET, result.getRecentlyGrantedPermissions());
        assertEquals(
                new HashSet<String>(){{ add("user_likes"); }},
                result.getRecentlyDeniedPermissions());
    }


    private AccessToken createAccessToken(Set<String> permissions,
                                          Set<String> declinedPermissions) {
        return new AccessToken(
            "token",
            "123",
            "234",
            permissions,
            declinedPermissions,
            null,
            null,
            null
        );
    }

    private LoginClient.Request createRequest(Set<String> permissions, boolean isRerequest) {
        LoginClient.Request request = new LoginClient.Request(
                LoginBehavior.SSO_WITH_FALLBACK,
                permissions,
                DefaultAudience.EVERYONE,
                "123",
                "authid"
        );
        request.setRerequest(isRerequest);
        return request;
    }
}

<code block>


package com.facebook.login.widget;

import android.app.Activity;

import com.facebook.BuildConfig;
import com.facebook.FacebookTestCase;
import com.facebook.junittests.MainActivity;
import com.facebook.junittests.R;
import com.facebook.login.DefaultAudience;
import com.facebook.login.LoginManager;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.Robolectric;
import org.robolectric.RobolectricGradleTestRunner;
import org.robolectric.annotation.Config;

import java.util.ArrayList;

import static org.junit.Assert.fail;
import static org.mockito.Matchers.anyCollection;
import static org.mockito.Matchers.isA;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.powermock.api.mockito.PowerMockito.mock;

public class LoginButtonTest extends FacebookTestCase {

    @Test
    public void testLoginButtonWithReadPermissions() throws Exception {
        LoginManager loginManager = mock(LoginManager.class);
        Activity activity = Robolectric.buildActivity(MainActivity.class).create().get();

        LoginButton loginButton = (LoginButton) activity.findViewById(R.id.login_button);
        ArrayList<String> permissions = new ArrayList<>();
        permissions.add("user_location");
        loginButton.setReadPermissions(permissions);
        loginButton.setDefaultAudience(DefaultAudience.EVERYONE);
        loginButton.setLoginManager(loginManager);
        loginButton.performClick();

        verify(loginManager).logInWithReadPermissions(activity, permissions);
        verify(loginManager, never())
                .logInWithPublishPermissions(isA(Activity.class), anyCollection());
        
        verify(loginManager).setDefaultAudience(DefaultAudience.EVERYONE);
    }

    @Test
    public void testLoginButtonWithPublishPermissions() throws Exception {
        LoginManager loginManager = mock(LoginManager.class);
        Activity activity = Robolectric.buildActivity(MainActivity.class).create().get();

        LoginButton loginButton = (LoginButton) activity.findViewById(R.id.login_button);
        ArrayList<String> permissions = new ArrayList<>();
        permissions.add("publish_actions");
        loginButton.setPublishPermissions(permissions);
        loginButton.setLoginManager(loginManager);
        loginButton.performClick();

        verify(loginManager, never())
                .logInWithReadPermissions(isA(Activity.class), anyCollection());
        verify(loginManager).logInWithPublishPermissions(activity, permissions);
    }

    @Test
    public void testCantSetReadThenPublishPermissions() throws Exception {
        Activity activity = Robolectric.buildActivity(MainActivity.class).create().get();

        LoginButton loginButton = (LoginButton) activity.findViewById(R.id.login_button);
        loginButton.setReadPermissions("user_location");
        try {
            loginButton.setPublishPermissions("publish_actions");
        } catch (UnsupportedOperationException e) {
            return;
        }
        fail();
    }

    @Test
    public void testCantSetPublishThenReadPermissions() throws Exception {
        Activity activity = Robolectric.buildActivity(MainActivity.class).create().get();

        LoginButton loginButton = (LoginButton) activity.findViewById(R.id.login_button);
        loginButton.setPublishPermissions("publish_actions");
        try {
            loginButton.setReadPermissions("user_location");
        } catch (UnsupportedOperationException e) {
            return;
        }
        fail();
    }
}

<code block>


package com.facebook.messenger;

import android.app.Activity;
import android.content.ContentResolver;
import android.content.Intent;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.database.MatrixCursor;
import android.net.Uri;
import android.os.Bundle;

import com.facebook.FacebookSdk;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.robolectric.Robolectric;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.RuntimeEnvironment;
import org.robolectric.annotation.Config;

import java.util.Arrays;

import static org.junit.Assert.*;
import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.*;


@RunWith(RobolectricTestRunner.class)
@Config(sdk = 18, manifest = Config.NONE)
public class MessengerUtilsTest {

  private Activity mMockActivity;
  private PackageManager mMockPackageManager;
  private ContentResolver mMockContentResolver;

  @Before
  public void setup() {
    mMockActivity = mock(Activity.class);
    mMockPackageManager = mock(PackageManager.class);
    mMockContentResolver = mock(ContentResolver.class);
    when(mMockActivity.getPackageManager()).thenReturn(mMockPackageManager);
    when(mMockActivity.getContentResolver()).thenReturn(mMockContentResolver);
    FacebookSdk.sdkInitialize(RuntimeEnvironment.application);
    FacebookSdk.setApplicationId("200");
  }

  @Test
  public void testMessengerIsInstalled() throws Exception {
    setupPackageManagerForMessenger(true);
    assertTrue(MessengerUtils.hasMessengerInstalled(mMockActivity));
  }

  @Test
  public void testMessengerNotInstalled() throws Exception {
    setupPackageManagerForMessenger(false);
    assertFalse(MessengerUtils.hasMessengerInstalled(mMockActivity));
  }

  @Test
  public void testShareToMessengerWith20150314Protocol() throws Exception {
    setupPackageManagerForMessenger(true);
    setupContentResolverForProtocolVersions(20150314);


    Uri uri = Uri.parse("file:
    Uri externalUri = Uri.parse("http:
    ShareToMessengerParams params = ShareToMessengerParams
        .newBuilder(uri, "image/jpeg")
        .setMetaData("{}")
        .setExternalUri(externalUri)
        .build();
    MessengerUtils.shareToMessenger(mMockActivity, 1, params);

    
    ArgumentCaptor<Intent> intentArgumentCaptor = ArgumentCaptor.forClass(Intent.class);
    verify(mMockActivity).startActivityForResult(
        intentArgumentCaptor.capture(),
        eq(1));
    Intent intent = intentArgumentCaptor.getValue();
    assertEquals(Intent.ACTION_SEND, intent.getAction());
    assertEquals(Intent.FLAG_GRANT_READ_URI_PERMISSION, intent.getFlags());
    assertEquals("com.facebook.orca", intent.getPackage());
    assertEquals(uri, intent.getParcelableExtra(Intent.EXTRA_STREAM));
    assertEquals("image/jpeg", intent.getType());
    assertEquals("200", intent.getStringExtra("com.facebook.orca.extra.APPLICATION_ID"));
    assertEquals(20150314, intent.getIntExtra("com.facebook.orca.extra.PROTOCOL_VERSION", -1));
    assertEquals("{}", intent.getStringExtra("com.facebook.orca.extra.METADATA"));
    assertEquals(externalUri, intent.getParcelableExtra("com.facebook.orca.extra.EXTERNAL_URI"));
  }

  @Test
  public void testShareToMessengerWithNoProtocol() throws Exception {
    setupPackageManagerForMessenger(true);
    setupContentResolverForProtocolVersions();

    Uri uri = Uri.parse("file:
    Uri externalUri = Uri.parse("http:
    ShareToMessengerParams params = ShareToMessengerParams
        .newBuilder(uri, "image/jpeg")
        .setMetaData("{}")
        .setExternalUri(externalUri)
        .build();
    MessengerUtils.shareToMessenger(mMockActivity, 1, params);


    
    ArgumentCaptor<Intent> intentArgumentCaptor = ArgumentCaptor.forClass(Intent.class);
    verify(mMockActivity).startActivity(intentArgumentCaptor.capture());
    Intent intent = intentArgumentCaptor.getValue();
    assertEquals(Intent.ACTION_VIEW, intent.getAction());
    assertEquals(Uri.parse("market:
  }

  @Test
  public void testGetMessengerThreadParamsForIntentWith20150314Protocol() throws Exception {
    
    Intent intent = new Intent();
    intent.addCategory("com.facebook.orca.category.PLATFORM_THREAD_20150314");
    Bundle extrasBundle = setupIntentWithAppLinkExtrasBundle(intent);
    extrasBundle.putString("com.facebook.orca.extra.THREAD_TOKEN", "thread_token");
    extrasBundle.putString("com.facebook.orca.extra.METADATA", "{}");
    extrasBundle.putString("com.facebook.orca.extra.PARTICIPANTS", "100,400,500");
    extrasBundle.putBoolean("com.facebook.orca.extra.IS_REPLY", true);

    
    MessengerThreadParams params = MessengerUtils.getMessengerThreadParamsForIntent(intent);
    assertEquals(MessengerThreadParams.Origin.REPLY_FLOW, params.origin);
    assertEquals("thread_token", params.threadToken);
    assertEquals("{}", params.metadata);
    assertEquals(Arrays.asList("100", "400", "500"), params.participants);
  }

  @Test
  public void testGetMessengerThreadParamsForIntentWithUnrecognizedIntent() throws Exception {
    
    Intent intent = new Intent();
    assertNull(MessengerUtils.getMessengerThreadParamsForIntent(intent));
  }

  @Test
  public void testFinishShareToMessengerWith20150314Protocol() throws Exception {
    
    Intent originalIntent = new Intent();
    originalIntent.addCategory("com.facebook.orca.category.PLATFORM_THREAD_20150314");
    Bundle extrasBundle = setupIntentWithAppLinkExtrasBundle(originalIntent);
    extrasBundle.putString("com.facebook.orca.extra.THREAD_TOKEN", "thread_token");
    extrasBundle.putString("com.facebook.orca.extra.METADATA", "{}");
    extrasBundle.putString("com.facebook.orca.extra.PARTICIPANTS", "100,400,500");
    when(mMockActivity.getIntent()).thenReturn(originalIntent);

    
    Uri uri = Uri.parse("file:
    Uri externalUri = Uri.parse("http:
    ShareToMessengerParams params = ShareToMessengerParams
        .newBuilder(uri, "image/jpeg")
        .setMetaData("{}")
        .setExternalUri(externalUri)
        .build();

    
    MessengerUtils.finishShareToMessenger(mMockActivity, params);
    ArgumentCaptor<Intent> intentArgumentCaptor = ArgumentCaptor.forClass(Intent.class);
    verify(mMockActivity).setResult(eq(Activity.RESULT_OK), intentArgumentCaptor.capture());
    verify(mMockActivity).finish();

    Intent intent = intentArgumentCaptor.getValue();
    assertNotNull(intent);
    assertEquals(Intent.FLAG_GRANT_READ_URI_PERMISSION, intent.getFlags());
    assertEquals(20150314, intent.getIntExtra("com.facebook.orca.extra.PROTOCOL_VERSION", -1));
    assertEquals("thread_token", intent.getStringExtra("com.facebook.orca.extra.THREAD_TOKEN"));
    assertEquals(uri, intent.getData());
    assertEquals("image/jpeg", intent.getType());
    assertEquals("200", intent.getStringExtra("com.facebook.orca.extra.APPLICATION_ID"));
    assertEquals("{}", intent.getStringExtra("com.facebook.orca.extra.METADATA"));
    assertEquals(externalUri, intent.getParcelableExtra("com.facebook.orca.extra.EXTERNAL_URI"));
  }

  @Test
  public void testFinishShareToMessengerWithUnexpectedIntent() throws Exception {
    
    Intent originalIntent = new Intent();
    when(mMockActivity.getIntent()).thenReturn(originalIntent);

    
    Uri uri = Uri.parse("file:
    Uri externalUri = Uri.parse("http:
    ShareToMessengerParams params = ShareToMessengerParams
        .newBuilder(uri, "image/jpeg")
        .setMetaData("{}")
        .setExternalUri(externalUri)
        .build();

    
    MessengerUtils.finishShareToMessenger(mMockActivity, params);
    verify(mMockActivity).setResult(Activity.RESULT_CANCELED, null);
    verify(mMockActivity).finish();
  }

  
  private void setupPackageManagerForMessenger(boolean isInstalled) throws Exception {
    if (isInstalled) {
      when(mMockPackageManager.getPackageInfo("com.facebook.orca", 0))
          .thenReturn(new PackageInfo());
    } else {
      when(mMockPackageManager.getPackageInfo("com.facebook.orca", 0))
          .thenThrow(new PackageManager.NameNotFoundException());
    }
  }

  
  private void setupContentResolverForProtocolVersions(int... versions) {
    MatrixCursor matrixCursor = new MatrixCursor(new String[]{"version"});
    for (int version : versions) {
      matrixCursor.addRow(new Object[]{version});
    }

    when(mMockContentResolver.query(
        Uri.parse("content:
        new String[]{"version"},
        null,
        null,
        null))
        .thenReturn(matrixCursor);
  }

  
  private Bundle setupIntentWithAppLinkExtrasBundle(Intent intent) {
    Bundle appLinksDataBundle = new Bundle();
    intent.putExtra("al_applink_data", appLinksDataBundle);
    Bundle extrasBundle = new Bundle();
    appLinksDataBundle.putBundle("extras", extrasBundle);
    return extrasBundle;
  }

}

<code block>


package com.facebook.appevents;

import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.support.v4.content.LocalBroadcastManager;

import com.facebook.AccessToken;
import com.facebook.FacebookTestCase;
import com.facebook.WaitForBroadcastReceiver;
import com.facebook.appevents.AppEventsLogger;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.util.HashMap;
import java.util.List;

public class AppEventsLoggerTests extends FacebookTestCase {
    public void testSimpleCall() throws InterruptedException {
        AppEventsLogger.setFlushBehavior(AppEventsLogger.FlushBehavior.EXPLICIT_ONLY);

        AccessToken accessToken1 = getAccessTokenForSharedUser();
        AccessToken accessToken2 = getAccessTokenForSharedUser(SECOND_TEST_USER_TAG);

        AppEventsLogger logger1 = AppEventsLogger.newLogger(getActivity(), accessToken1);
        AppEventsLogger logger2 = AppEventsLogger.newLogger(getActivity(), accessToken2);

        final WaitForBroadcastReceiver waitForBroadcastReceiver = new WaitForBroadcastReceiver();
        waitForBroadcastReceiver.incrementExpectCount();

        final LocalBroadcastManager broadcastManager = LocalBroadcastManager.getInstance(getActivity());

        try {
            
            runOnBlockerThread(new Runnable() {
                @Override
                public void run() {
                    broadcastManager.registerReceiver(waitForBroadcastReceiver,
                            new IntentFilter(AppEventsLogger.ACTION_APP_EVENTS_FLUSHED));
                }
            }, true);

            logger1.logEvent("an_event");
            logger2.logEvent("another_event");

            
            logger1.logEvent("$illegal_event_name");
            Bundle params = new Bundle();
            params.putString("illegal%key", "good_value");
            logger1.logEvent("legal_event_name", params);
            char[] val = {'b', 'a', 'd'};
            params.putCharArray("legal_key", val);
            logger1.logEvent("legal_event",params);

            logger1.flush();

            waitForBroadcastReceiver.waitForExpectedCalls();

            closeBlockerAndAssertSuccess();
        } finally {
            broadcastManager.unregisterReceiver(waitForBroadcastReceiver);
        }
    }
}

<code block>


package com.example.hellofacebook;

import android.os.Bundle;
import android.util.Log;
import com.facebook.FacebookBroadcastReceiver;


public class HelloFacebookBroadcastReceiver extends FacebookBroadcastReceiver {

    @Override
    protected void onSuccessfulAppCall(String appCallId, String action, Bundle extras) {
        
        Log.d("HelloFacebook", String.format("Photo uploaded by call " + appCallId + " succeeded."));
    }

    @Override
    protected void onFailedAppCall(String appCallId, String action, Bundle extras) {
        
        Log.d("HelloFacebook", String.format("Photo uploaded by call " + appCallId + " failed."));
    }
}

<code block>


package com.example.hellofacebook;

import android.app.AlertDialog;
import android.content.Intent;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.location.Location;
import android.net.Uri;
import android.os.Bundle;
import android.support.v4.app.FragmentActivity;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;

import com.facebook.*;
import com.facebook.appevents.AppEventsLogger;
import com.facebook.login.LoginManager;
import com.facebook.login.LoginResult;
import com.facebook.login.widget.ProfilePictureView;
import com.facebook.share.ShareApi;
import com.facebook.share.Sharer;
import com.facebook.share.model.SharePhoto;
import com.facebook.share.model.SharePhotoContent;
import com.facebook.share.model.ShareLinkContent;
import com.facebook.share.widget.ShareDialog;

import java.util.ArrayList;
import java.util.Arrays;

public class HelloFacebookSampleActivity extends FragmentActivity {

    private static final String PERMISSION = "publish_actions";
    private static final Location SEATTLE_LOCATION = new Location("") {
        {
            setLatitude(47.6097);
            setLongitude(-122.3331);
        }
    };

    private final String PENDING_ACTION_BUNDLE_KEY =
            "com.example.hellofacebook:PendingAction";

    private Button postStatusUpdateButton;
    private Button postPhotoButton;
    private ProfilePictureView profilePictureView;
    private TextView greeting;
    private PendingAction pendingAction = PendingAction.NONE;
    private boolean canPresentShareDialog;
    private boolean canPresentShareDialogWithPhotos;
    private CallbackManager callbackManager;
    private ProfileTracker profileTracker;
    private ShareDialog shareDialog;
    private FacebookCallback<Sharer.Result> shareCallback = new FacebookCallback<Sharer.Result>() {
        @Override
        public void onCancel() {
            Log.d("HelloFacebook", "Canceled");
        }

        @Override
        public void onError(FacebookException error) {
            Log.d("HelloFacebook", String.format("Error: %s", error.toString()));
            String title = getString(R.string.error);
            String alertMessage = error.getMessage();
            showResult(title, alertMessage);
        }

        @Override
        public void onSuccess(Sharer.Result result) {
            Log.d("HelloFacebook", "Success!");
            if (result.getPostId() != null) {
                String title = getString(R.string.success);
                String id = result.getPostId();
                String alertMessage = getString(R.string.successfully_posted_post, id);
                showResult(title, alertMessage);
            }
        }

        private void showResult(String title, String alertMessage) {
            new AlertDialog.Builder(HelloFacebookSampleActivity.this)
                    .setTitle(title)
                    .setMessage(alertMessage)
                    .setPositiveButton(R.string.ok, null)
                    .show();
        }
    };

    private enum PendingAction {
        NONE,
        POST_PHOTO,
        POST_STATUS_UPDATE
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        FacebookSdk.sdkInitialize(this.getApplicationContext());

        callbackManager = CallbackManager.Factory.create();

        LoginManager.getInstance().registerCallback(callbackManager,
                new FacebookCallback<LoginResult>() {
                    @Override
                    public void onSuccess(LoginResult loginResult) {
                        handlePendingAction();
                        updateUI();
                    }

                    @Override
                    public void onCancel() {
                        if (pendingAction != PendingAction.NONE) {
                            showAlert();
                            pendingAction = PendingAction.NONE;
                        }
                        updateUI();
                    }

                    @Override
                    public void onError(FacebookException exception) {
                        if (pendingAction != PendingAction.NONE
                                && exception instanceof FacebookAuthorizationException) {
                            showAlert();
                            pendingAction = PendingAction.NONE;
                        }
                        updateUI();
                    }

                    private void showAlert() {
                        new AlertDialog.Builder(HelloFacebookSampleActivity.this)
                                .setTitle(R.string.cancelled)
                                .setMessage(R.string.permission_not_granted)
                                .setPositiveButton(R.string.ok, null)
                                .show();
                    }
                });

        shareDialog = new ShareDialog(this);
        shareDialog.registerCallback(
                callbackManager,
                shareCallback);

        if (savedInstanceState != null) {
            String name = savedInstanceState.getString(PENDING_ACTION_BUNDLE_KEY);
            pendingAction = PendingAction.valueOf(name);
        }

        setContentView(R.layout.main);

        profileTracker = new ProfileTracker() {
            @Override
            protected void onCurrentProfileChanged(Profile oldProfile, Profile currentProfile) {
                updateUI();
                
                
                handlePendingAction();
            }
        };

        profilePictureView = (ProfilePictureView) findViewById(R.id.profilePicture);
        greeting = (TextView) findViewById(R.id.greeting);

        postStatusUpdateButton = (Button) findViewById(R.id.postStatusUpdateButton);
        postStatusUpdateButton.setOnClickListener(new View.OnClickListener() {
            public void onClick(View view) {
                onClickPostStatusUpdate();
            }
        });

        postPhotoButton = (Button) findViewById(R.id.postPhotoButton);
        postPhotoButton.setOnClickListener(new View.OnClickListener() {
            public void onClick(View view) {
                onClickPostPhoto();
            }
        });

        
        canPresentShareDialog = ShareDialog.canShow(
                ShareLinkContent.class);

        
        canPresentShareDialogWithPhotos = ShareDialog.canShow(
                SharePhotoContent.class);
    }

    @Override
    protected void onResume() {
        super.onResume();

        
        
        
        AppEventsLogger.activateApp(this);

        updateUI();
    }

    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);

        outState.putString(PENDING_ACTION_BUNDLE_KEY, pendingAction.name());
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        callbackManager.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    public void onPause() {
        super.onPause();

        
        
        
        AppEventsLogger.deactivateApp(this);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        profileTracker.stopTracking();
    }

    private void updateUI() {
        boolean enableButtons = AccessToken.getCurrentAccessToken() != null;

        postStatusUpdateButton.setEnabled(enableButtons || canPresentShareDialog);
        postPhotoButton.setEnabled(enableButtons || canPresentShareDialogWithPhotos);

        Profile profile = Profile.getCurrentProfile();
        if (enableButtons && profile != null) {
            profilePictureView.setProfileId(profile.getId());
            greeting.setText(getString(R.string.hello_user, profile.getFirstName()));
        } else {
            profilePictureView.setProfileId(null);
            greeting.setText(null);
        }
    }

    private void handlePendingAction() {
        PendingAction previouslyPendingAction = pendingAction;
        
        
        pendingAction = PendingAction.NONE;

        switch (previouslyPendingAction) {
            case NONE:
                break;
            case POST_PHOTO:
                postPhoto();
                break;
            case POST_STATUS_UPDATE:
                postStatusUpdate();
                break;
        }
    }

    private void onClickPostStatusUpdate() {
        performPublish(PendingAction.POST_STATUS_UPDATE, canPresentShareDialog);
    }

    private void postStatusUpdate() {
        Profile profile = Profile.getCurrentProfile();
        ShareLinkContent linkContent = new ShareLinkContent.Builder()
                .setContentTitle("Hello Facebook")
                .setContentDescription(
                        "The 'Hello Facebook' sample  showcases simple Facebook integration")
                .setContentUrl(Uri.parse("http:
                .build();
        if (canPresentShareDialog) {
            shareDialog.show(linkContent);
        } else if (profile != null && hasPublishPermission()) {
            ShareApi.share(linkContent, shareCallback);
        } else {
            pendingAction = PendingAction.POST_STATUS_UPDATE;
        }
    }

    private void onClickPostPhoto() {
        performPublish(PendingAction.POST_PHOTO, canPresentShareDialogWithPhotos);
    }

    private void postPhoto() {
        Bitmap image = BitmapFactory.decodeResource(this.getResources(), R.drawable.icon);
        SharePhoto sharePhoto = new SharePhoto.Builder().setBitmap(image).build();
        ArrayList<SharePhoto> photos = new ArrayList<>();
        photos.add(sharePhoto);

        SharePhotoContent sharePhotoContent =
                new SharePhotoContent.Builder().setPhotos(photos).build();
        if (canPresentShareDialogWithPhotos) {
            shareDialog.show(sharePhotoContent);
        } else if (hasPublishPermission()) {
            ShareApi.share(sharePhotoContent, shareCallback);
        } else {
            pendingAction = PendingAction.POST_PHOTO;
            
            LoginManager.getInstance().logInWithPublishPermissions(
                    this,
                    Arrays.asList(PERMISSION));
        }
    }

    private boolean hasPublishPermission() {
        AccessToken accessToken = AccessToken.getCurrentAccessToken();
        return accessToken != null && accessToken.getPermissions().contains("publish_actions");
    }

    private void performPublish(PendingAction action, boolean allowNoToken) {
        AccessToken accessToken = AccessToken.getCurrentAccessToken();
        if (accessToken != null || allowNoToken) {
            pendingAction = action;
            handlePendingAction();
        }
    }
}

<code block>


package com.example.switchuser;

import android.os.Parcel;
import android.os.Parcelable;

import com.facebook.AccessToken;

class UserInfo implements Parcelable {
    private String userName;
    private AccessToken accessToken;

    public UserInfo(String userName, AccessToken accessToken) {
        this.userName = userName;
        this.accessToken = accessToken;
    }

    public String getUserName() {
        return userName;
    }

    public AccessToken getAccessToken() {
        return accessToken;
    }

    UserInfo(Parcel parcel) {
        this.userName = parcel.readString();
        this.accessToken = parcel.readParcelable(UserInfo.class.getClassLoader());
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeString(userName);
        dest.writeParcelable(accessToken, 0);
    }

    public static final Parcelable.Creator<UserInfo> CREATOR = new Parcelable.Creator() {

        @Override
        public UserInfo createFromParcel(Parcel source) {
            return new UserInfo(source);
        }

        @Override
        public UserInfo[] newArray(int size) {
            return new UserInfo[size];
        }
    };
}

<code block>


package com.example.switchuser;

import android.content.Intent;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.view.*;
import android.widget.TextView;

import com.facebook.AccessToken;
import com.facebook.AccessTokenTracker;
import com.facebook.CallbackManager;
import com.facebook.Profile;
import com.facebook.ProfileTracker;
import com.facebook.login.widget.ProfilePictureView;

public class ProfileFragment extends Fragment {

    public static final String TAG = "ProfileFragment";

    private TextView userNameView;
    private ProfilePictureView profilePictureView;
    private OnOptionsItemSelectedListener onOptionsItemSelectedListener;

    private Profile pendingUpdateForUser;
    private CallbackManager callbackManager;
    private ProfileTracker profileTracker;
    private AccessTokenTracker accessTokenTracker;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setHasOptionsMenu(true);
        callbackManager = CallbackManager.Factory.create();
        profileTracker = new ProfileTracker() {
            @Override
            protected void onCurrentProfileChanged(Profile oldProfile, Profile currentProfile) {
                setProfile(currentProfile);
            }
        };

        accessTokenTracker = new AccessTokenTracker() {
            @Override
            protected void onCurrentAccessTokenChanged(
                    AccessToken oldAccessToken,
                    AccessToken currentAccessToken) {
                
                
                Profile.fetchProfileForCurrentAccessToken();
            }
        };

        
        Profile.fetchProfileForCurrentAccessToken();
        setProfile(Profile.getCurrentProfile());
    }

    @Override
    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
        super.onCreateOptionsMenu(menu, inflater);
        inflater.inflate(R.menu.options_profile, menu);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        boolean handled = false;
        OnOptionsItemSelectedListener listener = onOptionsItemSelectedListener;
        if (listener != null) {
            handled = listener.onOptionsItemSelected(item);
        }

        if (!handled) {
            handled = super.onOptionsItemSelected(item);
        }

        return handled;
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup parent, Bundle savedInstanceState) {
        View v = inflater.inflate(R.layout.fragment_profile, parent, false);

        userNameView = (TextView) v.findViewById(R.id.profileUserName);
        profilePictureView = (ProfilePictureView) v.findViewById(R.id.profilePic);

        if (pendingUpdateForUser != null) {
            setProfile(pendingUpdateForUser);
            pendingUpdateForUser = null;
        }

        return v;
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        callbackManager.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        profileTracker.stopTracking();
        accessTokenTracker.startTracking();
    }

    public void setOnOptionsItemSelectedListener(OnOptionsItemSelectedListener listener) {
        this.onOptionsItemSelectedListener = listener;
    }

    private void setProfile(Profile profile) {
        if (userNameView == null || profilePictureView == null || !isAdded()) {
            
            
            pendingUpdateForUser = profile;
            return;
        }

        if (profile == null) {
            profilePictureView.setProfileId(null);
            userNameView.setText(R.string.greeting_no_user);
        } else {
            profilePictureView.setProfileId(profile.getId());
            userNameView.setText(String.format(getString(R.string.greeting_format),
                    profile.getName()));
        }
    }

    public interface OnOptionsItemSelectedListener {
        boolean onOptionsItemSelected(MenuItem item);
    }
}

<code block>


package com.example.switchuser;

import com.facebook.AccessToken;
import com.facebook.login.LoginBehavior;

public class Slot {
    private UserInfo userInfo;
    private final UserInfoCache userInfoCache;
    private LoginBehavior loginBehavior;

    public Slot(int slotNumber, LoginBehavior loginBehavior) {
        this.loginBehavior = loginBehavior;
        this.userInfoCache = new UserInfoCache(slotNumber);
        this.userInfo = userInfoCache.get();
    }

    public LoginBehavior getLoginBehavior() {
        return loginBehavior;
    }

    public String getUserName() {
        return (userInfo != null) ? userInfo.getUserName() : null;
    }

    public AccessToken getAccessToken() {
        return (userInfo != null) ? userInfo.getAccessToken() : null;
    }

    public String getUserId() {
        return (userInfo != null) ? userInfo.getAccessToken().getUserId() : null;
    }

    public UserInfo getUserInfo() {
        return userInfo;
    }

    public void setUserInfo(UserInfo user) {
        userInfo = user;
        if (user == null) {
            return;
        }

        userInfoCache.put(user);
    }

    public void clear() {
        userInfo = null;
        userInfoCache.clear();
    }
}

<code block>


package com.example.switchuser;

import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.graphics.Color;
import android.os.Bundle;
import android.support.v4.app.ListFragment;
import android.view.*;
import android.widget.*;

import com.facebook.AccessToken;
import com.facebook.CallbackManager;
import com.facebook.FacebookCallback;
import com.facebook.FacebookException;
import com.facebook.FacebookSdk;
import com.facebook.Profile;
import com.facebook.ProfileTracker;
import com.facebook.login.LoginBehavior;
import com.facebook.login.LoginManager;
import com.facebook.login.LoginResult;
import com.facebook.login.widget.ProfilePictureView;

import java.util.ArrayList;
import java.util.Arrays;

public class SettingsFragment extends ListFragment {

    public static final String TAG = "SettingsFragment";
    private static final String CURRENT_SLOT_KEY = "CurrentSlot";

    private SlotManager slotManager;
    private Menu optionsMenu;
    private CallbackManager callbackManager;
    private ProfileTracker profileTracker;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        slotManager = new SlotManager();
        slotManager.restore(
                getActivity(),
                savedInstanceState != null ?
                        savedInstanceState.getInt(CURRENT_SLOT_KEY, SlotManager.NO_SLOT) :
                        SlotManager.NO_SLOT);
        ArrayList<Slot> slotList = new ArrayList<Slot>(
                Arrays.asList(slotManager.getAllSlots()));

        Slot currentSlot = slotManager.getSelectedSlot();
        if (currentSlot != null && currentSlot.getAccessToken() != null) {
            AccessToken.setCurrentAccessToken(currentSlot.getAccessToken());
        }

        setListAdapter(new SlotAdapter(slotList));
        setHasOptionsMenu(true);
        setUpCallbacks();
        currentUserChanged();
    }

    @Override
    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
        super.onCreateOptionsMenu(menu, inflater);
        inflater.inflate(R.menu.context_settings, menu);
        optionsMenu = menu;
        updateMenuVisibility();
    }

    private void setUpCallbacks() {
        callbackManager = CallbackManager.Factory.create();
        LoginManager manager = LoginManager.getInstance();
        manager.registerCallback(callbackManager, new FacebookCallback<LoginResult>() {
            @Override
            public void onSuccess(LoginResult loginResult) {
                Profile.fetchProfileForCurrentAccessToken();
            }

            @Override
            public void onError(FacebookException exception) {
                AccessToken.setCurrentAccessToken(null);
                currentUserChanged();
            }

            @Override
            public void onCancel() {
                AccessToken.setCurrentAccessToken(null);
                currentUserChanged();
            }
        });

        profileTracker = new ProfileTracker() {
            @Override
            protected void onCurrentProfileChanged(Profile oldProfile, Profile currentProfile) {
                Slot currentSlot = slotManager.getSelectedSlot();
                AccessToken currentAccessToken = AccessToken.getCurrentAccessToken();
                if(currentSlot != null && currentAccessToken != null && currentProfile != null) {
                    currentSlot.setUserInfo(
                            new UserInfo(currentProfile.getName(), currentAccessToken));
                    currentUserChanged();
                }
            }
        };
    }

    @Override
    public void onListItemClick(ListView l, View view, int position, long id) {
        slotManager.setCurrentUserSlot(position);
        Slot newSlot = slotManager.getSelectedSlot();
        if (newSlot.getAccessToken() == null) {
            final LoginManager manager = LoginManager.getInstance();
            manager.setLoginBehavior(newSlot.getLoginBehavior());
            manager.logInWithReadPermissions(this, null);
        } else {
            AccessToken.setCurrentAccessToken(newSlot.getAccessToken());
        }
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        Slot slot = slotManager.getSelectedSlot();

        if (item.getItemId() == R.id.menu_item_clear_slot) {
            if (slot.getUserId() != null) {
                
                
                
                slot.clear();
                if (slot == slotManager.getSelectedSlot()) {
                    slotManager.setCurrentUserSlot(SlotManager.NO_SLOT);
                }

                currentUserChanged();
            }
            return true;
        }

        return super.onContextItemSelected(item);
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        outState.putInt(CURRENT_SLOT_KEY, slotManager.getSelectedSlotNumber());
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        callbackManager.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        profileTracker.stopTracking();
    }

    private void updateMenuVisibility() {
        if (optionsMenu != null) {
            if (slotManager.getSelectedSlot() == null) {
                optionsMenu.setGroupVisible(0, false);
            } else if (optionsMenu != null) {
                optionsMenu.setGroupVisible(0, true);
            }
        }
    }

    private void currentUserChanged() {
        if (slotManager == null) {
            
            return;
        }

        updateMenuVisibility();
        updateListView();
        Slot currentSlot = slotManager.getSelectedSlot();
        AccessToken currentToken = (currentSlot != null) ? currentSlot.getAccessToken() : null;
        AccessToken.setCurrentAccessToken(currentToken);
    }

    private void updateListView() {
        SlotAdapter adapter = (SlotAdapter) getListAdapter();

        
        if (adapter != null) {
            adapter.notifyDataSetChanged();
        }
    }

    private class SlotManager {
        static final int NO_SLOT = -1;

        private final static int MAX_SLOTS = 4;

        private static final String SETTINGS_CURRENT_SLOT_KEY = "CurrentSlot";
        private static final String SETTINGS_NAME = "UserManagerSettings";

        private SharedPreferences settings;
        private int selectedSlotNumber = NO_SLOT;

        private Slot[] slots;

        public void restore(Context context, int oldSelectedSlot) {
            if (context == null) {
                throw new IllegalArgumentException("context cannot be null");
            }

            slots = new Slot[MAX_SLOTS];
            for (int i = 0; i < MAX_SLOTS; i++) {
                LoginBehavior loginBehavior = (i == 0) ?
                        LoginBehavior.SSO_WITH_FALLBACK :
                        LoginBehavior.SUPPRESS_SSO;
                slots[i] = new Slot(i, loginBehavior);
            }

            
            settings = FacebookSdk.getApplicationContext().getSharedPreferences(
                    SETTINGS_NAME, Context.MODE_PRIVATE);
            int savedSlotNumber = settings.getInt(SETTINGS_CURRENT_SLOT_KEY, NO_SLOT);
            if (savedSlotNumber != NO_SLOT && savedSlotNumber != oldSelectedSlot) {
                
                setCurrentUserSlot(savedSlotNumber);
            } else {
                
                
                
                setCurrentUserSlot(savedSlotNumber);
            }
        }

        public Slot getSelectedSlot() {
            if (selectedSlotNumber == NO_SLOT) {
                return null;
            } else {
                return getSlot(selectedSlotNumber);
            }
        }

        public int getSelectedSlotNumber() {
            return selectedSlotNumber;
        }

        public void setCurrentUserSlot(int slot) {
            if (slot != selectedSlotNumber) {
                
                settings.edit().putInt(SETTINGS_CURRENT_SLOT_KEY, slot).apply();
                selectedSlotNumber = slot;
                currentUserChanged();
            }
        }

        private Slot[] getAllSlots() {
            return slots;
        }

        private Slot getSlot(int slot) {
            validateSlot(slot);
            return slots[slot];
        }

        private void validateSlot(int slot) {
            if (slot <= NO_SLOT || slot >= MAX_SLOTS) {
                throw new IllegalArgumentException(
                        String.format("Choose a slot between 0 and %d inclusively", MAX_SLOTS - 1));
            }
        }
    }

    private class SlotAdapter extends ArrayAdapter<Slot> {

        public SlotAdapter(ArrayList<Slot> slots) {
            super(getActivity(), android.R.layout.simple_list_item_1, slots);
        }

        @Override
        public View getView(final int position, View convertView, ViewGroup parent) {
            if (null == convertView) {
                convertView = getActivity().getLayoutInflater()
                        .inflate(R.layout.list_item_user, parent, false);
            }

            Slot slot = getItem(position);
            if (slot.getLoginBehavior() != LoginBehavior.SUPPRESS_SSO) {
                convertView.setBackgroundColor(Color.argb(50, 255, 255, 255));
            }

            String userName = slot.getUserName();
            if (userName == null) {
                userName = getString(R.string.empty_slot);
            }

            String userId = slot.getUserId();
            ProfilePictureView profilePic = (ProfilePictureView) convertView.findViewById(
                    R.id.slotPic);
            if (userId != null) {
                profilePic.setProfileId(userId);
            } else {
                profilePic.setProfileId(null);
            }

            TextView userNameTextView = (TextView) convertView.findViewById(
                    R.id.slotUserName);
            userNameTextView.setText(userName);

            final CheckBox currentUserCheckBox = (CheckBox) convertView.findViewById(
                    R.id.currentUserIndicator);
            currentUserCheckBox.setChecked(
                    slotManager.getSelectedSlot() == slot
                            && slot.getUserInfo() != null);
            currentUserCheckBox.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    if (currentUserCheckBox.isChecked()) {
                        slotManager.setCurrentUserSlot(position);
                    } else {
                        slotManager.setCurrentUserSlot(SlotManager.NO_SLOT);
                    }
                    SlotAdapter adapter = (SlotAdapter) getListAdapter();
                    adapter.notifyDataSetChanged();
                }
            });

            currentUserCheckBox.setEnabled(slot.getAccessToken() != null);

            return convertView;
        }

    }
}

<code block>


package com.example.switchuser;

import android.os.Bundle;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentTransaction;
import android.support.v7.app.ActionBarActivity;
import android.view.MenuItem;

import com.facebook.*;
import com.facebook.appevents.AppEventsLogger;

public class MainActivity extends ActionBarActivity {

    private static final String SHOWING_SETTINGS_KEY = "Showing settings";

    private ProfileFragment profileFragment;
    private SettingsFragment settingsFragment;
    private boolean isShowingSettings;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        FacebookSdk.sdkInitialize(getApplicationContext());

        setContentView(R.layout.main);

        restoreFragments(savedInstanceState);

        if (savedInstanceState != null) {
            if (savedInstanceState.getBoolean(SHOWING_SETTINGS_KEY)) {
                showSettings();
            } else {
                showProfile();
            }
        } else {
            showProfile();
        }
    }

    @Override
    public void onBackPressed() {
        if (isShowingSettings()) {
            
            showProfile();
        } else {
            
            super.onBackPressed();
        }
    }


    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        outState.putBoolean(SHOWING_SETTINGS_KEY, isShowingSettings());

        FragmentManager manager = getSupportFragmentManager();
        manager.putFragment(outState, SettingsFragment.TAG, settingsFragment);
        manager.putFragment(outState, ProfileFragment.TAG, profileFragment);
    }

    @Override
    protected void onResume() {
        super.onResume();

        profileFragment.setOnOptionsItemSelectedListener(new ProfileFragment.OnOptionsItemSelectedListener() {
            @Override
            public boolean onOptionsItemSelected(MenuItem item) {
                return handleOptionsItemSelected(item);
            }
        });

        
        
        
        AppEventsLogger.activateApp(this);
    }

    @Override
    protected void onPause() {
        super.onPause();

        profileFragment.setOnOptionsItemSelectedListener(null);

        
        
        
        AppEventsLogger.deactivateApp(this);
    }

    private void restoreFragments(Bundle savedInstanceState) {
        FragmentManager manager = getSupportFragmentManager();
        FragmentTransaction transaction = manager.beginTransaction();

        if (savedInstanceState != null) {
            profileFragment = (ProfileFragment) manager.getFragment(savedInstanceState,
                    ProfileFragment.TAG);
            settingsFragment = (SettingsFragment) manager.getFragment(savedInstanceState,
                    SettingsFragment.TAG);
        }

        if (profileFragment == null) {
            profileFragment = new ProfileFragment();
            transaction.add(R.id.fragmentContainer, profileFragment, ProfileFragment.TAG);
        }

        if (settingsFragment == null) {
            settingsFragment = new SettingsFragment();
            transaction.add(R.id.fragmentContainer, settingsFragment, SettingsFragment.TAG);
        }

        transaction.commit();
    }

    private void showSettings() {
        isShowingSettings = true;

        FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
        transaction.hide(profileFragment)
                .show(settingsFragment)
                .commit();
    }

    private boolean isShowingSettings() {
        return isShowingSettings;
    }

    private void showProfile() {
        isShowingSettings = false;

        FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
        transaction.hide(settingsFragment)
                .show(profileFragment)
                .commit();
    }

    private boolean handleOptionsItemSelected(MenuItem item) {
        if (item.getItemId() == R.id.menu_item_switch) {
            showSettings();
            return true;
        } else {
            return false;
        }
    }
}

<code block>


package com.example.switchuser;

import android.content.Context;
import android.content.SharedPreferences;
import android.os.Parcel;
import android.util.Base64;

import com.facebook.FacebookSdk;

class UserInfoCache {
    private static final String USER_INFO_CACHE_FORMAT = "userInfo%d";
    private final String userInfoCacheKey;
    private final int slot;

    public UserInfoCache(int slotNumber) {
        userInfoCacheKey = String.format(USER_INFO_CACHE_FORMAT, slotNumber);
        slot = slotNumber;
    }
    public UserInfo get() {
        SharedPreferences prefs = getSharedPrefs();
        String encodedToken = prefs.getString(userInfoCacheKey, null);
        if(encodedToken == null) {
            return null;
        }
        return decodeUserInfo(encodedToken);
    }

    public void put(UserInfo userInfo) {
        SharedPreferences.Editor editor = getSharedPrefs().edit();
        String encodedToken = encodeUserInfo(userInfo);
        editor.putString(userInfoCacheKey, encodedToken);
        editor.apply();
    }

    public void clear() {
        SharedPreferences.Editor editor = getSharedPrefs().edit();
        editor.remove(userInfoCacheKey);
        editor.apply();
    }

    private static SharedPreferences getSharedPrefs() {
        return FacebookSdk.getApplicationContext().getSharedPreferences(
                "accessTokens",
                Context.MODE_PRIVATE);
    }

    private static UserInfo decodeUserInfo(String base64EncodedToken) {
        byte[] data = Base64.decode(base64EncodedToken, Base64.DEFAULT);
        Parcel parcel = Parcel.obtain();
        parcel.unmarshall(data, 0, data.length);
        parcel.setDataPosition(0);
        UserInfo userInfo = (UserInfo) parcel.readValue(UserInfo.class.getClassLoader());
        parcel.recycle();
        return userInfo;
    }

    private static String encodeUserInfo(UserInfo userInfo) {
        Parcel parcel = Parcel.obtain();
        parcel.writeValue(userInfo);
        byte[] data = parcel.marshall();
        parcel.recycle();
        return Base64.encodeToString(data, Base64.DEFAULT);
    }
}

<code block>


package com.example.scrumptious;

import android.content.Intent;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;
import android.widget.Toast;

import com.facebook.CallbackManager;
import com.facebook.FacebookCallback;
import com.facebook.FacebookException;
import com.facebook.login.LoginResult;
import com.facebook.login.widget.LoginButton;

public class SplashFragment extends Fragment {

    private LoginButton loginButton;
    private TextView skipLoginButton;
    private SkipLoginCallback skipLoginCallback;
    private CallbackManager callbackManager;

    public interface SkipLoginCallback {
        void onSkipLoginPressed();
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.splash, container, false);

        callbackManager = CallbackManager.Factory.create();
        loginButton = (LoginButton) view.findViewById(R.id.login_button);
        loginButton.setReadPermissions("user_friends");
        loginButton.setFragment(this);
        loginButton.registerCallback(callbackManager, new FacebookCallback<LoginResult>() {
            @Override
            public void onSuccess(LoginResult loginResult) {
                Toast.makeText(getActivity(), "Login successful", Toast.LENGTH_SHORT).show();
            }

            @Override
            public void onCancel() {
                Toast.makeText(getActivity(), "Login canceled", Toast.LENGTH_SHORT).show();
            }

            @Override
            public void onError(FacebookException exception) {
                Toast.makeText(getActivity(), "Login error", Toast.LENGTH_SHORT).show();
            }
        });

        skipLoginButton = (TextView) view.findViewById(R.id.skip_login_button);
        skipLoginButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                if (skipLoginCallback != null) {
                    skipLoginCallback.onSkipLoginPressed();
                }
            }
        });

        return view;
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        callbackManager.onActivityResult(requestCode, resultCode, data);
    }

    public void setSkipLoginCallback(SkipLoginCallback callback) {
        skipLoginCallback = callback;
    }

}


<code block>


package com.example.scrumptious;

import android.app.Application;

import com.facebook.FacebookSdk;

import org.json.JSONObject;

import java.util.List;


public class ScrumptiousApplication extends Application {

    @Override
    public void onCreate() {
        super.onCreate();
        FacebookSdk.sdkInitialize(getApplicationContext());
    }

    private List<JSONObject> selectedUsers;
    private JSONObject selectedPlace;

    public List<JSONObject> getSelectedUsers() {
        return selectedUsers;
    }

    public void setSelectedUsers(List<JSONObject> users) {
        selectedUsers = users;
    }

    public JSONObject getSelectedPlace() {
        return selectedPlace;
    }

    public void setSelectedPlace(JSONObject place) {
        this.selectedPlace = place;
    }
}

<code block>


package com.example.scrumptious;

import android.content.Context;
import android.util.AttributeSet;
import android.view.View;
import android.widget.ListAdapter;
import android.widget.ListView;


public class FullListView extends ListView {

    public FullListView(Context context) {
        super(context);
    }

    public FullListView(Context context, AttributeSet attributeSet) {
        super(context, attributeSet);
    }

    public FullListView(Context context, AttributeSet attributeSet, int defStyle) {
        super(context, attributeSet, defStyle);
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        int width = getMeasuredWidth();
        int height = 0;
        ListAdapter adapter = getAdapter();
        int count = adapter != null ? adapter.getCount() : 0;
        for (int i = 0; i < count; i++) {
            View childView = adapter.getView(i, null, this);
            childView.measure(MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED),
                    MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED));
            height += childView.getMeasuredHeight();
        }
        height += getDividerHeight() * (count-1);
        setMeasuredDimension(width, height);
    }
}

<code block>


package com.example.scrumptious;

import android.content.Intent;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.view.View;
import android.widget.BaseAdapter;

import com.facebook.share.model.ShareOpenGraphAction;


public abstract class BaseListElement {

    private Drawable icon;
    private String text1;
    private String text2;
    private BaseAdapter adapter;
    private int requestCode;

    
    public BaseListElement(Drawable icon, String text1, String text2, int requestCode) {
        this.icon = icon;
        this.text1 = text1;
        this.text2 = text2;
        this.requestCode = requestCode;
    }

    
    public void setAdapter(BaseAdapter adapter) {
        this.adapter = adapter;
    }

    
    public Drawable getIcon() {
        return icon;
    }

    
    public String getText1() {
        return text1;
    }

    
    public String getText2() {
        return text2;
    }

    
    public int getRequestCode() {
        return requestCode;
    }

    
    public void setText1(String text1) {
        this.text1 = text1;
        if (adapter != null) {
            adapter.notifyDataSetChanged();
        }
    }

    
    public void setText2(String text2) {
        this.text2 = text2;
        if (adapter != null) {
            adapter.notifyDataSetChanged();
        }
    }

    
    protected abstract View.OnClickListener getOnClickListener();

    
    protected abstract void populateOpenGraphAction(ShareOpenGraphAction.Builder actionBuilder);

    
    protected void onActivityResult(Intent data) {}

    
    protected void onSaveInstanceState(Bundle bundle) {}

    
    protected boolean restoreState(Bundle savedState) {
        return false;
    }

    
    protected void notifyDataChanged() {
        adapter.notifyDataSetChanged();
    }

}

<code block>


package com.example.scrumptious;

import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.location.Criteria;
import android.location.Location;
import android.location.LocationListener;
import android.location.LocationManager;
import android.net.Uri;
import android.os.Bundle;
import android.os.Looper;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentActivity;
import android.support.v4.app.FragmentManager;
import android.widget.Toast;
import com.facebook.FacebookException;
import com.example.scrumptious.picker.FriendPickerFragment;
import com.example.scrumptious.picker.PickerFragment;
import com.example.scrumptious.picker.PlacePickerFragment;


public class PickerActivity extends FragmentActivity {
    public static final Uri FRIEND_PICKER = Uri.parse("picker:
    public static final Uri PLACE_PICKER = Uri.parse("picker:

    private static final int SEARCH_RADIUS_METERS = 1000;
    private static final int SEARCH_RESULT_LIMIT = 50;
    private static final String SEARCH_TEXT = "Restaurant";
    private static final int LOCATION_CHANGE_THRESHOLD = 50; 

    private FriendPickerFragment friendPickerFragment;
    private PlacePickerFragment placePickerFragment;
    private LocationListener locationListener;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pickers);

        Bundle args = getIntent().getExtras();
        FragmentManager manager = getSupportFragmentManager();
        Fragment fragmentToShow = null;
        Uri intentUri = getIntent().getData();

        if (FRIEND_PICKER.equals(intentUri)) {
            if (savedInstanceState == null) {
                friendPickerFragment = new FriendPickerFragment();
                friendPickerFragment.setSettingsFromBundle(args);
                friendPickerFragment.setFriendPickerType(FriendPickerFragment.FriendPickerType.TAGGABLE_FRIENDS);
            } else {
                friendPickerFragment = (FriendPickerFragment) manager.findFragmentById(R.id.picker_fragment);;
            }

            friendPickerFragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
                @Override
                public void onError(PickerFragment fragment, FacebookException error) {
                    PickerActivity.this.onError(error);
                }
            });
            friendPickerFragment.setOnDoneButtonClickedListener(new PickerFragment.OnDoneButtonClickedListener() {
                @Override
                public void onDoneButtonClicked(PickerFragment fragment) {
                    finishActivity();
                }
            });
            fragmentToShow = friendPickerFragment;

        } else if (PLACE_PICKER.equals(intentUri)) {
            if (savedInstanceState == null) {
                placePickerFragment = new PlacePickerFragment();
                placePickerFragment.setSettingsFromBundle(args);
            } else {
                placePickerFragment = (PlacePickerFragment) manager.findFragmentById(R.id.picker_fragment);
            }
            placePickerFragment.setOnSelectionChangedListener(new PickerFragment.OnSelectionChangedListener() {
                @Override
                public void onSelectionChanged(PickerFragment fragment) {
                    finishActivity(); 
                }
            });
            placePickerFragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
                @Override
                public void onError(PickerFragment fragment, FacebookException error) {
                    PickerActivity.this.onError(error);
                }
            });
            placePickerFragment.setOnDoneButtonClickedListener(new PickerFragment.OnDoneButtonClickedListener() {
                @Override
                public void onDoneButtonClicked(PickerFragment fragment) {
                    finishActivity();
                }
            });
            fragmentToShow = placePickerFragment;
        } else {
            
            setResult(RESULT_CANCELED);
            finish();
            return;
        }

        manager.beginTransaction().replace(R.id.picker_fragment, fragmentToShow).commit();
    }

    @Override
    protected void onStart() {
        super.onStart();
        if (FRIEND_PICKER.equals(getIntent().getData())) {
            try {
                friendPickerFragment.loadData(false);
            } catch (Exception ex) {
                onError(ex);
            }
        } else if (PLACE_PICKER.equals(getIntent().getData())) {
            try {
                Location location = null;
                Criteria criteria = new Criteria();
                LocationManager locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);
                String bestProvider = locationManager.getBestProvider(criteria, false);
                if (bestProvider != null) {
                    location = locationManager.getLastKnownLocation(bestProvider);
                    if (locationManager.isProviderEnabled(bestProvider) && locationListener == null) {
                        locationListener = new LocationListener() {
                            @Override
                            public void onLocationChanged(Location location) {
                                boolean updateLocation = true;
                                Location prevLocation = placePickerFragment.getLocation();
                                if (prevLocation != null) {
                                    updateLocation = location.distanceTo(prevLocation) >= LOCATION_CHANGE_THRESHOLD;
                                }
                                if (updateLocation) {
                                    placePickerFragment.setLocation(location);
                                    placePickerFragment.loadData(true);
                                }
                            }
                            @Override
                            public void onStatusChanged(String s, int i, Bundle bundle) {
                            }
                            @Override
                            public void onProviderEnabled(String s) {
                            }
                            @Override
                            public void onProviderDisabled(String s) {
                            }
                        };
                        locationManager.requestLocationUpdates(bestProvider, 1, LOCATION_CHANGE_THRESHOLD,
                                locationListener, Looper.getMainLooper());
                    }
                }
                if (location != null) {
                    placePickerFragment.setLocation(location);
                    placePickerFragment.setRadiusInMeters(SEARCH_RADIUS_METERS);
                    placePickerFragment.setSearchText(SEARCH_TEXT);
                    placePickerFragment.setResultsLimit(SEARCH_RESULT_LIMIT);
                    placePickerFragment.loadData(false);
                }
            } catch (Exception ex) {
                onError(ex);
            }
        }
    }

    @Override
    protected void onStop() {
        super.onStop();
        if (locationListener != null) {
            LocationManager locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);
            locationManager.removeUpdates(locationListener);
            locationListener = null;
        }
    }

    private void onError(Exception error) {
        String text = getString(R.string.exception, error.getMessage());
        Toast toast = Toast.makeText(this, text, Toast.LENGTH_SHORT);
        toast.show();
    }

    private void onError(String error, final boolean finishActivity) {
        AlertDialog.Builder builder = new AlertDialog.Builder(this);
        builder.setTitle(R.string.error_dialog_title).
                setMessage(error).
                setPositiveButton(R.string.error_dialog_button_text, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialogInterface, int i) {
                        if (finishActivity) {
                            finishActivity();
                        }
                    }
                });
        builder.show();
    }

    private void finishActivity() {
        ScrumptiousApplication app = (ScrumptiousApplication) getApplication();
        if (FRIEND_PICKER.equals(getIntent().getData())) {
            if (friendPickerFragment != null) {
                app.setSelectedUsers(friendPickerFragment.getSelection());
            }
        } else if (PLACE_PICKER.equals(getIntent().getData())) {
            if (placePickerFragment != null) {
                app.setSelectedPlace(placePickerFragment.getSelection());
            }
        }
        setResult(RESULT_OK, null);
        finish();
    }
}

<code block>


package com.example.scrumptious;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.database.DataSetObserver;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Matrix;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Environment;
import android.provider.MediaStore;
import android.support.v4.app.Fragment;
import android.util.Log;
import android.util.Pair;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.WindowManager;
import android.widget.*;

import com.facebook.*;
import com.facebook.internal.Utility;
import com.facebook.login.DefaultAudience;
import com.facebook.login.LoginManager;
import com.facebook.share.ShareApi;
import com.facebook.share.Sharer;
import com.facebook.share.model.ShareContent;
import com.facebook.share.model.ShareOpenGraphContent;
import com.facebook.share.model.ShareOpenGraphObject;
import com.facebook.share.model.SharePhoto;
import com.facebook.share.model.ShareOpenGraphAction;
import com.facebook.share.widget.MessageDialog;
import com.facebook.share.widget.SendButton;
import com.facebook.share.widget.ShareButton;
import com.facebook.login.widget.ProfilePictureView;

import org.json.JSONException;
import org.json.JSONObject;

import java.io.*;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.UUID;


public class SelectionFragment extends Fragment {

    private static final String TAG = "SelectionFragment";
    private static final String MEAL_OBJECT_TYPE = "fb_sample_scrumps:meal";
    private static final String EAT_ACTION_TYPE = "fb_sample_scrumps:eat";

    private static final String PENDING_ANNOUNCE_KEY = "pendingAnnounce";
    private static final int USER_GENERATED_MIN_SIZE = 480;
    private static final float MAX_TEXTURE_SIZE = 1024f;

    private static final String PERMISSION = "publish_actions";

    private TextView announceButton;
    private ShareButton shareButton;
    private SendButton messageButton;
    private ListView listView;
    private List<BaseListElement> listElements;
    private ProfilePictureView profilePictureView;
    private boolean pendingAnnounce;
    private MainActivity activity;
    private ProgressDialog announceProgressDialog;

    private Uri photoUri;
    private ImageView photoThumbnail;
    private ScaleAndSetImageTask runningImageTask;

    private CallbackManager callbackManager;
    private AccessTokenTracker accessTokenTracker;
    private FacebookCallback<Sharer.Result> shareCallback =
            new FacebookCallback<Sharer.Result>() {
                @Override
                public void onCancel() {
                    processDialogResults(null, true);
                }

                @Override
                public void onError(FacebookException error) {
                    if (error instanceof FacebookGraphResponseException) {
                        FacebookGraphResponseException graphError =
                                (FacebookGraphResponseException) error;
                        if (graphError.getGraphResponse() != null) {
                            handleError(graphError.getGraphResponse());
                            return;
                        }
                    }
                    processDialogError(error);
                }

                @Override
                public void onSuccess(Sharer.Result result) {
                    processDialogResults(result.getPostId(), false);
                }
            };

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        activity = (MainActivity) getActivity();
        callbackManager = CallbackManager.Factory.create();

        accessTokenTracker = new AccessTokenTracker() {
            @Override
            protected void onCurrentAccessTokenChanged(AccessToken oldAccessToken,
                                                       AccessToken currentAccessToken) {
                updateWithToken(currentAccessToken);
            }
        };
    }

    private void updateWithToken(AccessToken currentAccessToken) {
        if (currentAccessToken != null) {
            tokenUpdated(currentAccessToken);
            profilePictureView.setProfileId(currentAccessToken.getUserId());
            announceButton.setVisibility(View.VISIBLE);
        } else {
            profilePictureView.setProfileId(null);
            announceButton.setVisibility(View.GONE);
        }
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        super.onCreateView(inflater, container, savedInstanceState);
        View view = inflater.inflate(R.layout.selection, container, false);

        profilePictureView = (ProfilePictureView) view.findViewById(R.id.selection_profile_pic);
        profilePictureView.setCropped(true);
        announceButton = (TextView) view.findViewById(R.id.announce_text);
        shareButton = (ShareButton) view.findViewById(R.id.share_button);
        messageButton = (SendButton) view.findViewById(R.id.message_button);
        listView = (ListView) view.findViewById(R.id.selection_list);
        photoThumbnail = (ImageView) view.findViewById(R.id.selected_image);

        announceProgressDialog = new ProgressDialog(getActivity());
        announceProgressDialog.setMessage(getString(R.string.progress_dialog_text));

        if (MessageDialog.canShow(ShareOpenGraphContent.class)) {
            messageButton.setVisibility(View.VISIBLE);
        }

        announceButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                handleAnnounce();
            }
        });

        messageButton.registerCallback(callbackManager, shareCallback);
        messageButton.setFragment(this);
        shareButton.registerCallback(callbackManager, shareCallback);
        shareButton.setFragment(this);

        profilePictureView.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                if (AccessToken.getCurrentAccessToken() != null) {
                    activity.showSettingsFragment();
                } else {
                    activity.showSplashFragment();
                }
            }
        });

        init(savedInstanceState);
        updateWithToken(AccessToken.getCurrentAccessToken());

        return view;
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if (resultCode == Activity.RESULT_OK && requestCode >= 0 && requestCode < listElements.size()) {
            listElements.get(requestCode).onActivityResult(data);
        } else {
            callbackManager.onActivityResult(requestCode, resultCode, data);
        }
    }

    @Override
    public void onSaveInstanceState(Bundle bundle) {
        super.onSaveInstanceState(bundle);
        for (BaseListElement listElement : listElements) {
            listElement.onSaveInstanceState(bundle);
        }
        bundle.putBoolean(PENDING_ANNOUNCE_KEY, pendingAnnounce);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        accessTokenTracker.stopTracking();
        activity = null;
    }

    private void processDialogError(FacebookException error) {
        enableButtons();
        announceProgressDialog.dismiss();

        if (error != null) {
            new AlertDialog.Builder(getActivity())
                    .setPositiveButton(R.string.error_dialog_button_text, null)
                    .setTitle(R.string.error_dialog_title)
                    .setMessage(error.getLocalizedMessage())
                    .show();
        }
    }

    private void processDialogResults(String postId, boolean isCanceled) {
        enableButtons();
        announceProgressDialog.dismiss();

        boolean resetSelections = true;
        if (isCanceled) {
            
            resetSelections = false;
            showCancelResponse();
        } else {
            showSuccessResponse(postId);
        }

        if (resetSelections) {
            init(null);
        }
    }

    private void showRejectedPermissionError() {
        new AlertDialog.Builder(getActivity())
                .setPositiveButton(R.string.error_dialog_button_text, null)
                .setTitle(R.string.error_dialog_title)
                .setMessage(R.string.rejected_publish_permission)
                .show();
    }

    
    private void tokenUpdated(AccessToken currentAccessToken) {
        if (pendingAnnounce) {
            Set<String> permissions = AccessToken.getCurrentAccessToken().getPermissions();
            if (currentAccessToken == null
                    || !currentAccessToken.getPermissions().contains(PERMISSION)) {
                pendingAnnounce = false;
                showRejectedPermissionError();
                return;
            }
            handleAnnounce();
        }
    }

    private void updateShareContent() {
        ShareContent content = createOpenGraphContent();
        if (content != null) {
            enableButtons();
        } else {
            disableButtons();
        }

        shareButton.setShareContent(content);
        messageButton.setShareContent(content);
    }

    private void disableButtons() {
        announceButton.setEnabled(false);
        shareButton.setEnabled(false);
        messageButton.setEnabled(false);
    }

    private void enableButtons() {
        announceButton.setEnabled(true);
        shareButton.setEnabled(true);
        messageButton.setEnabled(true);
    }

    
    private void init(Bundle savedInstanceState) {
        disableButtons();

        listElements = new ArrayList<BaseListElement>();

        listElements.add(new EatListElement(0));
        listElements.add(new LocationListElement(1));
        listElements.add(new PeopleListElement(2));
        listElements.add(new PhotoListElement(3));

        if (savedInstanceState != null) {
            for (BaseListElement listElement : listElements) {
                listElement.restoreState(savedInstanceState);
            }
            pendingAnnounce = savedInstanceState.getBoolean(PENDING_ANNOUNCE_KEY, false);
        }
        ActionListAdapter listAdapter = new ActionListAdapter(
                getActivity(),
                R.id.selection_list,
                listElements);
        listAdapter.registerDataSetObserver(new DataSetObserver() {
            @Override
            public void onChanged() {
                updateShareContent();
            }
        });
        listView.setAdapter(listAdapter);

        AccessToken accessToken = AccessToken.getCurrentAccessToken();
        if (accessToken != null) {
            profilePictureView.setProfileId(accessToken.getUserId());
        }

        updateShareContent();
    }

    private void handleAnnounce() {
        Set<String> permissions = AccessToken.getCurrentAccessToken().getPermissions();
        if (!permissions.contains(PERMISSION)) {
            pendingAnnounce = true;
            requestPublishPermissions();
            return;
        } else {
            pendingAnnounce = false;
        }

        disableButtons();
        announceProgressDialog.show();
        ShareApi.share(createOpenGraphContent(), shareCallback);
    }

    private ShareOpenGraphContent createOpenGraphContent() {
        ShareOpenGraphAction.Builder actionBuilder = createEatActionBuilder();

        boolean userGenerated = false;
        if (photoUri != null) {
            String photoUriString = photoUri.toString();
            Pair<File, Integer> fileAndMinDimension = getImageFileAndMinDimension();
            userGenerated = fileAndMinDimension.second >= USER_GENERATED_MIN_SIZE;

            if (fileAndMinDimension != null) {
                final SharePhoto actionPhoto = new SharePhoto.Builder()
                        .setImageUrl(Uri.parse(photoUriString))
                        .setUserGenerated(userGenerated)
                        .build();
                actionBuilder.putPhotoArrayList("image", new ArrayList<SharePhoto>() {{
                    add(actionPhoto);
                }});
            }
        }

        return new ShareOpenGraphContent.Builder()
                .setAction(actionBuilder.build())
                .setPreviewPropertyName("meal")
                .build();
    }

    private File getTempPhotoStagingDirectory() {
        File photoDir = new File(getActivity().getCacheDir(), "photoFiles");
        photoDir.mkdirs();

        return photoDir;
    }

    private Pair<File, Integer> getImageFileAndMinDimension() {
        File photoFile = null;
        String photoUriString = photoUri.toString();
        if (photoUriString.startsWith("file:
            photoFile = new File(photoUri.getPath());
        } else if (photoUriString.startsWith("content:
            FileOutputStream photoOutputStream = null;
            InputStream contentInputStream = null;
            try {
                Uri photoUri = Uri.parse(photoUriString);
                photoFile = new File(
                        getTempPhotoStagingDirectory(),
                        URLEncoder.encode(UUID.randomUUID().toString(), "UTF-8"));

                photoOutputStream = new FileOutputStream(photoFile);
                contentInputStream = getActivity()
                        .getContentResolver().openInputStream(photoUri);

                byte[] buffer = new byte[1024];
                int len;
                while ((len = contentInputStream.read(buffer)) > 0) {
                    photoOutputStream.write(buffer, 0, len);
                }
            } catch (FileNotFoundException fnfe) {
                Log.e(TAG, "photo not found", fnfe);
            } catch (UnsupportedEncodingException uee) {
                Log.e(TAG, "bad photo name", uee);
            } catch (IOException ioe) {
                Log.e(TAG, "can't copy photo", ioe);
            } finally {
                try {
                    if (photoOutputStream != null) {
                        photoOutputStream.close();
                    }
                    if (contentInputStream != null) {
                        contentInputStream.close();
                    }
                } catch (IOException ioe) {
                    Log.e(TAG, "can't close streams");
                }
            }
        }

        if (photoFile != null) {
            InputStream is = null;
            try {
                is = new FileInputStream(photoFile);

                
                BitmapFactory.Options options = new BitmapFactory.Options();
                options.inJustDecodeBounds = true;
                BitmapFactory.decodeStream(is, null, options);

                return new Pair<>(
                        photoFile, Math.min(options.outWidth, options.outHeight));
            } catch (Exception e) {
                return null;
            } finally {
                Utility.closeQuietly(is);
            }
        }
        return null;
    }

    private ShareOpenGraphAction.Builder createEatActionBuilder() {
        ShareOpenGraphAction.Builder builder = new ShareOpenGraphAction.Builder()
                .setActionType(EAT_ACTION_TYPE);
        for (BaseListElement element : listElements) {
            element.populateOpenGraphAction(builder);
        }

        return builder;
    }

    private void requestPublishPermissions() {
        LoginManager.getInstance()
                .setDefaultAudience(DefaultAudience.FRIENDS)
                .logInWithPublishPermissions(this, Arrays.asList(PERMISSION));
    }

    private void showSuccessResponse(String postId) {
        String dialogBody;
        if (postId != null) {
            dialogBody = String.format(getString(R.string.result_dialog_text_with_id), postId);
        } else {
            dialogBody = getString(R.string.result_dialog_text_default);
        }
        showResultDialog(dialogBody);
    }

    private void showCancelResponse() {
        showResultDialog(getString(R.string.result_dialog_text_canceled));
    }

    private void showResultDialog(String dialogBody) {
        new AlertDialog.Builder(getActivity())
                .setPositiveButton(R.string.result_dialog_button_text, null)
                .setTitle(R.string.result_dialog_title)
                .setMessage(dialogBody)
                .show();
    }

    private void handleError(GraphResponse response) {
        FacebookRequestError error = response.getError();
        DialogInterface.OnClickListener listener = null;
        String dialogBody = null;

        if (error == null) {
            dialogBody = getString(R.string.error_dialog_default_text);
        } else {
            switch (error.getCategory()) {
                case LOGIN_RECOVERABLE:
                    
                    LoginManager.getInstance().resolveError(this, response);
                    return;

                case TRANSIENT:
                    dialogBody = getString(R.string.error_transient);
                    break;

                case OTHER:
                default:
                    
                    
                    
                    dialogBody = getString(R.string.error_unknown, error.getErrorMessage());
                    break;
            }
        }

        String title = error.getErrorUserTitle();
        String message = error.getErrorUserMessage();
        if (message == null) {
            message = dialogBody;
        }
        if (title == null) {
            title = getResources().getString(R.string.error_dialog_title);
        }

        new AlertDialog.Builder(getActivity())
                .setPositiveButton(R.string.error_dialog_button_text, listener)
                .setTitle(title)
                .setMessage(message)
                .show();
    }

    private void startPickerActivity(Uri data, int requestCode) {
        Intent intent = new Intent();
        intent.setData(data);
        intent.setClass(getActivity(), PickerActivity.class);
        startActivityForResult(intent, requestCode);
    }

    private class EatListElement extends BaseListElement {

        private static final String FOOD_KEY = "food";
        private static final String FOOD_URL_KEY = "food_url";

        private final String[] foodChoices;
        private final String[] foodUrls;
        private String foodChoiceUrl = null;
        private String foodChoice = null;

        public EatListElement(int requestCode) {
            super(getActivity().getResources().getDrawable(R.drawable.add_food),
                    getActivity().getResources().getString(R.string.action_eating),
                    null,
                    requestCode);
            foodChoices = getActivity().getResources().getStringArray(R.array.food_types);
            foodUrls = getActivity().getResources().getStringArray(R.array.food_og_urls);
        }

        @Override
        protected View.OnClickListener getOnClickListener() {
            return new View.OnClickListener() {
                @Override
                public void onClick(View view) {
                    showMealOptions();
                }
            };
        }

        @Override
        protected void populateOpenGraphAction(ShareOpenGraphAction.Builder actionBuilder) {
            if (foodChoice != null && foodChoice.length() > 0) {
                if (foodChoiceUrl != null && foodChoiceUrl.length() > 0) {
                    actionBuilder.putString("meal", foodChoiceUrl);
                } else {
                    ShareOpenGraphObject mealObject = new ShareOpenGraphObject.Builder()
                            .putString("og:type", MEAL_OBJECT_TYPE)
                            .putString("og:title", foodChoice)
                            .build();
                    actionBuilder.putObject("meal", mealObject);
                }
            }
        }

        @Override
        protected void onSaveInstanceState(Bundle bundle) {
            if (foodChoice != null && foodChoiceUrl != null) {
                bundle.putString(FOOD_KEY, foodChoice);
                bundle.putString(FOOD_URL_KEY, foodChoiceUrl);
            }
        }

        @Override
        protected boolean restoreState(Bundle savedState) {
            String food = savedState.getString(FOOD_KEY);
            String foodUrl = savedState.getString(FOOD_URL_KEY);
            if (food != null && foodUrl != null) {
                foodChoice = food;
                foodChoiceUrl = foodUrl;
                setFoodText();
                return true;
            }
            return false;
        }

        private void showMealOptions() {
            String title = getActivity().getResources().getString(R.string.select_meal);
            AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
            builder.setTitle(title).
                    setCancelable(true).
                    setItems(foodChoices, new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialogInterface, int i) {
                            foodChoiceUrl = foodUrls[i];
                            if (foodChoiceUrl.length() == 0) {
                                getCustomFood();
                            } else {
                                foodChoice = foodChoices[i];
                                setFoodText();
                                notifyDataChanged();
                            }
                        }
                    });
            builder.show();
        }

        private void getCustomFood() {
            String title = getActivity().getResources().getString(R.string.enter_meal);
            final EditText input = new EditText(getActivity());

            AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
            builder.setTitle(title)
                    .setCancelable(true)
                    .setView(input)
                    .setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialogInterface, int i) {
                            foodChoice = input.getText().toString();
                            setFoodText();
                            notifyDataChanged();
                        }
                    })
                    .setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialogInterface, int i) {
                        }
                    });
            AlertDialog dialog = builder.create();
            
            dialog.getWindow().setSoftInputMode(
                    WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);
            dialog.show();
        }

        private void setFoodText() {
            if (foodChoice != null && foodChoice.length() > 0) {
                setText2(foodChoice);
                enableButtons();
            } else {
                setText2(getActivity().getResources().getString(R.string.action_eating_default));
                disableButtons();
            }
        }
    }

    private class PeopleListElement extends BaseListElement {

        private static final String FRIENDS_KEY = "friends";

        private List<JSONObject> selectedUsers;

        public PeopleListElement(int requestCode) {
            super(getActivity().getResources().getDrawable(R.drawable.add_friends),
                    getActivity().getResources().getString(R.string.action_people),
                    null,
                    requestCode);
        }

        @Override
        protected View.OnClickListener getOnClickListener() {
            return new View.OnClickListener() {
                @Override
                public void onClick(View view) {
                    if (AccessToken.getCurrentAccessToken() != null) {
                        startPickerActivity(PickerActivity.FRIEND_PICKER, getRequestCode());
                    } else {
                        activity.showSplashFragment();
                    }
                }
            };
        }

        @Override
        protected void onActivityResult(Intent data) {
            selectedUsers = ((ScrumptiousApplication) getActivity().getApplication())
                    .getSelectedUsers();
            setUsersText();
            notifyDataChanged();
        }

        @Override
        protected void populateOpenGraphAction(ShareOpenGraphAction.Builder actionBuilder) {
            if (selectedUsers != null && !selectedUsers.isEmpty()) {
                ArrayList<String> tags = new ArrayList<>();
                for (JSONObject user : selectedUsers) {
                    tags.add(user.optString("id"));
                }
                actionBuilder.putStringArrayList("tags", tags);
            }
        }

        @Override
        protected void onSaveInstanceState(Bundle bundle) {
            if (selectedUsers != null) {
                bundle.putByteArray(FRIENDS_KEY, getByteArray(selectedUsers));
            }
        }

        @Override
        protected boolean restoreState(Bundle savedState) {
            byte[] bytes = savedState.getByteArray(FRIENDS_KEY);
            if (bytes != null) {
                selectedUsers = restoreByteArray(bytes);
                setUsersText();
                return true;
            }
            return false;
        }

        private void setUsersText() {
            String text = null;
            if (selectedUsers != null) {
                if (selectedUsers.size() == 1) {
                    text = String.format(getResources().getString(R.string.single_user_selected),
                            selectedUsers.get(0).optString("name"));
                } else if (selectedUsers.size() == 2) {
                    text = String.format(getResources().getString(R.string.two_users_selected),
                            selectedUsers.get(0).optString("name"),
                            selectedUsers.get(1).optString("name"));
                } else if (selectedUsers.size() > 2) {
                    text = String.format(getResources().getString(R.string.multiple_users_selected),
                            selectedUsers.get(0).optString("name"), (selectedUsers.size() - 1));
                }
            }
            if (text == null) {
                text = getResources().getString(R.string.action_people_default);
            }
            setText2(text);
        }

        private byte[] getByteArray(List<JSONObject> users) {
            
            
            List<String> usersAsString = new ArrayList<String>(users.size());

            for (JSONObject user : users) {
                usersAsString.add(user.toString());
            }
            try {
                ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
                new ObjectOutputStream(outputStream).writeObject(usersAsString);
                return outputStream.toByteArray();
            } catch (IOException e) {
                Log.e(TAG, "Unable to serialize users.", e);
            }
            return null;
        }

        private List<JSONObject> restoreByteArray(byte[] bytes) {
            try {
                @SuppressWarnings("unchecked")
                List<String> usersAsString =
                        (List<String>) (new ObjectInputStream(
                                new ByteArrayInputStream(bytes))).readObject();
                if (usersAsString != null) {
                    List<JSONObject> users = new ArrayList<JSONObject>(usersAsString.size());
                    for (String user : usersAsString) {
                        users.add(new JSONObject(user));
                    }
                    return users;
                }
            } catch (ClassNotFoundException e) {
                Log.e(TAG, "Unable to deserialize users.", e);
            } catch (IOException e) {
                Log.e(TAG, "Unable to deserialize users.", e);
            } catch (JSONException e) {
                Log.e(TAG, "Unable to deserialize users.", e);
            }
            return null;
        }
    }

    private class LocationListElement extends BaseListElement {
        private static final String PLACE_KEY = "place";

        private JSONObject selectedPlace = null;

        public LocationListElement(int requestCode) {
            super(getActivity().getResources().getDrawable(R.drawable.add_location),
                    getActivity().getResources().getString(R.string.action_location),
                    null,
                    requestCode);
        }

        @Override
        protected View.OnClickListener getOnClickListener() {
            return new View.OnClickListener() {
                @Override
                public void onClick(View view) {
                    if (AccessToken.getCurrentAccessToken() != null) {
                        startPickerActivity(PickerActivity.PLACE_PICKER, getRequestCode());
                    } else {
                        activity.showSplashFragment();
                    }
                }
            };
        }

        @Override
        protected void onActivityResult(Intent data) {
            selectedPlace = ((ScrumptiousApplication) getActivity().getApplication())
                    .getSelectedPlace();
            setPlaceText();
            notifyDataChanged();
        }

        @Override
        protected void populateOpenGraphAction(ShareOpenGraphAction.Builder actionBuilder) {
            if (selectedPlace != null) {
                actionBuilder.putString("place", selectedPlace.optString("id"));
            }
        }

        @Override
        protected void onSaveInstanceState(Bundle bundle) {
            if (selectedPlace != null) {
                bundle.putString(PLACE_KEY, selectedPlace.toString());
            }
        }

        @Override
        protected boolean restoreState(Bundle savedState) {
            String place = savedState.getString(PLACE_KEY);
            if (place != null) {
                try {
                    selectedPlace = new JSONObject(place);
                    setPlaceText();
                    return true;
                } catch (JSONException e) {
                    Log.e(TAG, "Unable to deserialize place.", e);
                }
            }
            return false;
        }

        private void setPlaceText() {
            String text = selectedPlace != null ? selectedPlace.optString("name") : null;
            if (text == null) {
                text = getResources().getString(R.string.action_location_default);
            }
            setText2(text);
        }

    }

    private class PhotoListElement extends BaseListElement {
        private static final int CAMERA = 0;
        private static final int GALLERY = 1;
        private static final String PHOTO_URI_KEY = "photo_uri";
        private static final String TEMP_URI_KEY = "temp_uri";
        private static final String FILE_PREFIX = "scrumptious_img_";
        private static final String FILE_SUFFIX = ".jpg";

        private Uri tempUri = null;

        public PhotoListElement(int requestCode) {
            super(getActivity().getResources().getDrawable(R.drawable.add_photo),
                    getActivity().getResources().getString(R.string.action_photo),
                    null,
                    requestCode);
            photoUri = null;
            photoThumbnail.setImageDrawable(
                    getActivity().getResources().getDrawable(R.drawable.placeholder_image));
            photoThumbnail.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    showPhotoChoice();
                }
            });
        }

        @Override
        protected View.OnClickListener getOnClickListener() {
            return new View.OnClickListener() {
                @Override
                public void onClick(View view) {
                    showPhotoChoice();
                }
            };
        }

        @Override
        protected void onActivityResult(Intent data) {
            if (tempUri != null) {
                photoUri = tempUri;
            } else if (data != null) {
                photoUri = data.getData();
            }
            setPhotoThumbnail();
            setPhotoText();
        }

        @Override
        protected void populateOpenGraphAction(ShareOpenGraphAction.Builder actionBuilder) {
        }

        @Override
        protected void onSaveInstanceState(Bundle bundle) {
            if (photoUri != null) {
                bundle.putParcelable(PHOTO_URI_KEY, photoUri);
            }
            if (tempUri != null) {
                bundle.putParcelable(TEMP_URI_KEY, tempUri);
            }
        }

        @Override
        protected boolean restoreState(Bundle savedState) {
            photoUri = savedState.getParcelable(PHOTO_URI_KEY);
            tempUri = savedState.getParcelable(TEMP_URI_KEY);
            setPhotoText();
            return true;
        }

        private void showPhotoChoice() {
            AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
            CharSequence camera = getResources().getString(R.string.action_photo_camera);
            CharSequence gallery = getResources().getString(R.string.action_photo_gallery);
            builder.setCancelable(true).
                    setItems(new CharSequence[]{camera, gallery},
                            new DialogInterface.OnClickListener() {
                                @Override
                                public void onClick(DialogInterface dialogInterface, int i) {
                                    if (i == CAMERA) {
                                        startCameraActivity();
                                    } else if (i == GALLERY) {
                                        startGalleryActivity();
                                    }
                                }
                            });
            builder.show();
        }

        private void setPhotoText() {
            if (photoUri == null) {
                setText2(getResources().getString(R.string.action_photo_default));
            } else {
                setText2(getResources().getString(R.string.action_photo_ready));
            }
        }

        private void setPhotoThumbnail() {
            
            if (runningImageTask != null &&
                    runningImageTask.getStatus() != AsyncTask.Status.FINISHED) {
                runningImageTask.cancel(true);
            }

            runningImageTask = new ScaleAndSetImageTask(photoUri);
            runningImageTask.execute();
        }

        private void startCameraActivity() {
            Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
            tempUri = getTempUri();
            if (tempUri != null) {
                intent.putExtra(MediaStore.EXTRA_OUTPUT, tempUri);
            }
            startActivityForResult(intent, getRequestCode());
        }

        private void startGalleryActivity() {
            tempUri = null;
            Intent intent = new Intent(Intent.ACTION_GET_CONTENT);
            intent.setType("image/*");
            String selectPicture = getResources().getString(R.string.select_picture);
            startActivityForResult(Intent.createChooser(intent, selectPicture), getRequestCode());
        }

        private Uri getTempUri() {
            String imgFileName = FILE_PREFIX + System.currentTimeMillis() + FILE_SUFFIX;

            
            
            
            
            File image = new File(
                    Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),
                    imgFileName);
            return Uri.fromFile(image);
        }
    }

    private class ActionListAdapter extends ArrayAdapter<BaseListElement> {
        private List<BaseListElement> listElements;

        public ActionListAdapter(
                Context context, int resourceId, List<BaseListElement> listElements) {
            super(context, resourceId, listElements);
            this.listElements = listElements;
            for (int i = 0; i < listElements.size(); i++) {
                listElements.get(i).setAdapter(this);
            }
        }

        @Override
        public View getView(int position, View convertView, ViewGroup parent) {
            View view = convertView;
            if (view == null) {
                LayoutInflater inflater =
                        (LayoutInflater) getActivity().getSystemService(
                                Context.LAYOUT_INFLATER_SERVICE);
                view = inflater.inflate(R.layout.listitem, null);
            }

            BaseListElement listElement = listElements.get(position);
            if (listElement != null) {
                view.setOnClickListener(listElement.getOnClickListener());
                ImageView icon = (ImageView) view.findViewById(R.id.icon);
                TextView text1 = (TextView) view.findViewById(R.id.text1);
                TextView text2 = (TextView) view.findViewById(R.id.text2);
                if (icon != null) {
                    icon.setImageDrawable(listElement.getIcon());
                }
                if (text1 != null) {
                    text1.setText(listElement.getText1());
                }
                if (text2 != null) {
                    if (listElement.getText2() != null) {
                        text2.setVisibility(View.VISIBLE);
                        text2.setText(listElement.getText2());
                    } else {
                        text2.setVisibility(View.GONE);
                    }
                }
            }
            return view;
        }
    }

    private class ScaleAndSetImageTask extends AsyncTask<Void, Void, Bitmap> {
        private final Uri uri;

        public ScaleAndSetImageTask(Uri uri) {
            this.uri = uri;
        }

        @Override
        protected Bitmap doInBackground(Void... params) {
            try {
                Bitmap bitmap = MediaStore.Images.Media.getBitmap(
                        FacebookSdk.getApplicationContext().getContentResolver(), uri);
                if (bitmap.getHeight() > MAX_TEXTURE_SIZE || bitmap.getWidth() > MAX_TEXTURE_SIZE) {
                    
                    float scale = Math.min(
                            MAX_TEXTURE_SIZE / bitmap.getHeight(),
                            MAX_TEXTURE_SIZE / bitmap.getWidth());
                    Matrix matrix = new Matrix();
                    matrix.postScale(scale, scale);
                    bitmap = Bitmap.createBitmap(
                            bitmap,
                            0,
                            0,
                            bitmap.getWidth(),
                            bitmap.getHeight(),
                            matrix,
                            false);
                }
                return bitmap;
            } catch (Exception ex) {
                return null;
            }
        }

        protected void onPostExecute(Bitmap result) {
            if (result != null) {
                photoThumbnail.setImageBitmap(result);
            } else {
                
                photoThumbnail.setImageURI(photoUri);
            }
        }
    }
}

<code block>


package com.example.scrumptious;

import android.content.Intent;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentActivity;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentTransaction;

import com.facebook.AccessToken;
import com.facebook.AccessTokenTracker;
import com.facebook.appevents.AppEventsLogger;
import com.facebook.CallbackManager;

public class MainActivity extends FragmentActivity {

    private static final String USER_SKIPPED_LOGIN_KEY = "user_skipped_login";

    private static final int SPLASH = 0;
    private static final int SELECTION = 1;
    private static final int SETTINGS = 2;
    private static final int FRAGMENT_COUNT = SETTINGS +1;

    private Fragment[] fragments = new Fragment[FRAGMENT_COUNT];
    private boolean isResumed = false;
    private boolean userSkippedLogin = false;
    private AccessTokenTracker accessTokenTracker;
    private CallbackManager callbackManager;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        if (savedInstanceState != null) {
            userSkippedLogin = savedInstanceState.getBoolean(USER_SKIPPED_LOGIN_KEY);
        }
        callbackManager = CallbackManager.Factory.create();

        accessTokenTracker = new AccessTokenTracker() {
            @Override
            protected void onCurrentAccessTokenChanged(AccessToken oldAccessToken,
                                                       AccessToken currentAccessToken) {
                if (isResumed) {
                    FragmentManager manager = getSupportFragmentManager();
                    int backStackSize = manager.getBackStackEntryCount();
                    for (int i = 0; i < backStackSize; i++) {
                        manager.popBackStack();
                    }
                    if (currentAccessToken != null) {
                        showFragment(SELECTION, false);
                    } else {
                        showFragment(SPLASH, false);
                    }
                }
            }
        };

        setContentView(R.layout.main);

        FragmentManager fm = getSupportFragmentManager();
        SplashFragment splashFragment = (SplashFragment) fm.findFragmentById(R.id.splashFragment);
        fragments[SPLASH] = splashFragment;
        fragments[SELECTION] = fm.findFragmentById(R.id.selectionFragment);
        fragments[SETTINGS] = fm.findFragmentById(R.id.userSettingsFragment);

        FragmentTransaction transaction = fm.beginTransaction();
        for(int i = 0; i < fragments.length; i++) {
            transaction.hide(fragments[i]);
        }
        transaction.commit();

        splashFragment.setSkipLoginCallback(new SplashFragment.SkipLoginCallback() {
            @Override
            public void onSkipLoginPressed() {
                userSkippedLogin = true;
                showFragment(SELECTION, false);
            }
        });
    }

    @Override
    public void onResume() {
        super.onResume();
        isResumed = true;

        
        
        
        AppEventsLogger.activateApp(this);
    }

    @Override
    public void onPause() {
        super.onPause();
        isResumed = false;

        
        
        
        AppEventsLogger.deactivateApp(this);
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        callbackManager.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        accessTokenTracker.stopTracking();
    }

    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);

        outState.putBoolean(USER_SKIPPED_LOGIN_KEY, userSkippedLogin);
    }

    @Override
    protected void onResumeFragments() {
        super.onResumeFragments();

        if (AccessToken.getCurrentAccessToken() != null) {
            
            showFragment(SELECTION, false);
            userSkippedLogin = false;
        } else if (userSkippedLogin) {
            showFragment(SELECTION, false);
        } else {
            
            
            showFragment(SPLASH, false);
        }
    }

    public void showSettingsFragment() {
        showFragment(SETTINGS, true);
    }

    public void showSplashFragment() {
        showFragment(SPLASH, true);
    }


    private void showFragment(int fragmentIndex, boolean addToBackStack) {
        FragmentManager fm = getSupportFragmentManager();
        FragmentTransaction transaction = fm.beginTransaction();
        for (int i = 0; i < fragments.length; i++) {
            if (i == fragmentIndex) {
                transaction.show(fragments[i]);
            } else {
                transaction.hide(fragments[i]);
            }
        }
        if (addToBackStack) {
            transaction.addToBackStack(null);
        }
        transaction.commit();
    }
}

<code block>


package com.example.scrumptious.picker;

import android.app.Activity;
import android.content.Context;
import android.content.res.TypedArray;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v4.app.LoaderManager;
import android.support.v4.content.Loader;
import android.text.TextUtils;
import android.util.AttributeSet;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewStub;
import android.view.animation.AlphaAnimation;
import android.widget.*;

import com.facebook.AccessToken;
import com.facebook.AccessTokenTracker;
import com.facebook.FacebookException;
import com.facebook.GraphRequest;
import com.example.scrumptious.R;

import org.json.JSONObject;

import java.util.*;


public abstract class PickerFragment extends Fragment {
    
    public static final String SHOW_PICTURES_BUNDLE_KEY = "com.example.scrumptious.widget.PickerFragment.ShowPictures";
    
    public static final String EXTRA_FIELDS_BUNDLE_KEY = "com.example.scrumptious.widget.PickerFragment.ExtraFields";
    
    public static final String SHOW_TITLE_BAR_BUNDLE_KEY = "com.example.scrumptious.widget.PickerFragment.ShowTitleBar";
    
    public static final String TITLE_TEXT_BUNDLE_KEY = "com.example.scrumptious.widget.PickerFragment.TitleText";
    
    public static final String DONE_BUTTON_TEXT_BUNDLE_KEY = "com.example.scrumptious.widget.PickerFragment.DoneButtonText";

    private static final String SELECTION_BUNDLE_KEY = "com.facebook.android.PickerFragment.Selection";
    private static final String ACTIVITY_CIRCLE_SHOW_KEY = "com.facebook.android.PickerFragment.ActivityCircleShown";
    private static final int PROFILE_PICTURE_PREFETCH_BUFFER = 5;

    private final int layout;
    private OnErrorListener onErrorListener;
    private OnDataChangedListener onDataChangedListener;
    private OnSelectionChangedListener onSelectionChangedListener;
    private OnDoneButtonClickedListener onDoneButtonClickedListener;
    private GraphObjectFilter filter;
    private boolean showPictures = true;
    private boolean showTitleBar = true;
    private ListView listView;
    HashSet<String> extraFields = new HashSet<String>();
    GraphObjectAdapter adapter;
    private LoadingStrategy loadingStrategy;
    private SelectionStrategy selectionStrategy;
    private Set<String> selectionHint;
    private ProgressBar activityCircle;
    private AccessTokenTracker accessTokenTracker;
    private String titleText;
    private String doneButtonText;
    private TextView titleTextView;
    private Button doneButton;
    private Drawable titleBarBackground;
    private Drawable doneButtonBackground;
    private boolean appEventsLogged;

    protected PickerFragment(int layout) {
        this.layout = layout;
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        adapter = createAdapter();
        adapter.setFilter(new GraphObjectAdapter.Filter() {
            @Override
            public boolean includeItem(JSONObject graphObject) {
                return filterIncludesItem(graphObject);
            }
        });
    }

    @Override
    public void onInflate(Activity activity, AttributeSet attrs, Bundle savedInstanceState) {
        super.onInflate(activity, attrs, savedInstanceState);
        TypedArray a = activity.obtainStyledAttributes(attrs, R.styleable.picker_fragment);

        setShowPictures(a.getBoolean(R.styleable.picker_fragment_show_pictures, showPictures));
        String extraFieldsString = a.getString(R.styleable.picker_fragment_extra_fields);
        if (extraFieldsString != null) {
            String[] strings = extraFieldsString.split(",");
            setExtraFields(Arrays.asList(strings));
        }

        showTitleBar = a.getBoolean(R.styleable.picker_fragment_show_title_bar, showTitleBar);
        titleText = a.getString(R.styleable.picker_fragment_title_text);
        doneButtonText = a.getString(R.styleable.picker_fragment_done_button_text);
        titleBarBackground = a.getDrawable(R.styleable.picker_fragment_title_bar_background);
        doneButtonBackground = a.getDrawable(R.styleable.picker_fragment_done_button_background);

        a.recycle();
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        ViewGroup view = (ViewGroup) inflater.inflate(layout, container, false);

        listView = (ListView) view.findViewById(R.id.com_facebook_picker_list_view);
        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
            @Override
            public void onItemClick(AdapterView<?> parent, View v, int position, long id) {
                onListItemClick((ListView) parent, v, position);
            }
        });
        listView.setOnLongClickListener(new View.OnLongClickListener() {
            @Override
            public boolean onLongClick(View v) {
                
                
                
                return false;
            }
        });
        listView.setOnScrollListener(onScrollListener);

        activityCircle = (ProgressBar) view.findViewById(R.id.com_facebook_picker_activity_circle);

        setupViews(view);

        listView.setAdapter(adapter);

        return view;
    }

    @Override
    public void onActivityCreated(final Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        accessTokenTracker = new AccessTokenTracker() {
            @Override
            protected void onCurrentAccessTokenChanged(AccessToken oldAccessToken,
                                                       AccessToken currentAccessToken) {
                clearResults();
            }
        };

        setSettingsFromBundle(savedInstanceState);

        loadingStrategy = createLoadingStrategy();
        loadingStrategy.attach(adapter);

        selectionStrategy = createSelectionStrategy();
        selectionStrategy.readSelectionFromBundle(savedInstanceState, SELECTION_BUNDLE_KEY);

        
        if (showTitleBar) {
            inflateTitleBar((ViewGroup) getView());
        }

        if (activityCircle != null && savedInstanceState != null) {
            boolean shown = savedInstanceState.getBoolean(ACTIVITY_CIRCLE_SHOW_KEY, false);
            if (shown) {
                displayActivityCircle();
            } else {
                
                hideActivityCircle();
            }
        }
    }

    @Override
    public void onDetach() {
        super.onDetach();

        listView.setOnScrollListener(null);
        listView.setAdapter(null);

        loadingStrategy.detach();
        accessTokenTracker.stopTracking();
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);

        saveSettingsToBundle(outState);
        selectionStrategy.saveSelectionToBundle(outState, SELECTION_BUNDLE_KEY);
        if (activityCircle != null) {
            outState.putBoolean(ACTIVITY_CIRCLE_SHOW_KEY, activityCircle.getVisibility() == View.VISIBLE);
        }
    }

    @Override
    public void onStop() {
        if (!appEventsLogged) {
            logAppEvents(false);
        }
        super.onStop();
    }

    @Override
    public void setArguments(Bundle args) {
        super.setArguments(args);
        setSettingsFromBundle(args);
    }

    
    public OnDataChangedListener getOnDataChangedListener() {
        return onDataChangedListener;
    }

    
    public void setOnDataChangedListener(OnDataChangedListener onDataChangedListener) {
        this.onDataChangedListener = onDataChangedListener;
    }

    
    public OnSelectionChangedListener getOnSelectionChangedListener() {
        return onSelectionChangedListener;
    }

    
    public void setOnSelectionChangedListener(
            OnSelectionChangedListener onSelectionChangedListener) {
        this.onSelectionChangedListener = onSelectionChangedListener;
    }

    
    public OnDoneButtonClickedListener getOnDoneButtonClickedListener() {
        return onDoneButtonClickedListener;
    }

    
    public void setOnDoneButtonClickedListener(OnDoneButtonClickedListener onDoneButtonClickedListener) {
        this.onDoneButtonClickedListener = onDoneButtonClickedListener;
    }

    
    public OnErrorListener getOnErrorListener() {
        return onErrorListener;
    }

    
    public void setOnErrorListener(OnErrorListener onErrorListener) {
        this.onErrorListener = onErrorListener;
    }

    
    public GraphObjectFilter getFilter() {
        return filter;
    }

    
    public void setFilter(GraphObjectFilter filter) {
        this.filter = filter;
    }

    
    public boolean getShowPictures() {
        return showPictures;
    }

    
    public void setShowPictures(boolean showPictures) {
        this.showPictures = showPictures;
    }

    
    public Set<String> getExtraFields() {
        return new HashSet<String>(extraFields);
    }

    
    public void setExtraFields(Collection<String> fields) {
        extraFields = new HashSet<String>();
        if (fields != null) {
            extraFields.addAll(fields);
        }
    }

    
    public void setShowTitleBar(boolean showTitleBar) {
        this.showTitleBar = showTitleBar;
    }

    
    public boolean getShowTitleBar() {
        return showTitleBar;
    }

    
    public void setTitleText(String titleText) {
        this.titleText = titleText;
    }

    
    public String getTitleText() {
        if (titleText == null) {
            titleText = getDefaultTitleText();
        }
        return titleText;
    }

    
    public void setDoneButtonText(String doneButtonText) {
        this.doneButtonText = doneButtonText;
    }

    
    public String getDoneButtonText() {
        if (doneButtonText == null) {
            doneButtonText = getDefaultDoneButtonText();
        }
        return doneButtonText;
    }

    
    public void loadData(boolean forceReload) {
        loadData(forceReload, null);
    }

    
    public void loadData(boolean forceReload, Set<String> selectIds) {
        if (!forceReload && loadingStrategy.isDataPresentOrLoading()) {
            return;
        }
        selectionHint = selectIds;
        clearResults();

        GraphRequest request = getRequestForLoadData();
        if (request != null) {
            onLoadingData();
            loadingStrategy.startLoading(request);
        }
    }

    
    public void setSettingsFromBundle(Bundle inState) {
        if (inState != null) {
            showPictures = inState.getBoolean(SHOW_PICTURES_BUNDLE_KEY, showPictures);
            String extraFieldsString = inState.getString(EXTRA_FIELDS_BUNDLE_KEY);
            if (extraFieldsString != null) {
                String[] strings = extraFieldsString.split(",");
                setExtraFields(Arrays.asList(strings));
            }
            showTitleBar = inState.getBoolean(SHOW_TITLE_BAR_BUNDLE_KEY, showTitleBar);
            String titleTextString = inState.getString(TITLE_TEXT_BUNDLE_KEY);
            if (titleTextString != null) {
                titleText = titleTextString;
                if (titleTextView != null) {
                    titleTextView.setText(titleText);
                }
            }
            String doneButtonTextString = inState.getString(DONE_BUTTON_TEXT_BUNDLE_KEY);
            if (doneButtonTextString != null) {
                doneButtonText = doneButtonTextString;
                if (doneButton != null) {
                    doneButton.setText(doneButtonText);
                }
            }
        }

    }

    void setupViews(ViewGroup view) {
    }

    boolean filterIncludesItem(JSONObject graphObject) {
        if (filter != null) {
            return filter.includeItem(graphObject);
        }
        return true;
    }

    List<JSONObject> getSelectedGraphObjects() {
        return adapter.getGraphObjectsById(selectionStrategy.getSelectedIds());
    }

    void setSelectedGraphObjects(List<String> objectIds) {
        for(String objectId : objectIds) {
            if(!this.selectionStrategy.isSelected(objectId)) {
                this.selectionStrategy.toggleSelection(objectId);
            }
        }
    }

    void saveSettingsToBundle(Bundle outState) {
        outState.putBoolean(SHOW_PICTURES_BUNDLE_KEY, showPictures);
        if (!extraFields.isEmpty()) {
            outState.putString(EXTRA_FIELDS_BUNDLE_KEY, TextUtils.join(",", extraFields));
        }
        outState.putBoolean(SHOW_TITLE_BAR_BUNDLE_KEY, showTitleBar);
        outState.putString(TITLE_TEXT_BUNDLE_KEY, titleText);
        outState.putString(DONE_BUTTON_TEXT_BUNDLE_KEY, doneButtonText);
    }

    abstract GraphRequest getRequestForLoadData();

    abstract PickerFragmentAdapter createAdapter();

    abstract LoadingStrategy createLoadingStrategy();

    abstract SelectionStrategy createSelectionStrategy();

    void onLoadingData() {
    }

    String getDefaultTitleText() {
        return null;
    }

    String getDefaultDoneButtonText() {
        return getString(R.string.picker_picker_done_button_text);
    }

    void displayActivityCircle() {
        if (activityCircle != null) {
            layoutActivityCircle();
            activityCircle.setVisibility(View.VISIBLE);
        }
    }

    void layoutActivityCircle() {
        
        
        float alpha = (!adapter.isEmpty()) ? .25f : 1.0f;
        setAlpha(activityCircle, alpha);
    }

    void hideActivityCircle() {
        if (activityCircle != null) {
            
            activityCircle.clearAnimation();
            activityCircle.setVisibility(View.INVISIBLE);
        }
    }

    void setSelectionStrategy(SelectionStrategy selectionStrategy) {
        if (selectionStrategy != this.selectionStrategy) {
            this.selectionStrategy = selectionStrategy;
            if (adapter != null) {
                
                adapter.notifyDataSetChanged();
            }
        }
    }

    void logAppEvents(boolean doneButtonClicked) {
    }

    private static void setAlpha(View view, float alpha) {
        
        AlphaAnimation alphaAnimation = new AlphaAnimation(alpha, alpha);
        alphaAnimation.setDuration(0);
        alphaAnimation.setFillAfter(true);
        view.startAnimation(alphaAnimation);
    }

    private void inflateTitleBar(ViewGroup view) {
        ViewStub stub = (ViewStub) view.findViewById(R.id.com_facebook_picker_title_bar_stub);
        if (stub != null) {
            View titleBar = stub.inflate();

            final RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(
                    RelativeLayout.LayoutParams.MATCH_PARENT,
                    RelativeLayout.LayoutParams.MATCH_PARENT);
            layoutParams.addRule(RelativeLayout.BELOW, R.id.com_facebook_picker_title_bar);
            listView.setLayoutParams(layoutParams);

            if (titleBarBackground != null) {
                titleBar.setBackgroundDrawable(titleBarBackground);
            }

            doneButton = (Button) view.findViewById(R.id.com_facebook_picker_done_button);
            if (doneButton != null) {
                doneButton.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        logAppEvents(true);
                        appEventsLogged = true;

                        if (onDoneButtonClickedListener != null) {
                            onDoneButtonClickedListener.onDoneButtonClicked(PickerFragment.this);
                        }
                    }
                });

                if (getDoneButtonText() != null) {
                    doneButton.setText(getDoneButtonText());
                }

                if (doneButtonBackground != null) {
                    doneButton.setBackgroundDrawable(doneButtonBackground);
                }
            }

            titleTextView = (TextView) view.findViewById(R.id.com_facebook_picker_title);
            if (titleTextView != null) {
                if (getTitleText() != null) {
                    titleTextView.setText(getTitleText());
                }
            }
        }
    }

    private void onListItemClick(ListView listView, View v, int position) {
        @SuppressWarnings("unchecked")
        JSONObject graphObject = (JSONObject) listView.getItemAtPosition(position);
        String id = adapter.getIdOfGraphObject(graphObject);
        selectionStrategy.toggleSelection(id);
        adapter.notifyDataSetChanged();

        if (onSelectionChangedListener != null) {
            onSelectionChangedListener.onSelectionChanged(PickerFragment.this);
        }
    }

    private void clearResults() {
        if (adapter != null) {
            boolean wasSelection = !selectionStrategy.isEmpty();
            boolean wasData = !adapter.isEmpty();

            loadingStrategy.clearResults();
            selectionStrategy.clear();
            adapter.notifyDataSetChanged();

            
            if (wasData && onDataChangedListener != null) {
                onDataChangedListener.onDataChanged(PickerFragment.this);
            }
            if (wasSelection && onSelectionChangedListener != null) {
                onSelectionChangedListener.onSelectionChanged(PickerFragment.this);
            }
        }
    }

    void updateAdapter(GraphObjectCursor data) {
        if (adapter != null) {
            
            
            
            
            
            
            

            
            
            
            View view = listView.getChildAt(1);
            int anchorPosition = listView.getFirstVisiblePosition();
            if (anchorPosition > 0) {
                anchorPosition++;
            }
            GraphObjectAdapter.SectionAndItem anchorItem = adapter.getSectionAndItem(anchorPosition);
            final int top = (view != null &&
                    anchorItem.getType() != GraphObjectAdapter.SectionAndItem.Type.ACTIVITY_CIRCLE) ?
                    view.getTop() : 0;

            
            boolean dataChanged = adapter.changeCursor(data);

            if (view != null && anchorItem != null) {
                
                final int newPositionOfItem = adapter.getPosition(anchorItem.sectionKey, anchorItem.graphObject);
                if (newPositionOfItem != -1) {
                    listView.setSelectionFromTop(newPositionOfItem, top);
                }
            }

            if (dataChanged && onDataChangedListener != null) {
                onDataChangedListener.onDataChanged(PickerFragment.this);
            }
            if (selectionHint != null && !selectionHint.isEmpty() && data != null) {
                data.moveToFirst();
                boolean changed = false;
                for (int i = 0; i < data.getCount(); i++) {
                    data.moveToPosition(i);
                    String id = data.getGraphObject().optString("id");
                    if (id == null) {
                        continue;
                    }
                    if (selectionHint.contains(id)) {
                        selectionStrategy.toggleSelection(id);
                        selectionHint.remove(id);
                        changed = true;
                    }
                    if (selectionHint.isEmpty()) {
                        break;
                    }
                }
                if (onSelectionChangedListener != null && changed) {
                    onSelectionChangedListener.onSelectionChanged(PickerFragment.this);
                }
            }
        }
    }

    private void reprioritizeDownloads() {
        int lastVisibleItem = listView.getLastVisiblePosition();
        if (lastVisibleItem >= 0) {
            int firstVisibleItem = listView.getFirstVisiblePosition();
            adapter.prioritizeViewRange(firstVisibleItem, lastVisibleItem, PROFILE_PICTURE_PREFETCH_BUFFER);
        }
    }

    private ListView.OnScrollListener onScrollListener = new ListView.OnScrollListener() {
        @Override
        public void onScrollStateChanged(AbsListView view, int scrollState) {
        }

        @Override
        public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {
            reprioritizeDownloads();
        }
    };

    
    public interface OnErrorListener {
        
        void onError(PickerFragment fragment, FacebookException error);
    }

    
    public interface OnDataChangedListener {
        
        void onDataChanged(PickerFragment fragment);
    }

    
    public interface OnSelectionChangedListener {
        
        void onSelectionChanged(PickerFragment fragment);
    }

    
    public interface OnDoneButtonClickedListener {
        
        void onDoneButtonClicked(PickerFragment fragment);
    }

    
    public interface GraphObjectFilter {
        
        boolean includeItem(JSONObject graphObject);
    }

    abstract class LoadingStrategy {
        protected final static int CACHED_RESULT_REFRESH_DELAY = 2 * 1000;

        protected GraphObjectPagingLoader loader;
        protected GraphObjectAdapter adapter;

        public void attach(GraphObjectAdapter adapter) {
            loader = (GraphObjectPagingLoader) getLoaderManager().initLoader(0, null,
                    new LoaderManager.LoaderCallbacks<GraphObjectCursor>() {
                        @Override
                        public Loader<GraphObjectCursor> onCreateLoader(int id, Bundle args) {
                            return LoadingStrategy.this.onCreateLoader();
                        }

                        @Override
                        public void onLoadFinished(Loader<GraphObjectCursor> loader,
                                GraphObjectCursor data) {
                            if (loader != LoadingStrategy.this.loader) {
                                throw new FacebookException("Received callback for unknown loader.");
                            }
                            LoadingStrategy.this.onLoadFinished((GraphObjectPagingLoader) loader, data);
                        }

                        @Override
                        public void onLoaderReset(Loader<GraphObjectCursor> loader) {
                            if (loader != LoadingStrategy.this.loader) {
                                throw new FacebookException("Received callback for unknown loader.");
                            }
                            LoadingStrategy.this.onLoadReset((GraphObjectPagingLoader) loader);
                        }
                    });

            loader.setOnErrorListener(new GraphObjectPagingLoader.OnErrorListener() {
                @Override
                public void onError(FacebookException error, GraphObjectPagingLoader loader) {
                    hideActivityCircle();
                    if (onErrorListener != null) {
                        onErrorListener.onError(PickerFragment.this, error);
                    }
                }
            });

            this.adapter = adapter;
            
            this.adapter.changeCursor(loader.getCursor());
            this.adapter.setOnErrorListener(new GraphObjectAdapter.OnErrorListener() {
                @Override
                public void onError(GraphObjectAdapter adapter, FacebookException error) {
                    if (onErrorListener != null) {
                        onErrorListener.onError(PickerFragment.this, error);
                    }
                }
            });
        }

        public void detach() {
            adapter.setDataNeededListener(null);
            adapter.setOnErrorListener(null);
            loader.setOnErrorListener(null);

            loader = null;
            adapter = null;
        }

        public void clearResults() {
            if (loader != null) {
                loader.clearResults();
            }
        }

        public void startLoading(GraphRequest request) {
            if (loader != null) {
                loader.startLoading(request);
                onStartLoading(loader, request);
            }
        }

        public boolean isDataPresentOrLoading() {
            return !adapter.isEmpty() || loader.isLoading();
        }

        protected GraphObjectPagingLoader onCreateLoader() {
            return new GraphObjectPagingLoader(getActivity());
        }

        protected void onStartLoading(GraphObjectPagingLoader loader, GraphRequest request) {
            displayActivityCircle();
        }

        protected void onLoadReset(GraphObjectPagingLoader loader) {
            adapter.changeCursor(null);
        }

        protected void onLoadFinished(GraphObjectPagingLoader loader, GraphObjectCursor data) {
            updateAdapter(data);
        }
    }

    abstract class SelectionStrategy {
        abstract boolean isSelected(String id);

        abstract void toggleSelection(String id);

        abstract Collection<String> getSelectedIds();

        abstract void clear();

        abstract boolean isEmpty();

        abstract boolean shouldShowCheckBoxIfUnselected();

        abstract void saveSelectionToBundle(Bundle outBundle, String key);

        abstract void readSelectionFromBundle(Bundle inBundle, String key);
    }

    class SingleSelectionStrategy extends SelectionStrategy {
        private String selectedId;

        public Collection<String> getSelectedIds() {
            return Arrays.asList(new String[]{selectedId});
        }

        @Override
        boolean isSelected(String id) {
            return selectedId != null && id != null && selectedId.equals(id);
        }

        @Override
        void toggleSelection(String id) {
            if (selectedId != null && selectedId.equals(id)) {
                selectedId = null;
            } else {
                selectedId = id;
            }
        }

        @Override
        void saveSelectionToBundle(Bundle outBundle, String key) {
            if (!TextUtils.isEmpty(selectedId)) {
                outBundle.putString(key, selectedId);
            }
        }

        @Override
        void readSelectionFromBundle(Bundle inBundle, String key) {
            if (inBundle != null) {
                selectedId = inBundle.getString(key);
            }
        }

        @Override
        public void clear() {
            selectedId = null;
        }

        @Override
        boolean isEmpty() {
            return selectedId == null;
        }

        @Override
        boolean shouldShowCheckBoxIfUnselected() {
            return false;
        }
    }

    class MultiSelectionStrategy extends SelectionStrategy {
        private Set<String> selectedIds = new HashSet<String>();

        public Collection<String> getSelectedIds() {
            return selectedIds;
        }

        @Override
        boolean isSelected(String id) {
            return id != null && selectedIds.contains(id);
        }

        @Override
        void toggleSelection(String id) {
            if (id != null) {
                if (selectedIds.contains(id)) {
                    selectedIds.remove(id);
                } else {
                    selectedIds.add(id);
                }
            }
        }

        @Override
        void saveSelectionToBundle(Bundle outBundle, String key) {
            if (!selectedIds.isEmpty()) {
                String ids = TextUtils.join(",", selectedIds);
                outBundle.putString(key, ids);
            }
        }

        @Override
        void readSelectionFromBundle(Bundle inBundle, String key) {
            if (inBundle != null) {
                String ids = inBundle.getString(key);
                if (ids != null) {
                    String[] splitIds = TextUtils.split(ids, ",");
                    selectedIds.clear();
                    Collections.addAll(selectedIds, splitIds);
                }
            }
        }

        @Override
        public void clear() {
            selectedIds.clear();
        }

        @Override
        boolean isEmpty() {
            return selectedIds.isEmpty();
        }

        @Override
        boolean shouldShowCheckBoxIfUnselected() {
            return true;
        }
    }

    abstract class PickerFragmentAdapter extends GraphObjectAdapter {
        public PickerFragmentAdapter(Context context) {
            super(context);
        }

        @Override
        boolean isGraphObjectSelected(String graphObjectId) {
            return selectionStrategy.isSelected(graphObjectId);
        }

        @Override
        void updateCheckboxState(CheckBox checkBox, boolean graphObjectSelected) {
            checkBox.setChecked(graphObjectSelected);
            int visible = (graphObjectSelected || selectionStrategy.shouldShowCheckBoxIfUnselected())
                    ? View.VISIBLE : View.GONE;
            checkBox.setVisibility(visible);
        }
    }
}

<code block>


package com.example.scrumptious.picker;

import android.content.Context;
import android.support.v4.content.Loader;
import com.facebook.*;
import org.json.JSONArray;

class GraphObjectPagingLoader extends Loader<GraphObjectCursor> {
    private GraphRequest originalRequest;
    private GraphRequest currentRequest;
    private GraphRequest nextRequest;
    private OnErrorListener onErrorListener;
    private GraphObjectCursor cursor;
    private boolean appendResults = false;
    private boolean loading = false;

    public interface OnErrorListener {
        public void onError(FacebookException error, GraphObjectPagingLoader loader);
    }

    public GraphObjectPagingLoader(Context context) {
        super(context);
    }

    public OnErrorListener getOnErrorListener() {
        return onErrorListener;
    }

    public void setOnErrorListener(OnErrorListener listener) {
        this.onErrorListener = listener;
    }

    public GraphObjectCursor getCursor() {
        return cursor;
    }

    public void clearResults() {
        nextRequest = null;
        originalRequest = null;
        currentRequest = null;

        deliverResult(null);
    }

    public boolean isLoading() {
        return loading;
    }

    public void startLoading(GraphRequest request) {
        appendResults = false;
        nextRequest = null;
        currentRequest = request;
        currentRequest.setCallback(new GraphRequest.Callback() {
            @Override
            public void onCompleted(GraphResponse response) {
                requestCompleted(response);
            }
        });

        loading = true;
        final GraphRequestBatch batch = new GraphRequestBatch(request);
        GraphRequest.executeBatchAsync(batch);
    }

    public void followNextLink() {
        if (nextRequest != null) {
            appendResults = true;
            currentRequest = nextRequest;

            currentRequest.setCallback(new GraphRequest.Callback() {
                @Override
                public void onCompleted(GraphResponse response) {
                    requestCompleted(response);
                }
            });

            loading = true;
            GraphRequest.executeBatchAsync(new GraphRequestBatch(currentRequest));
        }
    }

    @Override
    public void deliverResult(GraphObjectCursor cursor) {
        GraphObjectCursor oldCursor = this.cursor;
        this.cursor = cursor;

        if (isStarted()) {
            super.deliverResult(cursor);

            if (oldCursor != null && oldCursor != cursor && !oldCursor.isClosed()) {
                oldCursor.close();
            }
        }
    }

    @Override
    protected void onStartLoading() {
        super.onStartLoading();

        if (cursor != null) {
            deliverResult(cursor);
        }
    }

    private void requestCompleted(GraphResponse response) {
        GraphRequest request = response.getRequest();
        if (request != currentRequest) {
            return;
        }

        loading = false;
        currentRequest = null;

        FacebookRequestError requestError = response.getError();
        FacebookException exception = (requestError == null) ? null : requestError.getException();
        if (response.getJSONObject() == null && exception == null) {
            exception = new FacebookException("GraphObjectPagingLoader received neither a result nor an error.");
        }

        if (exception != null) {
            nextRequest = null;

            if (onErrorListener != null) {
                onErrorListener.onError(exception, this);
            }
        } else {
            addResults(response);
        }
    }

    private void addResults(GraphResponse response) {
        GraphObjectCursor cursorToModify = (cursor == null || !appendResults) ? new GraphObjectCursor() :
                new GraphObjectCursor(cursor);

        JSONArray data = response.getJSONObject().optJSONArray("data");

        boolean haveData = data.length() > 0;

        if (haveData) {
            nextRequest = response.getRequestForPagedResults(GraphResponse.PagingDirection.NEXT);
            cursorToModify.addGraphObjects(data);
        } else {
            nextRequest = null;
        }
        cursorToModify.setMoreObjectsAvailable(nextRequest != null);

        deliverResult(cursorToModify);
    }
}

<code block>


package com.example.scrumptious.picker;

import android.database.CursorIndexOutOfBoundsException;
import org.json.JSONArray;
import org.json.JSONObject;

import java.util.ArrayList;
import java.util.List;

class GraphObjectCursor {
    private int pos = -1;
    private boolean closed = false;
    private List<JSONObject> graphObjects = new ArrayList<JSONObject>();
    private boolean moreObjectsAvailable = false;

    GraphObjectCursor() {
    }

    GraphObjectCursor(GraphObjectCursor other) {
        pos = other.pos;
        closed = other.closed;
        graphObjects = new ArrayList<JSONObject>();
        graphObjects.addAll(other.graphObjects);

        
    }

    public void addGraphObjects(JSONArray graphObjects) {
        for (int i = 0; i < graphObjects.length(); ++i) {
            this.graphObjects.add(graphObjects.optJSONObject(i));
        }
    }

    public boolean areMoreObjectsAvailable() {
        return moreObjectsAvailable;
    }

    public void setMoreObjectsAvailable(boolean moreObjectsAvailable) {
        this.moreObjectsAvailable = moreObjectsAvailable;
    }

    public int getCount() {
        return graphObjects.size();
    }

    public int getPosition() {
        return pos;
    }

    public boolean move(int offset) {
        return moveToPosition(pos + offset);
    }

    public boolean moveToPosition(int position) {
        final int count = getCount();
        if (position >= count) {
            pos = count;
            return false;
        }

        if (position < 0) {
            pos = -1;
            return false;
        }

        pos = position;
        return true;
    }

    public boolean moveToFirst() {
        return moveToPosition(0);
    }

    public boolean moveToLast() {
        return moveToPosition(getCount() - 1);
    }

    public boolean moveToNext() {
        return moveToPosition(pos + 1);
    }

    public boolean moveToPrevious() {
        return moveToPosition(pos - 1);
    }

    public boolean isFirst() {
        return (pos == 0) && (getCount() != 0);
    }

    public boolean isLast() {
        final int count = getCount();
        return (pos == (count - 1)) && (count != 0);
    }

    public boolean isBeforeFirst() {
        return (getCount() == 0) || (pos == -1);
    }

    public boolean isAfterLast() {
        final int count = getCount();
        return (count == 0) || (pos == count);
    }

    public JSONObject getGraphObject() {
        if (pos < 0) {
            throw new CursorIndexOutOfBoundsException("Before first object.");
        }
        if (pos >= graphObjects.size()) {
            throw new CursorIndexOutOfBoundsException("After last object.");
        }
        return graphObjects.get(pos);
    }

    public void close() {
        closed = true;
    }

    public boolean isClosed() {
        return closed;
    }

}

<code block>


package com.example.scrumptious.picker;

import android.app.Activity;
import android.content.res.TypedArray;
import android.os.Bundle;
import android.text.TextUtils;
import android.util.AttributeSet;

import com.facebook.AccessToken;
import com.facebook.GraphRequest;
import com.facebook.appevents.AppEventsLogger;
import com.facebook.FacebookException;
import com.example.scrumptious.R;
import com.facebook.internal.AnalyticsEvents;
import com.facebook.internal.Validate;

import org.json.JSONObject;

import java.util.*;


public class FriendPickerFragment extends PickerFragment {
    
    public static final String USER_ID_BUNDLE_KEY = "com.example.scrumptious.widget.FriendPickerFragment.UserId";
    
    public static final String MULTI_SELECT_BUNDLE_KEY = "com.example.scrumptious.widget.FriendPickerFragment.MultiSelect";
    
    public static final String FRIEND_PICKER_TYPE_KEY = "com.example.scrumptious.widget.FriendPickerFragment.FriendPickerType";

    public enum FriendPickerType {
        FRIENDS("/friends"),
        TAGGABLE_FRIENDS("/taggable_friends"),
        INVITABLE_FRIENDS("/invitable_friends");

        private final String requestPath;

        FriendPickerType(String path) {
            this.requestPath = path;
        }

        String getRequestPath() {
            return requestPath;
        }
    }

    private static final String ID = "id";
    private static final String NAME = "name";

    private String userId;

    private boolean multiSelect = true;

    
    private FriendPickerType friendPickerType = FriendPickerType.FRIENDS;

    private List<String> preSelectedFriendIds = new ArrayList<String>();

    
    public FriendPickerFragment() {
        super(R.layout.picker_friendpickerfragment);
    }

    
    public String getUserId() {
        return userId;
    }

    
    public void setUserId(String userId) {
        this.userId = userId;
    }

    
    public boolean getMultiSelect() {
        return multiSelect;
    }

    
    public void setMultiSelect(boolean multiSelect) {
        if (this.multiSelect != multiSelect) {
            this.multiSelect = multiSelect;
            setSelectionStrategy(createSelectionStrategy());
        }
    }

    
    public void setFriendPickerType(FriendPickerType type) {
        this.friendPickerType = type;
    }

    
    public void setSelectionByIds(List<String> userIds) {
        preSelectedFriendIds.addAll(userIds);
    }

    
    public void setSelectionByIds(String... userIds) {
        setSelectionByIds(Arrays.asList(userIds));
    }

    
    public void setSelection(JSONObject... graphUsers) {
        setSelection(Arrays.asList(graphUsers));
    }

    
    public void setSelection(List<JSONObject> graphUsers) {
        List<String> userIds = new ArrayList<String>();
        for(JSONObject graphUser: graphUsers) {
            String id = graphUser.optString("id");
            Validate.notNullOrEmpty(id, "id");
            userIds.add(id);
        }
        setSelectionByIds(userIds);
    }

    
    public List<JSONObject> getSelection() {
        return getSelectedGraphObjects();
    }

    @Override
    public void onInflate(Activity activity, AttributeSet attrs, Bundle savedInstanceState) {
        super.onInflate(activity, attrs, savedInstanceState);
        TypedArray a = activity.obtainStyledAttributes(attrs, R.styleable.picker_friend_picker_fragment);

        setMultiSelect(a.getBoolean(R.styleable.picker_friend_picker_fragment_multi_select, multiSelect));

        a.recycle();
    }

    @Override
    public void setSettingsFromBundle(Bundle inState) {
        super.setSettingsFromBundle(inState);
        if (inState != null) {
            if (inState.containsKey(USER_ID_BUNDLE_KEY)) {
                setUserId(inState.getString(USER_ID_BUNDLE_KEY));
            }
            setMultiSelect(inState.getBoolean(MULTI_SELECT_BUNDLE_KEY, multiSelect));
            if (inState.containsKey(FRIEND_PICKER_TYPE_KEY)) {
                try {
                    friendPickerType = FriendPickerType.valueOf(inState.getString(FRIEND_PICKER_TYPE_KEY));
                } catch (Exception e) {
                    
                }
            }
        }
    }

    void saveSettingsToBundle(Bundle outState) {
        super.saveSettingsToBundle(outState);

        outState.putString(USER_ID_BUNDLE_KEY, userId);
        outState.putBoolean(MULTI_SELECT_BUNDLE_KEY, multiSelect);
    }

    @Override
    PickerFragmentAdapter createAdapter() {
        PickerFragmentAdapter adapter = new PickerFragmentAdapter(this.getActivity()) {
            @Override
            protected int getGraphObjectRowLayoutId(JSONObject graphObject) {
                return R.layout.picker_list_row;
            }

            @Override
            protected int getDefaultPicture() {
                return R.drawable.profile_default_icon;
            }

        };
        adapter.setShowCheckbox(true);
        adapter.setShowPicture(getShowPictures());
        adapter.setSortFields(Arrays.asList(new String[]{NAME}));
        adapter.setGroupByField(NAME);

        return adapter;
    }

    @Override
    LoadingStrategy createLoadingStrategy() {
        return new ImmediateLoadingStrategy();
    }

    @Override
    SelectionStrategy createSelectionStrategy() {
        return multiSelect ? new MultiSelectionStrategy() : new SingleSelectionStrategy();
    }

    @Override
    GraphRequest getRequestForLoadData() {
        if (adapter == null) {
            throw new FacebookException("Can't issue requests until Fragment has been created.");
        }

        String userToFetch = (userId != null) ? userId : "me";
        return createRequest(userToFetch, extraFields);
    }

    @Override
    String getDefaultTitleText() {
        return getResources().getString(R.string.choose_friends);
    }

    @Override
    void logAppEvents(boolean doneButtonClicked) {
        AppEventsLogger logger = AppEventsLogger.newLogger(this.getActivity(),
                AccessToken.getCurrentAccessToken().getToken());
        Bundle parameters = new Bundle();

        
        
        
        String outcome = doneButtonClicked ? AnalyticsEvents.PARAMETER_DIALOG_OUTCOME_VALUE_COMPLETED :
                AnalyticsEvents.PARAMETER_DIALOG_OUTCOME_VALUE_UNKNOWN;
        parameters.putString(AnalyticsEvents.PARAMETER_DIALOG_OUTCOME, outcome);
        parameters.putInt("num_friends_picked", getSelection().size());

        logger.logSdkEvent(AnalyticsEvents.EVENT_FRIEND_PICKER_USAGE, null, parameters);
    }

    @Override
    public void loadData(boolean forceReload) {
        super.loadData(forceReload);
        setSelectedGraphObjects(preSelectedFriendIds);
    }

    private GraphRequest createRequest(String userID, Set<String> extraFields) {
        AccessToken accessToken = AccessToken.getCurrentAccessToken();
        GraphRequest request = GraphRequest.newGraphPathRequest(
                accessToken, userID + friendPickerType.getRequestPath(), null);

        Set<String> fields = new HashSet<String>(extraFields);
        String[] requiredFields = new String[]{
                ID,
                NAME
        };
        fields.addAll(Arrays.asList(requiredFields));

        String pictureField = adapter.getPictureFieldSpecifier();
        if (pictureField != null) {
            fields.add(pictureField);
        }

        Bundle parameters = request.getParameters();
        parameters.putString("fields", TextUtils.join(",", fields));
        request.setParameters(parameters);

        return request;
    }

    private class ImmediateLoadingStrategy extends LoadingStrategy {
        @Override
        protected void onLoadFinished(GraphObjectPagingLoader loader, GraphObjectCursor data) {
            super.onLoadFinished(loader, data);

            
            
            if (data == null || loader.isLoading()) {
                return;
            }

            if (data.areMoreObjectsAvailable()) {
                
                followNextLink();
            } else {
                
                hideActivityCircle();
            }
        }

        private void followNextLink() {
            
            displayActivityCircle();

            loader.followNextLink();
        }
    }
}

<code block>


package com.example.scrumptious.picker;

import android.content.Context;
import android.graphics.Bitmap;
import android.net.Uri;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewStub;
import android.widget.*;
import com.facebook.FacebookException;
import com.example.scrumptious.R;
import com.facebook.internal.ImageDownloader;
import com.facebook.internal.ImageRequest;
import com.facebook.internal.ImageResponse;
import com.facebook.internal.Utility;

import org.json.JSONObject;

import java.text.Collator;
import java.util.*;

class GraphObjectAdapter extends BaseAdapter implements SectionIndexer {
    private static final int DISPLAY_SECTIONS_THRESHOLD = 1;
    private static final int HEADER_VIEW_TYPE = 0;
    private static final int GRAPH_OBJECT_VIEW_TYPE = 1;
    private static final int ACTIVITY_CIRCLE_VIEW_TYPE = 2;
    private static final int MAX_PREFETCHED_PICTURES = 20;

    private static final String ID = "id";
    private static final String NAME = "name";
    private static final String PICTURE = "picture";

    private final Map<String, ImageRequest> pendingRequests = new HashMap<String, ImageRequest>();
    private final LayoutInflater inflater;
    private List<String> sectionKeys = new ArrayList<String>();
    private Map<String, ArrayList<JSONObject>> graphObjectsBySection = new HashMap<String, ArrayList<JSONObject>>();
    private Map<String, JSONObject> graphObjectsById = new HashMap<String, JSONObject>();
    private boolean displaySections;
    private List<String> sortFields;
    private String groupByField;
    private boolean showPicture;
    private boolean showCheckbox;
    private Filter filter;
    private DataNeededListener dataNeededListener;
    private GraphObjectCursor cursor;
    private Context context;
    private Map<String, ImageResponse> prefetchedPictureCache = new HashMap<String, ImageResponse>();
    private ArrayList<String> prefetchedProfilePictureIds = new ArrayList<String>();
    private OnErrorListener onErrorListener;

    public interface DataNeededListener {
        public void onDataNeeded();
    }

    public interface OnErrorListener {
        void onError(GraphObjectAdapter adapter, FacebookException error);
    }

    public static class SectionAndItem {
        public String sectionKey;
        public JSONObject graphObject;

        public enum Type {
            GRAPH_OBJECT,
            SECTION_HEADER,
            ACTIVITY_CIRCLE
        }

        public SectionAndItem(String sectionKey, JSONObject graphObject) {
            this.sectionKey = sectionKey;
            this.graphObject = graphObject;
        }

        public Type getType() {
            if (sectionKey == null) {
                return Type.ACTIVITY_CIRCLE;
            } else if (graphObject == null) {
                return Type.SECTION_HEADER;
            } else {
                return Type.GRAPH_OBJECT;
            }
        }
    }

    interface Filter {
        boolean includeItem(JSONObject graphObject);
    }

    public GraphObjectAdapter(Context context) {
        this.context = context;
        this.inflater = LayoutInflater.from(context);
    }

    public List<String> getSortFields() {
        return sortFields;
    }

    public void setSortFields(List<String> sortFields) {
        this.sortFields = sortFields;
    }

    public String getGroupByField() {
        return groupByField;
    }

    public void setGroupByField(String groupByField) {
        this.groupByField = groupByField;
    }

    public boolean getShowPicture() {
        return showPicture;
    }

    public void setShowPicture(boolean showPicture) {
        this.showPicture = showPicture;
    }

    public boolean getShowCheckbox() {
        return showCheckbox;
    }

    public void setShowCheckbox(boolean showCheckbox) {
        this.showCheckbox = showCheckbox;
    }

    public DataNeededListener getDataNeededListener() {
        return dataNeededListener;
    }

    public void setDataNeededListener(DataNeededListener dataNeededListener) {
        this.dataNeededListener = dataNeededListener;
    }

    public OnErrorListener getOnErrorListener() {
        return onErrorListener;
    }

    public void setOnErrorListener(OnErrorListener onErrorListener) {
        this.onErrorListener = onErrorListener;
    }

    public GraphObjectCursor getCursor() {
        return cursor;
    }

    public boolean changeCursor(GraphObjectCursor cursor) {
        if (this.cursor == cursor) {
            return false;
        }
        if (this.cursor != null) {
            this.cursor.close();
        }
        this.cursor = cursor;

        rebuildAndNotify();
        return true;
    }

    public void rebuildAndNotify() {
        rebuildSections();
        notifyDataSetChanged();
    }

    public void prioritizeViewRange(int firstVisibleItem, int lastVisibleItem, int prefetchBuffer) {
        if ((lastVisibleItem < firstVisibleItem) || (sectionKeys.size() == 0)) {
            return;
        }

        
        
        
        
        

        
        
        
        
        for (int i = lastVisibleItem; i >= 0; i--) {
            SectionAndItem sectionAndItem = getSectionAndItem(i);
            if (sectionAndItem.graphObject != null) {
                String id = getIdOfGraphObject(sectionAndItem.graphObject);
                ImageRequest request = pendingRequests.get(id);
                if (request != null) {
                    ImageDownloader.prioritizeRequest(request);
                }
            }
        }

        
        
        int start = Math.max(0, firstVisibleItem - prefetchBuffer);
        int end = Math.min(lastVisibleItem + prefetchBuffer, getCount() - 1);
        ArrayList<JSONObject> graphObjectsToPrefetchPicturesFor = new ArrayList<JSONObject>();
        
        for (int i = start; i < firstVisibleItem; ++i) {
            SectionAndItem sectionAndItem = getSectionAndItem(i);
            if (sectionAndItem.graphObject != null) {
                graphObjectsToPrefetchPicturesFor.add(sectionAndItem.graphObject);
            }
        }
        for (int i = lastVisibleItem + 1; i <= end; ++i) {
            SectionAndItem sectionAndItem = getSectionAndItem(i);
            if (sectionAndItem.graphObject != null) {
                graphObjectsToPrefetchPicturesFor.add(sectionAndItem.graphObject);
            }
        }
        for (JSONObject graphObject : graphObjectsToPrefetchPicturesFor) {
            Uri uri = getPictureUriOfGraphObject(graphObject);
            final String id = getIdOfGraphObject(graphObject);

            
            
            boolean alreadyPrefetching = prefetchedProfilePictureIds.remove(id);
            prefetchedProfilePictureIds.add(id);

            
            if (!alreadyPrefetching) {
                downloadProfilePicture(id, uri, null);
            }
        }
    }

    protected String getSectionKeyOfGraphObject(JSONObject graphObject) {
        String result = null;

        if (groupByField != null) {
            result = graphObject.optString(groupByField);
            if (result != null && result.length() > 0) {
                result = result.substring(0, 1).toUpperCase();
            }
        }

        return (result != null) ? result : "";
    }

    protected CharSequence getTitleOfGraphObject(JSONObject graphObject) {
        return graphObject.optString(NAME);
    }

    protected CharSequence getSubTitleOfGraphObject(JSONObject graphObject) {
        return null;
    }

    protected Uri getPictureUriOfGraphObject(JSONObject graphObject) {
        String uri = null;
        Object o = graphObject.opt(PICTURE);
        if (o instanceof String) {
            uri = (String) o;
        } else if (o instanceof JSONObject) {
            JSONObject data = ((JSONObject) o).optJSONObject("data");
            uri = data != null ? data.optString("url") : null;
        }

        if (uri != null) {
            return Uri.parse(uri);
        }
        return null;
    }

    protected View getSectionHeaderView(String sectionHeader, View convertView, ViewGroup parent) {
        TextView result = (TextView) convertView;

        if (result == null) {
            result = (TextView) inflater.inflate(R.layout.picker_list_section_header, null);
        }

        result.setText(sectionHeader);

        return result;
    }

    protected View getGraphObjectView(JSONObject graphObject, View convertView, ViewGroup parent) {
        View result = convertView;

        if (result == null) {
            result = createGraphObjectView(graphObject);
        }

        populateGraphObjectView(result, graphObject);
        return result;
    }

    private View getActivityCircleView(View convertView, ViewGroup parent) {
        View result = convertView;

        if (result == null) {
            result = inflater.inflate(R.layout.picker_activity_circle_row, null);
        }
        ProgressBar activityCircle = (ProgressBar) result.findViewById(R.id.com_facebook_picker_row_activity_circle);
        activityCircle.setVisibility(View.VISIBLE);

        return result;
    }

    protected int getGraphObjectRowLayoutId(JSONObject graphObject) {
        return R.layout.picker_list_row;
    }

    protected int getDefaultPicture() {
        return R.drawable.profile_default_icon;
    }

    protected View createGraphObjectView(JSONObject graphObject) {
        View result = inflater.inflate(getGraphObjectRowLayoutId(graphObject), null);

        ViewStub checkboxStub = (ViewStub) result.findViewById(R.id.com_facebook_picker_checkbox_stub);
        if (checkboxStub != null) {
            if (!getShowCheckbox()) {
                checkboxStub.setVisibility(View.GONE);
            } else {
                CheckBox checkBox = (CheckBox) checkboxStub.inflate();
                updateCheckboxState(checkBox, false);
            }
        }

        ViewStub profilePicStub = (ViewStub) result.findViewById(R.id.com_facebook_picker_profile_pic_stub);
        if (!getShowPicture()) {
            profilePicStub.setVisibility(View.GONE);
        } else {
            ImageView imageView = (ImageView) profilePicStub.inflate();
            imageView.setVisibility(View.VISIBLE);
        }

        return result;
    }

    protected void populateGraphObjectView(View view, JSONObject graphObject) {
        String id = getIdOfGraphObject(graphObject);
        view.setTag(id);

        CharSequence title = getTitleOfGraphObject(graphObject);
        TextView titleView = (TextView) view.findViewById(R.id.com_facebook_picker_title);
        if (titleView != null) {
            titleView.setText(title, TextView.BufferType.SPANNABLE);
        }

        CharSequence subtitle = getSubTitleOfGraphObject(graphObject);
        TextView subtitleView = (TextView) view.findViewById(R.id.picker_subtitle);
        if (subtitleView != null) {
            if (subtitle != null) {
                subtitleView.setText(subtitle, TextView.BufferType.SPANNABLE);
                subtitleView.setVisibility(View.VISIBLE);
            } else {
                subtitleView.setVisibility(View.GONE);
            }
        }

        if (getShowCheckbox()) {
            CheckBox checkBox = (CheckBox) view.findViewById(R.id.com_facebook_picker_checkbox);
            updateCheckboxState(checkBox, isGraphObjectSelected(id));
        }

        if (getShowPicture()) {
            Uri pictureURI = getPictureUriOfGraphObject(graphObject);

            if (pictureURI != null) {
                ImageView profilePic = (ImageView) view.findViewById(R.id.com_facebook_picker_image);

                
                if (prefetchedPictureCache.containsKey(id)) {
                    ImageResponse response = prefetchedPictureCache.get(id);
                    profilePic.setImageBitmap(response.getBitmap());
                    profilePic.setTag(response.getRequest().getImageUri());
                } else {
                    downloadProfilePicture(id, pictureURI, profilePic);
                }
            }
        }
    }

    
    String getIdOfGraphObject(JSONObject graphObject) {
        String id = graphObject.optString(ID);
        if (id != null) {
            return id;
        }
        throw new FacebookException("Received an object without an ID.");
    }

    boolean filterIncludesItem(JSONObject graphObject) {
        return filter == null || filter.includeItem(graphObject);
    }

    Filter getFilter() {
        return filter;
    }

    void setFilter(Filter filter) {
        this.filter = filter;
    }

    boolean isGraphObjectSelected(String graphObjectId) {
        return false;
    }

    void updateCheckboxState(CheckBox checkBox, boolean graphObjectSelected) {
        
    }

    String getPictureFieldSpecifier() {
        
        View view = createGraphObjectView(null);
        ImageView picture = (ImageView) view.findViewById(R.id.com_facebook_picker_image);
        if (picture == null) {
            return null;
        }

        
        ViewGroup.LayoutParams layoutParams = picture.getLayoutParams();
        return String.format(Locale.US, "picture.height(%d).width(%d)", layoutParams.height, layoutParams.width);
    }


    private boolean shouldShowActivityCircleCell() {
        
        
        return (cursor != null) && cursor.areMoreObjectsAvailable() && (dataNeededListener != null) && !isEmpty();
    }

    private void rebuildSections() {
        sectionKeys = new ArrayList<String>();
        graphObjectsBySection = new HashMap<String, ArrayList<JSONObject>>();
        graphObjectsById = new HashMap<String, JSONObject>();
        displaySections = false;

        if (cursor == null || cursor.getCount() == 0) {
            return;
        }

        int objectsAdded = 0;
        cursor.moveToFirst();
        do {
            JSONObject graphObject = cursor.getGraphObject();

            if (!filterIncludesItem(graphObject)) {
                continue;
            }

            objectsAdded++;

            String sectionKeyOfItem = getSectionKeyOfGraphObject(graphObject);
            if (!graphObjectsBySection.containsKey(sectionKeyOfItem)) {
                sectionKeys.add(sectionKeyOfItem);
                graphObjectsBySection.put(sectionKeyOfItem, new ArrayList<JSONObject>());
            }
            List<JSONObject> section = graphObjectsBySection.get(sectionKeyOfItem);
            section.add(graphObject);

            graphObjectsById.put(getIdOfGraphObject(graphObject), graphObject);
        } while (cursor.moveToNext());

        if (sortFields != null) {
            final Collator collator = Collator.getInstance();
            for (List<JSONObject> section : graphObjectsBySection.values()) {
                Collections.sort(section, new Comparator<JSONObject>() {
                    @Override
                    public int compare(JSONObject a, JSONObject b) {
                        return compareGraphObjects(a, b, sortFields, collator);
                    }
                });
            }
        }

        Collections.sort(sectionKeys, Collator.getInstance());

        displaySections = sectionKeys.size() > 1 && objectsAdded > DISPLAY_SECTIONS_THRESHOLD;
    }

    SectionAndItem getSectionAndItem(int position) {
        if (sectionKeys.size() == 0) {
            return null;
        }
        String sectionKey = null;
        JSONObject graphObject = null;

        if (!displaySections) {
            sectionKey = sectionKeys.get(0);
            List<JSONObject> section = graphObjectsBySection.get(sectionKey);
            if (position >= 0 && position < section.size()) {
                graphObject = graphObjectsBySection.get(sectionKey).get(position);
            } else {
                
                assert dataNeededListener != null && cursor.areMoreObjectsAvailable();
                
                return new SectionAndItem(null, null);
            }
        } else {
            
            
            for (String key : sectionKeys) {
                
                if (position-- == 0) {
                    sectionKey = key;
                    break;
                }

                List<JSONObject> section = graphObjectsBySection.get(key);
                if (position < section.size()) {
                    
                    sectionKey = key;
                    graphObject = section.get(position);
                    break;
                }
                
                position -= section.size();
            }
        }
        if (sectionKey != null) {
            
            return new SectionAndItem(sectionKey, graphObject);
        } else {
            throw new IndexOutOfBoundsException("position");
        }
    }

    int getPosition(String sectionKey, JSONObject graphObject) {
        int position = 0;
        boolean found = false;

        
        
        for (String key : sectionKeys) {
            if (displaySections) {
                position++;
            }
            if (key.equals(sectionKey)) {
                found = true;
                break;
            } else {
                position += graphObjectsBySection.get(key).size();
            }
        }

        if (!found) {
            return -1;
        } else if (graphObject == null) {
            
            
            return position - (displaySections ? 1 : 0);
        }

        
        for (JSONObject t : graphObjectsBySection.get(sectionKey)) {
            if (Utility.hasSameId(t, graphObject)) {
                return position;
            }
            position++;
        }
        return -1;
    }

    @Override
    public boolean isEmpty() {
        
        return sectionKeys.size() == 0;
    }

    @Override
    public int getCount() {
        if (sectionKeys.size() == 0) {
            return 0;
        }

        
        
        int count = (displaySections) ? sectionKeys.size() : 0;
        for (List<JSONObject> section : graphObjectsBySection.values()) {
            count += section.size();
        }

        
        if (shouldShowActivityCircleCell()) {
            ++count;
        }

        return count;
    }

    @Override
    public boolean areAllItemsEnabled() {
        return displaySections;
    }

    @Override
    public boolean hasStableIds() {
        return true;
    }

    @Override
    public boolean isEnabled(int position) {
        SectionAndItem sectionAndItem = getSectionAndItem(position);
        return sectionAndItem.getType() == SectionAndItem.Type.GRAPH_OBJECT;
    }

    @Override
    public Object getItem(int position) {
        SectionAndItem sectionAndItem = getSectionAndItem(position);
        return (sectionAndItem.getType() == SectionAndItem.Type.GRAPH_OBJECT) ? sectionAndItem.graphObject : null;
    }

    @Override
    public long getItemId(int position) {
        
        
        
        SectionAndItem sectionAndItem = getSectionAndItem(position);
        if (sectionAndItem != null && sectionAndItem.graphObject != null) {
            String id = getIdOfGraphObject(sectionAndItem.graphObject);
            if (id != null) {
                try {
                    return Long.parseLong(id);
                } catch (NumberFormatException e) {
                    
                }
            }
        }
        return 0;
    }

    @Override
    public int getViewTypeCount() {
        return 3;
    }

    @Override
    public int getItemViewType(int position) {
        SectionAndItem sectionAndItem = getSectionAndItem(position);
        switch (sectionAndItem.getType()) {
            case SECTION_HEADER:
                return HEADER_VIEW_TYPE;
            case GRAPH_OBJECT:
                return GRAPH_OBJECT_VIEW_TYPE;
            case ACTIVITY_CIRCLE:
                return ACTIVITY_CIRCLE_VIEW_TYPE;
            default:
                throw new FacebookException("Unexpected type of section and item.");
        }
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        SectionAndItem sectionAndItem = getSectionAndItem(position);

        switch (sectionAndItem.getType()) {
            case SECTION_HEADER:
                return getSectionHeaderView(sectionAndItem.sectionKey, convertView, parent);
            case GRAPH_OBJECT:
                return getGraphObjectView(sectionAndItem.graphObject, convertView, parent);
            case ACTIVITY_CIRCLE:
                
                assert cursor.areMoreObjectsAvailable() && (dataNeededListener != null);
                dataNeededListener.onDataNeeded();
                return getActivityCircleView(convertView, parent);
            default:
                throw new FacebookException("Unexpected type of section and item.");
        }
    }

    @Override
    public Object[] getSections() {
        if (displaySections) {
            return sectionKeys.toArray();
        } else {
            return new Object[0];
        }
    }

    @Override
    public int getPositionForSection(int section) {
        if (displaySections) {
            section = Math.max(0, Math.min(section, sectionKeys.size() - 1));
            if (section < sectionKeys.size()) {
                return getPosition(sectionKeys.get(section), null);
            }
        }
        return 0;
    }

    @Override
    public int getSectionForPosition(int position) {
        SectionAndItem sectionAndItem = getSectionAndItem(position);
        if (sectionAndItem != null &&
                sectionAndItem.getType() != SectionAndItem.Type.ACTIVITY_CIRCLE) {
            return Math.max(0, Math.min(sectionKeys.indexOf(sectionAndItem.sectionKey), sectionKeys.size() - 1));
        }
        return 0;
    }

    public List<JSONObject> getGraphObjectsById(Collection<String> ids) {
        Set<String> idSet = new HashSet<String>();
        idSet.addAll(ids);

        ArrayList<JSONObject> result = new ArrayList<JSONObject>(idSet.size());
        for (String id : idSet) {
            JSONObject graphObject = graphObjectsById.get(id);
            if (graphObject != null) {
                result.add(graphObject);
            }
        }

        return result;
    }

    private void downloadProfilePicture(
            final String profileId,
            Uri pictureUri,
            final ImageView imageView) {
        if (pictureUri == null) {
            return;
        }

        
        
        
        
        boolean prefetching = imageView == null;
        if (prefetching || !pictureUri.equals(imageView.getTag())) {
            if (!prefetching) {
                
                
                imageView.setTag(profileId);
                imageView.setImageResource(getDefaultPicture());
            }

            ImageRequest.Builder builder = new ImageRequest.Builder(
                    context.getApplicationContext(),
                    pictureUri)
                    .setCallerTag(this)
                    .setCallback(
                            new ImageRequest.Callback() {
                                @Override
                                public void onCompleted(ImageResponse response) {
                                    processImageResponse(response, profileId, imageView);
                                }
                            });

            ImageRequest newRequest = builder.build();
            pendingRequests.put(profileId, newRequest);

            ImageDownloader.downloadAsync(newRequest);
        }
    }

    private void callOnErrorListener(Exception exception) {
        if (onErrorListener != null) {
            if (!(exception instanceof FacebookException)) {
                exception = new FacebookException(exception);
            }
            onErrorListener.onError(this, (FacebookException) exception);
        }
    }

    private void processImageResponse(ImageResponse response, String graphObjectId, ImageView imageView) {
        pendingRequests.remove(graphObjectId);
        if (response.getError() != null) {
            callOnErrorListener(response.getError());
        }

        if (imageView == null) {
            
            if (response.getBitmap() != null) {
                
                if (prefetchedPictureCache.size() >= MAX_PREFETCHED_PICTURES) {
                    
                    String oldestId = prefetchedProfilePictureIds.remove(0);
                    prefetchedPictureCache.remove(oldestId);
                }
                prefetchedPictureCache.put(graphObjectId, response);
            }
        } else if (graphObjectId.equals(imageView.getTag())) {
            Exception error = response.getError();
            Bitmap bitmap = response.getBitmap();
            if (error == null && bitmap != null) {
                imageView.setImageBitmap(bitmap);
                imageView.setTag(response.getRequest().getImageUri());
            }
        }
    }

    private static int compareGraphObjects(JSONObject a, JSONObject b, Collection<String> sortFields,
            Collator collator) {
        for (String sortField : sortFields) {
            String sa = a.optString(sortField);
            String sb = b.optString(sortField);

            if (sa != null && sb != null) {
                int result = collator.compare(sa, sb);
                if (result != 0) {
                    return result;
                }
            } else if (!(sa == null && sb == null)) {
                return (sa == null) ? -1 : 1;
            }
        }
        return 0;
    }
}

<code block>


package com.example.scrumptious.picker;

import android.app.Activity;
import android.content.Context;
import android.content.res.TypedArray;
import android.location.Location;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.text.Editable;
import android.text.TextUtils;
import android.text.TextWatcher;
import android.util.AttributeSet;
import android.view.View;
import android.view.ViewGroup;
import android.view.inputmethod.InputMethodManager;
import android.widget.EditText;
import android.widget.ListView;
import com.facebook.*;
import com.facebook.appevents.AppEventsLogger;
import com.example.scrumptious.R;
import com.facebook.internal.AnalyticsEvents;
import com.facebook.internal.Logger;
import com.facebook.internal.Utility;

import org.json.JSONObject;

import java.util.*;

public class PlacePickerFragment extends PickerFragment {
    
    public static final String RADIUS_IN_METERS_BUNDLE_KEY = "com.example.scrumptious.widget.PlacePickerFragment.RadiusInMeters";
    
    public static final String RESULTS_LIMIT_BUNDLE_KEY = "com.example.scrumptious.widget.PlacePickerFragment.ResultsLimit";
    
    public static final String SEARCH_TEXT_BUNDLE_KEY = "com.example.scrumptious.widget.PlacePickerFragment.SearchText";
    
    public static final String LOCATION_BUNDLE_KEY = "com.example.scrumptious.widget.PlacePickerFragment.Location";
    
    public static final String SHOW_SEARCH_BOX_BUNDLE_KEY = "com.example.scrumptious.widget.PlacePickerFragment.ShowSearchBox";

    
    public static final int DEFAULT_RADIUS_IN_METERS = 1000;
    
    public static final int DEFAULT_RESULTS_LIMIT = 100;

    private static final int searchTextTimerDelayInMilliseconds = 2 * 1000;

    private static final String ID = "id";
    private static final String NAME = "name";
    private static final String LOCATION = "location";
    private static final String CATEGORY = "category";
    private static final String WERE_HERE_COUNT = "were_here_count";
    private static final String TAG = "PlacePickerFragment";

    private Location location;
    private int radiusInMeters = DEFAULT_RADIUS_IN_METERS;
    private int resultsLimit = DEFAULT_RESULTS_LIMIT;
    private String searchText;
    private Timer searchTextTimer;
    private boolean hasSearchTextChangedSinceLastQuery;
    private boolean showSearchBox = true;
    private EditText searchBox;

    
    public PlacePickerFragment() {
        super(R.layout.picker_placepickerfragment);
    }

    
    public Location getLocation() {
        return location;
    }

    
    public void setLocation(Location location) {
        this.location = location;
    }

    
    public int getRadiusInMeters() {
        return radiusInMeters;
    }

    
    public void setRadiusInMeters(int radiusInMeters) {
        this.radiusInMeters = radiusInMeters;
    }

    
    public int getResultsLimit() {
        return resultsLimit;
    }

    
    public void setResultsLimit(int resultsLimit) {
        this.resultsLimit = resultsLimit;
    }

    
    public String getSearchText() {
        return searchText;
    }

    
    public void setSearchText(String searchText) {
        if (TextUtils.isEmpty(searchText)) {
            searchText = null;
        }
        this.searchText = searchText;
        if (this.searchBox != null) {
            this.searchBox.setText(searchText);
        }
    }

    
    public void onSearchBoxTextChanged(String searchText, boolean forceReloadEventIfSameText) {
        if (!forceReloadEventIfSameText && Utility.stringsEqualOrEmpty(this.searchText, searchText)) {
            return;
        }

        if (TextUtils.isEmpty(searchText)) {
            searchText = null;
        }
        this.searchText = searchText;

        
        
        
        
        hasSearchTextChangedSinceLastQuery = true;
        if (searchTextTimer == null) {
            searchTextTimer = createSearchTextTimer();
        }
    }

    
    public JSONObject getSelection() {
        Collection<JSONObject> selection = getSelectedGraphObjects();
        return (selection != null && !selection.isEmpty()) ? selection.iterator().next() : null;
    }

    @Override
    public void setSettingsFromBundle(Bundle inState) {
        super.setSettingsFromBundle(inState);
        if (inState != null) {
            setRadiusInMeters(inState.getInt(RADIUS_IN_METERS_BUNDLE_KEY, radiusInMeters));
            setResultsLimit(inState.getInt(RESULTS_LIMIT_BUNDLE_KEY, resultsLimit));
            if (inState.containsKey(SEARCH_TEXT_BUNDLE_KEY)) {
                setSearchText(inState.getString(SEARCH_TEXT_BUNDLE_KEY));
            }
            if (inState.containsKey(LOCATION_BUNDLE_KEY)) {
                Location location = inState.getParcelable(LOCATION_BUNDLE_KEY);
                setLocation(location);
            }
            showSearchBox = inState.getBoolean(SHOW_SEARCH_BOX_BUNDLE_KEY, showSearchBox);
        }
    }

    @Override
    public void onInflate(Activity activity, AttributeSet attrs, Bundle savedInstanceState) {
        super.onInflate(activity, attrs, savedInstanceState);
        TypedArray a = activity.obtainStyledAttributes(attrs, R.styleable.picker_place_picker_fragment);

        setRadiusInMeters(a.getInt(R.styleable.picker_place_picker_fragment_radius_in_meters, radiusInMeters));
        setResultsLimit(a.getInt(R.styleable.picker_place_picker_fragment_results_limit, resultsLimit));
        if (a.hasValue(R.styleable.picker_place_picker_fragment_results_limit)) {
            setSearchText(a.getString(R.styleable.picker_place_picker_fragment_search_text));
        }
        showSearchBox = a.getBoolean(R.styleable.picker_place_picker_fragment_show_search_box, showSearchBox);

        a.recycle();
    }

    @Override
    void setupViews(ViewGroup view) {
        if (showSearchBox) {
            ListView listView = (ListView) view.findViewById(R.id.com_facebook_picker_list_view);

            View searchHeaderView = getActivity().getLayoutInflater().inflate(
                    R.layout.picker_search_box, listView, false);

            listView.addHeaderView(searchHeaderView, null, false);

            searchBox = (EditText) view.findViewById(R.id.com_facebook_picker_search_text);

            searchBox.addTextChangedListener(new SearchTextWatcher());
            if (!TextUtils.isEmpty(searchText)) {
                searchBox.setText(searchText);
            }
        }
    }

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);

        if (searchBox != null) {
            InputMethodManager imm = (InputMethodManager)getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);
            imm.showSoftInput(searchBox, InputMethodManager.SHOW_IMPLICIT);
        }
    }

    @Override
    public void onDetach() {
        super.onDetach();

        if (searchBox != null) {
            InputMethodManager imm = (InputMethodManager)getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);
            imm.hideSoftInputFromWindow(searchBox.getWindowToken(), 0);
        }
    }

    void saveSettingsToBundle(Bundle outState) {
        super.saveSettingsToBundle(outState);

        outState.putInt(RADIUS_IN_METERS_BUNDLE_KEY, radiusInMeters);
        outState.putInt(RESULTS_LIMIT_BUNDLE_KEY, resultsLimit);
        outState.putString(SEARCH_TEXT_BUNDLE_KEY, searchText);
        outState.putParcelable(LOCATION_BUNDLE_KEY, location);
        outState.putBoolean(SHOW_SEARCH_BOX_BUNDLE_KEY, showSearchBox);
    }

    @Override
    void onLoadingData() {
        hasSearchTextChangedSinceLastQuery = false;
    }

    @Override
    GraphRequest getRequestForLoadData() {
        return createRequest(location, radiusInMeters, resultsLimit, searchText, extraFields);
    }

    @Override
    String getDefaultTitleText() {
        return getResources().getString(R.string.nearby);
    }

    @Override
    void logAppEvents(boolean doneButtonClicked) {
        AppEventsLogger logger = AppEventsLogger.newLogger(this.getActivity(),
                AccessToken.getCurrentAccessToken().getToken());
        Bundle parameters = new Bundle();

        
        
        
        String outcome = doneButtonClicked ? AnalyticsEvents.PARAMETER_DIALOG_OUTCOME_VALUE_COMPLETED :
                AnalyticsEvents.PARAMETER_DIALOG_OUTCOME_VALUE_UNKNOWN;
        parameters.putString(AnalyticsEvents.PARAMETER_DIALOG_OUTCOME, outcome);
        parameters.putInt("num_places_picked", (getSelection() != null) ? 1 : 0);

        logger.logSdkEvent(AnalyticsEvents.EVENT_PLACE_PICKER_USAGE, null, parameters);
    }

    @Override
    PickerFragmentAdapter createAdapter() {
        PickerFragmentAdapter adapter = new PickerFragmentAdapter(
                this.getActivity()) {
            @Override
            protected CharSequence getSubTitleOfGraphObject(JSONObject graphObject) {
                String category = graphObject.optString(CATEGORY);
                int wereHereCount = graphObject.optInt(WERE_HERE_COUNT);

                String result = null;
                if (category != null && wereHereCount != 0) {
                    result = getString(R.string.picker_placepicker_subtitle_format, category, wereHereCount);
                } else if (category == null && wereHereCount != 0) {
                    result = getString(R.string.picker_placepicker_subtitle_were_here_only_format, wereHereCount);
                } else if (category != null && wereHereCount == 0) {
                    result = getString(R.string.picker_placepicker_subtitle_catetory_only_format, category);
                }
                return result;
            }

            @Override
            protected int getGraphObjectRowLayoutId(JSONObject graphObject) {
                return R.layout.picker_placepickerfragment_list_row;
            }

            @Override
            protected int getDefaultPicture() {
                return R.drawable.picker_place_default_icon;
            }

        };
        adapter.setShowCheckbox(false);
        adapter.setShowPicture(getShowPictures());
        return adapter;
    }

    @Override
    LoadingStrategy createLoadingStrategy() {
        return new AsNeededLoadingStrategy();
    }

    @Override
    SelectionStrategy createSelectionStrategy() {
        return new SingleSelectionStrategy();
    }

    private GraphRequest createRequest(Location location, int radiusInMeters, int resultsLimit,
                                  String searchText, Set<String> extraFields) {
        AccessToken accessToken = AccessToken.getCurrentAccessToken();
        GraphRequest request = GraphRequest.newPlacesSearchRequest(accessToken, location, radiusInMeters,
                resultsLimit, searchText, null);

        Set<String> fields = new HashSet<String>(extraFields);
        String[] requiredFields = new String[]{
                ID,
                NAME,
                LOCATION,
                CATEGORY,
                WERE_HERE_COUNT
        };
        fields.addAll(Arrays.asList(requiredFields));

        String pictureField = adapter.getPictureFieldSpecifier();
        if (pictureField != null) {
            fields.add(pictureField);
        }

        Bundle parameters = request.getParameters();
        parameters.putString("fields", TextUtils.join(",", fields));
        request.setParameters(parameters);

        return request;
    }

    private Timer createSearchTextTimer() {
        Timer timer = new Timer();
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                onSearchTextTimerTriggered();
            }
        }, 0, searchTextTimerDelayInMilliseconds);

        return timer;
    }

    private void onSearchTextTimerTriggered() {
        if (hasSearchTextChangedSinceLastQuery) {
            Handler handler = new Handler(Looper.getMainLooper());
            handler.post(new Runnable() {
                @Override
                public void run() {
                    FacebookException error = null;
                    try {
                        loadData(true);
                    } catch (FacebookException fe) {
                        error = fe;
                    } catch (Exception e) {
                        error = new FacebookException(e);
                    } finally {
                        if (error != null) {
                            OnErrorListener onErrorListener = getOnErrorListener();
                            if (onErrorListener != null) {
                                onErrorListener.onError(PlacePickerFragment.this, error);
                            } else {
                                Logger.log(LoggingBehavior.REQUESTS, TAG, "Error loading data : %s", error);
                            }
                        }
                    }
                }
            });
        } else {
            
            
            searchTextTimer.cancel();
            searchTextTimer = null;
        }
    }

    private class AsNeededLoadingStrategy extends LoadingStrategy {
        @Override
        public void attach(GraphObjectAdapter adapter) {
            super.attach(adapter);

            this.adapter.setDataNeededListener(new GraphObjectAdapter.DataNeededListener() {
                @Override
                public void onDataNeeded() {
                    
                    
                    if (!loader.isLoading()) {
                        loader.followNextLink();
                    }
                }
            });
        }

        @Override
        protected void onLoadFinished(GraphObjectPagingLoader loader, GraphObjectCursor data) {
            super.onLoadFinished(loader, data);

            
            
            if (data == null || loader.isLoading()) {
                return;
            }

            hideActivityCircle();
        }
    }

    private class SearchTextWatcher implements TextWatcher {

        @Override
        public void beforeTextChanged(CharSequence s, int start, int count, int after) {
        }

        @Override
        public void onTextChanged(CharSequence s, int start, int before, int count) {
            onSearchBoxTextChanged(s.toString(), false);
        }

        @Override
        public void afterTextChanged(Editable s) {
        }
    }
}

<code block>


package com.example.scrumptious.usersettings;

import android.content.Intent;
import android.graphics.Bitmap;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.text.TextUtils;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

import com.facebook.AccessToken;
import com.facebook.AccessTokenTracker;
import com.facebook.CallbackManager;
import com.facebook.GraphRequest;
import com.facebook.GraphResponse;
import com.facebook.internal.ImageDownloader;
import com.facebook.internal.ImageRequest;
import com.facebook.internal.ImageResponse;
import com.example.scrumptious.R;
import com.facebook.login.widget.LoginButton;

import org.json.JSONObject;


public final class UserSettingsFragment extends Fragment {

    private static final String NAME = "name";
    private static final String ID = "id";
    private static final String PICTURE = "picture";
    private static final String FIELDS = "fields";
    
    private static final String REQUEST_FIELDS =
            TextUtils.join(",", new String[] {ID, NAME, PICTURE});

    private AccessTokenTracker accessTokenTracker;
    private CallbackManager callbackManager;

    private LoginButton loginButton;
    private TextView connectedStateLabel;
    private JSONObject user;
    private Drawable userProfilePic;
    private String userProfilePicID;

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        accessTokenTracker = new AccessTokenTracker() {
            @Override
            protected void onCurrentAccessTokenChanged(AccessToken oldAccessToken,
                                                       AccessToken currentAccessToken) {
                fetchUserInfo();
                updateUI();

            }
        };
        callbackManager = CallbackManager.Factory.create();
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        callbackManager.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        accessTokenTracker.stopTracking();
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.usersettings_fragment, container, false);
        loginButton = (LoginButton) view.findViewById(R.id.usersettings_fragment_login_button);
        loginButton.setFragment(this);

        connectedStateLabel = (TextView) view.findViewById(R.id.usersettings_fragment_profile_name);
        
        
        if (view.getBackground() == null) {
            view.setBackgroundColor(getResources().getColor(R.color.com_facebook_blue));
        } else {
            view.getBackground().setDither(true);
        }
        return view;
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setRetainInstance(true);
    }

    
    @Override
    public void onResume() {
        super.onResume();
        fetchUserInfo();
        updateUI();
    }

    private void fetchUserInfo() {
        final AccessToken accessToken = AccessToken.getCurrentAccessToken();
        if (accessToken != null) {
            GraphRequest request = GraphRequest.newMeRequest(
                    accessToken, new GraphRequest.GraphJSONObjectCallback() {
                        @Override
                        public void onCompleted(JSONObject me, GraphResponse response) {
                            user = me;
                            updateUI();
                        }
                    });
            Bundle parameters = new Bundle();
            parameters.putString(FIELDS, REQUEST_FIELDS);
            request.setParameters(parameters);
            GraphRequest.executeBatchAsync(request);
        } else {
            user = null;
        }
    }
    
    private void updateUI() {
        if (!isAdded()) {
            return;
        }
        if (AccessToken.getCurrentAccessToken() != null) {
            connectedStateLabel.setTextColor(getResources().getColor(
                    R.color.usersettings_fragment_connected_text_color));
            connectedStateLabel.setShadowLayer(1f, 0f, -1f,
                    getResources().getColor(
                            R.color.usersettings_fragment_connected_shadow_color));
            
            if (user != null) {
                ImageRequest request = getImageRequest();
                if (request != null) {
                    Uri requestUri = request.getImageUri();
                    
                    if (!requestUri.equals(connectedStateLabel.getTag())) {
                        if (user.optString("id").equals(userProfilePicID)) {
                            connectedStateLabel.setCompoundDrawables(
                                    null, userProfilePic, null, null);
                            connectedStateLabel.setTag(requestUri);
                        } else {
                            ImageDownloader.downloadAsync(request);
                        }
                    }
                }
                connectedStateLabel.setText(user.optString("name"));
            } else {
                connectedStateLabel.setText(getResources().getString(
                        R.string.usersettings_fragment_logged_in));
                Drawable noProfilePic = getResources().getDrawable(
                        R.drawable.profile_default_icon);
                noProfilePic.setBounds(0, 0,
                        getResources().getDimensionPixelSize(
                                R.dimen.usersettings_fragment_profile_picture_width),
                        getResources().getDimensionPixelSize(
                                R.dimen.usersettings_fragment_profile_picture_height));
                connectedStateLabel.setCompoundDrawables(null, noProfilePic, null, null);
            }
        } else {
            int textColor = getResources().getColor(
                    R.color.usersettings_fragment_not_connected_text_color);
            connectedStateLabel.setTextColor(textColor);
            connectedStateLabel.setShadowLayer(0f, 0f, 0f, textColor);
            connectedStateLabel.setText(getResources().getString(
                    R.string.usersettings_fragment_not_logged_in));
            connectedStateLabel.setCompoundDrawables(null, null, null, null);
            connectedStateLabel.setTag(null);
        }
    }

    private ImageRequest getImageRequest() {
        ImageRequest request = null;
        ImageRequest.Builder requestBuilder = new ImageRequest.Builder(
                getActivity(),
                ImageRequest.getProfilePictureUri(
                        user.optString("id"),
                        getResources().getDimensionPixelSize(
                                R.dimen.usersettings_fragment_profile_picture_width),
                        getResources().getDimensionPixelSize(
                                R.dimen.usersettings_fragment_profile_picture_height)));

        request = requestBuilder.setCallerTag(this)
                .setCallback(
                        new ImageRequest.Callback() {
                            @Override
                            public void onCompleted(ImageResponse response) {
                                processImageResponse(user.optString("id"), response);
                            }
                        })
                .build();
        return request;
    }

    private void processImageResponse(String id, ImageResponse response) {
        if (response != null) {
            Bitmap bitmap = response.getBitmap();
            if (bitmap != null) {
                BitmapDrawable drawable = new BitmapDrawable(
                        UserSettingsFragment.this.getResources(), bitmap);
                drawable.setBounds(0, 0,
                        getResources().getDimensionPixelSize(
                                R.dimen.usersettings_fragment_profile_picture_width),
                        getResources().getDimensionPixelSize(
                                R.dimen.usersettings_fragment_profile_picture_height));
                userProfilePic = drawable;
                userProfilePicID = id;
                connectedStateLabel.setCompoundDrawables(null, drawable, null, null);
                connectedStateLabel.setTag(response.getRequest().getImageUri());
            }
        }
    }
}

<code block>


package com.example.iconicus;

import android.net.Uri;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;


public class GameBoard {
    public static final int BOARD_ROWS = 9; 
    public static final int GROUP_ROWS = 3;
    public static final int BOARD_SIZE = BOARD_ROWS * BOARD_ROWS; 
    public static final int EMPTY_PIECE = 0;
    public static final int MIN_VALUE = 1;
    public static final int MAX_VALUE = 9;

    private static final Uri SHARE_URI = Uri.parse("https:
    private static final String DATA_KEY = "data";
    private static final String LOCKED_KEY = "locked";

    private static final int [] SEED_GRID = {
            1,2,3,4,5,6,7,8,9,
            4,5,6,7,8,9,1,2,3,
            7,8,9,1,2,3,4,5,6,
            2,3,4,5,6,7,8,9,1,
            5,6,7,8,9,1,2,3,4,
            8,9,1,2,3,4,5,6,7,
            3,4,5,6,7,8,9,1,2,
            6,7,8,9,1,2,3,4,5,
            9,1,2,3,4,5,6,7,8
    };

    private int[] board = new int[BOARD_SIZE];
    private boolean[] lockedPositions = new boolean[BOARD_SIZE];

    private GameBoard(int[] board, boolean[] lockedPositions) {
        if (board.length != this.board.length
                || lockedPositions.length != this.lockedPositions.length) {
            throw new IllegalArgumentException("boards are not the same size");
        }
        System.arraycopy(board, 0, this.board, 0, board.length);
        System.arraycopy(lockedPositions, 0, this.lockedPositions, 0, lockedPositions.length);
    }

    private GameBoard(int[] board) {
        if (board.length != this.board.length) {
            throw new IllegalArgumentException("boards are not the same size");
        }
        for (int i = 0; i < BOARD_SIZE; i++) {
            this.board[i] = board[i];
            this.lockedPositions[i] = (this.board[i] != EMPTY_PIECE);
        }
    }

    
    public static GameBoard generateBoard(final int openPositions) {
        Random random = new Random(System.currentTimeMillis());
        int [] board = new int[BOARD_SIZE];
        System.arraycopy(SEED_GRID, 0, board, 0, BOARD_SIZE);

        for (int i = 0; i < 9; i++) {
            shuffleGrid(random, board);
        }

        List<Integer> remainingPositions = new ArrayList<>(BOARD_SIZE);
        for (int i = 0; i < BOARD_SIZE; i++) {
            remainingPositions.add(i);
        }

        for (int i = 0; i < openPositions; i++) {
            removeOpenPosition(random, board, remainingPositions);
        }

        return new GameBoard(board);
    }

    
    public static GameBoard fromUri(final Uri uri) {
        String data = uri.getQueryParameter(DATA_KEY);
        if (data != null) {
            int [] newBoard = decodeBoard(data);
            String locked = uri.getQueryParameter(LOCKED_KEY);
            boolean [] lockedArr;

            if (locked != null) {
                lockedArr = decodeLockedPositions(locked);
            } else {
                
                
                lockedArr = new boolean[BOARD_SIZE];
                for (int i = 0; i < lockedArr.length; i++) {
                    if (newBoard[i] != EMPTY_PIECE) {
                        lockedArr[i] = true;
                    }
                }
            }
            return new GameBoard(newBoard, lockedArr);
        }
        return null;
    }

    
    public void clearBoard() {
        for (int i = 0; i < board.length; i++) {
            if (!lockedPositions[i]) {
                board[i] = EMPTY_PIECE;
            }
        }
    }

    
    public boolean isLocked(final int position) {
        return lockedPositions[position];
    }

    
    public boolean setValue(final int value, final int position) {
        if (!isLocked(position)
                && ((value >= MIN_VALUE && value <= MAX_VALUE) || value == EMPTY_PIECE)) {
            board[position] = value;
            return true;
        }
        return false;
    }

    
    public int getValue(final int position) {
        if (position < 0 || position >= BOARD_SIZE) {
            return EMPTY_PIECE;
        }
        return board[position];
    }

    
    public String getValueAsString(final int position) {
        int value = getValue(position);
        if (value < MIN_VALUE || value > MAX_VALUE) {
            return "";
        }
        return "" + value;
    }

    
    public boolean isEmpty(final int position) {
        return board[position] == EMPTY_PIECE;
    }

    
    public boolean isValid(final int position) {
        if (isEmpty(position)) {
            return true;
        }
        return validateRow(position) && validateColumn(position) && validateGroup(position);
    }

    
    public Uri toUri() {
        Uri.Builder shareUri = SHARE_URI.buildUpon();
        shareUri.appendQueryParameter(DATA_KEY, encodeBoard());
        shareUri.appendQueryParameter(LOCKED_KEY, encodeLockedPositions());
        return shareUri.build();
    }

    private String encodeBoard() {
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < board.length; i++) {
            builder.append(board[i]);
        }
        return builder.toString();
    }

    private static int[] decodeBoard(String input) {
        int [] newBoard = new int[BOARD_SIZE];
        Arrays.fill(newBoard, EMPTY_PIECE);
        if (input.length() == BOARD_SIZE) {
            for (int i = 0; i < input.length(); i++) {
                newBoard[i] = Integer.parseInt(input.substring(i, i + 1));
            }
        }
        return newBoard;
    }

    private String encodeLockedPositions() {
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < lockedPositions.length; i++) {
            builder.append(lockedPositions[i] ? 1 : 0);;;
        }
        return builder.toString();
    }

    private static boolean[] decodeLockedPositions(String input) {
        boolean [] locked = new boolean[BOARD_SIZE];
        Arrays.fill(locked, false);
        if (input.length() == BOARD_SIZE) {
            for (int i = 0; i < input.length(); i++) {
                locked[i] = (input.charAt(i) == '1');
            }
        }
        return locked;
    }

    private boolean validateRow(final int position) {
        int startPos = (position / BOARD_ROWS) * BOARD_ROWS;
        for (int i = 0; i < BOARD_ROWS; i++) {
            if (!checkIsValid(position, startPos + i)) {
                return false;
            }
        }
        return true;
    }

    private boolean validateColumn(final int position) {
        int startPos = position % BOARD_ROWS;
        for (int i = 0; i < BOARD_ROWS; i++) {
            if (!checkIsValid(position, startPos + (i * BOARD_ROWS))) {
                return false;
            }
        }
        return true;
    }

    private boolean validateGroup(final int position) {
        int row = position / BOARD_ROWS;
        int column = position % BOARD_ROWS;

        int group = (row / GROUP_ROWS) * GROUP_ROWS + (column / GROUP_ROWS);
        int startRow = (group / GROUP_ROWS) * GROUP_ROWS;
        int startColumn = (group % GROUP_ROWS) * GROUP_ROWS;

        for (int i = 0; i < GROUP_ROWS; i++) {
            for (int j = 0; j < GROUP_ROWS; j++) {
                if (!checkIsValid(position, (startRow + i) * 9 + startColumn + j)) {
                    return false;
                }
            }
        }
        return true;
    }

    private boolean checkIsValid(final int position1, final int position2) {
        return (position1 == position2) || (board[position1] != board[position2]);
    }

    private static void shuffleGrid(final Random random, final int[] board) {
        switch (random.nextInt(5)) {
            case 0:
                shuffleRow(random, board);
                break;
            case 1:
                shuffleRowGroup(random, board);
                break;
            case 2:
                shuffleColumn(random, board);
                break;
            case 3:
                shuffleColumnGroup(random, board);
                break;
            case 4:
                transpose(board);
                break;
            default:
                break;
        }
    }

    private static void shuffleRow(final Random random, final int[] board) {
        
        
        int group = random.nextInt(GROUP_ROWS);
        int row1 = random.nextInt(GROUP_ROWS);
        int row2 = randomOther(random, row1, GROUP_ROWS);

        int realRow1 = group * GROUP_ROWS + row1;
        int realRow2 = group * GROUP_ROWS + row2;

        Range range1 = new Range(realRow1 * BOARD_ROWS, BOARD_ROWS);
        Range range2 = new Range(realRow2 * BOARD_ROWS, BOARD_ROWS);
        swap(board, range1, range2);
    }

    private static void shuffleRowGroup(final Random random, final int[] board) {
        
        int group1 = random.nextInt(GROUP_ROWS);
        int group2 = randomOther(random, group1, GROUP_ROWS);

        Range range1 = new Range(group1 * GROUP_ROWS * BOARD_ROWS, GROUP_ROWS * BOARD_ROWS);
        Range range2 = new Range(group2 * GROUP_ROWS * BOARD_ROWS, GROUP_ROWS * BOARD_ROWS);
        swap(board, range1, range2);
    }

    private static void shuffleColumn(final Random random, final int[] board) {
        
        
        int group = random.nextInt(GROUP_ROWS);
        int col1 = random.nextInt(GROUP_ROWS);
        int col2 = randomOther(random, col1, GROUP_ROWS);

        int realCol1 = group * GROUP_ROWS + col1;
        int realCol2 = group * GROUP_ROWS + col2;

        swapColumn(board, realCol1, realCol2);
    }

    private static void shuffleColumnGroup(final Random random, final int[] board) {
        
        int group1 = random.nextInt(GROUP_ROWS);
        int group2 = randomOther(random, group1, GROUP_ROWS);

        for (int i = 0; i < GROUP_ROWS; i++) {
            int realCol1 = group1 * GROUP_ROWS + i;
            int realCol2 = group2 * GROUP_ROWS + i;
            swapColumn(board, realCol1, realCol2);
        }
    }

    private static void transpose(final int[] board) {
        for (int row = 0; row < BOARD_ROWS; ++row) {
            for (int col = row + 1; col < BOARD_ROWS; ++col) {
                int index1 = (row * BOARD_ROWS) + col;
                int index2 = (col * BOARD_ROWS) + row;
                swapPosition(board, index1, index2);
            }
        }
    }

    private static int randomOther(final Random random, final int currentValue, final int space) {
        return ((currentValue % space) + (random.nextInt(space - 1) + 1)) % space;
    }

    private static void swap(final int[] board, final Range range1, final Range range2) {
        if (range1.getSize() != range2.getSize()) {
            return;
        }
        int[] range2Copy = Arrays.copyOfRange(board, range2.getStart(), range2.getEnd());
        System.arraycopy(board, range1.getStart(), board, range2.getStart(), range1.getSize());
        System.arraycopy(range2Copy, 0, board, range1.getStart(), range1.getSize());
    }

    private static void swapColumn(final int[] board, final int col1, final int col2) {
        for (int i = 0; i < BOARD_ROWS; i++) {
            swapPosition(board, (i * BOARD_ROWS) + col1, (i * BOARD_ROWS) + col2);
        }
    }

    private static void swapPosition(final int[] board, final int pos1, final int pos2) {
        int val2 = board[pos2];
        board[pos2] = board[pos1];
        board[pos1] = val2;
    }

    private static void removeOpenPosition(
            final Random random,
            final int[] board,
            final List<Integer> remainingPositions) {
        int index = random.nextInt(remainingPositions.size());
        int position = remainingPositions.remove(index);
        board[position] = EMPTY_PIECE;
    }

    private static class Range {
        private int start;
        private int size;
        private int end;

        public Range(final int start, final int size) {
            this.start = start;
            this.size = size;
            this.end = start + size;
        }

        public int getStart() {
            return start;
        }

        public int getSize() {
            return size;
        }

        public int getEnd() {
            return end;
        }
    }
}

<code block>


package com.example.iconicus;

import android.content.Context;
import android.content.Intent;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.BaseAdapter;
import android.widget.GridView;
import android.widget.ImageView;
import android.widget.Toast;

import bolts.AppLinks;

public class GameController {

    private static final int NUM_OPEN_POSITIONS = 50;

    private static boolean iconsInitialized = false;
    private static Drawable[] validIcons = new Drawable[GameBoard.BOARD_ROWS + 1];

    private Context context;
    private GameBoard board;
    private GridView boardView;
    private GridView selectionView;
    private BoardAdapter boardAdapter;
    private SelectionAdapter selectionAdapter;
    private int selectedNum;
    private View selectedView;


    public GameController(final Context context, final Intent intent) {
        this.context = context;
        initializeIcons();
        board = handleDeepLink(context, intent);
        if (board == null) {
            board = GameBoard.generateBoard(NUM_OPEN_POSITIONS);
        }
        resetSelection();
    }

    public void setBoardView(final GridView boardView) {
        this.boardView = boardView;
        boardAdapter = new BoardAdapter();
        this.boardView.setAdapter(boardAdapter);
        this.boardView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
            public void onItemClick(AdapterView<?> parent, View v,
                                    int position, long id) {
                if (selectedNum >= 0) {
                    if (board.isLocked(position)) {
                        Toast.makeText(context.getApplicationContext(),
                                R.string.position_locked,
                                Toast.LENGTH_SHORT).show();
                    } else {
                        board.setValue(selectedNum, position);
                        dataSetChanged();
                    }
                } else {
                    Toast.makeText(context.getApplicationContext(),
                            R.string.nothing_selected,
                            Toast.LENGTH_SHORT).show();
                }
            }
        });

    }

    public void setSelectionView(final GridView selectionView) {
        this.selectionView = selectionView;
        selectionAdapter = new SelectionAdapter();
        this.selectionView.setAdapter(selectionAdapter);
        this.selectionView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
            public void onItemClick(AdapterView<?> parent, View v,
                                    int position, long id) {
                if (selectedNum != position) {
                    resetSelection();
                    selectedNum = position;
                    v.setBackgroundResource(R.drawable.selected_icon_background);
                    selectedView = v;
                } else {
                    resetSelection();
                }
            }
        });
    }

    public void newGame() {
        board = GameBoard.generateBoard(NUM_OPEN_POSITIONS);
        dataSetChanged();
    }

    public void clearBoard() {
        board.clearBoard();
        dataSetChanged();
    }

    public Uri getShareUri() {
        return board.toUri();
    }

    private synchronized void initializeIcons() {
        if (iconsInitialized) {
            return;
        }
        validIcons[0] = null;
        validIcons[1] = context.getResources().getDrawable(R.drawable.tile1);
        validIcons[2] = context.getResources().getDrawable(R.drawable.tile2);
        validIcons[3] = context.getResources().getDrawable(R.drawable.tile3);
        validIcons[4] = context.getResources().getDrawable(R.drawable.tile4);
        validIcons[5] = context.getResources().getDrawable(R.drawable.tile5);
        validIcons[6] = context.getResources().getDrawable(R.drawable.tile6);
        validIcons[7] = context.getResources().getDrawable(R.drawable.tile7);
        validIcons[8] = context.getResources().getDrawable(R.drawable.tile8);
        validIcons[9] = context.getResources().getDrawable(R.drawable.tile9);
        iconsInitialized = true;
    }

    private GameBoard handleDeepLink(final Context context, final Intent intent) {
        Uri targetUri = AppLinks.getTargetUrlFromInboundIntent(context, intent);
        if (targetUri == null) {
            targetUri = intent.getData();
        }

        if (targetUri == null) {
            return null;
        }

        return GameBoard.fromUri(targetUri);
    }

    private void dataSetChanged() {
        if (boardAdapter != null) {
            boardAdapter.notifyDataSetChanged();
        }
    }

    private void resetSelection() {
        if (selectedView != null) {
            selectedView.setBackgroundResource(R.drawable.choice_icon_background);
        }
        selectedNum = GameBoard.EMPTY_PIECE;
        selectedView = null;
    }

    private void updateCell(final ImageView imageView, final int position) {
        imageView.setImageDrawable(validIcons[board.getValue(position)]);

        if (board.isLocked(position)) {
            imageView.setBackgroundResource(R.drawable.locked_icon_background);
        } else if (board.isEmpty(position)) {
            imageView.setBackgroundResource(R.drawable.default_icon_background);
        } else if (board.isValid(position)) {
            imageView.setBackgroundResource(R.drawable.valid_icon_background);
        } else {
            imageView.setBackgroundResource(R.drawable.invalid_icon_background);
        }
    }

    private class SelectionAdapter extends BaseAdapter {

        @Override
        public int getCount() {
            return GameBoard.BOARD_ROWS + 1;
        }

        @Override
        public Object getItem(int position) {
            return validIcons[position];
        }

        @Override
        public long getItemId(int position) {
            return position;
        }

        @Override
        public View getView(int position, View convertView, ViewGroup parent) {
            if (convertView != null) {
                return convertView;
            }

            ImageView view = (ImageView) View.inflate(context, R.layout.choice_cell, null);
            view.setImageDrawable(validIcons[position]);
            return view;
        }
    }

    private class BoardAdapter extends BaseAdapter {

        @Override
        public int getCount() {
            return GameBoard.BOARD_SIZE;
        }

        @Override
        public Object getItem(final int position) {
            return board.getValue(position);
        }

        @Override
        public long getItemId(final int position) {
            return position;
        }

        @Override
        public View getView(final int position, final View convertView, final ViewGroup parent) {
            if (convertView != null) {
                updateCell((ImageView) convertView, position);
                return convertView;
            }

            ImageView view = (ImageView) View.inflate(context, R.layout.grid_cell, null);

            updateCell(view, position);

            return view;
        }
    }
}

<code block>


package com.example.iconicus;

import android.app.Activity;
import android.content.ClipData;
import android.content.ClipboardManager;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.GridView;
import android.widget.Toast;

import com.facebook.FacebookSdk;
import com.facebook.share.model.ShareLinkContent;
import com.facebook.share.widget.SendButton;
import com.facebook.share.widget.ShareButton;

public class MainActivity extends Activity {

    private GridView board;
    private GridView validNumbers;

    private GameController gameController;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        FacebookSdk.sdkInitialize(this);
        setContentView(R.layout.activity_main);

        gameController = new GameController(this, getIntent());

        board = (GridView) findViewById(R.id.board);

        validNumbers = (GridView) findViewById(R.id.valid_numbers);

        gameController.setBoardView(board);
        gameController.setSelectionView(validNumbers);

        Button newGame = (Button) findViewById(R.id.new_board);
        newGame.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                gameController.newGame();
            }
        });

        Button clearBoard = (Button) findViewById(R.id.clear_board);
        clearBoard.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                gameController.clearBoard();
            }
        });

        final ShareButton share = (ShareButton) findViewById(R.id.share_button);
        share.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                share.setShareContent(getLinkContent());
            }
        });

        final SendButton send = (SendButton) findViewById(R.id.send_button);
        send.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                send.setShareContent(getLinkContent());
            }
        });

        Button copy = (Button) findViewById(R.id.copy_button);
        copy.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                ClipboardManager clipboard = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE);
                ClipData clip = ClipData.newUri(
                        getContentResolver(), "Iconicus", gameController.getShareUri());
                clipboard.setPrimaryClip(clip);
                Toast.makeText(MainActivity.this, R.string.link_copied, Toast.LENGTH_SHORT).show();
            }
        });
    }

    private ShareLinkContent getLinkContent() {
        return new ShareLinkContent.Builder()
                .setContentUrl(gameController.getShareUri())
                .setContentTitle(getString(R.string.share_title))
                .setContentDescription(getString(R.string.share_description))
                .build();
    }

}

<code block>


package com.example.rps;

public class RpsGameUtils {
    public enum RpsState {
        INIT,
        PLAYING,
        RESULT
    };

    public enum RpsResult {
        WIN(R.string.win, R.string.result_won),
        LOSS(R.string.loss, R.string.result_lost),
        TIE(R.string.tie, R.string.result_tied),
        INVALID(0, 0);

        private int id;
        private int resultId;

        private RpsResult(int stringId, int resultStringId) {
            id = stringId;
            resultId = resultStringId;
        }

        public int getStringId() {
            return id;
        }

        public int getResultStringId() {
            return resultId;
        }
    };

    public static final int ROCK = 0;
    public static final int PAPER = 1;
    public static final int SCISSORS = 2;
    public static final int INVALID_CHOICE = -1;
    public static final int SHOOT = 100;
    public static final int[] DRAWABLES_HUMAN =
            { R.drawable.left_rock, R.drawable.left_paper, R.drawable.left_scissors };
    public static final int[] DRAWABLES_COMPUTER =
            { R.drawable.right_rock, R.drawable.right_paper, R.drawable.right_scissors };
    public static final int[] STRINGS_TITLES =
            { R.string.rock, R.string.paper, R.string.scissors };
    public static final RpsResult[][] RESULTS =
            {
                    {RpsResult.TIE, RpsResult.LOSS, RpsResult.WIN},
                    {RpsResult.WIN, RpsResult.TIE, RpsResult.LOSS},
                    {RpsResult.LOSS, RpsResult.WIN, RpsResult.TIE}
            };
}

<code block>


package com.example.rps;

import android.app.AlertDialog;
import android.content.DialogInterface;
import android.content.Intent;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.drawable.BitmapDrawable;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.support.v4.app.Fragment;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.*;

import com.facebook.*;
import com.facebook.login.DefaultAudience;
import com.facebook.login.LoginManager;
import com.facebook.login.LoginResult;
import com.facebook.share.ShareApi;
import com.facebook.share.Sharer;
import com.facebook.share.model.ShareContent;
import com.facebook.share.model.ShareLinkContent;
import com.facebook.share.model.ShareOpenGraphAction;
import com.facebook.share.model.ShareOpenGraphContent;
import com.facebook.share.model.ShareOpenGraphObject;
import com.facebook.share.model.SharePhoto;
import com.facebook.share.model.AppInviteContent;
import com.facebook.share.widget.AppInviteDialog;
import com.facebook.share.widget.MessageDialog;
import com.facebook.share.widget.ShareDialog;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Random;

import static com.example.rps.RpsGameUtils.*;

public class RpsFragment extends Fragment {

    private static final String SHARE_GAME_LINK = "https:
    private static final String SHARE_GAME_NAME = "Rock, Papers, Scissors Sample Application";
    private static final String DEFAULT_GAME_OBJECT_TITLE =
            "an awesome game of Rock, Paper, Scissors";
    private static final String WIN_KEY = "wins";
    private static final String LOSS_KEY = "losses";
    private static final String TIE_KEY = "ties";
    private static final String PLAYER_CHOICE_KEY = "player_choice";
    private static final String COMPUTER_CHOICE_KEY = "computer_choice";
    private static final String STATE_KEY = "state";
    private static final String RESULT_KEY = "result";
    private static final String PENDING_PUBLISH_KEY = "pending_publish";
    private static final String IMPLICIT_PUBLISH_KEY = "implicitly_publish";
    private static final String ADDITIONAL_PERMISSIONS = "publish_actions";
    private static final int INITIAL_DELAY_MILLIS = 500;
    private static final int DEFAULT_DELAY_MILLIS = 1000;
    private static final String TAG = RpsFragment.class.getName();

    private static String[] PHOTO_URIS = {null, null, null};

    private TextView[] gestureTextViews = new TextView[3];
    private TextView shootTextView;
    private ImageView playerChoiceView;
    private ImageView computerChoiceView;
    private TextView resultTextView;
    private ViewGroup shootGroup;
    private ViewGroup resultGroup;
    private ViewGroup playerChoiceGroup;
    private Button againButton;
    private ImageButton[] gestureImages = new ImageButton[3];
    private ImageButton fbButton;
    private TextView statsTextView;
    private ViewFlipper rpsFlipper;

    private int wins = 0;
    private int losses = 0;
    private int ties = 0;
    private int playerChoice = INVALID_CHOICE;
    private int computerChoice = INVALID_CHOICE;
    private RpsState currentState = RpsState.INIT;
    private RpsResult result = RpsResult.INVALID;
    private InitHandler handler = new InitHandler();
    private Random random = new Random(System.currentTimeMillis());
    private boolean pendingPublish;
    private boolean shouldImplicitlyPublish = true;
    private CallbackManager callbackManager;
    private ShareDialog shareDialog;
    private MessageDialog messageDialog;
    private AppInviteDialog appInviteDialog;

    private DialogInterface.OnClickListener canPublishClickListener = new DialogInterface.OnClickListener() {
        @Override
        public void onClick(DialogInterface dialogInterface, int i) {
            if (AccessToken.getCurrentAccessToken() != null) {
                
                shouldImplicitlyPublish = true;
                pendingPublish = true;

                LoginManager.getInstance()
                        .setDefaultAudience(DefaultAudience.FRIENDS)
                        .logInWithPublishPermissions(
                                RpsFragment.this,
                                Arrays.asList(ADDITIONAL_PERMISSIONS));
            }
        }
    };

    private DialogInterface.OnClickListener dontPublishClickListener = new DialogInterface.OnClickListener() {
        @Override
        public void onClick(DialogInterface dialogInterface, int i) {
            
            
            pendingPublish = false;
            shouldImplicitlyPublish = false;
        }
    };

    private class InitHandler extends Handler {
        @Override
        public void handleMessage(Message msg) {
            if (!isResumed()) {
                
                return;
            }
            switch (msg.what) {
                case ROCK:
                    showViews(gestureTextViews[ROCK], gestureImages[ROCK]);
                    sendNextMessage(PAPER);
                    break;
                case PAPER:
                    showViews(gestureTextViews[PAPER], gestureImages[PAPER]);
                    sendNextMessage(SCISSORS);
                    break;
                case SCISSORS:
                    showViews(gestureTextViews[SCISSORS], gestureImages[SCISSORS]);
                    sendNextMessage(SHOOT);
                    break;
                case SHOOT:
                    showViews(shootTextView);
                    switchState(RpsState.PLAYING, false);
                    break;
                default:
                    Log.e(TAG, "Unexpected message received: " + msg.toString());
                    break;
            }
        }

        private void sendNextMessage(int what) {
            Message newMsg = new Message();
            newMsg.what = what;
            sendMessageDelayed(newMsg, DEFAULT_DELAY_MILLIS);
        }
    }

    private void switchState(RpsState newState, boolean isOnResume) {
        if (!isResumed()) {
            
            return;
        }
        switch (newState) {
            case INIT:
                playerChoice = INVALID_CHOICE;
                computerChoice = INVALID_CHOICE;
                result = RpsResult.INVALID;
                showViews(shootGroup, playerChoiceGroup, rpsFlipper);
                rpsFlipper.startFlipping();
                hideViews(gestureImages);
                hideViews(gestureTextViews);
                hideViews(resultGroup, shootTextView, againButton);
                enableViews(false, gestureImages);
                enableViews(false, againButton);
                Message initMessage = new Message();
                initMessage.what = ROCK;
                handler.sendMessageDelayed(initMessage, INITIAL_DELAY_MILLIS);
                break;
            case PLAYING:
                enableViews(true, gestureImages);
                showViews(rpsFlipper);
                rpsFlipper.startFlipping();
                break;
            case RESULT:
                hideViews(shootGroup, playerChoiceGroup);
                playerChoiceView.setImageResource(DRAWABLES_HUMAN[playerChoice]);
                computerChoiceView.setImageResource(DRAWABLES_COMPUTER[computerChoice]);
                resultTextView.setText(result.getStringId());
                showViews(resultGroup, againButton);
                enableViews(true, againButton);
                if (!isOnResume) {
                    
                    publishResult();
                }
                break;
            default:
                Log.e(TAG, "Unexpected state reached: " + newState.toString());
                break;
        }

        String statsFormat = getResources().getString(R.string.stats_format);
        statsTextView.setText(String.format(statsFormat, wins, losses, ties));

        currentState = newState;
    }

    private void hideViews(View... views) {
        for (View view : views) {
            view.setVisibility(View.INVISIBLE);
        }
    }

    private void showViews(View... views) {
        for (View view : views) {
            view.setVisibility(View.VISIBLE);
        }
    }

    private void enableViews(boolean enabled, View... views) {
        for (View view : views) {
            view.setEnabled(enabled);
        }
    }

    private void playerPlayed(int choice) {
        playerChoice = choice;
        computerChoice = getComputerChoice();
        result = RESULTS[playerChoice][computerChoice];
        switch (result) {
            case WIN:
                wins++;
                break;
            case LOSS:
                losses++;
                break;
            case TIE:
                ties++;
                break;
            default:
                Log.e(TAG, "Unexpected result: " + result.toString());
                break;
        }
        switchState(RpsState.RESULT, false);
    }

    private int getComputerChoice() {
        return random.nextInt(3);
    }

    private boolean canPublish() {
        final AccessToken accessToken = AccessToken.getCurrentAccessToken();
        if (accessToken != null) {
            if (accessToken.getPermissions().contains(ADDITIONAL_PERMISSIONS)) {
                
                return true;
            } else {
                
                new AlertDialog.Builder(getActivity())
                        .setTitle(R.string.share_with_friends_title)
                        .setMessage(R.string.share_with_friends_message)
                        .setPositiveButton(R.string.share_with_friends_yes, canPublishClickListener)
                        .setNegativeButton(R.string.share_with_friends_no, dontPublishClickListener)
                        .show();
                return false;
            }
        }
        return false;
    }

    private void showError(int messageId) {
        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
        builder.setTitle(R.string.error_dialog_title).
                setMessage(messageId).
                setPositiveButton(R.string.error_ok_button, null);
        builder.show();
    }

    private void publishResult() {
        if (shouldImplicitlyPublish && canPublish()) {
            String photoUri = PHOTO_URIS[playerChoice];
            SharePhoto.Builder sharePhotoBuilder = new SharePhoto.Builder();
            if (photoUri == null) {
                Bitmap bitmap = BitmapFactory.decodeResource(
                        getResources(),
                        DRAWABLES_HUMAN[playerChoice]);
                sharePhotoBuilder.setBitmap(bitmap);
            } else {
                sharePhotoBuilder.setImageUrl(Uri.parse(photoUri));
            }
            sharePhotoBuilder.setUserGenerated(false);
            final SharePhoto gesturePhoto = sharePhotoBuilder.build();

            ShareOpenGraphObject gameObject = createGameObject(gesturePhoto);
            ShareOpenGraphAction playAction = createPlayActionWithGame(gameObject);
            ShareOpenGraphContent content = new ShareOpenGraphContent.Builder()
                    .setAction(playAction)
                    .setPreviewPropertyName("game")
                    .build();

            ShareApi.share(content, new FacebookCallback<Sharer.Result>() {
                @Override
                public void onSuccess(Sharer.Result result) {
                    Log.i(TAG, "Posted OG Action with id: " +
                            result.getPostId());
                }

                @Override
                public void onCancel() {
                    
                }

                @Override
                public void onError(FacebookException error) {
                    Log.e(TAG, "Play action creation failed: " + error.getMessage());
                }
            });
        }
    }

    private ShareOpenGraphObject createGameObject(final SharePhoto gesturePhoto) {
        return new ShareOpenGraphObject.Builder()
                .putString("og:title", DEFAULT_GAME_OBJECT_TITLE)
                .putString("og:type", "fb_sample_rps:game")
                .putString("fb_sample_rps:player_gesture",
                        CommonObjects.BUILT_IN_OPEN_GRAPH_OBJECTS[playerChoice])
                .putString("fb_sample_rps:opponent_gesture",
                        CommonObjects.BUILT_IN_OPEN_GRAPH_OBJECTS[computerChoice])
                .putString("fb_sample_rps:result", getString(result.getResultStringId()))
                .putPhotoArrayList("og:image", new ArrayList<SharePhoto>() {{
                    add(gesturePhoto);
                }})
                .build();
    }

    private ShareOpenGraphAction createPlayActionWithGame(ShareOpenGraphObject game) {
        return new ShareOpenGraphAction.Builder()
                .setActionType(OpenGraphConsts.PLAY_ACTION_TYPE)
                .putObject("game", game).build();
    }

    private String getBuiltInGesture(int choice) {
        if (choice < 0 || choice >= CommonObjects.BUILT_IN_OPEN_GRAPH_OBJECTS.length) {
            throw new IllegalArgumentException("Invalid choice");
        }

        return CommonObjects.BUILT_IN_OPEN_GRAPH_OBJECTS[choice];
    }

    private ShareOpenGraphAction getThrowAction() {
        
        
        
        ImageButton view = gestureImages[playerChoice];
        BitmapDrawable drawable = (BitmapDrawable) view.getBackground();
        final Bitmap bitmap = drawable.getBitmap();

        return new ShareOpenGraphAction.Builder()
                .setActionType(OpenGraphConsts.THROW_ACTION_TYPE)
                .putString("fb_sample_rps:gesture", getBuiltInGesture(playerChoice))
                .putString("fb_sample_rps:opposing_gesture", getBuiltInGesture(computerChoice))
                .putPhotoArrayList("og:image", new ArrayList<SharePhoto>() {{
                    add(new SharePhoto.Builder().setBitmap(bitmap).build());
                }})
                .build();
    }

    private ShareOpenGraphContent getThrowActionContent() {
        return new ShareOpenGraphContent.Builder()
                .setAction(getThrowAction())
                .setPreviewPropertyName(OpenGraphConsts.THROW_ACTION_PREVIEW_PROPERTY_NAME)
                .build();
    }

    private ShareLinkContent getLinkContent() {
        return new ShareLinkContent.Builder()
                .setContentTitle(SHARE_GAME_NAME)
                .setContentUrl(Uri.parse(SHARE_GAME_LINK))
                .build();
    }

    public void shareUsingNativeDialog() {
        if (playerChoice == INVALID_CHOICE || computerChoice == INVALID_CHOICE) {
            ShareContent content = getLinkContent();

            
            if (shareDialog.canShow(content, ShareDialog.Mode.NATIVE)) {
                shareDialog.show(content, ShareDialog.Mode.NATIVE);
            } else {
                showError(R.string.native_share_error);
            }
        } else {
            ShareContent content = getThrowActionContent();

            if (shareDialog.canShow(content, ShareDialog.Mode.NATIVE)) {
                shareDialog.show(content, ShareDialog.Mode.NATIVE);
            } else {
                showError(R.string.native_share_error);
            }
        }
    }

    public void shareUsingMessengerDialog() {
        if (playerChoice == INVALID_CHOICE || computerChoice == INVALID_CHOICE) {
            ShareContent content = getLinkContent();

            
            if (messageDialog.canShow(content)) {
                messageDialog.show(content);
            }
        } else {
            ShareContent content = getThrowActionContent();

            if (messageDialog.canShow(content)) {
                messageDialog.show(content);
            }
        }
    }

    public void presentAppInviteDialog() {
        AppInviteContent content = new AppInviteContent.Builder()
                .setApplinkUrl("http:
                .setPreviewImageUrl("http:
                .build();
        if (AppInviteDialog.canShow()) {
            appInviteDialog.show(this, content);
        } else {
            showError(R.string.appinvite_error);
        }
    }

    @Override
    public View onCreateView(LayoutInflater inflater,
                             ViewGroup container,
                             Bundle savedInstanceState) {
        super.onCreateView(inflater, container, savedInstanceState);
        View view = inflater.inflate(R.layout.rps_fragment, container, false);

        gestureTextViews[ROCK] = (TextView) view.findViewById(R.id.text_rock);
        gestureTextViews[PAPER] = (TextView) view.findViewById(R.id.text_paper);
        gestureTextViews[SCISSORS] = (TextView) view.findViewById(R.id.text_scissors);
        shootTextView = (TextView) view.findViewById(R.id.shoot);
        playerChoiceView = (ImageView) view.findViewById(R.id.player_choice);
        computerChoiceView = (ImageView) view.findViewById(R.id.computer_choice);
        resultTextView = (TextView) view.findViewById(R.id.who_won);
        shootGroup = (ViewGroup) view.findViewById(R.id.shoot_display_group);
        resultGroup = (ViewGroup) view.findViewById(R.id.result_display_group);
        playerChoiceGroup = (ViewGroup) view.findViewById(R.id.player_choice_display_group);
        againButton = (Button) view.findViewById(R.id.again_button);
        gestureImages[ROCK] = (ImageButton) view.findViewById(R.id.player_rock);
        gestureImages[PAPER] = (ImageButton) view.findViewById(R.id.player_paper);
        gestureImages[SCISSORS] = (ImageButton) view.findViewById(R.id.player_scissors);
        fbButton = (ImageButton) view.findViewById(R.id.facebook_button);
        statsTextView = (TextView) view.findViewById(R.id.stats);
        rpsFlipper = (ViewFlipper) view.findViewById(R.id.rps_flipper);

        gestureImages[ROCK].setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                playerPlayed(ROCK);
            }
        });

        gestureImages[PAPER].setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                playerPlayed(PAPER);
            }
        });

        gestureImages[SCISSORS].setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                playerPlayed(SCISSORS);
            }
        });

        againButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                switchState(RpsState.INIT, false);
            }
        });

        fbButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                getActivity().openOptionsMenu();
            }
        });

        return view;
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        if (savedInstanceState != null) {
            wins = savedInstanceState.getInt(WIN_KEY);
            losses = savedInstanceState.getInt(LOSS_KEY);
            ties = savedInstanceState.getInt(TIE_KEY);
            computerChoice = savedInstanceState.getInt(COMPUTER_CHOICE_KEY);
            playerChoice = savedInstanceState.getInt(PLAYER_CHOICE_KEY);
            currentState = (RpsState) savedInstanceState.getSerializable(STATE_KEY);
            result = (RpsResult) savedInstanceState.getSerializable(RESULT_KEY);
            pendingPublish = savedInstanceState.getBoolean(PENDING_PUBLISH_KEY);
            shouldImplicitlyPublish = savedInstanceState.getBoolean(IMPLICIT_PUBLISH_KEY);
        }
        callbackManager = CallbackManager.Factory.create();
        LoginManager.getInstance().registerCallback(
                callbackManager,
                new FacebookCallback<LoginResult>() {
                    @Override
                    public void onSuccess(LoginResult loginResult) {
                        AccessToken accessToken = AccessToken.getCurrentAccessToken();
                        if (accessToken.getPermissions().contains(ADDITIONAL_PERMISSIONS)) {
                            publishResult();
                        } else {
                            handleError();
                        }
                    }

                    @Override
                    public void onCancel() {
                        handleError();
                    }

                    @Override
                    public void onError(FacebookException exception) {
                        handleError();
                    }

                    private void handleError() {
                        
                        
                        shouldImplicitlyPublish = false;
                        pendingPublish = false;
                    }
                }
        );

        FacebookCallback<Sharer.Result> callback =
                new FacebookCallback<Sharer.Result>() {
                    @Override
                    public void onCancel() {
                        Log.d(TAG, "Canceled");
                    }

                    @Override
                    public void onError(FacebookException error) {
                        Log.d(TAG, String.format("Error: %s", error.toString()));
                    }

                    @Override
                    public void onSuccess(Sharer.Result result) {
                        Log.d(TAG, "Success!");
                    }
                };
        shareDialog = new ShareDialog(this);
        shareDialog.registerCallback(callbackManager, callback);
        messageDialog = new MessageDialog(this);
        messageDialog.registerCallback(callbackManager, callback);

        FacebookCallback<AppInviteDialog.Result> appInviteCallback =
                new FacebookCallback<AppInviteDialog.Result>() {
                    @Override
                    public void onSuccess(AppInviteDialog.Result result) {
                        Log.d(TAG, "Success!");
                    }

                    @Override
                    public void onCancel() {
                        Log.d(TAG, "Canceled");
                    }

                    @Override
                    public void onError(FacebookException error) {
                        Log.d(TAG, String.format("Error: %s", error.toString()));
                    }
                };
        appInviteDialog = new AppInviteDialog(this);
        appInviteDialog.registerCallback(callbackManager, appInviteCallback);
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        callbackManager.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    public void onResume() {
        super.onResume();
        switchState(currentState, true);
    }

    @Override
    public void onSaveInstanceState(Bundle bundle) {
        super.onSaveInstanceState(bundle);
        bundle.putInt(WIN_KEY, wins);
        bundle.putInt(LOSS_KEY, losses);
        bundle.putInt(TIE_KEY, ties);
        bundle.putInt(COMPUTER_CHOICE_KEY, computerChoice);
        bundle.putInt(PLAYER_CHOICE_KEY, playerChoice);
        bundle.putSerializable(STATE_KEY, currentState);
        bundle.putSerializable(RESULT_KEY, result);
        bundle.putBoolean(PENDING_PUBLISH_KEY, pendingPublish);
        bundle.putBoolean(IMPLICIT_PUBLISH_KEY, shouldImplicitlyPublish);
    }
}

<code block>



package com.example.rps;

public class CommonObjects {
    public static final String BUILT_IN_OPEN_GRAPH_OBJECTS[] = {
            "672839339475385", 
            "296430467206197", 
            "524651207660361"  
    };
}


<code block>


package com.example.rps;

import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.TextView;

public class ContentFragment extends Fragment {
    public static final String CONTENT_INDEX_KEY = "content";

    private TextView title;
    private ImageView image;
    private Button playButton;

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.content_fragment, container, false);
        title = (TextView) view.findViewById(R.id.content_title);
        image = (ImageView) view.findViewById(R.id.content_image);
        playButton = (Button) view.findViewById(R.id.content_play_button);

        playButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                MainActivity activity = (MainActivity) getActivity();
                activity.showFragment(MainActivity.RPS, false);
            }
        });
        return view;
    }

    public void setContentIndex(int index) {
        title.setText(RpsGameUtils.STRINGS_TITLES[index]);
        image.setImageResource(RpsGameUtils.DRAWABLES_HUMAN[index]);
    }
}

<code block>


package com.example.rps;

import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentActivity;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentTransaction;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;

import bolts.AppLinks;
import com.facebook.*;
import com.facebook.appevents.AppEventsLogger;
import com.facebook.share.model.GameRequestContent;
import com.facebook.share.widget.GameRequestDialog;

import static com.example.rps.RpsGameUtils.INVALID_CHOICE;

public class MainActivity extends FragmentActivity {
    private static final String TAG = "MainActivity";

    static final int RPS = 0;
    static final int SETTINGS = 1;
    static final int CONTENT = 2;
    static final int FRAGMENT_COUNT = CONTENT +1;

    private Fragment[] fragments = new Fragment[FRAGMENT_COUNT];
    private MenuItem settings;
    private MenuItem challenge;
    private MenuItem share;
    private MenuItem message;
    private MenuItem invite;
    private boolean isResumed = false;
    private boolean hasNativeLink = false;
    private CallbackManager callbackManager;
    private GameRequestDialog gameRequestDialog;

    private AccessTokenTracker accessTokenTracker;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        FacebookSdk.sdkInitialize(this.getApplicationContext());

        accessTokenTracker = new AccessTokenTracker() {
            @Override
            protected void onCurrentAccessTokenChanged(AccessToken oldAccessToken,
                                                       AccessToken currentAccessToken) {
                if (isResumed) {
                    if (currentAccessToken == null) {
                        showFragment(RPS, false);
                    }
                }
            }
        };

        setContentView(R.layout.main);

        FragmentManager fm = getSupportFragmentManager();
        fragments[RPS] = fm.findFragmentById(R.id.rps_fragment);
        fragments[SETTINGS] = fm.findFragmentById(R.id.settings_fragment);
        fragments[CONTENT] = fm.findFragmentById(R.id.content_fragment);

        FragmentTransaction transaction = fm.beginTransaction();
        for(int i = 0; i < fragments.length; i++) {
            transaction.hide(fragments[i]);
        }
        transaction.commit();

        hasNativeLink = handleNativeLink();

        gameRequestDialog = new GameRequestDialog(this);
        callbackManager = CallbackManager.Factory.create();
        gameRequestDialog.registerCallback(
                callbackManager,
                new FacebookCallback<GameRequestDialog.Result>() {
                    @Override
                    public void onCancel() {
                        Log.d(TAG, "Canceled");
                    }

                    @Override
                    public void onError(FacebookException error) {
                        Log.d(TAG, String.format("Error: %s", error.toString()));
                    }

                    @Override
                    public void onSuccess(GameRequestDialog.Result result) {
                        Log.d(TAG, "Success!");
                        Log.d(TAG, "Request id: " + result.getRequestId());
                        Log.d(TAG, "Recipients:");
                        for (String recipient : result.getRequestRecipients()) {
                            Log.d(TAG, recipient);
                        }
                    }
                });
    }

    @Override
    public void onResume() {
        super.onResume();
        isResumed = true;

        
        
        AppEventsLogger.activateApp(this);
    }

    @Override
    public void onPause() {
        super.onPause();
        isResumed = false;

        
        
        AppEventsLogger.deactivateApp(this);
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        callbackManager.onActivityResult(requestCode, resultCode, data);
        super.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        accessTokenTracker.stopTracking();
    }

    @Override
    protected void onResumeFragments() {
        super.onResumeFragments();

        if (hasNativeLink) {
            showFragment(CONTENT, false);
            hasNativeLink = false;
        } else {
            showFragment(RPS, false);
        }
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        
        if (fragments[RPS].isVisible()) {
            if (menu.size() == 0) {
                share = menu.add(R.string.share_on_facebook);
                message = menu.add(R.string.send_with_messenger);
                challenge = menu.add(R.string.challenge_friends);
                settings = menu.add(R.string.check_settings);
                invite = menu.add(R.string.invite_friends);
            }
            return true;
        } else {
            menu.clear();
            settings = null;
        }
        return false;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if (item.equals(settings)) {
            showFragment(SETTINGS, true);
            return true;
        } else if (item.equals(challenge)) {
            GameRequestContent newGameRequestContent = new GameRequestContent.Builder()
                    .setTitle(getString(R.string.challenge_dialog_title))
                    .setMessage(getString(R.string.challenge_dialog_message))
                    .build();

            gameRequestDialog.show(this, newGameRequestContent);

            return true;
        } else if (item.equals(share)) {
            RpsFragment fragment = (RpsFragment) fragments[RPS];
            fragment.shareUsingNativeDialog();
            return true;
        } else if (item.equals(message)) {
            RpsFragment fragment = (RpsFragment) fragments[RPS];
            fragment.shareUsingMessengerDialog();
            return true;
        } else if (item.equals(invite)) {
            RpsFragment fragment = (RpsFragment) fragments[RPS];
            fragment.presentAppInviteDialog();
        }
        return false;
    }

    private boolean handleNativeLink() {
        AccessToken accessToken = AccessToken.getCurrentAccessToken();
        if (accessToken == null) {
            AccessToken.createFromNativeLinkingIntent(getIntent(),
                    FacebookSdk.getApplicationId(), new AccessToken.AccessTokenCreationCallback(){

                        @Override
                        public void onSuccess(AccessToken token) {
                            AccessToken.setCurrentAccessToken(token);
                        }

                        @Override
                        public void onError(FacebookException error) {

                        }
                    });
        }
        
        int appLinkGesture = getAppLinkGesture(getIntent());
        if (appLinkGesture != INVALID_CHOICE) {
            ContentFragment fragment = (ContentFragment) fragments[CONTENT];
            fragment.setContentIndex(appLinkGesture);
            return true;
        }
        return false;
    }

    private int getAppLinkGesture(Intent intent) {
      Uri targetURI = AppLinks.getTargetUrlFromInboundIntent(this, intent);
      if (targetURI == null) {
        return INVALID_CHOICE;
      }
      String gesture = targetURI.getQueryParameter("gesture");
      if (gesture != null) {
          if (gesture.equalsIgnoreCase(getString(R.string.rock))) {
              return RpsGameUtils.ROCK;
          } else if (gesture.equalsIgnoreCase(getString(R.string.paper))) {
              return RpsGameUtils.PAPER;
          } else if (gesture.equalsIgnoreCase(getString(R.string.scissors))) {
              return RpsGameUtils.SCISSORS;
          }
      }
      return INVALID_CHOICE;
    }

    void showFragment(int fragmentIndex, boolean addToBackStack) {
        FragmentManager fm = getSupportFragmentManager();
        FragmentTransaction transaction = fm.beginTransaction();
        if (addToBackStack) {
            transaction.addToBackStack(null);
        } else {
            int backStackSize = fm.getBackStackEntryCount();
            for (int i = 0; i < backStackSize; i++) {
                fm.popBackStack();
            }
        }
        for (int i = 0; i < fragments.length; i++) {
            if (i == fragmentIndex) {
                transaction.show(fragments[i]);
            } else {
                transaction.hide(fragments[i]);
            }
        }
        transaction.commit();
    }
}

<code block>


package com.example.rps;

public class OpenGraphConsts {
    public static final String THROW_ACTION_TYPE = "fb_sample_rps:throw";
    public static final String THROW_ACTION_PREVIEW_PROPERTY_NAME = "fb_sample_rps:gesture";

    public static final String GAME_OBJECT_TYPE = "fb_sample_rps:game";

    public static final String PLAY_ACTION_TYPE = "fb_sample_rps:play";
}

<code block>


package com.example.rps.usersettings;

import android.content.Intent;
import android.graphics.Bitmap;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.text.TextUtils;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

import com.facebook.AccessToken;
import com.facebook.AccessTokenTracker;
import com.facebook.CallbackManager;
import com.facebook.GraphRequest;
import com.facebook.GraphResponse;
import com.facebook.internal.ImageDownloader;
import com.facebook.internal.ImageRequest;
import com.facebook.internal.ImageResponse;
import com.example.rps.R;
import com.facebook.login.widget.LoginButton;

import org.json.JSONObject;


public final class UserSettingsFragment extends Fragment {

    private static final String NAME = "name";
    private static final String ID = "id";
    private static final String PICTURE = "picture";
    private static final String FIELDS = "fields";

    private static final String REQUEST_FIELDS =
            TextUtils.join(",", new String[] {ID, NAME, PICTURE});

    private AccessTokenTracker accessTokenTracker;
    private CallbackManager callbackManager;

    private LoginButton loginButton;
    private TextView connectedStateLabel;
    private JSONObject user;
    private Drawable userProfilePic;
    private String userProfilePicID;

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        accessTokenTracker = new AccessTokenTracker() {
            @Override
            protected void onCurrentAccessTokenChanged(AccessToken oldAccessToken,
                                                       AccessToken currentAccessToken) {
                fetchUserInfo();
                updateUI();

            }
        };
        callbackManager = CallbackManager.Factory.create();
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        callbackManager.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        accessTokenTracker.stopTracking();
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.usersettings_fragment, container, false);
        loginButton = (LoginButton) view.findViewById(R.id.usersettings_fragment_login_button);
        loginButton.setFragment(this);

        connectedStateLabel = (TextView) view.findViewById(R.id.usersettings_fragment_profile_name);

        
        if (view.getBackground() == null) {
            view.setBackgroundColor(getResources().getColor(R.color.com_facebook_blue));
        } else {
            view.getBackground().setDither(true);
        }
        return view;
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setRetainInstance(true);
    }

    
    @Override
    public void onResume() {
        super.onResume();
        fetchUserInfo();
        updateUI();
    }

    private void fetchUserInfo() {
        final AccessToken accessToken = AccessToken.getCurrentAccessToken();
        if (accessToken != null) {
            GraphRequest request = GraphRequest.newMeRequest(
                    accessToken, new GraphRequest.GraphJSONObjectCallback() {
                        @Override
                        public void onCompleted(JSONObject me, GraphResponse response) {
                            user = me;
                            updateUI();
                        }
                    });
            Bundle parameters = new Bundle();
            parameters.putString(FIELDS, REQUEST_FIELDS);
            request.setParameters(parameters);
            GraphRequest.executeBatchAsync(request);
        } else {
            user = null;
        }
    }

    private void updateUI() {
        if (!isAdded()) {
            return;
        }
        if (AccessToken.getCurrentAccessToken() != null) {
            connectedStateLabel.setTextColor(getResources().getColor(
                    R.color.usersettings_fragment_connected_text_color));
            connectedStateLabel.setShadowLayer(1f, 0f, -1f,
                    getResources().getColor(
                            R.color.usersettings_fragment_connected_shadow_color));

            if (user != null) {
                ImageRequest request = getImageRequest();
                if (request != null) {
                    Uri requestUri = request.getImageUri();
                    
                    if (!requestUri.equals(connectedStateLabel.getTag())) {
                        if (user.optString("id").equals(userProfilePicID)) {
                            connectedStateLabel.setCompoundDrawables(
                                    null, userProfilePic, null, null);
                            connectedStateLabel.setTag(requestUri);
                        } else {
                            ImageDownloader.downloadAsync(request);
                        }
                    }
                }
                connectedStateLabel.setText(user.optString("name"));
            } else {
                connectedStateLabel.setText(getResources().getString(
                        R.string.usersettings_fragment_logged_in));
                Drawable noProfilePic = getResources().getDrawable(
                        R.drawable.profile_default_icon);
                noProfilePic.setBounds(0, 0,
                        getResources().getDimensionPixelSize(
                                R.dimen.usersettings_fragment_profile_picture_width),
                        getResources().getDimensionPixelSize(
                                R.dimen.usersettings_fragment_profile_picture_height));
                connectedStateLabel.setCompoundDrawables(null, noProfilePic, null, null);
            }
        } else {
            int textColor = getResources().getColor(
                    R.color.usersettings_fragment_not_connected_text_color);
            connectedStateLabel.setTextColor(textColor);
            connectedStateLabel.setShadowLayer(0f, 0f, 0f, textColor);
            connectedStateLabel.setText(getResources().getString(
                    R.string.usersettings_fragment_not_logged_in));
            connectedStateLabel.setCompoundDrawables(null, null, null, null);
            connectedStateLabel.setTag(null);
        }
    }

    private ImageRequest getImageRequest() {
        ImageRequest request = null;
        ImageRequest.Builder requestBuilder = new ImageRequest.Builder(
                getActivity(),
                ImageRequest.getProfilePictureUri(
                        user.optString("id"),
                        getResources().getDimensionPixelSize(
                                R.dimen.usersettings_fragment_profile_picture_width),
                        getResources().getDimensionPixelSize(
                                R.dimen.usersettings_fragment_profile_picture_height)));

        request = requestBuilder.setCallerTag(this)
                .setCallback(
                        new ImageRequest.Callback() {
                            @Override
                            public void onCompleted(ImageResponse response) {
                                processImageResponse(user.optString("id"), response);
                            }
                        })
                .build();
        return request;
    }

    private void processImageResponse(String id, ImageResponse response) {
        if (response != null) {
            Bitmap bitmap = response.getBitmap();
            if (bitmap != null) {
                BitmapDrawable drawable = new BitmapDrawable(
                        UserSettingsFragment.this.getResources(), bitmap);
                drawable.setBounds(0, 0,
                        getResources().getDimensionPixelSize(
                                R.dimen.usersettings_fragment_profile_picture_width),
                        getResources().getDimensionPixelSize(
                                R.dimen.usersettings_fragment_profile_picture_height));
                userProfilePic = drawable;
                userProfilePicID = id;
                connectedStateLabel.setCompoundDrawables(null, drawable, null, null);
                connectedStateLabel.setTag(response.getRequest().getImageUri());
            }
        }
    }
}

<code block>


package com.facebook;

final class FacebookSdkVersion {
    public static final String BUILD = "4.2.0";
}

<code block>


package com.facebook;

import android.content.Context;
import android.graphics.Bitmap;
import android.location.Location;
import android.net.Uri;
import android.os.*;
import android.text.TextUtils;
import android.util.Log;
import android.util.Pair;

import com.facebook.internal.*;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.*;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLEncoder;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.zip.GZIPOutputStream;


public class GraphRequest {
    
    public static final int MAXIMUM_BATCH_SIZE = 50;

    public static final String TAG = GraphRequest.class.getSimpleName();

    private static final String VIDEOS_SUFFIX = "/videos";
    private static final String ME = "me";
    private static final String MY_FRIENDS = "me/friends";
    private static final String SEARCH = "search";
    private static final String USER_AGENT_BASE = "FBAndroidSDK";
    private static final String USER_AGENT_HEADER = "User-Agent";
    private static final String CONTENT_TYPE_HEADER = "Content-Type";
    private static final String ACCEPT_LANGUAGE_HEADER = "Accept-Language";
    private static final String CONTENT_ENCODING_HEADER = "Content-Encoding";

    
    private static final String FORMAT_PARAM = "format";
    private static final String FORMAT_JSON = "json";
    private static final String SDK_PARAM = "sdk";
    private static final String SDK_ANDROID = "android";
    private static final String ACCESS_TOKEN_PARAM = "access_token";
    private static final String BATCH_ENTRY_NAME_PARAM = "name";
    private static final String BATCH_ENTRY_OMIT_RESPONSE_ON_SUCCESS_PARAM =
            "omit_response_on_success";
    private static final String BATCH_ENTRY_DEPENDS_ON_PARAM = "depends_on";
    private static final String BATCH_APP_ID_PARAM = "batch_app_id";
    private static final String BATCH_RELATIVE_URL_PARAM = "relative_url";
    private static final String BATCH_BODY_PARAM = "body";
    private static final String BATCH_METHOD_PARAM = "method";
    private static final String BATCH_PARAM = "batch";
    private static final String ATTACHMENT_FILENAME_PREFIX = "file";
    private static final String ATTACHED_FILES_PARAM = "attached_files";
    private static final String ISO_8601_FORMAT_STRING = "yyyy-MM-dd'T'HH:mm:ssZ";
    private static final String DEBUG_PARAM = "debug";
    private static final String DEBUG_SEVERITY_INFO = "info";
    private static final String DEBUG_SEVERITY_WARNING = "warning";
    private static final String DEBUG_KEY = "__debug__";
    private static final String DEBUG_MESSAGES_KEY = "messages";
    private static final String DEBUG_MESSAGE_KEY = "message";
    private static final String DEBUG_MESSAGE_TYPE_KEY = "type";
    private static final String DEBUG_MESSAGE_LINK_KEY = "link";

    private static final String MIME_BOUNDARY = "3i2ndDfv2rTHiSisAbouNdArYfORhtTPEefj3q2f";

    private static String defaultBatchApplicationId;

    
    private static Pattern versionPattern = Pattern.compile("^/?v\\d+\\.\\d+/(.*)");

    private AccessToken accessToken;
    private HttpMethod httpMethod;
    private String graphPath;
    private JSONObject graphObject;
    private String batchEntryName;
    private String batchEntryDependsOn;
    private boolean batchEntryOmitResultOnSuccess = true;
    private Bundle parameters;
    private Callback callback;
    private String overriddenURL;
    private Object tag;
    private String version;
    private boolean skipClientToken = false;

    
    public GraphRequest() {
        this(null, null, null, null, null);
    }

    
    public GraphRequest(AccessToken accessToken, String graphPath) {
        this(accessToken, graphPath, null, null, null);
    }

    
    public GraphRequest(
            AccessToken accessToken,
            String graphPath,
            Bundle parameters,
            HttpMethod httpMethod) {
        this(accessToken, graphPath, parameters, httpMethod, null);
    }

    
    public GraphRequest(
            AccessToken accessToken,
            String graphPath,
            Bundle parameters,
            HttpMethod httpMethod,
            Callback callback) {
        this(accessToken, graphPath, parameters, httpMethod, callback, null);
    }

    
    public GraphRequest(
            AccessToken accessToken,
            String graphPath,
            Bundle parameters,
            HttpMethod httpMethod,
            Callback callback,
            String version) {
        this.accessToken = accessToken;
        this.graphPath = graphPath;
        this.version = version;

        setCallback(callback);
        setHttpMethod(httpMethod);

        if (parameters != null) {
            this.parameters = new Bundle(parameters);
        } else {
            this.parameters = new Bundle();
        }

        if (this.version == null) {
            this.version = ServerProtocol.getAPIVersion();
        }
    }

    GraphRequest(AccessToken accessToken, URL overriddenURL) {
        this.accessToken = accessToken;
        this.overriddenURL = overriddenURL.toString();

        setHttpMethod(HttpMethod.GET);

        this.parameters = new Bundle();
    }

    
    public static GraphRequest newDeleteObjectRequest(
            AccessToken accessToken,
            String id,
            Callback callback) {
        return new GraphRequest(accessToken, id, null, HttpMethod.DELETE, callback);
    }

    
    public static GraphRequest newMeRequest(
            AccessToken accessToken,
            final GraphJSONObjectCallback callback) {
        Callback wrapper = new Callback() {
            @Override
            public void onCompleted(GraphResponse response) {
                if (callback != null) {
                    callback.onCompleted(response.getJSONObject(), response);
                }
            }
        };
        return new GraphRequest(accessToken, ME, null, null, wrapper);
    }

    
    public static GraphRequest newPostRequest(
            AccessToken accessToken,
            String graphPath,
            JSONObject graphObject,
            Callback callback) {
        GraphRequest request = new GraphRequest(
                accessToken,
                graphPath,
                null,
                HttpMethod.POST,
                callback);
        request.setGraphObject(graphObject);
        return request;
    }

    
    public static GraphRequest newMyFriendsRequest(
            AccessToken accessToken,
            final GraphJSONArrayCallback callback) {
        Callback wrapper = new Callback() {
            @Override
            public void onCompleted(GraphResponse response) {
                if (callback != null) {
                    JSONObject result = response.getJSONObject();
                    JSONArray data = result != null ? result.optJSONArray("data") : null;
                    callback.onCompleted(data, response);
                }
            }
        };
        return new GraphRequest(accessToken, MY_FRIENDS, null, null, wrapper);
    }

    
    public static GraphRequest newGraphPathRequest(
            AccessToken accessToken,
            String graphPath,
            Callback callback) {
        return new GraphRequest(accessToken, graphPath, null, null, callback);
    }

    
    public static GraphRequest newPlacesSearchRequest(
            AccessToken accessToken,
            Location location,
            int radiusInMeters,
            int resultsLimit,
            String searchText,
            final GraphJSONArrayCallback callback) {
        if (location == null && Utility.isNullOrEmpty(searchText)) {
            throw new FacebookException("Either location or searchText must be specified.");
        }

        Bundle parameters = new Bundle(5);
        parameters.putString("type", "place");
        parameters.putInt("limit", resultsLimit);
        if (location != null) {
            parameters.putString("center",
                    String.format(
                            Locale.US,
                            "%f,%f",
                            location.getLatitude(),
                            location.getLongitude()));
            parameters.putInt("distance", radiusInMeters);
        }
        if (!Utility.isNullOrEmpty(searchText)) {
            parameters.putString("q", searchText);
        }

        Callback wrapper = new Callback() {
            @Override
            public void onCompleted(GraphResponse response) {
                if (callback != null) {
                    JSONObject result = response.getJSONObject();
                    JSONArray data = result != null ? result.optJSONArray("data") : null;
                    callback.onCompleted(data, response);
                }
            }
        };

        return new GraphRequest(accessToken, SEARCH, parameters, HttpMethod.GET, wrapper);
    }


    
    public static GraphRequest newCustomAudienceThirdPartyIdRequest(AccessToken accessToken,
                                                                    Context context,
                                                                    String applicationId,
                                                                    Callback callback) {

        if (applicationId == null && accessToken != null) {
            applicationId = accessToken.getApplicationId();
        }

        if (applicationId == null) {
            applicationId = Utility.getMetadataApplicationId(context);
        }

        if (applicationId == null) {
            throw new FacebookException("Facebook App ID cannot be determined");
        }

        String endpoint = applicationId + "/custom_audience_third_party_id";
        AttributionIdentifiers attributionIdentifiers =
                AttributionIdentifiers.getAttributionIdentifiers(context);
        Bundle parameters = new Bundle();

        if (accessToken == null) {
            
            
            String udid = attributionIdentifiers.getAttributionId() != null
                    ? attributionIdentifiers.getAttributionId()
                    : attributionIdentifiers.getAndroidAdvertiserId();
            if (attributionIdentifiers.getAttributionId() != null) {
                parameters.putString("udid", udid);
            }
        }

        
        
        if (FacebookSdk.getLimitEventAndDataUsage(context)
                || attributionIdentifiers.isTrackingLimited()) {
            parameters.putString("limit_event_usage", "1");
        }

        return new GraphRequest(accessToken, endpoint, parameters, HttpMethod.GET, callback);
    }

    
    public static GraphRequest newCustomAudienceThirdPartyIdRequest(
            AccessToken accessToken,
            Context context,
            Callback callback) {
        return newCustomAudienceThirdPartyIdRequest(accessToken, context, null, callback);
    }

    
    public final JSONObject getGraphObject() {
        return this.graphObject;
    }

    
    public final void setGraphObject(JSONObject graphObject) {
        this.graphObject = graphObject;
    }

    
    public final String getGraphPath() {
        return this.graphPath;
    }

    
    public final void setGraphPath(String graphPath) {
        this.graphPath = graphPath;
    }

    
    public final HttpMethod getHttpMethod() {
        return this.httpMethod;
    }

    
    public final void setHttpMethod(HttpMethod httpMethod) {
        if (overriddenURL != null && httpMethod != HttpMethod.GET) {
            throw new FacebookException("Can't change HTTP method on request with overridden URL.");
        }
        this.httpMethod = (httpMethod != null) ? httpMethod : HttpMethod.GET;
    }

    
    public final String getVersion() {
        return this.version;
    }

    
    public final void setVersion(String version) {
        this.version = version;
    }

    
    public final void setSkipClientToken(boolean skipClientToken) {
        this.skipClientToken = skipClientToken;
    }

    
    public final Bundle getParameters() {
        return this.parameters;
    }

    
    public final void setParameters(Bundle parameters) {
        this.parameters = parameters;
    }

    
    public final AccessToken getAccessToken() {
        return this.accessToken;
    }

    
    public final void setAccessToken(AccessToken accessToken) {
        this.accessToken = accessToken;
    }

    
    public final String getBatchEntryName() {
        return this.batchEntryName;
    }

    
    public final void setBatchEntryName(String batchEntryName) {
        this.batchEntryName = batchEntryName;
    }

    
    public final String getBatchEntryDependsOn() {
        return this.batchEntryDependsOn;
    }

    
    public final void setBatchEntryDependsOn(String batchEntryDependsOn) {
        this.batchEntryDependsOn = batchEntryDependsOn;
    }


    
    public final boolean getBatchEntryOmitResultOnSuccess() {
        return this.batchEntryOmitResultOnSuccess;
    }

    
    public final void setBatchEntryOmitResultOnSuccess(boolean batchEntryOmitResultOnSuccess) {
        this.batchEntryOmitResultOnSuccess = batchEntryOmitResultOnSuccess;
    }

    
    public static final String getDefaultBatchApplicationId() {
        return GraphRequest.defaultBatchApplicationId;
    }

    
    public static final void setDefaultBatchApplicationId(String applicationId) {
        defaultBatchApplicationId = applicationId;
    }

    
    public final Callback getCallback() {
        return callback;
    }

    
    public final void setCallback(final Callback callback) {
        
        if (FacebookSdk.isLoggingBehaviorEnabled(LoggingBehavior.GRAPH_API_DEBUG_INFO)
                || FacebookSdk.isLoggingBehaviorEnabled(LoggingBehavior.GRAPH_API_DEBUG_WARNING)) {
            Callback wrapper = new Callback() {
                @Override
                public void onCompleted(GraphResponse response) {
                    JSONObject responseObject = response.getJSONObject();
                    JSONObject debug =
                            responseObject != null ? responseObject.optJSONObject(DEBUG_KEY) : null;
                    JSONArray debugMessages =
                            debug != null ? debug.optJSONArray(DEBUG_MESSAGES_KEY) : null;
                    if (debugMessages != null) {
                        for (int i = 0; i < debugMessages.length(); ++i) {
                            JSONObject debugMessageObject = debugMessages.optJSONObject(i);
                            String debugMessage = debugMessageObject != null
                                    ? debugMessageObject.optString(DEBUG_MESSAGE_KEY)
                                    : null;
                            String debugMessageType = debugMessageObject != null
                                    ? debugMessageObject.optString(DEBUG_MESSAGE_TYPE_KEY)
                                    : null;
                            String debugMessageLink = debugMessageObject != null
                                    ? debugMessageObject.optString(DEBUG_MESSAGE_LINK_KEY)
                                    : null;
                            if (debugMessage != null && debugMessageType != null) {
                                LoggingBehavior behavior = LoggingBehavior.GRAPH_API_DEBUG_INFO;
                                if (debugMessageType.equals("warning")) {
                                    behavior = LoggingBehavior.GRAPH_API_DEBUG_WARNING;
                                }
                                if (!Utility.isNullOrEmpty(debugMessageLink)) {
                                    debugMessage += " Link: " + debugMessageLink;
                                }
                                Logger.log(behavior, TAG, debugMessage);
                            }
                        }
                    }
                    if (callback != null) {
                        callback.onCompleted(response);
                    }
                }
            };
            this.callback = wrapper;
        } else {
            this.callback = callback;
        }

    }

    
    public final void setTag(Object tag) {
        this.tag = tag;
    }

    
    public final Object getTag() {
        return tag;
    }

    
    public final GraphResponse executeAndWait() {
        return GraphRequest.executeAndWait(this);
    }

    
    public final GraphRequestAsyncTask executeAsync() {
        return GraphRequest.executeBatchAsync(this);
    }

    
    public static HttpURLConnection toHttpConnection(GraphRequest... requests) {
        return toHttpConnection(Arrays.asList(requests));
    }

    
    public static HttpURLConnection toHttpConnection(Collection<GraphRequest> requests) {
        Validate.notEmptyAndContainsNoNulls(requests, "requests");

        return toHttpConnection(new GraphRequestBatch(requests));
    }

    
    public static HttpURLConnection toHttpConnection(GraphRequestBatch requests) {

        URL url;
        try {
            if (requests.size() == 1) {
                
                GraphRequest request = requests.get(0);
                
                
                url = new URL(request.getUrlForSingleRequest());
            } else {
                
                
                url = new URL(ServerProtocol.getGraphUrlBase());
            }
        } catch (MalformedURLException e) {
            throw new FacebookException("could not construct URL for request", e);
        }

        HttpURLConnection connection;
        try {
            connection = createConnection(url);

            serializeToUrlConnection(requests, connection);
        } catch (IOException e) {
            throw new FacebookException("could not construct request body", e);
        } catch (JSONException e) {
            throw new FacebookException("could not construct request body", e);
        }

        return connection;
    }

    
    public static GraphResponse executeAndWait(GraphRequest request) {
        List<GraphResponse> responses = executeBatchAndWait(request);

        if (responses == null || responses.size() != 1) {
            throw new FacebookException("invalid state: expected a single response");
        }

        return responses.get(0);
    }

    
    public static List<GraphResponse> executeBatchAndWait(GraphRequest... requests) {
        Validate.notNull(requests, "requests");

        return executeBatchAndWait(Arrays.asList(requests));
    }

    
    public static List<GraphResponse> executeBatchAndWait(Collection<GraphRequest> requests) {
        return executeBatchAndWait(new GraphRequestBatch(requests));
    }

    
    public static List<GraphResponse> executeBatchAndWait(GraphRequestBatch requests) {
        Validate.notEmptyAndContainsNoNulls(requests, "requests");

        HttpURLConnection connection = null;
        try {
            connection = toHttpConnection(requests);
        } catch (Exception ex) {
            List<GraphResponse> responses = GraphResponse.constructErrorResponses(
                    requests.getRequests(),
                    null,
                    new FacebookException(ex));
            runCallbacks(requests, responses);
            return responses;
        }

        List<GraphResponse> responses = executeConnectionAndWait(connection, requests);
        return responses;
    }

    
    public static GraphRequestAsyncTask executeBatchAsync(GraphRequest... requests) {
        Validate.notNull(requests, "requests");

        return executeBatchAsync(Arrays.asList(requests));
    }

    
    public static GraphRequestAsyncTask executeBatchAsync(Collection<GraphRequest> requests) {
        return executeBatchAsync(new GraphRequestBatch(requests));
    }

    
    public static GraphRequestAsyncTask executeBatchAsync(GraphRequestBatch requests) {
        Validate.notEmptyAndContainsNoNulls(requests, "requests");

        GraphRequestAsyncTask asyncTask = new GraphRequestAsyncTask(requests);
        asyncTask.executeOnSettingsExecutor();
        return asyncTask;
    }

    
    public static List<GraphResponse> executeConnectionAndWait(
            HttpURLConnection connection,
            Collection<GraphRequest> requests) {
        return executeConnectionAndWait(connection, new GraphRequestBatch(requests));
    }

    
    public static List<GraphResponse> executeConnectionAndWait(
            HttpURLConnection connection,
            GraphRequestBatch requests) {
        List<GraphResponse> responses = GraphResponse.fromHttpConnection(connection, requests);

        Utility.disconnectQuietly(connection);

        int numRequests = requests.size();
        if (numRequests != responses.size()) {
            throw new FacebookException(
                    String.format(Locale.US,
                            "Received %d responses while expecting %d",
                            responses.size(),
                            numRequests));
        }

        runCallbacks(requests, responses);

        
        AccessTokenManager.getInstance().extendAccessTokenIfNeeded();

        return responses;
    }

    
    public static GraphRequestAsyncTask executeConnectionAsync(
            HttpURLConnection connection,
            GraphRequestBatch requests) {
        return executeConnectionAsync(null, connection, requests);
    }

    
    public static GraphRequestAsyncTask executeConnectionAsync(
            Handler callbackHandler,
            HttpURLConnection connection,
            GraphRequestBatch requests) {
        Validate.notNull(connection, "connection");

        GraphRequestAsyncTask asyncTask = new GraphRequestAsyncTask(connection, requests);
        requests.setCallbackHandler(callbackHandler);
        asyncTask.executeOnSettingsExecutor();
        return asyncTask;
    }

    
    @Override
    public String toString() {
        return new StringBuilder()
                .append("{Request: ")
                .append(" accessToken: ")
                .append(accessToken == null ? "null" : accessToken)
                .append(", graphPath: ")
                .append(graphPath)
                .append(", graphObject: ")
                .append(graphObject)
                .append(", httpMethod: ")
                .append(httpMethod)
                .append(", parameters: ")
                .append(parameters)
                .append("}")
                .toString();
    }

    static void runCallbacks(final GraphRequestBatch requests, List<GraphResponse> responses) {
        int numRequests = requests.size();

        
        
        final ArrayList<Pair<Callback, GraphResponse>> callbacks = new ArrayList<Pair<Callback, GraphResponse>>();
        for (int i = 0; i < numRequests; ++i) {
            GraphRequest request = requests.get(i);
            if (request.callback != null) {
                callbacks.add(
                        new Pair<Callback, GraphResponse>(request.callback, responses.get(i)));
            }
        }

        if (callbacks.size() > 0) {
            Runnable runnable = new Runnable() {
                public void run() {
                    for (Pair<Callback, GraphResponse> pair : callbacks) {
                        pair.first.onCompleted(pair.second);
                    }

                    List<GraphRequestBatch.Callback> batchCallbacks = requests.getCallbacks();
                    for (GraphRequestBatch.Callback batchCallback : batchCallbacks) {
                        batchCallback.onBatchCompleted(requests);
                    }
                }
            };

            Handler callbackHandler = requests.getCallbackHandler();
            if (callbackHandler == null) {
                
                runnable.run();
            } else {
                
                callbackHandler.post(runnable);
            }
        }
    }

    private static HttpURLConnection createConnection(URL url) throws IOException {
        HttpURLConnection connection;
        connection = (HttpURLConnection) url.openConnection();

        connection.setRequestProperty(USER_AGENT_HEADER, getUserAgent());
        connection.setRequestProperty(ACCEPT_LANGUAGE_HEADER, Locale.getDefault().toString());

        connection.setChunkedStreamingMode(0);
        return connection;
    }


    private void addCommonParameters() {
        if (this.accessToken != null) {
            if (!this.parameters.containsKey(ACCESS_TOKEN_PARAM)) {
                String token = accessToken.getToken();
                Logger.registerAccessToken(token);
                this.parameters.putString(ACCESS_TOKEN_PARAM, token);
            }
        } else if (!skipClientToken && !this.parameters.containsKey(ACCESS_TOKEN_PARAM)) {
            String appID = FacebookSdk.getApplicationId();
            String clientToken = FacebookSdk.getClientToken();
            if (!Utility.isNullOrEmpty(appID) && !Utility.isNullOrEmpty(clientToken)) {
                String accessToken = appID + "|" + clientToken;
                this.parameters.putString(ACCESS_TOKEN_PARAM, accessToken);
            } else {
                Log.d(TAG, "Warning: Request without access token missing application ID or" +
                        " client token.");
            }
        }
        this.parameters.putString(SDK_PARAM, SDK_ANDROID);
        this.parameters.putString(FORMAT_PARAM, FORMAT_JSON);

        if (FacebookSdk.isLoggingBehaviorEnabled(LoggingBehavior.GRAPH_API_DEBUG_INFO)) {
            this.parameters.putString(DEBUG_PARAM, DEBUG_SEVERITY_INFO);
        } else if (FacebookSdk.isLoggingBehaviorEnabled(LoggingBehavior.GRAPH_API_DEBUG_WARNING)) {
            this.parameters.putString(DEBUG_PARAM, DEBUG_SEVERITY_WARNING);
        }
    }

    private String appendParametersToBaseUrl(String baseUrl) {
        Uri.Builder uriBuilder = new Uri.Builder().encodedPath(baseUrl);

        Set<String> keys = this.parameters.keySet();
        for (String key : keys) {
            Object value = this.parameters.get(key);

            if (value == null) {
                value = "";
            }

            if (isSupportedParameterType(value)) {
                value = parameterToString(value);
            } else {
                if (httpMethod == HttpMethod.GET) {
                    throw new IllegalArgumentException(
                            String.format(
                                    Locale.US,
                                    "Unsupported parameter type for GET request: %s",
                                    value.getClass().getSimpleName()));
                }
                continue;
            }

            uriBuilder.appendQueryParameter(key, value.toString());
        }

        return uriBuilder.toString();
    }

    final String getUrlForBatchedRequest() {
        if (overriddenURL != null) {
            throw new FacebookException("Can't override URL for a batch request");
        }

        String baseUrl = getGraphPathWithVersion();
        addCommonParameters();
        return appendParametersToBaseUrl(baseUrl);
    }

    final String getUrlForSingleRequest() {
        if (overriddenURL != null) {
            return overriddenURL.toString();
        }

        String graphBaseUrlBase;
        if (this.getHttpMethod() == HttpMethod.POST
                && graphPath != null
                && graphPath.endsWith(VIDEOS_SUFFIX)) {
            graphBaseUrlBase = ServerProtocol.getGraphVideoUrlBase();
        } else {
            graphBaseUrlBase = ServerProtocol.getGraphUrlBase();
        }
        String baseUrl = String.format("%s/%s", graphBaseUrlBase, getGraphPathWithVersion());

        addCommonParameters();
        return appendParametersToBaseUrl(baseUrl);
    }

    private String getGraphPathWithVersion() {
        Matcher matcher = versionPattern.matcher(this.graphPath);
        if (matcher.matches()) {
            return this.graphPath;
        }
        return String.format("%s/%s", this.version, this.graphPath);
    }

    private static class Attachment {
        private final GraphRequest request;
        private final Object value;

        public Attachment(GraphRequest request, Object value) {
            this.request = request;
            this.value = value;
        }

        public GraphRequest getRequest() {
            return request;
        }

        public Object getValue() {
            return value;
        }
    }

    private void serializeToBatch(
            JSONArray batch,
            Map<String, Attachment> attachments
    ) throws JSONException, IOException {
        JSONObject batchEntry = new JSONObject();

        if (this.batchEntryName != null) {
            batchEntry.put(BATCH_ENTRY_NAME_PARAM, this.batchEntryName);
            batchEntry.put(
                    BATCH_ENTRY_OMIT_RESPONSE_ON_SUCCESS_PARAM,
                    this.batchEntryOmitResultOnSuccess);
        }
        if (this.batchEntryDependsOn != null) {
            batchEntry.put(BATCH_ENTRY_DEPENDS_ON_PARAM, this.batchEntryDependsOn);
        }

        String relativeURL = getUrlForBatchedRequest();
        batchEntry.put(BATCH_RELATIVE_URL_PARAM, relativeURL);
        batchEntry.put(BATCH_METHOD_PARAM, httpMethod);
        if (this.accessToken != null) {
            String token = this.accessToken.getToken();
            Logger.registerAccessToken(token);
        }

        
        ArrayList<String> attachmentNames = new ArrayList<String>();
        Set<String> keys = this.parameters.keySet();
        for (String key : keys) {
            Object value = this.parameters.get(key);
            if (isSupportedAttachmentType(value)) {
                
                String name = String.format(
                        Locale.ROOT,
                        "%s%d",
                        ATTACHMENT_FILENAME_PREFIX,
                        attachments.size());
                attachmentNames.add(name);
                attachments.put(name, new Attachment(this, value));
            }
        }

        if (!attachmentNames.isEmpty()) {
            String attachmentNamesString = TextUtils.join(",", attachmentNames);
            batchEntry.put(ATTACHED_FILES_PARAM, attachmentNamesString);
        }

        if (this.graphObject != null) {
            
            final ArrayList<String> keysAndValues = new ArrayList<String>();
            processGraphObject(this.graphObject, relativeURL, new KeyValueSerializer() {
                @Override
                public void writeString(String key, String value) throws IOException {
                    keysAndValues.add(String.format(
                            Locale.US,
                            "%s=%s",
                            key,
                            URLEncoder.encode(value, "UTF-8")));
                }
            });
            String bodyValue = TextUtils.join("&", keysAndValues);
            batchEntry.put(BATCH_BODY_PARAM, bodyValue);
        }

        batch.put(batchEntry);
    }

    private static boolean hasOnProgressCallbacks(GraphRequestBatch requests) {
        for (GraphRequestBatch.Callback callback : requests.getCallbacks()) {
            if (callback instanceof GraphRequestBatch.OnProgressCallback) {
                return true;
            }
        }

        for (GraphRequest request : requests) {
            if (request.getCallback() instanceof OnProgressCallback) {
                return true;
            }
        }

        return false;
    }

    private static void setConnectionContentType(
            HttpURLConnection connection,
            boolean shouldUseGzip) {
        if (shouldUseGzip) {
            connection.setRequestProperty(CONTENT_TYPE_HEADER, "application/x-www-form-urlencoded");
            connection.setRequestProperty(CONTENT_ENCODING_HEADER, "gzip");
        } else {
            connection.setRequestProperty(CONTENT_TYPE_HEADER, getMimeContentType());
        }
    }

    private static boolean isGzipCompressible(GraphRequestBatch requests) {
        for (GraphRequest request : requests) {
            for (String key : request.parameters.keySet()) {
                Object value = request.parameters.get(key);
                if (isSupportedAttachmentType(value)) {
                    return false;
                }
            }
        }
        return true;
    }

    final static void serializeToUrlConnection(
            GraphRequestBatch requests,
            HttpURLConnection connection
    ) throws IOException, JSONException {
        Logger logger = new Logger(LoggingBehavior.REQUESTS, "Request");

        int numRequests = requests.size();
        boolean shouldUseGzip = isGzipCompressible(requests);

        HttpMethod connectionHttpMethod =
                (numRequests == 1) ? requests.get(0).httpMethod : HttpMethod.POST;
        connection.setRequestMethod(connectionHttpMethod.name());
        setConnectionContentType(connection, shouldUseGzip);

        URL url = connection.getURL();
        logger.append("Request:\n");
        logger.appendKeyValue("Id", requests.getId());
        logger.appendKeyValue("URL", url);
        logger.appendKeyValue("Method", connection.getRequestMethod());
        logger.appendKeyValue("User-Agent", connection.getRequestProperty("User-Agent"));
        logger.appendKeyValue("Content-Type", connection.getRequestProperty("Content-Type"));

        connection.setConnectTimeout(requests.getTimeout());
        connection.setReadTimeout(requests.getTimeout());

        
        
        boolean isPost = (connectionHttpMethod == HttpMethod.POST);
        if (!isPost) {
            logger.log();
            return;
        }

        connection.setDoOutput(true);

        OutputStream outputStream = null;
        try {
            outputStream = new BufferedOutputStream(connection.getOutputStream());
            if (shouldUseGzip) {
                outputStream = new GZIPOutputStream(outputStream);
            }

            if (hasOnProgressCallbacks(requests)) {
                ProgressNoopOutputStream countingStream = null;
                countingStream = new ProgressNoopOutputStream(requests.getCallbackHandler());
                processRequest(requests, null, numRequests, url, countingStream, shouldUseGzip);

                int max = countingStream.getMaxProgress();
                Map<GraphRequest, RequestProgress> progressMap = countingStream.getProgressMap();

                outputStream = new ProgressOutputStream(outputStream, requests, progressMap, max);
            }

            processRequest(requests, logger, numRequests, url, outputStream, shouldUseGzip);
        } finally {
            if (outputStream != null) {
                outputStream.close();
            }
        }

        logger.log();
    }

    private static void processRequest(GraphRequestBatch requests, Logger logger, int numRequests,
                                       URL url, OutputStream outputStream, boolean shouldUseGzip)
            throws IOException, JSONException {
        Serializer serializer = new Serializer(outputStream, logger, shouldUseGzip);

        if (numRequests == 1) {
            GraphRequest request = requests.get(0);

            Map<String, Attachment> attachments = new HashMap<String, Attachment>();
            for (String key : request.parameters.keySet()) {
                Object value = request.parameters.get(key);
                if (isSupportedAttachmentType(value)) {
                    attachments.put(key, new Attachment(request, value));
                }
            }

            if (logger != null) {
                logger.append("  Parameters:\n");
            }
            serializeParameters(request.parameters, serializer, request);

            if (logger != null) {
                logger.append("  Attachments:\n");
            }
            serializeAttachments(attachments, serializer);

            if (request.graphObject != null) {
                processGraphObject(request.graphObject, url.getPath(), serializer);
            }
        } else {
            String batchAppID = getBatchAppId(requests);
            if (Utility.isNullOrEmpty(batchAppID)) {
                throw new FacebookException(
                        "App ID was not specified at the request or Settings.");
            }

            serializer.writeString(BATCH_APP_ID_PARAM, batchAppID);

            
            
            Map<String, Attachment> attachments = new HashMap<String, Attachment>();
            serializeRequestsAsJSON(serializer, requests, attachments);

            if (logger != null) {
                logger.append("  Attachments:\n");
            }
            serializeAttachments(attachments, serializer);
        }
    }

    private static boolean isMeRequest(String path) {
        Matcher matcher = versionPattern.matcher(path);
        if (matcher.matches()) {
            
            path = matcher.group(1);
        }
        if (path.startsWith("me/") || path.startsWith("/me/")) {
            return true;
        }
        return false;
    }

    private static void processGraphObject(
            JSONObject graphObject,
            String path,
            KeyValueSerializer serializer
    ) throws IOException {
        
        
        
        
        
        
        boolean isOGAction = false;
        if (isMeRequest(path)) {
            int colonLocation = path.indexOf(":");
            int questionMarkLocation = path.indexOf("?");
            isOGAction = colonLocation > 3
                    && (questionMarkLocation == -1 || colonLocation < questionMarkLocation);
        }

        Iterator<String> keyIterator = graphObject.keys();
        while (keyIterator.hasNext()) {
            String key = keyIterator.next();
            Object value = graphObject.opt(key);
            boolean passByValue = isOGAction && key.equalsIgnoreCase("image");
            processGraphObjectProperty(key, value, serializer, passByValue);
        }
    }

    private static void processGraphObjectProperty(
            String key,
            Object value,
            KeyValueSerializer serializer,
            boolean passByValue
    ) throws IOException {
        Class<?> valueClass = value.getClass();

        if (JSONObject.class.isAssignableFrom(valueClass)) {
            JSONObject jsonObject = (JSONObject) value;
            if (passByValue) {
                
                @SuppressWarnings("unchecked")
                Iterator<String> keys = jsonObject.keys();
                while (keys.hasNext()) {
                    String propertyName = keys.next();
                    String subKey = String.format("%s[%s]", key, propertyName);
                    processGraphObjectProperty(
                            subKey,
                            jsonObject.opt(propertyName),
                            serializer,
                            passByValue);
                }
            } else {
                
                
                if (jsonObject.has("id")) {
                    processGraphObjectProperty(
                            key,
                            jsonObject.optString("id"),
                            serializer,
                            passByValue);
                } else if (jsonObject.has("url")) {
                    processGraphObjectProperty(
                            key,
                            jsonObject.optString("url"),
                            serializer,
                            passByValue);
                } else if (jsonObject.has(NativeProtocol.OPEN_GRAPH_CREATE_OBJECT_KEY)) {
                    processGraphObjectProperty(key, jsonObject.toString(), serializer, passByValue);
                }
            }
        } else if (JSONArray.class.isAssignableFrom(valueClass)) {
            JSONArray jsonArray = (JSONArray) value;
            int length = jsonArray.length();
            for (int i = 0; i < length; ++i) {
                String subKey = String.format(Locale.ROOT, "%s[%d]", key, i);
                processGraphObjectProperty(subKey, jsonArray.opt(i), serializer, passByValue);
            }
        } else if (String.class.isAssignableFrom(valueClass) ||
                Number.class.isAssignableFrom(valueClass) ||
                Boolean.class.isAssignableFrom(valueClass)) {
            serializer.writeString(key, value.toString());
        } else if (Date.class.isAssignableFrom(valueClass)) {
            Date date = (Date) value;
            
            
            
            
            
            
            final SimpleDateFormat iso8601DateFormat = new SimpleDateFormat(
                    ISO_8601_FORMAT_STRING,
                    Locale.US);
            serializer.writeString(key, iso8601DateFormat.format(date));
        }
    }

    private static void serializeParameters(
            Bundle bundle,
            Serializer serializer,
            GraphRequest request
    ) throws IOException {
        Set<String> keys = bundle.keySet();

        for (String key : keys) {
            Object value = bundle.get(key);
            if (isSupportedParameterType(value)) {
                serializer.writeObject(key, value, request);
            }
        }
    }

    private static void serializeAttachments(
            Map<String, Attachment> attachments,
            Serializer serializer
    ) throws IOException {
        Set<String> keys = attachments.keySet();

        for (String key : keys) {
            Attachment attachment = attachments.get(key);
            if (isSupportedAttachmentType(attachment.getValue())) {
                serializer.writeObject(key, attachment.getValue(), attachment.getRequest());
            }
        }
    }

    private static void serializeRequestsAsJSON(
            Serializer serializer,
            Collection<GraphRequest> requests,
            Map<String, Attachment> attachments
    ) throws JSONException, IOException {
        JSONArray batch = new JSONArray();
        for (GraphRequest request : requests) {
            request.serializeToBatch(batch, attachments);
        }

        serializer.writeRequestsAsJson(BATCH_PARAM, batch, requests);
    }

    private static String getMimeContentType() {
        return String.format("multipart/form-data; boundary=%s", MIME_BOUNDARY);
    }

    private static volatile String userAgent;

    private static String getUserAgent() {
        if (userAgent == null) {
            userAgent = String.format("%s.%s", USER_AGENT_BASE, FacebookSdkVersion.BUILD);
        }

        return userAgent;
    }

    private static String getBatchAppId(GraphRequestBatch batch) {
        if (!Utility.isNullOrEmpty(batch.getBatchApplicationId())) {
            return batch.getBatchApplicationId();
        }

        for (GraphRequest request : batch) {
            AccessToken accessToken = request.accessToken;
            if (accessToken != null) {
                String applicationId = accessToken.getApplicationId();
                if (applicationId != null) {
                    return applicationId;
                }
            }
        }
        if (!Utility.isNullOrEmpty(GraphRequest.defaultBatchApplicationId)) {
            return GraphRequest.defaultBatchApplicationId;
        }
        return FacebookSdk.getApplicationId();
    }

    private static boolean isSupportedAttachmentType(Object value) {
        return value instanceof Bitmap ||
                value instanceof byte[] ||
                value instanceof Uri ||
                value instanceof ParcelFileDescriptor ||
                value instanceof ParcelableResourceWithMimeType;
    }

    private static boolean isSupportedParameterType(Object value) {
        return value instanceof String || value instanceof Boolean || value instanceof Number ||
                value instanceof Date;
    }

    private static String parameterToString(Object value) {
        if (value instanceof String) {
            return (String) value;
        } else if (value instanceof Boolean || value instanceof Number) {
            return value.toString();
        } else if (value instanceof Date) {
            final SimpleDateFormat iso8601DateFormat = new SimpleDateFormat(
                    ISO_8601_FORMAT_STRING, Locale.US);
            return iso8601DateFormat.format(value);
        }
        throw new IllegalArgumentException("Unsupported parameter type.");
    }

    private interface KeyValueSerializer {
        void writeString(String key, String value) throws IOException;
    }

    private static class Serializer implements KeyValueSerializer {
        private final OutputStream outputStream;
        private final Logger logger;
        private boolean firstWrite = true;
        private boolean useUrlEncode = false;

        public Serializer(OutputStream outputStream, Logger logger, boolean useUrlEncode) {
            this.outputStream = outputStream;
            this.logger = logger;
            this.useUrlEncode = useUrlEncode;
        }

        public void writeObject(String key, Object value, GraphRequest request) throws IOException {
            if (outputStream instanceof RequestOutputStream) {
                ((RequestOutputStream) outputStream).setCurrentRequest(request);
            }

            if (isSupportedParameterType(value)) {
                writeString(key, parameterToString(value));
            } else if (value instanceof Bitmap) {
                writeBitmap(key, (Bitmap) value);
            } else if (value instanceof byte[]) {
                writeBytes(key, (byte[]) value);
            } else if (value instanceof Uri) {
                writeContentUri(key, (Uri) value, null);
            } else if (value instanceof ParcelFileDescriptor) {
                writeFile(key, (ParcelFileDescriptor) value, null);
            } else if (value instanceof ParcelableResourceWithMimeType) {
                ParcelableResourceWithMimeType resourceWithMimeType =
                        (ParcelableResourceWithMimeType) value;
                Parcelable resource = resourceWithMimeType.getResource();
                String mimeType = resourceWithMimeType.getMimeType();
                if (resource instanceof ParcelFileDescriptor) {
                    writeFile(key, (ParcelFileDescriptor) resource, mimeType);
                } else if (resource instanceof Uri) {
                    writeContentUri(key, (Uri) resource, mimeType);
                } else {
                    throw getInvalidTypeError();
                }
            } else {
                throw getInvalidTypeError();
            }
        }

        private RuntimeException getInvalidTypeError() {
            return new IllegalArgumentException("value is not a supported type.");
        }

        public void writeRequestsAsJson(
                String key,
                JSONArray requestJsonArray,
                Collection<GraphRequest> requests
        ) throws IOException, JSONException {
            if (!(outputStream instanceof RequestOutputStream)) {
                writeString(key, requestJsonArray.toString());
                return;
            }

            RequestOutputStream requestOutputStream = (RequestOutputStream) outputStream;
            writeContentDisposition(key, null, null);
            write("[");
            int i = 0;
            for (GraphRequest request : requests) {
                JSONObject requestJson = requestJsonArray.getJSONObject(i);
                requestOutputStream.setCurrentRequest(request);
                if (i > 0) {
                    write(",%s", requestJson.toString());
                } else {
                    write("%s", requestJson.toString());
                }
                i++;
            }
            write("]");
            if (logger != null) {
                logger.appendKeyValue("    " + key, requestJsonArray.toString());
            }
        }

        public void writeString(String key, String value) throws IOException {
            writeContentDisposition(key, null, null);
            writeLine("%s", value);
            writeRecordBoundary();
            if (logger != null) {
                logger.appendKeyValue("    " + key, value);
            }
        }

        public void writeBitmap(String key, Bitmap bitmap) throws IOException {
            writeContentDisposition(key, key, "image/png");
            
            bitmap.compress(Bitmap.CompressFormat.PNG, 100, outputStream);
            writeLine("");
            writeRecordBoundary();
            if (logger != null) {
                logger.appendKeyValue("    " + key, "<Image>");
            }
        }

        public void writeBytes(String key, byte[] bytes) throws IOException {
            writeContentDisposition(key, key, "content/unknown");
            this.outputStream.write(bytes);
            writeLine("");
            writeRecordBoundary();
            if (logger != null) {
                logger.appendKeyValue(
                        "    " + key,
                        String.format(Locale.ROOT, "<Data: %d>", bytes.length));
            }
        }

        public void writeContentUri(String key, Uri contentUri, String mimeType)
                throws IOException {
            if (mimeType == null) {
                mimeType = "content/unknown";
            }
            writeContentDisposition(key, key, mimeType);

            InputStream inputStream = FacebookSdk
                    .getApplicationContext()
                    .getContentResolver()
                    .openInputStream(contentUri);

            int totalBytes = 0;
            if (outputStream instanceof ProgressNoopOutputStream) {
                
                long contentSize = Utility.getContentSize(contentUri);

                ((ProgressNoopOutputStream) outputStream).addProgress(contentSize);
            } else {
                totalBytes += Utility.copyAndCloseInputStream(inputStream, outputStream);
            }

            writeLine("");
            writeRecordBoundary();
            if (logger != null) {
                logger.appendKeyValue(
                        "    " + key,
                        String.format(Locale.ROOT, "<Data: %d>", totalBytes));
            }
        }

        public void writeFile(
                String key,
                ParcelFileDescriptor descriptor,
                String mimeType
        ) throws IOException {
            if (mimeType == null) {
                mimeType = "content/unknown";
            }
            writeContentDisposition(key, key, mimeType);

            int totalBytes = 0;

            if (outputStream instanceof ProgressNoopOutputStream) {
                
                ((ProgressNoopOutputStream) outputStream).addProgress(descriptor.getStatSize());
            } else {
                ParcelFileDescriptor.AutoCloseInputStream inputStream =
                        new ParcelFileDescriptor.AutoCloseInputStream(descriptor);
                totalBytes += Utility.copyAndCloseInputStream(inputStream, outputStream);
            }
            writeLine("");
            writeRecordBoundary();
            if (logger != null) {
                logger.appendKeyValue(
                        "    " + key,
                        String.format(Locale.ROOT, "<Data: %d>", totalBytes));
            }
        }

        public void writeRecordBoundary() throws IOException {
            if (!useUrlEncode) {
                writeLine("--%s", MIME_BOUNDARY);
            } else {
                this.outputStream.write("&".getBytes());
            }
        }

        public void writeContentDisposition(
                String name,
                String filename,
                String contentType
        ) throws IOException {
            if (!useUrlEncode) {
                write("Content-Disposition: form-data; name=\"%s\"", name);
                if (filename != null) {
                    write("; filename=\"%s\"", filename);
                }
                writeLine(""); 
                if (contentType != null) {
                    writeLine("%s: %s", CONTENT_TYPE_HEADER, contentType);
                }
                writeLine(""); 
            } else {
                this.outputStream.write(String.format("%s=", name).getBytes());
            }
        }

        public void write(String format, Object... args) throws IOException {
            if (!useUrlEncode) {
                if (firstWrite) {
                    
                    this.outputStream.write("--".getBytes());
                    this.outputStream.write(MIME_BOUNDARY.getBytes());
                    this.outputStream.write("\r\n".getBytes());
                    firstWrite = false;
                }
                this.outputStream.write(String.format(format, args).getBytes());
            } else {
                this.outputStream.write(
                        URLEncoder.encode(
                                String.format(Locale.US, format, args), "UTF-8").getBytes());
            }
        }

        public void writeLine(String format, Object... args) throws IOException {
            write(format, args);
            if (!useUrlEncode) {
                write("\r\n");
            }
        }

    }

    
    public interface Callback {
        
        void onCompleted(GraphResponse response);
    }

    
    public interface OnProgressCallback extends Callback {
        
        void onProgress(long current, long max);
    }

    
    public interface GraphJSONArrayCallback {
        
        void onCompleted(JSONArray objects, GraphResponse response);
    }

    
    public interface GraphJSONObjectCallback {
        
        void onCompleted(JSONObject object, GraphResponse response);
    }

    
    public static class ParcelableResourceWithMimeType<RESOURCE extends Parcelable>
            implements Parcelable {
        private final String mimeType;
        private final RESOURCE resource;

        public String getMimeType() {
            return mimeType;
        }

        public RESOURCE getResource() {
            return resource;
        }

        public int describeContents() {
            return CONTENTS_FILE_DESCRIPTOR;
        }

        public void writeToParcel(Parcel out, int flags) {
            out.writeString(mimeType);
            out.writeParcelable(resource, flags);
        }

        @SuppressWarnings("unused")
        public static final Parcelable.Creator<ParcelableResourceWithMimeType> CREATOR
                = new Parcelable.Creator<ParcelableResourceWithMimeType>() {
            public ParcelableResourceWithMimeType createFromParcel(Parcel in) {
                return new ParcelableResourceWithMimeType(in);
            }

            public ParcelableResourceWithMimeType[] newArray(int size) {
                return new ParcelableResourceWithMimeType[size];
            }
        };

        
        public ParcelableResourceWithMimeType(
                RESOURCE resource,
                String mimeType
        ) {
            this.mimeType = mimeType;
            this.resource = resource;
        }

        private ParcelableResourceWithMimeType(Parcel in) {
            mimeType = in.readString();
            resource = in.readParcelable(FacebookSdk.getApplicationContext().getClassLoader());
        }
    }
}

<code block>


package com.facebook;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.Signature;
import android.os.AsyncTask;
import android.util.Base64;
import android.util.Log;

import com.facebook.appevents.AppEventsLogger;
import com.facebook.internal.AppEventsLoggerUtility;
import com.facebook.internal.BoltsMeasurementEventListener;
import com.facebook.internal.AttributionIdentifiers;
import com.facebook.internal.NativeProtocol;
import com.facebook.internal.Utility;
import com.facebook.internal.Validate;

import org.json.JSONException;
import org.json.JSONObject;

import java.io.File;
import java.lang.reflect.Field;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;


public final class FacebookSdk {
    private static final String TAG = FacebookSdk.class.getCanonicalName();
    private static final HashSet<LoggingBehavior> loggingBehaviors =
            new HashSet<LoggingBehavior>(Arrays.asList(LoggingBehavior.DEVELOPER_ERRORS));
    private static volatile Executor executor;
    private static volatile String applicationId;
    private static volatile String applicationName;
    private static volatile String appClientToken;
    private static volatile int webDialogTheme;
    private static final String FACEBOOK_COM = "facebook.com";
    private static volatile String facebookDomain = FACEBOOK_COM;
    private static AtomicLong onProgressThreshold = new AtomicLong(65536);
    private static volatile boolean isDebugEnabled = BuildConfig.DEBUG;
    private static boolean isLegacyTokenUpgradeSupported = false;
    private static File cacheDir;
    private static Context applicationContext;
    private static final int DEFAULT_CORE_POOL_SIZE = 5;
    private static final int DEFAULT_MAXIMUM_POOL_SIZE = 128;
    private static final int DEFAULT_KEEP_ALIVE = 1;
    private static int callbackRequestCodeOffset = 0xface;
    private static final Object LOCK = new Object();

    private static final int MAX_REQUEST_CODE_RANGE = 100;

    private static final String ATTRIBUTION_PREFERENCES = "com.facebook.sdk.attributionTracking";
    private static final String PUBLISH_ACTIVITY_PATH = "%s/activities";

    private static final BlockingQueue<Runnable> DEFAULT_WORK_QUEUE =
            new LinkedBlockingQueue<Runnable>(10);

    private static final ThreadFactory DEFAULT_THREAD_FACTORY = new ThreadFactory() {
        private final AtomicInteger counter = new AtomicInteger(0);

        public Thread newThread(Runnable runnable) {
            return new Thread(runnable, "FacebookSdk #" + counter.incrementAndGet());
        }
    };

    static final String CALLBACK_OFFSET_CHANGED_AFTER_INIT =
            "The callback request code offset can't be updated once the SDK is initialized.";

    static final String CALLBACK_OFFSET_NEGATIVE =
            "The callback request code offset can't be negative.";


    
    public static final String APPLICATION_ID_PROPERTY = "com.facebook.sdk.ApplicationId";

    
    public static final String APPLICATION_NAME_PROPERTY = "com.facebook.sdk.ApplicationName";

    
    public static final String CLIENT_TOKEN_PROPERTY = "com.facebook.sdk.ClientToken";

    
    public static final String WEB_DIALOG_THEME = "com.facebook.sdk.WebDialogTheme";

    private static Boolean sdkInitialized = false;

    
    public static synchronized void sdkInitialize(
            Context applicationContext,
            int callbackRequestCodeOffset) {
        if (sdkInitialized && callbackRequestCodeOffset != FacebookSdk.callbackRequestCodeOffset) {
            throw new FacebookException(CALLBACK_OFFSET_CHANGED_AFTER_INIT);
        }
        if (callbackRequestCodeOffset < 0) {
            throw new FacebookException(CALLBACK_OFFSET_NEGATIVE);
        }
        FacebookSdk.callbackRequestCodeOffset = callbackRequestCodeOffset;
        sdkInitialize(applicationContext);
    }


    
    public static synchronized void sdkInitialize(Context applicationContext) {
        if (sdkInitialized == true) {
          return;
        }

        Validate.notNull(applicationContext, "applicationContext");

        
        
        Validate.hasFacebookActivity(applicationContext, false);
        Validate.hasInternetPermissions(applicationContext, false);

        FacebookSdk.applicationContext = applicationContext.getApplicationContext();

        
        FacebookSdk.loadDefaultsFromMetadata(FacebookSdk.applicationContext);
        
        Utility.loadAppSettingsAsync(FacebookSdk.applicationContext, applicationId);
        
        NativeProtocol.updateAllAvailableProtocolVersionsAsync();

        BoltsMeasurementEventListener.getInstance(FacebookSdk.applicationContext);

        cacheDir = FacebookSdk.applicationContext.getCacheDir();

        FutureTask<Void> accessTokenLoadFutureTask =
                new FutureTask<Void>(new Callable<Void>() {
                    @Override
                    public Void call() throws Exception {
                        AccessTokenManager.getInstance().loadCurrentAccessToken();
                        ProfileManager.getInstance().loadCurrentProfile();
                        if (AccessToken.getCurrentAccessToken() != null &&
                                Profile.getCurrentProfile() == null) {
                            
                            
                            Profile.fetchProfileForCurrentAccessToken();
                        }
                        return null;
                    }
                });
        getExecutor().execute(accessTokenLoadFutureTask);

        sdkInitialized = true;
    }

    
    public static synchronized boolean isInitialized() {
        return sdkInitialized;
    }

    
    public static Set<LoggingBehavior> getLoggingBehaviors() {
        synchronized (loggingBehaviors) {
            return Collections.unmodifiableSet(new HashSet<LoggingBehavior>(loggingBehaviors));
        }
    }

    
    public static void addLoggingBehavior(LoggingBehavior behavior) {
        synchronized (loggingBehaviors) {
            loggingBehaviors.add(behavior);
            updateGraphDebugBehavior();
        }
    }

    
    public static void removeLoggingBehavior(LoggingBehavior behavior) {
        synchronized (loggingBehaviors) {
            loggingBehaviors.remove(behavior);
        }
    }

    
    public static void clearLoggingBehaviors() {
        synchronized (loggingBehaviors) {
            loggingBehaviors.clear();
        }
    }

    
    public static boolean isLoggingBehaviorEnabled(LoggingBehavior behavior) {
        synchronized (loggingBehaviors) {
            return FacebookSdk.isDebugEnabled() && loggingBehaviors.contains(behavior);
        }
    }

    
    public static boolean isDebugEnabled() {
        return isDebugEnabled;
    }

    
    public static void setIsDebugEnabled(boolean enabled) {
        isDebugEnabled = enabled;
    }

    
    public static boolean isLegacyTokenUpgradeSupported() {
        return isLegacyTokenUpgradeSupported;
    }

    private static void updateGraphDebugBehavior() {
        if (loggingBehaviors.contains(LoggingBehavior.GRAPH_API_DEBUG_INFO)
           && !loggingBehaviors.contains(LoggingBehavior.GRAPH_API_DEBUG_WARNING)) {
            loggingBehaviors.add(LoggingBehavior.GRAPH_API_DEBUG_WARNING);
        }
    }

    
    public static void setLegacyTokenUpgradeSupported(boolean supported) {
        isLegacyTokenUpgradeSupported = supported;
    }

    
    public static Executor getExecutor() {
        synchronized (LOCK) {
            if (FacebookSdk.executor == null) {
                Executor executor = getAsyncTaskExecutor();
                if (executor == null) {
                    executor = new ThreadPoolExecutor(
                            DEFAULT_CORE_POOL_SIZE, DEFAULT_MAXIMUM_POOL_SIZE, DEFAULT_KEEP_ALIVE,
                            TimeUnit.SECONDS, DEFAULT_WORK_QUEUE, DEFAULT_THREAD_FACTORY);
                }
                FacebookSdk.executor = executor;
            }
        }
        return FacebookSdk.executor;
    }

    
    public static void setExecutor(Executor executor) {
        Validate.notNull(executor, "executor");
        synchronized (LOCK) {
            FacebookSdk.executor = executor;
        }
    }

    
    public static String getFacebookDomain() {
        return facebookDomain;
    }

    
    public static void setFacebookDomain(String facebookDomain) {
        if (!BuildConfig.DEBUG) {
            Log.w(TAG, "WARNING: Calling setFacebookDomain from non-DEBUG code.");
        }

        FacebookSdk.facebookDomain = facebookDomain;
    }

    
    public static Context getApplicationContext() {
        Validate.sdkInitialized();
        return applicationContext;
    }

    private static Executor getAsyncTaskExecutor() {
        Field executorField = null;
        try {
            executorField = AsyncTask.class.getField("THREAD_POOL_EXECUTOR");
        } catch (NoSuchFieldException e) {
            return null;
        }

        Object executorObject = null;
        try {
            executorObject = executorField.get(null);
        } catch (IllegalAccessException e) {
            return null;
        }

        if (executorObject == null) {
            return null;
        }

        if (!(executorObject instanceof Executor)) {
            return null;
        }

        return (Executor) executorObject;
    }

    
    public static void publishInstallAsync(final Context context, final String applicationId) {
        
        
        final Context applicationContext = context.getApplicationContext();
        FacebookSdk.getExecutor().execute(new Runnable() {
            @Override
            public void run() {
                FacebookSdk.publishInstallAndWaitForResponse(applicationContext, applicationId);
            }
        });
    }

    static GraphResponse publishInstallAndWaitForResponse(
            final Context context,
            final String applicationId) {
        try {
            if (context == null || applicationId == null) {
                throw new IllegalArgumentException("Both context and applicationId must be non-null");
            }
            AttributionIdentifiers identifiers = AttributionIdentifiers.getAttributionIdentifiers(context);
            SharedPreferences preferences = context.getSharedPreferences(ATTRIBUTION_PREFERENCES, Context.MODE_PRIVATE);
            String pingKey = applicationId+"ping";
            String jsonKey = applicationId+"json";
            long lastPing = preferences.getLong(pingKey, 0);
            String lastResponseJSON = preferences.getString(jsonKey, null);

            JSONObject publishParams;
            try {
                publishParams = AppEventsLoggerUtility.getJSONObjectForGraphAPICall(
                        AppEventsLoggerUtility.GraphAPIActivityType.MOBILE_INSTALL_EVENT,
                        identifiers,
                        AppEventsLogger.getAnonymousAppDeviceGUID(context),
                        getLimitEventAndDataUsage(context),
                        context);
            } catch (JSONException e) {
                throw new FacebookException("An error occurred while publishing install.", e);
            }

            String publishUrl = String.format(PUBLISH_ACTIVITY_PATH, applicationId);
            GraphRequest publishRequest = GraphRequest.newPostRequest(null, publishUrl, publishParams, null);

            if (lastPing != 0) {
                JSONObject graphObject = null;
                try {
                    if (lastResponseJSON != null) {
                        graphObject = new JSONObject(lastResponseJSON);
                    }
                }
                catch (JSONException je) {
                    
                }
                if (graphObject == null) {
                    return GraphResponse.createResponsesFromString(
                            "true",
                            null,
                            new GraphRequestBatch(publishRequest)
                    ).get(0);
                } else {
                    return new GraphResponse(null, null, null, graphObject);
                }

            } else {

                GraphResponse publishResponse = publishRequest.executeAndWait();

                
                SharedPreferences.Editor editor = preferences.edit();
                lastPing = System.currentTimeMillis();
                editor.putLong(pingKey, lastPing);

                
                if (publishResponse.getJSONObject() != null) {
                    editor.putString(jsonKey, publishResponse.getJSONObject().toString());
                }
                editor.apply();

                return publishResponse;
            }
        } catch (Exception e) {
            
            Utility.logd("Facebook-publish", e);
            return new GraphResponse(null, null, new FacebookRequestError(null, e));
        }
    }

    
    public static String getSdkVersion() {
        Validate.sdkInitialized();
        return FacebookSdkVersion.BUILD;
    }

    
    public static boolean getLimitEventAndDataUsage(Context context) {
        Validate.sdkInitialized();
        SharedPreferences preferences = context.getSharedPreferences(
                AppEventsLogger.APP_EVENT_PREFERENCES, Context.MODE_PRIVATE);
        return preferences.getBoolean("limitEventUsage", false);
    }

    
    public static void setLimitEventAndDataUsage(Context context, boolean limitEventUsage) {
        context.getSharedPreferences(AppEventsLogger.APP_EVENT_PREFERENCES, Context.MODE_PRIVATE)
            .edit()
            .putBoolean("limitEventUsage", limitEventUsage)
            .apply();
    }

    
    public static long getOnProgressThreshold() {
        Validate.sdkInitialized();
        return onProgressThreshold.get();
    }

    
    public static void setOnProgressThreshold(long threshold) {
        onProgressThreshold.set(threshold);
    }

    
    static void loadDefaultsFromMetadata(Context context) {
        if (context == null) {
            return;
        }

        ApplicationInfo ai = null;
        try {
            ai = context.getPackageManager().getApplicationInfo(
                    context.getPackageName(), PackageManager.GET_META_DATA);
        } catch (PackageManager.NameNotFoundException e) {
            return;
        }

        if (ai == null || ai.metaData == null) {
            return;
        }

        if (applicationId == null) {
            Object appId = ai.metaData.get(APPLICATION_ID_PROPERTY);
            if (appId instanceof String) {
                applicationId = (String) appId;
            } else if (appId instanceof Integer) {
                applicationId = appId.toString();
            }
        }

        if (applicationName == null) {
            applicationName = ai.metaData.getString(APPLICATION_NAME_PROPERTY);
        }

        if (appClientToken == null) {
            appClientToken = ai.metaData.getString(CLIENT_TOKEN_PROPERTY);
        }

        if (webDialogTheme == 0) {
            setWebDialogTheme(ai.metaData.getInt(WEB_DIALOG_THEME));
        }
    }

    
    public static String getApplicationSignature(Context context) {
        Validate.sdkInitialized();
        if (context == null) {
            return null;
        }
        PackageManager packageManager = context.getPackageManager();
        if (packageManager == null) {
            return null;
        }

        String packageName = context.getPackageName();
        PackageInfo pInfo;
        try {
            pInfo = packageManager.getPackageInfo(packageName, PackageManager.GET_SIGNATURES);
        } catch (PackageManager.NameNotFoundException e) {
            return null;
        }

        Signature[] signatures = pInfo.signatures;
        if (signatures == null || signatures.length == 0) {
            return null;
        }

        MessageDigest md;
        try {
            md = MessageDigest.getInstance("SHA-1");
        } catch (NoSuchAlgorithmException e) {
            return null;
        }

        md.update(pInfo.signatures[0].toByteArray());
        return Base64.encodeToString(md.digest(),  Base64.URL_SAFE | Base64.NO_PADDING);
    }

    
    public static String getApplicationId() {
        Validate.sdkInitialized();
        return applicationId;
    }

    
    public static void setApplicationId(String applicationId) {
        FacebookSdk.applicationId = applicationId;
    }

    
    public static String getApplicationName() {
        Validate.sdkInitialized();
        return applicationName;
    }

    
    public static void setApplicationName(String applicationName) {
        FacebookSdk.applicationName = applicationName;
    }

    
    public static String getClientToken() {
        Validate.sdkInitialized();
        return appClientToken;
    }

    
    public static void setClientToken(String clientToken) {
        appClientToken = clientToken;
    }

    
    public static int getWebDialogTheme() {
        Validate.sdkInitialized();
        return webDialogTheme;
    }

    
    public static void setWebDialogTheme(int theme) {
        webDialogTheme = theme;
    }

    
    public static File getCacheDir() {
        Validate.sdkInitialized();
        return cacheDir;
    }

    
    public static void setCacheDir(File cacheDir) {
        FacebookSdk.cacheDir = cacheDir;
    }

    
    public static int getCallbackRequestCodeOffset() {
        Validate.sdkInitialized();
        return callbackRequestCodeOffset;
    }

    
    public static boolean isFacebookRequestCode(int requestCode) {
        return requestCode >= callbackRequestCodeOffset
                && requestCode < callbackRequestCodeOffset + MAX_REQUEST_CODE_RANGE;
    }
}

<code block>


package com.facebook.internal;

import android.content.Context;
import android.database.Cursor;
import android.net.Uri;
import android.os.Looper;
import android.util.Log;

import com.facebook.FacebookException;

import java.lang.reflect.Method;


public class AttributionIdentifiers {
    private static final String TAG = AttributionIdentifiers.class.getCanonicalName();
    private static final String ATTRIBUTION_ID_CONTENT_PROVIDER =
            "com.facebook.katana.provider.AttributionIdProvider";
    private static final String ATTRIBUTION_ID_CONTENT_PROVIDER_WAKIZASHI =
            "com.facebook.wakizashi.provider.AttributionIdProvider";
    private static final String ATTRIBUTION_ID_COLUMN_NAME = "aid";
    private static final String ANDROID_ID_COLUMN_NAME = "androidid";
    private static final String LIMIT_TRACKING_COLUMN_NAME = "limit_tracking";

    
    private static final int CONNECTION_RESULT_SUCCESS = 0;

    private static final long IDENTIFIER_REFRESH_INTERVAL_MILLIS = 3600 * 1000;

    private String attributionId;
    private String androidAdvertiserId;
    private boolean limitTracking;
    private long fetchTime;

    private static AttributionIdentifiers recentlyFetchedIdentifiers;

    private static AttributionIdentifiers getAndroidId(Context context) {
        AttributionIdentifiers identifiers = new AttributionIdentifiers();
        try {
            
            
            if (Looper.myLooper() == Looper.getMainLooper()) {
              throw new FacebookException("getAndroidId cannot be called on the main thread.");
            }
            Method isGooglePlayServicesAvailable = Utility.getMethodQuietly(
                    "com.google.android.gms.common.GooglePlayServicesUtil",
                    "isGooglePlayServicesAvailable",
                    Context.class
            );

            if (isGooglePlayServicesAvailable == null) {
                return identifiers;
            }

            Object connectionResult = Utility.invokeMethodQuietly(
                    null, isGooglePlayServicesAvailable, context);
            if (!(connectionResult instanceof Integer)
                    || (Integer) connectionResult != CONNECTION_RESULT_SUCCESS) {
                return identifiers;
            }

            Method getAdvertisingIdInfo = Utility.getMethodQuietly(
                    "com.google.android.gms.ads.identifier.AdvertisingIdClient",
                    "getAdvertisingIdInfo",
                    Context.class
            );
            if (getAdvertisingIdInfo == null) {
                return identifiers;
            }
            Object advertisingInfo = Utility.invokeMethodQuietly(
                    null, getAdvertisingIdInfo, context);
            if (advertisingInfo == null) {
                return identifiers;
            }

            Method getId = Utility.getMethodQuietly(advertisingInfo.getClass(), "getId");
            Method isLimitAdTrackingEnabled = Utility.getMethodQuietly(
                    advertisingInfo.getClass(),
                    "isLimitAdTrackingEnabled");
            if (getId == null || isLimitAdTrackingEnabled == null) {
                return identifiers;
            }

            identifiers.androidAdvertiserId =
                    (String) Utility.invokeMethodQuietly(advertisingInfo, getId);
            identifiers.limitTracking = (Boolean) Utility.invokeMethodQuietly(
                    advertisingInfo,
                    isLimitAdTrackingEnabled);
        } catch (Exception e) {
            Utility.logd("android_id", e);
        }
        return identifiers;
    }

    public static AttributionIdentifiers getAttributionIdentifiers(Context context) {
        if (recentlyFetchedIdentifiers != null &&
            System.currentTimeMillis() - recentlyFetchedIdentifiers.fetchTime <
                    IDENTIFIER_REFRESH_INTERVAL_MILLIS) {
            return recentlyFetchedIdentifiers;
        }

        AttributionIdentifiers identifiers = getAndroidId(context);
        Cursor c = null;
        try {
            String [] projection = {
                    ATTRIBUTION_ID_COLUMN_NAME,
                    ANDROID_ID_COLUMN_NAME,
                    LIMIT_TRACKING_COLUMN_NAME};
            Uri providerUri = null;
            if (context.getPackageManager().resolveContentProvider(
                    ATTRIBUTION_ID_CONTENT_PROVIDER, 0) != null) {
                providerUri = Uri.parse("content:
            } else if (context.getPackageManager().resolveContentProvider(
                    ATTRIBUTION_ID_CONTENT_PROVIDER_WAKIZASHI, 0) != null) {
                providerUri = Uri.parse("content:
            }
            if (providerUri == null) {
                return identifiers;
            }
            c = context.getContentResolver().query(providerUri, projection, null, null, null);
            if (c == null || !c.moveToFirst()) {
                return identifiers;
            }
            int attributionColumnIndex = c.getColumnIndex(ATTRIBUTION_ID_COLUMN_NAME);
            int androidIdColumnIndex = c.getColumnIndex(ANDROID_ID_COLUMN_NAME);
            int limitTrackingColumnIndex = c.getColumnIndex(LIMIT_TRACKING_COLUMN_NAME);

            identifiers.attributionId = c.getString(attributionColumnIndex);

            
            
            if (androidIdColumnIndex > 0 && limitTrackingColumnIndex > 0 &&
                    identifiers.getAndroidAdvertiserId() == null) {
                identifiers.androidAdvertiserId = c.getString(androidIdColumnIndex);
                identifiers.limitTracking =
                        Boolean.parseBoolean(c.getString(limitTrackingColumnIndex));
            }
        } catch (Exception e) {
            Log.d(TAG, "Caught unexpected exception in getAttributionId(): " + e.toString());
            return null;
        } finally {
            if (c != null) {
                c.close();
            }
        }

        identifiers.fetchTime = System.currentTimeMillis();
        recentlyFetchedIdentifiers = identifiers;
        return identifiers;
    }

    public String getAttributionId() {
        return attributionId;
    }

    public String getAndroidAdvertiserId() {
        return androidAdvertiserId;
    }

    public boolean isTrackingLimited() {
        return limitTracking;
    }
}

<code block>


package com.facebook.appevents;

import android.app.Activity;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.support.v4.content.LocalBroadcastManager;
import android.util.Log;
import bolts.AppLinks;

import com.facebook.AccessToken;
import com.facebook.FacebookException;
import com.facebook.FacebookRequestError;
import com.facebook.FacebookSdk;
import com.facebook.GraphRequest;
import com.facebook.GraphResponse;
import com.facebook.LoggingBehavior;
import com.facebook.internal.AppEventsLoggerUtility;
import com.facebook.internal.AttributionIdentifiers;
import com.facebook.internal.Logger;
import com.facebook.internal.Utility;
import com.facebook.internal.Validate;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.FileNotFoundException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.io.UnsupportedEncodingException;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Currency;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;



public class AppEventsLogger {
    

    
    public enum FlushBehavior {
        
        AUTO,

        
        EXPLICIT_ONLY,
    }

    
    private static final String TAG = AppEventsLogger.class.getCanonicalName();

    private static final int NUM_LOG_EVENTS_TO_TRY_TO_FLUSH_AFTER = 100;
    private static final int FLUSH_PERIOD_IN_SECONDS = 15;
    private static final int APP_SUPPORTS_ATTRIBUTION_ID_RECHECK_PERIOD_IN_SECONDS = 60 * 60 * 24;
    private static final int FLUSH_APP_SESSION_INFO_IN_SECONDS = 30;

    public static final String APP_EVENT_PREFERENCES = "com.facebook.sdk.appEventPreferences";

    private static final String SOURCE_APPLICATION_HAS_BEEN_SET_BY_THIS_INTENT =
            "_fbSourceApplicationHasBeenSet";

    
    private final String uiName;
    private final AccessTokenAppIdPair accessTokenAppId;

    private static Map<AccessTokenAppIdPair, SessionEventsState> stateMap =
            new ConcurrentHashMap<AccessTokenAppIdPair, SessionEventsState>();
    private static ScheduledThreadPoolExecutor backgroundExecutor;
    private static FlushBehavior flushBehavior = FlushBehavior.AUTO;
    private static boolean requestInFlight;
    private static Context applicationContext;
    private static Object staticLock = new Object();
    private static String anonymousAppDeviceGUID;
    private static String sourceApplication;
    private static boolean isOpenedByApplink;

    private static class AccessTokenAppIdPair implements Serializable {
        private static final long serialVersionUID = 1L;
        private final String accessTokenString;
        private final String applicationId;

        AccessTokenAppIdPair(AccessToken accessToken) {
            this(accessToken.getToken(), FacebookSdk.getApplicationId());
        }

        AccessTokenAppIdPair(String accessTokenString, String applicationId) {
            this.accessTokenString = Utility.isNullOrEmpty(accessTokenString)
                    ? null
                    : accessTokenString;
            this.applicationId = applicationId;
        }

        String getAccessTokenString() {
            return accessTokenString;
        }

        String getApplicationId() {
            return applicationId;
        }

        @Override
        public int hashCode() {
            return (accessTokenString == null ? 0 : accessTokenString.hashCode()) ^
                    (applicationId == null ? 0 : applicationId.hashCode());
        }

        @Override
        public boolean equals(Object o) {
            if (!(o instanceof AccessTokenAppIdPair)) {
                return false;
            }
            AccessTokenAppIdPair p = (AccessTokenAppIdPair) o;
            return Utility.areObjectsEqual(p.accessTokenString, accessTokenString) &&
                    Utility.areObjectsEqual(p.applicationId, applicationId);
        }

        private static class SerializationProxyV1 implements Serializable {
            private static final long serialVersionUID = -2488473066578201069L;
            private final String accessTokenString;
            private final String appId;

            private SerializationProxyV1(String accessTokenString, String appId) {
                this.accessTokenString = accessTokenString;
                this.appId = appId;
            }

            private Object readResolve() {
                return new AccessTokenAppIdPair(accessTokenString, appId);
            }
        }

        private Object writeReplace() {
            return new SerializationProxyV1(accessTokenString, applicationId);
        }
    }

    
    public static void activateApp(Context context) {
        FacebookSdk.sdkInitialize(context);
        activateApp(context, Utility.getMetadataApplicationId(context));
    }

    
    public static void activateApp(Context context, String applicationId) {
        if (context == null || applicationId == null) {
            throw new IllegalArgumentException("Both context and applicationId must be non-null");
        }

        if ((context instanceof Activity)) {
            setSourceApplication((Activity) context);
        } else {
          
          resetSourceApplication();
          Log.d(AppEventsLogger.class.getName(),
              "To set source application the context of activateApp must be an instance of" +
                      " Activity");
        }

        
        
        
        FacebookSdk.publishInstallAsync(context, applicationId);

        final AppEventsLogger logger = new AppEventsLogger(context, applicationId, null);
        final long eventTime = System.currentTimeMillis();
        final String sourceApplicationInfo = getSourceApplication();
        backgroundExecutor.execute(new Runnable() {
            @Override
            public void run() {
                logger.logAppSessionResumeEvent(eventTime, sourceApplicationInfo);
            }
        });
    }

    
    public static void deactivateApp(Context context) {
        deactivateApp(context, Utility.getMetadataApplicationId(context));
    }

    
    public static void deactivateApp(Context context, String applicationId) {
        if (context == null || applicationId == null) {
            throw new IllegalArgumentException("Both context and applicationId must be non-null");
        }

        resetSourceApplication();

        final AppEventsLogger logger = new AppEventsLogger(context, applicationId, null);
        final long eventTime = System.currentTimeMillis();
        backgroundExecutor.execute(new Runnable() {
            @Override
            public void run() {
                logger.logAppSessionSuspendEvent(eventTime);
            }
        });
    }

    private void logAppSessionResumeEvent(long eventTime, String sourceApplicationInfo) {
        PersistedAppSessionInfo.onResume(
                applicationContext,
                accessTokenAppId,
                this,
                eventTime,
                sourceApplicationInfo);
    }

    private void logAppSessionSuspendEvent(long eventTime) {
        PersistedAppSessionInfo.onSuspend(applicationContext, accessTokenAppId, this, eventTime);
    }

    
    public static AppEventsLogger newLogger(Context context) {
        return new AppEventsLogger(context, null, null);
    }

    
    public static AppEventsLogger newLogger(Context context, AccessToken accessToken) {
        return new AppEventsLogger(context, null, accessToken);
    }

    
    public static AppEventsLogger newLogger(
            Context context,
            String applicationId,
            AccessToken accessToken) {
        return new AppEventsLogger(context, applicationId, accessToken);
    }

    
    public static AppEventsLogger newLogger(Context context, String applicationId) {
        return new AppEventsLogger(context, applicationId, null);
    }

    
    public static final String ACTION_APP_EVENTS_FLUSHED = "com.facebook.sdk.APP_EVENTS_FLUSHED";

    public static final String APP_EVENTS_EXTRA_NUM_EVENTS_FLUSHED =
            "com.facebook.sdk.APP_EVENTS_NUM_EVENTS_FLUSHED";
    public static final String APP_EVENTS_EXTRA_FLUSH_RESULT =
            "com.facebook.sdk.APP_EVENTS_FLUSH_RESULT";

    
    public static FlushBehavior getFlushBehavior() {
        synchronized (staticLock) {
            return flushBehavior;
        }
    }

    
    public static void setFlushBehavior(FlushBehavior flushBehavior) {
        synchronized (staticLock) {
            AppEventsLogger.flushBehavior = flushBehavior;
        }
    }

    
    public void logEvent(String eventName) {
        logEvent(eventName, null);
    }

    
    public void logEvent(String eventName, double valueToSum) {
        logEvent(eventName, valueToSum, null);
    }

    
    public void logEvent(String eventName, Bundle parameters) {
        logEvent(eventName, null, parameters, false);
    }

    
    public void logEvent(String eventName, double valueToSum, Bundle parameters) {
        logEvent(eventName, valueToSum, parameters, false);
    }

    
    public void logPurchase(BigDecimal purchaseAmount, Currency currency) {
        logPurchase(purchaseAmount, currency, null);
    }

    
    public void logPurchase(BigDecimal purchaseAmount, Currency currency, Bundle parameters) {

        if (purchaseAmount == null) {
            notifyDeveloperError("purchaseAmount cannot be null");
            return;
        } else if (currency == null) {
            notifyDeveloperError("currency cannot be null");
            return;
        }

        if (parameters == null) {
            parameters = new Bundle();
        }
        parameters.putString(AppEventsConstants.EVENT_PARAM_CURRENCY, currency.getCurrencyCode());

        logEvent(AppEventsConstants.EVENT_NAME_PURCHASED, purchaseAmount.doubleValue(), parameters);
        eagerFlush();
    }

    
    public void flush() {
        flush(FlushReason.EXPLICIT);
    }

    
    public static void onContextStop() {
        
        PersistedEvents.persistEvents(applicationContext, stateMap);
    }

    
    public boolean isValidForAccessToken(AccessToken accessToken) {
        AccessTokenAppIdPair other = new AccessTokenAppIdPair(accessToken);
        return accessTokenAppId.equals(other);
    }

    
    public void logSdkEvent(String eventName, Double valueToSum, Bundle parameters) {
        logEvent(eventName, valueToSum, parameters, true);
    }

    
    public String getApplicationId() {
        return accessTokenAppId.getApplicationId();
    }

    
    
    

    @SuppressWarnings("UnusedDeclaration")
    private enum FlushReason {
        EXPLICIT,
        TIMER,
        SESSION_CHANGE,
        PERSISTED_EVENTS,
        EVENT_THRESHOLD,
        EAGER_FLUSHING_EVENT,
    }

    @SuppressWarnings("UnusedDeclaration")
    private enum FlushResult {
        SUCCESS,
        SERVER_ERROR,
        NO_CONNECTIVITY,
        UNKNOWN_ERROR
    }

    
    private AppEventsLogger(Context context, String applicationId, AccessToken accessToken) {
        Validate.notNull(context, "context");
        uiName = Utility.getActivityName(context);

        if (accessToken == null) {
            accessToken = AccessToken.getCurrentAccessToken();
        }

        
        if (accessToken != null &&
                (applicationId == null || applicationId.equals(accessToken.getApplicationId()))
                ) {
            accessTokenAppId = new AccessTokenAppIdPair(accessToken);
        } else {
            
            if (applicationId == null) {
                applicationId = Utility.getMetadataApplicationId(context);
            }
            accessTokenAppId = new AccessTokenAppIdPair(null, applicationId);
        }

        synchronized (staticLock) {

            if (applicationContext == null) {
                applicationContext = context.getApplicationContext();
            }
        }

        initializeTimersIfNeeded();
    }

    private static void initializeTimersIfNeeded() {
        synchronized (staticLock) {
            if (backgroundExecutor != null) {
                return;
            }
            backgroundExecutor = new ScheduledThreadPoolExecutor(1);
        }

        final Runnable flushRunnable = new Runnable() {
            @Override
            public void run() {
                if (getFlushBehavior() != FlushBehavior.EXPLICIT_ONLY) {
                    flushAndWait(FlushReason.TIMER);
                }
            }
        };

        backgroundExecutor.scheduleAtFixedRate(
                flushRunnable,
                0,
                FLUSH_PERIOD_IN_SECONDS,
                TimeUnit.SECONDS
        );

        final Runnable attributionRecheckRunnable = new Runnable() {
            @Override
            public void run() {
                Set<String> applicationIds = new HashSet<String>();
                synchronized (staticLock) {
                    for (AccessTokenAppIdPair accessTokenAppId : stateMap.keySet()) {
                        applicationIds.add(accessTokenAppId.getApplicationId());
                    }
                }
                for (String applicationId : applicationIds) {
                    Utility.queryAppSettings(applicationId, true);
                }
            }
        };

        backgroundExecutor.scheduleAtFixedRate(
                attributionRecheckRunnable,
                0,
                APP_SUPPORTS_ATTRIBUTION_ID_RECHECK_PERIOD_IN_SECONDS,
                TimeUnit.SECONDS
        );
    }

    private void logEvent(
            String eventName,
            Double valueToSum,
            Bundle parameters,
            boolean isImplicitlyLogged) {
        AppEvent event = new AppEvent(
                uiName,
                eventName,
                valueToSum,
                parameters,
                isImplicitlyLogged);
        logEvent(applicationContext, event, accessTokenAppId);
    }

    private static void logEvent(final Context context,
                                 final AppEvent event,
                                 final AccessTokenAppIdPair accessTokenAppId) {
        FacebookSdk.getExecutor().execute(new Runnable() {
            @Override
            public void run() {
                SessionEventsState state = getSessionEventsState(context, accessTokenAppId);
                state.addEvent(event);
                flushIfNecessary();
            }
        });
    }

    static void eagerFlush() {
        if (getFlushBehavior() != FlushBehavior.EXPLICIT_ONLY) {
            flush(FlushReason.EAGER_FLUSHING_EVENT);
        }
    }

    private static void flushIfNecessary() {
        synchronized (staticLock) {
            if (getFlushBehavior() != FlushBehavior.EXPLICIT_ONLY) {
                if (getAccumulatedEventCount() > NUM_LOG_EVENTS_TO_TRY_TO_FLUSH_AFTER) {
                    flush(FlushReason.EVENT_THRESHOLD);
                }
            }
        }
    }

    private static int getAccumulatedEventCount() {
        synchronized (staticLock) {

            int result = 0;
            for (SessionEventsState state : stateMap.values()) {
                result += state.getAccumulatedEventCount();
            }
            return result;
        }
    }

    
    private static SessionEventsState getSessionEventsState(
            Context context,
            AccessTokenAppIdPair accessTokenAppId) {
        
        
        
        SessionEventsState state = stateMap.get(accessTokenAppId);
        AttributionIdentifiers attributionIdentifiers = null;
        if (state == null) {
            
            
            attributionIdentifiers = AttributionIdentifiers.getAttributionIdentifiers(context);
        }

        synchronized (staticLock) {
            
            state = stateMap.get(accessTokenAppId);
            if (state == null) {
                state = new SessionEventsState(
                        attributionIdentifiers,
                        context.getPackageName(),
                        getAnonymousAppDeviceGUID(context));
                stateMap.put(accessTokenAppId, state);
            }
            return state;
        }
    }

    private static SessionEventsState getSessionEventsState(AccessTokenAppIdPair accessTokenAppId) {
        synchronized (staticLock) {
            return stateMap.get(accessTokenAppId);
        }
    }

    private static void flush(final FlushReason reason) {

        FacebookSdk.getExecutor().execute(new Runnable() {
            @Override
            public void run() {
                flushAndWait(reason);
            }
        });
    }

    private static void flushAndWait(final FlushReason reason) {

        Set<AccessTokenAppIdPair> keysToFlush;
        synchronized (staticLock) {
            if (requestInFlight) {
                return;
            }
            requestInFlight = true;
            keysToFlush = new HashSet<AccessTokenAppIdPair>(stateMap.keySet());
        }

        accumulatePersistedEvents();

        FlushStatistics flushResults = null;
        try {
            flushResults = buildAndExecuteRequests(reason, keysToFlush);
        } catch (Exception e) {
            Utility.logd(TAG, "Caught unexpected exception while flushing: ", e);
        }

        synchronized (staticLock) {
            requestInFlight = false;
        }

        if (flushResults != null) {
            final Intent intent = new Intent(ACTION_APP_EVENTS_FLUSHED);
            intent.putExtra(APP_EVENTS_EXTRA_NUM_EVENTS_FLUSHED, flushResults.numEvents);
            intent.putExtra(APP_EVENTS_EXTRA_FLUSH_RESULT, flushResults.result);
            LocalBroadcastManager.getInstance(applicationContext).sendBroadcast(intent);
        }
    }

    private static FlushStatistics buildAndExecuteRequests(
            FlushReason reason,
            Set<AccessTokenAppIdPair> keysToFlush) {
        FlushStatistics flushResults = new FlushStatistics();

        boolean limitEventUsage = FacebookSdk.getLimitEventAndDataUsage(applicationContext);

        List<GraphRequest> requestsToExecute = new ArrayList<GraphRequest>();
        for (AccessTokenAppIdPair accessTokenAppId : keysToFlush) {
            SessionEventsState sessionEventsState = getSessionEventsState(accessTokenAppId);
            if (sessionEventsState == null) {
                continue;
            }

            GraphRequest request = buildRequestForSession(
                    accessTokenAppId,
                    sessionEventsState,
                    limitEventUsage,
                    flushResults);
            if (request != null) {
                requestsToExecute.add(request);
            }
        }

        if (requestsToExecute.size() > 0) {
            Logger.log(LoggingBehavior.APP_EVENTS, TAG, "Flushing %d events due to %s.",
                    flushResults.numEvents,
                    reason.toString());

            for (GraphRequest request : requestsToExecute) {
                
                
                request.executeAndWait();
            }
            return flushResults;
        }

        return null;
    }

    private static class FlushStatistics {
        public int numEvents = 0;
        public FlushResult result = FlushResult.SUCCESS;
    }

    private static GraphRequest buildRequestForSession(
            final AccessTokenAppIdPair accessTokenAppId,
            final SessionEventsState sessionEventsState,
            final boolean limitEventUsage,
            final FlushStatistics flushState) {
        String applicationId = accessTokenAppId.getApplicationId();

        Utility.FetchedAppSettings fetchedAppSettings =
                Utility.queryAppSettings(applicationId, false);

        final GraphRequest postRequest = GraphRequest.newPostRequest(
                null,
                String.format("%s/activities", applicationId),
                null,
                null);

        Bundle requestParameters = postRequest.getParameters();
        if (requestParameters == null) {
            requestParameters = new Bundle();
        }
        requestParameters.putString("access_token", accessTokenAppId.getAccessTokenString());
        postRequest.setParameters(requestParameters);

        if (fetchedAppSettings == null) {
            return null;
        }

        int numEvents = sessionEventsState.populateRequest(
                postRequest,
                fetchedAppSettings.supportsImplicitLogging(),
                limitEventUsage);

        if (numEvents == 0) {
            return null;
        }

        flushState.numEvents += numEvents;

        postRequest.setCallback(new GraphRequest.Callback() {
            @Override
            public void onCompleted(GraphResponse response) {
                handleResponse(accessTokenAppId, postRequest, response, sessionEventsState, flushState);
            }
        });

        return postRequest;
    }

    private static void handleResponse(
            AccessTokenAppIdPair accessTokenAppId,
            GraphRequest request,
            GraphResponse response,
            SessionEventsState sessionEventsState,
            FlushStatistics flushState) {
        FacebookRequestError error = response.getError();
        String resultDescription = "Success";

        FlushResult flushResult = FlushResult.SUCCESS;

        if (error != null) {
            final int NO_CONNECTIVITY_ERROR_CODE = -1;
            if (error.getErrorCode() == NO_CONNECTIVITY_ERROR_CODE) {
                resultDescription = "Failed: No Connectivity";
                flushResult = FlushResult.NO_CONNECTIVITY;
            } else {
                resultDescription = String.format("Failed:\n  Response: %s\n  Error %s",
                        response.toString(),
                        error.toString());
                flushResult = FlushResult.SERVER_ERROR;
            }
        }

        if (FacebookSdk.isLoggingBehaviorEnabled(LoggingBehavior.APP_EVENTS)) {
            String eventsJsonString = (String) request.getTag();
            String prettyPrintedEvents;

            try {
                JSONArray jsonArray = new JSONArray(eventsJsonString);
                prettyPrintedEvents = jsonArray.toString(2);
            } catch (JSONException exc) {
                prettyPrintedEvents = "<Can't encode events for debug logging>";
            }

            Logger.log(LoggingBehavior.APP_EVENTS, TAG,
                    "Flush completed\nParams: %s\n  Result: %s\n  Events JSON: %s",
                    request.getGraphObject().toString(),
                    resultDescription,
                    prettyPrintedEvents);
        }

        sessionEventsState.clearInFlightAndStats(error != null);

        if (flushResult == FlushResult.NO_CONNECTIVITY) {
            
            
            
            
            
            PersistedEvents.persistEvents(applicationContext, accessTokenAppId, sessionEventsState);
        }

        if (flushResult != FlushResult.SUCCESS) {
            
            if (flushState.result != FlushResult.NO_CONNECTIVITY) {
                flushState.result = flushResult;
            }
        }
    }

    private static int accumulatePersistedEvents() {
        PersistedEvents persistedEvents = PersistedEvents.readAndClearStore(applicationContext);

        int result = 0;
        for (AccessTokenAppIdPair accessTokenAppId : persistedEvents.keySet()) {
            SessionEventsState sessionEventsState =
                    getSessionEventsState(applicationContext, accessTokenAppId);

            List<AppEvent> events = persistedEvents.getEvents(accessTokenAppId);
            sessionEventsState.accumulatePersistedEvents(events);
            result += events.size();
        }

        return result;
    }

    
    private static void notifyDeveloperError(String message) {
        Logger.log(LoggingBehavior.DEVELOPER_ERRORS, "AppEvents", message);
    }

    
    private static void setSourceApplication(Activity activity) {

        ComponentName callingApplication = activity.getCallingActivity();
        if (callingApplication != null) {
            String callingApplicationPackage = callingApplication.getPackageName();
            if (callingApplicationPackage.equals(activity.getPackageName())) {
                
                resetSourceApplication();
                return;
            }
            sourceApplication = callingApplicationPackage;
        }

        
        
        
        Intent openIntent = activity.getIntent();
        if (openIntent == null ||
                openIntent.getBooleanExtra(SOURCE_APPLICATION_HAS_BEEN_SET_BY_THIS_INTENT, false)) {
            resetSourceApplication();
            return;
        }

        Bundle applinkData = AppLinks.getAppLinkData(openIntent);

        if (applinkData == null) {
            resetSourceApplication();
            return;
        }

        isOpenedByApplink = true;

        Bundle applinkReferrerData = applinkData.getBundle("referer_app_link");

        if (applinkReferrerData == null) {
            sourceApplication = null;
            return;
        }

        String applinkReferrerPackage = applinkReferrerData.getString("package");
        sourceApplication = applinkReferrerPackage;

        
        openIntent.putExtra(SOURCE_APPLICATION_HAS_BEEN_SET_BY_THIS_INTENT, true);

        return;
    }

    static void setSourceApplication(String applicationPackage, boolean openByAppLink) {
        sourceApplication = applicationPackage;
        isOpenedByApplink = openByAppLink;
    }

    static String getSourceApplication() {
        String openType = "Unclassified";
        if (isOpenedByApplink) {
            openType = "Applink";
        }
        if (sourceApplication != null) {
            return openType + "(" + sourceApplication + ")";
        }
        return openType;
    }

    static void resetSourceApplication() {
        sourceApplication = null;
        isOpenedByApplink = false;
    }

    
    public static String getAnonymousAppDeviceGUID(Context context) {

        if (anonymousAppDeviceGUID == null) {
            synchronized (staticLock) {
                if (anonymousAppDeviceGUID == null) {

                    SharedPreferences preferences = context.getSharedPreferences(
                            APP_EVENT_PREFERENCES,
                            Context.MODE_PRIVATE);
                    anonymousAppDeviceGUID = preferences.getString("anonymousAppDeviceGUID", null);
                    if (anonymousAppDeviceGUID == null) {
                        
                        anonymousAppDeviceGUID = "XZ" + UUID.randomUUID().toString();

                        context.getSharedPreferences(APP_EVENT_PREFERENCES, Context.MODE_PRIVATE)
                                .edit()
                                .putString("anonymousAppDeviceGUID", anonymousAppDeviceGUID)
                                .apply();
                    }
                }
            }
        }

        return anonymousAppDeviceGUID;
    }

    
    
    


    static class SessionEventsState {
        private List<AppEvent> accumulatedEvents = new ArrayList<AppEvent>();
        private List<AppEvent> inFlightEvents = new ArrayList<AppEvent>();
        private int numSkippedEventsDueToFullBuffer;
        private AttributionIdentifiers attributionIdentifiers;
        private String packageName;
        private String anonymousAppDeviceGUID;

        public static final String EVENT_COUNT_KEY = "event_count";
        public static final String ENCODED_EVENTS_KEY = "encoded_events";
        public static final String NUM_SKIPPED_KEY = "num_skipped";

        private final int MAX_ACCUMULATED_LOG_EVENTS = 1000;

        public SessionEventsState(
                AttributionIdentifiers identifiers,
                String packageName,
                String anonymousGUID) {
            this.attributionIdentifiers = identifiers;
            this.packageName = packageName;
            this.anonymousAppDeviceGUID = anonymousGUID;
        }

        
        
        public synchronized void addEvent(AppEvent event) {
            if (accumulatedEvents.size() + inFlightEvents.size() >= MAX_ACCUMULATED_LOG_EVENTS) {
                numSkippedEventsDueToFullBuffer++;
            } else {
                accumulatedEvents.add(event);
            }
        }

        public synchronized int getAccumulatedEventCount() {
            return accumulatedEvents.size();
        }

        public synchronized void clearInFlightAndStats(boolean moveToAccumulated) {
            if (moveToAccumulated) {
                accumulatedEvents.addAll(inFlightEvents);
            }
            inFlightEvents.clear();
            numSkippedEventsDueToFullBuffer = 0;
        }

        public int populateRequest(GraphRequest request, boolean includeImplicitEvents,
                                   boolean limitEventUsage) {

            int numSkipped;
            JSONArray jsonArray;
            synchronized (this) {
                numSkipped = numSkippedEventsDueToFullBuffer;

                
                inFlightEvents.addAll(accumulatedEvents);
                accumulatedEvents.clear();

                jsonArray = new JSONArray();
                for (AppEvent event : inFlightEvents) {
                    if (includeImplicitEvents || !event.getIsImplicit()) {
                        jsonArray.put(event.getJSONObject());
                    }
                }

                if (jsonArray.length() == 0) {
                    return 0;
                }
            }

            populateRequest(request, numSkipped, jsonArray, limitEventUsage);
            return jsonArray.length();
        }

        public synchronized List<AppEvent> getEventsToPersist() {
            
            
            
            List<AppEvent> result = accumulatedEvents;
            accumulatedEvents = new ArrayList<AppEvent>();
            return result;
        }

        public synchronized void accumulatePersistedEvents(List<AppEvent> events) {
            
            
            
            accumulatedEvents.addAll(events);
        }

        private void populateRequest(GraphRequest request, int numSkipped, JSONArray events,
                                     boolean limitEventUsage) {
            JSONObject publishParams = null;
            try {
                publishParams = AppEventsLoggerUtility.getJSONObjectForGraphAPICall(
                        AppEventsLoggerUtility.GraphAPIActivityType.CUSTOM_APP_EVENTS,
                        attributionIdentifiers,
                        anonymousAppDeviceGUID,
                        limitEventUsage,
                        applicationContext);

                if (numSkippedEventsDueToFullBuffer > 0) {
                    publishParams.put("num_skipped_events", numSkipped);
                }
            } catch (JSONException e) {
                
                publishParams = new JSONObject();
            }
            request.setGraphObject(publishParams);

            Bundle requestParameters = request.getParameters();
            if (requestParameters == null) {
                requestParameters = new Bundle();
            }

            String jsonString = events.toString();
            if (jsonString != null) {
                requestParameters.putByteArray(
                        "custom_events_file",
                        getStringAsByteArray(jsonString));
                request.setTag(jsonString);
            }
            request.setParameters(requestParameters);
        }

        private byte[] getStringAsByteArray(String jsonString) {
            byte[] jsonUtf8 = null;
            try {
                jsonUtf8 = jsonString.getBytes("UTF-8");
            } catch (UnsupportedEncodingException e) {
                
                Utility.logd("Encoding exception: ", e);
            }
            return jsonUtf8;
        }
    }

    static class AppEvent implements Serializable {
        private static final long serialVersionUID = 1L;

        private JSONObject jsonObject;
        private boolean isImplicit;
        private static final HashSet<String> validatedIdentifiers = new HashSet<String>();
        private String name;

        public AppEvent(
                String uiName,
                String eventName,
                Double valueToSum,
                Bundle parameters,
                boolean isImplicitlyLogged
        ) {
            try {
                validateIdentifier(eventName);

                this.name = eventName;
                isImplicit = isImplicitlyLogged;
                jsonObject = new JSONObject();

                jsonObject.put("_eventName", eventName);
                jsonObject.put("_logTime", System.currentTimeMillis() / 1000);
                jsonObject.put("_ui", uiName);

                if (valueToSum != null) {
                    jsonObject.put("_valueToSum", valueToSum.doubleValue());
                }

                if (isImplicit) {
                    jsonObject.put("_implicitlyLogged", "1");
                }

                if (parameters != null) {
                    for (String key : parameters.keySet()) {

                        validateIdentifier(key);

                        Object value = parameters.get(key);
                        if (!(value instanceof String) && !(value instanceof Number)) {
                            throw new FacebookException(
                                    String.format(
                                            "Parameter value '%s' for key '%s' should be a string" +
                                                    " or a numeric type.",
                                            value,
                                            key)
                            );
                        }

                        jsonObject.put(key, value.toString());
                    }
                }

                if (!isImplicit) {
                    Logger.log(LoggingBehavior.APP_EVENTS, "AppEvents",
                            "Created app event '%s'", jsonObject.toString());
                }
            } catch (JSONException jsonException) {

                
                Logger.log(LoggingBehavior.APP_EVENTS, "AppEvents",
                        "JSON encoding for app event failed: '%s'", jsonException.toString());
                jsonObject = null;

            } catch (FacebookException e) {
                
                Logger.log(LoggingBehavior.APP_EVENTS, "AppEvents",
                        "Invalid app event name or parameter:", e.toString());
                jsonObject = null;
            }
        }

        public String getName() {
            return name;
        }

        private AppEvent(String jsonString, boolean isImplicit) throws JSONException {
            jsonObject = new JSONObject(jsonString);
            this.isImplicit = isImplicit;
        }

        public boolean getIsImplicit() {
            return isImplicit;
        }

        public JSONObject getJSONObject() {
            return jsonObject;
        }

        
        private void validateIdentifier(String identifier) throws FacebookException {

            
            
            final String regex = "^[0-9a-zA-Z_]+[0-9a-zA-Z _-]*$";

            final int MAX_IDENTIFIER_LENGTH = 40;
            if (identifier == null
                    || identifier.length() == 0
                    || identifier.length() > MAX_IDENTIFIER_LENGTH) {
                if (identifier == null) {
                    identifier = "<None Provided>";
                }
                throw new FacebookException(
                    String.format(
                            Locale.ROOT,
                            "Identifier '%s' must be less than %d characters",
                            identifier,
                            MAX_IDENTIFIER_LENGTH)
                );
            }

            boolean alreadyValidated = false;
            synchronized (validatedIdentifiers) {
                alreadyValidated = validatedIdentifiers.contains(identifier);
            }

            if (!alreadyValidated) {
                if (identifier.matches(regex)) {
                    synchronized (validatedIdentifiers) {
                        validatedIdentifiers.add(identifier);
                    }
                } else {
                    throw new FacebookException(
                            String.format(
                                    "Skipping event named '%s' due to illegal name - must be " +
                                            "under 40 chars and alphanumeric, _, - or space, and " +
                                            "not start with a space or hyphen.",
                                    identifier
                            )
                    );
                }
            }
        }

        private static class SerializationProxyV1 implements Serializable {
            private static final long serialVersionUID = -2488473066578201069L;
            private final String jsonString;
            private final boolean isImplicit;

            private SerializationProxyV1(String jsonString, boolean isImplicit) {
                this.jsonString = jsonString;
                this.isImplicit = isImplicit;
            }

            private Object readResolve() throws JSONException {
                return new AppEvent(jsonString, isImplicit);
            }
        }

        private Object writeReplace() {
            return new SerializationProxyV1(jsonObject.toString(), isImplicit);
        }

        @Override
        public String toString() {
            return String.format(
                    "\"%s\", implicit: %b, json: %s",
                    jsonObject.optString("_eventName"),
                    isImplicit,
                    jsonObject.toString());
        }
    }

    static class PersistedAppSessionInfo {
        private static final String PERSISTED_SESSION_INFO_FILENAME =
                "AppEventsLogger.persistedsessioninfo";

        private static final Object staticLock = new Object();
        private static boolean hasChanges = false;
        private static boolean isLoaded = false;
        private static Map<AccessTokenAppIdPair, FacebookTimeSpentData> appSessionInfoMap;

        private static final Runnable appSessionInfoFlushRunnable = new Runnable() {
            @Override
            public void run() {
                PersistedAppSessionInfo.saveAppSessionInformation(applicationContext);
            }
        };

        @SuppressWarnings("unchecked")
        private static void restoreAppSessionInformation(Context context) {
            ObjectInputStream ois = null;

            synchronized (staticLock) {
                if (!isLoaded) {
                    try {
                        ois =
                                new ObjectInputStream(
                                        context.openFileInput(PERSISTED_SESSION_INFO_FILENAME));
                        appSessionInfoMap = (HashMap<AccessTokenAppIdPair, FacebookTimeSpentData>)
                                ois.readObject();
                        Logger.log(
                                LoggingBehavior.APP_EVENTS,
                                "AppEvents",
                                "App session info loaded");
                    } catch (FileNotFoundException fex) {
                    } catch (Exception e) {
                        Log.d(TAG, "Got unexpected exception: " + e.toString());
                    } finally {
                        Utility.closeQuietly(ois);
                        context.deleteFile(PERSISTED_SESSION_INFO_FILENAME);
                        if (appSessionInfoMap == null) {
                            appSessionInfoMap =
                                    new HashMap<AccessTokenAppIdPair, FacebookTimeSpentData>();
                        }
                        
                        
                        
                        isLoaded = true;
                        hasChanges = false;
                    }
                }
            }
        }

        static void saveAppSessionInformation(Context context) {
            ObjectOutputStream oos = null;

            synchronized (staticLock) {
                if (hasChanges) {
                    try {
                        oos = new ObjectOutputStream(
                                new BufferedOutputStream(
                                        context.openFileOutput(
                                                PERSISTED_SESSION_INFO_FILENAME,
                                                Context.MODE_PRIVATE)
                                )
                        );
                        oos.writeObject(appSessionInfoMap);
                        hasChanges = false;
                        Logger.log(
                                LoggingBehavior.APP_EVENTS,
                                "AppEvents",
                                "App session info saved");
                    } catch (Exception e) {
                        Log.d(TAG, "Got unexpected exception: " + e.toString());
                    } finally {
                        Utility.closeQuietly(oos);
                    }
                }
            }
        }

        static void onResume(
                Context context,
                AccessTokenAppIdPair accessTokenAppId,
                AppEventsLogger logger,
                long eventTime,
                String sourceApplicationInfo
        ) {
            synchronized (staticLock) {
                FacebookTimeSpentData timeSpentData = getTimeSpentData(context, accessTokenAppId);
                timeSpentData.onResume(logger, eventTime, sourceApplicationInfo);
                onTimeSpentDataUpdate();
            }
        }

        static void onSuspend(
                Context context,
                AccessTokenAppIdPair accessTokenAppId,
                AppEventsLogger logger,
                long eventTime
        ) {
            synchronized (staticLock) {
                FacebookTimeSpentData timeSpentData = getTimeSpentData(context, accessTokenAppId);
                timeSpentData.onSuspend(logger, eventTime);
                onTimeSpentDataUpdate();
            }
        }

        private static FacebookTimeSpentData getTimeSpentData(
                Context context,
                AccessTokenAppIdPair accessTokenAppId
        ) {
            restoreAppSessionInformation(context);
            FacebookTimeSpentData result = null;

            result = appSessionInfoMap.get(accessTokenAppId);
            if (result == null) {
                result = new FacebookTimeSpentData();
                appSessionInfoMap.put(accessTokenAppId, result);
            }

            return result;
        }

        private static void onTimeSpentDataUpdate() {
            if (!hasChanges) {
                hasChanges = true;
                backgroundExecutor.schedule(
                        appSessionInfoFlushRunnable,
                        FLUSH_APP_SESSION_INFO_IN_SECONDS,
                        TimeUnit.SECONDS);
            }
        }
    }

    
    
    static class PersistedEvents {
        static final String PERSISTED_EVENTS_FILENAME = "AppEventsLogger.persistedevents";

        private static Object staticLock = new Object();

        private Context context;
        private HashMap<AccessTokenAppIdPair, List<AppEvent>> persistedEvents =
                new HashMap<AccessTokenAppIdPair, List<AppEvent>>();

        private PersistedEvents(Context context) {
            this.context = context;
        }

        public static PersistedEvents readAndClearStore(Context context) {
            synchronized (staticLock) {
                PersistedEvents persistedEvents = new PersistedEvents(context);

                persistedEvents.readAndClearStore();

                return persistedEvents;
            }
        }

        public static void persistEvents(Context context, AccessTokenAppIdPair accessTokenAppId,
                                         SessionEventsState eventsToPersist) {
            Map<AccessTokenAppIdPair, SessionEventsState> map = new HashMap<AccessTokenAppIdPair, SessionEventsState>();
            map.put(accessTokenAppId, eventsToPersist);
            persistEvents(context, map);
        }

        public static void persistEvents(
                Context context,
                Map<AccessTokenAppIdPair,
                        SessionEventsState> eventsToPersist) {
            synchronized (staticLock) {
                
                
                
                
                
                PersistedEvents persistedEvents = readAndClearStore(context);

                for (Map.Entry<AccessTokenAppIdPair, SessionEventsState> entry
                        : eventsToPersist.entrySet()) {
                    List<AppEvent> events = entry.getValue().getEventsToPersist();
                    if (events.size() == 0) {
                        continue;
                    }

                    persistedEvents.addEvents(entry.getKey(), events);
                }

                persistedEvents.write();
            }
        }

        public Set<AccessTokenAppIdPair> keySet() {
            return persistedEvents.keySet();
        }

        public List<AppEvent> getEvents(AccessTokenAppIdPair accessTokenAppId) {
            return persistedEvents.get(accessTokenAppId);
        }

        private void write() {
            ObjectOutputStream oos = null;
            try {
                oos = new ObjectOutputStream(
                        new BufferedOutputStream(
                                context.openFileOutput(PERSISTED_EVENTS_FILENAME, 0)));
                oos.writeObject(persistedEvents);
            } catch (Exception e) {
                Log.d(TAG, "Got unexpected exception: " + e.toString());
            } finally {
                Utility.closeQuietly(oos);
            }
        }

        private void readAndClearStore() {
            ObjectInputStream ois = null;
            try {
                ois = new ObjectInputStream(
                        new BufferedInputStream(context.openFileInput(PERSISTED_EVENTS_FILENAME)));

                @SuppressWarnings("unchecked")
                HashMap<AccessTokenAppIdPair, List<AppEvent>> obj =
                        (HashMap<AccessTokenAppIdPair, List<AppEvent>>) ois.readObject();

                
                
                context.getFileStreamPath(PERSISTED_EVENTS_FILENAME).delete();
                persistedEvents = obj;
            } catch (FileNotFoundException e) {
                
            } catch (Exception e) {
                Log.d(TAG, "Got unexpected exception: " + e.toString());
            } finally {
                Utility.closeQuietly(ois);
            }
        }

        public void addEvents(
                AccessTokenAppIdPair accessTokenAppId,
                List<AppEvent> eventsToPersist) {
            if (!persistedEvents.containsKey(accessTokenAppId)) {
                persistedEvents.put(accessTokenAppId, new ArrayList<AppEvent>());
            }
            persistedEvents.get(accessTokenAppId).addAll(eventsToPersist);
        }
    }
}

<code block>


package com.facebook.share.model;

import android.os.Bundle;
import android.os.Parcel;


public abstract class ShareMedia implements ShareModel {

    private final Bundle params;

    protected ShareMedia(final Builder builder) {
        this.params = new Bundle(builder.params);
    }

    ShareMedia(final Parcel in) {
        this.params = in.readBundle();
    }

    
    public Bundle getParameters() {
        return new Bundle(params);
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeBundle(params);
    }

    
    public static abstract class Builder<M extends ShareMedia, B extends Builder>
            implements ShareModelBuilder<M, B> {
        private Bundle params = new Bundle();

        
        public B setParameter(final String key, final String value) {
            params.putString(key, value);
            return (B) this;
        }

        
        public B setParameters(final Bundle parameters) {
            params.putAll(parameters);
            return (B) this;
        }

        @Override
        public B readFrom(final M model) {
            if (model == null) {
                return (B) this;
            }
            return this.setParameters(model.getParameters());
        }
    }
}

<code block>


package com.facebook.login;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.Intent;
import android.content.pm.ResolveInfo;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.content.Context;

import com.facebook.AccessToken;
import com.facebook.CallbackManager;
import com.facebook.FacebookActivity;
import com.facebook.FacebookAuthorizationException;
import com.facebook.FacebookCallback;
import com.facebook.FacebookException;
import com.facebook.FacebookSdk;
import com.facebook.GraphResponse;
import com.facebook.Profile;
import com.facebook.internal.CallbackManagerImpl;
import com.facebook.internal.Validate;
import com.facebook.appevents.AppEventsConstants;

import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.UUID;


public class LoginManager {
    private static final String PUBLISH_PERMISSION_PREFIX = "publish";
    private static final String MANAGE_PERMISSION_PREFIX = "manage";
    private static final Set<String> OTHER_PUBLISH_PERMISSIONS = getOtherPublishPermissions();

    private static volatile LoginManager instance;

    private LoginBehavior loginBehavior = LoginBehavior.SSO_WITH_FALLBACK;
    private DefaultAudience defaultAudience = DefaultAudience.FRIENDS;
    private LoginClient.Request pendingLoginRequest;
    private HashMap<String, String> pendingLoggingExtras;
    private LoginLogger loginLogger;

    LoginManager() {
        Validate.sdkInitialized();
    }

    
    public static LoginManager getInstance() {
        if (instance == null) {
            synchronized (LoginManager.class) {
                if (instance == null) {
                    instance = new LoginManager();
                }
            }
        }

        return instance;
    }

    
    public void resolveError(final Activity activity, final GraphResponse response) {
        startLogin(
                new ActivityStartActivityDelegate(activity),
                createLoginRequestFromResponse(response)
        );
    }

    
    public void resolveError(final Fragment fragment, final GraphResponse response) {
        startLogin(
                new FragmentStartActivityDelegate(fragment),
                createLoginRequestFromResponse(response)
        );
    }

    private LoginClient.Request createLoginRequestFromResponse(final GraphResponse response) {
        Validate.notNull(response, "response");
        AccessToken failedToken = response.getRequest().getAccessToken();
        return createLoginRequest(failedToken != null ? failedToken.getPermissions() : null);
    }

    
    public void registerCallback(
            final CallbackManager callbackManager,
            final FacebookCallback<LoginResult> callback) {
        if (!(callbackManager instanceof CallbackManagerImpl)) {
            throw new FacebookException("Unexpected CallbackManager, " +
                    "please use the provided Factory.");
        }
        ((CallbackManagerImpl) callbackManager).registerCallback(
                CallbackManagerImpl.RequestCodeOffset.Login.toRequestCode(),
                new CallbackManagerImpl.Callback() {
                    @Override
                    public boolean onActivityResult(int resultCode, Intent data) {
                        return LoginManager.this.onActivityResult(
                                resultCode,
                                data,
                                callback);
                    }
                }
        );
    }

    boolean onActivityResult(int resultCode, Intent data) {
        return onActivityResult(resultCode, data, null);
    }

    boolean onActivityResult(int resultCode, Intent data, FacebookCallback<LoginResult>  callback) {

        if (pendingLoginRequest == null) {
            return false;
        }

        FacebookException exception = null;
        AccessToken newToken = null;
        LoginClient.Result.Code code = LoginClient.Result.Code.ERROR;
        Map<String, String> loggingExtras = null;

        boolean isCanceled = false;
        if (data != null) {
            LoginClient.Result result = (LoginClient.Result)
                    data.getParcelableExtra(LoginFragment.RESULT_KEY);
            if (result != null) {
                code = result.code;
                if (resultCode == Activity.RESULT_OK) {
                    if (result.code == LoginClient.Result.Code.SUCCESS) {
                        newToken = result.token;
                    } else {
                        exception = new FacebookAuthorizationException(result.errorMessage);
                    }
                } else if (resultCode == Activity.RESULT_CANCELED) {
                    isCanceled = true;
                }
                loggingExtras = result.loggingExtras;
            }
        } else if (resultCode == Activity.RESULT_CANCELED) {
            isCanceled = true;
            code = LoginClient.Result.Code.CANCEL;
        }

        if (exception == null && newToken == null && !isCanceled) {
            exception = new FacebookException("Unexpected call to LoginManager.onActivityResult");
        }

        logCompleteLogin(code, loggingExtras, exception);

        finishLogin(newToken, exception, isCanceled, callback);

        return true;
    }

    
    public LoginBehavior getLoginBehavior() {
        return loginBehavior;
    }

    
    public LoginManager setLoginBehavior(LoginBehavior loginBehavior) {
        this.loginBehavior = loginBehavior;
        return this;
    }

    
    public DefaultAudience getDefaultAudience() {
        return defaultAudience;
    }

    
    public LoginManager setDefaultAudience(DefaultAudience defaultAudience) {
        this.defaultAudience = defaultAudience;
        return this;
    }

    
    public void logOut() {
        AccessToken.setCurrentAccessToken(null);
        Profile.setCurrentProfile(null);
    }

    
    public void logInWithReadPermissions(Fragment fragment, Collection<String> permissions) {
        validateReadPermissions(permissions);

        LoginClient.Request loginRequest = createLoginRequest(permissions);
        startLogin(new FragmentStartActivityDelegate(fragment), loginRequest);
    }

    
    public void logInWithReadPermissions(Activity activity, Collection<String> permissions) {
        validateReadPermissions(permissions);

        LoginClient.Request loginRequest = createLoginRequest(permissions);
        startLogin(new ActivityStartActivityDelegate(activity), loginRequest);
    }

    
    public void logInWithPublishPermissions(Fragment fragment, Collection<String> permissions) {
        validatePublishPermissions(permissions);

        LoginClient.Request loginRequest = createLoginRequest(permissions);
        startLogin(new FragmentStartActivityDelegate(fragment), loginRequest);
    }

    
    public void logInWithPublishPermissions(Activity activity, Collection<String> permissions) {
        validatePublishPermissions(permissions);

        LoginClient.Request loginRequest = createLoginRequest(permissions);
        startLogin(new ActivityStartActivityDelegate(activity), loginRequest);
    }

    LoginClient.Request getPendingLoginRequest() {
        return pendingLoginRequest;
    }

    private void validateReadPermissions(Collection<String> permissions) {
        if (permissions == null) {
            return;
        }
        for (String permission : permissions) {
            if (isPublishPermission(permission)) {
                throw new FacebookException(
                    String.format(
                        "Cannot pass a publish or manage permission (%s) to a request for read " +
                                "authorization",
                        permission));
            }
        }
    }

    private void validatePublishPermissions(Collection<String> permissions) {
        if (permissions == null) {
            return;
        }
        for (String permission : permissions) {
            if (!isPublishPermission(permission)) {
                throw new FacebookException(
                    String.format(
                        "Cannot pass a read permission (%s) to a request for publish authorization",
                        permission));
            }
        }
    }

    static boolean isPublishPermission(String permission) {
        return permission != null &&
            (permission.startsWith(PUBLISH_PERMISSION_PREFIX) ||
                permission.startsWith(MANAGE_PERMISSION_PREFIX) ||
                OTHER_PUBLISH_PERMISSIONS.contains(permission));
    }

    private static Set<String> getOtherPublishPermissions() {
        HashSet<String> set = new HashSet<String>() {{
            add("ads_management");
            add("create_event");
            add("rsvp_event");
        }};
        return Collections.unmodifiableSet(set);
    }

    private LoginClient.Request createLoginRequest(Collection<String> permissions) {
        LoginClient.Request request = new LoginClient.Request(
                loginBehavior,
                Collections.unmodifiableSet(
                        permissions != null ? new HashSet(permissions) : new HashSet<String>()),
                defaultAudience,
                FacebookSdk.getApplicationId(),
                UUID.randomUUID().toString()
        );
        request.setRerequest(AccessToken.getCurrentAccessToken() != null);
        return request;
    }

    private void startLogin(
            StartActivityDelegate startActivityDelegate,
            LoginClient.Request request
    ) throws FacebookException {

        this.pendingLoginRequest = request;
        this.pendingLoggingExtras = new HashMap<>();
        this.loginLogger = getLoggerForContext(startActivityDelegate.getActivityContext());

        logStartLogin();

        
        CallbackManagerImpl.registerStaticCallback(
                CallbackManagerImpl.RequestCodeOffset.Login.toRequestCode(),
                new CallbackManagerImpl.Callback() {
                    @Override
                    public boolean onActivityResult(int resultCode, Intent data) {
                        return LoginManager.this.onActivityResult(resultCode, data);
                    }
                }
        );

        boolean started = tryFacebookActivity(startActivityDelegate, request);

        pendingLoggingExtras.put(
                LoginLogger.EVENT_EXTRAS_TRY_LOGIN_ACTIVITY,
                started ?
                AppEventsConstants.EVENT_PARAM_VALUE_YES : AppEventsConstants.EVENT_PARAM_VALUE_NO
        );

        if (!started) {
            FacebookException exception = new FacebookException(
                    "Log in attempt failed: FacebookActivity could not be started." +
                            " Please make sure you added FacebookActivity to the AndroidManifest.");
            logCompleteLogin(LoginClient.Result.Code.ERROR, null, exception);
            this.pendingLoginRequest = null;
            throw exception;
        }
    }

    private LoginLogger getLoggerForContext(Context context) {
        if (loginLogger == null ||
                !loginLogger.getApplicationId().equals(
                        pendingLoginRequest.getApplicationId())) {
            return new LoginLogger(
                    context,
                    pendingLoginRequest.getApplicationId());
        }
        return loginLogger;
    }

    private void logStartLogin() {
        if (loginLogger != null) {
            loginLogger.logStartLogin(pendingLoginRequest);
        }
    }

    private void logCompleteLogin(LoginClient.Result.Code result, Map<String, String> resultExtras,
                                  Exception exception) {
        if (loginLogger == null) {
            return;
        }
        if (pendingLoginRequest == null) {
            
            loginLogger.logUnexpectedError(
                    LoginLogger.EVENT_NAME_LOGIN_COMPLETE,
                    "Unexpected call to logCompleteLogin with null pendingAuthorizationRequest."
            );
        } else {
            loginLogger.logCompleteLogin(
                    pendingLoginRequest.getAuthId(),
                    pendingLoggingExtras,
                    result,
                    resultExtras,
                    exception);
        }
    }

    private boolean tryFacebookActivity(
            StartActivityDelegate startActivityDelegate,
            LoginClient.Request request) {

        Intent intent = getFacebookActivityIntent(request);

        if (!resolveIntent(intent)) {
            return false;
        }

        try {
            startActivityDelegate.startActivityForResult(
                    intent,
                    LoginClient.getLoginRequestCode());
        } catch (ActivityNotFoundException e) {
            return false;
        }

        return true;
    }

    private boolean resolveIntent(Intent intent) {
        ResolveInfo resolveInfo = FacebookSdk.getApplicationContext().getPackageManager()
            .resolveActivity(intent, 0);
        if (resolveInfo == null) {
            return false;
        }
        return true;
    }

    private Intent getFacebookActivityIntent(LoginClient.Request request) {
        Intent intent = new Intent();
        intent.setClass(FacebookSdk.getApplicationContext(), FacebookActivity.class);
        intent.setAction(request.getLoginBehavior().toString());

        
        LoginClient.Request authClientRequest = request;
        Bundle extras = LoginFragment.populateIntentExtras(authClientRequest);
        intent.putExtras(extras);

        return intent;
    }

    static LoginResult computeLoginResult(
            final LoginClient.Request request,
            final AccessToken newToken
    ) {
        Set<String> requestedPermissions = request.getPermissions();
        Set<String> grantedPermissions = new HashSet<String>(newToken.getPermissions());

        
        
        if (request.isRerequest()) {
            grantedPermissions.retainAll(requestedPermissions);
        }

        Set<String> deniedPermissions = new HashSet<String>(requestedPermissions);
        deniedPermissions.removeAll(grantedPermissions);
        return new LoginResult(newToken, grantedPermissions, deniedPermissions);
    }

    private void finishLogin(
            AccessToken newToken,
            FacebookException exception,
            boolean isCanceled,
            FacebookCallback<LoginResult>  callback) {
        if (newToken != null) {
            AccessToken.setCurrentAccessToken(newToken);
            Profile.fetchProfileForCurrentAccessToken();
        }

        if (callback != null) {
            LoginResult loginResult = newToken != null
                    ? computeLoginResult(pendingLoginRequest, newToken)
                    : null;
            
            if (isCanceled
                    || (loginResult != null
                           && loginResult.getRecentlyGrantedPermissions().size() == 0)) {
                callback.onCancel();
            } else if (exception != null) {
                callback.onError(exception);
            } else if (newToken != null) {
                callback.onSuccess(loginResult);
            }
        }

        pendingLoginRequest = null;
    }

    private static class ActivityStartActivityDelegate implements StartActivityDelegate {
        private final Activity activity;

        ActivityStartActivityDelegate(final Activity activity) {
            Validate.notNull(activity, "activity");
            this.activity = activity;
        }

        @Override
        public void startActivityForResult(Intent intent, int requestCode) {
            activity.startActivityForResult(intent, requestCode);
        }

        @Override
        public Activity getActivityContext() {
            return activity;
        }
    }

    private static class FragmentStartActivityDelegate implements StartActivityDelegate {
        private final Fragment fragment;

        FragmentStartActivityDelegate(final Fragment fragment) {
            Validate.notNull(fragment, "fragment");
            this.fragment = fragment;
        }

        @Override
        public void startActivityForResult(Intent intent, int requestCode) {
            fragment.startActivityForResult(intent, requestCode);
        }

        @Override
        public Activity getActivityContext() {
            return fragment.getActivity();
        }
    }
}

<code block>


package com.facebook.junittests;

import android.support.v7.app.ActionBarActivity;
import android.os.Bundle;
import android.view.Menu;
import android.view.MenuItem;

import com.facebook.FacebookSdk;


public class MainActivity extends ActionBarActivity {
    private static String APP_ID = "1234";
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        FacebookSdk.sdkInitialize(getApplicationContext());
        FacebookSdk.setApplicationId(APP_ID);
        setContentView(R.layout.activity_main);
    }


    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        
        getMenuInflater().inflate(R.menu.menu_main, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        
        
        
        int id = item.getItemId();

        
        if (id == R.id.action_settings) {
            return true;
        }

        return super.onOptionsItemSelected(item);
    }
}

<code block>


package com.facebook;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.robolectric.Robolectric;

import java.io.ByteArrayOutputStream;
import java.util.HashMap;
import java.util.Map;

import static org.junit.Assert.*;

public class ProgressOutputStreamTest extends FacebookTestCase {
    private static final int MAX_PROGRESS = 10;

    private GraphRequest r1, r2;
    private Map<GraphRequest, RequestProgress> progressMap;
    private GraphRequestBatch requests;
    private ProgressOutputStream stream;

    @Before
    public void before() throws Exception {
        FacebookSdk.sdkInitialize(Robolectric.application);
        r1 = new GraphRequest(null, "4");
        r2 = new GraphRequest(null, "4");

        progressMap = new HashMap<GraphRequest, RequestProgress>();
        progressMap.put(r1, new RequestProgress(null, r1));
        progressMap.get(r1).addToMax(5);
        progressMap.put(r2, new RequestProgress(null, r2));
        progressMap.get(r2).addToMax(5);

        requests = new GraphRequestBatch(r1, r2);

        ByteArrayOutputStream backing = new ByteArrayOutputStream();
        stream = new ProgressOutputStream(backing, requests, progressMap, MAX_PROGRESS);
    }

    @After
    public void after() throws Exception {
        stream.close();
    }

    @Test
    public void testSetup() {
        assertEquals(0, stream.getBatchProgress());
        assertEquals(MAX_PROGRESS, stream.getMaxProgress());

        for (RequestProgress p : progressMap.values()) {
            assertEquals(0, p.getProgress());
            assertEquals(5, p.getMaxProgress());
        }
    }

    @Test
    public void testWriting() {
        try {
            assertEquals(0, stream.getBatchProgress());

            stream.setCurrentRequest(r1);
            stream.write(0);
            assertEquals(1, stream.getBatchProgress());

            final byte[] buf = new byte[4];
            stream.write(buf);
            assertEquals(5, stream.getBatchProgress());

            stream.setCurrentRequest(r2);
            stream.write(buf, 2, 2);
            stream.write(buf, 1, 3);
            assertEquals(MAX_PROGRESS, stream.getBatchProgress());

            assertEquals(stream.getMaxProgress(), stream.getBatchProgress());
            assertEquals(progressMap.get(r1).getMaxProgress(), progressMap.get(r1).getProgress());
            assertEquals(progressMap.get(r2).getMaxProgress(), progressMap.get(r2).getProgress());
        }
        catch (Exception ex) {
            fail(ex.getMessage());
        }
    }
}

<code block>


package com.facebook;

import android.content.Intent;
import android.support.v4.content.LocalBroadcastManager;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.robolectric.Robolectric;

import java.util.InputMismatchException;

import static org.junit.Assert.*;
import static org.mockito.Matchers.any;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.powermock.api.mockito.PowerMockito.mock;

@PrepareForTest( { ProfileCache.class })
public class ProfileManagerTest extends FacebookPowerMockTestCase {

    @Before
    public void before() {
        FacebookSdk.sdkInitialize(Robolectric.application);
    }

    @Test
    public void testLoadCurrentProfileEmptyCache() {
        ProfileCache profileCache = mock(ProfileCache.class);
        LocalBroadcastManager localBroadcastManager = mock(LocalBroadcastManager.class);
        ProfileManager profileManager = new ProfileManager(
                localBroadcastManager,
                profileCache
        );
        assertFalse(profileManager.loadCurrentProfile());
        verify(profileCache, times(1)).load();
    }

    @Test
    public void testLoadCurrentProfileWithCache() {
        ProfileCache profileCache = mock(ProfileCache.class);
        Profile profile = ProfileTest.createDefaultProfile();
        when(profileCache.load()).thenReturn(profile);
        LocalBroadcastManager localBroadcastManager = mock(LocalBroadcastManager.class);
        ProfileManager profileManager = new ProfileManager(
                localBroadcastManager,
                profileCache
        );
        assertTrue(profileManager.loadCurrentProfile());
        verify(profileCache, times(1)).load();

        
        verify(profileCache, never()).save(any(Profile.class));

        
        verify(localBroadcastManager).sendBroadcast(any(Intent.class));

        
        profileManager.setCurrentProfile(ProfileTest.createDefaultProfile());
        verify(localBroadcastManager, times(1)).sendBroadcast(any(Intent.class));

        
        profileManager.setCurrentProfile(null);
        verify(localBroadcastManager, times(2)).sendBroadcast(any(Intent.class));
    }
}

<code block>


package com.facebook;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.support.v4.content.LocalBroadcastManager;

import com.facebook.internal.Utility;

import org.json.JSONException;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.powermock.api.mockito.PowerMockito;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.robolectric.Robolectric;

import java.util.Arrays;
import java.util.Date;
import java.util.List;

import static org.mockito.Mockito.*;
import static org.junit.Assert.*;
import static org.powermock.api.mockito.PowerMockito.mockStatic;
import static org.powermock.api.mockito.PowerMockito.when;
import static org.powermock.api.support.membermodification.MemberMatcher.method;
import static org.powermock.api.support.membermodification.MemberModifier.suppress;

@PrepareForTest({FacebookSdk.class, AccessTokenCache.class, Utility.class})
public class AccessTokenManagerTest extends FacebookPowerMockTestCase {

    private final String TOKEN_STRING = "A token of my esteem";
    private final String USER_ID = "1000";
    private final List<String> PERMISSIONS = Arrays.asList("walk", "chew gum");
    private final Date EXPIRES = new Date(2025, 5, 3);
    private final Date LAST_REFRESH = new Date(2023, 8, 15);
    private final String APP_ID = "1234";

    private LocalBroadcastManager localBroadcastManager;
    private AccessTokenCache accessTokenCache;

    @Before
    public void before() throws Exception {
        mockStatic(FacebookSdk.class);
        when(FacebookSdk.isInitialized()).thenReturn(true);
        when(FacebookSdk.getApplicationContext()).thenReturn(Robolectric.application);
        suppress(method(Utility.class, "clearFacebookCookies"));

        localBroadcastManager = LocalBroadcastManager.getInstance(Robolectric.application);
        accessTokenCache = mock(AccessTokenCache.class);
    }

    @Test
    public void testRequiresLocalBroadcastManager() {
        try {
            AccessTokenManager accessTokenManager = new AccessTokenManager(null, accessTokenCache);
            fail();
        } catch (NullPointerException ex) {
        }
    }

    @Test
    public void testRequiresTokenCache() {
        try {
            AccessTokenManager accessTokenManager = new AccessTokenManager(localBroadcastManager,
                    null);
            fail();
        } catch (NullPointerException ex) {
        }
    }

    @Test
    public void testDefaultsToNoCurrentAccessToken() {
        AccessTokenManager accessTokenManager = createAccessTokenManager();

        assertNull(accessTokenManager.getCurrentAccessToken());
    }

    @Test
    public void testCanSetCurrentAccessToken() {
        AccessTokenManager accessTokenManager = createAccessTokenManager();

        AccessToken accessToken = createAccessToken();

        accessTokenManager.setCurrentAccessToken(accessToken);

        assertEquals(accessToken, accessTokenManager.getCurrentAccessToken());
    }

    @Test
    public void testChangingAccessTokenSendsBroadcast() {
        AccessTokenManager accessTokenManager = createAccessTokenManager();

        AccessToken accessToken = createAccessToken();

        accessTokenManager.setCurrentAccessToken(accessToken);

        final Intent intents[] = new Intent[1];
        final BroadcastReceiver broadcastReceiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                intents[0] = intent;
            }
        };

        localBroadcastManager.registerReceiver(broadcastReceiver,
                new IntentFilter(AccessTokenManager.ACTION_CURRENT_ACCESS_TOKEN_CHANGED));

        AccessToken anotherAccessToken = createAccessToken("another string", "1000");

        accessTokenManager.setCurrentAccessToken(anotherAccessToken);

        localBroadcastManager.unregisterReceiver(broadcastReceiver);

        Intent intent = intents[0];

        assertNotNull(intent);

        AccessToken oldAccessToken =
                (AccessToken) intent.getParcelableExtra(AccessTokenManager.EXTRA_OLD_ACCESS_TOKEN);
        AccessToken newAccessToken =
                (AccessToken) intent.getParcelableExtra(AccessTokenManager.EXTRA_NEW_ACCESS_TOKEN);

        assertEquals(accessToken.getToken(), oldAccessToken.getToken());
        assertEquals(anotherAccessToken.getToken(), newAccessToken.getToken());
    }

    @Test
    public void testLoadReturnsFalseIfNoCachedToken() {
        AccessTokenManager accessTokenManager = createAccessTokenManager();

        boolean result = accessTokenManager.loadCurrentAccessToken();

        assertFalse(result);
    }

    @Test
    public void testLoadReturnsTrueIfCachedToken() {
        AccessToken accessToken = createAccessToken();
        when(accessTokenCache.load()).thenReturn(accessToken);

        AccessTokenManager accessTokenManager = createAccessTokenManager();

        boolean result = accessTokenManager.loadCurrentAccessToken();

        assertTrue(result);
    }

    @Test
    public void testLoadSetsCurrentTokenIfCached() {
        AccessToken accessToken = createAccessToken();
        when(accessTokenCache.load()).thenReturn(accessToken);

        AccessTokenManager accessTokenManager = createAccessTokenManager();

        accessTokenManager.loadCurrentAccessToken();

        assertEquals(accessToken, accessTokenManager.getCurrentAccessToken());
    }

    @Test
    public void testSaveWritesToCacheIfToken() throws JSONException {
        AccessToken accessToken = createAccessToken();
        AccessTokenManager accessTokenManager = createAccessTokenManager();

        accessTokenManager.setCurrentAccessToken(accessToken);

        verify(accessTokenCache, times(1)).save(any(AccessToken.class));
    }

    @Test
    public void testSetEmptyTokenClearsCache() {
        AccessTokenManager accessTokenManager = createAccessTokenManager();

        accessTokenManager.setCurrentAccessToken(null);

        verify(accessTokenCache, times(1)).clear();
    }

    @Test
    public void testLoadDoesNotSave() {
        AccessToken accessToken = createAccessToken();
        when(accessTokenCache.load()).thenReturn(accessToken);

        AccessTokenManager accessTokenManager = createAccessTokenManager();

        accessTokenManager.loadCurrentAccessToken();

        verify(accessTokenCache, never()).save(any(AccessToken.class));
    }

    private AccessTokenManager createAccessTokenManager() {
        return new AccessTokenManager(localBroadcastManager, accessTokenCache);
    }

    private AccessToken createAccessToken() {
        return createAccessToken(TOKEN_STRING, USER_ID);
    }

    private AccessToken createAccessToken(String tokenString, String userId) {
        return new AccessToken(
                tokenString,
                APP_ID,
                userId,
                PERMISSIONS,
                null,
                AccessTokenSource.WEB_VIEW,
                EXPIRES,
                LAST_REFRESH);
    }
}

<code block>


package com.facebook;

import android.content.Context;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;
import android.os.Bundle;
import android.os.ConditionVariable;

import com.facebook.internal.CallbackManagerImpl;
import com.facebook.internal.ServerProtocol;
import com.facebook.internal.Utility;

import org.junit.Before;
import org.junit.Test;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.powermock.reflect.Whitebox;
import org.robolectric.Robolectric;

import java.util.concurrent.Executor;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
import static org.powermock.api.support.membermodification.MemberMatcher.method;
import static org.powermock.api.support.membermodification.MemberModifier.stub;

@PrepareForTest({ FacebookSdk.class, Utility.class })
public final class FacebookSdkPowerMockTest extends FacebookPowerMockTestCase {

    @Before
    public void before() {
        Whitebox.setInternalState(FacebookSdk.class, "callbackRequestCodeOffset", 0xface);
        Whitebox.setInternalState(FacebookSdk.class, "sdkInitialized", false);
        stub(method(Utility.class, "loadAppSettingsAsync")).toReturn(null);

    }

    @Test
    public void testGetExecutor() {
        final ConditionVariable condition = new ConditionVariable();

        FacebookSdk.getExecutor().execute(new Runnable() {
            @Override
            public void run() {
                condition.open();
            }
        });

        boolean success = condition.block(5000);
        assertTrue(success);
    }

    @Test
    public void testSetExecutor() {
        final ConditionVariable condition = new ConditionVariable();

        final Runnable runnable = new Runnable() {
            @Override
            public void run() { }
        };

        final Executor executor = new Executor() {
            @Override
            public void execute(Runnable command) {
                assertEquals(runnable, command);
                command.run();

                condition.open();
            }
        };

        Executor original = FacebookSdk.getExecutor();
        try {
            FacebookSdk.setExecutor(executor);
            FacebookSdk.getExecutor().execute(runnable);

            boolean success = condition.block(5000);
            assertTrue(success);
        } finally {
            FacebookSdk.setExecutor(original);
        }
    }

    @Test
    public void testFacebookDomain() {
        FacebookSdk.setFacebookDomain("beta.facebook.com");

        String graphUrlBase = ServerProtocol.getGraphUrlBase();
        assertEquals("https:

        FacebookSdk.setFacebookDomain("facebook.com");
    }

    @Test
    public void testLoadDefaults() throws Exception {
        stub(method(FacebookSdk.class, "isInitialized")).toReturn(true);
        FacebookSdk.loadDefaultsFromMetadata(mockContextWithAppIdAndClientToken());

        assertEquals("1234", FacebookSdk.getApplicationId());
        assertEquals("abcd", FacebookSdk.getClientToken());
    }


    private Context mockContextWithAppIdAndClientToken() throws Exception {
        Bundle bundle = mock(Bundle.class);

        when(bundle.get(FacebookSdk.APPLICATION_ID_PROPERTY)).thenReturn("1234");
        when(bundle.getString(FacebookSdk.CLIENT_TOKEN_PROPERTY)).thenReturn("abcd");
        ApplicationInfo applicationInfo = mock(ApplicationInfo.class);
        applicationInfo.metaData = bundle;

        PackageManager packageManager = mock(PackageManager.class);
        when(packageManager.getApplicationInfo("packageName", PackageManager.GET_META_DATA))
                .thenReturn(applicationInfo);

        Context context = mock(Context.class);
        when(context.getPackageName()).thenReturn("packageName");
        when(context.getPackageManager()).thenReturn(packageManager);
        return context;
    }

    @Test
    public void testLoadDefaultsDoesNotOverwrite() throws Exception {
        stub(method(FacebookSdk.class, "isInitialized")).toReturn(true);
        FacebookSdk.setApplicationId("hello");
        FacebookSdk.setClientToken("world");

        FacebookSdk.loadDefaultsFromMetadata(mockContextWithAppIdAndClientToken());

        assertEquals("hello", FacebookSdk.getApplicationId());
        assertEquals("world", FacebookSdk.getClientToken());
    }

    @Test
    public void testRequestCodeOffsetAfterInit() throws Exception {
        FacebookSdk.sdkInitialize(Robolectric.application);

        try {
            FacebookSdk.sdkInitialize(Robolectric.application, 1000);
            fail();
        } catch (FacebookException exception) {
            assertEquals(FacebookSdk.CALLBACK_OFFSET_CHANGED_AFTER_INIT, exception.getMessage());
        }
    }

    @Test
    public void testRequestCodeOffsetNegative() throws Exception {
        try {
            
            FacebookSdk.sdkInitialize(Robolectric.application, 0xFACEB00C);
            fail();
        } catch (FacebookException exception) {
            assertEquals(FacebookSdk.CALLBACK_OFFSET_NEGATIVE, exception.getMessage());
        }
    }

    @Test
    public void testRequestCodeOffset() throws Exception {
        FacebookSdk.sdkInitialize(Robolectric.application, 1000);
        assertEquals(1000, FacebookSdk.getCallbackRequestCodeOffset());
    }

    @Test
    public void testRequestCodeRange() {
        FacebookSdk.sdkInitialize(Robolectric.application, 1000);
        assertTrue(FacebookSdk.isFacebookRequestCode(1000));
        assertTrue(FacebookSdk.isFacebookRequestCode(1099));
        assertFalse(FacebookSdk.isFacebookRequestCode(999));
        assertFalse(FacebookSdk.isFacebookRequestCode(1100));
        assertFalse(FacebookSdk.isFacebookRequestCode(0));
    }
}

<code block>


package com.facebook;

import android.os.Bundle;

import com.facebook.internal.Utility;

import org.json.JSONObject;
import org.junit.Before;
import org.junit.Test;
import org.powermock.api.mockito.PowerMockito;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.robolectric.Robolectric;

import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Random;
import java.util.Set;

import static org.junit.Assert.*;
import static org.powermock.api.support.membermodification.MemberModifier.stub;

@PrepareForTest( {Utility.class})
public final class LegacyTokenCacheTest extends FacebookPowerMockTestCase {

    private static final String BOOLEAN_KEY = "booleanKey";
    private static final String BOOLEAN_ARRAY_KEY = "booleanArrayKey";
    private static final String BYTE_KEY = "byteKey";
    private static final String BYTE_ARRAY_KEY = "byteArrayKey";
    private static final String SHORT_KEY = "shortKey";
    private static final String SHORT_ARRAY_KEY = "shortArrayKey";
    private static final String INT_KEY = "intKey";
    private static final String INT_ARRAY_KEY = "intArrayKey";
    private static final String LONG_KEY = "longKey";
    private static final String LONG_ARRAY_KEY = "longArrayKey";
    private static final String FLOAT_ARRAY_KEY = "floatKey";
    private static final String FLOAT_KEY = "floatArrayKey";
    private static final String DOUBLE_KEY = "doubleKey";
    private static final String DOUBLE_ARRAY_KEY = "doubleArrayKey";
    private static final String CHAR_KEY = "charKey";
    private static final String CHAR_ARRAY_KEY = "charArrayKey";
    private static final String STRING_KEY = "stringKey";
    private static final String STRING_LIST_KEY = "stringListKey";
    private static final String SERIALIZABLE_KEY = "serializableKey";

    private static Random random = new Random((new Date()).getTime());

    @Override
    public void setUp() {
        super.setUp();

        FacebookSdk.sdkInitialize(Robolectric.application);
    }

    @Before
    public void before() throws Exception {
        stub(PowerMockito.method(Utility.class, "awaitGetGraphMeRequestWithCache")).toReturn(
                new JSONObject().put("id", "1000"));
    }

    @Test
    public void testAllTypes() {
        Bundle originalBundle = new Bundle();

        putBoolean(BOOLEAN_KEY, originalBundle);
        putBooleanArray(BOOLEAN_ARRAY_KEY, originalBundle);
        putByte(BYTE_KEY, originalBundle);
        putByteArray(BYTE_ARRAY_KEY, originalBundle);
        putShort(SHORT_KEY, originalBundle);
        putShortArray(SHORT_ARRAY_KEY, originalBundle);
        putInt(INT_KEY, originalBundle);
        putIntArray(INT_ARRAY_KEY, originalBundle);
        putLong(LONG_KEY, originalBundle);
        putLongArray(LONG_ARRAY_KEY, originalBundle);
        putFloat(FLOAT_KEY, originalBundle);
        putFloatArray(FLOAT_ARRAY_KEY, originalBundle);
        putDouble(DOUBLE_KEY, originalBundle);
        putDoubleArray(DOUBLE_ARRAY_KEY, originalBundle);
        putChar(CHAR_KEY, originalBundle);
        putCharArray(CHAR_ARRAY_KEY, originalBundle);
        putString(STRING_KEY, originalBundle);
        putStringList(STRING_LIST_KEY, originalBundle);
        originalBundle.putSerializable(SERIALIZABLE_KEY, AccessTokenSource.FACEBOOK_APPLICATION_WEB);

        ensureApplicationContext();

        LegacyTokenHelper cache = new LegacyTokenHelper(Robolectric.application);
        cache.save(originalBundle);

        LegacyTokenHelper cache2 = new LegacyTokenHelper(Robolectric.application);
        Bundle cachedBundle = cache2.load();

        assertEquals(originalBundle.getBoolean(BOOLEAN_KEY), cachedBundle.getBoolean(BOOLEAN_KEY));
        assertArrayEquals(originalBundle.getBooleanArray(BOOLEAN_ARRAY_KEY), cachedBundle.getBooleanArray(BOOLEAN_ARRAY_KEY));
        assertEquals(originalBundle.getByte(BYTE_KEY), cachedBundle.getByte(BYTE_KEY));
        assertArrayEquals(originalBundle.getByteArray(BYTE_ARRAY_KEY), cachedBundle.getByteArray(BYTE_ARRAY_KEY));
        assertEquals(originalBundle.getShort(SHORT_KEY), cachedBundle.getShort(SHORT_KEY));
        assertArrayEquals(originalBundle.getShortArray(SHORT_ARRAY_KEY), cachedBundle.getShortArray(SHORT_ARRAY_KEY));
        assertEquals(originalBundle.getInt(INT_KEY), cachedBundle.getInt(INT_KEY));
        assertArrayEquals(originalBundle.getIntArray(INT_ARRAY_KEY), cachedBundle.getIntArray(INT_ARRAY_KEY));
        assertEquals(originalBundle.getLong(LONG_KEY), cachedBundle.getLong(LONG_KEY));
        assertArrayEquals(originalBundle.getLongArray(LONG_ARRAY_KEY), cachedBundle.getLongArray(LONG_ARRAY_KEY));
        assertEquals(originalBundle.getFloat(FLOAT_KEY), cachedBundle.getFloat(FLOAT_KEY), TestUtils.DOUBLE_EQUALS_DELTA);
        assertArrayEquals(originalBundle.getFloatArray(FLOAT_ARRAY_KEY), cachedBundle.getFloatArray(FLOAT_ARRAY_KEY));
        assertEquals(originalBundle.getDouble(DOUBLE_KEY), cachedBundle.getDouble(DOUBLE_KEY), TestUtils.DOUBLE_EQUALS_DELTA);
        assertArrayEquals(originalBundle.getDoubleArray(DOUBLE_ARRAY_KEY), cachedBundle.getDoubleArray(DOUBLE_ARRAY_KEY));
        assertEquals(originalBundle.getChar(CHAR_KEY), cachedBundle.getChar(CHAR_KEY));
        assertArrayEquals(originalBundle.getCharArray(CHAR_ARRAY_KEY), cachedBundle.getCharArray(CHAR_ARRAY_KEY));
        assertEquals(originalBundle.getString(STRING_KEY), cachedBundle.getString(STRING_KEY));
        assertListEquals(originalBundle.getStringArrayList(STRING_LIST_KEY), cachedBundle.getStringArrayList(
                STRING_LIST_KEY));
        assertEquals(originalBundle.getSerializable(SERIALIZABLE_KEY),
                cachedBundle.getSerializable(SERIALIZABLE_KEY));
    }

    @Test
    public void testMultipleCaches() {
        Bundle bundle1 = new Bundle(), bundle2 = new Bundle();

        bundle1.putInt(INT_KEY, 10);
        bundle1.putString(STRING_KEY, "ABC");
        bundle2.putInt(INT_KEY, 100);
        bundle2.putString(STRING_KEY, "xyz");

        ensureApplicationContext();

        LegacyTokenHelper cache1 = new LegacyTokenHelper(Robolectric.application);
        LegacyTokenHelper cache2 = new LegacyTokenHelper(Robolectric.application, "CustomCache");

        cache1.save(bundle1);
        cache2.save(bundle2);

        
        
        cache1 = new LegacyTokenHelper(Robolectric.application, "CustomCache");
        cache2 = new LegacyTokenHelper(Robolectric.application);

        Bundle newBundle1 = cache1.load(), newBundle2 = cache2.load();

        assertEquals(bundle2.getInt(INT_KEY), newBundle1.getInt(INT_KEY));
        assertEquals(bundle2.getString(STRING_KEY), newBundle1.getString(STRING_KEY));
        assertEquals(bundle1.getInt(INT_KEY), newBundle2.getInt(INT_KEY));
        assertEquals(bundle1.getString(STRING_KEY), newBundle2.getString(STRING_KEY));
    }

    @Test
    public void testCacheRoundtrip() {
        Set<String> permissions = Utility.hashSet("stream_publish", "go_outside_and_play");
        String token = "AnImaginaryTokenValue";
        Date later = TestUtils.nowPlusSeconds(60);
        Date earlier = TestUtils.nowPlusSeconds(-60);
        String applicationId = "1234";

        LegacyTokenHelper cache =
                new LegacyTokenHelper(Robolectric.application);
        cache.clear();

        Bundle bundle = new Bundle();
        LegacyTokenHelper.putToken(bundle, token);
        LegacyTokenHelper.putExpirationDate(bundle, later);
        LegacyTokenHelper.putSource(
                bundle,
                AccessTokenSource.FACEBOOK_APPLICATION_NATIVE);
        LegacyTokenHelper.putLastRefreshDate(bundle, earlier);
        LegacyTokenHelper.putPermissions(bundle, permissions);
        LegacyTokenHelper.putDeclinedPermissions(
                bundle,
                Utility.arrayList("whatever"));
        LegacyTokenHelper.putApplicationId(bundle, applicationId);

        cache.save(bundle);
        bundle = cache.load();

        AccessToken accessToken = AccessToken.createFromLegacyCache(bundle);
        TestUtils.assertSamePermissions(permissions, accessToken);
        assertEquals(token, accessToken.getToken());
        assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_NATIVE, accessToken.getSource());
        assertTrue(!accessToken.isExpired());

        Bundle cachedBundle = AccessTokenTestHelper.toLegacyCacheBundle(accessToken);
        TestUtils.assertEqualContentsWithoutOrder(bundle, cachedBundle);
    }

    private static void assertArrayEquals(Object a1, Object a2) {
        assertNotNull(a1);
        assertNotNull(a2);
        assertEquals(a1.getClass(), a2.getClass());
        assertTrue("Not an array", a1.getClass().isArray());

        int length = Array.getLength(a1);
        assertEquals(length, Array.getLength(a2));
        for (int i = 0; i < length; i++) {
            Object a1Value = Array.get(a1, i);
            Object a2Value = Array.get(a2, i);

            assertEquals(a1Value, a2Value);
        }
    }

    private static void assertListEquals(List<?> l1, List<?> l2) {
        assertNotNull(l1);
        assertNotNull(l2);

        Iterator<?> i1 = l1.iterator(), i2 = l2.iterator();
        while (i1.hasNext() && i2.hasNext()) {
            assertEquals(i1.next(), i2.next());
        }

        assertTrue("Lists not of the same length", !i1.hasNext());
        assertTrue("Lists not of the same length", !i2.hasNext());
    }

    private static void putInt(String key, Bundle bundle) {
        bundle.putInt(key, random.nextInt());
    }

    private static void putIntArray(String key, Bundle bundle) {
        int length = random.nextInt(50);
        int[] array = new int[length];
        for (int i = 0; i < length; i++) {
            array[i] = random.nextInt();
        }
        bundle.putIntArray(key, array);
    }

    private static void putShort(String key, Bundle bundle) {
        bundle.putShort(key, (short)random.nextInt());
    }

    private static void putShortArray(String key, Bundle bundle) {
        int length = random.nextInt(50);
        short[] array = new short[length];
        for (int i = 0; i < length; i++) {
            array[i] = (short)random.nextInt();
        }
        bundle.putShortArray(key, array);
    }

    private static void putByte(String key, Bundle bundle) {
        bundle.putByte(key, (byte)random.nextInt());
    }

    private static void putByteArray(String key, Bundle bundle) {
        int length = random.nextInt(50);
        byte[] array = new byte[length];
        random.nextBytes(array);
        bundle.putByteArray(key, array);
    }

    private static void putBoolean(String key, Bundle bundle) {
        bundle.putBoolean(key, random.nextBoolean());
    }

    private static void putBooleanArray(String key, Bundle bundle) {
        int length = random.nextInt(50);
        boolean[] array = new boolean[length];
        for (int i = 0; i < length; i++) {
            array[i] = random.nextBoolean();
        }
        bundle.putBooleanArray(key, array);
    }

    private static void putLong(String key, Bundle bundle) {
        bundle.putLong(key, random.nextLong());
    }

    private static void putLongArray(String key, Bundle bundle) {
        int length = random.nextInt(50);
        long[] array = new long[length];
        for (int i = 0; i < length; i++) {
            array[i] = random.nextLong();
        }
        bundle.putLongArray(key, array);
    }

    private static void putFloat(String key, Bundle bundle) {
        bundle.putFloat(key, random.nextFloat());
    }

    private static void putFloatArray(String key, Bundle bundle) {
        int length = random.nextInt(50);
        float[] array = new float[length];
        for (int i = 0; i < length; i++) {
            array[i] = random.nextFloat();
        }
        bundle.putFloatArray(key, array);
    }

    private static void putDouble(String key, Bundle bundle) {
        bundle.putDouble(key, random.nextDouble());
    }

    private static void putDoubleArray(String key, Bundle bundle) {
        int length = random.nextInt(50);
        double[] array = new double[length];
        for (int i = 0; i < length; i++) {
            array[i] = random.nextDouble();
        }
        bundle.putDoubleArray(key, array);
    }

    private static void putChar(String key, Bundle bundle) {
        bundle.putChar(key, getChar());
    }

    private static void putCharArray(String key, Bundle bundle) {
        bundle.putCharArray(key, getCharArray());
    }

    private static void putString(String key, Bundle bundle) {
        bundle.putString(key, new String(getCharArray()));
    }

    private static void putStringList(String key, Bundle bundle) {
        int length = random.nextInt(50);
        ArrayList<String> stringList = new ArrayList<String>(length);
        while (0 < length--) {
            if (length == 0) {
                stringList.add(null);
            } else {
                stringList.add(new String(getCharArray()));
            }
        }

        bundle.putStringArrayList(key, stringList);
    }

    private static char[] getCharArray() {
        int length = random.nextInt(50);
        char[] array = new char[length];
        for (int i = 0; i < length; i++) {
            array[i] = getChar();
        }

        return array;
    }

    private static char getChar() {
        return (char)random.nextInt(255);
    }

    private void ensureApplicationContext() {
        
        
        long waitedFor = 0;
        try {
            
            while (Robolectric.application.getApplicationContext() == null && waitedFor <= 2000) {
                Thread.sleep(50);
                waitedFor += 50;
            }
        }
        catch (InterruptedException e) {
        }
    }

}

<code block>


package com.facebook;

import android.net.Uri;
import android.os.Parcel;

import org.json.JSONObject;
import org.junit.Test;
import org.robolectric.Robolectric;

import static org.junit.Assert.*;

public final class ProfileTest extends FacebookTestCase {
    static final String ID = "ID";
    static final String ANOTHER_ID = "ANOTHER_ID";
    static final String FIRST_NAME = "FIRST_NAME";
    static final String MIDDLE_NAME = "MIDDLE_NAME";
    static final String LAST_NAME = "LAST_NAME";
    static final String NAME = "NAME";
    static final Uri LINK_URI = Uri.parse("https:

    public static Profile createDefaultProfile() {
        return new Profile(
                ID,
                FIRST_NAME,
                MIDDLE_NAME,
                LAST_NAME,
                NAME,
                LINK_URI
        );
    }

    static void assertDefaultObjectGetters(Profile profile) {
        assertEquals(ID, profile.getId());
        assertEquals(FIRST_NAME, profile.getFirstName());
        assertEquals(MIDDLE_NAME, profile.getMiddleName());
        assertEquals(LAST_NAME, profile.getLastName());
        assertEquals(NAME, profile.getName());
        assertEquals(LINK_URI, profile.getLinkUri());
    }

    static Profile createMostlyNullsProfile() {
        return new Profile(ANOTHER_ID, null, null, null, null, null);
    }

    static void assertMostlyNullsObjectGetters(Profile profile) {
        assertEquals(ANOTHER_ID, profile.getId());
        assertNull(profile.getFirstName());
        assertNull(profile.getMiddleName());
        assertNull(profile.getLastName());
        assertNull(profile.getName());
        assertNull(profile.getLinkUri());
    }


    @Test
    public void testProfileCtorAndGetters() {
        Profile profile = createDefaultProfile();
        assertDefaultObjectGetters(profile);

        profile = createMostlyNullsProfile();
        assertMostlyNullsObjectGetters(profile);
    }

    @Test
    public void testHashCode() {
        Profile profile1 = createDefaultProfile();
        Profile profile2 = createDefaultProfile();
        assertEquals(profile1.hashCode(), profile2.hashCode());

        Profile profile3 = createMostlyNullsProfile();
        assertNotEquals(profile1.hashCode(), profile3.hashCode());
    }

    @Test
    public void testEquals() {
        Profile profile1 = createDefaultProfile();
        Profile profile2 = createDefaultProfile();
        assertEquals(profile1, profile2);

        Profile profile3 = createMostlyNullsProfile();
        assertNotEquals(profile1, profile3);
    }

    @Test
    public void testJsonSerialization() {
        Profile profile1 = createDefaultProfile();
        JSONObject jsonObject = profile1.toJSONObject();
        Profile profile2 = new Profile(jsonObject);
        assertDefaultObjectGetters(profile2);
        assertEquals(profile1, profile2);

        
        profile1 = createMostlyNullsProfile();
        jsonObject = profile1.toJSONObject();
        profile2 = new Profile(jsonObject);
        assertMostlyNullsObjectGetters(profile2);
        assertEquals(profile1, profile2);
    }

    @Test
    public void testParcelSerialization() {
        Profile profile1 = createDefaultProfile();
        Profile profile2 = TestUtils.parcelAndUnparcel(profile1);

        assertDefaultObjectGetters(profile2);
        assertEquals(profile1, profile2);

        
        profile1 = createMostlyNullsProfile();
        profile2 = TestUtils.parcelAndUnparcel(profile1);
        assertMostlyNullsObjectGetters(profile2);
        assertEquals(profile1, profile2);
    }

    @Test
    public void testGetSetCurrentProfile() {
        FacebookSdk.sdkInitialize(Robolectric.application);
        Profile profile1 = createDefaultProfile();
        Profile.setCurrentProfile(profile1);
        assertEquals(ProfileManager.getInstance().getCurrentProfile(), profile1);
        assertEquals(profile1, Profile.getCurrentProfile());

        Profile.setCurrentProfile(null);
        assertNull(ProfileManager.getInstance().getCurrentProfile());
        assertNull(Profile.getCurrentProfile());
    }
}

<code block>


package com.facebook;

import com.facebook.junittests.R;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.junit.Test;

import static org.junit.Assert.*;

public class FacebookGraphRequestErrorTest extends FacebookTestCase {
    public static final String ERROR_SINGLE_RESPONSE =
            "{\n" +
            "  \"error\": {\n" +
            "    \"message\": \"Unknown path components: /unknown\",\n" +
            "    \"type\": \"OAuthException\",\n" +
            "    \"code\": 2500\n" +
            "  }\n" +
            "}";

    public static final String ERROR_BATCH_RESPONSE =
            "[\n" +
            "  {\n" +
            "    \"headers\": [\n" +
            "      {\n" +
            "        \"value\": \"*\",\n" +
            "        \"name\": \"Access-Control-Allow-Origin\"\n" +
            "      },\n" +
            "      {\n" +
            "        \"value\": \"no-store\",\n" +
            "        \"name\": \"Cache-Control\"\n" +
            "      },\n" +
            "      {\n" +
            "        \"value\": \"close\",\n" +
            "        \"name\": \"Connection\"\n" +
            "      },\n" +
            "      {\n" +
            "        \"value\": \"text\\/javascript; charset=UTF-8\",\n" +
            "        \"name\": \"Content-Type\"\n" +
            "      },\n" +
            "      {\n" +
            "        \"value\": \"Sat, 01 Jan 2000 00:00:00 GMT\",\n" +
            "        \"name\": \"Expires\"\n" +
            "      },\n" +
            "      {\n" +
            "        \"value\": \"no-cache\",\n" +
            "        \"name\": \"Pragma\"\n" +
            "      },\n" +
            "      {\n" +
            "        \"value\": \"OAuth \\\"Facebook Platform\\\" \\\"invalid_request\\\" \\\"An active access token must be used to query information about the current user.\\\"\",\n" +
            "        \"name\": \"WWW-Authenticate\"\n" +
            "      }\n" +
            "    ],\n" +
            "    \"body\": \"{\\\"error\\\":{\\\"message\\\":\\\"An active access token must be used to query information about the current user.\\\",\\\"type\\\":\\\"OAuthException\\\",\\\"code\\\":2500}}\",\n" +
            "    \"code\": 400\n" +
            "  },\n" +
            "  {\n" +
            "    \"headers\": [\n" +
            "      {\n" +
            "        \"value\": \"*\",\n" +
            "        \"name\": \"Access-Control-Allow-Origin\"\n" +
            "      },\n" +
            "      {\n" +
            "        \"value\": \"no-store\",\n" +
            "        \"name\": \"Cache-Control\"\n" +
            "      },\n" +
            "      {\n" +
            "        \"value\": \"close\",\n" +
            "        \"name\": \"Connection\"\n" +
            "      },\n" +
            "      {\n" +
            "        \"value\": \"text\\/javascript; charset=UTF-8\",\n" +
            "        \"name\": \"Content-Type\"\n" +
            "      },\n" +
            "      {\n" +
            "        \"value\": \"Sat, 01 Jan 2000 00:00:00 GMT\",\n" +
            "        \"name\": \"Expires\"\n" +
            "      },\n" +
            "      {\n" +
            "        \"value\": \"no-cache\",\n" +
            "        \"name\": \"Pragma\"\n" +
            "      },\n" +
            "      {\n" +
            "        \"value\": \"OAuth \\\"Facebook Platform\\\" \\\"invalid_request\\\" \\\"An active access token must be used to query information about the current user.\\\"\",\n" +
            "        \"name\": \"WWW-Authenticate\"\n" +
            "      }\n" +
            "    ],\n" +
            "    \"body\": \"{\\\"error\\\":{\\\"message\\\":\\\"An active access token must be used to query information about the current user.\\\",\\\"type\\\":\\\"OAuthException\\\",\\\"code\\\":2500}}\",\n" +
            "    \"code\": 400\n" +
            "  }\n" +
            "]";


    public static final String ERROR_SINGLE_RESPONSE_THROTTLE =
            "{\n" +
            "  \"error\": {\n" +
            "    \"message\": \"Application request limit reached\",\n" +
            "    \"code\": 4\n" +
            "  }\n" +
            "}";

    public static final String ERROR_SINGLE_RESPONSE_SERVER =
            "{\n" +
            "  \"error\": {\n" +
            "    \"message\": \"Some Server Error\",\n" +
            "    \"code\": 2\n" +
            "  }\n" +
            "}";

    public static final String ERROR_SINGLE_RESPONSE_PERMISSION =
            "{\n" +
            "  \"error\": {\n" +
            "    \"type\": \"OAuthException\",\n" +
            "    \"message\": \"(#200) Requires extended permission: publish_actions\",\n" +
            "    \"code\": 200\n" +
            "  }\n" +
            "}";

    public static final String ERROR_SINGLE_RESPONSE_WEB_LOGIN =
            "{\n" +
            "  \"error\": {\n" +
            "    \"message\": \"User need to login\",\n" +
            "    \"type\": \"OAuthException\",\n" +
            "    \"code\": 102,\n" +
            "    \"error_subcode\": 459\n" +
            "  }\n" +
            "}";

    public static final String ERROR_SINGLE_RESPONSE_RELOGIN =
            "{\n" +
            "  \"error\": {\n" +
            "    \"message\": \"User need to relogin\",\n" +
            "    \"type\": \"OAuthException\",\n" +
            "    \"code\": 102\n" +
            "  }\n" +
            "}";

    public static final String ERROR_SINGLE_RESPONSE_RELOGIN_DELETED_APP =
            "{\n" +
            "  \"error\": {\n" +
            "    \"message\": \"User need to relogin\",\n" +
            "    \"type\": \"OAuthException\",\n" +
            "    \"code\": 190,\n" +
            "    \"error_subcode\": 458\n" +
            "  }\n" +
            "}";

    @Test
    public void testClientException() {
        final String errorMsg = "some error happened";
        FacebookRequestError error =
                new FacebookRequestError(null, new FacebookException(errorMsg));
        assertEquals(errorMsg, error.getErrorMessage());
        assertEquals(FacebookRequestError.Category.OTHER, error.getCategory());
        assertEquals(FacebookRequestError.INVALID_ERROR_CODE, error.getErrorCode());
        assertEquals(FacebookRequestError.INVALID_HTTP_STATUS_CODE, error.getRequestStatusCode());
    }

    @Test
    public void testSingleRequestWithoutBody() throws JSONException {
        JSONObject withStatusCode = new JSONObject();
        withStatusCode.put("code", 400);
        FacebookRequestError error =
                FacebookRequestError.checkResponseAndCreateError(
                        withStatusCode, withStatusCode, null);
        assertNotNull(error);
        assertEquals(400, error.getRequestStatusCode());
        assertEquals(FacebookRequestError.Category.OTHER, error.getCategory());
    }

    @Test
    public void testSingleErrorWithBody() throws JSONException {
        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE);
        JSONObject withStatusCodeAndBody = new JSONObject();
        withStatusCodeAndBody.put("code", 400);
        withStatusCodeAndBody.put("body", originalResponse);
        FacebookRequestError error =
                FacebookRequestError.checkResponseAndCreateError(
                        withStatusCodeAndBody, originalResponse, null);
        assertNotNull(error);
        assertEquals(400, error.getRequestStatusCode());
        assertEquals("Unknown path components: /unknown", error.getErrorMessage());
        assertEquals("OAuthException", error.getErrorType());
        assertEquals(2500, error.getErrorCode());
        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
        assertEquals(FacebookRequestError.Category.OTHER, error.getCategory());
    }

    @Test
    public void testBatchRequest() throws JSONException {
        JSONArray batchResponse = new JSONArray(ERROR_BATCH_RESPONSE);
        assertEquals(2, batchResponse.length());
        JSONObject firstResponse = (JSONObject) batchResponse.get(0);
        FacebookRequestError error =
                FacebookRequestError.checkResponseAndCreateError(
                        firstResponse, batchResponse, null);
        assertNotNull(error);
        assertEquals(400, error.getRequestStatusCode());
        assertEquals("An active access token must be used to query information about the current user.",
                error.getErrorMessage());
        assertEquals("OAuthException", error.getErrorType());
        assertEquals(2500, error.getErrorCode());
        assertTrue(error.getBatchRequestResult() instanceof  JSONArray);
        assertEquals(FacebookRequestError.Category.OTHER, error.getCategory());
    }

    @Test
    public void testSingleThrottledError() throws JSONException {
        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_THROTTLE);
        JSONObject withStatusCodeAndBody = new JSONObject();
        withStatusCodeAndBody.put("code", 403);
        withStatusCodeAndBody.put("body", originalResponse);
        FacebookRequestError error =
                FacebookRequestError.checkResponseAndCreateError(
                        withStatusCodeAndBody, originalResponse, null);
        assertNotNull(error);
        assertEquals(403, error.getRequestStatusCode());
        assertEquals("Application request limit reached", error.getErrorMessage());
        assertNull(error.getErrorType());
        assertEquals(4, error.getErrorCode());
        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
        assertEquals(FacebookRequestError.Category.TRANSIENT, error.getCategory());
    }

    @Test
    public void testSingleServerError() throws JSONException {
        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_SERVER);
        JSONObject withStatusCodeAndBody = new JSONObject();
        withStatusCodeAndBody.put("code", 500);
        withStatusCodeAndBody.put("body", originalResponse);
        FacebookRequestError error =
                FacebookRequestError.checkResponseAndCreateError(
                        withStatusCodeAndBody, originalResponse, null);
        assertNotNull(error);
        assertEquals(500, error.getRequestStatusCode());
        assertEquals("Some Server Error", error.getErrorMessage());
        assertNull(error.getErrorType());
        assertEquals(2, error.getErrorCode());
        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
        assertEquals(FacebookRequestError.Category.TRANSIENT, error.getCategory());
    }

    @Test
    public void testSinglePermissionError() throws JSONException {
        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_PERMISSION);
        JSONObject withStatusCodeAndBody = new JSONObject();
        withStatusCodeAndBody.put("code", 400);
        withStatusCodeAndBody.put("body", originalResponse);
        FacebookRequestError error =
                FacebookRequestError.checkResponseAndCreateError(
                        withStatusCodeAndBody, originalResponse, null);
        assertNotNull(error);
        assertEquals(400, error.getRequestStatusCode());
        assertEquals(
                "(#200) Requires extended permission: publish_actions",
                error.getErrorMessage());
        assertEquals("OAuthException", error.getErrorType());
        assertEquals(200, error.getErrorCode());
        assertEquals(FacebookRequestError.INVALID_ERROR_CODE, error.getSubErrorCode());
        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
        assertEquals(FacebookRequestError.Category.OTHER, error.getCategory());
    }

    @Test
    public void testSingleWebLoginError() throws JSONException {
        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_WEB_LOGIN);
        JSONObject withStatusCodeAndBody = new JSONObject();
        withStatusCodeAndBody.put("code", 400);
        withStatusCodeAndBody.put("body", originalResponse);
        FacebookRequestError error =
                FacebookRequestError.checkResponseAndCreateError(
                        withStatusCodeAndBody, originalResponse, null);
        assertNotNull(error);
        assertEquals(400, error.getRequestStatusCode());
        assertEquals("User need to login", error.getErrorMessage());
        assertEquals("OAuthException", error.getErrorType());
        assertEquals(102, error.getErrorCode());
        assertEquals(459, error.getSubErrorCode());
        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
        assertEquals(FacebookRequestError.Category.LOGIN_RECOVERABLE, error.getCategory());
    }

    @Test
    public void testSingleReloginError() throws JSONException {
        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_RELOGIN);
        JSONObject withStatusCodeAndBody = new JSONObject();
        withStatusCodeAndBody.put("code", 400);
        withStatusCodeAndBody.put("body", originalResponse);
        FacebookRequestError error =
                FacebookRequestError.checkResponseAndCreateError(
                        withStatusCodeAndBody, originalResponse, null);
        assertNotNull(error);
        assertEquals(400, error.getRequestStatusCode());
        assertEquals("User need to relogin", error.getErrorMessage());
        assertEquals("OAuthException", error.getErrorType());
        assertEquals(102, error.getErrorCode());
        assertEquals(FacebookRequestError.INVALID_ERROR_CODE, error.getSubErrorCode());
        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
        assertEquals(FacebookRequestError.Category.LOGIN_RECOVERABLE, error.getCategory());
    }

    @Test
    public void testSingleReloginDeletedAppError() throws JSONException {
        JSONObject originalResponse = new JSONObject(ERROR_SINGLE_RESPONSE_RELOGIN_DELETED_APP);
        JSONObject withStatusCodeAndBody = new JSONObject();
        withStatusCodeAndBody.put("code", 400);
        withStatusCodeAndBody.put("body", originalResponse);
        FacebookRequestError error =
                FacebookRequestError.checkResponseAndCreateError(
                        withStatusCodeAndBody, originalResponse, null);
        assertNotNull(error);
        assertEquals(400, error.getRequestStatusCode());
        assertEquals("User need to relogin", error.getErrorMessage());
        assertEquals("OAuthException", error.getErrorType());
        assertEquals(190, error.getErrorCode());
        assertEquals(458, error.getSubErrorCode());
        assertTrue(error.getBatchRequestResult() instanceof JSONObject);
        assertEquals(FacebookRequestError.Category.LOGIN_RECOVERABLE, error.getCategory());
    }
}

<code block>


package com.facebook;

import com.facebook.internal.FacebookRequestErrorClassification;
import com.facebook.internal.Utility;

import org.json.JSONException;
import org.json.JSONObject;
import org.junit.Before;
import org.junit.Test;
import org.powermock.api.mockito.PowerMockito;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.robolectric.Robolectric;

import java.io.IOException;
import java.net.HttpURLConnection;

import static org.junit.Assert.*;
import static org.powermock.api.mockito.PowerMockito.doNothing;
import static org.powermock.api.mockito.PowerMockito.mock;
import static org.powermock.api.mockito.PowerMockito.mockStatic;
import static org.powermock.api.mockito.PowerMockito.when;
import static org.powermock.api.support.membermodification.MemberMatcher.method;
import static org.powermock.api.support.membermodification.MemberModifier.stub;
import static org.powermock.api.support.membermodification.MemberModifier.suppress;

@PrepareForTest( {
        AccessToken.class,
        AccessTokenCache.class,
        FacebookSdk.class,
        GraphRequest.class,
        Utility.class
})
public final class GraphErrorTest extends FacebookPowerMockTestCase {

    @Before
    public void before() throws Exception {
        mockStatic(FacebookSdk.class);
        suppress(method(Utility.class, "clearFacebookCookies"));
        when(FacebookSdk.isInitialized()).thenReturn(true);
        when(FacebookSdk.getApplicationContext()).thenReturn(Robolectric.application);
        stub(method(AccessTokenCache.class, "save")).toReturn(null);
    }

    @Test
    public void testAccessTokenResetOnTokenError() throws JSONException, IOException {
        AccessToken accessToken = mock(AccessToken.class);
        AccessToken.setCurrentAccessToken(accessToken);

        JSONObject errorBody = new JSONObject();
        errorBody.put("message", "Invalid OAuth access token.");
        errorBody.put("type", "OAuthException");
        errorBody.put("code", FacebookRequestErrorClassification.EC_INVALID_TOKEN);
        JSONObject error = new JSONObject();
        error.put("error", errorBody);
        String errorString = error.toString();

        HttpURLConnection connection = mock(HttpURLConnection.class);
        when(connection.getResponseCode()).thenReturn(400);

        GraphRequest request = mock(GraphRequest.class);
        when(request.getAccessToken()).thenReturn(accessToken);
        GraphRequestBatch batch = new GraphRequestBatch(request);

        assertNotNull(AccessToken.getCurrentAccessToken());
        GraphResponse.createResponsesFromString(errorString, connection, batch);
        assertNull(AccessToken.getCurrentAccessToken());
    }
}

<code block>


package com.facebook;

import android.content.Intent;
import android.support.v4.content.LocalBroadcastManager;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.robolectric.Robolectric;

import java.util.Arrays;
import java.util.Date;
import java.util.List;

import static org.junit.Assert.*;
import static org.powermock.api.mockito.PowerMockito.*;

@PrepareForTest( { FacebookSdk.class })
public class AccessTokenTrackerTest extends FacebookPowerMockTestCase {

    private final List<String> PERMISSIONS = Arrays.asList("walk", "chew gum");
    private final Date EXPIRES = new Date(2025, 5, 3);
    private final Date LAST_REFRESH = new Date(2023, 8, 15);
    private final String APP_ID = "1234";
    private final String USER_ID = "1000";

    private LocalBroadcastManager localBroadcastManager;
    private TestAccessTokenTracker accessTokenTracker = null;

    @Before
    public void before() throws Exception {
        mockStatic(FacebookSdk.class);
        when(FacebookSdk.isInitialized()).thenReturn(true);
        when(FacebookSdk.getApplicationContext()).thenReturn(Robolectric.application);

        localBroadcastManager = LocalBroadcastManager.getInstance(Robolectric.application);
    }

    @After
    public void after() throws Exception {
        if (accessTokenTracker != null && accessTokenTracker.isTracking()) {
            accessTokenTracker.stopTracking();
        }
    }

    @Test
    public void testRequiresSdkToBeInitialized() {
        try {
            when(FacebookSdk.isInitialized()).thenReturn(false);

            accessTokenTracker = new TestAccessTokenTracker();

            fail();
        } catch (FacebookSdkNotInitializedException exception) {
        }
    }

    @Test
    public void testDefaultsToTracking() {
        accessTokenTracker = new TestAccessTokenTracker();

        assertTrue(accessTokenTracker.isTracking());
    }

    @Test
    public void testCanTurnTrackingOff() {
        accessTokenTracker = new TestAccessTokenTracker();

        accessTokenTracker.stopTracking();

        assertFalse(accessTokenTracker.isTracking());
    }

    @Test
    public void testCanTurnTrackingOn() {
        accessTokenTracker = new TestAccessTokenTracker();

        accessTokenTracker.stopTracking();
        accessTokenTracker.startTracking();

        assertTrue(accessTokenTracker.isTracking());
    }

    @Test
    public void testCallbackCalledOnBroadcastReceived() throws Exception {
        accessTokenTracker = new TestAccessTokenTracker();

        AccessToken oldAccessToken = createAccessToken("I'm old!");
        AccessToken currentAccessToken = createAccessToken("I'm current!");

        sendBroadcast(oldAccessToken, currentAccessToken);


        assertNotNull(accessTokenTracker.currentAccessToken);
        assertEquals(currentAccessToken.getToken(), accessTokenTracker.currentAccessToken.getToken());
        assertNotNull(accessTokenTracker.oldAccessToken);
        assertEquals(oldAccessToken.getToken(), accessTokenTracker.oldAccessToken.getToken());
    }

    private AccessToken createAccessToken(String tokenString) {
        return new AccessToken(
                tokenString,
                APP_ID,
                USER_ID,
                PERMISSIONS,
                null,
                AccessTokenSource.WEB_VIEW,
                EXPIRES,
                LAST_REFRESH);
    }

    private void sendBroadcast(AccessToken oldAccessToken, AccessToken currentAccessToken) {
        Intent intent = new Intent(AccessTokenManager.ACTION_CURRENT_ACCESS_TOKEN_CHANGED);

        intent.putExtra(AccessTokenManager.EXTRA_OLD_ACCESS_TOKEN, oldAccessToken);
        intent.putExtra(AccessTokenManager.EXTRA_NEW_ACCESS_TOKEN, currentAccessToken);

        localBroadcastManager.sendBroadcast(intent);
    }

    class TestAccessTokenTracker extends AccessTokenTracker {

        public AccessToken currentAccessToken;
        public AccessToken oldAccessToken;

        public TestAccessTokenTracker() {
            super();
        }

        @Override
        protected void onCurrentAccessTokenChanged(AccessToken oldAccessToken,
            AccessToken currentAccessToken) {
            this.oldAccessToken = oldAccessToken;
            this.currentAccessToken = currentAccessToken;
        }
    }
}

<code block>


package com.facebook;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.robolectric.Robolectric;

import static org.junit.Assert.*;


public class ProgressNoopOutputStreamTest extends FacebookTestCase {
    private ProgressNoopOutputStream stream;

    @Before
    public void before() throws Exception {
        FacebookSdk.sdkInitialize(Robolectric.application);
        stream = new ProgressNoopOutputStream(null);
    }

    @After
    public void after() throws Exception {
        stream.close();
    }

    @Test
    public void testSetup() {
        assertEquals(0, stream.getMaxProgress());
        assertTrue(stream.getProgressMap().isEmpty());
    }

    @Test
    public void testWriting() {
        assertEquals(0, stream.getMaxProgress());

        stream.write(0);
        assertEquals(1, stream.getMaxProgress());

        final byte[] buf = new byte[8];

        stream.write(buf);
        assertEquals(9, stream.getMaxProgress());

        stream.write(buf, 2, 2);
        assertEquals(11, stream.getMaxProgress());

        stream.addProgress(16);
        assertEquals(27, stream.getMaxProgress());
    }
}

<code block>


package com.facebook;

import android.content.Intent;
import android.support.v4.content.LocalBroadcastManager;

import org.junit.Test;
import org.robolectric.Robolectric;

import static org.junit.Assert.*;

public class ProfileTrackerTest extends FacebookPowerMockTestCase {
    @Test
    public void testStartStopTrackingAndBroadcast() {
        FacebookSdk.sdkInitialize(Robolectric.application);
        LocalBroadcastManager localBroadcastManager =
                LocalBroadcastManager.getInstance(Robolectric.application);
        TestProfileTracker testProfileTracker = new TestProfileTracker();
        
        assertTrue(testProfileTracker.isTracking());

        testProfileTracker.stopTracking();
        assertFalse(testProfileTracker.isTracking());
        sendBroadcast(localBroadcastManager, null, ProfileTest.createDefaultProfile());
        assertFalse(testProfileTracker.isCallbackCalled);
        testProfileTracker.startTracking();
        assertTrue(testProfileTracker.isTracking());
        Profile profile = ProfileTest.createDefaultProfile();
        sendBroadcast(localBroadcastManager, null, profile);
        assertNull(testProfileTracker.oldProfile);
        assertEquals(profile, testProfileTracker.currentProfile);
        assertTrue(testProfileTracker.isCallbackCalled);

        Profile profile1 = ProfileTest.createMostlyNullsProfile();
        Profile profile2 = ProfileTest.createDefaultProfile();
        sendBroadcast(localBroadcastManager, profile1, profile2);
        ProfileTest.assertMostlyNullsObjectGetters(testProfileTracker.oldProfile);
        ProfileTest.assertDefaultObjectGetters(testProfileTracker.currentProfile);
        assertEquals(profile1, testProfileTracker.oldProfile);
        assertEquals(profile2, testProfileTracker.currentProfile);

        testProfileTracker.stopTracking();
    }

    private static void sendBroadcast(
            LocalBroadcastManager localBroadcastManager,
            Profile oldProfile,
            Profile currentProfile) {
        Intent intent = new Intent(ProfileManager.ACTION_CURRENT_PROFILE_CHANGED);

        intent.putExtra(ProfileManager.EXTRA_OLD_PROFILE, oldProfile);
        intent.putExtra(ProfileManager.EXTRA_NEW_PROFILE, currentProfile);

        localBroadcastManager.sendBroadcast(intent);
    }

    static class TestProfileTracker extends ProfileTracker {
        Profile oldProfile;
        Profile currentProfile;
        boolean isCallbackCalled = false;

        @Override
        protected void onCurrentProfileChanged(Profile oldProfile, Profile currentProfile) {
            this.oldProfile = oldProfile;
            this.currentProfile = currentProfile;
            isCallbackCalled = true;
        }
    }

}

<code block>


package com.facebook;

import android.content.Context;

import org.junit.Before;
import org.junit.Test;
import org.robolectric.Robolectric;

import static org.junit.Assert.*;

public final class ProfileCacheTest extends FacebookTestCase {
    @Before
    public void before() throws Exception {
        FacebookSdk.sdkInitialize(Robolectric.application);
        Robolectric.application.getSharedPreferences(
                ProfileCache.SHARED_PREFERENCES_NAME,
                Context.MODE_PRIVATE)
                .edit().
                clear().
                commit();
    }

    @Test
    public void testEmptyCase() {
        ProfileCache cache = new ProfileCache();
        assertNull(cache.load());
    }

    @Test
    public void testSaveGetAndClear() {
        ProfileCache cache = new ProfileCache();
        Profile profile1 = ProfileTest.createDefaultProfile();
        cache.save(profile1);
        Profile profile2 = cache.load();
        ProfileTest.assertDefaultObjectGetters(profile2);
        assertEquals(profile1, profile2);

        profile1 = ProfileTest.createMostlyNullsProfile();
        cache.save(profile1);
        profile2 = cache.load();
        ProfileTest.assertMostlyNullsObjectGetters(profile2);
        assertEquals(profile1, profile2);

        cache.clear();
        assertNull(cache.load());
    }
}

<code block>


package com.facebook;

import android.os.Bundle;

import com.facebook.internal.Utility;

import org.json.JSONException;
import org.json.JSONObject;
import org.junit.Before;
import org.junit.Test;
import org.powermock.api.mockito.PowerMockito;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.robolectric.Robolectric;

import java.io.IOException;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import static org.junit.Assert.*;
import static org.powermock.api.support.membermodification.MemberModifier.stub;

@PrepareForTest( {Utility.class})
public final class AccessTokenTest extends FacebookPowerMockTestCase {

    @Before
    public void before() throws Exception {
        stub(PowerMockito.method(Utility.class, "awaitGetGraphMeRequestWithCache")).toReturn(
                new JSONObject().put("id", "1000"));
    }

    @Test
    public void testNullTokenThrows() {
        try {
            AccessToken token = new AccessToken(
                    null,
                    "1234",
                    "1000",
                    Utility.arrayList("something"),
                    Utility.arrayList("something_else"),
                    AccessTokenSource.CLIENT_TOKEN,
                    new Date(),
                    new Date());
            fail();
        } catch (IllegalArgumentException e) {
        }
    }

    @Test
    public void testEmptyTokenThrows() {
        try {
            AccessToken token = new AccessToken(
                    "",
                    "1234",
                    "1000",
                    Utility.arrayList("something"),
                    Utility.arrayList("something_else"),
                    AccessTokenSource.CLIENT_TOKEN,
                    new Date(),
                    new Date());
            fail();
        } catch (IllegalArgumentException e) {
        }
    }

    @Test
    public void testNullUserIdThrows() {
        try {
            AccessToken token = new AccessToken(
                    "a token",
                    "1234",
                    null,
                    Utility.arrayList("something"),
                    Utility.arrayList("something_else"),
                    AccessTokenSource.CLIENT_TOKEN,
                    new Date(),
                    new Date());
            fail();
        } catch (IllegalArgumentException e) {
        }
    }

    @Test
    public void testEmptyUserIdThrows() {
        try {
            AccessToken token = new AccessToken(
                    "a token",
                    "1234",
                    "",
                    Utility.arrayList("something"),
                    Utility.arrayList("something_else"),
                    AccessTokenSource.CLIENT_TOKEN,
                    new Date(),
                    new Date());
            fail();
        } catch (IllegalArgumentException e) {
        }
    }

    @Test
    public void testCreateFromRefreshFailure() {
        AccessToken accessToken = new AccessToken(
                "a token",
                "1234",
                "1000",
                Utility.arrayList("stream_publish"),
                null,
                AccessTokenSource.WEB_VIEW,
                null,
                null);

        String token = "AnImaginaryTokenValue";

        Bundle bundle = new Bundle();
        bundle.putString("access_token", "AnImaginaryTokenValue");
        bundle.putString("expires_in", "60");

        try {
            AccessToken.createFromRefresh(accessToken, bundle);
            fail("Expected exception");
        } catch (FacebookException ex) {
            assertEquals("Invalid token source: " + AccessTokenSource.WEB_VIEW, ex.getMessage());
        }
    }

    @Test
    public void testCacheRoundtrip() {
        Set<String> permissions = Utility.hashSet("stream_publish", "go_outside_and_play");
        Set<String> declinedPermissions = Utility.hashSet("no you may not", "no soup for you");
        String token = "AnImaginaryTokenValue";
        Date later = TestUtils.nowPlusSeconds(60);
        Date earlier = TestUtils.nowPlusSeconds(-60);
        String applicationId = "1234";

        Bundle bundle = new Bundle();
        LegacyTokenHelper.putToken(bundle, token);
        LegacyTokenHelper.putExpirationDate(bundle, later);
        LegacyTokenHelper.putSource(
                bundle,
                AccessTokenSource.FACEBOOK_APPLICATION_WEB);
        LegacyTokenHelper.putLastRefreshDate(bundle, earlier);
        LegacyTokenHelper.putPermissions(bundle, permissions);
        LegacyTokenHelper.putDeclinedPermissions(bundle, declinedPermissions);
        LegacyTokenHelper.putApplicationId(bundle, applicationId);

        AccessToken accessToken = AccessToken.createFromLegacyCache(bundle);
        TestUtils.assertSamePermissions(permissions, accessToken);
        assertEquals(token, accessToken.getToken());
        assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_WEB, accessToken.getSource());
        assertTrue(!accessToken.isExpired());

        Bundle cache = AccessTokenTestHelper.toLegacyCacheBundle(accessToken);
        TestUtils.assertEqualContentsWithoutOrder(bundle, cache);
    }

    @Test
    public void testFromCacheWithMissingApplicationId() {
        String token = "AnImaginaryTokenValue";
        String applicationId = "1234";

        Bundle bundle = new Bundle();
        LegacyTokenHelper.putToken(bundle, token);
        

        FacebookSdk.sdkInitialize(Robolectric.application);
        FacebookSdk.setApplicationId(applicationId);

        AccessToken accessToken = AccessToken.createFromLegacyCache(bundle);

        assertEquals(applicationId, accessToken.getApplicationId());
    }

    @Test
    public void testCachePutGet() {
        Bundle bundle = new Bundle();

        for (String token : new String[] { "", "A completely random token value" }) {
            LegacyTokenHelper.putToken(bundle, token);
            assertEquals(token, LegacyTokenHelper.getToken(bundle));
        }

        for (Date date : new Date[] { new Date(42), new Date() }) {
            LegacyTokenHelper.putExpirationDate(bundle, date);
            assertEquals(date, LegacyTokenHelper.getExpirationDate(bundle));

            LegacyTokenHelper.putLastRefreshDate(bundle, date);
            assertEquals(date, LegacyTokenHelper.getLastRefreshDate(bundle));
        }

        for (long milliseconds : new long[] { 0, -1, System.currentTimeMillis() }) {
            LegacyTokenHelper.putExpirationMilliseconds(bundle, milliseconds);
            assertEquals(
                    milliseconds,
                    LegacyTokenHelper.getExpirationMilliseconds(bundle));

            LegacyTokenHelper.putLastRefreshMilliseconds(bundle, milliseconds);
            assertEquals(
                    milliseconds,
                    LegacyTokenHelper.getLastRefreshMilliseconds(bundle));
        }

        for (AccessTokenSource source : AccessTokenSource.values()) {
            LegacyTokenHelper.putSource(bundle, source);
            assertEquals(source, LegacyTokenHelper.getSource(bundle));
        }

        String userId = "1000";

        List<String> normalList = Arrays.asList("", "Another completely random token value");
        List<String> emptyList = Arrays.asList();
        HashSet<String> normalArrayList = new HashSet<String>(normalList);
        HashSet<String> emptyArrayList = new HashSet<String>();
        @SuppressWarnings("unchecked")
        List<Collection<String>> permissionLists = Arrays
                .asList(normalList, emptyList, normalArrayList, emptyArrayList);
        for (Collection<String> list : permissionLists) {
            LegacyTokenHelper.putPermissions(bundle, list);
            TestUtils.assertSamePermissions(
                    list,
                    LegacyTokenHelper.getPermissions(bundle));
        }
        normalArrayList.add(null);
    }

    @Test
    public void testRoundtripJSONObject() throws JSONException {
        AccessToken accessToken = new AccessToken(
                "a token",
                "1234",
                "1000",
                Arrays.asList("permission_1", "permission_2"),
                Arrays.asList("declined permission_1", "declined permission_2"),
                AccessTokenSource.WEB_VIEW,
                new Date(2015, 3, 3),
                new Date(2015, 1, 1));

        JSONObject jsonObject = accessToken.toJSONObject();

        AccessToken deserializedAccessToken = AccessToken.createFromJSONObject(jsonObject);

        assertEquals(accessToken, deserializedAccessToken);
    }

    @Test
    public void testParceling() throws IOException {
        String token = "a token";
        String appId = "1234";
        String userId = "1000";
        Set<String> permissions = new HashSet<String>(
                Arrays.asList("permission_1", "permission_2"));
        Set<String> declinedPermissions = new HashSet<String>(
                Arrays.asList("permission_3"));
        AccessTokenSource source = AccessTokenSource.WEB_VIEW;
        AccessToken accessToken1 = new AccessToken(
                token,
                appId,
                userId,
                permissions,
                declinedPermissions,
                source,
                null,
                null);

        AccessToken accessToken2 = TestUtils.parcelAndUnparcel(accessToken1);
        assertEquals(accessToken1, accessToken2);
        assertEquals(token, accessToken2.getToken());
        assertEquals(appId, accessToken2.getApplicationId());
        assertEquals(permissions, accessToken2.getPermissions());
        assertEquals(declinedPermissions, accessToken2.getDeclinedPermissions());
        assertEquals(accessToken1.getExpires(), accessToken2.getExpires());
        assertEquals(accessToken1.getLastRefresh(), accessToken2.getLastRefresh());
        assertEquals(accessToken1.getUserId(), accessToken2.getUserId());
    }

    @Test
    public void testPermissionsAreImmutable() {
        Set<String> permissions = Utility.hashSet("go to Jail", "do not pass Go");
        AccessToken accessToken = new AccessToken(
                "some token",
                "1234",
                "1000",
                permissions,
                null,
                AccessTokenSource.FACEBOOK_APPLICATION_WEB,
                new Date(),
                new Date());

        permissions = accessToken.getPermissions();

        try {
            permissions.add("can't touch this");
            fail();
        } catch (UnsupportedOperationException ex) {
        }
    }

    @Test
    public void testCreateFromExistingTokenDefaults() {
        final String token = "A token of my esteem";
        final String applicationId = "1234";
        final String userId = "1000";

        AccessToken accessToken = new AccessToken(
                token,
                applicationId,
                userId,
                null,
                null,
                null,
                null,
                null);

        assertEquals(token, accessToken.getToken());
        assertEquals(new Date(Long.MAX_VALUE), accessToken.getExpires());
        assertEquals(AccessTokenSource.FACEBOOK_APPLICATION_WEB, accessToken.getSource());
        assertEquals(0, accessToken.getPermissions().size());
        assertEquals(applicationId, accessToken.getApplicationId());
        assertEquals(userId, accessToken.getUserId());
        
        long delta = accessToken.getLastRefresh().getTime() - new Date().getTime();
        assertTrue(delta < 1000);
    }

    @Test
    public void testAccessTokenConstructor() {
        final String token = "A token of my esteem";
        final Set<String> permissions = Utility.hashSet("walk", "chew gum");
        final Set<String> declinedPermissions = Utility.hashSet("jump");
        final Date expires = new Date(2025, 5, 3);
        final Date lastRefresh = new Date(2023, 8, 15);
        final AccessTokenSource source = AccessTokenSource.WEB_VIEW;
        final String applicationId = "1234";
        final String userId = "1000";

        AccessToken accessToken = new AccessToken(
                token,
                applicationId,
                userId,
                permissions,
                declinedPermissions,
                source,
                expires,
                lastRefresh);

        assertEquals(token, accessToken.getToken());
        assertEquals(expires, accessToken.getExpires());
        assertEquals(lastRefresh, accessToken.getLastRefresh());
        assertEquals(source, accessToken.getSource());
        assertEquals(permissions, accessToken.getPermissions());
        assertEquals(declinedPermissions, accessToken.getDeclinedPermissions());
        assertEquals(applicationId, accessToken.getApplicationId());
        assertEquals(userId, accessToken.getUserId());
    }
}

<code block>


package com.facebook;

import android.net.Uri;
import android.os.ParcelFileDescriptor;
import android.util.Pair;

import com.facebook.internal.NativeAppCallAttachmentStore;

import org.junit.Before;
import org.junit.Test;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.robolectric.Robolectric;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

import static org.junit.Assert.*;
import static org.powermock.api.mockito.PowerMockito.mockStatic;
import static org.powermock.api.mockito.PowerMockito.when;

@PrepareForTest({ NativeAppCallAttachmentStore.class })
public class FacebookContentProviderTest extends FacebookPowerMockTestCase {
    private static final String APP_ID = "12345";
    private static final UUID CALL_ID = UUID.randomUUID();
    private static final String ATTACHMENT_NAME = "attachMe";

    private FacebookContentProvider providerUnderTest;

    @Before
    public void before() throws Exception {
        mockStatic(NativeAppCallAttachmentStore.class);
        providerUnderTest = new FacebookContentProvider();
    }

    @Test
    public void testGetAttachmentUrl() {
        String url = FacebookContentProvider.getAttachmentUrl(APP_ID, CALL_ID, ATTACHMENT_NAME);
        assertEquals("content:
                APP_ID + "/" + CALL_ID + "/" + ATTACHMENT_NAME, url);
    }

    @Test
    public void testOnCreate() throws Exception {
        assertTrue(providerUnderTest.onCreate());
    }

    @Test
    public void testQuery() throws Exception {
        assertNull(providerUnderTest.query(null, null, null, null, null));
    }

    @Test
    public void testGetType() throws Exception {
        assertNull(providerUnderTest.getType(null));
    }

    @Test
    public void testInsert() throws Exception {
        assertNull(providerUnderTest.insert(null, null));
    }

    @Test
    public void testDelete() throws Exception {
        assertEquals(0, providerUnderTest.delete(null, null, null));
    }

    @Test
    public void testUpdate() throws Exception {
        assertEquals(0, providerUnderTest.update(null, null, null, null));
    }

    @SuppressWarnings("unused")
    @Test
    public void testOpenFileWithNullUri() throws Exception {
        try {
            ParcelFileDescriptor pfd = providerUnderTest.openFile(null, "r");
            fail("expected FileNotFoundException");
        } catch (FileNotFoundException e) {
        }
    }

    @SuppressWarnings("unused")
    @Test
    public void testOpenFileWithBadPath() throws Exception {
        try {
            ParcelFileDescriptor pfd = providerUnderTest.openFile(Uri.parse("/"), "r");
            fail("expected FileNotFoundException");
        } catch (FileNotFoundException e) {
        }
    }

    @SuppressWarnings("unused")
    @Test
    public void testOpenFileWithoutCallIdAndAttachment() throws Exception {
        try {
            ParcelFileDescriptor pfd = providerUnderTest.openFile(Uri.parse("/foo"), "r");
            fail("expected FileNotFoundException");
        } catch (FileNotFoundException e) {
        }
    }

    @SuppressWarnings("unused")
    @Test
    public void testOpenFileWithBadCallID() throws Exception {
        try {
            ParcelFileDescriptor pfd = providerUnderTest.openFile(Uri.parse("/foo/bar"), "r");
            fail("expected FileNotFoundException");
        } catch (FileNotFoundException e) {
        }
    }

    @Test
    public void testOpenFileWithUnknownUri() throws Exception {
        try {
            ParcelFileDescriptor pfd = getTestAttachmentParcelFileDescriptor(UUID.randomUUID());
            assertNotNull(pfd);
            pfd.close();

            fail("expected FileNotFoundException");
        } catch (FileNotFoundException e) {
        }
    }

    @Test
    public void testOpenFileWithKnownUri() throws Exception {
        MockAttachmentStore.addAttachment(CALL_ID, ATTACHMENT_NAME);

        ParcelFileDescriptor pfd = getTestAttachmentParcelFileDescriptor(CALL_ID);
        assertNotNull(pfd);
        pfd.close();
    }

    private ParcelFileDescriptor getTestAttachmentParcelFileDescriptor(UUID callId)
            throws Exception {
        when(NativeAppCallAttachmentStore.openAttachment(callId, ATTACHMENT_NAME))
                .thenReturn(MockAttachmentStore.openAttachment(callId, ATTACHMENT_NAME));

        Uri uri = Uri.parse(
                FacebookContentProvider.getAttachmentUrl(APP_ID, callId, ATTACHMENT_NAME));

        return providerUnderTest.openFile(uri, "r");
    }

    static class MockAttachmentStore {
        private static List<Pair<UUID, String>> attachments = new ArrayList<>();
        private static final String DUMMY_FILE_NAME = "dummyfile";

        public static void addAttachment(UUID callId, String attachmentName) {
            attachments.add(new Pair<>(callId, attachmentName));
        }

        public static File openAttachment(UUID callId, String attachmentName)
                throws FileNotFoundException {
            if (attachments.contains(new Pair<>(callId, attachmentName))) {
                File cacheDir = Robolectric.application.getCacheDir();
                File dummyFile = new File(cacheDir, DUMMY_FILE_NAME);
                if (!dummyFile.exists()) {
                    try {
                        dummyFile.createNewFile();
                    } catch (IOException e) {
                    }
                }

                return dummyFile;
            }

            throw new FileNotFoundException();
        }
    }
}

<code block>


package com.facebook;

import android.content.Context;
import android.content.SharedPreferences;
import android.os.Bundle;

import com.facebook.internal.Utility;

import org.json.JSONException;
import org.json.JSONObject;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.powermock.api.mockito.PowerMockito;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.robolectric.Robolectric;

import java.util.Arrays;
import java.util.Date;
import java.util.List;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.mockito.Matchers.any;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.powermock.api.mockito.PowerMockito.mockStatic;
import static org.powermock.api.mockito.PowerMockito.when;
import static org.powermock.api.mockito.PowerMockito.mock;
import static org.powermock.api.support.membermodification.MemberModifier.stub;

@PrepareForTest( {
        AccessTokenCache.class,
        FacebookSdk.class,
        LegacyTokenHelper.class,
        Utility.class})
public class AccessTokenCacheTest extends FacebookPowerMockTestCase {

    private final String TOKEN_STRING = "A token of my esteem";
    private final String USER_ID = "1000";
    private final List<String> PERMISSIONS = Arrays.asList("walk", "chew gum");
    private final Date EXPIRES = new Date(2025, 5, 3);
    private final Date LAST_REFRESH = new Date(2023, 8, 15);
    private final String APP_ID = "1234";

    private SharedPreferences sharedPreferences;
    @Mock private LegacyTokenHelper cachingStrategy;
    private AccessTokenCache.SharedPreferencesTokenCachingStrategyFactory
            cachingStrategyFactory;

    @Before
    public void before() throws Exception {
        mockStatic(FacebookSdk.class);
        sharedPreferences = Robolectric.application.getSharedPreferences(
                AccessTokenManager.SHARED_PREFERENCES_NAME, Context.MODE_PRIVATE);
        sharedPreferences.edit().clear().commit();
        cachingStrategyFactory = mock(
                AccessTokenCache.SharedPreferencesTokenCachingStrategyFactory.class);
        when(cachingStrategyFactory.create()).thenReturn(cachingStrategy);
        stub(PowerMockito.method(Utility.class, "awaitGetGraphMeRequestWithCache")).toReturn(
                new JSONObject().put("id", "1000"));
    }


    @Test
    public void testLoadReturnsFalseIfNoCachedToken() {
        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);

        AccessToken accessToken = cache.load();

        assertNull(accessToken);
        PowerMockito.verifyZeroInteractions(cachingStrategy);
    }

    @Test
    public void testLoadReturnsFalseIfNoCachedOrLegacyToken() {
        when(FacebookSdk.isLegacyTokenUpgradeSupported()).thenReturn(true);

        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);

        AccessToken accessToken = cache.load();

        assertNull(accessToken);
    }

    @Test
    public void testLoadReturnsFalseIfEmptyCachedTokenAndDoesNotCheckLegacy() {

        JSONObject jsonObject = new JSONObject();
        sharedPreferences.edit().putString(AccessTokenCache.CACHED_ACCESS_TOKEN_KEY,
                jsonObject.toString()).commit();

        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);

        AccessToken accessToken = cache.load();

        assertNull(accessToken);
        verifyZeroInteractions(cachingStrategy);
    }

    @Test
    public void testLoadReturnsFalseIfNoCachedTokenAndEmptyLegacyToken() {
        when(FacebookSdk.isLegacyTokenUpgradeSupported()).thenReturn(true);

        when(cachingStrategy.load()).thenReturn(new Bundle());

        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);

        AccessToken accessToken = cache.load();

        assertNull(accessToken);
    }

    @Test
    public void testLoadValidCachedToken() throws JSONException {
        AccessToken accessToken = createAccessToken();
        JSONObject jsonObject = accessToken.toJSONObject();
        sharedPreferences.edit().putString(AccessTokenCache.CACHED_ACCESS_TOKEN_KEY,
                jsonObject.toString()).commit();

        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);

        AccessToken loadedAccessToken = cache.load();

        assertNotNull(loadedAccessToken);
        assertEquals(accessToken, loadedAccessToken);
    }

    @Test
    public void testLoadSetsCurrentTokenIfNoCachedTokenButValidLegacyToken() {
        when(FacebookSdk.isLegacyTokenUpgradeSupported()).thenReturn(true);

        AccessToken accessToken = createAccessToken();
        when(cachingStrategy.load()).thenReturn(
                AccessTokenTestHelper.toLegacyCacheBundle(accessToken));

        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);

        AccessToken loadedAccessToken = cache.load();

        assertNotNull(loadedAccessToken);
        assertEquals(accessToken, loadedAccessToken);
    }

    @Test
    public void testLoadSavesTokenWhenUpgradingFromLegacyToken() throws JSONException {
        when(FacebookSdk.isLegacyTokenUpgradeSupported()).thenReturn(true);

        AccessToken accessToken = createAccessToken();
        when(cachingStrategy.load()).thenReturn(
                AccessTokenTestHelper.toLegacyCacheBundle(accessToken));

        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);
        cache.load();

        assertTrue(sharedPreferences.contains(AccessTokenCache.CACHED_ACCESS_TOKEN_KEY));

        AccessToken savedAccessToken = AccessToken.createFromJSONObject(
                new JSONObject(sharedPreferences.getString(
                        AccessTokenCache.CACHED_ACCESS_TOKEN_KEY, null)));
        assertEquals(accessToken, savedAccessToken);
    }

    @Test
    public void testLoadClearsLegacyCacheWhenUpgradingFromLegacyToken() {
        when(FacebookSdk.isLegacyTokenUpgradeSupported()).thenReturn(true);

        AccessToken accessToken = createAccessToken();
        when(cachingStrategy.load()).thenReturn(
                AccessTokenTestHelper.toLegacyCacheBundle(accessToken));

        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);
        cache.load();

        verify(cachingStrategy, times(1)).clear();
    }

    @Test
    public void testSaveRequiresToken() {
        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);

        try {
            cache.save(null);
            fail();
        } catch (NullPointerException exception) {
        }
    }

    @Test
    public void testSaveWritesToCacheIfToken() throws JSONException {
        AccessToken accessToken = createAccessToken();
        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);

        cache.save(accessToken);

        verify(cachingStrategy, never()).save(any(Bundle.class));
        assertTrue(sharedPreferences.contains(AccessTokenCache.CACHED_ACCESS_TOKEN_KEY));

        AccessToken savedAccessToken = AccessToken.createFromJSONObject(
                new JSONObject(sharedPreferences.getString(
                        AccessTokenCache.CACHED_ACCESS_TOKEN_KEY, null)));
        assertEquals(accessToken, savedAccessToken);
    }

    @Test
    public void testClearCacheClearsCache() {
        AccessToken accessToken = createAccessToken();
        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);

        cache.save(accessToken);

        cache.clear();

        assertFalse(sharedPreferences.contains(AccessTokenCache.CACHED_ACCESS_TOKEN_KEY));
        verify(cachingStrategy, never()).clear();
    }

    @Test
    public void testClearCacheClearsLegacyCache() {
        when(FacebookSdk.isLegacyTokenUpgradeSupported()).thenReturn(true);

        AccessToken accessToken = createAccessToken();
        AccessTokenCache cache = new AccessTokenCache(sharedPreferences, cachingStrategyFactory);

        cache.save(accessToken);

        cache.clear();

        assertFalse(sharedPreferences.contains(AccessTokenCache.CACHED_ACCESS_TOKEN_KEY));
        verify(cachingStrategy, times(1)).clear();
    }

    private AccessToken createAccessToken() {
        return createAccessToken(TOKEN_STRING, USER_ID);
    }

    private AccessToken createAccessToken(String tokenString, String userId) {
        return new AccessToken(
                tokenString,
                APP_ID,
                userId,
                PERMISSIONS,
                null,
                AccessTokenSource.WEB_VIEW,
                EXPIRES,
                LAST_REFRESH);
    }
}

<code block>


package com.facebook.internal;


import com.facebook.FacebookSdk;
import com.facebook.FacebookTestCase;
import com.facebook.TestUtils;

import org.junit.Before;
import org.junit.Test;
import org.robolectric.Robolectric;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Random;

import static org.junit.Assert.*;

public final class FileLruCacheTest extends FacebookTestCase {
    private static final Random random = new Random();

    @Before
    public void before() {
        FacebookSdk.sdkInitialize(Robolectric.application);
    }

    @Test
    public void testCacheOutputStream() throws Exception {
        int dataSize = 1024;
        byte[] data = generateBytes(dataSize);
        String key = "a";

        
        FileLruCache cache = new FileLruCache("testCacheOutputStream", limitCacheSize(2*dataSize));

        try {
            put(cache, key, data);
            checkValue(cache, key, data);
        } finally {
            TestUtils.clearAndDeleteLruCacheDirectory(cache);
        }
    }

    @Test
    public void testCacheInputStream() throws Exception {
        int dataSize = 1024;
        byte[] data = generateBytes(dataSize);
        String key = "a";
        InputStream stream = new ByteArrayInputStream(data);

        
        FileLruCache cache = new FileLruCache("testCacheInputStream", limitCacheSize(2*dataSize));
        try {
            TestUtils.clearFileLruCache(cache);

            InputStream wrapped = cache.interceptAndPut(key, stream);
            consumeAndClose(wrapped);
            checkValue(cache, key, data);
        } finally {
            TestUtils.clearAndDeleteLruCacheDirectory(cache);
        }
    }

    @Test
    public void testCacheClear() throws Exception {
        int dataSize = 1024;
        byte[] data = generateBytes(dataSize);
        String key = "a";

        
        FileLruCache cache = new FileLruCache("testCacheClear", limitCacheSize(2*dataSize));
        try {
            TestUtils.clearFileLruCache(cache);

            put(cache, key, data);
            checkValue(cache, key, data);

            TestUtils.clearFileLruCache(cache);
            assertEquals(false, hasValue(cache, key));
            assertEquals(0, cache.sizeInBytesForTest());
        } finally {
            TestUtils.clearAndDeleteLruCacheDirectory(cache);
        }
    }

    @Test
    public void testCacheClearMidBuffer() throws Exception {
        int dataSize = 1024;
        byte[] data = generateBytes(dataSize);
        String key = "a";
        String key2 = "b";

        
        FileLruCache cache = new FileLruCache("testCacheClear", limitCacheSize(2*dataSize));
        try {
            TestUtils.clearFileLruCache(cache);

            put(cache, key, data);
            checkValue(cache, key, data);
            OutputStream stream = cache.openPutStream(key2);
            Thread.sleep(200);

            TestUtils.clearFileLruCache(cache);

            stream.write(data);
            stream.close();

            assertEquals(false, hasValue(cache, key));
            assertEquals(false, hasValue(cache, key2));
            assertEquals(0, cache.sizeInBytesForTest());
        } finally {
            TestUtils.clearAndDeleteLruCacheDirectory(cache);
        }
    }

    @Test
    public void testSizeInBytes() throws Exception {
        int count = 17;
        int dataSize = 53;
        int cacheSize = count * dataSize;
        byte[] data = generateBytes(dataSize);

        
        FileLruCache cache = new FileLruCache("testSizeInBytes", limitCacheSize(2*cacheSize));
        try {
            TestUtils.clearFileLruCache(cache);

            for (int i = 0; i < count; i++) {
                put(cache, i, data);

                
                
                
                
                int totalDataSize = (i + 1) * dataSize;
                assertTrue(cache.sizeInBytesForTest() > totalDataSize);
                assertTrue(cache.sizeInBytesForTest() < 2 * totalDataSize);
            }
            for (int i = 0; i < count; i++) {
                String key = Integer.valueOf(i).toString();
                checkValue(cache, key, data);
            }
        } finally {
            TestUtils.clearAndDeleteLruCacheDirectory(cache);
        }
    }

    @Test
    public void testCacheSizeLimit() throws Exception {
        int count = 64;
        int dataSize = 32;
        int cacheSize = count * dataSize / 2;
        byte[] data = generateBytes(dataSize);

        
        
        FileLruCache cache = new FileLruCache("testCacheSizeLimit", limitCacheSize(cacheSize));
        try {
            TestUtils.clearFileLruCache(cache);

            for (int i = 0; i < count; i++) {
                put(cache, i, data);

                
                
                
                
                int totalDataSize = (i + 1) * dataSize;
                assertTrue(cache.sizeInBytesForTest() > Math.min(totalDataSize, cacheSize / 2));
                assertTrue(cache.sizeInBytesForTest() < Math.min(2 * totalDataSize, cacheSize));
            }

            
            Thread.sleep(200);

            
            boolean hasValueExists = false;
            boolean hasNoValueExists = false;

            for (int i = 0; i < count; i++) {
                String key = Integer.valueOf(i).toString();
                if (hasValue(cache, key)) {
                    hasValueExists = true;
                    checkValue(cache, key, data);
                } else {
                    hasNoValueExists = true;
                }
            }

            assertEquals(true, hasValueExists);
            assertEquals(true, hasNoValueExists);
        } finally {
            TestUtils.clearAndDeleteLruCacheDirectory(cache);
        }
    }

    @Test
    public void testCacheCountLimit() throws Exception {
        int count = 64;
        int dataSize = 32;
        int cacheCount = count / 2;
        byte[] data = generateBytes(dataSize);

        
        FileLruCache cache = new FileLruCache("testCacheCountLimit", limitCacheCount(cacheCount));
        try {
            TestUtils.clearFileLruCache(cache);

            for (int i = 0; i < count; i++) {
                put(cache, i, data);
            }

            
            Thread.sleep(200);

            
            boolean hasValueExists = false;
            boolean hasNoValueExists = false;

            for (int i = 0; i < count; i++) {
                if (hasValue(cache, i)) {
                    hasValueExists = true;
                    checkValue(cache, i, data);
                } else {
                    hasNoValueExists = true;
                }
            }

            assertEquals(true, hasValueExists);
            assertEquals(true, hasNoValueExists);
        } finally {
            TestUtils.clearAndDeleteLruCacheDirectory(cache);
        }
    }

    @Test
    public void testCacheLru() throws IOException, InterruptedException {
        int keepCount = 10;
        int otherCount = 5;
        int dataSize = 64;
        byte[] data = generateBytes(dataSize);

        
        FileLruCache cache = new FileLruCache("testCacheLru", limitCacheCount(keepCount + 1));
        try {
            TestUtils.clearFileLruCache(cache);

            for (int i = 0; i < keepCount; i++) {
                put(cache, i, data);
            }

            
            
            
            Thread.sleep(1000);
            for (int i = 0; i < otherCount; i++) {
                put(cache, keepCount + i, data);
                Thread.sleep(1000);

                
                for (int keepIndex = 0; keepIndex < keepCount; keepIndex++) {
                    checkValue(cache, keepIndex, data);
                }
                Thread.sleep(200);
            }

            
            for (int i = 0; i < (otherCount - 1); i++) {
                String key = Integer.valueOf(keepCount + i).toString();
                assertEquals(false, hasValue(cache, key));
            }
        } finally {
            TestUtils.clearAndDeleteLruCacheDirectory(cache);
        }
    }

    @Test
    public void testConcurrentWritesToSameKey() throws IOException, InterruptedException {
        final int count = 5;
        final int dataSize = 81;
        final int threadCount = 31;
        final int iterationCount = 10;
        final byte[] data = generateBytes(dataSize);

        final FileLruCache cache = new FileLruCache(
                "testConcurrentWritesToSameKey", limitCacheCount(count+1));
        try {
            TestUtils.clearFileLruCache(cache);

            Runnable run = new Runnable() {
                @Override
                public void run() {
                    for (int iterations = 0; iterations < iterationCount; iterations++) {
                        for (int i = 0; i < count; i++) {
                            put(cache, i, data);
                        }
                    }
                }
            };

            
            Thread[] threads = new Thread[threadCount];
            for (int i = 0; i < threads.length; i++) {
                threads[i] = new Thread(run);
            }

            for (Thread thread : threads) {
                thread.start();
            }

            for (Thread thread : threads) {
                thread.join(10 * 1000, 0);
            }

            
            for (int i = 0; i < count; i++) {
                checkValue(cache, i, data);
            }
        } finally {
            TestUtils.clearAndDeleteLruCacheDirectory(cache);
        }
    }

    byte[] generateBytes(int n) {
        byte[] bytes = new byte[n];
        random.nextBytes(bytes);
        return bytes;
    }

    FileLruCache.Limits limitCacheSize(int n) {
        FileLruCache.Limits limits = new FileLruCache.Limits();
        limits.setByteCount(n);
        return limits;
    }

    FileLruCache.Limits limitCacheCount(int n) {
        FileLruCache.Limits limits = new FileLruCache.Limits();
        limits.setFileCount(n);
        return limits;
    }

    void put(FileLruCache cache, int i, byte[] data) {
        put(cache, Integer.valueOf(i).toString(), data);
    }

    void put(FileLruCache cache, String key, byte[] data) {
        try {
            OutputStream stream = cache.openPutStream(key);
            assertNotNull(stream);

            stream.write(data);
            stream.close();
        } catch (IOException e) {
            
            assertNull(e);
        }
    }

    void checkValue(FileLruCache cache, int i, byte[] expected) {
        checkValue(cache, Integer.valueOf(i).toString(), expected);
    }

    void checkValue(FileLruCache cache, String key, byte[] expected) {
        try {
            InputStream stream = cache.get(key);
            assertNotNull(stream);

            checkInputStream(expected, stream);
            stream.close();
        } catch (IOException e) {
            
            assertNull(e);
        }
    }

    boolean hasValue(FileLruCache cache, int i) {
        return hasValue(cache, Integer.valueOf(i).toString());
    }

    boolean hasValue(FileLruCache cache, String key) {
        InputStream stream = null;

        try {
            stream = cache.get(key);
        } catch (IOException e) {
            
            assertNull(e);
        }

        return stream != null;
    }

    void checkInputStream(byte[] expected, InputStream actual) {
        try {
            for (int i = 0; i < expected.length; i++) {
                int b = actual.read();
                assertEquals(((int)expected[i]) & 0xff, b);
            }

            int eof = actual.read();
            assertEquals(-1, eof);
        } catch (IOException e) {
            
            assertNull(e);
        }
    }

    void consumeAndClose(InputStream stream) {
        try {
            byte[] buffer = new byte[1024];
            while (stream.read(buffer) > -1) {
                
            }
            stream.close();
        } catch (IOException e) {
            
            assertNull(e);
        }
    }
}

<code block>


package com.facebook.internal;

import android.content.Intent;

import com.facebook.FacebookPowerMockTestCase;
import com.facebook.FacebookSdk;

import org.junit.Before;
import org.junit.Test;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.powermock.reflect.Whitebox;
import org.robolectric.Robolectric;

import java.util.HashMap;

import bolts.Capture;

import static org.junit.Assert.*;

@PrepareForTest({ CallbackManagerImpl.class })
public final class CallbackManagerImplPowerMockTest extends FacebookPowerMockTestCase {

    @Before
    public void before() {
        FacebookSdk.sdkInitialize(Robolectric.application);
        
        Whitebox.setInternalState(
                CallbackManagerImpl.class,
                "staticCallbacks",
                new HashMap<Integer, CallbackManagerImpl.Callback>());
    }

    @Test
    public void testStaticRegisterValidations() {
        try {
            CallbackManagerImpl.registerStaticCallback(
                    CallbackManagerImpl.RequestCodeOffset.Login.toRequestCode(), null);
            fail();
        } catch (NullPointerException exception) { }
    }

    @Test
    public void testRegisterValidations() {
        CallbackManagerImpl callbackManagerImpl = new CallbackManagerImpl();
        try {
            callbackManagerImpl.registerCallback(
                    CallbackManagerImpl.RequestCodeOffset.Login.toRequestCode(), null);
            fail();
        } catch (NullPointerException exception) { }
    }

    @Test
    public void testCallbackExecuted() {
        final Capture<Boolean> capture = new Capture(false);

        final CallbackManagerImpl callbackManagerImpl = new CallbackManagerImpl();

        callbackManagerImpl.registerCallback(
                CallbackManagerImpl.RequestCodeOffset.Login.toRequestCode(),
                new CallbackManagerImpl.Callback() {
                    @Override
                    public boolean onActivityResult(int resultCode, Intent data) {
                        capture.set(true);
                        return true;
                    }
                });
        callbackManagerImpl.onActivityResult(
                FacebookSdk.getCallbackRequestCodeOffset(),
                1,
                new Intent());
        assertTrue(capture.get());
    }

    @Test
    public void testRightCallbackExecuted() {
        final Capture<Boolean> capture = new Capture(false);

        final CallbackManagerImpl callbackManagerImpl = new CallbackManagerImpl();

        callbackManagerImpl.registerCallback(
                123,
                new CallbackManagerImpl.Callback() {
                    @Override
                    public boolean onActivityResult(int resultCode, Intent data) {
                        capture.set(true);
                        return true;
                    }
                });
        callbackManagerImpl.registerCallback(
                456,
                new CallbackManagerImpl.Callback() {
                    @Override
                    public boolean onActivityResult(int resultCode, Intent data) {
                        return false;
                    }
                });
        callbackManagerImpl.onActivityResult(
                123,
                1,
                new Intent());
        assertTrue(capture.get());
    }

    @Test
    public void testStaticCallbackExecuted() {
        final Capture<Boolean> capture = new Capture(false);

        final CallbackManagerImpl callbackManagerImpl = new CallbackManagerImpl();

        callbackManagerImpl.registerStaticCallback(
                CallbackManagerImpl.RequestCodeOffset.Login.toRequestCode(),
                new CallbackManagerImpl.Callback() {
                    @Override
                    public boolean onActivityResult(int resultCode, Intent data) {
                        capture.set(true);
                        return true;
                    }
                });
        callbackManagerImpl.onActivityResult(
                FacebookSdk.getCallbackRequestCodeOffset(),
                1,
                new Intent());
        assertTrue(capture.get());
    }

    @Test
    public void testStaticCallbackSkipped() {
        final Capture<Boolean> capture = new Capture(false);
        final Capture<Boolean> captureStatic = new Capture(false);

        final CallbackManagerImpl callbackManagerImpl = new CallbackManagerImpl();

        callbackManagerImpl.registerCallback(
                CallbackManagerImpl.RequestCodeOffset.Login.toRequestCode(),
                new CallbackManagerImpl.Callback() {
                    @Override
                    public boolean onActivityResult(int resultCode, Intent data) {
                        capture.set(true);
                        return true;
                    }
                });
        callbackManagerImpl.registerStaticCallback(
                CallbackManagerImpl.RequestCodeOffset.Login.toRequestCode(),
                new CallbackManagerImpl.Callback() {
                    @Override
                    public boolean onActivityResult(int resultCode, Intent data) {
                        captureStatic.set(true);
                        return true;
                    }
                });
        callbackManagerImpl.onActivityResult(
                FacebookSdk.getCallbackRequestCodeOffset(),
                1,
                new Intent());
        assertTrue(capture.get());
        assertFalse(captureStatic.get());
    }
}

<code block>


package com.facebook.share.internal;

import com.facebook.FacebookTestCase;
import com.facebook.TestUtils;
import com.facebook.share.model.ShareOpenGraphAction;
import com.facebook.share.model.ShareOpenGraphObject;

import org.apache.maven.artifact.ant.shaded.IOUtil;
import org.json.JSONException;
import org.json.JSONObject;
import org.junit.Test;
import org.robolectric.Robolectric;
import org.robolectric.util.RobolectricBackgroundExecutorService;

import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;

import static junit.framework.Assert.assertNotNull;

public class ShareOpenGraphUtilityTest extends FacebookTestCase {
    private static final String TYPE_KEY = "type";

    @Test
    public void testToJSONObject() throws IOException, JSONException {
        final JSONObject actual = OpenGraphJSONUtility.toJSONObject(this.getAction(), null);
        final JSONObject expected = this.getActionJSONObject();
        TestUtils.assertEquals(expected, actual);
    }

    private static <E> ArrayList<E> createArrayList(E... params) {
        final ArrayList<E> list = new ArrayList<E>();
        for (E item : params) {
            list.add(item);
        }
        return list;
    }

    private ShareOpenGraphAction getAction() {
        return new ShareOpenGraphAction.Builder()
                .putString(TYPE_KEY, "myActionType")
                .putObject(
                        "myObject",
                        new ShareOpenGraphObject.Builder()
                                .putString("myString", "value")
                                .putInt("myInt", 42)
                                .putBoolean("myBoolean", true)
                                .putStringArrayList(
                                        "myStringArray",
                                        createArrayList(
                                                "string1",
                                                "string2",
                                                "string3")
                                )
                                .putObject(
                                        "myObject",
                                        new ShareOpenGraphObject.Builder()
                                                .putDouble("myPi", 3.14)
                                                .build()
                                )
                                .build()).build();
    }

    private JSONObject getActionJSONObject() throws IOException, JSONException {
        return new JSONObject(this.getActionJSONString());
    }

    private String getActionJSONString() throws IOException {
        return TestUtils.getAssetFileStringContents(
                Robolectric.getShadowApplication().getApplicationContext(),
                "ShareOpenGraphUtilityTests_actionJSON.json"
        );
    }
}

<code block>


package com.facebook.login;

import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentActivity;

import com.facebook.AccessToken;
import com.facebook.FacebookPowerMockTestCase;
import com.facebook.FacebookSdk;
import com.facebook.TestUtils;

import org.junit.Before;
import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.robolectric.Robolectric;

import java.util.Arrays;
import java.util.HashSet;

import static org.junit.Assert.*;
import static org.mockito.Mockito.verify;
import static org.powermock.api.mockito.PowerMockito.mock;
import static org.powermock.api.mockito.PowerMockito.when;

@PrepareForTest({ LoginClient.class })
public class LoginClientTest extends FacebookPowerMockTestCase {

    private static final String ACCESS_TOKEN = "An access token for user 1";
    private static final String USER_ID = "1001";
    private static final String APP_ID = "2002";


    private static final long EXPIRES_IN_DELTA = 3600 * 24 * 60;
    private static final HashSet<String> PERMISSIONS = new HashSet<String>(
        Arrays.asList("go outside", "come back in"));
    private static final String ERROR_MESSAGE = "This is bad!";

    @Mock private Fragment mockFragment;

    @Before
    public void before() throws Exception {
        FragmentActivity activity =
            Robolectric.buildActivity(FragmentActivity.class).create().get();
        when(mockFragment.getActivity()).thenReturn(activity);
    }

    @Test
    public void testReauthorizationWithSameFbidSucceeds() throws Exception {
        FacebookSdk.sdkInitialize(Robolectric.application);
        LoginClient.Request request = createRequest(ACCESS_TOKEN);

        AccessToken token = new AccessToken(
                ACCESS_TOKEN,
                APP_ID,
                USER_ID,
                PERMISSIONS,
                null,
                null,
                null,
                null);
        LoginClient.Result result = LoginClient.Result.createTokenResult(request, token);

        LoginClient.OnCompletedListener listener = mock(LoginClient.OnCompletedListener.class);

        LoginClient client = new LoginClient(mockFragment);
        client.setOnCompletedListener(listener);

        client.completeAndValidate(result);

        ArgumentCaptor<LoginClient.Result> resultArgumentCaptor =
            ArgumentCaptor.forClass(LoginClient.Result.class);

        verify(listener).onCompleted(resultArgumentCaptor.capture());

        result = resultArgumentCaptor.getValue();

        assertNotNull(result);
        assertEquals(LoginClient.Result.Code.SUCCESS, result.code);

        AccessToken resultToken = result.token;
        assertNotNull(resultToken);
        assertEquals(ACCESS_TOKEN, resultToken.getToken());

        
        assertEquals(PERMISSIONS, resultToken.getPermissions());
    }

    @Test
    public void testRequestParceling() {
        LoginClient.Request request = createRequest(ACCESS_TOKEN);

        LoginClient.Request unparceledRequest = TestUtils.parcelAndUnparcel(request);

        assertEquals(LoginBehavior.SSO_WITH_FALLBACK, unparceledRequest.getLoginBehavior());
        assertEquals(new HashSet<String>(PERMISSIONS), unparceledRequest.getPermissions());
        assertEquals(DefaultAudience.FRIENDS, unparceledRequest.getDefaultAudience());
        assertEquals("1234", unparceledRequest.getApplicationId());
        assertEquals("5678", unparceledRequest.getAuthId());
        assertFalse(unparceledRequest.isRerequest());
    }

    @Test
    public void testResultParceling() {
        LoginClient.Request request = new LoginClient.Request(
                LoginBehavior.SUPPRESS_SSO,
                null,
                DefaultAudience.EVERYONE,
                null,
                null);
        request.setRerequest(true);
        AccessToken token1 = new AccessToken(
                "Token2",
                "12345",
                "1000",
                null,
                null,
                null,
                null,
                null);
        LoginClient.Result result = new LoginClient.Result(
                request,
                LoginClient.Result.Code.SUCCESS,
                token1,
                "error 1",
                "123"
        );

        LoginClient.Result unparceledResult = TestUtils.parcelAndUnparcel(result);
        LoginClient.Request unparceledRequest = unparceledResult.request;

        assertEquals(LoginBehavior.SUPPRESS_SSO, unparceledRequest.getLoginBehavior());
        assertEquals(new HashSet<String>(), unparceledRequest.getPermissions());
        assertEquals(DefaultAudience.EVERYONE, unparceledRequest.getDefaultAudience());
        assertEquals(null, unparceledRequest.getApplicationId());
        assertEquals(null, unparceledRequest.getAuthId());
        assertTrue(unparceledRequest.isRerequest());

        assertEquals(LoginClient.Result.Code.SUCCESS, unparceledResult.code);
        assertEquals(token1, unparceledResult.token);
        assertEquals("error 1", unparceledResult.errorMessage);
        assertEquals("123", unparceledResult.errorCode);
    }


    protected LoginClient.Request createRequest(String previousAccessTokenString) {
        return new LoginClient.Request(
                LoginBehavior.SSO_WITH_FALLBACK,
                new HashSet<String>(PERMISSIONS),
                DefaultAudience.FRIENDS,
                "1234",
                "5678");
    }

}

<code block>


package com.facebook.login;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;

import com.facebook.AccessToken;
import com.facebook.FacebookSdk;
import com.facebook.TestUtils;

import org.junit.Before;
import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.robolectric.Robolectric;

import java.util.Date;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.mockito.Matchers.any;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.powermock.api.mockito.PowerMockito.when;

@PrepareForTest( { LoginClient.class })
public class KatanaProxyLoginMethodHandlerTest extends LoginHandlerTestCase {
    private final static String SIGNED_REQUEST_STR = "ggarbage.eyJhbGdvcml0aG0iOiJITUFDSEEyNTYiLCJ"
            + "jb2RlIjoid2h5bm90IiwiaXNzdWVkX2F0IjoxNDIyNTAyMDkyLCJ1c2VyX2lkIjoiMTIzIn0";

    @Before
    @Override
    public void before() throws Exception {
        super.before();
        FacebookSdk.sdkInitialize(Robolectric.application);
    }

    @Test
    public void testProxyAuthHandlesSuccess() {
        Bundle bundle = new Bundle();
        bundle.putLong("expires_in", EXPIRES_IN_DELTA);
        bundle.putString("access_token", ACCESS_TOKEN);
        bundle.putString("signed_request", SIGNED_REQUEST_STR);

        Intent intent = new Intent();
        intent.putExtras(bundle);

        KatanaProxyLoginMethodHandler handler = new KatanaProxyLoginMethodHandler(mockLoginClient);

        LoginClient.Request request = createRequest();
        when(mockLoginClient.getPendingRequest()).thenReturn(request);

        handler.tryAuthorize(request);
        handler.onActivityResult(0, Activity.RESULT_OK, intent);

        ArgumentCaptor<LoginClient.Result> resultArgumentCaptor =
                ArgumentCaptor.forClass(LoginClient.Result.class);
        verify(mockLoginClient, times(1)).completeAndValidate(resultArgumentCaptor.capture());

        LoginClient.Result result = resultArgumentCaptor.getValue();

        assertNotNull(result);
        assertEquals(LoginClient.Result.Code.SUCCESS, result.code);

        AccessToken token = result.token;
        assertNotNull(token);
        assertEquals(ACCESS_TOKEN, token.getToken());
        assertDateDiffersWithinDelta(new Date(), token.getExpires(), EXPIRES_IN_DELTA * 1000, 1000);
        TestUtils.assertSamePermissions(PERMISSIONS, token.getPermissions());
    }

    @Test
    public void testProxyAuthHandlesCancel() {
        Bundle bundle = new Bundle();
        bundle.putString("error", ERROR_MESSAGE);

        Intent intent = new Intent();
        intent.putExtras(bundle);

        KatanaProxyLoginMethodHandler handler = new KatanaProxyLoginMethodHandler(mockLoginClient);

        LoginClient.Request request = createRequest();
        handler.tryAuthorize(request);
        handler.onActivityResult(0, Activity.RESULT_CANCELED, intent);

        ArgumentCaptor<LoginClient.Result> resultArgumentCaptor =
                ArgumentCaptor.forClass(LoginClient.Result.class);
        verify(mockLoginClient, times(1)).completeAndValidate(resultArgumentCaptor.capture());

        LoginClient.Result result = resultArgumentCaptor.getValue();

        assertNotNull(result);
        assertEquals(LoginClient.Result.Code.CANCEL, result.code);

        assertNull(result.token);
        assertNotNull(result.errorMessage);
        assertTrue(result.errorMessage.contains(ERROR_MESSAGE));
    }

    @Test
    public void testProxyAuthHandlesCancelErrorMessage() {
        Bundle bundle = new Bundle();
        bundle.putString("error", "access_denied");

        Intent intent = new Intent();
        intent.putExtras(bundle);

        KatanaProxyLoginMethodHandler handler = new KatanaProxyLoginMethodHandler(mockLoginClient);

        LoginClient.Request request = createRequest();
        handler.tryAuthorize(request);
        handler.onActivityResult(0, Activity.RESULT_CANCELED, intent);

        ArgumentCaptor<LoginClient.Result> resultArgumentCaptor =
                ArgumentCaptor.forClass(LoginClient.Result.class);
        verify(mockLoginClient, times(1)).completeAndValidate(resultArgumentCaptor.capture());

        LoginClient.Result result = resultArgumentCaptor.getValue();

        assertNotNull(result);
        assertEquals(LoginClient.Result.Code.CANCEL, result.code);

        assertNull(result.token);
    }

    @Test
    public void testProxyAuthHandlesDisabled() {
        Bundle bundle = new Bundle();
        bundle.putString("error", "service_disabled");

        Intent intent = new Intent();
        intent.putExtras(bundle);

        KatanaProxyLoginMethodHandler handler = new KatanaProxyLoginMethodHandler(mockLoginClient);

        LoginClient.Request request = createRequest();
        handler.tryAuthorize(request);
        handler.onActivityResult(0, Activity.RESULT_OK, intent);

        verify(mockLoginClient, never()).completeAndValidate(any(LoginClient.Result.class));
        verify(mockLoginClient, times(1)).tryNextHandler();
    }
}

<code block>


package com.facebook.login;

import com.facebook.AccessToken;
import com.facebook.FacebookSdk;
import com.facebook.FacebookTestCase;

import org.junit.Before;
import org.junit.Test;
import org.robolectric.Robolectric;

import java.util.HashSet;
import java.util.Set;

import static org.junit.Assert.*;

public class LoginResultTest extends FacebookTestCase {

    private final Set<String> EMAIL_SET = new HashSet<String>(){{ add("email"); }};
    private final Set<String> LIKES_EMAIL_SET = new HashSet<String>(){{
        add("user_likes");
        add("email");
    }};
    private final Set<String> PROFILE_EMAIL_SET = new HashSet<String>(){{
        add("user_profile");
        add("email");
    }};

    @Before
    public void before() throws Exception {
        FacebookSdk.sdkInitialize(Robolectric.application);
    }

    @Test
    public void testInitialLogin() {
        LoginClient.Request request = createRequest(EMAIL_SET, false);
        AccessToken accessToken = createAccessToken(PROFILE_EMAIL_SET, new HashSet<String>());
        LoginResult result = LoginManager.computeLoginResult(request, accessToken);
        assertEquals(accessToken, result.getAccessToken());
        assertEquals(PROFILE_EMAIL_SET, result.getRecentlyGrantedPermissions());
        assertEquals(0, result.getRecentlyDeniedPermissions().size());
    }

    @Test
    public void testReAuth() {
        LoginClient.Request request = createRequest(EMAIL_SET, true);
        AccessToken accessToken = createAccessToken(PROFILE_EMAIL_SET, new HashSet<String>());
        LoginResult result = LoginManager.computeLoginResult(request, accessToken);
        assertEquals(accessToken, result.getAccessToken());
        assertEquals(EMAIL_SET, result.getRecentlyGrantedPermissions());
        assertEquals(0, result.getRecentlyDeniedPermissions().size());
    }

    @Test
    public void testDeniedPermissions() {
        LoginClient.Request request = createRequest(LIKES_EMAIL_SET, true);
        AccessToken accessToken = createAccessToken(EMAIL_SET, new HashSet<String>());
        LoginResult result = LoginManager.computeLoginResult(request, accessToken);
        assertEquals(accessToken, result.getAccessToken());
        assertEquals(EMAIL_SET, result.getRecentlyGrantedPermissions());
        assertEquals(
                new HashSet<String>(){{ add("user_likes"); }},
                result.getRecentlyDeniedPermissions());
    }


    private AccessToken createAccessToken(Set<String> permissions,
                                          Set<String> declinedPermissions) {
        return new AccessToken(
            "token",
            "123",
            "234",
            permissions,
            declinedPermissions,
            null,
            null,
            null
        );
    }

    private LoginClient.Request createRequest(Set<String> permissions, boolean isRerequest) {
        LoginClient.Request request = new LoginClient.Request(
                LoginBehavior.SSO_WITH_FALLBACK,
                permissions,
                DefaultAudience.EVERYONE,
                "123",
                "authid"
        );
        request.setRerequest(isRerequest);
        return request;
    }
}

<code block>


package com.facebook.login.widget;

import android.app.Activity;

import com.facebook.FacebookTestCase;
import com.facebook.junittests.MainActivity;
import com.facebook.junittests.R;
import com.facebook.login.DefaultAudience;
import com.facebook.login.LoginManager;

import org.junit.Test;
import org.robolectric.Robolectric;

import java.util.ArrayList;

import static org.junit.Assert.fail;
import static org.mockito.Matchers.anyCollection;
import static org.mockito.Matchers.isA;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.powermock.api.mockito.PowerMockito.mock;

public class LoginButtonTest extends FacebookTestCase {

    @Test
    public void testLoginButtonWithReadPermissions() throws Exception {
        LoginManager loginManager = mock(LoginManager.class);
        Activity activity = Robolectric.buildActivity(MainActivity.class).create().get();

        LoginButton loginButton = (LoginButton) activity.findViewById(R.id.login_button);
        ArrayList<String> permissions = new ArrayList<>();
        permissions.add("user_location");
        loginButton.setReadPermissions(permissions);
        loginButton.setDefaultAudience(DefaultAudience.EVERYONE);
        loginButton.setLoginManager(loginManager);
        loginButton.performClick();

        verify(loginManager).logInWithReadPermissions(activity, permissions);
        verify(loginManager, never())
                .logInWithPublishPermissions(isA(Activity.class), anyCollection());
        
        verify(loginManager).setDefaultAudience(DefaultAudience.EVERYONE);
    }

    @Test
    public void testLoginButtonWithPublishPermissions() throws Exception {
        LoginManager loginManager = mock(LoginManager.class);
        Activity activity = Robolectric.buildActivity(MainActivity.class).create().get();

        LoginButton loginButton = (LoginButton) activity.findViewById(R.id.login_button);
        ArrayList<String> permissions = new ArrayList<>();
        permissions.add("publish_actions");
        loginButton.setPublishPermissions(permissions);
        loginButton.setLoginManager(loginManager);
        loginButton.performClick();

        verify(loginManager, never())
                .logInWithReadPermissions(isA(Activity.class), anyCollection());
        verify(loginManager).logInWithPublishPermissions(activity, permissions);
    }

    @Test
    public void testCantSetReadThenPublishPermissions() throws Exception {
        Activity activity = Robolectric.buildActivity(MainActivity.class).create().get();

        LoginButton loginButton = (LoginButton) activity.findViewById(R.id.login_button);
        loginButton.setReadPermissions("user_location");
        try {
            loginButton.setPublishPermissions("publish_actions");
        } catch (UnsupportedOperationException e) {
            return;
        }
        fail();
    }

    @Test
    public void testCantSetPublishThenReadPermissions() throws Exception {
        Activity activity = Robolectric.buildActivity(MainActivity.class).create().get();

        LoginButton loginButton = (LoginButton) activity.findViewById(R.id.login_button);
        loginButton.setPublishPermissions("publish_actions");
        try {
            loginButton.setReadPermissions("user_location");
        } catch (UnsupportedOperationException e) {
            return;
        }
        fail();
    }
}

<code block>


package com.facebook.messenger;

import android.app.Activity;
import android.content.ContentResolver;
import android.content.Intent;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.database.MatrixCursor;
import android.net.Uri;
import android.os.Bundle;

import com.facebook.FacebookSdk;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.robolectric.Robolectric;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;

import java.util.Arrays;

import static org.junit.Assert.*;
import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.*;


@RunWith(RobolectricTestRunner.class)
@Config(emulateSdk = 18, manifest = Config.NONE)
public class MessengerUtilsTest {

  private Activity mMockActivity;
  private PackageManager mMockPackageManager;
  private ContentResolver mMockContentResolver;

  @Before
  public void setup() {
    mMockActivity = mock(Activity.class);
    mMockPackageManager = mock(PackageManager.class);
    mMockContentResolver = mock(ContentResolver.class);
    when(mMockActivity.getPackageManager()).thenReturn(mMockPackageManager);
    when(mMockActivity.getContentResolver()).thenReturn(mMockContentResolver);
    FacebookSdk.sdkInitialize(Robolectric.application);
    FacebookSdk.setApplicationId("200");
  }

  @Test
  public void testMessengerIsInstalled() throws Exception {
    setupPackageManagerForMessenger(true);
    assertTrue(MessengerUtils.hasMessengerInstalled(mMockActivity));
  }

  @Test
  public void testMessengerNotInstalled() throws Exception {
    setupPackageManagerForMessenger(false);
    assertFalse(MessengerUtils.hasMessengerInstalled(mMockActivity));
  }

  @Test
  public void testShareToMessengerWith20150314Protocol() throws Exception {
    setupPackageManagerForMessenger(true);
    setupContentResolverForProtocolVersions(20150314);


    Uri uri = Uri.parse("file:
    Uri externalUri = Uri.parse("http:
    ShareToMessengerParams params = ShareToMessengerParams
        .newBuilder(uri, "image/jpeg")
        .setMetaData("{}")
        .setExternalUri(externalUri)
        .build();
    MessengerUtils.shareToMessenger(mMockActivity, 1, params);

    
    ArgumentCaptor<Intent> intentArgumentCaptor = ArgumentCaptor.forClass(Intent.class);
    verify(mMockActivity).startActivityForResult(
        intentArgumentCaptor.capture(),
        eq(1));
    Intent intent = intentArgumentCaptor.getValue();
    assertEquals(Intent.ACTION_SEND, intent.getAction());
    assertEquals(Intent.FLAG_GRANT_READ_URI_PERMISSION, intent.getFlags());
    assertEquals("com.facebook.orca", intent.getPackage());
    assertEquals(uri, intent.getParcelableExtra(Intent.EXTRA_STREAM));
    assertEquals("image/jpeg", intent.getType());
    assertEquals("200", intent.getStringExtra("com.facebook.orca.extra.APPLICATION_ID"));
    assertEquals(20150314, intent.getIntExtra("com.facebook.orca.extra.PROTOCOL_VERSION", -1));
    assertEquals("{}", intent.getStringExtra("com.facebook.orca.extra.METADATA"));
    assertEquals(externalUri, intent.getParcelableExtra("com.facebook.orca.extra.EXTERNAL_URI"));
  }

  @Test
  public void testShareToMessengerWithNoProtocol() throws Exception {
    setupPackageManagerForMessenger(true);
    setupContentResolverForProtocolVersions();

    Uri uri = Uri.parse("file:
    Uri externalUri = Uri.parse("http:
    ShareToMessengerParams params = ShareToMessengerParams
        .newBuilder(uri, "image/jpeg")
        .setMetaData("{}")
        .setExternalUri(externalUri)
        .build();
    MessengerUtils.shareToMessenger(mMockActivity, 1, params);


    
    ArgumentCaptor<Intent> intentArgumentCaptor = ArgumentCaptor.forClass(Intent.class);
    verify(mMockActivity).startActivity(intentArgumentCaptor.capture());
    Intent intent = intentArgumentCaptor.getValue();
    assertEquals(Intent.ACTION_VIEW, intent.getAction());
    assertEquals(Uri.parse("market:
  }

  @Test
  public void testGetMessengerThreadParamsForIntentWith20150314Protocol() throws Exception {
    
    Intent intent = new Intent();
    intent.addCategory("com.facebook.orca.category.PLATFORM_THREAD_20150314");
    Bundle extrasBundle = setupIntentWithAppLinkExtrasBundle(intent);
    extrasBundle.putString("com.facebook.orca.extra.THREAD_TOKEN", "thread_token");
    extrasBundle.putString("com.facebook.orca.extra.METADATA", "{}");
    extrasBundle.putString("com.facebook.orca.extra.PARTICIPANTS", "100,400,500");
    extrasBundle.putBoolean("com.facebook.orca.extra.IS_REPLY", true);

    
    MessengerThreadParams params = MessengerUtils.getMessengerThreadParamsForIntent(intent);
    assertEquals(MessengerThreadParams.Origin.REPLY_FLOW, params.origin);
    assertEquals("thread_token", params.threadToken);
    assertEquals("{}", params.metadata);
    assertEquals(Arrays.asList("100", "400", "500"), params.participants);
  }

  @Test
  public void testGetMessengerThreadParamsForIntentWithUnrecognizedIntent() throws Exception {
    
    Intent intent = new Intent();
    assertNull(MessengerUtils.getMessengerThreadParamsForIntent(intent));
  }

  @Test
  public void testFinishShareToMessengerWith20150314Protocol() throws Exception {
    
    Intent originalIntent = new Intent();
    originalIntent.addCategory("com.facebook.orca.category.PLATFORM_THREAD_20150314");
    Bundle extrasBundle = setupIntentWithAppLinkExtrasBundle(originalIntent);
    extrasBundle.putString("com.facebook.orca.extra.THREAD_TOKEN", "thread_token");
    extrasBundle.putString("com.facebook.orca.extra.METADATA", "{}");
    extrasBundle.putString("com.facebook.orca.extra.PARTICIPANTS", "100,400,500");
    when(mMockActivity.getIntent()).thenReturn(originalIntent);

    
    Uri uri = Uri.parse("file:
    Uri externalUri = Uri.parse("http:
    ShareToMessengerParams params = ShareToMessengerParams
        .newBuilder(uri, "image/jpeg")
        .setMetaData("{}")
        .setExternalUri(externalUri)
        .build();

    
    MessengerUtils.finishShareToMessenger(mMockActivity, params);
    ArgumentCaptor<Intent> intentArgumentCaptor = ArgumentCaptor.forClass(Intent.class);
    verify(mMockActivity).setResult(eq(Activity.RESULT_OK), intentArgumentCaptor.capture());
    verify(mMockActivity).finish();

    Intent intent = intentArgumentCaptor.getValue();
    assertNotNull(intent);
    assertEquals(Intent.FLAG_GRANT_READ_URI_PERMISSION, intent.getFlags());
    assertEquals(20150314, intent.getIntExtra("com.facebook.orca.extra.PROTOCOL_VERSION", -1));
    assertEquals("thread_token", intent.getStringExtra("com.facebook.orca.extra.THREAD_TOKEN"));
    assertEquals(uri, intent.getData());
    assertEquals("image/jpeg", intent.getType());
    assertEquals("200", intent.getStringExtra("com.facebook.orca.extra.APPLICATION_ID"));
    assertEquals("{}", intent.getStringExtra("com.facebook.orca.extra.METADATA"));
    assertEquals(externalUri, intent.getParcelableExtra("com.facebook.orca.extra.EXTERNAL_URI"));
  }

  @Test
  public void testFinishShareToMessengerWithUnexpectedIntent() throws Exception {
    
    Intent originalIntent = new Intent();
    when(mMockActivity.getIntent()).thenReturn(originalIntent);

    
    Uri uri = Uri.parse("file:
    Uri externalUri = Uri.parse("http:
    ShareToMessengerParams params = ShareToMessengerParams
        .newBuilder(uri, "image/jpeg")
        .setMetaData("{}")
        .setExternalUri(externalUri)
        .build();

    
    MessengerUtils.finishShareToMessenger(mMockActivity, params);
    verify(mMockActivity).setResult(Activity.RESULT_CANCELED, null);
    verify(mMockActivity).finish();
  }

  
  private void setupPackageManagerForMessenger(boolean isInstalled) throws Exception {
    if (isInstalled) {
      when(mMockPackageManager.getPackageInfo("com.facebook.orca", 0))
          .thenReturn(new PackageInfo());
    } else {
      when(mMockPackageManager.getPackageInfo("com.facebook.orca", 0))
          .thenThrow(new PackageManager.NameNotFoundException());
    }
  }

  
  private void setupContentResolverForProtocolVersions(int... versions) {
    MatrixCursor matrixCursor = new MatrixCursor(new String[]{"version"});
    for (int version : versions) {
      matrixCursor.addRow(new Object[]{version});
    }

    when(mMockContentResolver.query(
        Uri.parse("content:
        new String[]{"version"},
        null,
        null,
        null))
        .thenReturn(matrixCursor);
  }

  
  private Bundle setupIntentWithAppLinkExtrasBundle(Intent intent) {
    Bundle appLinksDataBundle = new Bundle();
    intent.putExtra("al_applink_data", appLinksDataBundle);
    Bundle extrasBundle = new Bundle();
    appLinksDataBundle.putBundle("extras", extrasBundle);
    return extrasBundle;
  }

}

<code block>


package com.facebook.appevents;

import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.support.v4.content.LocalBroadcastManager;

import com.facebook.AccessToken;
import com.facebook.FacebookTestCase;
import com.facebook.WaitForBroadcastReceiver;
import com.facebook.appevents.AppEventsLogger;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.util.HashMap;
import java.util.List;

public class AppEventsLoggerTests extends FacebookTestCase {
    public void testSimpleCall() throws InterruptedException {
        AppEventsLogger.setFlushBehavior(AppEventsLogger.FlushBehavior.EXPLICIT_ONLY);

        AccessToken accessToken1 = getAccessTokenForSharedUser();
        AccessToken accessToken2 = getAccessTokenForSharedUser(SECOND_TEST_USER_TAG);

        AppEventsLogger logger1 = AppEventsLogger.newLogger(getActivity(), accessToken1);
        AppEventsLogger logger2 = AppEventsLogger.newLogger(getActivity(), accessToken2);

        final WaitForBroadcastReceiver waitForBroadcastReceiver = new WaitForBroadcastReceiver();
        waitForBroadcastReceiver.incrementExpectCount();

        final LocalBroadcastManager broadcastManager = LocalBroadcastManager.getInstance(getActivity());

        try {
            
            runOnBlockerThread(new Runnable() {
                @Override
                public void run() {
                    broadcastManager.registerReceiver(waitForBroadcastReceiver,
                            new IntentFilter(AppEventsLogger.ACTION_APP_EVENTS_FLUSHED));
                }
            }, true);

            logger1.logEvent("an_event");
            logger2.logEvent("another_event");

            
            logger1.logEvent("$illegal_event_name");
            Bundle params = new Bundle();
            params.putString("illegal%key", "good_value");
            logger1.logEvent("legal_event_name", params);
            char[] val = {'b', 'a', 'd'};
            params.putCharArray("legal_key", val);
            logger1.logEvent("legal_event",params);

            logger1.flush();

            waitForBroadcastReceiver.waitForExpectedCalls();

            closeBlockerAndAssertSuccess();
        } finally {
            broadcastManager.unregisterReceiver(waitForBroadcastReceiver);
        }
    }

    public void testPersistedEvents() throws IOException, ClassNotFoundException {
        AppEventsLogger.setFlushBehavior(AppEventsLogger.FlushBehavior.EXPLICIT_ONLY);

        final WaitForBroadcastReceiver waitForBroadcastReceiver = new WaitForBroadcastReceiver();
        final LocalBroadcastManager broadcastManager =
                LocalBroadcastManager.getInstance(getActivity());

        try {
            broadcastManager.registerReceiver(waitForBroadcastReceiver,
                    new IntentFilter(AppEventsLogger.ACTION_APP_EVENTS_FLUSHED));

            getActivity().getFileStreamPath(
                    AppEventsLogger.PersistedEvents.PERSISTED_EVENTS_FILENAME).delete();

            AccessToken accessToken = getAccessTokenForSharedUser();
            AppEventsLogger logger1 = AppEventsLogger.newLogger(getActivity(), accessToken);

            logger1.logEvent("an_event");

            AppEventsLogger.onContextStop();

            FileInputStream fis = getActivity().openFileInput(
                    AppEventsLogger.PersistedEvents.PERSISTED_EVENTS_FILENAME);
            assertNotNull(fis);

            ObjectInputStream ois = new ObjectInputStream(fis);
            Object obj = ois.readObject();
            ois.close();

            assertTrue(obj instanceof HashMap);

            logger1.logEvent("another_event");

            waitForBroadcastReceiver.incrementExpectCount();

            
            
            try {
                Thread.sleep(100l);
            } catch (Exception ex) {
                
            }
            logger1.flush();

            waitForBroadcastReceiver.waitForExpectedCalls();
            List<Intent> receivedIntents = waitForBroadcastReceiver.getReceivedIntents();
            assertEquals(1, receivedIntents.size());

            Intent intent = receivedIntents.get(0);
            assertNotNull(intent);

            assertEquals(2, intent.getIntExtra(
                    AppEventsLogger.APP_EVENTS_EXTRA_NUM_EVENTS_FLUSHED, 0));
        } finally {
            broadcastManager.unregisterReceiver(waitForBroadcastReceiver);
        }
    }
}

<code block>


package com.facebook.samples.hellofacebook;

import android.os.Bundle;
import android.util.Log;
import com.facebook.FacebookBroadcastReceiver;


public class HelloFacebookBroadcastReceiver extends FacebookBroadcastReceiver {

    @Override
    protected void onSuccessfulAppCall(String appCallId, String action, Bundle extras) {
        
        Log.d("HelloFacebook", String.format("Photo uploaded by call " + appCallId + " succeeded."));
    }

    @Override
    protected void onFailedAppCall(String appCallId, String action, Bundle extras) {
        
        Log.d("HelloFacebook", String.format("Photo uploaded by call " + appCallId + " failed."));
    }
}

<code block>


package com.facebook.samples.hellofacebook;

import android.app.AlertDialog;
import android.content.Intent;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.location.Location;
import android.net.Uri;
import android.os.Bundle;
import android.support.v4.app.FragmentActivity;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;

import com.facebook.*;
import com.facebook.appevents.AppEventsLogger;
import com.facebook.login.LoginManager;
import com.facebook.login.LoginResult;
import com.facebook.login.widget.ProfilePictureView;
import com.facebook.share.ShareApi;
import com.facebook.share.Sharer;
import com.facebook.share.internal.ShareInternalUtility;
import com.facebook.share.model.SharePhoto;
import com.facebook.share.model.SharePhotoContent;
import com.facebook.share.model.ShareLinkContent;
import com.facebook.share.widget.ShareDialog;

import org.json.JSONObject;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;

public class HelloFacebookSampleActivity extends FragmentActivity {

    private static final String PERMISSION = "publish_actions";
    private static final Location SEATTLE_LOCATION = new Location("") {
        {
            setLatitude(47.6097);
            setLongitude(-122.3331);
        }
    };

    private final String PENDING_ACTION_BUNDLE_KEY =
            "com.facebook.samples.hellofacebook:PendingAction";

    private Button postStatusUpdateButton;
    private Button postPhotoButton;
    private ProfilePictureView profilePictureView;
    private TextView greeting;
    private PendingAction pendingAction = PendingAction.NONE;
    private boolean canPresentShareDialog;
    private boolean canPresentShareDialogWithPhotos;
    private CallbackManager callbackManager;
    private ProfileTracker profileTracker;
    private ShareDialog shareDialog;
    private FacebookCallback<Sharer.Result> shareCallback = new FacebookCallback<Sharer.Result>() {
        @Override
        public void onCancel() {
            Log.d("HelloFacebook", "Canceled");
        }

        @Override
        public void onError(FacebookException error) {
            Log.d("HelloFacebook", String.format("Error: %s", error.toString()));
            String title = getString(R.string.error);
            String alertMessage = error.getMessage();
            showResult(title, alertMessage);
        }

        @Override
        public void onSuccess(Sharer.Result result) {
            Log.d("HelloFacebook", "Success!");
            if (result.getPostId() != null) {
                String title = getString(R.string.success);
                String id = result.getPostId();
                String alertMessage = getString(R.string.successfully_posted_post, id);
                showResult(title, alertMessage);
            }
        }

        private void showResult(String title, String alertMessage) {
            new AlertDialog.Builder(HelloFacebookSampleActivity.this)
                    .setTitle(title)
                    .setMessage(alertMessage)
                    .setPositiveButton(R.string.ok, null)
                    .show();
        }
    };

    private enum PendingAction {
        NONE,
        POST_PHOTO,
        POST_STATUS_UPDATE
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        FacebookSdk.sdkInitialize(this.getApplicationContext());

        callbackManager = CallbackManager.Factory.create();

        LoginManager.getInstance().registerCallback(callbackManager,
                new FacebookCallback<LoginResult>() {
                    @Override
                    public void onSuccess(LoginResult loginResult) {
                        handlePendingAction();
                        updateUI();
                    }

                    @Override
                    public void onCancel() {
                        if (pendingAction != PendingAction.NONE) {
                            showAlert();
                            pendingAction = PendingAction.NONE;
                        }
                        updateUI();
                    }

                    @Override
                    public void onError(FacebookException exception) {
                        if (pendingAction != PendingAction.NONE
                                && exception instanceof FacebookAuthorizationException) {
                            showAlert();
                            pendingAction = PendingAction.NONE;
                        }
                        updateUI();
                    }

                    private void showAlert() {
                        new AlertDialog.Builder(HelloFacebookSampleActivity.this)
                                .setTitle(R.string.cancelled)
                                .setMessage(R.string.permission_not_granted)
                                .setPositiveButton(R.string.ok, null)
                                .show();
                    }
                });

        shareDialog = new ShareDialog(this);
        shareDialog.registerCallback(
                callbackManager,
                shareCallback);

        if (savedInstanceState != null) {
            String name = savedInstanceState.getString(PENDING_ACTION_BUNDLE_KEY);
            pendingAction = PendingAction.valueOf(name);
        }

        setContentView(R.layout.main);

        profileTracker = new ProfileTracker() {
            @Override
            protected void onCurrentProfileChanged(Profile oldProfile, Profile currentProfile) {
                updateUI();
                
                
                handlePendingAction();
            }
        };

        profilePictureView = (ProfilePictureView) findViewById(R.id.profilePicture);
        greeting = (TextView) findViewById(R.id.greeting);

        postStatusUpdateButton = (Button) findViewById(R.id.postStatusUpdateButton);
        postStatusUpdateButton.setOnClickListener(new View.OnClickListener() {
            public void onClick(View view) {
                onClickPostStatusUpdate();
            }
        });

        postPhotoButton = (Button) findViewById(R.id.postPhotoButton);
        postPhotoButton.setOnClickListener(new View.OnClickListener() {
            public void onClick(View view) {
                onClickPostPhoto();
            }
        });

        
        canPresentShareDialog = ShareDialog.canShow(
                ShareLinkContent.class);

        
        canPresentShareDialogWithPhotos = ShareDialog.canShow(
                SharePhotoContent.class);
    }

    @Override
    protected void onResume() {
        super.onResume();

        
        
        
        AppEventsLogger.activateApp(this);

        updateUI();
    }

    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);

        outState.putString(PENDING_ACTION_BUNDLE_KEY, pendingAction.name());
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        callbackManager.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    public void onPause() {
        super.onPause();

        
        
        
        AppEventsLogger.deactivateApp(this);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        profileTracker.stopTracking();
    }

    private void updateUI() {
        boolean enableButtons = AccessToken.getCurrentAccessToken() != null;

        postStatusUpdateButton.setEnabled(enableButtons || canPresentShareDialog);
        postPhotoButton.setEnabled(enableButtons || canPresentShareDialogWithPhotos);

        Profile profile = Profile.getCurrentProfile();
        if (enableButtons && profile != null) {
            profilePictureView.setProfileId(profile.getId());
            greeting.setText(getString(R.string.hello_user, profile.getFirstName()));
        } else {
            profilePictureView.setProfileId(null);
            greeting.setText(null);
        }
    }

    private void handlePendingAction() {
        PendingAction previouslyPendingAction = pendingAction;
        
        
        pendingAction = PendingAction.NONE;

        switch (previouslyPendingAction) {
            case NONE:
                break;
            case POST_PHOTO:
                postPhoto();
                break;
            case POST_STATUS_UPDATE:
                postStatusUpdate();
                break;
        }
    }

    private void onClickPostStatusUpdate() {
        performPublish(PendingAction.POST_STATUS_UPDATE, canPresentShareDialog);
    }

    private void postStatusUpdate() {
        Profile profile = Profile.getCurrentProfile();
        ShareLinkContent linkContent = new ShareLinkContent.Builder()
                .setContentTitle("Hello Facebook")
                .setContentDescription(
                        "The 'Hello Facebook' sample  showcases simple Facebook integration")
                .setContentUrl(Uri.parse("http:
                .build();
        if (canPresentShareDialog) {
            shareDialog.show(linkContent);
        } else if (profile != null && hasPublishPermission()) {
            ShareApi.share(linkContent, shareCallback);
        } else {
            pendingAction = PendingAction.POST_STATUS_UPDATE;
        }
    }

    private void onClickPostPhoto() {
        performPublish(PendingAction.POST_PHOTO, canPresentShareDialogWithPhotos);
    }

    private void postPhoto() {
        Bitmap image = BitmapFactory.decodeResource(this.getResources(), R.drawable.icon);
        SharePhoto sharePhoto = new SharePhoto.Builder().setBitmap(image).build();
        ArrayList<SharePhoto> photos = new ArrayList<>();
        photos.add(sharePhoto);

        SharePhotoContent sharePhotoContent =
                new SharePhotoContent.Builder().setPhotos(photos).build();
        if (canPresentShareDialogWithPhotos) {
            shareDialog.show(sharePhotoContent);
        } else if (hasPublishPermission()) {
            ShareApi.share(sharePhotoContent, shareCallback);
        } else {
            pendingAction = PendingAction.POST_PHOTO;
        }
    }

    private boolean hasPublishPermission() {
        AccessToken accessToken = AccessToken.getCurrentAccessToken();
        return accessToken != null && accessToken.getPermissions().contains("publish_actions");
    }

    private void performPublish(PendingAction action, boolean allowNoToken) {
        AccessToken accessToken = AccessToken.getCurrentAccessToken();
        if (accessToken != null) {
            pendingAction = action;
            if (hasPublishPermission()) {
                
                handlePendingAction();
                return;
            } else {
                
                LoginManager.getInstance().logInWithPublishPermissions(
                        this,
                        Arrays.asList(PERMISSION));
                return;
            }
        }

        if (allowNoToken) {
            pendingAction = action;
            handlePendingAction();
        }
    }
}

<code block>


package com.facebook.samples.switchuser;

import android.os.Parcel;
import android.os.Parcelable;

import com.facebook.AccessToken;

class UserInfo implements Parcelable {
    private String userName;
    private AccessToken accessToken;

    public UserInfo(String userName, AccessToken accessToken) {
        this.userName = userName;
        this.accessToken = accessToken;
    }

    public String getUserName() {
        return userName;
    }

    public AccessToken getAccessToken() {
        return accessToken;
    }

    UserInfo(Parcel parcel) {
        this.userName = parcel.readString();
        this.accessToken = parcel.readParcelable(UserInfo.class.getClassLoader());
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeString(userName);
        dest.writeParcelable(accessToken, 0);
    }

    public static final Parcelable.Creator<UserInfo> CREATOR = new Parcelable.Creator() {

        @Override
        public UserInfo createFromParcel(Parcel source) {
            return new UserInfo(source);
        }

        @Override
        public UserInfo[] newArray(int size) {
            return new UserInfo[size];
        }
    };
}

<code block>


package com.facebook.samples.switchuser;

import android.content.Intent;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.view.*;
import android.widget.TextView;

import com.facebook.AccessToken;
import com.facebook.AccessTokenTracker;
import com.facebook.CallbackManager;
import com.facebook.Profile;
import com.facebook.ProfileTracker;
import com.facebook.login.widget.ProfilePictureView;

public class ProfileFragment extends Fragment {

    public static final String TAG = "ProfileFragment";

    private TextView userNameView;
    private ProfilePictureView profilePictureView;
    private OnOptionsItemSelectedListener onOptionsItemSelectedListener;

    private Profile pendingUpdateForUser;
    private CallbackManager callbackManager;
    private ProfileTracker profileTracker;
    private AccessTokenTracker accessTokenTracker;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setHasOptionsMenu(true);
        callbackManager = CallbackManager.Factory.create();
        profileTracker = new ProfileTracker() {
            @Override
            protected void onCurrentProfileChanged(Profile oldProfile, Profile currentProfile) {
                setProfile(currentProfile);
            }
        };

        accessTokenTracker = new AccessTokenTracker() {
            @Override
            protected void onCurrentAccessTokenChanged(
                    AccessToken oldAccessToken,
                    AccessToken currentAccessToken) {
                
                
                Profile.fetchProfileForCurrentAccessToken();
            }
        };

        
        Profile.fetchProfileForCurrentAccessToken();
        setProfile(Profile.getCurrentProfile());
    }

    @Override
    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
        super.onCreateOptionsMenu(menu, inflater);
        inflater.inflate(R.menu.options_profile, menu);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        boolean handled = false;
        OnOptionsItemSelectedListener listener = onOptionsItemSelectedListener;
        if (listener != null) {
            handled = listener.onOptionsItemSelected(item);
        }

        if (!handled) {
            handled = super.onOptionsItemSelected(item);
        }

        return handled;
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup parent, Bundle savedInstanceState) {
        View v = inflater.inflate(R.layout.fragment_profile, parent, false);

        userNameView = (TextView) v.findViewById(R.id.profileUserName);
        profilePictureView = (ProfilePictureView) v.findViewById(R.id.profilePic);

        if (pendingUpdateForUser != null) {
            setProfile(pendingUpdateForUser);
            pendingUpdateForUser = null;
        }

        return v;
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        callbackManager.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        profileTracker.stopTracking();
        accessTokenTracker.startTracking();
    }

    public void setOnOptionsItemSelectedListener(OnOptionsItemSelectedListener listener) {
        this.onOptionsItemSelectedListener = listener;
    }

    private void setProfile(Profile profile) {
        if (userNameView == null || profilePictureView == null || !isAdded()) {
            
            
            pendingUpdateForUser = profile;
            return;
        }

        if (profile == null) {
            profilePictureView.setProfileId(null);
            userNameView.setText(R.string.greeting_no_user);
        } else {
            profilePictureView.setProfileId(profile.getId());
            userNameView.setText(String.format(getString(R.string.greeting_format),
                    profile.getName()));
        }
    }

    public interface OnOptionsItemSelectedListener {
        boolean onOptionsItemSelected(MenuItem item);
    }
}

<code block>


package com.facebook.samples.switchuser;

import com.facebook.AccessToken;
import com.facebook.login.LoginBehavior;

public class Slot {
    private UserInfo userInfo;
    private final UserInfoCache userInfoCache;
    private LoginBehavior loginBehavior;

    public Slot(int slotNumber, LoginBehavior loginBehavior) {
        this.loginBehavior = loginBehavior;
        this.userInfoCache = new UserInfoCache(slotNumber);
        this.userInfo = userInfoCache.get();
    }

    public LoginBehavior getLoginBehavior() {
        return loginBehavior;
    }

    public String getUserName() {
        return (userInfo != null) ? userInfo.getUserName() : null;
    }

    public AccessToken getAccessToken() {
        return (userInfo != null) ? userInfo.getAccessToken() : null;
    }

    public String getUserId() {
        return (userInfo != null) ? userInfo.getAccessToken().getUserId() : null;
    }

    public UserInfo getUserInfo() {
        return userInfo;
    }

    public void setUserInfo(UserInfo user) {
        userInfo = user;
        if (user == null) {
            return;
        }

        userInfoCache.put(user);
    }

    public void clear() {
        userInfo = null;
        userInfoCache.clear();
    }
}

<code block>


package com.facebook.samples.switchuser;

import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.graphics.Color;
import android.os.Bundle;
import android.support.v4.app.ListFragment;
import android.view.*;
import android.widget.*;

import com.facebook.AccessToken;
import com.facebook.CallbackManager;
import com.facebook.FacebookCallback;
import com.facebook.FacebookException;
import com.facebook.FacebookSdk;
import com.facebook.Profile;
import com.facebook.ProfileTracker;
import com.facebook.login.LoginBehavior;
import com.facebook.login.LoginManager;
import com.facebook.login.LoginResult;
import com.facebook.login.widget.ProfilePictureView;

import java.util.ArrayList;
import java.util.Arrays;

public class SettingsFragment extends ListFragment {

    public static final String TAG = "SettingsFragment";
    private static final String CURRENT_SLOT_KEY = "CurrentSlot";

    private SlotManager slotManager;
    private Menu optionsMenu;
    private CallbackManager callbackManager;
    private ProfileTracker profileTracker;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        slotManager = new SlotManager();
        slotManager.restore(
                getActivity(),
                savedInstanceState != null ?
                        savedInstanceState.getInt(CURRENT_SLOT_KEY, SlotManager.NO_SLOT) :
                        SlotManager.NO_SLOT);
        ArrayList<Slot> slotList = new ArrayList<Slot>(
                Arrays.asList(slotManager.getAllSlots()));

        Slot currentSlot = slotManager.getSelectedSlot();
        if (currentSlot != null && currentSlot.getAccessToken() != null) {
            AccessToken.setCurrentAccessToken(currentSlot.getAccessToken());
        }

        setListAdapter(new SlotAdapter(slotList));
        setHasOptionsMenu(true);
        setUpCallbacks();
        currentUserChanged();
    }

    @Override
    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
        super.onCreateOptionsMenu(menu, inflater);
        inflater.inflate(R.menu.context_settings, menu);
        optionsMenu = menu;
        updateMenuVisibility();
    }

    private void setUpCallbacks() {
        callbackManager = CallbackManager.Factory.create();
        LoginManager manager = LoginManager.getInstance();
        manager.registerCallback(callbackManager, new FacebookCallback<LoginResult>() {
            @Override
            public void onSuccess(LoginResult loginResult) {
                Profile.fetchProfileForCurrentAccessToken();
            }

            @Override
            public void onError(FacebookException exception) {
                AccessToken.setCurrentAccessToken(null);
                currentUserChanged();
            }

            @Override
            public void onCancel() {
                AccessToken.setCurrentAccessToken(null);
                currentUserChanged();
            }
        });

        profileTracker = new ProfileTracker() {
            @Override
            protected void onCurrentProfileChanged(Profile oldProfile, Profile currentProfile) {
                Slot currentSlot = slotManager.getSelectedSlot();
                AccessToken currentAccessToken = AccessToken.getCurrentAccessToken();
                if(currentSlot != null && currentAccessToken != null && currentProfile != null) {
                    currentSlot.setUserInfo(
                            new UserInfo(currentProfile.getName(), currentAccessToken));
                    currentUserChanged();
                }
            }
        };
    }

    @Override
    public void onListItemClick(ListView l, View view, int position, long id) {
        slotManager.setCurrentUserSlot(position);
        Slot newSlot = slotManager.getSelectedSlot();
        if (newSlot.getAccessToken() == null) {
            final LoginManager manager = LoginManager.getInstance();
            manager.setLoginBehavior(newSlot.getLoginBehavior());
            manager.logInWithReadPermissions(this, null);
        } else {
            AccessToken.setCurrentAccessToken(newSlot.getAccessToken());
        }
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        Slot slot = slotManager.getSelectedSlot();

        switch (item.getItemId()) {
            case R.id.menu_item_clear_slot:
                if (slot.getUserId() != null) {
                    
                    
                    
                    slot.clear();
                    if (slot == slotManager.getSelectedSlot()) {
                        slotManager.setCurrentUserSlot(SlotManager.NO_SLOT);
                    }

                    currentUserChanged();
                }
                return true;
        }

        return super.onContextItemSelected(item);
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        outState.putInt(CURRENT_SLOT_KEY, slotManager.getSelectedSlotNumber());
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        callbackManager.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        profileTracker.stopTracking();
    }

    private void updateMenuVisibility() {
        if (optionsMenu != null) {
            if (slotManager.getSelectedSlot() == null) {
                optionsMenu.setGroupVisible(0, false);
            } else if (optionsMenu != null) {
                optionsMenu.setGroupVisible(0, true);
            }
        }
    }

    private void currentUserChanged() {
        if (slotManager == null) {
            
            return;
        }

        updateMenuVisibility();
        updateListView();
        Slot currentSlot = slotManager.getSelectedSlot();
        AccessToken currentToken = (currentSlot != null) ? currentSlot.getAccessToken() : null;
        AccessToken.setCurrentAccessToken(currentToken);
    }

    private void updateListView() {
        SlotAdapter adapter = (SlotAdapter) getListAdapter();

        
        if (adapter != null) {
            adapter.notifyDataSetChanged();
        }
    }

    private class SlotManager {
        static final int NO_SLOT = -1;

        private final static int MAX_SLOTS = 4;

        private static final String SETTINGS_CURRENT_SLOT_KEY = "CurrentSlot";
        private static final String SETTINGS_NAME = "UserManagerSettings";

        private SharedPreferences settings;
        private int selectedSlotNumber = NO_SLOT;

        private Slot[] slots;

        public void restore(Context context, int oldSelectedSlot) {
            if (context == null) {
                throw new IllegalArgumentException("context cannot be null");
            }

            slots = new Slot[MAX_SLOTS];
            for (int i = 0; i < MAX_SLOTS; i++) {
                LoginBehavior loginBehavior = (i == 0) ?
                        LoginBehavior.SSO_WITH_FALLBACK :
                        LoginBehavior.SUPPRESS_SSO;
                slots[i] = new Slot(i, loginBehavior);
            }

            
            settings = FacebookSdk.getApplicationContext().getSharedPreferences(
                    SETTINGS_NAME, Context.MODE_PRIVATE);
            int savedSlotNumber = settings.getInt(SETTINGS_CURRENT_SLOT_KEY, NO_SLOT);
            if (savedSlotNumber != NO_SLOT && savedSlotNumber != oldSelectedSlot) {
                
                setCurrentUserSlot(savedSlotNumber);
            } else {
                
                
                
                setCurrentUserSlot(savedSlotNumber);
            }
        }

        public Slot getSelectedSlot() {
            if (selectedSlotNumber == NO_SLOT) {
                return null;
            } else {
                return getSlot(selectedSlotNumber);
            }
        }

        public int getSelectedSlotNumber() {
            return selectedSlotNumber;
        }

        public void setCurrentUserSlot(int slot) {
            if (slot != selectedSlotNumber) {
                
                settings.edit().putInt(SETTINGS_CURRENT_SLOT_KEY, slot).apply();
                selectedSlotNumber = slot;
                currentUserChanged();
            }
        }

        private Slot[] getAllSlots() {
            return slots;
        }

        private Slot getSlot(int slot) {
            validateSlot(slot);
            return slots[slot];
        }

        private void validateSlot(int slot) {
            if (slot <= NO_SLOT || slot >= MAX_SLOTS) {
                throw new IllegalArgumentException(
                        String.format("Choose a slot between 0 and %d inclusively", MAX_SLOTS - 1));
            }
        }
    }

    private class SlotAdapter extends ArrayAdapter<Slot> {

        public SlotAdapter(ArrayList<Slot> slots) {
            super(getActivity(), android.R.layout.simple_list_item_1, slots);
        }

        @Override
        public View getView(final int position, View convertView, ViewGroup parent) {
            if (null == convertView) {
                convertView = getActivity().getLayoutInflater()
                        .inflate(R.layout.list_item_user, parent, false);
            }

            Slot slot = getItem(position);
            if (slot.getLoginBehavior() != LoginBehavior.SUPPRESS_SSO) {
                convertView.setBackgroundColor(Color.argb(50, 255, 255, 255));
            }

            String userName = slot.getUserName();
            if (userName == null) {
                userName = getString(R.string.empty_slot);
            }

            String userId = slot.getUserId();
            ProfilePictureView profilePic = (ProfilePictureView) convertView.findViewById(
                    R.id.slotPic);
            if (userId != null) {
                profilePic.setProfileId(userId);
            } else {
                profilePic.setProfileId(null);
            }

            TextView userNameTextView = (TextView) convertView.findViewById(
                    R.id.slotUserName);
            userNameTextView.setText(userName);

            final CheckBox currentUserCheckBox = (CheckBox) convertView.findViewById(
                    R.id.currentUserIndicator);
            currentUserCheckBox.setChecked(
                    slotManager.getSelectedSlot() == slot
                            && slot.getUserInfo() != null);
            currentUserCheckBox.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    if (currentUserCheckBox.isChecked()) {
                        slotManager.setCurrentUserSlot(position);
                    } else {
                        slotManager.setCurrentUserSlot(SlotManager.NO_SLOT);
                    }
                    SlotAdapter adapter = (SlotAdapter) getListAdapter();
                    adapter.notifyDataSetChanged();
                }
            });

            currentUserCheckBox.setEnabled(slot.getAccessToken() != null);

            return convertView;
        }

    }
}

<code block>


package com.facebook.samples.switchuser;

import android.os.Bundle;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentTransaction;
import android.support.v7.app.ActionBarActivity;
import android.view.MenuItem;

import com.facebook.*;
import com.facebook.appevents.AppEventsLogger;

public class MainActivity extends ActionBarActivity {

    private static final String SHOWING_SETTINGS_KEY = "Showing settings";

    private ProfileFragment profileFragment;
    private SettingsFragment settingsFragment;
    private boolean isShowingSettings;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        FacebookSdk.sdkInitialize(getApplicationContext());

        setContentView(R.layout.main);

        restoreFragments(savedInstanceState);

        if (savedInstanceState != null) {
            if (savedInstanceState.getBoolean(SHOWING_SETTINGS_KEY)) {
                showSettings();
            } else {
                showProfile();
            }
        } else {
            showProfile();
        }
    }

    @Override
    public void onBackPressed() {
        if (isShowingSettings()) {
            
            showProfile();
        } else {
            
            super.onBackPressed();
        }
    }


    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        outState.putBoolean(SHOWING_SETTINGS_KEY, isShowingSettings());

        FragmentManager manager = getSupportFragmentManager();
        manager.putFragment(outState, SettingsFragment.TAG, settingsFragment);
        manager.putFragment(outState, ProfileFragment.TAG, profileFragment);
    }

    @Override
    protected void onResume() {
        super.onResume();

        profileFragment.setOnOptionsItemSelectedListener(new ProfileFragment.OnOptionsItemSelectedListener() {
            @Override
            public boolean onOptionsItemSelected(MenuItem item) {
                return handleOptionsItemSelected(item);
            }
        });

        
        
        
        AppEventsLogger.activateApp(this);
    }

    @Override
    protected void onPause() {
        super.onPause();

        profileFragment.setOnOptionsItemSelectedListener(null);

        
        
        
        AppEventsLogger.deactivateApp(this);
    }

    private void restoreFragments(Bundle savedInstanceState) {
        FragmentManager manager = getSupportFragmentManager();
        FragmentTransaction transaction = manager.beginTransaction();

        if (savedInstanceState != null) {
            profileFragment = (ProfileFragment) manager.getFragment(savedInstanceState,
                    ProfileFragment.TAG);
            settingsFragment = (SettingsFragment) manager.getFragment(savedInstanceState,
                    SettingsFragment.TAG);
        }

        if (profileFragment == null) {
            profileFragment = new ProfileFragment();
            transaction.add(R.id.fragmentContainer, profileFragment, ProfileFragment.TAG);
        }

        if (settingsFragment == null) {
            settingsFragment = new SettingsFragment();
            transaction.add(R.id.fragmentContainer, settingsFragment, SettingsFragment.TAG);
        }

        transaction.commit();
    }

    private void showSettings() {
        isShowingSettings = true;

        FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
        transaction.hide(profileFragment)
                .show(settingsFragment)
                .commit();
    }

    private boolean isShowingSettings() {
        return isShowingSettings;
    }

    private void showProfile() {
        isShowingSettings = false;

        FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
        transaction.hide(settingsFragment)
                .show(profileFragment)
                .commit();
    }

    private boolean handleOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.menu_item_switch:
                showSettings();
                return true;
            default:
                return false;
        }
    }
}

<code block>


package com.facebook.samples.switchuser;

import android.content.Context;
import android.content.SharedPreferences;
import android.os.Parcel;
import android.util.Base64;

import com.facebook.FacebookSdk;

class UserInfoCache {
    private static final String USER_INFO_CACHE_FORMAT = "userInfo%d";
    private final String userInfoCacheKey;
    private final int slot;

    public UserInfoCache(int slotNumber) {
        userInfoCacheKey = String.format(USER_INFO_CACHE_FORMAT, slotNumber);
        slot = slotNumber;
    }
    public UserInfo get() {
        SharedPreferences prefs = getSharedPrefs();
        String encodedToken = prefs.getString(userInfoCacheKey, null);
        if(encodedToken == null) {
            return null;
        }
        return decodeUserInfo(encodedToken);
    }

    public void put(UserInfo userInfo) {
        SharedPreferences.Editor editor = getSharedPrefs().edit();
        String encodedToken = encodeUserInfo(userInfo);
        editor.putString(userInfoCacheKey, encodedToken);
        editor.apply();
    }

    public void clear() {
        SharedPreferences.Editor editor = getSharedPrefs().edit();
        editor.remove(userInfoCacheKey);
        editor.apply();
    }

    private static SharedPreferences getSharedPrefs() {
        return FacebookSdk.getApplicationContext().getSharedPreferences(
                "accessTokens",
                Context.MODE_PRIVATE);
    }

    private static UserInfo decodeUserInfo(String base64EncodedToken) {
        byte[] data = Base64.decode(base64EncodedToken, Base64.DEFAULT);
        Parcel parcel = Parcel.obtain();
        parcel.unmarshall(data, 0, data.length);
        parcel.setDataPosition(0);
        UserInfo userInfo = (UserInfo) parcel.readValue(UserInfo.class.getClassLoader());
        parcel.recycle();
        return userInfo;
    }

    private static String encodeUserInfo(UserInfo userInfo) {
        Parcel parcel = Parcel.obtain();
        parcel.writeValue(userInfo);
        byte[] data = parcel.marshall();
        parcel.recycle();
        return Base64.encodeToString(data, Base64.DEFAULT);
    }
}

<code block>


package com.facebook.scrumptious;

import android.content.Intent;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;
import android.widget.Toast;

import com.facebook.CallbackManager;
import com.facebook.FacebookCallback;
import com.facebook.FacebookException;
import com.facebook.login.LoginResult;
import com.facebook.login.widget.LoginButton;

public class SplashFragment extends Fragment {

    private LoginButton loginButton;
    private TextView skipLoginButton;
    private SkipLoginCallback skipLoginCallback;
    private CallbackManager callbackManager;

    public interface SkipLoginCallback {
        void onSkipLoginPressed();
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.splash, container, false);

        callbackManager = CallbackManager.Factory.create();
        loginButton = (LoginButton) view.findViewById(R.id.login_button);
        loginButton.setReadPermissions("user_friends");
        loginButton.setFragment(this);
        loginButton.registerCallback(callbackManager, new FacebookCallback<LoginResult>() {
            @Override
            public void onSuccess(LoginResult loginResult) {
                Toast.makeText(getActivity(), "Login successful", Toast.LENGTH_SHORT).show();
            }

            @Override
            public void onCancel() {
                Toast.makeText(getActivity(), "Login canceled", Toast.LENGTH_SHORT).show();
            }

            @Override
            public void onError(FacebookException exception) {
                Toast.makeText(getActivity(), "Login error", Toast.LENGTH_SHORT).show();
            }
        });

        skipLoginButton = (TextView) view.findViewById(R.id.skip_login_button);
        skipLoginButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                if (skipLoginCallback != null) {
                    skipLoginCallback.onSkipLoginPressed();
                }
            }
        });

        return view;
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        callbackManager.onActivityResult(requestCode, resultCode, data);
    }

    public void setSkipLoginCallback(SkipLoginCallback callback) {
        skipLoginCallback = callback;
    }

}


<code block>


package com.facebook.scrumptious;

import android.app.Application;

import com.facebook.FacebookSdk;

import org.json.JSONObject;

import java.util.List;


public class ScrumptiousApplication extends Application {

    @Override
    public void onCreate() {
        super.onCreate();
        FacebookSdk.sdkInitialize(getApplicationContext());
    }

    private List<JSONObject> selectedUsers;
    private JSONObject selectedPlace;

    public List<JSONObject> getSelectedUsers() {
        return selectedUsers;
    }

    public void setSelectedUsers(List<JSONObject> users) {
        selectedUsers = users;
    }

    public JSONObject getSelectedPlace() {
        return selectedPlace;
    }

    public void setSelectedPlace(JSONObject place) {
        this.selectedPlace = place;
    }
}

<code block>


package com.facebook.scrumptious;

import android.content.Context;
import android.util.AttributeSet;
import android.view.View;
import android.widget.ListAdapter;
import android.widget.ListView;


public class FullListView extends ListView {

    public FullListView(Context context) {
        super(context);
    }

    public FullListView(Context context, AttributeSet attributeSet) {
        super(context, attributeSet);
    }

    public FullListView(Context context, AttributeSet attributeSet, int defStyle) {
        super(context, attributeSet, defStyle);
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        int width = getMeasuredWidth();
        int height = 0;
        ListAdapter adapter = getAdapter();
        int count = adapter != null ? adapter.getCount() : 0;
        for (int i = 0; i < count; i++) {
            View childView = adapter.getView(i, null, this);
            childView.measure(MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED),
                    MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED));
            height += childView.getMeasuredHeight();
        }
        height += getDividerHeight() * (count-1);
        setMeasuredDimension(width, height);
    }
}

<code block>


package com.facebook.scrumptious;

import android.content.Intent;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.view.View;
import android.widget.BaseAdapter;

import com.facebook.share.model.ShareOpenGraphAction;

import org.json.JSONObject;


public abstract class BaseListElement {

    private Drawable icon;
    private String text1;
    private String text2;
    private BaseAdapter adapter;
    private int requestCode;

    
    public BaseListElement(Drawable icon, String text1, String text2, int requestCode) {
        this.icon = icon;
        this.text1 = text1;
        this.text2 = text2;
        this.requestCode = requestCode;
    }

    
    public void setAdapter(BaseAdapter adapter) {
        this.adapter = adapter;
    }

    
    public Drawable getIcon() {
        return icon;
    }

    
    public String getText1() {
        return text1;
    }

    
    public String getText2() {
        return text2;
    }

    
    public int getRequestCode() {
        return requestCode;
    }

    
    public void setText1(String text1) {
        this.text1 = text1;
        if (adapter != null) {
            adapter.notifyDataSetChanged();
        }
    }

    
    public void setText2(String text2) {
        this.text2 = text2;
        if (adapter != null) {
            adapter.notifyDataSetChanged();
        }
    }

    
    protected abstract View.OnClickListener getOnClickListener();

    
    protected abstract void populateOpenGraphAction(ShareOpenGraphAction.Builder actionBuilder);

    
    protected void onActivityResult(Intent data) {}

    
    protected void onSaveInstanceState(Bundle bundle) {}

    
    protected boolean restoreState(Bundle savedState) {
        return false;
    }

    
    protected void notifyDataChanged() {
        adapter.notifyDataSetChanged();
    }

}

<code block>


package com.facebook.scrumptious;

import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.location.Criteria;
import android.location.Location;
import android.location.LocationListener;
import android.location.LocationManager;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.os.Looper;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentActivity;
import android.support.v4.app.FragmentManager;
import android.widget.Toast;
import com.facebook.FacebookException;
import com.facebook.scrumptious.picker.FriendPickerFragment;
import com.facebook.scrumptious.picker.PickerFragment;
import com.facebook.scrumptious.picker.PlacePickerFragment;


public class PickerActivity extends FragmentActivity {
    public static final Uri FRIEND_PICKER = Uri.parse("picker:
    public static final Uri PLACE_PICKER = Uri.parse("picker:

    private static final int SEARCH_RADIUS_METERS = 1000;
    private static final int SEARCH_RESULT_LIMIT = 50;
    private static final String SEARCH_TEXT = "Restaurant";
    private static final int LOCATION_CHANGE_THRESHOLD = 50; 

    private FriendPickerFragment friendPickerFragment;
    private PlacePickerFragment placePickerFragment;
    private LocationListener locationListener;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pickers);

        Bundle args = getIntent().getExtras();
        FragmentManager manager = getSupportFragmentManager();
        Fragment fragmentToShow = null;
        Uri intentUri = getIntent().getData();

        if (FRIEND_PICKER.equals(intentUri)) {
            if (savedInstanceState == null) {
                friendPickerFragment = new FriendPickerFragment();
                friendPickerFragment.setSettingsFromBundle(args);
                friendPickerFragment.setFriendPickerType(FriendPickerFragment.FriendPickerType.TAGGABLE_FRIENDS);
            } else {
                friendPickerFragment = (FriendPickerFragment) manager.findFragmentById(R.id.picker_fragment);;
            }

            friendPickerFragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
                @Override
                public void onError(PickerFragment fragment, FacebookException error) {
                    PickerActivity.this.onError(error);
                }
            });
            friendPickerFragment.setOnDoneButtonClickedListener(new PickerFragment.OnDoneButtonClickedListener() {
                @Override
                public void onDoneButtonClicked(PickerFragment fragment) {
                    finishActivity();
                }
            });
            fragmentToShow = friendPickerFragment;

        } else if (PLACE_PICKER.equals(intentUri)) {
            if (savedInstanceState == null) {
                placePickerFragment = new PlacePickerFragment();
                placePickerFragment.setSettingsFromBundle(args);
            } else {
                placePickerFragment = (PlacePickerFragment) manager.findFragmentById(R.id.picker_fragment);
            }
            placePickerFragment.setOnSelectionChangedListener(new PickerFragment.OnSelectionChangedListener() {
                @Override
                public void onSelectionChanged(PickerFragment fragment) {
                    finishActivity(); 
                }
            });
            placePickerFragment.setOnErrorListener(new PickerFragment.OnErrorListener() {
                @Override
                public void onError(PickerFragment fragment, FacebookException error) {
                    PickerActivity.this.onError(error);
                }
            });
            placePickerFragment.setOnDoneButtonClickedListener(new PickerFragment.OnDoneButtonClickedListener() {
                @Override
                public void onDoneButtonClicked(PickerFragment fragment) {
                    finishActivity();
                }
            });
            fragmentToShow = placePickerFragment;
        } else {
            
            setResult(RESULT_CANCELED);
            finish();
            return;
        }

        manager.beginTransaction().replace(R.id.picker_fragment, fragmentToShow).commit();
    }

    @Override
    protected void onStart() {
        super.onStart();
        if (FRIEND_PICKER.equals(getIntent().getData())) {
            try {
                friendPickerFragment.loadData(false);
            } catch (Exception ex) {
                onError(ex);
            }
        } else if (PLACE_PICKER.equals(getIntent().getData())) {
            try {
                Location location = null;
                Criteria criteria = new Criteria();
                LocationManager locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);
                String bestProvider = locationManager.getBestProvider(criteria, false);
                if (bestProvider != null) {
                    location = locationManager.getLastKnownLocation(bestProvider);
                    if (locationManager.isProviderEnabled(bestProvider) && locationListener == null) {
                        locationListener = new LocationListener() {
                            @Override
                            public void onLocationChanged(Location location) {
                                boolean updateLocation = true;
                                Location prevLocation = placePickerFragment.getLocation();
                                if (prevLocation != null) {
                                    updateLocation = location.distanceTo(prevLocation) >= LOCATION_CHANGE_THRESHOLD;
                                }
                                if (updateLocation) {
                                    placePickerFragment.setLocation(location);
                                    placePickerFragment.loadData(true);
                                }
                            }
                            @Override
                            public void onStatusChanged(String s, int i, Bundle bundle) {
                            }
                            @Override
                            public void onProviderEnabled(String s) {
                            }
                            @Override
                            public void onProviderDisabled(String s) {
                            }
                        };
                        locationManager.requestLocationUpdates(bestProvider, 1, LOCATION_CHANGE_THRESHOLD,
                                locationListener, Looper.getMainLooper());
                    }
                }
                if (location != null) {
                    placePickerFragment.setLocation(location);
                    placePickerFragment.setRadiusInMeters(SEARCH_RADIUS_METERS);
                    placePickerFragment.setSearchText(SEARCH_TEXT);
                    placePickerFragment.setResultsLimit(SEARCH_RESULT_LIMIT);
                    placePickerFragment.loadData(false);
                }
            } catch (Exception ex) {
                onError(ex);
            }
        }
    }

    @Override
    protected void onStop() {
        super.onStop();
        if (locationListener != null) {
            LocationManager locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);
            locationManager.removeUpdates(locationListener);
            locationListener = null;
        }
    }

    private void onError(Exception error) {
        String text = getString(R.string.exception, error.getMessage());
        Toast toast = Toast.makeText(this, text, Toast.LENGTH_SHORT);
        toast.show();
    }

    private void onError(String error, final boolean finishActivity) {
        AlertDialog.Builder builder = new AlertDialog.Builder(this);
        builder.setTitle(R.string.error_dialog_title).
                setMessage(error).
                setPositiveButton(R.string.error_dialog_button_text, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialogInterface, int i) {
                        if (finishActivity) {
                            finishActivity();
                        }
                    }
                });
        builder.show();
    }

    private void finishActivity() {
        ScrumptiousApplication app = (ScrumptiousApplication) getApplication();
        if (FRIEND_PICKER.equals(getIntent().getData())) {
            if (friendPickerFragment != null) {
                app.setSelectedUsers(friendPickerFragment.getSelection());
            }
        } else if (PLACE_PICKER.equals(getIntent().getData())) {
            if (placePickerFragment != null) {
                app.setSelectedPlace(placePickerFragment.getSelection());
            }
        }
        setResult(RESULT_OK, null);
        finish();
    }
}

<code block>


package com.facebook.scrumptious;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.database.DataSetObserver;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Matrix;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Environment;
import android.provider.MediaStore;
import android.support.v4.app.Fragment;
import android.util.Log;
import android.util.Pair;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.WindowManager;
import android.widget.*;

import com.facebook.*;
import com.facebook.internal.Utility;
import com.facebook.login.DefaultAudience;
import com.facebook.login.LoginManager;
import com.facebook.share.ShareApi;
import com.facebook.share.Sharer;
import com.facebook.share.model.ShareContent;
import com.facebook.share.model.ShareOpenGraphContent;
import com.facebook.share.model.ShareOpenGraphObject;
import com.facebook.share.model.SharePhoto;
import com.facebook.share.model.ShareOpenGraphAction;
import com.facebook.share.widget.MessageDialog;
import com.facebook.share.widget.SendButton;
import com.facebook.share.widget.ShareButton;
import com.facebook.login.widget.ProfilePictureView;

import org.json.JSONException;
import org.json.JSONObject;

import java.io.*;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.UUID;


public class SelectionFragment extends Fragment {

    private static final String TAG = "SelectionFragment";
    private static final String MEAL_OBJECT_TYPE = "fb_sample_scrumps:meal";
    private static final String EAT_ACTION_TYPE = "fb_sample_scrumps:eat";

    private static final String PENDING_ANNOUNCE_KEY = "pendingAnnounce";
    private static final int USER_GENERATED_MIN_SIZE = 480;
    private static final float MAX_TEXTURE_SIZE = 1024f;

    private static final String PERMISSION = "publish_actions";

    private TextView announceButton;
    private ShareButton shareButton;
    private SendButton messageButton;
    private ListView listView;
    private List<BaseListElement> listElements;
    private ProfilePictureView profilePictureView;
    private boolean pendingAnnounce;
    private MainActivity activity;
    private ProgressDialog announceProgressDialog;

    private Uri photoUri;
    private ImageView photoThumbnail;
    private ScaleAndSetImageTask runningImageTask;

    private CallbackManager callbackManager;
    private AccessTokenTracker accessTokenTracker;
    private FacebookCallback<Sharer.Result> shareCallback =
            new FacebookCallback<Sharer.Result>() {
                @Override
                public void onCancel() {
                    processDialogResults(null, true);
                }

                @Override
                public void onError(FacebookException error) {
                    if (error instanceof FacebookGraphResponseException) {
                        FacebookGraphResponseException graphError =
                                (FacebookGraphResponseException) error;
                        if (graphError.getGraphResponse() != null) {
                            handleError(graphError.getGraphResponse());
                            return;
                        }
                    }
                    processDialogError(error);
                }

                @Override
                public void onSuccess(Sharer.Result result) {
                    processDialogResults(result.getPostId(), false);
                }
            };

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        activity = (MainActivity) getActivity();
        callbackManager = CallbackManager.Factory.create();

        accessTokenTracker = new AccessTokenTracker() {
            @Override
            protected void onCurrentAccessTokenChanged(AccessToken oldAccessToken,
                                                       AccessToken currentAccessToken) {
                updateWithToken(currentAccessToken);
            }
        };
    }

    private void updateWithToken(AccessToken currentAccessToken) {
        if (currentAccessToken != null) {
            tokenUpdated(currentAccessToken);
            profilePictureView.setProfileId(currentAccessToken.getUserId());
            announceButton.setVisibility(View.VISIBLE);
        } else {
            profilePictureView.setProfileId(null);
            announceButton.setVisibility(View.GONE);
        }
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        super.onCreateView(inflater, container, savedInstanceState);
        View view = inflater.inflate(R.layout.selection, container, false);

        profilePictureView = (ProfilePictureView) view.findViewById(R.id.selection_profile_pic);
        profilePictureView.setCropped(true);
        announceButton = (TextView) view.findViewById(R.id.announce_text);
        shareButton = (ShareButton) view.findViewById(R.id.share_button);
        messageButton = (SendButton) view.findViewById(R.id.message_button);
        listView = (ListView) view.findViewById(R.id.selection_list);
        photoThumbnail = (ImageView) view.findViewById(R.id.selected_image);

        announceProgressDialog = new ProgressDialog(getActivity());
        announceProgressDialog.setMessage(getString(R.string.progress_dialog_text));

        if (MessageDialog.canShow(ShareOpenGraphContent.class)) {
            messageButton.setVisibility(View.VISIBLE);
        }

        announceButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                handleAnnounce();
            }
        });

        messageButton.registerCallback(callbackManager, shareCallback);
        messageButton.setFragment(this);
        shareButton.registerCallback(callbackManager, shareCallback);
        shareButton.setFragment(this);

        profilePictureView.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                if (AccessToken.getCurrentAccessToken() != null) {
                    activity.showSettingsFragment();
                } else {
                    activity.showSplashFragment();
                }
            }
        });

        init(savedInstanceState);
        updateWithToken(AccessToken.getCurrentAccessToken());

        return view;
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if (resultCode == Activity.RESULT_OK && requestCode >= 0 && requestCode < listElements.size()) {
            listElements.get(requestCode).onActivityResult(data);
        } else {
            callbackManager.onActivityResult(requestCode, resultCode, data);
        }
    }

    @Override
    public void onSaveInstanceState(Bundle bundle) {
        super.onSaveInstanceState(bundle);
        for (BaseListElement listElement : listElements) {
            listElement.onSaveInstanceState(bundle);
        }
        bundle.putBoolean(PENDING_ANNOUNCE_KEY, pendingAnnounce);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        accessTokenTracker.stopTracking();
        activity = null;
    }

    private void processDialogError(FacebookException error) {
        enableButtons();
        announceProgressDialog.dismiss();

        if (error != null) {
            new AlertDialog.Builder(getActivity())
                    .setPositiveButton(R.string.error_dialog_button_text, null)
                    .setTitle(R.string.error_dialog_title)
                    .setMessage(error.getLocalizedMessage())
                    .show();
        }
    }

    private void processDialogResults(String postId, boolean isCanceled) {
        enableButtons();
        announceProgressDialog.dismiss();

        boolean resetSelections = true;
        if (isCanceled) {
            
            resetSelections = false;
            showCancelResponse();
        } else {
            showSuccessResponse(postId);
        }

        if (resetSelections) {
            init(null);
        }
    }

    private void showRejectedPermissionError() {
        new AlertDialog.Builder(getActivity())
                .setPositiveButton(R.string.error_dialog_button_text, null)
                .setTitle(R.string.error_dialog_title)
                .setMessage(R.string.rejected_publish_permission)
                .show();
    }

    
    private void tokenUpdated(AccessToken currentAccessToken) {
        if (pendingAnnounce) {
            Set<String> permissions = AccessToken.getCurrentAccessToken().getPermissions();
            if (currentAccessToken == null
                    || !currentAccessToken.getPermissions().contains(PERMISSION)) {
                pendingAnnounce = false;
                showRejectedPermissionError();
                return;
            }
            handleAnnounce();
        }
    }

    private void updateShareContent() {
        ShareContent content = createOpenGraphContent();
        if (content != null) {
            enableButtons();
        } else {
            disableButtons();
        }

        shareButton.setShareContent(content);
        messageButton.setShareContent(content);
    }

    private void disableButtons() {
        announceButton.setEnabled(false);
        shareButton.setEnabled(false);
        messageButton.setEnabled(false);
    }

    private void enableButtons() {
        announceButton.setEnabled(true);
        shareButton.setEnabled(true);
        messageButton.setEnabled(true);
    }

    
    private void init(Bundle savedInstanceState) {
        disableButtons();

        listElements = new ArrayList<BaseListElement>();

        listElements.add(new EatListElement(0));
        listElements.add(new LocationListElement(1));
        listElements.add(new PeopleListElement(2));
        listElements.add(new PhotoListElement(3));

        if (savedInstanceState != null) {
            for (BaseListElement listElement : listElements) {
                listElement.restoreState(savedInstanceState);
            }
            pendingAnnounce = savedInstanceState.getBoolean(PENDING_ANNOUNCE_KEY, false);
        }
        ActionListAdapter listAdapter = new ActionListAdapter(
                getActivity(),
                R.id.selection_list,
                listElements);
        listAdapter.registerDataSetObserver(new DataSetObserver() {
            @Override
            public void onChanged() {
                updateShareContent();
            }
        });
        listView.setAdapter(listAdapter);

        AccessToken accessToken = AccessToken.getCurrentAccessToken();
        if (accessToken != null) {
            profilePictureView.setProfileId(accessToken.getUserId());
        }

        updateShareContent();
    }

    private void handleAnnounce() {
        Set<String> permissions = AccessToken.getCurrentAccessToken().getPermissions();
        if (!permissions.contains(PERMISSION)) {
            pendingAnnounce = true;
            requestPublishPermissions();
            return;
        } else {
            pendingAnnounce = false;
        }

        disableButtons();
        announceProgressDialog.show();
        ShareApi.share(createOpenGraphContent(), shareCallback);
    }

    private ShareOpenGraphContent createOpenGraphContent() {
        ShareOpenGraphAction.Builder actionBuilder = createEatActionBuilder();

        boolean userGenerated = false;
        if (photoUri != null) {
            String photoUriString = photoUri.toString();
            Pair<File, Integer> fileAndMinDimension = getImageFileAndMinDimension();
            userGenerated = fileAndMinDimension.second >= USER_GENERATED_MIN_SIZE;

            if (fileAndMinDimension != null) {
                final SharePhoto actionPhoto = new SharePhoto.Builder()
                        .setImageUrl(Uri.parse(photoUriString))
                        .setUserGenerated(userGenerated)
                        .build();
                actionBuilder.putPhotoArrayList("image", new ArrayList<SharePhoto>() {{
                    add(actionPhoto);
                }});
            }
        }

        return new ShareOpenGraphContent.Builder()
                .setAction(actionBuilder.build())
                .setPreviewPropertyName("meal")
                .build();
    }

    private File getTempPhotoStagingDirectory() {
        File photoDir = new File(getActivity().getCacheDir(), "photoFiles");
        photoDir.mkdirs();

        return photoDir;
    }

    private Pair<File, Integer> getImageFileAndMinDimension() {
        File photoFile = null;
        String photoUriString = photoUri.toString();
        if (photoUriString.startsWith("file:
            photoFile = new File(photoUri.getPath());
        } else if (photoUriString.startsWith("content:
            FileOutputStream photoOutputStream = null;
            InputStream contentInputStream = null;
            try {
                Uri photoUri = Uri.parse(photoUriString);
                photoFile = new File(
                        getTempPhotoStagingDirectory(),
                        URLEncoder.encode(UUID.randomUUID().toString(), "UTF-8"));

                photoOutputStream = new FileOutputStream(photoFile);
                contentInputStream = getActivity()
                        .getContentResolver().openInputStream(photoUri);

                byte[] buffer = new byte[1024];
                int len;
                while ((len = contentInputStream.read(buffer)) > 0) {
                    photoOutputStream.write(buffer, 0, len);
                }
            } catch (FileNotFoundException fnfe) {
                Log.e(TAG, "photo not found", fnfe);
            } catch (UnsupportedEncodingException uee) {
                Log.e(TAG, "bad photo name", uee);
            } catch (IOException ioe) {
                Log.e(TAG, "can't copy photo", ioe);
            } finally {
                try {
                    if (photoOutputStream != null) {
                        photoOutputStream.close();
                    }
                    if (contentInputStream != null) {
                        contentInputStream.close();
                    }
                } catch (IOException ioe) {
                    Log.e(TAG, "can't close streams");
                }
            }
        }

        if (photoFile != null) {
            InputStream is = null;
            try {
                is = new FileInputStream(photoFile);

                
                BitmapFactory.Options options = new BitmapFactory.Options();
                options.inJustDecodeBounds = true;
                BitmapFactory.decodeStream(is, null, options);

                return new Pair<>(
                        photoFile, Math.min(options.outWidth, options.outHeight));
            } catch (Exception e) {
                return null;
            } finally {
                Utility.closeQuietly(is);
            }
        }
        return null;
    }

    private ShareOpenGraphAction.Builder createEatActionBuilder() {
        ShareOpenGraphAction.Builder builder = new ShareOpenGraphAction.Builder()
                .setActionType(EAT_ACTION_TYPE);
        for (BaseListElement element : listElements) {
            element.populateOpenGraphAction(builder);
        }

        return builder;
    }

    private void requestPublishPermissions() {
        LoginManager.getInstance()
                .setDefaultAudience(DefaultAudience.FRIENDS)
                .logInWithPublishPermissions(this, Arrays.asList(PERMISSION));
    }

    private void showSuccessResponse(String postId) {
        String dialogBody;
        if (postId != null) {
            dialogBody = String.format(getString(R.string.result_dialog_text_with_id), postId);
        } else {
            dialogBody = getString(R.string.result_dialog_text_default);
        }
        showResultDialog(dialogBody);
    }

    private void showCancelResponse() {
        showResultDialog(getString(R.string.result_dialog_text_canceled));
    }

    private void showResultDialog(String dialogBody) {
        new AlertDialog.Builder(getActivity())
                .setPositiveButton(R.string.result_dialog_button_text, null)
                .setTitle(R.string.result_dialog_title)
                .setMessage(dialogBody)
                .show();
    }

    private void handleError(GraphResponse response) {
        FacebookRequestError error = response.getError();
        DialogInterface.OnClickListener listener = null;
        String dialogBody = null;

        if (error == null) {
            dialogBody = getString(R.string.error_dialog_default_text);
        } else {
            switch (error.getCategory()) {
                case LOGIN_RECOVERABLE:
                    
                    LoginManager.getInstance().resolveError(this, response);
                    return;

                case TRANSIENT:
                    dialogBody = getString(R.string.error_transient);
                    break;

                case OTHER:
                default:
                    
                    
                    
                    dialogBody = getString(R.string.error_unknown, error.getErrorMessage());
                    break;
            }
        }

        String title = error.getErrorUserTitle();
        String message = error.getErrorUserMessage();
        if (message == null) {
            message = dialogBody;
        }
        if (title == null) {
            title = getResources().getString(R.string.error_dialog_title);
        }

        new AlertDialog.Builder(getActivity())
                .setPositiveButton(R.string.error_dialog_button_text, listener)
                .setTitle(title)
                .setMessage(message)
                .show();
    }

    private void startPickerActivity(Uri data, int requestCode) {
        Intent intent = new Intent();
        intent.setData(data);
        intent.setClass(getActivity(), PickerActivity.class);
        startActivityForResult(intent, requestCode);
    }

    private class EatListElement extends BaseListElement {

        private static final String FOOD_KEY = "food";
        private static final String FOOD_URL_KEY = "food_url";

        private final String[] foodChoices;
        private final String[] foodUrls;
        private String foodChoiceUrl = null;
        private String foodChoice = null;

        public EatListElement(int requestCode) {
            super(getActivity().getResources().getDrawable(R.drawable.add_food),
                    getActivity().getResources().getString(R.string.action_eating),
                    null,
                    requestCode);
            foodChoices = getActivity().getResources().getStringArray(R.array.food_types);
            foodUrls = getActivity().getResources().getStringArray(R.array.food_og_urls);
        }

        @Override
        protected View.OnClickListener getOnClickListener() {
            return new View.OnClickListener() {
                @Override
                public void onClick(View view) {
                    showMealOptions();
                }
            };
        }

        @Override
        protected void populateOpenGraphAction(ShareOpenGraphAction.Builder actionBuilder) {
            if (foodChoice != null && foodChoice.length() > 0) {
                if (foodChoiceUrl != null && foodChoiceUrl.length() > 0) {
                    actionBuilder.putString("meal", foodChoiceUrl);
                } else {
                    ShareOpenGraphObject mealObject = new ShareOpenGraphObject.Builder()
                            .putString("og:type", MEAL_OBJECT_TYPE)
                            .putString("og:title", foodChoice)
                            .build();
                    actionBuilder.putObject("meal", mealObject);
                }
            }
        }

        @Override
        protected void onSaveInstanceState(Bundle bundle) {
            if (foodChoice != null && foodChoiceUrl != null) {
                bundle.putString(FOOD_KEY, foodChoice);
                bundle.putString(FOOD_URL_KEY, foodChoiceUrl);
            }
        }

        @Override
        protected boolean restoreState(Bundle savedState) {
            String food = savedState.getString(FOOD_KEY);
            String foodUrl = savedState.getString(FOOD_URL_KEY);
            if (food != null && foodUrl != null) {
                foodChoice = food;
                foodChoiceUrl = foodUrl;
                setFoodText();
                return true;
            }
            return false;
        }

        private void showMealOptions() {
            String title = getActivity().getResources().getString(R.string.select_meal);
            AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
            builder.setTitle(title).
                    setCancelable(true).
                    setItems(foodChoices, new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialogInterface, int i) {
                            foodChoiceUrl = foodUrls[i];
                            if (foodChoiceUrl.length() == 0) {
                                getCustomFood();
                            } else {
                                foodChoice = foodChoices[i];
                                setFoodText();
                                notifyDataChanged();
                            }
                        }
                    });
            builder.show();
        }

        private void getCustomFood() {
            String title = getActivity().getResources().getString(R.string.enter_meal);
            final EditText input = new EditText(getActivity());

            AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
            builder.setTitle(title)
                    .setCancelable(true)
                    .setView(input)
                    .setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialogInterface, int i) {
                            foodChoice = input.getText().toString();
                            setFoodText();
                            notifyDataChanged();
                        }
                    })
                    .setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {
                        @Override
                        public void onClick(DialogInterface dialogInterface, int i) {
                        }
                    });
            AlertDialog dialog = builder.create();
            
            dialog.getWindow().setSoftInputMode(
                    WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);
            dialog.show();
        }

        private void setFoodText() {
            if (foodChoice != null && foodChoice.length() > 0) {
                setText2(foodChoice);
                enableButtons();
            } else {
                setText2(getActivity().getResources().getString(R.string.action_eating_default));
                disableButtons();
            }
        }
    }

    private class PeopleListElement extends BaseListElement {

        private static final String FRIENDS_KEY = "friends";

        private List<JSONObject> selectedUsers;

        public PeopleListElement(int requestCode) {
            super(getActivity().getResources().getDrawable(R.drawable.add_friends),
                    getActivity().getResources().getString(R.string.action_people),
                    null,
                    requestCode);
        }

        @Override
        protected View.OnClickListener getOnClickListener() {
            return new View.OnClickListener() {
                @Override
                public void onClick(View view) {
                    if (AccessToken.getCurrentAccessToken() != null) {
                        startPickerActivity(PickerActivity.FRIEND_PICKER, getRequestCode());
                    } else {
                        activity.showSplashFragment();
                    }
                }
            };
        }

        @Override
        protected void onActivityResult(Intent data) {
            selectedUsers = ((ScrumptiousApplication) getActivity().getApplication())
                    .getSelectedUsers();
            setUsersText();
            notifyDataChanged();
        }

        @Override
        protected void populateOpenGraphAction(ShareOpenGraphAction.Builder actionBuilder) {
            if (selectedUsers != null && !selectedUsers.isEmpty()) {
                ArrayList<String> tags = new ArrayList<>();
                for (JSONObject user : selectedUsers) {
                    tags.add(user.optString("id"));
                }
                actionBuilder.putStringArrayList("tags", tags);
            }
        }

        @Override
        protected void onSaveInstanceState(Bundle bundle) {
            if (selectedUsers != null) {
                bundle.putByteArray(FRIENDS_KEY, getByteArray(selectedUsers));
            }
        }

        @Override
        protected boolean restoreState(Bundle savedState) {
            byte[] bytes = savedState.getByteArray(FRIENDS_KEY);
            if (bytes != null) {
                selectedUsers = restoreByteArray(bytes);
                setUsersText();
                return true;
            }
            return false;
        }

        private void setUsersText() {
            String text = null;
            if (selectedUsers != null) {
                if (selectedUsers.size() == 1) {
                    text = String.format(getResources().getString(R.string.single_user_selected),
                            selectedUsers.get(0).optString("name"));
                } else if (selectedUsers.size() == 2) {
                    text = String.format(getResources().getString(R.string.two_users_selected),
                            selectedUsers.get(0).optString("name"),
                            selectedUsers.get(1).optString("name"));
                } else if (selectedUsers.size() > 2) {
                    text = String.format(getResources().getString(R.string.multiple_users_selected),
                            selectedUsers.get(0).optString("name"), (selectedUsers.size() - 1));
                }
            }
            if (text == null) {
                text = getResources().getString(R.string.action_people_default);
            }
            setText2(text);
        }

        private byte[] getByteArray(List<JSONObject> users) {
            
            
            List<String> usersAsString = new ArrayList<String>(users.size());

            for (JSONObject user : users) {
                usersAsString.add(user.toString());
            }
            try {
                ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
                new ObjectOutputStream(outputStream).writeObject(usersAsString);
                return outputStream.toByteArray();
            } catch (IOException e) {
                Log.e(TAG, "Unable to serialize users.", e);
            }
            return null;
        }

        private List<JSONObject> restoreByteArray(byte[] bytes) {
            try {
                @SuppressWarnings("unchecked")
                List<String> usersAsString =
                        (List<String>) (new ObjectInputStream(
                                new ByteArrayInputStream(bytes))).readObject();
                if (usersAsString != null) {
                    List<JSONObject> users = new ArrayList<JSONObject>(usersAsString.size());
                    for (String user : usersAsString) {
                        users.add(new JSONObject(user));
                    }
                    return users;
                }
            } catch (ClassNotFoundException e) {
                Log.e(TAG, "Unable to deserialize users.", e);
            } catch (IOException e) {
                Log.e(TAG, "Unable to deserialize users.", e);
            } catch (JSONException e) {
                Log.e(TAG, "Unable to deserialize users.", e);
            }
            return null;
        }
    }

    private class LocationListElement extends BaseListElement {
        private static final String PLACE_KEY = "place";

        private JSONObject selectedPlace = null;

        public LocationListElement(int requestCode) {
            super(getActivity().getResources().getDrawable(R.drawable.add_location),
                    getActivity().getResources().getString(R.string.action_location),
                    null,
                    requestCode);
        }

        @Override
        protected View.OnClickListener getOnClickListener() {
            return new View.OnClickListener() {
                @Override
                public void onClick(View view) {
                    if (AccessToken.getCurrentAccessToken() != null) {
                        startPickerActivity(PickerActivity.PLACE_PICKER, getRequestCode());
                    } else {
                        activity.showSplashFragment();
                    }
                }
            };
        }

        @Override
        protected void onActivityResult(Intent data) {
            selectedPlace = ((ScrumptiousApplication) getActivity().getApplication())
                    .getSelectedPlace();
            setPlaceText();
            notifyDataChanged();
        }

        @Override
        protected void populateOpenGraphAction(ShareOpenGraphAction.Builder actionBuilder) {
            if (selectedPlace != null) {
                actionBuilder.putString("place", selectedPlace.optString("id"));
            }
        }

        @Override
        protected void onSaveInstanceState(Bundle bundle) {
            if (selectedPlace != null) {
                bundle.putString(PLACE_KEY, selectedPlace.toString());
            }
        }

        @Override
        protected boolean restoreState(Bundle savedState) {
            String place = savedState.getString(PLACE_KEY);
            if (place != null) {
                try {
                    selectedPlace = new JSONObject(place);
                    setPlaceText();
                    return true;
                } catch (JSONException e) {
                    Log.e(TAG, "Unable to deserialize place.", e);
                }
            }
            return false;
        }

        private void setPlaceText() {
            String text = selectedPlace != null ? selectedPlace.optString("name") : null;
            if (text == null) {
                text = getResources().getString(R.string.action_location_default);
            }
            setText2(text);
        }

    }

    private class PhotoListElement extends BaseListElement {
        private static final int CAMERA = 0;
        private static final int GALLERY = 1;
        private static final String PHOTO_URI_KEY = "photo_uri";
        private static final String TEMP_URI_KEY = "temp_uri";
        private static final String FILE_PREFIX = "scrumptious_img_";
        private static final String FILE_SUFFIX = ".jpg";

        private Uri tempUri = null;

        public PhotoListElement(int requestCode) {
            super(getActivity().getResources().getDrawable(R.drawable.add_photo),
                    getActivity().getResources().getString(R.string.action_photo),
                    null,
                    requestCode);
            photoUri = null;
            photoThumbnail.setImageDrawable(
                    getActivity().getResources().getDrawable(R.drawable.placeholder_image));
            photoThumbnail.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    showPhotoChoice();
                }
            });
        }

        @Override
        protected View.OnClickListener getOnClickListener() {
            return new View.OnClickListener() {
                @Override
                public void onClick(View view) {
                    showPhotoChoice();
                }
            };
        }

        @Override
        protected void onActivityResult(Intent data) {
            if (tempUri != null) {
                photoUri = tempUri;
            } else if (data != null) {
                photoUri = data.getData();
            }
            setPhotoThumbnail();
            setPhotoText();
        }

        @Override
        protected void populateOpenGraphAction(ShareOpenGraphAction.Builder actionBuilder) {
        }

        @Override
        protected void onSaveInstanceState(Bundle bundle) {
            if (photoUri != null) {
                bundle.putParcelable(PHOTO_URI_KEY, photoUri);
            }
            if (tempUri != null) {
                bundle.putParcelable(TEMP_URI_KEY, tempUri);
            }
        }

        @Override
        protected boolean restoreState(Bundle savedState) {
            photoUri = savedState.getParcelable(PHOTO_URI_KEY);
            tempUri = savedState.getParcelable(TEMP_URI_KEY);
            setPhotoText();
            return true;
        }

        private void showPhotoChoice() {
            AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
            CharSequence camera = getResources().getString(R.string.action_photo_camera);
            CharSequence gallery = getResources().getString(R.string.action_photo_gallery);
            builder.setCancelable(true).
                    setItems(new CharSequence[]{camera, gallery},
                            new DialogInterface.OnClickListener() {
                                @Override
                                public void onClick(DialogInterface dialogInterface, int i) {
                                    if (i == CAMERA) {
                                        startCameraActivity();
                                    } else if (i == GALLERY) {
                                        startGalleryActivity();
                                    }
                                }
                            });
            builder.show();
        }

        private void setPhotoText() {
            if (photoUri == null) {
                setText2(getResources().getString(R.string.action_photo_default));
            } else {
                setText2(getResources().getString(R.string.action_photo_ready));
            }
        }

        private void setPhotoThumbnail() {
            
            if (runningImageTask != null &&
                    runningImageTask.getStatus() != AsyncTask.Status.FINISHED) {
                runningImageTask.cancel(true);
            }

            runningImageTask = new ScaleAndSetImageTask(photoUri);
            runningImageTask.execute();
        }

        private void startCameraActivity() {
            Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
            tempUri = getTempUri();
            if (tempUri != null) {
                intent.putExtra(MediaStore.EXTRA_OUTPUT, tempUri);
            }
            startActivityForResult(intent, getRequestCode());
        }

        private void startGalleryActivity() {
            tempUri = null;
            Intent intent = new Intent(Intent.ACTION_GET_CONTENT);
            intent.setType("image/*");
            String selectPicture = getResources().getString(R.string.select_picture);
            startActivityForResult(Intent.createChooser(intent, selectPicture), getRequestCode());
        }

        private Uri getTempUri() {
            String imgFileName = FILE_PREFIX + System.currentTimeMillis() + FILE_SUFFIX;

            
            
            
            
            File image = new File(
                    Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),
                    imgFileName);
            return Uri.fromFile(image);
        }
    }

    private class ActionListAdapter extends ArrayAdapter<BaseListElement> {
        private List<BaseListElement> listElements;

        public ActionListAdapter(
                Context context, int resourceId, List<BaseListElement> listElements) {
            super(context, resourceId, listElements);
            this.listElements = listElements;
            for (int i = 0; i < listElements.size(); i++) {
                listElements.get(i).setAdapter(this);
            }
        }

        @Override
        public View getView(int position, View convertView, ViewGroup parent) {
            View view = convertView;
            if (view == null) {
                LayoutInflater inflater =
                        (LayoutInflater) getActivity().getSystemService(
                                Context.LAYOUT_INFLATER_SERVICE);
                view = inflater.inflate(R.layout.listitem, null);
            }

            BaseListElement listElement = listElements.get(position);
            if (listElement != null) {
                view.setOnClickListener(listElement.getOnClickListener());
                ImageView icon = (ImageView) view.findViewById(R.id.icon);
                TextView text1 = (TextView) view.findViewById(R.id.text1);
                TextView text2 = (TextView) view.findViewById(R.id.text2);
                if (icon != null) {
                    icon.setImageDrawable(listElement.getIcon());
                }
                if (text1 != null) {
                    text1.setText(listElement.getText1());
                }
                if (text2 != null) {
                    if (listElement.getText2() != null) {
                        text2.setVisibility(View.VISIBLE);
                        text2.setText(listElement.getText2());
                    } else {
                        text2.setVisibility(View.GONE);
                    }
                }
            }
            return view;
        }
    }

    private class ScaleAndSetImageTask extends AsyncTask<Void, Void, Bitmap> {
        private final Uri uri;

        public ScaleAndSetImageTask(Uri uri) {
            this.uri = uri;
        }

        @Override
        protected Bitmap doInBackground(Void... params) {
            try {
                Bitmap bitmap = MediaStore.Images.Media.getBitmap(
                        FacebookSdk.getApplicationContext().getContentResolver(), uri);
                if (bitmap.getHeight() > MAX_TEXTURE_SIZE || bitmap.getWidth() > MAX_TEXTURE_SIZE) {
                    
                    float scale = Math.min(
                            MAX_TEXTURE_SIZE / bitmap.getHeight(),
                            MAX_TEXTURE_SIZE / bitmap.getWidth());
                    Matrix matrix = new Matrix();
                    matrix.postScale(scale, scale);
                    bitmap = Bitmap.createBitmap(
                            bitmap,
                            0,
                            0,
                            bitmap.getWidth(),
                            bitmap.getHeight(),
                            matrix,
                            false);
                }
                return bitmap;
            } catch (Exception ex) {
                return null;
            }
        }

        protected void onPostExecute(Bitmap result) {
            if (result != null) {
                photoThumbnail.setImageBitmap(result);
            } else {
                
                photoThumbnail.setImageURI(photoUri);
            }
        }
    }
}

<code block>


package com.facebook.scrumptious;

import android.content.Intent;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentActivity;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentTransaction;

import com.facebook.AccessToken;
import com.facebook.AccessTokenTracker;
import com.facebook.FacebookSdk;
import com.facebook.appevents.AppEventsLogger;
import com.facebook.CallbackManager;

public class MainActivity extends FragmentActivity {

    private static final String USER_SKIPPED_LOGIN_KEY = "user_skipped_login";

    private static final int SPLASH = 0;
    private static final int SELECTION = 1;
    private static final int SETTINGS = 2;
    private static final int FRAGMENT_COUNT = SETTINGS +1;

    private Fragment[] fragments = new Fragment[FRAGMENT_COUNT];
    private boolean isResumed = false;
    private boolean userSkippedLogin = false;
    private AccessTokenTracker accessTokenTracker;
    private CallbackManager callbackManager;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        if (savedInstanceState != null) {
            userSkippedLogin = savedInstanceState.getBoolean(USER_SKIPPED_LOGIN_KEY);
        }
        callbackManager = CallbackManager.Factory.create();

        accessTokenTracker = new AccessTokenTracker() {
            @Override
            protected void onCurrentAccessTokenChanged(AccessToken oldAccessToken,
                                                       AccessToken currentAccessToken) {
                if (isResumed) {
                    FragmentManager manager = getSupportFragmentManager();
                    int backStackSize = manager.getBackStackEntryCount();
                    for (int i = 0; i < backStackSize; i++) {
                        manager.popBackStack();
                    }
                    if (currentAccessToken != null) {
                        showFragment(SELECTION, false);
                    } else {
                        showFragment(SPLASH, false);
                    }
                }
            }
        };

        setContentView(R.layout.main);

        FragmentManager fm = getSupportFragmentManager();
        SplashFragment splashFragment = (SplashFragment) fm.findFragmentById(R.id.splashFragment);
        fragments[SPLASH] = splashFragment;
        fragments[SELECTION] = fm.findFragmentById(R.id.selectionFragment);
        fragments[SETTINGS] = fm.findFragmentById(R.id.userSettingsFragment);

        FragmentTransaction transaction = fm.beginTransaction();
        for(int i = 0; i < fragments.length; i++) {
            transaction.hide(fragments[i]);
        }
        transaction.commit();

        splashFragment.setSkipLoginCallback(new SplashFragment.SkipLoginCallback() {
            @Override
            public void onSkipLoginPressed() {
                userSkippedLogin = true;
                showFragment(SELECTION, false);
            }
        });
    }

    @Override
    public void onResume() {
        super.onResume();
        isResumed = true;

        
        
        
        AppEventsLogger.activateApp(this);
    }

    @Override
    public void onPause() {
        super.onPause();
        isResumed = false;

        
        
        
        AppEventsLogger.deactivateApp(this);
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        callbackManager.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        accessTokenTracker.stopTracking();
    }

    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);

        outState.putBoolean(USER_SKIPPED_LOGIN_KEY, userSkippedLogin);
    }

    @Override
    protected void onResumeFragments() {
        super.onResumeFragments();

        if (AccessToken.getCurrentAccessToken() != null) {
            
            showFragment(SELECTION, false);
            userSkippedLogin = false;
        } else if (userSkippedLogin) {
            showFragment(SELECTION, false);
        } else {
            
            
            showFragment(SPLASH, false);
        }
    }

    public void showSettingsFragment() {
        showFragment(SETTINGS, true);
    }

    public void showSplashFragment() {
        showFragment(SPLASH, true);
    }


    private void showFragment(int fragmentIndex, boolean addToBackStack) {
        FragmentManager fm = getSupportFragmentManager();
        FragmentTransaction transaction = fm.beginTransaction();
        for (int i = 0; i < fragments.length; i++) {
            if (i == fragmentIndex) {
                transaction.show(fragments[i]);
            } else {
                transaction.hide(fragments[i]);
            }
        }
        if (addToBackStack) {
            transaction.addToBackStack(null);
        }
        transaction.commit();
    }
}

<code block>


package com.facebook.scrumptious.picker;

import android.app.Activity;
import android.content.Context;
import android.content.res.TypedArray;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v4.app.LoaderManager;
import android.support.v4.content.Loader;
import android.text.TextUtils;
import android.util.AttributeSet;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewStub;
import android.view.animation.AlphaAnimation;
import android.widget.*;

import com.facebook.AccessToken;
import com.facebook.AccessTokenTracker;
import com.facebook.FacebookException;
import com.facebook.GraphRequest;
import com.facebook.scrumptious.R;

import org.json.JSONObject;

import java.util.*;


public abstract class PickerFragment extends Fragment {
    
    public static final String SHOW_PICTURES_BUNDLE_KEY = "com.facebook.scrumptious.widget.PickerFragment.ShowPictures";
    
    public static final String EXTRA_FIELDS_BUNDLE_KEY = "com.facebook.scrumptious.widget.PickerFragment.ExtraFields";
    
    public static final String SHOW_TITLE_BAR_BUNDLE_KEY = "com.facebook.scrumptious.widget.PickerFragment.ShowTitleBar";
    
    public static final String TITLE_TEXT_BUNDLE_KEY = "com.facebook.scrumptious.widget.PickerFragment.TitleText";
    
    public static final String DONE_BUTTON_TEXT_BUNDLE_KEY = "com.facebook.scrumptious.widget.PickerFragment.DoneButtonText";

    private static final String SELECTION_BUNDLE_KEY = "com.facebook.android.PickerFragment.Selection";
    private static final String ACTIVITY_CIRCLE_SHOW_KEY = "com.facebook.android.PickerFragment.ActivityCircleShown";
    private static final int PROFILE_PICTURE_PREFETCH_BUFFER = 5;

    private final int layout;
    private OnErrorListener onErrorListener;
    private OnDataChangedListener onDataChangedListener;
    private OnSelectionChangedListener onSelectionChangedListener;
    private OnDoneButtonClickedListener onDoneButtonClickedListener;
    private GraphObjectFilter filter;
    private boolean showPictures = true;
    private boolean showTitleBar = true;
    private ListView listView;
    HashSet<String> extraFields = new HashSet<String>();
    GraphObjectAdapter adapter;
    private LoadingStrategy loadingStrategy;
    private SelectionStrategy selectionStrategy;
    private Set<String> selectionHint;
    private ProgressBar activityCircle;
    private AccessTokenTracker accessTokenTracker;
    private String titleText;
    private String doneButtonText;
    private TextView titleTextView;
    private Button doneButton;
    private Drawable titleBarBackground;
    private Drawable doneButtonBackground;
    private boolean appEventsLogged;

    protected PickerFragment(int layout) {
        this.layout = layout;
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        adapter = createAdapter();
        adapter.setFilter(new GraphObjectAdapter.Filter() {
            @Override
            public boolean includeItem(JSONObject graphObject) {
                return filterIncludesItem(graphObject);
            }
        });
    }

    @Override
    public void onInflate(Activity activity, AttributeSet attrs, Bundle savedInstanceState) {
        super.onInflate(activity, attrs, savedInstanceState);
        TypedArray a = activity.obtainStyledAttributes(attrs, R.styleable.picker_fragment);

        setShowPictures(a.getBoolean(R.styleable.picker_fragment_show_pictures, showPictures));
        String extraFieldsString = a.getString(R.styleable.picker_fragment_extra_fields);
        if (extraFieldsString != null) {
            String[] strings = extraFieldsString.split(",");
            setExtraFields(Arrays.asList(strings));
        }

        showTitleBar = a.getBoolean(R.styleable.picker_fragment_show_title_bar, showTitleBar);
        titleText = a.getString(R.styleable.picker_fragment_title_text);
        doneButtonText = a.getString(R.styleable.picker_fragment_done_button_text);
        titleBarBackground = a.getDrawable(R.styleable.picker_fragment_title_bar_background);
        doneButtonBackground = a.getDrawable(R.styleable.picker_fragment_done_button_background);

        a.recycle();
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        ViewGroup view = (ViewGroup) inflater.inflate(layout, container, false);

        listView = (ListView) view.findViewById(R.id.com_facebook_picker_list_view);
        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
            @Override
            public void onItemClick(AdapterView<?> parent, View v, int position, long id) {
                onListItemClick((ListView) parent, v, position);
            }
        });
        listView.setOnLongClickListener(new View.OnLongClickListener() {
            @Override
            public boolean onLongClick(View v) {
                
                
                
                return false;
            }
        });
        listView.setOnScrollListener(onScrollListener);

        activityCircle = (ProgressBar) view.findViewById(R.id.com_facebook_picker_activity_circle);

        setupViews(view);

        listView.setAdapter(adapter);

        return view;
    }

    @Override
    public void onActivityCreated(final Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        accessTokenTracker = new AccessTokenTracker() {
            @Override
            protected void onCurrentAccessTokenChanged(AccessToken oldAccessToken,
                                                       AccessToken currentAccessToken) {
                clearResults();
            }
        };

        setSettingsFromBundle(savedInstanceState);

        loadingStrategy = createLoadingStrategy();
        loadingStrategy.attach(adapter);

        selectionStrategy = createSelectionStrategy();
        selectionStrategy.readSelectionFromBundle(savedInstanceState, SELECTION_BUNDLE_KEY);

        
        if (showTitleBar) {
            inflateTitleBar((ViewGroup) getView());
        }

        if (activityCircle != null && savedInstanceState != null) {
            boolean shown = savedInstanceState.getBoolean(ACTIVITY_CIRCLE_SHOW_KEY, false);
            if (shown) {
                displayActivityCircle();
            } else {
                
                hideActivityCircle();
            }
        }
    }

    @Override
    public void onDetach() {
        super.onDetach();

        listView.setOnScrollListener(null);
        listView.setAdapter(null);

        loadingStrategy.detach();
        accessTokenTracker.stopTracking();
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);

        saveSettingsToBundle(outState);
        selectionStrategy.saveSelectionToBundle(outState, SELECTION_BUNDLE_KEY);
        if (activityCircle != null) {
            outState.putBoolean(ACTIVITY_CIRCLE_SHOW_KEY, activityCircle.getVisibility() == View.VISIBLE);
        }
    }

    @Override
    public void onStop() {
        if (!appEventsLogged) {
            logAppEvents(false);
        }
        super.onStop();
    }

    @Override
    public void setArguments(Bundle args) {
        super.setArguments(args);
        setSettingsFromBundle(args);
    }

    
    public OnDataChangedListener getOnDataChangedListener() {
        return onDataChangedListener;
    }

    
    public void setOnDataChangedListener(OnDataChangedListener onDataChangedListener) {
        this.onDataChangedListener = onDataChangedListener;
    }

    
    public OnSelectionChangedListener getOnSelectionChangedListener() {
        return onSelectionChangedListener;
    }

    
    public void setOnSelectionChangedListener(
            OnSelectionChangedListener onSelectionChangedListener) {
        this.onSelectionChangedListener = onSelectionChangedListener;
    }

    
    public OnDoneButtonClickedListener getOnDoneButtonClickedListener() {
        return onDoneButtonClickedListener;
    }

    
    public void setOnDoneButtonClickedListener(OnDoneButtonClickedListener onDoneButtonClickedListener) {
        this.onDoneButtonClickedListener = onDoneButtonClickedListener;
    }

    
    public OnErrorListener getOnErrorListener() {
        return onErrorListener;
    }

    
    public void setOnErrorListener(OnErrorListener onErrorListener) {
        this.onErrorListener = onErrorListener;
    }

    
    public GraphObjectFilter getFilter() {
        return filter;
    }

    
    public void setFilter(GraphObjectFilter filter) {
        this.filter = filter;
    }

    
    public boolean getShowPictures() {
        return showPictures;
    }

    
    public void setShowPictures(boolean showPictures) {
        this.showPictures = showPictures;
    }

    
    public Set<String> getExtraFields() {
        return new HashSet<String>(extraFields);
    }

    
    public void setExtraFields(Collection<String> fields) {
        extraFields = new HashSet<String>();
        if (fields != null) {
            extraFields.addAll(fields);
        }
    }

    
    public void setShowTitleBar(boolean showTitleBar) {
        this.showTitleBar = showTitleBar;
    }

    
    public boolean getShowTitleBar() {
        return showTitleBar;
    }

    
    public void setTitleText(String titleText) {
        this.titleText = titleText;
    }

    
    public String getTitleText() {
        if (titleText == null) {
            titleText = getDefaultTitleText();
        }
        return titleText;
    }

    
    public void setDoneButtonText(String doneButtonText) {
        this.doneButtonText = doneButtonText;
    }

    
    public String getDoneButtonText() {
        if (doneButtonText == null) {
            doneButtonText = getDefaultDoneButtonText();
        }
        return doneButtonText;
    }

    
    public void loadData(boolean forceReload) {
        loadData(forceReload, null);
    }

    
    public void loadData(boolean forceReload, Set<String> selectIds) {
        if (!forceReload && loadingStrategy.isDataPresentOrLoading()) {
            return;
        }
        selectionHint = selectIds;
        clearResults();

        GraphRequest request = getRequestForLoadData();
        if (request != null) {
            onLoadingData();
            loadingStrategy.startLoading(request);
        }
    }

    
    public void setSettingsFromBundle(Bundle inState) {
        if (inState != null) {
            showPictures = inState.getBoolean(SHOW_PICTURES_BUNDLE_KEY, showPictures);
            String extraFieldsString = inState.getString(EXTRA_FIELDS_BUNDLE_KEY);
            if (extraFieldsString != null) {
                String[] strings = extraFieldsString.split(",");
                setExtraFields(Arrays.asList(strings));
            }
            showTitleBar = inState.getBoolean(SHOW_TITLE_BAR_BUNDLE_KEY, showTitleBar);
            String titleTextString = inState.getString(TITLE_TEXT_BUNDLE_KEY);
            if (titleTextString != null) {
                titleText = titleTextString;
                if (titleTextView != null) {
                    titleTextView.setText(titleText);
                }
            }
            String doneButtonTextString = inState.getString(DONE_BUTTON_TEXT_BUNDLE_KEY);
            if (doneButtonTextString != null) {
                doneButtonText = doneButtonTextString;
                if (doneButton != null) {
                    doneButton.setText(doneButtonText);
                }
            }
        }

    }

    void setupViews(ViewGroup view) {
    }

    boolean filterIncludesItem(JSONObject graphObject) {
        if (filter != null) {
            return filter.includeItem(graphObject);
        }
        return true;
    }

    List<JSONObject> getSelectedGraphObjects() {
        return adapter.getGraphObjectsById(selectionStrategy.getSelectedIds());
    }

    void setSelectedGraphObjects(List<String> objectIds) {
        for(String objectId : objectIds) {
            if(!this.selectionStrategy.isSelected(objectId)) {
                this.selectionStrategy.toggleSelection(objectId);
            }
        }
    }

    void saveSettingsToBundle(Bundle outState) {
        outState.putBoolean(SHOW_PICTURES_BUNDLE_KEY, showPictures);
        if (!extraFields.isEmpty()) {
            outState.putString(EXTRA_FIELDS_BUNDLE_KEY, TextUtils.join(",", extraFields));
        }
        outState.putBoolean(SHOW_TITLE_BAR_BUNDLE_KEY, showTitleBar);
        outState.putString(TITLE_TEXT_BUNDLE_KEY, titleText);
        outState.putString(DONE_BUTTON_TEXT_BUNDLE_KEY, doneButtonText);
    }

    abstract GraphRequest getRequestForLoadData();

    abstract PickerFragmentAdapter createAdapter();

    abstract LoadingStrategy createLoadingStrategy();

    abstract SelectionStrategy createSelectionStrategy();

    void onLoadingData() {
    }

    String getDefaultTitleText() {
        return null;
    }

    String getDefaultDoneButtonText() {
        return getString(R.string.picker_picker_done_button_text);
    }

    void displayActivityCircle() {
        if (activityCircle != null) {
            layoutActivityCircle();
            activityCircle.setVisibility(View.VISIBLE);
        }
    }

    void layoutActivityCircle() {
        
        
        float alpha = (!adapter.isEmpty()) ? .25f : 1.0f;
        setAlpha(activityCircle, alpha);
    }

    void hideActivityCircle() {
        if (activityCircle != null) {
            
            activityCircle.clearAnimation();
            activityCircle.setVisibility(View.INVISIBLE);
        }
    }

    void setSelectionStrategy(SelectionStrategy selectionStrategy) {
        if (selectionStrategy != this.selectionStrategy) {
            this.selectionStrategy = selectionStrategy;
            if (adapter != null) {
                
                adapter.notifyDataSetChanged();
            }
        }
    }

    void logAppEvents(boolean doneButtonClicked) {
    }

    private static void setAlpha(View view, float alpha) {
        
        AlphaAnimation alphaAnimation = new AlphaAnimation(alpha, alpha);
        alphaAnimation.setDuration(0);
        alphaAnimation.setFillAfter(true);
        view.startAnimation(alphaAnimation);
    }

    private void inflateTitleBar(ViewGroup view) {
        ViewStub stub = (ViewStub) view.findViewById(R.id.com_facebook_picker_title_bar_stub);
        if (stub != null) {
            View titleBar = stub.inflate();

            final RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(
                    RelativeLayout.LayoutParams.MATCH_PARENT,
                    RelativeLayout.LayoutParams.MATCH_PARENT);
            layoutParams.addRule(RelativeLayout.BELOW, R.id.com_facebook_picker_title_bar);
            listView.setLayoutParams(layoutParams);

            if (titleBarBackground != null) {
                titleBar.setBackgroundDrawable(titleBarBackground);
            }

            doneButton = (Button) view.findViewById(R.id.com_facebook_picker_done_button);
            if (doneButton != null) {
                doneButton.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        logAppEvents(true);
                        appEventsLogged = true;

                        if (onDoneButtonClickedListener != null) {
                            onDoneButtonClickedListener.onDoneButtonClicked(PickerFragment.this);
                        }
                    }
                });

                if (getDoneButtonText() != null) {
                    doneButton.setText(getDoneButtonText());
                }

                if (doneButtonBackground != null) {
                    doneButton.setBackgroundDrawable(doneButtonBackground);
                }
            }

            titleTextView = (TextView) view.findViewById(R.id.com_facebook_picker_title);
            if (titleTextView != null) {
                if (getTitleText() != null) {
                    titleTextView.setText(getTitleText());
                }
            }
        }
    }

    private void onListItemClick(ListView listView, View v, int position) {
        @SuppressWarnings("unchecked")
        JSONObject graphObject = (JSONObject) listView.getItemAtPosition(position);
        String id = adapter.getIdOfGraphObject(graphObject);
        selectionStrategy.toggleSelection(id);
        adapter.notifyDataSetChanged();

        if (onSelectionChangedListener != null) {
            onSelectionChangedListener.onSelectionChanged(PickerFragment.this);
        }
    }

    private void clearResults() {
        if (adapter != null) {
            boolean wasSelection = !selectionStrategy.isEmpty();
            boolean wasData = !adapter.isEmpty();

            loadingStrategy.clearResults();
            selectionStrategy.clear();
            adapter.notifyDataSetChanged();

            
            if (wasData && onDataChangedListener != null) {
                onDataChangedListener.onDataChanged(PickerFragment.this);
            }
            if (wasSelection && onSelectionChangedListener != null) {
                onSelectionChangedListener.onSelectionChanged(PickerFragment.this);
            }
        }
    }

    void updateAdapter(GraphObjectCursor data) {
        if (adapter != null) {
            
            
            
            
            
            
            

            
            
            
            View view = listView.getChildAt(1);
            int anchorPosition = listView.getFirstVisiblePosition();
            if (anchorPosition > 0) {
                anchorPosition++;
            }
            GraphObjectAdapter.SectionAndItem anchorItem = adapter.getSectionAndItem(anchorPosition);
            final int top = (view != null &&
                    anchorItem.getType() != GraphObjectAdapter.SectionAndItem.Type.ACTIVITY_CIRCLE) ?
                    view.getTop() : 0;

            
            boolean dataChanged = adapter.changeCursor(data);

            if (view != null && anchorItem != null) {
                
                final int newPositionOfItem = adapter.getPosition(anchorItem.sectionKey, anchorItem.graphObject);
                if (newPositionOfItem != -1) {
                    listView.setSelectionFromTop(newPositionOfItem, top);
                }
            }

            if (dataChanged && onDataChangedListener != null) {
                onDataChangedListener.onDataChanged(PickerFragment.this);
            }
            if (selectionHint != null && !selectionHint.isEmpty() && data != null) {
                data.moveToFirst();
                boolean changed = false;
                for (int i = 0; i < data.getCount(); i++) {
                    data.moveToPosition(i);
                    String id = data.getGraphObject().optString("id");
                    if (id == null) {
                        continue;
                    }
                    if (selectionHint.contains(id)) {
                        selectionStrategy.toggleSelection(id);
                        selectionHint.remove(id);
                        changed = true;
                    }
                    if (selectionHint.isEmpty()) {
                        break;
                    }
                }
                if (onSelectionChangedListener != null && changed) {
                    onSelectionChangedListener.onSelectionChanged(PickerFragment.this);
                }
            }
        }
    }

    private void reprioritizeDownloads() {
        int lastVisibleItem = listView.getLastVisiblePosition();
        if (lastVisibleItem >= 0) {
            int firstVisibleItem = listView.getFirstVisiblePosition();
            adapter.prioritizeViewRange(firstVisibleItem, lastVisibleItem, PROFILE_PICTURE_PREFETCH_BUFFER);
        }
    }

    private ListView.OnScrollListener onScrollListener = new ListView.OnScrollListener() {
        @Override
        public void onScrollStateChanged(AbsListView view, int scrollState) {
        }

        @Override
        public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {
            reprioritizeDownloads();
        }
    };

    
    public interface OnErrorListener {
        
        void onError(PickerFragment fragment, FacebookException error);
    }

    
    public interface OnDataChangedListener {
        
        void onDataChanged(PickerFragment fragment);
    }

    
    public interface OnSelectionChangedListener {
        
        void onSelectionChanged(PickerFragment fragment);
    }

    
    public interface OnDoneButtonClickedListener {
        
        void onDoneButtonClicked(PickerFragment fragment);
    }

    
    public interface GraphObjectFilter {
        
        boolean includeItem(JSONObject graphObject);
    }

    abstract class LoadingStrategy {
        protected final static int CACHED_RESULT_REFRESH_DELAY = 2 * 1000;

        protected GraphObjectPagingLoader loader;
        protected GraphObjectAdapter adapter;

        public void attach(GraphObjectAdapter adapter) {
            loader = (GraphObjectPagingLoader) getLoaderManager().initLoader(0, null,
                    new LoaderManager.LoaderCallbacks<GraphObjectCursor>() {
                        @Override
                        public Loader<GraphObjectCursor> onCreateLoader(int id, Bundle args) {
                            return LoadingStrategy.this.onCreateLoader();
                        }

                        @Override
                        public void onLoadFinished(Loader<GraphObjectCursor> loader,
                                GraphObjectCursor data) {
                            if (loader != LoadingStrategy.this.loader) {
                                throw new FacebookException("Received callback for unknown loader.");
                            }
                            LoadingStrategy.this.onLoadFinished((GraphObjectPagingLoader) loader, data);
                        }

                        @Override
                        public void onLoaderReset(Loader<GraphObjectCursor> loader) {
                            if (loader != LoadingStrategy.this.loader) {
                                throw new FacebookException("Received callback for unknown loader.");
                            }
                            LoadingStrategy.this.onLoadReset((GraphObjectPagingLoader) loader);
                        }
                    });

            loader.setOnErrorListener(new GraphObjectPagingLoader.OnErrorListener() {
                @Override
                public void onError(FacebookException error, GraphObjectPagingLoader loader) {
                    hideActivityCircle();
                    if (onErrorListener != null) {
                        onErrorListener.onError(PickerFragment.this, error);
                    }
                }
            });

            this.adapter = adapter;
            
            this.adapter.changeCursor(loader.getCursor());
            this.adapter.setOnErrorListener(new GraphObjectAdapter.OnErrorListener() {
                @Override
                public void onError(GraphObjectAdapter adapter, FacebookException error) {
                    if (onErrorListener != null) {
                        onErrorListener.onError(PickerFragment.this, error);
                    }
                }
            });
        }

        public void detach() {
            adapter.setDataNeededListener(null);
            adapter.setOnErrorListener(null);
            loader.setOnErrorListener(null);

            loader = null;
            adapter = null;
        }

        public void clearResults() {
            if (loader != null) {
                loader.clearResults();
            }
        }

        public void startLoading(GraphRequest request) {
            if (loader != null) {
                loader.startLoading(request);
                onStartLoading(loader, request);
            }
        }

        public boolean isDataPresentOrLoading() {
            return !adapter.isEmpty() || loader.isLoading();
        }

        protected GraphObjectPagingLoader onCreateLoader() {
            return new GraphObjectPagingLoader(getActivity());
        }

        protected void onStartLoading(GraphObjectPagingLoader loader, GraphRequest request) {
            displayActivityCircle();
        }

        protected void onLoadReset(GraphObjectPagingLoader loader) {
            adapter.changeCursor(null);
        }

        protected void onLoadFinished(GraphObjectPagingLoader loader, GraphObjectCursor data) {
            updateAdapter(data);
        }
    }

    abstract class SelectionStrategy {
        abstract boolean isSelected(String id);

        abstract void toggleSelection(String id);

        abstract Collection<String> getSelectedIds();

        abstract void clear();

        abstract boolean isEmpty();

        abstract boolean shouldShowCheckBoxIfUnselected();

        abstract void saveSelectionToBundle(Bundle outBundle, String key);

        abstract void readSelectionFromBundle(Bundle inBundle, String key);
    }

    class SingleSelectionStrategy extends SelectionStrategy {
        private String selectedId;

        public Collection<String> getSelectedIds() {
            return Arrays.asList(new String[]{selectedId});
        }

        @Override
        boolean isSelected(String id) {
            return selectedId != null && id != null && selectedId.equals(id);
        }

        @Override
        void toggleSelection(String id) {
            if (selectedId != null && selectedId.equals(id)) {
                selectedId = null;
            } else {
                selectedId = id;
            }
        }

        @Override
        void saveSelectionToBundle(Bundle outBundle, String key) {
            if (!TextUtils.isEmpty(selectedId)) {
                outBundle.putString(key, selectedId);
            }
        }

        @Override
        void readSelectionFromBundle(Bundle inBundle, String key) {
            if (inBundle != null) {
                selectedId = inBundle.getString(key);
            }
        }

        @Override
        public void clear() {
            selectedId = null;
        }

        @Override
        boolean isEmpty() {
            return selectedId == null;
        }

        @Override
        boolean shouldShowCheckBoxIfUnselected() {
            return false;
        }
    }

    class MultiSelectionStrategy extends SelectionStrategy {
        private Set<String> selectedIds = new HashSet<String>();

        public Collection<String> getSelectedIds() {
            return selectedIds;
        }

        @Override
        boolean isSelected(String id) {
            return id != null && selectedIds.contains(id);
        }

        @Override
        void toggleSelection(String id) {
            if (id != null) {
                if (selectedIds.contains(id)) {
                    selectedIds.remove(id);
                } else {
                    selectedIds.add(id);
                }
            }
        }

        @Override
        void saveSelectionToBundle(Bundle outBundle, String key) {
            if (!selectedIds.isEmpty()) {
                String ids = TextUtils.join(",", selectedIds);
                outBundle.putString(key, ids);
            }
        }

        @Override
        void readSelectionFromBundle(Bundle inBundle, String key) {
            if (inBundle != null) {
                String ids = inBundle.getString(key);
                if (ids != null) {
                    String[] splitIds = TextUtils.split(ids, ",");
                    selectedIds.clear();
                    Collections.addAll(selectedIds, splitIds);
                }
            }
        }

        @Override
        public void clear() {
            selectedIds.clear();
        }

        @Override
        boolean isEmpty() {
            return selectedIds.isEmpty();
        }

        @Override
        boolean shouldShowCheckBoxIfUnselected() {
            return true;
        }
    }

    abstract class PickerFragmentAdapter extends GraphObjectAdapter {
        public PickerFragmentAdapter(Context context) {
            super(context);
        }

        @Override
        boolean isGraphObjectSelected(String graphObjectId) {
            return selectionStrategy.isSelected(graphObjectId);
        }

        @Override
        void updateCheckboxState(CheckBox checkBox, boolean graphObjectSelected) {
            checkBox.setChecked(graphObjectSelected);
            int visible = (graphObjectSelected || selectionStrategy.shouldShowCheckBoxIfUnselected())
                    ? View.VISIBLE : View.GONE;
            checkBox.setVisibility(visible);
        }
    }
}

<code block>


package com.facebook.scrumptious.picker;

import android.content.Context;
import android.support.v4.content.Loader;
import com.facebook.*;
import org.json.JSONArray;

class GraphObjectPagingLoader extends Loader<GraphObjectCursor> {
    private GraphRequest originalRequest;
    private GraphRequest currentRequest;
    private GraphRequest nextRequest;
    private OnErrorListener onErrorListener;
    private GraphObjectCursor cursor;
    private boolean appendResults = false;
    private boolean loading = false;

    public interface OnErrorListener {
        public void onError(FacebookException error, GraphObjectPagingLoader loader);
    }

    public GraphObjectPagingLoader(Context context) {
        super(context);
    }

    public OnErrorListener getOnErrorListener() {
        return onErrorListener;
    }

    public void setOnErrorListener(OnErrorListener listener) {
        this.onErrorListener = listener;
    }

    public GraphObjectCursor getCursor() {
        return cursor;
    }

    public void clearResults() {
        nextRequest = null;
        originalRequest = null;
        currentRequest = null;

        deliverResult(null);
    }

    public boolean isLoading() {
        return loading;
    }

    public void startLoading(GraphRequest request) {
        appendResults = false;
        nextRequest = null;
        currentRequest = request;
        currentRequest.setCallback(new GraphRequest.Callback() {
            @Override
            public void onCompleted(GraphResponse response) {
                requestCompleted(response);
            }
        });

        loading = true;
        final GraphRequestBatch batch = new GraphRequestBatch(request);
        GraphRequest.executeBatchAsync(batch);
    }

    public void followNextLink() {
        if (nextRequest != null) {
            appendResults = true;
            currentRequest = nextRequest;

            currentRequest.setCallback(new GraphRequest.Callback() {
                @Override
                public void onCompleted(GraphResponse response) {
                    requestCompleted(response);
                }
            });

            loading = true;
            GraphRequest.executeBatchAsync(new GraphRequestBatch(currentRequest));
        }
    }

    @Override
    public void deliverResult(GraphObjectCursor cursor) {
        GraphObjectCursor oldCursor = this.cursor;
        this.cursor = cursor;

        if (isStarted()) {
            super.deliverResult(cursor);

            if (oldCursor != null && oldCursor != cursor && !oldCursor.isClosed()) {
                oldCursor.close();
            }
        }
    }

    @Override
    protected void onStartLoading() {
        super.onStartLoading();

        if (cursor != null) {
            deliverResult(cursor);
        }
    }

    private void requestCompleted(GraphResponse response) {
        GraphRequest request = response.getRequest();
        if (request != currentRequest) {
            return;
        }

        loading = false;
        currentRequest = null;

        FacebookRequestError requestError = response.getError();
        FacebookException exception = (requestError == null) ? null : requestError.getException();
        if (response.getJSONObject() == null && exception == null) {
            exception = new FacebookException("GraphObjectPagingLoader received neither a result nor an error.");
        }

        if (exception != null) {
            nextRequest = null;

            if (onErrorListener != null) {
                onErrorListener.onError(exception, this);
            }
        } else {
            addResults(response);
        }
    }

    private void addResults(GraphResponse response) {
        GraphObjectCursor cursorToModify = (cursor == null || !appendResults) ? new GraphObjectCursor() :
                new GraphObjectCursor(cursor);

        JSONArray data = response.getJSONObject().optJSONArray("data");

        boolean haveData = data.length() > 0;

        if (haveData) {
            nextRequest = response.getRequestForPagedResults(GraphResponse.PagingDirection.NEXT);
            cursorToModify.addGraphObjects(data);
        } else {
            nextRequest = null;
        }
        cursorToModify.setMoreObjectsAvailable(nextRequest != null);

        deliverResult(cursorToModify);
    }
}

<code block>


package com.facebook.scrumptious.picker;

import android.database.CursorIndexOutOfBoundsException;
import org.json.JSONArray;
import org.json.JSONObject;

import java.util.ArrayList;
import java.util.List;

class GraphObjectCursor {
    private int pos = -1;
    private boolean closed = false;
    private List<JSONObject> graphObjects = new ArrayList<JSONObject>();
    private boolean moreObjectsAvailable = false;

    GraphObjectCursor() {
    }

    GraphObjectCursor(GraphObjectCursor other) {
        pos = other.pos;
        closed = other.closed;
        graphObjects = new ArrayList<JSONObject>();
        graphObjects.addAll(other.graphObjects);

        
    }

    public void addGraphObjects(JSONArray graphObjects) {
        for (int i = 0; i < graphObjects.length(); ++i) {
            this.graphObjects.add(graphObjects.optJSONObject(i));
        }
    }

    public boolean areMoreObjectsAvailable() {
        return moreObjectsAvailable;
    }

    public void setMoreObjectsAvailable(boolean moreObjectsAvailable) {
        this.moreObjectsAvailable = moreObjectsAvailable;
    }

    public int getCount() {
        return graphObjects.size();
    }

    public int getPosition() {
        return pos;
    }

    public boolean move(int offset) {
        return moveToPosition(pos + offset);
    }

    public boolean moveToPosition(int position) {
        final int count = getCount();
        if (position >= count) {
            pos = count;
            return false;
        }

        if (position < 0) {
            pos = -1;
            return false;
        }

        pos = position;
        return true;
    }

    public boolean moveToFirst() {
        return moveToPosition(0);
    }

    public boolean moveToLast() {
        return moveToPosition(getCount() - 1);
    }

    public boolean moveToNext() {
        return moveToPosition(pos + 1);
    }

    public boolean moveToPrevious() {
        return moveToPosition(pos - 1);
    }

    public boolean isFirst() {
        return (pos == 0) && (getCount() != 0);
    }

    public boolean isLast() {
        final int count = getCount();
        return (pos == (count - 1)) && (count != 0);
    }

    public boolean isBeforeFirst() {
        return (getCount() == 0) || (pos == -1);
    }

    public boolean isAfterLast() {
        final int count = getCount();
        return (count == 0) || (pos == count);
    }

    public JSONObject getGraphObject() {
        if (pos < 0) {
            throw new CursorIndexOutOfBoundsException("Before first object.");
        }
        if (pos >= graphObjects.size()) {
            throw new CursorIndexOutOfBoundsException("After last object.");
        }
        return graphObjects.get(pos);
    }

    public void close() {
        closed = true;
    }

    public boolean isClosed() {
        return closed;
    }

}

<code block>


package com.facebook.scrumptious.picker;

import android.app.Activity;
import android.content.res.TypedArray;
import android.os.Bundle;
import android.text.TextUtils;
import android.util.AttributeSet;

import com.facebook.AccessToken;
import com.facebook.GraphRequest;
import com.facebook.appevents.AppEventsLogger;
import com.facebook.FacebookException;
import com.facebook.scrumptious.R;
import com.facebook.internal.AnalyticsEvents;
import com.facebook.internal.Validate;

import org.json.JSONObject;

import java.util.*;


public class FriendPickerFragment extends PickerFragment {
    
    public static final String USER_ID_BUNDLE_KEY = "com.facebook.scrumptious.widget.FriendPickerFragment.UserId";
    
    public static final String MULTI_SELECT_BUNDLE_KEY = "com.facebook.scrumptious.widget.FriendPickerFragment.MultiSelect";
    
    public static final String FRIEND_PICKER_TYPE_KEY = "com.facebook.scrumptious.widget.FriendPickerFragment.FriendPickerType";

    public enum FriendPickerType {
        FRIENDS("/friends"),
        TAGGABLE_FRIENDS("/taggable_friends"),
        INVITABLE_FRIENDS("/invitable_friends");

        private final String requestPath;

        FriendPickerType(String path) {
            this.requestPath = path;
        }

        String getRequestPath() {
            return requestPath;
        }
    }

    private static final String ID = "id";
    private static final String NAME = "name";

    private String userId;

    private boolean multiSelect = true;

    
    private FriendPickerType friendPickerType = FriendPickerType.FRIENDS;

    private List<String> preSelectedFriendIds = new ArrayList<String>();

    
    public FriendPickerFragment() {
        super(R.layout.picker_friendpickerfragment);
    }

    
    public String getUserId() {
        return userId;
    }

    
    public void setUserId(String userId) {
        this.userId = userId;
    }

    
    public boolean getMultiSelect() {
        return multiSelect;
    }

    
    public void setMultiSelect(boolean multiSelect) {
        if (this.multiSelect != multiSelect) {
            this.multiSelect = multiSelect;
            setSelectionStrategy(createSelectionStrategy());
        }
    }

    
    public void setFriendPickerType(FriendPickerType type) {
        this.friendPickerType = type;
    }

    
    public void setSelectionByIds(List<String> userIds) {
        preSelectedFriendIds.addAll(userIds);
    }

    
    public void setSelectionByIds(String... userIds) {
        setSelectionByIds(Arrays.asList(userIds));
    }

    
    public void setSelection(JSONObject... graphUsers) {
        setSelection(Arrays.asList(graphUsers));
    }

    
    public void setSelection(List<JSONObject> graphUsers) {
        List<String> userIds = new ArrayList<String>();
        for(JSONObject graphUser: graphUsers) {
            String id = graphUser.optString("id");
            Validate.notNullOrEmpty(id, "id");
            userIds.add(id);
        }
        setSelectionByIds(userIds);
    }

    
    public List<JSONObject> getSelection() {
        return getSelectedGraphObjects();
    }

    @Override
    public void onInflate(Activity activity, AttributeSet attrs, Bundle savedInstanceState) {
        super.onInflate(activity, attrs, savedInstanceState);
        TypedArray a = activity.obtainStyledAttributes(attrs, R.styleable.picker_friend_picker_fragment);

        setMultiSelect(a.getBoolean(R.styleable.picker_friend_picker_fragment_multi_select, multiSelect));

        a.recycle();
    }

    @Override
    public void setSettingsFromBundle(Bundle inState) {
        super.setSettingsFromBundle(inState);
        if (inState != null) {
            if (inState.containsKey(USER_ID_BUNDLE_KEY)) {
                setUserId(inState.getString(USER_ID_BUNDLE_KEY));
            }
            setMultiSelect(inState.getBoolean(MULTI_SELECT_BUNDLE_KEY, multiSelect));
            if (inState.containsKey(FRIEND_PICKER_TYPE_KEY)) {
                try {
                    friendPickerType = FriendPickerType.valueOf(inState.getString(FRIEND_PICKER_TYPE_KEY));
                } catch (Exception e) {
                    
                }
            }
        }
    }

    void saveSettingsToBundle(Bundle outState) {
        super.saveSettingsToBundle(outState);

        outState.putString(USER_ID_BUNDLE_KEY, userId);
        outState.putBoolean(MULTI_SELECT_BUNDLE_KEY, multiSelect);
    }

    @Override
    PickerFragmentAdapter createAdapter() {
        PickerFragmentAdapter adapter = new PickerFragmentAdapter(this.getActivity()) {
            @Override
            protected int getGraphObjectRowLayoutId(JSONObject graphObject) {
                return R.layout.picker_list_row;
            }

            @Override
            protected int getDefaultPicture() {
                return R.drawable.profile_default_icon;
            }

        };
        adapter.setShowCheckbox(true);
        adapter.setShowPicture(getShowPictures());
        adapter.setSortFields(Arrays.asList(new String[]{NAME}));
        adapter.setGroupByField(NAME);

        return adapter;
    }

    @Override
    LoadingStrategy createLoadingStrategy() {
        return new ImmediateLoadingStrategy();
    }

    @Override
    SelectionStrategy createSelectionStrategy() {
        return multiSelect ? new MultiSelectionStrategy() : new SingleSelectionStrategy();
    }

    @Override
    GraphRequest getRequestForLoadData() {
        if (adapter == null) {
            throw new FacebookException("Can't issue requests until Fragment has been created.");
        }

        String userToFetch = (userId != null) ? userId : "me";
        return createRequest(userToFetch, extraFields);
    }

    @Override
    String getDefaultTitleText() {
        return getResources().getString(R.string.choose_friends);
    }

    @Override
    void logAppEvents(boolean doneButtonClicked) {
        AppEventsLogger logger = AppEventsLogger.newLogger(this.getActivity(),
                AccessToken.getCurrentAccessToken().getToken());
        Bundle parameters = new Bundle();

        
        
        
        String outcome = doneButtonClicked ? AnalyticsEvents.PARAMETER_DIALOG_OUTCOME_VALUE_COMPLETED :
                AnalyticsEvents.PARAMETER_DIALOG_OUTCOME_VALUE_UNKNOWN;
        parameters.putString(AnalyticsEvents.PARAMETER_DIALOG_OUTCOME, outcome);
        parameters.putInt("num_friends_picked", getSelection().size());

        logger.logSdkEvent(AnalyticsEvents.EVENT_FRIEND_PICKER_USAGE, null, parameters);
    }

    @Override
    public void loadData(boolean forceReload) {
        super.loadData(forceReload);
        setSelectedGraphObjects(preSelectedFriendIds);
    }

    private GraphRequest createRequest(String userID, Set<String> extraFields) {
        AccessToken accessToken = AccessToken.getCurrentAccessToken();
        GraphRequest request = GraphRequest.newGraphPathRequest(
                accessToken, userID + friendPickerType.getRequestPath(), null);

        Set<String> fields = new HashSet<String>(extraFields);
        String[] requiredFields = new String[]{
                ID,
                NAME
        };
        fields.addAll(Arrays.asList(requiredFields));

        String pictureField = adapter.getPictureFieldSpecifier();
        if (pictureField != null) {
            fields.add(pictureField);
        }

        Bundle parameters = request.getParameters();
        parameters.putString("fields", TextUtils.join(",", fields));
        request.setParameters(parameters);

        return request;
    }

    private class ImmediateLoadingStrategy extends LoadingStrategy {
        @Override
        protected void onLoadFinished(GraphObjectPagingLoader loader, GraphObjectCursor data) {
            super.onLoadFinished(loader, data);

            
            
            if (data == null || loader.isLoading()) {
                return;
            }

            if (data.areMoreObjectsAvailable()) {
                
                followNextLink();
            } else {
                
                hideActivityCircle();
            }
        }

        private void followNextLink() {
            
            displayActivityCircle();

            loader.followNextLink();
        }
    }
}

<code block>


package com.facebook.scrumptious.picker;

import android.content.Context;
import android.graphics.Bitmap;
import android.net.Uri;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewStub;
import android.widget.*;
import com.facebook.FacebookException;
import com.facebook.scrumptious.R;
import com.facebook.internal.ImageDownloader;
import com.facebook.internal.ImageRequest;
import com.facebook.internal.ImageResponse;
import com.facebook.internal.Utility;

import org.json.JSONObject;

import java.net.URI;
import java.net.URISyntaxException;
import java.text.Collator;
import java.util.*;

class GraphObjectAdapter extends BaseAdapter implements SectionIndexer {
    private static final int DISPLAY_SECTIONS_THRESHOLD = 1;
    private static final int HEADER_VIEW_TYPE = 0;
    private static final int GRAPH_OBJECT_VIEW_TYPE = 1;
    private static final int ACTIVITY_CIRCLE_VIEW_TYPE = 2;
    private static final int MAX_PREFETCHED_PICTURES = 20;

    private static final String ID = "id";
    private static final String NAME = "name";
    private static final String PICTURE = "picture";

    private final Map<String, ImageRequest> pendingRequests = new HashMap<String, ImageRequest>();
    private final LayoutInflater inflater;
    private List<String> sectionKeys = new ArrayList<String>();
    private Map<String, ArrayList<JSONObject>> graphObjectsBySection = new HashMap<String, ArrayList<JSONObject>>();
    private Map<String, JSONObject> graphObjectsById = new HashMap<String, JSONObject>();
    private boolean displaySections;
    private List<String> sortFields;
    private String groupByField;
    private boolean showPicture;
    private boolean showCheckbox;
    private Filter filter;
    private DataNeededListener dataNeededListener;
    private GraphObjectCursor cursor;
    private Context context;
    private Map<String, ImageResponse> prefetchedPictureCache = new HashMap<String, ImageResponse>();
    private ArrayList<String> prefetchedProfilePictureIds = new ArrayList<String>();
    private OnErrorListener onErrorListener;

    public interface DataNeededListener {
        public void onDataNeeded();
    }

    public interface OnErrorListener {
        void onError(GraphObjectAdapter adapter, FacebookException error);
    }

    public static class SectionAndItem {
        public String sectionKey;
        public JSONObject graphObject;

        public enum Type {
            GRAPH_OBJECT,
            SECTION_HEADER,
            ACTIVITY_CIRCLE
        }

        public SectionAndItem(String sectionKey, JSONObject graphObject) {
            this.sectionKey = sectionKey;
            this.graphObject = graphObject;
        }

        public Type getType() {
            if (sectionKey == null) {
                return Type.ACTIVITY_CIRCLE;
            } else if (graphObject == null) {
                return Type.SECTION_HEADER;
            } else {
                return Type.GRAPH_OBJECT;
            }
        }
    }

    interface Filter {
        boolean includeItem(JSONObject graphObject);
    }

    public GraphObjectAdapter(Context context) {
        this.context = context;
        this.inflater = LayoutInflater.from(context);
    }

    public List<String> getSortFields() {
        return sortFields;
    }

    public void setSortFields(List<String> sortFields) {
        this.sortFields = sortFields;
    }

    public String getGroupByField() {
        return groupByField;
    }

    public void setGroupByField(String groupByField) {
        this.groupByField = groupByField;
    }

    public boolean getShowPicture() {
        return showPicture;
    }

    public void setShowPicture(boolean showPicture) {
        this.showPicture = showPicture;
    }

    public boolean getShowCheckbox() {
        return showCheckbox;
    }

    public void setShowCheckbox(boolean showCheckbox) {
        this.showCheckbox = showCheckbox;
    }

    public DataNeededListener getDataNeededListener() {
        return dataNeededListener;
    }

    public void setDataNeededListener(DataNeededListener dataNeededListener) {
        this.dataNeededListener = dataNeededListener;
    }

    public OnErrorListener getOnErrorListener() {
        return onErrorListener;
    }

    public void setOnErrorListener(OnErrorListener onErrorListener) {
        this.onErrorListener = onErrorListener;
    }

    public GraphObjectCursor getCursor() {
        return cursor;
    }

    public boolean changeCursor(GraphObjectCursor cursor) {
        if (this.cursor == cursor) {
            return false;
        }
        if (this.cursor != null) {
            this.cursor.close();
        }
        this.cursor = cursor;

        rebuildAndNotify();
        return true;
    }

    public void rebuildAndNotify() {
        rebuildSections();
        notifyDataSetChanged();
    }

    public void prioritizeViewRange(int firstVisibleItem, int lastVisibleItem, int prefetchBuffer) {
        if ((lastVisibleItem < firstVisibleItem) || (sectionKeys.size() == 0)) {
            return;
        }

        
        
        
        
        

        
        
        
        
        for (int i = lastVisibleItem; i >= 0; i--) {
            SectionAndItem sectionAndItem = getSectionAndItem(i);
            if (sectionAndItem.graphObject != null) {
                String id = getIdOfGraphObject(sectionAndItem.graphObject);
                ImageRequest request = pendingRequests.get(id);
                if (request != null) {
                    ImageDownloader.prioritizeRequest(request);
                }
            }
        }

        
        
        int start = Math.max(0, firstVisibleItem - prefetchBuffer);
        int end = Math.min(lastVisibleItem + prefetchBuffer, getCount() - 1);
        ArrayList<JSONObject> graphObjectsToPrefetchPicturesFor = new ArrayList<JSONObject>();
        
        for (int i = start; i < firstVisibleItem; ++i) {
            SectionAndItem sectionAndItem = getSectionAndItem(i);
            if (sectionAndItem.graphObject != null) {
                graphObjectsToPrefetchPicturesFor.add(sectionAndItem.graphObject);
            }
        }
        for (int i = lastVisibleItem + 1; i <= end; ++i) {
            SectionAndItem sectionAndItem = getSectionAndItem(i);
            if (sectionAndItem.graphObject != null) {
                graphObjectsToPrefetchPicturesFor.add(sectionAndItem.graphObject);
            }
        }
        for (JSONObject graphObject : graphObjectsToPrefetchPicturesFor) {
            Uri uri = getPictureUriOfGraphObject(graphObject);
            final String id = getIdOfGraphObject(graphObject);

            
            
            boolean alreadyPrefetching = prefetchedProfilePictureIds.remove(id);
            prefetchedProfilePictureIds.add(id);

            
            if (!alreadyPrefetching) {
                downloadProfilePicture(id, uri, null);
            }
        }
    }

    protected String getSectionKeyOfGraphObject(JSONObject graphObject) {
        String result = null;

        if (groupByField != null) {
            result = graphObject.optString(groupByField);
            if (result != null && result.length() > 0) {
                result = result.substring(0, 1).toUpperCase();
            }
        }

        return (result != null) ? result : "";
    }

    protected CharSequence getTitleOfGraphObject(JSONObject graphObject) {
        return graphObject.optString(NAME);
    }

    protected CharSequence getSubTitleOfGraphObject(JSONObject graphObject) {
        return null;
    }

    protected Uri getPictureUriOfGraphObject(JSONObject graphObject) {
        String uri = null;
        Object o = graphObject.opt(PICTURE);
        if (o instanceof String) {
            uri = (String) o;
        } else if (o instanceof JSONObject) {
            JSONObject data = ((JSONObject) o).optJSONObject("data");
            uri = data != null ? data.optString("url") : null;
        }

        if (uri != null) {
            return Uri.parse(uri);
        }
        return null;
    }

    protected View getSectionHeaderView(String sectionHeader, View convertView, ViewGroup parent) {
        TextView result = (TextView) convertView;

        if (result == null) {
            result = (TextView) inflater.inflate(R.layout.picker_list_section_header, null);
        }

        result.setText(sectionHeader);

        return result;
    }

    protected View getGraphObjectView(JSONObject graphObject, View convertView, ViewGroup parent) {
        View result = convertView;

        if (result == null) {
            result = createGraphObjectView(graphObject);
        }

        populateGraphObjectView(result, graphObject);
        return result;
    }

    private View getActivityCircleView(View convertView, ViewGroup parent) {
        View result = convertView;

        if (result == null) {
            result = inflater.inflate(R.layout.picker_activity_circle_row, null);
        }
        ProgressBar activityCircle = (ProgressBar) result.findViewById(R.id.com_facebook_picker_row_activity_circle);
        activityCircle.setVisibility(View.VISIBLE);

        return result;
    }

    protected int getGraphObjectRowLayoutId(JSONObject graphObject) {
        return R.layout.picker_list_row;
    }

    protected int getDefaultPicture() {
        return R.drawable.profile_default_icon;
    }

    protected View createGraphObjectView(JSONObject graphObject) {
        View result = inflater.inflate(getGraphObjectRowLayoutId(graphObject), null);

        ViewStub checkboxStub = (ViewStub) result.findViewById(R.id.com_facebook_picker_checkbox_stub);
        if (checkboxStub != null) {
            if (!getShowCheckbox()) {
                checkboxStub.setVisibility(View.GONE);
            } else {
                CheckBox checkBox = (CheckBox) checkboxStub.inflate();
                updateCheckboxState(checkBox, false);
            }
        }

        ViewStub profilePicStub = (ViewStub) result.findViewById(R.id.com_facebook_picker_profile_pic_stub);
        if (!getShowPicture()) {
            profilePicStub.setVisibility(View.GONE);
        } else {
            ImageView imageView = (ImageView) profilePicStub.inflate();
            imageView.setVisibility(View.VISIBLE);
        }

        return result;
    }

    protected void populateGraphObjectView(View view, JSONObject graphObject) {
        String id = getIdOfGraphObject(graphObject);
        view.setTag(id);

        CharSequence title = getTitleOfGraphObject(graphObject);
        TextView titleView = (TextView) view.findViewById(R.id.com_facebook_picker_title);
        if (titleView != null) {
            titleView.setText(title, TextView.BufferType.SPANNABLE);
        }

        CharSequence subtitle = getSubTitleOfGraphObject(graphObject);
        TextView subtitleView = (TextView) view.findViewById(R.id.picker_subtitle);
        if (subtitleView != null) {
            if (subtitle != null) {
                subtitleView.setText(subtitle, TextView.BufferType.SPANNABLE);
                subtitleView.setVisibility(View.VISIBLE);
            } else {
                subtitleView.setVisibility(View.GONE);
            }
        }

        if (getShowCheckbox()) {
            CheckBox checkBox = (CheckBox) view.findViewById(R.id.com_facebook_picker_checkbox);
            updateCheckboxState(checkBox, isGraphObjectSelected(id));
        }

        if (getShowPicture()) {
            Uri pictureURI = getPictureUriOfGraphObject(graphObject);

            if (pictureURI != null) {
                ImageView profilePic = (ImageView) view.findViewById(R.id.com_facebook_picker_image);

                
                if (prefetchedPictureCache.containsKey(id)) {
                    ImageResponse response = prefetchedPictureCache.get(id);
                    profilePic.setImageBitmap(response.getBitmap());
                    profilePic.setTag(response.getRequest().getImageUri());
                } else {
                    downloadProfilePicture(id, pictureURI, profilePic);
                }
            }
        }
    }

    
    String getIdOfGraphObject(JSONObject graphObject) {
        String id = graphObject.optString(ID);
        if (id != null) {
            return id;
        }
        throw new FacebookException("Received an object without an ID.");
    }

    boolean filterIncludesItem(JSONObject graphObject) {
        return filter == null || filter.includeItem(graphObject);
    }

    Filter getFilter() {
        return filter;
    }

    void setFilter(Filter filter) {
        this.filter = filter;
    }

    boolean isGraphObjectSelected(String graphObjectId) {
        return false;
    }

    void updateCheckboxState(CheckBox checkBox, boolean graphObjectSelected) {
        
    }

    String getPictureFieldSpecifier() {
        
        View view = createGraphObjectView(null);
        ImageView picture = (ImageView) view.findViewById(R.id.com_facebook_picker_image);
        if (picture == null) {
            return null;
        }

        
        ViewGroup.LayoutParams layoutParams = picture.getLayoutParams();
        return String.format(Locale.US, "picture.height(%d).width(%d)", layoutParams.height, layoutParams.width);
    }


    private boolean shouldShowActivityCircleCell() {
        
        
        return (cursor != null) && cursor.areMoreObjectsAvailable() && (dataNeededListener != null) && !isEmpty();
    }

    private void rebuildSections() {
        sectionKeys = new ArrayList<String>();
        graphObjectsBySection = new HashMap<String, ArrayList<JSONObject>>();
        graphObjectsById = new HashMap<String, JSONObject>();
        displaySections = false;

        if (cursor == null || cursor.getCount() == 0) {
            return;
        }

        int objectsAdded = 0;
        cursor.moveToFirst();
        do {
            JSONObject graphObject = cursor.getGraphObject();

            if (!filterIncludesItem(graphObject)) {
                continue;
            }

            objectsAdded++;

            String sectionKeyOfItem = getSectionKeyOfGraphObject(graphObject);
            if (!graphObjectsBySection.containsKey(sectionKeyOfItem)) {
                sectionKeys.add(sectionKeyOfItem);
                graphObjectsBySection.put(sectionKeyOfItem, new ArrayList<JSONObject>());
            }
            List<JSONObject> section = graphObjectsBySection.get(sectionKeyOfItem);
            section.add(graphObject);

            graphObjectsById.put(getIdOfGraphObject(graphObject), graphObject);
        } while (cursor.moveToNext());

        if (sortFields != null) {
            final Collator collator = Collator.getInstance();
            for (List<JSONObject> section : graphObjectsBySection.values()) {
                Collections.sort(section, new Comparator<JSONObject>() {
                    @Override
                    public int compare(JSONObject a, JSONObject b) {
                        return compareGraphObjects(a, b, sortFields, collator);
                    }
                });
            }
        }

        Collections.sort(sectionKeys, Collator.getInstance());

        displaySections = sectionKeys.size() > 1 && objectsAdded > DISPLAY_SECTIONS_THRESHOLD;
    }

    SectionAndItem getSectionAndItem(int position) {
        if (sectionKeys.size() == 0) {
            return null;
        }
        String sectionKey = null;
        JSONObject graphObject = null;

        if (!displaySections) {
            sectionKey = sectionKeys.get(0);
            List<JSONObject> section = graphObjectsBySection.get(sectionKey);
            if (position >= 0 && position < section.size()) {
                graphObject = graphObjectsBySection.get(sectionKey).get(position);
            } else {
                
                assert dataNeededListener != null && cursor.areMoreObjectsAvailable();
                
                return new SectionAndItem(null, null);
            }
        } else {
            
            
            for (String key : sectionKeys) {
                
                if (position-- == 0) {
                    sectionKey = key;
                    break;
                }

                List<JSONObject> section = graphObjectsBySection.get(key);
                if (position < section.size()) {
                    
                    sectionKey = key;
                    graphObject = section.get(position);
                    break;
                }
                
                position -= section.size();
            }
        }
        if (sectionKey != null) {
            
            return new SectionAndItem(sectionKey, graphObject);
        } else {
            throw new IndexOutOfBoundsException("position");
        }
    }

    int getPosition(String sectionKey, JSONObject graphObject) {
        int position = 0;
        boolean found = false;

        
        
        for (String key : sectionKeys) {
            if (displaySections) {
                position++;
            }
            if (key.equals(sectionKey)) {
                found = true;
                break;
            } else {
                position += graphObjectsBySection.get(key).size();
            }
        }

        if (!found) {
            return -1;
        } else if (graphObject == null) {
            
            
            return position - (displaySections ? 1 : 0);
        }

        
        for (JSONObject t : graphObjectsBySection.get(sectionKey)) {
            if (Utility.hasSameId(t, graphObject)) {
                return position;
            }
            position++;
        }
        return -1;
    }

    @Override
    public boolean isEmpty() {
        
        return sectionKeys.size() == 0;
    }

    @Override
    public int getCount() {
        if (sectionKeys.size() == 0) {
            return 0;
        }

        
        
        int count = (displaySections) ? sectionKeys.size() : 0;
        for (List<JSONObject> section : graphObjectsBySection.values()) {
            count += section.size();
        }

        
        if (shouldShowActivityCircleCell()) {
            ++count;
        }

        return count;
    }

    @Override
    public boolean areAllItemsEnabled() {
        return displaySections;
    }

    @Override
    public boolean hasStableIds() {
        return true;
    }

    @Override
    public boolean isEnabled(int position) {
        SectionAndItem sectionAndItem = getSectionAndItem(position);
        return sectionAndItem.getType() == SectionAndItem.Type.GRAPH_OBJECT;
    }

    @Override
    public Object getItem(int position) {
        SectionAndItem sectionAndItem = getSectionAndItem(position);
        return (sectionAndItem.getType() == SectionAndItem.Type.GRAPH_OBJECT) ? sectionAndItem.graphObject : null;
    }

    @Override
    public long getItemId(int position) {
        
        
        
        SectionAndItem sectionAndItem = getSectionAndItem(position);
        if (sectionAndItem != null && sectionAndItem.graphObject != null) {
            String id = getIdOfGraphObject(sectionAndItem.graphObject);
            if (id != null) {
                try {
                    return Long.parseLong(id);
                } catch (NumberFormatException e) {
                    
                }
            }
        }
        return 0;
    }

    @Override
    public int getViewTypeCount() {
        return 3;
    }

    @Override
    public int getItemViewType(int position) {
        SectionAndItem sectionAndItem = getSectionAndItem(position);
        switch (sectionAndItem.getType()) {
            case SECTION_HEADER:
                return HEADER_VIEW_TYPE;
            case GRAPH_OBJECT:
                return GRAPH_OBJECT_VIEW_TYPE;
            case ACTIVITY_CIRCLE:
                return ACTIVITY_CIRCLE_VIEW_TYPE;
            default:
                throw new FacebookException("Unexpected type of section and item.");
        }
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        SectionAndItem sectionAndItem = getSectionAndItem(position);

        switch (sectionAndItem.getType()) {
            case SECTION_HEADER:
                return getSectionHeaderView(sectionAndItem.sectionKey, convertView, parent);
            case GRAPH_OBJECT:
                return getGraphObjectView(sectionAndItem.graphObject, convertView, parent);
            case ACTIVITY_CIRCLE:
                
                assert cursor.areMoreObjectsAvailable() && (dataNeededListener != null);
                dataNeededListener.onDataNeeded();
                return getActivityCircleView(convertView, parent);
            default:
                throw new FacebookException("Unexpected type of section and item.");
        }
    }

    @Override
    public Object[] getSections() {
        if (displaySections) {
            return sectionKeys.toArray();
        } else {
            return new Object[0];
        }
    }

    @Override
    public int getPositionForSection(int section) {
        if (displaySections) {
            section = Math.max(0, Math.min(section, sectionKeys.size() - 1));
            if (section < sectionKeys.size()) {
                return getPosition(sectionKeys.get(section), null);
            }
        }
        return 0;
    }

    @Override
    public int getSectionForPosition(int position) {
        SectionAndItem sectionAndItem = getSectionAndItem(position);
        if (sectionAndItem != null &&
                sectionAndItem.getType() != SectionAndItem.Type.ACTIVITY_CIRCLE) {
            return Math.max(0, Math.min(sectionKeys.indexOf(sectionAndItem.sectionKey), sectionKeys.size() - 1));
        }
        return 0;
    }

    public List<JSONObject> getGraphObjectsById(Collection<String> ids) {
        Set<String> idSet = new HashSet<String>();
        idSet.addAll(ids);

        ArrayList<JSONObject> result = new ArrayList<JSONObject>(idSet.size());
        for (String id : idSet) {
            JSONObject graphObject = graphObjectsById.get(id);
            if (graphObject != null) {
                result.add(graphObject);
            }
        }

        return result;
    }

    private void downloadProfilePicture(
            final String profileId,
            Uri pictureUri,
            final ImageView imageView) {
        if (pictureUri == null) {
            return;
        }

        
        
        
        
        boolean prefetching = imageView == null;
        if (prefetching || !pictureUri.equals(imageView.getTag())) {
            if (!prefetching) {
                
                
                imageView.setTag(profileId);
                imageView.setImageResource(getDefaultPicture());
            }

            ImageRequest.Builder builder = new ImageRequest.Builder(
                    context.getApplicationContext(),
                    pictureUri)
                    .setCallerTag(this)
                    .setCallback(
                            new ImageRequest.Callback() {
                                @Override
                                public void onCompleted(ImageResponse response) {
                                    processImageResponse(response, profileId, imageView);
                                }
                            });

            ImageRequest newRequest = builder.build();
            pendingRequests.put(profileId, newRequest);

            ImageDownloader.downloadAsync(newRequest);
        }
    }

    private void callOnErrorListener(Exception exception) {
        if (onErrorListener != null) {
            if (!(exception instanceof FacebookException)) {
                exception = new FacebookException(exception);
            }
            onErrorListener.onError(this, (FacebookException) exception);
        }
    }

    private void processImageResponse(ImageResponse response, String graphObjectId, ImageView imageView) {
        pendingRequests.remove(graphObjectId);
        if (response.getError() != null) {
            callOnErrorListener(response.getError());
        }

        if (imageView == null) {
            
            if (response.getBitmap() != null) {
                
                if (prefetchedPictureCache.size() >= MAX_PREFETCHED_PICTURES) {
                    
                    String oldestId = prefetchedProfilePictureIds.remove(0);
                    prefetchedPictureCache.remove(oldestId);
                }
                prefetchedPictureCache.put(graphObjectId, response);
            }
        } else if (graphObjectId.equals(imageView.getTag())) {
            Exception error = response.getError();
            Bitmap bitmap = response.getBitmap();
            if (error == null && bitmap != null) {
                imageView.setImageBitmap(bitmap);
                imageView.setTag(response.getRequest().getImageUri());
            }
        }
    }

    private static int compareGraphObjects(JSONObject a, JSONObject b, Collection<String> sortFields,
            Collator collator) {
        for (String sortField : sortFields) {
            String sa = a.optString(sortField);
            String sb = b.optString(sortField);

            if (sa != null && sb != null) {
                int result = collator.compare(sa, sb);
                if (result != 0) {
                    return result;
                }
            } else if (!(sa == null && sb == null)) {
                return (sa == null) ? -1 : 1;
            }
        }
        return 0;
    }
}

<code block>


package com.facebook.scrumptious.picker;

import android.app.Activity;
import android.content.Context;
import android.content.res.TypedArray;
import android.location.Location;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.text.Editable;
import android.text.TextUtils;
import android.text.TextWatcher;
import android.util.AttributeSet;
import android.view.View;
import android.view.ViewGroup;
import android.view.inputmethod.InputMethodManager;
import android.widget.EditText;
import android.widget.ListView;
import com.facebook.*;
import com.facebook.appevents.AppEventsLogger;
import com.facebook.scrumptious.R;
import com.facebook.internal.AnalyticsEvents;
import com.facebook.internal.Logger;
import com.facebook.internal.Utility;

import org.json.JSONObject;

import java.util.*;

public class PlacePickerFragment extends PickerFragment {
    
    public static final String RADIUS_IN_METERS_BUNDLE_KEY = "com.facebook.scrumptious.widget.PlacePickerFragment.RadiusInMeters";
    
    public static final String RESULTS_LIMIT_BUNDLE_KEY = "com.facebook.scrumptious.widget.PlacePickerFragment.ResultsLimit";
    
    public static final String SEARCH_TEXT_BUNDLE_KEY = "com.facebook.scrumptious.widget.PlacePickerFragment.SearchText";
    
    public static final String LOCATION_BUNDLE_KEY = "com.facebook.scrumptious.widget.PlacePickerFragment.Location";
    
    public static final String SHOW_SEARCH_BOX_BUNDLE_KEY = "com.facebook.scrumptious.widget.PlacePickerFragment.ShowSearchBox";

    
    public static final int DEFAULT_RADIUS_IN_METERS = 1000;
    
    public static final int DEFAULT_RESULTS_LIMIT = 100;

    private static final int searchTextTimerDelayInMilliseconds = 2 * 1000;

    private static final String ID = "id";
    private static final String NAME = "name";
    private static final String LOCATION = "location";
    private static final String CATEGORY = "category";
    private static final String WERE_HERE_COUNT = "were_here_count";
    private static final String TAG = "PlacePickerFragment";

    private Location location;
    private int radiusInMeters = DEFAULT_RADIUS_IN_METERS;
    private int resultsLimit = DEFAULT_RESULTS_LIMIT;
    private String searchText;
    private Timer searchTextTimer;
    private boolean hasSearchTextChangedSinceLastQuery;
    private boolean showSearchBox = true;
    private EditText searchBox;

    
    public PlacePickerFragment() {
        super(R.layout.picker_placepickerfragment);
    }

    
    public Location getLocation() {
        return location;
    }

    
    public void setLocation(Location location) {
        this.location = location;
    }

    
    public int getRadiusInMeters() {
        return radiusInMeters;
    }

    
    public void setRadiusInMeters(int radiusInMeters) {
        this.radiusInMeters = radiusInMeters;
    }

    
    public int getResultsLimit() {
        return resultsLimit;
    }

    
    public void setResultsLimit(int resultsLimit) {
        this.resultsLimit = resultsLimit;
    }

    
    public String getSearchText() {
        return searchText;
    }

    
    public void setSearchText(String searchText) {
        if (TextUtils.isEmpty(searchText)) {
            searchText = null;
        }
        this.searchText = searchText;
        if (this.searchBox != null) {
            this.searchBox.setText(searchText);
        }
    }

    
    public void onSearchBoxTextChanged(String searchText, boolean forceReloadEventIfSameText) {
        if (!forceReloadEventIfSameText && Utility.stringsEqualOrEmpty(this.searchText, searchText)) {
            return;
        }

        if (TextUtils.isEmpty(searchText)) {
            searchText = null;
        }
        this.searchText = searchText;

        
        
        
        
        hasSearchTextChangedSinceLastQuery = true;
        if (searchTextTimer == null) {
            searchTextTimer = createSearchTextTimer();
        }
    }

    
    public JSONObject getSelection() {
        Collection<JSONObject> selection = getSelectedGraphObjects();
        return (selection != null && !selection.isEmpty()) ? selection.iterator().next() : null;
    }

    @Override
    public void setSettingsFromBundle(Bundle inState) {
        super.setSettingsFromBundle(inState);
        if (inState != null) {
            setRadiusInMeters(inState.getInt(RADIUS_IN_METERS_BUNDLE_KEY, radiusInMeters));
            setResultsLimit(inState.getInt(RESULTS_LIMIT_BUNDLE_KEY, resultsLimit));
            if (inState.containsKey(SEARCH_TEXT_BUNDLE_KEY)) {
                setSearchText(inState.getString(SEARCH_TEXT_BUNDLE_KEY));
            }
            if (inState.containsKey(LOCATION_BUNDLE_KEY)) {
                Location location = inState.getParcelable(LOCATION_BUNDLE_KEY);
                setLocation(location);
            }
            showSearchBox = inState.getBoolean(SHOW_SEARCH_BOX_BUNDLE_KEY, showSearchBox);
        }
    }

    @Override
    public void onInflate(Activity activity, AttributeSet attrs, Bundle savedInstanceState) {
        super.onInflate(activity, attrs, savedInstanceState);
        TypedArray a = activity.obtainStyledAttributes(attrs, R.styleable.picker_place_picker_fragment);

        setRadiusInMeters(a.getInt(R.styleable.picker_place_picker_fragment_radius_in_meters, radiusInMeters));
        setResultsLimit(a.getInt(R.styleable.picker_place_picker_fragment_results_limit, resultsLimit));
        if (a.hasValue(R.styleable.picker_place_picker_fragment_results_limit)) {
            setSearchText(a.getString(R.styleable.picker_place_picker_fragment_search_text));
        }
        showSearchBox = a.getBoolean(R.styleable.picker_place_picker_fragment_show_search_box, showSearchBox);

        a.recycle();
    }

    @Override
    void setupViews(ViewGroup view) {
        if (showSearchBox) {
            ListView listView = (ListView) view.findViewById(R.id.com_facebook_picker_list_view);

            View searchHeaderView = getActivity().getLayoutInflater().inflate(
                    R.layout.picker_search_box, listView, false);

            listView.addHeaderView(searchHeaderView, null, false);

            searchBox = (EditText) view.findViewById(R.id.com_facebook_picker_search_text);

            searchBox.addTextChangedListener(new SearchTextWatcher());
            if (!TextUtils.isEmpty(searchText)) {
                searchBox.setText(searchText);
            }
        }
    }

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);

        if (searchBox != null) {
            InputMethodManager imm = (InputMethodManager)getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);
            imm.showSoftInput(searchBox, InputMethodManager.SHOW_IMPLICIT);
        }
    }

    @Override
    public void onDetach() {
        super.onDetach();

        if (searchBox != null) {
            InputMethodManager imm = (InputMethodManager)getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);
            imm.hideSoftInputFromWindow(searchBox.getWindowToken(), 0);
        }
    }

    void saveSettingsToBundle(Bundle outState) {
        super.saveSettingsToBundle(outState);

        outState.putInt(RADIUS_IN_METERS_BUNDLE_KEY, radiusInMeters);
        outState.putInt(RESULTS_LIMIT_BUNDLE_KEY, resultsLimit);
        outState.putString(SEARCH_TEXT_BUNDLE_KEY, searchText);
        outState.putParcelable(LOCATION_BUNDLE_KEY, location);
        outState.putBoolean(SHOW_SEARCH_BOX_BUNDLE_KEY, showSearchBox);
    }

    @Override
    void onLoadingData() {
        hasSearchTextChangedSinceLastQuery = false;
    }

    @Override
    GraphRequest getRequestForLoadData() {
        return createRequest(location, radiusInMeters, resultsLimit, searchText, extraFields);
    }

    @Override
    String getDefaultTitleText() {
        return getResources().getString(R.string.nearby);
    }

    @Override
    void logAppEvents(boolean doneButtonClicked) {
        AppEventsLogger logger = AppEventsLogger.newLogger(this.getActivity(),
                AccessToken.getCurrentAccessToken().getToken());
        Bundle parameters = new Bundle();

        
        
        
        String outcome = doneButtonClicked ? AnalyticsEvents.PARAMETER_DIALOG_OUTCOME_VALUE_COMPLETED :
                AnalyticsEvents.PARAMETER_DIALOG_OUTCOME_VALUE_UNKNOWN;
        parameters.putString(AnalyticsEvents.PARAMETER_DIALOG_OUTCOME, outcome);
        parameters.putInt("num_places_picked", (getSelection() != null) ? 1 : 0);

        logger.logSdkEvent(AnalyticsEvents.EVENT_PLACE_PICKER_USAGE, null, parameters);
    }

    @Override
    PickerFragmentAdapter createAdapter() {
        PickerFragmentAdapter adapter = new PickerFragmentAdapter(
                this.getActivity()) {
            @Override
            protected CharSequence getSubTitleOfGraphObject(JSONObject graphObject) {
                String category = graphObject.optString(CATEGORY);
                int wereHereCount = graphObject.optInt(WERE_HERE_COUNT);

                String result = null;
                if (category != null && wereHereCount != 0) {
                    result = getString(R.string.picker_placepicker_subtitle_format, category, wereHereCount);
                } else if (category == null && wereHereCount != 0) {
                    result = getString(R.string.picker_placepicker_subtitle_were_here_only_format, wereHereCount);
                } else if (category != null && wereHereCount == 0) {
                    result = getString(R.string.picker_placepicker_subtitle_catetory_only_format, category);
                }
                return result;
            }

            @Override
            protected int getGraphObjectRowLayoutId(JSONObject graphObject) {
                return R.layout.picker_placepickerfragment_list_row;
            }

            @Override
            protected int getDefaultPicture() {
                return R.drawable.picker_place_default_icon;
            }

        };
        adapter.setShowCheckbox(false);
        adapter.setShowPicture(getShowPictures());
        return adapter;
    }

    @Override
    LoadingStrategy createLoadingStrategy() {
        return new AsNeededLoadingStrategy();
    }

    @Override
    SelectionStrategy createSelectionStrategy() {
        return new SingleSelectionStrategy();
    }

    private GraphRequest createRequest(Location location, int radiusInMeters, int resultsLimit,
                                  String searchText, Set<String> extraFields) {
        AccessToken accessToken = AccessToken.getCurrentAccessToken();
        GraphRequest request = GraphRequest.newPlacesSearchRequest(accessToken, location, radiusInMeters,
                resultsLimit, searchText, null);

        Set<String> fields = new HashSet<String>(extraFields);
        String[] requiredFields = new String[]{
                ID,
                NAME,
                LOCATION,
                CATEGORY,
                WERE_HERE_COUNT
        };
        fields.addAll(Arrays.asList(requiredFields));

        String pictureField = adapter.getPictureFieldSpecifier();
        if (pictureField != null) {
            fields.add(pictureField);
        }

        Bundle parameters = request.getParameters();
        parameters.putString("fields", TextUtils.join(",", fields));
        request.setParameters(parameters);

        return request;
    }

    private Timer createSearchTextTimer() {
        Timer timer = new Timer();
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                onSearchTextTimerTriggered();
            }
        }, 0, searchTextTimerDelayInMilliseconds);

        return timer;
    }

    private void onSearchTextTimerTriggered() {
        if (hasSearchTextChangedSinceLastQuery) {
            Handler handler = new Handler(Looper.getMainLooper());
            handler.post(new Runnable() {
                @Override
                public void run() {
                    FacebookException error = null;
                    try {
                        loadData(true);
                    } catch (FacebookException fe) {
                        error = fe;
                    } catch (Exception e) {
                        error = new FacebookException(e);
                    } finally {
                        if (error != null) {
                            OnErrorListener onErrorListener = getOnErrorListener();
                            if (onErrorListener != null) {
                                onErrorListener.onError(PlacePickerFragment.this, error);
                            } else {
                                Logger.log(LoggingBehavior.REQUESTS, TAG, "Error loading data : %s", error);
                            }
                        }
                    }
                }
            });
        } else {
            
            
            searchTextTimer.cancel();
            searchTextTimer = null;
        }
    }

    private class AsNeededLoadingStrategy extends LoadingStrategy {
        @Override
        public void attach(GraphObjectAdapter adapter) {
            super.attach(adapter);

            this.adapter.setDataNeededListener(new GraphObjectAdapter.DataNeededListener() {
                @Override
                public void onDataNeeded() {
                    
                    
                    if (!loader.isLoading()) {
                        loader.followNextLink();
                    }
                }
            });
        }

        @Override
        protected void onLoadFinished(GraphObjectPagingLoader loader, GraphObjectCursor data) {
            super.onLoadFinished(loader, data);

            
            
            if (data == null || loader.isLoading()) {
                return;
            }

            hideActivityCircle();
        }
    }

    private class SearchTextWatcher implements TextWatcher {

        @Override
        public void beforeTextChanged(CharSequence s, int start, int count, int after) {
        }

        @Override
        public void onTextChanged(CharSequence s, int start, int before, int count) {
            onSearchBoxTextChanged(s.toString(), false);
        }

        @Override
        public void afterTextChanged(Editable s) {
        }
    }
}

<code block>


package com.facebook.scrumptious.usersettings;

import android.content.Intent;
import android.graphics.Bitmap;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.text.TextUtils;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

import com.facebook.AccessToken;
import com.facebook.AccessTokenTracker;
import com.facebook.CallbackManager;
import com.facebook.GraphRequest;
import com.facebook.GraphResponse;
import com.facebook.internal.ImageDownloader;
import com.facebook.internal.ImageRequest;
import com.facebook.internal.ImageResponse;
import com.facebook.scrumptious.R;
import com.facebook.login.widget.LoginButton;

import org.json.JSONObject;


public final class UserSettingsFragment extends Fragment {

    private static final String NAME = "name";
    private static final String ID = "id";
    private static final String PICTURE = "picture";
    private static final String FIELDS = "fields";
    
    private static final String REQUEST_FIELDS =
            TextUtils.join(",", new String[] {ID, NAME, PICTURE});

    private AccessTokenTracker accessTokenTracker;
    private CallbackManager callbackManager;

    private LoginButton loginButton;
    private TextView connectedStateLabel;
    private JSONObject user;
    private Drawable userProfilePic;
    private String userProfilePicID;

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        accessTokenTracker = new AccessTokenTracker() {
            @Override
            protected void onCurrentAccessTokenChanged(AccessToken oldAccessToken,
                                                       AccessToken currentAccessToken) {
                fetchUserInfo();
                updateUI();

            }
        };
        callbackManager = CallbackManager.Factory.create();
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        callbackManager.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        accessTokenTracker.stopTracking();
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.usersettings_fragment, container, false);
        loginButton = (LoginButton) view.findViewById(R.id.usersettings_fragment_login_button);
        loginButton.setFragment(this);

        connectedStateLabel = (TextView) view.findViewById(R.id.usersettings_fragment_profile_name);
        
        
        if (view.getBackground() == null) {
            view.setBackgroundColor(getResources().getColor(R.color.com_facebook_blue));
        } else {
            view.getBackground().setDither(true);
        }
        return view;
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setRetainInstance(true);
    }

    
    @Override
    public void onResume() {
        super.onResume();
        fetchUserInfo();
        updateUI();
    }

    private void fetchUserInfo() {
        final AccessToken accessToken = AccessToken.getCurrentAccessToken();
        if (accessToken != null) {
            GraphRequest request = GraphRequest.newMeRequest(
                    accessToken, new GraphRequest.GraphJSONObjectCallback() {
                        @Override
                        public void onCompleted(JSONObject me, GraphResponse response) {
                            user = me;
                            updateUI();
                        }
                    });
            Bundle parameters = new Bundle();
            parameters.putString(FIELDS, REQUEST_FIELDS);
            request.setParameters(parameters);
            GraphRequest.executeBatchAsync(request);
        } else {
            user = null;
        }
    }
    
    private void updateUI() {
        if (!isAdded()) {
            return;
        }
        if (AccessToken.getCurrentAccessToken() != null) {
            connectedStateLabel.setTextColor(getResources().getColor(
                    R.color.usersettings_fragment_connected_text_color));
            connectedStateLabel.setShadowLayer(1f, 0f, -1f,
                    getResources().getColor(
                            R.color.usersettings_fragment_connected_shadow_color));
            
            if (user != null) {
                ImageRequest request = getImageRequest();
                if (request != null) {
                    Uri requestUri = request.getImageUri();
                    
                    if (!requestUri.equals(connectedStateLabel.getTag())) {
                        if (user.optString("id").equals(userProfilePicID)) {
                            connectedStateLabel.setCompoundDrawables(
                                    null, userProfilePic, null, null);
                            connectedStateLabel.setTag(requestUri);
                        } else {
                            ImageDownloader.downloadAsync(request);
                        }
                    }
                }
                connectedStateLabel.setText(user.optString("name"));
            } else {
                connectedStateLabel.setText(getResources().getString(
                        R.string.usersettings_fragment_logged_in));
                Drawable noProfilePic = getResources().getDrawable(
                        R.drawable.profile_default_icon);
                noProfilePic.setBounds(0, 0,
                        getResources().getDimensionPixelSize(
                                R.dimen.usersettings_fragment_profile_picture_width),
                        getResources().getDimensionPixelSize(
                                R.dimen.usersettings_fragment_profile_picture_height));
                connectedStateLabel.setCompoundDrawables(null, noProfilePic, null, null);
            }
        } else {
            int textColor = getResources().getColor(
                    R.color.usersettings_fragment_not_connected_text_color);
            connectedStateLabel.setTextColor(textColor);
            connectedStateLabel.setShadowLayer(0f, 0f, 0f, textColor);
            connectedStateLabel.setText(getResources().getString(
                    R.string.usersettings_fragment_not_logged_in));
            connectedStateLabel.setCompoundDrawables(null, null, null, null);
            connectedStateLabel.setTag(null);
        }
    }

    private ImageRequest getImageRequest() {
        ImageRequest request = null;
        ImageRequest.Builder requestBuilder = new ImageRequest.Builder(
                getActivity(),
                ImageRequest.getProfilePictureUri(
                        user.optString("id"),
                        getResources().getDimensionPixelSize(
                                R.dimen.usersettings_fragment_profile_picture_width),
                        getResources().getDimensionPixelSize(
                                R.dimen.usersettings_fragment_profile_picture_height)));

        request = requestBuilder.setCallerTag(this)
                .setCallback(
                        new ImageRequest.Callback() {
                            @Override
                            public void onCompleted(ImageResponse response) {
                                processImageResponse(user.optString("id"), response);
                            }
                        })
                .build();
        return request;
    }

    private void processImageResponse(String id, ImageResponse response) {
        if (response != null) {
            Bitmap bitmap = response.getBitmap();
            if (bitmap != null) {
                BitmapDrawable drawable = new BitmapDrawable(
                        UserSettingsFragment.this.getResources(), bitmap);
                drawable.setBounds(0, 0,
                        getResources().getDimensionPixelSize(
                                R.dimen.usersettings_fragment_profile_picture_width),
                        getResources().getDimensionPixelSize(
                                R.dimen.usersettings_fragment_profile_picture_height));
                userProfilePic = drawable;
                userProfilePicID = id;
                connectedStateLabel.setCompoundDrawables(null, drawable, null, null);
                connectedStateLabel.setTag(response.getRequest().getImageUri());
            }
        }
    }
}

<code block>


package com.facebook.iconicus;

import android.net.Uri;
import android.util.Log;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;


public class GameBoard {
    public static final int BOARD_ROWS = 9; 
    public static final int GROUP_ROWS = 3;
    public static final int BOARD_SIZE = BOARD_ROWS * BOARD_ROWS; 
    public static final int EMPTY_PIECE = 0;
    public static final int MIN_VALUE = 1;
    public static final int MAX_VALUE = 9;

    private static final Uri SHARE_URI = Uri.parse("https:
    private static final String DATA_KEY = "data";
    private static final String LOCKED_KEY = "locked";

    private static final int [] SEED_GRID = {
            1,2,3,4,5,6,7,8,9,
            4,5,6,7,8,9,1,2,3,
            7,8,9,1,2,3,4,5,6,
            2,3,4,5,6,7,8,9,1,
            5,6,7,8,9,1,2,3,4,
            8,9,1,2,3,4,5,6,7,
            3,4,5,6,7,8,9,1,2,
            6,7,8,9,1,2,3,4,5,
            9,1,2,3,4,5,6,7,8
    };

    private int[] board = new int[BOARD_SIZE];
    private boolean[] lockedPositions = new boolean[BOARD_SIZE];

    private GameBoard(int[] board, boolean[] lockedPositions) {
        if (board.length != this.board.length
                || lockedPositions.length != this.lockedPositions.length) {
            throw new IllegalArgumentException("boards are not the same size");
        }
        System.arraycopy(board, 0, this.board, 0, board.length);
        System.arraycopy(lockedPositions, 0, this.lockedPositions, 0, lockedPositions.length);
    }

    private GameBoard(int[] board) {
        if (board.length != this.board.length) {
            throw new IllegalArgumentException("boards are not the same size");
        }
        for (int i = 0; i < BOARD_SIZE; i++) {
            this.board[i] = board[i];
            this.lockedPositions[i] = (this.board[i] != EMPTY_PIECE);
        }
    }

    
    public static GameBoard generateBoard(final int openPositions) {
        Random random = new Random(System.currentTimeMillis());
        int [] board = new int[BOARD_SIZE];
        System.arraycopy(SEED_GRID, 0, board, 0, BOARD_SIZE);

        for (int i = 0; i < 9; i++) {
            shuffleGrid(random, board);
        }

        List<Integer> remainingPositions = new ArrayList<>(BOARD_SIZE);
        for (int i = 0; i < BOARD_SIZE; i++) {
            remainingPositions.add(i);
        }

        for (int i = 0; i < openPositions; i++) {
            removeOpenPosition(random, board, remainingPositions);
        }

        return new GameBoard(board);
    }

    
    public static GameBoard fromUri(final Uri uri) {
        String data = uri.getQueryParameter(DATA_KEY);
        if (data != null) {
            int [] newBoard = decodeBoard(data);
            String locked = uri.getQueryParameter(LOCKED_KEY);
            boolean [] lockedArr;

            if (locked != null) {
                lockedArr = decodeLockedPositions(locked);
            } else {
                
                
                lockedArr = new boolean[BOARD_SIZE];
                for (int i = 0; i < lockedArr.length; i++) {
                    if (newBoard[i] != EMPTY_PIECE) {
                        lockedArr[i] = true;
                    }
                }
            }
            return new GameBoard(newBoard, lockedArr);
        }
        return null;
    }

    
    public void clearBoard() {
        for (int i = 0; i < board.length; i++) {
            if (!lockedPositions[i]) {
                board[i] = EMPTY_PIECE;
            }
        }
    }

    
    public boolean isLocked(final int position) {
        return lockedPositions[position];
    }

    
    public boolean setValue(final int value, final int position) {
        if (!isLocked(position)
                && ((value >= MIN_VALUE && value <= MAX_VALUE) || value == EMPTY_PIECE)) {
            board[position] = value;
            return true;
        }
        return false;
    }

    
    public int getValue(final int position) {
        if (position < 0 || position >= BOARD_SIZE) {
            return EMPTY_PIECE;
        }
        return board[position];
    }

    
    public String getValueAsString(final int position) {
        int value = getValue(position);
        if (value < MIN_VALUE || value > MAX_VALUE) {
            return "";
        }
        return "" + value;
    }

    
    public boolean isEmpty(final int position) {
        return board[position] == EMPTY_PIECE;
    }

    
    public boolean isValid(final int position) {
        if (isEmpty(position)) {
            return true;
        }
        return validateRow(position) && validateColumn(position) && validateGroup(position);
    }

    
    public Uri toUri() {
        Uri.Builder shareUri = SHARE_URI.buildUpon();
        shareUri.appendQueryParameter(DATA_KEY, encodeBoard());
        shareUri.appendQueryParameter(LOCKED_KEY, encodeLockedPositions());
        return shareUri.build();
    }

    private String encodeBoard() {
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < board.length; i++) {
            builder.append(board[i]);
        }
        return builder.toString();
    }

    private static int[] decodeBoard(String input) {
        int [] newBoard = new int[BOARD_SIZE];
        Arrays.fill(newBoard, EMPTY_PIECE);
        if (input.length() == BOARD_SIZE) {
            for (int i = 0; i < input.length(); i++) {
                newBoard[i] = Integer.parseInt(input.substring(i, i + 1));
            }
        }
        return newBoard;
    }

    private String encodeLockedPositions() {
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < lockedPositions.length; i++) {
            builder.append(lockedPositions[i] ? 1 : 0);;;
        }
        return builder.toString();
    }

    private static boolean[] decodeLockedPositions(String input) {
        boolean [] locked = new boolean[BOARD_SIZE];
        Arrays.fill(locked, false);
        if (input.length() == BOARD_SIZE) {
            for (int i = 0; i < input.length(); i++) {
                locked[i] = (input.charAt(i) == '1');
            }
        }
        return locked;
    }

    private boolean validateRow(final int position) {
        int startPos = (position / BOARD_ROWS) * BOARD_ROWS;
        for (int i = 0; i < BOARD_ROWS; i++) {
            if (!checkIsValid(position, startPos + i)) {
                return false;
            }
        }
        return true;
    }

    private boolean validateColumn(final int position) {
        int startPos = position % BOARD_ROWS;
        for (int i = 0; i < BOARD_ROWS; i++) {
            if (!checkIsValid(position, startPos + (i * BOARD_ROWS))) {
                return false;
            }
        }
        return true;
    }

    private boolean validateGroup(final int position) {
        int row = position / BOARD_ROWS;
        int column = position % BOARD_ROWS;

        int group = (row / GROUP_ROWS) * GROUP_ROWS + (column / GROUP_ROWS);
        int startRow = (group / GROUP_ROWS) * GROUP_ROWS;
        int startColumn = (group % GROUP_ROWS) * GROUP_ROWS;

        for (int i = 0; i < GROUP_ROWS; i++) {
            for (int j = 0; j < GROUP_ROWS; j++) {
                if (!checkIsValid(position, (startRow + i) * 9 + startColumn + j)) {
                    return false;
                }
            }
        }
        return true;
    }

    private boolean checkIsValid(final int position1, final int position2) {
        return (position1 == position2) || (board[position1] != board[position2]);
    }

    private static void shuffleGrid(final Random random, final int[] board) {
        switch (random.nextInt(5)) {
            case 0:
                shuffleRow(random, board);
                break;
            case 1:
                shuffleRowGroup(random, board);
                break;
            case 2:
                shuffleColumn(random, board);
                break;
            case 3:
                shuffleColumnGroup(random, board);
                break;
            case 4:
                transpose(board);
                break;
            default:
                break;
        }
    }

    private static void shuffleRow(final Random random, final int[] board) {
        
        
        int group = random.nextInt(GROUP_ROWS);
        int row1 = random.nextInt(GROUP_ROWS);
        int row2 = randomOther(random, row1, GROUP_ROWS);

        int realRow1 = group * GROUP_ROWS + row1;
        int realRow2 = group * GROUP_ROWS + row2;

        Range range1 = new Range(realRow1 * BOARD_ROWS, BOARD_ROWS);
        Range range2 = new Range(realRow2 * BOARD_ROWS, BOARD_ROWS);
        swap(board, range1, range2);
    }

    private static void shuffleRowGroup(final Random random, final int[] board) {
        
        int group1 = random.nextInt(GROUP_ROWS);
        int group2 = randomOther(random, group1, GROUP_ROWS);

        Range range1 = new Range(group1 * GROUP_ROWS * BOARD_ROWS, GROUP_ROWS * BOARD_ROWS);
        Range range2 = new Range(group2 * GROUP_ROWS * BOARD_ROWS, GROUP_ROWS * BOARD_ROWS);
        swap(board, range1, range2);
    }

    private static void shuffleColumn(final Random random, final int[] board) {
        
        
        int group = random.nextInt(GROUP_ROWS);
        int col1 = random.nextInt(GROUP_ROWS);
        int col2 = randomOther(random, col1, GROUP_ROWS);

        int realCol1 = group * GROUP_ROWS + col1;
        int realCol2 = group * GROUP_ROWS + col2;

        swapColumn(board, realCol1, realCol2);
    }

    private static void shuffleColumnGroup(final Random random, final int[] board) {
        
        int group1 = random.nextInt(GROUP_ROWS);
        int group2 = randomOther(random, group1, GROUP_ROWS);

        for (int i = 0; i < GROUP_ROWS; i++) {
            int realCol1 = group1 * GROUP_ROWS + i;
            int realCol2 = group2 * GROUP_ROWS + i;
            swapColumn(board, realCol1, realCol2);
        }
    }

    private static void transpose(final int[] board) {
        for (int row = 0; row < BOARD_ROWS; ++row) {
            for (int col = row + 1; col < BOARD_ROWS; ++col) {
                int index1 = (row * BOARD_ROWS) + col;
                int index2 = (col * BOARD_ROWS) + row;
                swapPosition(board, index1, index2);
            }
        }
    }

    private static int randomOther(final Random random, final int currentValue, final int space) {
        return ((currentValue % space) + (random.nextInt(space - 1) + 1)) % space;
    }

    private static void swap(final int[] board, final Range range1, final Range range2) {
        if (range1.getSize() != range2.getSize()) {
            return;
        }
        int[] range2Copy = Arrays.copyOfRange(board, range2.getStart(), range2.getEnd());
        System.arraycopy(board, range1.getStart(), board, range2.getStart(), range1.getSize());
        System.arraycopy(range2Copy, 0, board, range1.getStart(), range1.getSize());
    }

    private static void swapColumn(final int[] board, final int col1, final int col2) {
        for (int i = 0; i < BOARD_ROWS; i++) {
            swapPosition(board, (i * BOARD_ROWS) + col1, (i * BOARD_ROWS) + col2);
        }
    }

    private static void swapPosition(final int[] board, final int pos1, final int pos2) {
        int val2 = board[pos2];
        board[pos2] = board[pos1];
        board[pos1] = val2;
    }

    private static void removeOpenPosition(
            final Random random,
            final int[] board,
            final List<Integer> remainingPositions) {
        int index = random.nextInt(remainingPositions.size());
        int position = remainingPositions.remove(index);
        board[position] = EMPTY_PIECE;
    }

    private static class Range {
        private int start;
        private int size;
        private int end;

        public Range(final int start, final int size) {
            this.start = start;
            this.size = size;
            this.end = start + size;
        }

        public int getStart() {
            return start;
        }

        public int getSize() {
            return size;
        }

        public int getEnd() {
            return end;
        }
    }
}

<code block>


package com.facebook.iconicus;

import android.content.Context;
import android.content.Intent;
import android.graphics.drawable.Drawable;
import android.media.Image;
import android.net.Uri;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.BaseAdapter;
import android.widget.GridView;
import android.widget.ImageView;
import android.widget.TextView;
import android.widget.Toast;

import bolts.AppLinks;

public class GameController {

    private static final int NUM_OPEN_POSITIONS = 50;

    private static boolean iconsInitialized = false;
    private static Drawable[] validIcons = new Drawable[GameBoard.BOARD_ROWS + 1];

    private Context context;
    private GameBoard board;
    private GridView boardView;
    private GridView selectionView;
    private BoardAdapter boardAdapter;
    private SelectionAdapter selectionAdapter;
    private int selectedNum;
    private View selectedView;


    public GameController(final Context context, final Intent intent) {
        this.context = context;
        initializeIcons();
        board = handleDeepLink(context, intent);
        if (board == null) {
            board = GameBoard.generateBoard(NUM_OPEN_POSITIONS);
        }
        resetSelection();
    }

    public void setBoardView(final GridView boardView) {
        this.boardView = boardView;
        boardAdapter = new BoardAdapter();
        this.boardView.setAdapter(boardAdapter);
        this.boardView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
            public void onItemClick(AdapterView<?> parent, View v,
                                    int position, long id) {
                if (selectedNum >= 0) {
                    if (board.isLocked(position)) {
                        Toast.makeText(context.getApplicationContext(),
                                R.string.position_locked,
                                Toast.LENGTH_SHORT).show();
                    } else {
                        board.setValue(selectedNum, position);
                        dataSetChanged();
                    }
                } else {
                    Toast.makeText(context.getApplicationContext(),
                            R.string.nothing_selected,
                            Toast.LENGTH_SHORT).show();
                }
            }
        });

    }

    public void setSelectionView(final GridView selectionView) {
        this.selectionView = selectionView;
        selectionAdapter = new SelectionAdapter();
        this.selectionView.setAdapter(selectionAdapter);
        this.selectionView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
            public void onItemClick(AdapterView<?> parent, View v,
                                    int position, long id) {
                if (selectedNum != position) {
                    resetSelection();
                    selectedNum = position;
                    v.setBackgroundResource(R.drawable.selected_icon_background);
                    selectedView = v;
                } else {
                    resetSelection();
                }
            }
        });
    }

    public void newGame() {
        board = GameBoard.generateBoard(NUM_OPEN_POSITIONS);
        dataSetChanged();
    }

    public void clearBoard() {
        board.clearBoard();
        dataSetChanged();
    }

    public Uri getShareUri() {
        return board.toUri();
    }

    private synchronized void initializeIcons() {
        if (iconsInitialized) {
            return;
        }
        validIcons[0] = null;
        validIcons[1] = context.getResources().getDrawable(R.drawable.tile1);
        validIcons[2] = context.getResources().getDrawable(R.drawable.tile2);
        validIcons[3] = context.getResources().getDrawable(R.drawable.tile3);
        validIcons[4] = context.getResources().getDrawable(R.drawable.tile4);
        validIcons[5] = context.getResources().getDrawable(R.drawable.tile5);
        validIcons[6] = context.getResources().getDrawable(R.drawable.tile6);
        validIcons[7] = context.getResources().getDrawable(R.drawable.tile7);
        validIcons[8] = context.getResources().getDrawable(R.drawable.tile8);
        validIcons[9] = context.getResources().getDrawable(R.drawable.tile9);
        iconsInitialized = true;
    }

    private GameBoard handleDeepLink(final Context context, final Intent intent) {
        Uri targetUri = AppLinks.getTargetUrlFromInboundIntent(context, intent);
        if (targetUri == null) {
            targetUri = intent.getData();
        }

        if (targetUri == null) {
            return null;
        }

        return GameBoard.fromUri(targetUri);
    }

    private void dataSetChanged() {
        if (boardAdapter != null) {
            boardAdapter.notifyDataSetChanged();
        }
    }

    private void resetSelection() {
        if (selectedView != null) {
            selectedView.setBackgroundResource(R.drawable.choice_icon_background);
        }
        selectedNum = GameBoard.EMPTY_PIECE;
        selectedView = null;
    }

    private void updateCell(final ImageView imageView, final int position) {
        imageView.setImageDrawable(validIcons[board.getValue(position)]);

        if (board.isLocked(position)) {
            imageView.setBackgroundResource(R.drawable.locked_icon_background);
        } else if (board.isEmpty(position)) {
            imageView.setBackgroundResource(R.drawable.default_icon_background);
        } else if (board.isValid(position)) {
            imageView.setBackgroundResource(R.drawable.valid_icon_background);
        } else {
            imageView.setBackgroundResource(R.drawable.invalid_icon_background);
        }
    }

    private class SelectionAdapter extends BaseAdapter {

        @Override
        public int getCount() {
            return GameBoard.BOARD_ROWS + 1;
        }

        @Override
        public Object getItem(int position) {
            return validIcons[position];
        }

        @Override
        public long getItemId(int position) {
            return position;
        }

        @Override
        public View getView(int position, View convertView, ViewGroup parent) {
            if (convertView != null) {
                return convertView;
            }

            ImageView view = (ImageView) View.inflate(context, R.layout.choice_cell, null);
            view.setImageDrawable(validIcons[position]);
            return view;
        }
    }

    private class BoardAdapter extends BaseAdapter {

        @Override
        public int getCount() {
            return GameBoard.BOARD_SIZE;
        }

        @Override
        public Object getItem(final int position) {
            return board.getValue(position);
        }

        @Override
        public long getItemId(final int position) {
            return position;
        }

        @Override
        public View getView(final int position, final View convertView, final ViewGroup parent) {
            if (convertView != null) {
                updateCell((ImageView) convertView, position);
                return convertView;
            }

            ImageView view = (ImageView) View.inflate(context, R.layout.grid_cell, null);

            updateCell(view, position);

            return view;
        }
    }
}

<code block>


package com.facebook.iconicus;

import android.app.Activity;
import android.content.ClipData;
import android.content.ClipboardManager;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.GridView;
import android.widget.Toast;

import com.facebook.FacebookSdk;
import com.facebook.share.model.ShareLinkContent;
import com.facebook.share.widget.SendButton;
import com.facebook.share.widget.ShareButton;

public class MainActivity extends Activity {

    private GridView board;
    private GridView validNumbers;

    private String[] numbers = new String[81];


    private GameController gameController;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        FacebookSdk.sdkInitialize(this);
        setContentView(R.layout.activity_main);

        gameController = new GameController(this, getIntent());

        board = (GridView) findViewById(R.id.board);

        validNumbers = (GridView) findViewById(R.id.valid_numbers);

        gameController.setBoardView(board);
        gameController.setSelectionView(validNumbers);

        Button newGame = (Button) findViewById(R.id.new_board);
        newGame.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                gameController.newGame();
            }
        });

        Button clearBoard = (Button) findViewById(R.id.clear_board);
        clearBoard.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                gameController.clearBoard();
            }
        });

        final ShareButton share = (ShareButton) findViewById(R.id.share_button);
        share.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                share.setShareContent(getLinkContent());
            }
        });

        final SendButton send = (SendButton) findViewById(R.id.send_button);
        send.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                send.setShareContent(getLinkContent());
            }
        });

        Button copy = (Button) findViewById(R.id.copy_button);
        copy.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                ClipboardManager clipboard = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE);
                ClipData clip = ClipData.newUri(
                        getContentResolver(), "Iconicus", gameController.getShareUri());
                clipboard.setPrimaryClip(clip);
                Toast.makeText(MainActivity.this, R.string.link_copied, Toast.LENGTH_SHORT).show();
            }
        });
    }

    private ShareLinkContent getLinkContent() {
        return new ShareLinkContent.Builder()
                .setContentUrl(gameController.getShareUri())
                .setContentTitle(getString(R.string.share_title))
                .setContentDescription(getString(R.string.share_description))
                .build();
    }

}

<code block>


package com.facebook.samples.rps;

public class RpsGameUtils {
    public enum RpsState {
        INIT,
        PLAYING,
        RESULT
    };

    public enum RpsResult {
        WIN(R.string.win, R.string.result_won),
        LOSS(R.string.loss, R.string.result_lost),
        TIE(R.string.tie, R.string.result_tied),
        INVALID(0, 0);

        private int id;
        private int resultId;

        private RpsResult(int stringId, int resultStringId) {
            id = stringId;
            resultId = resultStringId;
        }

        public int getStringId() {
            return id;
        }

        public int getResultStringId() {
            return resultId;
        }
    };

    public static final int ROCK = 0;
    public static final int PAPER = 1;
    public static final int SCISSORS = 2;
    public static final int INVALID_CHOICE = -1;
    public static final int SHOOT = 100;
    public static final int[] DRAWABLES_HUMAN =
            { R.drawable.left_rock, R.drawable.left_paper, R.drawable.left_scissors };
    public static final int[] DRAWABLES_COMPUTER =
            { R.drawable.right_rock, R.drawable.right_paper, R.drawable.right_scissors };
    public static final int[] STRINGS_TITLES =
            { R.string.rock, R.string.paper, R.string.scissors };
    public static final RpsResult[][] RESULTS =
            {
                    {RpsResult.TIE, RpsResult.LOSS, RpsResult.WIN},
                    {RpsResult.WIN, RpsResult.TIE, RpsResult.LOSS},
                    {RpsResult.LOSS, RpsResult.WIN, RpsResult.TIE}
            };
}

<code block>


package com.facebook.samples.rps;

import android.app.AlertDialog;
import android.content.DialogInterface;
import android.content.Intent;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.drawable.BitmapDrawable;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.support.v4.app.Fragment;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.*;

import com.facebook.*;
import com.facebook.login.DefaultAudience;
import com.facebook.login.LoginManager;
import com.facebook.login.LoginResult;
import com.facebook.share.ShareApi;
import com.facebook.share.Sharer;
import com.facebook.share.model.ShareContent;
import com.facebook.share.model.ShareLinkContent;
import com.facebook.share.model.ShareOpenGraphAction;
import com.facebook.share.model.ShareOpenGraphContent;
import com.facebook.share.model.ShareOpenGraphObject;
import com.facebook.share.model.SharePhoto;
import com.facebook.share.model.AppInviteContent;
import com.facebook.share.widget.AppInviteDialog;
import com.facebook.share.widget.MessageDialog;
import com.facebook.share.widget.ShareDialog;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Random;

import static com.facebook.samples.rps.RpsGameUtils.*;

public class RpsFragment extends Fragment {

    private static final String SHARE_GAME_LINK = "https:
    private static final String SHARE_GAME_NAME = "Rock, Papers, Scissors Sample Application";
    private static final String DEFAULT_GAME_OBJECT_TITLE =
            "an awesome game of Rock, Paper, Scissors";
    private static final String WIN_KEY = "wins";
    private static final String LOSS_KEY = "losses";
    private static final String TIE_KEY = "ties";
    private static final String PLAYER_CHOICE_KEY = "player_choice";
    private static final String COMPUTER_CHOICE_KEY = "computer_choice";
    private static final String STATE_KEY = "state";
    private static final String RESULT_KEY = "result";
    private static final String PENDING_PUBLISH_KEY = "pending_publish";
    private static final String IMPLICIT_PUBLISH_KEY = "implicitly_publish";
    private static final String ADDITIONAL_PERMISSIONS = "publish_actions";
    private static final int INITIAL_DELAY_MILLIS = 500;
    private static final int DEFAULT_DELAY_MILLIS = 1000;
    private static final String TAG = RpsFragment.class.getName();

    private static String[] PHOTO_URIS = {null, null, null};

    private TextView[] gestureTextViews = new TextView[3];
    private TextView shootTextView;
    private ImageView playerChoiceView;
    private ImageView computerChoiceView;
    private TextView resultTextView;
    private ViewGroup shootGroup;
    private ViewGroup resultGroup;
    private ViewGroup playerChoiceGroup;
    private Button againButton;
    private ImageButton[] gestureImages = new ImageButton[3];
    private ImageButton fbButton;
    private TextView statsTextView;
    private ViewFlipper rpsFlipper;

    private int wins = 0;
    private int losses = 0;
    private int ties = 0;
    private int playerChoice = INVALID_CHOICE;
    private int computerChoice = INVALID_CHOICE;
    private RpsState currentState = RpsState.INIT;
    private RpsResult result = RpsResult.INVALID;
    private InitHandler handler = new InitHandler();
    private Random random = new Random(System.currentTimeMillis());
    private boolean pendingPublish;
    private boolean shouldImplicitlyPublish = true;
    private CallbackManager callbackManager;
    private ShareDialog shareDialog;
    private MessageDialog messageDialog;
    private AppInviteDialog appInviteDialog;

    private DialogInterface.OnClickListener canPublishClickListener = new DialogInterface.OnClickListener() {
        @Override
        public void onClick(DialogInterface dialogInterface, int i) {
            if (AccessToken.getCurrentAccessToken() != null) {
                
                shouldImplicitlyPublish = true;
                pendingPublish = true;

                LoginManager.getInstance()
                        .setDefaultAudience(DefaultAudience.FRIENDS)
                        .logInWithPublishPermissions(
                                RpsFragment.this,
                                Arrays.asList(ADDITIONAL_PERMISSIONS));
            }
        }
    };

    private DialogInterface.OnClickListener dontPublishClickListener = new DialogInterface.OnClickListener() {
        @Override
        public void onClick(DialogInterface dialogInterface, int i) {
            
            
            pendingPublish = false;
            shouldImplicitlyPublish = false;
        }
    };

    private class InitHandler extends Handler {
        @Override
        public void handleMessage(Message msg) {
            if (!isResumed()) {
                
                return;
            }
            switch (msg.what) {
                case ROCK:
                    showViews(gestureTextViews[ROCK], gestureImages[ROCK]);
                    sendNextMessage(PAPER);
                    break;
                case PAPER:
                    showViews(gestureTextViews[PAPER], gestureImages[PAPER]);
                    sendNextMessage(SCISSORS);
                    break;
                case SCISSORS:
                    showViews(gestureTextViews[SCISSORS], gestureImages[SCISSORS]);
                    sendNextMessage(SHOOT);
                    break;
                case SHOOT:
                    showViews(shootTextView);
                    switchState(RpsState.PLAYING, false);
                    break;
                default:
                    Log.e(TAG, "Unexpected message received: " + msg.toString());
                    break;
            }
        }

        private void sendNextMessage(int what) {
            Message newMsg = new Message();
            newMsg.what = what;
            sendMessageDelayed(newMsg, DEFAULT_DELAY_MILLIS);
        }
    }

    private void switchState(RpsState newState, boolean isOnResume) {
        if (!isResumed()) {
            
            return;
        }
        switch (newState) {
            case INIT:
                playerChoice = INVALID_CHOICE;
                computerChoice = INVALID_CHOICE;
                result = RpsResult.INVALID;
                showViews(shootGroup, playerChoiceGroup, rpsFlipper);
                rpsFlipper.startFlipping();
                hideViews(gestureImages);
                hideViews(gestureTextViews);
                hideViews(resultGroup, shootTextView, againButton);
                enableViews(false, gestureImages);
                enableViews(false, againButton);
                Message initMessage = new Message();
                initMessage.what = ROCK;
                handler.sendMessageDelayed(initMessage, INITIAL_DELAY_MILLIS);
                break;
            case PLAYING:
                enableViews(true, gestureImages);
                showViews(rpsFlipper);
                rpsFlipper.startFlipping();
                break;
            case RESULT:
                hideViews(shootGroup, playerChoiceGroup);
                playerChoiceView.setImageResource(DRAWABLES_HUMAN[playerChoice]);
                computerChoiceView.setImageResource(DRAWABLES_COMPUTER[computerChoice]);
                resultTextView.setText(result.getStringId());
                showViews(resultGroup, againButton);
                enableViews(true, againButton);
                if (!isOnResume) {
                    
                    publishResult();
                }
                break;
            default:
                Log.e(TAG, "Unexpected state reached: " + newState.toString());
                break;
        }

        String statsFormat = getResources().getString(R.string.stats_format);
        statsTextView.setText(String.format(statsFormat, wins, losses, ties));

        currentState = newState;
    }

    private void hideViews(View... views) {
        for (View view : views) {
            view.setVisibility(View.INVISIBLE);
        }
    }

    private void showViews(View... views) {
        for (View view : views) {
            view.setVisibility(View.VISIBLE);
        }
    }

    private void enableViews(boolean enabled, View... views) {
        for (View view : views) {
            view.setEnabled(enabled);
        }
    }

    private void playerPlayed(int choice) {
        playerChoice = choice;
        computerChoice = getComputerChoice();
        result = RESULTS[playerChoice][computerChoice];
        switch (result) {
            case WIN:
                wins++;
                break;
            case LOSS:
                losses++;
                break;
            case TIE:
                ties++;
                break;
            default:
                Log.e(TAG, "Unexpected result: " + result.toString());
                break;
        }
        switchState(RpsState.RESULT, false);
    }

    private int getComputerChoice() {
        return random.nextInt(3);
    }

    private boolean canPublish() {
        final AccessToken accessToken = AccessToken.getCurrentAccessToken();
        if (accessToken != null) {
            if (accessToken.getPermissions().contains(ADDITIONAL_PERMISSIONS)) {
                
                return true;
            } else {
                
                new AlertDialog.Builder(getActivity())
                        .setTitle(R.string.share_with_friends_title)
                        .setMessage(R.string.share_with_friends_message)
                        .setPositiveButton(R.string.share_with_friends_yes, canPublishClickListener)
                        .setNegativeButton(R.string.share_with_friends_no, dontPublishClickListener)
                        .show();
                return false;
            }
        }
        return false;
    }

    private void showError(int messageId) {
        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
        builder.setTitle(R.string.error_dialog_title).
                setMessage(messageId).
                setPositiveButton(R.string.error_ok_button, null);
        builder.show();
    }

    private void publishResult() {
        if (shouldImplicitlyPublish && canPublish()) {
            String photoUri = PHOTO_URIS[playerChoice];
            SharePhoto.Builder sharePhotoBuilder = new SharePhoto.Builder();
            if (photoUri == null) {
                Bitmap bitmap = BitmapFactory.decodeResource(
                        getResources(),
                        DRAWABLES_HUMAN[playerChoice]);
                sharePhotoBuilder.setBitmap(bitmap);
            } else {
                sharePhotoBuilder.setImageUrl(Uri.parse(photoUri));
            }
            sharePhotoBuilder.setUserGenerated(false);
            final SharePhoto gesturePhoto = sharePhotoBuilder.build();

            ShareOpenGraphObject gameObject = createGameObject(gesturePhoto);
            ShareOpenGraphAction playAction = createPlayActionWithGame(gameObject);
            ShareOpenGraphContent content = new ShareOpenGraphContent.Builder()
                    .setAction(playAction)
                    .setPreviewPropertyName("game")
                    .build();

            ShareApi.share(content, new FacebookCallback<Sharer.Result>() {
                @Override
                public void onSuccess(Sharer.Result result) {
                    Log.i(TAG, "Posted OG Action with id: " +
                            result.getPostId());
                }

                @Override
                public void onCancel() {
                    
                }

                @Override
                public void onError(FacebookException error) {
                    Log.e(TAG, "Play action creation failed: " + error.getMessage());
                }
            });
        }
    }

    private ShareOpenGraphObject createGameObject(final SharePhoto gesturePhoto) {
        return new ShareOpenGraphObject.Builder()
                .putString("og:title", DEFAULT_GAME_OBJECT_TITLE)
                .putString("og:type", "fb_sample_rps:game")
                .putString("fb_sample_rps:player_gesture",
                        CommonObjects.BUILT_IN_OPEN_GRAPH_OBJECTS[playerChoice])
                .putString("fb_sample_rps:opponent_gesture",
                        CommonObjects.BUILT_IN_OPEN_GRAPH_OBJECTS[computerChoice])
                .putString("fb_sample_rps:result", getString(result.getResultStringId()))
                .putPhotoArrayList("og:image", new ArrayList<SharePhoto>() {{
                    add(gesturePhoto);
                }})
                .build();
    }

    private ShareOpenGraphAction createPlayActionWithGame(ShareOpenGraphObject game) {
        return new ShareOpenGraphAction.Builder()
                .setActionType(OpenGraphConsts.PLAY_ACTION_TYPE)
                .putObject("game", game).build();
    }

    private String getBuiltInGesture(int choice) {
        if (choice < 0 || choice >= CommonObjects.BUILT_IN_OPEN_GRAPH_OBJECTS.length) {
            throw new IllegalArgumentException("Invalid choice");
        }

        return CommonObjects.BUILT_IN_OPEN_GRAPH_OBJECTS[choice];
    }

    private ShareOpenGraphAction getThrowAction() {
        
        
        
        ImageButton view = gestureImages[playerChoice];
        BitmapDrawable drawable = (BitmapDrawable) view.getBackground();
        final Bitmap bitmap = drawable.getBitmap();

        return new ShareOpenGraphAction.Builder()
                .setActionType(OpenGraphConsts.THROW_ACTION_TYPE)
                .putString("fb_sample_rps:gesture", getBuiltInGesture(playerChoice))
                .putString("fb_sample_rps:opposing_gesture", getBuiltInGesture(computerChoice))
                .putPhotoArrayList("og:image", new ArrayList<SharePhoto>() {{
                    add(new SharePhoto.Builder().setBitmap(bitmap).build());
                }})
                .build();
    }

    private ShareOpenGraphContent getThrowActionContent() {
        return new ShareOpenGraphContent.Builder()
                .setAction(getThrowAction())
                .setPreviewPropertyName(OpenGraphConsts.THROW_ACTION_PREVIEW_PROPERTY_NAME)
                .build();
    }

    private ShareLinkContent getLinkContent() {
        return new ShareLinkContent.Builder()
                .setContentTitle(SHARE_GAME_NAME)
                .setContentUrl(Uri.parse(SHARE_GAME_LINK))
                .build();
    }

    public void shareUsingNativeDialog() {
        if (playerChoice == INVALID_CHOICE || computerChoice == INVALID_CHOICE) {
            ShareContent content = getLinkContent();

            
            if (shareDialog.canShow(content, ShareDialog.Mode.NATIVE)) {
                shareDialog.show(content, ShareDialog.Mode.NATIVE);
            } else {
                showError(R.string.native_share_error);
            }
        } else {
            ShareContent content = getThrowActionContent();

            if (shareDialog.canShow(content, ShareDialog.Mode.NATIVE)) {
                shareDialog.show(content, ShareDialog.Mode.NATIVE);
            } else {
                showError(R.string.native_share_error);
            }
        }
    }

    public void shareUsingMessengerDialog() {
        if (playerChoice == INVALID_CHOICE || computerChoice == INVALID_CHOICE) {
            ShareContent content = getLinkContent();

            
            if (messageDialog.canShow(content)) {
                messageDialog.show(content);
            }
        } else {
            ShareContent content = getThrowActionContent();

            if (messageDialog.canShow(content)) {
                messageDialog.show(content);
            }
        }
    }

    public void presentAppInviteDialog() {
        AppInviteContent content = new AppInviteContent.Builder()
                .setApplinkUrl("http:
                .setPreviewImageUrl("http:
                .build();
        if (AppInviteDialog.canShow()) {
            appInviteDialog.show(this, content);
        } else {
            showError(R.string.appinvite_error);
        }
    }

    @Override
    public View onCreateView(LayoutInflater inflater,
                             ViewGroup container,
                             Bundle savedInstanceState) {
        super.onCreateView(inflater, container, savedInstanceState);
        View view = inflater.inflate(R.layout.rps_fragment, container, false);

        gestureTextViews[ROCK] = (TextView) view.findViewById(R.id.text_rock);
        gestureTextViews[PAPER] = (TextView) view.findViewById(R.id.text_paper);
        gestureTextViews[SCISSORS] = (TextView) view.findViewById(R.id.text_scissors);
        shootTextView = (TextView) view.findViewById(R.id.shoot);
        playerChoiceView = (ImageView) view.findViewById(R.id.player_choice);
        computerChoiceView = (ImageView) view.findViewById(R.id.computer_choice);
        resultTextView = (TextView) view.findViewById(R.id.who_won);
        shootGroup = (ViewGroup) view.findViewById(R.id.shoot_display_group);
        resultGroup = (ViewGroup) view.findViewById(R.id.result_display_group);
        playerChoiceGroup = (ViewGroup) view.findViewById(R.id.player_choice_display_group);
        againButton = (Button) view.findViewById(R.id.again_button);
        gestureImages[ROCK] = (ImageButton) view.findViewById(R.id.player_rock);
        gestureImages[PAPER] = (ImageButton) view.findViewById(R.id.player_paper);
        gestureImages[SCISSORS] = (ImageButton) view.findViewById(R.id.player_scissors);
        fbButton = (ImageButton) view.findViewById(R.id.facebook_button);
        statsTextView = (TextView) view.findViewById(R.id.stats);
        rpsFlipper = (ViewFlipper) view.findViewById(R.id.rps_flipper);

        gestureImages[ROCK].setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                playerPlayed(ROCK);
            }
        });

        gestureImages[PAPER].setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                playerPlayed(PAPER);
            }
        });

        gestureImages[SCISSORS].setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                playerPlayed(SCISSORS);
            }
        });

        againButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                switchState(RpsState.INIT, false);
            }
        });

        fbButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                getActivity().openOptionsMenu();
            }
        });

        return view;
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        if (savedInstanceState != null) {
            wins = savedInstanceState.getInt(WIN_KEY);
            losses = savedInstanceState.getInt(LOSS_KEY);
            ties = savedInstanceState.getInt(TIE_KEY);
            computerChoice = savedInstanceState.getInt(COMPUTER_CHOICE_KEY);
            playerChoice = savedInstanceState.getInt(PLAYER_CHOICE_KEY);
            currentState = (RpsState) savedInstanceState.getSerializable(STATE_KEY);
            result = (RpsResult) savedInstanceState.getSerializable(RESULT_KEY);
            pendingPublish = savedInstanceState.getBoolean(PENDING_PUBLISH_KEY);
            shouldImplicitlyPublish = savedInstanceState.getBoolean(IMPLICIT_PUBLISH_KEY);
        }
        callbackManager = CallbackManager.Factory.create();
        LoginManager.getInstance().registerCallback(
                callbackManager,
                new FacebookCallback<LoginResult>() {
                    @Override
                    public void onSuccess(LoginResult loginResult) {
                        AccessToken accessToken = AccessToken.getCurrentAccessToken();
                        if (accessToken.getPermissions().contains(ADDITIONAL_PERMISSIONS)) {
                            publishResult();
                        } else {
                            handleError();
                        }
                    }

                    @Override
                    public void onCancel() {
                        handleError();
                    }

                    @Override
                    public void onError(FacebookException exception) {
                        handleError();
                    }

                    private void handleError() {
                        
                        
                        shouldImplicitlyPublish = false;
                        pendingPublish = false;
                    }
                }
        );

        FacebookCallback<Sharer.Result> callback =
                new FacebookCallback<Sharer.Result>() {
                    @Override
                    public void onCancel() {
                        Log.d(TAG, "Canceled");
                    }

                    @Override
                    public void onError(FacebookException error) {
                        Log.d(TAG, String.format("Error: %s", error.toString()));
                    }

                    @Override
                    public void onSuccess(Sharer.Result result) {
                        Log.d(TAG, "Success!");
                    }
                };
        shareDialog = new ShareDialog(this);
        shareDialog.registerCallback(callbackManager, callback);
        messageDialog = new MessageDialog(this);
        messageDialog.registerCallback(callbackManager, callback);

        FacebookCallback<AppInviteDialog.Result> appInviteCallback =
                new FacebookCallback<AppInviteDialog.Result>() {
                    @Override
                    public void onSuccess(AppInviteDialog.Result result) {
                        Log.d(TAG, "Success!");
                    }

                    @Override
                    public void onCancel() {
                        Log.d(TAG, "Canceled");
                    }

                    @Override
                    public void onError(FacebookException error) {
                        Log.d(TAG, String.format("Error: %s", error.toString()));
                    }
                };
        appInviteDialog = new AppInviteDialog(this);
        appInviteDialog.registerCallback(callbackManager, appInviteCallback);
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        callbackManager.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    public void onResume() {
        super.onResume();
        switchState(currentState, true);
    }

    @Override
    public void onSaveInstanceState(Bundle bundle) {
        super.onSaveInstanceState(bundle);
        bundle.putInt(WIN_KEY, wins);
        bundle.putInt(LOSS_KEY, losses);
        bundle.putInt(TIE_KEY, ties);
        bundle.putInt(COMPUTER_CHOICE_KEY, computerChoice);
        bundle.putInt(PLAYER_CHOICE_KEY, playerChoice);
        bundle.putSerializable(STATE_KEY, currentState);
        bundle.putSerializable(RESULT_KEY, result);
        bundle.putBoolean(PENDING_PUBLISH_KEY, pendingPublish);
        bundle.putBoolean(IMPLICIT_PUBLISH_KEY, shouldImplicitlyPublish);
    }
}

<code block>



package com.facebook.samples.rps;

public class CommonObjects {
    public static final String BUILT_IN_OPEN_GRAPH_OBJECTS[] = {
            "672839339475385", 
            "296430467206197", 
            "524651207660361"  
    };
}


<code block>


package com.facebook.samples.rps;

import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.TextView;

public class ContentFragment extends Fragment {
    public static final String CONTENT_INDEX_KEY = "content";

    private TextView title;
    private ImageView image;
    private Button playButton;

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.content_fragment, container, false);
        title = (TextView) view.findViewById(R.id.content_title);
        image = (ImageView) view.findViewById(R.id.content_image);
        playButton = (Button) view.findViewById(R.id.content_play_button);

        playButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                MainActivity activity = (MainActivity) getActivity();
                activity.showFragment(MainActivity.RPS, false);
            }
        });
        return view;
    }

    public void setContentIndex(int index) {
        title.setText(RpsGameUtils.STRINGS_TITLES[index]);
        image.setImageResource(RpsGameUtils.DRAWABLES_HUMAN[index]);
    }
}

<code block>


package com.facebook.samples.rps;

import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentActivity;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentTransaction;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;

import bolts.AppLinks;
import com.facebook.*;
import com.facebook.appevents.AppEventsLogger;
import com.facebook.share.model.GameRequestContent;
import com.facebook.share.widget.GameRequestDialog;

import static com.facebook.samples.rps.RpsGameUtils.INVALID_CHOICE;

public class MainActivity extends FragmentActivity {
    private static final String TAG = "MainActivity";

    static final int RPS = 0;
    static final int SETTINGS = 1;
    static final int CONTENT = 2;
    static final int FRAGMENT_COUNT = CONTENT +1;

    private Fragment[] fragments = new Fragment[FRAGMENT_COUNT];
    private MenuItem settings;
    private MenuItem challenge;
    private MenuItem share;
    private MenuItem message;
    private MenuItem invite;
    private boolean isResumed = false;
    private boolean hasNativeLink = false;
    private CallbackManager callbackManager;
    private GameRequestDialog gameRequestDialog;

    private AccessTokenTracker accessTokenTracker;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        FacebookSdk.sdkInitialize(this.getApplicationContext());

        accessTokenTracker = new AccessTokenTracker() {
            @Override
            protected void onCurrentAccessTokenChanged(AccessToken oldAccessToken,
                                                       AccessToken currentAccessToken) {
                if (isResumed) {
                    if (currentAccessToken == null) {
                        showFragment(RPS, false);
                    }
                }
            }
        };

        setContentView(R.layout.main);

        FragmentManager fm = getSupportFragmentManager();
        fragments[RPS] = fm.findFragmentById(R.id.rps_fragment);
        fragments[SETTINGS] = fm.findFragmentById(R.id.settings_fragment);
        fragments[CONTENT] = fm.findFragmentById(R.id.content_fragment);

        FragmentTransaction transaction = fm.beginTransaction();
        for(int i = 0; i < fragments.length; i++) {
            transaction.hide(fragments[i]);
        }
        transaction.commit();

        hasNativeLink = handleNativeLink();

        gameRequestDialog = new GameRequestDialog(this);
        callbackManager = CallbackManager.Factory.create();
        gameRequestDialog.registerCallback(
                callbackManager,
                new FacebookCallback<GameRequestDialog.Result>() {
                    @Override
                    public void onCancel() {
                        Log.d(TAG, "Canceled");
                    }

                    @Override
                    public void onError(FacebookException error) {
                        Log.d(TAG, String.format("Error: %s", error.toString()));
                    }

                    @Override
                    public void onSuccess(GameRequestDialog.Result result) {
                        Log.d(TAG, "Success!");
                        Log.d(TAG, "Request id: " + result.getRequestId());
                        Log.d(TAG, "Recipients:");
                        for (String recipient : result.getRequestRecipients()) {
                            Log.d(TAG, recipient);
                        }
                    }
                });
    }

    @Override
    public void onResume() {
        super.onResume();
        isResumed = true;

        
        
        AppEventsLogger.activateApp(this);
    }

    @Override
    public void onPause() {
        super.onPause();
        isResumed = false;

        
        
        AppEventsLogger.deactivateApp(this);
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        callbackManager.onActivityResult(requestCode, resultCode, data);
        super.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        accessTokenTracker.stopTracking();
    }

    @Override
    protected void onResumeFragments() {
        super.onResumeFragments();

        if (hasNativeLink) {
            showFragment(CONTENT, false);
            hasNativeLink = false;
        } else {
            showFragment(RPS, false);
        }
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        
        if (fragments[RPS].isVisible()) {
            if (menu.size() == 0) {
                share = menu.add(R.string.share_on_facebook);
                message = menu.add(R.string.send_with_messenger);
                challenge = menu.add(R.string.challenge_friends);
                settings = menu.add(R.string.check_settings);
                invite = menu.add(R.string.invite_friends);
            }
            return true;
        } else {
            menu.clear();
            settings = null;
        }
        return false;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if (item.equals(settings)) {
            showFragment(SETTINGS, true);
            return true;
        } else if (item.equals(challenge)) {
            GameRequestContent newGameRequestContent = new GameRequestContent.Builder()
                    .setTitle(getString(R.string.challenge_dialog_title))
                    .setMessage(getString(R.string.challenge_dialog_message))
                    .build();

            gameRequestDialog.show(this, newGameRequestContent);

            return true;
        } else if (item.equals(share)) {
            RpsFragment fragment = (RpsFragment) fragments[RPS];
            fragment.shareUsingNativeDialog();
            return true;
        } else if (item.equals(message)) {
            RpsFragment fragment = (RpsFragment) fragments[RPS];
            fragment.shareUsingMessengerDialog();
            return true;
        } else if (item.equals(invite)) {
            RpsFragment fragment = (RpsFragment) fragments[RPS];
            fragment.presentAppInviteDialog();
        }
        return false;
    }

    private boolean handleNativeLink() {
        AccessToken accessToken = AccessToken.getCurrentAccessToken();
        if (accessToken == null) {
            AccessToken.createFromNativeLinkingIntent(getIntent(),
                    FacebookSdk.getApplicationId(), new AccessToken.AccessTokenCreationCallback(){

                        @Override
                        public void onSuccess(AccessToken token) {
                            AccessToken.setCurrentAccessToken(token);
                        }

                        @Override
                        public void onError(FacebookException error) {

                        }
                    });
        }
        
        int appLinkGesture = getAppLinkGesture(getIntent());
        if (appLinkGesture != INVALID_CHOICE) {
            ContentFragment fragment = (ContentFragment) fragments[CONTENT];
            fragment.setContentIndex(appLinkGesture);
            return true;
        }
        return false;
    }

    private int getAppLinkGesture(Intent intent) {
      Uri targetURI = AppLinks.getTargetUrlFromInboundIntent(this, intent);
      if (targetURI == null) {
        return INVALID_CHOICE;
      }
      String gesture = targetURI.getQueryParameter("gesture");
      if (gesture != null) {
          if (gesture.equalsIgnoreCase(getString(R.string.rock))) {
              return RpsGameUtils.ROCK;
          } else if (gesture.equalsIgnoreCase(getString(R.string.paper))) {
              return RpsGameUtils.PAPER;
          } else if (gesture.equalsIgnoreCase(getString(R.string.scissors))) {
              return RpsGameUtils.SCISSORS;
          }
      }
      return INVALID_CHOICE;
    }

    void showFragment(int fragmentIndex, boolean addToBackStack) {
        FragmentManager fm = getSupportFragmentManager();
        FragmentTransaction transaction = fm.beginTransaction();
        if (addToBackStack) {
            transaction.addToBackStack(null);
        } else {
            int backStackSize = fm.getBackStackEntryCount();
            for (int i = 0; i < backStackSize; i++) {
                fm.popBackStack();
            }
        }
        for (int i = 0; i < fragments.length; i++) {
            if (i == fragmentIndex) {
                transaction.show(fragments[i]);
            } else {
                transaction.hide(fragments[i]);
            }
        }
        transaction.commit();
    }
}

<code block>


package com.facebook.samples.rps;

public class OpenGraphConsts {
    public static final String THROW_ACTION_TYPE = "fb_sample_rps:throw";
    public static final String THROW_ACTION_PREVIEW_PROPERTY_NAME = "fb_sample_rps:gesture";

    public static final String GAME_OBJECT_TYPE = "fb_sample_rps:game";

    public static final String PLAY_ACTION_TYPE = "fb_sample_rps:play";
}

<code block>


package com.facebook.samples.rps.usersettings;

import android.content.Intent;
import android.graphics.Bitmap;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.text.TextUtils;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

import com.facebook.AccessToken;
import com.facebook.AccessTokenTracker;
import com.facebook.CallbackManager;
import com.facebook.GraphRequest;
import com.facebook.GraphResponse;
import com.facebook.internal.ImageDownloader;
import com.facebook.internal.ImageRequest;
import com.facebook.internal.ImageResponse;
import com.facebook.samples.rps.R;
import com.facebook.login.widget.LoginButton;

import org.json.JSONObject;


public final class UserSettingsFragment extends Fragment {

    private static final String NAME = "name";
    private static final String ID = "id";
    private static final String PICTURE = "picture";
    private static final String FIELDS = "fields";

    private static final String REQUEST_FIELDS =
            TextUtils.join(",", new String[] {ID, NAME, PICTURE});

    private AccessTokenTracker accessTokenTracker;
    private CallbackManager callbackManager;

    private LoginButton loginButton;
    private TextView connectedStateLabel;
    private JSONObject user;
    private Drawable userProfilePic;
    private String userProfilePicID;

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        accessTokenTracker = new AccessTokenTracker() {
            @Override
            protected void onCurrentAccessTokenChanged(AccessToken oldAccessToken,
                                                       AccessToken currentAccessToken) {
                fetchUserInfo();
                updateUI();

            }
        };
        callbackManager = CallbackManager.Factory.create();
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        callbackManager.onActivityResult(requestCode, resultCode, data);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        accessTokenTracker.stopTracking();
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.usersettings_fragment, container, false);
        loginButton = (LoginButton) view.findViewById(R.id.usersettings_fragment_login_button);
        loginButton.setFragment(this);

        connectedStateLabel = (TextView) view.findViewById(R.id.usersettings_fragment_profile_name);

        
        if (view.getBackground() == null) {
            view.setBackgroundColor(getResources().getColor(R.color.com_facebook_blue));
        } else {
            view.getBackground().setDither(true);
        }
        return view;
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setRetainInstance(true);
    }

    
    @Override
    public void onResume() {
        super.onResume();
        fetchUserInfo();
        updateUI();
    }

    private void fetchUserInfo() {
        final AccessToken accessToken = AccessToken.getCurrentAccessToken();
        if (accessToken != null) {
            GraphRequest request = GraphRequest.newMeRequest(
                    accessToken, new GraphRequest.GraphJSONObjectCallback() {
                        @Override
                        public void onCompleted(JSONObject me, GraphResponse response) {
                            user = me;
                            updateUI();
                        }
                    });
            Bundle parameters = new Bundle();
            parameters.putString(FIELDS, REQUEST_FIELDS);
            request.setParameters(parameters);
            GraphRequest.executeBatchAsync(request);
        } else {
            user = null;
        }
    }

    private void updateUI() {
        if (!isAdded()) {
            return;
        }
        if (AccessToken.getCurrentAccessToken() != null) {
            connectedStateLabel.setTextColor(getResources().getColor(
                    R.color.usersettings_fragment_connected_text_color));
            connectedStateLabel.setShadowLayer(1f, 0f, -1f,
                    getResources().getColor(
                            R.color.usersettings_fragment_connected_shadow_color));

            if (user != null) {
                ImageRequest request = getImageRequest();
                if (request != null) {
                    Uri requestUri = request.getImageUri();
                    
                    if (!requestUri.equals(connectedStateLabel.getTag())) {
                        if (user.optString("id").equals(userProfilePicID)) {
                            connectedStateLabel.setCompoundDrawables(
                                    null, userProfilePic, null, null);
                            connectedStateLabel.setTag(requestUri);
                        } else {
                            ImageDownloader.downloadAsync(request);
                        }
                    }
                }
                connectedStateLabel.setText(user.optString("name"));
            } else {
                connectedStateLabel.setText(getResources().getString(
                        R.string.usersettings_fragment_logged_in));
                Drawable noProfilePic = getResources().getDrawable(
                        R.drawable.profile_default_icon);
                noProfilePic.setBounds(0, 0,
                        getResources().getDimensionPixelSize(
                                R.dimen.usersettings_fragment_profile_picture_width),
                        getResources().getDimensionPixelSize(
                                R.dimen.usersettings_fragment_profile_picture_height));
                connectedStateLabel.setCompoundDrawables(null, noProfilePic, null, null);
            }
        } else {
            int textColor = getResources().getColor(
                    R.color.usersettings_fragment_not_connected_text_color);
            connectedStateLabel.setTextColor(textColor);
            connectedStateLabel.setShadowLayer(0f, 0f, 0f, textColor);
            connectedStateLabel.setText(getResources().getString(
                    R.string.usersettings_fragment_not_logged_in));
            connectedStateLabel.setCompoundDrawables(null, null, null, null);
            connectedStateLabel.setTag(null);
        }
    }

    private ImageRequest getImageRequest() {
        ImageRequest request = null;
        ImageRequest.Builder requestBuilder = new ImageRequest.Builder(
                getActivity(),
                ImageRequest.getProfilePictureUri(
                        user.optString("id"),
                        getResources().getDimensionPixelSize(
                                R.dimen.usersettings_fragment_profile_picture_width),
                        getResources().getDimensionPixelSize(
                                R.dimen.usersettings_fragment_profile_picture_height)));

        request = requestBuilder.setCallerTag(this)
                .setCallback(
                        new ImageRequest.Callback() {
                            @Override
                            public void onCompleted(ImageResponse response) {
                                processImageResponse(user.optString("id"), response);
                            }
                        })
                .build();
        return request;
    }

    private void processImageResponse(String id, ImageResponse response) {
        if (response != null) {
            Bitmap bitmap = response.getBitmap();
            if (bitmap != null) {
                BitmapDrawable drawable = new BitmapDrawable(
                        UserSettingsFragment.this.getResources(), bitmap);
                drawable.setBounds(0, 0,
                        getResources().getDimensionPixelSize(
                                R.dimen.usersettings_fragment_profile_picture_width),
                        getResources().getDimensionPixelSize(
                                R.dimen.usersettings_fragment_profile_picture_height));
                userProfilePic = drawable;
                userProfilePicID = id;
                connectedStateLabel.setCompoundDrawables(null, drawable, null, null);
                connectedStateLabel.setTag(response.getRequest().getImageUri());
            }
        }
    }
}
