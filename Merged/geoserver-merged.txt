

package org.geoserver.wps.ogr;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import net.opengis.wfs.GetFeatureType;
import net.opengis.wfs.WfsFactory;

import org.geoserver.platform.Operation;
import org.geoserver.platform.Service;
import org.geoserver.wfs.response.Ogr2OgrOutputFormat;
import org.geoserver.wfs.response.OgrFormat;
import org.geoserver.wps.ppio.PPIOFactory;
import org.geoserver.wps.ppio.ProcessParameterIO;
import org.geotools.util.Version;



public class Ogr2OgrPPIOFactory implements PPIOFactory {

    private Ogr2OgrOutputFormat ogr2OgrOutputFormat;

    public Ogr2OgrPPIOFactory(Ogr2OgrOutputFormat ogr2OgrOutputFormat) {
        this.ogr2OgrOutputFormat = ogr2OgrOutputFormat;
    }


    @Override
    public List<ProcessParameterIO> getProcessParameterIO() {
        List<ProcessParameterIO> ogrParams = new ArrayList<ProcessParameterIO>();
        for (OgrFormat of : this.ogr2OgrOutputFormat.getFormats()) {
            ProcessParameterIO ppio = null;
            GetFeatureType gft = WfsFactory.eINSTANCE.createGetFeatureType();
            gft.setOutputFormat(of.formatName);
            Operation operation = new Operation("GetFeature", new Service("WFS", null, new Version(
                    "1.1.0"), Arrays.asList("GetFeature")), null, new Object[] { gft });


            String computedMimeType = ogr2OgrOutputFormat.getMimeType(null, operation);
            if (of.formatName != null && !of.formatName.isEmpty()) {
                computedMimeType = computedMimeType + "; subtype=" + of.formatName;
            }

            if (of.type == null) {

                ppio = new OgrBinaryPPIO(computedMimeType, of.fileExtension, ogr2OgrOutputFormat,
                        operation);
            } else {
                switch (of.type) {
                case BINARY:
                    ppio = new OgrBinaryPPIO(computedMimeType, of.fileExtension,
                            ogr2OgrOutputFormat, operation);
                    break;
                case TEXT:
                    ppio = new OgrCDataPPIO(computedMimeType, of.fileExtension,
                            ogr2OgrOutputFormat, operation);
                    break;
                case XML:
                    ppio = new OgrXMLPPIO(computedMimeType, of.fileExtension, ogr2OgrOutputFormat,
                            operation);
                    break;
                default:
                    break;
                }
            }
            if (ppio != null) {
                ogrParams.add(ppio);
            }
        }
        return ogrParams;
    }
}

<code block>

package org.geoserver.wps.ogr;

import static junit.framework.Assert.assertEquals;
import static org.custommonkey.xmlunit.XMLAssert.assertXpathExists;
import static org.junit.Assert.assertTrue;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import org.custommonkey.xmlunit.SimpleNamespaceContext;
import org.custommonkey.xmlunit.XMLUnit;
import org.custommonkey.xmlunit.XpathEngine;
import org.geoserver.platform.GeoServerExtensions;
import org.geoserver.platform.GeoServerResourceLoader;
import org.geoserver.wfs.response.Ogr2OgrConfigurator;
import org.geoserver.wfs.response.Ogr2OgrTestUtil;
import org.geoserver.wfs.response.OgrConfiguration;
import org.geoserver.wfs.response.OgrFormat;
import org.geoserver.wps.WPSTestSupport;
import org.junit.Assume;
import org.junit.Before;
import org.junit.Test;
import org.w3c.dom.Document;

import com.mockrunner.mock.web.MockHttpServletResponse;
import com.thoughtworks.xstream.XStream;

public class WPSOgrTest extends WPSTestSupport {

    @Before
    public void setUp() throws Exception {
        Assume.assumeTrue(Ogr2OgrTestUtil.isOgrAvailable());
    }

    private File loadConfiguration() throws Exception {
        String ogrConfigruationName = "ogr2ogr.xml";
        GeoServerResourceLoader loader = GeoServerExtensions.bean(GeoServerResourceLoader.class);

        XStream xstream = buildXStream();
        ClassLoader classLoader = getClass().getClassLoader();
        File file = new File(classLoader.getResource(ogrConfigruationName).getFile());
        OgrConfiguration ogrConfiguration = (OgrConfiguration) xstream.fromXML(file);
        ogrConfiguration.ogr2ogrLocation = Ogr2OgrTestUtil.getOgr2Ogr();
        ogrConfiguration.gdalData = Ogr2OgrTestUtil.getGdalData();

        File configuration = loader.createFile(ogrConfigruationName);
        xstream.toXML(ogrConfiguration, new FileOutputStream(configuration));

        Ogr2OgrConfigurator configurator = applicationContext.getBean(Ogr2OgrConfigurator.class);
        configurator.loadConfiguration();

        return configuration;
    }

    @Test
    public void testConfigurationLoad() throws Exception {
        File configuration = null;
        try {
            configuration = loadConfiguration();
            Ogr2OgrConfigurator configurator = applicationContext
                    .getBean(Ogr2OgrConfigurator.class);
            configurator.loadConfiguration();
            List<String> formatNames = new ArrayList<>();
            for (OgrFormat f : configurator.of.getFormats()) {
                formatNames.add(f.formatName);
            }
            assertTrue(formatNames.contains("OGR-TAB"));
            assertTrue(formatNames.contains("OGR-MIF"));
            assertTrue(formatNames.contains("OGR-CSV"));
            assertTrue(formatNames.contains("OGR-KML"));
        } catch (IOException e) {
            System.err.println(e.getStackTrace());
        } finally {
            if (configuration != null) {
                configuration.delete();
            }
        }
    }

    @Test
    public void testDescribeProcess() throws Exception {
        OgrConfiguration.DEFAULT.ogr2ogrLocation = Ogr2OgrTestUtil.getOgr2Ogr();
        OgrConfiguration.DEFAULT.gdalData = Ogr2OgrTestUtil.getGdalData();
        Ogr2OgrConfigurator configurator = applicationContext.getBean(Ogr2OgrConfigurator.class);
        configurator.loadConfiguration();
        Document d = getAsDOM(root()
                + "service=wps&request=describeprocess&identifier=gs:BufferFeatureCollection");
        String base = "/wps:ProcessDescriptions/ProcessDescription/ProcessOutputs";
        for (OgrFormat f : OgrConfiguration.DEFAULT.formats) {
            if (f.mimeType != null) {
                assertXpathExists(base + "/Output[1]/ComplexOutput/Supported/Format[MimeType='"
                        + f.mimeType + "; subtype=" + f.formatName + "']", d);
            }
        }
    }

    @Test
    public void testOGRKMLOutputExecuteRaw() throws Exception {
        File configuration = null;
        try {
            configuration = loadConfiguration();
            Ogr2OgrConfigurator configurator = applicationContext
                    .getBean(Ogr2OgrConfigurator.class);
            configurator.loadConfiguration();
            MockHttpServletResponse r = postAsServletResponse("wps",
                    getWpsRawXML("application/vnd.google-earth.kml; subtype=OGR-KML"));
            assertEquals("application/vnd.google-earth.kml; subtype=OGR-KML", r.getContentType());
            assertTrue(r.getOutputStreamContent().length() > 0);

        } catch (IOException e) {
            System.err.println(e.getStackTrace());
        } finally {
            if (configuration != null) {
                configuration.delete();
            }
        }
    }

    @Test
    public void testOGRKMLOutputExecuteDocument() throws Exception {
        File configuration = null;
        try {
            configuration = loadConfiguration();
            Ogr2OgrConfigurator configurator = applicationContext
                    .getBean(Ogr2OgrConfigurator.class);
            configurator.loadConfiguration();
            Document d = postAsDOM("wps",
                    getWpsDocumentXML("application/vnd.google-earth.kml; subtype=OGR-KML"));
            Map<String, String> m = new HashMap<String, String>();
            m.put("kml", "http://www.opengis.net/kml/2.2");
            org.custommonkey.xmlunit.NamespaceContext ctx = new SimpleNamespaceContext(m);
            XpathEngine engine = XMLUnit.newXpathEngine();
            engine.setNamespaceContext(ctx);
            assertEquals(1, engine.getMatchingNodes("//kml:kml/kml:Document/kml:Schema", d)
                    .getLength());
        } catch (IOException e) {
            System.err.println(e.getStackTrace());
        } finally {
            if (configuration != null) {
                configuration.delete();
            }
        }
    }

    @Test
    public void testOGRCSVOutputExecuteDocument() throws Exception {
        File configuration = null;
        try {
            configuration = loadConfiguration();
            Ogr2OgrConfigurator configurator = applicationContext
                    .getBean(Ogr2OgrConfigurator.class);
            configurator.loadConfiguration();
            MockHttpServletResponse r = postAsServletResponse("wps",
                    getWpsRawXML("text/csv; subtype=OGR-CSV"));
            assertEquals("text/csv; subtype=OGR-CSV", r.getContentType());
            assertTrue(r.getOutputStreamContent().length() > 0);
            assertTrue(r.getOutputStreamContent().contains("WKT,gml_id,STATE_NAME"));
        } catch (IOException e) {
            System.err.println(e.getStackTrace());
        } finally {
            if (configuration != null) {
                configuration.delete();
            }
        }
    }

    @Test
    public void testOGRBinaryOutputExecuteDocument() throws Exception {
        File configuration = null;
        try {
            configuration = loadConfiguration();
            Ogr2OgrConfigurator configurator = applicationContext
                    .getBean(Ogr2OgrConfigurator.class);
            configurator.loadConfiguration();
            MockHttpServletResponse r = postAsServletResponse("wps",
                    getWpsRawXML("application/zip; subtype=OGR-TAB"));
            assertEquals("application/zip; subtype=OGR-TAB", r.getContentType());
            ByteArrayInputStream bis = getBinaryInputStream(r);
            ZipInputStream zis = new ZipInputStream(bis);
            ZipEntry entry = null;
            boolean found = false;
            while ((entry = zis.getNextEntry()) != null) {
                final String name = entry.getName();
                zis.closeEntry();
                if (name.equals("feature.tab")) {
                    found = true;
                    break;
                }
            }
            zis.close();
            assertTrue(found);
        } catch (IOException e) {
            System.err.println(e.getStackTrace());
        } finally {
            if (configuration != null) {
                configuration.delete();
            }
        }
    }

    private String getWpsRawXML(String ouputMime) throws Exception {
        String xml = "<wps:Execute service='WPS' version='1.0.0' xmlns:wps='http://www.opengis.net/wps/1.0.0' "
                + "xmlns:ows='http://www.opengis.net/ows/1.1'>"
                + "<ows:Identifier>gs:BufferFeatureCollection</ows:Identifier>"
                + "<wps:DataInputs>"
                + "<wps:Input>"
                + "<ows:Identifier>features</ows:Identifier>"
                + "<wps:Data>"
                + "<wps:ComplexData mimeType=\"application/json\"><![CDATA["
                + readFileIntoString("states-FeatureCollection.json")
                + "]]></wps:ComplexData>"
                + "</wps:Data>"
                + "</wps:Input>"
                + "<wps:Input>"
                + "<ows:Identifier>distance</ows:Identifier>"
                + "<wps:Data>"
                + "<wps:LiteralData>10</wps:LiteralData>"
                + "</wps:Data>"
                + "</wps:Input>"
                + "</wps:DataInputs>"
                + "<wps:ResponseForm>"
                + "<wps:RawDataOutput mimeType=\""
                + ouputMime
                + "\">"
                + "<ows:Identifier>result</ows:Identifier>"
                + "</wps:RawDataOutput>" + "</wps:ResponseForm>" + "</wps:Execute>";
        return xml;
    }

    private String getWpsDocumentXML(String ouputMime) throws Exception {
        String xml = "<wps:Execute service='WPS' version='1.0.0' xmlns:wps='http://www.opengis.net/wps/1.0.0' "
                + "xmlns:ows='http://www.opengis.net/ows/1.1'>"
                + "<ows:Identifier>gs:BufferFeatureCollection</ows:Identifier>"
                + "<wps:DataInputs>"
                + "<wps:Input>"
                + "<ows:Identifier>features</ows:Identifier>"
                + "<wps:Data>"
                + "<wps:ComplexData mimeType=\"application/json\"><![CDATA["
                + readFileIntoString("states-FeatureCollection.json")
                + "]]></wps:ComplexData>"
                + "</wps:Data>"
                + "</wps:Input>"
                + "<wps:Input>"
                + "<ows:Identifier>distance</ows:Identifier>"
                + "<wps:Data>"
                + "<wps:LiteralData>10</wps:LiteralData>"
                + "</wps:Data>"
                + "</wps:Input>"
                + "</wps:DataInputs>"
                + "<wps:ResponseForm>"
                + "<wps:ResponseDocument>"
                + "<wps:Output mimeType=\""
                + ouputMime
                + "\">"
                + "<ows:Identifier>result</ows:Identifier>"
                + "</wps:Output>"
                + "</wps:ResponseDocument>" + "</wps:ResponseForm>" + "</wps:Execute>";
        return xml;
    }

    private static XStream buildXStream() {
        XStream xstream = new XStream();
        xstream.alias("OgrConfiguration", OgrConfiguration.class);
        xstream.alias("Format", OgrFormat.class);
        xstream.addImplicitCollection(OgrFormat.class, "options", "option", String.class);
        return xstream;
    }


}

<code block>


package org.geoserver.wfs.response;



public enum OgrType {
    BINARY, TEXT, XML;
}

<code block>

package org.geoserver.wfs.response;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;


public class OgrFormat {

    public String ogrFormat;


    public String formatName;


    public String fileExtension;


    public List<String> options;


    public OgrType type;


    public boolean singleFile;


    public String mimeType;

    public OgrFormat(String ogrFormat, String formatName, String fileExtension, boolean singleFile,
            String mimeType, OgrType type, String... options) {
        this.ogrFormat = ogrFormat;
        this.formatName = formatName;
        this.fileExtension = fileExtension;
        this.singleFile = singleFile;
        this.mimeType = mimeType;
        this.type = type;
        if (options != null) {
            this.options = new ArrayList<String>(Arrays.asList(options));
        }
        if (type == null) {
            this.type = OgrType.BINARY;
        }
    }

    public OgrFormat(String ogrFormat, String formatName, String fileExtension, boolean singleFile,
            String mimeType, String... options) {
        this(ogrFormat, formatName, fileExtension, singleFile, mimeType, OgrType.BINARY, options);
    }

}

<code block>

package org.geoserver.wfs.response;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.geotools.util.logging.Logging;
import org.opengis.referencing.crs.CoordinateReferenceSystem;


public class OGRWrapper {

    private static final Logger LOGGER = Logging.getLogger(OGRWrapper.class);

    private String ogrExecutable;
    private String gdalData;

    public OGRWrapper(String ogrExecutable, String gdalData) {
        this.ogrExecutable = ogrExecutable;
        this.gdalData = gdalData;
    }


    public File convert(File inputData, File outputDirectory, String typeName,
            OgrFormat format, CoordinateReferenceSystem crs) throws IOException, InterruptedException {

        List<String> cmd = new ArrayList<String>();
        cmd.add(ogrExecutable);
        cmd.add("-f");
        cmd.add(format.ogrFormat);
        File crsFile = null;
        if (crs != null) {





            crsFile = File.createTempFile("gdal_srs", "wkt", inputData.getParentFile());
            cmd.add("-a_srs");
            String s = crs.toWKT();
            s = s.replaceAll("\n\r", "").replaceAll("  ", "");
            FileUtils.writeStringToFile(crsFile, s);
            cmd.add(crsFile.getAbsolutePath());
        }
        if (format.options != null) {
            for (String option : format.options) {
                cmd.add(option);
            }
        }
        String outFileName = typeName;
        if (format.fileExtension != null)
            outFileName += format.fileExtension;
        cmd.add(new File(outputDirectory, outFileName).getAbsolutePath());
        cmd.add(inputData.getAbsolutePath());

        StringBuilder sb = new StringBuilder();
        int exitCode = run(cmd, sb);
        if(crsFile != null) {
            crsFile.delete();
        }

        if (exitCode != 0)
            throw new IOException("ogr2ogr did not terminate successfully, exit code " + exitCode
                    + ". Was trying to run: " + cmd + "\nResulted in:\n" + sb);
        

        File output = new File(outputDirectory, outFileName);
        if(output.isDirectory()) {
            output = new File(output, outFileName);
        }
        return output;
    }


    public Set<String> getSupportedFormats() {
        try {

            List<String> commands = new ArrayList<String>();
            commands.add(ogrExecutable);
            commands.add("--help");
            
            Set<String> formats = new HashSet<String>();
            addFormats(commands, formats);
            

            commands = new ArrayList<String>();
            commands.add(ogrExecutable);
            commands.add("--long-usage");
            addFormats(commands, formats);

            return formats;
        } catch (Exception e) {
            LOGGER.log(Level.SEVERE,
                    "Could not get the list of output formats supported by ogr2ogr", e);
            return Collections.emptySet();
        }
    }

    private void addFormats(List<String> commands, Set<String> formats) throws IOException,
            InterruptedException {
        StringBuilder sb = new StringBuilder();

        run(commands, sb);
        
        String[] lines = sb.toString().split("\n");
        for (String line : lines) {
            if (line.matches("\\s*-f \".*")) {
                String format = line.substring(line.indexOf('"') + 1, line.lastIndexOf('"'));
                formats.add(format);
            }
        }
    }


    public boolean isAvailable() {
        List<String> commands = new ArrayList<String>();
        commands.add(ogrExecutable);
        commands.add("--version");

        try {
            return run(commands, null) == 0;
        } catch(Exception e) {
            LOGGER.log(Level.SEVERE, "Ogr2Ogr is not available", e);
            return false;
        }
    }


    int run(List<String> cmd, StringBuilder sb) throws IOException, InterruptedException {

        ProcessBuilder builder = new ProcessBuilder(cmd);
        if(gdalData != null)
            builder.environment().put("GDAL_DATA", gdalData);
        builder.redirectErrorStream(true);
        Process p = builder.start();
        BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));
        String line = null;
        while ((line = reader.readLine()) != null) {
            if (sb != null) {
                sb.append("\n");
                sb.append(line);
            }
        }
        return p.waitFor();
    }
}

<code block>

package org.geoserver.wfs.response;

import com.thoughtworks.xstream.XStream;


public class OgrConfiguration {
    public static final OgrConfiguration DEFAULT;
    static {
        DEFAULT = new OgrConfiguration();

        DEFAULT.ogr2ogrLocation = "ogr2ogr";

        DEFAULT.formats = new OgrFormat[] {
                new OgrFormat("MapInfo File", "OGR-TAB", ".tab", false, null),
                new OgrFormat("MapInfo File", "OGR-MIF", ".mif", false, null, "-dsco", "FORMAT=MIF"),
                new OgrFormat("CSV", "OGR-CSV", ".csv", true, "text/csv", OgrType.TEXT),
                new OgrFormat("KML", "OGR-KML", ".kml", true, "application/vnd.google-earth.kml", OgrType.XML),
        };
    }

    public String ogr2ogrLocation;
    public String gdalData;
    public OgrFormat[] formats;

    public static void main(String[] args) {

        XStream xstream = Ogr2OgrConfigurator.buildXStream();
        System.out.println(xstream.toXML(OgrConfiguration.DEFAULT));
    }
}

<code block>

package org.geoserver.wfs.response;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.logging.Level;
import java.util.zip.ZipOutputStream;

import org.geoserver.config.GeoServer;
import org.geoserver.data.util.IOUtils;
import org.geoserver.platform.Operation;
import org.geoserver.platform.ServiceException;
import org.geoserver.wfs.WFSException;
import org.geoserver.wfs.WFSGetFeatureOutputFormat;
import org.geoserver.wfs.request.FeatureCollectionResponse;
import org.geoserver.wfs.request.GetFeatureRequest;
import org.geoserver.wfs.request.Query;
import org.geotools.data.DataStore;
import org.geotools.data.shapefile.ShapefileDataStore;
import org.geotools.data.simple.SimpleFeatureCollection;
import org.geotools.data.simple.SimpleFeatureStore;
import org.geotools.data.store.EmptyFeatureCollection;
import org.geotools.feature.simple.SimpleFeatureTypeBuilder;
import org.geotools.gml.producer.FeatureTransformer;
import org.opengis.feature.simple.SimpleFeatureType;
import org.opengis.feature.type.AttributeDescriptor;
import org.opengis.feature.type.GeometryDescriptor;
import org.opengis.feature.type.GeometryType;
import org.opengis.referencing.crs.CoordinateReferenceSystem;

import com.vividsolutions.jts.geom.LineString;
import com.vividsolutions.jts.geom.LinearRing;
import com.vividsolutions.jts.geom.MultiLineString;
import com.vividsolutions.jts.geom.MultiPoint;
import com.vividsolutions.jts.geom.MultiPolygon;
import com.vividsolutions.jts.geom.Point;
import com.vividsolutions.jts.geom.Polygon;

public class Ogr2OgrOutputFormat extends WFSGetFeatureOutputFormat {
    

    private static final Set<Class> SHAPEFILE_GEOM_TYPES = new HashSet<Class>() {
        {
            add(Point.class);
            add(LineString.class);
            add(LinearRing.class);
            add(Polygon.class);
            add(MultiPoint.class);
            add(MultiLineString.class);
            add(MultiPolygon.class);
        }
    };
    

    String ogrPath = null;


    String ogrExecutable = "ogr2ogr";
    

    String gdalData = null;


    static Map<String, OgrFormat> formats = new ConcurrentHashMap<String, OgrFormat>();

    public Ogr2OgrOutputFormat(GeoServer gs) {


        super(gs, formats.keySet());
    }


    public String getOgrExecutable() {
        return ogrExecutable;
    }


    public void setOgrExecutable(String ogrExecutable) {
        this.ogrExecutable = ogrExecutable;
    }
    

    public String getGdalData() {
        return gdalData;
    }


    public void setGdalData(String gdalData) {
        this.gdalData = gdalData;
    }


    public String getMimeType(Object value, Operation operation) throws ServiceException {
        GetFeatureRequest request = GetFeatureRequest.adapt(operation.getParameters()[0]);
        String outputFormat = request.getOutputFormat();
        String mimeType = "";
        OgrFormat format = formats.get(outputFormat);
        if (format == null) {
            throw new WFSException("Unknown output format " + outputFormat);
        } else if (format.singleFile && request.getQueries().size() <= 1) {
            if (format.mimeType != null) {
                mimeType = format.mimeType;
            } else {

                mimeType = "application/octet-stream";
            }
        } else {
            mimeType = "application/zip";
        }
        return mimeType;
    }
    
    @Override
    public boolean canHandle(Operation operation) {

        if(formats.size() == 0) {
            return false;
        } else {
            return super.canHandle(operation);
        }
    }

    @Override
    public String getPreferredDisposition(Object value, Operation operation) {
        return DISPOSITION_ATTACH;
    }
    
    @Override
    public String getAttachmentFileName(Object value, Operation operation) {
        GetFeatureRequest request = GetFeatureRequest.adapt(operation.getParameters()[0]);
        String outputFormat = request.getOutputFormat();
        
        OgrFormat format = formats.get(outputFormat);
        List<Query> queries = request.getQueries();
        if (format == null) {
            throw new WFSException("Unknown output format " + outputFormat);
        } else if (!format.singleFile || queries.size() > 1) {
            String outputFileName = queries.get(0).getTypeNames().get(0).getLocalPart();
            return outputFileName + ".zip";
        } else {
            return null;
        }
    }
    

    public void addFormat(OgrFormat parameters) {
        formats.put(parameters.formatName, parameters);
    }


    public List<OgrFormat> getFormats() {
        return new ArrayList<OgrFormat>(formats.values());
    }


    public void clearFormats() {
        formats.clear();
    }


    @Override
    protected void write(FeatureCollectionResponse featureCollection, OutputStream output, 
        Operation getFeature) throws IOException ,ServiceException {


        GetFeatureRequest request = GetFeatureRequest.adapt(getFeature.getParameters()[0]);
        String outputFormat = request.getOutputFormat();

        OgrFormat format = formats.get(outputFormat);
        if (format == null)
            throw new WFSException("Unknown output format " + outputFormat);



        File tempGS = org.geoserver.data.util.IOUtils.createTempDirectory("ogrtmpin");
        File tempOGR = org.geoserver.data.util.IOUtils.createTempDirectory("ogrtmpout");


        OGRWrapper wrapper = new OGRWrapper(ogrExecutable, gdalData);


        try {
            Iterator outputFeatureCollections = featureCollection.getFeature().iterator();
            SimpleFeatureCollection curCollection;

            File outputFile = null;
            while (outputFeatureCollections.hasNext()) {
                curCollection = (SimpleFeatureCollection) outputFeatureCollections
                        .next();
                

                File intermediate = writeToDisk(tempGS, curCollection);


                final SimpleFeatureType schema = curCollection.getSchema();
                final CoordinateReferenceSystem crs = schema.getCoordinateReferenceSystem();
                outputFile = wrapper.convert(intermediate, tempOGR, schema.getTypeName(), format, crs);


                IOUtils.emptyDirectory(tempGS);
            }
            

            if(format.singleFile && featureCollection.getFeature().size() == 1) {
                FileInputStream fis = null;
                try {
                    fis = new FileInputStream(outputFile);
                    org.apache.commons.io.IOUtils.copy(fis, output);
                } finally {
                    if(fis != null) {
                        fis.close();
                    }
                }
            } else {

                ZipOutputStream zipOut = null;
                try {
                    zipOut = new ZipOutputStream(output);
                    IOUtils.zipDirectory(tempOGR, zipOut, null);
                    zipOut.finish();
                } finally {
                    org.apache.commons.io.IOUtils.closeQuietly(zipOut);
                }
            }


            IOUtils.delete(tempGS);
            IOUtils.delete(tempOGR);
        } catch (Exception e) {
            throw new ServiceException("Exception occurred during output generation", e);
        }
    }
    

    private File writeToDisk(File tempDir,
            SimpleFeatureCollection curCollection) throws Exception {


        final SimpleFeatureType originalSchema = curCollection.getSchema();
        if(curCollection.isEmpty()) {
            if(isShapefileCompatible(originalSchema)) {
                return writeShapefile(tempDir, curCollection);
            } else {
                SimpleFeatureType simplifiedShema = buildShapefileCompatible(originalSchema);
                return writeShapefile(tempDir, new EmptyFeatureCollection(simplifiedShema));
            }
        }
        

        File outFile = new File(tempDir, originalSchema.getTypeName() + ".gml");


        OutputStream os = null;
        try {
            os = new FileOutputStream(outFile);


            FeatureTransformer ft = new FeatureTransformer();
            ft.setNumDecimals(16);
            ft.getFeatureNamespaces().declarePrefix("gs",
                    originalSchema.getName().getNamespaceURI());
            ft.transform(curCollection, os);
        } finally {
            os.close();
        }

        return outFile;
    }
    
    private SimpleFeatureType buildShapefileCompatible(SimpleFeatureType originalSchema) {
        SimpleFeatureTypeBuilder tb = new SimpleFeatureTypeBuilder();
        tb.setName(originalSchema.getName());

        tb.add("the_geom", Point.class, originalSchema.getCoordinateReferenceSystem());

        for (AttributeDescriptor at : originalSchema.getAttributeDescriptors()) {
            if(!(at instanceof GeometryDescriptor)) {
                tb.add(at);
            }
        }
        return tb.buildFeatureType();
    }


    private boolean isShapefileCompatible(SimpleFeatureType schema) {
        GeometryType gt = null;
        for (AttributeDescriptor at : schema.getAttributeDescriptors()) {
            if(at instanceof GeometryDescriptor) {
                if(gt == null)
                    gt = ((GeometryDescriptor) at).getType();
                else

                    return false;
            }
        } 
        
        return gt != null && SHAPEFILE_GEOM_TYPES.contains(gt.getBinding()); 
    }
    
    private File writeShapefile(File tempDir,
            SimpleFeatureCollection collection) {
        SimpleFeatureType schema = collection.getSchema();

        SimpleFeatureStore fstore = null;
        DataStore dstore = null;
        File file = null;
        try {
            file = new File(tempDir, schema.getTypeName() + ".shp");
            dstore = new ShapefileDataStore(file.toURL());
            dstore.createSchema(schema);
            
            fstore = (SimpleFeatureStore) dstore.getFeatureSource(schema.getTypeName());
            fstore.addFeatures(collection);
        } catch (IOException ioe) {
            LOGGER.log(Level.WARNING,
                "Error while writing featuretype '" + schema.getTypeName() + "' to shapefile.", ioe);
            throw new ServiceException(ioe);
        } finally {
            if(dstore != null) {
                dstore.dispose();
            }
        }
        
        return file; 
    }
    
    @Override
    public List<String> getCapabilitiesElementNames() {
        return getAllCapabilitiesElementNames();
    }

}

<code block>

package org.geoserver.wfs.response;

import java.io.InputStream;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.geoserver.config.util.SecureXStream;
import org.geoserver.platform.GeoServerExtensions;
import org.geoserver.platform.GeoServerResourceLoader;
import org.geoserver.platform.resource.Resource;
import org.geoserver.platform.resource.Resource.Type;
import org.geoserver.platform.resource.ResourceListener;
import org.geoserver.platform.resource.ResourceNotification;
import org.geotools.util.logging.Logging;
import org.springframework.context.ApplicationListener;
import org.springframework.context.event.ContextClosedEvent;

import com.thoughtworks.xstream.XStream;


public class Ogr2OgrConfigurator implements ApplicationListener<ContextClosedEvent> {
    private static final Logger LOGGER = Logging.getLogger(Ogr2OgrConfigurator.class);

    public Ogr2OgrOutputFormat of;

    OGRWrapper wrapper;

    Resource configFile;


    private ResourceListener listener = new ResourceListener() {
        public void changed(ResourceNotification notify) {
            loadConfiguration();
        }
    };

    public Ogr2OgrConfigurator(Ogr2OgrOutputFormat format) {
        this.of = format;

        GeoServerResourceLoader loader = GeoServerExtensions.bean(GeoServerResourceLoader.class);
        configFile = loader.get("ogr2ogr.xml");
        loadConfiguration();
        configFile.addListener( listener );
    }

    public void loadConfiguration() {

        OgrConfiguration configuration = OgrConfiguration.DEFAULT;
        try {
            if (configFile.getType() == Type.RESOURCE) {
                InputStream in = configFile.in();
                try {
                    XStream xstream = buildXStream();
                    configuration = (OgrConfiguration) xstream.fromXML( in);
                }
                finally {
                    in.close();
                }
            }
        } catch (Exception e) {
            LOGGER.log(Level.SEVERE, "Error reading the ogr2ogr.xml configuration file", e);
        }

        if (configuration == null) {
            LOGGER.log(Level.INFO,
                            "Could not find/load the ogr2ogr.xml configuration file, using internal defaults");
        }


        OGRWrapper wrapper = new OGRWrapper(configuration.ogr2ogrLocation, configuration.gdalData);
        Set<String> supported = wrapper.getSupportedFormats();
        of.setOgrExecutable(configuration.ogr2ogrLocation);
        of.setGdalData(configuration.gdalData);
        of.clearFormats();
        for (OgrFormat format : configuration.formats) {
            if (supported.contains(format.ogrFormat)) {
                of.addFormat(format);
            } else {
                LOGGER.severe("Skipping '" + format.formatName + "' as its OGR format '"
                        + format.ogrFormat + "' is not among the ones supported by "
                        + configuration.ogr2ogrLocation);
            }
        }
    }


    static XStream buildXStream() {
        XStream xstream = new SecureXStream();
        xstream.alias("OgrConfiguration", OgrConfiguration.class);
        xstream.alias("Format", OgrFormat.class);
        xstream.allowTypes(new Class[] { OgrConfiguration.class, OgrFormat.class });
        xstream.addImplicitCollection(OgrFormat.class, "options", "option", String.class);
        return xstream;
    }


    public void onApplicationEvent(ContextClosedEvent event) {
        if( configFile != null ){
            configFile.removeListener(listener);
        }
    }

}

<code block>

package org.geoserver.wfs.response;

import static org.junit.Assert.*;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import net.opengis.wfs.FeatureCollectionType;
import net.opengis.wfs.GetFeatureType;
import net.opengis.wfs.WfsFactory;

import org.geoserver.config.impl.GeoServerImpl;
import org.geoserver.platform.Operation;
import org.geoserver.platform.Service;
import org.geotools.data.DataStore;
import org.geotools.data.property.PropertyDataStore;
import org.geotools.feature.FeatureCollection;
import org.geotools.util.Version;
import org.junit.Assume;
import org.junit.Before;
import org.junit.Test;
import org.opengis.filter.Filter;
import org.w3c.dom.Document;
import org.xml.sax.SAXException;

public class Ogr2OgrFormatTest {

    DataStore dataStore;

    Ogr2OgrOutputFormat ogr;

    Operation op;

    FeatureCollectionType fct;

    GetFeatureType gft;

    @Before
    public void setUp() throws Exception {

        Assume.assumeTrue(Ogr2OgrTestUtil.isOgrAvailable());
        

        dataStore = new PropertyDataStore(new File("./src/test/java/org/geoserver/wfs/response"));


        ogr = new Ogr2OgrOutputFormat(new GeoServerImpl());
        ogr.addFormat(new OgrFormat("KML", "OGR-KML", ".kml", true, "application/vnd.google-earth.kml"));
        ogr.addFormat(new OgrFormat("KML", "OGR-KML-ZIP", ".kml", false, "application/vnd.google-earth.kml"));
        ogr.addFormat(new OgrFormat("CSV", "OGR-CSV", ".csv", true, "text/csv"));
        ogr.addFormat(new OgrFormat("SHP", "OGR-SHP", ".shp", false, null));
        ogr.addFormat(new OgrFormat("MapInfo File", "OGR-MIF", ".mif", false, null, "-dsco", "FORMAT=MIF"));
        
        ogr.setOgrExecutable(Ogr2OgrTestUtil.getOgr2Ogr());
        ogr.setGdalData(Ogr2OgrTestUtil.getGdalData());


        gft = WfsFactory.eINSTANCE.createGetFeatureType();
        fct = WfsFactory.eINSTANCE.createFeatureCollectionType();
        op = new Operation("GetFeature", new Service("WFS", null, new Version("1.0.0"), 
                Arrays.asList("GetFeature")), null, new Object[] { gft });
    }

    @Test
    public void testCanHandle() {
        gft.setOutputFormat("OGR-KML");
        assertTrue(ogr.canHandle(op));
        gft.setOutputFormat("OGR-CSV");
        assertTrue(ogr.canHandle(op));
        gft.setOutputFormat("RANDOM_FORMAT");
        assertTrue(ogr.canHandle(op));
    }

    @Test
    public void testContentTypeZip() {
        gft.setOutputFormat("OGR-SHP");
        assertEquals("application/zip", ogr.getMimeType(null, op));
    }
    
    @Test
    public void testContentTypeKml() {
        gft.setOutputFormat("OGR-KML");
        assertEquals("application/vnd.google-earth.kml", ogr.getMimeType(null, op));
    }

    @Test
    public void testSimpleKML() throws Exception {

        FeatureCollection fc = dataStore.getFeatureSource("Buildings").getFeatures();
        fct.getFeature().add(fc);


        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        gft.setOutputFormat("OGR-KML");
        ogr.write(fct, bos, op);


        Document dom = dom(new ByteArrayInputStream(bos.toByteArray()));





        assertEquals("kml", dom.getDocumentElement().getTagName());
        assertEquals(2, dom.getElementsByTagName("Placemark").getLength());
    }
    
    @Test
    public void testZippedKML() throws Exception {

        FeatureCollection fc = dataStore.getFeatureSource("Buildings").getFeatures();
        fct.getFeature().add(fc);


        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        gft.setOutputFormat("OGR-KML-ZIP");
        ogr.write(fct, bos, op);
        

        ZipInputStream zis = new ZipInputStream(new ByteArrayInputStream(bos.toByteArray()));
        Document dom = null;
        ZipEntry entry = zis.getNextEntry(); 
        assertEquals("Buildings.kml", entry.getName());
        dom = dom(zis);
        



        assertEquals("kml", dom.getDocumentElement().getTagName());
        assertEquals(2, dom.getElementsByTagName("Placemark").getLength());
    }
    
    @Test
    public void testEmptyKML() throws Exception {

        FeatureCollection fc = dataStore.getFeatureSource("Buildings").getFeatures(Filter.EXCLUDE);
        fct.getFeature().add(fc);


        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        gft.setOutputFormat("OGR-KML");
        ogr.write(fct, bos, op);


        Document dom = dom(new ByteArrayInputStream(bos.toByteArray()));





        assertEquals("kml", dom.getDocumentElement().getTagName());
        assertEquals(0, dom.getElementsByTagName("Placemark").getLength());
    }
    
    @Test
    public void testSimpleCSV() throws Exception {

        FeatureCollection fc = dataStore.getFeatureSource("Buildings").getFeatures();
        fct.getFeature().add(fc);


        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        gft.setOutputFormat("OGR-CSV");
        ogr.write(fct, bos, op);


        String csv = read(new ByteArrayInputStream(bos.toByteArray()));
        

        String[] lines = csv.split("\n");

        assertEquals(3, lines.length);
        assertTrue(csv.contains("123 Main Street"));
    }
    
    @Test
    public void testSimpleMIF() throws Exception {

        FeatureCollection fc = dataStore.getFeatureSource("Buildings").getFeatures();
        fct.getFeature().add(fc);


        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        gft.setOutputFormat("OGR-MIF");
        ogr.write(fct, bos, op);


        ZipInputStream zis = new ZipInputStream(new ByteArrayInputStream(bos.toByteArray()));
        

        Set<String> fileNames = new HashSet<String>();
        ZipEntry entry = null;
        while((entry = zis.getNextEntry()) != null) {
            fileNames.add(entry.getName());
        }
        assertTrue(fileNames.contains("Buildings.mif"));
        assertTrue(fileNames.contains("Buildings.mid"));
    }
    
    @Test
    public void testGeometrylessCSV() throws Exception {

        FeatureCollection fc = dataStore.getFeatureSource("Geometryless").getFeatures();
        fct.getFeature().add(fc);


        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        gft.setOutputFormat("OGR-CSV");
        ogr.write(fct, bos, op);


        String csv = read(new ByteArrayInputStream(bos.toByteArray()));
        

        String[] lines = csv.split("\n");

        assertEquals(4, lines.length);

        assertTrue(csv.contains("Alessia"));
    }
    
    @Test
    public void testAllTypesKML() throws Exception {

        FeatureCollection fc = dataStore.getFeatureSource("AllTypes").getFeatures();
        fct.getFeature().add(fc);


        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        gft.setOutputFormat("OGR-KML");
        ogr.write(fct, bos, op);


        Document dom = dom(new ByteArrayInputStream(bos.toByteArray()));





        assertEquals("kml", dom.getDocumentElement().getTagName());
        assertEquals(6, dom.getElementsByTagName("Placemark").getLength());
    }


    protected void print(Document dom) throws Exception {
        TransformerFactory txFactory = TransformerFactory.newInstance();
        try {
            txFactory.setAttribute("{http://xml.apache.org/xalan}indent-number", new Integer(2));
        } catch (Exception e) {

        }

        Transformer tx = txFactory.newTransformer();
        tx.setOutputProperty(OutputKeys.METHOD, "xml");
        tx.setOutputProperty(OutputKeys.INDENT, "yes");

        tx.transform(new DOMSource(dom), new StreamResult(new OutputStreamWriter(System.out,
                "utf-8")));
    }
    
    protected String read(InputStream is) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(is));
        String line = null;
        StringBuilder sb = new StringBuilder();
        while((line = br.readLine()) != null) {
            sb.append(line);
            sb.append("\n");
        }
        return sb.toString();
    }


    protected Document dom(InputStream input) throws ParserConfigurationException, SAXException,
            IOException {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true);
        factory.setValidating(false);

        DocumentBuilder builder = factory.newDocumentBuilder();
        return builder.parse(input);
    }

}

<code block>

package org.geoserver.wfs.response;

import static org.junit.Assert.*;

import java.util.Set;

import org.junit.Assume;
import org.junit.Before;
import org.junit.Test;

public class OGRWrapperTest {

    private OGRWrapper ogr;

    @Before
    public void setUp() throws Exception {
        Assume.assumeTrue(Ogr2OgrTestUtil.isOgrAvailable());
        ogr = new OGRWrapper(Ogr2OgrTestUtil.getOgr2Ogr(), Ogr2OgrTestUtil.getGdalData());
    }
    
    @Test
    public void testAvaialable() {

        ogr.isAvailable();
    }
    
    @Test
    public void testFormats() {
        Set<String> formats = ogr.getSupportedFormats();

        assertTrue(formats.size() > 0);
        





    }
}

<code block>

package org.geoserver.wfs.response;

import java.io.File;
import java.io.FileInputStream;
import java.util.Properties;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.geotools.util.logging.Logging;

public class Ogr2OgrTestUtil {
    private static Logger LOGGER = Logging.getLogger(Ogr2OgrTestUtil.class);

    private static Boolean IS_OGR_AVAILABLE;
    private static String OGR2OGR;
    private static String GDAL_DATA;

    public static boolean isOgrAvailable() {


        if (IS_OGR_AVAILABLE == null) {
            try {
                File props = new File("./src/test/resources/ogr2ogr.properties");
                Properties p = new Properties();
                p.load(new FileInputStream(props));
                
                OGR2OGR = p.getProperty("ogr2ogr");

                if(OGR2OGR == null)
                    OGR2OGR = "ogr2ogr";
                GDAL_DATA = p.getProperty("gdalData");
                
                OGRWrapper ogr = new OGRWrapper(OGR2OGR, GDAL_DATA);
                IS_OGR_AVAILABLE = ogr.isAvailable();
            } catch (Exception e) {
                IS_OGR_AVAILABLE = false;
                e.printStackTrace();
                LOGGER.log(Level.SEVERE,
                        "Disabling ogr2ogr output format tests, as ogr2ogr lookup failed", e);
            }
        }

        return IS_OGR_AVAILABLE;
    }
    
    public static String getOgr2Ogr() {
        if(isOgrAvailable())
            return OGR2OGR;
        else
            return null;
    }
    
    public static String getGdalData() {
        if(isOgrAvailable())
            return GDAL_DATA;
        else
            return null;
    }
    
    
}

<code block>


package org.geoserver.wps.ogr;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import net.opengis.wfs.GetFeatureType;
import net.opengis.wfs.WfsFactory;

import org.geoserver.ogr.core.Format;
import org.geoserver.platform.Operation;
import org.geoserver.platform.Service;
import org.geoserver.wfs.response.Ogr2OgrOutputFormat;
import org.geoserver.wps.ppio.PPIOFactory;
import org.geoserver.wps.ppio.ProcessParameterIO;
import org.geotools.util.Version;



public class Ogr2OgrPPIOFactory implements PPIOFactory {

    private Ogr2OgrOutputFormat ogr2OgrOutputFormat;

    public Ogr2OgrPPIOFactory(Ogr2OgrOutputFormat ogr2OgrOutputFormat) {
        this.ogr2OgrOutputFormat = ogr2OgrOutputFormat;
    }


    @Override
    public List<ProcessParameterIO> getProcessParameterIO() {
        List<ProcessParameterIO> ogrParams = new ArrayList<ProcessParameterIO>();
        for (Format of : this.ogr2OgrOutputFormat.getFormats()) {
            ProcessParameterIO ppio = null;
            GetFeatureType gft = WfsFactory.eINSTANCE.createGetFeatureType();
            gft.setOutputFormat(of.getGeoserverFormat());
            Operation operation = new Operation("GetFeature", new Service("WFS", null, new Version(
                    "1.1.0"), Arrays.asList("GetFeature")), null, new Object[] { gft });


            String computedMimeType = ogr2OgrOutputFormat.getMimeType(null, operation);
            if (of.getGeoserverFormat() != null && !of.getGeoserverFormat().isEmpty()) {
                computedMimeType = computedMimeType + "; subtype=" + of.getGeoserverFormat();
            }

            if (of.getType() == null) {

                ppio = new OgrBinaryPPIO(computedMimeType, of.getFileExtension(), ogr2OgrOutputFormat,
                        operation);
            } else {
                switch (of.getType()) {
                case BINARY:
                    ppio = new OgrBinaryPPIO(computedMimeType, of.getFileExtension(),
                            ogr2OgrOutputFormat, operation);
                    break;
                case TEXT:
                    ppio = new OgrCDataPPIO(computedMimeType, of.getFileExtension(),
                            ogr2OgrOutputFormat, operation);
                    break;
                case XML:
                    ppio = new OgrXMLPPIO(computedMimeType, of.getFileExtension(), ogr2OgrOutputFormat,
                            operation);
                    break;
                default:
                    break;
                }
            }
            if (ppio != null) {
                ogrParams.add(ppio);
            }
        }
        return ogrParams;
    }
}

<code block>

package org.geoserver.wps.ogr;

import static junit.framework.Assert.assertEquals;
import static org.custommonkey.xmlunit.XMLAssert.assertXpathExists;
import static org.junit.Assert.assertTrue;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import org.custommonkey.xmlunit.SimpleNamespaceContext;
import org.custommonkey.xmlunit.XMLUnit;
import org.custommonkey.xmlunit.XpathEngine;
import org.geoserver.ogr.core.Format;
import org.geoserver.platform.GeoServerExtensions;
import org.geoserver.platform.GeoServerResourceLoader;
import org.geoserver.wfs.response.Ogr2OgrConfigurator;
import org.geoserver.wfs.response.Ogr2OgrTestUtil;
import org.geoserver.wfs.response.OgrConfiguration;
import org.geoserver.wfs.response.OgrFormat;
import org.geoserver.wps.WPSTestSupport;
import org.junit.Assume;
import org.junit.Before;
import org.junit.Test;
import org.w3c.dom.Document;

import com.mockrunner.mock.web.MockHttpServletResponse;
import com.thoughtworks.xstream.XStream;

public class WPSOgrTest extends WPSTestSupport {

    @Before
    public void setUp() throws Exception {
        Assume.assumeTrue(Ogr2OgrTestUtil.isOgrAvailable());
    }

    private File loadConfiguration() throws Exception {
        String ogrConfigruationName = "ogr2ogr.xml";
        GeoServerResourceLoader loader = GeoServerExtensions.bean(GeoServerResourceLoader.class);

        XStream xstream = buildXStream();
        ClassLoader classLoader = getClass().getClassLoader();
        File file = new File(classLoader.getResource(ogrConfigruationName).getFile());
        OgrConfiguration ogrConfiguration = (OgrConfiguration) xstream.fromXML(file);
        ogrConfiguration.ogr2ogrLocation = Ogr2OgrTestUtil.getOgr2Ogr();
        ogrConfiguration.gdalData = Ogr2OgrTestUtil.getGdalData();

        File configuration = loader.createFile(ogrConfigruationName);
        xstream.toXML(ogrConfiguration, new FileOutputStream(configuration));

        Ogr2OgrConfigurator configurator = applicationContext.getBean(Ogr2OgrConfigurator.class);
        configurator.loadConfiguration();

        return configuration;
    }

    @Test
    public void testConfigurationLoad() throws Exception {
        File configuration = null;
        try {
            configuration = loadConfiguration();
            Ogr2OgrConfigurator configurator = applicationContext
                    .getBean(Ogr2OgrConfigurator.class);
            configurator.loadConfiguration();
            List<String> formatNames = new ArrayList<>();
            for (Format f : configurator.of.getFormats()) {
                formatNames.add(f.getGeoserverFormat());
            }
            assertTrue(formatNames.contains("OGR-TAB"));
            assertTrue(formatNames.contains("OGR-MIF"));
            assertTrue(formatNames.contains("OGR-CSV"));
            assertTrue(formatNames.contains("OGR-KML"));
        } catch (IOException e) {
            System.err.println(e.getStackTrace());
        } finally {
            if (configuration != null) {
                configuration.delete();
            }
        }
    }

    @Test
    public void testDescribeProcess() throws Exception {
        OgrConfiguration.DEFAULT.ogr2ogrLocation = Ogr2OgrTestUtil.getOgr2Ogr();
        OgrConfiguration.DEFAULT.gdalData = Ogr2OgrTestUtil.getGdalData();
        Ogr2OgrConfigurator configurator = applicationContext.getBean(Ogr2OgrConfigurator.class);
        configurator.loadConfiguration();
        Document d = getAsDOM(root()
                + "service=wps&request=describeprocess&identifier=gs:BufferFeatureCollection");
        String base = "/wps:ProcessDescriptions/ProcessDescription/ProcessOutputs";
        for (Format f : OgrConfiguration.DEFAULT.getFormats()) {
            if (f.getMimeType() != null) {
                assertXpathExists(base + "/Output[1]/ComplexOutput/Supported/Format[MimeType='"
                        + f.getMimeType() + "; subtype=" + f.getGeoserverFormat() + "']", d);
            }
        }
    }

    @Test
    public void testOGRKMLOutputExecuteRaw() throws Exception {
        File configuration = null;
        try {
            configuration = loadConfiguration();
            Ogr2OgrConfigurator configurator = applicationContext
                    .getBean(Ogr2OgrConfigurator.class);
            configurator.loadConfiguration();
            MockHttpServletResponse r = postAsServletResponse("wps",
                    getWpsRawXML("application/vnd.google-earth.kml; subtype=OGR-KML"));
            assertEquals("application/vnd.google-earth.kml; subtype=OGR-KML", r.getContentType());
            assertTrue(r.getOutputStreamContent().length() > 0);

        } catch (IOException e) {
            System.err.println(e.getStackTrace());
        } finally {
            if (configuration != null) {
                configuration.delete();
            }
        }
    }

    @Test
    public void testOGRKMLOutputExecuteDocument() throws Exception {
        File configuration = null;
        try {
            configuration = loadConfiguration();
            Ogr2OgrConfigurator configurator = applicationContext
                    .getBean(Ogr2OgrConfigurator.class);
            configurator.loadConfiguration();
            Document d = postAsDOM("wps",
                    getWpsDocumentXML("application/vnd.google-earth.kml; subtype=OGR-KML"));
            Map<String, String> m = new HashMap<String, String>();
            m.put("kml", "http://www.opengis.net/kml/2.2");
            org.custommonkey.xmlunit.NamespaceContext ctx = new SimpleNamespaceContext(m);
            XpathEngine engine = XMLUnit.newXpathEngine();
            engine.setNamespaceContext(ctx);
            assertEquals(1, engine.getMatchingNodes("//kml:kml/kml:Document/kml:Schema", d)
                    .getLength());
        } catch (IOException e) {
            System.err.println(e.getStackTrace());
        } finally {
            if (configuration != null) {
                configuration.delete();
            }
        }
    }

    @Test
    public void testOGRCSVOutputExecuteDocument() throws Exception {
        File configuration = null;
        try {
            configuration = loadConfiguration();
            Ogr2OgrConfigurator configurator = applicationContext
                    .getBean(Ogr2OgrConfigurator.class);
            configurator.loadConfiguration();
            MockHttpServletResponse r = postAsServletResponse("wps",
                    getWpsRawXML("text/csv; subtype=OGR-CSV"));
            assertEquals("text/csv; subtype=OGR-CSV", r.getContentType());
            assertTrue(r.getOutputStreamContent().length() > 0);
            assertTrue(r.getOutputStreamContent().contains("WKT,gml_id,STATE_NAME"));
        } catch (IOException e) {
            System.err.println(e.getStackTrace());
        } finally {
            if (configuration != null) {
                configuration.delete();
            }
        }
    }

    @Test
    public void testOGRBinaryOutputExecuteDocument() throws Exception {
        File configuration = null;
        try {
            configuration = loadConfiguration();
            Ogr2OgrConfigurator configurator = applicationContext
                    .getBean(Ogr2OgrConfigurator.class);
            configurator.loadConfiguration();
            MockHttpServletResponse r = postAsServletResponse("wps",
                    getWpsRawXML("application/zip; subtype=OGR-TAB"));
            assertEquals("application/zip; subtype=OGR-TAB", r.getContentType());
            ByteArrayInputStream bis = getBinaryInputStream(r);
            ZipInputStream zis = new ZipInputStream(bis);
            ZipEntry entry = null;
            boolean found = false;
            while ((entry = zis.getNextEntry()) != null) {
                final String name = entry.getName();
                zis.closeEntry();
                if (name.equals("feature.tab")) {
                    found = true;
                    break;
                }
            }
            zis.close();
            assertTrue(found);
        } catch (IOException e) {
            System.err.println(e.getStackTrace());
        } finally {
            if (configuration != null) {
                configuration.delete();
            }
        }
    }

    private String getWpsRawXML(String ouputMime) throws Exception {
        String xml = "<wps:Execute service='WPS' version='1.0.0' xmlns:wps='http://www.opengis.net/wps/1.0.0' "
                + "xmlns:ows='http://www.opengis.net/ows/1.1'>"
                + "<ows:Identifier>gs:BufferFeatureCollection</ows:Identifier>"
                + "<wps:DataInputs>"
                + "<wps:Input>"
                + "<ows:Identifier>features</ows:Identifier>"
                + "<wps:Data>"
                + "<wps:ComplexData mimeType=\"application/json\"><![CDATA["
                + readFileIntoString("states-FeatureCollection.json")
                + "]]></wps:ComplexData>"
                + "</wps:Data>"
                + "</wps:Input>"
                + "<wps:Input>"
                + "<ows:Identifier>distance</ows:Identifier>"
                + "<wps:Data>"
                + "<wps:LiteralData>10</wps:LiteralData>"
                + "</wps:Data>"
                + "</wps:Input>"
                + "</wps:DataInputs>"
                + "<wps:ResponseForm>"
                + "<wps:RawDataOutput mimeType=\""
                + ouputMime
                + "\">"
                + "<ows:Identifier>result</ows:Identifier>"
                + "</wps:RawDataOutput>" + "</wps:ResponseForm>" + "</wps:Execute>";
        return xml;
    }

    private String getWpsDocumentXML(String ouputMime) throws Exception {
        String xml = "<wps:Execute service='WPS' version='1.0.0' xmlns:wps='http://www.opengis.net/wps/1.0.0' "
                + "xmlns:ows='http://www.opengis.net/ows/1.1'>"
                + "<ows:Identifier>gs:BufferFeatureCollection</ows:Identifier>"
                + "<wps:DataInputs>"
                + "<wps:Input>"
                + "<ows:Identifier>features</ows:Identifier>"
                + "<wps:Data>"
                + "<wps:ComplexData mimeType=\"application/json\"><![CDATA["
                + readFileIntoString("states-FeatureCollection.json")
                + "]]></wps:ComplexData>"
                + "</wps:Data>"
                + "</wps:Input>"
                + "<wps:Input>"
                + "<ows:Identifier>distance</ows:Identifier>"
                + "<wps:Data>"
                + "<wps:LiteralData>10</wps:LiteralData>"
                + "</wps:Data>"
                + "</wps:Input>"
                + "</wps:DataInputs>"
                + "<wps:ResponseForm>"
                + "<wps:ResponseDocument>"
                + "<wps:Output mimeType=\""
                + ouputMime
                + "\">"
                + "<ows:Identifier>result</ows:Identifier>"
                + "</wps:Output>"
                + "</wps:ResponseDocument>" + "</wps:ResponseForm>" + "</wps:Execute>";
        return xml;
    }

    private static XStream buildXStream() {
        XStream xstream = new XStream();
        xstream.alias("OgrConfiguration", OgrConfiguration.class);
        xstream.alias("Format", OgrFormat.class);
        xstream.addImplicitCollection(OgrFormat.class, "options", "option", String.class);
        return xstream;
    }


}

<code block>

package org.geoserver.wfs.response;

import java.util.ArrayList;
import java.util.Arrays;

import org.geoserver.ogr.core.Format;
import org.geoserver.ogr.core.OutputType;


public class OgrFormat extends Format {
    
    public OgrFormat(String ogrFormat, String formatName, String fileExtension, boolean singleFile,
            String mimeType, OutputType type, String... options) {
        this.ogrFormat = ogrFormat;
        this.formatName = formatName;
        setFileExtension(fileExtension);
        setSingleFile(singleFile);
        setMimeType(mimeType);
        setType(type);
        if (options != null) {
            setOptions(new ArrayList<String>(Arrays.asList(options)));
        }
        if (type == null) {
            setType(OutputType.BINARY);
        }
    }

    public OgrFormat(String toolFormat, String formatName, String fileExtension, boolean singleFile,
            String mimeType, String... options) {
        this(toolFormat, formatName, fileExtension, singleFile, mimeType, OutputType.BINARY, options);
    }


    private String ogrFormat;
    private String formatName;

    @Override
    public String getToolFormat() {
        return ogrFormat;
    }

    @Override
    public String getGeoserverFormat() {
        return formatName;
    }
}

<code block>

package org.geoserver.wfs.response;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.geoserver.ogr.core.AbstractToolWrapper;
import org.geoserver.ogr.core.Format;
import org.geotools.util.logging.Logging;
import org.opengis.referencing.crs.CoordinateReferenceSystem;


public class OGRWrapper extends AbstractToolWrapper {

    private static final Logger LOGGER = Logging.getLogger(OGRWrapper.class);

    private File crsFile;

    public OGRWrapper(String ogrExecutable, Map<String, String> environment) {
        super(ogrExecutable, environment);
    }

    @Override
    public String getToolFormatParameter() {
        return "-f";
    }

    @Override
    public boolean isInputFirst() {
        return false;
    }


    public Set<String> getSupportedFormats() {
        try {

            List<String> commands = new ArrayList<String>();
            commands.add(getExecutable());
            commands.add("--help");
            
            Set<String> formats = new HashSet<String>();
            addFormats(commands, formats);
            

            commands = new ArrayList<String>();
            commands.add(getExecutable());
            commands.add("--long-usage");
            addFormats(commands, formats);

            return formats;
        } catch (Exception e) {
            LOGGER.log(Level.SEVERE,
                    "Could not get the list of output formats supported by ogr2ogr", e);
            return Collections.emptySet();
        }
    }

    private void addFormats(List<String> commands, Set<String> formats) throws IOException,
            InterruptedException {
        StringBuilder sb = new StringBuilder();

        run(commands, sb);
        
        String[] lines = sb.toString().split("\n");
        for (String line : lines) {
            if (line.matches("\\s*-f \".*")) {
                String format = line.substring(line.indexOf('"') + 1, line.lastIndexOf('"'));
                formats.add(format);
            }
        }
    }


    public boolean isAvailable() {
        List<String> commands = new ArrayList<String>();
        commands.add(getExecutable());
        commands.add("--version");

        try {
            return run(commands, null) == 0;
        } catch(Exception e) {
            LOGGER.log(Level.SEVERE, getExecutable() + " is not available", e);
            return false;
        }
    }

    @Override
    public void onBeforeRun(List<String> cmd, File inputData, File outputDirectory,
            String typeName, Format format, CoordinateReferenceSystem crs) throws IOException {
        crsFile = dumpCrs(inputData.getParentFile(), crs);

        if (crsFile != null) {
            cmd.add("-a_srs");
            cmd.add(crsFile.getAbsolutePath());
        }
    }

    @Override
    public void onAfterRun(int exitCode) throws IOException {
        if (crsFile != null) {
            crsFile.delete();
            crsFile = null;
        }
    }

}

<code block>

package org.geoserver.wfs.response;

import java.util.Map;

import org.geoserver.ogr.core.Format;
import org.geoserver.ogr.core.OutputType;
import org.geoserver.ogr.core.ToolConfiguration;

import com.thoughtworks.xstream.XStream;


public class OgrConfiguration extends ToolConfiguration {

    public static final OgrConfiguration DEFAULT;
    static {
        DEFAULT = new OgrConfiguration();

        DEFAULT.ogr2ogrLocation = "ogr2ogr";

        DEFAULT.formats = new OgrFormat[] {
                new OgrFormat("MapInfo File", "OGR-TAB", ".tab", false, null),
                new OgrFormat("MapInfo File", "OGR-MIF", ".mif", false, null, "-dsco", "FORMAT=MIF"),
                new OgrFormat("CSV", "OGR-CSV", ".csv", true, "text/csv", OutputType.TEXT),
                new OgrFormat("KML", "OGR-KML", ".kml", true, "application/vnd.google-earth.kml", OutputType.XML),
        };
    }

    public String ogr2ogrLocation;
    public String gdalData;


    @Override
    public String getExecutable() {
        if (ogr2ogrLocation != null) {
            return ogr2ogrLocation;
        } else {
            return executable;
        }
    }


    @Override
    public Map<String, String> getEnvironment() {
        if (gdalData != null) {
            return java.util.Collections.singletonMap("GDAL_DATA", gdalData);
        } else {
            return environment;
        }
    }

    public static void main(String[] args) {

        XStream xstream = new XStream();
        xstream.alias("OgrConfiguration", OgrConfiguration.class);
        xstream.alias("Format", OgrFormat.class);
        xstream.addImplicitCollection(Format.class, "options", "option", String.class);

        System.out.println(xstream.toXML(OgrConfiguration.DEFAULT));
    }

}

<code block>

package org.geoserver.wfs.response;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.logging.Level;
import java.util.zip.ZipOutputStream;

import org.geoserver.config.GeoServer;
import org.geoserver.data.util.IOUtils;
import org.geoserver.ogr.core.Format;
import org.geoserver.ogr.core.FormatConverter;
import org.geoserver.ogr.core.ToolWrapper;
import org.geoserver.ogr.core.ToolWrapperFactory;
import org.geoserver.platform.Operation;
import org.geoserver.platform.ServiceException;
import org.geoserver.wfs.WFSException;
import org.geoserver.wfs.WFSGetFeatureOutputFormat;
import org.geoserver.wfs.request.FeatureCollectionResponse;
import org.geoserver.wfs.request.GetFeatureRequest;
import org.geoserver.wfs.request.Query;
import org.geotools.data.DataStore;
import org.geotools.data.shapefile.ShapefileDataStore;
import org.geotools.data.simple.SimpleFeatureCollection;
import org.geotools.data.simple.SimpleFeatureStore;
import org.geotools.data.store.EmptyFeatureCollection;
import org.geotools.feature.simple.SimpleFeatureTypeBuilder;
import org.geotools.gml.producer.FeatureTransformer;
import org.opengis.feature.simple.SimpleFeatureType;
import org.opengis.feature.type.AttributeDescriptor;
import org.opengis.feature.type.GeometryDescriptor;
import org.opengis.feature.type.GeometryType;
import org.opengis.referencing.crs.CoordinateReferenceSystem;

import com.vividsolutions.jts.geom.LineString;
import com.vividsolutions.jts.geom.LinearRing;
import com.vividsolutions.jts.geom.MultiLineString;
import com.vividsolutions.jts.geom.MultiPoint;
import com.vividsolutions.jts.geom.MultiPolygon;
import com.vividsolutions.jts.geom.Point;
import com.vividsolutions.jts.geom.Polygon;

public class Ogr2OgrOutputFormat extends WFSGetFeatureOutputFormat implements FormatConverter {
    

    private static final Set<Class> SHAPEFILE_GEOM_TYPES = new HashSet<Class>() {
        {
            add(Point.class);
            add(LineString.class);
            add(LinearRing.class);
            add(Polygon.class);
            add(MultiPoint.class);
            add(MultiLineString.class);
            add(MultiPolygon.class);
        }
    };


    ToolWrapperFactory ogrWrapperFactory;


    String ogrPath = null;


    String ogrExecutable = "ogr2ogr";
    

    Map<String, String> environment = null;


    static Map<String, Format> formats = new ConcurrentHashMap<String, Format>();

    public Ogr2OgrOutputFormat(GeoServer gs, ToolWrapperFactory wrapperFactory) {


        super(gs, formats.keySet());
        this.ogrWrapperFactory = wrapperFactory;
        this.environment = new HashMap<String, String>();
    }


    @Override
    public String getExecutable() {
        return ogrExecutable;
    }


    @Override
    public void setExecutable(String ogrExecutable) {
        this.ogrExecutable = ogrExecutable;
    }


    @Override
    public Map<String, String> getEnvironment() {
        return environment;
    }


    @Override
    public void setEnvironment(Map<String, String> environment) {
        if (environment != null) {
            this.environment.clear();
            this.environment.putAll(environment);
        }
    }


    public String getMimeType(Object value, Operation operation) throws ServiceException {
        GetFeatureRequest request = GetFeatureRequest.adapt(operation.getParameters()[0]);
        String outputFormat = request.getOutputFormat();
        String mimeType = "";
        Format format = formats.get(outputFormat);
        if (format == null) {
            throw new WFSException("Unknown output format " + outputFormat);
        } else if (format.isSingleFile() && request.getQueries().size() <= 1) {
            if (format.getMimeType() != null) {
                mimeType = format.getMimeType();
            } else {

                mimeType = "application/octet-stream";
            }
        } else {
            mimeType = "application/zip";
        }
        return mimeType;
    }
    
    @Override
    public boolean canHandle(Operation operation) {

        if(formats.size() == 0) {
            return false;
        } else {
            return super.canHandle(operation);
        }
    }

    @Override
    public String getPreferredDisposition(Object value, Operation operation) {
        return DISPOSITION_ATTACH;
    }
    
    @Override
    public String getAttachmentFileName(Object value, Operation operation) {
        GetFeatureRequest request = GetFeatureRequest.adapt(operation.getParameters()[0]);
        String outputFormat = request.getOutputFormat();
        
        Format format = formats.get(outputFormat);
        List<Query> queries = request.getQueries();
        if (format == null) {
            throw new WFSException("Unknown output format " + outputFormat);
        } else if (!format.isSingleFile() || queries.size() > 1) {
            String outputFileName = queries.get(0).getTypeNames().get(0).getLocalPart();
            return outputFileName + ".zip";
        } else {
            return null;
        }
    }
    

    @Override
    public void addFormat(Format parameters) {
        formats.put(parameters.getGeoserverFormat(), parameters);
    }


    @Override
    public List<Format> getFormats() {
        return new ArrayList<Format>(formats.values());
    }

    @Override
    public void clearFormats() {
        formats.clear();
    }

    @Override
    public void replaceFormats(List<Format> newFormats) {
        clearFormats();
        for (Format newFormat: newFormats) {
            addFormat(newFormat);
        }
    }


    @Override
    protected void write(FeatureCollectionResponse featureCollection, OutputStream output, 
        Operation getFeature) throws IOException ,ServiceException {


        GetFeatureRequest request = GetFeatureRequest.adapt(getFeature.getParameters()[0]);
        String outputFormat = request.getOutputFormat();

        Format format = formats.get(outputFormat);
        if (format == null)
            throw new WFSException("Unknown output format " + outputFormat);



        File tempGS = org.geoserver.data.util.IOUtils.createTempDirectory("ogrtmpin");
        File tempOGR = org.geoserver.data.util.IOUtils.createTempDirectory("ogrtmpout");


        ToolWrapper wrapper = new OGRWrapper(ogrExecutable, environment);


        try {
            Iterator outputFeatureCollections = featureCollection.getFeature().iterator();
            SimpleFeatureCollection curCollection;

            File outputFile = null;
            while (outputFeatureCollections.hasNext()) {
                curCollection = (SimpleFeatureCollection) outputFeatureCollections
                        .next();
                

                File intermediate = writeToDisk(tempGS, curCollection);


                final SimpleFeatureType schema = curCollection.getSchema();
                final CoordinateReferenceSystem crs = schema.getCoordinateReferenceSystem();
                outputFile = wrapper.convert(intermediate, tempOGR, schema.getTypeName(), format, crs);


                IOUtils.emptyDirectory(tempGS);
            }
            

            if(format.isSingleFile() && featureCollection.getFeature().size() == 1) {
                FileInputStream fis = null;
                try {
                    fis = new FileInputStream(outputFile);
                    org.apache.commons.io.IOUtils.copy(fis, output);
                } finally {
                    if(fis != null) {
                        fis.close();
                    }
                }
            } else {

                ZipOutputStream zipOut = null;
                try {
                    zipOut = new ZipOutputStream(output);
                    IOUtils.zipDirectory(tempOGR, zipOut, null);
                    zipOut.finish();
                } finally {
                    org.apache.commons.io.IOUtils.closeQuietly(zipOut);
                }
            }


            IOUtils.delete(tempGS);
            IOUtils.delete(tempOGR);
        } catch (Exception e) {
            throw new ServiceException("Exception occurred during output generation", e);
        }
    }
    

    private File writeToDisk(File tempDir,
            SimpleFeatureCollection curCollection) throws Exception {


        final SimpleFeatureType originalSchema = curCollection.getSchema();
        if(curCollection.isEmpty()) {
            if(isShapefileCompatible(originalSchema)) {
                return writeShapefile(tempDir, curCollection);
            } else {
                SimpleFeatureType simplifiedShema = buildShapefileCompatible(originalSchema);
                return writeShapefile(tempDir, new EmptyFeatureCollection(simplifiedShema));
            }
        }
        

        File outFile = new File(tempDir, originalSchema.getTypeName() + ".gml");


        OutputStream os = null;
        try {
            os = new FileOutputStream(outFile);


            FeatureTransformer ft = new FeatureTransformer();
            ft.setNumDecimals(16);
            ft.getFeatureNamespaces().declarePrefix("gs",
                    originalSchema.getName().getNamespaceURI());
            ft.transform(curCollection, os);
        } finally {
            os.close();
        }

        return outFile;
    }
    
    private SimpleFeatureType buildShapefileCompatible(SimpleFeatureType originalSchema) {
        SimpleFeatureTypeBuilder tb = new SimpleFeatureTypeBuilder();
        tb.setName(originalSchema.getName());

        tb.add("the_geom", Point.class, originalSchema.getCoordinateReferenceSystem());

        for (AttributeDescriptor at : originalSchema.getAttributeDescriptors()) {
            if(!(at instanceof GeometryDescriptor)) {
                tb.add(at);
            }
        }
        return tb.buildFeatureType();
    }


    private boolean isShapefileCompatible(SimpleFeatureType schema) {
        GeometryType gt = null;
        for (AttributeDescriptor at : schema.getAttributeDescriptors()) {
            if(at instanceof GeometryDescriptor) {
                if(gt == null)
                    gt = ((GeometryDescriptor) at).getType();
                else

                    return false;
            }
        } 
        
        return gt != null && SHAPEFILE_GEOM_TYPES.contains(gt.getBinding()); 
    }
    
    private File writeShapefile(File tempDir,
            SimpleFeatureCollection collection) {
        SimpleFeatureType schema = collection.getSchema();

        SimpleFeatureStore fstore = null;
        DataStore dstore = null;
        File file = null;
        try {
            file = new File(tempDir, schema.getTypeName() + ".shp");
            dstore = new ShapefileDataStore(file.toURL());
            dstore.createSchema(schema);
            
            fstore = (SimpleFeatureStore) dstore.getFeatureSource(schema.getTypeName());
            fstore.addFeatures(collection);
        } catch (IOException ioe) {
            LOGGER.log(Level.WARNING,
                "Error while writing featuretype '" + schema.getTypeName() + "' to shapefile.", ioe);
            throw new ServiceException(ioe);
        } finally {
            if(dstore != null) {
                dstore.dispose();
            }
        }
        
        return file; 
    }
    
    @Override
    public List<String> getCapabilitiesElementNames() {
        return getAllCapabilitiesElementNames();
    }

}

<code block>

package org.geoserver.wfs.response;

import org.geoserver.ogr.core.AbstractToolConfigurator;
import org.geoserver.ogr.core.ToolConfiguration;
import org.geoserver.ogr.core.ToolWrapperFactory;

import com.thoughtworks.xstream.XStream;


public class Ogr2OgrConfigurator extends AbstractToolConfigurator {

    public Ogr2OgrConfigurator(Ogr2OgrOutputFormat format, ToolWrapperFactory wrapperFactory) {
        super(format, wrapperFactory);
    }

    @Override
    protected String getConfigurationFile() {
        return "ogr2ogr.xml";
    }

    @Override
    protected ToolConfiguration getDefaultConfiguration() {
        return OgrConfiguration.DEFAULT;
    }


    @Override
    protected XStream buildXStream() {
        XStream xstream = super.buildXStream();

        xstream.alias("OgrConfiguration", OgrConfiguration.class);
        xstream.alias("Format", OgrFormat.class);
	xstream.allowTypes(new Class[] { OgrConfiguration.class, OgrFormat.class });

        return xstream;
    }

}

<code block>

package org.geoserver.wfs.response;

import java.util.Map;

import org.geoserver.ogr.core.ToolWrapper;
import org.geoserver.ogr.core.ToolWrapperFactory;


public class OGRWrapperFactory implements ToolWrapperFactory {

    @Override
    public ToolWrapper createWrapper(String executable, Map<String, String> environment) {
        return new OGRWrapper(executable, environment);
    }

}

<code block>

package org.geoserver.wfs.response;

import static org.junit.Assert.*;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import net.opengis.wfs.FeatureCollectionType;
import net.opengis.wfs.GetFeatureType;
import net.opengis.wfs.WfsFactory;

import org.geoserver.config.impl.GeoServerImpl;
import org.geoserver.platform.Operation;
import org.geoserver.platform.Service;
import org.geotools.data.DataStore;
import org.geotools.data.property.PropertyDataStore;
import org.geotools.feature.FeatureCollection;
import org.geotools.util.Version;
import org.junit.Assume;
import org.junit.Before;
import org.junit.Test;
import org.opengis.filter.Filter;
import org.w3c.dom.Document;
import org.xml.sax.SAXException;

public class Ogr2OgrFormatTest {

    DataStore dataStore;

    Ogr2OgrOutputFormat ogr;

    Operation op;

    FeatureCollectionType fct;

    GetFeatureType gft;

    @Before
    public void setUp() throws Exception {

        Assume.assumeTrue(Ogr2OgrTestUtil.isOgrAvailable());
        

        dataStore = new PropertyDataStore(new File("./src/test/java/org/geoserver/wfs/response"));


        ogr = new Ogr2OgrOutputFormat(new GeoServerImpl(), new OGRWrapperFactory());
        ogr.addFormat(new OgrFormat("KML", "OGR-KML", ".kml", true, "application/vnd.google-earth.kml"));
        ogr.addFormat(new OgrFormat("KML", "OGR-KML-ZIP", ".kml", false, "application/vnd.google-earth.kml"));
        ogr.addFormat(new OgrFormat("CSV", "OGR-CSV", ".csv", true, "text/csv"));
        ogr.addFormat(new OgrFormat("SHP", "OGR-SHP", ".shp", false, null));
        ogr.addFormat(new OgrFormat("MapInfo File", "OGR-MIF", ".mif", false, null, "-dsco", "FORMAT=MIF"));
        
        ogr.setExecutable(Ogr2OgrTestUtil.getOgr2Ogr());
        ogr.setEnvironment(Collections.singletonMap("GDAL_DATA", Ogr2OgrTestUtil.getGdalData()));


        gft = WfsFactory.eINSTANCE.createGetFeatureType();
        fct = WfsFactory.eINSTANCE.createFeatureCollectionType();
        op = new Operation("GetFeature", new Service("WFS", null, new Version("1.0.0"), 
                Arrays.asList("GetFeature")), null, new Object[] { gft });
    }

    @Test
    public void testCanHandle() {
        gft.setOutputFormat("OGR-KML");
        assertTrue(ogr.canHandle(op));
        gft.setOutputFormat("OGR-CSV");
        assertTrue(ogr.canHandle(op));
        gft.setOutputFormat("RANDOM_FORMAT");
        assertTrue(ogr.canHandle(op));
    }

    @Test
    public void testContentTypeZip() {
        gft.setOutputFormat("OGR-SHP");
        assertEquals("application/zip", ogr.getMimeType(null, op));
    }
    
    @Test
    public void testContentTypeKml() {
        gft.setOutputFormat("OGR-KML");
        assertEquals("application/vnd.google-earth.kml", ogr.getMimeType(null, op));
    }

    @Test
    public void testSimpleKML() throws Exception {

        FeatureCollection fc = dataStore.getFeatureSource("Buildings").getFeatures();
        fct.getFeature().add(fc);


        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        gft.setOutputFormat("OGR-KML");
        ogr.write(fct, bos, op);


        Document dom = dom(new ByteArrayInputStream(bos.toByteArray()));





        assertEquals("kml", dom.getDocumentElement().getTagName());
        assertEquals(2, dom.getElementsByTagName("Placemark").getLength());
    }
    
    @Test
    public void testZippedKML() throws Exception {

        FeatureCollection fc = dataStore.getFeatureSource("Buildings").getFeatures();
        fct.getFeature().add(fc);


        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        gft.setOutputFormat("OGR-KML-ZIP");
        ogr.write(fct, bos, op);
        

        ZipInputStream zis = new ZipInputStream(new ByteArrayInputStream(bos.toByteArray()));
        Document dom = null;
        ZipEntry entry = zis.getNextEntry(); 
        assertEquals("Buildings.kml", entry.getName());
        dom = dom(zis);
        



        assertEquals("kml", dom.getDocumentElement().getTagName());
        assertEquals(2, dom.getElementsByTagName("Placemark").getLength());
    }
    
    @Test
    public void testEmptyKML() throws Exception {

        FeatureCollection fc = dataStore.getFeatureSource("Buildings").getFeatures(Filter.EXCLUDE);
        fct.getFeature().add(fc);


        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        gft.setOutputFormat("OGR-KML");
        ogr.write(fct, bos, op);


        Document dom = dom(new ByteArrayInputStream(bos.toByteArray()));





        assertEquals("kml", dom.getDocumentElement().getTagName());
        assertEquals(0, dom.getElementsByTagName("Placemark").getLength());
    }
    
    @Test
    public void testSimpleCSV() throws Exception {

        FeatureCollection fc = dataStore.getFeatureSource("Buildings").getFeatures();
        fct.getFeature().add(fc);


        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        gft.setOutputFormat("OGR-CSV");
        ogr.write(fct, bos, op);


        String csv = read(new ByteArrayInputStream(bos.toByteArray()));
        

        String[] lines = csv.split("\n");

        assertEquals(3, lines.length);
        assertTrue(csv.contains("123 Main Street"));
    }
    
    @Test
    public void testSimpleMIF() throws Exception {

        FeatureCollection fc = dataStore.getFeatureSource("Buildings").getFeatures();
        fct.getFeature().add(fc);


        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        gft.setOutputFormat("OGR-MIF");
        ogr.write(fct, bos, op);


        ZipInputStream zis = new ZipInputStream(new ByteArrayInputStream(bos.toByteArray()));
        

        Set<String> fileNames = new HashSet<String>();
        ZipEntry entry = null;
        while((entry = zis.getNextEntry()) != null) {
            fileNames.add(entry.getName());
        }
        assertTrue(fileNames.contains("Buildings.mif"));
        assertTrue(fileNames.contains("Buildings.mid"));
    }
    
    @Test
    public void testGeometrylessCSV() throws Exception {

        FeatureCollection fc = dataStore.getFeatureSource("Geometryless").getFeatures();
        fct.getFeature().add(fc);


        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        gft.setOutputFormat("OGR-CSV");
        ogr.write(fct, bos, op);


        String csv = read(new ByteArrayInputStream(bos.toByteArray()));
        

        String[] lines = csv.split("\n");

        assertEquals(4, lines.length);

        assertTrue(csv.contains("Alessia"));
    }
    
    @Test
    public void testAllTypesKML() throws Exception {

        FeatureCollection fc = dataStore.getFeatureSource("AllTypes").getFeatures();
        fct.getFeature().add(fc);


        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        gft.setOutputFormat("OGR-KML");
        ogr.write(fct, bos, op);


        Document dom = dom(new ByteArrayInputStream(bos.toByteArray()));





        assertEquals("kml", dom.getDocumentElement().getTagName());
        assertEquals(6, dom.getElementsByTagName("Placemark").getLength());
    }


    protected void print(Document dom) throws Exception {
        TransformerFactory txFactory = TransformerFactory.newInstance();
        try {
            txFactory.setAttribute("{http://xml.apache.org/xalan}indent-number", new Integer(2));
        } catch (Exception e) {

        }

        Transformer tx = txFactory.newTransformer();
        tx.setOutputProperty(OutputKeys.METHOD, "xml");
        tx.setOutputProperty(OutputKeys.INDENT, "yes");

        tx.transform(new DOMSource(dom), new StreamResult(new OutputStreamWriter(System.out,
                "utf-8")));
    }
    
    protected String read(InputStream is) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(is));
        String line = null;
        StringBuilder sb = new StringBuilder();
        while((line = br.readLine()) != null) {
            sb.append(line);
            sb.append("\n");
        }
        return sb.toString();
    }


    protected Document dom(InputStream input) throws ParserConfigurationException, SAXException,
            IOException {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true);
        factory.setValidating(false);

        DocumentBuilder builder = factory.newDocumentBuilder();
        return builder.parse(input);
    }

}

<code block>

package org.geoserver.wfs.response;

import static org.junit.Assert.*;

import java.util.Collections;
import java.util.Set;

import org.junit.Assume;
import org.junit.Before;
import org.junit.Test;

public class OGRWrapperTest {

    private OGRWrapper ogr;

    @Before
    public void setUp() throws Exception {
        Assume.assumeTrue(Ogr2OgrTestUtil.isOgrAvailable());
        ogr = new OGRWrapper(Ogr2OgrTestUtil.getOgr2Ogr(), Collections.singletonMap("GDAL_DATA",
                Ogr2OgrTestUtil.getGdalData()));
    }
    
    @Test
    public void testAvaialable() {

        ogr.isAvailable();
    }
    
    @Test
    public void testFormats() {
        Set<String> formats = ogr.getSupportedFormats();

        assertTrue(formats.size() > 0);
        





    }
}

<code block>

package org.geoserver.wfs.response;

import java.io.File;
import java.io.FileInputStream;
import java.util.Collections;
import java.util.Properties;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.geotools.util.logging.Logging;

public class Ogr2OgrTestUtil {
    private static Logger LOGGER = Logging.getLogger(Ogr2OgrTestUtil.class);

    private static Boolean IS_OGR_AVAILABLE;
    private static String OGR2OGR;
    private static String GDAL_DATA;

    public static boolean isOgrAvailable() {


        if (IS_OGR_AVAILABLE == null) {
            try {
                File props = new File("./src/test/resources/ogr2ogr.properties");
                Properties p = new Properties();
                p.load(new FileInputStream(props));
                
                OGR2OGR = p.getProperty("ogr2ogr");

                if(OGR2OGR == null)
                    OGR2OGR = "ogr2ogr";
                GDAL_DATA = p.getProperty("gdalData");
                
                OGRWrapper ogr = new OGRWrapper(OGR2OGR, Collections.singletonMap("GDAL_DATA", GDAL_DATA));
                IS_OGR_AVAILABLE = ogr.isAvailable();
            } catch (Exception e) {
                IS_OGR_AVAILABLE = false;
                e.printStackTrace();
                LOGGER.log(Level.SEVERE,
                        "Disabling ogr2ogr output format tests, as ogr2ogr lookup failed", e);
            }
        }

        return IS_OGR_AVAILABLE;
    }
    
    public static String getOgr2Ogr() {
        if(isOgrAvailable())
            return OGR2OGR;
        else
            return null;
    }
    
    public static String getGdalData() {
        if(isOgrAvailable())
            return GDAL_DATA;
        else
            return null;
    }
    
    
}

<code block>

package org.geoserver.ogr.core;

import java.util.List;
import java.util.Map;


public interface FormatConverter {


    public String getExecutable();


    public void setExecutable(String executable);


    public Map<String, String> getEnvironment();


    public void setEnvironment(Map<String, String> environment);


    public void addFormat(Format format);


    public List<Format> getFormats();


    public void clearFormats();


    public void replaceFormats(List<Format> formats);

}

<code block>

package org.geoserver.ogr.core;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;


public class Format {

    private String toolFormat;


    private String geoserverFormat;


    private String fileExtension;


    private List<String> options;


    private OutputType type;


    private boolean singleFile;


    private String mimeType;

    public Format() {
        this.options = Collections.emptyList();
    }

    public Format(String toolFormat, String formatName, String fileExtension, boolean singleFile,
            String mimeType, OutputType type, String... options) {
        this.toolFormat = toolFormat;
        this.geoserverFormat = formatName;
        this.fileExtension = fileExtension;
        this.singleFile = singleFile;
        this.mimeType = mimeType;
        this.type = type;
        if (options != null) {
            this.options = new ArrayList<String>(Arrays.asList(options));
        }
        if (type == null) {
            this.type = OutputType.BINARY;
        }
    }

    public Format(String toolFormat, String formatName, String fileExtension, boolean singleFile,
            String mimeType, String... options) {
        this(toolFormat, formatName, fileExtension, singleFile, mimeType, OutputType.BINARY, options);
    }


    public String getToolFormat() {
        return toolFormat;
    }


    public void setToolFormat(String toolFormat) {
        this.toolFormat = toolFormat;
    }


    public String getGeoserverFormat() {
        return geoserverFormat;
    }


    public void setGeoserverFormat(String geoserverFormat) {
        this.geoserverFormat = geoserverFormat;
    }


    public String getFileExtension() {
        return fileExtension;
    }


    public void setFileExtension(String fileExtension) {
        this.fileExtension = fileExtension;
    }


    public List<String> getOptions() {
        return options;
    }


    public void setOptions(List<String> options) {
        this.options = options;
    }


    public OutputType getType() {
        return type;
    }


    public void setType(OutputType type) {
        this.type = type;
    }


    public boolean isSingleFile() {
        return singleFile;
    }


    public void setSingleFile(boolean singleFile) {
        this.singleFile = singleFile;
    }


    public String getMimeType() {
        return mimeType;
    }


    public void setMimeType(String mimeType) {
        this.mimeType = mimeType;
    }

}

<code block>

package org.geoserver.ogr.core;

import java.util.Map;


public interface ToolWrapperFactory {


    public ToolWrapper createWrapper(String executable, Map<String, String> environment);

}

<code block>

package org.geoserver.ogr.core;

import java.util.Map;



public class ToolConfiguration {

    protected String executable;
    protected Map<String, String> environment;
    protected Format[] formats;

    public ToolConfiguration() {
    }

    public ToolConfiguration(String executable, Map<String, String> environment, Format[] formats) {
        super();
        this.executable = executable;
        this.environment = environment;
        this.formats = formats;
    }


    public String getExecutable() {
        return executable;
    }


    public void setExecutable(String executable) {
        this.executable = executable;
    }


    public Map<String, String> getEnvironment() {
        return environment;
    }


    public void setEnvironment(Map<String, String> environment) {
        this.environment = environment;
    }


    public Format[] getFormats() {
        return formats;
    }


    public void setFormats(Format[] formats) {
        this.formats = formats;
    }

}

<code block>

package org.geoserver.ogr.core;

import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.geoserver.config.util.SecureXStream;
import org.geoserver.platform.GeoServerExtensions;
import org.geoserver.platform.GeoServerResourceLoader;
import org.geoserver.platform.resource.Resource;
import org.geoserver.platform.resource.Resource.Type;
import org.geoserver.platform.resource.ResourceListener;
import org.geoserver.platform.resource.ResourceNotification;
import org.geotools.util.logging.Logging;
import org.springframework.context.ApplicationListener;
import org.springframework.context.event.ContextClosedEvent;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.converters.extended.NamedMapConverter;


public abstract class AbstractToolConfigurator implements ApplicationListener<ContextClosedEvent> {
    private static final Logger LOGGER = Logging.getLogger(AbstractToolConfigurator.class);

    public FormatConverter of;

    protected ToolWrapperFactory wrapperFactory;

    protected Resource configFile;


    protected ResourceListener listener = new ResourceListener() {
        public void changed(ResourceNotification notify) {
            loadConfiguration();
        }
    };


    public AbstractToolConfigurator(FormatConverter formatConverter, ToolWrapperFactory wrapperFactory) {
        this.of = formatConverter;
        this.wrapperFactory = wrapperFactory;

        GeoServerResourceLoader loader = GeoServerExtensions.bean(GeoServerResourceLoader.class);
        configFile = loader.get(getConfigurationFile());
        loadConfiguration();
        configFile.addListener( listener );
    }


    protected abstract String getConfigurationFile();


    protected abstract ToolConfiguration getDefaultConfiguration();


    public void loadConfiguration() {

        ToolConfiguration configuration = getDefaultConfiguration();
        try {
            if (configFile.getType() == Type.RESOURCE) {
                InputStream in = configFile.in();
                try {
                    XStream xstream = buildXStream();
                    configuration = (ToolConfiguration) xstream.fromXML( in);
                }
                finally {
                    in.close();
                }
            }
        } catch (Exception e) {
            LOGGER.log(Level.SEVERE, "Error reading the " + getConfigurationFile() + " configuration file", e);
        }

        if (configuration == null) {
            LOGGER.log(Level.INFO,
                            "Could not find/load the " + getConfigurationFile() + " configuration file, using internal defaults");
            configuration = getDefaultConfiguration();
        }


        if (configuration == null) {
            throw new IllegalStateException("No default configuration available, giving up");
        }


        ToolWrapper wrapper = wrapperFactory.createWrapper(configuration.getExecutable(), configuration.getEnvironment());
        Set<String> supported = wrapper.getSupportedFormats();
        of.setExecutable(configuration.getExecutable());
        of.setEnvironment(configuration.getEnvironment());
        List<Format> toBeAdded = new ArrayList<Format>();
        for (Format format : configuration.getFormats()) {
            if (supported.contains(format.getToolFormat())) {
                toBeAdded.add(format);
            } else {
                LOGGER.severe("Skipping '" + format.getGeoserverFormat() + "' as its tool format '"
                        + format.getToolFormat() + "' is not among the ones supported by "
                        + configuration.getExecutable());
            }
        }

        of.replaceFormats(toBeAdded);
    }


    protected XStream buildXStream() {
        XStream xstream = new SecureXStream();
        xstream.alias("ToolConfiguration", ToolConfiguration.class);
        xstream.alias("Format", Format.class);
        xstream.allowTypes(new Class[] { ToolConfiguration.class, Format.class });
        xstream.addImplicitCollection(Format.class, "options", "option", String.class);
        NamedMapConverter environmentConverter = new NamedMapConverter(xstream
                .getMapper(), "variable", "name", String.class, "value", String.class,
                true, true, xstream.getConverterLookup());
        xstream.registerConverter(environmentConverter);

        return xstream;
    }


    public void onApplicationEvent(ContextClosedEvent event) {
        if( configFile != null ){
            configFile.removeListener(listener);
        }
    }

}

<code block>

package org.geoserver.ogr.core;

import java.io.File;
import java.io.IOException;
import java.util.Map;
import java.util.Set;

import org.opengis.referencing.crs.CoordinateReferenceSystem;


public interface ToolWrapper {


    public String getExecutable();


    public Map<String, String> getEnvironment();


    public String getToolFormatParameter();


    public boolean isInputFirst();


    public Set<String> getSupportedFormats();


    public boolean isAvailable();


    public File convert(File inputData, File outputDirectory, String typeName,
            Format format, CoordinateReferenceSystem crs) throws IOException, InterruptedException;

}

<code block>


package org.geoserver.ogr.core;


public enum OutputType {
    BINARY, TEXT, XML;
}

<code block>

package org.geoserver.ogr.core;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.io.FileUtils;
import org.opengis.referencing.crs.CoordinateReferenceSystem;


public abstract class AbstractToolWrapper implements ToolWrapper {

    private String executable;
    private Map<String, String> environment;

    public AbstractToolWrapper(String executable, Map<String, String> environment) {
        this.executable = executable;
        this.environment = new HashMap<String, String>();
        if (environment != null) {
            this.environment.putAll(environment);
        }
    }

    @Override
    public String getExecutable() {
        return executable;
    }

    @Override
    public Map<String, String> getEnvironment() {
        return new HashMap<String, String>(environment);
    }

    @Override
    public boolean isInputFirst() {
        return true;
    }

    @Override
    public File convert(File inputData, File outputDirectory, String typeName,
            Format format, CoordinateReferenceSystem crs) throws IOException, InterruptedException {

        List<String> cmd = new ArrayList<String>();
        cmd.add(executable);

        String toolFormatParameter = getToolFormatParameter();
        if (toolFormatParameter != null) {
            cmd.add(toolFormatParameter);
            cmd.add(format.getToolFormat());
        }

        if (format.getOptions() != null) {
            for (String option : format.getOptions()) {
                cmd.add(option);
            }
        }

        StringBuilder sb = new StringBuilder();
        String outFileName = null;
        int exitCode = -1;
        try {
            onBeforeRun(cmd, inputData, outputDirectory, typeName, format, crs);

            outFileName = setInputOutput(cmd, inputData, outputDirectory, typeName, format);

            exitCode = run(cmd, sb);
        } finally {
            onAfterRun(exitCode);
        }

        if (exitCode != 0)
            throw new IOException(executable + " did not terminate successfully, exit code " + exitCode
                    + ". Was trying to run: " + cmd + "\nResulted in:\n" + sb);


        File output = new File(outputDirectory, outFileName);
        if(output.isDirectory()) {
            output = new File(output, outFileName);
        }
        return output;
    }


    protected String setInputOutput(List<String> cmd, File inputData, File outputDirectory, String typeName,
            Format format) {
        String outFileName = typeName;

        if (format.getFileExtension() != null)
            outFileName += format.getFileExtension();
        if (isInputFirst()) {
            cmd.add(inputData.getAbsolutePath());
            cmd.add(new File(outputDirectory, outFileName).getAbsolutePath());
        } else {
            cmd.add(new File(outputDirectory, outFileName).getAbsolutePath());
            cmd.add(inputData.getAbsolutePath());
        }

        return outFileName;
    }


    protected static File dumpCrs(File parentDir, CoordinateReferenceSystem crs) throws IOException {
      File crsFile = null;
      if (crs != null) {





          crsFile = File.createTempFile("srs", "wkt", parentDir);
          String s = crs.toWKT();
          s = s.replaceAll("\n\r", "").replaceAll("  ", "");
          FileUtils.writeStringToFile(crsFile, s);
      }

      return crsFile;
    }


    protected void onBeforeRun(List<String> cmd, File inputData, File outputDirectory, String typeName,
            Format format, CoordinateReferenceSystem crs) throws IOException {

    }


    protected void onAfterRun(int exitCode) throws IOException {

    }



    protected int run(List<String> cmd, StringBuilder sb) throws IOException, InterruptedException {

        ProcessBuilder builder = new ProcessBuilder(cmd);
        if(environment != null)
            builder.environment().putAll(environment);
        builder.redirectErrorStream(true);
        Process p = builder.start();
        BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));
        String line = null;
        while ((line = reader.readLine()) != null) {
            if (sb != null) {
                sb.append("\n");
                sb.append(line);
            }
        }
        return p.waitFor();
    }

}

<code block>


package org.geoserver.wps.gdal;

import java.io.InputStream;
import java.io.OutputStream;

import org.geoserver.wcs.response.GdalCoverageResponseDelegate;
import org.geoserver.wps.ppio.CDataPPIO;
import org.geotools.coverage.grid.GridCoverage2D;


public class GdalCDataPPIO extends CDataPPIO {

    private GdalCoverageResponseDelegate delegate;
    private String outputFormat;
    private String fileExtension;

    protected GdalCDataPPIO(String outputFormat, GdalCoverageResponseDelegate delegate, String mimeType) {
        super(GridCoverage2D.class, GridCoverage2D.class, mimeType);
        this.delegate = delegate;
        this.outputFormat = outputFormat;
        this.fileExtension = delegate.getFileExtension(outputFormat);
    }

    @Override
    public void encode(Object value, OutputStream os) throws Exception {
        delegate.encode((GridCoverage2D) value, outputFormat, null, os);
    }

    @Override
    public String getFileExtension() {
        return this.fileExtension;
    }

    @Override
    public PPIODirection getDirection() {
        return PPIODirection.ENCODING;
    }

    @Override
    public Object decode(String input) throws Exception {
        return null;
    }

    @Override
    public Object decode(InputStream input) throws Exception {
        return null;
    }

}

<code block>


package org.geoserver.wps.gdal;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.io.OutputStream;

import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

import org.geoserver.wcs.response.GdalCoverageResponseDelegate;
import org.geoserver.wps.ppio.XMLPPIO;
import org.geotools.coverage.grid.GridCoverage2D;
import org.geotools.gml4wcs.GML;
import org.xml.sax.ContentHandler;
import org.xml.sax.InputSource;
import org.xml.sax.XMLReader;


public class GdalXMLPPIO extends XMLPPIO {

    private GdalCoverageResponseDelegate delegate;
    private String outputFormat;
    private String fileExtension;

    protected GdalXMLPPIO(String outputFormat, GdalCoverageResponseDelegate delegate) {
        super(GridCoverage2D.class, GridCoverage2D.class, GML.RectifiedGridType);
        this.delegate = delegate;
        this.outputFormat = outputFormat;
        this.fileExtension = delegate.getFileExtension(outputFormat);
    }

    @Override
    public String getFileExtension() {
        return this.fileExtension;
    }

    @Override
    public PPIODirection getDirection() {
        return PPIODirection.ENCODING;
    }

    @Override
    public Object decode(InputStream input) throws Exception {
        return null;
    }

    @Override
    public void encode(Object value, OutputStream os) throws Exception {
        delegate.encode((GridCoverage2D) value, outputFormat, null, os);
    }

    @Override
    public void encode(Object value, ContentHandler handler) throws Exception {
        ByteArrayOutputStream os = new ByteArrayOutputStream();
        encode(value, os);

        InputStream bis = new ByteArrayInputStream(os.toByteArray());
        SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();
        SAXParser saxParser = saxParserFactory.newSAXParser();
        XMLReader parser = saxParser.getXMLReader();
        parser.setContentHandler(handler);
        parser.parse(new InputSource(bis));
    }

}

<code block>


package org.geoserver.wps.gdal;

import java.util.ArrayList;
import java.util.List;

import org.geoserver.ogr.core.Format;
import org.geoserver.wcs.response.GdalCoverageResponseDelegate;
import org.geoserver.wps.ppio.PPIOFactory;
import org.geoserver.wps.ppio.ProcessParameterIO;


public class GdalPPIOFactory implements PPIOFactory {

    private GdalCoverageResponseDelegate delegate;

    public GdalPPIOFactory(GdalCoverageResponseDelegate delegate) {
        this.delegate = delegate;
    }

    @Override
    public List<ProcessParameterIO> getProcessParameterIO() {
        List<ProcessParameterIO> gdalParams = new ArrayList<ProcessParameterIO>();
        for (Format of : this.delegate.getFormats()) {
            ProcessParameterIO ppio = null;
            String computedMimeType = delegate.getMimeType(of.getGeoserverFormat());
            if (of.getGeoserverFormat() != null && !of.getGeoserverFormat().isEmpty()) {
                computedMimeType = computedMimeType + "; subtype=" + of.getGeoserverFormat();
            }
            if (of.getType() == null) {

                ppio = new GdalBinaryPPIO(of.getGeoserverFormat(), delegate, computedMimeType);
            } else {
                switch (of.getType()) {
                case BINARY:
                    ppio = new GdalBinaryPPIO(of.getGeoserverFormat(), delegate, computedMimeType);
                    break;
                case TEXT:
                    ppio = new GdalCDataPPIO(of.getGeoserverFormat(), delegate, computedMimeType);
                    break;
                case XML:
                    ppio = new GdalXMLPPIO(of.getGeoserverFormat(), delegate);
                    break;
                default:
                    break;
                }
            }
            if (ppio != null) {
                gdalParams.add(ppio);
            }
        }
        return gdalParams;
    }

}

<code block>


package org.geoserver.wps.gdal;

import java.io.InputStream;
import java.io.OutputStream;

import org.geoserver.wcs.response.GdalCoverageResponseDelegate;
import org.geoserver.wps.ppio.BinaryPPIO;
import org.geotools.coverage.grid.GridCoverage2D;


public class GdalBinaryPPIO extends BinaryPPIO {

    private GdalCoverageResponseDelegate delegate;
    private String outputFormat;
    private String fileExtension;

    protected GdalBinaryPPIO(String outputFormat, GdalCoverageResponseDelegate delegate, String mimeType) {
        super(GridCoverage2D.class, GridCoverage2D.class, mimeType);
        this.delegate = delegate;
        this.outputFormat = outputFormat;
        this.fileExtension = delegate.getFileExtension(outputFormat);
    }

    @Override
    public Object decode(InputStream input) throws Exception {
        return null;
    }

    @Override
    public void encode(Object value, OutputStream os) throws Exception {
        delegate.encode((GridCoverage2D) value, outputFormat, null, os);
    }

    @Override
    public PPIODirection getDirection() {
        return PPIODirection.ENCODING;
    }

    @Override
    public String getFileExtension() {
        return fileExtension;
    }
}

<code block>


package org.geoserver.wps.gdal;

import static org.custommonkey.xmlunit.XMLAssert.assertXpathExists;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import org.geoserver.data.test.MockData;
import org.geoserver.data.test.SystemTestData;
import org.geoserver.ogr.core.Format;
import org.geoserver.wcs.response.GdalConfigurator;
import org.geoserver.wcs.response.GdalCoverageResponseDelegate;
import org.geoserver.wcs.response.GdalTestUtil;
import org.geoserver.wps.WPSTestSupport;
import org.geotools.coverage.grid.GridCoverage2D;
import org.geotools.gce.arcgrid.ArcGridFormat;
import org.geotools.geometry.DirectPosition2D;
import org.geotools.geometry.jts.ReferencedEnvelope;
import org.junit.Assume;
import org.junit.Before;
import org.junit.Test;
import org.w3c.dom.Document;

import com.mockrunner.mock.web.MockHttpServletResponse;
import com.vividsolutions.jts.geom.Envelope;

public class GdalWpsTest extends WPSTestSupport {

    @Override
    protected void onSetUp(SystemTestData testData) throws Exception {
        super.onSetUp(testData);
        
        addWcs11Coverages(testData);
    }

    @Before
    public void setUp() throws Exception {
        Assume.assumeTrue(GdalTestUtil.isGdalAvailable());

        GdalConfigurator.DEFAULT.setExecutable(GdalTestUtil.getGdalTranslate());
        GdalConfigurator.DEFAULT.setEnvironment(GdalTestUtil.getGdalData());


        GdalConfigurator configurator = applicationContext.getBean(GdalConfigurator.class);
        configurator.loadConfiguration();
    }

    @Test
    public void testDescribeProcess() throws Exception {
        GdalCoverageResponseDelegate delegate = applicationContext.getBean(GdalCoverageResponseDelegate.class);

        Document d = getAsDOM(root()
                + "service=wps&request=describeprocess&identifier=gs:CropCoverage");
        String base = "/wps:ProcessDescriptions/ProcessDescription/ProcessOutputs";
        for (Format f : delegate.getFormats()) {
            assertXpathExists(base + "/Output[1]/ComplexOutput/Supported/Format[MimeType='"
                        + delegate.getMimeType(f.getGeoserverFormat()) + "; subtype=" + f.getGeoserverFormat() + "']", d);
        }
    }

    @Test
    public void testCrop() throws Exception {
        String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
                + "<wps:Execute version=\"1.0.0\" service=\"WPS\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://www.opengis.net/wps/1.0.0\" xmlns:wfs=\"http://www.opengis.net/wfs\" xmlns:wps=\"http://www.opengis.net/wps/1.0.0\" xmlns:ows=\"http://www.opengis.net/ows/1.1\" xmlns:gml=\"http://www.opengis.net/gml\" xmlns:ogc=\"http://www.opengis.net/ogc\" xmlns:wcs=\"http://www.opengis.net/wcs/1.1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xsi:schemaLocation=\"http://www.opengis.net/wps/1.0.0 http://schemas.opengis.net/wps/1.0.0/wpsAll.xsd\">\n"
                + "  <ows:Identifier>gs:CropCoverage</ows:Identifier>\n"
                + "  <wps:DataInputs>\n"
                + "    <wps:Input>\n"
                + "      <ows:Identifier>coverage</ows:Identifier>\n"
                + "      <wps:Reference mimeType=\"image/tiff\" xlink:href=\"http://geoserver/wcs\" method=\"POST\">\n"
                + "        <wps:Body>\n"
                + "          <wcs:GetCoverage service=\"WCS\" version=\"1.1.1\">\n"
                + "            <ows:Identifier>" + getLayerId(MockData.TASMANIA_DEM) + "</ows:Identifier>\n"
                + "            <wcs:DomainSubset>\n"
                + "              <gml:BoundingBox crs=\"http://www.opengis.net/gml/srs/epsg.xml#4326\">\n"
                + "                <ows:LowerCorner>-180.0 -90.0</ows:LowerCorner>\n"
                + "                <ows:UpperCorner>180.0 90.0</ows:UpperCorner>\n"
                + "              </gml:BoundingBox>\n"
                + "            </wcs:DomainSubset>\n"
                + "            <wcs:Output format=\"image/tiff\"/>\n"
                + "          </wcs:GetCoverage>\n"
                + "        </wps:Body>\n"
                + "      </wps:Reference>\n"
                + "    </wps:Input>\n"
                + "    <wps:Input>\n"
                + "      <ows:Identifier>cropShape</ows:Identifier>\n"
                + "      <wps:Data>\n"
                + "        <wps:ComplexData mimeType=\"application/wkt\"><![CDATA[POLYGON((145.5 -41.9, 145.5 -42.1, 145.6 -42, 145.5 -41.9))]]></wps:ComplexData>\n"
                + "      </wps:Data>\n" + "    </wps:Input>\n" + "  </wps:DataInputs>\n"
                + "  <wps:ResponseForm>\n"
                + "    <wps:RawDataOutput mimeType=\"application/zip; subtype=GDAL-ArcInfoGrid\">\n"
                + "      <ows:Identifier>result</ows:Identifier>\n" + "    </wps:RawDataOutput>\n"
                + "  </wps:ResponseForm>\n" + "</wps:Execute>\n" + "\n" + "";

        MockHttpServletResponse response = postAsServletResponse(root(), xml);

        ZipInputStream is = new ZipInputStream(getBinaryInputStream(response));
        ZipEntry entry = null;
        boolean arcGridFound = false;
        while ((entry = is.getNextEntry()) != null && !arcGridFound) {
            if (entry.getName().endsWith(".asc")) {
                ArcGridFormat format = new ArcGridFormat();
                GridCoverage2D gc = format.getReader(is).read(null);

                assertTrue(new Envelope(-145.4, 145.6, -41.8, -42.1).contains(new ReferencedEnvelope(gc.getEnvelope())));
                
                double[] valueInside = (double[]) gc.evaluate(new DirectPosition2D(145.55, -42));
                assertEquals(615.0, valueInside[0], 1E-12);
                double[] valueOutside = (double[]) gc.evaluate(new DirectPosition2D(145.57, -41.9));

                assertEquals(55537.0, valueOutside[0], 1E-12);

                gc.dispose(true);

                arcGridFound = true;
            }
        }

        assertTrue(arcGridFound);
    }

    @Test
    public void testCropText() throws Exception {
        String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
                + "<wps:Execute version=\"1.0.0\" service=\"WPS\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://www.opengis.net/wps/1.0.0\" xmlns:wfs=\"http://www.opengis.net/wfs\" xmlns:wps=\"http://www.opengis.net/wps/1.0.0\" xmlns:ows=\"http://www.opengis.net/ows/1.1\" xmlns:gml=\"http://www.opengis.net/gml\" xmlns:ogc=\"http://www.opengis.net/ogc\" xmlns:wcs=\"http://www.opengis.net/wcs/1.1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xsi:schemaLocation=\"http://www.opengis.net/wps/1.0.0 http://schemas.opengis.net/wps/1.0.0/wpsAll.xsd\">\n"
                + "  <ows:Identifier>gs:CropCoverage</ows:Identifier>\n"
                + "  <wps:DataInputs>\n"
                + "    <wps:Input>\n"
                + "      <ows:Identifier>coverage</ows:Identifier>\n"
                + "      <wps:Reference mimeType=\"image/tiff\" xlink:href=\"http://geoserver/wcs\" method=\"POST\">\n"
                + "        <wps:Body>\n"
                + "          <wcs:GetCoverage service=\"WCS\" version=\"1.1.1\">\n"
                + "            <ows:Identifier>" + getLayerId(MockData.TASMANIA_DEM) + "</ows:Identifier>\n"
                + "            <wcs:DomainSubset>\n"
                + "              <gml:BoundingBox crs=\"http://www.opengis.net/gml/srs/epsg.xml#4326\">\n"
                + "                <ows:LowerCorner>-180.0 -90.0</ows:LowerCorner>\n"
                + "                <ows:UpperCorner>180.0 90.0</ows:UpperCorner>\n"
                + "              </gml:BoundingBox>\n"
                + "            </wcs:DomainSubset>\n"
                + "            <wcs:Output format=\"image/tiff\"/>\n"
                + "          </wcs:GetCoverage>\n"
                + "        </wps:Body>\n"
                + "      </wps:Reference>\n"
                + "    </wps:Input>\n"
                + "    <wps:Input>\n"
                + "      <ows:Identifier>cropShape</ows:Identifier>\n"
                + "      <wps:Data>\n"
                + "        <wps:ComplexData mimeType=\"application/wkt\"><![CDATA[POLYGON((145.5 -41.9, 145.5 -42.1, 145.6 -42, 145.5 -41.9))]]></wps:ComplexData>\n"
                + "      </wps:Data>\n" + "    </wps:Input>\n" + "  </wps:DataInputs>\n"
                + "  <wps:ResponseForm>\n"
                + "    <wps:RawDataOutput mimeType=\"text/plain; subtype=GDAL-XYZ\">\n"
                + "      <ows:Identifier>result</ows:Identifier>\n" + "    </wps:RawDataOutput>\n"
                + "  </wps:ResponseForm>\n" + "</wps:Execute>\n" + "\n" + "";

        MockHttpServletResponse response = postAsServletResponse(root(), xml);

        BufferedReader reader = new BufferedReader(new InputStreamReader(getBinaryInputStream(response)));
        String line = null;
        boolean valueInsideFound = false, valueOutsideFound = false;
        double x1 = -145.4, x2 = 145.6, y1 = -42.1, y2 = -41.8;
        while ((line = reader.readLine()) != null) {
           String[] cols = line.split(" ");
           assertTrue(cols.length == 3);

           double x = round(Double.valueOf(cols[0]));
           double y = round(Double.valueOf(cols[1]));
           double value = Double.valueOf(cols[2]);
           assertTrue(x >= x1 && x <= x2);
           assertTrue(y >= y1 && y <= y2);
           if (x == 145.55 && y == -42 && !valueInsideFound) {
                assertEquals(550.0, value, 1E-12);
                valueInsideFound = true;
           }
           if (x == 145.57 && y == -41.9 && !valueOutsideFound) {
                assertEquals(55537.0, value, 1E-12);
                valueOutsideFound = true;
           }
        }

        assertTrue(valueInsideFound);
        assertTrue(valueOutsideFound);
    }

    private double round(double value) {
        return Math.round(value * 100) / 100.0;
    }

}

<code block>

package org.geoserver.wcs.response;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.zip.ZipOutputStream;

import org.geoserver.config.GeoServer;
import org.geoserver.data.util.IOUtils;
import org.geoserver.ogr.core.Format;
import org.geoserver.ogr.core.FormatConverter;
import org.geoserver.ogr.core.ToolWrapper;
import org.geoserver.ogr.core.ToolWrapperFactory;
import org.geoserver.platform.ServiceException;
import org.geoserver.wcs.WCSInfo;
import org.geoserver.wcs.responses.CoverageResponseDelegate;
import org.geotools.coverage.grid.GridCoverage2D;
import org.geotools.coverage.grid.io.AbstractGridFormat;
import org.geotools.gce.geotiff.GeoTiffFormat;
import org.geotools.gce.geotiff.GeoTiffWriteParams;
import org.geotools.gce.geotiff.GeoTiffWriter;
import org.geotools.util.Utilities;
import org.opengis.parameter.GeneralParameterValue;
import org.opengis.parameter.ParameterValueGroup;
import org.opengis.referencing.crs.CoordinateReferenceSystem;
import org.vfny.geoserver.wcs.WcsException;


public class GdalCoverageResponseDelegate implements CoverageResponseDelegate, FormatConverter {

    private static final GeoTiffFormat GEOTIF_FORMAT = new GeoTiffFormat();


    GeoServer geoServer;


    ToolWrapperFactory gdalWrapperFactory;


    String gdalTranslatePath = null;


    String gdalTranslateExecutable = "gdal_translate";


    Map<String, String> environment = null;


    static Map<String, Format> formats = new HashMap<String, Format>();

    static Map<String, Format> formatsByMimeType = new HashMap<String, Format>();


    private ReadWriteLock formatsLock;


    public GdalCoverageResponseDelegate(GeoServer gs, ToolWrapperFactory wrapperFactory) {
        this.formatsLock = new ReentrantReadWriteLock();
        this.geoServer = gs;
        this.gdalWrapperFactory = wrapperFactory;
        this.environment = new HashMap<String, String>();
    }


    @Override
    public String getExecutable() {
        return gdalTranslateExecutable;
    }


    @Override
    public void setExecutable(String gdalTranslate) {
        this.gdalTranslateExecutable = gdalTranslate;
    }


    @Override
    public Map<String, String> getEnvironment() {
        return environment;
    }


    @Override
    public void setEnvironment(Map<String, String> environment) {
        if (environment != null) {
            this.environment.clear();
            this.environment.putAll(environment);
        }
    }


    @Override
    public void addFormat(Format format) {
        if (format == null) {
            throw new IllegalArgumentException("No format provided");
        }

        formatsLock.writeLock().lock();
        try {
            addFormatInternal(format);
        } finally {
            formatsLock.writeLock().unlock();
        }
    }

    private void addFormatInternal(Format format) {
        formats.put(format.getGeoserverFormat().toUpperCase(), format);
        if (format.getMimeType() != null) {
            formatsByMimeType.put(format.getMimeType().toUpperCase(), format);
        }
    }


    @Override
    public List<Format> getFormats() {
        formatsLock.readLock().lock();
        try {
            return new ArrayList<Format>(formats.values());
        } finally {
            formatsLock.readLock().unlock();
        }
    }


    @Override
    public void clearFormats() {
        formatsLock.writeLock().lock();
        try {
            clearFormatsInternal();
        } finally {
            formatsLock.writeLock().unlock();
        }
    }

    private void clearFormatsInternal() {
        formats.clear();
        formatsByMimeType.clear();
    }


    @Override
    public void replaceFormats(List<Format> formats) {
        if (formats == null || formats.isEmpty()) {
            throw new IllegalArgumentException("No formats provided");
        }

        formatsLock.writeLock().lock();
        try {
            clearFormatsInternal();
            for (Format format: formats) {
                if (format != null) {
                    addFormatInternal(format);
                }
            }
        } finally {
            formatsLock.writeLock().unlock();
        }
    }

    @Override
    public boolean canProduce(String outputFormat) {
        try {
            return getGdalFormat(outputFormat) != null;
        } catch (WcsException e) {

            return false;
        }
    }

    @Override
    public String getMimeType(String outputFormat) {
        String mimeType = "";

        Format format = getGdalFormat(outputFormat);
        if (format.isSingleFile()) {
            if (format.getMimeType() != null) {
                mimeType = format.getMimeType();
            } else {

                mimeType = "application/octet-stream";
            }
        } else {
            mimeType = "application/zip";
        }

        return mimeType;
    }

    @Override
    public String getFileExtension(String outputFormat) {
        String extension = "";

        Format format = getGdalFormat(outputFormat);
        if (format.isSingleFile()) {
            if (format.getFileExtension() != null) {
                extension = format.getFileExtension();
            } else {

                extension = "bin";
            }
        } else {
            extension = "zip";
        }


        if (extension.charAt(0) == '.') {
            extension = extension.substring(1);
        }

        return extension;
    }

    private Format getGdalFormat(String outputFormat) {
        Format format = null;

        formatsLock.readLock().lock();
        try {
            format = formats.get(outputFormat.toUpperCase());
            if (format == null) {

                format = formatsByMimeType.get(outputFormat.toUpperCase());
            }
        } finally {
            formatsLock.readLock().unlock();
        }

        if (format == null) {
            throw new WcsException("Unknown output format: " + outputFormat);
        }

        return format;
    }

    @Override
    public void encode(GridCoverage2D coverage, String outputFormat,
            Map<String, String> econdingParameters, OutputStream output) throws ServiceException,
            IOException {
        Utilities.ensureNonNull("sourceCoverage", coverage);


        Format format = getGdalFormat(outputFormat);



        File tempGS = org.geoserver.data.util.IOUtils.createTempDirectory("gdaltmpin");
        File tempGDAL = org.geoserver.data.util.IOUtils.createTempDirectory("gdaltmpout");


        ToolWrapper wrapper = gdalWrapperFactory.createWrapper(gdalTranslateExecutable, environment);


        try {
            File outputFile = null;


            File intermediate = writeToDisk(tempGS, coverage);


            final CoordinateReferenceSystem crs = coverage.getCoordinateReferenceSystem();
            outputFile = wrapper.convert(intermediate, tempGDAL, coverage.getName().toString(),
                    format, crs);


            IOUtils.emptyDirectory(tempGS);


            if(format.isSingleFile()) {
                try (FileInputStream fis = new FileInputStream(outputFile)) {
                    org.apache.commons.io.IOUtils.copy(fis, output);
                }
            } else {

                try (ZipOutputStream zipOut = new ZipOutputStream(output)) {
                    IOUtils.zipDirectory(tempGDAL, zipOut, null);
                    zipOut.finish();
                }
            }
        } catch (Exception e) {
            throw new ServiceException("Exception occurred during output generation", e);
        } finally {

            IOUtils.delete(tempGS);
            IOUtils.delete(tempGDAL);
        }
    }


    private File writeToDisk(File tempDir, GridCoverage2D coverage) throws Exception {


        File outFile = new File(tempDir, coverage.getName().toString() + ".tiff");


        GeoTiffWriter writer = null;
        try {
            writer = (GeoTiffWriter) GEOTIF_FORMAT.getWriter(outFile);


            final GeoTiffWriteParams wp = new GeoTiffWriteParams();

            final ParameterValueGroup writerParams = GEOTIF_FORMAT.getWriteParameters();
            writerParams.parameter(AbstractGridFormat.GEOTOOLS_WRITE_PARAMS.getName().toString()).setValue(wp);

            WCSInfo wcsService = geoServer.getService(WCSInfo.class);
            if(wcsService != null && wcsService.isLatLon()){
                writerParams.parameter(GeoTiffFormat.RETAIN_AXES_ORDER.getName().toString()).setValue(true);
            }


            if (writer != null)
                writer.write(coverage, (GeneralParameterValue[]) writerParams.values()
                        .toArray(new GeneralParameterValue[1]));
        } finally {
            try {
                if (writer != null)
                    writer.dispose();
            } catch (Throwable e) {

            }
            coverage.dispose(false);
        }

        return outFile;
    }

    @Override
    public List<String> getOutputFormats() {
        List<String> outputFormats = null;
        formatsLock.readLock().lock();
        try {
            outputFormats = new ArrayList<String>(formats.keySet());
        } finally {
            formatsLock.readLock().unlock();
        }
        Collections.sort(outputFormats);

        return outputFormats;
    }

    @Override
    public boolean isAvailable() {
        ToolWrapper gdal = gdalWrapperFactory.createWrapper(gdalTranslateExecutable, environment);
        return gdal.isAvailable();
    }

    @Override
    public String getConformanceClass(String format) {
        return "http://www.opengis.net/spec/WCS_coverage-encoding-x" + getMimeType(format);
    }

}

<code block>

package org.geoserver.wcs.response;

import java.util.Map;

import org.geoserver.ogr.core.ToolWrapper;
import org.geoserver.ogr.core.ToolWrapperFactory;


public class GdalWrapperFactory implements ToolWrapperFactory {

    @Override
    public ToolWrapper createWrapper(String executable, Map<String, String> environment) {
        return new GdalWrapper(executable, environment);
    }

}

<code block>

package org.geoserver.wcs.response;

import java.util.HashMap;

import org.geoserver.ogr.core.AbstractToolConfigurator;
import org.geoserver.ogr.core.Format;
import org.geoserver.ogr.core.FormatConverter;
import org.geoserver.ogr.core.OutputType;
import org.geoserver.ogr.core.ToolConfiguration;
import org.geoserver.ogr.core.ToolWrapperFactory;


public class GdalConfigurator extends AbstractToolConfigurator {

    public static final ToolConfiguration DEFAULT;
    static {


        DEFAULT = new ToolConfiguration(
                "gdal_translate",
                new HashMap<String, String>(),
                new Format[] {
                    new Format("JPEG2000", "GDAL-JPEG2000", ".jp2", true, "image/jp2"),
                    new Format("PDF", "GDAL-PDF", ".pdf", true, "application/pdf"),
                    new Format("AAIGrid", "GDAL-ArcInfoGrid", ".asc", false, null),
                    new Format("XYZ", "GDAL-XYZ", ".txt", true, "text/plain", OutputType.TEXT)
                });
    }

    public GdalConfigurator(FormatConverter format, ToolWrapperFactory wrapperFactory) {
        super(format, wrapperFactory);
    }

    @Override
    protected String getConfigurationFile() {
        return "gdal/gdal_translate.xml";
    }

    @Override
    protected ToolConfiguration getDefaultConfiguration() {
        return DEFAULT;
    }

}

<code block>

package org.geoserver.wcs.response;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.geoserver.ogr.core.AbstractToolWrapper;
import org.geoserver.ogr.core.Format;
import org.geotools.util.logging.Logging;
import org.opengis.referencing.crs.CoordinateReferenceSystem;


public class GdalWrapper extends AbstractToolWrapper {

    private static final Logger LOGGER = Logging.getLogger(GdalWrapper.class);

    private File crsFile;

    public GdalWrapper(String executable, Map<String, String> environment) {
        super(executable, environment);
    }


    public Set<String> getSupportedFormats() {
        try {


            List<String> commands = new ArrayList<String>();
            commands.add(getExecutable());
            commands.add("--long-usage");

            Set<String> formats = new HashSet<String>();
            addFormats(commands, formats);

            return formats;
        } catch (Exception e) {
            LOGGER.log(Level.SEVERE,
                    "Could not get the list of output formats supported by gdal_translate", e);
            return Collections.emptySet();
        }
    }


    private void addFormats(List<String> commands, Set<String> formats) throws IOException,
            InterruptedException {
        StringBuilder sb = new StringBuilder();
        run(commands, sb);

        Pattern formatRegExp = Pattern.compile("^\\s{2}(\\w+)\\:\\s");
        String[] lines = sb.toString().split("\n");
        for (String line : lines) {
            Matcher formatMatcher = formatRegExp.matcher(line);
            if (formatMatcher.find()) {
                String format = formatMatcher.group(1);
                formats.add(format);
            }
        }
    }


    public boolean isAvailable() {
        List<String> commands = new ArrayList<String>();
        commands.add(getExecutable());
        commands.add("--version");

        try {
            return run(commands, null) == 0;
        } catch(Exception e) {
            LOGGER.log(Level.SEVERE, "gdal_translate is not available", e);
            return false;
        }
    }

    @Override
    public String getToolFormatParameter() {
        return "-of";
    }

    @Override
    protected void onBeforeRun(List<String> cmd, File inputData, File outputDirectory,
            String typeName, Format format, CoordinateReferenceSystem crs) throws IOException {
        crsFile = dumpCrs(inputData.getParentFile(), crs);

        if (crsFile != null) {
            cmd.add("-a_srs");
            cmd.add(crsFile.getAbsolutePath());
        }
    }

    @Override
    protected void onAfterRun(int exitCode) throws IOException {
        if (crsFile != null) {
            crsFile.delete();
            crsFile = null;
        }
    }

}

<code block>


package org.geoserver.wcs.response;

import static org.junit.Assert.assertTrue;

import java.util.Set;

import org.junit.Assume;
import org.junit.Before;
import org.junit.Test;

public class GdalWrapperTest {

    private GdalWrapper gdal;

    @Before
    public void setUp() throws Exception {
        Assume.assumeTrue(GdalTestUtil.isGdalAvailable());
        gdal = new GdalWrapper(GdalTestUtil.getGdalTranslate(), GdalTestUtil.getGdalData());
    }

    @Test
    public void testAvaialable() {

        gdal.isAvailable();
    }

    @Test
    public void testFormats() {
        Set<String> formats = gdal.getSupportedFormats();

        assertTrue(formats.size() > 0);



        assertTrue(formats.contains("GTiff"));
        assertTrue(formats.contains("PNG"));
        assertTrue(formats.contains("JPEG"));
        assertTrue(formats.contains("PDF"));
        assertTrue(formats.contains("AAIGrid"));
    }
}

<code block>

package org.geoserver.wcs.response;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Collections;
import java.util.Map;
import java.util.Properties;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import org.apache.commons.io.IOUtils;
import org.geotools.referencing.CRS;
import org.geotools.util.logging.Logging;
import org.opengis.referencing.crs.CoordinateReferenceSystem;

public class GdalTestUtil {
    private static Logger LOGGER = Logging.getLogger(GdalTestUtil.class);

    static final String TEST_RESOURCE = "/org/geoserver/data/test/tazdem.tiff";

    static final double[][] TEST_XYZ_DATA = new double[][] {
            { 145.004166666664673, -41.004166666654271, 75 },
            { 145.012499999997999, -41.004166666654271, 64 },
            { 145.020833333331325, -41.004166666654271, 66 },
            { 145.029166666664679, -41.004166666654271, 52 },
            { 145.037499999998005, -41.004166666654271, 53 } };

    static final int TEST_GRID_COLS = 120;
    static final double TEST_GRID_NODATA = -9999;
    static final String[] TEST_GRID_HEADER_LABEL = new String[] {
        "ncols", "nrows", "xllcorner", "yllcorner", "cellsize", "NODATA_value"
    };
    static final double[] TEST_GRID_HEADER_DATA = new double[] {
        TEST_GRID_COLS, 240, 144.999999999998, -42.999999999987, 0.008333333333, TEST_GRID_NODATA
    };

    static final double EQUALS_TOLERANCE = 1E-12;

    private static Boolean IS_GDAL_AVAILABLE;
    private static String GDAL_TRANSLATE;
    private static String GDAL_DATA;

    public static boolean isGdalAvailable() {


        if (IS_GDAL_AVAILABLE == null) {
            try {
                InputStream conf = GdalTestUtil.class.getResourceAsStream("/gdal_translate.properties");
                Properties p = new Properties();
                if (conf != null) {
                    p.load(conf);
                }
                
                GDAL_TRANSLATE = p.getProperty("gdal_translate");

                if(GDAL_TRANSLATE == null)
                    GDAL_TRANSLATE = "gdal_translate";
                GDAL_DATA = p.getProperty("gdalData");
                
                GdalWrapper gdal = new GdalWrapper(GDAL_TRANSLATE, Collections.singletonMap("GDAL_DATA", GDAL_DATA));
                IS_GDAL_AVAILABLE = gdal.isAvailable();
            } catch (Exception e) {
                IS_GDAL_AVAILABLE = false;
                e.printStackTrace();
                LOGGER.log(Level.SEVERE,
                        "Disabling gdal_translate output format tests, as gdal_translate lookup failed", e);
            }
        }

        return IS_GDAL_AVAILABLE;
    }
    
    public static String getGdalTranslate() {
        if(isGdalAvailable())
            return GDAL_TRANSLATE;
        else
            return null;
    }
    
    public static Map<String, String> getGdalData() {
        if(isGdalAvailable())
            return Collections.singletonMap("GDAL_DATA", GDAL_DATA);
        else
            return Collections.emptyMap();
    }
    

    public static void checkXyzData(InputStream is) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(is));
        int maxCount = 5, count = 0;
        String line = null;
        while ((line = reader.readLine()) != null && count < maxCount) {
            String[] cols = line.trim().split(" ");
            assertTrue(cols.length == 3);
            assertEquals(TEST_XYZ_DATA[count][0], (double) Double.valueOf(cols[0]),
                    EQUALS_TOLERANCE);
            assertEquals(TEST_XYZ_DATA[count][1], (double) Double.valueOf(cols[1]),
                    EQUALS_TOLERANCE);
            assertEquals(TEST_XYZ_DATA[count][2], (double) Double.valueOf(cols[2]),
                    EQUALS_TOLERANCE);
            count++;
        }
    }

    public static void checkZippedGridData(InputStream input) throws Exception {
        try (ZipInputStream zis = new ZipInputStream(input)) {


            boolean gridFileFound = false, auxFileFound = false, prjFileFound = false;
            ZipEntry entry = null;
            while ((entry = zis.getNextEntry()) != null) {
                if (entry.getName().matches("^\\w+.asc.aux.xml$")) {
                    auxFileFound = true;

                } else if (entry.getName().matches("^\\w+.prj$")) {
                    prjFileFound = true;

                    checkGridProjection(zis);

                } else if (entry.getName().matches("^\\w+.asc$")) {
                    gridFileFound = true;

                    checkGridContent(zis);
                }
            }
            assertTrue(gridFileFound);
            assertTrue(auxFileFound);
            assertTrue(prjFileFound);
        }
    }

    private static void checkGridProjection(InputStream is) throws Exception {
        String wkt = IOUtils.readLines(is).get(0);
        CoordinateReferenceSystem crs = CRS.parseWKT(wkt);
        assertNotNull(crs);
        assertEquals("GCS_WGS_1984", crs.getName().getCode());
    }

    private static void checkGridContent(InputStream is) throws Exception {
        BufferedReader reader = new BufferedReader(new InputStreamReader(is));
        int row = 0, maxRow = 7;
        String line = null;
        while ((line = reader.readLine()) != null && row < maxRow) {
            String[] cols = line.trim().replaceAll("\\s+", " ").split(" ");
            if (row < TEST_GRID_HEADER_LABEL.length) {
                assertEquals(2, cols.length);
                assertEquals(TEST_GRID_HEADER_LABEL[row], cols[0].trim());
                assertEquals(TEST_GRID_HEADER_DATA[row], Double.valueOf(cols[1].trim()), EQUALS_TOLERANCE);
            } else {
                assertEquals(TEST_GRID_COLS, cols.length);
                assertEquals(75.0, Double.valueOf(cols[0].trim()), EQUALS_TOLERANCE);
            }
            row++;
        }
    }
}

<code block>


package org.geoserver.wcs.response;

import static org.junit.Assert.assertEquals;
import static org.junit.Assume.assumeTrue;

import org.geoserver.wcs2_0.kvp.WCSKVPTestSupport;
import org.junit.Before;
import org.junit.Test;
import org.w3c.dom.Document;

import com.mockrunner.mock.web.MockHttpServletResponse;

public class GdalWcsTest extends WCSKVPTestSupport {

    @Before
    public void setup() {
        assumeTrue(GdalTestUtil.isGdalAvailable());
        GdalConfigurator.DEFAULT.setExecutable(GdalTestUtil.getGdalTranslate());
        GdalConfigurator.DEFAULT.setEnvironment(GdalTestUtil.getGdalData());


        GdalConfigurator configurator = applicationContext.getBean(GdalConfigurator.class);
        configurator.loadConfiguration();
    }

    public boolean isFormatSupported(String mimeType) throws Exception {
        Document dom = getAsDOM("wcs?request=GetCapabilities&service=WCS");

        String exprResult = xpath.evaluate(
                "count(//wcs:ServiceMetadata/wcs:formatSupported[text()='" + mimeType + "'])", dom);
        return "1".equals(exprResult);
    }

    @Test
    public void testUnsupportedFormat() throws Exception {

        MockHttpServletResponse response = getAsServletResponse("wcs?request=GetCoverage&service=WCS&version=2.0.1"
                + "&coverageId=BlueMarble&Format=image/x-mrsid");

        checkOws20Exception(response, 400, "InvalidParameterValue", "format");
    }

    @Test
    public void testGetCoverageJP2K() throws Exception {
        assumeTrue(isFormatSupported("image/jp2"));

        MockHttpServletResponse response = getAsServletResponse("wcs?request=GetCoverage&service=WCS&version=2.0.1"
                + "&coverageId=BlueMarble&Format=image/jp2");

        assertEquals("image/jp2", response.getContentType());
    }

    @Test
    public void testGetCoveragePdfByMimeType() throws Exception {
        assumeTrue(isFormatSupported("application/pdf"));

        MockHttpServletResponse response = getAsServletResponse("wcs?request=GetCoverage&service=WCS&version=2.0.1"
                + "&coverageId=BlueMarble&Format=application/pdf");

        assertEquals("application/pdf", response.getContentType());
    }

    @Test
    public void testGetCoveragePdfByName() throws Exception {
        assumeTrue(isFormatSupported("application/pdf"));

        MockHttpServletResponse response = getAsServletResponse("wcs?request=GetCoverage&service=WCS&version=2.0.1"
                + "&coverageId=BlueMarble&Format=gdal-pdf");


        assertEquals("gdal-pdf", response.getContentType());
    }

    @Test
    public void testGetCoverageArcInfoGrid() throws Exception {
        assumeTrue(isFormatSupported("application/zip"));

        MockHttpServletResponse response = getAsServletResponse("wcs?request=GetCoverage&service=WCS&version=2.0.1"
                + "&coverageId=DEM&Format=GDAL-ArcInfoGrid");


        assertEquals("GDAL-ArcInfoGrid", response.getContentType());

        GdalTestUtil.checkZippedGridData(getBinaryInputStream(response));
    }

    @Test
    public void testGetCoverageXyzGrid() throws Exception {
        assumeTrue(isFormatSupported("text/plain"));

        MockHttpServletResponse response = getAsServletResponse("wcs?request=GetCoverage&service=WCS&version=2.0.1"
                + "&coverageId=DEM&Format=GDAL-XYZ");


        assertEquals("GDAL-XYZ", response.getContentType());

        GdalTestUtil.checkXyzData(getBinaryInputStream(response));
    }

}

<code block>

package org.geoserver.wcs.response;

import static org.geoserver.wcs.response.GdalTestUtil.TEST_RESOURCE;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;

import org.apache.commons.io.IOUtils;
import org.geoserver.config.impl.GeoServerImpl;
import org.geoserver.ogr.core.Format;
import org.geotools.coverage.grid.GridCoverage2D;
import org.geotools.coverage.grid.io.GridCoverage2DReader;
import org.geotools.gce.geotiff.GeoTiffReader;
import org.junit.Assume;
import org.junit.Before;
import org.junit.Test;

public class GdalFormatTest {

    GdalCoverageResponseDelegate gdalCovRespDelegate;

    @Before
    public void setUp() throws Exception {

        Assume.assumeTrue(GdalTestUtil.isGdalAvailable());


        gdalCovRespDelegate = new GdalCoverageResponseDelegate(new GeoServerImpl(), new GdalWrapperFactory());

        for (Format format : GdalConfigurator.DEFAULT.getFormats()) {
            gdalCovRespDelegate.addFormat(format);
        }

        gdalCovRespDelegate.setExecutable(GdalTestUtil.getGdalTranslate());
        gdalCovRespDelegate.setEnvironment(GdalTestUtil.getGdalData());
    }

    @Test
    public void testCanProduce() {
        assertTrue(gdalCovRespDelegate.canProduce("GDAL-JPEG2000"));
        assertTrue(gdalCovRespDelegate.canProduce("GDAL-XYZ"));

        assertFalse(gdalCovRespDelegate.canProduce("GDAL-MrSID"));
    }

    @Test
    public void testContentTypeZip() {
        assertEquals("application/zip", gdalCovRespDelegate.getMimeType("GDAL-ArcInfoGrid"));
        assertEquals("zip", gdalCovRespDelegate.getFileExtension("GDAL-ArcInfoGrid"));
    }

    @Test
    public void testContentTypeJP2K() {
        assertEquals("image/jp2", gdalCovRespDelegate.getMimeType("GDAL-JPEG2000"));
        assertEquals("jp2", gdalCovRespDelegate.getFileExtension("GDAL-JPEG2000"));
    }

    @Test
    public void testContentTypePDF() {
        assertEquals("application/pdf", gdalCovRespDelegate.getMimeType("GDAL-PDF"));
        assertEquals("pdf", gdalCovRespDelegate.getFileExtension("GDAL-PDF"));
    }

    @Test
    public void testContentTypeText() {
        assertEquals("text/plain", gdalCovRespDelegate.getMimeType("GDAL-XYZ"));
        assertEquals("txt", gdalCovRespDelegate.getFileExtension("GDAL-XYZ"));
    }

    @Test
    public void testXYZ() throws Exception {

        File tempFile = prepareInput();
        try {
            GridCoverage2DReader covReader = new GeoTiffReader(tempFile);
            GridCoverage2D cov = covReader.read(null);

            try (ByteArrayOutputStream bos = new ByteArrayOutputStream()) {

                gdalCovRespDelegate.encode(cov, "GDAL-XYZ", null, bos);


                try (InputStream is = new ByteArrayInputStream(bos.toByteArray())) {
                    GdalTestUtil.checkXyzData(is);
                }
            }
        } finally {
            if (tempFile != null) {
                tempFile.delete();
            }
        }
    }

    @Test
    public void testZippedGrid() throws Exception {

        File tempFile = prepareInput();
        try {
            GridCoverage2DReader covReader = new GeoTiffReader(tempFile);
            GridCoverage2D cov = covReader.read(null);

            try (ByteArrayOutputStream bos = new ByteArrayOutputStream()) {

                gdalCovRespDelegate.encode(cov, "GDAL-ArcInfoGrid", null, bos);

                GdalTestUtil.checkZippedGridData(new ByteArrayInputStream(bos.toByteArray()));
            }
        } finally {
            if (tempFile != null) {
                tempFile.delete();
            }
        }
    }

    private File prepareInput() throws IOException {
        File tempFile = File.createTempFile("gdal_wcs_", "_test_data");
        IOUtils.copy(getClass().getResourceAsStream(TEST_RESOURCE), new FileOutputStream(tempFile));
        
        return tempFile;
    }

}

<code block>


package org.geoserver.wfs.xml;

import static org.easymock.EasyMock.expect;
import static org.easymock.classextension.EasyMock.replay;
import static org.easymock.classextension.EasyMock.reset;
import static org.easymock.classextension.EasyMock.verify;
import static org.hamcrest.Matchers.contains;
import static org.hamcrest.Matchers.containsInAnyOrder;
import static org.hamcrest.Matchers.empty;
import static org.hamcrest.Matchers.is;
import static org.junit.Assert.*;

import java.net.NetworkInterface;
import java.util.Collection;
import java.util.Collections;

import org.easymock.classextension.EasyMock;
import org.eclipse.emf.common.util.URI;
import org.geoserver.config.GeoServer;
import org.geoserver.config.GeoServerInfo;
import org.geoserver.wfs.xml.WFSURIHandler.InitStrategy;
import org.junit.After;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Rule;
import org.junit.Test;

public class WFSURIHandlerTest {
    
    @Rule
    public PropertyRule aliases = PropertyRule.system("org.geoserver.wfs.xml.WFSURIHandler.additionalHostnames");
    
    InitStrategy strategy;

    private GeoServer gs;

    private GeoServerInfo config;
    
    @SuppressWarnings("deprecation")
    @Before
    public void setUp() {
        WFSURIHandler.ADDITIONAL_HOSTNAMES.clear();
        WFSURIHandler.ADDRESSES.clear();
        

        strategy = new InitStrategy() {
            public Collection<NetworkInterface> getNetworkInterfaces(){
                return Collections.emptyList();
            }
        };
        
        gs = EasyMock.createMock(GeoServer.class);
        config = EasyMock.createMock(GeoServerInfo.class);
        expect(gs.getGlobal()).andStubReturn(config);
        expect(config.getProxyBaseUrl()).andStubReturn(null);
        replay(gs, config);
    }
    
    @After
    public void tearDown() {
        verify(gs, config);
    }
    
    @Test
    @Ignore
    public void testFromNetworkInterfaces() {

    }
    
    @Test
    public void testDefaultAliases() {
        
        WFSURIHandler.init(strategy);
        
        assertThat(WFSURIHandler.ADDRESSES, empty());
        assertThat(WFSURIHandler.ADDITIONAL_HOSTNAMES, contains("localhost"));
        
    }

    @Test
    public void testOverrideAliasesComma() {
        
        
        aliases.setValue("foo,bar , baz");
        
        WFSURIHandler.init(strategy);
        
        assertThat(WFSURIHandler.ADDRESSES, empty());
        assertThat(WFSURIHandler.ADDITIONAL_HOSTNAMES, containsInAnyOrder("foo", "bar", "baz"));
        
    }

    @Test
    public void testOverrideAliasesSpace() {
        
        aliases.setValue("foo bar  baz ");
        
        WFSURIHandler.init(strategy);
        
        assertThat(WFSURIHandler.ADDRESSES, empty());
        assertThat(WFSURIHandler.ADDITIONAL_HOSTNAMES, containsInAnyOrder("foo", "bar", "baz"));
        
    }
    
    @SuppressWarnings("deprecation")
    protected void setProxyBase(String url) {
        reset(config); {
            expect(config.getProxyBaseUrl()).andStubReturn(url);
        }replay(config);
    }
    
    @Test
    public void testRecognizeReflexiveSimple() {
        
        WFSURIHandler.init(strategy);
        
        WFSURIHandler handler = new WFSURIHandler(gs);
        
        final URI wrongHost = URI.createURI("http://example.com/geoserver/wfs?service=wfs&version=2.0.0&request=DescribeFeatureType");
        final URI notDFT = URI.createURI("http://localhost/geoserver/wfs?service=wfs&version=2.0.0&request=GetCapabilities");
        final URI localDFT = URI.createURI("http://localhost/geoserver/wfs?service=wfs&version=2.0.0&request=DescribeFeatureType");
        assertThat(handler.canHandle(wrongHost), is(false));
        assertThat(handler.canHandle(notDFT), is(false));
        assertThat(handler.canHandle(localDFT), is(true));
    }

    @Test
    public void testRecognizeReflexiveUserAliases() {
        
        aliases.setValue("foo bar baz");
        
        WFSURIHandler.init(strategy);
        
        WFSURIHandler handler = new WFSURIHandler(gs);
        
        final URI wrongHost = URI.createURI("http://example.com/geoserver/wfs?service=wfs&version=2.0.0&request=DescribeFeatureType");
        final URI notDFT = URI.createURI("http://foo/geoserver/wfs?service=wfs&version=2.0.0&request=GetCapabilities");
        final URI fooDFT = URI.createURI("http://foo/geoserver/wfs?service=wfs&version=2.0.0&request=DescribeFeatureType");
        final URI barDFT = URI.createURI("http://bar/geoserver/wfs?service=wfs&version=2.0.0&request=DescribeFeatureType");
        final URI bazDFT = URI.createURI("http://baz/geoserver/wfs?service=wfs&version=2.0.0&request=DescribeFeatureType");
        final URI localhostDFT = URI.createURI("http://localhost/geoserver/wfs?service=wfs&version=2.0.0&request=DescribeFeatureType");
        assertThat(handler.canHandle(wrongHost), is(false));
        assertThat(handler.canHandle(notDFT), is(false));
        assertThat(handler.canHandle(fooDFT), is(true));
        assertThat(handler.canHandle(barDFT), is(true));
        assertThat(handler.canHandle(bazDFT), is(true));
        assertThat(handler.canHandle(localhostDFT), is(false));
    }

    @Test
    public void testRecognizeReflexiveProxy() {
        
        this.setProxyBase("http://foo/geoserver");
        
        WFSURIHandler.init(strategy);
        
        WFSURIHandler handler = new WFSURIHandler(gs);
        
        final URI wrongHost = URI.createURI("http://example.com/geoserver/wfs?service=wfs&version=2.0.0&request=DescribeFeatureType");
        final URI notDFT = URI.createURI("http://foo/geoserver/wfs?service=wfs&version=2.0.0&request=GetCapabilities");
        final URI fooDFT = URI.createURI("http://foo/geoserver/wfs?service=wfs&version=2.0.0&request=DescribeFeatureType");
        assertThat(handler.canHandle(wrongHost), is(false));
        assertThat(handler.canHandle(notDFT), is(false));
        assertThat(handler.canHandle(fooDFT), is(true));
    }

}
<code block>


package org.geoserver.wfs.xml;

import java.util.Properties;


class PropertyRule extends org.junit.rules.ExternalResource {
    final Properties props;
    final String name;
    String oldValue;
    
    public static PropertyRule system(String name) {
        return new PropertyRule(System.getProperties(), name);
    }
    
    public PropertyRule(Properties props, String name) {
        super();
        this.props = props;
        this.name = name;
    }

    public Object getOldValue() {
        return oldValue;
    }

    public void setValue(String value) {
        props.setProperty(name, value);
    }

    public String getName() {
        return name;
    }

    @Override
    protected void before() throws Throwable {
        this.oldValue = props.getProperty(name);
    }

    @Override
    protected void after() {
        if(this.oldValue==null) {
            props.remove(name);
        } else {
            props.setProperty(name, oldValue);
        }
    }
    
}
<code block>


package org.geoserver.wfs.xml;

import static org.easymock.EasyMock.expect;
import static org.easymock.classextension.EasyMock.replay;
import static org.easymock.classextension.EasyMock.reset;
import static org.easymock.classextension.EasyMock.verify;
import static org.hamcrest.Matchers.contains;
import static org.hamcrest.Matchers.containsInAnyOrder;
import static org.hamcrest.Matchers.empty;
import static org.hamcrest.Matchers.is;
import static org.junit.Assert.*;

import java.net.NetworkInterface;
import java.util.Collection;
import java.util.Collections;

import org.easymock.classextension.EasyMock;
import org.eclipse.emf.common.util.URI;
import org.geoserver.config.GeoServer;
import org.geoserver.config.GeoServerInfo;
import org.geoserver.util.PropertyRule;
import org.geoserver.wfs.xml.WFSURIHandler.InitStrategy;
import org.junit.After;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Rule;
import org.junit.Test;

public class WFSURIHandlerTest {
    
    @Rule
    public PropertyRule aliases = PropertyRule.system("org.geoserver.wfs.xml.WFSURIHandler.additionalHostnames");
    
    InitStrategy strategy;

    private GeoServer gs;

    private GeoServerInfo config;
    
    @SuppressWarnings("deprecation")
    @Before
    public void setUp() {
        WFSURIHandler.ADDITIONAL_HOSTNAMES.clear();
        WFSURIHandler.ADDRESSES.clear();
        

        strategy = new InitStrategy() {
            public Collection<NetworkInterface> getNetworkInterfaces(){
                return Collections.emptyList();
            }
        };
        
        gs = EasyMock.createMock(GeoServer.class);
        config = EasyMock.createMock(GeoServerInfo.class);
        expect(gs.getGlobal()).andStubReturn(config);
        expect(config.getProxyBaseUrl()).andStubReturn(null);
        replay(gs, config);
    }
    
    @After
    public void tearDown() {
        verify(gs, config);
    }
    
    @Test
    @Ignore
    public void testFromNetworkInterfaces() {

    }
    
    @Test
    public void testDefaultAliases() {
        
        WFSURIHandler.init(strategy);
        
        assertThat(WFSURIHandler.ADDRESSES, empty());
        assertThat(WFSURIHandler.ADDITIONAL_HOSTNAMES, contains("localhost"));
        
    }

    @Test
    public void testOverrideAliasesComma() {
        
        
        aliases.setValue("foo,bar , baz");
        
        WFSURIHandler.init(strategy);
        
        assertThat(WFSURIHandler.ADDRESSES, empty());
        assertThat(WFSURIHandler.ADDITIONAL_HOSTNAMES, containsInAnyOrder("foo", "bar", "baz"));
        
    }

    @Test
    public void testOverrideAliasesSpace() {
        
        aliases.setValue("foo bar  baz ");
        
        WFSURIHandler.init(strategy);
        
        assertThat(WFSURIHandler.ADDRESSES, empty());
        assertThat(WFSURIHandler.ADDITIONAL_HOSTNAMES, containsInAnyOrder("foo", "bar", "baz"));
        
    }
    
    @SuppressWarnings("deprecation")
    protected void setProxyBase(String url) {
        reset(config); {
            expect(config.getProxyBaseUrl()).andStubReturn(url);
        }replay(config);
    }
    
    @Test
    public void testRecognizeReflexiveSimple() {
        
        WFSURIHandler.init(strategy);
        
        WFSURIHandler handler = new WFSURIHandler(gs);
        
        final URI wrongHost = URI.createURI("http://example.com/geoserver/wfs?service=wfs&version=2.0.0&request=DescribeFeatureType");
        final URI notDFT = URI.createURI("http://localhost/geoserver/wfs?service=wfs&version=2.0.0&request=GetCapabilities");
        final URI localDFT = URI.createURI("http://localhost/geoserver/wfs?service=wfs&version=2.0.0&request=DescribeFeatureType");
        assertThat(handler.canHandle(wrongHost), is(false));
        assertThat(handler.canHandle(notDFT), is(false));
        assertThat(handler.canHandle(localDFT), is(true));
    }

    @Test
    public void testRecognizeReflexiveUserAliases() {
        
        aliases.setValue("foo bar baz");
        
        WFSURIHandler.init(strategy);
        
        WFSURIHandler handler = new WFSURIHandler(gs);
        
        final URI wrongHost = URI.createURI("http://example.com/geoserver/wfs?service=wfs&version=2.0.0&request=DescribeFeatureType");
        final URI notDFT = URI.createURI("http://foo/geoserver/wfs?service=wfs&version=2.0.0&request=GetCapabilities");
        final URI fooDFT = URI.createURI("http://foo/geoserver/wfs?service=wfs&version=2.0.0&request=DescribeFeatureType");
        final URI barDFT = URI.createURI("http://bar/geoserver/wfs?service=wfs&version=2.0.0&request=DescribeFeatureType");
        final URI bazDFT = URI.createURI("http://baz/geoserver/wfs?service=wfs&version=2.0.0&request=DescribeFeatureType");
        final URI localhostDFT = URI.createURI("http://localhost/geoserver/wfs?service=wfs&version=2.0.0&request=DescribeFeatureType");
        assertThat(handler.canHandle(wrongHost), is(false));
        assertThat(handler.canHandle(notDFT), is(false));
        assertThat(handler.canHandle(fooDFT), is(true));
        assertThat(handler.canHandle(barDFT), is(true));
        assertThat(handler.canHandle(bazDFT), is(true));
        assertThat(handler.canHandle(localhostDFT), is(false));
    }

    @Test
    public void testRecognizeReflexiveProxy() {
        
        this.setProxyBase("http://foo/geoserver");
        
        WFSURIHandler.init(strategy);
        
        WFSURIHandler handler = new WFSURIHandler(gs);
        
        final URI wrongHost = URI.createURI("http://example.com/geoserver/wfs?service=wfs&version=2.0.0&request=DescribeFeatureType");
        final URI notDFT = URI.createURI("http://foo/geoserver/wfs?service=wfs&version=2.0.0&request=GetCapabilities");
        final URI fooDFT = URI.createURI("http://foo/geoserver/wfs?service=wfs&version=2.0.0&request=DescribeFeatureType");
        assertThat(handler.canHandle(wrongHost), is(false));
        assertThat(handler.canHandle(notDFT), is(false));
        assertThat(handler.canHandle(fooDFT), is(true));
    }

}
<code block>


package org.geoserver.util;

import java.util.Properties;


public class PropertyRule extends org.junit.rules.ExternalResource {
    final Properties props;
    final String name;
    String oldValue;
    
    public static PropertyRule system(String name) {
        return new PropertyRule(System.getProperties(), name);
    }
    
    public PropertyRule(Properties props, String name) {
        super();
        this.props = props;
        this.name = name;
    }

    public Object getOldValue() {
        return oldValue;
    }

    public void setValue(String value) {
        props.setProperty(name, value);
    }

    public String getName() {
        return name;
    }

    @Override
    protected void before() throws Throwable {
        this.oldValue = props.getProperty(name);
    }

    @Override
    protected void after() {
        if(this.oldValue==null) {
            props.remove(name);
        } else {
            props.setProperty(name, oldValue);
        }
    }
    
}
<code block>

package org.geoserver.importer;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.zip.ZipOutputStream;

import org.apache.commons.fileupload.FileItem;
import org.apache.commons.io.FilenameUtils;
import org.geoserver.data.util.IOUtils;
import org.geotools.util.logging.Logging;
import org.geoserver.importer.job.ProgressMonitor;

import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;

public class Directory extends FileData {

    private static final Logger LOGGER = Logging.getLogger(Directory.class);
    
    private static final long serialVersionUID = 1L;


    protected List<FileData> files = new ArrayList<FileData>();


    boolean recursive;
    String name;

    public Directory(File file) {
        this(file, true);
    }

    public Directory(File file, boolean recursive) {
        super(file);
        this.recursive = recursive;
    }

    public static Directory createNew(File parent) throws IOException {
        File directory = File.createTempFile("tmp", "", parent);
        if (!directory.delete() || !directory.mkdir()) throw new IOException("Error creating temp directory at " + directory.getAbsolutePath());
        return new Directory(directory);
    }

    public static Directory createFromArchive(File archive) throws IOException {
        VFSWorker vfs = new VFSWorker();
        if (!vfs.canHandle(archive)) {
            throw new IOException(archive.getPath() + " is not a recognizable  format");
        }

        String basename = FilenameUtils.getBaseName(archive.getName());
        File dir = new File(archive.getParentFile(), basename);
        int i = 0;
        while (dir.exists()) {
            dir = new File(archive.getParentFile(), basename + i++);
        }
        vfs.extractTo(archive, dir);
        return new Directory(dir);
    }

    public File getFile() {
        return file;
    }

    public List<FileData> getFiles() {
        return files;
    }

    public void unpack(File file) throws IOException {

        VFSWorker vfs = new VFSWorker();
        if (vfs.canHandle(file)) {
            LOGGER.fine("unpacking " + file.getAbsolutePath() + " to " + this.file.getAbsolutePath());
            vfs.extractTo(file, this.file);

            LOGGER.fine("deleting " + file.getAbsolutePath());
            if (!file.delete()) {
                throw new IOException("unable to delete file");
            }
        }
    }
    
    public File child(String name) {
        if (name == null) {

            try {
                return File.createTempFile("child", "tmp", file);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }

        return new File(this.file,name);
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String getName() {
        return this.name != null ? this.name : file.getName();
    }

    @Override
    public void prepare(ProgressMonitor m) throws IOException {
        files = new ArrayList<FileData>();


        LinkedList<File> q = new LinkedList<File>();
        q.add(file);

        while(!q.isEmpty()) {
            File dir = q.poll();

            if (m.isCanceled()){
                return;
            }
            m.setTask("Scanning " + dir.getPath());


            Set<File> all = new LinkedHashSet<File>(Arrays.asList(dir.listFiles(new FilenameFilter() {
                public boolean accept(File dir, String name) {
                    return !new File(dir, name).isDirectory();
                }
            })));


            for (File f : dir.listFiles()) {
                if (f.isHidden()) {
                    all.remove(f);
                    continue;
                }
                if (f.isDirectory()) {
                    if (!recursive && !f.equals(file)) {

                        continue;
                    }




                    if (!"__MACOSX".equals(f.getName())) {
                        Directory d = new Directory(f);
                        d.prepare(m);

                        files.add(d);
                    }

                    continue;
                }



                if ("aux".equalsIgnoreCase(FilenameUtils.getExtension(f.getName()))) {
                    continue;
                }


                DataFormat format = DataFormat.lookup(f);

                if (format != null) {
                    SpatialFile sf = newSpatialFile(f, format);
                    

                    sf.prepare(m);

                    files.add(sf);

                    all.removeAll(sf.allFiles());
                }
            }


            for (File f : all) {
                files.add(new ASpatialFile(f));
            }
        }

        format = format();





























    }


    protected SpatialFile newSpatialFile(File f, DataFormat format) {
        SpatialFile sf = new SpatialFile(f);
        sf.setFormat(format);
        return sf;
    }

    public List<Directory> flatten() {
        List<Directory> flat = new ArrayList<Directory>();

        LinkedList<Directory> q = new LinkedList<Directory>();
        q.addLast(this);
        while(!q.isEmpty()) {
            Directory dir = q.removeFirst();
            flat.add(dir);

            for (Iterator<FileData> it = dir.getFiles().iterator(); it.hasNext(); ) {
                FileData f = it.next();
                if (f instanceof Directory) {
                    Directory d = (Directory) f;
                    it.remove();
                    q.addLast(d);
                }
            }
        }

        return flat;
    }


























































    public DataFormat format() throws IOException {
        if (files.isEmpty()) {
            LOGGER.warning("no files recognized");
            return null;
        }

        FileData file = files.get(0);
        DataFormat format = file.getFormat();
        for (int i = 1; i < files.size(); i++) {
            FileData other = files.get(i);
            if (format != null && !format.equals(other.getFormat())) {
                logFormatMismatch();
                return null;
            }
            if (format == null && other.getFormat() != null) {
                logFormatMismatch();
                return null;
            }
        }

        return format;
    }

    private void logFormatMismatch() {
        StringBuilder buf = new StringBuilder("all files are not the same format:\n");
        for (int i = 0; i < files.size(); i++) {
            FileData f = files.get(i);
            String format = "not recognized";
            if (f.getFormat() != null) {
                format = f.getName();
            }
            buf.append(f.getFile().getName()).append(" : ").append(format).append('\n');
        }
        LOGGER.warning(buf.toString());
    }

    public Directory filter(List<FileData> files) {
        Filtered f = new Filtered(file, files);
        f.setFormat(getFormat());
        return f;
    }

    @Override
    public String toString() {
        return file.getPath();
    }

    public void accept(String childName, InputStream in) throws IOException {
        File dest = child(childName);
        
        IOUtils.copy(in, dest);

        try {
            unpack(dest);
        } catch (IOException ioe) {

            LOGGER.warning("Possible invalid file uploaded to " + dest.getAbsolutePath());
            throw ioe;
        }
    }

    public void accept(FileItem item) throws Exception {
        File dest = child(item.getName());
        item.write(dest);

        try {
            unpack(dest);
        } 
        catch (IOException e) {

            LOGGER.warning("Possible invalid file uploaded to " + dest.getAbsolutePath());
            throw e;
        }
    }
    
    public void archive(File output) throws IOException {
        File archiveDir = output.getAbsoluteFile().getParentFile();
        String outputName = output.getName().replace(".zip","");
        int id = 0;
        while (output.exists()) {
            output = new File(archiveDir, outputName + id + ".zip");
            id++;
        }
        ZipOutputStream zout = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(output)));
        Exception error = null;



        try {
            IOUtils.zipDirectory(file, zout, null);
        } catch (Exception ex) {
            error = ex;
            try {
                zout.close();
            } catch (Exception ex2) {

            }
            output.delete();
            if (ex instanceof IOException) throw (IOException) ex;
            throw (IOException) new IOException("Error archiving").initCause(ex);
        } 
        

        try {
            zout.close();
        } finally {
            cleanup();
        }
    }

    @Override
    public void cleanup() throws IOException {
        File[] files = file.listFiles();
        if (files != null) {
            for (File f: files) {
                if (f.isDirectory()) {
                    new Directory(f).cleanup();
                } else {
                    if (LOGGER.isLoggable(Level.FINE)) {
                        LOGGER.fine("Deleting file " + f.getAbsolutePath());
                    }
                    if (!f.delete()) {
                        throw new IOException("unable to delete " + f);
                    }
                }
            }
        }
        super.cleanup();
    }

    @Override
    public FileData part(final String name) {
        List<FileData> files = this.files;
        if (this instanceof Filtered) {
            files = ((Filtered)this).filter;
        }

        try {
            return Iterables.find(files, new Predicate<FileData>() {
                @Override
                public boolean apply(FileData input) {
                    return name.equals(input.getName());
                }
            });
        }
        catch(NoSuchElementException e) {
            return null;
        }
    }

    static class Filtered extends Directory {

        List<FileData> filter;

        public Filtered(File file, List<FileData> filter) {
            super(file);
            this.filter = filter;
        }

        @Override
        public void prepare(ProgressMonitor m) throws IOException {
            super.prepare(m);

            files.retainAll(filter);
            format = format();
        }
    }
}

<code block>

package org.geoserver.importer;

import java.io.File;
import java.io.IOException;
import java.sql.Connection;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.TreeSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.geoserver.catalog.Catalog;
import org.geoserver.catalog.CatalogBuilder;
import org.geoserver.catalog.CoverageInfo;
import org.geoserver.catalog.CoverageStoreInfo;
import org.geoserver.catalog.DataStoreInfo;
import org.geoserver.catalog.FeatureTypeInfo;
import org.geoserver.catalog.LayerInfo;
import org.geoserver.catalog.NamespaceInfo;
import org.geoserver.catalog.ProjectionPolicy;
import org.geoserver.catalog.ResourceInfo;
import org.geoserver.catalog.StoreInfo;
import org.geoserver.catalog.StyleInfo;
import org.geoserver.catalog.WorkspaceInfo;
import org.geoserver.config.util.XStreamPersister;
import org.geoserver.config.util.XStreamPersister.CRSConverter;
import org.geoserver.config.util.XStreamPersisterFactory;
import org.geoserver.importer.ImportTask.State;
import org.geoserver.importer.job.Job;
import org.geoserver.importer.job.JobQueue;
import org.geoserver.importer.job.ProgressMonitor;
import org.geoserver.importer.job.Task;
import org.geoserver.importer.mosaic.Mosaic;
import org.geoserver.importer.transform.RasterTransformChain;
import org.geoserver.importer.transform.ReprojectTransform;
import org.geoserver.importer.transform.TransformChain;
import org.geoserver.importer.transform.VectorTransformChain;
import org.geoserver.platform.ContextLoadedEvent;
import org.geoserver.platform.GeoServerExtensions;
import org.geotools.data.DataStore;
import org.geotools.data.DefaultTransaction;
import org.geotools.data.FeatureReader;
import org.geotools.data.FeatureStore;
import org.geotools.data.FeatureWriter;
import org.geotools.data.Transaction;
import org.geotools.data.directory.DirectoryDataStore;
import org.geotools.data.shapefile.ShapefileDataStore;
import org.geotools.feature.simple.SimpleFeatureTypeBuilder;
import org.geotools.geometry.GeneralEnvelope;
import org.geotools.geometry.jts.ReferencedEnvelope;
import org.geotools.jdbc.JDBCDataStore;
import org.geotools.referencing.CRS;
import org.geotools.util.logging.Logging;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.feature.simple.SimpleFeatureType;
import org.opengis.feature.type.FeatureType;
import org.opengis.filter.Filter;
import org.opengis.referencing.crs.CoordinateReferenceSystem;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.context.ApplicationEvent;
import org.springframework.context.ApplicationListener;

import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import com.google.common.collect.Iterators;
import com.thoughtworks.xstream.XStream;
import com.vividsolutions.jts.geom.Geometry;


public class Importer implements DisposableBean, ApplicationListener {

    static Logger LOGGER = Logging.getLogger(Importer.class);


    Catalog catalog;


    ImportStore contextStore;


    StyleGenerator styleGen;


    JobQueue jobs = new JobQueue();
    
    ConcurrentHashMap<Long,ImportTask> currentlyProcessing = new ConcurrentHashMap<Long, ImportTask>();

    public Importer(Catalog catalog) {
        this.catalog = catalog;
        this.styleGen = new StyleGenerator(catalog);
    }


    public StyleGenerator getStyleGenerator() {
        return styleGen;
    }

    ImportStore createContextStore() {

        ImportStore store = null;

        String name = GeoServerExtensions.getProperty("org.geoserver.importer.store");
        if (name == null) {

            name = GeoServerExtensions.getProperty("org.opengeo.importer.store");
        }

        if (name != null) {
            for (ImportStore bean : GeoServerExtensions.extensions(ImportStore.class)) {
                if (name.equals(bean.getName())) {
                    store = bean;
                    break;
                }
            }

            if (store == null) {
                LOGGER.warning("Invalid value for import store, no such store " + name);
            }
        }

        if (store == null) {
            store = new MemoryImportStore();
        }

        LOGGER.info("Enabling import store: " + store.getName());
        return store;
    }

    public ImportStore getStore() {
        return contextStore;
    }

    public ImportTask getCurrentlyProcessingTask(long contextId) {
        return currentlyProcessing.get(new Long(contextId));
    }

    @Override
    public void onApplicationEvent(ApplicationEvent event) {

        if (event instanceof ContextLoadedEvent) {
            contextStore = createContextStore();
            contextStore.init();
        }
    }

    public Catalog getCatalog() {
        return catalog;
    }

    public ImportContext getContext(long id) {
        ImportContext context = contextStore.get(id);
        return context != null ? reattach(context) : null;
    }

    public ImportContext reattach(ImportContext context) {


        context.reattach(catalog);
        for (ImportTask task : context.getTasks()) {
            StoreInfo store = task.getStore();
            if (store != null && store.getId() != null) {
                task.setStore(catalog.getStore(store.getId(), StoreInfo.class));

            }
            if (task.getLayer() != null) {
                LayerInfo l = task.getLayer();
                if (l.getDefaultStyle() != null && l.getDefaultStyle().getId() != null) {
                    l.setDefaultStyle(catalog.getStyle(l.getDefaultStyle().getId()));
                }
                if (l.getResource() != null) {
                    ResourceInfo r = l.getResource();
                    r.setCatalog(catalog);

                    if (r.getStore() == null && resourceMatchesStore(r, store)) {
                        r.setStore(store);
                    }

                }
            }

        }
        return context;
    }


    public Iterator<ImportContext> getContexts() {
        return contextStore.allNonCompleteImports();
    }

    public Iterator<ImportContext> getContextsByUser(String user) {
        return contextStore.importsByUser(user);
    }
    
    public Iterator<ImportContext> getAllContexts() {
        return contextStore.iterator();
    }
    
    public Iterator<ImportContext> getAllContextsByUpdated() {
        try {
            return contextStore.iterator("updated");
        }
        catch(UnsupportedOperationException e) {

            TreeSet sorted = new TreeSet<ImportContext>(new Comparator<ImportContext>() {
                @Override
                public int compare(ImportContext o1, ImportContext o2) {
                    Date d1 = o1.getUpdated();
                    Date d2 = o2.getUpdated();
                    return -1 * d1.compareTo(d2);
                }
            });
            Iterators.addAll(sorted, contextStore.iterator());
            return sorted.iterator();
        }
    }

    public ImportContext createContext(ImportData data, WorkspaceInfo targetWorkspace) throws IOException {
        return createContext(data, targetWorkspace, null);
    }

    public ImportContext createContext(ImportData data, StoreInfo targetStore) throws IOException {
        return createContext(data, null, targetStore); 
    }

    public ImportContext createContext(ImportData data) throws IOException {
        return createContext(data, null, null); 
    }
    

    public ImportContext createContext(Long id) throws IOException, IllegalArgumentException {
        ImportContext context = new ImportContext();
        if (id != null) {
            Long retval = contextStore.advanceId(id);
            assert retval >= id;
            context.setId(retval);
            contextStore.save(context);
        } else {
            contextStore.add(context);
        }
        return context;
    }
    
    public ImportContext createContext(ImportData data, WorkspaceInfo targetWorkspace, 
        StoreInfo targetStore) throws IOException {
        return createContext(data, targetWorkspace, targetStore, null);
    }

    public ImportContext createContext(ImportData data, WorkspaceInfo targetWorkspace, 
            StoreInfo targetStore, ProgressMonitor monitor) throws IOException {

        ImportContext context = new ImportContext();
        context.setProgress(monitor);
        context.setData(data);

        if (targetWorkspace == null && targetStore != null) {
            targetWorkspace = targetStore.getWorkspace();
        }
        if (targetWorkspace == null) {
            targetWorkspace = catalog.getDefaultWorkspace();
        }
        context.setTargetWorkspace(targetWorkspace);
        context.setTargetStore(targetStore);

        init(context);
        if (!context.progress().isCanceled()) {
            contextStore.add(context);
        }




        return context;
    }

    public Long createContextAsync(final ImportData data, final WorkspaceInfo targetWorkspace, 
        final StoreInfo targetStore) throws IOException {
        return jobs.submit(new Job<ImportContext>() {
            @Override
            protected ImportContext call(ProgressMonitor monitor) throws Exception {
                return createContext(data, targetWorkspace, targetStore, monitor);
            }

            @Override
            public String toString() {
                return "Processing data " + data.toString();
            }
        });
    }

    public void init(ImportContext context) throws IOException {
        init(context, true);
    }
    
    public void init(ImportContext context, boolean prepData) throws IOException {
        context.reattach(catalog);

        ImportData data = context.getData();
        if (data != null) {
            addTasks(context, data, prepData); 
        }
    }

    public List<ImportTask> update(ImportContext context, ImportData data) throws IOException {
        List<ImportTask> tasks = addTasks(context, data, true);
        

        changed(context);

        return tasks;
    }

    List<ImportTask> addTasks(ImportContext context, ImportData data, boolean prepData) throws IOException {
        if (data == null) {
            return Collections.emptyList();
        }

        if (prepData) {
            data.prepare(context.progress());
        }

        if (data instanceof FileData) {
            if (data instanceof Mosaic) {
                return initForMosaic(context, (Mosaic)data);
            }
            else if (data instanceof Directory) {
                return initForDirectory(context, (Directory)data);
            }
            else {
                return initForFile(context, (FileData)data);
            }
        }
        else if (data instanceof Table) {
        }
        else if (data instanceof Database) {
            return initForDatabase(context, (Database)data);
        }

        throw new IllegalStateException();

    }


    List<ImportTask> initForMosaic(ImportContext context, Mosaic mosaic) throws IOException {

        if (context.getTargetStore() != null) {
            throw new IllegalArgumentException("ingest not supported for mosaics");
        }

        return createTasks(mosaic, context);

    }

    List<ImportTask> initForDirectory(ImportContext context, Directory data) throws IOException {
        List<ImportTask> tasks = new ArrayList<ImportTask>();


        for (Directory dir : data.flatten()) {

            if (dir.getFiles().isEmpty()) continue;


            Map<DataFormat,List<FileData>> map = new HashMap<DataFormat,List<FileData>>();
            for (FileData f : dir.getFiles()) {
                DataFormat format = f.getFormat();
                List<FileData> files = map.get(format);
                if (files == null) {
                    files = new ArrayList<FileData>();
                    map.put(format, files);
                }
                files.add(f);
            }
    


            boolean skipNoFormat = !(map.size() == 1 && map.containsKey(null));
            


            StoreInfo targetStore = context.getTargetStore();
            if (targetStore == null) {
    

                for (DataFormat format: new ArrayList<DataFormat>(map.keySet())) {
                    if (format != null && format.canRead(dir)) {
                        List<FileData> files = map.get(format);
                        if (files.size() == 1) {


                            tasks.addAll(createTasks(files.get(0), format, context));
                        }
                        else {
                            tasks.addAll(createTasks(dir.filter(files), format, context));

                        }
                        
                        map.remove(format);
                    }
                }
    

                for (List<FileData> files : map.values()) {
                    for (FileData file : files) {

                        tasks.addAll(createTasks(file, file.getFormat(), context, skipNoFormat));
                    }
                }

            }
            else {
                for (FileData file : dir.getFiles()) {
                    tasks.addAll(createTasks(file, file.getFormat(), context, skipNoFormat));
                }
            }
        }

        return tasks;
    }

    List<ImportTask>  initForFile(ImportContext context, FileData file) throws IOException {
        return createTasks(file, context);
    }

    List<ImportTask>  initForDatabase(ImportContext context, Database db) throws IOException {





        return createTasks(db, context);
    }
    
    List<ImportTask> createTasks(ImportData data, ImportContext context) throws IOException {
        return createTasks(data, data.getFormat(), context);
    }
    

    List<ImportTask> createTasks(ImportData data, DataFormat format, ImportContext context) 
        throws IOException {
        return createTasks(data, format, context, true);
    }

    List<ImportTask> createTasks(ImportData data, DataFormat format, ImportContext context, 
        boolean skipNoFormat) throws IOException {

        List<ImportTask> tasks = new ArrayList<ImportTask>();

        boolean direct = false;

        StoreInfo targetStore = context.getTargetStore();
        if (targetStore == null) {

            direct = true;

            if (format != null) {
                targetStore = format.createStore(data, context.getTargetWorkspace(), catalog);    
            }
            
            if (targetStore == null) {


                targetStore = lookupDefaultStore();

                direct = targetStore == null;
            }
        }

        if (format != null) {


            for (ImportTask t : format.list(data, catalog, context.progress())) {

                t.setTransform(format instanceof VectorFormat 
                        ? new VectorTransformChain() : new RasterTransformChain());
                t.setDirect(direct);
                t.setStore(targetStore);

                prep(t);
                tasks.add(t);
            }
        }
        else if (!skipNoFormat) {
            ImportTask t = new ImportTask(data);
            t.setDirect(direct);
            t.setStore(targetStore);
            prep(t);
            tasks.add(t);
        }

        for (ImportTask t : tasks) {
            context.addTask(t);
        }
        return tasks;
    }

    boolean prep(ImportTask task) {
        if (task.getState() == ImportTask.State.COMPLETE) {
            return true;
        }


        DataFormat format = task.getData().getFormat();
        if (format == null) {
            task.setState(State.NO_FORMAT);
            return false;
        }

        

        if (task.getStore() == null) {
            task.setError(new Exception("No target store for task"));
            task.setState(State.ERROR);
            return false;
        }


        if (!formatMatchesStore(format, task.getStore())) {
            String msg = task.getStore() instanceof DataStoreInfo ? 
                    "Unable to import raster data into vector store" : 
                    "Unable to import vector data into raster store";

            task.setError(new Exception(msg));
            task.setState(State.BAD_FORMAT);
            return false;
        }

        if (task.getLayer() == null || task.getLayer().getResource() == null) {
            task.setError(new Exception("Task has no layer configuration"));
            task.setState(State.ERROR);
            return false;
        }

        LayerInfo l = task.getLayer();
        ResourceInfo r = l.getResource();
        

        r.setStore(task.getStore());
        r.setNamespace(
            catalog.getNamespaceByPrefix(task.getStore().getWorkspace().getName()));



        if (l.getDefaultStyle() == null) {
            try {
                StyleInfo style = null;
                if (r instanceof FeatureTypeInfo) {



                    FeatureType featureType =
                        (FeatureType) task.getMetadata().get(FeatureType.class);
                    if (featureType != null) {
                        style = styleGen.createStyle((FeatureTypeInfo) r, featureType);
                    } else {
                        throw new RuntimeException("Unable to compute style");
                    }

                }
                else if (r instanceof CoverageInfo) {
                    style = styleGen.createStyle((CoverageInfo) r);
                }
                else {
                    throw new RuntimeException("Unknown resource type :"
                            + r.getClass());
                }
                l.setDefaultStyle(style);
            }
            catch(Exception e) {
                task.setError(e);
                task.setState(ImportTask.State.ERROR);
                return false;
            }
        }
        

        if (r.getSRS() == null) {
            task.setState(ImportTask.State.NO_CRS);
            return false;
        }
        else if (task.getState() == ImportTask.State.NO_CRS) {

            try {
                computeLatLonBoundingBox(task, false);
            }
            catch(Exception e) {
                LOGGER.log(Level.WARNING, "Error computing lat long bounding box", e);
                task.setState(ImportTask.State.ERROR);
                task.setError(e);
                return false;
            }


            task.getLayer().getResource().setProjectionPolicy(ProjectionPolicy.FORCE_DECLARED);
        }
        else {
            task.getLayer().getResource().setProjectionPolicy(ProjectionPolicy.NONE);
        }


        if (r.getNativeBoundingBox() == null) {
            task.setState(ImportTask.State.NO_BOUNDS);
            return false;
        }
        
        task.setState(ImportTask.State.READY);
        return true;
    }

    boolean formatMatchesStore(DataFormat format, StoreInfo store) {
        if (format instanceof VectorFormat) {
            return store instanceof DataStoreInfo;
        }
        if (format instanceof GridFormat) {
            return store instanceof CoverageStoreInfo;
        }
        return false;
    }

    boolean resourceMatchesStore(ResourceInfo resource, StoreInfo store) {
        if (resource instanceof FeatureTypeInfo) {
            return store instanceof DataStoreInfo;
        }
        if (resource instanceof CoverageInfo) {
            return store instanceof CoverageStoreInfo;
        }
        return false;
    }

    public void run(ImportContext context) throws IOException {
        run(context, ImportFilter.ALL);
    }

    public void run(ImportContext context, ImportFilter filter) throws IOException {
        run(context, filter, null);
    }
    
    public void run(ImportContext context, ImportFilter filter, ProgressMonitor monitor) throws IOException {
        context.setProgress(monitor);
        context.setState(ImportContext.State.RUNNING);
        
        if (LOGGER.isLoggable(Level.FINE)) {
            LOGGER.fine("Running import " + context.getId());
        }
        
        for (ImportTask task : context.getTasks()) {
            if (!filter.include(task)) {
                continue;
            }
            if (!task.readyForImport()) {
                continue;
            }

            if (context.progress().isCanceled()) {
                break;
            }
            run(task);
        }

        context.updated();
        contextStore.save(context);

        if (context.isArchive() && context.getState() == ImportContext.State.COMPLETE) {
            boolean canArchive = !Iterables.any(context.getTasks(), new Predicate<ImportTask>() {
                @Override
                public boolean apply(ImportTask input) {
                    return input.isDirect();
                }
            });

            if (canArchive) {
                Directory directory = null;
                if (context.getData() instanceof Directory) {
                    directory = (Directory) context.getData();
                } else if ( context.getData() instanceof SpatialFile ) {
                    directory = new Directory( ((SpatialFile) context.getData()).getFile().getParentFile() );
                }
                if (directory != null) {
                    if (LOGGER.isLoggable(Level.FINE)) {
                        LOGGER.fine("Archiving directory " + directory.getFile().getAbsolutePath());
                    }       
                    try {
                        directory.archive(getArchiveFile(context));
                    } catch (Exception ioe) {
                        ioe.printStackTrace();

                        LOGGER.log(Level.WARNING, "Error archiving", ioe);
                    }
                }
            }

        }
    }

    void run(ImportTask task) throws IOException {
        if (task.getState() == ImportTask.State.COMPLETE) {
            return;
        }
        task.setState(ImportTask.State.RUNNING);

        if (task.isDirect()) {

            doDirectImport(task);
        }
        else {

            doIndirectImport(task);
        }

    }
    
    public File getArchiveFile(ImportContext context) throws IOException {

        String archiveName = "import-" + context.getId() + ".zip";
        File dir = getCatalog().getResourceLoader().findOrCreateDirectory("uploads","archives");
        return new File(dir, archiveName);
    }
    
    public void changed(ImportContext context) {
        context.updated();
        contextStore.save(context);
    }

    public void changed(ImportTask task)  {
        prep(task);
        changed(task.getContext());
    }

    public Long runAsync(final ImportContext context, final ImportFilter filter) {
        return jobs.submit(new Job<ImportContext>() {
            @Override
            protected ImportContext call(ProgressMonitor monitor) throws Exception {
                run(context, filter, monitor);
                return context;
            }

            @Override
            public String toString() {
                return "Processing import " + context.getId();
            }
        });
    }

    public Task<ImportContext> getTask(Long job) {
        return (Task<ImportContext>) jobs.getTask(job);
    }

    public List<Task<ImportContext>> getTasks() {
        return (List) jobs.getTasks();
    }


    void doDirectImport(ImportTask task) throws IOException {



        if (task.getStore().getId() == null) {
            StoreInfo store = task.getStore();


            store.setName(findUniqueStoreName(task.getStore()));
            

            if (!store.getConnectionParameters().containsKey("namespace")) {
                WorkspaceInfo ws = task.getContext().getTargetWorkspace();
                if (ws == null && task.getContext().getTargetStore() != null) {
                    ws = task.getContext().getTargetStore().getWorkspace();
                }
                if (ws != null) {
                    NamespaceInfo ns = catalog.getNamespaceByPrefix(ws.getName());
                    if (ns != null) {
                        store.getConnectionParameters().put("namespace", ns.getURI());
                    }
                }
            }
            catalog.add(task.getStore());
        }

        task.setState(ImportTask.State.RUNNING);

        try {

            TransformChain tx = task.getTransform();
            

            if (!doPreTransform(task, task.getData(), tx)) {
                return;
            }

            addToCatalog(task);


            if (!doPostTransform(task, task.getData(), tx)) {
                return;
            }

            task.setState(ImportTask.State.COMPLETE);
        }
        catch(Exception e) {
            LOGGER.log(Level.WARNING, "Task failed during import: " + task, e);
            task.setState(ImportTask.State.ERROR);
            task.setError(e);
        }

    }


    void doIndirectImport(ImportTask task) throws IOException {
        if (!task.getStore().isEnabled()) {
            task.getStore().setEnabled(true);
        }

        if (task.progress().isCanceled()){
            return;
        }

        task.setState(ImportTask.State.RUNNING);


        TransformChain tx = task.getTransform();


        if (!doPreTransform(task, task.getData(), tx)) {
            return;
        }

        boolean canceled = false;
        DataFormat format = task.getData().getFormat();
        if (format instanceof VectorFormat) {
            try {
                currentlyProcessing.put(task.getContext().getId(), task);
                loadIntoDataStore(task, (DataStoreInfo)task.getStore(), (VectorFormat) format, 
                    (VectorTransformChain) tx);
                canceled = task.progress().isCanceled();

                FeatureTypeInfo featureType = (FeatureTypeInfo) task.getLayer().getResource();
                featureType.getAttributes().clear();

                if (!canceled) {
                    if (task.getUpdateMode() == UpdateMode.CREATE) {
                        addToCatalog(task);
                    }
    




                    FeatureTypeInfo resource = getCatalog().getResourceByName(
                            featureType.getQualifiedName(), FeatureTypeInfo.class);
                    if (resource.getNativeBoundingBox().isEmpty()
                            || resource.getMetadata().get("recalculate-bounds") != null) {

                        CatalogBuilder cb = new CatalogBuilder(getCatalog());
                        ReferencedEnvelope nativeBounds = cb.getNativeBounds(resource);
                        resource.setNativeBoundingBox(nativeBounds);
                        resource.setLatLonBoundingBox(cb.getLatLonBounds(nativeBounds,
                                resource.getCRS()));
                        getCatalog().save(resource);
                    }
                }
            }
            catch(Exception e) {
                LOGGER.log(Level.SEVERE, "Error occured during import", e);
                task.setError(e);
                task.setState(ImportTask.State.ERROR);
                return;
            } finally {
                currentlyProcessing.remove(task.getContext().getId());
            }
        }
        else {
            throw new UnsupportedOperationException("Indirect raster import not yet supported");
        }

        if (!canceled && !doPostTransform(task, task.getData(), tx)) {
            return;
        }

        task.setState(canceled ? ImportTask.State.CANCELED : ImportTask.State.COMPLETE);

    }

    boolean doPreTransform(ImportTask task, ImportData data, TransformChain tx) {
        try {
            tx.pre(task, data);
        } 
        catch (Exception e) {
            LOGGER.log(Level.SEVERE, "Error occured during pre transform", e);
            task.setError(e);
            task.setState(ImportTask.State.ERROR);
            return false;
        }
        return true;
    }

    boolean doPostTransform(ImportTask task, ImportData data, TransformChain tx) {
        try {
            tx.post(task, data);
        } 
        catch (Exception e) {
            LOGGER.log(Level.SEVERE, "Error occured during post transform", e);
            task.setError(e);
            task.setState(ImportTask.State.ERROR);
            return false;
        }
        return true;
    }

    void loadIntoDataStore(ImportTask task, DataStoreInfo store, VectorFormat format, 
        VectorTransformChain tx) throws Exception {

        ImportData data = task.getData();
        FeatureReader reader = null;
        FeatureWriter writer = null;

        Exception error = null;
        try {
            reader = format.read(data, task);

            SimpleFeatureType featureType = (SimpleFeatureType) reader.getFeatureType();
            final String featureTypeName = featureType.getName().getLocalPart();
    
            DataStore dataStore = (DataStore) store.getDataStore(null);
            FeatureDataConverter featureDataConverter = FeatureDataConverter.DEFAULT;
            if (isShapefileDataStore(dataStore)) {
                featureDataConverter = FeatureDataConverter.TO_SHAPEFILE;
            }
            else if (isOracleDataStore(dataStore)) {
                featureDataConverter = FeatureDataConverter.TO_ORACLE;
            }
            else if (isPostGISDataStore(dataStore)) {
                featureDataConverter = FeatureDataConverter.TO_POSTGIS;
            }
            
            featureType = featureDataConverter.convertType(featureType, format, data, task);
            UpdateMode updateMode = task.getUpdateMode();
            final String uniquifiedFeatureTypeName;
            if (updateMode == UpdateMode.CREATE) {

                uniquifiedFeatureTypeName = findUniqueNativeFeatureTypeName(featureType, store);
                task.setOriginalLayerName(featureTypeName);
    
                if (!uniquifiedFeatureTypeName.equals(featureTypeName)) {

                    task.getLayer().getResource().setName(uniquifiedFeatureTypeName);
                    task.getLayer().getResource().setNativeName(uniquifiedFeatureTypeName);
                    

                    SimpleFeatureTypeBuilder typeBuilder = new SimpleFeatureTypeBuilder();
                    typeBuilder.setName(uniquifiedFeatureTypeName);
                    typeBuilder.addAll(featureType.getAttributeDescriptors());
                    featureType = typeBuilder.buildFeatureType();
                }
    


                if (dataStore instanceof JDBCDataStore) {
                    JDBCDataStore ds = (JDBCDataStore) dataStore;

                    if (ds.getSqlTypeNameToClassMappings().containsKey("timestamptz")) {
                        ds.getSqlTypeToSqlTypeNameOverrides().put(java.sql.Types.TIMESTAMP, "timestamptz");
                    }
                }
    

                featureType = tx.inline(task, dataStore, featureType);
    
                dataStore.createSchema(featureType);
            } else {

                

                if (updateMode == UpdateMode.UPDATE) {
                    throw new UnsupportedOperationException("updateMode UPDATE is not supported yet");
                }
                uniquifiedFeatureTypeName = featureTypeName;
            }
                
            Transaction transaction = new DefaultTransaction();
            
            if (updateMode == UpdateMode.REPLACE) {
                
                FeatureStore fs = (FeatureStore) dataStore.getFeatureSource(featureTypeName);
                fs.setTransaction(transaction);
                fs.removeFeatures(Filter.INCLUDE);
            }
            


            
            ProgressMonitor monitor = task.progress();
            

            int skipped = 0;
            int cnt = 0;

            long startTime = System.currentTimeMillis();
            task.clearMessages();
            
            task.setTotalToProcess(format.getFeatureCount(task.getData(), task));
            
            LOGGER.info("begining import");
            try {
                writer = dataStore.getFeatureWriterAppend(uniquifiedFeatureTypeName, transaction);
                
                while(reader.hasNext()) {
                    if (monitor.isCanceled()){
                        break;
                    }
                    SimpleFeature feature = (SimpleFeature) reader.next();
                    SimpleFeature next = (SimpleFeature) writer.next();
    




                    featureDataConverter.convert(feature, next);
                    

                    Geometry geom = (Geometry) next.getDefaultGeometry();
                    if (geom != null && geom.isEmpty()) {
                        next.setDefaultGeometry(null);
                    }
                    

                    next = tx.inline(task, dataStore, feature, next);
                    
                    if (next == null) {
                        skipped++;
                    } else {
                        writer.write();
                    }
                    task.setNumberProcessed(++cnt);
                }
                transaction.commit();
                if (skipped > 0) {
                    task.addMessage(Level.WARNING,skipped + " features were skipped.");
                }
                LOGGER.info("load to target took " + (System.currentTimeMillis() - startTime));
            } 
            catch (Exception e) {
                error = e;
            } 

            
            if (error != null || monitor.isCanceled()) {


    

                try {
                    transaction.rollback();
                } catch (Exception e1) {
                    LOGGER.log(Level.WARNING, "Error rolling back transaction",e1);
                }
    

                try {
                    dropSchema(dataStore,featureTypeName);
                } catch(Exception e1) {
                    LOGGER.log(Level.WARNING, "Error dropping schema in rollback",e1);
                }
            }
    

            try {
                transaction.close();
            } catch (Exception e) {
                if (error != null) {
                    error = e;
                }
                LOGGER.log(Level.WARNING, "Error closing transaction",e);
            }
    




            






        } finally {
            if (writer != null) {
                try {
                    writer.close();
                } catch (Exception e) {
                    if (error != null) {
                        error = e;
                    }
                    LOGGER.log(Level.WARNING, "Error closing writer",e);
                }
            }
            try {    
                if(reader != null) {
                    format.dispose(reader, task);



                }
            } catch (Exception e) {
                LOGGER.log(Level.WARNING, "Error closing reader",e);
            }
        }
        

        if (error != null) {
            throw error;
        }
    }

    StoreInfo lookupDefaultStore() {
        WorkspaceInfo ws = catalog.getDefaultWorkspace();
        if (ws == null) {
            return null;
        }

        return catalog.getDefaultDataStore(ws);
    }

    void addToCatalog(ImportTask task) throws IOException {
        LayerInfo layer = task.getLayer();
        ResourceInfo resource = layer.getResource();
        resource.setStore(task.getStore());


        String name = findUniqueResourceName(resource);
        resource.setName(name); 





        resource.setEnabled(true);
        catalog.add(resource);


        if (layer.getDefaultStyle().getId() == null) {
            catalog.add(layer.getDefaultStyle());
        }

        layer.setEnabled(true);
        catalog.add(layer);
    }

    String findUniqueStoreName(StoreInfo store) {
        WorkspaceInfo workspace = store.getWorkspace();


        String name = store.getName();
        if (catalog.getStoreByName(workspace, store.getName(), StoreInfo.class) != null) {
            int i = 0;
            name += i;
            while (catalog.getStoreByName(workspace, name, StoreInfo.class) != null) {
                name = name.replaceAll(i + "$", String.valueOf(i+1));
                i++;
            }
        }

        return name;
    }
    
    String findUniqueResourceName(ResourceInfo resource) 
        throws IOException {


        StoreInfo store = resource.getStore();
        NamespaceInfo ns = catalog.getNamespaceByPrefix(store.getWorkspace().getName());
        
        String name = resource.getName();


        if (!Character.isLetter(name.charAt(0))) {
            name = "a_" + name;
        }


        name = name.replaceAll("\\W", "_");

        if (catalog.getResourceByName(ns, name, ResourceInfo.class) != null) {
            int i = 0;
            name += i;
            while (catalog.getResourceByName(ns, name, ResourceInfo.class) != null) {
                name = name.replaceAll(i + "$", String.valueOf(i+1));
                i++;
            }
        }

        return name;
    }

    String findUniqueNativeFeatureTypeName(FeatureType featureType, DataStoreInfo store) throws IOException {
        return findUniqueNativeFeatureTypeName(featureType.getName().getLocalPart(), store);
    }

    private String findUniqueNativeFeatureTypeName(String name, DataStoreInfo store) throws IOException {
        DataStore dataStore = (DataStore) store.getDataStore(null);



        if (isOracleDataStore(dataStore)) {
            name = name.toUpperCase();
        }


        List<String> names = Arrays.asList(dataStore.getTypeNames());
        if (names.contains(name)) {
            int i = 0;
            name += i;
            while(names.contains(name)) {
                name = name.replaceAll(i + "$", String.valueOf(i+1));
                i++;
            }
        }

        return name;
    }

    boolean isShapefileDataStore(DataStore dataStore) {
        return dataStore instanceof ShapefileDataStore || dataStore instanceof DirectoryDataStore;
    }

    boolean isOracleDataStore(DataStore dataStore) {
        return dataStore instanceof JDBCDataStore && "org.geotools.data.oracle.OracleDialect"
            .equals(((JDBCDataStore)dataStore).getSQLDialect().getClass().getName());
    }

    boolean isPostGISDataStore(DataStore dataStore) {
        return dataStore instanceof JDBCDataStore && ((JDBCDataStore)dataStore).getSQLDialect()
            .getClass().getName().startsWith("org.geotools.data.postgis");
    }


    boolean computeLatLonBoundingBox(ImportTask task, boolean force) throws Exception {
        ResourceInfo r = task.getLayer().getResource();
        if (force || r.getLatLonBoundingBox() == null && r.getNativeBoundingBox() != null) {
            CoordinateReferenceSystem nativeCRS = CRS.decode(r.getSRS());
            ReferencedEnvelope nativeBbox = 
                new ReferencedEnvelope(r.getNativeBoundingBox(), nativeCRS);
            r.setLatLonBoundingBox(nativeBbox.transform(CRS.decode("EPSG:4326"), true));
            return true;
        }
        return false;
    }


    public File getImportRoot() {
        try {
            return catalog.getResourceLoader().findOrCreateDirectory("imports");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public File getUploadRoot() {
        try {
            return catalog.getResourceLoader().findOrCreateDirectory("uploads");
        }
        catch(IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void destroy() throws Exception {
        jobs.shutdown();
        contextStore.destroy();
    }

    public void delete(ImportContext importContext) throws IOException {
        delete(importContext, false);
    }
    
    public void delete(ImportContext importContext, boolean purge) throws IOException {
        if (purge) {
            importContext.delete();    
        }
        
        contextStore.remove(importContext);
    }

    private void dropSchema(DataStore ds, String featureTypeName) throws Exception {

        SimpleFeatureType schema = ds.getSchema(featureTypeName);
        if (schema != null) {
            try {
                ds.removeSchema(featureTypeName);
            } catch(Exception e) {
                LOGGER.warning("Unable to dropSchema " + featureTypeName + " from datastore " + ds.getClass());
            }
        } else {
            LOGGER.warning("Unable to dropSchema " + featureTypeName + " as it does not appear to exist in dataStore");
        }
    }

    public XStreamPersister createXStreamPersisterXML() {
        return initXStreamPersister(new XStreamPersisterFactory().createXMLPersister());
    }

    public XStreamPersister createXStreamPersisterJSON() {
        return initXStreamPersister(new XStreamPersisterFactory().createJSONPersister());
    }

    public XStreamPersister initXStreamPersister(XStreamPersister xp) {
        xp.setCatalog(catalog);

        
        XStream xs = xp.getXStream();


        xs.alias("import", ImportContext.class);


        xs.alias("task", ImportTask.class);
        xs.omitField(ImportTask.class, "context");






        xs.alias("dataStoreFormat", DataStoreFormat.class);


        xs.alias("spatialFile", SpatialFile.class);
        xs.alias("database", org.geoserver.importer.Database.class);
        xs.alias("table", Table.class);
        xs.omitField(Table.class, "db");

        xs.alias("vectorTransformChain", VectorTransformChain.class);
        xs.registerLocalConverter(ReprojectTransform.class, "source", new CRSConverter());
        xs.registerLocalConverter(ReprojectTransform.class, "target", new CRSConverter());

        xs.registerLocalConverter( ReferencedEnvelope.class, "crs", new CRSConverter() );
        xs.registerLocalConverter( GeneralEnvelope.class, "crs", new CRSConverter() );
        
        return xp;
    }

}

<code block>

package org.geoserver.importer.transform;

import org.geoserver.importer.ImportData;
import org.geoserver.importer.ImportTask;


public interface PostVectorTransform extends VectorTransform {

    void apply(ImportTask task, ImportData data) throws Exception;
}

<code block>

package org.geoserver.importer.transform;

import org.geoserver.catalog.ResourceInfo;
import org.geotools.data.DataStore;
import org.geotools.feature.simple.SimpleFeatureTypeBuilder;
import org.geotools.geometry.jts.JTS;
import org.geotools.referencing.CRS;
import org.geoserver.importer.ImportTask;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.feature.simple.SimpleFeatureType;
import org.opengis.referencing.crs.CoordinateReferenceSystem;
import org.opengis.referencing.operation.MathTransform;

import com.vividsolutions.jts.geom.Geometry;

public class ReprojectTransform extends AbstractVectorTransform implements InlineVectorTransform {
    
    private static final long serialVersionUID = 1L;

    CoordinateReferenceSystem source, target;
    transient MathTransform transform;

    public CoordinateReferenceSystem getSource() {
        return source;
    }

    public void setSource(CoordinateReferenceSystem source) {
        this.source = source;
    }

    public CoordinateReferenceSystem getTarget() {
        return target;
    }

    public void setTarget(CoordinateReferenceSystem target) {
        this.target = target;
    }

    public ReprojectTransform(CoordinateReferenceSystem target) {
        this(null, target);
    }

    public ReprojectTransform(CoordinateReferenceSystem source, CoordinateReferenceSystem target) {
        this.source = source;
        this.target = target;
    }

    public SimpleFeatureType apply(ImportTask task, DataStore dataStore,
            SimpleFeatureType featureType) throws Exception {


        ResourceInfo r = task.getLayer().getResource();
        r.setNativeCRS(target);
        r.setSRS(CRS.lookupIdentifier(target, true));
        if (r.getNativeBoundingBox() != null) {
            r.setNativeBoundingBox(r.getNativeBoundingBox().transform(target, true));
        }

        return SimpleFeatureTypeBuilder.retype(featureType, target);
    }

    public SimpleFeature apply(ImportTask task, DataStore dataStore, SimpleFeature oldFeature, SimpleFeature feature)
            throws Exception {
        if (transform == null) {

            CoordinateReferenceSystem source = this.source;
            if (source == null) {

                source = oldFeature.getType().getCoordinateReferenceSystem();
            }

            if (source == null) {
                throw new IllegalStateException("Unable to determine source projection");
            }

            transform = CRS.findMathTransform(source, target, true);
        }

        Geometry g = (Geometry) oldFeature.getDefaultGeometry();
        if (g != null) {
            feature.setDefaultGeometry(JTS.transform(g, transform));
        }
        return feature;
    }
}

<code block>

package org.geoserver.importer.transform;

import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.geotools.data.DataStore;
import org.geotools.util.logging.Logging;
import org.geoserver.importer.ImportData;
import org.geoserver.importer.ImportTask;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.feature.simple.SimpleFeatureType;


public class VectorTransformChain extends TransformChain<VectorTransform> {

    static Logger LOGGER = Logging.getLogger(VectorTransformChain.class);

    public VectorTransformChain(List<VectorTransform> transforms) {
        super(transforms);
    }

    public VectorTransformChain(VectorTransform... transforms) {
        super(transforms);
    }
    
    public void pre(ImportTask item, ImportData data) throws Exception {
        for (PreVectorTransform tx : filter(transforms, PreVectorTransform.class)) {
            try {
                tx.apply(item, data);
            } catch (Exception e) {
                error(tx, e);
            }
        }
    }

    public SimpleFeatureType inline(ImportTask task, DataStore dataStore, SimpleFeatureType featureType) 
        throws Exception {
        
        for (InlineVectorTransform tx : filter(transforms, InlineVectorTransform.class)) {
            try {
                tx.init();
                featureType = tx.apply(task, dataStore, featureType);
            } catch (Exception e) {
                error(tx, e);
            }
        }
        
        return featureType;
    }

    public SimpleFeature inline(ImportTask task, DataStore dataStore, SimpleFeature oldFeature, 
        SimpleFeature feature) throws Exception {
        
        for (InlineVectorTransform tx : filter(transforms, InlineVectorTransform.class)) {
            try {
                feature = tx.apply(task, dataStore, oldFeature, feature);
                if (feature == null) {
                    break;
                }
            } catch (Exception e) {
                error(tx, e);
            }
        }
        
        return feature;
    }

    public void post(ImportTask task, ImportData data) throws Exception {
        for (PostVectorTransform tx : filter(transforms, PostVectorTransform.class)) {
            try {
                tx.apply(task, data);
            } catch (Exception e) {
                error(tx, e);
            }
        }
    }

    <T> List<T> filter(List<VectorTransform> transforms, Class<T> type) {
        List<T> filtered = new ArrayList<T>();
        for (VectorTransform tx : transforms) {
            if (type.isInstance(tx)) {
                filtered.add((T) tx);
            }
        }
        return filtered;
    }

    void error(VectorTransform tx, Exception e) throws Exception {
        if (tx.stopOnError(e)) {
            throw e;
        }
        else {

            LOGGER.log(Level.WARNING, "Transform " + tx + " failed", e);
        }
    }
}

<code block>

package org.geoserver.importer.transform;

import org.geotools.data.DataStore;
import org.geotools.feature.simple.SimpleFeatureTypeBuilder;
import org.geoserver.importer.ImportTask;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.feature.simple.SimpleFeatureType;
import org.opengis.feature.type.GeometryDescriptor;

import com.vividsolutions.jts.geom.Coordinate;
import com.vividsolutions.jts.geom.GeometryFactory;
import com.vividsolutions.jts.geom.Point;

public class AttributesToPointGeometryTransform extends AbstractVectorTransform implements
        InlineVectorTransform {


    private static final long serialVersionUID = 1L;

    private static final String POINT_NAME = "location";

    private final String latField;

    private final String lngField;

    private final String pointFieldName;

    private final GeometryFactory geometryFactory;

    public AttributesToPointGeometryTransform(String latField, String lngField) {
        this(latField, lngField, AttributesToPointGeometryTransform.POINT_NAME);
    }

    public AttributesToPointGeometryTransform(String latField, String lngField,
            String pointFieldName) {
        this.latField = latField;
        this.lngField = lngField;
        this.pointFieldName = pointFieldName;
        geometryFactory = new GeometryFactory();
    }

    @Override
    public SimpleFeatureType apply(ImportTask task, DataStore dataStore,
            SimpleFeatureType featureType) throws Exception {
        SimpleFeatureTypeBuilder builder = new SimpleFeatureTypeBuilder();
        builder.init(featureType);

        int latIndex = featureType.indexOf(latField);
        int lngIndex = featureType.indexOf(lngField);
        if (latIndex < 0 || lngIndex < 0) {
            throw new Exception("FeatureType " + featureType.getName()
                    + " does not have lat lng fields named '" + latField + "'" + " and " + "'"
                    + lngField + "'");
        }

        GeometryDescriptor geometryDescriptor = featureType.getGeometryDescriptor();
        if (geometryDescriptor != null) {
            builder.remove(geometryDescriptor.getLocalName());
        }
        builder.remove(latField);
        builder.remove(lngField);
        builder.add(pointFieldName, Point.class);

        return builder.buildFeatureType();
    }

    @Override
    public SimpleFeature apply(ImportTask task, DataStore dataStore, SimpleFeature oldFeature,
            SimpleFeature feature) throws Exception {
        Object latObject = oldFeature.getAttribute(latField);
        Object lngObject = oldFeature.getAttribute(lngField);
        Double lat = asDouble(latObject);
        Double lng = asDouble(lngObject);
        if (lat == null || lng == null) {
            feature.setDefaultGeometry(null);
        } else {
            Coordinate coordinate = new Coordinate(lng, lat);
            Point point = geometryFactory.createPoint(coordinate);
            feature.setAttribute(pointFieldName, point);
        }
        return feature;
    }

    private Double asDouble(Object value) {
        if (value == null) {
            return null;
        }
        if (value instanceof Double) {
            return (Double) value;
        }
        try {
            return Double.parseDouble(value.toString());
        } catch (NumberFormatException e) {
            return null;
        }
    }

    public String getLatField() {
        return latField;
    }

    public String getLngField() {
        return lngField;
    }

}

<code block>

package org.geoserver.importer.transform;

import java.util.logging.Logger;
import org.geotools.util.logging.Logging;

public abstract class AbstractVectorTransform implements VectorTransform {

    private static final long serialVersionUID = 1L;
    
    final transient Logger LOGGER = Logging.getLogger(getClass());
    
    public boolean stopOnError(Exception e) {
        return true;
    }
    

    public void init() {

    }

}

<code block>

package org.geoserver.importer.transform;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import org.geoserver.importer.ImportData;
import org.geoserver.importer.ImportTask;


public abstract class TransformChain<T extends ImportTransform> implements Serializable {

    protected List<T> transforms;
    
    public TransformChain() {
        this(new ArrayList<T>(3));
    }

    public TransformChain(List<T> transforms) {
        this.transforms = transforms;
    }

    public TransformChain(T... transforms) {
        this.transforms = new ArrayList(Arrays.asList(transforms));
    }

    public List<T> getTransforms() {
        return transforms;
    }

    public <X extends T> void add(X tx) {
        transforms.add(tx);
    }

    public <X extends T> boolean remove(X tx) {
        return transforms.remove(tx);
    }

    public <X extends T> X get(Class<X> type) {
        for (T tx : transforms) {
            if (type.equals(tx.getClass())) {
                return (X) tx;
            }
        }
        return null;
    }

    public <X extends T> List<X> getAll(Class<X> type) {
        List<X> list = new ArrayList<X>();
        for (T tx : transforms) {
            if (type.isAssignableFrom(tx.getClass())) {
                list.add((X) tx);
            }
        }
        return list;
    }

    public <X extends T> void removeAll(Class<X> type) {
        for (Iterator<T> it = transforms.iterator(); it.hasNext(); ) {
            if (type.isAssignableFrom(it.next().getClass())) {
                it.remove();
            }
        }
    }
    
    public abstract void pre(ImportTask task, ImportData data) throws Exception;
    public abstract void post(ImportTask task, ImportData data) throws Exception;

    private Object readResolve() {
        if (transforms == null) {
            transforms = new ArrayList();
        }
        return this;
    }
}

<code block>

package org.geoserver.importer.transform;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.apache.commons.lang.StringUtils;
import org.geotools.data.DataStore;
import org.geotools.feature.simple.SimpleFeatureBuilder;
import org.geotools.feature.simple.SimpleFeatureTypeBuilder;
import org.geotools.kml.Folder;
import org.geoserver.importer.FeatureDataConverter;
import org.geoserver.importer.ImportTask;
import org.geoserver.importer.format.KMLFileFormat;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.feature.simple.SimpleFeatureType;
import org.opengis.feature.type.AttributeDescriptor;

import com.vividsolutions.jts.geom.Geometry;

public class KMLPlacemarkTransform extends AbstractVectorTransform implements InlineVectorTransform {


    private static final long serialVersionUID = 1L;

    public SimpleFeatureType convertFeatureType(SimpleFeatureType oldFeatureType) {
        SimpleFeatureTypeBuilder ftb = new SimpleFeatureTypeBuilder();
        ftb.add("Geometry", Geometry.class);
        ftb.setDefaultGeometry("Geometry");
        List<AttributeDescriptor> attributeDescriptors = oldFeatureType.getAttributeDescriptors();
        for (AttributeDescriptor attributeDescriptor : attributeDescriptors) {
            String localName = attributeDescriptor.getLocalName();
            if (!"Geometry".equals(localName)) {
                ftb.add(attributeDescriptor);
            }
        }
        ftb.setName(oldFeatureType.getName());
        ftb.setDescription(oldFeatureType.getDescription());
        ftb.setCRS(KMLFileFormat.KML_CRS);
        ftb.setSRS(KMLFileFormat.KML_SRS);

        if (oldFeatureType.getDescriptor("Style") != null) {
            ftb.remove("Style");
        }
        ftb.add("Folder", String.class);
        SimpleFeatureType ft = ftb.buildFeatureType();
        return ft;
    }

    public SimpleFeature convertFeature(SimpleFeature old, SimpleFeatureType targetFeatureType) {
        SimpleFeatureBuilder fb = new SimpleFeatureBuilder(targetFeatureType);
        SimpleFeature newFeature = fb.buildFeature(old.getID());
        FeatureDataConverter.DEFAULT.convert(old, newFeature);
        Map<Object, Object> userData = old.getUserData();
        Object folderObject = userData.get("Folder");
        if (folderObject != null) {
            String serializedFolders = serializeFolders(folderObject);
            newFeature.setAttribute("Folder", serializedFolders);
        }
        @SuppressWarnings("unchecked")
        Map<String, String> untypedExtendedData = (Map<String, String>) userData
                .get("UntypedExtendedData");
        if (untypedExtendedData != null) {
            for (Entry<String, String> entry : untypedExtendedData.entrySet()) {
                if (targetFeatureType.getDescriptor(entry.getKey()) != null) {
                    newFeature.setAttribute(entry.getKey(), entry.getValue());
                }
            }
        }
        return newFeature;
    }

    private String serializeFolders(Object folderObject) {
        @SuppressWarnings("unchecked")
        List<Folder> folders = (List<Folder>) folderObject;
        List<String> folderNames = new ArrayList<String>(folders.size());
        for (Folder folder : folders) {
            String name = folder.getName();
            if (!StringUtils.isEmpty(name)) {
                folderNames.add(name);
            }
        }
        String serializedFolders = StringUtils.join(folderNames.toArray(), " -> ");
        return serializedFolders;
    }

    @Override
    public SimpleFeatureType apply(ImportTask task, DataStore dataStore,
            SimpleFeatureType featureType) throws Exception {
        return convertFeatureType(featureType);
    }

    @Override
    public SimpleFeature apply(ImportTask task, DataStore dataStore, SimpleFeature oldFeature,
            SimpleFeature feature) throws Exception {
        SimpleFeatureType targetFeatureType = feature.getFeatureType();
        SimpleFeature newFeature = convertFeature(oldFeature, targetFeatureType);
        feature.setAttributes(newFeature.getAttributes());
        return feature;
    }
}

<code block>

package org.geoserver.importer.transform;

import org.geoserver.importer.ImportData;
import org.geoserver.importer.ImportTask;


public class RasterTransformChain extends TransformChain<RasterTransform> {

    @Override
    public void pre(ImportTask task, ImportData data) throws Exception {
        if (transforms.size() > 0) {
            throw new RuntimeException("Not implemented");
        }
    }

    @Override
    public void post(ImportTask task, ImportData data) throws Exception {
    }
    
}

<code block>

package org.geoserver.importer.transform;

import org.geotools.data.DataStore;
import org.geotools.feature.AttributeTypeBuilder;
import org.geotools.feature.simple.SimpleFeatureTypeBuilder;
import org.geoserver.importer.ImportTask;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.feature.simple.SimpleFeatureType;
import org.opengis.feature.type.AttributeDescriptor;


public class AttributeRemapTransform extends AbstractVectorTransform implements InlineVectorTransform {
    
    private static final long serialVersionUID = 1L;


    protected String field;


    protected Class type;
    
    public AttributeRemapTransform(String field, Class type) {
        this.field = field;
        this.type = type;
    }
    
    protected AttributeRemapTransform() {
        
    }

    public String getField() {
        return field;
    }

    public void setField(String field) {
        this.field = field;
    }

    public Class getType() {
        return type;
    }

    public void setType(Class type) {
        this.type = type;
    }

    public SimpleFeatureType apply(ImportTask task, DataStore dataStore,
            SimpleFeatureType featureType) throws Exception {

        SimpleFeatureTypeBuilder builder = new SimpleFeatureTypeBuilder();
        builder.init(featureType);

        int index = featureType.indexOf(field);
        if (index < 0) {
            throw new Exception("FeatureType " + featureType.getName() + " does not have attribute named '" + field + "'");
        }
        


        AttributeDescriptor existing = builder.remove(field);
        AttributeTypeBuilder attBuilder = new AttributeTypeBuilder();
        attBuilder.init(existing);
        attBuilder.setBinding(type);
        builder.add(index, attBuilder.buildDescriptor(field));

        return builder.buildFeatureType();
    }

    public SimpleFeature apply(ImportTask task, DataStore dataStore, SimpleFeature oldFeature, 
        SimpleFeature feature) throws Exception {
        return feature;
    }

}

<code block>

package org.geoserver.importer.transform;

import org.geotools.data.DataStore;
import org.geoserver.importer.ImportTask;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.feature.simple.SimpleFeatureType;


public abstract class AbstractInlineVectorTransform extends AbstractVectorTransform implements
        InlineVectorTransform {


    private static final long serialVersionUID = 1L;

    @Override
    public SimpleFeatureType apply(ImportTask task, DataStore dataStore,
            SimpleFeatureType featureType) throws Exception {
        return featureType;
    }

    @Override
    public SimpleFeature apply(ImportTask task, DataStore dataStore, SimpleFeature oldFeature,
            SimpleFeature feature) throws Exception {
        return feature;
    }

}

<code block>

package org.geoserver.importer.transform;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.logging.Level;
import org.geoserver.catalog.DataStoreInfo;
import org.geotools.data.DataAccess;
import org.geotools.data.Transaction;
import org.geotools.jdbc.JDBCDataStore;
import org.geoserver.importer.ImportData;
import org.geoserver.importer.ImportTask;


public class CreateIndexTransform extends AbstractVectorTransform implements PostVectorTransform {
    
    private static final long serialVersionUID = 1L;
    
    private String field;
    
    public CreateIndexTransform(String field) {
        this.field = field;
    }

    public String getField() {
        return field;
    }

    public void setField(String field) {
        this.field = field;
    }
    
    public void apply(ImportTask task, ImportData data) throws Exception {
        DataStoreInfo storeInfo = (DataStoreInfo) task.getStore();
        DataAccess store = storeInfo.getDataStore(null);
        if (store instanceof JDBCDataStore) {
            createIndex( task, (JDBCDataStore) store);
        } else {
            task.addMessage(Level.WARNING, "Cannot create index on non database target. Not a big deal.");
        }
    }
    
    private void createIndex(ImportTask item, JDBCDataStore store) throws Exception {
        Connection conn = null;
        Statement stmt = null;
        Exception error = null;
        String sql = null;
        try {
            conn = store.getConnection(Transaction.AUTO_COMMIT);
            stmt = conn.createStatement();
            String tableName = item.getLayer().getResource().getNativeName();
            String indexName = "\"" + tableName + "_" + field + "\"";
            sql = "CREATE INDEX " + indexName + " ON \"" + tableName + "\" (\"" + field + "\")";
            stmt.execute(sql);
        } catch (SQLException sqle) {
            error = sqle;
        } finally {
            store.closeSafe(stmt);
            store.closeSafe(conn);
        }
        if (error != null) {
            throw new Exception("Error creating index, SQL was : " + sql,error);
        }
    }
    
}

<code block>

package org.geoserver.importer.transform;

import org.geoserver.importer.ImportData;
import org.geoserver.importer.ImportTask;


public interface PreVectorTransform extends VectorTransform {

    void apply(ImportTask task, ImportData data) throws Exception;
}

<code block>

package org.geoserver.importer.rest;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.text.SimpleDateFormat;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.TimeZone;
import java.util.logging.LogRecord;

import net.sf.json.JSONArray;
import net.sf.json.JSONObject;
import net.sf.json.JSONSerializer;
import net.sf.json.util.JSONBuilder;

import org.geoserver.catalog.CoverageStoreInfo;
import org.geoserver.catalog.DataStoreInfo;
import org.geoserver.catalog.FeatureTypeInfo;
import org.geoserver.catalog.LayerInfo;
import org.geoserver.catalog.ResourceInfo;
import org.geoserver.catalog.StoreInfo;
import org.geoserver.catalog.StyleInfo;
import org.geoserver.config.util.XStreamPersister;
import org.geoserver.config.util.XStreamPersister.Callback;
import org.geoserver.config.util.XStreamPersisterFactory;
import org.geoserver.rest.PageInfo;
import org.geoserver.rest.RestletException;
import org.geotools.geometry.jts.ReferencedEnvelope;
import org.geotools.referencing.CRS;
import org.geoserver.importer.Database;
import org.geoserver.importer.Directory;
import org.geoserver.importer.FileData;
import org.geoserver.importer.ImportContext;
import org.geoserver.importer.ImportData;
import org.geoserver.importer.ImportTask;
import org.geoserver.importer.Importer;
import org.geoserver.importer.SpatialFile;
import org.geoserver.importer.Table;
import org.geoserver.importer.mosaic.Granule;
import org.geoserver.importer.mosaic.Mosaic;
import org.geoserver.importer.transform.AttributeRemapTransform;
import org.geoserver.importer.transform.AttributesToPointGeometryTransform;
import org.geoserver.importer.transform.CreateIndexTransform;
import org.geoserver.importer.transform.DateFormatTransform;
import org.geoserver.importer.transform.ImportTransform;
import org.geoserver.importer.transform.IntegerFieldToDateTransform;
import org.geoserver.importer.transform.ReprojectTransform;
import org.geoserver.importer.transform.TransformChain;
import org.geoserver.importer.transform.VectorTransformChain;
import org.opengis.referencing.crs.CoordinateReferenceSystem;
import org.restlet.data.Status;

import com.thoughtworks.xstream.converters.MarshallingContext;
import com.thoughtworks.xstream.io.HierarchicalStreamWriter;
import org.geoserver.catalog.AttributeTypeInfo;


public class ImportJSONWriter {

    static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ");
    static {
        DATE_FORMAT.setTimeZone(TimeZone.getTimeZone("GMT"));
    }

    Importer importer;
    PageInfo page;
    FlushableJSONBuilder json;

    public ImportJSONWriter(Importer importer, PageInfo page) {
        this(importer, page, new ByteArrayOutputStream());
    }

    public ImportJSONWriter(Importer importer, PageInfo page, OutputStream out) {
        this(importer, page, new OutputStreamWriter(out));
    }

    public ImportJSONWriter(Importer importer, PageInfo page, Writer w) {
        this.importer = importer;
        this.page = page;
        this.json = new FlushableJSONBuilder(w);
    }

    public void contexts(Iterator<ImportContext> contexts, int expand) throws IOException {
        json.object().key("imports").array();
        while (contexts.hasNext()) {
            ImportContext context = contexts.next();
            context(context, false, expand);
        }
        json.endArray().endObject();
        json.flush();
    }

    public void context(ImportContext context, boolean top, int expand) throws IOException {
        if (top) {
            json.object().key("import");
        }

        json.object();
        json.key("id").value(context.getId());
        json.key("href").value(page.rootURI(pathTo(context)));
        json.key("state").value(context.getState());
        
        if (expand > 0) {
            json.key("archive").value(context.isArchive());
            if (context.getTargetWorkspace() != null) {
                json.key("targetWorkspace").value(toJSON(context.getTargetWorkspace()));
            }
            if (context.getTargetStore() != null) {
                json.key("targetStore");
                store(context.getTargetStore(), null, false, expand-1);

            }
    
            if (context.getData() != null) {
                json.key("data");
                data(context.getData(), context, expand-1);
            }
            tasks(context.getTasks(), false, expand-1);
        }

        json.endObject();

        if (top) {
            json.endObject();
        }
        json.flush();
    }

    public void tasks(List<ImportTask> tasks, boolean top, int expand) throws IOException {

        if (top) {
            json.object();
        }

        json.key("tasks").array();
        for (ImportTask task : tasks) {
            task(task, false, expand);
        }
        json.endArray();
        
        if (top) {
            json.endObject();
        }
        json.flush();
    }

    public void task(ImportTask task, boolean top, int expand) throws IOException {

        long id = task.getId();
        String href = page.rootURI(pathTo(task));
        if (top) {
            json.object().key("task");
        }
        json.object();
        json.key("id").value(id);
        json.key("href").value(href);
        json.key("state").value(task.getState());

        if (expand > 0) {
            json.key("updateMode").value(task.getUpdateMode().name());
    

            ImportData data = task.getData();
            if (data != null) {
                json.key("data");
                data(data, task, expand-1);
            }


            StoreInfo store = task.getStore();
            if (store != null) {
                json.key("target");
                store(store, task, false, expand-1);
            }

            json.key("progress").value(href + "/progress");

            LayerInfo layer = task.getLayer();
            if (layer != null) {

                layer.getResource().setCatalog(importer.getCatalog());

                json.key("layer");
                layer(task, false, expand-1);
            }

            if (task.getError() != null) {
                json.key("errorMessage").value(concatErrorMessages(task.getError()));
            }

            transformChain(task, false, expand-1);
            messages(task.getMessages());
        }
        
        json.endObject();
        if (top) {
            json.endObject();
        }

        json.flush();
    }

    void store(StoreInfo store, ImportTask task, boolean top, int expand) throws IOException {
            
        String type = store instanceof DataStoreInfo ? "dataStore" : 
                      store instanceof CoverageStoreInfo ? "coverageStore" : "store";

        json.object();
        if (task != null) {
            json.key("href").value(page.rootURI(pathTo(task) + "/target"));
        }

        if (expand > 0) {
            JSONObject obj = toJSON(store);
            json.key(type).value(obj.get(type));
        }
        else {
            json.key(type).object()
                .key("name").value(store.getName())
                .key("type").value(store.getType())
                .endObject();
        }

        json.endObject();
        json.flush();
    }

    void layer(ImportTask task, boolean top, int expand) throws IOException {

        if (top) {
            json.object().key("layer");
        }

        LayerInfo layer = task.getLayer();
        ResourceInfo r = layer.getResource();

        json.object()
            .key("name").value(layer.getName())
            .key("href").value(page.rootURI(pathTo(task) + "/layer"));
        
        if (expand > 0) {
            if (r.getTitle() != null) {
                json.key("title").value(r.getTitle());
            }
            if (r.getAbstract() != null) {
                json.key("abstract").value(r.getAbstract());
            }
            if (r.getDescription() != null) {
                json.key("description").value(r.getDescription());
            }
            json.key("originalName").value(task.getOriginalLayerName());
            if (r != null) {
                json.key("nativeName").value(r.getNativeName());
    
                if (r.getSRS() != null) {
                    json.key("srs").value(r.getSRS());
                }
                if (r.getNativeBoundingBox() != null) {
                    json.key("bbox");
                    bbox(json, r.getNativeBoundingBox());
                }
            }
            if (r instanceof FeatureTypeInfo) {
                featureType((FeatureTypeInfo) r);
            }
            StyleInfo s = layer.getDefaultStyle();
            if (s != null) {
                style(s, task, false, expand-1);
            }
        }

        json.endObject();
        if (top) {
            json.endObject();
        }
        json.flush();
    }

    void featureType(FeatureTypeInfo featureTypeInfo) throws IOException {
        json.key("attributes").array();
        List<AttributeTypeInfo> attributes = featureTypeInfo.attributes();
        for (int i = 0; i < attributes.size(); i++) {
            AttributeTypeInfo att = attributes.get(i);
            json.object();
            json.key("name").value(att.getName());
            json.key("binding").value(att.getBinding().getName());
            json.endObject();
        }
        json.endArray();
    }

    void style(StyleInfo style, ImportTask task, boolean top, int expand) throws IOException {
        
        if (top) {
            json.object();
        }

        String href = page.rootURI(pathTo(task) + "/layer/style");

        json.key("style");
        if (expand > 0) {
            JSONObject obj = toJSON(style).getJSONObject("style");
            obj.put("href", href);
            json.value(obj);
        }
        else {
            json.object();
            json.key("name").value(style.getName());
            json.key("href").value(href);
            json.endObject();
        }
        
        if (top) {
            json.endObject();
        }
    }

    void transformChain(ImportTask task, boolean top, int expand) throws IOException {

        if (top) {
            json.object();
        }

        TransformChain<? extends ImportTransform> txChain = task.getTransform();

        json.key("transformChain").object();
        json.key("type").value(txChain instanceof VectorTransformChain ? "vector" : "raster");

        json.key("transforms").array();

        if (txChain != null) {
            for (int i = 0; i < txChain.getTransforms().size(); i++) {
                transform(txChain.getTransforms().get(i), i, task, false, expand);
            }
        }

        json.endArray();
        json.endObject();

        if (top) {
            json.endObject();
        }
        
        json.flush();
    }

    public void transform(ImportTransform transform, int index, ImportTask task, boolean top, 
        int expand) throws IOException {
        json.object();
        json.key("type").value(transform.getClass().getSimpleName());
        json.key("href").value(page.rootURI(pathTo(task)+"/transform/" + index));
        if (expand > 0) {
            if (transform instanceof DateFormatTransform) {
                DateFormatTransform df = (DateFormatTransform) transform;
                json.key("field").value(df.getField());
                if (df.getDatePattern() != null) {
                    json.key("format").value(df.getDatePattern().dateFormat().toPattern());
                }
    
            } else if (transform instanceof IntegerFieldToDateTransform) {
                IntegerFieldToDateTransform df = (IntegerFieldToDateTransform) transform;
                json.key("field").value(df.getField());
            } else if (transform instanceof CreateIndexTransform) {
                CreateIndexTransform df = (CreateIndexTransform) transform;
                json.key("field").value(df.getField());
            } else if (transform instanceof AttributeRemapTransform) {
                AttributeRemapTransform art = (AttributeRemapTransform) transform;
                json.key("field").value(art.getField());
                json.key("target").value(art.getType().getName());
            } else if (transform.getClass() == AttributesToPointGeometryTransform.class) {
                AttributesToPointGeometryTransform atpgt = (AttributesToPointGeometryTransform) transform;
                json.key("latField").value(atpgt.getLatField());
                json.key("lngField").value(atpgt.getLngField());
            } else if (transform.getClass() == ReprojectTransform.class) {
                ReprojectTransform rt = (ReprojectTransform) transform;
                json.key("source").value(srs(rt.getSource()));
                json.key("target").value(srs(rt.getTarget()));
            } else {
                throw new IOException("Serializaiton of " + transform.getClass() + " not implemented");
            }
        }
        json.endObject();
        json.flush();
    }

    void bbox(JSONBuilder json, ReferencedEnvelope bbox) {
        json.object()
            .key("minx").value(bbox.getMinX())
            .key("miny").value(bbox.getMinY())
            .key("maxx").value(bbox.getMaxX())
            .key("maxy").value(bbox.getMaxY());

        CoordinateReferenceSystem crs = bbox.getCoordinateReferenceSystem(); 
        if (crs != null) {
            json.key("crs").value(crs.toWKT());
        }

        json.endObject();
    }

    public void data(ImportData data, Object parent, int expand) throws IOException {
        if (data instanceof FileData) {
            if (data instanceof Directory) {
                if (data instanceof Mosaic) {
                    mosaic((Mosaic) data, parent ,expand);
                }
                else {
                    directory((Directory) data, parent, expand);
                }
            } else {
                file((FileData) data, parent, expand, false);
            }
        } else if (data instanceof Database) {
            database((Database) data, parent, expand);
        } else if (data instanceof Table) {
            table((Table)data, parent, expand);
        }
        json.flush();
    }

    public void file(FileData data, Object parent, int expand, boolean href) throws IOException {
        
        json.object();
        
        json.key("type").value("file");
        json.key("format").value(data.getFormat() != null ? data.getFormat().getName() : null);
        if (href) {
            json.key("href").value(page.rootURI(pathTo(data, parent)));
        }
        
        if (expand > 0) {
            json.key("location").value(data.getFile().getParentFile().getPath());
            if (data.getCharsetEncoding() != null) {
                json.key("charset").value(data.getCharsetEncoding());
            }
            fileContents(data, parent, expand);
            message(data);
        }
        else {
            json.key("file").value(data.getFile().getName());
        }

        json.endObject();
        json.flush();
    }

    void fileContents(FileData data, Object parent, int expand) throws IOException {

        String filename = data.getFile().getName();
        json.key("file").value(filename);
        json.key("href").value(page.rootURI(pathTo(data, parent)+"/files/"+filename));
        if (expand > 0) {
            if (data instanceof SpatialFile) {
                SpatialFile sf = (SpatialFile) data;
                json.key("prj").value(sf.getPrjFile() != null ? sf.getPrjFile().getName() : null);
                json.key("other").array();
                for (File supp : ((SpatialFile) data).getSuppFiles()) {
                    json.value(supp.getName());
                }
                json.endArray();
    
                if (sf instanceof Granule) {
                    Granule g = (Granule) sf;
                    if (g.getTimestamp() != null) {
                        json.key("timestamp").value(DATE_FORMAT.format(g.getTimestamp()));
                    }
                }
            }
        }
    }


    public void mosaic(Mosaic data, Object parent, int expand) 
        throws IOException {
        directory(data, "mosaic", parent, expand);
    }

    public void directory(Directory data, Object parent, int expand) throws IOException {
        directory(data, "directory", parent, expand);
    }

    public void directory(Directory data, String typeName, Object parent, int expand) 
        throws IOException {

        json.object();
        json.key("type").value(typeName);
        if (data.getFormat() != null) {
            json.key("format").value(data.getFormat().getName());
        }

        json.key("location").value(data.getFile().getPath());
        json.key("href").value(page.rootURI(pathTo(data, parent)));

        if (expand > 0) {
            if (data.getCharsetEncoding() != null) {
                json.key("charset").value(data.getCharsetEncoding());
            }

            json.key("files");
            files(data, parent, false, expand-1);
            message(data);
        }
        json.endObject();
        json.flush();
    }

    public void files(Directory data, Object parent, boolean top, int expand) throws IOException {

        if (top) {
            json.object().key("files");
        }
        json.array();
        for (FileData file : data.getFiles()) {
            json.object();
            fileContents(file, parent, expand-1);
            json.endObject();
        }
        json.endArray();
        if (top) {
            json.endObject();
        }
        json.flush();
    }

    public void database(Database data, Object parent, int expand) throws IOException {
        json.object();
        json.key("type").value("database");
        json.key("format").value(data.getFormat() != null ? data.getFormat().getName() : null);
        json.key("href").value(page.rootURI(pathTo(data, parent)));

        if (expand > 0) {
            json.key("parameters").object();
            for (Map.Entry e : data.getParameters().entrySet()) {
                json.key((String) e.getKey()).value(e.getValue());
            }
    
            json.endObject();
            
            json.key("tables").array();
            for (Table t : data.getTables()) {
                json.value(t.getName());
            }
    
            message(data);
            json.endArray();
        }

        json.endObject();
    }

    void table(Table data, Object parent, int expand) throws IOException {
        json.object();
        json.key("type").value("table");
        json.key("name").value(data.getName());
        json.key("format").value(data.getFormat() != null ? data.getFormat().getName() : null);
        json.key("href").value(page.rootURI(pathTo(data, parent)));
        json.endObject();
    }

    void message(ImportData data) throws IOException {
        if (data.getMessage() != null) {
            json.key("message").value(data.getMessage());
        }
    }

    void messages(List<LogRecord> records) {
        if (!records.isEmpty()) {
            json.key("messages");
            json.array();
            for (int i = 0; i < records.size(); i++) {
                LogRecord record = records.get(i);
                json.object();
                json.key("level").value(record.getLevel().toString());
                json.key("message").value(record.getMessage());
                json.endObject();
            }
            json.endArray();
        }
    }

    String concatErrorMessages(Throwable ex) {
        StringBuilder buf = new StringBuilder();
        while (ex != null) {
            if (buf.length() > 0) {
                buf.append('\n');
            }
            if (ex.getMessage() != null) {
                buf.append(ex.getMessage());
            }
            ex = ex.getCause();
        }
        return buf.toString();
    }

    FlushableJSONBuilder builder(OutputStream out) {
        return new FlushableJSONBuilder(new OutputStreamWriter(out));
    }

    JSONObject toJSON(Object o) throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        toJSON(o, out);
        return (JSONObject) JSONSerializer.toJSON(new String(out.toByteArray()));
    }

    void toJSON(Object o, OutputStream out) throws IOException {
        toJSON(o, out, null);
    }
    
    void toJSON(Object o, OutputStream out, Callback callback) throws IOException {
        XStreamPersister xp = persister();
        if (callback != null) {
            xp.setCallback(callback);
        }
        xp.save(o, out);
        out.flush();
    }

    XStreamPersister persister() {
        XStreamPersister xp = 
            importer.initXStreamPersister(new XStreamPersisterFactory().createJSONPersister());
        
        xp.setReferenceByName(true);
        xp.setExcludeIds();


        xp.setHideFeatureTypeAttributes();

        xp.setCallback(new XStreamPersister.Callback() {

            @Override
            protected void postEncodeFeatureType(FeatureTypeInfo ft,
                    HierarchicalStreamWriter writer, MarshallingContext context) {
                try {
                    writer.startNode("attributes");
                    context.convertAnother(ft.attributes());
                    writer.endNode();
                } catch (IOException e) {
                    throw new RuntimeException("Could not get native attributes", e);
                }
            }
        });
        return xp;
    }

    String srs(CoordinateReferenceSystem crs) {
        return CRS.toSRS(crs);
    }

    static String pathTo(ImportContext context) {
        return "/imports/" + context.getId();
    }

    static String pathTo(ImportTask task) {
        return pathTo(task.getContext()) +  "/tasks/" + task.getId();
    }

    String pathTo(Object parent) {
        if (parent instanceof ImportContext) {
            return pathTo((ImportContext)parent);
        }
        else if (parent instanceof ImportTask) {
            return pathTo((ImportTask)parent);
        }
        else {
            throw new IllegalArgumentException("Don't recognize: " + parent);
        }
    }

    String pathTo(ImportData data, Object parent) {
        return pathTo(parent) + "/data";
    }

    static RestletException badRequest(String error) {
        JSONObject errorResponse = new JSONObject();
        JSONArray errors = new JSONArray();
        errors.add(error);
        errorResponse.put("errors", errors);
        
        JSONRepresentation rep = new JSONRepresentation(errorResponse);
        return new RestletException(rep, Status.CLIENT_ERROR_BAD_REQUEST);
    }

    public static class FlushableJSONBuilder extends JSONBuilder {

        public FlushableJSONBuilder(Writer w) {
            super(w);
        }

        public void flush() throws IOException {
            writer.flush();
        }
    }
}

<code block>

package org.geoserver.importer.rest;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;

import net.sf.json.JSONArray;
import net.sf.json.JSONObject;

import org.apache.commons.io.IOUtils;
import org.geoserver.catalog.CatalogFactory;
import org.geoserver.catalog.DataStoreInfo;
import org.geoserver.catalog.LayerInfo;
import org.geoserver.catalog.ResourceInfo;
import org.geoserver.catalog.StoreInfo;
import org.geoserver.catalog.StyleInfo;
import org.geoserver.catalog.WorkspaceInfo;
import org.geoserver.config.util.XStreamPersister;
import org.geotools.geometry.jts.ReferencedEnvelope;
import org.geotools.referencing.CRS;
import org.geoserver.importer.Archive;
import org.geoserver.importer.Database;
import org.geoserver.importer.Directory;
import org.geoserver.importer.FileData;
import org.geoserver.importer.ImportContext;
import org.geoserver.importer.ImportData;
import org.geoserver.importer.ImportTask;
import org.geoserver.importer.Importer;
import org.geoserver.importer.UpdateMode;
import org.geoserver.importer.ImportContext.State;
import org.geoserver.importer.ValidationException;
import org.geoserver.importer.mosaic.Mosaic;
import org.geoserver.importer.mosaic.TimeMode;
import org.geoserver.importer.transform.AttributeRemapTransform;
import org.geoserver.importer.transform.AttributesToPointGeometryTransform;
import org.geoserver.importer.transform.CreateIndexTransform;
import org.geoserver.importer.transform.DateFormatTransform;
import org.geoserver.importer.transform.ImportTransform;
import org.geoserver.importer.transform.IntegerFieldToDateTransform;
import org.geoserver.importer.transform.RasterTransformChain;
import org.geoserver.importer.transform.ReprojectTransform;
import org.geoserver.importer.transform.TransformChain;
import org.geoserver.importer.transform.VectorTransformChain;
import org.opengis.referencing.crs.CoordinateReferenceSystem;

public class ImportJSONReader {

    Importer importer;
    JSONObject json;

    public ImportJSONReader(Importer importer, String in) throws IOException {
        this(importer, new ByteArrayInputStream(in.getBytes()));
    }

    public ImportJSONReader(Importer importer, InputStream in) throws IOException {
        this.importer = importer;
        json = parse(in);
    }

    public ImportJSONReader(Importer importer, JSONObject obj) {
        this.importer = importer;
        json = obj;
    }

    public JSONObject object() {
        return json;
    }

    public ImportContext context() throws IOException {
        ImportContext context = null;
        if (json.has("import")) {
            context = new ImportContext();
            
            json = json.getJSONObject("import");
            if (json.has("id")) {
                context.setId(json.getLong("id"));
            }
            if (json.has("state")) {
                context.setState(State.valueOf(json.getString("state")));
            }
            if (json.has("user")) {
                context.setUser(json.getString("user"));
            }
            if (json.has("archive")) {
                context.setArchive(json.getBoolean("archive"));
            }
            if (json.has("targetWorkspace")) {
                context.setTargetWorkspace(
                    fromJSON(json.getJSONObject("targetWorkspace"), WorkspaceInfo.class));
            }
            if (json.has("targetStore")) {
                context.setTargetStore(
                    fromJSON(json.getJSONObject("targetStore"), StoreInfo.class));
            }
            if (json.has("data")) {
                context.setData(data(json.getJSONObject("data")));
            }
        }
        return context;
    }

    public LayerInfo layer() throws IOException {
        return layer(json);
    }

    LayerInfo layer(JSONObject json) throws IOException {
        CatalogFactory f = importer.getCatalog().getFactory();

        if (json.has("layer")) {
            json = json.getJSONObject("layer");
        }


        ResourceInfo r = f.createFeatureType();
        if (json.has("name")) {
            r.setName(json.getString("name"));
        }
        if (json.has("nativeName")) {
            r.setNativeName(json.getString("nativeName"));
        }
        if (json.has("srs")) {
            r.setSRS(json.getString("srs"));
            try {
                r.setNativeCRS(CRS.decode(json.getString("srs")));
            }
            catch(Exception e) {

            }
            
        }
        if (json.has("bbox")) {
            r.setNativeBoundingBox(bbox(json.getJSONObject("bbox")));
        }
        if (json.has("title")) {
            r.setTitle(json.getString("title"));
        }
        if (json.has("abstract")) {
            r.setAbstract(json.getString("abstract"));
        }
        if (json.has("description")) {
            r.setDescription(json.getString("description"));
        }

        LayerInfo l = f.createLayer();
        l.setResource(r);

        
        if (json.has("style")) {
            JSONObject sobj = new JSONObject();
            sobj.put("defaultStyle", json.get("style"));

            JSONObject lobj = new JSONObject();
            lobj.put("layer", sobj);

            LayerInfo tmp = fromJSON(lobj, LayerInfo.class);
            if (tmp.getDefaultStyle() != null) {
                l.setDefaultStyle(tmp.getDefaultStyle());
            }
            else {
                sobj = new JSONObject();
                sobj.put("style", json.get("style"));
                
                l.setDefaultStyle(fromJSON(sobj, StyleInfo.class));
            }

        }
        return l;
    }

    public ImportTask task() throws IOException {

        if (json.has("task")) {
            json =  json.getJSONObject("task");
        }

        ImportTask task = new ImportTask();

        if (json.has("id")) {
            task.setId(json.getInt("id"));
        }
        if (json.has("updateMode")) {
            task.setUpdateMode(UpdateMode.valueOf(json.getString("updateMode").toUpperCase()));
        } else {


            task.setUpdateMode(null);
        }

        JSONObject data = null;
        if (json.has("data")) {
            data = json.getJSONObject("data");
        }
        else if (json.has("source")) { 
            data = json.getJSONObject("source");
        }

        if (data != null) {

            if (data.has("charset")) {
                if (task.getData() == null) {
                    task.setData(new ImportData.TransferObject());
                }
                task.getData().setCharsetEncoding(data.getString("charset"));
            }
        }
        if (json.has("target")) {
            task.setStore(fromJSON(json.getJSONObject("target"), StoreInfo.class));
        }

        LayerInfo layer = null; 
        if (json.has("layer")) {
            layer = layer(json.getJSONObject("layer"));
        } else {
            layer = importer.getCatalog().getFactory().createLayer();
        }
        task.setLayer(layer);

        if (json.has("transformChain")) {
            task.setTransform(transformChain(json.getJSONObject("transformChain")));
        }

        return task;
    }

    TransformChain transformChain(JSONObject json) throws IOException {
        String type = json.getString("type");
        TransformChain chain = null;
        if ("vector".equalsIgnoreCase(type) || "VectorTransformChain".equalsIgnoreCase(type)) {
            chain = new VectorTransformChain();
        } else if ("raster".equalsIgnoreCase(type) || "RasterTransformChain".equalsIgnoreCase(type)) {
            chain = new RasterTransformChain();
        } else {
            throw new IOException("Unable to parse transformChain of type " + type);
        }
        JSONArray transforms = json.getJSONArray("transforms");
        for (int i = 0; i < transforms.size(); i++) {
            chain.add(transform(transforms.getJSONObject(i)));
        }
        return chain;
    }

    public ImportTransform transform() throws IOException {
        return transform(json);
    }

    ImportTransform transform(JSONObject json) throws IOException {
        ImportTransform transform;
        String type = json.getString("type");
        if ("DateFormatTransform".equalsIgnoreCase(type)) {
            transform = new DateFormatTransform(json.getString("field"), json.optString("format", null));
        } else if ("IntegerFieldToDateTransform".equalsIgnoreCase(type)) {
            transform = new IntegerFieldToDateTransform(json.getString("field"));
        } else if ("CreateIndexTransform".equalsIgnoreCase(type)) {
            transform = new CreateIndexTransform(json.getString("field"));
        } else if ("AttributeRemapTransform".equalsIgnoreCase(type)) {
            Class clazz;
            try {
                clazz = Class.forName( json.getString("target") );
            } catch (ClassNotFoundException cnfe) {
                throw new ValidationException("unable to locate target class " + json.getString("target"));
            }
            transform = new AttributeRemapTransform(json.getString("field"), clazz);
        } else if ("AttributesToPointGeometryTransform".equalsIgnoreCase(type)) {
            String latField = json.getString("latField");
            String lngField = json.getString("lngField");
            transform = new AttributesToPointGeometryTransform(latField, lngField);
        } else if ("ReprojectTransform".equalsIgnoreCase(type)){
            CoordinateReferenceSystem source = json.has("source") ? crs(json.getString("source")) : null;
            CoordinateReferenceSystem target = json.has("target") ? crs(json.getString("target")) : null;

            try {
                transform = new ReprojectTransform(source, target);
            } 
            catch(Exception e) {
                throw new ValidationException("Error parsing reproject transform", e);
            }
        } else {
            throw new ValidationException("Invalid transform type '" + type + "'");
        }
        return transform;
    }

    public ImportData data() throws IOException {
        return data(json);
    }

    ImportData data(JSONObject json) throws IOException {
        String type = json.getString("type");
        if (type == null) {
            throw new IOException("Data object must specify 'type' property");
        }

        if ("file".equalsIgnoreCase(type)) {
            return file(json);
        }
        else if("directory".equalsIgnoreCase(type)) {
            return directory(json);
        }
        else if("mosaic".equalsIgnoreCase(type)) {
            return mosaic(json);
        }
        else if("archive".equalsIgnoreCase(type)) {
            return archive(json);
        }
        else if ("database".equalsIgnoreCase(type)) {
            return database(json);
        }
        else {
            throw new IllegalArgumentException("Unknown data type: " + type);
        }
    }

    FileData file(JSONObject json) throws IOException {
        if (json.has("file")) {

            String file = json.getString("file");
            return FileData.createFromFile(new File(file));

        }
        else {

            return new FileData((File)null);
        }
    }

    Mosaic mosaic(JSONObject json) throws IOException {
        Mosaic m = new Mosaic(json.has("location") ?  new File(json.getString("location")) : 
            Directory.createNew(importer.getUploadRoot()).getFile());
        if (json.has("name")) {
            m.setName(json.getString("name"));
        }
        if (json.containsKey("time")) {
            JSONObject time = json.getJSONObject("time");
            if (!time.containsKey("mode")) {
                throw new IllegalArgumentException("time object must specific mode property as " +
                    "one of " + TimeMode.values());
            }

            m.setTimeMode(TimeMode.valueOf(time.getString("mode").toUpperCase()));
            m.getTimeHandler().init(time);
        }
        return m;
    }

    Archive archive(JSONObject json) throws IOException {
        throw new UnsupportedOperationException("TODO: implement");
    }

    public Directory directory() throws IOException {
        return directory(json);
    }

    Directory directory(JSONObject json) throws IOException {
        if (json.has("location")) {
            return new Directory(new File(json.getString("location")));
        }
        else {
            return Directory.createNew(importer.getUploadRoot());
        }
    }

    Database database(JSONObject json) throws IOException {
        throw new UnsupportedOperationException("TODO: implement");
    }
    
    ReferencedEnvelope bbox(JSONObject json) {
        CoordinateReferenceSystem crs = null;
        if (json.has("crs")) {
            crs = (CoordinateReferenceSystem) 
                new XStreamPersister.CRSConverter().fromString(json.getString("crs"));
        }

        return new ReferencedEnvelope(json.getDouble("minx"), json.getDouble("maxx"), 
            json.getDouble("miny"), json.getDouble("maxy"), crs);
    }

    CoordinateReferenceSystem crs(String srs) {
        try {
            return CRS.decode(srs);
        } catch (Exception e) {
            throw new RuntimeException("Failing parsing srs: " + srs, e);
        }
    }

    JSONObject parse(InputStream in) throws IOException {
        ByteArrayOutputStream bout = new ByteArrayOutputStream();
        IOUtils.copy(in, bout);
        return JSONObject.fromObject(new String(bout.toByteArray()));
    }

    Object read(InputStream in) throws IOException {
        Object result = null;
        JSONObject json = parse(in);

        if (json.containsKey("target")) {
            result = fromJSON(json.getJSONObject("target"), DataStoreInfo.class);
        }
        return result;
    }

    <T> T fromJSON(JSONObject json, Class<T> clazz) throws IOException {
        XStreamPersister xp = importer.createXStreamPersisterJSON();
        return (T) xp.load(new ByteArrayInputStream(json.toString().getBytes()), clazz);
    }

    <T> T fromJSON(Class<T> clazz) throws IOException {
        return fromJSON(json, clazz);
    }
}

<code block>

package org.geoserver.catalog;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.measure.unit.Unit;
import javax.media.jai.PlanarImage;

import org.geoserver.catalog.impl.FeatureTypeInfoImpl;
import org.geoserver.catalog.impl.ModificationProxy;
import org.geoserver.catalog.impl.ResourceInfoImpl;
import org.geoserver.catalog.impl.StoreInfoImpl;
import org.geoserver.catalog.impl.StyleInfoImpl;
import org.geoserver.catalog.impl.WMSStoreInfoImpl;
import org.geoserver.data.util.CoverageStoreUtils;
import org.geoserver.data.util.CoverageUtils;
import org.geoserver.ows.util.OwsUtils;
import org.geotools.coverage.Category;
import org.geotools.coverage.GridSampleDimension;
import org.geotools.coverage.grid.GridCoverage2D;
import org.geotools.coverage.grid.GridEnvelope2D;
import org.geotools.coverage.grid.GridGeometry2D;
import org.geotools.coverage.grid.io.AbstractGridFormat;
import org.geotools.coverage.grid.io.GridCoverage2DReader;
import org.geotools.data.FeatureSource;
import org.geotools.data.ows.CRSEnvelope;
import org.geotools.data.ows.Layer;
import org.geotools.factory.GeoTools;
import org.geotools.feature.FeatureTypes;
import org.geotools.gce.imagemosaic.ImageMosaicFormat;
import org.geotools.geometry.GeneralEnvelope;
import org.geotools.geometry.jts.ReferencedEnvelope;
import org.geotools.referencing.CRS;
import org.geotools.referencing.CRS.AxisOrder;
import org.geotools.referencing.crs.DefaultGeographicCRS;
import org.geotools.resources.image.ImageUtilities;
import org.geotools.util.NumberRange;
import org.geotools.util.Version;
import org.geotools.util.logging.Logging;
import org.opengis.coverage.grid.Format;
import org.opengis.coverage.grid.GridEnvelope;
import org.opengis.feature.type.AttributeDescriptor;
import org.opengis.feature.type.FeatureType;
import org.opengis.feature.type.GeometryDescriptor;
import org.opengis.feature.type.Name;
import org.opengis.feature.type.PropertyDescriptor;
import org.opengis.metadata.Identifier;
import org.opengis.parameter.ParameterValueGroup;
import org.opengis.referencing.FactoryException;
import org.opengis.referencing.crs.CoordinateReferenceSystem;
import org.opengis.referencing.crs.GeographicCRS;
import org.opengis.referencing.datum.PixelInCell;
import org.opengis.referencing.operation.MathTransform;

import com.vividsolutions.jts.geom.LineString;
import com.vividsolutions.jts.geom.MultiLineString;
import com.vividsolutions.jts.geom.MultiPoint;
import com.vividsolutions.jts.geom.MultiPolygon;
import com.vividsolutions.jts.geom.Point;
import com.vividsolutions.jts.geom.Polygon;


public class CatalogBuilder {

    static final Logger LOGGER = Logging.getLogger(CatalogBuilder.class);


    Catalog catalog;


    WorkspaceInfo workspace;


    StoreInfo store;

    public CatalogBuilder(Catalog catalog) {
        this.catalog = catalog;
    }


    public void setWorkspace(WorkspaceInfo workspace) {
        this.workspace = workspace;
    }


    public void setStore(StoreInfo store) {
        this.store = store;
    }


    public void updateWorkspace(WorkspaceInfo original, WorkspaceInfo update) {
        update(original, update, WorkspaceInfo.class);
    }


    public void updateNamespace(NamespaceInfo original, NamespaceInfo update) {
        update(original, update, NamespaceInfo.class);
    }


    public void updateDataStore(DataStoreInfo original, DataStoreInfo update) {
        update(original, update, DataStoreInfo.class);
    }


    public void updateWMSStore(WMSStoreInfo original, WMSStoreInfo update) {
        update(original, update, WMSStoreInfo.class);
    }


    public void updateCoverageStore(CoverageStoreInfo original, CoverageStoreInfo update) {
        update(original, update, CoverageStoreInfo.class);
    }


    public void updateFeatureType(FeatureTypeInfo original, FeatureTypeInfo update) {
        update(original, update, FeatureTypeInfo.class);
    }


    public void updateCoverage(CoverageInfo original, CoverageInfo update) {
        update(original, update, CoverageInfo.class);
    }


    public void updateWMSLayer(WMSLayerInfo original, WMSLayerInfo update) {
        update(original, update, WMSLayerInfo.class);
    }


    public void updateLayer(LayerInfo original, LayerInfo update) {
        update(original, update, LayerInfo.class);
    }


    public void updateLayerGroup(LayerGroupInfo original, LayerGroupInfo update) {
        update(original, update, LayerGroupInfo.class);
    }


    public void updateStyle(StyleInfo original, StyleInfo update) {
        update(original, update, StyleInfo.class);
    }


    <T> void update(T original, T update, Class<T> clazz) {
        OwsUtils.copy(update, original, clazz);
    }


    public DataStoreInfo buildDataStore(String name) {
        DataStoreInfo info = catalog.getFactory().createDataStore();
        buildStore(info, name);

        return info;
    }


    public CoverageStoreInfo buildCoverageStore(String name) {
        CoverageStoreInfo info = catalog.getFactory().createCoverageStore();
        buildStore(info, name);

        return info;
    }


    public WMSStoreInfo buildWMSStore(String name) throws IOException {
        WMSStoreInfo info = catalog.getFactory().createWebMapServer();
        buildStore(info, name);
        info.setType("WMS");
        info.setMaxConnections(WMSStoreInfoImpl.DEFAULT_MAX_CONNECTIONS);
        info.setConnectTimeout(WMSStoreInfoImpl.DEFAULT_CONNECT_TIMEOUT);
        info.setReadTimeout(WMSStoreInfoImpl.DEFAULT_READ_TIMEOUT);

        return info;
    }


    void buildStore(StoreInfo info, String name) {

        info.setName(name);
        info.setEnabled(true);


        if (workspace != null) {
            info.setWorkspace(workspace);
        } else {
            info.setWorkspace(catalog.getDefaultWorkspace());
        }
    }


    public FeatureTypeInfo buildFeatureType(Name typeName) throws Exception {
        if (store == null || !(store instanceof DataStoreInfo)) {
            throw new IllegalStateException("Data store not set.");
        }

        DataStoreInfo dstore = (DataStoreInfo) store;
        return buildFeatureType(dstore.getDataStore(null).getFeatureSource(typeName));
    }


    public FeatureTypeInfo buildFeatureType(FeatureSource featureSource) {
        if (store == null || !(store instanceof DataStoreInfo)) {
            throw new IllegalStateException("Data store not set.");
        }

        FeatureType featureType = featureSource.getSchema();

        FeatureTypeInfo ftinfo = catalog.getFactory().createFeatureType();
        ftinfo.setStore(store);
        ftinfo.setEnabled(true);


        Name name = featureSource.getName();
        if (name == null) {
            name = featureType.getName();
        }
        ftinfo.setNativeName(name.getLocalPart());
        ftinfo.setName(name.getLocalPart());

        WorkspaceInfo workspace = store.getWorkspace();
        NamespaceInfo namespace = catalog.getNamespaceByPrefix(workspace.getName());
        if (namespace == null) {
            namespace = catalog.getDefaultNamespace();
        }

        ftinfo.setNamespace(namespace);

        CoordinateReferenceSystem crs = featureType.getCoordinateReferenceSystem();
        if (crs == null && featureType.getGeometryDescriptor() != null) {
            crs = featureType.getGeometryDescriptor().getCoordinateReferenceSystem();
        }
        ftinfo.setNativeCRS(crs);


        try {
            lookupSRS(ftinfo, false);
        } catch (Exception e) {
            LOGGER.log(Level.WARNING, "SRS lookup failed", e);
        }
        setupProjectionPolicy(ftinfo);


        try {
            setupMetadata(ftinfo, featureSource);
        } catch (IOException e) {
            LOGGER.log(Level.WARNING, "Metadata lookup failed", e);
        }
        
        return ftinfo;
    }


    public void setupProjectionPolicy(ResourceInfo rinfo) {
        if (rinfo.getSRS() != null) {
            rinfo.setProjectionPolicy(ProjectionPolicy.FORCE_DECLARED);
        } else {
            rinfo.setProjectionPolicy(ProjectionPolicy.NONE);
        }
    }


    public void setupBounds(FeatureTypeInfo ftinfo, FeatureSource featureSource) throws IOException {
        doSetupBounds(ftinfo, featureSource);
    }


    public void setupBounds(CoverageInfo cinfo, GridCoverage2DReader coverageReader) 
        throws IOException {
        doSetupBounds(cinfo, coverageReader);
    }


    public void setupBounds(ResourceInfo rinfo) throws IOException {
        doSetupBounds(rinfo, null);
    }


    void doSetupBounds(ResourceInfo rinfo, Object data) throws IOException {

        if (rinfo.getNativeBoundingBox() == null) {
            ReferencedEnvelope bounds = getNativeBounds(rinfo, data);
            rinfo.setNativeBoundingBox(bounds);
        }


        rinfo.setLatLonBoundingBox(getLatLonBounds(rinfo.getNativeBoundingBox(), rinfo.getCRS()));
    }


    public void setupMetadata(FeatureTypeInfo ftinfo, FeatureSource featureSource) 
        throws IOException {

        org.geotools.data.ResourceInfo rinfo = null;
        try {
            rinfo = featureSource.getInfo();
        }
        catch(Exception ignore) {
            if (LOGGER.isLoggable(Level.FINE)) {
                LOGGER.log(Level.FINE, "Unable to get resource info from feature source", ignore);
            }
        }

        if (ftinfo.getTitle() == null) {
            ftinfo.setTitle(rinfo != null ? rinfo.getTitle() : ftinfo.getName());
        }
        if (rinfo != null && ftinfo.getDescription() == null) {
            ftinfo.setDescription(rinfo.getDescription());
        }
        if (rinfo != null && (ftinfo.getKeywords() == null || ftinfo.getKeywords().isEmpty())) {
            if (rinfo.getKeywords() != null) {
                if (ftinfo.getKeywords() == null) {
                    ((FeatureTypeInfoImpl)ftinfo).setKeywords(new ArrayList());
                }
                for (String kw : rinfo.getKeywords()) {
                    if (kw == null || "".equals(kw.trim())) {
                        LOGGER.fine("Empty keyword ignored");
                        continue;
                    }
                    ftinfo.getKeywords().add(new Keyword(kw));
                }
            }
        }
    }


    public ReferencedEnvelope getLatLonBounds(ReferencedEnvelope nativeBounds,
            CoordinateReferenceSystem declaredCRS) throws IOException {
        if (nativeBounds != null && declaredCRS != null) {

            if (!CRS.equalsIgnoreMetadata(DefaultGeographicCRS.WGS84, declaredCRS)) {

                try {
                    ReferencedEnvelope bounds = new ReferencedEnvelope(nativeBounds, declaredCRS);
                    return bounds.transform(DefaultGeographicCRS.WGS84, true);
                } catch (Exception e) {
                    throw (IOException) new IOException("transform error").initCause(e);
                }
            } else {
                return new ReferencedEnvelope(nativeBounds, DefaultGeographicCRS.WGS84);
            }
        }
        return null;
    }


    public ReferencedEnvelope getNativeBounds(ResourceInfo rinfo) throws IOException {
        return getNativeBounds(rinfo, null);
    }


    ReferencedEnvelope getNativeBounds(ResourceInfo rinfo, Object data) throws IOException {
        ReferencedEnvelope bounds = null;
        if (rinfo instanceof FeatureTypeInfo) {
            FeatureTypeInfo ftinfo = (FeatureTypeInfo) rinfo;


            if (data instanceof FeatureSource) {
                bounds = ((FeatureSource)data).getBounds();
            }
            else {
                bounds = ftinfo.getFeatureSource(null, null).getBounds();
            }



            CoordinateReferenceSystem crs = ftinfo.getNativeCRS();
            if (bounds != null && bounds.getCoordinateReferenceSystem() == null && crs != null) {
                bounds = new ReferencedEnvelope(bounds, crs);
            }

            if (bounds != null) {

                double expandBy = 1; 
                if (bounds.getCoordinateReferenceSystem() instanceof GeographicCRS) {
                    expandBy = 0.0001;
                }
                if (bounds.getWidth() == 0 || bounds.getHeight() == 0) {
                    bounds.expandBy(expandBy);
                }
            }

        } else if (rinfo instanceof CoverageInfo) {


            CoverageInfo cinfo = (CoverageInfo) rinfo;            
            GridCoverage2DReader reader = null;
            if (data instanceof GridCoverage2DReader) {
                reader = (GridCoverage2DReader) data;
            }
            else {
                reader = (GridCoverage2DReader) 
                    cinfo.getGridCoverageReader(null, GeoTools.getDefaultHints());
            }


            bounds = new ReferencedEnvelope(reader.getOriginalEnvelope());
           
        } else if(rinfo instanceof WMSLayerInfo) {


            WMSLayerInfo rebuilt = buildWMSLayer(rinfo.getStore(), rinfo.getNativeName());
            bounds = rebuilt.getNativeBoundingBox();
        }


        if (rinfo.getProjectionPolicy() == ProjectionPolicy.REPROJECT_TO_DECLARED && bounds != null) {
            try {
                bounds = bounds.transform(rinfo.getCRS(), true);
            } catch (Exception e) {
                throw (IOException) new IOException("transform error").initCause(e);
            }
        }

        return bounds;
    }


    public void lookupSRS(FeatureTypeInfo ftinfo, boolean extensive) throws IOException {
        lookupSRS(ftinfo, null, extensive);
    }


    public void lookupSRS(FeatureTypeInfo ftinfo, FeatureSource data, boolean extensive) 
            throws IOException {
        CoordinateReferenceSystem crs = ftinfo.getNativeCRS();
        if (crs == null) {
            if (data != null) {
                crs = data.getSchema().getCoordinateReferenceSystem();
            }
            else {
                crs = ftinfo.getFeatureType().getCoordinateReferenceSystem();
            }
        }
        if (crs != null) {
            try {
                Integer code = CRS.lookupEpsgCode(crs, extensive);
                if (code != null)
                    ftinfo.setSRS("EPSG:" + code);
            } catch (FactoryException e) {
                throw (IOException) new IOException().initCause(e);
            }
        }
    }


    private void initResourceInfo(ResourceInfo resInfo) throws Exception {

    	if (resInfo.getNativeName() == null && resInfo.getName() != null) {
    		resInfo.setNativeName(resInfo.getName());
    	}
    	if (resInfo.getNativeName() != null && resInfo.getName() == null) {
    		resInfo.setName(resInfo.getNativeName());
    	}
    }


    public void initFeatureType(FeatureTypeInfo featureType) throws Exception {
        if (featureType.getCatalog() == null) {
            featureType.setCatalog(catalog);
        }

        initResourceInfo(featureType);


        if (featureType.getSRS() == null) {
            lookupSRS(featureType, true);
        }
        if (featureType.getProjectionPolicy() == null) {
            setupProjectionPolicy(featureType);
        }


        CoordinateReferenceSystem crs = featureType.getCRS();
        if (featureType.getLatLonBoundingBox() == null
                && featureType.getNativeBoundingBox() == null) {

            setupBounds(featureType);
        } else if (featureType.getLatLonBoundingBox() == null) {

            setupBounds(featureType);
        } else if (featureType.getNativeBoundingBox() == null && crs != null) {

            ReferencedEnvelope boundsLatLon = featureType.getLatLonBoundingBox();
            featureType.setNativeBoundingBox(boundsLatLon.transform(crs, true));
        }
    }


    public void initWMSLayer(WMSLayerInfo wmsLayer) throws Exception {
        wmsLayer.setCatalog(catalog);

        initResourceInfo(wmsLayer);
        OwsUtils.resolveCollections(wmsLayer);


        WMSLayerInfo full = buildWMSLayer(store, wmsLayer.getNativeName());


        if (wmsLayer.getSRS() == null) {
            wmsLayer.setSRS(full.getSRS());
        }
        if (wmsLayer.getNativeCRS() == null) {
            wmsLayer.setNativeCRS(full.getNativeCRS());
        }
        if (wmsLayer.getProjectionPolicy() == null) {
            wmsLayer.setProjectionPolicy(full.getProjectionPolicy());
        }


        if (wmsLayer.getLatLonBoundingBox() == null
                && wmsLayer.getNativeBoundingBox() == null) {

            wmsLayer.setLatLonBoundingBox(full.getLatLonBoundingBox());
            wmsLayer.setNativeBoundingBox(full.getNativeBoundingBox());
        } else if (wmsLayer.getLatLonBoundingBox() == null) {

            setupBounds(wmsLayer);
        } else if (wmsLayer.getNativeBoundingBox() == null && wmsLayer.getNativeCRS() != null) {

            ReferencedEnvelope boundsLatLon = wmsLayer.getLatLonBoundingBox();
            wmsLayer.setNativeBoundingBox(boundsLatLon.transform(wmsLayer.getNativeCRS(), true));
        }


        if (wmsLayer.getTitle() == null) {
            wmsLayer.setTitle(full.getTitle());
        }
        if (wmsLayer.getDescription() == null) {
            wmsLayer.setDescription(full.getDescription());
        }
        if (wmsLayer.getAbstract() == null) {
            wmsLayer.setAbstract(full.getAbstract());
        }
        if (wmsLayer.getKeywords().isEmpty()) {
            wmsLayer.getKeywords().addAll(full.getKeywords());
        }
    }


    public void initCoverage(CoverageInfo cinfo) throws Exception {
        initCoverage(cinfo, null);
    }
    

    public void initCoverage(CoverageInfo cinfo, final String coverageName) throws Exception {
    	CoverageStoreInfo csinfo = (CoverageStoreInfo) store;
        GridCoverage2DReader reader = (GridCoverage2DReader) catalog
            	.getResourcePool().getGridCoverageReader(cinfo, GeoTools.getDefaultHints());
        if(coverageName != null) {
            reader = SingleGridCoverage2DReader.wrap(reader, coverageName);
        }
        
        initResourceInfo(cinfo);

        if (reader == null)
            throw new Exception("Unable to acquire a reader for this coverage with format: "
                    + csinfo.getFormat().getName());

        if (cinfo.getNativeCRS() == null) {
        	cinfo.setNativeCRS(reader.getCoordinateReferenceSystem());
        }

        CoordinateReferenceSystem nativeCRS = cinfo.getNativeCRS();

        if (cinfo.getSRS() == null) {
        	cinfo.setSRS(nativeCRS.getIdentifiers().toArray()[0].toString());
        }

        if (cinfo.getProjectionPolicy() == null) {
            if (nativeCRS != null && !nativeCRS.getIdentifiers().isEmpty()) {
                cinfo.setProjectionPolicy(ProjectionPolicy.REPROJECT_TO_DECLARED);
            }
            if (nativeCRS == null) {
                cinfo.setProjectionPolicy(ProjectionPolicy.FORCE_DECLARED);
            }
        }

    	if (cinfo.getLatLonBoundingBox() == null
    			&& cinfo.getNativeBoundingBox() == null) {
    		GeneralEnvelope envelope = reader.getOriginalEnvelope();

    		cinfo.setNativeBoundingBox(new ReferencedEnvelope(envelope));
    		cinfo.setLatLonBoundingBox(new ReferencedEnvelope(CoverageStoreUtils.getWGS84LonLatEnvelope(envelope)));
    	} else if (cinfo.getLatLonBoundingBox() == null) {
    		setupBounds(cinfo);
    	} else if (cinfo.getNativeBoundingBox() == null && cinfo.getNativeCRS() != null) {
    		ReferencedEnvelope boundsLatLon = cinfo.getLatLonBoundingBox();
    		cinfo.setNativeBoundingBox(boundsLatLon.transform(cinfo.getNativeCRS(), true));
    	}

        if (cinfo.getGrid() == null) {
            GridEnvelope originalRange = reader.getOriginalGridRange();
            cinfo.setGrid(new GridGeometry2D(originalRange, reader.getOriginalGridToWorld(PixelInCell.CELL_CENTER), nativeCRS));
        }
    }
    

    public CoverageInfo buildCoverage() throws Exception {
        return buildCoverage(null);
    }


    public CoverageInfo buildCoverage(String coverageName) throws Exception {
        if (store == null || !(store instanceof CoverageStoreInfo)) {
            throw new IllegalStateException("Coverage store not set.");
        }

        CoverageStoreInfo csinfo = (CoverageStoreInfo) store;
        GridCoverage2DReader reader = (GridCoverage2DReader) catalog
                .getResourcePool().getGridCoverageReader(csinfo, GeoTools.getDefaultHints());

        if (reader == null)
            throw new Exception("Unable to acquire a reader for this coverage with format: "
                    + csinfo.getFormat().getName());

        return buildCoverage(reader, coverageName, null);
    }


    public CoverageInfo buildCoverage(GridCoverage2DReader reader, Map customParameters) throws Exception {
        return buildCoverage(reader, null, customParameters);
    }
    

    public CoverageInfo buildCoverage(GridCoverage2DReader reader, String coverageName, Map customParameters) throws Exception {
        if (store == null || !(store instanceof CoverageStoreInfo)) {
            throw new IllegalStateException("Coverage store not set.");
        }
        

        if (coverageName != null) {
            reader = SingleGridCoverage2DReader.wrap(reader, coverageName);
        }

        CoverageStoreInfo csinfo = (CoverageStoreInfo) store;
        CoverageInfo cinfo = catalog.getFactory().createCoverage();

        cinfo.setStore(csinfo);
        cinfo.setEnabled(true);

        WorkspaceInfo workspace = store.getWorkspace();
        NamespaceInfo namespace = catalog.getNamespaceByPrefix(workspace.getName());
        if (namespace == null) {
            namespace = catalog.getDefaultNamespace();
        }
        cinfo.setNamespace(namespace);

        GeneralEnvelope envelope = reader.getOriginalEnvelope();
        CoordinateReferenceSystem nativeCRS = envelope.getCoordinateReferenceSystem();
        cinfo.setNativeCRS(nativeCRS);




        if (nativeCRS != null && !nativeCRS.getIdentifiers().isEmpty()) {
            cinfo.setSRS(nativeCRS.getIdentifiers().toArray()[0].toString());
            cinfo.setProjectionPolicy(ProjectionPolicy.REPROJECT_TO_DECLARED);
        }
        if (nativeCRS == null) {
            cinfo.setProjectionPolicy(ProjectionPolicy.FORCE_DECLARED);
        }

        
        cinfo.setNativeBoundingBox(new ReferencedEnvelope(envelope));
        cinfo.setLatLonBoundingBox(new ReferencedEnvelope(CoverageStoreUtils.getWGS84LonLatEnvelope(envelope)));

        GridEnvelope originalRange = reader.getOriginalGridRange();
        cinfo.setGrid(new GridGeometry2D(originalRange, reader.getOriginalGridToWorld(PixelInCell.CELL_CENTER), nativeCRS));












        Format format = csinfo.getFormat();
        final GridCoverage2D gc;

        final ParameterValueGroup readParams = format.getReadParameters();
        final Map parameters = CoverageUtils.getParametersKVP(readParams);
        final int minX = originalRange.getLow(0);
        final int minY = originalRange.getLow(1);
        final int width = originalRange.getSpan(0);
        final int height = originalRange.getSpan(1);
        final int maxX = minX + (width <= 5 ? width : 5);
        final int maxY = minY + (height <= 5 ? height : 5);


        final GridEnvelope2D testRange = new GridEnvelope2D(minX, minY, maxX, maxY);


        final MathTransform gridToWorldCorner = reader.getOriginalGridToWorld(PixelInCell.CELL_CORNER);
        final GeneralEnvelope testEnvelope = CRS.transform(gridToWorldCorner, new GeneralEnvelope(testRange.getBounds()));
        testEnvelope.setCoordinateReferenceSystem(nativeCRS);

        if (customParameters != null) {
        	parameters.putAll(customParameters);
        }



        String maxAllowedTiles = ImageMosaicFormat.MAX_ALLOWED_TILES.getName().toString();
        if (parameters.keySet().contains(maxAllowedTiles)) {
            parameters.put(maxAllowedTiles, 1);
        }



        String useJaiImageRead = ImageMosaicFormat.USE_JAI_IMAGEREAD.getName().toString();
        if (parameters.keySet().contains(useJaiImageRead)) {
            parameters.put(useJaiImageRead, false);
        }

        parameters.put(AbstractGridFormat.READ_GRIDGEOMETRY2D.getName().toString(), new GridGeometry2D(testRange, testEnvelope));


        gc = (GridCoverage2D) reader.read(CoverageUtils.getParameters(readParams, parameters, true));
        if (gc == null) {
            throw new Exception("Unable to acquire test coverage for format:" + format.getName());
        }


        parameters.remove(AbstractGridFormat.READ_GRIDGEOMETRY2D.getName().toString());

        cinfo.getDimensions().addAll(getCoverageDimensions(gc.getSampleDimensions()));
        String name = gc.getName().toString();
        cinfo.setName(name);
        cinfo.setNativeCoverageName(coverageName);
        cinfo.setTitle(name);
        cinfo.setDescription(new StringBuilder("Generated from ").append(format.getName()).toString());


        cinfo.getKeywords().add(new Keyword("WCS"));
        cinfo.getKeywords().add(new Keyword(format.getName()));
        cinfo.getKeywords().add(new Keyword(name));


        cinfo.setNativeFormat(format.getName());
        cinfo.getMetadata().put("dirName", new StringBuilder(store.getName()).append("_").append(name).toString());


        if ((gc.getCoordinateReferenceSystem2D().getIdentifiers() != null)
                && !gc.getCoordinateReferenceSystem2D().getIdentifiers().isEmpty()) {
            cinfo.getRequestSRS().add(((Identifier) gc.getCoordinateReferenceSystem2D().getIdentifiers().toArray()[0]).toString());
        }


        if ((gc.getCoordinateReferenceSystem2D().getIdentifiers() != null)
                && !gc.getCoordinateReferenceSystem2D().getIdentifiers().isEmpty()) {
            cinfo.getResponseSRS().add(((Identifier) gc.getCoordinateReferenceSystem2D().getIdentifiers().toArray()[0]).toString());
        }


        final List formats = CoverageStoreUtils.listDataFormats();
        for (Iterator i = formats.iterator(); i.hasNext();) {
            final Format fTmp = (Format) i.next();
            final String fName = fTmp.getName();

            if (fName.equalsIgnoreCase("WorldImage")) {

                cinfo.getSupportedFormats().add("GIF");
                cinfo.getSupportedFormats().add("PNG");
                cinfo.getSupportedFormats().add("JPEG");
                cinfo.getSupportedFormats().add("TIFF");
            } else if (fName.toLowerCase().startsWith("geotiff")) {

                cinfo.getSupportedFormats().add("GEOTIFF");
            } else {

                cinfo.getSupportedFormats().add(fName);
            }
        }


        cinfo.setDefaultInterpolationMethod("nearest neighbor");
        cinfo.getInterpolationMethods().add("nearest neighbor");
        cinfo.getInterpolationMethods().add("bilinear");
        cinfo.getInterpolationMethods().add("bicubic");



        cinfo.getParameters().putAll(CoverageUtils.getParametersKVP(readParams));


        gc.dispose(true);
        if(gc.getRenderedImage() instanceof PlanarImage) {
            ImageUtilities.disposePlanarImageChain((PlanarImage) gc.getRenderedImage());
        }

        return cinfo;
    }

    List<CoverageDimensionInfo> getCoverageDimensions(GridSampleDimension[] sampleDimensions) {

        final int length = sampleDimensions.length;
        List<CoverageDimensionInfo> dims = new ArrayList<CoverageDimensionInfo>();

        for (int i = 0; i < length; i++) {
            CoverageDimensionInfo dim = catalog.getFactory().createCoverageDimension();
            GridSampleDimension sd = sampleDimensions[i];
            String name = sd.getDescription().toString(Locale.getDefault());
            dim.setName(name);

            StringBuilder label = new StringBuilder("GridSampleDimension".intern());
            final Unit uom = sd.getUnits();

            String uName = name.toUpperCase();
            if (uom != null) {
                label.append("(".intern());
                parseUOM(label, uom);
                label.append(")".intern());
                dim.setUnit(uom.toString());
            } else if(uName.startsWith("RED") || uName.startsWith("GREEN") || uName.startsWith("BLUE")) {

                dim.setUnit("W.m-2.Sr-1");
            }
            
            dim.setDimensionType(sd.getSampleDimensionType());

            label.append("[".intern());
            label.append(sd.getMinimumValue());
            label.append(",".intern());
            label.append(sd.getMaximumValue());
            label.append("]".intern());

            dim.setDescription(label.toString());

            if (sd.getRange() != null) {
                dim.setRange(sd.getRange());    
            }
            else {
                dim.setRange(NumberRange.create(sd.getMinimumValue(), sd.getMaximumValue()));
            }
            
            final List<Category> categories = sd.getCategories();
            if (categories != null) {
                for (Category cat : categories) {

                    if ((cat != null) && cat.getName().toString().equalsIgnoreCase("no data")) {
                        double min = cat.getRange().getMinimum();
                        double max = cat.getRange().getMaximum();

                        dim.getNullValues().add(min);
                        if (min != max) {
                            dim.getNullValues().add(max);
                        }
                    }
                }
            }
            
            dims.add(dim);
        }

        return dims;
    }
    
    public WMSLayerInfo buildWMSLayer(String layerName) throws IOException {
        return buildWMSLayer(this.store, layerName);
    }

    WMSLayerInfo buildWMSLayer(StoreInfo store, String layerName) throws IOException {
        if (store == null || !(store instanceof WMSStoreInfo)) {
            throw new IllegalStateException("WMS store not set.");
        }

        WMSLayerInfo wli = catalog.getFactory().createWMSLayer();

        wli.setName(layerName);
        wli.setNativeName(layerName);

        wli.setStore(store);
        wli.setEnabled(true);

        WorkspaceInfo workspace = store.getWorkspace();
        NamespaceInfo namespace = catalog.getNamespaceByPrefix(workspace.getName());
        if (namespace == null) {
            namespace = catalog.getDefaultNamespace();
        }
        wli.setNamespace(namespace);

        Layer layer = wli.getWMSLayer(null);



        for (String srs : layer.getBoundingBoxes().keySet()) {
            try {
                CoordinateReferenceSystem crs = CRS.decode(srs);
                wli.setSRS(srs);
                wli.setNativeCRS(crs);
            } catch (Exception e) {
                LOGGER.log(Level.INFO, "Skipping " + srs
                        + " definition, it was not recognized by the referencing subsystem");
            }
        }
        

        String srs = wli.getSRS();
        try {
            if (srs == null || srs.equals("CRS:84")) {
                wli.setSRS("EPSG:4326");
                srs = "EPSG:4326";
                wli.setNativeCRS(CRS.decode("EPSG:4326"));
            } else if(srs.equals("CRS:83")) {
                wli.setSRS("EPSG:4269");
                srs = "EPSG:4269";
                wli.setNativeCRS(CRS.decode("EPSG:4269"));
            } else if(srs.equals("CRS:27")) {
                wli.setSRS("EPSG:4267");
                srs = "EPSG:4267";
                wli.setNativeCRS(CRS.decode("EPSG:4267"));
            }
        } catch(Exception e) {
            throw (IOException) new IOException("Failed to compute the layer declared SRS code").initCause(e);
        }
        wli.setProjectionPolicy(ProjectionPolicy.FORCE_DECLARED);


        GeneralEnvelope envelope = layer.getEnvelope(wli.getNativeCRS());
        if (envelope != null) {
            ReferencedEnvelope re = new ReferencedEnvelope(envelope.getMinimum(0), envelope
                    .getMaximum(0), envelope.getMinimum(1), envelope.getMaximum(1), wli
                    .getNativeCRS());
            wli.setNativeBoundingBox(re);
        }
        CRSEnvelope llbbox = layer.getLatLonBoundingBox();
        if (llbbox != null) {
            ReferencedEnvelope re = new ReferencedEnvelope(llbbox.getMinX(), llbbox.getMaxX(),
                    llbbox.getMinY(), llbbox.getMaxY(), DefaultGeographicCRS.WGS84);
            wli.setLatLonBoundingBox(re);
        } else if (wli.getNativeBoundingBox() != null) {
            try {
                wli.setLatLonBoundingBox(wli.getNativeBoundingBox().transform(
                        DefaultGeographicCRS.WGS84, true));
            } catch (Exception e) {
                LOGGER.log(Level.INFO, "Could not transform native bbox into a lat/lon one", e);
            }
        }


        wli.setAbstract(layer.get_abstract());
        wli.setDescription(layer.get_abstract());
        wli.setTitle(layer.getTitle());
        if (layer.getKeywords() != null) {
            for (String kw : layer.getKeywords()) {
                if(kw != null){
                    wli.getKeywords().add(new Keyword(kw));
                }
            }
        }


        String published = wli.getName();
        if (published.contains(":")) {
            wli.setName(published.substring(published.lastIndexOf(':') + 1));
        }

        return wli;
    }
    
    private boolean axisFlipped(Version version, String srsName) {
        if(version.compareTo(new Version("1.3.0")) < 0) {

            return false;
        } else {

            if(srsName.startsWith("EPSG:")) {
                try {
                    String epsgNative =  "urn:x-ogc:def:crs:EPSG:".concat(srsName.substring(5));
                    return CRS.getAxisOrder(CRS.decode(epsgNative)) == AxisOrder.NORTH_EAST;
                } catch(Exception e) {
                    LOGGER.log(Level.WARNING, "Failed to determine axis order for " 
                            + srsName + ", assuming east/north", e);
                    return false;
                }
            } else {

                return false;
            }
        }
    }

    void parseUOM(StringBuilder label, Unit uom) {
        String uomString = uom.toString();
        uomString = uomString.replaceAll("\u00B2", "^2");
        uomString = uomString.replaceAll("\u00B3", "^3");
        uomString = uomString.replaceAll("\u212B", "A");
        uomString = uomString.replaceAll("ï¿½", "");
        label.append(uomString);
    }


    public LayerInfo buildLayer(FeatureTypeInfo featureType) throws IOException {

        LayerInfo layer = buildLayer((ResourceInfo) featureType);

        StyleInfo style = getDefaultStyle(featureType);
        layer.setDefaultStyle(style);

        return layer;
    }


    public LayerInfo buildLayer(CoverageInfo coverage) throws IOException {
        LayerInfo layer = buildLayer((ResourceInfo) coverage);

        layer.setDefaultStyle(getDefaultStyle(coverage));

        return layer;
    }


    public LayerInfo buildLayer(WMSLayerInfo wms) throws IOException {
        LayerInfo layer = buildLayer((ResourceInfo) wms);
        
        layer.setDefaultStyle(getDefaultStyle(wms));
        
        return layer;
    }


    public StyleInfo getDefaultStyle(ResourceInfo resource) throws IOException {

        if (resource instanceof CoverageInfo || resource instanceof WMSLayerInfo)
            return catalog.getStyleByName(StyleInfo.DEFAULT_RASTER);


        String styleName;
        FeatureTypeInfo featureType = (FeatureTypeInfo) resource;
        if (featureType.getFeatureType() == null) {
            return null;
        }
        GeometryDescriptor gd = featureType.getFeatureType().getGeometryDescriptor();
        if (gd == null) {
            return null;
        }

        Class gtype = gd.getType().getBinding();
        if (Point.class.isAssignableFrom(gtype) || MultiPoint.class.isAssignableFrom(gtype)) {
            styleName = StyleInfo.DEFAULT_POINT;
        } else if (LineString.class.isAssignableFrom(gtype)
                || MultiLineString.class.isAssignableFrom(gtype)) {
            styleName = StyleInfo.DEFAULT_LINE;
        } else if (Polygon.class.isAssignableFrom(gtype)
                || MultiPolygon.class.isAssignableFrom(gtype)) {
            styleName = StyleInfo.DEFAULT_POLYGON;
        } else {

            styleName = StyleInfo.DEFAULT_POINT;
        }

        return catalog.getStyleByName(styleName);
    }

    public LayerInfo buildLayer(ResourceInfo resource) {
        LayerInfo layer = catalog.getFactory().createLayer();
        layer.setResource(resource);
        layer.setName(resource.getName());
        layer.setEnabled(true);


        if (layer.getResource() instanceof FeatureTypeInfo) {
            layer.setType(PublishedType.VECTOR);
        } else if (layer.getResource() instanceof CoverageInfo) {
            layer.setType(PublishedType.RASTER);
        } else if (layer.getResource() instanceof WMSLayerInfo) {
            layer.setType(PublishedType.WMS);
        }

        return layer;
    }


    public void calculateLayerGroupBounds(LayerGroupInfo layerGroup, CoordinateReferenceSystem crs)
            throws Exception {
        LayerGroupHelper helper = new LayerGroupHelper(layerGroup);
        helper.calculateBounds(crs);
    }


    public void calculateLayerGroupBounds(LayerGroupInfo layerGroup) throws Exception {
        LayerGroupHelper helper = new LayerGroupHelper(layerGroup);
        helper.calculateBounds();
    }






    public void removeWorkspace(WorkspaceInfo workspace, boolean recursive) {
        if (recursive) {
            workspace.accept(new CascadeDeleteVisitor(catalog));
        } else {
            catalog.remove(workspace);
        }
    }


    public void removeStore(StoreInfo store, boolean recursive) {
        if (recursive) {
            store.accept(new CascadeDeleteVisitor(catalog));
        } else {
            catalog.remove(store);
        }
    }


    public void removeResource(ResourceInfo resource, boolean recursive) {
        if (recursive) {
            resource.accept(new CascadeDeleteVisitor(catalog));
        } else {
            catalog.remove(resource);
        }
    }


    public void attach(StoreInfo storeInfo) {
        storeInfo = ModificationProxy.unwrap(storeInfo);
        ((StoreInfoImpl) storeInfo).setCatalog(catalog);
    }


    public void attach(ResourceInfo resourceInfo) {
        resourceInfo = ModificationProxy.unwrap(resourceInfo);
        ((ResourceInfoImpl) resourceInfo).setCatalog(catalog);
    }


    public void attach(LayerInfo layerInfo) {
        attach(layerInfo.getResource());
    }


    public void attach(MapInfo mapInfo) {

        for (LayerInfo layer : mapInfo.getLayers()) {
            attach(layer);
        }
    }


    public void attach(LayerGroupInfo groupInfo) {
        if (groupInfo.getRootLayer() != null) {
            attach(groupInfo.getRootLayer());
        }
        
        if (groupInfo.getRootLayerStyle() != null) {
            attach(groupInfo.getRootLayerStyle());            
        }
        
        for (PublishedInfo p : groupInfo.getLayers()) {
            if (p instanceof LayerInfo) {
                attach((LayerInfo) p);
            } else {
                attach((LayerGroupInfo) p);                
            }
        }
        
        for (StyleInfo style : groupInfo.getStyles()) {
            if (style != null)
                attach(style);
        }
    }


    public void attach(StyleInfo styleInfo) {
        styleInfo = ModificationProxy.unwrap(styleInfo);
        ((StyleInfoImpl) styleInfo).setCatalog(catalog);
    }


    public void attach(NamespaceInfo nsInfo) {

    }


    public void attach(WorkspaceInfo wsInfo) {

    }
    

    public List<AttributeTypeInfo> getAttributes(FeatureType ft, FeatureTypeInfo info) {
        List<AttributeTypeInfo> attributes = new ArrayList<AttributeTypeInfo>();
        for (PropertyDescriptor pd : ft.getDescriptors()) {
            AttributeTypeInfo att = catalog.getFactory().createAttribute();
            att.setFeatureType(info);
            att.setName(pd.getName().getLocalPart());
            att.setMinOccurs(pd.getMinOccurs());
            att.setMaxOccurs(pd.getMaxOccurs());
            att.setNillable(pd.isNillable());
            att.setBinding(pd.getType().getBinding());
            int length = FeatureTypes.getFieldLength((AttributeDescriptor) pd);
            if(length > 0) {
                att.setLength(length);
            }
            attributes.add(att);
        }
        
        return attributes;
    }
}

<code block>

package org.geoserver.importer;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.zip.ZipOutputStream;

import org.apache.commons.fileupload.FileItem;
import org.apache.commons.io.FilenameUtils;
import org.geoserver.data.util.IOUtils;
import org.geoserver.importer.job.ProgressMonitor;
import org.geotools.util.logging.Logging;

import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;

public class Directory extends FileData {

    private static final Logger LOGGER = Logging.getLogger(Directory.class);
    
    private static final long serialVersionUID = 1L;


    protected List<FileData> files = new ArrayList<FileData>();


    boolean recursive;
    String name;

    public Directory(File file) {
        this(file, true);
    }

    public Directory(File file, boolean recursive) {
        super(file);
        this.recursive = recursive;
    }

    public static Directory createNew(File parent) throws IOException {
        File directory = File.createTempFile("tmp", "", parent);
        if (!directory.delete() || !directory.mkdir()) throw new IOException("Error creating temp directory at " + directory.getAbsolutePath());
        return new Directory(directory);
    }

    public static Directory createFromArchive(File archive) throws IOException {
        VFSWorker vfs = new VFSWorker();
        if (!vfs.canHandle(archive)) {
            throw new IOException(archive.getPath() + " is not a recognizable  format");
        }

        String basename = FilenameUtils.getBaseName(archive.getName());
        File dir = new File(archive.getParentFile(), basename);
        int i = 0;
        while (dir.exists()) {
            dir = new File(archive.getParentFile(), basename + i++);
        }
        vfs.extractTo(archive, dir);
        return new Directory(dir);
    }

    public File getFile() {
        return file;
    }

    public List<FileData> getFiles() {
        return files;
    }

    public void unpack(File file) throws IOException {

        VFSWorker vfs = new VFSWorker();
        if (vfs.canHandle(file)) {
            LOGGER.fine("unpacking " + file.getAbsolutePath() + " to " + this.file.getAbsolutePath());
            vfs.extractTo(file, this.file);

            LOGGER.fine("deleting " + file.getAbsolutePath());
            if (!file.delete()) {
                throw new IOException("unable to delete file");
            }
        }
    }
    
    public File child(String name) {
        if (name == null) {

            try {
                return File.createTempFile("child", "tmp", file);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }

        return new File(this.file,name);
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String getName() {
        return this.name != null ? this.name : file.getName();
    }

    @Override
    public void prepare(ProgressMonitor m) throws IOException {
        files = new ArrayList<FileData>();


        LinkedList<File> q = new LinkedList<File>();
        q.add(file);

        while(!q.isEmpty()) {
            File dir = q.poll();

            if (m.isCanceled()) {
                return;
            }
            m.setTask("Scanning " + dir.getPath());


            File[] fileList = dir.listFiles(new FilenameFilter() {
                public boolean accept(File dir, String name) {
                    return !new File(dir, name).isDirectory();
                }
            });
            if (fileList == null) {


                continue;
            }
            Set<File> all = new LinkedHashSet<File>(Arrays.asList(fileList));


            for (File f : dir.listFiles()) {
                if (f.isHidden()) {
                    all.remove(f);
                    continue;
                }
                if (f.isDirectory()) {
                    if (!recursive && !f.equals(file)) {

                        continue;
                    }




                    if (!"__MACOSX".equals(f.getName())) {
                        Directory d = new Directory(f);
                        d.prepare(m);

                        files.add(d);
                    }

                    continue;
                }



                if ("aux".equalsIgnoreCase(FilenameUtils.getExtension(f.getName()))) {
                    continue;
                }


                DataFormat format = DataFormat.lookup(f);

                if (format != null) {
                    SpatialFile sf = newSpatialFile(f, format);
                    

                    sf.prepare(m);

                    files.add(sf);

                    all.removeAll(sf.allFiles());
                }
            }


            for (File f : all) {
                files.add(new ASpatialFile(f));
            }
        }

        format = format();





























    }


    protected SpatialFile newSpatialFile(File f, DataFormat format) {
        SpatialFile sf = new SpatialFile(f);
        sf.setFormat(format);
        return sf;
    }

    public List<Directory> flatten() {
        List<Directory> flat = new ArrayList<Directory>();

        LinkedList<Directory> q = new LinkedList<Directory>();
        q.addLast(this);
        while(!q.isEmpty()) {
            Directory dir = q.removeFirst();
            flat.add(dir);

            for (Iterator<FileData> it = dir.getFiles().iterator(); it.hasNext(); ) {
                FileData f = it.next();
                if (f instanceof Directory) {
                    Directory d = (Directory) f;
                    it.remove();
                    q.addLast(d);
                }
            }
        }

        return flat;
    }


























































    public DataFormat format() throws IOException {
        if (files.isEmpty()) {
            LOGGER.warning("no files recognized");
            return null;
        }

        FileData file = files.get(0);
        DataFormat format = file.getFormat();
        for (int i = 1; i < files.size(); i++) {
            FileData other = files.get(i);
            if (format != null && !format.equals(other.getFormat())) {
                logFormatMismatch();
                return null;
            }
            if (format == null && other.getFormat() != null) {
                logFormatMismatch();
                return null;
            }
        }

        return format;
    }

    private void logFormatMismatch() {
        StringBuilder buf = new StringBuilder("all files are not the same format:\n");
        for (int i = 0; i < files.size(); i++) {
            FileData f = files.get(i);
            String format = "not recognized";
            if (f.getFormat() != null) {
                format = f.getName();
            }
            buf.append(f.getFile().getName()).append(" : ").append(format).append('\n');
        }
        LOGGER.warning(buf.toString());
    }

    public Directory filter(List<FileData> files) {
        Filtered f = new Filtered(file, files);
        f.setFormat(getFormat());
        return f;
    }

    @Override
    public String toString() {
        return file.getPath();
    }

    public void accept(String childName, InputStream in) throws IOException {
        File dest = child(childName);
        
        IOUtils.copy(in, dest);

        try {
            unpack(dest);
        } catch (IOException ioe) {

            LOGGER.warning("Possible invalid file uploaded to " + dest.getAbsolutePath());
            throw ioe;
        }
    }

    public void accept(FileItem item) throws Exception {
        File dest = child(item.getName());
        item.write(dest);

        try {
            unpack(dest);
        } 
        catch (IOException e) {

            LOGGER.warning("Possible invalid file uploaded to " + dest.getAbsolutePath());
            throw e;
        }
    }
    
    public void archive(File output) throws IOException {
        File archiveDir = output.getAbsoluteFile().getParentFile();
        String outputName = output.getName().replace(".zip","");
        int id = 0;
        while (output.exists()) {
            output = new File(archiveDir, outputName + id + ".zip");
            id++;
        }
        ZipOutputStream zout = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(output)));
        Exception error = null;



        try {
            IOUtils.zipDirectory(file, zout, null);
        } catch (Exception ex) {
            error = ex;
            try {
                zout.close();
            } catch (Exception ex2) {

            }
            output.delete();
            if (ex instanceof IOException) throw (IOException) ex;
            throw (IOException) new IOException("Error archiving").initCause(ex);
        } 
        

        try {
            zout.close();
        } finally {
            cleanup();
        }
    }

    @Override
    public void cleanup() throws IOException {
        File[] files = file.listFiles();
        if (files != null) {
            for (File f: files) {
                if (f.isDirectory()) {
                    new Directory(f).cleanup();
                } else {
                    if (LOGGER.isLoggable(Level.FINE)) {
                        LOGGER.fine("Deleting file " + f.getAbsolutePath());
                    }
                    if (!f.delete()) {
                        throw new IOException("unable to delete " + f);
                    }
                }
            }
        }
        super.cleanup();
    }

    @Override
    public FileData part(final String name) {
        List<FileData> files = this.files;
        if (this instanceof Filtered) {
            files = ((Filtered)this).filter;
        }

        try {
            return Iterables.find(files, new Predicate<FileData>() {
                @Override
                public boolean apply(FileData input) {
                    return name.equals(input.getName());
                }
            });
        }
        catch(NoSuchElementException e) {
            return null;
        }
    }

    static class Filtered extends Directory {

        List<FileData> filter;

        public Filtered(File file, List<FileData> filter) {
            super(file);
            this.filter = filter;
        }

        @Override
        public void prepare(ProgressMonitor m) throws IOException {
            super.prepare(m);

            files.retainAll(filter);
            format = format();
        }
    }
}

<code block>

package org.geoserver.importer;

import java.io.File;
import java.io.IOException;
import java.sql.Connection;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.TreeSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.geoserver.catalog.Catalog;
import org.geoserver.catalog.CatalogBuilder;
import org.geoserver.catalog.CoverageInfo;
import org.geoserver.catalog.CoverageStoreInfo;
import org.geoserver.catalog.DataStoreInfo;
import org.geoserver.catalog.FeatureTypeInfo;
import org.geoserver.catalog.LayerInfo;
import org.geoserver.catalog.NamespaceInfo;
import org.geoserver.catalog.ProjectionPolicy;
import org.geoserver.catalog.ResourceInfo;
import org.geoserver.catalog.StoreInfo;
import org.geoserver.catalog.StyleInfo;
import org.geoserver.catalog.WorkspaceInfo;
import org.geoserver.config.util.XStreamPersister;
import org.geoserver.config.util.XStreamPersister.CRSConverter;
import org.geoserver.config.util.XStreamPersisterFactory;
import org.geoserver.importer.ImportTask.State;
import org.geoserver.importer.job.Job;
import org.geoserver.importer.job.JobQueue;
import org.geoserver.importer.job.ProgressMonitor;
import org.geoserver.importer.job.Task;
import org.geoserver.importer.mosaic.Mosaic;
import org.geoserver.importer.transform.RasterTransformChain;
import org.geoserver.importer.transform.ReprojectTransform;
import org.geoserver.importer.transform.TransformChain;
import org.geoserver.importer.transform.VectorTransformChain;
import org.geoserver.platform.ContextLoadedEvent;
import org.geoserver.platform.GeoServerExtensions;
import org.geotools.data.DataStore;
import org.geotools.data.DefaultTransaction;
import org.geotools.data.FeatureReader;
import org.geotools.data.FeatureStore;
import org.geotools.data.FeatureWriter;
import org.geotools.data.Transaction;
import org.geotools.data.directory.DirectoryDataStore;
import org.geotools.data.shapefile.ShapefileDataStore;
import org.geotools.feature.simple.SimpleFeatureTypeBuilder;
import org.geotools.geometry.GeneralEnvelope;
import org.geotools.geometry.jts.ReferencedEnvelope;
import org.geotools.jdbc.JDBCDataStore;
import org.geotools.referencing.CRS;
import org.geotools.util.logging.Logging;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.feature.simple.SimpleFeatureType;
import org.opengis.feature.type.FeatureType;
import org.opengis.filter.Filter;
import org.opengis.referencing.crs.CoordinateReferenceSystem;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.context.ApplicationEvent;
import org.springframework.context.ApplicationListener;

import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import com.google.common.collect.Iterators;
import com.thoughtworks.xstream.XStream;
import com.vividsolutions.jts.geom.Geometry;


public class Importer implements DisposableBean, ApplicationListener {

    static Logger LOGGER = Logging.getLogger(Importer.class);


    Catalog catalog;


    ImportStore contextStore;


    StyleGenerator styleGen;


    JobQueue jobs = new JobQueue();
    
    ConcurrentHashMap<Long,ImportTask> currentlyProcessing = new ConcurrentHashMap<Long, ImportTask>();

    public Importer(Catalog catalog) {
        this.catalog = catalog;
        this.styleGen = new StyleGenerator(catalog);
    }


    public StyleGenerator getStyleGenerator() {
        return styleGen;
    }

    ImportStore createContextStore() {

        ImportStore store = null;

        String name = GeoServerExtensions.getProperty("org.geoserver.importer.store");
        if (name == null) {

            name = GeoServerExtensions.getProperty("org.opengeo.importer.store");
        }

        if (name != null) {
            for (ImportStore bean : GeoServerExtensions.extensions(ImportStore.class)) {
                if (name.equals(bean.getName())) {
                    store = bean;
                    break;
                }
            }

            if (store == null) {
                LOGGER.warning("Invalid value for import store, no such store " + name);
            }
        }

        if (store == null) {
            store = new MemoryImportStore();
        }

        LOGGER.info("Enabling import store: " + store.getName());
        return store;
    }

    public ImportStore getStore() {
        return contextStore;
    }

    public ImportTask getCurrentlyProcessingTask(long contextId) {
        return currentlyProcessing.get(new Long(contextId));
    }

    @Override
    public void onApplicationEvent(ApplicationEvent event) {

        if (event instanceof ContextLoadedEvent) {
            contextStore = createContextStore();
            contextStore.init();
        }
    }

    public Catalog getCatalog() {
        return catalog;
    }

    public ImportContext getContext(long id) {
        ImportContext context = contextStore.get(id);
        return context != null ? reattach(context) : null;
    }

    public ImportContext reattach(ImportContext context) {


        context.reattach(catalog);
        for (ImportTask task : context.getTasks()) {
            StoreInfo store = task.getStore();
            if (store != null && store.getId() != null) {
                task.setStore(catalog.getStore(store.getId(), StoreInfo.class));

            }
            if (task.getLayer() != null) {
                LayerInfo l = task.getLayer();
                if (l.getDefaultStyle() != null && l.getDefaultStyle().getId() != null) {
                    l.setDefaultStyle(catalog.getStyle(l.getDefaultStyle().getId()));
                }
                if (l.getResource() != null) {
                    ResourceInfo r = l.getResource();
                    r.setCatalog(catalog);

                    if (r.getStore() == null && resourceMatchesStore(r, store)) {
                        r.setStore(store);
                    }

                }
            }

        }
        return context;
    }


    public Iterator<ImportContext> getContexts() {
        return contextStore.allNonCompleteImports();
    }

    public Iterator<ImportContext> getContextsByUser(String user) {
        return contextStore.importsByUser(user);
    }
    
    public Iterator<ImportContext> getAllContexts() {
        return contextStore.iterator();
    }
    
    public Iterator<ImportContext> getAllContextsByUpdated() {
        try {
            return contextStore.iterator("updated");
        }
        catch(UnsupportedOperationException e) {

            TreeSet sorted = new TreeSet<ImportContext>(new Comparator<ImportContext>() {
                @Override
                public int compare(ImportContext o1, ImportContext o2) {
                    Date d1 = o1.getUpdated();
                    Date d2 = o2.getUpdated();
                    return -1 * d1.compareTo(d2);
                }
            });
            Iterators.addAll(sorted, contextStore.iterator());
            return sorted.iterator();
        }
    }

    public ImportContext createContext(ImportData data, WorkspaceInfo targetWorkspace) throws IOException {
        return createContext(data, targetWorkspace, null);
    }

    public ImportContext createContext(ImportData data, StoreInfo targetStore) throws IOException {
        return createContext(data, null, targetStore); 
    }

    public ImportContext createContext(ImportData data) throws IOException {
        return createContext(data, null, null); 
    }
    

    public ImportContext createContext(Long id) throws IOException, IllegalArgumentException {
        ImportContext context = new ImportContext();
        if (id != null) {
            Long retval = contextStore.advanceId(id);
            assert retval >= id;
            context.setId(retval);
            contextStore.save(context);
        } else {
            contextStore.add(context);
        }
        return context;
    }
    
    public ImportContext createContext(ImportData data, WorkspaceInfo targetWorkspace, 
        StoreInfo targetStore) throws IOException {
        return createContext(data, targetWorkspace, targetStore, null);
    }

    public ImportContext createContext(ImportData data, WorkspaceInfo targetWorkspace, 
            StoreInfo targetStore, ProgressMonitor monitor) throws IOException {

        ImportContext context = new ImportContext();
        context.setProgress(monitor);
        context.setData(data);

        if (targetWorkspace == null && targetStore != null) {
            targetWorkspace = targetStore.getWorkspace();
        }
        if (targetWorkspace == null) {
            targetWorkspace = catalog.getDefaultWorkspace();
        }
        context.setTargetWorkspace(targetWorkspace);
        context.setTargetStore(targetStore);

        init(context);
        if (!context.progress().isCanceled()) {
            contextStore.add(context);
        }




        return context;
    }

    public Long createContextAsync(final ImportData data, final WorkspaceInfo targetWorkspace, 
        final StoreInfo targetStore) throws IOException {
        return jobs.submit(new Job<ImportContext>() {
            @Override
            protected ImportContext call(ProgressMonitor monitor) throws Exception {
                return createContext(data, targetWorkspace, targetStore, monitor);
            }

            @Override
            public String toString() {
                return "Processing data " + data.toString();
            }
        });
    }

    public void init(ImportContext context) throws IOException {
        init(context, true);
    }
    
    public void init(ImportContext context, boolean prepData) throws IOException {
        context.reattach(catalog);

        ImportData data = context.getData();
        if (data != null) {
            addTasks(context, data, prepData); 
        }
    }

    public List<ImportTask> update(ImportContext context, ImportData data) throws IOException {
        List<ImportTask> tasks = addTasks(context, data, true);
        

        changed(context);

        return tasks;
    }

    List<ImportTask> addTasks(ImportContext context, ImportData data, boolean prepData) throws IOException {
        if (data == null) {
            return Collections.emptyList();
        }

        if (prepData) {
            data.prepare(context.progress());
        }

        if (data instanceof FileData) {
            if (data instanceof Mosaic) {
                return initForMosaic(context, (Mosaic)data);
            }
            else if (data instanceof Directory) {
                return initForDirectory(context, (Directory)data);
            }
            else {
                return initForFile(context, (FileData)data);
            }
        }
        else if (data instanceof Table) {
        }
        else if (data instanceof Database) {
            return initForDatabase(context, (Database)data);
        }

        throw new IllegalStateException();

    }


    List<ImportTask> initForMosaic(ImportContext context, Mosaic mosaic) throws IOException {

        if (context.getTargetStore() != null) {
            throw new IllegalArgumentException("ingest not supported for mosaics");
        }

        return createTasks(mosaic, context);

    }

    List<ImportTask> initForDirectory(ImportContext context, Directory data) throws IOException {
        List<ImportTask> tasks = new ArrayList<ImportTask>();


        for (Directory dir : data.flatten()) {

            if (dir.getFiles().isEmpty()) continue;


            Map<DataFormat,List<FileData>> map = new HashMap<DataFormat,List<FileData>>();
            for (FileData f : dir.getFiles()) {
                DataFormat format = f.getFormat();
                List<FileData> files = map.get(format);
                if (files == null) {
                    files = new ArrayList<FileData>();
                    map.put(format, files);
                }
                files.add(f);
            }
    


            boolean skipNoFormat = !(map.size() == 1 && map.containsKey(null));
            


            StoreInfo targetStore = context.getTargetStore();
            if (targetStore == null) {
    

                for (DataFormat format: new ArrayList<DataFormat>(map.keySet())) {
                    if (format != null && format.canRead(dir)) {
                        List<FileData> files = map.get(format);
                        if (files.size() == 1) {


                            tasks.addAll(createTasks(files.get(0), format, context));
                        }
                        else {
                            tasks.addAll(createTasks(dir.filter(files), format, context));

                        }
                        
                        map.remove(format);
                    }
                }
    

                for (List<FileData> files : map.values()) {
                    for (FileData file : files) {

                        tasks.addAll(createTasks(file, file.getFormat(), context, skipNoFormat));
                    }
                }

            }
            else {
                for (FileData file : dir.getFiles()) {
                    tasks.addAll(createTasks(file, file.getFormat(), context, skipNoFormat));
                }
            }
        }

        return tasks;
    }

    List<ImportTask>  initForFile(ImportContext context, FileData file) throws IOException {
        return createTasks(file, context);
    }

    List<ImportTask>  initForDatabase(ImportContext context, Database db) throws IOException {





        return createTasks(db, context);
    }
    
    List<ImportTask> createTasks(ImportData data, ImportContext context) throws IOException {
        return createTasks(data, data.getFormat(), context);
    }
    

    List<ImportTask> createTasks(ImportData data, DataFormat format, ImportContext context) 
        throws IOException {
        return createTasks(data, format, context, true);
    }

    List<ImportTask> createTasks(ImportData data, DataFormat format, ImportContext context, 
        boolean skipNoFormat) throws IOException {

        List<ImportTask> tasks = new ArrayList<ImportTask>();

        boolean direct = false;

        StoreInfo targetStore = context.getTargetStore();
        if (targetStore == null) {

            direct = true;

            if (format != null) {
                targetStore = format.createStore(data, context.getTargetWorkspace(), catalog);    
            }
            
            if (targetStore == null) {


                targetStore = lookupDefaultStore();

                direct = targetStore == null;
            }
        }

        if (format != null) {


            for (ImportTask t : format.list(data, catalog, context.progress())) {

                t.setTransform(format instanceof VectorFormat 
                        ? new VectorTransformChain() : new RasterTransformChain());
                t.setDirect(direct);
                t.setStore(targetStore);

                prep(t);
                tasks.add(t);
            }
        }
        else if (!skipNoFormat) {
            ImportTask t = new ImportTask(data);
            t.setDirect(direct);
            t.setStore(targetStore);
            prep(t);
            tasks.add(t);
        }

        for (ImportTask t : tasks) {
            context.addTask(t);
        }
        return tasks;
    }

    boolean prep(ImportTask task) {
        if (task.getState() == ImportTask.State.COMPLETE) {
            return true;
        }


        DataFormat format = task.getData().getFormat();
        if (format == null) {
            task.setState(State.NO_FORMAT);
            return false;
        }

        

        if (task.getStore() == null) {
            task.setError(new Exception("No target store for task"));
            task.setState(State.ERROR);
            return false;
        }


        if (!formatMatchesStore(format, task.getStore())) {
            String msg = task.getStore() instanceof DataStoreInfo ? 
                    "Unable to import raster data into vector store" : 
                    "Unable to import vector data into raster store";

            task.setError(new Exception(msg));
            task.setState(State.BAD_FORMAT);
            return false;
        }

        if (task.getLayer() == null || task.getLayer().getResource() == null) {
            task.setError(new Exception("Task has no layer configuration"));
            task.setState(State.ERROR);
            return false;
        }

        LayerInfo l = task.getLayer();
        ResourceInfo r = l.getResource();
        

        r.setStore(task.getStore());
        r.setNamespace(
            catalog.getNamespaceByPrefix(task.getStore().getWorkspace().getName()));



        if (l.getDefaultStyle() == null) {
            try {
                StyleInfo style = null;
                if (r instanceof FeatureTypeInfo) {



                    FeatureType featureType =
                        (FeatureType) task.getMetadata().get(FeatureType.class);
                    if (featureType != null) {
                        style = styleGen.createStyle((FeatureTypeInfo) r, featureType);
                    } else {
                        throw new RuntimeException("Unable to compute style");
                    }

                }
                else if (r instanceof CoverageInfo) {
                    style = styleGen.createStyle((CoverageInfo) r);
                }
                else {
                    throw new RuntimeException("Unknown resource type :"
                            + r.getClass());
                }
                l.setDefaultStyle(style);
            }
            catch(Exception e) {
                task.setError(e);
                task.setState(ImportTask.State.ERROR);
                return false;
            }
        }
        

        if (r.getSRS() == null) {
            task.setState(ImportTask.State.NO_CRS);
            return false;
        }
        else if (task.getState() == ImportTask.State.NO_CRS) {

            try {
                computeLatLonBoundingBox(task, false);
            }
            catch(Exception e) {
                LOGGER.log(Level.WARNING, "Error computing lat long bounding box", e);
                task.setState(ImportTask.State.ERROR);
                task.setError(e);
                return false;
            }


            task.getLayer().getResource().setProjectionPolicy(ProjectionPolicy.FORCE_DECLARED);
        }
        else {
            task.getLayer().getResource().setProjectionPolicy(ProjectionPolicy.NONE);
        }


        if (r.getNativeBoundingBox() == null) {
            task.setState(ImportTask.State.NO_BOUNDS);
            return false;
        }
        
        task.setState(ImportTask.State.READY);
        return true;
    }

    boolean formatMatchesStore(DataFormat format, StoreInfo store) {
        if (format instanceof VectorFormat) {
            return store instanceof DataStoreInfo;
        }
        if (format instanceof GridFormat) {
            return store instanceof CoverageStoreInfo;
        }
        return false;
    }

    boolean resourceMatchesStore(ResourceInfo resource, StoreInfo store) {
        if (resource instanceof FeatureTypeInfo) {
            return store instanceof DataStoreInfo;
        }
        if (resource instanceof CoverageInfo) {
            return store instanceof CoverageStoreInfo;
        }
        return false;
    }

    public void run(ImportContext context) throws IOException {
        run(context, ImportFilter.ALL);
    }

    public void run(ImportContext context, ImportFilter filter) throws IOException {
        run(context, filter, null);
    }
    
    public void run(ImportContext context, ImportFilter filter, ProgressMonitor monitor) throws IOException {
        context.setProgress(monitor);
        context.setState(ImportContext.State.RUNNING);
        
        if (LOGGER.isLoggable(Level.FINE)) {
            LOGGER.fine("Running import " + context.getId());
        }
        
        for (ImportTask task : context.getTasks()) {
            if (!filter.include(task)) {
                continue;
            }
            if (!task.readyForImport()) {
                continue;
            }

            if (context.progress().isCanceled()) {
                break;
            }
            run(task);
        }

        context.updated();
        contextStore.save(context);

        if (context.isArchive() && context.getState() == ImportContext.State.COMPLETE) {
            boolean canArchive = !Iterables.any(context.getTasks(), new Predicate<ImportTask>() {
                @Override
                public boolean apply(ImportTask input) {
                    return input.isDirect();
                }
            });

            if (canArchive) {
                Directory directory = null;
                if (context.getData() instanceof Directory) {
                    directory = (Directory) context.getData();
                } else if ( context.getData() instanceof SpatialFile ) {
                    directory = new Directory( ((SpatialFile) context.getData()).getFile().getParentFile() );
                }
                if (directory != null) {
                    if (LOGGER.isLoggable(Level.FINE)) {
                        LOGGER.fine("Archiving directory " + directory.getFile().getAbsolutePath());
                    }       
                    try {
                        directory.archive(getArchiveFile(context));
                    } catch (Exception ioe) {
                        ioe.printStackTrace();

                        LOGGER.log(Level.WARNING, "Error archiving", ioe);
                    }
                }
            }

        }
    }

    void run(ImportTask task) throws IOException {
        if (task.getState() == ImportTask.State.COMPLETE) {
            return;
        }
        task.setState(ImportTask.State.RUNNING);

        if (task.isDirect()) {

            doDirectImport(task);
        }
        else {

            doIndirectImport(task);
        }

    }
    
    public File getArchiveFile(ImportContext context) throws IOException {

        String archiveName = "import-" + context.getId() + ".zip";
        File dir = getCatalog().getResourceLoader().findOrCreateDirectory("uploads","archives");
        return new File(dir, archiveName);
    }
    
    public void changed(ImportContext context) {
        context.updated();
        contextStore.save(context);
    }

    public void changed(ImportTask task)  {
        prep(task);
        changed(task.getContext());
    }

    public Long runAsync(final ImportContext context, final ImportFilter filter) {
        return jobs.submit(new Job<ImportContext>() {
            @Override
            protected ImportContext call(ProgressMonitor monitor) throws Exception {
                run(context, filter, monitor);
                return context;
            }

            @Override
            public String toString() {
                return "Processing import " + context.getId();
            }
        });
    }

    public Task<ImportContext> getTask(Long job) {
        return (Task<ImportContext>) jobs.getTask(job);
    }

    public List<Task<ImportContext>> getTasks() {
        return (List) jobs.getTasks();
    }


    void doDirectImport(ImportTask task) throws IOException {



        if (task.getStore().getId() == null) {
            StoreInfo store = task.getStore();


            store.setName(findUniqueStoreName(task.getStore()));
            

            if (!store.getConnectionParameters().containsKey("namespace")) {
                WorkspaceInfo ws = task.getContext().getTargetWorkspace();
                if (ws == null && task.getContext().getTargetStore() != null) {
                    ws = task.getContext().getTargetStore().getWorkspace();
                }
                if (ws != null) {
                    NamespaceInfo ns = catalog.getNamespaceByPrefix(ws.getName());
                    if (ns != null) {
                        store.getConnectionParameters().put("namespace", ns.getURI());
                    }
                }
            }
            catalog.add(task.getStore());
        }

        task.setState(ImportTask.State.RUNNING);

        try {

            TransformChain tx = task.getTransform();
            

            if (!doPreTransform(task, task.getData(), tx)) {
                return;
            }

            addToCatalog(task);


            if (!doPostTransform(task, task.getData(), tx)) {
                return;
            }

            task.setState(ImportTask.State.COMPLETE);
        }
        catch(Exception e) {
            LOGGER.log(Level.WARNING, "Task failed during import: " + task, e);
            task.setState(ImportTask.State.ERROR);
            task.setError(e);
        }

    }


    void doIndirectImport(ImportTask task) throws IOException {
        if (!task.getStore().isEnabled()) {
            task.getStore().setEnabled(true);
        }

        if (task.progress().isCanceled()){
            return;
        }

        task.setState(ImportTask.State.RUNNING);


        TransformChain tx = task.getTransform();


        if (!doPreTransform(task, task.getData(), tx)) {
            return;
        }

        boolean canceled = false;
        DataFormat format = task.getData().getFormat();
        if (format instanceof VectorFormat) {
            try {
                currentlyProcessing.put(task.getContext().getId(), task);
                loadIntoDataStore(task, (DataStoreInfo)task.getStore(), (VectorFormat) format, 
                    (VectorTransformChain) tx);
                canceled = task.progress().isCanceled();

                FeatureTypeInfo featureType = (FeatureTypeInfo) task.getLayer().getResource();
                featureType.getAttributes().clear();

                if (!canceled) {
                    if (task.getUpdateMode() == UpdateMode.CREATE) {
                        addToCatalog(task);
                    }
    




                    FeatureTypeInfo resource = getCatalog().getResourceByName(
                            featureType.getQualifiedName(), FeatureTypeInfo.class);
                    if (resource.getNativeBoundingBox().isEmpty()
                            || resource.getMetadata().get("recalculate-bounds") != null) {

                        CatalogBuilder cb = new CatalogBuilder(getCatalog());
                        ReferencedEnvelope nativeBounds = cb.getNativeBounds(resource);
                        resource.setNativeBoundingBox(nativeBounds);
                        resource.setLatLonBoundingBox(cb.getLatLonBounds(nativeBounds,
                                resource.getCRS()));
                        getCatalog().save(resource);
                    }
                }
            }
            catch(Exception e) {
                LOGGER.log(Level.SEVERE, "Error occured during import", e);
                task.setError(e);
                task.setState(ImportTask.State.ERROR);
                return;
            } finally {
                currentlyProcessing.remove(task.getContext().getId());
            }
        }
        else {
            throw new UnsupportedOperationException("Indirect raster import not yet supported");
        }

        if (!canceled && !doPostTransform(task, task.getData(), tx)) {
            return;
        }

        task.setState(canceled ? ImportTask.State.CANCELED : ImportTask.State.COMPLETE);

    }

    boolean doPreTransform(ImportTask task, ImportData data, TransformChain tx) {
        try {
            tx.pre(task, data);
        } 
        catch (Exception e) {
            LOGGER.log(Level.SEVERE, "Error occured during pre transform", e);
            task.setError(e);
            task.setState(ImportTask.State.ERROR);
            return false;
        }
        return true;
    }

    boolean doPostTransform(ImportTask task, ImportData data, TransformChain tx) {
        try {
            tx.post(task, data);
        } 
        catch (Exception e) {
            LOGGER.log(Level.SEVERE, "Error occured during post transform", e);
            task.setError(e);
            task.setState(ImportTask.State.ERROR);
            return false;
        }
        return true;
    }

    void loadIntoDataStore(ImportTask task, DataStoreInfo store, VectorFormat format, 
        VectorTransformChain tx) throws Exception {

        ImportData data = task.getData();
        FeatureReader reader = null;
        FeatureWriter writer = null;

        Exception error = null;
        try {
            reader = format.read(data, task);

            SimpleFeatureType featureType = (SimpleFeatureType) reader.getFeatureType();
            final String featureTypeName = featureType.getName().getLocalPart();
    
            DataStore dataStore = (DataStore) store.getDataStore(null);
            FeatureDataConverter featureDataConverter = FeatureDataConverter.DEFAULT;
            if (isShapefileDataStore(dataStore)) {
                featureDataConverter = FeatureDataConverter.TO_SHAPEFILE;
            }
            else if (isOracleDataStore(dataStore)) {
                featureDataConverter = FeatureDataConverter.TO_ORACLE;
            }
            else if (isPostGISDataStore(dataStore)) {
                featureDataConverter = FeatureDataConverter.TO_POSTGIS;
            }
            
            featureType = featureDataConverter.convertType(featureType, format, data, task);
            UpdateMode updateMode = task.getUpdateMode();
            final String uniquifiedFeatureTypeName;
            if (updateMode == UpdateMode.CREATE) {

                uniquifiedFeatureTypeName = findUniqueNativeFeatureTypeName(featureType, store);
                task.setOriginalLayerName(featureTypeName);
    
                if (!uniquifiedFeatureTypeName.equals(featureTypeName)) {

                    task.getLayer().getResource().setName(uniquifiedFeatureTypeName);
                    task.getLayer().getResource().setNativeName(uniquifiedFeatureTypeName);
                    

                    SimpleFeatureTypeBuilder typeBuilder = new SimpleFeatureTypeBuilder();
                    typeBuilder.setName(uniquifiedFeatureTypeName);
                    typeBuilder.addAll(featureType.getAttributeDescriptors());
                    featureType = typeBuilder.buildFeatureType();
                }
    


                if (dataStore instanceof JDBCDataStore) {
                    JDBCDataStore ds = (JDBCDataStore) dataStore;

                    if (ds.getSqlTypeNameToClassMappings().containsKey("timestamptz")) {
                        ds.getSqlTypeToSqlTypeNameOverrides().put(java.sql.Types.TIMESTAMP, "timestamptz");
                    }
                }
    

                featureType = tx.inline(task, dataStore, featureType);
    
                dataStore.createSchema(featureType);
            } else {

                

                if (updateMode == UpdateMode.UPDATE) {
                    throw new UnsupportedOperationException("updateMode UPDATE is not supported yet");
                }
                uniquifiedFeatureTypeName = featureTypeName;
            }
                
            Transaction transaction = new DefaultTransaction();
            
            if (updateMode == UpdateMode.REPLACE) {
                
                FeatureStore fs = (FeatureStore) dataStore.getFeatureSource(featureTypeName);
                fs.setTransaction(transaction);
                fs.removeFeatures(Filter.INCLUDE);
            }
            


            
            ProgressMonitor monitor = task.progress();
            

            int skipped = 0;
            int cnt = 0;

            long startTime = System.currentTimeMillis();
            task.clearMessages();
            
            task.setTotalToProcess(format.getFeatureCount(task.getData(), task));
            
            LOGGER.info("begining import");
            try {
                writer = dataStore.getFeatureWriterAppend(uniquifiedFeatureTypeName, transaction);
                
                while(reader.hasNext()) {
                    if (monitor.isCanceled()){
                        break;
                    }
                    SimpleFeature feature = (SimpleFeature) reader.next();
                    SimpleFeature next = (SimpleFeature) writer.next();
    




                    featureDataConverter.convert(feature, next);
                    

                    Geometry geom = (Geometry) next.getDefaultGeometry();
                    if (geom != null && geom.isEmpty()) {
                        next.setDefaultGeometry(null);
                    }
                    

                    next = tx.inline(task, dataStore, feature, next);
                    
                    if (next == null) {
                        skipped++;
                    } else {
                        writer.write();
                    }
                    task.setNumberProcessed(++cnt);
                }
                transaction.commit();
                if (skipped > 0) {
                    task.addMessage(Level.WARNING,skipped + " features were skipped.");
                }
                LOGGER.info("load to target took " + (System.currentTimeMillis() - startTime));
            } 
            catch (Exception e) {
                error = e;
            } 

            
            if (error != null || monitor.isCanceled()) {


    

                try {
                    transaction.rollback();
                } catch (Exception e1) {
                    LOGGER.log(Level.WARNING, "Error rolling back transaction",e1);
                }
    

                try {
                    dropSchema(dataStore,featureTypeName);
                } catch(Exception e1) {
                    LOGGER.log(Level.WARNING, "Error dropping schema in rollback",e1);
                }
            }
    

            try {
                transaction.close();
            } catch (Exception e) {
                if (error != null) {
                    error = e;
                }
                LOGGER.log(Level.WARNING, "Error closing transaction",e);
            }
    




            






        } finally {
            if (writer != null) {
                try {
                    writer.close();
                } catch (Exception e) {
                    if (error != null) {
                        error = e;
                    }
                    LOGGER.log(Level.WARNING, "Error closing writer",e);
                }
            }
            try {    
                if(reader != null) {
                    format.dispose(reader, task);



                }
            } catch (Exception e) {
                LOGGER.log(Level.WARNING, "Error closing reader",e);
            }
        }
        

        if (error != null) {
            throw error;
        }
    }

    StoreInfo lookupDefaultStore() {
        WorkspaceInfo ws = catalog.getDefaultWorkspace();
        if (ws == null) {
            return null;
        }

        return catalog.getDefaultDataStore(ws);
    }

    void addToCatalog(ImportTask task) throws IOException {
        LayerInfo layer = task.getLayer();
        ResourceInfo resource = layer.getResource();
        resource.setStore(task.getStore());


        String name = findUniqueResourceName(resource);
        resource.setName(name); 





        resource.setEnabled(true);
        catalog.add(resource);


        if (layer.getDefaultStyle().getId() == null) {
            catalog.add(layer.getDefaultStyle());
        }

        layer.setEnabled(true);
        catalog.add(layer);
    }

    String findUniqueStoreName(StoreInfo store) {
        WorkspaceInfo workspace = store.getWorkspace();


        String name = store.getName();
        if (catalog.getStoreByName(workspace, store.getName(), StoreInfo.class) != null) {
            int i = 0;
            name += i;
            while (catalog.getStoreByName(workspace, name, StoreInfo.class) != null) {
                name = name.replaceAll(i + "$", String.valueOf(i+1));
                i++;
            }
        }

        return name;
    }
    
    String findUniqueResourceName(ResourceInfo resource) 
        throws IOException {


        StoreInfo store = resource.getStore();
        NamespaceInfo ns = catalog.getNamespaceByPrefix(store.getWorkspace().getName());
        
        String name = resource.getName();


        if (!Character.isLetter(name.charAt(0))) {
            name = "a_" + name;
        }


        name = name.replaceAll("\\W", "_");

        if (catalog.getResourceByName(ns, name, ResourceInfo.class) != null) {
            int i = 0;
            name += i;
            while (catalog.getResourceByName(ns, name, ResourceInfo.class) != null) {
                name = name.replaceAll(i + "$", String.valueOf(i+1));
                i++;
            }
        }

        return name;
    }

    String findUniqueNativeFeatureTypeName(FeatureType featureType, DataStoreInfo store) throws IOException {
        return findUniqueNativeFeatureTypeName(featureType.getName().getLocalPart(), store);
    }

    private String findUniqueNativeFeatureTypeName(String name, DataStoreInfo store) throws IOException {
        DataStore dataStore = (DataStore) store.getDataStore(null);



        if (isOracleDataStore(dataStore)) {
            name = name.toUpperCase();
        }


        List<String> names = Arrays.asList(dataStore.getTypeNames());
        if (names.contains(name)) {
            int i = 0;
            name += i;
            while(names.contains(name)) {
                name = name.replaceAll(i + "$", String.valueOf(i+1));
                i++;
            }
        }

        return name;
    }

    boolean isShapefileDataStore(DataStore dataStore) {
        return dataStore instanceof ShapefileDataStore || dataStore instanceof DirectoryDataStore;
    }

    boolean isOracleDataStore(DataStore dataStore) {
        return dataStore instanceof JDBCDataStore && "org.geotools.data.oracle.OracleDialect"
            .equals(((JDBCDataStore)dataStore).getSQLDialect().getClass().getName());
    }

    boolean isPostGISDataStore(DataStore dataStore) {
        return dataStore instanceof JDBCDataStore && ((JDBCDataStore)dataStore).getSQLDialect()
            .getClass().getName().startsWith("org.geotools.data.postgis");
    }


    boolean computeLatLonBoundingBox(ImportTask task, boolean force) throws Exception {
        ResourceInfo r = task.getLayer().getResource();
        if (force || r.getLatLonBoundingBox() == null && r.getNativeBoundingBox() != null) {
            CoordinateReferenceSystem nativeCRS = CRS.decode(r.getSRS());
            ReferencedEnvelope nativeBbox = 
                new ReferencedEnvelope(r.getNativeBoundingBox(), nativeCRS);
            r.setLatLonBoundingBox(nativeBbox.transform(CRS.decode("EPSG:4326"), true));
            return true;
        }
        return false;
    }


    public File getImportRoot() {
        try {
            return catalog.getResourceLoader().findOrCreateDirectory("imports");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public File getUploadRoot() {
        try {
            return catalog.getResourceLoader().findOrCreateDirectory("uploads");
        }
        catch(IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void destroy() throws Exception {
        jobs.shutdown();
        contextStore.destroy();
    }

    public void delete(ImportContext importContext) throws IOException {
        delete(importContext, false);
    }
    
    public void delete(ImportContext importContext, boolean purge) throws IOException {
        if (purge) {
            importContext.delete();    
        }
        
        contextStore.remove(importContext);
    }

    private void dropSchema(DataStore ds, String featureTypeName) throws Exception {

        SimpleFeatureType schema = ds.getSchema(featureTypeName);
        if (schema != null) {
            try {
                ds.removeSchema(featureTypeName);
            } catch(Exception e) {
                LOGGER.warning("Unable to dropSchema " + featureTypeName + " from datastore " + ds.getClass());
            }
        } else {
            LOGGER.warning("Unable to dropSchema " + featureTypeName + " as it does not appear to exist in dataStore");
        }
    }

    public XStreamPersister createXStreamPersisterXML() {
        return initXStreamPersister(new XStreamPersisterFactory().createXMLPersister());
    }

    public XStreamPersister createXStreamPersisterJSON() {
        return initXStreamPersister(new XStreamPersisterFactory().createJSONPersister());
    }

    public XStreamPersister initXStreamPersister(XStreamPersister xp) {
        xp.setCatalog(catalog);

        
        XStream xs = xp.getXStream();


        xs.alias("import", ImportContext.class);


        xs.alias("task", ImportTask.class);
        xs.omitField(ImportTask.class, "context");






        xs.alias("dataStoreFormat", DataStoreFormat.class);


        xs.alias("spatialFile", SpatialFile.class);
        xs.alias("database", org.geoserver.importer.Database.class);
        xs.alias("table", Table.class);
        xs.omitField(Table.class, "db");

        xs.alias("vectorTransformChain", VectorTransformChain.class);
        xs.registerLocalConverter(ReprojectTransform.class, "source", new CRSConverter());
        xs.registerLocalConverter(ReprojectTransform.class, "target", new CRSConverter());

        xs.registerLocalConverter( ReferencedEnvelope.class, "crs", new CRSConverter() );
        xs.registerLocalConverter( GeneralEnvelope.class, "crs", new CRSConverter() );
        
        return xp;
    }

}

<code block>

package org.geoserver.importer.transform;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;

import org.apache.commons.exec.CommandLine;
import org.apache.commons.exec.DefaultExecutor;
import org.apache.commons.exec.ExecuteWatchdog;
import org.apache.commons.exec.PumpStreamHandler;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.output.CountingOutputStream;
import org.apache.commons.lang.SystemUtils;
import org.geoserver.data.util.IOUtils;
import org.geoserver.importer.ImportData;
import org.geoserver.importer.ImportTask;


public abstract class AbstractCommandLineTransform extends AbstractTransform implements
        PreTransform {

    private static final long serialVersionUID = 5998049960852782644L;

    static final long DEFAULT_TIMEOUT = 60 * 60 * 1000; 

    List<String> options;

    public AbstractCommandLineTransform(List<String> options) {
        this.options = options;
    }


    public List<String> getOptions() {
        return options;
    }


    public void setOptions(List<String> options) {
        this.options = options;
    }

    @Override
    public boolean stopOnError(Exception e) {
        return true;
    }

    @Override
    public void apply(ImportTask task, ImportData data) throws Exception {
        boolean inline = isInline();
        File executable = getExecutable();
        File inputFile = getInputFile(data);
        Map<String, File> substitutions = new HashMap<>();
        substitutions.put("input", inputFile);
        File outputDirectory = null;
        File outputFile = null;
        if (!inline) {
            outputDirectory = getOutputDirectory(data);
            outputFile = new File(outputDirectory, inputFile.getName());
            substitutions.put("output", outputFile);
        }



        CommandLine cmd = new CommandLine(executable);
        cmd.setSubstitutionMap(substitutions);

        setupCommandLine(inline, cmd);


        DefaultExecutor executor = new DefaultExecutor();

        executor.setWatchdog(new ExecuteWatchdog(DEFAULT_TIMEOUT));


        int limit = 16 * 1024;
        try (OutputStream os = new BoundedOutputStream(new ByteArrayOutputStream(), limit);
                OutputStream es = new BoundedOutputStream(new ByteArrayOutputStream(), limit)) {
            PumpStreamHandler streamHandler = new PumpStreamHandler(os, es);
            executor.setStreamHandler(streamHandler);
            int result = executor.execute(cmd);

            if (result != 0) {


                throw new IOException("Failed to execute command " + cmd.toString()
                        + "\nStandard output is:\n" + os.toString() + "\nStandard error is:\n"
                        + es.toString());
            }

        } catch (Exception e) {
            throw new IOException("Failure to execute command " + cmd.toString(), e);
        }


        if (!inline) {
            List<String> names = getReplacementTargetNames(data);
            File inputParent = inputFile.getParentFile();
            for (String name : names) {
                File output = new File(outputDirectory, name);
                File input = new File(inputParent, name);
                if (output.exists()) {

                    IOUtils.rename(output, input);
                } else if (input.exists()) {
                    input.delete();
                }
            }
            FileUtils.deleteDirectory(outputDirectory);
        }
    }

    protected boolean checkAvailable() throws IOException {
        CommandLine cmd = new CommandLine(getExecutable());
        for (String option : getAvailabilityTestOptions()) {
            cmd.addArgument(option);
        }


        DefaultExecutor executor = new DefaultExecutor();


        int limit = 16 * 1024;
        try (OutputStream os = new BoundedOutputStream(new ByteArrayOutputStream(), limit);
                OutputStream es = new BoundedOutputStream(new ByteArrayOutputStream(), limit)) {
            PumpStreamHandler streamHandler = new PumpStreamHandler(os, es);
            executor.setStreamHandler(streamHandler);
            int result = executor.execute(cmd);

            if (result != 0) {
                LOGGER.log(Level.SEVERE,
                        "Failed to execute command " + cmd.toString()
                        + "\nStandard output is:\n" + os.toString() + "\nStandard error is:\n"
                        + es.toString());
                return false;
            }

        } catch (Exception e) {
            LOGGER.log(Level.SEVERE, "Failure to execute command " + cmd.toString(), e);
            return false;
        }

        return true;
    }


    protected abstract List<String> getAvailabilityTestOptions();

    protected void setupCommandLine(boolean inline, CommandLine cmd) {
        for (String option : options) {
            cmd.addArgument(option);
        }


        if (inline) {
            cmd.addArgument("${input}");
        } else {

            if (isOutputAfterInput()) {
                cmd.addArgument("${input}");
                cmd.addArgument("${output}");
            } else {
                cmd.addArgument("${output}");
                cmd.addArgument("${input}");
            }
        }
    }


    protected abstract List<String> getReplacementTargetNames(ImportData data) throws IOException;


    protected boolean isInline() {
        return false;
    }


    protected boolean isOutputAfterInput() {
        return true;
    }


    protected abstract File getInputFile(ImportData data) throws IOException;


    protected File getOutputDirectory(ImportData data) throws IOException {
        File input = getInputFile(data);
        File parent = input.getParentFile();
        File tempFile = File.createTempFile("tmp", null, parent);
        tempFile.delete();
        if (!tempFile.mkdir()) {
            throw new IOException("Could not create work directory " + tempFile.getAbsolutePath());
        }

        return tempFile;
    }


    protected abstract File getExecutable() throws IOException;


    protected File getExecutableFromPath(String name) throws IOException {
        if (SystemUtils.IS_OS_WINDOWS) {
            name = name + ".exe";
        }
        String systemPath = System.getenv("PATH");
        if (systemPath == null) {
            systemPath = System.getenv("path");
        }
        if (systemPath == null) {
            throw new IOException("Path is not set, cannot locate " + name);
        }
        String[] paths = systemPath.split(File.pathSeparator);

        for (String pathDir : paths) {
            File file = new File(pathDir, name);
            if (file.exists() && file.isFile() && file.canExecute()) {
                return file;
            }
        }
        throw new IOException(
                "Could not locate executable (or could locate, but does not have execution rights): "
                        + name);
    }


    static final class BoundedOutputStream extends CountingOutputStream {

        private long maxSize;

        private OutputStream delegate;

        public BoundedOutputStream(OutputStream delegate, long maxSize) {
            super(delegate);
            this.delegate = delegate;
            this.maxSize = maxSize;
        }

        @Override
        public void write(byte[] bts) throws IOException {
            if (getByteCount() > maxSize) {
                return;
            }
            super.write(bts);
        }

        @Override
        public void write(byte[] bts, int st, int end) throws IOException {
            if (getByteCount() > maxSize) {
                return;
            }
            super.write(bts, st, end);
        }

        @Override
        public void write(int idx) throws IOException {
            if (getByteCount() > maxSize) {
                return;
            }
            super.write(idx);
        }

        @Override
        public String toString() {
            return delegate.toString();
        }

    }

}

<code block>

package org.geoserver.importer.transform;

import org.geoserver.catalog.ResourceInfo;
import org.geoserver.importer.ImportTask;
import org.geotools.data.DataStore;
import org.geotools.feature.simple.SimpleFeatureTypeBuilder;
import org.geotools.geometry.jts.JTS;
import org.geotools.referencing.CRS;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.feature.simple.SimpleFeatureType;
import org.opengis.referencing.crs.CoordinateReferenceSystem;
import org.opengis.referencing.operation.MathTransform;

import com.vividsolutions.jts.geom.Geometry;

public class ReprojectTransform extends AbstractTransform implements InlineVectorTransform {
    
    private static final long serialVersionUID = 1L;

    CoordinateReferenceSystem source, target;
    transient MathTransform transform;

    public CoordinateReferenceSystem getSource() {
        return source;
    }

    public void setSource(CoordinateReferenceSystem source) {
        this.source = source;
    }

    public CoordinateReferenceSystem getTarget() {
        return target;
    }

    public void setTarget(CoordinateReferenceSystem target) {
        this.target = target;
    }

    public ReprojectTransform(CoordinateReferenceSystem target) {
        this(null, target);
    }

    public ReprojectTransform(CoordinateReferenceSystem source, CoordinateReferenceSystem target) {
        this.source = source;
        this.target = target;
    }

    public SimpleFeatureType apply(ImportTask task, DataStore dataStore,
            SimpleFeatureType featureType) throws Exception {


        ResourceInfo r = task.getLayer().getResource();
        r.setNativeCRS(target);
        r.setSRS(CRS.lookupIdentifier(target, true));
        if (r.getNativeBoundingBox() != null) {
            r.setNativeBoundingBox(r.getNativeBoundingBox().transform(target, true));
        }

        return SimpleFeatureTypeBuilder.retype(featureType, target);
    }

    public SimpleFeature apply(ImportTask task, DataStore dataStore, SimpleFeature oldFeature, SimpleFeature feature)
            throws Exception {
        if (transform == null) {

            CoordinateReferenceSystem source = this.source;
            if (source == null) {

                source = oldFeature.getType().getCoordinateReferenceSystem();
            }

            if (source == null) {
                throw new IllegalStateException("Unable to determine source projection");
            }

            transform = CRS.findMathTransform(source, target, true);
        }

        Geometry g = (Geometry) oldFeature.getDefaultGeometry();
        if (g != null) {
            feature.setDefaultGeometry(JTS.transform(g, transform));
        }
        return feature;
    }
}

<code block>

package org.geoserver.importer.transform;

import java.util.List;
import java.util.logging.Logger;

import org.geoserver.importer.ImportTask;
import org.geotools.data.DataStore;
import org.geotools.util.logging.Logging;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.feature.simple.SimpleFeatureType;


public class VectorTransformChain extends TransformChain<VectorTransform> {
    private static final long serialVersionUID = 7406010540766743012L;

    static Logger LOGGER = Logging.getLogger(VectorTransformChain.class);

    public VectorTransformChain(List<VectorTransform> transforms) {
        super(transforms);
    }

    public VectorTransformChain(VectorTransform... transforms) {
        super(transforms);
    }
    
    public SimpleFeatureType inline(ImportTask task, DataStore dataStore, SimpleFeatureType featureType) 
        throws Exception {
        
        for (InlineVectorTransform tx : filter(transforms, InlineVectorTransform.class)) {
            try {
                tx.init();
                featureType = tx.apply(task, dataStore, featureType);
            } catch (Exception e) {
                error(tx, e);
            }
        }
        
        return featureType;
    }

    public SimpleFeature inline(ImportTask task, DataStore dataStore, SimpleFeature oldFeature, 
        SimpleFeature feature) throws Exception {
        
        for (InlineVectorTransform tx : filter(transforms, InlineVectorTransform.class)) {
            try {
                feature = tx.apply(task, dataStore, oldFeature, feature);
                if (feature == null) {
                    break;
                }
            } catch (Exception e) {
                error(tx, e);
            }
        }
        
        return feature;
    }






}

<code block>

package org.geoserver.importer.transform;

import org.geoserver.importer.ImportData;
import org.geoserver.importer.ImportTask;


public interface PostTransform extends ImportTransform {

    void apply(ImportTask task, ImportData data) throws Exception;
}

<code block>

package org.geoserver.importer.transform;

import org.geoserver.importer.ImportTask;
import org.geotools.data.DataStore;
import org.geotools.feature.simple.SimpleFeatureTypeBuilder;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.feature.simple.SimpleFeatureType;
import org.opengis.feature.type.GeometryDescriptor;

import com.vividsolutions.jts.geom.Coordinate;
import com.vividsolutions.jts.geom.GeometryFactory;
import com.vividsolutions.jts.geom.Point;

public class AttributesToPointGeometryTransform extends AbstractTransform implements
        InlineVectorTransform {


    private static final long serialVersionUID = 1L;

    private static final String POINT_NAME = "location";

    private final String latField;

    private final String lngField;

    private final String pointFieldName;

    private final GeometryFactory geometryFactory;

    public AttributesToPointGeometryTransform(String latField, String lngField) {
        this(latField, lngField, AttributesToPointGeometryTransform.POINT_NAME);
    }

    public AttributesToPointGeometryTransform(String latField, String lngField,
            String pointFieldName) {
        this.latField = latField;
        this.lngField = lngField;
        this.pointFieldName = pointFieldName;
        geometryFactory = new GeometryFactory();
    }

    @Override
    public SimpleFeatureType apply(ImportTask task, DataStore dataStore,
            SimpleFeatureType featureType) throws Exception {
        SimpleFeatureTypeBuilder builder = new SimpleFeatureTypeBuilder();
        builder.init(featureType);

        int latIndex = featureType.indexOf(latField);
        int lngIndex = featureType.indexOf(lngField);
        if (latIndex < 0 || lngIndex < 0) {
            throw new Exception("FeatureType " + featureType.getName()
                    + " does not have lat lng fields named '" + latField + "'" + " and " + "'"
                    + lngField + "'");
        }

        GeometryDescriptor geometryDescriptor = featureType.getGeometryDescriptor();
        if (geometryDescriptor != null) {
            builder.remove(geometryDescriptor.getLocalName());
        }
        builder.remove(latField);
        builder.remove(lngField);
        builder.add(pointFieldName, Point.class);

        return builder.buildFeatureType();
    }

    @Override
    public SimpleFeature apply(ImportTask task, DataStore dataStore, SimpleFeature oldFeature,
            SimpleFeature feature) throws Exception {
        Object latObject = oldFeature.getAttribute(latField);
        Object lngObject = oldFeature.getAttribute(lngField);
        Double lat = asDouble(latObject);
        Double lng = asDouble(lngObject);
        if (lat == null || lng == null) {
            feature.setDefaultGeometry(null);
        } else {
            Coordinate coordinate = new Coordinate(lng, lat);
            Point point = geometryFactory.createPoint(coordinate);
            feature.setAttribute(pointFieldName, point);
        }
        return feature;
    }

    private Double asDouble(Object value) {
        if (value == null) {
            return null;
        }
        if (value instanceof Double) {
            return (Double) value;
        }
        try {
            return Double.parseDouble(value.toString());
        } catch (NumberFormatException e) {
            return null;
        }
    }

    public String getLatField() {
        return latField;
    }

    public String getLngField() {
        return lngField;
    }

}

<code block>

package org.geoserver.importer.transform;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import org.apache.commons.exec.CommandLine;
import org.geoserver.importer.FileData;
import org.geoserver.importer.ImportData;
import org.geoserver.importer.ValidationException;



public class GdalAddoTransform extends AbstractCommandLineTransform implements RasterTransform {
    private static final long serialVersionUID = -6241844409161277128L;


    public static boolean isAvailable() throws IOException {
        return new GdalAddoTransform(new ArrayList<String>(), Arrays.asList(2))
                .checkAvailable();
    }

    private List<Integer> levels;

    public GdalAddoTransform(List<String> options, List<Integer> levels) {
        super(options);
        this.levels = levels;
        if (levels == null || levels.size() == 0) {
            throw new ValidationException("Levels is missing, must contain at least one value");
        } else {
            for (Integer level : levels) {
                if (level == null) {
                    throw new ValidationException(
                            "Invalid null level found in the gdaladdo overviews levels: " + levels);
                }
                if (level <= 1) {
                    throw new ValidationException(
                            "Invalid level found in the gdaladdo overviews levels, they must be positive and greater than one: "
                                    + level);
                }
            }
            int previous = levels.get(0);
            for (int i = 1; i < levels.size(); i++) {
                int curr = levels.get(i);
                if (curr <= previous) {
                    throw new ValidationException(
                            "Invalid levels order, they must be provided in increasing order, but we have "
                                    + curr + " after " + previous + " in " + levels);
                }
            }
        }
    }

    @Override
    protected void setupCommandLine(boolean inline, CommandLine cmd) {
        super.setupCommandLine(inline, cmd);
        for (Integer level : levels) {
            cmd.addArgument(String.valueOf(level));
        }
    }

    @Override
    protected List<String> getReplacementTargetNames(ImportData data) throws IOException {
        File input = getInputFile(data);
        return Collections.singletonList(input.getName());
    }

    @Override
    protected File getInputFile(ImportData data) throws IOException {
        if (data instanceof FileData) {
            FileData fd = (FileData) data;
            return fd.getFile();
        } else {
            throw new IOException("Can run gdaladdo only against file data");
        }
    }

    @Override
    protected File getExecutable() throws IOException {
        return getExecutableFromPath("gdaladdo");
    }

    @Override
    protected boolean isInline() {
        return true;
    }

    @Override
    protected List<String> getAvailabilityTestOptions() {
        return Collections.singletonList("--version");
    }


    public List<Integer> getLevels() {
        return levels;
    }

}

<code block>

package org.geoserver.importer.transform;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.geoserver.importer.ImportData;
import org.geoserver.importer.ImportTask;
import org.geotools.util.logging.Logging;


public abstract class TransformChain<T extends ImportTransform> implements Serializable {

    private static final long serialVersionUID = 4090734786225748502L;

    static Logger LOGGER = Logging.getLogger(TransformChain.class);

    protected List<T> transforms;
    
    public TransformChain() {
        this(new ArrayList<T>(3));
    }

    public TransformChain(List<T> transforms) {
        this.transforms = transforms;
    }

    public TransformChain(T... transforms) {
        this.transforms = new ArrayList(Arrays.asList(transforms));
    }

    public List<T> getTransforms() {
        return transforms;
    }

    public <X extends T> void add(X tx) {
        transforms.add(tx);
    }

    public <X extends T> boolean remove(X tx) {
        return transforms.remove(tx);
    }

    public <X extends T> X get(Class<X> type) {
        for (T tx : transforms) {
            if (type.equals(tx.getClass())) {
                return (X) tx;
            }
        }
        return null;
    }

    public <X extends T> List<X> getAll(Class<X> type) {
        List<X> list = new ArrayList<X>();
        for (T tx : transforms) {
            if (type.isAssignableFrom(tx.getClass())) {
                list.add((X) tx);
            }
        }
        return list;
    }

    public <X extends T> void removeAll(Class<X> type) {
        for (Iterator<T> it = transforms.iterator(); it.hasNext(); ) {
            if (type.isAssignableFrom(it.next().getClass())) {
                it.remove();
            }
        }
    }
    

    public void pre(ImportTask item, ImportData data) throws Exception {
        for (PreTransform tx : filter(transforms, PreTransform.class)) {
            try {
                tx.apply(item, data);
            } catch (Exception e) {
                error(tx, e);
            }
        }
    }


    public void post(ImportTask task, ImportData data) throws Exception {
        for (PostTransform tx : filter(transforms, PostTransform.class)) {
            try {
                tx.apply(task, data);
            } catch (Exception e) {
                error(tx, e);
            }
        }
    }

    private Object readResolve() {
        if (transforms == null) {
            transforms = new ArrayList();
        }
        return this;
    }

    protected void error(ImportTransform tx, Exception e) throws Exception {
        if (tx.stopOnError(e)) {
            throw e;
        } else {

            LOGGER.log(Level.WARNING, "Transform " + tx + " failed", e);
        }
    }

    protected <T> List<T> filter(List<? extends ImportTransform> transforms, Class<T> type) {
        List<T> filtered = new ArrayList<T>();
        for (ImportTransform tx : transforms) {
            if (type.isInstance(tx)) {
                filtered.add((T) tx);
            }
        }
        return filtered;
    }
}

<code block>

package org.geoserver.importer.transform;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.apache.commons.lang.StringUtils;
import org.geoserver.importer.FeatureDataConverter;
import org.geoserver.importer.ImportTask;
import org.geoserver.importer.format.KMLFileFormat;
import org.geotools.data.DataStore;
import org.geotools.feature.simple.SimpleFeatureBuilder;
import org.geotools.feature.simple.SimpleFeatureTypeBuilder;
import org.geotools.kml.Folder;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.feature.simple.SimpleFeatureType;
import org.opengis.feature.type.AttributeDescriptor;

import com.vividsolutions.jts.geom.Geometry;

public class KMLPlacemarkTransform extends AbstractTransform implements InlineVectorTransform {


    private static final long serialVersionUID = 1L;

    public SimpleFeatureType convertFeatureType(SimpleFeatureType oldFeatureType) {
        SimpleFeatureTypeBuilder ftb = new SimpleFeatureTypeBuilder();
        ftb.add("Geometry", Geometry.class);
        ftb.setDefaultGeometry("Geometry");
        List<AttributeDescriptor> attributeDescriptors = oldFeatureType.getAttributeDescriptors();
        for (AttributeDescriptor attributeDescriptor : attributeDescriptors) {
            String localName = attributeDescriptor.getLocalName();
            if (!"Geometry".equals(localName)) {
                ftb.add(attributeDescriptor);
            }
        }
        ftb.setName(oldFeatureType.getName());
        ftb.setDescription(oldFeatureType.getDescription());
        ftb.setCRS(KMLFileFormat.KML_CRS);
        ftb.setSRS(KMLFileFormat.KML_SRS);

        if (oldFeatureType.getDescriptor("Style") != null) {
            ftb.remove("Style");
        }
        ftb.add("Folder", String.class);
        SimpleFeatureType ft = ftb.buildFeatureType();
        return ft;
    }

    public SimpleFeature convertFeature(SimpleFeature old, SimpleFeatureType targetFeatureType) {
        SimpleFeatureBuilder fb = new SimpleFeatureBuilder(targetFeatureType);
        SimpleFeature newFeature = fb.buildFeature(old.getID());
        FeatureDataConverter.DEFAULT.convert(old, newFeature);
        Map<Object, Object> userData = old.getUserData();
        Object folderObject = userData.get("Folder");
        if (folderObject != null) {
            String serializedFolders = serializeFolders(folderObject);
            newFeature.setAttribute("Folder", serializedFolders);
        }
        @SuppressWarnings("unchecked")
        Map<String, String> untypedExtendedData = (Map<String, String>) userData
                .get("UntypedExtendedData");
        if (untypedExtendedData != null) {
            for (Entry<String, String> entry : untypedExtendedData.entrySet()) {
                if (targetFeatureType.getDescriptor(entry.getKey()) != null) {
                    newFeature.setAttribute(entry.getKey(), entry.getValue());
                }
            }
        }
        return newFeature;
    }

    private String serializeFolders(Object folderObject) {
        @SuppressWarnings("unchecked")
        List<Folder> folders = (List<Folder>) folderObject;
        List<String> folderNames = new ArrayList<String>(folders.size());
        for (Folder folder : folders) {
            String name = folder.getName();
            if (!StringUtils.isEmpty(name)) {
                folderNames.add(name);
            }
        }
        String serializedFolders = StringUtils.join(folderNames.toArray(), " -> ");
        return serializedFolders;
    }

    @Override
    public SimpleFeatureType apply(ImportTask task, DataStore dataStore,
            SimpleFeatureType featureType) throws Exception {
        return convertFeatureType(featureType);
    }

    @Override
    public SimpleFeature apply(ImportTask task, DataStore dataStore, SimpleFeature oldFeature,
            SimpleFeature feature) throws Exception {
        SimpleFeatureType targetFeatureType = feature.getFeatureType();
        SimpleFeature newFeature = convertFeature(oldFeature, targetFeatureType);
        feature.setAttributes(newFeature.getAttributes());
        return feature;
    }
}

<code block>

package org.geoserver.importer.transform;

import java.util.logging.Logger;

import org.geotools.util.logging.Logging;

public abstract class AbstractTransform implements ImportTransform {

    private static final long serialVersionUID = 1L;
    
    final transient Logger LOGGER = Logging.getLogger(getClass());
    
    public boolean stopOnError(Exception e) {
        return true;
    }
    

    public void init() {

    }

}

<code block>

package org.geoserver.importer.transform;

import org.geoserver.importer.ImportData;
import org.geoserver.importer.ImportTask;


public interface PreTransform extends ImportTransform {

    void apply(ImportTask task, ImportData data) throws Exception;
}

<code block>

package org.geoserver.importer.transform;



public class RasterTransformChain extends TransformChain<RasterTransform> {

    
}

<code block>

package org.geoserver.importer.transform;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.geoserver.importer.FileData;
import org.geoserver.importer.ImportData;


public class GdalTranslateTransform extends AbstractCommandLineTransform implements RasterTransform {
    private static final long serialVersionUID = -6241844409161277128L;


    public static boolean isAvailable() throws IOException {
        return new GdalTranslateTransform(new ArrayList<String>()).checkAvailable();
    }

    public GdalTranslateTransform(List<String> options) {
        super(options);
    }

    @Override
    protected List<String> getReplacementTargetNames(ImportData data) throws IOException {
        File input = getInputFile(data);
        return Collections.singletonList(input.getName());
    }

    @Override
    protected File getInputFile(ImportData data) throws IOException {
        if (data instanceof FileData) {
            FileData fd = (FileData) data;
            return fd.getFile();
        } else {
            throw new IOException("Can run gdal_translate only against file data");
        }
    }

    @Override
    protected File getExecutable() throws IOException {
        return getExecutableFromPath("gdal_translate");
    }

    protected List<String> getAvailabilityTestOptions() {
        return Collections.singletonList("--version");
    }

}

<code block>

package org.geoserver.importer.transform;

import org.geoserver.importer.ImportTask;
import org.geotools.data.DataStore;
import org.geotools.feature.AttributeTypeBuilder;
import org.geotools.feature.simple.SimpleFeatureTypeBuilder;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.feature.simple.SimpleFeatureType;
import org.opengis.feature.type.AttributeDescriptor;


public class AttributeRemapTransform extends AbstractTransform implements InlineVectorTransform {
    
    private static final long serialVersionUID = 1L;


    protected String field;


    protected Class type;
    
    public AttributeRemapTransform(String field, Class type) {
        this.field = field;
        this.type = type;
    }
    
    protected AttributeRemapTransform() {
        
    }

    public String getField() {
        return field;
    }

    public void setField(String field) {
        this.field = field;
    }

    public Class getType() {
        return type;
    }

    public void setType(Class type) {
        this.type = type;
    }

    public SimpleFeatureType apply(ImportTask task, DataStore dataStore,
            SimpleFeatureType featureType) throws Exception {

        SimpleFeatureTypeBuilder builder = new SimpleFeatureTypeBuilder();
        builder.init(featureType);

        int index = featureType.indexOf(field);
        if (index < 0) {
            throw new Exception("FeatureType " + featureType.getName() + " does not have attribute named '" + field + "'");
        }
        


        AttributeDescriptor existing = builder.remove(field);
        AttributeTypeBuilder attBuilder = new AttributeTypeBuilder();
        attBuilder.init(existing);
        attBuilder.setBinding(type);
        builder.add(index, attBuilder.buildDescriptor(field));

        return builder.buildFeatureType();
    }

    public SimpleFeature apply(ImportTask task, DataStore dataStore, SimpleFeature oldFeature, 
        SimpleFeature feature) throws Exception {
        return feature;
    }

}

<code block>

package org.geoserver.importer.transform;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Set;

import org.apache.commons.io.FilenameUtils;
import org.geoserver.catalog.LayerInfo;
import org.geoserver.catalog.ResourceInfo;
import org.geoserver.importer.DataFormat;
import org.geoserver.importer.FileData;
import org.geoserver.importer.ImportData;
import org.geoserver.importer.ImportTask;
import org.geoserver.importer.job.ProgressMonitor;
import org.geotools.gce.image.WorldImageFormat;


public class GdalWarpTransform extends AbstractCommandLineTransform implements RasterTransform {
    private static final long serialVersionUID = -6241844409161277128L;


    public static boolean isAvailable() throws IOException {
        return new GdalWarpTransform(new ArrayList<String>()).checkAvailable();
    }

    public GdalWarpTransform(List<String> options) {
        super(options);
    }
    
    @Override
    public void apply(ImportTask task, ImportData data) throws Exception {

        super.apply(task, data);


        LayerInfo layer = task.getLayer();
        ResourceInfo resource = layer.getResource();
        String originalSRS = resource.getSRS();


        if (layer.getId() != null || resource == null || resource.getCatalog() == null) {
            return;
        }

        DataFormat format = DataFormat.lookup(((FileData) data).getFile());
        List<ImportTask> tasks = format.list(data, resource.getCatalog(),
                new ProgressMonitor());
        if (tasks == null || tasks.isEmpty()) {
            return;
        }
        LayerInfo updatedLayer = tasks.get(0).getLayer();
        ResourceInfo updatedResource = updatedLayer.getResource();
        String updatedSRS = updatedResource.getSRS();


        if (originalSRS == null || (!originalSRS.equals(updatedSRS) && updatedSRS != null)) {
            resource.setSRS(updatedSRS);
            resource.setNativeCRS(updatedResource.getNativeCRS());
            resource.setNativeBoundingBox(updatedResource.getNativeBoundingBox());
            resource.setLatLonBoundingBox(updatedResource.getLatLonBoundingBox());
        }
    }

    @Override
    protected List<String> getReplacementTargetNames(ImportData data) throws IOException {
        File input = getInputFile(data);
        String name = input.getName();
        String baseName = FilenameUtils.getBaseName(name);
        String extension = FilenameUtils.getExtension(name);
        List<String> names = new ArrayList<>();
        names.add(name);
        names.add(baseName + ".prj");
        names.add(baseName + ".wld");
        try {

            Set<String> worldExtensions = WorldImageFormat.getWorldExtension(extension);
            for (String we : worldExtensions) {
                names.add(baseName + we);
            }
        } catch (IllegalArgumentException e) {

        }
        return Collections.singletonList(name);
    }

    @Override
    protected File getInputFile(ImportData data) throws IOException {
        if (data instanceof FileData) {
            FileData fd = (FileData) data;
            return fd.getFile();
        } else {
            throw new IOException("Can run gdalwarp only against file data");
        }
    }

    @Override
    protected File getExecutable() throws IOException {
        return getExecutableFromPath("gdalwarp");
    }

    protected List<String> getAvailabilityTestOptions() {
        return Collections.singletonList("--version");
    }

}

<code block>

package org.geoserver.importer.transform;

import org.geoserver.importer.ImportTask;
import org.geotools.data.DataStore;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.feature.simple.SimpleFeatureType;


public abstract class AbstractInlineVectorTransform extends AbstractTransform implements
        InlineVectorTransform {


    private static final long serialVersionUID = 1L;

    @Override
    public SimpleFeatureType apply(ImportTask task, DataStore dataStore,
            SimpleFeatureType featureType) throws Exception {
        return featureType;
    }

    @Override
    public SimpleFeature apply(ImportTask task, DataStore dataStore, SimpleFeature oldFeature,
            SimpleFeature feature) throws Exception {
        return feature;
    }

}

<code block>

package org.geoserver.importer.transform;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.logging.Level;

import org.geoserver.catalog.DataStoreInfo;
import org.geoserver.importer.ImportData;
import org.geoserver.importer.ImportTask;
import org.geotools.data.DataAccess;
import org.geotools.data.Transaction;
import org.geotools.jdbc.JDBCDataStore;


public class CreateIndexTransform extends AbstractTransform implements PostTransform,
        VectorTransform {
    
    private static final long serialVersionUID = 1L;
    
    private String field;
    
    public CreateIndexTransform(String field) {
        this.field = field;
    }

    public String getField() {
        return field;
    }

    public void setField(String field) {
        this.field = field;
    }
    
    public void apply(ImportTask task, ImportData data) throws Exception {
        DataStoreInfo storeInfo = (DataStoreInfo) task.getStore();
        DataAccess store = storeInfo.getDataStore(null);
        if (store instanceof JDBCDataStore) {
            createIndex( task, (JDBCDataStore) store);
        } else {
            task.addMessage(Level.WARNING, "Cannot create index on non database target. Not a big deal.");
        }
    }
    
    private void createIndex(ImportTask item, JDBCDataStore store) throws Exception {
        Connection conn = null;
        Statement stmt = null;
        Exception error = null;
        String sql = null;
        try {
            conn = store.getConnection(Transaction.AUTO_COMMIT);
            stmt = conn.createStatement();
            String tableName = item.getLayer().getResource().getNativeName();
            String indexName = "\"" + tableName + "_" + field + "\"";
            sql = "CREATE INDEX " + indexName + " ON \"" + tableName + "\" (\"" + field + "\")";
            stmt.execute(sql);
        } catch (SQLException sqle) {
            error = sqle;
        } finally {
            store.closeSafe(stmt);
            store.closeSafe(conn);
        }
        if (error != null) {
            throw new Exception("Error creating index, SQL was : " + sql,error);
        }
    }
    
}

<code block>

package org.geoserver.importer.transform;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;

import java.awt.image.ColorModel;
import java.awt.image.DataBuffer;
import java.awt.image.SampleModel;
import java.io.File;
import java.util.ArrayList;
import java.util.List;

import javax.media.jai.ImageLayout;

import org.geoserver.catalog.Catalog;
import org.geoserver.catalog.CoverageStoreInfo;
import org.geoserver.importer.ImportContext;
import org.geoserver.importer.ImportTask;
import org.geoserver.importer.ImporterTestSupport;
import org.geoserver.importer.SpatialFile;
import org.geotools.gce.geotiff.GeoTiffReader;
import org.geotools.referencing.CRS;
import org.junit.Assume;
import org.junit.Test;

public class GdalTransformTest extends ImporterTestSupport {

    @Test
    public void testGdalTranslateTrasform() throws Exception {
        Assume.assumeTrue(GdalTranslateTransform.isAvailable());

        File dir = unpack("geotiff/EmissiveCampania.tif.bz2");
        File tif = new File(dir, "EmissiveCampania.tif");

        ImportContext context = importer.createContext(new SpatialFile(tif));
        assertEquals(1, context.getTasks().size());

        ImportTask task = context.getTasks().get(0);
        assertEquals(ImportTask.State.READY, task.getState());


        GdalTranslateTransform gtx = buildGdalTranslate();
        task.getTransform().add(gtx);

        assertEquals("EmissiveCampania", task.getLayer().getResource().getName());

        importer.run(context);

        Catalog cat = getCatalog();
        assertNotNull(cat.getLayerByName("EmissiveCampania"));

        assertEquals(ImportTask.State.COMPLETE, task.getState());

        runChecks("EmissiveCampania");
        

        GeoTiffReader reader = null;
        try {
            reader = new GeoTiffReader(tif);
            ImageLayout layout = reader.getImageLayout();
            ColorModel cm = layout.getColorModel(null);
            assertEquals(3, cm.getNumComponents());
            SampleModel sm = layout.getSampleModel(null);
            assertEquals(3, sm.getNumBands());
            assertEquals(DataBuffer.TYPE_BYTE, sm.getDataType());
            assertEquals(0, reader.getNumOverviews());
        } finally {
            if (reader != null) {
                reader.dispose();
            }
        }
        
    }

    @Test
    public void testGdalAddo() throws Exception {
        Assume.assumeTrue(GdalAddoTransform.isAvailable());
        File dir = unpack("geotiff/EmissiveCampania.tif.bz2");
        File tif = new File(dir, "EmissiveCampania.tif");

        ImportContext context = importer.createContext(new SpatialFile(tif));
        assertEquals(1, context.getTasks().size());

        ImportTask task = context.getTasks().get(0);
        assertEquals(ImportTask.State.READY, task.getState());


        GdalAddoTransform gad = buildGdalAddo();
        task.getTransform().add(gad);

        assertEquals("EmissiveCampania", task.getLayer().getResource().getName());

        importer.run(context);

        Catalog cat = getCatalog();
        assertNotNull(cat.getLayerByName("EmissiveCampania"));

        assertEquals(ImportTask.State.COMPLETE, task.getState());

        runChecks("EmissiveCampania");


        GeoTiffReader reader = null;
        try {
            reader = new GeoTiffReader(tif);
            ImageLayout layout = reader.getImageLayout();
            ColorModel cm = layout.getColorModel(null);
            assertEquals(16, cm.getNumComponents());
            SampleModel sm = layout.getSampleModel(null);
            assertEquals(16, sm.getNumBands());
            assertEquals(DataBuffer.TYPE_USHORT, sm.getDataType());
            assertEquals(3, reader.getNumOverviews());
        } finally {
            if (reader != null) {
                reader.dispose();
            }
        }

    }



    @Test
    public void testTranslateAddo() throws Exception {
        Assume.assumeTrue(GdalTranslateTransform.isAvailable());
        Assume.assumeTrue(GdalAddoTransform.isAvailable());

        File dir = unpack("geotiff/EmissiveCampania.tif.bz2");
        File tif = new File(dir, "EmissiveCampania.tif");

        ImportContext context = importer.createContext(new SpatialFile(tif));
        assertEquals(1, context.getTasks().size());

        ImportTask task = context.getTasks().get(0);
        assertEquals(ImportTask.State.READY, task.getState());

        GdalTranslateTransform gtx = buildGdalTranslate();
        task.getTransform().add(gtx);
        GdalAddoTransform gad = buildGdalAddo();
        task.getTransform().add(gad);

        assertEquals("EmissiveCampania", task.getLayer().getResource().getName());

        importer.run(context);

        Catalog cat = getCatalog();
        assertNotNull(cat.getLayerByName("EmissiveCampania"));

        assertEquals(ImportTask.State.COMPLETE, task.getState());

        runChecks("EmissiveCampania");


        GeoTiffReader reader = null;
        try {
            reader = new GeoTiffReader(tif);
            ImageLayout layout = reader.getImageLayout();
            ColorModel cm = layout.getColorModel(null);
            assertEquals(3, cm.getNumComponents());
            SampleModel sm = layout.getSampleModel(null);
            assertEquals(3, sm.getNumBands());
            assertEquals(DataBuffer.TYPE_BYTE, sm.getDataType());
            assertEquals(3, reader.getNumOverviews());
        } finally {
            if (reader != null) {
                reader.dispose();
            }
        }

    }

    @Test
    public void testWarpFromGroundControlPoint() throws Exception {
        Assume.assumeTrue(GdalWarpTransform.isAvailable());
        File dir = unpack("geotiff/box_gcp_fixed.tif.bz2");
        File tif = new File(dir, "box_gcp_fixed.tif");

        ImportContext context = importer.createContext(new SpatialFile(tif));
        assertEquals(1, context.getTasks().size());

        ImportTask task = context.getTasks().get(0);
        assertEquals(ImportTask.State.READY, task.getState());


        GdalWarpTransform warp = buildGdalWarp();
        task.getTransform().add(warp);

        assertEquals("box_gcp_fixed", task.getLayer().getResource().getName());
        
        CoverageStoreInfo store = (CoverageStoreInfo) task.getStore();
        assertEquals("GeoTIFF", store.getFormat().getName());

        importer.run(context);

        Catalog cat = getCatalog();
        assertNotNull(cat.getLayerByName("box_gcp_fixed"));

        assertEquals(ImportTask.State.COMPLETE, task.getState());

        runChecks("box_gcp_fixed");


        GeoTiffReader reader = null;
        try {
            reader = new GeoTiffReader(tif);
            ImageLayout layout = reader.getImageLayout();
            ColorModel cm = layout.getColorModel(null);
            assertEquals(3, cm.getNumComponents());
            SampleModel sm = layout.getSampleModel(null);
            assertEquals(1, sm.getNumBands());
            assertEquals(DataBuffer.TYPE_BYTE, sm.getDataType());
            assertEquals(0, reader.getNumOverviews());
            assertEquals(Integer.valueOf(4326),
                    CRS.lookupEpsgCode(reader.getCoordinateReferenceSystem(), false));
        } finally {
            if (reader != null) {
                reader.dispose();
            }
        }
    }


    private GdalTranslateTransform buildGdalTranslate() {
        List<String> options = new ArrayList<>();
        options.add("-b");
        options.add("1");
        options.add("-b");
        options.add("2");
        options.add("-b");
        options.add("3");
        options.add("-ot");
        options.add("Byte");
        GdalTranslateTransform gtx = new GdalTranslateTransform(options);
        return gtx;
    }

    private GdalAddoTransform buildGdalAddo() {
        List<String> options = new ArrayList<>();
        options.add("-r");
        options.add("average");
        List<Integer> levels = new ArrayList<>();
        levels.add(2);
        levels.add(4);
        levels.add(8);
        GdalAddoTransform gad = new GdalAddoTransform(options, levels);
        return gad;
    }

    private GdalWarpTransform buildGdalWarp() {
        List<String> options = new ArrayList<>();
        options.add("-t_srs");
        options.add("EPSG:4326");
        GdalWarpTransform warp = new GdalWarpTransform(options);
        return warp;
    }

}

<code block>

package org.geoserver.importer.rest;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.text.SimpleDateFormat;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.TimeZone;
import java.util.logging.LogRecord;

import net.sf.json.JSONArray;
import net.sf.json.JSONObject;
import net.sf.json.JSONSerializer;
import net.sf.json.util.JSONBuilder;

import org.geoserver.catalog.AttributeTypeInfo;
import org.geoserver.catalog.CoverageStoreInfo;
import org.geoserver.catalog.DataStoreInfo;
import org.geoserver.catalog.FeatureTypeInfo;
import org.geoserver.catalog.LayerInfo;
import org.geoserver.catalog.ResourceInfo;
import org.geoserver.catalog.StoreInfo;
import org.geoserver.catalog.StyleInfo;
import org.geoserver.config.util.XStreamPersister;
import org.geoserver.config.util.XStreamPersister.Callback;
import org.geoserver.config.util.XStreamPersisterFactory;
import org.geoserver.importer.Database;
import org.geoserver.importer.Directory;
import org.geoserver.importer.FileData;
import org.geoserver.importer.ImportContext;
import org.geoserver.importer.ImportData;
import org.geoserver.importer.ImportTask;
import org.geoserver.importer.Importer;
import org.geoserver.importer.SpatialFile;
import org.geoserver.importer.Table;
import org.geoserver.importer.mosaic.Granule;
import org.geoserver.importer.mosaic.Mosaic;
import org.geoserver.importer.transform.AttributeRemapTransform;
import org.geoserver.importer.transform.AttributesToPointGeometryTransform;
import org.geoserver.importer.transform.CreateIndexTransform;
import org.geoserver.importer.transform.DateFormatTransform;
import org.geoserver.importer.transform.GdalAddoTransform;
import org.geoserver.importer.transform.GdalTranslateTransform;
import org.geoserver.importer.transform.GdalWarpTransform;
import org.geoserver.importer.transform.ImportTransform;
import org.geoserver.importer.transform.IntegerFieldToDateTransform;
import org.geoserver.importer.transform.ReprojectTransform;
import org.geoserver.importer.transform.TransformChain;
import org.geoserver.importer.transform.VectorTransformChain;
import org.geoserver.rest.PageInfo;
import org.geoserver.rest.RestletException;
import org.geotools.geometry.jts.ReferencedEnvelope;
import org.geotools.referencing.CRS;
import org.opengis.referencing.crs.CoordinateReferenceSystem;
import org.restlet.data.Status;

import com.thoughtworks.xstream.converters.MarshallingContext;
import com.thoughtworks.xstream.io.HierarchicalStreamWriter;


public class ImportJSONWriter {

    static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ");
    static {
        DATE_FORMAT.setTimeZone(TimeZone.getTimeZone("GMT"));
    }

    Importer importer;
    PageInfo page;
    FlushableJSONBuilder json;

    public ImportJSONWriter(Importer importer, PageInfo page) {
        this(importer, page, new ByteArrayOutputStream());
    }

    public ImportJSONWriter(Importer importer, PageInfo page, OutputStream out) {
        this(importer, page, new OutputStreamWriter(out));
    }

    public ImportJSONWriter(Importer importer, PageInfo page, Writer w) {
        this.importer = importer;
        this.page = page;
        this.json = new FlushableJSONBuilder(w);
    }

    public void contexts(Iterator<ImportContext> contexts, int expand) throws IOException {
        json.object().key("imports").array();
        while (contexts.hasNext()) {
            ImportContext context = contexts.next();
            context(context, false, expand);
        }
        json.endArray().endObject();
        json.flush();
    }

    public void context(ImportContext context, boolean top, int expand) throws IOException {
        if (top) {
            json.object().key("import");
        }

        json.object();
        json.key("id").value(context.getId());
        json.key("href").value(page.rootURI(pathTo(context)));
        json.key("state").value(context.getState());
        
        if (expand > 0) {
            json.key("archive").value(context.isArchive());
            if (context.getTargetWorkspace() != null) {
                json.key("targetWorkspace").value(toJSON(context.getTargetWorkspace()));
            }
            if (context.getTargetStore() != null) {
                json.key("targetStore");
                store(context.getTargetStore(), null, false, expand-1);

            }
    
            if (context.getData() != null) {
                json.key("data");
                data(context.getData(), context, expand-1);
            }
            tasks(context.getTasks(), false, expand-1);
        }

        json.endObject();

        if (top) {
            json.endObject();
        }
        json.flush();
    }

    public void tasks(List<ImportTask> tasks, boolean top, int expand) throws IOException {

        if (top) {
            json.object();
        }

        json.key("tasks").array();
        for (ImportTask task : tasks) {
            task(task, false, expand);
        }
        json.endArray();
        
        if (top) {
            json.endObject();
        }
        json.flush();
    }

    public void task(ImportTask task, boolean top, int expand) throws IOException {

        long id = task.getId();
        String href = page.rootURI(pathTo(task));
        if (top) {
            json.object().key("task");
        }
        json.object();
        json.key("id").value(id);
        json.key("href").value(href);
        json.key("state").value(task.getState());

        if (expand > 0) {
            json.key("updateMode").value(task.getUpdateMode().name());
    

            ImportData data = task.getData();
            if (data != null) {
                json.key("data");
                data(data, task, expand-1);
            }


            StoreInfo store = task.getStore();
            if (store != null) {
                json.key("target");
                store(store, task, false, expand-1);
            }

            json.key("progress").value(href + "/progress");

            LayerInfo layer = task.getLayer();
            if (layer != null) {

                layer.getResource().setCatalog(importer.getCatalog());

                json.key("layer");
                layer(task, false, expand-1);
            }

            if (task.getError() != null) {
                json.key("errorMessage").value(concatErrorMessages(task.getError()));
            }

            transformChain(task, false, expand-1);
            messages(task.getMessages());
        }
        
        json.endObject();
        if (top) {
            json.endObject();
        }

        json.flush();
    }

    void store(StoreInfo store, ImportTask task, boolean top, int expand) throws IOException {
            
        String type = store instanceof DataStoreInfo ? "dataStore" : 
                      store instanceof CoverageStoreInfo ? "coverageStore" : "store";

        json.object();
        if (task != null) {
            json.key("href").value(page.rootURI(pathTo(task) + "/target"));
        }

        if (expand > 0) {
            JSONObject obj = toJSON(store);
            json.key(type).value(obj.get(type));
        }
        else {
            json.key(type).object()
                .key("name").value(store.getName())
                .key("type").value(store.getType())
                .endObject();
        }

        json.endObject();
        json.flush();
    }

    void layer(ImportTask task, boolean top, int expand) throws IOException {

        if (top) {
            json.object().key("layer");
        }

        LayerInfo layer = task.getLayer();
        ResourceInfo r = layer.getResource();

        json.object()
            .key("name").value(layer.getName())
            .key("href").value(page.rootURI(pathTo(task) + "/layer"));
        
        if (expand > 0) {
            if (r.getTitle() != null) {
                json.key("title").value(r.getTitle());
            }
            if (r.getAbstract() != null) {
                json.key("abstract").value(r.getAbstract());
            }
            if (r.getDescription() != null) {
                json.key("description").value(r.getDescription());
            }
            json.key("originalName").value(task.getOriginalLayerName());
            if (r != null) {
                json.key("nativeName").value(r.getNativeName());
    
                if (r.getSRS() != null) {
                    json.key("srs").value(r.getSRS());
                }
                if (r.getNativeBoundingBox() != null) {
                    json.key("bbox");
                    bbox(json, r.getNativeBoundingBox());
                }
            }
            if (r instanceof FeatureTypeInfo) {
                featureType((FeatureTypeInfo) r);
            }
            StyleInfo s = layer.getDefaultStyle();
            if (s != null) {
                style(s, task, false, expand-1);
            }
        }

        json.endObject();
        if (top) {
            json.endObject();
        }
        json.flush();
    }

    void featureType(FeatureTypeInfo featureTypeInfo) throws IOException {
        json.key("attributes").array();
        List<AttributeTypeInfo> attributes = featureTypeInfo.attributes();
        for (int i = 0; i < attributes.size(); i++) {
            AttributeTypeInfo att = attributes.get(i);
            json.object();
            json.key("name").value(att.getName());
            json.key("binding").value(att.getBinding().getName());
            json.endObject();
        }
        json.endArray();
    }

    void style(StyleInfo style, ImportTask task, boolean top, int expand) throws IOException {
        
        if (top) {
            json.object();
        }

        String href = page.rootURI(pathTo(task) + "/layer/style");

        json.key("style");
        if (expand > 0) {
            JSONObject obj = toJSON(style).getJSONObject("style");
            obj.put("href", href);
            json.value(obj);
        }
        else {
            json.object();
            json.key("name").value(style.getName());
            json.key("href").value(href);
            json.endObject();
        }
        
        if (top) {
            json.endObject();
        }
    }

    void transformChain(ImportTask task, boolean top, int expand) throws IOException {

        if (top) {
            json.object();
        }

        TransformChain<? extends ImportTransform> txChain = task.getTransform();

        json.key("transformChain").object();
        json.key("type").value(txChain instanceof VectorTransformChain ? "vector" : "raster");

        json.key("transforms").array();

        if (txChain != null) {
            for (int i = 0; i < txChain.getTransforms().size(); i++) {
                transform(txChain.getTransforms().get(i), i, task, false, expand);
            }
        }

        json.endArray();
        json.endObject();

        if (top) {
            json.endObject();
        }
        
        json.flush();
    }

    public void transform(ImportTransform transform, int index, ImportTask task, boolean top, 
        int expand) throws IOException {
        json.object();
        json.key("type").value(transform.getClass().getSimpleName());
        json.key("href").value(page.rootURI(pathTo(task)+"/transform/" + index));
        if (expand > 0) {
            if (transform instanceof DateFormatTransform) {
                DateFormatTransform df = (DateFormatTransform) transform;
                json.key("field").value(df.getField());
                if (df.getDatePattern() != null) {
                    json.key("format").value(df.getDatePattern().dateFormat().toPattern());
                }
    
            } else if (transform instanceof IntegerFieldToDateTransform) {
                IntegerFieldToDateTransform df = (IntegerFieldToDateTransform) transform;
                json.key("field").value(df.getField());
            } else if (transform instanceof CreateIndexTransform) {
                CreateIndexTransform df = (CreateIndexTransform) transform;
                json.key("field").value(df.getField());
            } else if (transform instanceof AttributeRemapTransform) {
                AttributeRemapTransform art = (AttributeRemapTransform) transform;
                json.key("field").value(art.getField());
                json.key("target").value(art.getType().getName());
            } else if (transform.getClass() == AttributesToPointGeometryTransform.class) {
                AttributesToPointGeometryTransform atpgt = (AttributesToPointGeometryTransform) transform;
                json.key("latField").value(atpgt.getLatField());
                json.key("lngField").value(atpgt.getLngField());
            } else if (transform.getClass() == ReprojectTransform.class) {
                ReprojectTransform rt = (ReprojectTransform) transform;
                json.key("source").value(srs(rt.getSource()));
                json.key("target").value(srs(rt.getTarget()));
            } else if (transform.getClass().equals(GdalTranslateTransform.class)) {
                GdalTranslateTransform gtx = (GdalTranslateTransform) transform;
                List<String> options = gtx.getOptions();
                buildJsonOptions(json, "options", options);
            } else if (transform.getClass().equals(GdalWarpTransform.class)) {
                GdalWarpTransform gw = (GdalWarpTransform) transform;
                List<String> options = gw.getOptions();
                buildJsonOptions(json, "options", options);
            } else if (transform.getClass().equals(GdalAddoTransform.class)) {
                GdalAddoTransform gad = (GdalAddoTransform) transform;
                List<String> options = gad.getOptions();
                buildJsonOptions(json, "options", options);
                JSONBuilder arrayBuilder = json.key("levels").array();
                for (Integer level : gad.getLevels()) {
                    arrayBuilder.value(level);
                }
                arrayBuilder.endArray();
            } else {
                throw new IOException("Serializaiton of " + transform.getClass() + " not implemented");
            }
        }
        json.endObject();
        json.flush();
    }

    private void buildJsonOptions(FlushableJSONBuilder json, String key, List<String> options) {
        JSONBuilder arrayBuilder = json.key(key).array();
        for (String option : options) {
            arrayBuilder.value(option);
        }
        arrayBuilder.endArray();

    }

    void bbox(JSONBuilder json, ReferencedEnvelope bbox) {
        json.object()
            .key("minx").value(bbox.getMinX())
            .key("miny").value(bbox.getMinY())
            .key("maxx").value(bbox.getMaxX())
            .key("maxy").value(bbox.getMaxY());

        CoordinateReferenceSystem crs = bbox.getCoordinateReferenceSystem(); 
        if (crs != null) {
            json.key("crs").value(crs.toWKT());
        }

        json.endObject();
    }

    public void data(ImportData data, Object parent, int expand) throws IOException {
        if (data instanceof FileData) {
            if (data instanceof Directory) {
                if (data instanceof Mosaic) {
                    mosaic((Mosaic) data, parent ,expand);
                }
                else {
                    directory((Directory) data, parent, expand);
                }
            } else {
                file((FileData) data, parent, expand, false);
            }
        } else if (data instanceof Database) {
            database((Database) data, parent, expand);
        } else if (data instanceof Table) {
            table((Table)data, parent, expand);
        }
        json.flush();
    }

    public void file(FileData data, Object parent, int expand, boolean href) throws IOException {
        
        json.object();
        
        json.key("type").value("file");
        json.key("format").value(data.getFormat() != null ? data.getFormat().getName() : null);
        if (href) {
            json.key("href").value(page.rootURI(pathTo(data, parent)));
        }
        
        if (expand > 0) {
            json.key("location").value(data.getFile().getParentFile().getPath());
            if (data.getCharsetEncoding() != null) {
                json.key("charset").value(data.getCharsetEncoding());
            }
            fileContents(data, parent, expand);
            message(data);
        }
        else {
            json.key("file").value(data.getFile().getName());
        }

        json.endObject();
        json.flush();
    }

    void fileContents(FileData data, Object parent, int expand) throws IOException {

        String filename = data.getFile().getName();
        json.key("file").value(filename);
        json.key("href").value(page.rootURI(pathTo(data, parent)+"/files/"+filename));
        if (expand > 0) {
            if (data instanceof SpatialFile) {
                SpatialFile sf = (SpatialFile) data;
                json.key("prj").value(sf.getPrjFile() != null ? sf.getPrjFile().getName() : null);
                json.key("other").array();
                for (File supp : ((SpatialFile) data).getSuppFiles()) {
                    json.value(supp.getName());
                }
                json.endArray();
    
                if (sf instanceof Granule) {
                    Granule g = (Granule) sf;
                    if (g.getTimestamp() != null) {
                        json.key("timestamp").value(DATE_FORMAT.format(g.getTimestamp()));
                    }
                }
            }
        }
    }


    public void mosaic(Mosaic data, Object parent, int expand) 
        throws IOException {
        directory(data, "mosaic", parent, expand);
    }

    public void directory(Directory data, Object parent, int expand) throws IOException {
        directory(data, "directory", parent, expand);
    }

    public void directory(Directory data, String typeName, Object parent, int expand) 
        throws IOException {

        json.object();
        json.key("type").value(typeName);
        if (data.getFormat() != null) {
            json.key("format").value(data.getFormat().getName());
        }

        json.key("location").value(data.getFile().getPath());
        json.key("href").value(page.rootURI(pathTo(data, parent)));

        if (expand > 0) {
            if (data.getCharsetEncoding() != null) {
                json.key("charset").value(data.getCharsetEncoding());
            }

            json.key("files");
            files(data, parent, false, expand-1);
            message(data);
        }
        json.endObject();
        json.flush();
    }

    public void files(Directory data, Object parent, boolean top, int expand) throws IOException {

        if (top) {
            json.object().key("files");
        }
        json.array();
        for (FileData file : data.getFiles()) {
            json.object();
            fileContents(file, parent, expand-1);
            json.endObject();
        }
        json.endArray();
        if (top) {
            json.endObject();
        }
        json.flush();
    }

    public void database(Database data, Object parent, int expand) throws IOException {
        json.object();
        json.key("type").value("database");
        json.key("format").value(data.getFormat() != null ? data.getFormat().getName() : null);
        json.key("href").value(page.rootURI(pathTo(data, parent)));

        if (expand > 0) {
            json.key("parameters").object();
            for (Map.Entry e : data.getParameters().entrySet()) {
                json.key((String) e.getKey()).value(e.getValue());
            }
    
            json.endObject();
            
            json.key("tables").array();
            for (Table t : data.getTables()) {
                json.value(t.getName());
            }
    
            message(data);
            json.endArray();
        }

        json.endObject();
    }

    void table(Table data, Object parent, int expand) throws IOException {
        json.object();
        json.key("type").value("table");
        json.key("name").value(data.getName());
        json.key("format").value(data.getFormat() != null ? data.getFormat().getName() : null);
        json.key("href").value(page.rootURI(pathTo(data, parent)));
        json.endObject();
    }

    void message(ImportData data) throws IOException {
        if (data.getMessage() != null) {
            json.key("message").value(data.getMessage());
        }
    }

    void messages(List<LogRecord> records) {
        if (!records.isEmpty()) {
            json.key("messages");
            json.array();
            for (int i = 0; i < records.size(); i++) {
                LogRecord record = records.get(i);
                json.object();
                json.key("level").value(record.getLevel().toString());
                json.key("message").value(record.getMessage());
                json.endObject();
            }
            json.endArray();
        }
    }

    String concatErrorMessages(Throwable ex) {
        StringBuilder buf = new StringBuilder();
        while (ex != null) {
            if (buf.length() > 0) {
                buf.append('\n');
            }
            if (ex.getMessage() != null) {
                buf.append(ex.getMessage());
            }
            ex = ex.getCause();
        }
        return buf.toString();
    }

    FlushableJSONBuilder builder(OutputStream out) {
        return new FlushableJSONBuilder(new OutputStreamWriter(out));
    }

    JSONObject toJSON(Object o) throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        toJSON(o, out);
        return (JSONObject) JSONSerializer.toJSON(new String(out.toByteArray()));
    }

    void toJSON(Object o, OutputStream out) throws IOException {
        toJSON(o, out, null);
    }
    
    void toJSON(Object o, OutputStream out, Callback callback) throws IOException {
        XStreamPersister xp = persister();
        if (callback != null) {
            xp.setCallback(callback);
        }
        xp.save(o, out);
        out.flush();
    }

    XStreamPersister persister() {
        XStreamPersister xp = 
            importer.initXStreamPersister(new XStreamPersisterFactory().createJSONPersister());
        
        xp.setReferenceByName(true);
        xp.setExcludeIds();


        xp.setHideFeatureTypeAttributes();

        xp.setCallback(new XStreamPersister.Callback() {

            @Override
            protected void postEncodeFeatureType(FeatureTypeInfo ft,
                    HierarchicalStreamWriter writer, MarshallingContext context) {
                try {
                    writer.startNode("attributes");
                    context.convertAnother(ft.attributes());
                    writer.endNode();
                } catch (IOException e) {
                    throw new RuntimeException("Could not get native attributes", e);
                }
            }
        });
        return xp;
    }

    String srs(CoordinateReferenceSystem crs) {
        return CRS.toSRS(crs);
    }

    static String pathTo(ImportContext context) {
        return "/imports/" + context.getId();
    }

    static String pathTo(ImportTask task) {
        return pathTo(task.getContext()) +  "/tasks/" + task.getId();
    }

    String pathTo(Object parent) {
        if (parent instanceof ImportContext) {
            return pathTo((ImportContext)parent);
        }
        else if (parent instanceof ImportTask) {
            return pathTo((ImportTask)parent);
        }
        else {
            throw new IllegalArgumentException("Don't recognize: " + parent);
        }
    }

    String pathTo(ImportData data, Object parent) {
        return pathTo(parent) + "/data";
    }

    static RestletException badRequest(String error) {
        JSONObject errorResponse = new JSONObject();
        JSONArray errors = new JSONArray();
        errors.add(error);
        errorResponse.put("errors", errors);
        
        JSONRepresentation rep = new JSONRepresentation(errorResponse);
        return new RestletException(rep, Status.CLIENT_ERROR_BAD_REQUEST);
    }

    public static class FlushableJSONBuilder extends JSONBuilder {

        public FlushableJSONBuilder(Writer w) {
            super(w);
        }

        public void flush() throws IOException {
            writer.flush();
        }
    }
}

<code block>

package org.geoserver.importer.rest;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;

import net.sf.json.JSONArray;
import net.sf.json.JSONObject;

import org.apache.commons.io.IOUtils;
import org.geoserver.catalog.CatalogFactory;
import org.geoserver.catalog.DataStoreInfo;
import org.geoserver.catalog.LayerInfo;
import org.geoserver.catalog.ResourceInfo;
import org.geoserver.catalog.StoreInfo;
import org.geoserver.catalog.StyleInfo;
import org.geoserver.catalog.WorkspaceInfo;
import org.geoserver.config.util.XStreamPersister;
import org.geoserver.importer.Archive;
import org.geoserver.importer.Database;
import org.geoserver.importer.Directory;
import org.geoserver.importer.FileData;
import org.geoserver.importer.ImportContext;
import org.geoserver.importer.ImportContext.State;
import org.geoserver.importer.ImportData;
import org.geoserver.importer.ImportTask;
import org.geoserver.importer.Importer;
import org.geoserver.importer.UpdateMode;
import org.geoserver.importer.ValidationException;
import org.geoserver.importer.mosaic.Mosaic;
import org.geoserver.importer.mosaic.TimeMode;
import org.geoserver.importer.transform.AttributeRemapTransform;
import org.geoserver.importer.transform.AttributesToPointGeometryTransform;
import org.geoserver.importer.transform.CreateIndexTransform;
import org.geoserver.importer.transform.DateFormatTransform;
import org.geoserver.importer.transform.GdalAddoTransform;
import org.geoserver.importer.transform.GdalTranslateTransform;
import org.geoserver.importer.transform.GdalWarpTransform;
import org.geoserver.importer.transform.ImportTransform;
import org.geoserver.importer.transform.IntegerFieldToDateTransform;
import org.geoserver.importer.transform.RasterTransformChain;
import org.geoserver.importer.transform.ReprojectTransform;
import org.geoserver.importer.transform.TransformChain;
import org.geoserver.importer.transform.VectorTransformChain;
import org.geotools.geometry.jts.ReferencedEnvelope;
import org.geotools.referencing.CRS;
import org.opengis.referencing.crs.CoordinateReferenceSystem;

public class ImportJSONReader {

    Importer importer;
    JSONObject json;

    public ImportJSONReader(Importer importer, String in) throws IOException {
        this(importer, new ByteArrayInputStream(in.getBytes()));
    }

    public ImportJSONReader(Importer importer, InputStream in) throws IOException {
        this.importer = importer;
        json = parse(in);
    }

    public ImportJSONReader(Importer importer, JSONObject obj) {
        this.importer = importer;
        json = obj;
    }

    public JSONObject object() {
        return json;
    }

    public ImportContext context() throws IOException {
        ImportContext context = null;
        if (json.has("import")) {
            context = new ImportContext();
            
            json = json.getJSONObject("import");
            if (json.has("id")) {
                context.setId(json.getLong("id"));
            }
            if (json.has("state")) {
                context.setState(State.valueOf(json.getString("state")));
            }
            if (json.has("user")) {
                context.setUser(json.getString("user"));
            }
            if (json.has("archive")) {
                context.setArchive(json.getBoolean("archive"));
            }
            if (json.has("targetWorkspace")) {
                context.setTargetWorkspace(
                    fromJSON(json.getJSONObject("targetWorkspace"), WorkspaceInfo.class));
            }
            if (json.has("targetStore")) {
                context.setTargetStore(
                    fromJSON(json.getJSONObject("targetStore"), StoreInfo.class));
            }
            if (json.has("data")) {
                context.setData(data(json.getJSONObject("data")));
            }
        }
        return context;
    }

    public LayerInfo layer() throws IOException {
        return layer(json);
    }

    LayerInfo layer(JSONObject json) throws IOException {
        CatalogFactory f = importer.getCatalog().getFactory();

        if (json.has("layer")) {
            json = json.getJSONObject("layer");
        }


        ResourceInfo r = f.createFeatureType();
        if (json.has("name")) {
            r.setName(json.getString("name"));
        }
        if (json.has("nativeName")) {
            r.setNativeName(json.getString("nativeName"));
        }
        if (json.has("srs")) {
            r.setSRS(json.getString("srs"));
            try {
                r.setNativeCRS(CRS.decode(json.getString("srs")));
            }
            catch(Exception e) {

            }
            
        }
        if (json.has("bbox")) {
            r.setNativeBoundingBox(bbox(json.getJSONObject("bbox")));
        }
        if (json.has("title")) {
            r.setTitle(json.getString("title"));
        }
        if (json.has("abstract")) {
            r.setAbstract(json.getString("abstract"));
        }
        if (json.has("description")) {
            r.setDescription(json.getString("description"));
        }

        LayerInfo l = f.createLayer();
        l.setResource(r);

        
        if (json.has("style")) {
            JSONObject sobj = new JSONObject();
            sobj.put("defaultStyle", json.get("style"));

            JSONObject lobj = new JSONObject();
            lobj.put("layer", sobj);

            LayerInfo tmp = fromJSON(lobj, LayerInfo.class);
            if (tmp.getDefaultStyle() != null) {
                l.setDefaultStyle(tmp.getDefaultStyle());
            }
            else {
                sobj = new JSONObject();
                sobj.put("style", json.get("style"));
                
                l.setDefaultStyle(fromJSON(sobj, StyleInfo.class));
            }

        }
        return l;
    }

    public ImportTask task() throws IOException {

        if (json.has("task")) {
            json =  json.getJSONObject("task");
        }

        ImportTask task = new ImportTask();

        if (json.has("id")) {
            task.setId(json.getInt("id"));
        }
        if (json.has("updateMode")) {
            task.setUpdateMode(UpdateMode.valueOf(json.getString("updateMode").toUpperCase()));
        } else {


            task.setUpdateMode(null);
        }

        JSONObject data = null;
        if (json.has("data")) {
            data = json.getJSONObject("data");
        }
        else if (json.has("source")) { 
            data = json.getJSONObject("source");
        }

        if (data != null) {

            if (data.has("charset")) {
                if (task.getData() == null) {
                    task.setData(new ImportData.TransferObject());
                }
                task.getData().setCharsetEncoding(data.getString("charset"));
            }
        }
        if (json.has("target")) {
            task.setStore(fromJSON(json.getJSONObject("target"), StoreInfo.class));
        }

        LayerInfo layer = null; 
        if (json.has("layer")) {
            layer = layer(json.getJSONObject("layer"));
        } else {
            layer = importer.getCatalog().getFactory().createLayer();
        }
        task.setLayer(layer);

        if (json.has("transformChain")) {
            task.setTransform(transformChain(json.getJSONObject("transformChain")));
        }

        return task;
    }

    TransformChain transformChain(JSONObject json) throws IOException {
        String type = json.getString("type");
        TransformChain chain = null;
        if ("vector".equalsIgnoreCase(type) || "VectorTransformChain".equalsIgnoreCase(type)) {
            chain = new VectorTransformChain();
        } else if ("raster".equalsIgnoreCase(type) || "RasterTransformChain".equalsIgnoreCase(type)) {
            chain = new RasterTransformChain();
        } else {
            throw new IOException("Unable to parse transformChain of type " + type);
        }
        JSONArray transforms = json.getJSONArray("transforms");
        for (int i = 0; i < transforms.size(); i++) {
            chain.add(transform(transforms.getJSONObject(i)));
        }
        return chain;
    }

    public ImportTransform transform() throws IOException {
        return transform(json);
    }

    ImportTransform transform(JSONObject json) throws IOException {
        ImportTransform transform;
        String type = json.getString("type");
        if ("DateFormatTransform".equalsIgnoreCase(type)) {
            transform = new DateFormatTransform(json.getString("field"), json.optString("format", null));
        } else if ("IntegerFieldToDateTransform".equalsIgnoreCase(type)) {
            transform = new IntegerFieldToDateTransform(json.getString("field"));
        } else if ("CreateIndexTransform".equalsIgnoreCase(type)) {
            transform = new CreateIndexTransform(json.getString("field"));
        } else if ("AttributeRemapTransform".equalsIgnoreCase(type)) {
            Class clazz;
            try {
                clazz = Class.forName( json.getString("target") );
            } catch (ClassNotFoundException cnfe) {
                throw new ValidationException("unable to locate target class " + json.getString("target"));
            }
            transform = new AttributeRemapTransform(json.getString("field"), clazz);
        } else if ("AttributesToPointGeometryTransform".equalsIgnoreCase(type)) {
            String latField = json.getString("latField");
            String lngField = json.getString("lngField");
            transform = new AttributesToPointGeometryTransform(latField, lngField);
        } else if ("ReprojectTransform".equalsIgnoreCase(type)){
            CoordinateReferenceSystem source = json.has("source") ? crs(json.getString("source")) : null;
            CoordinateReferenceSystem target = json.has("target") ? crs(json.getString("target")) : null;

            try {
                transform = new ReprojectTransform(source, target);
            } 
            catch(Exception e) {
                throw new ValidationException("Error parsing reproject transform", e);
            }
        } else if ("GdalTranslateTransform".equalsIgnoreCase(type)) {
            List<String> options = getOptions(json);
            transform = new GdalTranslateTransform(options);
        } else if ("GdalWarpTransform".equalsIgnoreCase(type)) {
            List<String> options = getOptions(json);
            transform = new GdalWarpTransform(options);
        } else if ("GdalAddoTransform".equalsIgnoreCase(type)) {
            List<String> options = getOptions(json);
            JSONArray array = json.getJSONArray("levels");
            List<Integer> levels = new ArrayList<>();
            for (int i = 0; i < array.size(); i++) {
                int level = array.getInt(i);
                levels.add(level);
            }
            transform = new GdalAddoTransform(options, levels);
        } else {
            throw new ValidationException("Invalid transform type '" + type + "'");
        }
        return transform;
    }

    List<String> getOptions(JSONObject json) {
        JSONArray array = json.getJSONArray("options");
        List<String> options = new ArrayList<>();
        for (int i = 0; i < array.size(); i++) {
            String option = array.getString(i);
            options.add(option);
        }
        return options;
    }

    public ImportData data() throws IOException {
        return data(json);
    }

    ImportData data(JSONObject json) throws IOException {
        String type = json.getString("type");
        if (type == null) {
            throw new IOException("Data object must specify 'type' property");
        }

        if ("file".equalsIgnoreCase(type)) {
            return file(json);
        }
        else if("directory".equalsIgnoreCase(type)) {
            return directory(json);
        }
        else if("mosaic".equalsIgnoreCase(type)) {
            return mosaic(json);
        }
        else if("archive".equalsIgnoreCase(type)) {
            return archive(json);
        }
        else if ("database".equalsIgnoreCase(type)) {
            return database(json);
        }
        else {
            throw new IllegalArgumentException("Unknown data type: " + type);
        }
    }

    FileData file(JSONObject json) throws IOException {
        if (json.has("file")) {

            String file = json.getString("file");
            return FileData.createFromFile(new File(file));

        }
        else {

            return new FileData((File)null);
        }
    }

    Mosaic mosaic(JSONObject json) throws IOException {
        Mosaic m = new Mosaic(json.has("location") ?  new File(json.getString("location")) : 
            Directory.createNew(importer.getUploadRoot()).getFile());
        if (json.has("name")) {
            m.setName(json.getString("name"));
        }
        if (json.containsKey("time")) {
            JSONObject time = json.getJSONObject("time");
            if (!time.containsKey("mode")) {
                throw new IllegalArgumentException("time object must specific mode property as " +
                    "one of " + TimeMode.values());
            }

            m.setTimeMode(TimeMode.valueOf(time.getString("mode").toUpperCase()));
            m.getTimeHandler().init(time);
        }
        return m;
    }

    Archive archive(JSONObject json) throws IOException {
        throw new UnsupportedOperationException("TODO: implement");
    }

    public Directory directory() throws IOException {
        return directory(json);
    }

    Directory directory(JSONObject json) throws IOException {
        if (json.has("location")) {
            return new Directory(new File(json.getString("location")));
        }
        else {
            return Directory.createNew(importer.getUploadRoot());
        }
    }

    Database database(JSONObject json) throws IOException {
        throw new UnsupportedOperationException("TODO: implement");
    }
    
    ReferencedEnvelope bbox(JSONObject json) {
        CoordinateReferenceSystem crs = null;
        if (json.has("crs")) {
            crs = (CoordinateReferenceSystem) 
                new XStreamPersister.CRSConverter().fromString(json.getString("crs"));
        }

        return new ReferencedEnvelope(json.getDouble("minx"), json.getDouble("maxx"), 
            json.getDouble("miny"), json.getDouble("maxy"), crs);
    }

    CoordinateReferenceSystem crs(String srs) {
        try {
            return CRS.decode(srs);
        } catch (Exception e) {
            throw new RuntimeException("Failing parsing srs: " + srs, e);
        }
    }

    JSONObject parse(InputStream in) throws IOException {
        ByteArrayOutputStream bout = new ByteArrayOutputStream();
        IOUtils.copy(in, bout);
        return JSONObject.fromObject(new String(bout.toByteArray()));
    }

    Object read(InputStream in) throws IOException {
        Object result = null;
        JSONObject json = parse(in);

        if (json.containsKey("target")) {
            result = fromJSON(json.getJSONObject("target"), DataStoreInfo.class);
        }
        return result;
    }

    <T> T fromJSON(JSONObject json, Class<T> clazz) throws IOException {
        XStreamPersister xp = importer.createXStreamPersisterJSON();
        return xp.load(new ByteArrayInputStream(json.toString().getBytes()), clazz);
    }

    <T> T fromJSON(Class<T> clazz) throws IOException {
        return fromJSON(json, clazz);
    }
}

<code block>

package org.geoserver.importer.rest;

import java.util.Arrays;

import org.geoserver.importer.transform.GdalAddoTransform;
import org.geoserver.importer.transform.GdalTranslateTransform;
import org.geoserver.importer.transform.GdalWarpTransform;
import org.junit.Test;

public class GdalTransformTest extends TransformTestSupport {

    @Test
    public void testGdalTransformJSON() throws Exception {
        doJSONTest(new GdalTranslateTransform(Arrays.asList("-co", "blockxsize=128", "-co",
                "blockysize=128")));
    }

    @Test
    public void testGdalWarpJSON() throws Exception {
        doJSONTest(new GdalWarpTransform(Arrays.asList("-t_srs", "EPSG:4326")));
    }

    @Test
    public void testAddoTransformJSON() throws Exception {
        doJSONTest(new GdalAddoTransform(Arrays.asList("-r", "average"), Arrays.asList(2, 4, 8)));
    }

}

<code block>

package org.geoserver.catalog;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.measure.unit.Unit;
import javax.media.jai.PlanarImage;

import org.geoserver.catalog.impl.FeatureTypeInfoImpl;
import org.geoserver.catalog.impl.ModificationProxy;
import org.geoserver.catalog.impl.ResourceInfoImpl;
import org.geoserver.catalog.impl.StoreInfoImpl;
import org.geoserver.catalog.impl.StyleInfoImpl;
import org.geoserver.catalog.impl.WMSStoreInfoImpl;
import org.geoserver.data.util.CoverageStoreUtils;
import org.geoserver.data.util.CoverageUtils;
import org.geoserver.ows.util.OwsUtils;
import org.geotools.coverage.Category;
import org.geotools.coverage.GridSampleDimension;
import org.geotools.coverage.grid.GridCoverage2D;
import org.geotools.coverage.grid.GridEnvelope2D;
import org.geotools.coverage.grid.GridGeometry2D;
import org.geotools.coverage.grid.io.AbstractGridFormat;
import org.geotools.coverage.grid.io.GridCoverage2DReader;
import org.geotools.data.FeatureSource;
import org.geotools.data.ows.CRSEnvelope;
import org.geotools.data.ows.Layer;
import org.geotools.factory.GeoTools;
import org.geotools.feature.FeatureTypes;
import org.geotools.gce.imagemosaic.ImageMosaicFormat;
import org.geotools.geometry.GeneralEnvelope;
import org.geotools.geometry.jts.ReferencedEnvelope;
import org.geotools.referencing.CRS;
import org.geotools.referencing.CRS.AxisOrder;
import org.geotools.referencing.crs.DefaultGeographicCRS;
import org.geotools.resources.image.ImageUtilities;
import org.geotools.util.NumberRange;
import org.geotools.util.Version;
import org.geotools.util.logging.Logging;
import org.opengis.coverage.grid.Format;
import org.opengis.coverage.grid.GridEnvelope;
import org.opengis.feature.type.FeatureType;
import org.opengis.feature.type.GeometryDescriptor;
import org.opengis.feature.type.Name;
import org.opengis.feature.type.PropertyDescriptor;
import org.opengis.metadata.Identifier;
import org.opengis.parameter.ParameterValueGroup;
import org.opengis.referencing.FactoryException;
import org.opengis.referencing.crs.CoordinateReferenceSystem;
import org.opengis.referencing.crs.GeographicCRS;
import org.opengis.referencing.datum.PixelInCell;
import org.opengis.referencing.operation.MathTransform;

import com.vividsolutions.jts.geom.LineString;
import com.vividsolutions.jts.geom.MultiLineString;
import com.vividsolutions.jts.geom.MultiPoint;
import com.vividsolutions.jts.geom.MultiPolygon;
import com.vividsolutions.jts.geom.Point;
import com.vividsolutions.jts.geom.Polygon;


public class CatalogBuilder {

    static final Logger LOGGER = Logging.getLogger(CatalogBuilder.class);


    Catalog catalog;


    WorkspaceInfo workspace;


    StoreInfo store;

    public CatalogBuilder(Catalog catalog) {
        this.catalog = catalog;
    }


    public void setWorkspace(WorkspaceInfo workspace) {
        this.workspace = workspace;
    }


    public void setStore(StoreInfo store) {
        this.store = store;
    }


    public void updateWorkspace(WorkspaceInfo original, WorkspaceInfo update) {
        update(original, update, WorkspaceInfo.class);
    }


    public void updateNamespace(NamespaceInfo original, NamespaceInfo update) {
        update(original, update, NamespaceInfo.class);
    }


    public void updateDataStore(DataStoreInfo original, DataStoreInfo update) {
        update(original, update, DataStoreInfo.class);
    }


    public void updateWMSStore(WMSStoreInfo original, WMSStoreInfo update) {
        update(original, update, WMSStoreInfo.class);
    }


    public void updateCoverageStore(CoverageStoreInfo original, CoverageStoreInfo update) {
        update(original, update, CoverageStoreInfo.class);
    }


    public void updateFeatureType(FeatureTypeInfo original, FeatureTypeInfo update) {
        update(original, update, FeatureTypeInfo.class);
    }


    public void updateCoverage(CoverageInfo original, CoverageInfo update) {
        update(original, update, CoverageInfo.class);
    }


    public void updateWMSLayer(WMSLayerInfo original, WMSLayerInfo update) {
        update(original, update, WMSLayerInfo.class);
    }


    public void updateLayer(LayerInfo original, LayerInfo update) {
        update(original, update, LayerInfo.class);
    }


    public void updateLayerGroup(LayerGroupInfo original, LayerGroupInfo update) {
        update(original, update, LayerGroupInfo.class);
    }


    public void updateStyle(StyleInfo original, StyleInfo update) {
        update(original, update, StyleInfo.class);
    }


    <T> void update(T original, T update, Class<T> clazz) {
        OwsUtils.copy(update, original, clazz);
    }


    public DataStoreInfo buildDataStore(String name) {
        DataStoreInfo info = catalog.getFactory().createDataStore();
        buildStore(info, name);

        return info;
    }


    public CoverageStoreInfo buildCoverageStore(String name) {
        CoverageStoreInfo info = catalog.getFactory().createCoverageStore();
        buildStore(info, name);

        return info;
    }


    public WMSStoreInfo buildWMSStore(String name) throws IOException {
        WMSStoreInfo info = catalog.getFactory().createWebMapServer();
        buildStore(info, name);
        info.setType("WMS");
        info.setMaxConnections(WMSStoreInfoImpl.DEFAULT_MAX_CONNECTIONS);
        info.setConnectTimeout(WMSStoreInfoImpl.DEFAULT_CONNECT_TIMEOUT);
        info.setReadTimeout(WMSStoreInfoImpl.DEFAULT_READ_TIMEOUT);

        return info;
    }


    void buildStore(StoreInfo info, String name) {

        info.setName(name);
        info.setEnabled(true);


        if (workspace != null) {
            info.setWorkspace(workspace);
        } else {
            info.setWorkspace(catalog.getDefaultWorkspace());
        }
    }


    public FeatureTypeInfo buildFeatureType(Name typeName) throws Exception {
        if (store == null || !(store instanceof DataStoreInfo)) {
            throw new IllegalStateException("Data store not set.");
        }

        DataStoreInfo dstore = (DataStoreInfo) store;
        return buildFeatureType(dstore.getDataStore(null).getFeatureSource(typeName));
    }


    public FeatureTypeInfo buildFeatureType(FeatureSource featureSource) {
        if (store == null || !(store instanceof DataStoreInfo)) {
            throw new IllegalStateException("Data store not set.");
        }

        FeatureType featureType = featureSource.getSchema();

        FeatureTypeInfo ftinfo = catalog.getFactory().createFeatureType();
        ftinfo.setStore(store);
        ftinfo.setEnabled(true);


        Name name = featureSource.getName();
        if (name == null) {
            name = featureType.getName();
        }
        ftinfo.setNativeName(name.getLocalPart());
        ftinfo.setName(name.getLocalPart());

        WorkspaceInfo workspace = store.getWorkspace();
        NamespaceInfo namespace = catalog.getNamespaceByPrefix(workspace.getName());
        if (namespace == null) {
            namespace = catalog.getDefaultNamespace();
        }

        ftinfo.setNamespace(namespace);

        CoordinateReferenceSystem crs = featureType.getCoordinateReferenceSystem();
        if (crs == null && featureType.getGeometryDescriptor() != null) {
            crs = featureType.getGeometryDescriptor().getCoordinateReferenceSystem();
        }
        ftinfo.setNativeCRS(crs);


        try {
            lookupSRS(ftinfo, false);
        } catch (Exception e) {
            LOGGER.log(Level.WARNING, "SRS lookup failed", e);
        }
        setupProjectionPolicy(ftinfo);


        try {
            setupMetadata(ftinfo, featureSource);
        } catch (IOException e) {
            LOGGER.log(Level.WARNING, "Metadata lookup failed", e);
        }
        
        return ftinfo;
    }


    public void setupProjectionPolicy(ResourceInfo rinfo) {
        if (rinfo.getSRS() != null) {
            rinfo.setProjectionPolicy(ProjectionPolicy.FORCE_DECLARED);
        } else {
            rinfo.setProjectionPolicy(ProjectionPolicy.NONE);
        }
    }


    public void setupBounds(FeatureTypeInfo ftinfo, FeatureSource featureSource) throws IOException {
        doSetupBounds(ftinfo, featureSource);
    }


    public void setupBounds(CoverageInfo cinfo, GridCoverage2DReader coverageReader) 
        throws IOException {
        doSetupBounds(cinfo, coverageReader);
    }


    public void setupBounds(ResourceInfo rinfo) throws IOException {
        doSetupBounds(rinfo, null);
    }


    void doSetupBounds(ResourceInfo rinfo, Object data) throws IOException {

        if (rinfo.getNativeBoundingBox() == null) {
            ReferencedEnvelope bounds = getNativeBounds(rinfo, data);
            rinfo.setNativeBoundingBox(bounds);
        }


        rinfo.setLatLonBoundingBox(getLatLonBounds(rinfo.getNativeBoundingBox(), rinfo.getCRS()));
    }


    public void setupMetadata(FeatureTypeInfo ftinfo, FeatureSource featureSource) 
        throws IOException {

        org.geotools.data.ResourceInfo rinfo = null;
        try {
            rinfo = featureSource.getInfo();
        }
        catch(Exception ignore) {
            if (LOGGER.isLoggable(Level.FINE)) {
                LOGGER.log(Level.FINE, "Unable to get resource info from feature source", ignore);
            }
        }

        if (ftinfo.getTitle() == null) {
            ftinfo.setTitle(rinfo != null ? rinfo.getTitle() : ftinfo.getName());
        }
        if (rinfo != null && ftinfo.getDescription() == null) {
            ftinfo.setDescription(rinfo.getDescription());
        }
        if (rinfo != null && (ftinfo.getKeywords() == null || ftinfo.getKeywords().isEmpty())) {
            if (rinfo.getKeywords() != null) {
                if (ftinfo.getKeywords() == null) {
                    ((FeatureTypeInfoImpl)ftinfo).setKeywords(new ArrayList());
                }
                for (String kw : rinfo.getKeywords()) {
                    if (kw == null || "".equals(kw.trim())) {
                        LOGGER.fine("Empty keyword ignored");
                        continue;
                    }
                    ftinfo.getKeywords().add(new Keyword(kw));
                }
            }
        }
    }


    public ReferencedEnvelope getLatLonBounds(ReferencedEnvelope nativeBounds,
            CoordinateReferenceSystem declaredCRS) throws IOException {
        if (nativeBounds != null && declaredCRS != null) {

            if (!CRS.equalsIgnoreMetadata(DefaultGeographicCRS.WGS84, declaredCRS)) {

                try {
                    ReferencedEnvelope bounds = new ReferencedEnvelope(nativeBounds, declaredCRS);
                    return bounds.transform(DefaultGeographicCRS.WGS84, true);
                } catch (Exception e) {
                    throw (IOException) new IOException("transform error").initCause(e);
                }
            } else {
                return new ReferencedEnvelope(nativeBounds, DefaultGeographicCRS.WGS84);
            }
        }
        return null;
    }


    public ReferencedEnvelope getNativeBounds(ResourceInfo rinfo) throws IOException {
        return getNativeBounds(rinfo, null);
    }


    ReferencedEnvelope getNativeBounds(ResourceInfo rinfo, Object data) throws IOException {
        ReferencedEnvelope bounds = null;
        if (rinfo instanceof FeatureTypeInfo) {
            FeatureTypeInfo ftinfo = (FeatureTypeInfo) rinfo;


            if (data instanceof FeatureSource) {
                bounds = ((FeatureSource)data).getBounds();
            }
            else {
                bounds = ftinfo.getFeatureSource(null, null).getBounds();
            }



            CoordinateReferenceSystem crs = ftinfo.getNativeCRS();
            if (bounds != null && bounds.getCoordinateReferenceSystem() == null && crs != null) {
                bounds = new ReferencedEnvelope(bounds, crs);
            }

            if (bounds != null) {

                double expandBy = 1; 
                if (bounds.getCoordinateReferenceSystem() instanceof GeographicCRS) {
                    expandBy = 0.0001;
                }
                if (bounds.getWidth() == 0 || bounds.getHeight() == 0) {
                    bounds.expandBy(expandBy);
                }
            }

        } else if (rinfo instanceof CoverageInfo) {


            CoverageInfo cinfo = (CoverageInfo) rinfo;            
            GridCoverage2DReader reader = null;
            if (data instanceof GridCoverage2DReader) {
                reader = (GridCoverage2DReader) data;
            }
            else {
                reader = (GridCoverage2DReader) 
                    cinfo.getGridCoverageReader(null, GeoTools.getDefaultHints());
            }


            bounds = new ReferencedEnvelope(reader.getOriginalEnvelope());
           
        } else if(rinfo instanceof WMSLayerInfo) {


            WMSLayerInfo rebuilt = buildWMSLayer(rinfo.getStore(), rinfo.getNativeName());
            bounds = rebuilt.getNativeBoundingBox();
        }


        if (rinfo.getProjectionPolicy() == ProjectionPolicy.REPROJECT_TO_DECLARED && bounds != null) {
            try {
                bounds = bounds.transform(rinfo.getCRS(), true);
            } catch (Exception e) {
                throw (IOException) new IOException("transform error").initCause(e);
            }
        }

        return bounds;
    }


    public void lookupSRS(FeatureTypeInfo ftinfo, boolean extensive) throws IOException {
        lookupSRS(ftinfo, null, extensive);
    }


    public void lookupSRS(FeatureTypeInfo ftinfo, FeatureSource data, boolean extensive) 
            throws IOException {
        CoordinateReferenceSystem crs = ftinfo.getNativeCRS();
        if (crs == null) {
            if (data != null) {
                crs = data.getSchema().getCoordinateReferenceSystem();
            }
            else {
                crs = ftinfo.getFeatureType().getCoordinateReferenceSystem();
            }
        }
        if (crs != null) {
            try {
                Integer code = CRS.lookupEpsgCode(crs, extensive);
                if (code != null)
                    ftinfo.setSRS("EPSG:" + code);
            } catch (FactoryException e) {
                throw (IOException) new IOException().initCause(e);
            }
        }
    }


    private void initResourceInfo(ResourceInfo resInfo) throws Exception {

    	if (resInfo.getNativeName() == null && resInfo.getName() != null) {
    		resInfo.setNativeName(resInfo.getName());
    	}
    	if (resInfo.getNativeName() != null && resInfo.getName() == null) {
    		resInfo.setName(resInfo.getNativeName());
    	}
    }


    public void initFeatureType(FeatureTypeInfo featureType) throws Exception {
        if (featureType.getCatalog() == null) {
            featureType.setCatalog(catalog);
        }

        initResourceInfo(featureType);


        if (featureType.getSRS() == null) {
            lookupSRS(featureType, true);
        }
        if (featureType.getProjectionPolicy() == null) {
            setupProjectionPolicy(featureType);
        }


        CoordinateReferenceSystem crs = featureType.getCRS();
        if (featureType.getLatLonBoundingBox() == null
                && featureType.getNativeBoundingBox() == null) {

            setupBounds(featureType);
        } else if (featureType.getLatLonBoundingBox() == null) {

            setupBounds(featureType);
        } else if (featureType.getNativeBoundingBox() == null && crs != null) {

            ReferencedEnvelope boundsLatLon = featureType.getLatLonBoundingBox();
            featureType.setNativeBoundingBox(boundsLatLon.transform(crs, true));
        }
    }


    public void initWMSLayer(WMSLayerInfo wmsLayer) throws Exception {
        wmsLayer.setCatalog(catalog);

        initResourceInfo(wmsLayer);
        OwsUtils.resolveCollections(wmsLayer);


        WMSLayerInfo full = buildWMSLayer(store, wmsLayer.getNativeName());


        if (wmsLayer.getSRS() == null) {
            wmsLayer.setSRS(full.getSRS());
        }
        if (wmsLayer.getNativeCRS() == null) {
            wmsLayer.setNativeCRS(full.getNativeCRS());
        }
        if (wmsLayer.getProjectionPolicy() == null) {
            wmsLayer.setProjectionPolicy(full.getProjectionPolicy());
        }


        if (wmsLayer.getLatLonBoundingBox() == null
                && wmsLayer.getNativeBoundingBox() == null) {

            wmsLayer.setLatLonBoundingBox(full.getLatLonBoundingBox());
            wmsLayer.setNativeBoundingBox(full.getNativeBoundingBox());
        } else if (wmsLayer.getLatLonBoundingBox() == null) {

            setupBounds(wmsLayer);
        } else if (wmsLayer.getNativeBoundingBox() == null && wmsLayer.getNativeCRS() != null) {

            ReferencedEnvelope boundsLatLon = wmsLayer.getLatLonBoundingBox();
            wmsLayer.setNativeBoundingBox(boundsLatLon.transform(wmsLayer.getNativeCRS(), true));
        }


        if (wmsLayer.getTitle() == null) {
            wmsLayer.setTitle(full.getTitle());
        }
        if (wmsLayer.getDescription() == null) {
            wmsLayer.setDescription(full.getDescription());
        }
        if (wmsLayer.getAbstract() == null) {
            wmsLayer.setAbstract(full.getAbstract());
        }
        if (wmsLayer.getKeywords().isEmpty()) {
            wmsLayer.getKeywords().addAll(full.getKeywords());
        }
    }


    public void initCoverage(CoverageInfo cinfo) throws Exception {
        initCoverage(cinfo, null);
    }
    

    public void initCoverage(CoverageInfo cinfo, final String coverageName) throws Exception {
    	CoverageStoreInfo csinfo = (CoverageStoreInfo) store;
        GridCoverage2DReader reader = (GridCoverage2DReader) catalog
            	.getResourcePool().getGridCoverageReader(cinfo, GeoTools.getDefaultHints());
        if(coverageName != null) {
            reader = SingleGridCoverage2DReader.wrap(reader, coverageName);
        }
        
        initResourceInfo(cinfo);

        if (reader == null)
            throw new Exception("Unable to acquire a reader for this coverage with format: "
                    + csinfo.getFormat().getName());

        if (cinfo.getNativeCRS() == null) {
        	cinfo.setNativeCRS(reader.getCoordinateReferenceSystem());
        }

        CoordinateReferenceSystem nativeCRS = cinfo.getNativeCRS();

        if (cinfo.getSRS() == null) {
        	cinfo.setSRS(nativeCRS.getIdentifiers().toArray()[0].toString());
        }

        if (cinfo.getProjectionPolicy() == null) {
            if (nativeCRS != null && !nativeCRS.getIdentifiers().isEmpty()) {
                cinfo.setProjectionPolicy(ProjectionPolicy.REPROJECT_TO_DECLARED);
            }
            if (nativeCRS == null) {
                cinfo.setProjectionPolicy(ProjectionPolicy.FORCE_DECLARED);
            }
        }

    	if (cinfo.getLatLonBoundingBox() == null
    			&& cinfo.getNativeBoundingBox() == null) {
    		GeneralEnvelope envelope = reader.getOriginalEnvelope();

    		cinfo.setNativeBoundingBox(new ReferencedEnvelope(envelope));
    		cinfo.setLatLonBoundingBox(new ReferencedEnvelope(CoverageStoreUtils.getWGS84LonLatEnvelope(envelope)));
    	} else if (cinfo.getLatLonBoundingBox() == null) {
    		setupBounds(cinfo);
    	} else if (cinfo.getNativeBoundingBox() == null && cinfo.getNativeCRS() != null) {
    		ReferencedEnvelope boundsLatLon = cinfo.getLatLonBoundingBox();
    		cinfo.setNativeBoundingBox(boundsLatLon.transform(cinfo.getNativeCRS(), true));
    	}

        if (cinfo.getGrid() == null) {
            GridEnvelope originalRange = reader.getOriginalGridRange();
            cinfo.setGrid(new GridGeometry2D(originalRange, reader.getOriginalGridToWorld(PixelInCell.CELL_CENTER), nativeCRS));
        }
    }
    

    public CoverageInfo buildCoverage() throws Exception {
        return buildCoverage(null);
    }


    public CoverageInfo buildCoverage(String coverageName) throws Exception {
        if (store == null || !(store instanceof CoverageStoreInfo)) {
            throw new IllegalStateException("Coverage store not set.");
        }

        CoverageStoreInfo csinfo = (CoverageStoreInfo) store;
        GridCoverage2DReader reader = (GridCoverage2DReader) catalog
                .getResourcePool().getGridCoverageReader(csinfo, GeoTools.getDefaultHints());

        if (reader == null)
            throw new Exception("Unable to acquire a reader for this coverage with format: "
                    + csinfo.getFormat().getName());

        return buildCoverage(reader, coverageName, null);
    }


    public CoverageInfo buildCoverage(GridCoverage2DReader reader, Map customParameters) throws Exception {
        return buildCoverage(reader, null, customParameters);
    }
    

    public CoverageInfo buildCoverage(GridCoverage2DReader reader, String coverageName, Map customParameters) throws Exception {
        if (store == null || !(store instanceof CoverageStoreInfo)) {
            throw new IllegalStateException("Coverage store not set.");
        }
        

        if (coverageName != null) {
            reader = SingleGridCoverage2DReader.wrap(reader, coverageName);
        }

        CoverageStoreInfo csinfo = (CoverageStoreInfo) store;
        CoverageInfo cinfo = catalog.getFactory().createCoverage();

        cinfo.setStore(csinfo);
        cinfo.setEnabled(true);

        WorkspaceInfo workspace = store.getWorkspace();
        NamespaceInfo namespace = catalog.getNamespaceByPrefix(workspace.getName());
        if (namespace == null) {
            namespace = catalog.getDefaultNamespace();
        }
        cinfo.setNamespace(namespace);

        GeneralEnvelope envelope = reader.getOriginalEnvelope();
        CoordinateReferenceSystem nativeCRS = envelope.getCoordinateReferenceSystem();
        cinfo.setNativeCRS(nativeCRS);




        if (nativeCRS != null) {
            try {
                Integer code = CRS.lookupEpsgCode(nativeCRS, false);
                if (code != null) {
                    cinfo.setSRS("EPSG:" + code);
                    cinfo.setProjectionPolicy(ProjectionPolicy.REPROJECT_TO_DECLARED);
                }
            } catch (FactoryException e) {
                LOGGER.log(Level.WARNING, "SRS lookup failed", e);
            }
        }
        if (nativeCRS == null) {
            cinfo.setProjectionPolicy(ProjectionPolicy.FORCE_DECLARED);
        }

        
        cinfo.setNativeBoundingBox(new ReferencedEnvelope(envelope));
        cinfo.setLatLonBoundingBox(new ReferencedEnvelope(CoverageStoreUtils.getWGS84LonLatEnvelope(envelope)));

        GridEnvelope originalRange = reader.getOriginalGridRange();
        cinfo.setGrid(new GridGeometry2D(originalRange, reader.getOriginalGridToWorld(PixelInCell.CELL_CENTER), nativeCRS));












        Format format = csinfo.getFormat();
        final GridCoverage2D gc;

        final ParameterValueGroup readParams = format.getReadParameters();
        final Map parameters = CoverageUtils.getParametersKVP(readParams);
        final int minX = originalRange.getLow(0);
        final int minY = originalRange.getLow(1);
        final int width = originalRange.getSpan(0);
        final int height = originalRange.getSpan(1);
        final int maxX = minX + (width <= 5 ? width : 5);
        final int maxY = minY + (height <= 5 ? height : 5);


        final GridEnvelope2D testRange = new GridEnvelope2D(minX, minY, maxX, maxY);


        final MathTransform gridToWorldCorner = reader.getOriginalGridToWorld(PixelInCell.CELL_CORNER);
        final GeneralEnvelope testEnvelope = CRS.transform(gridToWorldCorner, new GeneralEnvelope(testRange.getBounds()));
        testEnvelope.setCoordinateReferenceSystem(nativeCRS);

        if (customParameters != null) {
        	parameters.putAll(customParameters);
        }



        String maxAllowedTiles = ImageMosaicFormat.MAX_ALLOWED_TILES.getName().toString();
        if (parameters.keySet().contains(maxAllowedTiles)) {
            parameters.put(maxAllowedTiles, 1);
        }



        String useJaiImageRead = ImageMosaicFormat.USE_JAI_IMAGEREAD.getName().toString();
        if (parameters.keySet().contains(useJaiImageRead)) {
            parameters.put(useJaiImageRead, false);
        }

        parameters.put(AbstractGridFormat.READ_GRIDGEOMETRY2D.getName().toString(), new GridGeometry2D(testRange, testEnvelope));


        gc = reader.read(CoverageUtils.getParameters(readParams, parameters, true));
        if (gc == null) {
            throw new Exception("Unable to acquire test coverage for format:" + format.getName());
        }


        parameters.remove(AbstractGridFormat.READ_GRIDGEOMETRY2D.getName().toString());

        cinfo.getDimensions().addAll(getCoverageDimensions(gc.getSampleDimensions()));
        String name = gc.getName().toString();
        cinfo.setName(name);
        cinfo.setNativeCoverageName(coverageName);
        cinfo.setTitle(name);
        cinfo.setDescription(new StringBuilder("Generated from ").append(format.getName()).toString());


        cinfo.getKeywords().add(new Keyword("WCS"));
        cinfo.getKeywords().add(new Keyword(format.getName()));
        cinfo.getKeywords().add(new Keyword(name));


        cinfo.setNativeFormat(format.getName());
        cinfo.getMetadata().put("dirName", new StringBuilder(store.getName()).append("_").append(name).toString());


        if ((gc.getCoordinateReferenceSystem2D().getIdentifiers() != null)
                && !gc.getCoordinateReferenceSystem2D().getIdentifiers().isEmpty()) {
            cinfo.getRequestSRS().add(((Identifier) gc.getCoordinateReferenceSystem2D().getIdentifiers().toArray()[0]).toString());
        }


        if ((gc.getCoordinateReferenceSystem2D().getIdentifiers() != null)
                && !gc.getCoordinateReferenceSystem2D().getIdentifiers().isEmpty()) {
            cinfo.getResponseSRS().add(((Identifier) gc.getCoordinateReferenceSystem2D().getIdentifiers().toArray()[0]).toString());
        }


        final List formats = CoverageStoreUtils.listDataFormats();
        for (Iterator i = formats.iterator(); i.hasNext();) {
            final Format fTmp = (Format) i.next();
            final String fName = fTmp.getName();

            if (fName.equalsIgnoreCase("WorldImage")) {

                cinfo.getSupportedFormats().add("GIF");
                cinfo.getSupportedFormats().add("PNG");
                cinfo.getSupportedFormats().add("JPEG");
                cinfo.getSupportedFormats().add("TIFF");
            } else if (fName.toLowerCase().startsWith("geotiff")) {

                cinfo.getSupportedFormats().add("GEOTIFF");
            } else {

                cinfo.getSupportedFormats().add(fName);
            }
        }


        cinfo.setDefaultInterpolationMethod("nearest neighbor");
        cinfo.getInterpolationMethods().add("nearest neighbor");
        cinfo.getInterpolationMethods().add("bilinear");
        cinfo.getInterpolationMethods().add("bicubic");



        cinfo.getParameters().putAll(CoverageUtils.getParametersKVP(readParams));


        gc.dispose(true);
        if(gc.getRenderedImage() instanceof PlanarImage) {
            ImageUtilities.disposePlanarImageChain((PlanarImage) gc.getRenderedImage());
        }

        return cinfo;
    }

    List<CoverageDimensionInfo> getCoverageDimensions(GridSampleDimension[] sampleDimensions) {

        final int length = sampleDimensions.length;
        List<CoverageDimensionInfo> dims = new ArrayList<CoverageDimensionInfo>();

        for (int i = 0; i < length; i++) {
            CoverageDimensionInfo dim = catalog.getFactory().createCoverageDimension();
            GridSampleDimension sd = sampleDimensions[i];
            String name = sd.getDescription().toString(Locale.getDefault());
            dim.setName(name);

            StringBuilder label = new StringBuilder("GridSampleDimension".intern());
            final Unit uom = sd.getUnits();

            String uName = name.toUpperCase();
            if (uom != null) {
                label.append("(".intern());
                parseUOM(label, uom);
                label.append(")".intern());
                dim.setUnit(uom.toString());
            } else if(uName.startsWith("RED") || uName.startsWith("GREEN") || uName.startsWith("BLUE")) {

                dim.setUnit("W.m-2.Sr-1");
            }
            
            dim.setDimensionType(sd.getSampleDimensionType());

            label.append("[".intern());
            label.append(sd.getMinimumValue());
            label.append(",".intern());
            label.append(sd.getMaximumValue());
            label.append("]".intern());

            dim.setDescription(label.toString());

            if (sd.getRange() != null) {
                dim.setRange(sd.getRange());    
            }
            else {
                dim.setRange(NumberRange.create(sd.getMinimumValue(), sd.getMaximumValue()));
            }
            
            final List<Category> categories = sd.getCategories();
            if (categories != null) {
                for (Category cat : categories) {

                    if ((cat != null) && cat.getName().toString().equalsIgnoreCase("no data")) {
                        double min = cat.getRange().getMinimum();
                        double max = cat.getRange().getMaximum();

                        dim.getNullValues().add(min);
                        if (min != max) {
                            dim.getNullValues().add(max);
                        }
                    }
                }
            }
            
            dims.add(dim);
        }

        return dims;
    }
    
    public WMSLayerInfo buildWMSLayer(String layerName) throws IOException {
        return buildWMSLayer(this.store, layerName);
    }

    WMSLayerInfo buildWMSLayer(StoreInfo store, String layerName) throws IOException {
        if (store == null || !(store instanceof WMSStoreInfo)) {
            throw new IllegalStateException("WMS store not set.");
        }

        WMSLayerInfo wli = catalog.getFactory().createWMSLayer();

        wli.setName(layerName);
        wli.setNativeName(layerName);

        wli.setStore(store);
        wli.setEnabled(true);

        WorkspaceInfo workspace = store.getWorkspace();
        NamespaceInfo namespace = catalog.getNamespaceByPrefix(workspace.getName());
        if (namespace == null) {
            namespace = catalog.getDefaultNamespace();
        }
        wli.setNamespace(namespace);

        Layer layer = wli.getWMSLayer(null);



        for (String srs : layer.getBoundingBoxes().keySet()) {
            try {
                CoordinateReferenceSystem crs = CRS.decode(srs);
                wli.setSRS(srs);
                wli.setNativeCRS(crs);
            } catch (Exception e) {
                LOGGER.log(Level.INFO, "Skipping " + srs
                        + " definition, it was not recognized by the referencing subsystem");
            }
        }
        

        String srs = wli.getSRS();
        try {
            if (srs == null || srs.equals("CRS:84")) {
                wli.setSRS("EPSG:4326");
                srs = "EPSG:4326";
                wli.setNativeCRS(CRS.decode("EPSG:4326"));
            } else if(srs.equals("CRS:83")) {
                wli.setSRS("EPSG:4269");
                srs = "EPSG:4269";
                wli.setNativeCRS(CRS.decode("EPSG:4269"));
            } else if(srs.equals("CRS:27")) {
                wli.setSRS("EPSG:4267");
                srs = "EPSG:4267";
                wli.setNativeCRS(CRS.decode("EPSG:4267"));
            }
        } catch(Exception e) {
            throw (IOException) new IOException("Failed to compute the layer declared SRS code").initCause(e);
        }
        wli.setProjectionPolicy(ProjectionPolicy.FORCE_DECLARED);


        GeneralEnvelope envelope = layer.getEnvelope(wli.getNativeCRS());
        if (envelope != null) {
            ReferencedEnvelope re = new ReferencedEnvelope(envelope.getMinimum(0), envelope
                    .getMaximum(0), envelope.getMinimum(1), envelope.getMaximum(1), wli
                    .getNativeCRS());
            wli.setNativeBoundingBox(re);
        }
        CRSEnvelope llbbox = layer.getLatLonBoundingBox();
        if (llbbox != null) {
            ReferencedEnvelope re = new ReferencedEnvelope(llbbox.getMinX(), llbbox.getMaxX(),
                    llbbox.getMinY(), llbbox.getMaxY(), DefaultGeographicCRS.WGS84);
            wli.setLatLonBoundingBox(re);
        } else if (wli.getNativeBoundingBox() != null) {
            try {
                wli.setLatLonBoundingBox(wli.getNativeBoundingBox().transform(
                        DefaultGeographicCRS.WGS84, true));
            } catch (Exception e) {
                LOGGER.log(Level.INFO, "Could not transform native bbox into a lat/lon one", e);
            }
        }


        wli.setAbstract(layer.get_abstract());
        wli.setDescription(layer.get_abstract());
        wli.setTitle(layer.getTitle());
        if (layer.getKeywords() != null) {
            for (String kw : layer.getKeywords()) {
                if(kw != null){
                    wli.getKeywords().add(new Keyword(kw));
                }
            }
        }


        String published = wli.getName();
        if (published.contains(":")) {
            wli.setName(published.substring(published.lastIndexOf(':') + 1));
        }

        return wli;
    }
    
    private boolean axisFlipped(Version version, String srsName) {
        if(version.compareTo(new Version("1.3.0")) < 0) {

            return false;
        } else {

            if(srsName.startsWith("EPSG:")) {
                try {
                    String epsgNative =  "urn:x-ogc:def:crs:EPSG:".concat(srsName.substring(5));
                    return CRS.getAxisOrder(CRS.decode(epsgNative)) == AxisOrder.NORTH_EAST;
                } catch(Exception e) {
                    LOGGER.log(Level.WARNING, "Failed to determine axis order for " 
                            + srsName + ", assuming east/north", e);
                    return false;
                }
            } else {

                return false;
            }
        }
    }

    void parseUOM(StringBuilder label, Unit uom) {
        String uomString = uom.toString();
        uomString = uomString.replaceAll("\u00B2", "^2");
        uomString = uomString.replaceAll("\u00B3", "^3");
        uomString = uomString.replaceAll("\u212B", "A");
        uomString = uomString.replaceAll("ï¿½", "");
        label.append(uomString);
    }


    public LayerInfo buildLayer(FeatureTypeInfo featureType) throws IOException {

        LayerInfo layer = buildLayer((ResourceInfo) featureType);

        StyleInfo style = getDefaultStyle(featureType);
        layer.setDefaultStyle(style);

        return layer;
    }


    public LayerInfo buildLayer(CoverageInfo coverage) throws IOException {
        LayerInfo layer = buildLayer((ResourceInfo) coverage);

        layer.setDefaultStyle(getDefaultStyle(coverage));

        return layer;
    }


    public LayerInfo buildLayer(WMSLayerInfo wms) throws IOException {
        LayerInfo layer = buildLayer((ResourceInfo) wms);
        
        layer.setDefaultStyle(getDefaultStyle(wms));
        
        return layer;
    }


    public StyleInfo getDefaultStyle(ResourceInfo resource) throws IOException {

        if (resource instanceof CoverageInfo || resource instanceof WMSLayerInfo)
            return catalog.getStyleByName(StyleInfo.DEFAULT_RASTER);


        String styleName;
        FeatureTypeInfo featureType = (FeatureTypeInfo) resource;
        if (featureType.getFeatureType() == null) {
            return null;
        }
        GeometryDescriptor gd = featureType.getFeatureType().getGeometryDescriptor();
        if (gd == null) {
            return null;
        }

        Class gtype = gd.getType().getBinding();
        if (Point.class.isAssignableFrom(gtype) || MultiPoint.class.isAssignableFrom(gtype)) {
            styleName = StyleInfo.DEFAULT_POINT;
        } else if (LineString.class.isAssignableFrom(gtype)
                || MultiLineString.class.isAssignableFrom(gtype)) {
            styleName = StyleInfo.DEFAULT_LINE;
        } else if (Polygon.class.isAssignableFrom(gtype)
                || MultiPolygon.class.isAssignableFrom(gtype)) {
            styleName = StyleInfo.DEFAULT_POLYGON;
        } else {

            styleName = StyleInfo.DEFAULT_POINT;
        }

        return catalog.getStyleByName(styleName);
    }

    public LayerInfo buildLayer(ResourceInfo resource) {
        LayerInfo layer = catalog.getFactory().createLayer();
        layer.setResource(resource);
        layer.setName(resource.getName());
        layer.setEnabled(true);


        if (layer.getResource() instanceof FeatureTypeInfo) {
            layer.setType(PublishedType.VECTOR);
        } else if (layer.getResource() instanceof CoverageInfo) {
            layer.setType(PublishedType.RASTER);
        } else if (layer.getResource() instanceof WMSLayerInfo) {
            layer.setType(PublishedType.WMS);
        }

        return layer;
    }


    public void calculateLayerGroupBounds(LayerGroupInfo layerGroup, CoordinateReferenceSystem crs)
            throws Exception {
        LayerGroupHelper helper = new LayerGroupHelper(layerGroup);
        helper.calculateBounds(crs);
    }


    public void calculateLayerGroupBounds(LayerGroupInfo layerGroup) throws Exception {
        LayerGroupHelper helper = new LayerGroupHelper(layerGroup);
        helper.calculateBounds();
    }






    public void removeWorkspace(WorkspaceInfo workspace, boolean recursive) {
        if (recursive) {
            workspace.accept(new CascadeDeleteVisitor(catalog));
        } else {
            catalog.remove(workspace);
        }
    }


    public void removeStore(StoreInfo store, boolean recursive) {
        if (recursive) {
            store.accept(new CascadeDeleteVisitor(catalog));
        } else {
            catalog.remove(store);
        }
    }


    public void removeResource(ResourceInfo resource, boolean recursive) {
        if (recursive) {
            resource.accept(new CascadeDeleteVisitor(catalog));
        } else {
            catalog.remove(resource);
        }
    }


    public void attach(StoreInfo storeInfo) {
        storeInfo = ModificationProxy.unwrap(storeInfo);
        ((StoreInfoImpl) storeInfo).setCatalog(catalog);
    }


    public void attach(ResourceInfo resourceInfo) {
        resourceInfo = ModificationProxy.unwrap(resourceInfo);
        ((ResourceInfoImpl) resourceInfo).setCatalog(catalog);
    }


    public void attach(LayerInfo layerInfo) {
        attach(layerInfo.getResource());
    }


    public void attach(MapInfo mapInfo) {

        for (LayerInfo layer : mapInfo.getLayers()) {
            attach(layer);
        }
    }


    public void attach(LayerGroupInfo groupInfo) {
        if (groupInfo.getRootLayer() != null) {
            attach(groupInfo.getRootLayer());
        }
        
        if (groupInfo.getRootLayerStyle() != null) {
            attach(groupInfo.getRootLayerStyle());            
        }
        
        for (PublishedInfo p : groupInfo.getLayers()) {
            if (p instanceof LayerInfo) {
                attach((LayerInfo) p);
            } else {
                attach((LayerGroupInfo) p);                
            }
        }
        
        for (StyleInfo style : groupInfo.getStyles()) {
            if (style != null)
                attach(style);
        }
    }


    public void attach(StyleInfo styleInfo) {
        styleInfo = ModificationProxy.unwrap(styleInfo);
        ((StyleInfoImpl) styleInfo).setCatalog(catalog);
    }


    public void attach(NamespaceInfo nsInfo) {

    }


    public void attach(WorkspaceInfo wsInfo) {

    }
    

    public List<AttributeTypeInfo> getAttributes(FeatureType ft, FeatureTypeInfo info) {
        List<AttributeTypeInfo> attributes = new ArrayList<AttributeTypeInfo>();
        for (PropertyDescriptor pd : ft.getDescriptors()) {
            AttributeTypeInfo att = catalog.getFactory().createAttribute();
            att.setFeatureType(info);
            att.setName(pd.getName().getLocalPart());
            att.setMinOccurs(pd.getMinOccurs());
            att.setMaxOccurs(pd.getMaxOccurs());
            att.setNillable(pd.isNillable());
            att.setBinding(pd.getType().getBinding());
            int length = FeatureTypes.getFieldLength(pd);
            if(length > 0) {
                att.setLength(length);
            }
            attributes.add(att);
        }
        
        return attributes;
    }
}
