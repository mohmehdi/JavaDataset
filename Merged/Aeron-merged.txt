
package uk.co.real_logic.aeron.driver;

import uk.co.real_logic.aeron.driver.buffer.RawLog;
import uk.co.real_logic.aeron.driver.media.SendChannelEndpoint;
import uk.co.real_logic.aeron.logbuffer.LogBufferPartition;
import uk.co.real_logic.aeron.protocol.DataHeaderFlyweight;
import uk.co.real_logic.aeron.protocol.HeaderFlyweight;
import uk.co.real_logic.aeron.protocol.SetupFlyweight;
import uk.co.real_logic.agrona.concurrent.NanoClock;
import uk.co.real_logic.agrona.concurrent.UnsafeBuffer;
import uk.co.real_logic.agrona.concurrent.status.Position;

import java.net.InetSocketAddress;
import java.nio.ByteBuffer;

import static uk.co.real_logic.aeron.driver.Configuration.PUBLICATION_HEARTBEAT_TIMEOUT_NS;
import static uk.co.real_logic.aeron.driver.Configuration.PUBLICATION_SETUP_TIMEOUT_NS;
import static uk.co.real_logic.aeron.logbuffer.LogBufferDescriptor.*;
import static uk.co.real_logic.aeron.logbuffer.TermScanner.*;


public class NetworkPublication implements RetransmitSender, AutoCloseable
{
    private final RawLog rawLog;
    private final SetupFlyweight setupHeader = new SetupFlyweight();
    private final DataHeaderFlyweight dataHeader = new DataHeaderFlyweight();
    private final ByteBuffer setupFrameBuffer = ByteBuffer.allocateDirect(SetupFlyweight.HEADER_LENGTH);
    private final ByteBuffer heartbeatFrameBuffer = ByteBuffer.allocateDirect(DataHeaderFlyweight.HEADER_LENGTH);
    private final LogBufferPartition[] logPartitions;
    private final ByteBuffer[] sendBuffers;
    private final Position publisherLimit;
    private final Position senderPosition;
    private final SendChannelEndpoint channelEndpoint;
    private final SystemCounters systemCounters;
    private final FlowControl flowControl;
    private final RetransmitHandler retransmitHandler;

    private final int positionBitsToShift;
    private final int initialTermId;
    private final int termLengthMask;
    private final int mtuLength;
    private final int termWindowLength;

    private long timeOfLastSendOrHeartbeat;
    private long timeOfFlush = 0;
    private int statusMessagesReceivedCount = 0;
    private int refCount = 0;

    private volatile long senderPositionLimit;
    private boolean trackSenderLimits = true;
    private volatile boolean isActive = true;
    private volatile boolean shouldSendSetupFrame = true;

    public NetworkPublication(
        final SendChannelEndpoint channelEndpoint,
        final NanoClock clock,
        final RawLog rawLog,
        final Position senderPosition,
        final Position publisherLimit,
        final int sessionId,
        final int streamId,
        final int initialTermId,
        final int mtuLength,
        final long initialPositionLimit,
        final SystemCounters systemCounters,
        final FlowControl flowControl,
        final RetransmitHandler retransmitHandler)
    {
        this.channelEndpoint = channelEndpoint;
        this.rawLog = rawLog;
        this.senderPosition = senderPosition;
        this.systemCounters = systemCounters;
        this.flowControl = flowControl;
        this.retransmitHandler = retransmitHandler;
        this.publisherLimit = publisherLimit;
        this.mtuLength = mtuLength;

        logPartitions = rawLog
            .stream()
            .map((partition) -> new LogBufferPartition(partition.termBuffer(), partition.metaDataBuffer()))
            .toArray(LogBufferPartition[]::new);

        sendBuffers = rawLog.sliceTerms();

        final int termLength = logPartitions[0].termBuffer().capacity();
        termLengthMask = termLength - 1;
        senderPositionLimit = initialPositionLimit;

        timeOfLastSendOrHeartbeat = clock.nanoTime();

        positionBitsToShift = Integer.numberOfTrailingZeros(termLength);
        this.initialTermId = initialTermId;
        termWindowLength = Configuration.publicationTermWindowLength(termLength);
        publisherLimit.setOrdered(termWindowLength);

        setupHeader.wrap(new UnsafeBuffer(setupFrameBuffer), 0);
        initSetupFrame(initialTermId, termLength, sessionId, streamId);

        dataHeader.wrap(new UnsafeBuffer(heartbeatFrameBuffer), 0);
        initHeartBeatFrame(sessionId, streamId);
    }

    public void close()
    {
        rawLog.close();
        publisherLimit.close();
        senderPosition.close();
    }

    public int send(final long now)
    {
        int bytesSent = 0;

        if (isActive)
        {
            final long senderPosition = this.senderPosition.get();
            final int activeTermId = computeTermIdFromPosition(senderPosition, positionBitsToShift, initialTermId);
            final int termOffset = (int)senderPosition & termLengthMask;

            if (shouldSendSetupFrame)
            {
                setupMessageCheck(now, activeTermId, termOffset, senderPosition);
            }

            bytesSent = sendData(now, senderPosition, termOffset);

            if (0 == bytesSent)
            {
                heartbeatMessageCheck(now, senderPosition, activeTermId);
            }

            retransmitHandler.processTimeouts(now, this);
        }

        return bytesSent;
    }

    public SendChannelEndpoint sendChannelEndpoint()
    {
        return channelEndpoint;
    }

    public int sessionId()
    {
        return dataHeader.sessionId();
    }

    public int streamId()
    {
        return dataHeader.streamId();
    }

    public void senderPositionLimit(final long positionLimit)
    {
        statusMessagesReceivedCount++;
        senderPositionLimit = positionLimit;
    }

    
    public int cleanLogBuffer()
    {
        int workCount = 0;

        for (final LogBufferPartition partition : logPartitions)
        {
            if (partition.status() == NEEDS_CLEANING)
            {
                partition.clean();
                workCount = 1;
            }
        }

        return workCount;
    }

    public long timeOfFlush()
    {
        return timeOfFlush;
    }

    public void resend(final int termId, int termOffset, final int length)
    {
        final long senderPosition = this.senderPosition.get();
        final int activeTermId = computeTermIdFromPosition(senderPosition, positionBitsToShift, initialTermId);

        if (termId == activeTermId || termId == (activeTermId - 1))
        {
            final int activeIndex = indexByTerm(initialTermId, termId);
            final UnsafeBuffer termBuffer = logPartitions[activeIndex].termBuffer();
            final ByteBuffer sendBuffer = sendBuffers[activeIndex];

            int remainingBytes = length;
            int bytesSent = 0;
            do
            {
                termOffset += bytesSent;

                final long scanOutcome = scanForAvailability(termBuffer, termOffset, mtuLength);
                final int available = available(scanOutcome);
                if (available <= 0)
                {
                    break;
                }

                sendBuffer.limit(termOffset + available).position(termOffset);

                if (available != channelEndpoint.send(sendBuffer))
                {
                    systemCounters.dataPacketShortSends().orderedIncrement();
                    break;
                }

                bytesSent = available + padding(scanOutcome);
                remainingBytes -= bytesSent;
            }
            while (remainingBytes > 0);

            systemCounters.retransmitsSent().orderedIncrement();
        }
    }

    public void triggerSendSetupFrame()
    {
        shouldSendSetupFrame = true;
    }

    public int decRef()
    {
        return --refCount;
    }

    public int incRef()
    {
        final int i = ++refCount;

        if (i == 1)
        {
            timeOfFlush = 0;
            isActive = true;
        }

        return i;
    }

    public boolean isUnreferencedAndFlushed(final long now)
    {
        boolean isFlushed = false;
        if (0 == refCount)
        {
            final long senderPosition = this.senderPosition.getVolatile();
            final int activeIndex = indexByPosition(senderPosition, positionBitsToShift);
            isFlushed = (int)(senderPosition & termLengthMask) >= logPartitions[activeIndex].tailVolatile();

            if (isFlushed && isActive)
            {
                timeOfFlush = now;
                isActive = false;
            }
        }

        return isFlushed;
    }

    public RawLog rawLog()
    {
        return rawLog;
    }

    public int publisherLimitId()
    {
        return publisherLimit.id();
    }

    
    public int updatePublishersLimit()
    {
        int workCount = 0;
        final long candidatePublisherLimit = senderPosition.getVolatile() + termWindowLength;
        if (publisherLimit.proposeMaxOrdered(candidatePublisherLimit))
        {
            workCount = 1;
        }

        return workCount;
    }

    public void onNak(final int termId, final int termOffset, final int length)
    {
        retransmitHandler.onNak(termId, termOffset, length, this);
    }

    private int sendData(final long now, final long senderPosition, final int termOffset)
    {
        int bytesSent = 0;
        final int availableWindow = (int)(senderPositionLimit - senderPosition);
        if (availableWindow > 0)
        {
            final int scanLimit = Math.min(availableWindow, mtuLength);
            final int activeIndex = indexByPosition(senderPosition, positionBitsToShift);

            final long scanOutcome = scanForAvailability(logPartitions[activeIndex].termBuffer(), termOffset, scanLimit);
            final int available = available(scanOutcome);
            if (available > 0)
            {
                final ByteBuffer sendBuffer = sendBuffers[activeIndex];
                sendBuffer.limit(termOffset + available).position(termOffset);

                if (available == channelEndpoint.send(sendBuffer))
                {
                    timeOfLastSendOrHeartbeat = now;
                    trackSenderLimits = true;

                    bytesSent = available;
                    this.senderPosition.setOrdered(senderPosition + bytesSent + padding(scanOutcome));
                }
                else
                {
                    systemCounters.dataPacketShortSends().orderedIncrement();
                }
            }
        }
        else if (trackSenderLimits)
        {
            trackSenderLimits = false;
            systemCounters.senderFlowControlLimits().orderedIncrement();
        }

        return bytesSent;
    }

    public void onStatusMessage(
        final int termId, final int termOffset, final int receiverWindowLength, final InetSocketAddress srcAddress)
    {
        final long position = flowControl.onStatusMessage(termId, termOffset, receiverWindowLength, srcAddress);
        senderPositionLimit(position);
    }

    private void setupMessageCheck(final long now, final int activeTermId, final int termOffset, final long senderPosition)
    {
        if (0 != senderPosition || (now > (timeOfLastSendOrHeartbeat + PUBLICATION_SETUP_TIMEOUT_NS)))
        {
            setupFrameBuffer.clear();
            setupHeader.activeTermId(activeTermId).termOffset(termOffset);

            final int bytesSent = channelEndpoint.send(setupFrameBuffer);
            if (SetupFlyweight.HEADER_LENGTH != bytesSent)
            {
                systemCounters.setupMessageShortSends().orderedIncrement();
            }

            timeOfLastSendOrHeartbeat = now;
        }

        if (statusMessagesReceivedCount > 0)
        {
            shouldSendSetupFrame = false;
        }
    }

    private void heartbeatMessageCheck(final long now, final long senderPosition, final int activeTermId)
    {
        if (now > (timeOfLastSendOrHeartbeat + PUBLICATION_HEARTBEAT_TIMEOUT_NS))
        {
            final int termOffset = (int)senderPosition & termLengthMask;

            heartbeatFrameBuffer.clear();
            dataHeader.termId(activeTermId).termOffset(termOffset);

            final int bytesSent = channelEndpoint.send(heartbeatFrameBuffer);
            if (DataHeaderFlyweight.HEADER_LENGTH != bytesSent)
            {
                systemCounters.dataPacketShortSends().orderedIncrement();
            }

            systemCounters.heartbeatsSent().orderedIncrement();
            timeOfLastSendOrHeartbeat = now;
        }
    }

    private void initSetupFrame(final int activeTermId, final int termLength, final int sessionId, final int streamId)
    {
        setupHeader
            .sessionId(sessionId)
            .streamId(streamId)
            .initialTermId(initialTermId)
            .activeTermId(activeTermId)
            .termOffset(0)
            .termLength(termLength)
            .mtuLength(mtuLength)
            .version(HeaderFlyweight.CURRENT_VERSION)
            .flags((byte)0)
            .headerType(HeaderFlyweight.HDR_TYPE_SETUP)
            .frameLength(SetupFlyweight.HEADER_LENGTH);
    }

    private void initHeartBeatFrame(final int sessionId, final int streamId)
    {
        dataHeader
            .sessionId(sessionId)
            .streamId(streamId)
            .version(HeaderFlyweight.CURRENT_VERSION)
            .flags((byte)DataHeaderFlyweight.BEGIN_AND_END_FLAGS)
            .headerType(HeaderFlyweight.HDR_TYPE_DATA)
            .frameLength(0);
    }
}

<code block>

package uk.co.real_logic.aeron.driver;

import uk.co.real_logic.aeron.driver.cmd.SenderCmd;
import uk.co.real_logic.aeron.driver.media.SendChannelEndpoint;
import uk.co.real_logic.aeron.driver.media.TransportPoller;
import uk.co.real_logic.agrona.concurrent.Agent;
import uk.co.real_logic.agrona.concurrent.AtomicCounter;
import uk.co.real_logic.agrona.concurrent.NanoClock;
import uk.co.real_logic.agrona.concurrent.OneToOneConcurrentArrayQueue;

import java.util.function.Consumer;


public class Sender implements Agent, Consumer<SenderCmd>
{
    private static final NetworkPublication[] EMPTY_PUBLICATIONS = new NetworkPublication[0];

    private final TransportPoller transportPoller;
    private final OneToOneConcurrentArrayQueue<SenderCmd> commandQueue;
    private final DriverConductorProxy conductorProxy;
    private final AtomicCounter totalBytesSent;
    private final NanoClock nanoClock;

    private NetworkPublication[] publications = EMPTY_PUBLICATIONS;
    private int roundRobinIndex = 0;

    public Sender(final MediaDriver.Context ctx)
    {
        this.transportPoller = ctx.senderNioSelector();
        this.commandQueue = ctx.senderCommandQueue();
        this.conductorProxy = ctx.fromSenderDriverConductorProxy();
        this.totalBytesSent = ctx.systemCounters().bytesSent();
        this.nanoClock = ctx.nanoClock();
    }

    public int doWork()
    {
        final long now = nanoClock.nanoTime();
        final int workCount = commandQueue.drain(this);
        final int bytesSent = doSend(now);
        final int bytesReceived = transportPoller.pollTransports();

        return workCount + bytesSent + bytesReceived;
    }

    public String roleName()
    {
        return "sender";
    }

    public void onRegisterSendChannelEndpoint(final SendChannelEndpoint channelEndpoint)
    {
        channelEndpoint.openChannel();
        channelEndpoint.registerForRead(transportPoller);
        transportPoller.selectNowWithoutProcessing();
    }

    public void onCloseSendChannelEndpoint(final SendChannelEndpoint channelEndpoint)
    {
        channelEndpoint.close();
        transportPoller.selectNowWithoutProcessing();
    }

    public void onNewPublication(final NetworkPublication publication)
    {
        final NetworkPublication[] oldPublications = publications;
        final int length = oldPublications.length;
        final NetworkPublication[] newPublications = new NetworkPublication[length + 1];

        System.arraycopy(oldPublications, 0, newPublications, 0, length);
        newPublications[length] = publication;

        publications = newPublications;

        publication.sendChannelEndpoint().addToDispatcher(publication);
    }

    public void onRemovePublication(final NetworkPublication publication)
    {
        final NetworkPublication[] oldPublications = publications;
        final int length = oldPublications.length;
        final NetworkPublication[] newPublications = new NetworkPublication[length - 1];
        for (int i = 0, j = 0; i < length; i++)
        {
            if (oldPublications[i] != publication)
            {
                newPublications[j++] = oldPublications[i];
            }
        }

        publications = newPublications;
        publication.sendChannelEndpoint().removeFromDispatcher(publication);
        conductorProxy.closeResource(publication);
    }

    public void accept(final SenderCmd cmd)
    {
        cmd.execute(this);
    }

    private int doSend(final long now)
    {
        int bytesSent = 0;
        final NetworkPublication[] publications = this.publications;
        final int length = publications.length;

        if (length > 0)
        {
            int startingIndex = roundRobinIndex++;
            if (startingIndex >= length)
            {
                roundRobinIndex = startingIndex = 0;
            }

            int i = startingIndex;

            do
            {
                bytesSent += publications[i].send(now);

                if (++i == length)
                {
                    i = 0;
                }
            }
            while (i != startingIndex);
        }

        totalBytesSent.addOrdered(bytesSent);

        return bytesSent;
    }
}

<code block>

package uk.co.real_logic.aeron.driver;

import uk.co.real_logic.aeron.command.CorrelatedMessageFlyweight;
import uk.co.real_logic.aeron.command.PublicationMessageFlyweight;
import uk.co.real_logic.aeron.command.RemoveMessageFlyweight;
import uk.co.real_logic.aeron.command.SubscriptionMessageFlyweight;
import uk.co.real_logic.aeron.driver.MediaDriver.Context;
import uk.co.real_logic.aeron.driver.buffer.RawLog;
import uk.co.real_logic.aeron.driver.buffer.RawLogFactory;
import uk.co.real_logic.aeron.driver.cmd.DriverConductorCmd;
import uk.co.real_logic.aeron.driver.event.EventCode;
import uk.co.real_logic.aeron.driver.event.EventLogger;
import uk.co.real_logic.aeron.driver.exceptions.ControlProtocolException;
import uk.co.real_logic.aeron.driver.media.ReceiveChannelEndpoint;
import uk.co.real_logic.aeron.driver.media.SendChannelEndpoint;
import uk.co.real_logic.aeron.driver.media.UdpChannel;
import uk.co.real_logic.aeron.logbuffer.LogBufferDescriptor;
import uk.co.real_logic.aeron.protocol.DataHeaderFlyweight;
import uk.co.real_logic.agrona.BitUtil;
import uk.co.real_logic.agrona.MutableDirectBuffer;
import uk.co.real_logic.agrona.concurrent.*;
import uk.co.real_logic.agrona.concurrent.ringbuffer.RingBuffer;
import uk.co.real_logic.agrona.concurrent.status.Position;
import uk.co.real_logic.agrona.concurrent.status.UnsafeBufferPosition;

import java.net.InetSocketAddress;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.function.Consumer;
import java.util.function.Supplier;

import static java.util.stream.Collectors.toList;
import static uk.co.real_logic.aeron.ErrorCode.*;
import static uk.co.real_logic.aeron.command.ControlProtocolEvents.*;
import static uk.co.real_logic.aeron.driver.Configuration.*;
import static uk.co.real_logic.aeron.driver.event.EventConfiguration.EVENT_READER_FRAME_LIMIT;


public class DriverConductor implements Agent
{
    private final int mtuLength;
    private final int termBufferLength;
    private final int initialWindowLength;

    private final RawLogFactory rawLogFactory;
    private final ReceiverProxy receiverProxy;
    private final SenderProxy senderProxy;
    private final ClientProxy clientProxy;
    private final DriverConductorProxy fromReceiverConductorProxy;
    private final RingBuffer toDriverCommands;
    private final RingBuffer toEventReader;
    private final OneToOneConcurrentArrayQueue<DriverConductorCmd> fromReceiverDriverConductorCmdQueue;
    private final OneToOneConcurrentArrayQueue<DriverConductorCmd> fromSenderDriverConductorCmdQueue;
    private final Supplier<FlowControl> unicastFlowControl;
    private final Supplier<FlowControl> multicastFlowControl;
    private final HashMap<String, SendChannelEndpoint> sendChannelEndpointByChannelMap = new HashMap<>();
    private final HashMap<String, ReceiveChannelEndpoint> receiveChannelEndpointByChannelMap = new HashMap<>();
    private final ArrayList<PublicationLink> publicationLinks = new ArrayList<>();
    private final ArrayList<NetworkPublication> publications = new ArrayList<>();
    private final ArrayList<SubscriptionLink> subscriptionLinks = new ArrayList<>();
    private final ArrayList<NetworkConnection> connections = new ArrayList<>();
    private final ArrayList<AeronClient> clients = new ArrayList<>();

    private final PublicationMessageFlyweight publicationMsgFlyweight = new PublicationMessageFlyweight();
    private final SubscriptionMessageFlyweight subscriptionMsgFlyweight = new SubscriptionMessageFlyweight();
    private final CorrelatedMessageFlyweight correlatedMsgFlyweight = new CorrelatedMessageFlyweight();
    private final RemoveMessageFlyweight removeMsgFlyweight = new RemoveMessageFlyweight();

    private final EpochClock epochClock;
    private final NanoClock nanoClock;
    private final SystemCounters systemCounters;
    private final UnsafeBuffer countersBuffer;
    private final CountersManager countersManager;
    private final EventLogger logger;
    private final Consumer<DriverConductorCmd> onDriverConductorCmdFunc = this::onDriverConductorCmd;
    private final MessageHandler onClientCommandFunc = this::onClientCommand;
    private final MessageHandler onEventFunc;
    private final LossGenerator dataLossGenerator;
    private final LossGenerator controlLossGenerator;

    private long timeOfLastTimeoutCheck;

    public DriverConductor(final Context ctx)
    {
        fromReceiverDriverConductorCmdQueue = ctx.toConductorFromReceiverCommandQueue();
        fromSenderDriverConductorCmdQueue = ctx.toConductorFromSenderCommandQueue();
        receiverProxy = ctx.receiverProxy();
        senderProxy = ctx.senderProxy();
        rawLogFactory = ctx.rawLogBuffersFactory();
        mtuLength = ctx.mtuLength();
        initialWindowLength = ctx.initialWindowLength();
        termBufferLength = ctx.termBufferLength();
        unicastFlowControl = ctx.unicastSenderFlowControl();
        multicastFlowControl = ctx.multicastSenderFlowControl();
        countersManager = ctx.countersManager();
        countersBuffer = ctx.counterValuesBuffer();
        epochClock = ctx.epochClock();
        nanoClock = ctx.nanoClock();
        toDriverCommands = ctx.toDriverCommands();
        toEventReader = ctx.toEventReader();
        clientProxy = ctx.clientProxy();
        fromReceiverConductorProxy = ctx.fromReceiverDriverConductorProxy();
        logger = ctx.eventLogger();
        systemCounters = ctx.systemCounters();
        dataLossGenerator = ctx.dataLossGenerator();
        controlLossGenerator = ctx.controlLossGenerator();

        final Consumer<String> eventConsumer = ctx.eventConsumer();
        onEventFunc =
            (typeId, buffer, offset, length) -> eventConsumer.accept(EventCode.get(typeId).decode(buffer, offset, length));

        final AtomicBuffer buffer = toDriverCommands.buffer();
        publicationMsgFlyweight.wrap(buffer, 0);
        subscriptionMsgFlyweight.wrap(buffer, 0);
        correlatedMsgFlyweight.wrap(buffer, 0);
        removeMsgFlyweight.wrap(buffer, 0);

        toDriverCommands.consumerHeartbeatTime(epochClock.time());
        timeOfLastTimeoutCheck = nanoClock.nanoTime();
    }

    private static AeronClient findClient(final ArrayList<AeronClient> clients, final long clientId)
    {
        AeronClient aeronClient = null;

        for (int i = 0, size = clients.size(); i < size; i++)
        {
            final AeronClient client = clients.get(i);
            if (client.clientId() == clientId)
            {
                aeronClient = client;
                break;
            }
        }

        return aeronClient;
    }

    private static PublicationLink findPublicationLink(
        final ArrayList<PublicationLink> publicationLinks, final long registrationId)
    {
        PublicationLink publicationLink = null;

        for (int i = 0, size = publicationLinks.size(); i < size; i++)
        {
            final PublicationLink link = publicationLinks.get(i);
            if (registrationId == link.registrationId())
            {
                publicationLink = link;
                break;
            }
        }

        return publicationLink;
    }

    private static String generateSourceIdentity(final InetSocketAddress address)
    {
        return String.format("%s:%d", address.getHostString(), address.getPort());
    }

    private static SubscriptionLink removeSubscription(
        final ArrayList<SubscriptionLink> subscriptions, final long registrationId)
    {
        SubscriptionLink subscription = null;
        for (int i = 0, size = subscriptions.size(); i < size; i++)
        {
            subscription = subscriptions.get(i);
            if (subscription.registrationId() == registrationId)
            {
                subscriptions.remove(i);
                break;
            }
        }

        return subscription;
    }

    public void onClose()
    {
        rawLogFactory.close();
        publications.forEach(NetworkPublication::close);
        connections.forEach(NetworkConnection::close);
        sendChannelEndpointByChannelMap.values().forEach(SendChannelEndpoint::close);
        receiveChannelEndpointByChannelMap.values().forEach(ReceiveChannelEndpoint::close);
    }

    public String roleName()
    {
        return "driver-conductor";
    }

    public SendChannelEndpoint senderChannelEndpoint(final UdpChannel channel)
    {
        return sendChannelEndpointByChannelMap.get(channel.canonicalForm());
    }

    public ReceiveChannelEndpoint receiverChannelEndpoint(final UdpChannel channel)
    {
        return receiveChannelEndpointByChannelMap.get(channel.canonicalForm());
    }

    public int doWork() throws Exception
    {
        int workCount = 0;

        workCount += toDriverCommands.read(onClientCommandFunc);
        workCount += fromReceiverDriverConductorCmdQueue.drain(onDriverConductorCmdFunc);
        workCount += fromSenderDriverConductorCmdQueue.drain(onDriverConductorCmdFunc);
        workCount += toEventReader.read(onEventFunc, EVENT_READER_FRAME_LIMIT);

        final long now = nanoClock.nanoTime();
        workCount += processTimers(now);

        final ArrayList<NetworkConnection> connections = this.connections;
        for (int i = 0, size = connections.size(); i < size; i++)
        {
            final NetworkConnection connection = connections.get(i);
            workCount += connection.trackRebuild(now);
        }

        final ArrayList<NetworkPublication> publications = this.publications;
        for (int i = 0, size = publications.size(); i < size; i++)
        {
            final NetworkPublication publication = publications.get(i);
            workCount += publication.updatePublishersLimit() + publication.cleanLogBuffer();
        }

        return workCount;
    }

    private void onHeartbeatCheckTimeouts(final long nanoTimeNow)
    {
        toDriverCommands.consumerHeartbeatTime(epochClock.time());

        onCheckClients(nanoTimeNow);
        onCheckPublications(nanoTimeNow);
        onCheckPublicationLinks(nanoTimeNow);
        onCheckConnections(nanoTimeNow);
        onCheckSubscriptionLinks(nanoTimeNow);
    }

    public void onCreateConnection(
        final int sessionId,
        final int streamId,
        final int initialTermId,
        final int activeTermId,
        final int initialTermOffset,
        final int termBufferLength,
        final int senderMtuLength,
        final InetSocketAddress controlAddress,
        final InetSocketAddress sourceAddress,
        final ReceiveChannelEndpoint channelEndpoint)
    {
        channelEndpoint.validateSenderMtuLength(senderMtuLength);
        channelEndpoint.validateWindowMaxLength(initialWindowLength);

        final UdpChannel udpChannel = channelEndpoint.udpChannel();
        final String channel = udpChannel.originalUriString();
        final long connectionCorrelationId = generateCreationCorrelationId();

        final long joiningPosition = LogBufferDescriptor.computePosition(
            activeTermId, initialTermOffset, Integer.numberOfTrailingZeros(termBufferLength), initialTermId);

        final List<SubscriberPosition> subscriberPositions = listSubscriberPositions(
            sessionId, streamId, channelEndpoint, channel, joiningPosition);

        if (subscriberPositions.size() > 0)
        {
            final RawLog rawLog = newConnectionLog(
                sessionId, streamId, initialTermId, termBufferLength, senderMtuLength, udpChannel, connectionCorrelationId);

            final NetworkConnection connection = new NetworkConnection(
                connectionCorrelationId,
                channelEndpoint,
                controlAddress,
                sessionId,
                streamId,
                initialTermId,
                activeTermId,
                initialTermOffset,
                initialWindowLength,
                rawLog,
                Configuration.doNotSendNaks() ? NO_NAK_DELAY_GENERATOR :
                    udpChannel.isMulticast() ? NAK_MULTICAST_DELAY_GENERATOR : NAK_UNICAST_DELAY_GENERATOR,
                subscriberPositions.stream().map(SubscriberPosition::position).collect(toList()),
                newPosition("receiver hwm", channel, sessionId, streamId, connectionCorrelationId),
                nanoClock,
                systemCounters,
                sourceAddress);

            subscriberPositions.forEach(
                (subscriberPosition) ->
                    subscriberPosition.subscription().addConnection(connection, subscriberPosition.position()));

            connections.add(connection);
            receiverProxy.newConnection(channelEndpoint, connection);

            clientProxy.onConnectionReady(
                streamId,
                sessionId,
                joiningPosition,
                rawLog,
                connectionCorrelationId,
                subscriberPositions,
                generateSourceIdentity(sourceAddress));
        }
    }

    public void onCloseResource(final AutoCloseable resource)
    {
        try
        {
            resource.close();
        }
        catch (final Exception ex)
        {
            logger.logException(ex);
        }
    }

    public List<SubscriberPosition> listSubscriberPositions(
        final int sessionId,
        final int streamId,
        final ReceiveChannelEndpoint channelEndpoint,
        final String channel,
        final long joiningPosition)
    {
        return subscriptionLinks
            .stream()
            .filter((subscription) -> subscription.matches(channelEndpoint, streamId))
            .map(
                (subscription) ->
                {
                    final Position position = newPosition(
                        "subscriber pos", channel, sessionId, streamId, subscription.registrationId());

                    position.setOrdered(joiningPosition);

                    return new SubscriberPosition(subscription, position);
                })
            .collect(toList());
    }

    private void onClientCommand(final int msgTypeId, final MutableDirectBuffer buffer, final int index, final int length)
    {
        CorrelatedMessageFlyweight flyweight = null;

        try
        {
            switch (msgTypeId)
            {
                case ADD_PUBLICATION:
                {
                    logger.log(EventCode.CMD_IN_ADD_PUBLICATION, buffer, index, length);

                    final PublicationMessageFlyweight publicationMessageFlyweight = publicationMsgFlyweight;
                    publicationMessageFlyweight.offset(index);
                    flyweight = publicationMessageFlyweight;

                    onAddPublication(
                        publicationMessageFlyweight.channel(),
                        publicationMessageFlyweight.sessionId(),
                        publicationMessageFlyweight.streamId(),
                        publicationMessageFlyweight.correlationId(),
                        publicationMessageFlyweight.clientId());
                    break;
                }

                case REMOVE_PUBLICATION:
                {
                    logger.log(EventCode.CMD_IN_REMOVE_PUBLICATION, buffer, index, length);

                    final RemoveMessageFlyweight removeMessageFlyweight = removeMsgFlyweight;
                    removeMessageFlyweight.offset(index);
                    flyweight = removeMessageFlyweight;

                    onRemovePublication(removeMessageFlyweight.registrationId(), removeMessageFlyweight.correlationId());
                    break;
                }

                case ADD_SUBSCRIPTION:
                {
                    logger.log(EventCode.CMD_IN_ADD_SUBSCRIPTION, buffer, index, length);

                    final SubscriptionMessageFlyweight subscriptionMessageFlyweight = subscriptionMsgFlyweight;
                    subscriptionMessageFlyweight.offset(index);
                    flyweight = subscriptionMessageFlyweight;

                    onAddSubscription(
                        subscriptionMessageFlyweight.channel(),
                        subscriptionMessageFlyweight.streamId(),
                        subscriptionMessageFlyweight.correlationId(),
                        subscriptionMessageFlyweight.clientId());
                    break;
                }

                case REMOVE_SUBSCRIPTION:
                {
                    logger.log(EventCode.CMD_IN_REMOVE_SUBSCRIPTION, buffer, index, length);

                    final RemoveMessageFlyweight removeMessageFlyweight = removeMsgFlyweight;
                    removeMessageFlyweight.offset(index);
                    flyweight = removeMessageFlyweight;

                    onRemoveSubscription(removeMessageFlyweight.registrationId(), removeMessageFlyweight.correlationId());
                    break;
                }

                case CLIENT_KEEPALIVE:
                {
                    logger.log(EventCode.CMD_IN_KEEPALIVE_CLIENT, buffer, index, length);

                    final CorrelatedMessageFlyweight correlatedMessageFlyweight = correlatedMsgFlyweight;
                    correlatedMessageFlyweight.offset(index);
                    flyweight = correlatedMessageFlyweight;

                    onClientKeepalive(correlatedMessageFlyweight.clientId());
                    break;
                }
            }
        }
        catch (final ControlProtocolException ex)
        {
            clientProxy.onError(ex.errorCode(), ex.getMessage(), flyweight);
            logger.logException(ex);
        }
        catch (final Exception ex)
        {
            clientProxy.onError(GENERIC_ERROR, ex.getMessage(), flyweight);
            logger.logException(ex);
        }
    }

    private int processTimers(final long now)
    {
        int workCount = 0;

        if (now > (timeOfLastTimeoutCheck + HEARTBEAT_TIMEOUT_NS))
        {
            onHeartbeatCheckTimeouts(now);
            timeOfLastTimeoutCheck = now;
            workCount = 1;
        }

        return workCount;
    }

    private void onAddPublication(
        final String channel, final int sessionId, final int streamId, final long registrationId, final long clientId)
    {
        final UdpChannel udpChannel = UdpChannel.parse(channel);
        final SendChannelEndpoint channelEndpoint = getOrCreateSendChannelEndpoint(udpChannel);

        NetworkPublication publication = channelEndpoint.getPublication(sessionId, streamId);
        if (null == publication)
        {
            final int initialTermId = BitUtil.generateRandomisedId();
            final FlowControl flowControl = udpChannel.isMulticast() ? multicastFlowControl.get() : unicastFlowControl.get();

            final RetransmitHandler retransmitHandler = new RetransmitHandler(
                nanoClock,
                systemCounters,
                RETRANSMIT_UNICAST_DELAY_GENERATOR,
                RETRANSMIT_UNICAST_LINGER_GENERATOR,
                initialTermId,
                termBufferLength);

            publication = new NetworkPublication(
                channelEndpoint,
                nanoClock,
                newPublicationLog(sessionId, streamId, initialTermId, udpChannel, registrationId),
                newPosition("sender pos", channel, sessionId, streamId, registrationId),
                newPosition("publisher limit", channel, sessionId, streamId, registrationId),
                sessionId,
                streamId,
                initialTermId,
                mtuLength,
                flowControl.initialPositionLimit(initialTermId, termBufferLength),
                systemCounters,
                flowControl,
                retransmitHandler);

            channelEndpoint.addPublication(publication);
            publications.add(publication);
            senderProxy.newPublication(publication);
        }

        final AeronClient client = getOrAddClient(clientId);
        linkPublication(registrationId, publication, client);

        publication.incRef();

        clientProxy.onPublicationReady(
            streamId,
            sessionId,
            publication.rawLog(),
            registrationId,
            publication.publisherLimitId());
    }

    private void linkPublication(final long registrationId, final NetworkPublication publication, final AeronClient client)
    {
        if (null != findPublicationLink(publicationLinks, registrationId))
        {
            throw new ControlProtocolException(GENERIC_ERROR, "registration id already in use.");
        }

        publicationLinks.add(new PublicationLink(registrationId, publication, client));
    }

    private RawLog newPublicationLog(
        final int sessionId, final int streamId, final int initialTermId, final UdpChannel udpChannel, final long registrationId)
    {
        final String canonicalForm = udpChannel.canonicalForm();
        final RawLog rawLog = rawLogFactory.newPublication(canonicalForm, sessionId, streamId, registrationId);

        final MutableDirectBuffer header = DataHeaderFlyweight.createDefaultHeader(sessionId, streamId, initialTermId);
        final UnsafeBuffer logMetaData = rawLog.logMetaData();
        LogBufferDescriptor.storeDefaultFrameHeaders(logMetaData, header);
        LogBufferDescriptor.initialTermId(logMetaData, initialTermId);
        LogBufferDescriptor.mtuLength(logMetaData, mtuLength);

        return rawLog;
    }

    private RawLog newConnectionLog(
        final int sessionId,
        final int streamId,
        final int initialTermId,
        final int termBufferLength,
        final int senderMtuLength,
        final UdpChannel udpChannel,
        final long correlationId)
    {
        final String canonicalForm = udpChannel.canonicalForm();
        final RawLog rawLog = rawLogFactory.newConnection(canonicalForm, sessionId, streamId, correlationId, termBufferLength);

        final MutableDirectBuffer header = DataHeaderFlyweight.createDefaultHeader(sessionId, streamId, initialTermId);
        final UnsafeBuffer logMetaData = rawLog.logMetaData();
        LogBufferDescriptor.storeDefaultFrameHeaders(logMetaData, header);
        LogBufferDescriptor.initialTermId(logMetaData, initialTermId);
        LogBufferDescriptor.mtuLength(logMetaData, senderMtuLength);

        return rawLog;
    }

    private SendChannelEndpoint getOrCreateSendChannelEndpoint(final UdpChannel udpChannel)
    {
        SendChannelEndpoint channelEndpoint = sendChannelEndpointByChannelMap.get(udpChannel.canonicalForm());
        if (null == channelEndpoint)
        {
            logger.logChannelCreated(udpChannel.description());

            channelEndpoint = new SendChannelEndpoint(
                udpChannel,
                logger,
                controlLossGenerator,
                systemCounters);

            sendChannelEndpointByChannelMap.put(udpChannel.canonicalForm(), channelEndpoint);
            senderProxy.registerSendChannelEndpoint(channelEndpoint);
        }

        return channelEndpoint;
    }

    private void onRemovePublication(final long registrationId, final long correlationId)
    {
        PublicationLink publicationLink = null;
        final ArrayList<PublicationLink> publicationLinks = this.publicationLinks;
        for (int i = 0, size = publicationLinks.size(); i < size; i++)
        {
            final PublicationLink link = publicationLinks.get(i);
            if (registrationId == link.registrationId())
            {
                publicationLink = link;
                publicationLinks.remove(i);
                break;
            }
        }

        if (null == publicationLink)
        {
            throw new ControlProtocolException(UNKNOWN_PUBLICATION, "Unknown publication: " + registrationId);
        }

        publicationLink.remove();
        clientProxy.operationSucceeded(correlationId);
    }

    private void onAddSubscription(final String channel, final int streamId, final long registrationId, final long clientId)
    {
        final ReceiveChannelEndpoint channelEndpoint = getOrCreateReceiveChannelEndpoint(UdpChannel.parse(channel));

        final int refCount = channelEndpoint.incRefToStream(streamId);
        if (1 == refCount)
        {
            receiverProxy.addSubscription(channelEndpoint, streamId);
        }

        final AeronClient client = getOrAddClient(clientId);
        final SubscriptionLink subscription = new SubscriptionLink(registrationId, channelEndpoint, streamId, client);

        subscriptionLinks.add(subscription);
        clientProxy.operationSucceeded(registrationId);

        connections
            .stream()
            .filter((connection) -> connection.matches(channelEndpoint, streamId) && (connection.subscriberCount() > 0))
            .forEach(
                (connection) ->
                {
                    final Position position = newPosition(
                        "subscriber pos", channel, connection.sessionId(), streamId, registrationId);

                    connection.addSubscriber(position);
                    subscription.addConnection(connection, position);

                    clientProxy.onConnectionReady(
                        streamId,
                        connection.sessionId(),
                        connection.rebuildPosition(),
                        connection.rawLog(),
                        connection.correlationId(),
                        Collections.singletonList(new SubscriberPosition(subscription, position)),
                        generateSourceIdentity(connection.sourceAddress()));
                });
    }

    private ReceiveChannelEndpoint getOrCreateReceiveChannelEndpoint(final UdpChannel udpChannel)
    {
        ReceiveChannelEndpoint channelEndpoint = receiveChannelEndpointByChannelMap.get(udpChannel.canonicalForm());
        if (null == channelEndpoint)
        {
            channelEndpoint = new ReceiveChannelEndpoint(
                udpChannel,
                new DataPacketDispatcher(fromReceiverConductorProxy, receiverProxy.receiver()),
                logger,
                systemCounters,
                dataLossGenerator);

            receiveChannelEndpointByChannelMap.put(udpChannel.canonicalForm(), channelEndpoint);
            receiverProxy.registerReceiveChannelEndpoint(channelEndpoint);
        }

        return channelEndpoint;
    }

    private void onRemoveSubscription(final long registrationId, final long correlationId)
    {
        final SubscriptionLink subscription = removeSubscription(subscriptionLinks, registrationId);
        if (null == subscription)
        {
            throw new ControlProtocolException(UNKNOWN_SUBSCRIPTION, "Unknown subscription: " + registrationId);
        }

        subscription.close();
        final ReceiveChannelEndpoint channelEndpoint = subscription.channelEndpoint();

        final int refCount = channelEndpoint.decRefToStream(subscription.streamId());
        if (0 == refCount)
        {
            receiverProxy.removeSubscription(channelEndpoint, subscription.streamId());
        }

        if (0 == channelEndpoint.streamCount())
        {
            receiveChannelEndpointByChannelMap.remove(channelEndpoint.udpChannel().canonicalForm());
            receiverProxy.closeReceiveChannelEndpoint(channelEndpoint);

            while (!channelEndpoint.isClosed())
            {
                Thread.yield();
            }
        }

        clientProxy.operationSucceeded(correlationId);
    }

    private void onClientKeepalive(final long clientId)
    {
        systemCounters.clientKeepAlives().addOrdered(1);

        final AeronClient client = findClient(clients, clientId);
        if (null != client)
        {
            client.timeOfLastKeepalive(nanoClock.nanoTime());
        }
    }

    private void onCheckPublicationLinks(final long now)
    {
        final ArrayList<PublicationLink> publicationLinks = this.publicationLinks;
        for (int i = publicationLinks.size() - 1; i >= 0; i--)
        {
            final PublicationLink link = publicationLinks.get(i);
            if (link.hasClientTimedOut(now))
            {
                publicationLinks.remove(i);
            }
        }
    }

    private void onCheckPublications(final long now)
    {
        final ArrayList<NetworkPublication> publications = this.publications;
        for (int i = publications.size() - 1; i >= 0; i--)
        {
            final NetworkPublication publication = publications.get(i);

            if (publication.isUnreferencedAndFlushed(now) && now > (publication.timeOfFlush() + PUBLICATION_LINGER_NS))
            {
                final SendChannelEndpoint channelEndpoint = publication.sendChannelEndpoint();

                logger.logPublicationRemoval(
                    channelEndpoint.originalUriString(), publication.sessionId(), publication.streamId());

                channelEndpoint.removePublication(publication);
                publications.remove(i);

                senderProxy.removePublication(publication);

                if (channelEndpoint.sessionCount() == 0)
                {
                    sendChannelEndpointByChannelMap.remove(channelEndpoint.udpChannel().canonicalForm());
                    senderProxy.closeSendChannelEndpoint(channelEndpoint);
                }
            }
        }
    }

    private void onCheckSubscriptionLinks(final long now)
    {
        final ArrayList<SubscriptionLink> subscriptions = this.subscriptionLinks;
        for (int i = subscriptions.size() - 1; i >= 0; i--)
        {
            final SubscriptionLink subscription = subscriptions.get(i);

            if (now > (subscription.timeOfLastKeepaliveFromClient() + CLIENT_LIVENESS_TIMEOUT_NS))
            {
                final ReceiveChannelEndpoint channelEndpoint = subscription.channelEndpoint();
                final int streamId = subscription.streamId();

                logger.logSubscriptionRemoval(
                    channelEndpoint.originalUriString(), subscription.streamId(), subscription.registrationId());

                subscriptions.remove(i);
                subscription.close();

                if (0 == channelEndpoint.decRefToStream(subscription.streamId()))
                {
                    receiverProxy.removeSubscription(channelEndpoint, streamId);
                }

                if (channelEndpoint.streamCount() == 0)
                {
                    receiveChannelEndpointByChannelMap.remove(channelEndpoint.udpChannel().canonicalForm());
                    receiverProxy.closeReceiveChannelEndpoint(channelEndpoint);
                }
            }
        }
    }

    private void onCheckConnections(final long now)
    {
        final ArrayList<NetworkConnection> connections = this.connections;
        for (int i = connections.size() - 1; i >= 0; i--)
        {
            final NetworkConnection conn = connections.get(i);

            switch (conn.status())
            {
                case INACTIVE:
                    if (conn.isDrained() || now > (conn.timeOfLastStatusChange() + CONNECTION_LIVENESS_TIMEOUT_NS))
                    {
                        conn.status(NetworkConnection.Status.LINGER);

                        clientProxy.onInactiveConnection(
                            conn.correlationId(),
                            conn.sessionId(),
                            conn.streamId(),
                            conn.rebuildPosition(),
                            conn.channelUriString());
                    }
                    break;

                case LINGER:
                    if (now > (conn.timeOfLastStatusChange() + CONNECTION_LIVENESS_TIMEOUT_NS))
                    {
                        logger.logConnectionRemoval(
                            conn.channelUriString(), conn.sessionId(), conn.streamId(), conn.correlationId());

                        connections.remove(i);

                        subscriptionLinks.stream()
                            .filter((link) -> conn.matches(link.channelEndpoint(), link.streamId()))
                            .forEach((subscriptionLink) -> subscriptionLink.removeConnection(conn));

                        conn.close();
                    }
                    break;
            }
        }
    }

    private void onCheckClients(final long now)
    {
        for (int i = clients.size() - 1; i >= 0; i--)
        {
            final AeronClient client = clients.get(i);

            if (now > (client.timeOfLastKeepalive() + CONNECTION_LIVENESS_TIMEOUT_NS))
            {
                clients.remove(i);
            }
        }
    }

    private void onDriverConductorCmd(final DriverConductorCmd cmd)
    {
        cmd.execute(this);
    }

    private AeronClient getOrAddClient(final long clientId)
    {
        AeronClient client = findClient(clients, clientId);
        if (null == client)
        {
            client = new AeronClient(clientId, nanoClock.nanoTime());
            clients.add(client);
        }

        return client;
    }

    private Position newPosition(
        final String name, final String channel, final int sessionId, final int streamId, final long correlationId)
    {
        final int positionId = allocateCounter(name, channel, sessionId, streamId, correlationId);
        return new UnsafeBufferPosition(countersBuffer, positionId, countersManager);
    }

    private int allocateCounter(
        final String type, final String channel, final int sessionId, final int streamId, final long correlationId)
    {
        return countersManager.allocate(String.format("%s: %s %d %d %d", type, channel, sessionId, streamId, correlationId));
    }

    private long generateCreationCorrelationId()
    {
        return toDriverCommands.nextCorrelationId();
    }
}

<code block>

package uk.co.real_logic.aeron.driver;

import uk.co.real_logic.aeron.driver.cmd.*;
import uk.co.real_logic.aeron.driver.media.SendChannelEndpoint;
import uk.co.real_logic.agrona.concurrent.AtomicCounter;

import java.util.Queue;

import static uk.co.real_logic.aeron.driver.ThreadingMode.SHARED;


public class SenderProxy
{
    private final ThreadingMode threadingMode;
    private final Queue<SenderCmd> commandQueue;
    private final AtomicCounter failCount;
    private Sender sender;

    public SenderProxy(final ThreadingMode threadingMode, final Queue<SenderCmd> commandQueue, final AtomicCounter failCount)
    {
        this.threadingMode = threadingMode;
        this.commandQueue = commandQueue;
        this.failCount = failCount;
    }

    public void sender(final Sender sender)
    {
        this.sender = sender;
    }

    public void registerSendChannelEndpoint(final SendChannelEndpoint channelEndpoint)
    {
        if (isSharedThread())
        {
            sender.onRegisterSendChannelEndpoint(channelEndpoint);
        }
        else
        {
            offer(new RegisterSendChannelEndpointCmd(channelEndpoint));
        }
    }

    public void closeSendChannelEndpoint(final SendChannelEndpoint channelEndpoint)
    {
        if (isSharedThread())
        {
            sender.onCloseSendChannelEndpoint(channelEndpoint);
        }
        else
        {
            offer(new CloseSendChannelEndpointCmd(channelEndpoint));
        }
    }

    public void removePublication(final NetworkPublication publication)
    {
        if (isSharedThread())
        {
            sender.onRemovePublication(publication);
        }
        else
        {
            offer(new RemovePublicationCmd(publication));
        }
    }

    public void newPublication(final NetworkPublication publication)
    {
        if (isSharedThread())
        {
            sender.onNewPublication(publication);
        }
        else
        {
            offer(new NewPublicationCmd(publication));
        }
    }

    private boolean isSharedThread()
    {
        return threadingMode == SHARED;
    }

    private void offer(final SenderCmd cmd)
    {
        while (!commandQueue.offer(cmd))
        {
            failCount.orderedIncrement();
            Thread.yield();
        }
    }
}

<code block>

package uk.co.real_logic.aeron.driver.media;

import uk.co.real_logic.aeron.driver.event.EventLogger;
import uk.co.real_logic.aeron.protocol.NakFlyweight;
import uk.co.real_logic.aeron.protocol.StatusMessageFlyweight;
import uk.co.real_logic.aeron.driver.*;
import uk.co.real_logic.agrona.collections.BiInt2ObjectMap;
import uk.co.real_logic.agrona.concurrent.AtomicCounter;
import uk.co.real_logic.agrona.concurrent.UnsafeBuffer;

import java.net.InetSocketAddress;

import static uk.co.real_logic.aeron.logbuffer.FrameDescriptor.frameType;
import static uk.co.real_logic.aeron.protocol.HeaderFlyweight.HDR_TYPE_NAK;
import static uk.co.real_logic.aeron.protocol.HeaderFlyweight.HDR_TYPE_SM;
import static uk.co.real_logic.aeron.protocol.StatusMessageFlyweight.SEND_SETUP_FLAG;


public class SendChannelEndpoint extends UdpChannelTransport
{
    private final NakFlyweight nakMessage = new NakFlyweight();
    private final StatusMessageFlyweight statusMessage = new StatusMessageFlyweight();

    private final BiInt2ObjectMap<NetworkPublication> driversPublicationByStreamAndSessionId = new BiInt2ObjectMap<>();
    private final BiInt2ObjectMap<NetworkPublication> sendersPublicationByStreamAndSessionId = new BiInt2ObjectMap<>();

    private final AtomicCounter nakMessagesReceived;
    private final AtomicCounter statusMessagesReceived;

    public SendChannelEndpoint(
        final UdpChannel udpChannel,
        final EventLogger logger,
        final LossGenerator lossGenerator,
        final SystemCounters systemCounters)
    {
        super(
            udpChannel,
            udpChannel.remoteControl(),
            udpChannel.localControl(),
            udpChannel.remoteData(),
            lossGenerator,
            logger);

        this.nakMessagesReceived = systemCounters.nakMessagesReceived();
        this.statusMessagesReceived = systemCounters.statusMessagesReceived();

        nakMessage.wrap(receiveBuffer(), 0);
        statusMessage.wrap(receiveBuffer(), 0);
    }

    
    public void openChannel()
    {
        openDatagramChannel();
    }

    public String originalUriString()
    {
        return udpChannel().originalUriString();
    }

    
    public NetworkPublication getPublication(final int sessionId, final int streamId)
    {
        return driversPublicationByStreamAndSessionId.get(sessionId, streamId);
    }

    
    public void addPublication(final NetworkPublication publication)
    {
        driversPublicationByStreamAndSessionId.put(publication.sessionId(), publication.streamId(), publication);
    }

    
    public NetworkPublication removePublication(final NetworkPublication publication)
    {
        return driversPublicationByStreamAndSessionId.remove(publication.sessionId(), publication.streamId());
    }

    
    public int sessionCount()
    {
        return driversPublicationByStreamAndSessionId.size();
    }

    
    public void addToDispatcher(final NetworkPublication publication)
    {
        sendersPublicationByStreamAndSessionId.put(publication.sessionId(), publication.streamId(), publication);
    }

    
    public void removeFromDispatcher(final NetworkPublication publication)
    {
        sendersPublicationByStreamAndSessionId.remove(publication.sessionId(), publication.streamId());
    }

    protected int dispatch(final UnsafeBuffer buffer, final int length, final InetSocketAddress srcAddress)
    {
        int framesRead = 0;
        switch (frameType(buffer, 0))
        {
            case HDR_TYPE_NAK:
                onNakMessage(nakMessage);
                framesRead = 1;
                break;

            case HDR_TYPE_SM:
                onStatusMessage(statusMessage, srcAddress);
                framesRead = 1;
                break;
        }

        return framesRead;
    }

    private void onStatusMessage(final StatusMessageFlyweight statusMsg, final InetSocketAddress srcAddress)
    {
        final NetworkPublication publication = sendersPublicationByStreamAndSessionId.get(
            statusMsg.sessionId(), statusMsg.streamId());
        if (null != publication)
        {
            if (SEND_SETUP_FLAG == (statusMsg.flags() & SEND_SETUP_FLAG))
            {
                publication.triggerSendSetupFrame();
            }
            else
            {
                publication.onStatusMessage(
                    statusMsg.consumptionTermId(),
                    statusMsg.consumptionTermOffset(),
                    statusMsg.receiverWindowLength(),
                    srcAddress);
            }

            statusMessagesReceived.orderedIncrement();
        }
    }

    private void onNakMessage(final NakFlyweight nakMsg)
    {
        final NetworkPublication publication = sendersPublicationByStreamAndSessionId.get(nakMsg.sessionId(), nakMsg.streamId());
        if (null != publication)
        {
            publication.onNak(nakMsg.termId(), nakMsg.termOffset(), nakMsg.length());
            nakMessagesReceived.orderedIncrement();
        }
    }
}

<code block>

package uk.co.real_logic.aeron.driver.cmd;

import uk.co.real_logic.aeron.driver.NetworkPublication;
import uk.co.real_logic.aeron.driver.Sender;

public class NewPublicationCmd implements SenderCmd
{
    private final NetworkPublication publication;

    public NewPublicationCmd(final NetworkPublication publication)
    {
        this.publication = publication;
    }

    public void execute(final Sender sender)
    {
        sender.onNewPublication(publication);
    }
}

<code block>

package uk.co.real_logic.aeron.driver;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.mockito.stubbing.Answer;
import uk.co.real_logic.aeron.driver.buffer.RawLog;
import uk.co.real_logic.aeron.driver.cmd.NewPublicationCmd;
import uk.co.real_logic.aeron.driver.cmd.SenderCmd;
import uk.co.real_logic.aeron.driver.event.EventLogger;
import uk.co.real_logic.aeron.driver.media.SendChannelEndpoint;
import uk.co.real_logic.aeron.driver.media.TransportPoller;
import uk.co.real_logic.aeron.driver.media.UdpChannel;
import uk.co.real_logic.aeron.logbuffer.LogBufferDescriptor;
import uk.co.real_logic.aeron.logbuffer.TermAppender;
import uk.co.real_logic.aeron.protocol.DataHeaderFlyweight;
import uk.co.real_logic.aeron.protocol.HeaderFlyweight;
import uk.co.real_logic.aeron.protocol.SetupFlyweight;
import uk.co.real_logic.agrona.MutableDirectBuffer;
import uk.co.real_logic.agrona.concurrent.AtomicCounter;
import uk.co.real_logic.agrona.concurrent.OneToOneConcurrentArrayQueue;
import uk.co.real_logic.agrona.concurrent.UnsafeBuffer;
import uk.co.real_logic.agrona.concurrent.status.AtomicLongPosition;
import uk.co.real_logic.agrona.concurrent.status.Position;

import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.util.ArrayDeque;
import java.util.Queue;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.greaterThanOrEqualTo;
import static org.hamcrest.core.Is.is;
import static org.mockito.Mockito.*;
import static uk.co.real_logic.aeron.logbuffer.FrameDescriptor.FRAME_ALIGNMENT;
import static uk.co.real_logic.agrona.BitUtil.align;

public class SenderTest
{
    private static final int TERM_BUFFER_LENGTH = LogBufferDescriptor.TERM_MIN_LENGTH;
    private static final int MAX_FRAME_LENGTH = 1024;
    private static final int SESSION_ID = 1;
    private static final int STREAM_ID = 2;
    private static final int INITIAL_TERM_ID = 3;
    private static final byte[] PAYLOAD = "Payload is here!".getBytes();

    private static final MutableDirectBuffer HEADER =
        DataHeaderFlyweight.createDefaultHeader(SESSION_ID, STREAM_ID, INITIAL_TERM_ID);
    private static final int ALIGNED_FRAME_LENGTH = align(HEADER.capacity() + PAYLOAD.length, FRAME_ALIGNMENT);

    private final EventLogger mockLogger = mock(EventLogger.class);
    private final TransportPoller mockTransportPoller = mock(TransportPoller.class);

    private final RawLog rawLog =
        LogBufferHelper.newTestLogBuffers(TERM_BUFFER_LENGTH, LogBufferDescriptor.TERM_META_DATA_LENGTH);

    private TermAppender[] termAppenders;
    private NetworkPublication publication;
    private Sender sender;

    private final FlowControl flowControl = spy(new UnicastFlowControl());
    private final RetransmitHandler mockRetransmitHandler = mock(RetransmitHandler.class);

    private long currentTimestamp = 0;

    private final Queue<ByteBuffer> receivedFrames = new ArrayDeque<>();

    private final UdpChannel udpChannel = UdpChannel.parse("udp:
    private final InetSocketAddress rcvAddress = udpChannel.remoteData();
    private final DataHeaderFlyweight dataHeader = new DataHeaderFlyweight();
    private final SetupFlyweight setupHeader = new SetupFlyweight();
    private final SystemCounters mockSystemCounters = mock(SystemCounters.class);
    private final OneToOneConcurrentArrayQueue<SenderCmd> senderCommandQueue = new OneToOneConcurrentArrayQueue<>(1024);

    private Answer<Integer> saveByteBufferAnswer =
        (invocation) ->
        {
            final Object args[] = invocation.getArguments();
            final ByteBuffer buffer = (ByteBuffer)args[0];

            final int length = buffer.limit() - buffer.position();
            receivedFrames.add(ByteBuffer.allocateDirect(length).put(buffer));

            
            return length;
        };

    @Before
    public void setUp() throws Exception
    {
        final SendChannelEndpoint mockSendChannelEndpoint = mock(SendChannelEndpoint.class);
        when(mockSendChannelEndpoint.udpChannel()).thenReturn(udpChannel);
        when(mockSendChannelEndpoint.send(anyObject())).thenAnswer(saveByteBufferAnswer);
        when(mockSystemCounters.heartbeatsSent()).thenReturn(mock(AtomicCounter.class));
        when(mockSystemCounters.bytesSent()).thenReturn(mock(AtomicCounter.class));
        when(mockSystemCounters.senderFlowControlLimits()).thenReturn(mock(AtomicCounter.class));

        sender = new Sender(
            new MediaDriver.Context()
                .senderNioSelector(mockTransportPoller)
                .systemCounters(mockSystemCounters)
                .senderCommandQueue(senderCommandQueue)
                .eventLogger(mockLogger)
                .nanoClock(() -> currentTimestamp));

        termAppenders = rawLog
            .stream()
            .map((log) -> new TermAppender(log.termBuffer(), log.metaDataBuffer(), HEADER, MAX_FRAME_LENGTH))
            .toArray(TermAppender[]::new);

        publication = new NetworkPublication(
            mockSendChannelEndpoint,
            () -> currentTimestamp,
            rawLog,
            new AtomicLongPosition(),
            mock(Position.class),
            SESSION_ID,
            STREAM_ID,
            INITIAL_TERM_ID,
            MAX_FRAME_LENGTH,
            flowControl.initialPositionLimit(INITIAL_TERM_ID, TERM_BUFFER_LENGTH),
            mockSystemCounters,
            flowControl,
            mockRetransmitHandler);

        senderCommandQueue.offer(new NewPublicationCmd(publication));
    }

    @After
    public void tearDown() throws Exception
    {
        sender.onClose();
    }

    @Test
    public void shouldSendSetupFrameOnChannelWhenTimeoutWithoutStatusMessage() throws Exception
    {
        currentTimestamp += Configuration.PUBLICATION_SETUP_TIMEOUT_NS - 1;
        sender.doWork();
        assertThat(receivedFrames.size(), is(0));
        currentTimestamp += 10;
        sender.doWork();
        assertThat(receivedFrames.size(), is(1));

        setupHeader.wrap(receivedFrames.remove(), 0);
        assertThat(setupHeader.frameLength(), is(SetupFlyweight.HEADER_LENGTH));
        assertThat(setupHeader.initialTermId(), is(INITIAL_TERM_ID));
        assertThat(setupHeader.activeTermId(), is(INITIAL_TERM_ID));
        assertThat(setupHeader.streamId(), is(STREAM_ID));
        assertThat(setupHeader.sessionId(), is(SESSION_ID));
        assertThat(setupHeader.headerType(), is(HeaderFlyweight.HDR_TYPE_SETUP));
        assertThat(setupHeader.flags(), is((short)0));
        assertThat(setupHeader.version(), is((short)HeaderFlyweight.CURRENT_VERSION));
    }

    @Test
    public void shouldSendMultipleSetupFramesOnChannelWhenTimeoutWithoutStatusMessage() throws Exception
    {
        currentTimestamp += Configuration.PUBLICATION_SETUP_TIMEOUT_NS - 1;
        sender.doWork();
        assertThat(receivedFrames.size(), is(0));
        currentTimestamp += 10;
        sender.doWork();
        assertThat(receivedFrames.size(), is(1));

        currentTimestamp += Configuration.PUBLICATION_SETUP_TIMEOUT_NS - 1;
        sender.doWork();
        currentTimestamp += 10;
        sender.doWork();

        assertThat(receivedFrames.size(), is(2));
    }

    @Test
    public void shouldNotSendSetupFrameAfterReceivingStatusMessage() throws Exception
    {
        currentTimestamp += Configuration.PUBLICATION_SETUP_TIMEOUT_NS - 1;

        publication.senderPositionLimit(flowControl.onStatusMessage(INITIAL_TERM_ID, 0, 0, rcvAddress));
        sender.doWork();

        assertThat(receivedFrames.size(), is(0));
    }

    @Test
    public void shouldBeAbleToSendOnChannel() throws Exception
    {
        publication.senderPositionLimit(
            flowControl.onStatusMessage(INITIAL_TERM_ID, 0, ALIGNED_FRAME_LENGTH, rcvAddress));

        final UnsafeBuffer buffer = new UnsafeBuffer(ByteBuffer.allocateDirect(PAYLOAD.length));
        buffer.putBytes(0, PAYLOAD);

        termAppenders[0].append(buffer, 0, PAYLOAD.length);
        sender.doWork();

        assertThat(receivedFrames.size(), is(1));

        dataHeader.wrap(receivedFrames.remove(), 0);

        assertThat(dataHeader.frameLength(), is(ALIGNED_FRAME_LENGTH));
        assertThat(dataHeader.termId(), is(INITIAL_TERM_ID));
        assertThat(dataHeader.streamId(), is(STREAM_ID));
        assertThat(dataHeader.sessionId(), is(SESSION_ID));
        assertThat(dataHeader.termOffset(), is(offsetOfMessage(1)));
        assertThat(dataHeader.headerType(), is(HeaderFlyweight.HDR_TYPE_DATA));
        assertThat(dataHeader.flags(), is(DataHeaderFlyweight.BEGIN_AND_END_FLAGS));
        assertThat(dataHeader.version(), is((short)HeaderFlyweight.CURRENT_VERSION));
    }

    @Test
    public void shouldBeAbleToSendOnChannelTwice() throws Exception
    {
        publication.senderPositionLimit(
            flowControl.onStatusMessage(INITIAL_TERM_ID, 0, (2 * ALIGNED_FRAME_LENGTH), rcvAddress));

        final UnsafeBuffer buffer = new UnsafeBuffer(ByteBuffer.allocateDirect(PAYLOAD.length));
        buffer.putBytes(0, PAYLOAD);

        termAppenders[0].append(buffer, 0, PAYLOAD.length);
        sender.doWork();
        termAppenders[0].append(buffer, 0, PAYLOAD.length);
        sender.doWork();

        assertThat(receivedFrames.size(), is(2));

        dataHeader.wrap(receivedFrames.remove(), 0);

        assertThat(dataHeader.frameLength(), is(ALIGNED_FRAME_LENGTH));
        assertThat(dataHeader.termId(), is(INITIAL_TERM_ID));
        assertThat(dataHeader.streamId(), is(STREAM_ID));
        assertThat(dataHeader.sessionId(), is(SESSION_ID));
        assertThat(dataHeader.termOffset(), is(offsetOfMessage(1)));
        assertThat(dataHeader.headerType(), is(HeaderFlyweight.HDR_TYPE_DATA));
        assertThat(dataHeader.flags(), is(DataHeaderFlyweight.BEGIN_AND_END_FLAGS));
        assertThat(dataHeader.version(), is((short)HeaderFlyweight.CURRENT_VERSION));

        dataHeader.wrap(receivedFrames.remove(), 0);
        assertThat(dataHeader.frameLength(), is(ALIGNED_FRAME_LENGTH));
        assertThat(dataHeader.termId(), is(INITIAL_TERM_ID));
        assertThat(dataHeader.streamId(), is(STREAM_ID));
        assertThat(dataHeader.sessionId(), is(SESSION_ID));
        assertThat(dataHeader.termOffset(), is(offsetOfMessage(2)));
        assertThat(dataHeader.headerType(), is(HeaderFlyweight.HDR_TYPE_DATA));
        assertThat(dataHeader.flags(), is(DataHeaderFlyweight.BEGIN_AND_END_FLAGS));
        assertThat(dataHeader.version(), is((short)HeaderFlyweight.CURRENT_VERSION));
    }

    @Test
    public void shouldBeAbleToSendOnChannelTwiceAsBatch() throws Exception
    {
        publication.senderPositionLimit(
            flowControl.onStatusMessage(INITIAL_TERM_ID, 0, (2 * ALIGNED_FRAME_LENGTH), rcvAddress));

        final UnsafeBuffer buffer = new UnsafeBuffer(ByteBuffer.allocateDirect(PAYLOAD.length));
        buffer.putBytes(0, PAYLOAD);

        termAppenders[0].append(buffer, 0, PAYLOAD.length);
        termAppenders[0].append(buffer, 0, PAYLOAD.length);
        sender.doWork();

        assertThat(receivedFrames.size(), is(1));
        final ByteBuffer frame = receivedFrames.remove();

        dataHeader.wrap(frame, 0);
        assertThat(dataHeader.frameLength(), is(ALIGNED_FRAME_LENGTH));
        assertThat(dataHeader.termId(), is(INITIAL_TERM_ID));
        assertThat(dataHeader.streamId(), is(STREAM_ID));
        assertThat(dataHeader.sessionId(), is(SESSION_ID));
        assertThat(dataHeader.termOffset(), is(offsetOfMessage(1)));
        assertThat(dataHeader.headerType(), is(HeaderFlyweight.HDR_TYPE_DATA));
        assertThat(dataHeader.flags(), is(DataHeaderFlyweight.BEGIN_AND_END_FLAGS));
        assertThat(dataHeader.version(), is((short)HeaderFlyweight.CURRENT_VERSION));

        dataHeader.wrap(frame, offsetOfMessage(2));
        assertThat(dataHeader.frameLength(), is(ALIGNED_FRAME_LENGTH));
        assertThat(dataHeader.termId(), is(INITIAL_TERM_ID));
        assertThat(dataHeader.streamId(), is(STREAM_ID));
        assertThat(dataHeader.sessionId(), is(SESSION_ID));
        assertThat(dataHeader.termOffset(), is(offsetOfMessage(2)));
        assertThat(dataHeader.headerType(), is(HeaderFlyweight.HDR_TYPE_DATA));
        assertThat(dataHeader.flags(), is(DataHeaderFlyweight.BEGIN_AND_END_FLAGS));
        assertThat(dataHeader.version(), is((short)HeaderFlyweight.CURRENT_VERSION));
    }

    @Test
    public void shouldNotSendUntilStatusMessageReceived() throws Exception
    {
        final UnsafeBuffer buffer = new UnsafeBuffer(ByteBuffer.allocateDirect(PAYLOAD.length));
        buffer.putBytes(0, PAYLOAD);
        termAppenders[0].append(buffer, 0, PAYLOAD.length);

        sender.doWork();
        assertThat(receivedFrames.size(), is(0));

        publication.senderPositionLimit(
            flowControl.onStatusMessage(INITIAL_TERM_ID, 0, ALIGNED_FRAME_LENGTH, rcvAddress));
        sender.doWork();

        assertThat(receivedFrames.size(), is(1));

        dataHeader.wrap(receivedFrames.remove(), 0);

        assertThat(dataHeader.frameLength(), is(ALIGNED_FRAME_LENGTH));
        assertThat(dataHeader.termId(), is(INITIAL_TERM_ID));
        assertThat(dataHeader.streamId(), is(STREAM_ID));
        assertThat(dataHeader.sessionId(), is(SESSION_ID));
        assertThat(dataHeader.termOffset(), is(offsetOfMessage(1)));
        assertThat(dataHeader.headerType(), is(HeaderFlyweight.HDR_TYPE_DATA));
        assertThat(dataHeader.flags(), is(DataHeaderFlyweight.BEGIN_AND_END_FLAGS));
        assertThat(dataHeader.version(), is((short)HeaderFlyweight.CURRENT_VERSION));
    }

    @Test
    public void shouldNotBeAbleToSendAfterUsingUpYourWindow() throws Exception
    {
        final UnsafeBuffer buffer = new UnsafeBuffer(ByteBuffer.allocateDirect(PAYLOAD.length));
        buffer.putBytes(0, PAYLOAD);
        termAppenders[0].append(buffer, 0, PAYLOAD.length);
        publication.senderPositionLimit(
            flowControl.onStatusMessage(INITIAL_TERM_ID, 0, ALIGNED_FRAME_LENGTH, rcvAddress));

        sender.doWork();

        assertThat(receivedFrames.size(), is(1));

        dataHeader.wrap(receivedFrames.remove(), 0);

        assertThat(dataHeader.frameLength(), is(ALIGNED_FRAME_LENGTH));
        assertThat(dataHeader.termId(), is(INITIAL_TERM_ID));
        assertThat(dataHeader.streamId(), is(STREAM_ID));
        assertThat(dataHeader.sessionId(), is(SESSION_ID));
        assertThat(dataHeader.termOffset(), is(offsetOfMessage(1)));
        assertThat(dataHeader.headerType(), is(HeaderFlyweight.HDR_TYPE_DATA));
        assertThat(dataHeader.flags(), is(DataHeaderFlyweight.BEGIN_AND_END_FLAGS));
        assertThat(dataHeader.version(), is((short)HeaderFlyweight.CURRENT_VERSION));

        termAppenders[0].append(buffer, 0, PAYLOAD.length);
        sender.doWork();

        assertThat(receivedFrames.size(), is(0));
    }

    @Test
    public void shouldSendLastDataFrameAsHeartbeatWhenIdle() throws Exception
    {
        publication.senderPositionLimit(
            flowControl.onStatusMessage(INITIAL_TERM_ID, 0, ALIGNED_FRAME_LENGTH, rcvAddress));

        final UnsafeBuffer buffer = new UnsafeBuffer(ByteBuffer.allocateDirect(PAYLOAD.length));
        buffer.putBytes(0, PAYLOAD);

        termAppenders[0].append(buffer, 0, PAYLOAD.length);
        sender.doWork();

        assertThat(receivedFrames.size(), is(1));  
        receivedFrames.remove();                   

        currentTimestamp += Configuration.PUBLICATION_HEARTBEAT_TIMEOUT_NS - 1;
        sender.doWork();

        assertThat(receivedFrames.size(), is(0));  
        currentTimestamp += 10;
        sender.doWork();

        assertThat(receivedFrames.size(), greaterThanOrEqualTo(1));  

        dataHeader.wrap(new UnsafeBuffer(receivedFrames.remove()), 0);
        assertThat(dataHeader.frameLength(), is(0));
        assertThat(dataHeader.termOffset(), is(offsetOfMessage(2)));
    }

    @Test
    public void shouldSendMultipleDataFramesAsHeartbeatsWhenIdle()
    {
        publication.senderPositionLimit(
            flowControl.onStatusMessage(INITIAL_TERM_ID, 0, ALIGNED_FRAME_LENGTH, rcvAddress));

        final UnsafeBuffer buffer = new UnsafeBuffer(ByteBuffer.allocateDirect(PAYLOAD.length));
        buffer.putBytes(0, PAYLOAD);

        termAppenders[0].append(buffer, 0, PAYLOAD.length);
        sender.doWork();

        assertThat(receivedFrames.size(), is(1));  
        receivedFrames.remove();                   

        currentTimestamp += Configuration.PUBLICATION_HEARTBEAT_TIMEOUT_NS - 1;
        sender.doWork();
        assertThat(receivedFrames.size(), is(0));  
        currentTimestamp += 10;
        sender.doWork();
        assertThat(receivedFrames.size(), greaterThanOrEqualTo(1));  

        dataHeader.wrap(new UnsafeBuffer(receivedFrames.remove()), 0);
        assertThat(dataHeader.frameLength(), is(0));
        assertThat(dataHeader.termOffset(), is(offsetOfMessage(2)));

        currentTimestamp += Configuration.PUBLICATION_HEARTBEAT_TIMEOUT_NS - 1;
        sender.doWork();
        assertThat(receivedFrames.size(), is(0));  
        currentTimestamp += 10;
        sender.doWork();
        assertThat(receivedFrames.size(), greaterThanOrEqualTo(1));  

        dataHeader.wrap(new UnsafeBuffer(receivedFrames.remove()), 0);
        assertThat(dataHeader.frameLength(), is(0));
        assertThat(dataHeader.termOffset(), is(offsetOfMessage(2)));
    }

    private int offsetOfMessage(final int offset)
    {
        return (offset - 1) * align(HEADER.capacity() + PAYLOAD.length, FRAME_ALIGNMENT);
    }
}

<code block>

package uk.co.real_logic.aeron.driver;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.InOrder;
import org.mockito.stubbing.Answer;
import uk.co.real_logic.aeron.command.*;
import uk.co.real_logic.aeron.driver.buffer.RawLogFactory;
import uk.co.real_logic.aeron.driver.event.EventConfiguration;
import uk.co.real_logic.aeron.driver.event.EventLogger;
import uk.co.real_logic.aeron.driver.media.ReceiveChannelEndpoint;
import uk.co.real_logic.aeron.driver.media.TransportPoller;
import uk.co.real_logic.aeron.driver.media.UdpChannel;
import uk.co.real_logic.agrona.concurrent.*;
import uk.co.real_logic.agrona.concurrent.ringbuffer.ManyToOneRingBuffer;
import uk.co.real_logic.agrona.concurrent.ringbuffer.RingBuffer;
import uk.co.real_logic.agrona.concurrent.ringbuffer.RingBufferDescriptor;

import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.util.concurrent.TimeUnit;
import java.util.function.BooleanSupplier;

import static org.hamcrest.Matchers.*;
import static org.junit.Assert.*;
import static org.mockito.Mockito.any;
import static org.mockito.Mockito.*;
import static uk.co.real_logic.aeron.ErrorCode.INVALID_CHANNEL;
import static uk.co.real_logic.aeron.ErrorCode.UNKNOWN_PUBLICATION;
import static uk.co.real_logic.aeron.command.ControlProtocolEvents.*;
import static uk.co.real_logic.aeron.driver.Configuration.*;
import static uk.co.real_logic.aeron.logbuffer.LogBufferDescriptor.TERM_META_DATA_LENGTH;
import static uk.co.real_logic.aeron.logbuffer.LogBufferDescriptor.computePosition;

public class DriverConductorTest
{
    private static final String CHANNEL_URI = "udp:
    private static final String INVALID_URI = "udp:
    private static final int SESSION_ID = 100;
    private static final int STREAM_ID_1 = 10;
    private static final int STREAM_ID_2 = 20;
    private static final int STREAM_ID_3 = 30;
    private static final int TERM_BUFFER_LENGTH = Configuration.TERM_BUFFER_LENGTH_DEFAULT;
    private static final long CORRELATION_ID_1 = 1429;
    private static final long CORRELATION_ID_2 = 1430;
    private static final long CORRELATION_ID_3 = 1431;
    private static final long CORRELATION_ID_4 = 1432;
    private static final long CLIENT_ID = 1433;
    private static final int BUFFER_LENGTH = 1024 * 1024;

    private final ByteBuffer toDriverBuffer = ByteBuffer.allocateDirect(Configuration.CONDUCTOR_BUFFER_LENGTH);
    private final ByteBuffer toEventBuffer = ByteBuffer.allocateDirect(
        EventConfiguration.BUFFER_LENGTH_DEFAULT + RingBufferDescriptor.TRAILER_LENGTH);

    private final TransportPoller transportPoller = mock(TransportPoller.class);
    private final RawLogFactory mockRawLogFactory = mock(RawLogFactory.class);

    private final RingBuffer fromClientCommands = new ManyToOneRingBuffer(new UnsafeBuffer(toDriverBuffer));
    private final RingBuffer toEventReader = new ManyToOneRingBuffer(new UnsafeBuffer(toEventBuffer));
    private final ClientProxy mockClientProxy = mock(ClientProxy.class);

    private final PublicationMessageFlyweight publicationMessage = new PublicationMessageFlyweight();
    private final SubscriptionMessageFlyweight subscriptionMessage = new SubscriptionMessageFlyweight();
    private final RemoveMessageFlyweight removeMessage = new RemoveMessageFlyweight();
    private final CorrelatedMessageFlyweight correlatedMessage = new CorrelatedMessageFlyweight();
    private final UnsafeBuffer writeBuffer = new UnsafeBuffer(ByteBuffer.allocateDirect(256));

    private final EventLogger mockConductorLogger = mock(EventLogger.class);

    private final SenderProxy senderProxy = mock(SenderProxy.class);
    private final ReceiverProxy receiverProxy = mock(ReceiverProxy.class);
    private final DriverConductorProxy fromSenderConductorProxy = mock(DriverConductorProxy.class);
    private final DriverConductorProxy fromReceiverConductorProxy = mock(DriverConductorProxy.class);

    private long currentTime;
    private NanoClock nanoClock = () -> currentTime;

    private DriverConductor driverConductor;

    private final Answer<Void> closeChannelEndpointAnswer =
        (invocation) ->
        {
            final Object args[] = invocation.getArguments();
            final ReceiveChannelEndpoint channelEndpoint = (ReceiveChannelEndpoint)args[0];
            channelEndpoint.close();

            return null;
        };

    @Before
    public void setUp() throws Exception
    {
        when(mockRawLogFactory.newPublication(anyObject(), anyInt(), anyInt(), anyInt()))
            .thenReturn(LogBufferHelper.newTestLogBuffers(TERM_BUFFER_LENGTH, TERM_META_DATA_LENGTH));
        when(mockRawLogFactory.newConnection(anyObject(), anyInt(), anyInt(), anyInt(), eq(TERM_BUFFER_LENGTH)))
            .thenReturn(LogBufferHelper.newTestLogBuffers(TERM_BUFFER_LENGTH, TERM_META_DATA_LENGTH));

        currentTime = 0;

        final UnsafeBuffer counterBuffer = new UnsafeBuffer(ByteBuffer.allocateDirect(BUFFER_LENGTH));
        final CountersManager countersManager = new CountersManager(
            new UnsafeBuffer(ByteBuffer.allocateDirect(BUFFER_LENGTH)), counterBuffer);

        final MediaDriver.Context ctx = new MediaDriver.Context()
            .receiverNioSelector(transportPoller)
            .senderNioSelector(transportPoller)
            .unicastSenderFlowControl(UnicastFlowControl::new)
            .multicastSenderFlowControl(MaxMulticastFlowControl::new)
            
            .toConductorFromReceiverCommandQueue(new OneToOneConcurrentArrayQueue<>(1024))
            .toConductorFromSenderCommandQueue(new OneToOneConcurrentArrayQueue<>(1024))
            .eventLogger(mockConductorLogger)
            .rawLogBuffersFactory(mockRawLogFactory)
            .countersManager(countersManager)
            .nanoClock(nanoClock);

        ctx.toEventReader(toEventReader);
        ctx.toDriverCommands(fromClientCommands);
        ctx.clientProxy(mockClientProxy);
        ctx.counterValuesBuffer(counterBuffer);

        final SystemCounters mockSystemCounters = mock(SystemCounters.class);
        ctx.systemCounters(mockSystemCounters);
        when(mockSystemCounters.bytesReceived()).thenReturn(mock(AtomicCounter.class));
        when(mockSystemCounters.clientKeepAlives()).thenReturn(mock(AtomicCounter.class));

        ctx.epochClock(new SystemEpochClock());
        ctx.receiverProxy(receiverProxy);
        ctx.senderProxy(senderProxy);
        ctx.fromReceiverDriverConductorProxy(fromReceiverConductorProxy);
        ctx.fromSenderDriverConductorProxy(fromSenderConductorProxy);

        driverConductor = new DriverConductor(ctx);

        doAnswer(closeChannelEndpointAnswer).when(receiverProxy).closeReceiveChannelEndpoint(any());
    }

    @After
    public void tearDown() throws Exception
    {
        driverConductor.onClose();
    }

    @Test
    public void shouldBeAbleToAddSinglePublication() throws Exception
    {
        writePublicationMessage(ADD_PUBLICATION, 1, 2, 4000, CORRELATION_ID_1);

        driverConductor.doWork();

        verify(senderProxy).registerSendChannelEndpoint(any());
        final ArgumentCaptor<NetworkPublication> captor = ArgumentCaptor.forClass(NetworkPublication.class);
        verify(senderProxy, times(1)).newPublication(captor.capture());

        final NetworkPublication publication = captor.getValue();
        assertThat(publication.sessionId(), is(1));
        assertThat(publication.streamId(), is(2));

        verify(mockClientProxy).onPublicationReady(eq(2), anyInt(), any(), anyLong(), anyInt());
    }

    @Test
    public void shouldBeAbleToAddSingleSubscription() throws Exception
    {
        writeSubscriptionMessage(ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);

        driverConductor.doWork();

        verify(receiverProxy).registerReceiveChannelEndpoint(any());
        verify(receiverProxy).addSubscription(any(), eq(STREAM_ID_1));
        verify(mockClientProxy).operationSucceeded(CORRELATION_ID_1);

        assertNotNull(driverConductor.receiverChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000)));
    }

    @Test
    public void shouldBeAbleToAddAndRemoveSingleSubscription() throws Exception
    {
        writeSubscriptionMessage(ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);
        writeSubscriptionMessage(REMOVE_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);

        driverConductor.doWork();

        assertNull(driverConductor.receiverChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000)));
    }

    @Test
    public void shouldBeAbleToAddMultipleStreams() throws Exception
    {
        writePublicationMessage(ADD_PUBLICATION, 1, 2, 4001, CORRELATION_ID_1);
        writePublicationMessage(ADD_PUBLICATION, 1, 3, 4002, CORRELATION_ID_2);
        writePublicationMessage(ADD_PUBLICATION, 3, 2, 4003, CORRELATION_ID_3);
        writePublicationMessage(ADD_PUBLICATION, 3, 4, 4004, CORRELATION_ID_4);

        driverConductor.doWork();

        verify(senderProxy, times(4)).newPublication(any());
    }

    @Test
    public void shouldBeAbleToRemoveSingleStream() throws Exception
    {
        writePublicationMessage(ADD_PUBLICATION, 1, 2, 4005, CORRELATION_ID_1);
        writePublicationMessage(REMOVE_PUBLICATION, 1, 2, 4005, CORRELATION_ID_1);

        driverConductor.doWork();

        doWorkUntil(() -> nanoClock.nanoTime() >= CLIENT_LIVENESS_TIMEOUT_NS + PUBLICATION_LINGER_NS * 2);

        verify(senderProxy).removePublication(any());
        assertNull(driverConductor.senderChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4005)));
    }

    @Test
    public void shouldBeAbleToRemoveMultipleStreams() throws Exception
    {
        writePublicationMessage(ADD_PUBLICATION, 1, 2, 4006, CORRELATION_ID_1);
        writePublicationMessage(ADD_PUBLICATION, 1, 3, 4007, CORRELATION_ID_2);
        writePublicationMessage(ADD_PUBLICATION, 3, 2, 4008, CORRELATION_ID_3);
        writePublicationMessage(ADD_PUBLICATION, 3, 4, 4008, CORRELATION_ID_4);

        removePublicationMessage(CORRELATION_ID_1);
        removePublicationMessage(CORRELATION_ID_2);
        removePublicationMessage(CORRELATION_ID_3);
        removePublicationMessage(CORRELATION_ID_4);

        driverConductor.doWork();

        doWorkUntil(() -> nanoClock.nanoTime() >= PUBLICATION_LINGER_NS * 2 + CLIENT_LIVENESS_TIMEOUT_NS * 2);

        verify(senderProxy, times(4)).removePublication(any());
    }

    

    private void removePublicationMessage(final long registrationId)
    {
        removeMessage.wrap(writeBuffer, 0);
        removeMessage.registrationId(registrationId);
        assertTrue(fromClientCommands.write(REMOVE_PUBLICATION, writeBuffer, 0, RemoveMessageFlyweight.length()));
    }

    @Test
    public void shouldKeepSubscriptionMediaEndpointUponRemovalOfAllButOneSubscriber() throws Exception
    {
        final UdpChannel udpChannel = UdpChannel.parse(CHANNEL_URI + 4000);

        writeSubscriptionMessage(ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);
        writeSubscriptionMessage(ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_2, CORRELATION_ID_2);
        writeSubscriptionMessage(ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_3, CORRELATION_ID_3);

        driverConductor.doWork();

        final ReceiveChannelEndpoint channelEndpoint = driverConductor.receiverChannelEndpoint(udpChannel);

        assertNotNull(channelEndpoint);
        assertThat(channelEndpoint.streamCount(), is(3));

        writeSubscriptionMessage(REMOVE_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);
        writeSubscriptionMessage(REMOVE_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_2, CORRELATION_ID_2);

        driverConductor.doWork();

        assertNotNull(driverConductor.receiverChannelEndpoint(udpChannel));
        assertThat(channelEndpoint.streamCount(), is(1));
    }

    @Test
    public void shouldOnlyRemoveSubscriptionMediaEndpointUponRemovalOfAllSubscribers() throws Exception
    {
        final UdpChannel udpChannel = UdpChannel.parse(CHANNEL_URI + 4000);

        writeSubscriptionMessage(ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);
        writeSubscriptionMessage(ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_2, CORRELATION_ID_2);
        writeSubscriptionMessage(ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_3, CORRELATION_ID_3);

        driverConductor.doWork();

        final ReceiveChannelEndpoint channelEndpoint = driverConductor.receiverChannelEndpoint(udpChannel);

        assertNotNull(channelEndpoint);
        assertThat(channelEndpoint.streamCount(), is(3));

        writeSubscriptionMessage(REMOVE_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_2, CORRELATION_ID_2);
        writeSubscriptionMessage(REMOVE_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_3, CORRELATION_ID_3);

        driverConductor.doWork();

        assertNotNull(driverConductor.receiverChannelEndpoint(udpChannel));
        assertThat(channelEndpoint.streamCount(), is(1));

        writeSubscriptionMessage(REMOVE_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);

        driverConductor.doWork();

        assertNull(driverConductor.receiverChannelEndpoint(udpChannel));
    }

    @Test
    public void shouldErrorOnRemoveChannelOnUnknownSessionId() throws Exception
    {
        writePublicationMessage(ADD_PUBLICATION, 1, 2, 4000, CORRELATION_ID_1);
        writePublicationMessage(REMOVE_PUBLICATION, 2, 2, 4000, CORRELATION_ID_1);

        driverConductor.doWork();

        verify(senderProxy).newPublication(any());
        verify(mockClientProxy).onError(eq(UNKNOWN_PUBLICATION), argThat(not(isEmptyOrNullString())), any());
        verify(mockClientProxy, never()).operationSucceeded(anyLong());
        verify(mockConductorLogger).logException(any());
    }

    @Test
    public void shouldErrorOnRemoveChannelOnUnknownStreamId() throws Exception
    {
        writePublicationMessage(ADD_PUBLICATION, 1, 2, 4000, CORRELATION_ID_1);
        writePublicationMessage(REMOVE_PUBLICATION, 1, 3, 4000, CORRELATION_ID_1);

        driverConductor.doWork();

        verify(senderProxy).newPublication(any());
        verify(senderProxy, never()).removePublication(any());
        verify(mockClientProxy).onError(eq(UNKNOWN_PUBLICATION), argThat(not(isEmptyOrNullString())), any());
        verify(mockClientProxy, never()).operationSucceeded(anyLong());
        verify(mockConductorLogger).logException(any());
    }

    @Test
    public void shouldErrorOnAddSubscriptionWithInvalidUri() throws Exception
    {
        writeSubscriptionMessage(ADD_SUBSCRIPTION, INVALID_URI, STREAM_ID_1, CORRELATION_ID_1);

        driverConductor.doWork();
        driverConductor.doWork();

        verify(senderProxy, never()).newPublication(any());

        verify(mockClientProxy).onError(eq(INVALID_CHANNEL), argThat(not(isEmptyOrNullString())), any());
        verify(mockClientProxy, never()).operationSucceeded(anyLong());
        verify(mockConductorLogger).logException(any());
    }

    @Test
    public void shouldTimeoutPublication() throws Exception
    {
        writePublicationMessage(ADD_PUBLICATION, 1, 2, 4000, CORRELATION_ID_1);

        driverConductor.doWork();

        final ArgumentCaptor<NetworkPublication> captor = ArgumentCaptor.forClass(NetworkPublication.class);
        verify(senderProxy, times(1)).newPublication(captor.capture());

        final NetworkPublication publication = captor.getValue();

        doWorkUntil(() -> nanoClock.nanoTime() >= PUBLICATION_LINGER_NS + CLIENT_LIVENESS_TIMEOUT_NS * 2);

        verify(senderProxy).removePublication(eq(publication));
        assertNull(driverConductor.senderChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000)));
    }

    @Test
    public void shouldNotTimeoutPublicationOnKeepAlive() throws Exception
    {
        writePublicationMessage(ADD_PUBLICATION, 1, 2, 4000, CORRELATION_ID_1);

        driverConductor.doWork();

        final ArgumentCaptor<NetworkPublication> captor = ArgumentCaptor.forClass(NetworkPublication.class);
        verify(senderProxy, times(1)).newPublication(captor.capture());

        final NetworkPublication publication = captor.getValue();

        doWorkUntil(() -> nanoClock.nanoTime() >= CLIENT_LIVENESS_TIMEOUT_NS / 2);

        writeKeepaliveClientMessage();

        doWorkUntil(() -> nanoClock.nanoTime() >= CLIENT_LIVENESS_TIMEOUT_NS + 1000);

        writeKeepaliveClientMessage();

        doWorkUntil(() -> nanoClock.nanoTime() >= CLIENT_LIVENESS_TIMEOUT_NS * 2);

        verify(senderProxy, never()).removePublication(eq(publication));
    }

    @Test
    public void shouldTimeoutSubscription() throws Exception
    {
        writeSubscriptionMessage(ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);

        driverConductor.doWork();

        final ReceiveChannelEndpoint receiveChannelEndpoint =
            driverConductor.receiverChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000));
        assertNotNull(receiveChannelEndpoint);

        verify(receiverProxy).addSubscription(eq(receiveChannelEndpoint), eq(STREAM_ID_1));

        doWorkUntil(() -> nanoClock.nanoTime() >= CLIENT_LIVENESS_TIMEOUT_NS * 2);

        verify(receiverProxy, times(1)).removeSubscription(eq(receiveChannelEndpoint), eq(STREAM_ID_1));

        assertNull(driverConductor.receiverChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000)));
    }

    @Test
    public void shouldNotTimeoutSubscriptionOnKeepAlive() throws Exception
    {
        writeSubscriptionMessage(ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);

        driverConductor.doWork();

        final ReceiveChannelEndpoint receiveChannelEndpoint =
            driverConductor.receiverChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000));
        assertNotNull(receiveChannelEndpoint);

        verify(receiverProxy).addSubscription(eq(receiveChannelEndpoint), eq(STREAM_ID_1));

        doWorkUntil(() -> nanoClock.nanoTime() >= CLIENT_LIVENESS_TIMEOUT_NS);

        writeKeepaliveClientMessage();

        doWorkUntil(() -> nanoClock.nanoTime() >= CLIENT_LIVENESS_TIMEOUT_NS + 1000);

        writeKeepaliveClientMessage();

        doWorkUntil(() -> nanoClock.nanoTime() >= CLIENT_LIVENESS_TIMEOUT_NS * 2);

        verify(receiverProxy, never()).removeSubscription(any(), anyInt());
        assertNotNull(driverConductor.receiverChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000)));
    }

    @Test
    public void shouldCreateConnectionOnSubscription() throws Exception
    {
        final InetSocketAddress sourceAddress = new InetSocketAddress("localhost", 4400);
        final int initialTermId = 1;
        final int activeTermId = 2;
        final int termOffset = 100;

        writeSubscriptionMessage(ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);

        driverConductor.doWork();

        final ReceiveChannelEndpoint receiveChannelEndpoint =
            driverConductor.receiverChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000));
        assertNotNull(receiveChannelEndpoint);

        receiveChannelEndpoint.openChannel();

        driverConductor.onCreateConnection(
            SESSION_ID, STREAM_ID_1, initialTermId, activeTermId, termOffset, TERM_BUFFER_LENGTH, MTU_LENGTH,
            mock(InetSocketAddress.class), sourceAddress, receiveChannelEndpoint);

        final ArgumentCaptor<NetworkConnection> captor = ArgumentCaptor.forClass(NetworkConnection.class);
        verify(receiverProxy).newConnection(eq(receiveChannelEndpoint), captor.capture());

        final NetworkConnection networkConnection = captor.getValue();
        assertThat(networkConnection.sessionId(), is(SESSION_ID));
        assertThat(networkConnection.streamId(), is(STREAM_ID_1));

        final long position =
            computePosition(activeTermId, termOffset, Integer.numberOfTrailingZeros(TERM_BUFFER_LENGTH), initialTermId);
        verify(mockClientProxy).onConnectionReady(
            eq(STREAM_ID_1), eq(SESSION_ID), eq(position), anyObject(), anyLong(), anyObject(), anyString());
    }

    @Test
    public void shouldNotCreateConnectionOnUnknownSubscription() throws Exception
    {
        final InetSocketAddress sourceAddress = new InetSocketAddress("localhost", 4400);

        writeSubscriptionMessage(ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);

        driverConductor.doWork();

        final ReceiveChannelEndpoint receiveChannelEndpoint =
            driverConductor.receiverChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000));
        assertNotNull(receiveChannelEndpoint);

        receiveChannelEndpoint.openChannel();

        driverConductor.onCreateConnection(
            SESSION_ID, STREAM_ID_2, 1, 1, 0, TERM_BUFFER_LENGTH, MTU_LENGTH,
            mock(InetSocketAddress.class), sourceAddress, receiveChannelEndpoint);

        verify(receiverProxy, never()).newConnection(any(), any());
        verify(mockClientProxy, never()).onConnectionReady(
            anyInt(), anyInt(), anyLong(), anyObject(), anyLong(), anyObject(), anyString());
    }

    @Test
    public void shouldSignalInactiveConnectionWhenConnectionTimesout() throws Exception
    {
        final InetSocketAddress sourceAddress = new InetSocketAddress("localhost", 4400);

        writeSubscriptionMessage(ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);

        driverConductor.doWork();

        final ReceiveChannelEndpoint receiveChannelEndpoint =
            driverConductor.receiverChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000));
        assertNotNull(receiveChannelEndpoint);

        receiveChannelEndpoint.openChannel();

        driverConductor.onCreateConnection(
            SESSION_ID, STREAM_ID_1, 1, 1, 0, TERM_BUFFER_LENGTH, MTU_LENGTH,
            mock(InetSocketAddress.class), sourceAddress, receiveChannelEndpoint);

        final ArgumentCaptor<NetworkConnection> captor = ArgumentCaptor.forClass(NetworkConnection.class);
        verify(receiverProxy).newConnection(eq(receiveChannelEndpoint), captor.capture());

        final NetworkConnection networkConnection = captor.getValue();

        networkConnection.status(NetworkConnection.Status.INACTIVE);

        doWorkUntil(() -> nanoClock.nanoTime() >= CONNECTION_LIVENESS_TIMEOUT_NS + 1000);

        verify(mockClientProxy).onInactiveConnection(
            eq(networkConnection.correlationId()), eq(SESSION_ID), eq(STREAM_ID_1), eq(0L), anyString());
    }

    @Test
    public void shouldAlwaysGiveNetworkConnectionCorrelationIdToClientCallbacks() throws Exception
    {
        final InetSocketAddress sourceAddress = new InetSocketAddress("localhost", 4400);

        writeSubscriptionMessage(
            ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, fromClientCommands.nextCorrelationId());

        driverConductor.doWork();

        final ReceiveChannelEndpoint receiveChannelEndpoint =
            driverConductor.receiverChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000));
        assertNotNull(receiveChannelEndpoint);

        receiveChannelEndpoint.openChannel();

        driverConductor.onCreateConnection(
            SESSION_ID, STREAM_ID_1, 1, 1, 0, TERM_BUFFER_LENGTH, MTU_LENGTH,
            mock(InetSocketAddress.class), sourceAddress, receiveChannelEndpoint);

        final ArgumentCaptor<NetworkConnection> captor = ArgumentCaptor.forClass(NetworkConnection.class);
        verify(receiverProxy).newConnection(eq(receiveChannelEndpoint), captor.capture());

        final NetworkConnection networkConnection = captor.getValue();

        networkConnection.status(NetworkConnection.Status.ACTIVE);

        writeSubscriptionMessage(
            ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, fromClientCommands.nextCorrelationId());

        driverConductor.doWork();

        networkConnection.status(NetworkConnection.Status.INACTIVE);

        doWorkUntil(() -> nanoClock.nanoTime() >= CONNECTION_LIVENESS_TIMEOUT_NS + 1000);

        final InOrder inOrder = inOrder(mockClientProxy);
        inOrder.verify(mockClientProxy, times(2)).onConnectionReady(
            eq(STREAM_ID_1), eq(SESSION_ID), eq(0L), anyObject(),
            eq(networkConnection.correlationId()), anyObject(), anyString());
        inOrder.verify(mockClientProxy, times(1)).onInactiveConnection(
            eq(networkConnection.correlationId()), eq(SESSION_ID), eq(STREAM_ID_1), eq(0L), anyString());
    }

    private void writePublicationMessage(
        final int msgTypeId, final int sessionId, final int streamId, final int port, final long correlationId)
    {
        publicationMessage.wrap(writeBuffer, 0);
        publicationMessage.streamId(streamId);
        publicationMessage.sessionId(sessionId);
        publicationMessage.channel(CHANNEL_URI + port);
        publicationMessage.clientId(CLIENT_ID);
        publicationMessage.correlationId(correlationId);

        fromClientCommands.write(msgTypeId, writeBuffer, 0, publicationMessage.length());
    }

    private void writeSubscriptionMessage(
        final int msgTypeId, final String channel, final int streamId, final long registrationCorrelationId)
    {
        subscriptionMessage.wrap(writeBuffer, 0);
        subscriptionMessage.streamId(streamId)
                           .channel(channel)
                           .registrationCorrelationId(registrationCorrelationId)
                           .correlationId(registrationCorrelationId)
                           .clientId(CLIENT_ID);

        fromClientCommands.write(msgTypeId, writeBuffer, 0, subscriptionMessage.length());
    }

    private void writeKeepaliveClientMessage()
    {
        correlatedMessage.wrap(writeBuffer, 0);
        correlatedMessage.clientId(CLIENT_ID);
        correlatedMessage.correlationId(0);

        fromClientCommands.write(ControlProtocolEvents.CLIENT_KEEPALIVE, writeBuffer, 0, CorrelatedMessageFlyweight.LENGTH);
    }

    private long doWorkUntil(final BooleanSupplier condition) throws Exception
    {
        final long startTime = currentTime;

        while (!condition.getAsBoolean())
        {
            currentTime += TimeUnit.MILLISECONDS.toNanos(10);
            driverConductor.doWork();
        }

        return currentTime - startTime;
    }
}

<code block>

package uk.co.real_logic.aeron.driver;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import uk.co.real_logic.aeron.driver.media.*;
import uk.co.real_logic.aeron.logbuffer.FrameDescriptor;
import uk.co.real_logic.aeron.driver.event.EventLogger;
import uk.co.real_logic.aeron.protocol.DataHeaderFlyweight;
import uk.co.real_logic.aeron.protocol.HeaderFlyweight;
import uk.co.real_logic.aeron.protocol.StatusMessageFlyweight;
import uk.co.real_logic.agrona.BitUtil;
import uk.co.real_logic.agrona.concurrent.AtomicCounter;
import uk.co.real_logic.agrona.concurrent.UnsafeBuffer;

import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.util.concurrent.atomic.AtomicInteger;

import static org.hamcrest.core.Is.is;
import static org.junit.Assert.assertThat;
import static org.mockito.Mockito.*;

public class SelectorAndTransportTest
{
    private static final int RCV_PORT = 40123;
    private static final int SRC_PORT = 40124;
    private static final int SESSION_ID = 0xdeadbeef;
    private static final int STREAM_ID = 0x44332211;
    private static final int TERM_ID = 0x99887766;
    private static final int FRAME_LENGTH = 24;

    private static final UdpChannel SRC_DST = UdpChannel.parse("udp:
    private static final UdpChannel RCV_DST = UdpChannel.parse("udp:

    private static final LossGenerator NO_LOSS = (address, header, length) -> false;

    private final ByteBuffer byteBuffer = ByteBuffer.allocateDirect(256);
    private final UnsafeBuffer buffer = new UnsafeBuffer(byteBuffer);

    private final DataHeaderFlyweight encodeDataHeader = new DataHeaderFlyweight();
    private final StatusMessageFlyweight statusMessage = new StatusMessageFlyweight();

    private final InetSocketAddress rcvRemoteAddress = new InetSocketAddress("localhost", SRC_PORT);
    private final InetSocketAddress srcRemoteAddress = new InetSocketAddress("localhost", RCV_PORT);

    private final EventLogger mockTransportLogger = mock(EventLogger.class);
    private final SystemCounters mockSystemCounters = mock(SystemCounters.class);
    private final AtomicCounter mockStatusMessagesReceivedCounter = mock(AtomicCounter.class);

    private final DataPacketDispatcher mockDispatcher = mock(DataPacketDispatcher.class);
    private final NetworkPublication mockPublication = mock(NetworkPublication.class);

    private TransportPoller transportPoller;
    private SendChannelEndpoint sendChannelEndpoint;
    private ReceiveChannelEndpoint receiveChannelEndpoint;

    @Before
    public void setup()
    {
        when(mockSystemCounters.statusMessagesReceived()).thenReturn(mockStatusMessagesReceivedCounter);
        when(mockPublication.streamId()).thenReturn(STREAM_ID);
        when(mockPublication.sessionId()).thenReturn(SESSION_ID);
    }

    @After
    public void tearDown()
    {
        try
        {
            if (null != sendChannelEndpoint)
            {
                sendChannelEndpoint.close();
                processLoop(transportPoller, 5);
            }

            if (null != receiveChannelEndpoint)
            {
                receiveChannelEndpoint.close();
                processLoop(transportPoller, 5);
            }

            if (null != transportPoller)
            {
                transportPoller.close();
            }
        }
        catch (final Exception ex)
        {
            ex.printStackTrace();
        }
    }

    @Test(timeout = 1000)
    public void shouldHandleBasicSetupAndTearDown() throws Exception
    {
        transportPoller = new TransportPoller();
        receiveChannelEndpoint = new ReceiveChannelEndpoint(
            RCV_DST, mockDispatcher, mockTransportLogger, mockSystemCounters, NO_LOSS);
        sendChannelEndpoint = new SendChannelEndpoint(SRC_DST, mockTransportLogger, NO_LOSS, mockSystemCounters);

        receiveChannelEndpoint.openDatagramChannel();
        receiveChannelEndpoint.registerForRead(transportPoller);
        sendChannelEndpoint.openDatagramChannel();
        sendChannelEndpoint.registerForRead(transportPoller);

        processLoop(transportPoller, 5);
    }

    @Test(timeout = 1000)
    public void shouldSendEmptyDataFrameUnicastFromSourceToReceiver() throws Exception
    {
        final AtomicInteger dataHeadersReceived = new AtomicInteger(0);

        doAnswer(
            (invocation) ->
            {
                dataHeadersReceived.incrementAndGet();
                return null;
            })
            .when(mockDispatcher).onDataPacket(
                any(ReceiveChannelEndpoint.class),
                any(DataHeaderFlyweight.class),
                any(UnsafeBuffer.class),
                anyInt(),
                any(InetSocketAddress.class));

        transportPoller = new TransportPoller();
        receiveChannelEndpoint = new ReceiveChannelEndpoint(
            RCV_DST, mockDispatcher, mockTransportLogger, mockSystemCounters, NO_LOSS);
        sendChannelEndpoint = new SendChannelEndpoint(SRC_DST, mockTransportLogger, NO_LOSS, mockSystemCounters);

        receiveChannelEndpoint.openDatagramChannel();
        receiveChannelEndpoint.registerForRead(transportPoller);
        sendChannelEndpoint.openDatagramChannel();
        sendChannelEndpoint.registerForRead(transportPoller);

        encodeDataHeader.wrap(buffer, 0);
        encodeDataHeader
            .version(HeaderFlyweight.CURRENT_VERSION)
            .flags(DataHeaderFlyweight.BEGIN_AND_END_FLAGS)
            .headerType(HeaderFlyweight.HDR_TYPE_DATA)
            .frameLength(FRAME_LENGTH);
        encodeDataHeader
            .sessionId(SESSION_ID)
            .streamId(STREAM_ID)
            .termId(TERM_ID);
        byteBuffer.position(0).limit(FRAME_LENGTH);

        processLoop(transportPoller, 5);
        sendChannelEndpoint.sendTo(byteBuffer, srcRemoteAddress);
        while (dataHeadersReceived.get() < 1)
        {
            processLoop(transportPoller, 1);
        }

        assertThat(dataHeadersReceived.get(), is(1));
    }

    @Test(timeout = 1000)
    public void shouldSendMultipleDataFramesPerDatagramUnicastFromSourceToReceiver() throws Exception
    {
        final AtomicInteger dataHeadersReceived = new AtomicInteger(0);

        doAnswer(
            (invocation) ->
            {
                dataHeadersReceived.incrementAndGet();
                return null;
            })
            .when(mockDispatcher).onDataPacket(
                any(ReceiveChannelEndpoint.class),
                any(DataHeaderFlyweight.class),
                any(UnsafeBuffer.class),
                anyInt(),
                any(InetSocketAddress.class));

        transportPoller = new TransportPoller();
        receiveChannelEndpoint = new ReceiveChannelEndpoint(
            RCV_DST, mockDispatcher, mockTransportLogger, mockSystemCounters, NO_LOSS);
        sendChannelEndpoint = new SendChannelEndpoint(SRC_DST, mockTransportLogger, NO_LOSS, mockSystemCounters);

        receiveChannelEndpoint.openDatagramChannel();
        receiveChannelEndpoint.registerForRead(transportPoller);
        sendChannelEndpoint.openDatagramChannel();
        sendChannelEndpoint.registerForRead(transportPoller);

        encodeDataHeader.wrap(buffer, 0);
        encodeDataHeader
            .version(HeaderFlyweight.CURRENT_VERSION)
            .flags(DataHeaderFlyweight.BEGIN_AND_END_FLAGS)
            .headerType(HeaderFlyweight.HDR_TYPE_DATA)
            .frameLength(FRAME_LENGTH);
        encodeDataHeader
            .sessionId(SESSION_ID)
            .streamId(STREAM_ID)
            .termId(TERM_ID);

        encodeDataHeader.wrap(buffer, BitUtil.align(FRAME_LENGTH, FrameDescriptor.FRAME_ALIGNMENT));
        encodeDataHeader
            .version(HeaderFlyweight.CURRENT_VERSION)
            .flags(DataHeaderFlyweight.BEGIN_AND_END_FLAGS)
            .headerType(HeaderFlyweight.HDR_TYPE_DATA)
            .frameLength(24);
        encodeDataHeader
            .sessionId(SESSION_ID)
            .streamId(STREAM_ID)
            .termId(TERM_ID);

        byteBuffer.position(0).limit(2 * BitUtil.align(FRAME_LENGTH, FrameDescriptor.FRAME_ALIGNMENT));

        processLoop(transportPoller, 5);
        sendChannelEndpoint.sendTo(byteBuffer, srcRemoteAddress);
        while (dataHeadersReceived.get() < 1)
        {
            processLoop(transportPoller, 1);
        }

        assertThat(dataHeadersReceived.get(), is(1));
    }

    @Test(timeout = 1000)
    public void shouldHandleSmFrameFromReceiverToSender() throws Exception
    {
        transportPoller = new TransportPoller();
        receiveChannelEndpoint = new ReceiveChannelEndpoint(
            RCV_DST, mockDispatcher, mockTransportLogger, mockSystemCounters, NO_LOSS);
        sendChannelEndpoint = new SendChannelEndpoint(SRC_DST, mockTransportLogger, NO_LOSS, mockSystemCounters);
        sendChannelEndpoint.addToDispatcher(mockPublication);

        receiveChannelEndpoint.openDatagramChannel();
        receiveChannelEndpoint.registerForRead(transportPoller);
        sendChannelEndpoint.openDatagramChannel();
        sendChannelEndpoint.registerForRead(transportPoller);

        statusMessage.wrap(buffer, 0);
        statusMessage
            .streamId(STREAM_ID)
            .sessionId(SESSION_ID)
            .consumptionTermId(TERM_ID)
            .receiverWindowLength(1000)
            .consumptionTermOffset(0)
            .version(HeaderFlyweight.CURRENT_VERSION)
            .flags((short)0)
            .headerType(HeaderFlyweight.HDR_TYPE_SM)
            .frameLength(StatusMessageFlyweight.HEADER_LENGTH);
        byteBuffer.position(0).limit(statusMessage.frameLength());

        processLoop(transportPoller, 5);
        receiveChannelEndpoint.sendTo(byteBuffer, rcvRemoteAddress);

        processLoop(transportPoller, 3);

        verify(mockStatusMessagesReceivedCounter, times(1)).orderedIncrement();
    }

    private void processLoop(final TransportPoller transportPoller, final int iterations) throws Exception
    {
        for (int i = 0; i < iterations; i++)
        {
            transportPoller.pollTransports();
        }
    }
}

<code block>

package uk.co.real_logic.aeron.driver;

import uk.co.real_logic.aeron.driver.buffer.RawLog;
import uk.co.real_logic.aeron.driver.media.SendChannelEndpoint;
import uk.co.real_logic.aeron.logbuffer.LogBufferPartition;
import uk.co.real_logic.aeron.protocol.DataHeaderFlyweight;
import uk.co.real_logic.aeron.protocol.HeaderFlyweight;
import uk.co.real_logic.aeron.protocol.SetupFlyweight;
import uk.co.real_logic.agrona.concurrent.NanoClock;
import uk.co.real_logic.agrona.concurrent.UnsafeBuffer;
import uk.co.real_logic.agrona.concurrent.status.Position;

import java.nio.ByteBuffer;

import static uk.co.real_logic.aeron.driver.Configuration.PUBLICATION_HEARTBEAT_TIMEOUT_NS;
import static uk.co.real_logic.aeron.driver.Configuration.PUBLICATION_SETUP_TIMEOUT_NS;
import static uk.co.real_logic.aeron.logbuffer.LogBufferDescriptor.*;
import static uk.co.real_logic.aeron.logbuffer.TermScanner.*;


public class NetworkPublication implements RetransmitSender, AutoCloseable
{
    private final RawLog rawLog;
    private final SetupFlyweight setupHeader = new SetupFlyweight();
    private final DataHeaderFlyweight dataHeader = new DataHeaderFlyweight();
    private final ByteBuffer setupFrameBuffer = ByteBuffer.allocateDirect(SetupFlyweight.HEADER_LENGTH);
    private final ByteBuffer heartbeatFrameBuffer = ByteBuffer.allocateDirect(DataHeaderFlyweight.HEADER_LENGTH);
    private final LogBufferPartition[] logPartitions;
    private final ByteBuffer[] sendBuffers;
    private final Position publisherLimit;
    private final Position senderPosition;
    private final SendChannelEndpoint channelEndpoint;
    private final SystemCounters systemCounters;
    private final RetransmitHandler retransmitHandler;

    private final int positionBitsToShift;
    private final int initialTermId;
    private final int termLengthMask;
    private final int mtuLength;
    private final int termWindowLength;

    private long timeOfLastSendOrHeartbeat;
    private long timeOfFlush = 0;
    private int statusMessagesReceivedCount = 0;
    private int refCount = 0;

    private volatile long senderPositionLimit;
    private boolean trackSenderLimits = true;
    private volatile boolean isActive = true;
    private volatile boolean shouldSendSetupFrame = true;

    public NetworkPublication(
        final SendChannelEndpoint channelEndpoint,
        final NanoClock clock,
        final RawLog rawLog,
        final Position senderPosition,
        final Position publisherLimit,
        final int sessionId,
        final int streamId,
        final int initialTermId,
        final int mtuLength,
        final long initialPositionLimit,
        final SystemCounters systemCounters,
        final RetransmitHandler retransmitHandler)
    {
        this.channelEndpoint = channelEndpoint;
        this.rawLog = rawLog;
        this.senderPosition = senderPosition;
        this.systemCounters = systemCounters;
        this.retransmitHandler = retransmitHandler;
        this.publisherLimit = publisherLimit;
        this.mtuLength = mtuLength;

        logPartitions = rawLog
            .stream()
            .map((partition) -> new LogBufferPartition(partition.termBuffer(), partition.metaDataBuffer()))
            .toArray(LogBufferPartition[]::new);

        sendBuffers = rawLog.sliceTerms();

        final int termLength = logPartitions[0].termBuffer().capacity();
        termLengthMask = termLength - 1;
        senderPositionLimit = initialPositionLimit;

        timeOfLastSendOrHeartbeat = clock.nanoTime();

        positionBitsToShift = Integer.numberOfTrailingZeros(termLength);
        this.initialTermId = initialTermId;
        termWindowLength = Configuration.publicationTermWindowLength(termLength);
        publisherLimit.setOrdered(termWindowLength);

        setupHeader.wrap(new UnsafeBuffer(setupFrameBuffer), 0);
        initSetupFrame(initialTermId, termLength, sessionId, streamId);

        dataHeader.wrap(new UnsafeBuffer(heartbeatFrameBuffer), 0);
        initHeartBeatFrame(sessionId, streamId);
    }

    public void close()
    {
        rawLog.close();
        publisherLimit.close();
        senderPosition.close();
    }

    public int send(final long now)
    {
        int bytesSent = 0;

        if (isActive)
        {
            final long senderPosition = this.senderPosition.get();
            final int activeTermId = computeTermIdFromPosition(senderPosition, positionBitsToShift, initialTermId);
            final int termOffset = (int)senderPosition & termLengthMask;

            if (shouldSendSetupFrame)
            {
                setupMessageCheck(now, activeTermId, termOffset, senderPosition);
            }

            bytesSent = sendData(now, senderPosition, termOffset);

            if (0 == bytesSent)
            {
                heartbeatMessageCheck(now, senderPosition, activeTermId);
            }

            retransmitHandler.processTimeouts(now, this);
        }

        return bytesSent;
    }

    public SendChannelEndpoint sendChannelEndpoint()
    {
        return channelEndpoint;
    }

    public int sessionId()
    {
        return dataHeader.sessionId();
    }

    public int streamId()
    {
        return dataHeader.streamId();
    }

    public void senderPositionLimit(final long positionLimit)
    {
        statusMessagesReceivedCount++;
        senderPositionLimit = positionLimit;
    }

    
    public int cleanLogBuffer()
    {
        int workCount = 0;

        for (final LogBufferPartition partition : logPartitions)
        {
            if (partition.status() == NEEDS_CLEANING)
            {
                partition.clean();
                workCount = 1;
            }
        }

        return workCount;
    }

    public long timeOfFlush()
    {
        return timeOfFlush;
    }

    public void resend(final int termId, int termOffset, final int length)
    {
        final long senderPosition = this.senderPosition.get();
        final int activeTermId = computeTermIdFromPosition(senderPosition, positionBitsToShift, initialTermId);

        if (termId == activeTermId || termId == (activeTermId - 1))
        {
            final int activeIndex = indexByTerm(initialTermId, termId);
            final UnsafeBuffer termBuffer = logPartitions[activeIndex].termBuffer();
            final ByteBuffer sendBuffer = sendBuffers[activeIndex];

            int remainingBytes = length;
            int bytesSent = 0;
            do
            {
                termOffset += bytesSent;

                final long scanOutcome = scanForAvailability(termBuffer, termOffset, mtuLength);
                final int available = available(scanOutcome);
                if (available <= 0)
                {
                    break;
                }

                sendBuffer.limit(termOffset + available).position(termOffset);

                if (available != channelEndpoint.send(sendBuffer))
                {
                    systemCounters.dataPacketShortSends().orderedIncrement();
                    break;
                }

                bytesSent = available + padding(scanOutcome);
                remainingBytes -= bytesSent;
            }
            while (remainingBytes > 0);

            systemCounters.retransmitsSent().orderedIncrement();
        }
    }

    public void triggerSendSetupFrame()
    {
        shouldSendSetupFrame = true;
    }

    public int decRef()
    {
        return --refCount;
    }

    public int incRef()
    {
        final int i = ++refCount;

        if (i == 1)
        {
            timeOfFlush = 0;
            isActive = true;
        }

        return i;
    }

    public boolean isUnreferencedAndFlushed(final long now)
    {
        boolean isFlushed = false;
        if (0 == refCount)
        {
            final long senderPosition = this.senderPosition.getVolatile();
            final int activeIndex = indexByPosition(senderPosition, positionBitsToShift);
            isFlushed = (int)(senderPosition & termLengthMask) >= logPartitions[activeIndex].tailVolatile();

            if (isFlushed && isActive)
            {
                timeOfFlush = now;
                isActive = false;
            }
        }

        return isFlushed;
    }

    public RawLog rawLog()
    {
        return rawLog;
    }

    public int publisherLimitId()
    {
        return publisherLimit.id();
    }

    
    public int updatePublishersLimit()
    {
        int workCount = 0;
        final long candidatePublisherLimit = senderPosition.getVolatile() + termWindowLength;
        if (publisherLimit.proposeMaxOrdered(candidatePublisherLimit))
        {
            workCount = 1;
        }

        return workCount;
    }

    public void onNak(final int termId, final int termOffset, final int length)
    {
        retransmitHandler.onNak(termId, termOffset, length, this);
    }

    private int sendData(final long now, final long senderPosition, final int termOffset)
    {
        int bytesSent = 0;
        final int availableWindow = (int)(senderPositionLimit - senderPosition);
        if (availableWindow > 0)
        {
            final int scanLimit = Math.min(availableWindow, mtuLength);
            final int activeIndex = indexByPosition(senderPosition, positionBitsToShift);

            final long scanOutcome = scanForAvailability(logPartitions[activeIndex].termBuffer(), termOffset, scanLimit);
            final int available = available(scanOutcome);
            if (available > 0)
            {
                final ByteBuffer sendBuffer = sendBuffers[activeIndex];
                sendBuffer.limit(termOffset + available).position(termOffset);

                if (available == channelEndpoint.send(sendBuffer))
                {
                    timeOfLastSendOrHeartbeat = now;
                    trackSenderLimits = true;

                    bytesSent = available;
                    this.senderPosition.setOrdered(senderPosition + bytesSent + padding(scanOutcome));
                }
                else
                {
                    systemCounters.dataPacketShortSends().orderedIncrement();
                }
            }
        }
        else if (trackSenderLimits)
        {
            trackSenderLimits = false;
            systemCounters.senderFlowControlLimits().orderedIncrement();
        }

        return bytesSent;
    }

    private void setupMessageCheck(final long now, final int activeTermId, final int termOffset, final long senderPosition)
    {
        if (0 != senderPosition || (now > (timeOfLastSendOrHeartbeat + PUBLICATION_SETUP_TIMEOUT_NS)))
        {
            setupFrameBuffer.clear();
            setupHeader.activeTermId(activeTermId).termOffset(termOffset);

            final int bytesSent = channelEndpoint.send(setupFrameBuffer);
            if (SetupFlyweight.HEADER_LENGTH != bytesSent)
            {
                systemCounters.setupMessageShortSends().orderedIncrement();
            }

            timeOfLastSendOrHeartbeat = now;
        }

        if (statusMessagesReceivedCount > 0)
        {
            shouldSendSetupFrame = false;
        }
    }

    private void heartbeatMessageCheck(final long now, final long senderPosition, final int activeTermId)
    {
        if (now > (timeOfLastSendOrHeartbeat + PUBLICATION_HEARTBEAT_TIMEOUT_NS))
        {
            final int termOffset = (int)senderPosition & termLengthMask;

            heartbeatFrameBuffer.clear();
            dataHeader.termId(activeTermId).termOffset(termOffset);

            final int bytesSent = channelEndpoint.send(heartbeatFrameBuffer);
            if (DataHeaderFlyweight.HEADER_LENGTH != bytesSent)
            {
                systemCounters.dataPacketShortSends().orderedIncrement();
            }

            systemCounters.heartbeatsSent().orderedIncrement();
            timeOfLastSendOrHeartbeat = now;
        }
    }

    private void initSetupFrame(final int activeTermId, final int termLength, final int sessionId, final int streamId)
    {
        setupHeader
            .sessionId(sessionId)
            .streamId(streamId)
            .initialTermId(initialTermId)
            .activeTermId(activeTermId)
            .termOffset(0)
            .termLength(termLength)
            .mtuLength(mtuLength)
            .version(HeaderFlyweight.CURRENT_VERSION)
            .flags((byte)0)
            .headerType(HeaderFlyweight.HDR_TYPE_SETUP)
            .frameLength(SetupFlyweight.HEADER_LENGTH);
    }

    private void initHeartBeatFrame(final int sessionId, final int streamId)
    {
        dataHeader
            .sessionId(sessionId)
            .streamId(streamId)
            .version(HeaderFlyweight.CURRENT_VERSION)
            .flags((byte)DataHeaderFlyweight.BEGIN_AND_END_FLAGS)
            .headerType(HeaderFlyweight.HDR_TYPE_DATA)
            .frameLength(0);
    }
}

<code block>

package uk.co.real_logic.aeron.driver;

import uk.co.real_logic.aeron.driver.cmd.SenderCmd;
import uk.co.real_logic.aeron.driver.media.SendChannelEndpoint;
import uk.co.real_logic.aeron.driver.media.TransportPoller;
import uk.co.real_logic.agrona.concurrent.Agent;
import uk.co.real_logic.agrona.concurrent.AtomicCounter;
import uk.co.real_logic.agrona.concurrent.NanoClock;
import uk.co.real_logic.agrona.concurrent.OneToOneConcurrentArrayQueue;

import java.util.function.Consumer;


public class Sender implements Agent, Consumer<SenderCmd>
{
    private static final NetworkPublication[] EMPTY_PUBLICATIONS = new NetworkPublication[0];

    private final TransportPoller transportPoller;
    private final OneToOneConcurrentArrayQueue<SenderCmd> commandQueue;
    private final DriverConductorProxy conductorProxy;
    private final AtomicCounter totalBytesSent;
    private final NanoClock nanoClock;

    private NetworkPublication[] publications = EMPTY_PUBLICATIONS;
    private int roundRobinIndex = 0;

    public Sender(final MediaDriver.Context ctx)
    {
        this.transportPoller = ctx.senderNioSelector();
        this.commandQueue = ctx.senderCommandQueue();
        this.conductorProxy = ctx.fromSenderDriverConductorProxy();
        this.totalBytesSent = ctx.systemCounters().bytesSent();
        this.nanoClock = ctx.nanoClock();
    }

    public int doWork()
    {
        final long now = nanoClock.nanoTime();
        final int workCount = commandQueue.drain(this);
        final int bytesSent = doSend(now);
        final int bytesReceived = transportPoller.pollTransports();

        return workCount + bytesSent + bytesReceived;
    }

    public String roleName()
    {
        return "sender";
    }

    public void onRegisterSendChannelEndpoint(final SendChannelEndpoint channelEndpoint)
    {
        channelEndpoint.openChannel();
        channelEndpoint.registerForRead(transportPoller);
        transportPoller.selectNowWithoutProcessing();
    }

    public void onCloseSendChannelEndpoint(final SendChannelEndpoint channelEndpoint)
    {
        channelEndpoint.close();
        transportPoller.selectNowWithoutProcessing();
    }

    public void onNewPublication(final NetworkPublication publication, final FlowControl flowControl)
    {
        final NetworkPublication[] oldPublications = publications;
        final int length = oldPublications.length;
        final NetworkPublication[] newPublications = new NetworkPublication[length + 1];

        System.arraycopy(oldPublications, 0, newPublications, 0, length);
        newPublications[length] = publication;

        publications = newPublications;

        publication.sendChannelEndpoint().addToDispatcher(publication, flowControl);
    }

    public void onRemovePublication(final NetworkPublication publication)
    {
        final NetworkPublication[] oldPublications = publications;
        final int length = oldPublications.length;
        final NetworkPublication[] newPublications = new NetworkPublication[length - 1];
        for (int i = 0, j = 0; i < length; i++)
        {
            if (oldPublications[i] != publication)
            {
                newPublications[j++] = oldPublications[i];
            }
        }

        publications = newPublications;
        publication.sendChannelEndpoint().removeFromDispatcher(publication);
        conductorProxy.closeResource(publication);
    }

    public void accept(final SenderCmd cmd)
    {
        cmd.execute(this);
    }

    private int doSend(final long now)
    {
        int bytesSent = 0;
        final NetworkPublication[] publications = this.publications;
        final int length = publications.length;

        if (length > 0)
        {
            int startingIndex = roundRobinIndex++;
            if (startingIndex >= length)
            {
                roundRobinIndex = startingIndex = 0;
            }

            int i = startingIndex;

            do
            {
                bytesSent += publications[i].send(now);

                if (++i == length)
                {
                    i = 0;
                }
            }
            while (i != startingIndex);
        }

        totalBytesSent.addOrdered(bytesSent);

        return bytesSent;
    }
}

<code block>

package uk.co.real_logic.aeron.driver;

import uk.co.real_logic.aeron.command.CorrelatedMessageFlyweight;
import uk.co.real_logic.aeron.command.PublicationMessageFlyweight;
import uk.co.real_logic.aeron.command.RemoveMessageFlyweight;
import uk.co.real_logic.aeron.command.SubscriptionMessageFlyweight;
import uk.co.real_logic.aeron.driver.MediaDriver.Context;
import uk.co.real_logic.aeron.driver.buffer.RawLog;
import uk.co.real_logic.aeron.driver.buffer.RawLogFactory;
import uk.co.real_logic.aeron.driver.cmd.DriverConductorCmd;
import uk.co.real_logic.aeron.driver.event.EventCode;
import uk.co.real_logic.aeron.driver.event.EventLogger;
import uk.co.real_logic.aeron.driver.exceptions.ControlProtocolException;
import uk.co.real_logic.aeron.driver.media.ReceiveChannelEndpoint;
import uk.co.real_logic.aeron.driver.media.SendChannelEndpoint;
import uk.co.real_logic.aeron.driver.media.UdpChannel;
import uk.co.real_logic.aeron.logbuffer.LogBufferDescriptor;
import uk.co.real_logic.aeron.protocol.DataHeaderFlyweight;
import uk.co.real_logic.agrona.BitUtil;
import uk.co.real_logic.agrona.MutableDirectBuffer;
import uk.co.real_logic.agrona.concurrent.*;
import uk.co.real_logic.agrona.concurrent.ringbuffer.RingBuffer;
import uk.co.real_logic.agrona.concurrent.status.Position;
import uk.co.real_logic.agrona.concurrent.status.UnsafeBufferPosition;

import java.net.InetSocketAddress;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.function.Consumer;
import java.util.function.Supplier;

import static java.util.stream.Collectors.toList;
import static uk.co.real_logic.aeron.ErrorCode.*;
import static uk.co.real_logic.aeron.command.ControlProtocolEvents.*;
import static uk.co.real_logic.aeron.driver.Configuration.*;
import static uk.co.real_logic.aeron.driver.event.EventConfiguration.EVENT_READER_FRAME_LIMIT;


public class DriverConductor implements Agent
{
    private final int mtuLength;
    private final int termBufferLength;
    private final int initialWindowLength;

    private final RawLogFactory rawLogFactory;
    private final ReceiverProxy receiverProxy;
    private final SenderProxy senderProxy;
    private final ClientProxy clientProxy;
    private final DriverConductorProxy fromReceiverConductorProxy;
    private final RingBuffer toDriverCommands;
    private final RingBuffer toEventReader;
    private final OneToOneConcurrentArrayQueue<DriverConductorCmd> fromReceiverDriverConductorCmdQueue;
    private final OneToOneConcurrentArrayQueue<DriverConductorCmd> fromSenderDriverConductorCmdQueue;
    private final Supplier<FlowControl> unicastFlowControl;
    private final Supplier<FlowControl> multicastFlowControl;
    private final HashMap<String, SendChannelEndpoint> sendChannelEndpointByChannelMap = new HashMap<>();
    private final HashMap<String, ReceiveChannelEndpoint> receiveChannelEndpointByChannelMap = new HashMap<>();
    private final ArrayList<PublicationLink> publicationLinks = new ArrayList<>();
    private final ArrayList<NetworkPublication> publications = new ArrayList<>();
    private final ArrayList<SubscriptionLink> subscriptionLinks = new ArrayList<>();
    private final ArrayList<NetworkConnection> connections = new ArrayList<>();
    private final ArrayList<AeronClient> clients = new ArrayList<>();

    private final PublicationMessageFlyweight publicationMsgFlyweight = new PublicationMessageFlyweight();
    private final SubscriptionMessageFlyweight subscriptionMsgFlyweight = new SubscriptionMessageFlyweight();
    private final CorrelatedMessageFlyweight correlatedMsgFlyweight = new CorrelatedMessageFlyweight();
    private final RemoveMessageFlyweight removeMsgFlyweight = new RemoveMessageFlyweight();

    private final EpochClock epochClock;
    private final NanoClock nanoClock;
    private final SystemCounters systemCounters;
    private final UnsafeBuffer countersBuffer;
    private final CountersManager countersManager;
    private final EventLogger logger;
    private final Consumer<DriverConductorCmd> onDriverConductorCmdFunc = this::onDriverConductorCmd;
    private final MessageHandler onClientCommandFunc = this::onClientCommand;
    private final MessageHandler onEventFunc;
    private final LossGenerator dataLossGenerator;
    private final LossGenerator controlLossGenerator;

    private long timeOfLastTimeoutCheck;

    public DriverConductor(final Context ctx)
    {
        fromReceiverDriverConductorCmdQueue = ctx.toConductorFromReceiverCommandQueue();
        fromSenderDriverConductorCmdQueue = ctx.toConductorFromSenderCommandQueue();
        receiverProxy = ctx.receiverProxy();
        senderProxy = ctx.senderProxy();
        rawLogFactory = ctx.rawLogBuffersFactory();
        mtuLength = ctx.mtuLength();
        initialWindowLength = ctx.initialWindowLength();
        termBufferLength = ctx.termBufferLength();
        unicastFlowControl = ctx.unicastSenderFlowControl();
        multicastFlowControl = ctx.multicastSenderFlowControl();
        countersManager = ctx.countersManager();
        countersBuffer = ctx.counterValuesBuffer();
        epochClock = ctx.epochClock();
        nanoClock = ctx.nanoClock();
        toDriverCommands = ctx.toDriverCommands();
        toEventReader = ctx.toEventReader();
        clientProxy = ctx.clientProxy();
        fromReceiverConductorProxy = ctx.fromReceiverDriverConductorProxy();
        logger = ctx.eventLogger();
        systemCounters = ctx.systemCounters();
        dataLossGenerator = ctx.dataLossGenerator();
        controlLossGenerator = ctx.controlLossGenerator();

        final Consumer<String> eventConsumer = ctx.eventConsumer();
        onEventFunc =
            (typeId, buffer, offset, length) -> eventConsumer.accept(EventCode.get(typeId).decode(buffer, offset, length));

        final AtomicBuffer buffer = toDriverCommands.buffer();
        publicationMsgFlyweight.wrap(buffer, 0);
        subscriptionMsgFlyweight.wrap(buffer, 0);
        correlatedMsgFlyweight.wrap(buffer, 0);
        removeMsgFlyweight.wrap(buffer, 0);

        toDriverCommands.consumerHeartbeatTime(epochClock.time());
        timeOfLastTimeoutCheck = nanoClock.nanoTime();
    }

    private static AeronClient findClient(final ArrayList<AeronClient> clients, final long clientId)
    {
        AeronClient aeronClient = null;

        for (int i = 0, size = clients.size(); i < size; i++)
        {
            final AeronClient client = clients.get(i);
            if (client.clientId() == clientId)
            {
                aeronClient = client;
                break;
            }
        }

        return aeronClient;
    }

    private static PublicationLink findPublicationLink(
        final ArrayList<PublicationLink> publicationLinks, final long registrationId)
    {
        PublicationLink publicationLink = null;

        for (int i = 0, size = publicationLinks.size(); i < size; i++)
        {
            final PublicationLink link = publicationLinks.get(i);
            if (registrationId == link.registrationId())
            {
                publicationLink = link;
                break;
            }
        }

        return publicationLink;
    }

    private static String generateSourceIdentity(final InetSocketAddress address)
    {
        return String.format("%s:%d", address.getHostString(), address.getPort());
    }

    private static SubscriptionLink removeSubscription(
        final ArrayList<SubscriptionLink> subscriptions, final long registrationId)
    {
        SubscriptionLink subscription = null;
        for (int i = 0, size = subscriptions.size(); i < size; i++)
        {
            subscription = subscriptions.get(i);
            if (subscription.registrationId() == registrationId)
            {
                subscriptions.remove(i);
                break;
            }
        }

        return subscription;
    }

    public void onClose()
    {
        rawLogFactory.close();
        publications.forEach(NetworkPublication::close);
        connections.forEach(NetworkConnection::close);
        sendChannelEndpointByChannelMap.values().forEach(SendChannelEndpoint::close);
        receiveChannelEndpointByChannelMap.values().forEach(ReceiveChannelEndpoint::close);
    }

    public String roleName()
    {
        return "driver-conductor";
    }

    public SendChannelEndpoint senderChannelEndpoint(final UdpChannel channel)
    {
        return sendChannelEndpointByChannelMap.get(channel.canonicalForm());
    }

    public ReceiveChannelEndpoint receiverChannelEndpoint(final UdpChannel channel)
    {
        return receiveChannelEndpointByChannelMap.get(channel.canonicalForm());
    }

    public int doWork() throws Exception
    {
        int workCount = 0;

        workCount += toDriverCommands.read(onClientCommandFunc);
        workCount += fromReceiverDriverConductorCmdQueue.drain(onDriverConductorCmdFunc);
        workCount += fromSenderDriverConductorCmdQueue.drain(onDriverConductorCmdFunc);
        workCount += toEventReader.read(onEventFunc, EVENT_READER_FRAME_LIMIT);

        final long now = nanoClock.nanoTime();
        workCount += processTimers(now);

        final ArrayList<NetworkConnection> connections = this.connections;
        for (int i = 0, size = connections.size(); i < size; i++)
        {
            final NetworkConnection connection = connections.get(i);
            workCount += connection.trackRebuild(now);
        }

        final ArrayList<NetworkPublication> publications = this.publications;
        for (int i = 0, size = publications.size(); i < size; i++)
        {
            final NetworkPublication publication = publications.get(i);
            workCount += publication.updatePublishersLimit() + publication.cleanLogBuffer();
        }

        return workCount;
    }

    private void onHeartbeatCheckTimeouts(final long nanoTimeNow)
    {
        toDriverCommands.consumerHeartbeatTime(epochClock.time());

        onCheckClients(nanoTimeNow);
        onCheckPublications(nanoTimeNow);
        onCheckPublicationLinks(nanoTimeNow);
        onCheckConnections(nanoTimeNow);
        onCheckSubscriptionLinks(nanoTimeNow);
    }

    public void onCreateConnection(
        final int sessionId,
        final int streamId,
        final int initialTermId,
        final int activeTermId,
        final int initialTermOffset,
        final int termBufferLength,
        final int senderMtuLength,
        final InetSocketAddress controlAddress,
        final InetSocketAddress sourceAddress,
        final ReceiveChannelEndpoint channelEndpoint)
    {
        channelEndpoint.validateSenderMtuLength(senderMtuLength);
        channelEndpoint.validateWindowMaxLength(initialWindowLength);

        final UdpChannel udpChannel = channelEndpoint.udpChannel();
        final String channel = udpChannel.originalUriString();
        final long connectionCorrelationId = generateCreationCorrelationId();

        final long joiningPosition = LogBufferDescriptor.computePosition(
            activeTermId, initialTermOffset, Integer.numberOfTrailingZeros(termBufferLength), initialTermId);

        final List<SubscriberPosition> subscriberPositions = listSubscriberPositions(
            sessionId, streamId, channelEndpoint, channel, joiningPosition);

        if (subscriberPositions.size() > 0)
        {
            final RawLog rawLog = newConnectionLog(
                sessionId, streamId, initialTermId, termBufferLength, senderMtuLength, udpChannel, connectionCorrelationId);

            final NetworkConnection connection = new NetworkConnection(
                connectionCorrelationId,
                channelEndpoint,
                controlAddress,
                sessionId,
                streamId,
                initialTermId,
                activeTermId,
                initialTermOffset,
                initialWindowLength,
                rawLog,
                Configuration.doNotSendNaks() ? NO_NAK_DELAY_GENERATOR :
                    udpChannel.isMulticast() ? NAK_MULTICAST_DELAY_GENERATOR : NAK_UNICAST_DELAY_GENERATOR,
                subscriberPositions.stream().map(SubscriberPosition::position).collect(toList()),
                newPosition("receiver hwm", channel, sessionId, streamId, connectionCorrelationId),
                nanoClock,
                systemCounters,
                sourceAddress);

            subscriberPositions.forEach(
                (subscriberPosition) ->
                    subscriberPosition.subscription().addConnection(connection, subscriberPosition.position()));

            connections.add(connection);
            receiverProxy.newConnection(channelEndpoint, connection);

            clientProxy.onConnectionReady(
                streamId,
                sessionId,
                joiningPosition,
                rawLog,
                connectionCorrelationId,
                subscriberPositions,
                generateSourceIdentity(sourceAddress));
        }
    }

    public void onCloseResource(final AutoCloseable resource)
    {
        try
        {
            resource.close();
        }
        catch (final Exception ex)
        {
            logger.logException(ex);
        }
    }

    public List<SubscriberPosition> listSubscriberPositions(
        final int sessionId,
        final int streamId,
        final ReceiveChannelEndpoint channelEndpoint,
        final String channel,
        final long joiningPosition)
    {
        return subscriptionLinks
            .stream()
            .filter((subscription) -> subscription.matches(channelEndpoint, streamId))
            .map(
                (subscription) ->
                {
                    final Position position = newPosition(
                        "subscriber pos", channel, sessionId, streamId, subscription.registrationId());

                    position.setOrdered(joiningPosition);

                    return new SubscriberPosition(subscription, position);
                })
            .collect(toList());
    }

    private void onClientCommand(final int msgTypeId, final MutableDirectBuffer buffer, final int index, final int length)
    {
        CorrelatedMessageFlyweight flyweight = null;

        try
        {
            switch (msgTypeId)
            {
                case ADD_PUBLICATION:
                {
                    logger.log(EventCode.CMD_IN_ADD_PUBLICATION, buffer, index, length);

                    final PublicationMessageFlyweight publicationMessageFlyweight = publicationMsgFlyweight;
                    publicationMessageFlyweight.offset(index);
                    flyweight = publicationMessageFlyweight;

                    onAddPublication(
                        publicationMessageFlyweight.channel(),
                        publicationMessageFlyweight.sessionId(),
                        publicationMessageFlyweight.streamId(),
                        publicationMessageFlyweight.correlationId(),
                        publicationMessageFlyweight.clientId());
                    break;
                }

                case REMOVE_PUBLICATION:
                {
                    logger.log(EventCode.CMD_IN_REMOVE_PUBLICATION, buffer, index, length);

                    final RemoveMessageFlyweight removeMessageFlyweight = removeMsgFlyweight;
                    removeMessageFlyweight.offset(index);
                    flyweight = removeMessageFlyweight;

                    onRemovePublication(removeMessageFlyweight.registrationId(), removeMessageFlyweight.correlationId());
                    break;
                }

                case ADD_SUBSCRIPTION:
                {
                    logger.log(EventCode.CMD_IN_ADD_SUBSCRIPTION, buffer, index, length);

                    final SubscriptionMessageFlyweight subscriptionMessageFlyweight = subscriptionMsgFlyweight;
                    subscriptionMessageFlyweight.offset(index);
                    flyweight = subscriptionMessageFlyweight;

                    onAddSubscription(
                        subscriptionMessageFlyweight.channel(),
                        subscriptionMessageFlyweight.streamId(),
                        subscriptionMessageFlyweight.correlationId(),
                        subscriptionMessageFlyweight.clientId());
                    break;
                }

                case REMOVE_SUBSCRIPTION:
                {
                    logger.log(EventCode.CMD_IN_REMOVE_SUBSCRIPTION, buffer, index, length);

                    final RemoveMessageFlyweight removeMessageFlyweight = removeMsgFlyweight;
                    removeMessageFlyweight.offset(index);
                    flyweight = removeMessageFlyweight;

                    onRemoveSubscription(removeMessageFlyweight.registrationId(), removeMessageFlyweight.correlationId());
                    break;
                }

                case CLIENT_KEEPALIVE:
                {
                    logger.log(EventCode.CMD_IN_KEEPALIVE_CLIENT, buffer, index, length);

                    final CorrelatedMessageFlyweight correlatedMessageFlyweight = correlatedMsgFlyweight;
                    correlatedMessageFlyweight.offset(index);
                    flyweight = correlatedMessageFlyweight;

                    onClientKeepalive(correlatedMessageFlyweight.clientId());
                    break;
                }
            }
        }
        catch (final ControlProtocolException ex)
        {
            clientProxy.onError(ex.errorCode(), ex.getMessage(), flyweight);
            logger.logException(ex);
        }
        catch (final Exception ex)
        {
            clientProxy.onError(GENERIC_ERROR, ex.getMessage(), flyweight);
            logger.logException(ex);
        }
    }

    private int processTimers(final long now)
    {
        int workCount = 0;

        if (now > (timeOfLastTimeoutCheck + HEARTBEAT_TIMEOUT_NS))
        {
            onHeartbeatCheckTimeouts(now);
            timeOfLastTimeoutCheck = now;
            workCount = 1;
        }

        return workCount;
    }

    private void onAddPublication(
        final String channel, final int sessionId, final int streamId, final long registrationId, final long clientId)
    {
        final UdpChannel udpChannel = UdpChannel.parse(channel);
        final SendChannelEndpoint channelEndpoint = getOrCreateSendChannelEndpoint(udpChannel);

        NetworkPublication publication = channelEndpoint.getPublication(sessionId, streamId);
        if (null == publication)
        {
            final int initialTermId = BitUtil.generateRandomisedId();
            final FlowControl flowControl = udpChannel.isMulticast() ? multicastFlowControl.get() : unicastFlowControl.get();

            final RetransmitHandler retransmitHandler = new RetransmitHandler(
                nanoClock,
                systemCounters,
                RETRANSMIT_UNICAST_DELAY_GENERATOR,
                RETRANSMIT_UNICAST_LINGER_GENERATOR,
                initialTermId,
                termBufferLength);

            publication = new NetworkPublication(
                channelEndpoint,
                nanoClock,
                newPublicationLog(sessionId, streamId, initialTermId, udpChannel, registrationId),
                newPosition("sender pos", channel, sessionId, streamId, registrationId),
                newPosition("publisher limit", channel, sessionId, streamId, registrationId),
                sessionId,
                streamId,
                initialTermId,
                mtuLength,
                flowControl.initialPositionLimit(initialTermId, termBufferLength),
                systemCounters,
                retransmitHandler);

            channelEndpoint.addPublication(publication);
            publications.add(publication);
            senderProxy.newPublication(publication, flowControl);
        }

        final AeronClient client = getOrAddClient(clientId);
        linkPublication(registrationId, publication, client);

        publication.incRef();

        clientProxy.onPublicationReady(
            streamId,
            sessionId,
            publication.rawLog(),
            registrationId,
            publication.publisherLimitId());
    }

    private void linkPublication(final long registrationId, final NetworkPublication publication, final AeronClient client)
    {
        if (null != findPublicationLink(publicationLinks, registrationId))
        {
            throw new ControlProtocolException(GENERIC_ERROR, "registration id already in use.");
        }

        publicationLinks.add(new PublicationLink(registrationId, publication, client));
    }

    private RawLog newPublicationLog(
        final int sessionId, final int streamId, final int initialTermId, final UdpChannel udpChannel, final long registrationId)
    {
        final String canonicalForm = udpChannel.canonicalForm();
        final RawLog rawLog = rawLogFactory.newPublication(canonicalForm, sessionId, streamId, registrationId);

        final MutableDirectBuffer header = DataHeaderFlyweight.createDefaultHeader(sessionId, streamId, initialTermId);
        final UnsafeBuffer logMetaData = rawLog.logMetaData();
        LogBufferDescriptor.storeDefaultFrameHeaders(logMetaData, header);
        LogBufferDescriptor.initialTermId(logMetaData, initialTermId);
        LogBufferDescriptor.mtuLength(logMetaData, mtuLength);

        return rawLog;
    }

    private RawLog newConnectionLog(
        final int sessionId,
        final int streamId,
        final int initialTermId,
        final int termBufferLength,
        final int senderMtuLength,
        final UdpChannel udpChannel,
        final long correlationId)
    {
        final String canonicalForm = udpChannel.canonicalForm();
        final RawLog rawLog = rawLogFactory.newConnection(canonicalForm, sessionId, streamId, correlationId, termBufferLength);

        final MutableDirectBuffer header = DataHeaderFlyweight.createDefaultHeader(sessionId, streamId, initialTermId);
        final UnsafeBuffer logMetaData = rawLog.logMetaData();
        LogBufferDescriptor.storeDefaultFrameHeaders(logMetaData, header);
        LogBufferDescriptor.initialTermId(logMetaData, initialTermId);
        LogBufferDescriptor.mtuLength(logMetaData, senderMtuLength);

        return rawLog;
    }

    private SendChannelEndpoint getOrCreateSendChannelEndpoint(final UdpChannel udpChannel)
    {
        SendChannelEndpoint channelEndpoint = sendChannelEndpointByChannelMap.get(udpChannel.canonicalForm());
        if (null == channelEndpoint)
        {
            logger.logChannelCreated(udpChannel.description());

            channelEndpoint = new SendChannelEndpoint(
                udpChannel,
                logger,
                controlLossGenerator,
                systemCounters);

            sendChannelEndpointByChannelMap.put(udpChannel.canonicalForm(), channelEndpoint);
            senderProxy.registerSendChannelEndpoint(channelEndpoint);
        }

        return channelEndpoint;
    }

    private void onRemovePublication(final long registrationId, final long correlationId)
    {
        PublicationLink publicationLink = null;
        final ArrayList<PublicationLink> publicationLinks = this.publicationLinks;
        for (int i = 0, size = publicationLinks.size(); i < size; i++)
        {
            final PublicationLink link = publicationLinks.get(i);
            if (registrationId == link.registrationId())
            {
                publicationLink = link;
                publicationLinks.remove(i);
                break;
            }
        }

        if (null == publicationLink)
        {
            throw new ControlProtocolException(UNKNOWN_PUBLICATION, "Unknown publication: " + registrationId);
        }

        publicationLink.remove();
        clientProxy.operationSucceeded(correlationId);
    }

    private void onAddSubscription(final String channel, final int streamId, final long registrationId, final long clientId)
    {
        final ReceiveChannelEndpoint channelEndpoint = getOrCreateReceiveChannelEndpoint(UdpChannel.parse(channel));

        final int refCount = channelEndpoint.incRefToStream(streamId);
        if (1 == refCount)
        {
            receiverProxy.addSubscription(channelEndpoint, streamId);
        }

        final AeronClient client = getOrAddClient(clientId);
        final SubscriptionLink subscription = new SubscriptionLink(registrationId, channelEndpoint, streamId, client);

        subscriptionLinks.add(subscription);
        clientProxy.operationSucceeded(registrationId);

        connections
            .stream()
            .filter((connection) -> connection.matches(channelEndpoint, streamId) && (connection.subscriberCount() > 0))
            .forEach(
                (connection) ->
                {
                    final Position position = newPosition(
                        "subscriber pos", channel, connection.sessionId(), streamId, registrationId);

                    connection.addSubscriber(position);
                    subscription.addConnection(connection, position);

                    clientProxy.onConnectionReady(
                        streamId,
                        connection.sessionId(),
                        connection.rebuildPosition(),
                        connection.rawLog(),
                        connection.correlationId(),
                        Collections.singletonList(new SubscriberPosition(subscription, position)),
                        generateSourceIdentity(connection.sourceAddress()));
                });
    }

    private ReceiveChannelEndpoint getOrCreateReceiveChannelEndpoint(final UdpChannel udpChannel)
    {
        ReceiveChannelEndpoint channelEndpoint = receiveChannelEndpointByChannelMap.get(udpChannel.canonicalForm());
        if (null == channelEndpoint)
        {
            channelEndpoint = new ReceiveChannelEndpoint(
                udpChannel,
                new DataPacketDispatcher(fromReceiverConductorProxy, receiverProxy.receiver()),
                logger,
                systemCounters,
                dataLossGenerator);

            receiveChannelEndpointByChannelMap.put(udpChannel.canonicalForm(), channelEndpoint);
            receiverProxy.registerReceiveChannelEndpoint(channelEndpoint);
        }

        return channelEndpoint;
    }

    private void onRemoveSubscription(final long registrationId, final long correlationId)
    {
        final SubscriptionLink subscription = removeSubscription(subscriptionLinks, registrationId);
        if (null == subscription)
        {
            throw new ControlProtocolException(UNKNOWN_SUBSCRIPTION, "Unknown subscription: " + registrationId);
        }

        subscription.close();
        final ReceiveChannelEndpoint channelEndpoint = subscription.channelEndpoint();

        final int refCount = channelEndpoint.decRefToStream(subscription.streamId());
        if (0 == refCount)
        {
            receiverProxy.removeSubscription(channelEndpoint, subscription.streamId());
        }

        if (0 == channelEndpoint.streamCount())
        {
            receiveChannelEndpointByChannelMap.remove(channelEndpoint.udpChannel().canonicalForm());
            receiverProxy.closeReceiveChannelEndpoint(channelEndpoint);

            while (!channelEndpoint.isClosed())
            {
                Thread.yield();
            }
        }

        clientProxy.operationSucceeded(correlationId);
    }

    private void onClientKeepalive(final long clientId)
    {
        systemCounters.clientKeepAlives().addOrdered(1);

        final AeronClient client = findClient(clients, clientId);
        if (null != client)
        {
            client.timeOfLastKeepalive(nanoClock.nanoTime());
        }
    }

    private void onCheckPublicationLinks(final long now)
    {
        final ArrayList<PublicationLink> publicationLinks = this.publicationLinks;
        for (int i = publicationLinks.size() - 1; i >= 0; i--)
        {
            final PublicationLink link = publicationLinks.get(i);
            if (link.hasClientTimedOut(now))
            {
                publicationLinks.remove(i);
            }
        }
    }

    private void onCheckPublications(final long now)
    {
        final ArrayList<NetworkPublication> publications = this.publications;
        for (int i = publications.size() - 1; i >= 0; i--)
        {
            final NetworkPublication publication = publications.get(i);

            if (publication.isUnreferencedAndFlushed(now) && now > (publication.timeOfFlush() + PUBLICATION_LINGER_NS))
            {
                final SendChannelEndpoint channelEndpoint = publication.sendChannelEndpoint();

                logger.logPublicationRemoval(
                    channelEndpoint.originalUriString(), publication.sessionId(), publication.streamId());

                channelEndpoint.removePublication(publication);
                publications.remove(i);

                senderProxy.removePublication(publication);

                if (channelEndpoint.sessionCount() == 0)
                {
                    sendChannelEndpointByChannelMap.remove(channelEndpoint.udpChannel().canonicalForm());
                    senderProxy.closeSendChannelEndpoint(channelEndpoint);
                }
            }
        }
    }

    private void onCheckSubscriptionLinks(final long now)
    {
        final ArrayList<SubscriptionLink> subscriptions = this.subscriptionLinks;
        for (int i = subscriptions.size() - 1; i >= 0; i--)
        {
            final SubscriptionLink subscription = subscriptions.get(i);

            if (now > (subscription.timeOfLastKeepaliveFromClient() + CLIENT_LIVENESS_TIMEOUT_NS))
            {
                final ReceiveChannelEndpoint channelEndpoint = subscription.channelEndpoint();
                final int streamId = subscription.streamId();

                logger.logSubscriptionRemoval(
                    channelEndpoint.originalUriString(), subscription.streamId(), subscription.registrationId());

                subscriptions.remove(i);
                subscription.close();

                if (0 == channelEndpoint.decRefToStream(subscription.streamId()))
                {
                    receiverProxy.removeSubscription(channelEndpoint, streamId);
                }

                if (channelEndpoint.streamCount() == 0)
                {
                    receiveChannelEndpointByChannelMap.remove(channelEndpoint.udpChannel().canonicalForm());
                    receiverProxy.closeReceiveChannelEndpoint(channelEndpoint);
                }
            }
        }
    }

    private void onCheckConnections(final long now)
    {
        final ArrayList<NetworkConnection> connections = this.connections;
        for (int i = connections.size() - 1; i >= 0; i--)
        {
            final NetworkConnection conn = connections.get(i);

            switch (conn.status())
            {
                case INACTIVE:
                    if (conn.isDrained() || now > (conn.timeOfLastStatusChange() + CONNECTION_LIVENESS_TIMEOUT_NS))
                    {
                        conn.status(NetworkConnection.Status.LINGER);

                        clientProxy.onInactiveConnection(
                            conn.correlationId(),
                            conn.sessionId(),
                            conn.streamId(),
                            conn.rebuildPosition(),
                            conn.channelUriString());
                    }
                    break;

                case LINGER:
                    if (now > (conn.timeOfLastStatusChange() + CONNECTION_LIVENESS_TIMEOUT_NS))
                    {
                        logger.logConnectionRemoval(
                            conn.channelUriString(), conn.sessionId(), conn.streamId(), conn.correlationId());

                        connections.remove(i);

                        subscriptionLinks.stream()
                            .filter((link) -> conn.matches(link.channelEndpoint(), link.streamId()))
                            .forEach((subscriptionLink) -> subscriptionLink.removeConnection(conn));

                        conn.close();
                    }
                    break;
            }
        }
    }

    private void onCheckClients(final long now)
    {
        for (int i = clients.size() - 1; i >= 0; i--)
        {
            final AeronClient client = clients.get(i);

            if (now > (client.timeOfLastKeepalive() + CONNECTION_LIVENESS_TIMEOUT_NS))
            {
                clients.remove(i);
            }
        }
    }

    private void onDriverConductorCmd(final DriverConductorCmd cmd)
    {
        cmd.execute(this);
    }

    private AeronClient getOrAddClient(final long clientId)
    {
        AeronClient client = findClient(clients, clientId);
        if (null == client)
        {
            client = new AeronClient(clientId, nanoClock.nanoTime());
            clients.add(client);
        }

        return client;
    }

    private Position newPosition(
        final String name, final String channel, final int sessionId, final int streamId, final long correlationId)
    {
        final int positionId = allocateCounter(name, channel, sessionId, streamId, correlationId);
        return new UnsafeBufferPosition(countersBuffer, positionId, countersManager);
    }

    private int allocateCounter(
        final String type, final String channel, final int sessionId, final int streamId, final long correlationId)
    {
        return countersManager.allocate(String.format("%s: %s %d %d %d", type, channel, sessionId, streamId, correlationId));
    }

    private long generateCreationCorrelationId()
    {
        return toDriverCommands.nextCorrelationId();
    }
}

<code block>

package uk.co.real_logic.aeron.driver;

import uk.co.real_logic.aeron.driver.cmd.*;
import uk.co.real_logic.aeron.driver.media.SendChannelEndpoint;
import uk.co.real_logic.agrona.concurrent.AtomicCounter;

import java.util.Queue;

import static uk.co.real_logic.aeron.driver.ThreadingMode.SHARED;


public class SenderProxy
{
    private final ThreadingMode threadingMode;
    private final Queue<SenderCmd> commandQueue;
    private final AtomicCounter failCount;
    private Sender sender;

    public SenderProxy(final ThreadingMode threadingMode, final Queue<SenderCmd> commandQueue, final AtomicCounter failCount)
    {
        this.threadingMode = threadingMode;
        this.commandQueue = commandQueue;
        this.failCount = failCount;
    }

    public void sender(final Sender sender)
    {
        this.sender = sender;
    }

    public void registerSendChannelEndpoint(final SendChannelEndpoint channelEndpoint)
    {
        if (isSharedThread())
        {
            sender.onRegisterSendChannelEndpoint(channelEndpoint);
        }
        else
        {
            offer(new RegisterSendChannelEndpointCmd(channelEndpoint));
        }
    }

    public void closeSendChannelEndpoint(final SendChannelEndpoint channelEndpoint)
    {
        if (isSharedThread())
        {
            sender.onCloseSendChannelEndpoint(channelEndpoint);
        }
        else
        {
            offer(new CloseSendChannelEndpointCmd(channelEndpoint));
        }
    }

    public void removePublication(final NetworkPublication publication)
    {
        if (isSharedThread())
        {
            sender.onRemovePublication(publication);
        }
        else
        {
            offer(new RemovePublicationCmd(publication));
        }
    }

    public void newPublication(final NetworkPublication publication, final FlowControl flowControl)
    {
        if (isSharedThread())
        {
            sender.onNewPublication(publication, flowControl);
        }
        else
        {
            offer(new NewPublicationCmd(publication, flowControl));
        }
    }

    private boolean isSharedThread()
    {
        return threadingMode == SHARED;
    }

    private void offer(final SenderCmd cmd)
    {
        while (!commandQueue.offer(cmd))
        {
            failCount.orderedIncrement();
            Thread.yield();
        }
    }
}

<code block>

package uk.co.real_logic.aeron.driver.media;

import uk.co.real_logic.aeron.driver.event.EventLogger;
import uk.co.real_logic.aeron.protocol.NakFlyweight;
import uk.co.real_logic.aeron.protocol.StatusMessageFlyweight;
import uk.co.real_logic.aeron.driver.*;
import uk.co.real_logic.agrona.collections.BiInt2ObjectMap;
import uk.co.real_logic.agrona.concurrent.AtomicCounter;
import uk.co.real_logic.agrona.concurrent.UnsafeBuffer;

import java.net.InetSocketAddress;

import static uk.co.real_logic.aeron.logbuffer.FrameDescriptor.frameType;
import static uk.co.real_logic.aeron.protocol.HeaderFlyweight.HDR_TYPE_NAK;
import static uk.co.real_logic.aeron.protocol.HeaderFlyweight.HDR_TYPE_SM;
import static uk.co.real_logic.aeron.protocol.StatusMessageFlyweight.SEND_SETUP_FLAG;


public class SendChannelEndpoint extends UdpChannelTransport
{
    private final NakFlyweight nakMessage = new NakFlyweight();
    private final StatusMessageFlyweight statusMessage = new StatusMessageFlyweight();

    private final BiInt2ObjectMap<NetworkPublication> publicationByStreamAndSessionIdMap = new BiInt2ObjectMap<>();
    private final BiInt2ObjectMap<PublicationAssembly> assemblyByStreamAndSessionIdMap = new BiInt2ObjectMap<>();

    private final AtomicCounter nakMessagesReceived;
    private final AtomicCounter statusMessagesReceived;

    public SendChannelEndpoint(
        final UdpChannel udpChannel,
        final EventLogger logger,
        final LossGenerator lossGenerator,
        final SystemCounters systemCounters)
    {
        super(
            udpChannel,
            udpChannel.remoteControl(),
            udpChannel.localControl(),
            udpChannel.remoteData(),
            lossGenerator,
            logger);

        this.nakMessagesReceived = systemCounters.nakMessagesReceived();
        this.statusMessagesReceived = systemCounters.statusMessagesReceived();

        nakMessage.wrap(receiveBuffer(), 0);
        statusMessage.wrap(receiveBuffer(), 0);
    }

    
    public void openChannel()
    {
        openDatagramChannel();
    }

    public String originalUriString()
    {
        return udpChannel().originalUriString();
    }

    
    public NetworkPublication getPublication(final int sessionId, final int streamId)
    {
        return publicationByStreamAndSessionIdMap.get(sessionId, streamId);
    }

    
    public void addPublication(final NetworkPublication publication)
    {
        publicationByStreamAndSessionIdMap.put(publication.sessionId(), publication.streamId(), publication);
    }

    
    public NetworkPublication removePublication(final NetworkPublication publication)
    {
        return publicationByStreamAndSessionIdMap.remove(publication.sessionId(), publication.streamId());
    }

    
    public int sessionCount()
    {
        return publicationByStreamAndSessionIdMap.size();
    }

    
    public void addToDispatcher(final NetworkPublication publication, final FlowControl flowControl)
    {
        assemblyByStreamAndSessionIdMap.put(
            publication.sessionId(), publication.streamId(),
            new PublicationAssembly(publication, flowControl));
    }

    
    public void removeFromDispatcher(final NetworkPublication publication)
    {
        assemblyByStreamAndSessionIdMap.remove(publication.sessionId(), publication.streamId());
    }

    protected int dispatch(final UnsafeBuffer buffer, final int length, final InetSocketAddress srcAddress)
    {
        int framesRead = 0;
        switch (frameType(buffer, 0))
        {
            case HDR_TYPE_NAK:
                onNakMessage(nakMessage);
                framesRead = 1;
                break;

            case HDR_TYPE_SM:
                onStatusMessage(statusMessage, srcAddress);
                framesRead = 1;
                break;
        }

        return framesRead;
    }

    private void onStatusMessage(final StatusMessageFlyweight statusMsg, final InetSocketAddress srcAddress)
    {
        final PublicationAssembly assembly = assemblyByStreamAndSessionIdMap.get(statusMsg.sessionId(), statusMsg.streamId());

        if (null != assembly)
        {
            if (SEND_SETUP_FLAG == (statusMsg.flags() & SEND_SETUP_FLAG))
            {
                assembly.publication.triggerSendSetupFrame();
            }
            else
            {
                final long positionLimit = assembly.flowControl.onStatusMessage(
                    statusMsg.consumptionTermId(),
                    statusMsg.consumptionTermOffset(),
                    statusMsg.receiverWindowLength(),
                    srcAddress);

                assembly.publication.senderPositionLimit(positionLimit);
            }

            statusMessagesReceived.orderedIncrement();
        }
    }

    private void onNakMessage(final NakFlyweight nakMessage)
    {
        final PublicationAssembly assembly = assemblyByStreamAndSessionIdMap.get(nakMessage.sessionId(), nakMessage.streamId());

        if (null != assembly)
        {
            assembly.publication.onNak(nakMessage.termId(), nakMessage.termOffset(), nakMessage.length());
            nakMessagesReceived.orderedIncrement();
        }
    }

    static final class PublicationAssembly
    {
        final NetworkPublication publication;
        final FlowControl flowControl;

        public PublicationAssembly(final NetworkPublication publication, final FlowControl flowControl)
        {
            this.publication = publication;
            this.flowControl = flowControl;
        }
    }
}

<code block>

package uk.co.real_logic.aeron.driver.cmd;

import uk.co.real_logic.aeron.driver.FlowControl;
import uk.co.real_logic.aeron.driver.NetworkPublication;
import uk.co.real_logic.aeron.driver.Sender;

public class NewPublicationCmd implements SenderCmd
{
    private final NetworkPublication publication;
    private final FlowControl flowControl;

    public NewPublicationCmd(final NetworkPublication publication, final FlowControl flowControl)
    {
        this.publication = publication;
        this.flowControl = flowControl;
    }

    public void execute(final Sender sender)
    {
        sender.onNewPublication(publication, flowControl);
    }
}

<code block>

package uk.co.real_logic.aeron.driver;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.mockito.stubbing.Answer;
import uk.co.real_logic.aeron.driver.buffer.RawLog;
import uk.co.real_logic.aeron.driver.cmd.NewPublicationCmd;
import uk.co.real_logic.aeron.driver.cmd.SenderCmd;
import uk.co.real_logic.aeron.driver.event.EventLogger;
import uk.co.real_logic.aeron.driver.media.SendChannelEndpoint;
import uk.co.real_logic.aeron.driver.media.TransportPoller;
import uk.co.real_logic.aeron.driver.media.UdpChannel;
import uk.co.real_logic.aeron.logbuffer.LogBufferDescriptor;
import uk.co.real_logic.aeron.logbuffer.TermAppender;
import uk.co.real_logic.aeron.protocol.DataHeaderFlyweight;
import uk.co.real_logic.aeron.protocol.HeaderFlyweight;
import uk.co.real_logic.aeron.protocol.SetupFlyweight;
import uk.co.real_logic.agrona.MutableDirectBuffer;
import uk.co.real_logic.agrona.concurrent.AtomicCounter;
import uk.co.real_logic.agrona.concurrent.OneToOneConcurrentArrayQueue;
import uk.co.real_logic.agrona.concurrent.UnsafeBuffer;
import uk.co.real_logic.agrona.concurrent.status.AtomicLongPosition;
import uk.co.real_logic.agrona.concurrent.status.Position;

import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.util.ArrayDeque;
import java.util.Queue;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.greaterThanOrEqualTo;
import static org.hamcrest.core.Is.is;
import static org.mockito.Mockito.*;
import static uk.co.real_logic.aeron.logbuffer.FrameDescriptor.FRAME_ALIGNMENT;
import static uk.co.real_logic.agrona.BitUtil.align;

public class SenderTest
{
    private static final int TERM_BUFFER_LENGTH = LogBufferDescriptor.TERM_MIN_LENGTH;
    private static final int MAX_FRAME_LENGTH = 1024;
    private static final int SESSION_ID = 1;
    private static final int STREAM_ID = 2;
    private static final int INITIAL_TERM_ID = 3;
    private static final byte[] PAYLOAD = "Payload is here!".getBytes();

    private static final MutableDirectBuffer HEADER =
        DataHeaderFlyweight.createDefaultHeader(SESSION_ID, STREAM_ID, INITIAL_TERM_ID);
    private static final int ALIGNED_FRAME_LENGTH = align(HEADER.capacity() + PAYLOAD.length, FRAME_ALIGNMENT);

    private final EventLogger mockLogger = mock(EventLogger.class);
    private final TransportPoller mockTransportPoller = mock(TransportPoller.class);

    private final RawLog rawLog =
        LogBufferHelper.newTestLogBuffers(TERM_BUFFER_LENGTH, LogBufferDescriptor.TERM_META_DATA_LENGTH);

    private TermAppender[] termAppenders;
    private NetworkPublication publication;
    private Sender sender;

    private final FlowControl flowControl = spy(new UnicastFlowControl());
    private final RetransmitHandler mockRetransmitHandler = mock(RetransmitHandler.class);

    private long currentTimestamp = 0;

    private final Queue<ByteBuffer> receivedFrames = new ArrayDeque<>();

    private final UdpChannel udpChannel = UdpChannel.parse("udp:
    private final InetSocketAddress rcvAddress = udpChannel.remoteData();
    private final DataHeaderFlyweight dataHeader = new DataHeaderFlyweight();
    private final SetupFlyweight setupHeader = new SetupFlyweight();
    private final SystemCounters mockSystemCounters = mock(SystemCounters.class);
    private final OneToOneConcurrentArrayQueue<SenderCmd> senderCommandQueue = new OneToOneConcurrentArrayQueue<>(1024);

    private Answer<Integer> saveByteBufferAnswer =
        (invocation) ->
        {
            final Object args[] = invocation.getArguments();
            final ByteBuffer buffer = (ByteBuffer)args[0];

            final int length = buffer.limit() - buffer.position();
            receivedFrames.add(ByteBuffer.allocateDirect(length).put(buffer));

            
            return length;
        };

    @Before
    public void setUp() throws Exception
    {
        final SendChannelEndpoint mockSendChannelEndpoint = mock(SendChannelEndpoint.class);
        when(mockSendChannelEndpoint.udpChannel()).thenReturn(udpChannel);
        when(mockSendChannelEndpoint.send(anyObject())).thenAnswer(saveByteBufferAnswer);
        when(mockSystemCounters.heartbeatsSent()).thenReturn(mock(AtomicCounter.class));
        when(mockSystemCounters.bytesSent()).thenReturn(mock(AtomicCounter.class));
        when(mockSystemCounters.senderFlowControlLimits()).thenReturn(mock(AtomicCounter.class));

        sender = new Sender(
            new MediaDriver.Context()
                .senderNioSelector(mockTransportPoller)
                .systemCounters(mockSystemCounters)
                .senderCommandQueue(senderCommandQueue)
                .eventLogger(mockLogger)
                .nanoClock(() -> currentTimestamp));

        termAppenders = rawLog
            .stream()
            .map((log) -> new TermAppender(log.termBuffer(), log.metaDataBuffer(), HEADER, MAX_FRAME_LENGTH))
            .toArray(TermAppender[]::new);

        publication = new NetworkPublication(
            mockSendChannelEndpoint,
            () -> currentTimestamp,
            rawLog,
            new AtomicLongPosition(),
            mock(Position.class),
            SESSION_ID,
            STREAM_ID,
            INITIAL_TERM_ID,
            MAX_FRAME_LENGTH,
            flowControl.initialPositionLimit(INITIAL_TERM_ID, TERM_BUFFER_LENGTH),
            mockSystemCounters,
            mockRetransmitHandler);

        senderCommandQueue.offer(new NewPublicationCmd(publication, flowControl));
    }

    @After
    public void tearDown() throws Exception
    {
        sender.onClose();
    }

    @Test
    public void shouldSendSetupFrameOnChannelWhenTimeoutWithoutStatusMessage() throws Exception
    {
        currentTimestamp += Configuration.PUBLICATION_SETUP_TIMEOUT_NS - 1;
        sender.doWork();
        assertThat(receivedFrames.size(), is(0));
        currentTimestamp += 10;
        sender.doWork();
        assertThat(receivedFrames.size(), is(1));

        setupHeader.wrap(receivedFrames.remove(), 0);
        assertThat(setupHeader.frameLength(), is(SetupFlyweight.HEADER_LENGTH));
        assertThat(setupHeader.initialTermId(), is(INITIAL_TERM_ID));
        assertThat(setupHeader.activeTermId(), is(INITIAL_TERM_ID));
        assertThat(setupHeader.streamId(), is(STREAM_ID));
        assertThat(setupHeader.sessionId(), is(SESSION_ID));
        assertThat(setupHeader.headerType(), is(HeaderFlyweight.HDR_TYPE_SETUP));
        assertThat(setupHeader.flags(), is((short)0));
        assertThat(setupHeader.version(), is((short)HeaderFlyweight.CURRENT_VERSION));
    }

    @Test
    public void shouldSendMultipleSetupFramesOnChannelWhenTimeoutWithoutStatusMessage() throws Exception
    {
        currentTimestamp += Configuration.PUBLICATION_SETUP_TIMEOUT_NS - 1;
        sender.doWork();
        assertThat(receivedFrames.size(), is(0));
        currentTimestamp += 10;
        sender.doWork();
        assertThat(receivedFrames.size(), is(1));

        currentTimestamp += Configuration.PUBLICATION_SETUP_TIMEOUT_NS - 1;
        sender.doWork();
        currentTimestamp += 10;
        sender.doWork();

        assertThat(receivedFrames.size(), is(2));
    }

    @Test
    public void shouldNotSendSetupFrameAfterReceivingStatusMessage() throws Exception
    {
        currentTimestamp += Configuration.PUBLICATION_SETUP_TIMEOUT_NS - 1;

        publication.senderPositionLimit(flowControl.onStatusMessage(INITIAL_TERM_ID, 0, 0, rcvAddress));
        sender.doWork();

        assertThat(receivedFrames.size(), is(0));
    }

    @Test
    public void shouldBeAbleToSendOnChannel() throws Exception
    {
        publication.senderPositionLimit(
            flowControl.onStatusMessage(INITIAL_TERM_ID, 0, ALIGNED_FRAME_LENGTH, rcvAddress));

        final UnsafeBuffer buffer = new UnsafeBuffer(ByteBuffer.allocateDirect(PAYLOAD.length));
        buffer.putBytes(0, PAYLOAD);

        termAppenders[0].append(buffer, 0, PAYLOAD.length);
        sender.doWork();

        assertThat(receivedFrames.size(), is(1));

        dataHeader.wrap(receivedFrames.remove(), 0);

        assertThat(dataHeader.frameLength(), is(ALIGNED_FRAME_LENGTH));
        assertThat(dataHeader.termId(), is(INITIAL_TERM_ID));
        assertThat(dataHeader.streamId(), is(STREAM_ID));
        assertThat(dataHeader.sessionId(), is(SESSION_ID));
        assertThat(dataHeader.termOffset(), is(offsetOfMessage(1)));
        assertThat(dataHeader.headerType(), is(HeaderFlyweight.HDR_TYPE_DATA));
        assertThat(dataHeader.flags(), is(DataHeaderFlyweight.BEGIN_AND_END_FLAGS));
        assertThat(dataHeader.version(), is((short)HeaderFlyweight.CURRENT_VERSION));
    }

    @Test
    public void shouldBeAbleToSendOnChannelTwice() throws Exception
    {
        publication.senderPositionLimit(
            flowControl.onStatusMessage(INITIAL_TERM_ID, 0, (2 * ALIGNED_FRAME_LENGTH), rcvAddress));

        final UnsafeBuffer buffer = new UnsafeBuffer(ByteBuffer.allocateDirect(PAYLOAD.length));
        buffer.putBytes(0, PAYLOAD);

        termAppenders[0].append(buffer, 0, PAYLOAD.length);
        sender.doWork();
        termAppenders[0].append(buffer, 0, PAYLOAD.length);
        sender.doWork();

        assertThat(receivedFrames.size(), is(2));

        dataHeader.wrap(receivedFrames.remove(), 0);

        assertThat(dataHeader.frameLength(), is(ALIGNED_FRAME_LENGTH));
        assertThat(dataHeader.termId(), is(INITIAL_TERM_ID));
        assertThat(dataHeader.streamId(), is(STREAM_ID));
        assertThat(dataHeader.sessionId(), is(SESSION_ID));
        assertThat(dataHeader.termOffset(), is(offsetOfMessage(1)));
        assertThat(dataHeader.headerType(), is(HeaderFlyweight.HDR_TYPE_DATA));
        assertThat(dataHeader.flags(), is(DataHeaderFlyweight.BEGIN_AND_END_FLAGS));
        assertThat(dataHeader.version(), is((short)HeaderFlyweight.CURRENT_VERSION));

        dataHeader.wrap(receivedFrames.remove(), 0);
        assertThat(dataHeader.frameLength(), is(ALIGNED_FRAME_LENGTH));
        assertThat(dataHeader.termId(), is(INITIAL_TERM_ID));
        assertThat(dataHeader.streamId(), is(STREAM_ID));
        assertThat(dataHeader.sessionId(), is(SESSION_ID));
        assertThat(dataHeader.termOffset(), is(offsetOfMessage(2)));
        assertThat(dataHeader.headerType(), is(HeaderFlyweight.HDR_TYPE_DATA));
        assertThat(dataHeader.flags(), is(DataHeaderFlyweight.BEGIN_AND_END_FLAGS));
        assertThat(dataHeader.version(), is((short)HeaderFlyweight.CURRENT_VERSION));
    }

    @Test
    public void shouldBeAbleToSendOnChannelTwiceAsBatch() throws Exception
    {
        publication.senderPositionLimit(
            flowControl.onStatusMessage(INITIAL_TERM_ID, 0, (2 * ALIGNED_FRAME_LENGTH), rcvAddress));

        final UnsafeBuffer buffer = new UnsafeBuffer(ByteBuffer.allocateDirect(PAYLOAD.length));
        buffer.putBytes(0, PAYLOAD);

        termAppenders[0].append(buffer, 0, PAYLOAD.length);
        termAppenders[0].append(buffer, 0, PAYLOAD.length);
        sender.doWork();

        assertThat(receivedFrames.size(), is(1));
        final ByteBuffer frame = receivedFrames.remove();

        dataHeader.wrap(frame, 0);
        assertThat(dataHeader.frameLength(), is(ALIGNED_FRAME_LENGTH));
        assertThat(dataHeader.termId(), is(INITIAL_TERM_ID));
        assertThat(dataHeader.streamId(), is(STREAM_ID));
        assertThat(dataHeader.sessionId(), is(SESSION_ID));
        assertThat(dataHeader.termOffset(), is(offsetOfMessage(1)));
        assertThat(dataHeader.headerType(), is(HeaderFlyweight.HDR_TYPE_DATA));
        assertThat(dataHeader.flags(), is(DataHeaderFlyweight.BEGIN_AND_END_FLAGS));
        assertThat(dataHeader.version(), is((short)HeaderFlyweight.CURRENT_VERSION));

        dataHeader.wrap(frame, offsetOfMessage(2));
        assertThat(dataHeader.frameLength(), is(ALIGNED_FRAME_LENGTH));
        assertThat(dataHeader.termId(), is(INITIAL_TERM_ID));
        assertThat(dataHeader.streamId(), is(STREAM_ID));
        assertThat(dataHeader.sessionId(), is(SESSION_ID));
        assertThat(dataHeader.termOffset(), is(offsetOfMessage(2)));
        assertThat(dataHeader.headerType(), is(HeaderFlyweight.HDR_TYPE_DATA));
        assertThat(dataHeader.flags(), is(DataHeaderFlyweight.BEGIN_AND_END_FLAGS));
        assertThat(dataHeader.version(), is((short)HeaderFlyweight.CURRENT_VERSION));
    }

    @Test
    public void shouldNotSendUntilStatusMessageReceived() throws Exception
    {
        final UnsafeBuffer buffer = new UnsafeBuffer(ByteBuffer.allocateDirect(PAYLOAD.length));
        buffer.putBytes(0, PAYLOAD);
        termAppenders[0].append(buffer, 0, PAYLOAD.length);

        sender.doWork();
        assertThat(receivedFrames.size(), is(0));

        publication.senderPositionLimit(
            flowControl.onStatusMessage(INITIAL_TERM_ID, 0, ALIGNED_FRAME_LENGTH, rcvAddress));
        sender.doWork();

        assertThat(receivedFrames.size(), is(1));

        dataHeader.wrap(receivedFrames.remove(), 0);

        assertThat(dataHeader.frameLength(), is(ALIGNED_FRAME_LENGTH));
        assertThat(dataHeader.termId(), is(INITIAL_TERM_ID));
        assertThat(dataHeader.streamId(), is(STREAM_ID));
        assertThat(dataHeader.sessionId(), is(SESSION_ID));
        assertThat(dataHeader.termOffset(), is(offsetOfMessage(1)));
        assertThat(dataHeader.headerType(), is(HeaderFlyweight.HDR_TYPE_DATA));
        assertThat(dataHeader.flags(), is(DataHeaderFlyweight.BEGIN_AND_END_FLAGS));
        assertThat(dataHeader.version(), is((short)HeaderFlyweight.CURRENT_VERSION));
    }

    @Test
    public void shouldNotBeAbleToSendAfterUsingUpYourWindow() throws Exception
    {
        final UnsafeBuffer buffer = new UnsafeBuffer(ByteBuffer.allocateDirect(PAYLOAD.length));
        buffer.putBytes(0, PAYLOAD);
        termAppenders[0].append(buffer, 0, PAYLOAD.length);
        publication.senderPositionLimit(
            flowControl.onStatusMessage(INITIAL_TERM_ID, 0, ALIGNED_FRAME_LENGTH, rcvAddress));

        sender.doWork();

        assertThat(receivedFrames.size(), is(1));

        dataHeader.wrap(receivedFrames.remove(), 0);

        assertThat(dataHeader.frameLength(), is(ALIGNED_FRAME_LENGTH));
        assertThat(dataHeader.termId(), is(INITIAL_TERM_ID));
        assertThat(dataHeader.streamId(), is(STREAM_ID));
        assertThat(dataHeader.sessionId(), is(SESSION_ID));
        assertThat(dataHeader.termOffset(), is(offsetOfMessage(1)));
        assertThat(dataHeader.headerType(), is(HeaderFlyweight.HDR_TYPE_DATA));
        assertThat(dataHeader.flags(), is(DataHeaderFlyweight.BEGIN_AND_END_FLAGS));
        assertThat(dataHeader.version(), is((short)HeaderFlyweight.CURRENT_VERSION));

        termAppenders[0].append(buffer, 0, PAYLOAD.length);
        sender.doWork();

        assertThat(receivedFrames.size(), is(0));
    }

    @Test
    public void shouldSendLastDataFrameAsHeartbeatWhenIdle() throws Exception
    {
        publication.senderPositionLimit(
            flowControl.onStatusMessage(INITIAL_TERM_ID, 0, ALIGNED_FRAME_LENGTH, rcvAddress));

        final UnsafeBuffer buffer = new UnsafeBuffer(ByteBuffer.allocateDirect(PAYLOAD.length));
        buffer.putBytes(0, PAYLOAD);

        termAppenders[0].append(buffer, 0, PAYLOAD.length);
        sender.doWork();

        assertThat(receivedFrames.size(), is(1));  
        receivedFrames.remove();                   

        currentTimestamp += Configuration.PUBLICATION_HEARTBEAT_TIMEOUT_NS - 1;
        sender.doWork();

        assertThat(receivedFrames.size(), is(0));  
        currentTimestamp += 10;
        sender.doWork();

        assertThat(receivedFrames.size(), greaterThanOrEqualTo(1));  

        dataHeader.wrap(new UnsafeBuffer(receivedFrames.remove()), 0);
        assertThat(dataHeader.frameLength(), is(0));
        assertThat(dataHeader.termOffset(), is(offsetOfMessage(2)));
    }

    @Test
    public void shouldSendMultipleDataFramesAsHeartbeatsWhenIdle()
    {
        publication.senderPositionLimit(
            flowControl.onStatusMessage(INITIAL_TERM_ID, 0, ALIGNED_FRAME_LENGTH, rcvAddress));

        final UnsafeBuffer buffer = new UnsafeBuffer(ByteBuffer.allocateDirect(PAYLOAD.length));
        buffer.putBytes(0, PAYLOAD);

        termAppenders[0].append(buffer, 0, PAYLOAD.length);
        sender.doWork();

        assertThat(receivedFrames.size(), is(1));  
        receivedFrames.remove();                   

        currentTimestamp += Configuration.PUBLICATION_HEARTBEAT_TIMEOUT_NS - 1;
        sender.doWork();
        assertThat(receivedFrames.size(), is(0));  
        currentTimestamp += 10;
        sender.doWork();
        assertThat(receivedFrames.size(), greaterThanOrEqualTo(1));  

        dataHeader.wrap(new UnsafeBuffer(receivedFrames.remove()), 0);
        assertThat(dataHeader.frameLength(), is(0));
        assertThat(dataHeader.termOffset(), is(offsetOfMessage(2)));

        currentTimestamp += Configuration.PUBLICATION_HEARTBEAT_TIMEOUT_NS - 1;
        sender.doWork();
        assertThat(receivedFrames.size(), is(0));  
        currentTimestamp += 10;
        sender.doWork();
        assertThat(receivedFrames.size(), greaterThanOrEqualTo(1));  

        dataHeader.wrap(new UnsafeBuffer(receivedFrames.remove()), 0);
        assertThat(dataHeader.frameLength(), is(0));
        assertThat(dataHeader.termOffset(), is(offsetOfMessage(2)));
    }

    private int offsetOfMessage(final int offset)
    {
        return (offset - 1) * align(HEADER.capacity() + PAYLOAD.length, FRAME_ALIGNMENT);
    }
}

<code block>

package uk.co.real_logic.aeron.driver;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.InOrder;
import org.mockito.stubbing.Answer;
import uk.co.real_logic.aeron.command.*;
import uk.co.real_logic.aeron.driver.buffer.RawLogFactory;
import uk.co.real_logic.aeron.driver.event.EventConfiguration;
import uk.co.real_logic.aeron.driver.event.EventLogger;
import uk.co.real_logic.aeron.driver.media.ReceiveChannelEndpoint;
import uk.co.real_logic.aeron.driver.media.TransportPoller;
import uk.co.real_logic.aeron.driver.media.UdpChannel;
import uk.co.real_logic.agrona.concurrent.*;
import uk.co.real_logic.agrona.concurrent.ringbuffer.ManyToOneRingBuffer;
import uk.co.real_logic.agrona.concurrent.ringbuffer.RingBuffer;
import uk.co.real_logic.agrona.concurrent.ringbuffer.RingBufferDescriptor;

import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.util.concurrent.TimeUnit;
import java.util.function.BooleanSupplier;

import static org.hamcrest.Matchers.*;
import static org.junit.Assert.*;
import static org.mockito.Mockito.any;
import static org.mockito.Mockito.*;
import static uk.co.real_logic.aeron.ErrorCode.INVALID_CHANNEL;
import static uk.co.real_logic.aeron.ErrorCode.UNKNOWN_PUBLICATION;
import static uk.co.real_logic.aeron.command.ControlProtocolEvents.*;
import static uk.co.real_logic.aeron.driver.Configuration.*;
import static uk.co.real_logic.aeron.logbuffer.LogBufferDescriptor.TERM_META_DATA_LENGTH;
import static uk.co.real_logic.aeron.logbuffer.LogBufferDescriptor.computePosition;

public class DriverConductorTest
{
    private static final String CHANNEL_URI = "udp:
    private static final String INVALID_URI = "udp:
    private static final int SESSION_ID = 100;
    private static final int STREAM_ID_1 = 10;
    private static final int STREAM_ID_2 = 20;
    private static final int STREAM_ID_3 = 30;
    private static final int TERM_BUFFER_LENGTH = Configuration.TERM_BUFFER_LENGTH_DEFAULT;
    private static final long CORRELATION_ID_1 = 1429;
    private static final long CORRELATION_ID_2 = 1430;
    private static final long CORRELATION_ID_3 = 1431;
    private static final long CORRELATION_ID_4 = 1432;
    private static final long CLIENT_ID = 1433;
    private static final int BUFFER_LENGTH = 1024 * 1024;

    private final ByteBuffer toDriverBuffer = ByteBuffer.allocateDirect(Configuration.CONDUCTOR_BUFFER_LENGTH);
    private final ByteBuffer toEventBuffer = ByteBuffer.allocateDirect(
        EventConfiguration.BUFFER_LENGTH_DEFAULT + RingBufferDescriptor.TRAILER_LENGTH);

    private final TransportPoller transportPoller = mock(TransportPoller.class);
    private final RawLogFactory mockRawLogFactory = mock(RawLogFactory.class);

    private final RingBuffer fromClientCommands = new ManyToOneRingBuffer(new UnsafeBuffer(toDriverBuffer));
    private final RingBuffer toEventReader = new ManyToOneRingBuffer(new UnsafeBuffer(toEventBuffer));
    private final ClientProxy mockClientProxy = mock(ClientProxy.class);

    private final PublicationMessageFlyweight publicationMessage = new PublicationMessageFlyweight();
    private final SubscriptionMessageFlyweight subscriptionMessage = new SubscriptionMessageFlyweight();
    private final RemoveMessageFlyweight removeMessage = new RemoveMessageFlyweight();
    private final CorrelatedMessageFlyweight correlatedMessage = new CorrelatedMessageFlyweight();
    private final UnsafeBuffer writeBuffer = new UnsafeBuffer(ByteBuffer.allocateDirect(256));

    private final EventLogger mockConductorLogger = mock(EventLogger.class);

    private final SenderProxy senderProxy = mock(SenderProxy.class);
    private final ReceiverProxy receiverProxy = mock(ReceiverProxy.class);
    private final DriverConductorProxy fromSenderConductorProxy = mock(DriverConductorProxy.class);
    private final DriverConductorProxy fromReceiverConductorProxy = mock(DriverConductorProxy.class);

    private long currentTime;
    private NanoClock nanoClock = () -> currentTime;

    private DriverConductor driverConductor;

    private final Answer<Void> closeChannelEndpointAnswer =
        (invocation) ->
        {
            final Object args[] = invocation.getArguments();
            final ReceiveChannelEndpoint channelEndpoint = (ReceiveChannelEndpoint)args[0];
            channelEndpoint.close();

            return null;
        };

    @Before
    public void setUp() throws Exception
    {
        when(mockRawLogFactory.newPublication(anyObject(), anyInt(), anyInt(), anyInt()))
            .thenReturn(LogBufferHelper.newTestLogBuffers(TERM_BUFFER_LENGTH, TERM_META_DATA_LENGTH));
        when(mockRawLogFactory.newConnection(anyObject(), anyInt(), anyInt(), anyInt(), eq(TERM_BUFFER_LENGTH)))
            .thenReturn(LogBufferHelper.newTestLogBuffers(TERM_BUFFER_LENGTH, TERM_META_DATA_LENGTH));

        currentTime = 0;

        final UnsafeBuffer counterBuffer = new UnsafeBuffer(ByteBuffer.allocateDirect(BUFFER_LENGTH));
        final CountersManager countersManager = new CountersManager(
            new UnsafeBuffer(ByteBuffer.allocateDirect(BUFFER_LENGTH)), counterBuffer);

        final MediaDriver.Context ctx = new MediaDriver.Context()
            .receiverNioSelector(transportPoller)
            .senderNioSelector(transportPoller)
            .unicastSenderFlowControl(UnicastFlowControl::new)
            .multicastSenderFlowControl(MaxMulticastFlowControl::new)
            
            .toConductorFromReceiverCommandQueue(new OneToOneConcurrentArrayQueue<>(1024))
            .toConductorFromSenderCommandQueue(new OneToOneConcurrentArrayQueue<>(1024))
            .eventLogger(mockConductorLogger)
            .rawLogBuffersFactory(mockRawLogFactory)
            .countersManager(countersManager)
            .nanoClock(nanoClock);

        ctx.toEventReader(toEventReader);
        ctx.toDriverCommands(fromClientCommands);
        ctx.clientProxy(mockClientProxy);
        ctx.counterValuesBuffer(counterBuffer);

        final SystemCounters mockSystemCounters = mock(SystemCounters.class);
        ctx.systemCounters(mockSystemCounters);
        when(mockSystemCounters.bytesReceived()).thenReturn(mock(AtomicCounter.class));
        when(mockSystemCounters.clientKeepAlives()).thenReturn(mock(AtomicCounter.class));

        ctx.epochClock(new SystemEpochClock());
        ctx.receiverProxy(receiverProxy);
        ctx.senderProxy(senderProxy);
        ctx.fromReceiverDriverConductorProxy(fromReceiverConductorProxy);
        ctx.fromSenderDriverConductorProxy(fromSenderConductorProxy);

        driverConductor = new DriverConductor(ctx);

        doAnswer(closeChannelEndpointAnswer).when(receiverProxy).closeReceiveChannelEndpoint(any());
    }

    @After
    public void tearDown() throws Exception
    {
        driverConductor.onClose();
    }

    @Test
    public void shouldBeAbleToAddSinglePublication() throws Exception
    {
        writePublicationMessage(ADD_PUBLICATION, 1, 2, 4000, CORRELATION_ID_1);

        driverConductor.doWork();

        verify(senderProxy).registerSendChannelEndpoint(any());
        final ArgumentCaptor<NetworkPublication> captor = ArgumentCaptor.forClass(NetworkPublication.class);
        verify(senderProxy, times(1)).newPublication(captor.capture(), any());

        final NetworkPublication publication = captor.getValue();
        assertThat(publication.sessionId(), is(1));
        assertThat(publication.streamId(), is(2));

        verify(mockClientProxy).onPublicationReady(eq(2), anyInt(), any(), anyLong(), anyInt());
    }

    @Test
    public void shouldBeAbleToAddSingleSubscription() throws Exception
    {
        writeSubscriptionMessage(ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);

        driverConductor.doWork();

        verify(receiverProxy).registerReceiveChannelEndpoint(any());
        verify(receiverProxy).addSubscription(any(), eq(STREAM_ID_1));
        verify(mockClientProxy).operationSucceeded(CORRELATION_ID_1);

        assertNotNull(driverConductor.receiverChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000)));
    }

    @Test
    public void shouldBeAbleToAddAndRemoveSingleSubscription() throws Exception
    {
        writeSubscriptionMessage(ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);
        writeSubscriptionMessage(REMOVE_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);

        driverConductor.doWork();

        assertNull(driverConductor.receiverChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000)));
    }

    @Test
    public void shouldBeAbleToAddMultipleStreams() throws Exception
    {
        writePublicationMessage(ADD_PUBLICATION, 1, 2, 4001, CORRELATION_ID_1);
        writePublicationMessage(ADD_PUBLICATION, 1, 3, 4002, CORRELATION_ID_2);
        writePublicationMessage(ADD_PUBLICATION, 3, 2, 4003, CORRELATION_ID_3);
        writePublicationMessage(ADD_PUBLICATION, 3, 4, 4004, CORRELATION_ID_4);

        driverConductor.doWork();

        verify(senderProxy, times(4)).newPublication(any(), any());
    }

    @Test
    public void shouldBeAbleToRemoveSingleStream() throws Exception
    {
        writePublicationMessage(ADD_PUBLICATION, 1, 2, 4005, CORRELATION_ID_1);
        writePublicationMessage(REMOVE_PUBLICATION, 1, 2, 4005, CORRELATION_ID_1);

        driverConductor.doWork();

        doWorkUntil(() -> nanoClock.nanoTime() >= CLIENT_LIVENESS_TIMEOUT_NS + PUBLICATION_LINGER_NS * 2);

        verify(senderProxy).removePublication(any());
        assertNull(driverConductor.senderChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4005)));
    }

    @Test
    public void shouldBeAbleToRemoveMultipleStreams() throws Exception
    {
        writePublicationMessage(ADD_PUBLICATION, 1, 2, 4006, CORRELATION_ID_1);
        writePublicationMessage(ADD_PUBLICATION, 1, 3, 4007, CORRELATION_ID_2);
        writePublicationMessage(ADD_PUBLICATION, 3, 2, 4008, CORRELATION_ID_3);
        writePublicationMessage(ADD_PUBLICATION, 3, 4, 4008, CORRELATION_ID_4);

        removePublicationMessage(CORRELATION_ID_1);
        removePublicationMessage(CORRELATION_ID_2);
        removePublicationMessage(CORRELATION_ID_3);
        removePublicationMessage(CORRELATION_ID_4);

        driverConductor.doWork();

        doWorkUntil(() -> nanoClock.nanoTime() >= PUBLICATION_LINGER_NS * 2 + CLIENT_LIVENESS_TIMEOUT_NS * 2);

        verify(senderProxy, times(4)).removePublication(any());
    }

    

    private void removePublicationMessage(final long registrationId)
    {
        removeMessage.wrap(writeBuffer, 0);
        removeMessage.registrationId(registrationId);
        assertTrue(fromClientCommands.write(REMOVE_PUBLICATION, writeBuffer, 0, RemoveMessageFlyweight.length()));
    }

    @Test
    public void shouldKeepSubscriptionMediaEndpointUponRemovalOfAllButOneSubscriber() throws Exception
    {
        final UdpChannel udpChannel = UdpChannel.parse(CHANNEL_URI + 4000);

        writeSubscriptionMessage(ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);
        writeSubscriptionMessage(ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_2, CORRELATION_ID_2);
        writeSubscriptionMessage(ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_3, CORRELATION_ID_3);

        driverConductor.doWork();

        final ReceiveChannelEndpoint channelEndpoint = driverConductor.receiverChannelEndpoint(udpChannel);

        assertNotNull(channelEndpoint);
        assertThat(channelEndpoint.streamCount(), is(3));

        writeSubscriptionMessage(REMOVE_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);
        writeSubscriptionMessage(REMOVE_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_2, CORRELATION_ID_2);

        driverConductor.doWork();

        assertNotNull(driverConductor.receiverChannelEndpoint(udpChannel));
        assertThat(channelEndpoint.streamCount(), is(1));
    }

    @Test
    public void shouldOnlyRemoveSubscriptionMediaEndpointUponRemovalOfAllSubscribers() throws Exception
    {
        final UdpChannel udpChannel = UdpChannel.parse(CHANNEL_URI + 4000);

        writeSubscriptionMessage(ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);
        writeSubscriptionMessage(ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_2, CORRELATION_ID_2);
        writeSubscriptionMessage(ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_3, CORRELATION_ID_3);

        driverConductor.doWork();

        final ReceiveChannelEndpoint channelEndpoint = driverConductor.receiverChannelEndpoint(udpChannel);

        assertNotNull(channelEndpoint);
        assertThat(channelEndpoint.streamCount(), is(3));

        writeSubscriptionMessage(REMOVE_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_2, CORRELATION_ID_2);
        writeSubscriptionMessage(REMOVE_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_3, CORRELATION_ID_3);

        driverConductor.doWork();

        assertNotNull(driverConductor.receiverChannelEndpoint(udpChannel));
        assertThat(channelEndpoint.streamCount(), is(1));

        writeSubscriptionMessage(REMOVE_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);

        driverConductor.doWork();

        assertNull(driverConductor.receiverChannelEndpoint(udpChannel));
    }

    @Test
    public void shouldErrorOnRemoveChannelOnUnknownSessionId() throws Exception
    {
        writePublicationMessage(ADD_PUBLICATION, 1, 2, 4000, CORRELATION_ID_1);
        writePublicationMessage(REMOVE_PUBLICATION, 2, 2, 4000, CORRELATION_ID_1);

        driverConductor.doWork();

        verify(senderProxy).newPublication(any(), any());
        verify(mockClientProxy).onError(eq(UNKNOWN_PUBLICATION), argThat(not(isEmptyOrNullString())), any());
        verify(mockClientProxy, never()).operationSucceeded(anyLong());
        verify(mockConductorLogger).logException(any());
    }

    @Test
    public void shouldErrorOnRemoveChannelOnUnknownStreamId() throws Exception
    {
        writePublicationMessage(ADD_PUBLICATION, 1, 2, 4000, CORRELATION_ID_1);
        writePublicationMessage(REMOVE_PUBLICATION, 1, 3, 4000, CORRELATION_ID_1);

        driverConductor.doWork();

        verify(senderProxy).newPublication(any(), any());
        verify(senderProxy, never()).removePublication(any());
        verify(mockClientProxy).onError(eq(UNKNOWN_PUBLICATION), argThat(not(isEmptyOrNullString())), any());
        verify(mockClientProxy, never()).operationSucceeded(anyLong());
        verify(mockConductorLogger).logException(any());
    }

    @Test
    public void shouldErrorOnAddSubscriptionWithInvalidUri() throws Exception
    {
        writeSubscriptionMessage(ADD_SUBSCRIPTION, INVALID_URI, STREAM_ID_1, CORRELATION_ID_1);

        driverConductor.doWork();
        driverConductor.doWork();

        verify(senderProxy, never()).newPublication(any(), any());

        verify(mockClientProxy).onError(eq(INVALID_CHANNEL), argThat(not(isEmptyOrNullString())), any());
        verify(mockClientProxy, never()).operationSucceeded(anyLong());
        verify(mockConductorLogger).logException(any());
    }

    @Test
    public void shouldTimeoutPublication() throws Exception
    {
        writePublicationMessage(ADD_PUBLICATION, 1, 2, 4000, CORRELATION_ID_1);

        driverConductor.doWork();

        final ArgumentCaptor<NetworkPublication> captor = ArgumentCaptor.forClass(NetworkPublication.class);
        verify(senderProxy, times(1)).newPublication(captor.capture(), any());

        final NetworkPublication publication = captor.getValue();

        doWorkUntil(() -> nanoClock.nanoTime() >= PUBLICATION_LINGER_NS + CLIENT_LIVENESS_TIMEOUT_NS * 2);

        verify(senderProxy).removePublication(eq(publication));
        assertNull(driverConductor.senderChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000)));
    }

    @Test
    public void shouldNotTimeoutPublicationOnKeepAlive() throws Exception
    {
        writePublicationMessage(ADD_PUBLICATION, 1, 2, 4000, CORRELATION_ID_1);

        driverConductor.doWork();

        final ArgumentCaptor<NetworkPublication> captor = ArgumentCaptor.forClass(NetworkPublication.class);
        verify(senderProxy, times(1)).newPublication(captor.capture(), any());

        final NetworkPublication publication = captor.getValue();

        doWorkUntil(() -> nanoClock.nanoTime() >= CLIENT_LIVENESS_TIMEOUT_NS / 2);

        writeKeepaliveClientMessage();

        doWorkUntil(() -> nanoClock.nanoTime() >= CLIENT_LIVENESS_TIMEOUT_NS + 1000);

        writeKeepaliveClientMessage();

        doWorkUntil(() -> nanoClock.nanoTime() >= CLIENT_LIVENESS_TIMEOUT_NS * 2);

        verify(senderProxy, never()).removePublication(eq(publication));
    }

    @Test
    public void shouldTimeoutSubscription() throws Exception
    {
        writeSubscriptionMessage(ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);

        driverConductor.doWork();

        final ReceiveChannelEndpoint receiveChannelEndpoint =
            driverConductor.receiverChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000));
        assertNotNull(receiveChannelEndpoint);

        verify(receiverProxy).addSubscription(eq(receiveChannelEndpoint), eq(STREAM_ID_1));

        doWorkUntil(() -> nanoClock.nanoTime() >= CLIENT_LIVENESS_TIMEOUT_NS * 2);

        verify(receiverProxy, times(1)).removeSubscription(eq(receiveChannelEndpoint), eq(STREAM_ID_1));

        assertNull(driverConductor.receiverChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000)));
    }

    @Test
    public void shouldNotTimeoutSubscriptionOnKeepAlive() throws Exception
    {
        writeSubscriptionMessage(ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);

        driverConductor.doWork();

        final ReceiveChannelEndpoint receiveChannelEndpoint =
            driverConductor.receiverChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000));
        assertNotNull(receiveChannelEndpoint);

        verify(receiverProxy).addSubscription(eq(receiveChannelEndpoint), eq(STREAM_ID_1));

        doWorkUntil(() -> nanoClock.nanoTime() >= CLIENT_LIVENESS_TIMEOUT_NS);

        writeKeepaliveClientMessage();

        doWorkUntil(() -> nanoClock.nanoTime() >= CLIENT_LIVENESS_TIMEOUT_NS + 1000);

        writeKeepaliveClientMessage();

        doWorkUntil(() -> nanoClock.nanoTime() >= CLIENT_LIVENESS_TIMEOUT_NS * 2);

        verify(receiverProxy, never()).removeSubscription(any(), anyInt());
        assertNotNull(driverConductor.receiverChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000)));
    }

    @Test
    public void shouldCreateConnectionOnSubscription() throws Exception
    {
        final InetSocketAddress sourceAddress = new InetSocketAddress("localhost", 4400);
        final int initialTermId = 1;
        final int activeTermId = 2;
        final int termOffset = 100;

        writeSubscriptionMessage(ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);

        driverConductor.doWork();

        final ReceiveChannelEndpoint receiveChannelEndpoint =
            driverConductor.receiverChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000));
        assertNotNull(receiveChannelEndpoint);

        receiveChannelEndpoint.openChannel();

        driverConductor.onCreateConnection(
            SESSION_ID, STREAM_ID_1, initialTermId, activeTermId, termOffset, TERM_BUFFER_LENGTH, MTU_LENGTH,
            mock(InetSocketAddress.class), sourceAddress, receiveChannelEndpoint);

        final ArgumentCaptor<NetworkConnection> captor = ArgumentCaptor.forClass(NetworkConnection.class);
        verify(receiverProxy).newConnection(eq(receiveChannelEndpoint), captor.capture());

        final NetworkConnection networkConnection = captor.getValue();
        assertThat(networkConnection.sessionId(), is(SESSION_ID));
        assertThat(networkConnection.streamId(), is(STREAM_ID_1));

        final long position =
            computePosition(activeTermId, termOffset, Integer.numberOfTrailingZeros(TERM_BUFFER_LENGTH), initialTermId);
        verify(mockClientProxy).onConnectionReady(
            eq(STREAM_ID_1), eq(SESSION_ID), eq(position), anyObject(), anyLong(), anyObject(), anyString());
    }

    @Test
    public void shouldNotCreateConnectionOnUnknownSubscription() throws Exception
    {
        final InetSocketAddress sourceAddress = new InetSocketAddress("localhost", 4400);

        writeSubscriptionMessage(ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);

        driverConductor.doWork();

        final ReceiveChannelEndpoint receiveChannelEndpoint =
            driverConductor.receiverChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000));
        assertNotNull(receiveChannelEndpoint);

        receiveChannelEndpoint.openChannel();

        driverConductor.onCreateConnection(
            SESSION_ID, STREAM_ID_2, 1, 1, 0, TERM_BUFFER_LENGTH, MTU_LENGTH,
            mock(InetSocketAddress.class), sourceAddress, receiveChannelEndpoint);

        verify(receiverProxy, never()).newConnection(any(), any());
        verify(mockClientProxy, never()).onConnectionReady(
            anyInt(), anyInt(), anyLong(), anyObject(), anyLong(), anyObject(), anyString());
    }

    @Test
    public void shouldSignalInactiveConnectionWhenConnectionTimesout() throws Exception
    {
        final InetSocketAddress sourceAddress = new InetSocketAddress("localhost", 4400);

        writeSubscriptionMessage(ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);

        driverConductor.doWork();

        final ReceiveChannelEndpoint receiveChannelEndpoint =
            driverConductor.receiverChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000));
        assertNotNull(receiveChannelEndpoint);

        receiveChannelEndpoint.openChannel();

        driverConductor.onCreateConnection(
            SESSION_ID, STREAM_ID_1, 1, 1, 0, TERM_BUFFER_LENGTH, MTU_LENGTH,
            mock(InetSocketAddress.class), sourceAddress, receiveChannelEndpoint);

        final ArgumentCaptor<NetworkConnection> captor = ArgumentCaptor.forClass(NetworkConnection.class);
        verify(receiverProxy).newConnection(eq(receiveChannelEndpoint), captor.capture());

        final NetworkConnection networkConnection = captor.getValue();

        networkConnection.status(NetworkConnection.Status.INACTIVE);

        doWorkUntil(() -> nanoClock.nanoTime() >= CONNECTION_LIVENESS_TIMEOUT_NS + 1000);

        verify(mockClientProxy).onInactiveConnection(
            eq(networkConnection.correlationId()), eq(SESSION_ID), eq(STREAM_ID_1), eq(0L), anyString());
    }

    @Test
    public void shouldAlwaysGiveNetworkConnectionCorrelationIdToClientCallbacks() throws Exception
    {
        final InetSocketAddress sourceAddress = new InetSocketAddress("localhost", 4400);

        writeSubscriptionMessage(
            ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, fromClientCommands.nextCorrelationId());

        driverConductor.doWork();

        final ReceiveChannelEndpoint receiveChannelEndpoint =
            driverConductor.receiverChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000));
        assertNotNull(receiveChannelEndpoint);

        receiveChannelEndpoint.openChannel();

        driverConductor.onCreateConnection(
            SESSION_ID, STREAM_ID_1, 1, 1, 0, TERM_BUFFER_LENGTH, MTU_LENGTH,
            mock(InetSocketAddress.class), sourceAddress, receiveChannelEndpoint);

        final ArgumentCaptor<NetworkConnection> captor = ArgumentCaptor.forClass(NetworkConnection.class);
        verify(receiverProxy).newConnection(eq(receiveChannelEndpoint), captor.capture());

        final NetworkConnection networkConnection = captor.getValue();

        networkConnection.status(NetworkConnection.Status.ACTIVE);

        writeSubscriptionMessage(
            ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, fromClientCommands.nextCorrelationId());

        driverConductor.doWork();

        networkConnection.status(NetworkConnection.Status.INACTIVE);

        doWorkUntil(() -> nanoClock.nanoTime() >= CONNECTION_LIVENESS_TIMEOUT_NS + 1000);

        final InOrder inOrder = inOrder(mockClientProxy);
        inOrder.verify(mockClientProxy, times(2)).onConnectionReady(
            eq(STREAM_ID_1), eq(SESSION_ID), eq(0L), anyObject(),
            eq(networkConnection.correlationId()), anyObject(), anyString());
        inOrder.verify(mockClientProxy, times(1)).onInactiveConnection(
            eq(networkConnection.correlationId()), eq(SESSION_ID), eq(STREAM_ID_1), eq(0L), anyString());
    }

    private void writePublicationMessage(
        final int msgTypeId, final int sessionId, final int streamId, final int port, final long correlationId)
    {
        publicationMessage.wrap(writeBuffer, 0);
        publicationMessage.streamId(streamId);
        publicationMessage.sessionId(sessionId);
        publicationMessage.channel(CHANNEL_URI + port);
        publicationMessage.clientId(CLIENT_ID);
        publicationMessage.correlationId(correlationId);

        fromClientCommands.write(msgTypeId, writeBuffer, 0, publicationMessage.length());
    }

    private void writeSubscriptionMessage(
        final int msgTypeId, final String channel, final int streamId, final long registrationCorrelationId)
    {
        subscriptionMessage.wrap(writeBuffer, 0);
        subscriptionMessage.streamId(streamId)
                           .channel(channel)
                           .registrationCorrelationId(registrationCorrelationId)
                           .correlationId(registrationCorrelationId)
                           .clientId(CLIENT_ID);

        fromClientCommands.write(msgTypeId, writeBuffer, 0, subscriptionMessage.length());
    }

    private void writeKeepaliveClientMessage()
    {
        correlatedMessage.wrap(writeBuffer, 0);
        correlatedMessage.clientId(CLIENT_ID);
        correlatedMessage.correlationId(0);

        fromClientCommands.write(ControlProtocolEvents.CLIENT_KEEPALIVE, writeBuffer, 0, CorrelatedMessageFlyweight.LENGTH);
    }

    private long doWorkUntil(final BooleanSupplier condition) throws Exception
    {
        final long startTime = currentTime;

        while (!condition.getAsBoolean())
        {
            currentTime += TimeUnit.MILLISECONDS.toNanos(10);
            driverConductor.doWork();
        }

        return currentTime - startTime;
    }
}

<code block>

package uk.co.real_logic.aeron.driver;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import uk.co.real_logic.aeron.driver.media.*;
import uk.co.real_logic.aeron.logbuffer.FrameDescriptor;
import uk.co.real_logic.aeron.driver.event.EventLogger;
import uk.co.real_logic.aeron.protocol.DataHeaderFlyweight;
import uk.co.real_logic.aeron.protocol.HeaderFlyweight;
import uk.co.real_logic.aeron.protocol.StatusMessageFlyweight;
import uk.co.real_logic.agrona.BitUtil;
import uk.co.real_logic.agrona.concurrent.AtomicCounter;
import uk.co.real_logic.agrona.concurrent.UnsafeBuffer;

import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.util.concurrent.atomic.AtomicInteger;

import static org.hamcrest.core.Is.is;
import static org.junit.Assert.assertThat;
import static org.mockito.Mockito.*;

public class SelectorAndTransportTest
{
    private static final int RCV_PORT = 40123;
    private static final int SRC_PORT = 40124;
    private static final int SESSION_ID = 0xdeadbeef;
    private static final int STREAM_ID = 0x44332211;
    private static final int TERM_ID = 0x99887766;
    private static final int FRAME_LENGTH = 24;

    private static final UdpChannel SRC_DST = UdpChannel.parse("udp:
    private static final UdpChannel RCV_DST = UdpChannel.parse("udp:

    private static final LossGenerator NO_LOSS = (address, header, length) -> false;

    private final ByteBuffer byteBuffer = ByteBuffer.allocateDirect(256);
    private final UnsafeBuffer buffer = new UnsafeBuffer(byteBuffer);

    private final DataHeaderFlyweight encodeDataHeader = new DataHeaderFlyweight();
    private final StatusMessageFlyweight statusMessage = new StatusMessageFlyweight();

    private final InetSocketAddress rcvRemoteAddress = new InetSocketAddress("localhost", SRC_PORT);
    private final InetSocketAddress srcRemoteAddress = new InetSocketAddress("localhost", RCV_PORT);

    private final EventLogger mockTransportLogger = mock(EventLogger.class);
    private final SystemCounters mockSystemCounters = mock(SystemCounters.class);
    private final AtomicCounter mockStatusMessagesReceivedCounter = mock(AtomicCounter.class);

    private final DataPacketDispatcher mockDispatcher = mock(DataPacketDispatcher.class);
    private final NetworkPublication mockPublication = mock(NetworkPublication.class);
    private final FlowControl mockFlowControl = mock(FlowControl.class);

    private TransportPoller transportPoller;
    private SendChannelEndpoint sendChannelEndpoint;
    private ReceiveChannelEndpoint receiveChannelEndpoint;

    @Before
    public void setup()
    {
        when(mockSystemCounters.statusMessagesReceived()).thenReturn(mockStatusMessagesReceivedCounter);
        when(mockPublication.streamId()).thenReturn(STREAM_ID);
        when(mockPublication.sessionId()).thenReturn(SESSION_ID);
    }

    @After
    public void tearDown()
    {
        try
        {
            if (null != sendChannelEndpoint)
            {
                sendChannelEndpoint.close();
                processLoop(transportPoller, 5);
            }

            if (null != receiveChannelEndpoint)
            {
                receiveChannelEndpoint.close();
                processLoop(transportPoller, 5);
            }

            if (null != transportPoller)
            {
                transportPoller.close();
            }
        }
        catch (final Exception ex)
        {
            ex.printStackTrace();
        }
    }

    @Test(timeout = 1000)
    public void shouldHandleBasicSetupAndTearDown() throws Exception
    {
        transportPoller = new TransportPoller();
        receiveChannelEndpoint = new ReceiveChannelEndpoint(
            RCV_DST, mockDispatcher, mockTransportLogger, mockSystemCounters, NO_LOSS);
        sendChannelEndpoint = new SendChannelEndpoint(SRC_DST, mockTransportLogger, NO_LOSS, mockSystemCounters);

        receiveChannelEndpoint.openDatagramChannel();
        receiveChannelEndpoint.registerForRead(transportPoller);
        sendChannelEndpoint.openDatagramChannel();
        sendChannelEndpoint.registerForRead(transportPoller);

        processLoop(transportPoller, 5);
    }

    @Test(timeout = 1000)
    public void shouldSendEmptyDataFrameUnicastFromSourceToReceiver() throws Exception
    {
        final AtomicInteger dataHeadersReceived = new AtomicInteger(0);

        doAnswer(
            (invocation) ->
            {
                dataHeadersReceived.incrementAndGet();
                return null;
            })
            .when(mockDispatcher).onDataPacket(
                any(ReceiveChannelEndpoint.class),
                any(DataHeaderFlyweight.class),
                any(UnsafeBuffer.class),
                anyInt(),
                any(InetSocketAddress.class));

        transportPoller = new TransportPoller();
        receiveChannelEndpoint = new ReceiveChannelEndpoint(
            RCV_DST, mockDispatcher, mockTransportLogger, mockSystemCounters, NO_LOSS);
        sendChannelEndpoint = new SendChannelEndpoint(SRC_DST, mockTransportLogger, NO_LOSS, mockSystemCounters);

        receiveChannelEndpoint.openDatagramChannel();
        receiveChannelEndpoint.registerForRead(transportPoller);
        sendChannelEndpoint.openDatagramChannel();
        sendChannelEndpoint.registerForRead(transportPoller);

        encodeDataHeader.wrap(buffer, 0);
        encodeDataHeader
            .version(HeaderFlyweight.CURRENT_VERSION)
            .flags(DataHeaderFlyweight.BEGIN_AND_END_FLAGS)
            .headerType(HeaderFlyweight.HDR_TYPE_DATA)
            .frameLength(FRAME_LENGTH);
        encodeDataHeader
            .sessionId(SESSION_ID)
            .streamId(STREAM_ID)
            .termId(TERM_ID);
        byteBuffer.position(0).limit(FRAME_LENGTH);

        processLoop(transportPoller, 5);
        sendChannelEndpoint.sendTo(byteBuffer, srcRemoteAddress);
        while (dataHeadersReceived.get() < 1)
        {
            processLoop(transportPoller, 1);
        }

        assertThat(dataHeadersReceived.get(), is(1));
    }

    @Test(timeout = 1000)
    public void shouldSendMultipleDataFramesPerDatagramUnicastFromSourceToReceiver() throws Exception
    {
        final AtomicInteger dataHeadersReceived = new AtomicInteger(0);

        doAnswer(
            (invocation) ->
            {
                dataHeadersReceived.incrementAndGet();
                return null;
            })
            .when(mockDispatcher).onDataPacket(
                any(ReceiveChannelEndpoint.class),
                any(DataHeaderFlyweight.class),
                any(UnsafeBuffer.class),
                anyInt(),
                any(InetSocketAddress.class));

        transportPoller = new TransportPoller();
        receiveChannelEndpoint = new ReceiveChannelEndpoint(
            RCV_DST, mockDispatcher, mockTransportLogger, mockSystemCounters, NO_LOSS);
        sendChannelEndpoint = new SendChannelEndpoint(SRC_DST, mockTransportLogger, NO_LOSS, mockSystemCounters);

        receiveChannelEndpoint.openDatagramChannel();
        receiveChannelEndpoint.registerForRead(transportPoller);
        sendChannelEndpoint.openDatagramChannel();
        sendChannelEndpoint.registerForRead(transportPoller);

        encodeDataHeader.wrap(buffer, 0);
        encodeDataHeader
            .version(HeaderFlyweight.CURRENT_VERSION)
            .flags(DataHeaderFlyweight.BEGIN_AND_END_FLAGS)
            .headerType(HeaderFlyweight.HDR_TYPE_DATA)
            .frameLength(FRAME_LENGTH);
        encodeDataHeader
            .sessionId(SESSION_ID)
            .streamId(STREAM_ID)
            .termId(TERM_ID);

        encodeDataHeader.wrap(buffer, BitUtil.align(FRAME_LENGTH, FrameDescriptor.FRAME_ALIGNMENT));
        encodeDataHeader
            .version(HeaderFlyweight.CURRENT_VERSION)
            .flags(DataHeaderFlyweight.BEGIN_AND_END_FLAGS)
            .headerType(HeaderFlyweight.HDR_TYPE_DATA)
            .frameLength(24);
        encodeDataHeader
            .sessionId(SESSION_ID)
            .streamId(STREAM_ID)
            .termId(TERM_ID);

        byteBuffer.position(0).limit(2 * BitUtil.align(FRAME_LENGTH, FrameDescriptor.FRAME_ALIGNMENT));

        processLoop(transportPoller, 5);
        sendChannelEndpoint.sendTo(byteBuffer, srcRemoteAddress);
        while (dataHeadersReceived.get() < 1)
        {
            processLoop(transportPoller, 1);
        }

        assertThat(dataHeadersReceived.get(), is(1));
    }

    @Test(timeout = 1000)
    public void shouldHandleSmFrameFromReceiverToSender() throws Exception
    {
        transportPoller = new TransportPoller();
        receiveChannelEndpoint = new ReceiveChannelEndpoint(
            RCV_DST, mockDispatcher, mockTransportLogger, mockSystemCounters, NO_LOSS);
        sendChannelEndpoint = new SendChannelEndpoint(SRC_DST, mockTransportLogger, NO_LOSS, mockSystemCounters);
        sendChannelEndpoint.addToDispatcher(mockPublication, mockFlowControl);

        receiveChannelEndpoint.openDatagramChannel();
        receiveChannelEndpoint.registerForRead(transportPoller);
        sendChannelEndpoint.openDatagramChannel();
        sendChannelEndpoint.registerForRead(transportPoller);

        statusMessage.wrap(buffer, 0);
        statusMessage
            .streamId(STREAM_ID)
            .sessionId(SESSION_ID)
            .consumptionTermId(TERM_ID)
            .receiverWindowLength(1000)
            .consumptionTermOffset(0)
            .version(HeaderFlyweight.CURRENT_VERSION)
            .flags((short)0)
            .headerType(HeaderFlyweight.HDR_TYPE_SM)
            .frameLength(StatusMessageFlyweight.HEADER_LENGTH);
        byteBuffer.position(0).limit(statusMessage.frameLength());

        processLoop(transportPoller, 5);
        receiveChannelEndpoint.sendTo(byteBuffer, rcvRemoteAddress);

        processLoop(transportPoller, 3);

        verify(mockStatusMessagesReceivedCounter, times(1)).orderedIncrement();
    }

    private void processLoop(final TransportPoller transportPoller, final int iterations) throws Exception
    {
        for (int i = 0; i < iterations; i++)
        {
            transportPoller.pollTransports();
        }
    }
}

<code block>

package uk.co.real_logic.aeron.driver;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.stubbing.Answer;
import uk.co.real_logic.aeron.command.*;
import uk.co.real_logic.aeron.driver.buffer.RawLogFactory;
import uk.co.real_logic.aeron.driver.event.EventConfiguration;
import uk.co.real_logic.aeron.driver.event.EventLogger;
import uk.co.real_logic.aeron.driver.media.ReceiveChannelEndpoint;
import uk.co.real_logic.aeron.driver.media.TransportPoller;
import uk.co.real_logic.aeron.driver.media.UdpChannel;
import uk.co.real_logic.agrona.TimerWheel;
import uk.co.real_logic.agrona.concurrent.*;
import uk.co.real_logic.agrona.concurrent.ringbuffer.ManyToOneRingBuffer;
import uk.co.real_logic.agrona.concurrent.ringbuffer.RingBuffer;
import uk.co.real_logic.agrona.concurrent.ringbuffer.RingBufferDescriptor;

import java.nio.ByteBuffer;
import java.util.concurrent.TimeUnit;
import java.util.function.BooleanSupplier;

import static org.hamcrest.Matchers.*;
import static org.junit.Assert.*;
import static org.mockito.Mockito.any;
import static org.mockito.Mockito.*;
import static uk.co.real_logic.aeron.ErrorCode.INVALID_CHANNEL;
import static uk.co.real_logic.aeron.ErrorCode.UNKNOWN_PUBLICATION;
import static uk.co.real_logic.aeron.command.ControlProtocolEvents.*;
import static uk.co.real_logic.aeron.driver.Configuration.*;
import static uk.co.real_logic.aeron.logbuffer.LogBufferDescriptor.TERM_META_DATA_LENGTH;

public class DriverConductorTest
{
    private static final String CHANNEL_URI = "udp:
    private static final String INVALID_URI = "udp:
    private static final int STREAM_ID_1 = 10;
    private static final int STREAM_ID_2 = 20;
    private static final int STREAM_ID_3 = 30;
    private static final int TERM_BUFFER_SZ = Configuration.TERM_BUFFER_LENGTH_DEFAULT;
    private static final long CORRELATION_ID_1 = 1429;
    private static final long CORRELATION_ID_2 = 1430;
    private static final long CORRELATION_ID_3 = 1431;
    private static final long CORRELATION_ID_4 = 1432;
    private static final long CLIENT_ID = 1433;
    private static final int BUFFER_LENGTH = 1024 * 1024;

    private final ByteBuffer toDriverBuffer = ByteBuffer.allocateDirect(Configuration.CONDUCTOR_BUFFER_LENGTH);
    private final ByteBuffer toEventBuffer = ByteBuffer.allocateDirect(
        EventConfiguration.BUFFER_LENGTH_DEFAULT + RingBufferDescriptor.TRAILER_LENGTH);

    private final TransportPoller transportPoller = mock(TransportPoller.class);
    private final RawLogFactory mockRawLogFactory = mock(RawLogFactory.class);

    private final RingBuffer fromClientCommands = new ManyToOneRingBuffer(new UnsafeBuffer(toDriverBuffer));
    private final RingBuffer toEventReader = new ManyToOneRingBuffer(new UnsafeBuffer(toEventBuffer));
    private final ClientProxy mockClientProxy = mock(ClientProxy.class);

    private final PublicationMessageFlyweight publicationMessage = new PublicationMessageFlyweight();
    private final SubscriptionMessageFlyweight subscriptionMessage = new SubscriptionMessageFlyweight();
    private final RemoveMessageFlyweight removeMessage = new RemoveMessageFlyweight();
    private final CorrelatedMessageFlyweight correlatedMessage = new CorrelatedMessageFlyweight();
    private final UnsafeBuffer writeBuffer = new UnsafeBuffer(ByteBuffer.allocateDirect(256));

    private final EventLogger mockConductorLogger = mock(EventLogger.class);

    private final SenderProxy senderProxy = mock(SenderProxy.class);
    private final ReceiverProxy receiverProxy = mock(ReceiverProxy.class);
    private final DriverConductorProxy fromSenderConductorProxy = mock(DriverConductorProxy.class);
    private final DriverConductorProxy fromReceiverConductorProxy = mock(DriverConductorProxy.class);

    private long currentTime;
    private final TimerWheel wheel = new TimerWheel(
        () -> currentTime, CONDUCTOR_TICK_DURATION_US, TimeUnit.MICROSECONDS, CONDUCTOR_TICKS_PER_WHEEL);

    private DriverConductor driverConductor;

    private final Answer<Void> closeChannelEndpointAnswer =
        (invocation) ->
        {
            final Object args[] = invocation.getArguments();
            final ReceiveChannelEndpoint channelEndpoint = (ReceiveChannelEndpoint)args[0];
            channelEndpoint.close();

            return null;
        };

    @Before
    public void setUp() throws Exception
    {
        when(mockRawLogFactory.newPublication(anyObject(), anyInt(), anyInt(), anyInt()))
            .thenReturn(LogBufferHelper.newTestLogBuffers(TERM_BUFFER_SZ, TERM_META_DATA_LENGTH));

        currentTime = 0;

        final UnsafeBuffer counterBuffer = new UnsafeBuffer(ByteBuffer.allocateDirect(BUFFER_LENGTH));
        final CountersManager countersManager = new CountersManager(
            new UnsafeBuffer(ByteBuffer.allocateDirect(BUFFER_LENGTH)), counterBuffer);

        final MediaDriver.Context ctx = new MediaDriver.Context()
            .receiverNioSelector(transportPoller)
            .senderNioSelector(transportPoller)
            .unicastSenderFlowControl(UnicastFlowControl::new)
            .multicastSenderFlowControl(MaxMulticastFlowControl::new)
            .conductorTimerWheel(wheel)
            
            .toConductorFromReceiverCommandQueue(new OneToOneConcurrentArrayQueue<>(1024))
            .toConductorFromSenderCommandQueue(new OneToOneConcurrentArrayQueue<>(1024))
            .eventLogger(mockConductorLogger)
            .rawLogBuffersFactory(mockRawLogFactory)
            .countersManager(countersManager);

        ctx.toEventReader(toEventReader);
        ctx.toDriverCommands(fromClientCommands);
        ctx.clientProxy(mockClientProxy);
        ctx.countersBuffer(counterBuffer);

        final SystemCounters mockSystemCounters = mock(SystemCounters.class);
        ctx.systemCounters(mockSystemCounters);
        when(mockSystemCounters.bytesReceived()).thenReturn(mock(AtomicCounter.class));
        when(mockSystemCounters.clientKeepAlives()).thenReturn(mock(AtomicCounter.class));

        ctx.epochClock(new SystemEpochClock());
        ctx.receiverProxy(receiverProxy);
        ctx.senderProxy(senderProxy);
        ctx.fromReceiverDriverConductorProxy(fromReceiverConductorProxy);
        ctx.fromSenderDriverConductorProxy(fromSenderConductorProxy);

        driverConductor = new DriverConductor(ctx);

        doAnswer(closeChannelEndpointAnswer).when(receiverProxy).closeReceiveChannelEndpoint(any());
    }

    @After
    public void tearDown() throws Exception
    {
        driverConductor.onClose();
    }

    @Test
    public void shouldBeAbleToAddSinglePublication() throws Exception
    {
        writePublicationMessage(ADD_PUBLICATION, 1, 2, 4000, CORRELATION_ID_1);

        driverConductor.doWork();

        final ArgumentCaptor<NetworkPublication> captor = ArgumentCaptor.forClass(NetworkPublication.class);
        verify(senderProxy, times(1)).newPublication(captor.capture(), any(), any());

        final NetworkPublication publication = captor.getValue();
        assertThat(publication.sessionId(), is(1));
        assertThat(publication.streamId(), is(2));

        verify(mockClientProxy).onPublicationReady(eq(2), anyInt(), any(), anyLong(), anyInt());
    }

    @Test
    public void shouldBeAbleToAddSingleSubscription() throws Exception
    {
        writeSubscriptionMessage(ControlProtocolEvents.ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);

        driverConductor.doWork();

        verify(mockClientProxy).operationSucceeded(CORRELATION_ID_1);

        assertNotNull(driverConductor.receiverChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000)));
    }

    @Test
    public void shouldBeAbleToAddAndRemoveSingleSubscription() throws Exception
    {
        writeSubscriptionMessage(ControlProtocolEvents.ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);
        writeSubscriptionMessage(ControlProtocolEvents.REMOVE_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);

        driverConductor.doWork();

        assertNull(driverConductor.receiverChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000)));
    }

    @Test
    public void shouldBeAbleToAddMultipleStreams() throws Exception
    {
        writePublicationMessage(ADD_PUBLICATION, 1, 2, 4001, CORRELATION_ID_1);
        writePublicationMessage(ADD_PUBLICATION, 1, 3, 4002, CORRELATION_ID_2);
        writePublicationMessage(ADD_PUBLICATION, 3, 2, 4003, CORRELATION_ID_3);
        writePublicationMessage(ADD_PUBLICATION, 3, 4, 4004, CORRELATION_ID_4);

        driverConductor.doWork();

        verify(senderProxy, times(4)).newPublication(any(), any(), any());
    }

    @Test
    public void shouldBeAbleToRemoveSingleStream() throws Exception
    {
        writePublicationMessage(ADD_PUBLICATION, 1, 2, 4005, CORRELATION_ID_1);
        writePublicationMessage(REMOVE_PUBLICATION, 1, 2, 4005, CORRELATION_ID_1);

        driverConductor.doWork();

        doWorkUntil(() -> wheel.clock().nanoTime() >= CLIENT_LIVENESS_TIMEOUT_NS + PUBLICATION_LINGER_NS * 2);

        verify(senderProxy).removePublication(any());
        assertNull(driverConductor.senderChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4005)));
    }

    @Test
    public void shouldBeAbleToRemoveMultipleStreams() throws Exception
    {
        writePublicationMessage(ADD_PUBLICATION, 1, 2, 4006, CORRELATION_ID_1);
        writePublicationMessage(ADD_PUBLICATION, 1, 3, 4007, CORRELATION_ID_2);
        writePublicationMessage(ADD_PUBLICATION, 3, 2, 4008, CORRELATION_ID_3);
        writePublicationMessage(ADD_PUBLICATION, 3, 4, 4008, CORRELATION_ID_4);

        removePublicationMessage(CORRELATION_ID_1);
        removePublicationMessage(CORRELATION_ID_2);
        removePublicationMessage(CORRELATION_ID_3);
        removePublicationMessage(CORRELATION_ID_4);

        driverConductor.doWork();

        doWorkUntil(() -> wheel.clock().nanoTime() >= PUBLICATION_LINGER_NS * 2 + CLIENT_LIVENESS_TIMEOUT_NS * 2);

        verify(senderProxy, times(4)).removePublication(any());
    }

    

    private void removePublicationMessage(final long registrationId)
    {
        removeMessage.wrap(writeBuffer, 0);
        removeMessage.registrationId(registrationId);
        assertTrue(fromClientCommands.write(REMOVE_PUBLICATION, writeBuffer, 0, RemoveMessageFlyweight.length()));
    }

    @Test
    public void shouldKeepSubscriptionMediaEndpointUponRemovalOfAllButOneSubscriber() throws Exception
    {
        final UdpChannel udpChannel = UdpChannel.parse(CHANNEL_URI + 4000);

        writeSubscriptionMessage(ControlProtocolEvents.ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);
        writeSubscriptionMessage(ControlProtocolEvents.ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_2, CORRELATION_ID_2);
        writeSubscriptionMessage(ControlProtocolEvents.ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_3, CORRELATION_ID_3);

        driverConductor.doWork();

        final ReceiveChannelEndpoint channelEndpoint = driverConductor.receiverChannelEndpoint(udpChannel);

        assertNotNull(channelEndpoint);
        assertThat(channelEndpoint.streamCount(), is(3));

        writeSubscriptionMessage(ControlProtocolEvents.REMOVE_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);
        writeSubscriptionMessage(ControlProtocolEvents.REMOVE_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_2, CORRELATION_ID_2);

        driverConductor.doWork();

        assertNotNull(driverConductor.receiverChannelEndpoint(udpChannel));
        assertThat(channelEndpoint.streamCount(), is(1));
    }

    @Test
    public void shouldOnlyRemoveSubscriptionMediaEndpointUponRemovalOfAllSubscribers() throws Exception
    {
        final UdpChannel udpChannel = UdpChannel.parse(CHANNEL_URI + 4000);

        writeSubscriptionMessage(ControlProtocolEvents.ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);
        writeSubscriptionMessage(ControlProtocolEvents.ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_2, CORRELATION_ID_2);
        writeSubscriptionMessage(ControlProtocolEvents.ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_3, CORRELATION_ID_3);

        driverConductor.doWork();

        final ReceiveChannelEndpoint channelEndpoint = driverConductor.receiverChannelEndpoint(udpChannel);

        assertNotNull(channelEndpoint);
        assertThat(channelEndpoint.streamCount(), is(3));

        writeSubscriptionMessage(ControlProtocolEvents.REMOVE_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_2, CORRELATION_ID_2);
        writeSubscriptionMessage(ControlProtocolEvents.REMOVE_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_3, CORRELATION_ID_3);

        driverConductor.doWork();

        assertNotNull(driverConductor.receiverChannelEndpoint(udpChannel));
        assertThat(channelEndpoint.streamCount(), is(1));

        writeSubscriptionMessage(ControlProtocolEvents.REMOVE_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);

        driverConductor.doWork();

        assertNull(driverConductor.receiverChannelEndpoint(udpChannel));
    }

    @Test
    public void shouldErrorOnRemoveChannelOnUnknownSessionId() throws Exception
    {
        writePublicationMessage(ADD_PUBLICATION, 1, 2, 4000, CORRELATION_ID_1);
        writePublicationMessage(REMOVE_PUBLICATION, 2, 2, 4000, CORRELATION_ID_1);

        driverConductor.doWork();

        verify(senderProxy).newPublication(any(), any(), any());
        verify(mockClientProxy).onError(eq(UNKNOWN_PUBLICATION), argThat(not(isEmptyOrNullString())), any(), anyInt());
        verify(mockClientProxy, never()).operationSucceeded(anyLong());
        verify(mockConductorLogger).logException(any());
    }

    @Test
    public void shouldErrorOnRemoveChannelOnUnknownStreamId() throws Exception
    {
        writePublicationMessage(ADD_PUBLICATION, 1, 2, 4000, CORRELATION_ID_1);
        writePublicationMessage(REMOVE_PUBLICATION, 1, 3, 4000, CORRELATION_ID_1);

        driverConductor.doWork();

        verify(senderProxy).newPublication(any(), any(), any());
        verify(senderProxy, never()).removePublication(any());
        verify(mockClientProxy).onError(eq(UNKNOWN_PUBLICATION), argThat(not(isEmptyOrNullString())), any(), anyInt());
        verify(mockClientProxy, never()).operationSucceeded(anyLong());
        verify(mockConductorLogger).logException(any());
    }

    @Test
    public void shouldErrorOnAddSubscriptionWithInvalidUri() throws Exception
    {
        writeSubscriptionMessage(ADD_SUBSCRIPTION, INVALID_URI, STREAM_ID_1, CORRELATION_ID_1);

        driverConductor.doWork();
        driverConductor.doWork();

        verify(senderProxy, never()).newPublication(any(), any(), any());

        verify(mockClientProxy).onError(eq(INVALID_CHANNEL), argThat(not(isEmptyOrNullString())), any(), anyInt());
        verify(mockClientProxy, never()).operationSucceeded(anyLong());
        verify(mockConductorLogger).logException(any());
    }

    @Test
    public void shouldTimeoutPublication() throws Exception
    {
        writePublicationMessage(ADD_PUBLICATION, 1, 2, 4000, CORRELATION_ID_1);

        driverConductor.doWork();

        final ArgumentCaptor<NetworkPublication> captor = ArgumentCaptor.forClass(NetworkPublication.class);
        verify(senderProxy, times(1)).newPublication(captor.capture(), any(), any());

        final NetworkPublication publication = captor.getValue();

        doWorkUntil(() -> wheel.clock().nanoTime() >= PUBLICATION_LINGER_NS + CLIENT_LIVENESS_TIMEOUT_NS * 2);

        verify(senderProxy).removePublication(eq(publication));
        assertNull(driverConductor.senderChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000)));
    }

    @Test
    public void shouldNotTimeoutPublicationOnKeepAlive() throws Exception
    {
        writePublicationMessage(ADD_PUBLICATION, 1, 2, 4000, CORRELATION_ID_1);

        driverConductor.doWork();

        final ArgumentCaptor<NetworkPublication> captor = ArgumentCaptor.forClass(NetworkPublication.class);
        verify(senderProxy, times(1)).newPublication(captor.capture(), any(), any());

        final NetworkPublication publication = captor.getValue();

        doWorkUntil(() -> wheel.clock().nanoTime() >= CLIENT_LIVENESS_TIMEOUT_NS / 2);

        writeKeepaliveClientMessage();

        doWorkUntil(() -> wheel.clock().nanoTime() >= CLIENT_LIVENESS_TIMEOUT_NS + 1000);

        writeKeepaliveClientMessage();

        doWorkUntil(() -> wheel.clock().nanoTime() >= CLIENT_LIVENESS_TIMEOUT_NS * 2);

        verify(senderProxy, never()).removePublication(eq(publication));
    }

    @Test
    public void shouldTimeoutSubscription() throws Exception
    {
        writeSubscriptionMessage(ControlProtocolEvents.ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);

        driverConductor.doWork();

        final ReceiveChannelEndpoint receiveChannelEndpoint =
            driverConductor.receiverChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000));
        assertNotNull(receiveChannelEndpoint);

        verify(receiverProxy).addSubscription(eq(receiveChannelEndpoint), eq(STREAM_ID_1));

        doWorkUntil(() -> wheel.clock().nanoTime() >= CLIENT_LIVENESS_TIMEOUT_NS * 2);

        verify(receiverProxy, times(1)).removeSubscription(eq(receiveChannelEndpoint), eq(STREAM_ID_1));

        assertNull(driverConductor.receiverChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000)));
    }

    @Test
    public void shouldNotTimeoutSubscriptionOnKeepAlive() throws Exception
    {
        writeSubscriptionMessage(ControlProtocolEvents.ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);

        driverConductor.doWork();

        final ReceiveChannelEndpoint receiveChannelEndpoint =
            driverConductor.receiverChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000));
        assertNotNull(receiveChannelEndpoint);

        verify(receiverProxy).addSubscription(eq(receiveChannelEndpoint), eq(STREAM_ID_1));

        doWorkUntil(() -> wheel.clock().nanoTime() >= CLIENT_LIVENESS_TIMEOUT_NS);

        writeKeepaliveClientMessage();

        doWorkUntil(() -> wheel.clock().nanoTime() >= CLIENT_LIVENESS_TIMEOUT_NS + 1000);

        writeKeepaliveClientMessage();

        doWorkUntil(() -> wheel.clock().nanoTime() >= CLIENT_LIVENESS_TIMEOUT_NS * 2);

        verify(receiverProxy, never()).removeSubscription(any(), anyInt());
        assertNotNull(driverConductor.receiverChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000)));
    }

    private void writePublicationMessage(
        final int msgTypeId, final int sessionId, final int streamId, final int port, final long correlationId)
    {
        publicationMessage.wrap(writeBuffer, 0);
        publicationMessage.streamId(streamId);
        publicationMessage.sessionId(sessionId);
        publicationMessage.channel(CHANNEL_URI + port);
        publicationMessage.clientId(CLIENT_ID);
        publicationMessage.correlationId(correlationId);

        fromClientCommands.write(msgTypeId, writeBuffer, 0, publicationMessage.length());
    }

    private void writeSubscriptionMessage(
        final int msgTypeId, final String channel, final int streamId, final long registrationCorrelationId)
    {
        subscriptionMessage.wrap(writeBuffer, 0);
        subscriptionMessage.streamId(streamId)
                           .channel(channel)
                           .registrationCorrelationId(registrationCorrelationId)
                           .correlationId(registrationCorrelationId)
                           .clientId(CLIENT_ID);

        fromClientCommands.write(msgTypeId, writeBuffer, 0, subscriptionMessage.length());
    }

    private void writeKeepaliveClientMessage()
    {
        correlatedMessage.wrap(writeBuffer, 0);
        correlatedMessage.clientId(CLIENT_ID);
        correlatedMessage.correlationId(0);

        fromClientCommands.write(ControlProtocolEvents.CLIENT_KEEPALIVE, writeBuffer, 0, CorrelatedMessageFlyweight.LENGTH);
    }

    private long doWorkUntil(final BooleanSupplier condition) throws Exception
    {
        final long startTime = wheel.clock().nanoTime();

        while (!condition.getAsBoolean())
        {
            if (wheel.computeDelayInMs() > 0)
            {
                currentTime += TimeUnit.MICROSECONDS.toNanos(Configuration.CONDUCTOR_TICK_DURATION_US);
            }

            driverConductor.doWork();
        }

        return wheel.clock().nanoTime() - startTime;
    }
}

<code block>

package uk.co.real_logic.aeron.driver;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.stubbing.Answer;
import org.mockito.verification.VerificationMode;
import uk.co.real_logic.aeron.command.*;
import uk.co.real_logic.aeron.driver.event.EventConfiguration;
import uk.co.real_logic.aeron.driver.event.EventLogger;
import uk.co.real_logic.aeron.driver.buffer.RawLogFactory;
import uk.co.real_logic.aeron.driver.media.ReceiveChannelEndpoint;
import uk.co.real_logic.aeron.driver.media.TransportPoller;
import uk.co.real_logic.aeron.driver.media.UdpChannel;
import uk.co.real_logic.agrona.TimerWheel;
import uk.co.real_logic.agrona.concurrent.*;
import uk.co.real_logic.agrona.concurrent.ringbuffer.ManyToOneRingBuffer;
import uk.co.real_logic.agrona.concurrent.ringbuffer.RingBuffer;
import uk.co.real_logic.agrona.concurrent.ringbuffer.RingBufferDescriptor;

import java.nio.ByteBuffer;
import java.util.concurrent.TimeUnit;
import java.util.function.BooleanSupplier;

import static org.hamcrest.Matchers.*;
import static org.junit.Assert.*;
import static org.mockito.Mockito.any;
import static org.mockito.Mockito.*;
import static uk.co.real_logic.aeron.ErrorCode.INVALID_CHANNEL;
import static uk.co.real_logic.aeron.ErrorCode.UNKNOWN_PUBLICATION;
import static uk.co.real_logic.aeron.command.ControlProtocolEvents.ADD_PUBLICATION;
import static uk.co.real_logic.aeron.command.ControlProtocolEvents.REMOVE_PUBLICATION;
import static uk.co.real_logic.aeron.logbuffer.LogBufferDescriptor.TERM_META_DATA_LENGTH;
import static uk.co.real_logic.aeron.driver.Configuration.*;

public class DriverConductorTest
{
    private static final String CHANNEL_URI = "udp:
    private static final String INVALID_URI = "udp:
    private static final int STREAM_ID_1 = 10;
    private static final int STREAM_ID_2 = 20;
    private static final int STREAM_ID_3 = 30;
    private static final int TERM_BUFFER_SZ = Configuration.TERM_BUFFER_LENGTH_DEFAULT;
    private static final long CORRELATION_ID_1 = 1429;
    private static final long CORRELATION_ID_2 = 1430;
    private static final long CORRELATION_ID_3 = 1431;
    private static final long CORRELATION_ID_4 = 1432;
    private static final long CLIENT_ID = 1433;
    private static final int BUFFER_LENGTH = 1024 * 1024;

    private final ByteBuffer toDriverBuffer = ByteBuffer.allocateDirect(Configuration.CONDUCTOR_BUFFER_LENGTH);
    private final ByteBuffer toEventBuffer = ByteBuffer.allocateDirect(
        EventConfiguration.BUFFER_LENGTH_DEFAULT + RingBufferDescriptor.TRAILER_LENGTH);

    private final TransportPoller transportPoller = mock(TransportPoller.class);
    private final RawLogFactory mockRawLogFactory = mock(RawLogFactory.class);

    private final RingBuffer fromClientCommands = new ManyToOneRingBuffer(new UnsafeBuffer(toDriverBuffer));
    private final RingBuffer toEventReader = new ManyToOneRingBuffer(new UnsafeBuffer(toEventBuffer));
    private final ClientProxy mockClientProxy = mock(ClientProxy.class);

    private final PublicationMessageFlyweight publicationMessage = new PublicationMessageFlyweight();
    private final SubscriptionMessageFlyweight subscriptionMessage = new SubscriptionMessageFlyweight();
    private final RemoveMessageFlyweight removeMessage = new RemoveMessageFlyweight();
    private final CorrelatedMessageFlyweight correlatedMessage = new CorrelatedMessageFlyweight();
    private final UnsafeBuffer writeBuffer = new UnsafeBuffer(ByteBuffer.allocateDirect(256));

    private final EventLogger mockConductorLogger = mock(EventLogger.class);

    private final SenderProxy senderProxy = mock(SenderProxy.class);
    private final ReceiverProxy receiverProxy = mock(ReceiverProxy.class);
    private final DriverConductorProxy fromSenderConductorProxy = mock(DriverConductorProxy.class);
    private final DriverConductorProxy fromReceiverConductorProxy = mock(DriverConductorProxy.class);

    private long currentTime;
    private final TimerWheel wheel = new TimerWheel(
        () -> currentTime, CONDUCTOR_TICK_DURATION_US, TimeUnit.MICROSECONDS, CONDUCTOR_TICKS_PER_WHEEL);

    private DriverConductor driverConductor;

    private final Answer<Void> closeChannelEndpointAnswer =
        (invocation) ->
        {
            final Object args[] = invocation.getArguments();
            final ReceiveChannelEndpoint channelEndpoint = (ReceiveChannelEndpoint)args[0];
            channelEndpoint.close();

            return null;
        };

    @Before
    public void setUp() throws Exception
    {
        when(mockRawLogFactory.newPublication(anyObject(), anyInt(), anyInt(), anyInt()))
            .thenReturn(LogBufferHelper.newTestLogBuffers(TERM_BUFFER_SZ, TERM_META_DATA_LENGTH));

        currentTime = 0;

        final UnsafeBuffer counterBuffer = new UnsafeBuffer(ByteBuffer.allocateDirect(BUFFER_LENGTH));
        final CountersManager countersManager = new CountersManager(
            new UnsafeBuffer(ByteBuffer.allocateDirect(BUFFER_LENGTH)), counterBuffer);

        final MediaDriver.Context ctx = new MediaDriver.Context()
            .receiverNioSelector(transportPoller)
            .senderNioSelector(transportPoller)
            .unicastSenderFlowControl(UnicastFlowControl::new)
            .multicastSenderFlowControl(MaxMulticastFlowControl::new)
            .conductorTimerWheel(wheel)
            
            .toConductorFromReceiverCommandQueue(new OneToOneConcurrentArrayQueue<>(1024))
            .toConductorFromSenderCommandQueue(new OneToOneConcurrentArrayQueue<>(1024))
            .eventLogger(mockConductorLogger)
            .rawLogBuffersFactory(mockRawLogFactory)
            .countersManager(countersManager);

        ctx.toEventReader(toEventReader);
        ctx.toDriverCommands(fromClientCommands);
        ctx.clientProxy(mockClientProxy);
        ctx.countersBuffer(counterBuffer);

        final SystemCounters mockSystemCounters = mock(SystemCounters.class);
        ctx.systemCounters(mockSystemCounters);
        when(mockSystemCounters.bytesReceived()).thenReturn(mock(AtomicCounter.class));
        when(mockSystemCounters.clientKeepAlives()).thenReturn(mock(AtomicCounter.class));

        ctx.epochClock(new SystemEpochClock());
        ctx.receiverProxy(receiverProxy);
        ctx.senderProxy(senderProxy);
        ctx.fromReceiverDriverConductorProxy(fromReceiverConductorProxy);
        ctx.fromSenderDriverConductorProxy(fromSenderConductorProxy);

        driverConductor = new DriverConductor(ctx);

        doAnswer(closeChannelEndpointAnswer).when(receiverProxy).closeReceiveChannelEndpoint(any());
    }

    @After
    public void tearDown() throws Exception
    {
        driverConductor.onClose();
    }

    @Test
    public void shouldBeAbleToAddSinglePublication() throws Exception
    {
        writePublicationMessage(ADD_PUBLICATION, 1, 2, 4000, CORRELATION_ID_1);

        driverConductor.doWork();

        verifySenderNotifiedOfNewPublication();

        verify(mockClientProxy).onPublicationReady(
            eq(2), anyInt(), any(), anyLong(), anyInt());
    }

    @Test
    public void shouldBeAbleToAddSingleSubscription() throws Exception
    {
        writeSubscriptionMessage(ControlProtocolEvents.ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);

        driverConductor.doWork();

        verify(mockClientProxy).operationSucceeded(CORRELATION_ID_1);

        assertNotNull(driverConductor.receiverChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000)));
    }

    @Test
    public void shouldBeAbleToAddAndRemoveSingleSubscription() throws Exception
    {
        writeSubscriptionMessage(ControlProtocolEvents.ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);
        writeSubscriptionMessage(ControlProtocolEvents.REMOVE_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);

        driverConductor.doWork();

        assertNull(driverConductor.receiverChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000)));
    }

    @Test
    public void shouldBeAbleToAddMultipleStreams() throws Exception
    {
        writePublicationMessage(ADD_PUBLICATION, 1, 2, 4001, CORRELATION_ID_1);
        writePublicationMessage(ADD_PUBLICATION, 1, 3, 4002, CORRELATION_ID_2);
        writePublicationMessage(ADD_PUBLICATION, 3, 2, 4003, CORRELATION_ID_3);
        writePublicationMessage(ADD_PUBLICATION, 3, 4, 4004, CORRELATION_ID_4);

        driverConductor.doWork();

        verify(senderProxy, times(4)).newPublication(any(), any(), any());
    }

    @Test
    public void shouldBeAbleToRemoveSingleStream() throws Exception
    {
        writePublicationMessage(ADD_PUBLICATION, 1, 2, 4005, CORRELATION_ID_1);
        writePublicationMessage(REMOVE_PUBLICATION, 1, 2, 4005, CORRELATION_ID_1);

        driverConductor.doWork();

        processTimersUntil(() -> wheel.clock().nanoTime() >= CLIENT_LIVENESS_TIMEOUT_NS + PUBLICATION_LINGER_NS * 2);

        verify(senderProxy).removePublication(any());
        assertNull(driverConductor.senderChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4005)));
    }

    @Test
    public void shouldBeAbleToRemoveMultipleStreams() throws Exception
    {
        writePublicationMessage(ADD_PUBLICATION, 1, 2, 4006, CORRELATION_ID_1);
        writePublicationMessage(ADD_PUBLICATION, 1, 3, 4007, CORRELATION_ID_2);
        writePublicationMessage(ADD_PUBLICATION, 3, 2, 4008, CORRELATION_ID_3);
        writePublicationMessage(ADD_PUBLICATION, 3, 4, 4008, CORRELATION_ID_4);

        removePublicationMessage(CORRELATION_ID_1);
        removePublicationMessage(CORRELATION_ID_2);
        removePublicationMessage(CORRELATION_ID_3);
        removePublicationMessage(CORRELATION_ID_4);

        driverConductor.doWork();

        processTimersUntil(() -> wheel.clock().nanoTime() >= PUBLICATION_LINGER_NS * 2 + CLIENT_LIVENESS_TIMEOUT_NS * 2);

        verify(senderProxy, times(4)).removePublication(any());
    }

    

    private void removePublicationMessage(final long registrationId)
    {
        removeMessage.wrap(writeBuffer, 0);
        removeMessage.registrationId(registrationId);
        assertTrue(fromClientCommands.write(REMOVE_PUBLICATION, writeBuffer, 0, RemoveMessageFlyweight.length()));
    }

    @Test
    public void shouldKeepSubscriptionMediaEndpointUponRemovalOfAllButOneSubscriber() throws Exception
    {
        final UdpChannel udpChannel = UdpChannel.parse(CHANNEL_URI + 4000);

        writeSubscriptionMessage(ControlProtocolEvents.ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);
        writeSubscriptionMessage(ControlProtocolEvents.ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_2, CORRELATION_ID_2);
        writeSubscriptionMessage(ControlProtocolEvents.ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_3, CORRELATION_ID_3);

        driverConductor.doWork();

        final ReceiveChannelEndpoint channelEndpoint = driverConductor.receiverChannelEndpoint(udpChannel);

        assertNotNull(channelEndpoint);
        assertThat(channelEndpoint.streamCount(), is(3));

        writeSubscriptionMessage(ControlProtocolEvents.REMOVE_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);
        writeSubscriptionMessage(ControlProtocolEvents.REMOVE_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_2, CORRELATION_ID_2);

        driverConductor.doWork();

        assertNotNull(driverConductor.receiverChannelEndpoint(udpChannel));
        assertThat(channelEndpoint.streamCount(), is(1));
    }

    @Test
    public void shouldOnlyRemoveSubscriptionMediaEndpointUponRemovalOfAllSubscribers() throws Exception
    {
        final UdpChannel udpChannel = UdpChannel.parse(CHANNEL_URI + 4000);

        writeSubscriptionMessage(ControlProtocolEvents.ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);
        writeSubscriptionMessage(ControlProtocolEvents.ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_2, CORRELATION_ID_2);
        writeSubscriptionMessage(ControlProtocolEvents.ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_3, CORRELATION_ID_3);

        driverConductor.doWork();

        final ReceiveChannelEndpoint channelEndpoint = driverConductor.receiverChannelEndpoint(udpChannel);

        assertNotNull(channelEndpoint);
        assertThat(channelEndpoint.streamCount(), is(3));

        writeSubscriptionMessage(ControlProtocolEvents.REMOVE_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_2, CORRELATION_ID_2);
        writeSubscriptionMessage(ControlProtocolEvents.REMOVE_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_3, CORRELATION_ID_3);

        driverConductor.doWork();

        assertNotNull(driverConductor.receiverChannelEndpoint(udpChannel));
        assertThat(channelEndpoint.streamCount(), is(1));

        writeSubscriptionMessage(ControlProtocolEvents.REMOVE_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);

        driverConductor.doWork();

        assertNull(driverConductor.receiverChannelEndpoint(udpChannel));
    }

    @Test
    public void shouldErrorOnRemoveChannelOnUnknownSessionId() throws Exception
    {
        writePublicationMessage(ADD_PUBLICATION, 1, 2, 4000, CORRELATION_ID_1);
        writePublicationMessage(REMOVE_PUBLICATION, 2, 2, 4000, CORRELATION_ID_1);

        driverConductor.doWork();

        verifySenderNotifiedOfNewPublication();

        verify(mockClientProxy).onError(eq(UNKNOWN_PUBLICATION), argThat(not(isEmptyOrNullString())), any(), anyInt());
        verifyNeverSucceeds();
        verifyExceptionLogged();
    }

    @Test
    public void shouldErrorOnRemoveChannelOnUnknownStreamId() throws Exception
    {
        writePublicationMessage(ADD_PUBLICATION, 1, 2, 4000, CORRELATION_ID_1);
        writePublicationMessage(REMOVE_PUBLICATION, 1, 3, 4000, CORRELATION_ID_1);

        driverConductor.doWork();

        verifyPublicationClosed(never());
        verify(mockClientProxy).onError(eq(UNKNOWN_PUBLICATION), argThat(not(isEmptyOrNullString())), any(), anyInt());
        verifyNeverSucceeds();
        verifyExceptionLogged();
    }

    @Test
    public void shouldErrorOnAddSubscriptionWithInvalidUri() throws Exception
    {
        writeSubscriptionMessage(ControlProtocolEvents.ADD_SUBSCRIPTION, INVALID_URI, STREAM_ID_1, CORRELATION_ID_1);

        driverConductor.doWork();
        driverConductor.doWork();

        verify(senderProxy, never()).newPublication(any(), any(), any());

        verify(mockClientProxy).onError(eq(INVALID_CHANNEL), argThat(not(isEmptyOrNullString())), any(), anyInt());
        verifyNeverSucceeds();
        verifyExceptionLogged();
    }

    @Test
    public void shouldTimeoutPublication() throws Exception
    {
        writePublicationMessage(ADD_PUBLICATION, 1, 2, 4000, CORRELATION_ID_1);

        driverConductor.doWork();

        verifySenderNotifiedOfNewPublication();

        processTimersUntil(() -> wheel.clock().nanoTime() >= PUBLICATION_LINGER_NS + CLIENT_LIVENESS_TIMEOUT_NS * 2);

        verifyPublicationClosed(times(1));
        assertNull(driverConductor.senderChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000)));
    }

    @Test
    public void shouldNotTimeoutPublicationOnKeepAlive() throws Exception
    {
        writePublicationMessage(ADD_PUBLICATION, 1, 2, 4000, CORRELATION_ID_1);

        driverConductor.doWork();

        verifySenderNotifiedOfNewPublication();

        processTimersUntil(() -> wheel.clock().nanoTime() >= CLIENT_LIVENESS_TIMEOUT_NS / 2);

        writeKeepaliveClientMessage();

        processTimersUntil(() -> wheel.clock().nanoTime() >= CLIENT_LIVENESS_TIMEOUT_NS + 1000);

        writeKeepaliveClientMessage();

        processTimersUntil(() -> wheel.clock().nanoTime() >= CLIENT_LIVENESS_TIMEOUT_NS * 2);

        verifyPublicationClosed(never());
    }

    @Test
    public void shouldTimeoutSubscription() throws Exception
    {
        writeSubscriptionMessage(ControlProtocolEvents.ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);

        driverConductor.doWork();

        verifyReceiverSubscribes();
        assertNotNull(driverConductor.receiverChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000)));

        processTimersUntil(() -> wheel.clock().nanoTime() >= CLIENT_LIVENESS_TIMEOUT_NS * 2);

        verifyReceiverRemovesSubscription(times(1));
        assertNull(driverConductor.receiverChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000)));
    }

    @Test
    public void shouldNotTimeoutSubscriptionOnKeepAlive() throws Exception
    {
        writeSubscriptionMessage(ControlProtocolEvents.ADD_SUBSCRIPTION, CHANNEL_URI + 4000, STREAM_ID_1, CORRELATION_ID_1);

        driverConductor.doWork();

        assertNotNull(driverConductor.receiverChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000)));
        verifyReceiverSubscribes();

        processTimersUntil(() -> wheel.clock().nanoTime() >= CLIENT_LIVENESS_TIMEOUT_NS);

        writeKeepaliveClientMessage();

        processTimersUntil(() -> wheel.clock().nanoTime() >= CLIENT_LIVENESS_TIMEOUT_NS + 1000);

        writeKeepaliveClientMessage();

        processTimersUntil(() -> wheel.clock().nanoTime() >= CLIENT_LIVENESS_TIMEOUT_NS * 2);

        verifyReceiverRemovesSubscription(never());
        assertNotNull(driverConductor.receiverChannelEndpoint(UdpChannel.parse(CHANNEL_URI + 4000)));
    }

    private void verifyReceiverRemovesSubscription(final VerificationMode times)
    {
        verify(receiverProxy, times).removeSubscription(any(), anyInt());
    }

    private void verifyReceiverSubscribes()
    {
        verify(receiverProxy).addSubscription(any(), eq(STREAM_ID_1));
    }

    private void verifyPublicationClosed(final VerificationMode times)
    {
        verify(senderProxy, times).removePublication(any());
    }

    private void verifyExceptionLogged()
    {
        verify(mockConductorLogger).logException(any());
    }

    private void verifyNeverSucceeds()
    {
        verify(mockClientProxy, never()).operationSucceeded(anyLong());
    }

    private void writePublicationMessage(
        final int msgTypeId, final int sessionId, final int streamId, final int port, final long correlationId)
    {
        publicationMessage.wrap(writeBuffer, 0);
        publicationMessage.streamId(streamId);
        publicationMessage.sessionId(sessionId);
        publicationMessage.channel(CHANNEL_URI + port);
        publicationMessage.clientId(CLIENT_ID);
        publicationMessage.correlationId(correlationId);

        fromClientCommands.write(msgTypeId, writeBuffer, 0, publicationMessage.length());
    }

    private void verifySenderNotifiedOfNewPublication()
    {
        final ArgumentCaptor<NetworkPublication> captor = ArgumentCaptor.forClass(NetworkPublication.class);
        verify(senderProxy, times(1)).newPublication(captor.capture(), any(), any());

        final NetworkPublication publication = captor.getValue();
        assertThat(publication.sessionId(), is(1));
        assertThat(publication.streamId(), is(2));
    }

    private void writeSubscriptionMessage(
        final int msgTypeId, final String channel, final int streamId, final long registrationCorrelationId)
    {
        subscriptionMessage.wrap(writeBuffer, 0);
        subscriptionMessage.streamId(streamId)
                           .channel(channel)
                           .registrationCorrelationId(registrationCorrelationId)
                           .correlationId(registrationCorrelationId)
                           .clientId(CLIENT_ID);

        fromClientCommands.write(msgTypeId, writeBuffer, 0, subscriptionMessage.length());
    }

    private void writeKeepaliveClientMessage()
    {
        correlatedMessage.wrap(writeBuffer, 0);
        correlatedMessage.clientId(CLIENT_ID);
        correlatedMessage.correlationId(0);

        fromClientCommands.write(ControlProtocolEvents.CLIENT_KEEPALIVE, writeBuffer, 0, CorrelatedMessageFlyweight.LENGTH);
    }

    private long processTimersUntil(final BooleanSupplier condition) throws Exception
    {
        final long startTime = wheel.clock().nanoTime();

        while (!condition.getAsBoolean())
        {
            if (wheel.computeDelayInMs() > 0)
            {
                currentTime += TimeUnit.MICROSECONDS.toNanos(Configuration.CONDUCTOR_TICK_DURATION_US);
            }

            driverConductor.doWork();
        }

        return wheel.clock().nanoTime() - startTime;
    }
}
