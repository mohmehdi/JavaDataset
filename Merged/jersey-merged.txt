
package org.glassfish.jersey.examples.exception;

import java.io.IOException;

import javax.ws.rs.Consumes;
import javax.ws.rs.GET;
import javax.ws.rs.InternalServerErrorException;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.container.ContainerRequestContext;
import javax.ws.rs.container.ContainerRequestFilter;
import javax.ws.rs.container.ContainerResponseContext;
import javax.ws.rs.container.ContainerResponseFilter;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.ext.Provider;

import org.glassfish.jersey.examples.exception.Exceptions.MyException;
import org.glassfish.jersey.examples.exception.Exceptions.MySubException;
import org.glassfish.jersey.examples.exception.Exceptions.MySubSubException;
import org.glassfish.jersey.server.ContainerRequest;


@Path("exception")
@Consumes("text/plain")
@Produces("text/plain")
public class ExceptionResource {

    @Provider
    static class MyResponseFilter implements ContainerResponseFilter {

        @Override
        public void filter(ContainerRequestContext requestContext, ContainerResponseContext responseContext) throws IOException {
            System.out.println("MyResponseFilter.postFilter() enter");
            responseContext.setEntity(
                    responseContext.getEntity() + ":" + getClass().getSimpleName(), null, MediaType.TEXT_PLAIN_TYPE);
            System.out.println("MyResponseFilter.postFilter() exit");
        }
    }

    @Provider
    static class WebApplicationExceptionFilter implements ContainerRequestFilter, ContainerResponseFilter {

        @Override
        public void filter(ContainerRequestContext context) throws IOException {
            System.out.println("WebApplicationExceptionFilter.preFilter() enter");

            String path = ((ContainerRequest) context).getRequestUri().getPath();
            if (path.endsWith("request_exception") && context.hasEntity() && ((ContainerRequest) context)
                    .readEntity(String.class).equals("Request Exception")) {
                throw new WebApplicationException(Response.Status.OK);
            }
            System.out.println("WebApplicationExceptionFilter.preFilter() exit");
        }

        @Override
        public void filter(ContainerRequestContext requestContext, ContainerResponseContext responseContext) throws IOException {
            System.out.println("WebApplicationExceptionFilter.postFilter() enter");
            if (responseContext.hasEntity() && responseContext.getEntity().equals("Response Exception")) {
                throw new WebApplicationException(Response.Status.OK);
            }
            System.out.println("WebApplicationExceptionFilter.postFilter() exit");
        }
    }

    @GET
    public String pingMe() {
        return "ping!";
    }

    @POST
    @Path("webapplication_entity")
    public String testWebApplicationExceptionEntity(String s) {
        String[] tokens = s.split(":");
        assert tokens.length == 2;
        int statusCode = Integer.valueOf(tokens[1]);
        Response r = Response.status(statusCode).entity(s).build();
        throw new WebApplicationException(r);
    }

    @POST
    @Path("webapplication_noentity")
    public String testWebApplicationExceptionNoEntity(String s) {
        String[] tokens = s.split(":");
        assert tokens.length == 2;
        int statusCode = Integer.valueOf(tokens[1]);
        Response r = Response.status(statusCode).build();
        throw new WebApplicationException(r);
    }

    @POST
    @Path("my")
    public String testMyException(String s) {
        String[] tokens = s.split(":");
        assert tokens.length == 2;
        int statusCode = Integer.valueOf(tokens[1]);
        Response r = Response.status(statusCode).build();
        throw new MyException(r);
    }

    @POST
    @Path("mysub")
    public String testMySubException(String s) {
        String[] tokens = s.split(":");
        assert tokens.length == 2;
        int statusCode = Integer.valueOf(tokens[1]);
        Response r = Response.status(statusCode).build();
        throw new MySubException(r);
    }

    @POST
    @Path("mysubsub")
    public String testMySubSubException(String s) {
        String[] tokens = s.split(":");
        assert tokens.length == 2;
        int statusCode = Integer.valueOf(tokens[1]);
        Response r = Response.status(statusCode).build();
        throw new MySubSubException(r);
    }

    @POST
    @Path("request_exception")
    public String exceptionInRequestFilter() {
        throw new InternalServerErrorException();        
    }

    @GET
    @Path("response_exception")
    public String exceptionInResponseFilter() {
        return "Response Exception";
    }
}

<code block>

package org.glassfish.jersey.examples.exception;

import java.io.IOException;
import java.net.URI;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.glassfish.jersey.grizzly2.httpserver.GrizzlyHttpServerFactory;
import org.glassfish.jersey.server.ResourceConfig;

import org.glassfish.grizzly.http.server.HttpServer;


public class App {

    private static final URI BASE_URI = URI.create("http:
    public static final String ROOT_PATH = "exception";

    public static void main(String[] args) {
        try {
            System.out.println("\"Exception Mapping\" Jersey Example App");

            final ResourceConfig resourceConfig = new ResourceConfig(
                    ExceptionResource.class,
                    ExceptionResource.MyResponseFilter.class,
                    ExceptionResource.WebApplicationExceptionFilter.class,
                    Exceptions.MyExceptionMapper.class,
                    Exceptions.MySubExceptionMapper.class,
                    Exceptions.WebApplicationExceptionMapper.class);

            final HttpServer server = GrizzlyHttpServerFactory.createHttpServer(BASE_URI, resourceConfig, false);
            Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
                @Override
                public void run() {
                    server.shutdownNow();
                }
            }));
            server.start();

            System.out.println(String.format(
                    "Application started.%n"
                    + "Try out %s%s%n"
                    + "Stop the application using CTRL+C",
                    BASE_URI, ROOT_PATH));

            Thread.currentThread().join();
        } catch (IOException | InterruptedException ex) {
            Logger.getLogger(App.class.getName()).log(Level.SEVERE, null, ex);
        }

    }
}

<code block>

package org.glassfish.jersey.examples.exception;

import javax.ws.rs.client.Entity;
import javax.ws.rs.client.WebTarget;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.UriBuilder;

import org.glassfish.jersey.server.ResourceConfig;
import org.glassfish.jersey.test.JerseyTest;

import org.junit.Test;
import static org.glassfish.jersey.examples.exception.ExceptionResource.MyResponseFilter;
import static org.glassfish.jersey.examples.exception.Exceptions.MyExceptionMapper;
import static org.glassfish.jersey.examples.exception.Exceptions.MySubExceptionMapper;
import static org.glassfish.jersey.examples.exception.Exceptions.WebApplicationExceptionMapper;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;


public class ExceptionMappingFilterTest extends JerseyTest {

    @Override
    protected ResourceConfig configure() {
        
        

        final ResourceConfig resourceConfig = new ResourceConfig(
                ExceptionResource.class,
                MyResponseFilter.class,
                ExceptionResource.WebApplicationExceptionFilter.class,
                MyExceptionMapper.class,
                MySubExceptionMapper.class,
                WebApplicationExceptionMapper.class);

        return resourceConfig;
    }

    
    @Test
    public void testWebApplicationExceptionInRequestFilter() {
        WebTarget t = client().target(UriBuilder.fromUri(getBaseUri()).path(App.ROOT_PATH).path("request_exception").build());
        Response r = t.request("text/plain").post(Entity.text("Request Exception"));
        assertEquals(200, r.getStatus());
        final String entity = r.readEntity(String.class);
        System.out.println("entity = " + entity);
        assertTrue(entity.contains(MyResponseFilter.class.getSimpleName()));
    }

    @Test
    public void testWebApplicationExceptionInResponseFilter() {
        WebTarget t = client().target(UriBuilder.fromUri(getBaseUri()).path(App.ROOT_PATH).path("response_exception").build());
        Response r = t.request("text/plain").get();
        assertEquals(200, r.getStatus());
        final String entity = r.readEntity(String.class);
        System.out.println("entity = " + entity);
        assertTrue(entity.contains(MyResponseFilter.class.getSimpleName()));
    }
}

<code block>

package org.glassfish.jersey.examples.hello.spring.annotations;

import org.springframework.stereotype.Component;

@Component
public class NorwegianGoodbyeService implements GoodbyeService {

    @Override
    public String goodbye(final String who) {
        return String.format("hadet, %s!", who);
    }
}

<code block>

package org.glassfish.jersey.examples.hello.spring.annotations;

public interface GoodbyeService {

    String goodbye(String who);
}

<code block>

package org.glassfish.jersey.examples.hello.spring.annotations;

import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.ProcessingException;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

import javax.inject.Singleton;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;


@Singleton
@Path("spring-resource")
@Service
public class SpringRequestResource {

    AtomicInteger counter = new AtomicInteger();

    @Autowired
    private GreetingService greetingService;

    @Autowired
    private List<GoodbyeService> goodbyeServicesList;
    @Autowired
    private Set<GoodbyeService> goodbyeServicesSet;

    @Autowired
    private Iterable<GoodbyeService> goodbyeServicesIterable;


    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String getHello() {
        return greetingService.greet("world " + counter.incrementAndGet());
    }

    private void checkIntegrity() {
        final Iterator<GoodbyeService> it = goodbyeServicesIterable.iterator();
        int i = 0;
        while (it.hasNext()) {

            final GoodbyeService s1 = it.next();
            final GoodbyeService s2 = goodbyeServicesList.get(i);
            if (s1 != s2) {
                throw new ProcessingException("Instance of service s1 (" + s1.getClass()
                        + ") is not equal to service s2(" + s2.getClass() + ")");
            }
            i++;
        }

        if (goodbyeServicesList.size() != goodbyeServicesSet.size()) {
            throw new ProcessingException("Size of set and size of the list differs. list=" + goodbyeServicesList.size()
                    + "; set=" + goodbyeServicesSet.size());
        }
    }

    private GoodbyeService getService(Class<?> serviceClass) {
        for (GoodbyeService service : goodbyeServicesList) {
            if (serviceClass.isAssignableFrom(service.getClass())) {
                return service;
            }
        }
        return null;
    }

    @Path("goodbye")
    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String getGoodbye() {
        checkIntegrity();

        final GoodbyeService goodbyeService = getService(EnglishGoodbyeService.class);
        return goodbyeService.goodbye("cruel world");
    }

    @Path("norwegian-goodbye")
    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String getNorwegianGoodbye() {
        checkIntegrity();
        return getService(NorwegianGoodbyeService.class).goodbye("pÃ¥ badet");
    }
}

<code block>

package org.glassfish.jersey.examples.hello.spring.annotations;

import org.glassfish.jersey.filter.LoggingFilter;
import org.glassfish.jersey.server.ResourceConfig;
import org.glassfish.jersey.server.spring.scope.RequestContextFilter;


public class JerseyConfig extends ResourceConfig {

    public JerseyConfig() {
        register(RequestContextFilter.class);
        packages("org.glassfish.jersey.examples.hello.spring.annotations");
        register(LoggingFilter.class);
    }
}

<code block>

package org.glassfish.jersey.examples.hello.spring.annotations;

import org.springframework.stereotype.Service;


@Service
public class GreetingService {
    public String greet(String who) {
        return String.format("hello, %s!", who);
    }
}

<code block>

package org.glassfish.jersey.examples.hello.spring.annotations;

import java.io.IOException;
import java.net.URI;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.glassfish.jersey.grizzly2.httpserver.GrizzlyHttpServerFactory;
import org.glassfish.jersey.server.ResourceConfig;

import org.glassfish.grizzly.http.server.HttpServer;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;


public class App {

    private static final URI BASE_URI = URI.create("http:

    public static final String ROOT_PATH = "base";

    public static void main(String[] args) {
        try {
            System.out.println("\"Hello World\" Jersey-Spring Example App");

            final JerseyConfig resourceConfig = new JerseyConfig();
            resourceConfig.property("contextConfig", new AnnotationConfigApplicationContext(SpringAnnotationConfig.class));

            final HttpServer server = GrizzlyHttpServerFactory.createHttpServer(BASE_URI, resourceConfig, false);
            Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
                @Override
                public void run() {
                    server.shutdownNow();
                }
            }));
            server.start();

            System.out.println(String.format("Application started.\nTry out %s%s\nStop the application using CTRL+C",
                    BASE_URI, ROOT_PATH));

            Thread.currentThread().join();
        } catch (IOException | InterruptedException ex) {
            Logger.getLogger(App.class.getName()).log(Level.SEVERE, null, ex);
        }

    }
}

<code block>

package org.glassfish.jersey.examples.hello.spring.annotations;

import org.springframework.stereotype.Component;

@Component
public class EnglishGoodbyeService implements GoodbyeService {

    @Override
    public String goodbye(final String who) {
        return String.format("goodbye, %s!", who);
    }
}

<code block>

package org.glassfish.jersey.examples.hello.spring.annotations;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;


@Configuration
@ComponentScan(basePackageClasses = {GreetingService.class})
public class SpringAnnotationConfig {
}

<code block>

package org.glassfish.jersey.examples.hello.spring.annotations;

import javax.ws.rs.core.Application;

import org.glassfish.jersey.test.JerseyTest;

import org.junit.Assert;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;


public class SpringRequestResourceTest extends JerseyTest {

    @Override
    protected Application configure() {
        ApplicationContext context = new AnnotationConfigApplicationContext(SpringAnnotationConfig.class);
        return new JerseyConfig()
                .property("contextConfig", context);
    }

    @Test
    public void testGreet() throws Exception {
        final String greeting = target("spring-resource").request().get(String.class);
        Assert.assertEquals("hello, world 1!", greeting);
        final String greeting2 = target("spring-resource").request().get(String.class);
        Assert.assertEquals("hello, world 2!", greeting2);
    }

    @Test
    public void testGoodbye() {
        final String goodbye = target("spring-resource").path("goodbye").request().get(String.class);
        Assert.assertEquals("goodbye, cruel world!", goodbye);
        final String norwegianGoodbye = target("spring-resource").path("norwegian-goodbye").request().get(String.class);
        Assert.assertEquals("hadet, pÃ¥ badet!", norwegianGoodbye);
    }
}

<code block>

package org.glassfish.jersey.examples.clipboard;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.annotation.Annotation;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.nio.charset.Charset;
import java.util.Collection;
import java.util.logging.Logger;

import javax.ws.rs.Consumes;
import javax.ws.rs.Produces;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.MultivaluedMap;
import javax.ws.rs.ext.MessageBodyReader;
import javax.ws.rs.ext.MessageBodyWriter;
import javax.ws.rs.ext.Provider;

import org.glassfish.jersey.message.MessageUtils;


public abstract class ClipboardDataProvider implements MessageBodyWriter, MessageBodyReader {

    @Provider
    @Consumes("text/plain")
    @Produces("text/plain")
    public static class TextPlain extends ClipboardDataProvider {

        @Override
        public void writeTo(final Object t, final Class type, final Type genericType, final Annotation[] annotations,
                            final MediaType mediaType, final MultivaluedMap httpHeaders, final OutputStream entityStream)
                throws IOException, WebApplicationException {
            entityStream.write(t.toString().getBytes(MessageUtils.getCharset(mediaType)));
        }

        @Override
        public Object readFrom(final Class type, final Type genericType, final Annotation[] annotations,
                               final MediaType mediaType, final MultivaluedMap httpHeaders, final InputStream entityStream)
                throws IOException, WebApplicationException {
            return new ClipboardData(readStringFromStream(entityStream, MessageUtils.getCharset(mediaType)));
        }
    }

    @Provider
    @Consumes("application/json")
    @Produces("application/json")
    public static class ApplicationJson extends ClipboardDataProvider {

        private static final String JsonOpenning = "{\"content\":\"";
        private static final String JsonClosing = "\"}";

        @Override
        public void writeTo(final Object t, final Class type, final Type genericType, final Annotation[] annotations,
                            final MediaType mediaType, final MultivaluedMap httpHeaders, final OutputStream entityStream)
                throws IOException, WebApplicationException {
            entityStream.write(String.format("%s%s%s", JsonOpenning, t.toString(), JsonClosing)
                    .getBytes(MessageUtils.getCharset(mediaType)));
        }

        @Override
        public Object readFrom(final Class type, final Type genericType, final Annotation[] annotations,
                               final MediaType mediaType, final MultivaluedMap httpHeaders, final InputStream entityStream)
                throws IOException, WebApplicationException {
            final String jsonExpression = readStringFromStream(entityStream, MessageUtils.getCharset(mediaType));
            return new ClipboardData(jsonExpression.replace(JsonOpenning, "").replace(JsonClosing, ""));
        }
    }

    @Override
    public boolean isWriteable(final Class type, final Type genericType, final Annotation[] annotations,
                               final MediaType mediaType) {
        return isKnownType(type, genericType);
    }

    private boolean isKnownType(final Class<?> type, final Type genericType) {
        return type.isAssignableFrom(ClipboardData.class)
                || (Collection.class.isAssignableFrom(type)
                    && (((ParameterizedType) genericType).getActualTypeArguments()[0]).equals(String.class));
    }

    @Override
    public long getSize(final Object t, final Class type, final Type genericType, final Annotation[] annotations,
                        final MediaType mediaType) {
        return -1;
    }

    @Override
    public boolean isReadable(final Class type, final Type genericType, final Annotation[] annotations,
                              final MediaType mediaType) {
        return isKnownType(type, genericType);
    }

    private static String readStringFromStream(final InputStream entityStream, Charset charset) throws IOException {
        final StringBuilder result = new StringBuilder();
        final byte[] buf = new byte[2048];
        int i;
        while ((i = entityStream.read(buf)) != -1) {
            result.append(new String(buf, 0, i, charset));
        }
        return result.toString();
    }
}

<code block>

package org.glassfish.jersey.examples.clipboard;

import java.util.Objects;


public class ClipboardData {

    private String content;

    public ClipboardData(String content) {
        this.content = content;
    }

    @Override
    public String toString() {
        return content;
    }

    boolean isEmpty() {
        return "".equals(content);
    }

    ClipboardData append(ClipboardData addition) {
        content = content + addition.content;
        return this;
    }

    void clear() {
        content = "";
    }

    @Override
    public boolean equals(final Object o) {
        if (this == o) {
            return true;
        }
        if (!(o instanceof ClipboardData)) {
            return false;
        }
        final ClipboardData that = (ClipboardData) o;
        return Objects.equals(content, that.content);
    }

    @Override
    public int hashCode() {
        return Objects.hash(content);
    }
}

<code block>

package org.glassfish.jersey.examples.clipboard;

import javax.ws.rs.client.Entity;
import javax.ws.rs.client.WebTarget;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

import org.glassfish.jersey.client.ClientConfig;
import org.glassfish.jersey.server.ResourceConfig;
import org.glassfish.jersey.test.JerseyTest;
import org.glassfish.jersey.test.TestProperties;

import org.junit.Before;
import org.junit.Test;
import static org.junit.Assert.assertEquals;

public class ClipboardTest extends JerseyTest {

    @Override
    protected ResourceConfig configure() {
        enable(TestProperties.LOG_TRAFFIC);
        return App.createApp();
    }

    @Before
    @Override
    public void setUp() throws Exception {
        super.setUp();

        client().target(getBaseUri()).path(App.ROOT_PATH).request().delete();
        client().target(getBaseUri()).path(App.ROOT_PATH).path("history").request().delete();
    }

    @Override
    protected void configureClient(ClientConfig config) {
        config.register(ClipboardDataProvider.ApplicationJson.class).register(ClipboardDataProvider.TextPlain.class);
    }

    @Test
    public void testDeclarativeClipboardTextPlain() throws Exception {
        testDeclarativeClipboard(MediaType.TEXT_PLAIN_TYPE);
    }

    @Test
    public void testDeclarativeClipboardAppJson() throws Exception {
        testDeclarativeClipboard(MediaType.APPLICATION_JSON_TYPE);
    }

    public void testDeclarativeClipboard(MediaType mediaType) throws Exception {
        final WebTarget clipboard = client().target(getBaseUri()).path(App.ROOT_PATH);

        Response response;

        response = clipboard.request(mediaType).get();
        assertEquals(204, response.getStatus());

        response = clipboard.request(mediaType).put(Entity.entity(new ClipboardData("Hello"), mediaType));
        assertEquals(204, response.getStatus());

        assertEquals("Hello", clipboard.request(mediaType).get(ClipboardData.class).toString());

        response = clipboard.request(mediaType).post(Entity.entity(new ClipboardData(" World!"), mediaType));
        assertEquals(200, response.getStatus());

        assertEquals("Hello World!", clipboard.request(mediaType).get(ClipboardData.class).toString());

        response = clipboard.request(mediaType).delete();
        assertEquals(204, response.getStatus());

        assertEquals(204, clipboard.request(mediaType).get().getStatus());
    }

    @Test
    public void testProgrammaticEchoTextPlain() throws Exception {
        testProgrammaticEcho(MediaType.TEXT_PLAIN_TYPE);
    }

    @Test
    public void testProgrammaticEchoAppJson() throws Exception {
        testProgrammaticEcho(MediaType.APPLICATION_JSON_TYPE);
    }

    @Test
    public void testHistoryInJson() throws Exception {
        callGetHistory(MediaType.APPLICATION_JSON_TYPE);
    }

    @Test
    public void testHistoryInTextPlain() throws Exception {
        callGetHistory(MediaType.TEXT_PLAIN_TYPE);
    }

    private void callGetHistory(final MediaType mediaType) {
        final WebTarget clipboard = client().target(getBaseUri()).path(App.ROOT_PATH);
        clipboard.request(mediaType).post(Entity.entity(new ClipboardData("Task 1 "), mediaType));
        clipboard.request(mediaType).post(Entity.entity(new ClipboardData("Task 2 "), mediaType));
        clipboard.request(mediaType).post(Entity.entity(new ClipboardData("Task 3 "), mediaType));

        ClipboardData response = clipboard.path("history").request(mediaType).get(ClipboardData.class);
        assertEquals(new ClipboardData("[Task 1 , Task 1 Task 2 ]"), response);
    }

    public void testProgrammaticEcho(MediaType mediaType) throws Exception {
        final WebTarget echo = client().target(getBaseUri()).path("echo");

        Response response = echo.request(mediaType).post(Entity.entity(new ClipboardData("Hello"), mediaType));
        assertEquals("Hello", response.readEntity(ClipboardData.class).toString());
    }
}

<code block>

package org.glassfish.jersey.examples.exception;

import java.io.IOException;

import javax.ws.rs.Consumes;
import javax.ws.rs.GET;
import javax.ws.rs.InternalServerErrorException;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.container.ContainerRequestContext;
import javax.ws.rs.container.ContainerRequestFilter;
import javax.ws.rs.container.ContainerResponseContext;
import javax.ws.rs.container.ContainerResponseFilter;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.ext.Provider;

import org.glassfish.jersey.examples.exception.Exceptions.MyException;
import org.glassfish.jersey.examples.exception.Exceptions.MySubException;
import org.glassfish.jersey.examples.exception.Exceptions.MySubSubException;
import org.glassfish.jersey.server.ContainerRequest;


@Path("exception")
public class ExceptionResource {

    @Provider
    static class MyResponseFilter implements ContainerResponseFilter {

        @Override
        public void filter(ContainerRequestContext requestContext, ContainerResponseContext responseContext) throws IOException {
            System.out.println("MyResponseFilter.postFilter() enter");
            responseContext.setEntity(
                    responseContext.getEntity() + ":" + getClass().getSimpleName(), null, MediaType.TEXT_PLAIN_TYPE);
            System.out.println("MyResponseFilter.postFilter() exit");
        }
    }

    @Provider
    static class WebApplicationExceptionFilter implements ContainerRequestFilter, ContainerResponseFilter {

        @Override
        public void filter(ContainerRequestContext context) throws IOException {
            System.out.println("WebApplicationExceptionFilter.preFilter() enter");
            if (context.hasEntity() && ((ContainerRequest) context)
                    .readEntity(String.class).equals("Request Exception")) {
                throw new WebApplicationException(Response.Status.OK);
            }
            System.out.println("WebApplicationExceptionFilter.preFilter() exit");

        }

        @Override
        public void filter(ContainerRequestContext requestContext, ContainerResponseContext responseContext) throws IOException {
            System.out.println("WebApplicationExceptionFilter.postFilter() enter");
            if (responseContext.hasEntity() && responseContext.getEntity().equals("Response Exception")) {
                throw new WebApplicationException(Response.Status.OK);
            }
            System.out.println("WebApplicationExceptionFilter.postFilter() exit");
        }
    }

    @GET
    @Produces("text/plain")
    public String pingMe() {
        return "ping!";
    }

    @POST
    @Consumes("text/plain")
    @Produces("text/plain")
    @Path("webapplication_entity")
    public String testWebApplicationExceptionEntity(String s) {
        String[] tokens = s.split(":");
        assert tokens.length == 2;
        int statusCode = Integer.valueOf(tokens[1]);
        Response r = Response.status(statusCode).entity(s).build();
        throw new WebApplicationException(r);
    }

    @POST
    @Consumes("text/plain")
    @Produces("text/plain")
    @Path("webapplication_noentity")
    public String testWebApplicationExceptionNoEntity(String s) {
        String[] tokens = s.split(":");
        assert tokens.length == 2;
        int statusCode = Integer.valueOf(tokens[1]);
        Response r = Response.status(statusCode).build();
        throw new WebApplicationException(r);
    }

    @POST
    @Consumes("text/plain")
    @Produces("text/plain")
    @Path("my")
    public String testMyException(String s) {
        String[] tokens = s.split(":");
        assert tokens.length == 2;
        int statusCode = Integer.valueOf(tokens[1]);
        Response r = Response.status(statusCode).build();
        throw new MyException(r);
    }

    @POST
    @Consumes("text/plain")
    @Produces("text/plain")
    @Path("mysub")
    public String testMySubException(String s) {
        String[] tokens = s.split(":");
        assert tokens.length == 2;
        int statusCode = Integer.valueOf(tokens[1]);
        Response r = Response.status(statusCode).build();
        throw new MySubException(r);
    }

    @POST
    @Consumes("text/plain")
    @Produces("text/plain")
    @Path("mysubsub")
    public String testMySubSubException(String s) {
        String[] tokens = s.split(":");
        assert tokens.length == 2;
        int statusCode = Integer.valueOf(tokens[1]);
        Response r = Response.status(statusCode).build();
        throw new MySubSubException(r);
    }

    @POST
    @Consumes("text/plain")
    @Produces("text/plain")
    @Path("request_exception")
    public String exceptionInRequestFilter() {
        throw new InternalServerErrorException();        
    }

    @GET
    @Produces("text/plain")
    @Path("response_exception")
    public String exceptionInResponseFilter() {
        return "response_exception";
    }
}

<code block>

package org.glassfish.jersey.examples.exception;

import java.io.IOException;
import java.net.URI;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.glassfish.jersey.grizzly2.httpserver.GrizzlyHttpServerFactory;
import org.glassfish.jersey.server.ResourceConfig;

import org.glassfish.grizzly.http.server.HttpServer;


public class App {

    private static final URI BASE_URI = URI.create("http:
    public static final String ROOT_PATH = "exception";

    public static void main(String[] args) {
        try {
            System.out.println("\"Exception Mapping\" Jersey Example App");

            final ResourceConfig resourceConfig = new ResourceConfig(ExceptionResource.class);
            final HttpServer server = GrizzlyHttpServerFactory.createHttpServer(BASE_URI, resourceConfig, false);
            Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
                @Override
                public void run() {
                    server.shutdownNow();
                }
            }));
            server.start();

            System.out.println(String.format(
                    "Application started.%n"
                    + "Try out %s%s%n"
                    + "Stop the application using CTRL+C",
                    BASE_URI, ROOT_PATH));

            Thread.currentThread().join();
        } catch (IOException | InterruptedException ex) {
            Logger.getLogger(App.class.getName()).log(Level.SEVERE, null, ex);
        }

    }
}

<code block>

package org.glassfish.jersey.examples.exception;

import javax.ws.rs.client.Entity;
import javax.ws.rs.client.WebTarget;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.UriBuilder;

import org.glassfish.jersey.server.ResourceConfig;
import org.glassfish.jersey.test.JerseyTest;

import org.junit.Test;
import static org.glassfish.jersey.examples.exception.ExceptionResource.MyResponseFilter;
import static org.glassfish.jersey.examples.exception.Exceptions.MyExceptionMapper;
import static org.glassfish.jersey.examples.exception.Exceptions.MySubExceptionMapper;
import static org.glassfish.jersey.examples.exception.Exceptions.MySubSubException;
import static org.glassfish.jersey.examples.exception.Exceptions.WebApplicationExceptionMapper;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;


public class ExceptionMappingFilterTest extends JerseyTest {

    @Override
    protected ResourceConfig configure() {
        
        

        final ResourceConfig resourceConfig = new ResourceConfig(
                ExceptionResource.class,
                MyResponseFilter.class,
                ExceptionResource.WebApplicationExceptionFilter.class,
                MyExceptionMapper.class,
                MySubExceptionMapper.class,
                MySubSubException.class,
                WebApplicationExceptionMapper.class);

        return resourceConfig;
    }

    
    @Test
    public void testWebApplicationExceptionInRequestFilter() {
        WebTarget t = client().target(UriBuilder.fromUri(getBaseUri()).path(App.ROOT_PATH).path("request_exception").build());
        Response r = t.request("text/plain").post(Entity.text("Request Exception"));
        assertEquals(200, r.getStatus());
        final String entity = r.readEntity(String.class);
        System.out.println("entity = " + entity);
        assertTrue(entity.contains(MyResponseFilter.class.getSimpleName()));
    }

    @Test
    public void testWebApplicationExceptionInResponseFilter() {
        WebTarget t = client().target(UriBuilder.fromUri(getBaseUri()).path(App.ROOT_PATH).path("response_exception").build());
        Response r = t.request("text/plain").get();
        assertEquals(200, r.getStatus());
        final String entity = r.readEntity(String.class);
        System.out.println("entity = " + entity);
        assertTrue(entity.contains(MyResponseFilter.class.getSimpleName()));
    }
}

<code block>

package org.glassfish.jersey.examples.hello.spring.annotations.annotations;

import org.springframework.stereotype.Component;

@Component
public class NorwegianGoodbyeService implements GoodbyeService {

    @Override
    public String goodbye(final String who) {
        return String.format("hadet, %s!", who);
    }
}

<code block>

package org.glassfish.jersey.examples.hello.spring.annotations.annotations;

public interface GoodbyeService {

    String goodbye(String who);
}

<code block>

package org.glassfish.jersey.examples.hello.spring.annotations.annotations;

import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.ProcessingException;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

import javax.inject.Singleton;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;


@Singleton
@Path("spring-resource")
@Service
public class SpringRequestResource {

    AtomicInteger counter = new AtomicInteger();

    @Autowired
    private GreetingService greetingService;

    @Autowired
    private List<GoodbyeService> goodbyeServicesList;
    @Autowired
    private Set<GoodbyeService> goodbyeServicesSet;

    @Autowired
    private Iterable<GoodbyeService> goodbyeServicesIterable;


    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String getHello() {
        return greetingService.greet("world " + counter.incrementAndGet());
    }

    private void checkIntegrity() {
        final Iterator<GoodbyeService> it = goodbyeServicesIterable.iterator();
        int i = 0;
        while (it.hasNext()) {

            final GoodbyeService s1 = it.next();
            final GoodbyeService s2 = goodbyeServicesList.get(i);
            if (s1 != s2) {
                throw new ProcessingException("Instance of service s1 (" + s1.getClass()
                        + ") is not equal to service s2(" + s2.getClass() + ")");
            }
            i++;
        }

        if (goodbyeServicesList.size() != goodbyeServicesSet.size()) {
            throw new ProcessingException("Size of set and size of the list differs. list=" + goodbyeServicesList.size()
                    + "; set=" + goodbyeServicesSet.size());
        }
    }

    private GoodbyeService getService(Class<?> serviceClass) {
        for (GoodbyeService service : goodbyeServicesList) {
            if (serviceClass.isAssignableFrom(service.getClass())) {
                return service;
            }
        }
        return null;
    }

    @Path("goodbye")
    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String getGoodbye() {
        checkIntegrity();

        final GoodbyeService goodbyeService = getService(EnglishGoodbyeService.class);
        return goodbyeService.goodbye("cruel world");
    }

    @Path("norwegian-goodbye")
    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String getNorwegianGoodbye() {
        checkIntegrity();
        return getService(NorwegianGoodbyeService.class).goodbye("pÃ¥ badet");
    }
}

<code block>

package org.glassfish.jersey.examples.hello.spring.annotations.annotations;

import org.glassfish.jersey.filter.LoggingFilter;
import org.glassfish.jersey.server.ResourceConfig;
import org.glassfish.jersey.server.spring.scope.RequestContextFilter;


public class JerseyConfig extends ResourceConfig {

    public JerseyConfig() {
        register(RequestContextFilter.class);
        packages("org.glassfish.jersey.examples.hello.spring.annotations.annotations");
        register(LoggingFilter.class);
    }
}

<code block>

package org.glassfish.jersey.examples.hello.spring.annotations.annotations;

import org.springframework.stereotype.Service;


@Service
public class GreetingService {
    public String greet(String who) {
        return String.format("hello, %s!", who);
    }
}

<code block>

package org.glassfish.jersey.examples.hello.spring.annotations.annotations;

import org.springframework.stereotype.Component;

@Component
public class EnglishGoodbyeService implements GoodbyeService {

    @Override
    public String goodbye(final String who) {
        return String.format("goodbye, %s!", who);
    }
}

<code block>

package org.glassfish.jersey.examples.hello.spring.annotations.annotations;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;


@Configuration
@ComponentScan(basePackageClasses = {GreetingService.class})
public class SpringAnnotationConfig {
}

<code block>

package org.glassfish.jersey.examples.hello.spring.annotations.annotations;

import javax.ws.rs.core.Application;

import org.glassfish.jersey.test.JerseyTest;

import org.junit.Assert;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;


public class SpringRequestResourceTest extends JerseyTest {

    @Override
    protected Application configure() {
        ApplicationContext context = new AnnotationConfigApplicationContext(SpringAnnotationConfig.class);
        return new JerseyConfig()
                .property("contextConfig", context);
    }

    @Test
    public void testGreet() throws Exception {
        final String greeting = target("spring-resource").request().get(String.class);
        Assert.assertEquals("hello, world 1!", greeting);
        final String greeting2 = target("spring-resource").request().get(String.class);
        Assert.assertEquals("hello, world 2!", greeting2);
    }

    @Test
    public void testGoodbye() {
        final String goodbye = target("spring-resource").path("goodbye").request().get(String.class);
        Assert.assertEquals("goodbye, cruel world!", goodbye);
        final String norwegianGoodbye = target("spring-resource").path("norwegian-goodbye").request().get(String.class);
        Assert.assertEquals("hadet, pÃ¥ badet!", norwegianGoodbye);
    }
}

<code block>

package org.glassfish.jersey.examples.clipboard;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.annotation.Annotation;
import java.lang.reflect.Type;
import java.nio.charset.Charset;
import java.util.logging.Logger;

import javax.ws.rs.Consumes;
import javax.ws.rs.Produces;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.MultivaluedMap;
import javax.ws.rs.ext.MessageBodyReader;
import javax.ws.rs.ext.MessageBodyWriter;
import javax.ws.rs.ext.Provider;

import org.glassfish.jersey.message.MessageUtils;


public abstract class ClipboardDataProvider implements MessageBodyWriter, MessageBodyReader {

    private static final Logger LOG = Logger.getLogger(ClipboardDataProvider.class.getName());

    @Provider
    @Consumes("text/plain")
    @Produces("text/plain")
    public static class TextPlain extends ClipboardDataProvider {

        @Override
        public void writeTo(final Object t, final Class type, final Type genericType, final Annotation[] annotations,
                            final MediaType mediaType, final MultivaluedMap httpHeaders, final OutputStream entityStream)
                throws IOException, WebApplicationException {
            entityStream.write(t.toString().getBytes(MessageUtils.getCharset(mediaType)));
        }

        @Override
        public Object readFrom(final Class type, final Type genericType, final Annotation[] annotations,
                               final MediaType mediaType, final MultivaluedMap httpHeaders, final InputStream entityStream)
                throws IOException, WebApplicationException {
            return new ClipboardData(readStringFromStream(entityStream, MessageUtils.getCharset(mediaType)));
        }
    }

    @Provider
    @Consumes("application/json")
    @Produces("application/json")
    public static class ApplicationJson extends ClipboardDataProvider {

        private static final String JsonOpenning = "{\"content\":\"";
        private static final String JsonClosing = "\"}";

        @Override
        public void writeTo(final Object t, final Class type, final Type genericType, final Annotation[] annotations,
                            final MediaType mediaType, final MultivaluedMap httpHeaders, final OutputStream entityStream)
                throws IOException, WebApplicationException {
            entityStream.write(String.format("%s%s%s", JsonOpenning, t.toString(), JsonClosing)
                    .getBytes(MessageUtils.getCharset(mediaType)));
        }

        @Override
        public Object readFrom(final Class type, final Type genericType, final Annotation[] annotations,
                               final MediaType mediaType, final MultivaluedMap httpHeaders, final InputStream entityStream)
                throws IOException, WebApplicationException {
            final String jsonExpression = readStringFromStream(entityStream, MessageUtils.getCharset(mediaType));
            return new ClipboardData(jsonExpression.replace(JsonOpenning, "").replace(JsonClosing, ""));
        }
    }

    @Override
    public boolean isWriteable(final Class type, final Type genericType, final Annotation[] annotations,
                               final MediaType mediaType) {
        return isKnownType(type);
    }

    private boolean isKnownType(final Class<?> type) {
        return type.isAssignableFrom(ClipboardData.class);
    }

    @Override
    public long getSize(final Object t, final Class type, final Type genericType, final Annotation[] annotations,
                        final MediaType mediaType) {
        return -1;
    }

    @Override
    public boolean isReadable(final Class type, final Type genericType, final Annotation[] annotations,
                              final MediaType mediaType) {
        return isKnownType(type);
    }

    private static String readStringFromStream(final InputStream entityStream, Charset charset) throws IOException {
        final StringBuilder result = new StringBuilder();
        final byte[] buf = new byte[2048];
        int i;
        while ((i = entityStream.read(buf)) != -1) {
            result.append(new String(buf, 0, i, charset));
        }
        return result.toString();
    }
}

<code block>

package org.glassfish.jersey.examples.clipboard;


public class ClipboardData {

    private String content;

    public ClipboardData(String content) {
        this.content = content;
    }

    @Override
    public String toString() {
        return content;
    }

    boolean isEmpty() {
        return "".equals(content);
    }

    ClipboardData append(ClipboardData addition) {
        content = content + addition.content;
        return this;
    }

    void clear() {
        content = "";
    }
}

<code block>

package org.glassfish.jersey.examples.clipboard;

import javax.ws.rs.client.Entity;
import javax.ws.rs.client.WebTarget;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

import org.glassfish.jersey.client.ClientConfig;
import org.glassfish.jersey.server.ResourceConfig;
import org.glassfish.jersey.test.JerseyTest;
import org.glassfish.jersey.test.TestProperties;

import org.junit.Test;
import static org.junit.Assert.assertEquals;

public class ClipboardTest extends JerseyTest {

    @Override
    protected ResourceConfig configure() {
        enable(TestProperties.LOG_TRAFFIC);
        return App.createApp();
    }

    @Override
    protected void configureClient(ClientConfig config) {
        config.register(ClipboardDataProvider.ApplicationJson.class).register(ClipboardDataProvider.TextPlain.class);
    }

    @Test
    public void testDeclarativeClipboardTextPlain() throws Exception {
        testDeclarativeClipboard(MediaType.TEXT_PLAIN_TYPE);
    }

    @Test
    public void testDeclarativeClipboardAppJson() throws Exception {
        testDeclarativeClipboard(MediaType.APPLICATION_JSON_TYPE);
    }

    public void testDeclarativeClipboard(MediaType mediaType) throws Exception {
        final WebTarget clipboard = client().target(getBaseUri()).path(App.ROOT_PATH);

        Response response;

        response = clipboard.request(mediaType).get();
        assertEquals(204, response.getStatus());

        response = clipboard.request(mediaType).put(Entity.entity(new ClipboardData("Hello"), mediaType));
        assertEquals(204, response.getStatus());

        assertEquals("Hello", clipboard.request(mediaType).get(ClipboardData.class).toString());

        response = clipboard.request(mediaType).post(Entity.entity(new ClipboardData(" World!"), mediaType));
        assertEquals(200, response.getStatus());

        assertEquals("Hello World!", clipboard.request(mediaType).get(ClipboardData.class).toString());

        response = clipboard.request(mediaType).delete();
        assertEquals(204, response.getStatus());

        assertEquals(204, clipboard.request(mediaType).get().getStatus());
    }

    @Test
    public void testProgrammaticEchoTextPlain() throws Exception {
        testProgrammaticEcho(MediaType.TEXT_PLAIN_TYPE);

    }

    @Test
    public void testProgrammaticEchoAppJson() throws Exception {
        testProgrammaticEcho(MediaType.APPLICATION_JSON_TYPE);

    }

    public void testProgrammaticEcho(MediaType mediaType) throws Exception {
        final WebTarget echo = client().target(getBaseUri()).path("echo");

        Response response = echo.request(mediaType).post(Entity.entity(new ClipboardData("Hello"), mediaType));
        assertEquals("Hello", response.readEntity(ClipboardData.class).toString());
    }
}

<code block>

package org.glassfish.jersey.grizzly2.httpserver;

import java.io.IOException;
import java.io.OutputStream;
import java.lang.reflect.Type;
import java.net.URI;
import java.net.URISyntaxException;
import java.security.Principal;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.ws.rs.core.Application;
import javax.ws.rs.core.SecurityContext;
import javax.ws.rs.core.UriBuilder;

import javax.inject.Inject;
import javax.inject.Provider;

import org.glassfish.jersey.grizzly2.httpserver.internal.LocalizationMessages;
import org.glassfish.jersey.internal.inject.ReferencingFactory;
import org.glassfish.jersey.internal.util.ExtendedLogger;
import org.glassfish.jersey.internal.util.collection.Ref;
import org.glassfish.jersey.process.internal.RequestScoped;
import org.glassfish.jersey.server.ApplicationHandler;
import org.glassfish.jersey.server.ContainerException;
import org.glassfish.jersey.server.ContainerRequest;
import org.glassfish.jersey.server.ContainerResponse;
import org.glassfish.jersey.server.ResourceConfig;
import org.glassfish.jersey.server.ServerProperties;
import org.glassfish.jersey.server.internal.ContainerUtils;
import org.glassfish.jersey.server.spi.Container;
import org.glassfish.jersey.server.spi.ContainerResponseWriter;
import org.glassfish.jersey.server.spi.RequestScopedInitializer;

import org.glassfish.hk2.api.ServiceLocator;
import org.glassfish.hk2.api.TypeLiteral;
import org.glassfish.hk2.utilities.binding.AbstractBinder;

import org.glassfish.grizzly.CompletionHandler;
import org.glassfish.grizzly.http.server.HttpHandler;
import org.glassfish.grizzly.http.server.Request;
import org.glassfish.grizzly.http.server.Response;
import org.glassfish.grizzly.utils.Charsets;


public final class GrizzlyHttpContainer extends HttpHandler implements Container {

    private static final ExtendedLogger logger =
            new ExtendedLogger(Logger.getLogger(GrizzlyHttpContainer.class.getName()), Level.FINEST);

    private final Type RequestTYPE = (new TypeLiteral<Ref<Request>>() {
    }).getType();
    private final Type ResponseTYPE = (new TypeLiteral<Ref<Response>>() {
    }).getType();
    
    private boolean configSetStatusOverSendError;

    
    private static class GrizzlyRequestReferencingFactory extends ReferencingFactory<Request> {

        @Inject
        public GrizzlyRequestReferencingFactory(final Provider<Ref<Request>> referenceFactory) {
            super(referenceFactory);
        }
    }

    
    private static class GrizzlyResponseReferencingFactory extends ReferencingFactory<Response> {

        @Inject
        public GrizzlyResponseReferencingFactory(final Provider<Ref<Response>> referenceFactory) {
            super(referenceFactory);
        }
    }

    
    static class GrizzlyBinder extends AbstractBinder {

        @Override
        protected void configure() {
            bindFactory(GrizzlyRequestReferencingFactory.class).to(Request.class)
                    .proxy(false).in(RequestScoped.class);
            bindFactory(ReferencingFactory.<Request>referenceFactory()).to(new TypeLiteral<Ref<Request>>() {})
                    .in(RequestScoped.class);

            bindFactory(GrizzlyResponseReferencingFactory.class).to(Response.class)
                    .proxy(true).proxyForSameScope(false).in(RequestScoped.class);
            bindFactory(ReferencingFactory.<Response>referenceFactory()).to(new TypeLiteral<Ref<Response>>() {})
                    .in(RequestScoped.class);
        }
    }

    private static final CompletionHandler<Response> EMPTY_COMPLETION_HANDLER = new CompletionHandler<Response>() {

        @Override
        public void cancelled() {
            
        }

        @Override
        public void failed(final Throwable throwable) {
            
        }

        @Override
        public void completed(final Response result) {
            
        }

        @Override
        public void updated(final Response result) {
            
        }
    };

    private static final class ResponseWriter implements ContainerResponseWriter {

        private final String name;
        private final Response grizzlyResponse;
        private final boolean configSetStatusOverSendError;

        ResponseWriter(final Response response, final boolean configSetStatusOverSendError) {
            this.grizzlyResponse = response;
            this.configSetStatusOverSendError = configSetStatusOverSendError;

            if (logger.isDebugLoggable()) {
                this.name = "ResponseWriter {" + "id=" + UUID.randomUUID().toString() + ", grizzlyResponse="
                        + grizzlyResponse.hashCode() + '}';
                logger.debugLog("{0} - init", name);
            } else {
                this.name = "ResponseWriter";
            }
        }

        @Override
        public String toString() {
            return name;
        }

        @Override
        public void commit() {
            try {
                if (grizzlyResponse.isSuspended()) {
                    grizzlyResponse.resume();
                }
            } finally {
                logger.debugLog("{0} - commit() called", name);
            }
        }

        @Override
        public boolean suspend(final long timeOut, final TimeUnit timeUnit, final TimeoutHandler timeoutHandler) {
            try {
                grizzlyResponse.suspend(timeOut, timeUnit, EMPTY_COMPLETION_HANDLER,
                        new org.glassfish.grizzly.http.server.TimeoutHandler() {

                            @Override
                            public boolean onTimeout(final Response response) {
                                if (timeoutHandler != null) {
                                    timeoutHandler.onTimeout(ResponseWriter.this);
                                }

                                
                                
                                return false;
                            }
                        }
                );
                return true;
            } catch (final IllegalStateException ex) {
                return false;
            } finally {
                logger.debugLog("{0} - suspend(...) called", name);
            }
        }

        @Override
        public void setSuspendTimeout(final long timeOut, final TimeUnit timeUnit) throws IllegalStateException {
            try {
                grizzlyResponse.getSuspendContext().setTimeout(timeOut, timeUnit);
            } finally {
                logger.debugLog("{0} - setTimeout(...) called", name);
            }
        }

        @Override
        public OutputStream writeResponseStatusAndHeaders(final long contentLength,
                                                          final ContainerResponse context)
                throws ContainerException {
            try {
                final javax.ws.rs.core.Response.StatusType statusInfo = context.getStatusInfo();
                if (statusInfo.getReasonPhrase() == null) {
                    grizzlyResponse.setStatus(statusInfo.getStatusCode());
                } else {
                    grizzlyResponse.setStatus(statusInfo.getStatusCode(), statusInfo.getReasonPhrase());
                }

                grizzlyResponse.setContentLengthLong(contentLength);

                for (final Map.Entry<String, List<String>> e : context.getStringHeaders().entrySet()) {
                    for (final String value : e.getValue()) {
                        grizzlyResponse.addHeader(e.getKey(), value);
                    }
                }

                return grizzlyResponse.getOutputStream();
            } finally {
                logger.debugLog("{0} - writeResponseStatusAndHeaders() called", name);
            }
        }

        @Override
        @SuppressWarnings("MagicNumber")
        public void failure(final Throwable error) {
            try {
                if (!grizzlyResponse.isCommitted()) {
                    try {
                        if (configSetStatusOverSendError) {
                            grizzlyResponse.reset();
                            grizzlyResponse.setStatus(500, "Request failed.");
                        } else {
                            grizzlyResponse.sendError(500, "Request failed.");
                        }
                    } catch (final IllegalStateException ex) {
                        
                        logger.log(Level.FINER, "Unable to reset failed response.", ex);
                    } catch (final IOException ex) {
                        throw new ContainerException(
                                LocalizationMessages.EXCEPTION_SENDING_ERROR_RESPONSE(500, "Request failed."),
                                ex);
                    }
                }
            } finally {
                logger.debugLog("{0} - failure(...) called", name);
                rethrow(error);
            }
        }

        @Override
        public boolean enableResponseBuffering() {
            return true;
        }

        
        private void rethrow(final Throwable error) {
            if (error instanceof RuntimeException) {
                throw (RuntimeException) error;
            } else {
                throw new ContainerException(error);
            }
        }
    }

    private volatile ApplicationHandler appHandler;

    
     GrizzlyHttpContainer(final Application application) {
        this.appHandler = new ApplicationHandler(application, new GrizzlyBinder());
        cacheConfigSetStatusOverSendError();
    }

    
     GrizzlyHttpContainer(final Application application, final ServiceLocator parentLocator) {
        this.appHandler = new ApplicationHandler(application, new GrizzlyBinder(), parentLocator);
        cacheConfigSetStatusOverSendError();
    }

    @Override
    public void start() {
        super.start();
        appHandler.onStartup(this);
    }

    @Override
    public void service(final Request request, final Response response) {
        final ResponseWriter responseWriter = new ResponseWriter(response, configSetStatusOverSendError);
        try {
            logger.debugLog("GrizzlyHttpContainer.service(...) started");
            final URI baseUri = getBaseUri(request);
            final ContainerRequest requestContext = new ContainerRequest(baseUri,
                    getRequestUri(baseUri, request), request.getMethod().getMethodString(),
                    getSecurityContext(request), new GrizzlyRequestPropertiesDelegate(request));
            requestContext.setEntityStream(request.getInputStream());
            for (final String headerName : request.getHeaderNames()) {
                requestContext.headers(headerName, request.getHeaders(headerName));
            }
            requestContext.setWriter(responseWriter);

            requestContext.setRequestScopedInitializer(new RequestScopedInitializer() {

                @Override
                public void initialize(final ServiceLocator locator) {
                    locator.<Ref<Request>>getService(RequestTYPE).set(request);
                    locator.<Ref<Response>>getService(ResponseTYPE).set(response);
                }
            });
            appHandler.handle(requestContext);
        } finally {
            logger.debugLog("GrizzlyHttpContainer.service(...) finished");
        }
    }

    @Override
    public ResourceConfig getConfiguration() {
        return appHandler.getConfiguration();
    }

    @Override
    public void reload() {
        reload(appHandler.getConfiguration());
    }

    @Override
    public void reload(final ResourceConfig configuration) {
        appHandler.onShutdown(this);

        appHandler = new ApplicationHandler(configuration, new GrizzlyBinder());
        appHandler.onReload(this);
        appHandler.onStartup(this);
        cacheConfigSetStatusOverSendError();
    }

    @Override
    public ApplicationHandler getApplicationHandler() {
        return appHandler;
    }

    @Override
    public void destroy() {
        super.destroy();
        appHandler.onShutdown(this);
        appHandler = null;
    }

    private SecurityContext getSecurityContext(final Request request) {
        return new SecurityContext() {

            @Override
            public boolean isUserInRole(final String role) {
                return false;
            }

            @Override
            public boolean isSecure() {
                return request.isSecure();
            }

            @Override
            public Principal getUserPrincipal() {
                return request.getUserPrincipal();
            }

            @Override
            public String getAuthenticationScheme() {
                return request.getAuthType();
            }
        };
    }

    private URI getBaseUri(final Request request) {
        try {
            return new URI(request.getScheme(), null, request.getServerName(),
                    request.getServerPort(), getBasePath(request), null, null);
        } catch (final URISyntaxException ex) {
            throw new IllegalArgumentException(ex);
        }
    }

    private String getBasePath(final Request request) {
        final String contextPath = request.getContextPath();

        if (contextPath == null || contextPath.isEmpty()) {
            return "/";
        } else if (contextPath.charAt(contextPath.length() - 1) != '/') {
            return contextPath + "/";
        } else {
            return contextPath;
        }
    }

    private URI getRequestUri(final URI baseUri, final Request grizzlyRequest) {
        
        String originalUri = UriBuilder.fromPath(
                grizzlyRequest.getRequest().getRequestURIRef().getOriginalRequestURIBC().toString(Charsets.ASCII_CHARSET)
        ).build().toString();

        final String queryString = grizzlyRequest.getQueryString();
        if (queryString != null) {
            originalUri = originalUri + "?" + ContainerUtils.encodeUnsafeCharacters(queryString);
        }

        return baseUri.resolve(originalUri);
    }

    
    private void cacheConfigSetStatusOverSendError() {
        this.configSetStatusOverSendError = ServerProperties.getValue(getConfiguration().getProperties(),
                ServerProperties.RESPONSE_SET_STATUS_OVER_SEND_ERROR, false, Boolean.class);
    }
}

<code block>


package org.glassfish.jersey.ext.cdi1x.validation.internal;

import java.util.Set;

import javax.annotation.Priority;
import javax.enterprise.inject.spi.Bean;
import javax.enterprise.inject.spi.BeanManager;
import javax.inject.Inject;
import javax.interceptor.AroundConstruct;
import javax.interceptor.AroundInvoke;
import javax.interceptor.Interceptor;
import javax.interceptor.InvocationContext;

import org.hibernate.validator.internal.cdi.interceptor.MethodValidated;
import org.hibernate.validator.internal.cdi.interceptor.ValidationInterceptor;


@MethodValidated
@Interceptor
@Priority(Interceptor.Priority.PLATFORM_AFTER + 800)
public class CdiInterceptorWrapper {

    private final ValidationInterceptor interceptor;

    @Inject
    public CdiInterceptorWrapper(BeanManager beanManager) {
        
        
        final Set<Bean<?>> interceptorBeans = beanManager.getBeans(ValidationInterceptor.class);
        final Bean<?> interceptorBean = beanManager.resolve(interceptorBeans);
        this.interceptor = (ValidationInterceptor) beanManager.getReference(
                interceptorBean, ValidationInterceptor.class, beanManager.createCreationalContext(interceptorBean));
    }

    @Inject
    private CdiInterceptorWrapperExtension extension;

    @AroundInvoke
    public Object validateMethodInvocation(InvocationContext ctx) throws Exception {
        final boolean isJaxRsMethod = extension.jaxRsResourceCache.compute(ctx.getMethod().getDeclaringClass());
        return isJaxRsMethod ? ctx.proceed() : interceptor.validateMethodInvocation(ctx);
    }

    @AroundConstruct
    public void validateConstructorInvocation(InvocationContext ctx) throws Exception {
        final boolean isJaxRsConstructor = extension.jaxRsResourceCache.compute(ctx.getConstructor().getDeclaringClass());
        if (!isJaxRsConstructor) {
            interceptor.validateConstructorInvocation(ctx);
        }
    }
}
<code block>


package org.glassfish.jersey.ext.cdi1x.validation.internal;

import java.lang.annotation.Annotation;
import java.lang.reflect.Type;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

import javax.annotation.Priority;
import javax.enterprise.context.Dependent;
import javax.enterprise.context.spi.CreationalContext;
import javax.enterprise.event.Observes;
import javax.enterprise.inject.Any;
import javax.enterprise.inject.Default;
import javax.enterprise.inject.spi.AfterBeanDiscovery;
import javax.enterprise.inject.spi.AfterTypeDiscovery;
import javax.enterprise.inject.spi.AnnotatedType;
import javax.enterprise.inject.spi.Bean;
import javax.enterprise.inject.spi.BeanManager;
import javax.enterprise.inject.spi.BeforeBeanDiscovery;
import javax.enterprise.inject.spi.Extension;
import javax.enterprise.inject.spi.InjectionPoint;
import javax.enterprise.inject.spi.InjectionTarget;
import javax.enterprise.util.AnnotationLiteral;
import javax.interceptor.Interceptor;

import org.glassfish.jersey.server.model.Resource;

import org.glassfish.hk2.utilities.cache.Cache;
import org.glassfish.hk2.utilities.cache.Computable;

import org.hibernate.validator.internal.cdi.interceptor.ValidationInterceptor;


@Priority(value = Interceptor.Priority.PLATFORM_BEFORE + 199)
public class CdiInterceptorWrapperExtension implements Extension {

    public static final AnnotationLiteral<Default> DEFAULT_ANNOTATION_LITERAL = new AnnotationLiteral<Default>() {};
    public static final AnnotationLiteral<Any> ANY_ANNOTATION_LITERAL = new AnnotationLiteral<Any>() {};

    final Cache<Class<?>, Boolean> jaxRsResourceCache = new Cache<>(new Computable<Class<?>, Boolean>() {
        @Override
        public Boolean compute(final Class<?> clazz) {
            return Resource.from(clazz) != null;
        }
    });
    private AnnotatedType<ValidationInterceptor> interceptorAnnotatedType;

    
    private void beforeBeanDiscovery(@Observes BeforeBeanDiscovery beforeBeanDiscoveryEvent, final BeanManager beanManager) {
        beforeBeanDiscoveryEvent.addAnnotatedType(beanManager.createAnnotatedType(CdiInterceptorWrapper.class));
        interceptorAnnotatedType = beanManager.createAnnotatedType(ValidationInterceptor.class);
        beforeBeanDiscoveryEvent.addAnnotatedType(interceptorAnnotatedType);
    }

    
    private void afterTypeDiscovery(@Observes final AfterTypeDiscovery afterTypeDiscovery) {
        afterTypeDiscovery.getInterceptors().remove(ValidationInterceptor.class);
    }

    
    private void afterBeanDiscovery(@Observes AfterBeanDiscovery afterBeanDiscovery, BeanManager beanManager) {

        
        final AnnotatedType<ValidationInterceptor> interceptorType = interceptorAnnotatedType;
        final InjectionTarget<ValidationInterceptor> interceptorTarget = beanManager.createInjectionTarget(interceptorType);


        afterBeanDiscovery.addBean(new Bean<ValidationInterceptor>() {

            @Override
            public Class<?> getBeanClass() {
                return ValidationInterceptor.class;
            }

            @Override
            public Set<InjectionPoint> getInjectionPoints() {
                return interceptorTarget.getInjectionPoints();
            }

            @Override
            public String getName() {
                return "HibernateValidationInterceptorImpl";
            }

            @Override
            public Set<Annotation> getQualifiers() {
                return new HashSet<Annotation>() {{
                    add(DEFAULT_ANNOTATION_LITERAL);
                    add(ANY_ANNOTATION_LITERAL);
                }};
            }

            @Override
            public Class<? extends Annotation> getScope() {
                return Dependent.class;
            }

            @Override
            public Set<Class<? extends Annotation>> getStereotypes() {
                return Collections.emptySet();
            }

            @Override
            public Set<Type> getTypes() {
                return new HashSet<Type>() {{
                    add(ValidationInterceptor.class);
                    add(Object.class);
                }};
            }

            @Override
            public boolean isAlternative() {
                return false;
            }

            @Override
            public boolean isNullable() {
                return false;
            }

            @Override
            public ValidationInterceptor create(CreationalContext<ValidationInterceptor> ctx) {

                final ValidationInterceptor result = interceptorTarget.produce(ctx);
                interceptorTarget.inject(result, ctx);
                interceptorTarget.postConstruct(result);
                return result;
            }


            @Override
            public void destroy(ValidationInterceptor instance,
                                CreationalContext<ValidationInterceptor> ctx) {

                interceptorTarget.preDestroy(instance);
                interceptorTarget.dispose(instance);
                ctx.release();
            }
        });
    }
}
<code block>

package org.glassfish.jersey.weld.se;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;
import javax.inject.Provider;
import javax.ws.rs.core.Context;

import org.glassfish.jersey.ext.cdi1x.internal.JerseyVetoed;
import org.glassfish.jersey.server.spi.ExternalRequestContext;
import org.glassfish.jersey.server.spi.ExternalRequestScope;

import org.glassfish.hk2.api.ServiceLocator;

import org.jboss.weld.context.bound.BoundRequestContext;


@ApplicationScoped
@JerseyVetoed
public class WeldRequestScope implements ExternalRequestScope<Map<String, Object>> {

    @Inject
    private BoundRequestContext context;

    private final ThreadLocal<Map<String, Object>> actualMap = new ThreadLocal<>();

    public static final ThreadLocal<ServiceLocator> actualServiceLocator = new ThreadLocal<>();

    @Override
    public ExternalRequestContext<Map<String, Object>> open(ServiceLocator serviceLocator) {
        final Map<String, Object> newMap = new ConcurrentHashMap<>();
        actualMap.set(newMap);
        context.associate(newMap);
        context.activate();
        actualServiceLocator.set(serviceLocator);
        return new ExternalRequestContext<>(newMap);
    }

    @Override
    public void resume(final ExternalRequestContext<Map<String, Object>> ctx, ServiceLocator serviceLocator) {
        final Map<String, Object> newMap = ctx.getContext();
        actualServiceLocator.set(serviceLocator);
        actualMap.set(newMap);
        context.associate(newMap);
        context.activate();
    }

    @Override
    public void suspend(final ExternalRequestContext<Map<String, Object>> ctx, ServiceLocator serviceLocator) {
        try {
            final Map<String, Object> contextMap = actualMap.get();
            if (contextMap != null) {
                context.deactivate();
                context.dissociate(contextMap);
            }
        } finally {
            actualMap.remove();
            actualServiceLocator.remove();
        }
    }

    @Override
    public void close() {
        try {
            final Map<String, Object> contextMap = actualMap.get();
            if (contextMap != null) {
                context.invalidate();
                context.deactivate();
                context.dissociate(contextMap);
            } else {
                context.deactivate();
            }
        } finally {
            actualMap.remove();
            actualServiceLocator.remove();
        }
    }
}

<code block>


package org.glassfish.jersey.weld.se;

import org.glassfish.jersey.ext.cdi1x.internal.GenericHk2LocatorManager;
import org.glassfish.jersey.ext.cdi1x.internal.spi.Hk2LocatorManager;

import org.glassfish.hk2.api.ServiceLocator;


public class WeldHk2LocatorManager extends GenericHk2LocatorManager {

    @Override
    public ServiceLocator lookupLocator() {
        return WeldRequestScope.actualServiceLocator.get();
    }
}

<code block>

package org.glassfish.jersey.ext.cdi1x.internal;

import java.lang.annotation.Annotation;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Member;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.annotation.ManagedBean;
import javax.annotation.Priority;
import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.context.Dependent;
import javax.enterprise.context.RequestScoped;
import javax.enterprise.context.spi.CreationalContext;
import javax.enterprise.event.Observes;
import javax.enterprise.inject.Default;
import javax.enterprise.inject.spi.AfterBeanDiscovery;
import javax.enterprise.inject.spi.AfterTypeDiscovery;
import javax.enterprise.inject.spi.Annotated;
import javax.enterprise.inject.spi.AnnotatedCallable;
import javax.enterprise.inject.spi.AnnotatedConstructor;
import javax.enterprise.inject.spi.AnnotatedParameter;
import javax.enterprise.inject.spi.AnnotatedType;
import javax.enterprise.inject.spi.Bean;
import javax.enterprise.inject.spi.BeanManager;
import javax.enterprise.inject.spi.BeforeBeanDiscovery;
import javax.enterprise.inject.spi.Extension;
import javax.enterprise.inject.spi.InjectionPoint;
import javax.enterprise.inject.spi.InjectionTarget;
import javax.enterprise.inject.spi.ProcessAnnotatedType;
import javax.enterprise.inject.spi.ProcessInjectionTarget;
import javax.enterprise.inject.spi.WithAnnotations;
import javax.enterprise.util.AnnotationLiteral;
import javax.inject.Qualifier;
import javax.ws.rs.ApplicationPath;
import javax.ws.rs.BeanParam;
import javax.ws.rs.FormParam;
import javax.ws.rs.HeaderParam;
import javax.ws.rs.MatrixParam;
import javax.ws.rs.PathParam;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Application;
import javax.ws.rs.core.Context;

import org.glassfish.jersey.ext.cdi1x.internal.spi.Hk2InjectedTarget;
import org.glassfish.jersey.ext.cdi1x.internal.spi.Hk2LocatorManager;
import org.glassfish.jersey.ext.cdi1x.internal.spi.InjectionTargetListener;
import org.glassfish.jersey.ext.cdi1x.spi.Hk2CustomBoundTypesProvider;
import org.glassfish.jersey.internal.inject.ForeignRequestScopeBridge;
import org.glassfish.jersey.internal.inject.Injections;
import org.glassfish.jersey.internal.inject.Providers;
import org.glassfish.jersey.server.model.Parameter;
import org.glassfish.jersey.server.model.Resource;
import org.glassfish.jersey.server.spi.ComponentProvider;
import org.glassfish.jersey.server.spi.internal.ValueFactoryProvider;

import org.glassfish.hk2.api.ClassAnalyzer;
import org.glassfish.hk2.api.DynamicConfiguration;
import org.glassfish.hk2.api.Factory;
import org.glassfish.hk2.api.ServiceLocator;
import org.glassfish.hk2.utilities.binding.ScopedBindingBuilder;
import org.glassfish.hk2.utilities.binding.ServiceBindingBuilder;
import org.glassfish.hk2.utilities.cache.Cache;
import org.glassfish.hk2.utilities.cache.Computable;

import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.ElementType.TYPE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;


@Priority(200)
public class CdiComponentProvider implements ComponentProvider, Extension {

    private static final Logger LOGGER = Logger.getLogger(CdiComponentProvider.class.getName());

    
    private static final Set<Class<? extends Annotation>> JAX_RS_INJECT_ANNOTATIONS =
            new HashSet<Class<? extends Annotation>>() {{
                addAll(JaxRsParamProducer.JAX_RS_STRING_PARAM_ANNOTATIONS);
                add(Context.class);
            }};

    
    public static final String CDI_CLASS_ANALYZER = "CdiInjecteeSkippingClassAnalyzer";

    
    private final Set<Type> jaxrsInjectableTypes = new HashSet<>();
    private final Set<Type> hk2ProvidedTypes = Collections.synchronizedSet(new HashSet<Type>());
    private final Set<Type> jerseyVetoedTypes = Collections.synchronizedSet(new HashSet<Type>());

    
    private final Set<Class<?>> requestScopedComponents = new HashSet<>();


    private final Cache<Class<?>, Boolean> jaxRsComponentCache = new Cache<>(new Computable<Class<?>, Boolean>() {
        @Override
        public Boolean compute(final Class<?> clazz) {
            return Application.class.isAssignableFrom(clazz)
                    || Providers.isJaxRsProvider(clazz)
                    || jaxRsResourceCache.compute(clazz);
        }
    });

    private final Cache<Class<?>, Boolean> jaxRsResourceCache = new Cache<>(new Computable<Class<?>, Boolean>() {
        @Override
        public Boolean compute(final Class<?> clazz) {
            return Resource.from(clazz) != null;
        }
    });

    private final Hk2CustomBoundTypesProvider customHk2TypesProvider;
    private final Hk2LocatorManager locatorManager;

    private volatile ServiceLocator locator;
    private volatile BeanManager beanManager;

    private volatile Map<Class<?>, Set<Method>> methodsToSkip = new HashMap<>();
    private volatile Map<Class<?>, Set<Field>> fieldsToSkip = new HashMap<>();

    public CdiComponentProvider() {
        customHk2TypesProvider = CdiUtil.lookupService(Hk2CustomBoundTypesProvider.class);
        locatorManager = CdiUtil.createHk2LocatorManager();
    }

    @Override
    public void initialize(final ServiceLocator locator) {
        this.locator = locator;
        this.beanManager = CdiUtil.getBeanManager();

        if (beanManager != null) {
            
            final CdiComponentProvider extension = beanManager.getExtension(CdiComponentProvider.class);

            if (extension != null) {
                extension.addLocator(this.locator);

                this.fieldsToSkip = extension.getFieldsToSkip();
                this.methodsToSkip = extension.getMethodsToSkip();

                bindHk2ClassAnalyzer();

                LOGGER.config(LocalizationMessages.CDI_PROVIDER_INITIALIZED());
            }
        }
    }

    
    @ApplicationScoped
    public static class JaxRsParamProducer {

        @Qualifier
        @Retention(RUNTIME)
        @Target({METHOD, FIELD, PARAMETER, TYPE})
        public static @interface JaxRsParamQualifier {
        }

        private static final JaxRsParamQualifier JaxRsParamQUALIFIER = new JaxRsParamQualifier() {

            @Override
            public Class<? extends Annotation> annotationType() {
                return JaxRsParamQualifier.class;
            }
        };

        static final Set<Class<? extends Annotation>> JAX_RS_STRING_PARAM_ANNOTATIONS =
                new HashSet<Class<? extends Annotation>>() {{
                    add(javax.ws.rs.PathParam.class);
                    add(javax.ws.rs.QueryParam.class);
                    add(javax.ws.rs.CookieParam.class);
                    add(javax.ws.rs.HeaderParam.class);
                    add(javax.ws.rs.MatrixParam.class);
                    add(javax.ws.rs.FormParam.class);
                }};

        
        final Cache<InjectionPoint, Parameter> parameterCache = new Cache<>(new Computable<InjectionPoint, Parameter>() {

            @Override
            public Parameter compute(final InjectionPoint injectionPoint) {
                final Annotated annotated = injectionPoint.getAnnotated();
                final Class<?> clazz = injectionPoint.getMember().getDeclaringClass();

                if (annotated instanceof AnnotatedParameter) {

                    final AnnotatedParameter annotatedParameter = (AnnotatedParameter) annotated;
                    final AnnotatedCallable callable = annotatedParameter.getDeclaringCallable();

                    if (callable instanceof AnnotatedConstructor) {

                        final AnnotatedConstructor ac = (AnnotatedConstructor) callable;
                        final int position = annotatedParameter.getPosition();
                        final List<Parameter> parameters = Parameter.create(clazz, clazz, ac.getJavaMember(), false);

                        return parameters.get(position);
                    }
                }

                return null;
            }
        });

        
        @javax.enterprise.inject.Produces
        @JaxRsParamQualifier
        public String getParameterValue(final InjectionPoint injectionPoint, final BeanManager beanManager) {
            final Parameter parameter = parameterCache.compute(injectionPoint);

            if (parameter != null) {
                final ServiceLocator locator = beanManager.getExtension(CdiComponentProvider.class).getEffectiveLocator();
                final Set<ValueFactoryProvider> providers = Providers.getProviders(locator, ValueFactoryProvider.class);

                for (final ValueFactoryProvider vfp : providers) {
                    final Factory<?> valueFactory = vfp.getValueFactory(parameter);
                    if (valueFactory != null) {
                        return (String) valueFactory.provide();
                    }
                }
            }

            return null;
        }
    }

    @Override
    public boolean bind(final Class<?> clazz, final Set<Class<?>> providerContracts) {
        if (LOGGER.isLoggable(Level.FINE)) {
            LOGGER.fine(LocalizationMessages.CDI_CLASS_BEING_CHECKED(clazz));
        }

        if (beanManager == null) {
            return false;
        }

        if (isJerseyOrDependencyType(clazz)) {
            return false;
        }

        final boolean isCdiManaged = isCdiComponent(clazz);
        final boolean isManagedBean = isManagedBean(clazz);
        final boolean isJaxRsComponent = isJaxRsComponentType(clazz);

        if (!isCdiManaged && !isManagedBean && !isJaxRsComponent) {
            return false;
        }

        final boolean isJaxRsResource = jaxRsResourceCache.compute(clazz);

        final DynamicConfiguration dc = Injections.getConfiguration(locator);

        final Class<? extends Annotation> beanScopeAnnotation = CdiUtil.getBeanScope(clazz, beanManager);
        final boolean isRequestScoped = beanScopeAnnotation == RequestScoped.class
                                        || (beanScopeAnnotation == Dependent.class && isJaxRsResource);

        Factory beanFactory = isRequestScoped
                ? new RequestScopedCdiBeanHk2Factory(clazz, locator, beanManager, isCdiManaged)
                : new GenericCdiBeanHk2Factory(clazz, locator, beanManager, isCdiManaged);

        final ServiceBindingBuilder bindingBuilder =
                    Injections.newFactoryBinder(beanFactory);

        bindingBuilder.to(clazz);
        for (final Class contract : providerContracts) {
            bindingBuilder.to(contract);
        }

        Injections.addBinding(bindingBuilder, dc);

        dc.commit();

        if (isRequestScoped) {
            requestScopedComponents.add(clazz);
        }

        if (LOGGER.isLoggable(Level.CONFIG)) {
            LOGGER.config(LocalizationMessages.CDI_CLASS_BOUND_WITH_CDI(clazz));
        }

        return true;
    }

    @Override
    public void done() {
        if (requestScopedComponents.size() > 0) {
            final DynamicConfiguration dc = Injections.getConfiguration(locator);
            Injections.addBinding(Injections.newBinder(new ForeignRequestScopeBridge() {
                @Override
                public Set<Class<?>> getRequestScopedComponents() {
                    return requestScopedComponents;
                }
            }).to(ForeignRequestScopeBridge.class), dc);
            dc.commit();
            if (LOGGER.isLoggable(Level.CONFIG)) {
                LOGGER.config(LocalizationMessages.CDI_REQUEST_SCOPED_COMPONENTS_RECOGNIZED(
                        listElements(new StringBuilder().append("\n"), requestScopedComponents).toString()));
            }
        }
    }

    private boolean isCdiComponent(final Class<?> component) {
        final Annotation[] qualifiers = CdiUtil.getQualifiers(component.getAnnotations());
        return !beanManager.getBeans(component, qualifiers).isEmpty();
    }

    private boolean isManagedBean(final Class<?> component) {
        return component.isAnnotationPresent(ManagedBean.class);
    }

    private static AnnotatedConstructor<?> enrichedConstructor(final AnnotatedConstructor<?> ctor) {
        return new AnnotatedConstructor(){

            @Override
            public Constructor getJavaMember() {
                return ctor.getJavaMember();
            }

            @Override
            public List<AnnotatedParameter> getParameters() {
                final List<AnnotatedParameter> parameters = new ArrayList<>(ctor.getParameters().size());

                for (final AnnotatedParameter<?> ap : ctor.getParameters()) {
                    parameters.add(new AnnotatedParameter() {

                        @Override
                        public int getPosition() {
                            return ap.getPosition();
                        }

                        @Override
                        public AnnotatedCallable getDeclaringCallable() {
                            return ap.getDeclaringCallable();
                        }

                        @Override
                        public Type getBaseType() {
                            return ap.getBaseType();
                        }

                        @Override
                        public Set<Type> getTypeClosure() {
                            return ap.getTypeClosure();
                        }

                        @Override
                        public <T extends Annotation> T getAnnotation(final Class<T> annotationType) {
                            if (annotationType == JaxRsParamProducer.JaxRsParamQualifier.class) {
                                return hasAnnotation(ap, JaxRsParamProducer.JAX_RS_STRING_PARAM_ANNOTATIONS)
                                        ? (T) JaxRsParamProducer.JaxRsParamQUALIFIER : null;
                            } else {
                                return ap.getAnnotation(annotationType);
                            }
                        }

                        @Override
                        public Set<Annotation> getAnnotations() {
                            final Set<Annotation> result = new HashSet<>();
                            for (final Annotation a : ap.getAnnotations()) {
                                result.add(a);
                                final Class<? extends Annotation> annotationType = a.annotationType();
                                if (JaxRsParamProducer.JAX_RS_STRING_PARAM_ANNOTATIONS.contains(annotationType)) {
                                    result.add(JaxRsParamProducer.JaxRsParamQUALIFIER);
                                }
                            }
                            return result;
                        }

                        @Override
                        public boolean isAnnotationPresent(final Class<? extends Annotation> annotationType) {
                            return (annotationType == JaxRsParamProducer.JaxRsParamQualifier.class
                                            && hasAnnotation(ap, JaxRsParamProducer.JAX_RS_STRING_PARAM_ANNOTATIONS))
                                    || ap.isAnnotationPresent(annotationType);
                        }
                    });
                }
                return parameters;
            }

            @Override
            public boolean isStatic() {
                return ctor.isStatic();
            }

            @Override
            public AnnotatedType getDeclaringType() {
                return ctor.getDeclaringType();
            }

            @Override
            public Type getBaseType() {
                return ctor.getBaseType();
            }

            @Override
            public Set<Type> getTypeClosure() {
                return ctor.getTypeClosure();
            }

            @Override
            public <T extends Annotation> T getAnnotation(final Class<T> annotationType) {
                return ctor.getAnnotation(annotationType);
            }

            @Override
            public Set<Annotation> getAnnotations() {
                return ctor.getAnnotations();
            }

            @Override
            public boolean isAnnotationPresent(final Class<? extends Annotation> annotationType) {
                return ctor.isAnnotationPresent(annotationType);
            }
        };
    }

    @SuppressWarnings("unused")
    private void processAnnotatedType(@Observes
                                      @WithAnnotations({
                                              Context.class,
                                              ApplicationPath.class,
                                              HeaderParam.class,
                                              QueryParam.class,
                                              FormParam.class,
                                              MatrixParam.class,
                                              BeanParam.class,
                                              PathParam.class})
                                      final ProcessAnnotatedType processAnnotatedType) {
        final AnnotatedType<?> annotatedType = processAnnotatedType.getAnnotatedType();

        
        if (containsJaxRsConstructorInjection(annotatedType)
                || containsJaxRsFieldInjection(annotatedType)
                || containsJaxRsMethodInjection(annotatedType)) {
            jaxrsInjectableTypes.add(annotatedType.getBaseType());
        }

        if (customHk2TypesProvider != null) {
            final Type baseType = annotatedType.getBaseType();
            if (customHk2TypesProvider.getHk2Types().contains(baseType)) {
                processAnnotatedType.veto();
                jerseyVetoedTypes.add(baseType);
            }
        }

        if (containsJaxRsParameterizedCtor(annotatedType)) {
            processAnnotatedType.setAnnotatedType(new AnnotatedType() {

                @Override
                public Class getJavaClass() {
                    return annotatedType.getJavaClass();
                }

                @Override
                public Set<AnnotatedConstructor> getConstructors() {
                    final Set<AnnotatedConstructor> result = new HashSet<>();
                    for (final AnnotatedConstructor c : annotatedType.getConstructors()) {
                        result.add(enrichedConstructor(c));
                    }
                    return result;
                }

                @Override
                public Set getMethods() {
                    return annotatedType.getMethods();
                }

                @Override
                public Set getFields() {
                    return annotatedType.getFields();
                }

                @Override
                public Type getBaseType() {
                    return annotatedType.getBaseType();
                }

                @Override
                public Set<Type> getTypeClosure() {
                    return annotatedType.getTypeClosure();
                }

                @Override
                public <T extends Annotation> T getAnnotation(final Class<T> annotationType) {
                    return annotatedType.getAnnotation(annotationType);
                }

                @Override
                public Set<Annotation> getAnnotations() {
                    return annotatedType.getAnnotations();
                }

                @Override
                public boolean isAnnotationPresent(final Class<? extends Annotation> annotationType) {
                    return annotatedType.isAnnotationPresent(annotationType);
                }
            });
        }
    }

    private boolean containsJaxRsParameterizedCtor(final AnnotatedType annotatedType) {
        return containAnnotatedParameters(annotatedType.getConstructors(), JaxRsParamProducer.JAX_RS_STRING_PARAM_ANNOTATIONS);
    }

    private boolean containsJaxRsConstructorInjection(final AnnotatedType annotatedType) {
        return containAnnotatedParameters(annotatedType.getConstructors(), JAX_RS_INJECT_ANNOTATIONS);
    }

    private boolean containsJaxRsMethodInjection(final AnnotatedType annotatedType) {
        return containAnnotatedParameters(annotatedType.getMethods(), JAX_RS_INJECT_ANNOTATIONS);
    }

    private boolean containsJaxRsFieldInjection(final AnnotatedType annotatedType) {
        return containAnnotation(annotatedType.getFields(), JAX_RS_INJECT_ANNOTATIONS);
    }

    private boolean containAnnotatedParameters(final Collection<AnnotatedCallable> annotatedCallables,
                                               final Set<Class<? extends Annotation>> annotationSet) {
        for (final AnnotatedCallable c : annotatedCallables) {
            if (containAnnotation(c.getParameters(), annotationSet)) {
                return true;
            }
        }
        return false;
    }

    private boolean containAnnotation(final Collection<Annotated> elements,
                                      final Set<Class<? extends Annotation>> annotationSet) {
        for (final Annotated element : elements) {
            if (hasAnnotation(element, annotationSet)) {
                return true;
            }
        }
        return false;
    }

    private static boolean hasAnnotation(final Annotated element, final Set<Class<? extends Annotation>> annotations) {
        for (final Class<? extends Annotation> a : annotations) {
            if (element.isAnnotationPresent(a)) {
                return true;
            }
        }
        return false;
    }

    @SuppressWarnings("unused")
    private void afterTypeDiscovery(@Observes final AfterTypeDiscovery afterTypeDiscovery) {
        if (LOGGER.isLoggable(Level.CONFIG) && !jerseyVetoedTypes.isEmpty()) {
            LOGGER.config(LocalizationMessages.CDI_TYPE_VETOED(customHk2TypesProvider,
                    listElements(new StringBuilder().append("\n"), jerseyVetoedTypes).toString()));
        }
    }

    @SuppressWarnings("unused")
    private void beforeBeanDiscovery(@Observes final BeforeBeanDiscovery beforeBeanDiscovery, final BeanManager beanManager) {
        beforeBeanDiscovery.addAnnotatedType(beanManager.createAnnotatedType(JaxRsParamProducer.class));
    }

    @SuppressWarnings("unused")
    private void processInjectionTarget(@Observes final ProcessInjectionTarget event) {
        final InjectionTarget it = event.getInjectionTarget();
        final Class<?> componentClass = event.getAnnotatedType().getJavaClass();

        final Set<InjectionPoint> cdiInjectionPoints = filterHk2InjectionPointsOut(it.getInjectionPoints());

        for (final InjectionPoint injectionPoint : cdiInjectionPoints) {
            final Member member = injectionPoint.getMember();
            if (member instanceof Field) {
                addInjecteeToSkip(componentClass, fieldsToSkip, (Field) member);
            } else if (member instanceof Method) {
                addInjecteeToSkip(componentClass, methodsToSkip, (Method) member);
            }
        }

        Hk2InjectedCdiTarget target = null;
        if (isJerseyOrDependencyType(componentClass)) {
            target = new Hk2InjectedCdiTarget(componentClass, it) {

                @Override
                public Set<InjectionPoint> getInjectionPoints() {
                    
                    
                    return Collections.emptySet();
                }
            };
        } else if (isJaxRsComponentType(componentClass)
                || jaxrsInjectableTypes.contains(event.getAnnotatedType().getBaseType())) {
            target = new Hk2InjectedCdiTarget(componentClass, it) {

                @Override
                public Set<InjectionPoint> getInjectionPoints() {
                    
                    return cdiInjectionPoints;
                }
            };
        }

        if (target != null) {
            notify(target);
            
            event.setInjectionTarget(target);
        }
    }

    private Set<InjectionPoint> filterHk2InjectionPointsOut(final Set<InjectionPoint> originalInjectionPoints) {
        final Set<InjectionPoint> filteredInjectionPoints = new HashSet<>();
        for (final InjectionPoint ip : originalInjectionPoints) {
            final Type injectedType = ip.getType();
            if (customHk2TypesProvider != null && customHk2TypesProvider.getHk2Types().contains(injectedType)) {
                
                hk2ProvidedTypes.add(injectedType);
            } else {
                if (injectedType instanceof Class<?>) {
                    final Class<?> injectedClass = (Class<?>) injectedType;
                    if (isJerseyOrDependencyType(injectedClass)) {
                        
                        hk2ProvidedTypes.add(injectedType);
                    } else {
                        filteredInjectionPoints.add(ip);
                    }
                } else { 
                    if (isInjectionProvider(injectedType)
                            && (isProviderOfJerseyType((ParameterizedType) injectedType))) {
                        
                        hk2ProvidedTypes.add(((ParameterizedType) injectedType).getActualTypeArguments()[0]);
                    } else {
                        filteredInjectionPoints.add(ip);
                    }
                }
            }
        }
        return filteredInjectionPoints;
    }

    private boolean isInjectionProvider(final Type injectedType) {
        return injectedType instanceof ParameterizedType
                && ((ParameterizedType) injectedType).getRawType() == javax.inject.Provider.class;
    }

    private boolean isProviderOfJerseyType(final ParameterizedType provider) {
        final Type firstArgumentType = provider.getActualTypeArguments()[0];
        if (firstArgumentType instanceof Class && isJerseyOrDependencyType((Class<?>) firstArgumentType)) {
            return true;
        }
        return (customHk2TypesProvider != null && customHk2TypesProvider.getHk2Types().contains(firstArgumentType));
    }

    private <T> void addInjecteeToSkip(final Class<?> componentClass, final Map<Class<?>, Set<T>> toSkip, final T member) {
        if (!toSkip.containsKey(componentClass)) {
            toSkip.put(componentClass, new HashSet<T>());
        }
        toSkip.get(componentClass).add(member);
    }

    
    @SuppressWarnings("serial")
    public static class CdiDefaultAnnotation extends AnnotationLiteral<Default> implements Default {

        private static final long serialVersionUID = 1L;
    }

    @SuppressWarnings({"unused", "unchecked", "rawtypes"})
    private void afterDiscoveryObserver(@Observes final AfterBeanDiscovery abd) {
        if (customHk2TypesProvider != null) {
            hk2ProvidedTypes.addAll(customHk2TypesProvider.getHk2Types());
        }

        for (final Type t : hk2ProvidedTypes) {
            abd.addBean(new Hk2Bean(t));
        }
    }

    
     Map<Class<?>, Set<Field>> getFieldsToSkip() {
        return fieldsToSkip;
    }

    
     Map<Class<?>, Set<Method>> getMethodsToSkip() {
        return methodsToSkip;
    }

    
     ServiceLocator getEffectiveLocator() {
        return locatorManager.getEffectiveLocator();
    }

    
     void addLocator(final ServiceLocator locator) {
        locatorManager.registerLocator(locator);
    }

    
     void notify(final Hk2InjectedTarget target) {
        if (locatorManager instanceof InjectionTargetListener) {
            ((InjectionTargetListener) locatorManager).notify(target);
        }
    }

    
     boolean isJaxRsComponentType(final Class<?> clazz) {
        return jaxRsComponentCache.compute(clazz);
    }

    private static boolean isJerseyOrDependencyType(final Class<?> clazz) {
        if (clazz.isPrimitive() || clazz.isSynthetic()) {
            return false;
        }

        final Package pkg = clazz.getPackage();
        if (pkg == null) { 
            LOGGER.warning(String.format("Class %s has null package", clazz));
            return false;
        }

        final String pkgName = pkg.getName();
        return !clazz.isAnnotationPresent(JerseyVetoed.class)
                && (pkgName.contains("org.glassfish.hk2")
                            || pkgName.contains("jersey.repackaged")
                            || pkgName.contains("org.jvnet.hk2")
                            || (pkgName.startsWith("org.glassfish.jersey")
                                        && !pkgName.startsWith("org.glassfish.jersey.examples")
                                        && !pkgName.startsWith("org.glassfish.jersey.tests"))
                            || (pkgName.startsWith("com.sun.jersey")
                                        && !pkgName.startsWith("com.sun.jersey.examples")
                                        && !pkgName.startsWith("com.sun.jersey.tests")));
    }

    private void bindHk2ClassAnalyzer() {
        final ClassAnalyzer defaultClassAnalyzer =
                locator.getService(ClassAnalyzer.class, ClassAnalyzer.DEFAULT_IMPLEMENTATION_NAME);

        final int skippedElements = methodsToSkip.size() + fieldsToSkip.size();

        final ClassAnalyzer customizedClassAnalyzer = skippedElements > 0
                ? new InjecteeSkippingAnalyzer(defaultClassAnalyzer, methodsToSkip, fieldsToSkip)
                : defaultClassAnalyzer;

        final DynamicConfiguration dc = Injections.getConfiguration(locator);

        final ScopedBindingBuilder bindingBuilder =
                Injections.newBinder(customizedClassAnalyzer);

        bindingBuilder.analyzeWith(ClassAnalyzer.DEFAULT_IMPLEMENTATION_NAME)
                .to(ClassAnalyzer.class)
                .named(CDI_CLASS_ANALYZER);

        Injections.addBinding(bindingBuilder, dc);

        dc.commit();
    }

    private StringBuilder listElements(final StringBuilder logMsgBuilder, final Collection<? extends Object> elements) {
        for (final Object t : elements) {
            logMsgBuilder.append(String.format(" - %s%n", t));
        }
        return logMsgBuilder;
    }

    @SuppressWarnings("unchecked")
    private abstract class Hk2InjectedCdiTarget implements Hk2InjectedTarget {

        private final Class<?> componentClass;
        private final InjectionTarget delegate;
        private final ClassLoader targetClassLoader;

        private volatile ServiceLocator effectiveLocator;

        public Hk2InjectedCdiTarget(final Class<?> componentClass,
                                    final InjectionTarget delegate) {
            this.componentClass = componentClass;
            this.delegate = delegate;
            this.targetClassLoader = componentClass.getClassLoader();
        }

        @Override
        public abstract Set<InjectionPoint> getInjectionPoints();

        @Override
        public void inject(final Object t, final CreationalContext cc) {
            delegate.inject(t, cc);

            final ServiceLocator injectingLocator = (effectiveLocator != null) ? effectiveLocator : getEffectiveLocator();

            if (injectingLocator != null) {
                injectingLocator.inject(t, CdiComponentProvider.CDI_CLASS_ANALYZER);
            }
        }

        @Override
        public void postConstruct(final Object t) {
            delegate.postConstruct(t);
        }

        @Override
        public void preDestroy(final Object t) {
            delegate.preDestroy(t);
        }

        @Override
        public Object produce(final CreationalContext cc) {
            return delegate.produce(cc);
        }

        @Override
        public void dispose(final Object t) {
            delegate.dispose(t);
        }

        @Override
        public void setLocator(final ServiceLocator effectiveLocator) {
            this.effectiveLocator = effectiveLocator;
        }
    }

    private class Hk2Bean implements Bean {

        private final Type t;

        public Hk2Bean(final Type t) {
            this.t = t;
        }

        @Override
        public Class getBeanClass() {
            return (Class) t;
        }

        @Override
        public Set getInjectionPoints() {
            return Collections.emptySet();
        }

        @Override
        public boolean isNullable() {
            return true;
        }

        @Override
        public Object create(final CreationalContext creationalContext) {
            return getEffectiveLocator().getService(t);
        }

        @Override
        public void destroy(final Object instance, final CreationalContext creationalContext) {
        }

        @Override
        public Set getTypes() {
            return Collections.singleton(t);
        }

        @Override
        public Set getQualifiers() {
            return Collections.singleton(new CdiDefaultAnnotation());
        }

        @Override
        public Class getScope() {
            return Dependent.class;
        }

        @Override
        public String getName() {
            return t.toString();
        }

        @Override
        public Set getStereotypes() {
            return Collections.emptySet();
        }

        @Override
        public boolean isAlternative() {
            return false;
        }
    }
}

<code block>

package org.glassfish.jersey.ext.cdi1x.internal;

import java.lang.annotation.Annotation;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import javax.enterprise.context.spi.CreationalContext;
import javax.enterprise.inject.spi.Bean;
import javax.enterprise.inject.spi.BeanManager;
import javax.inject.Qualifier;

import org.glassfish.jersey.ext.cdi1x.internal.spi.BeanManagerProvider;
import org.glassfish.jersey.ext.cdi1x.internal.spi.Hk2LocatorManager;
import org.glassfish.jersey.internal.ServiceFinder;
import org.glassfish.jersey.model.internal.RankedComparator;
import org.glassfish.jersey.model.internal.RankedProvider;


public final class CdiUtil {

    private static final BeanManagerProvider BEAN_MANAGER_PROVIDER = new DefaultBeanManagerProvider();

    
    private CdiUtil() {
        throw new AssertionError("No instances allowed.");
    }

    
    public static Annotation[] getQualifiers(final Annotation[] annotations) {
        final List<Annotation> result = new ArrayList<>(annotations.length);
        for (final Annotation a : annotations) {
            if (a.annotationType().isAnnotationPresent(Qualifier.class)) {
                result.add(a);
            }
        }
        return result.toArray(new Annotation[result.size()]);
    }

    
    public static BeanManager getBeanManager() {
        final BeanManagerProvider provider = lookupService(BeanManagerProvider.class);
        if (provider != null) {
            return provider.getBeanManager();
        }

        return BEAN_MANAGER_PROVIDER.getBeanManager();
    }

    
    static Hk2LocatorManager createHk2LocatorManager() {
        final Hk2LocatorManager manager = lookupService(Hk2LocatorManager.class);
        return manager != null ? manager : new SingleHk2LocatorManager();
    }

    
    static <T> T lookupService(final Class<T> clazz) {
        final List<RankedProvider<T>> providers = new LinkedList<>();

        for (final T provider : ServiceFinder.find(clazz)) {
            providers.add(new RankedProvider<>(provider));
        }
        Collections.sort(providers, new RankedComparator<T>(RankedComparator.Order.ASCENDING));

        return providers.isEmpty() ? null : providers.get(0).getProvider();
    }

    
    static <T> T getBeanReference(final Class<T> clazz, final Bean bean, final BeanManager beanManager) {
        final CreationalContext<?> creationalContext = beanManager.createCreationalContext(bean);
        final Object result = beanManager.getReference(bean, clazz, creationalContext);

        return clazz.cast(result);
    }

    
    public static Class<? extends Annotation> getBeanScope(final Class<?> beanClass, final BeanManager beanManager) {
        final Set<Bean<?>> beans = beanManager.getBeans(beanClass);
        if (beans.isEmpty()) {
            return null;
        }
        for (Bean b : beans) {
            return b.getScope();
        }
        return null;
    }
}

<code block>


package org.glassfish.jersey.ext.cdi1x.internal;

import java.util.LinkedList;
import java.util.List;

import org.glassfish.jersey.ext.cdi1x.internal.spi.Hk2InjectedTarget;
import org.glassfish.jersey.ext.cdi1x.internal.spi.Hk2LocatorManager;
import org.glassfish.jersey.ext.cdi1x.internal.spi.InjectionTargetListener;

import org.glassfish.hk2.api.ServiceLocator;


public abstract class GenericHk2LocatorManager implements Hk2LocatorManager, InjectionTargetListener {

    private final List<Hk2InjectedTarget> injectionTargets;

    private volatile ServiceLocator locator;

    private volatile boolean multipleLocators = false;

    public GenericHk2LocatorManager() {
        injectionTargets = new LinkedList<>();
    }

    @Override
    public void registerLocator(final ServiceLocator locator) {
        if (!multipleLocators) {
            if (this.locator == null) { 
                this.locator = locator;
            } else { 
                this.locator = null;
                multipleLocators = true;
            } 
            for (final Hk2InjectedTarget target : injectionTargets) {
                target.setLocator(this.locator);
            }
        } 
    }

    @Override
    public ServiceLocator getEffectiveLocator() {
        return !multipleLocators ? locator : lookupLocator();
    }

    
    public abstract ServiceLocator lookupLocator();

    @Override
    public void notify(final Hk2InjectedTarget target) {

        injectionTargets.add(target);
    }
}

<code block>


package org.glassfish.jersey.ext.cdi1x.internal;

import javax.ws.rs.WebApplicationException;

import org.glassfish.jersey.ext.cdi1x.internal.spi.Hk2LocatorManager;

import org.glassfish.hk2.api.ServiceLocator;


final class SingleHk2LocatorManager implements Hk2LocatorManager {

    private volatile ServiceLocator locator;

    @Override
    public void registerLocator(final ServiceLocator locator) {
        if (this.locator == null) {
            this.locator = locator;
        } else if (this.locator != locator) {
            throw new WebApplicationException(LocalizationMessages.CDI_MULTIPLE_LOCATORS_INTO_SIMPLE_APP());
        }
    }

    @Override
    public ServiceLocator getEffectiveLocator() {
        return locator;
    }
}

<code block>


package org.glassfish.jersey.ext.cdi1x.internal.spi;

import javax.enterprise.inject.spi.InjectionTarget;

import org.glassfish.hk2.api.ServiceLocator;


public interface Hk2InjectedTarget extends InjectionTarget {

    
    void setLocator(ServiceLocator locator);
}

<code block>


package org.glassfish.jersey.ext.cdi1x.internal;

import javax.annotation.Priority;
import javax.enterprise.inject.spi.BeanManager;

import org.glassfish.jersey.ext.cdi1x.internal.spi.BeanManagerProvider;
import org.glassfish.jersey.ext.cdi1x.internal.spi.Hk2LocatorManager;

import org.glassfish.hk2.api.ServiceLocator;

import org.junit.Test;

import static org.hamcrest.CoreMatchers.instanceOf;
import static org.hamcrest.CoreMatchers.nullValue;
import static org.junit.Assert.assertThat;

import mockit.Mock;
import mockit.MockUp;
import mockit.Mocked;
import mockit.Verifications;


public class CdiUtilTest {

    public static class TestBeanManagerProvider implements BeanManagerProvider {

        @Override
        public BeanManager getBeanManager() {
            throw new RuntimeException("BeanManager!");
        }
    }

    @Test
    public void getBeanManagerCustom(@Mocked final TestBeanManagerProvider custom,
                                     @Mocked final DefaultBeanManagerProvider fallback) throws Exception {
        CdiUtil.getBeanManager();

        new Verifications() {{
            custom.getBeanManager(); times = 1;
            fallback.getBeanManager(); times = 0;
        }};
    }

    @Test
    public void getDefaultBeanManagerDefault(@Mocked final DefaultBeanManagerProvider fallback) throws Exception {
        new MockUp<CdiUtil>() {
            @Mock
            @SuppressWarnings("UnusedDeclaration")
            <T> T lookupService(final Class<T> clazz) {
                return null;
            }
        };

        CdiUtil.getBeanManager();

        new Verifications() {{
            fallback.getBeanManager(); times = 1;
        }};
    }

    @Priority(500)
    public static class MyServiceOne implements MyService {
    }

    @Priority(100)
    public static class MyServiceTwo implements MyService {
    }

    @Priority(300)
    public static class MyServiceThree implements MyService {
    }

    @Test
    public void testLookupService() throws Exception {
        assertThat(CdiUtil.lookupService(MyService.class), instanceOf(MyServiceTwo.class));
    }

    @Test
    public void testLookupServiceNegative() throws Exception {
        assertThat(CdiUtil.lookupService(CdiUtil.class), nullValue());
    }

    public static class TestHk2LocatorManager implements Hk2LocatorManager {

        @Override
        public void registerLocator(final ServiceLocator locator) {
        }

        @Override
        public ServiceLocator getEffectiveLocator() {
            return null;
        }
    }

    @Test
    public void createHk2LocatorManagerCustom() throws Exception {
        assertThat(CdiUtil.createHk2LocatorManager(), instanceOf(TestHk2LocatorManager.class));
    }

    @Test
    public void createHk2LocatorManagerDefault() throws Exception {
        new MockUp<CdiUtil>() {
            @Mock
            @SuppressWarnings("UnusedDeclaration")
            <T> T lookupService(final Class<T> clazz) {
                return null;
            }
        };

        assertThat(CdiUtil.createHk2LocatorManager(), instanceOf(SingleHk2LocatorManager.class));
    }
}

<code block>

package org.glassfish.jersey.ext.cdi1x.servlet.internal;

import javax.enterprise.context.ApplicationScoped;

import org.glassfish.jersey.ext.cdi1x.internal.JerseyVetoed;
import org.glassfish.jersey.server.spi.ExternalRequestContext;
import org.glassfish.jersey.server.spi.ExternalRequestScope;

import org.glassfish.hk2.api.ServiceLocator;


@ApplicationScoped
@JerseyVetoed
public class CdiExternalRequestScope implements ExternalRequestScope<Object> {

    public static final ThreadLocal<ServiceLocator> actualServiceLocator = new ThreadLocal<>();

    @Override
    public ExternalRequestContext<Object> open(ServiceLocator serviceLocator) {
        actualServiceLocator.set(serviceLocator);
        return new ExternalRequestContext<>(null);
    }

    @Override
    public void resume(final ExternalRequestContext<Object> ctx, ServiceLocator serviceLocator) {
        actualServiceLocator.set(serviceLocator);
    }

    @Override
    public void suspend(final ExternalRequestContext<Object> ctx, ServiceLocator serviceLocator) {
        actualServiceLocator.remove();
    }

    @Override
    public void close() {
        actualServiceLocator.remove();
    }
}

<code block>


package org.glassfish.jersey.ext.cdi1x.servlet.internal;

import org.glassfish.jersey.ext.cdi1x.internal.GenericHk2LocatorManager;

import org.glassfish.hk2.api.ServiceLocator;


public class ServletHk2LocatorManager extends GenericHk2LocatorManager {

    @Override
    public ServiceLocator lookupLocator() {
        return CdiExternalRequestScope.actualServiceLocator.get();
    }
}

<code block>


package org.glassfish.jersey.ext.cdi1x.servlet.internal;

import java.lang.annotation.Annotation;
import java.lang.reflect.Type;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

import javax.enterprise.context.Dependent;
import javax.enterprise.context.spi.CreationalContext;
import javax.enterprise.event.Observes;
import javax.enterprise.inject.Any;
import javax.enterprise.inject.Default;
import javax.enterprise.inject.spi.AfterBeanDiscovery;
import javax.enterprise.inject.spi.AnnotatedType;
import javax.enterprise.inject.spi.Bean;
import javax.enterprise.inject.spi.BeanManager;
import javax.enterprise.inject.spi.BeforeBeanDiscovery;
import javax.enterprise.inject.spi.Extension;
import javax.enterprise.inject.spi.InjectionPoint;
import javax.enterprise.inject.spi.InjectionTarget;
import javax.enterprise.util.AnnotationLiteral;


public class CdiExternalRequestScopeExtension implements Extension {

    public static final AnnotationLiteral<Default> DEFAULT_ANNOTATION_LITERAL = new AnnotationLiteral<Default>() {};
    public static final AnnotationLiteral<Any> ANY_ANNOTATION_LITERAL = new AnnotationLiteral<Any>() {};

    private AnnotatedType<CdiExternalRequestScope> requestScopeType;

    
    private void beforeBeanDiscovery(@Observes BeforeBeanDiscovery beforeBeanDiscoveryEvent, final BeanManager beanManager) {
        requestScopeType = beanManager.createAnnotatedType(CdiExternalRequestScope.class);
        beforeBeanDiscoveryEvent.addAnnotatedType(requestScopeType);
    }

    
    private void afterBeanDiscovery(@Observes AfterBeanDiscovery afterBeanDiscovery, BeanManager beanManager) {

        
        final InjectionTarget<CdiExternalRequestScope> interceptorTarget = beanManager.createInjectionTarget(requestScopeType);


        afterBeanDiscovery.addBean(new Bean<CdiExternalRequestScope>() {

            @Override
            public Class<?> getBeanClass() {
                return CdiExternalRequestScope.class;
            }

            @Override
            public Set<InjectionPoint> getInjectionPoints() {
                return interceptorTarget.getInjectionPoints();
            }

            @Override
            public String getName() {
                return "CdiExternalRequestScope";
            }

            @Override
            public Set<Annotation> getQualifiers() {
                return new HashSet<Annotation>() {{
                    add(DEFAULT_ANNOTATION_LITERAL);
                    add(ANY_ANNOTATION_LITERAL);
                }};
            }

            @Override
            public Class<? extends Annotation> getScope() {
                return Dependent.class;
            }

            @Override
            public Set<Class<? extends Annotation>> getStereotypes() {
                return Collections.emptySet();
            }

            @Override
            public Set<Type> getTypes() {
                return new HashSet<Type>() {{
                    add(CdiExternalRequestScope.class);
                    add(Object.class);
                }};
            }

            @Override
            public boolean isAlternative() {
                return false;
            }

            @Override
            public boolean isNullable() {
                return false;
            }

            @Override
            public CdiExternalRequestScope create(CreationalContext<CdiExternalRequestScope> ctx) {

                final CdiExternalRequestScope result = interceptorTarget.produce(ctx);
                interceptorTarget.inject(result, ctx);
                interceptorTarget.postConstruct(result);
                return result;
            }


            @Override
            public void destroy(CdiExternalRequestScope instance,
                                CreationalContext<CdiExternalRequestScope> ctx) {

                interceptorTarget.preDestroy(instance);
                interceptorTarget.dispose(instance);
                ctx.release();
            }
        });
    }
}
<code block>


package org.glassfish.jersey.tests.integration.multimodule.cdi.web2;

import java.util.HashSet;
import java.util.Set;

import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;


@ApplicationPath("one")
public class JaxRsAppOne extends Application {

    @Override
    public Set<Class<?>> getClasses() {
        return new HashSet<Class<?>>() {{
            add(SharedRequestScopedJaxRsResource.class);
            add(SharedAppScopedJaxRsResource.class);
        }};
    }
}


<code block>


package org.glassfish.jersey.tests.integration.multimodule.cdi.web2;

import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;

import org.glassfish.jersey.tests.integration.multimodule.cdi.lib.JaxRsInjectedDependentBean;
import org.glassfish.jersey.tests.integration.multimodule.cdi.lib.JaxRsInjectedRequestScopedBean;


@Path("app-scoped")
@ApplicationScoped
public class SharedAppScopedJaxRsResource {

    @Inject
    JaxRsInjectedDependentBean dependentBean;

    @Inject
    JaxRsInjectedRequestScopedBean reqScopedBean;

    @Path("req/header")
    @GET
    public String getReqHeader() {
        return reqScopedBean.getTestHeader();
    }

    @Path("dependent/header")
    @GET
    public String getDependentHeader() {
        return dependentBean.getTestHeader();
    }

    @Path("req/uri/{p}")
    @GET
    public String getReqUri() {
        return reqScopedBean.getUriInfo().getRequestUri().toString();
    }

    @Path("dependent/uri/{p}")
    @GET
    public String getAppUri() {
        return dependentBean.getUriInfo().getRequestUri().toString();
    }
}
<code block>


package org.glassfish.jersey.tests.integration.multimodule.cdi.web2;

import java.util.HashSet;
import java.util.Set;

import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;


@ApplicationPath("two")
public class JaxRsAppTwo extends Application {

    @Override
    public Set<Class<?>> getClasses() {
        return new HashSet<Class<?>>() {{
            add(SharedRequestScopedJaxRsResource.class);
            add(SharedAppScopedJaxRsResource.class);
        }};
    }
}


<code block>


package org.glassfish.jersey.tests.integration.multimodule.cdi.web2;

import javax.enterprise.context.RequestScoped;
import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;

import org.glassfish.jersey.tests.integration.multimodule.cdi.lib.JaxRsInjectedDependentBean;
import org.glassfish.jersey.tests.integration.multimodule.cdi.lib.JaxRsInjectedRequestScopedBean;


@Path("request-scoped")
@RequestScoped
public class SharedRequestScopedJaxRsResource {

    @Inject
    JaxRsInjectedDependentBean dependentBean;

    @Inject
    JaxRsInjectedRequestScopedBean reqScopedBean;

    @Path("req/header")
    @GET
    public String getReqHeader() {
        return reqScopedBean.getTestHeader();
    }

    @Path("dependent/header")
    @GET
    public String getDependentHeader() {
        return dependentBean.getTestHeader();
    }

    @Path("req/uri/{p}")
    @GET
    public String getReqUri() {
        return reqScopedBean.getUriInfo().getRequestUri().toString();
    }

    @Path("dependent/uri/{p}")
    @GET
    public String getAppUri() {
        return dependentBean.getUriInfo().getRequestUri().toString();
    }
}

<code block>


package org.glassfish.jersey.tests.integration.multimodule.cdi.web2;

import java.net.URI;

import javax.ws.rs.core.Application;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.UriBuilder;

import org.glassfish.jersey.client.ClientConfig;
import org.glassfish.jersey.filter.LoggingFilter;
import org.glassfish.jersey.test.JerseyTest;

import org.junit.Ignore;
import org.junit.Test;

import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.MatcherAssert.assertThat;


public class JaxRsCdiIntegrationTest extends JerseyTest {

    @Override
    protected Application configure() {
        return new JaxRsAppOne();
    }






    @Override
    protected void configureClient(final ClientConfig config) {
        config.register(LoggingFilter.class);
    }

    @Test
    public void testUriInfoInjectionReqScopedResourceDependentBean() {

        _testResource("cdi-multimodule-war2/one/request-scoped/dependent");
        _testResource("cdi-multimodule-war2/two/request-scoped/dependent");
    }

    @Test
    public void testUriInfoInjectionReqScopedResourceRequestScopedBean() {

        _testResource("cdi-multimodule-war2/one/request-scoped/req");
        _testResource("cdi-multimodule-war2/two/request-scoped/req");
    }

    @Test
    public void testUriInfoInjectionAppScopedResourceRequestScopedBean() {

        _testResource("cdi-multimodule-war2/one/app-scoped/req");
        _testResource("cdi-multimodule-war2/two/app-scoped/req");
    }

    @Ignore("until JERSEY-2914 gets resolved")
    @Test
    public void testUriInfoInjectionAppScopedResourceDependentBean() {

        _testResource("cdi-multimodule-war2/one/app-scoped/dependent");
        _testResource("cdi-multimodule-war2/two/app-scoped/dependent");
    }

    private void _testResource(String resourcePath) {
        _testUriInfo(resourcePath);
        _testHeader(resourcePath);
    }

    private void _testUriInfo(String resourcePath) {

        _testSinglePathUriUnfo(resourcePath, "one");
        _testSinglePathUriUnfo(resourcePath, "two");
        _testSinglePathUriUnfo(resourcePath, "three");
    }

    private void _testSinglePathUriUnfo(final String resourcePath, final String pathParam) {

        final URI baseUri = getBaseUri();
        final String expectedResult = baseUri.resolve(resourcePath + "/uri/" + pathParam).toString();

        final Response response = target().path(resourcePath).path("uri").path(pathParam).request().get();
        assertThat(response.getStatus(), is(200));
        assertThat(response.readEntity(String.class), equalTo(expectedResult));
    }

    private void _testHeader(final String resourcePath) {

        _testSingleHeader(resourcePath, "one");
        _testSingleHeader(resourcePath, "two");
        _testSingleHeader(resourcePath, "three");
    }

    private void _testSingleHeader(final String resourcePath, final String headerValue) {

        final String expectedResult = headerValue;

        final Response response = target().path(resourcePath).path("header").request().header("x-test", headerValue).get();
        assertThat(response.getStatus(), is(200));
        assertThat(response.readEntity(String.class), equalTo(expectedResult));
    }
}

<code block>


package org.glassfish.jersey.tests.integration.multimodule.cdi.web1;

import java.util.HashSet;
import java.util.Set;

import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;


@ApplicationPath("/")
public class JaxRsApp extends Application {

    @Override
    public Set<Class<?>> getClasses() {
        return new HashSet<Class<?>>() {{
            add(RequestScopedJaxRsResource.class);
            add(AppScopedJaxRsResource.class);
        }};
    }
}

<code block>


package org.glassfish.jersey.tests.integration.multimodule.cdi.web1;

import javax.enterprise.context.RequestScoped;
import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;

import org.glassfish.jersey.tests.integration.multimodule.cdi.lib.JaxRsInjectedDependentBean;
import org.glassfish.jersey.tests.integration.multimodule.cdi.lib.JaxRsInjectedRequestScopedBean;


@Path("request-scoped")
@RequestScoped
public class RequestScopedJaxRsResource {

    @Inject
    JaxRsInjectedDependentBean dependentBean;

    @Inject
    JaxRsInjectedRequestScopedBean reqScopedBean;

    @Path("req/header")
    @GET
    public String getReqHeader() {
        return reqScopedBean.getTestHeader();
    }

    @Path("dependent/header")
    @GET
    public String getDependentHeader() {
        return dependentBean.getTestHeader();
    }

    @Path("req/uri/{p}")
    @GET
    public String getReqUri() {
        return reqScopedBean.getUriInfo().getRequestUri().toString();
    }

    @Path("dependent/uri/{p}")
    @GET
    public String getAppUri() {
        return dependentBean.getUriInfo().getRequestUri().toString();
    }
}

<code block>


package org.glassfish.jersey.tests.integration.multimodule.cdi.web1;

import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;

import org.glassfish.jersey.tests.integration.multimodule.cdi.lib.JaxRsInjectedDependentBean;
import org.glassfish.jersey.tests.integration.multimodule.cdi.lib.JaxRsInjectedRequestScopedBean;


@Path("app-scoped")
@ApplicationScoped
public class AppScopedJaxRsResource {

    @Inject
    JaxRsInjectedRequestScopedBean reqScopedBean;

    @Path("req/header")
    @GET
    public String getReqHeader() {
        return reqScopedBean.getTestHeader();
    }

    @Path("req/uri/{p}")
    @GET
    public String getReqUri() {
        return reqScopedBean.getUriInfo().getRequestUri().toString();
    }

}

<code block>


package org.glassfish.jersey.tests.integration.multimodule.cdi.web1;

import java.net.URI;

import javax.ws.rs.core.Application;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.UriBuilder;

import org.glassfish.jersey.client.ClientConfig;
import org.glassfish.jersey.filter.LoggingFilter;
import org.glassfish.jersey.test.JerseyTest;

import org.junit.Test;
import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.MatcherAssert.assertThat;


public class JaxRsCdiIntegrationTest extends JerseyTest {

    @Override
    protected Application configure() {
        return new JaxRsApp();
    }

    @Override
    protected URI getBaseUri() {
        return UriBuilder.fromUri(super.getBaseUri()).path("cdi-multimodule-war1").build();
    }

    @Override
    protected void configureClient(final ClientConfig config) {
        config.register(LoggingFilter.class);
    }

    @Test
    public void testUriInfoInjectionReqScopedResourceDependentBean() {
        _testResource("request-scoped/dependent");
    }

    @Test
    public void testUriInfoInjectionReqScopedResourceRequestScopedBean() {
        _testResource("request-scoped/req");
    }

    @Test
    public void testUriInfoInjectionAppScopedResourceRequestScopedBean() {
        _testResource("app-scoped/req");
    }

    private void _testResource(String resourcePath) {
        _testUriInfo(resourcePath);
        _testHeader(resourcePath);
    }

    private void _testUriInfo(String resourcePath) {

        _testSinglePathUriUnfo(resourcePath, "one");
        _testSinglePathUriUnfo(resourcePath, "two");
        _testSinglePathUriUnfo(resourcePath, "three");
    }

    private void _testSinglePathUriUnfo(final String resourcePath, final String pathParam) {

        final URI baseUri = getBaseUri();
        final String expectedResult = baseUri.resolve(resourcePath + "/uri/" + pathParam).toString();

        final Response response = target().path(resourcePath).path("uri").path(pathParam).request().get();
        assertThat(response.getStatus(), is(200));
        assertThat(response.readEntity(String.class), equalTo(expectedResult));
    }

    private void _testHeader(final String resourcePath) {

        _testSingleHeader(resourcePath, "one");
        _testSingleHeader(resourcePath, "two");
        _testSingleHeader(resourcePath, "three");
    }

    private void _testSingleHeader(final String resourcePath, final String headerValue) {

        final String expectedResult = headerValue;

        final Response response = target().path(resourcePath).path("header").request().header("x-test", headerValue).get();
        assertThat(response.getStatus(), is(200));
        assertThat(response.readEntity(String.class), equalTo(expectedResult));
    }
}

<code block>


package org.glassfish.jersey.tests.integration.multimodule.cdi.lib;

import javax.enterprise.context.RequestScoped;
import javax.ws.rs.HeaderParam;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.UriInfo;


@RequestScoped
public class JaxRsInjectedRequestScopedBean {

    @Context
    UriInfo uriInfo;

    @HeaderParam("x-test")
    String testHeader;

    
    public UriInfo getUriInfo() {
        return uriInfo;
    }

    
    public String getTestHeader() {
        return testHeader;
    }
}

<code block>


package org.glassfish.jersey.tests.integration.multimodule.cdi.lib;

import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.context.RequestScoped;
import javax.inject.Inject;
import javax.ws.rs.HeaderParam;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.Request;
import javax.ws.rs.core.UriInfo;


public class JaxRsInjectedDependentBean {

    @Context
    UriInfo uriInfo;

    @HeaderParam("x-test")
    String testHeader;

    
    public UriInfo getUriInfo() {
        return uriInfo;
    }

    
    public String getTestHeader() {
        return testHeader;
    }

}

<code block>

package org.glassfish.jersey.tests.cdi.bv;

import javax.enterprise.context.RequestScoped;
import javax.validation.constraints.NotNull;
import javax.validation.executable.ExecutableType;
import javax.validation.executable.ValidateOnExecution;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Context;


@Path("old/fashioned")
@RequestScoped
public class CdiOldFashionedResource {

    
    @Path("validate")
    @GET
    @ValidateOnExecution(type = ExecutableType.NONE)
    public String getQ(@QueryParam("q") @NotNull String q) {

        return q;
    }
}

<code block>

package org.glassfish.jersey.tests.cdi.bv;

import javax.enterprise.inject.Vetoed;
import javax.validation.constraints.NotNull;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Context;


@Path("validated/property")
@Vetoed
public class Hk2PropertyInjectedResource {

    @QueryParam("q")
    @NotNull
    String q;

    ValidationResult validationResult;

    public ValidationResult getValidationResult() {
        return validationResult;
    }

    @Context
    public void setValidationResult(ValidationResult validationResult) {
        this.validationResult = validationResult;
    }

    
    @Path("validate")
    @GET
    public int getValidate() {
        return validationResult.getViolationCount();
    }
}

<code block>

package org.glassfish.jersey.tests.cdi.bv;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;

import javax.enterprise.inject.Vetoed;
import javax.inject.Inject;
import javax.inject.Provider;
import javax.inject.Singleton;
import javax.validation.ConstraintViolationException;
import javax.validation.ValidationException;
import javax.ws.rs.core.Context;

import org.glassfish.jersey.server.spi.ValidationInterceptorContext;
import org.glassfish.jersey.server.spi.ValidationInterceptor;

import org.glassfish.hk2.api.Factory;
import org.glassfish.hk2.api.PerLookup;
import org.glassfish.hk2.utilities.binding.AbstractBinder;


@Vetoed
public class Hk2ValidationInterceptor implements ValidationInterceptor {


    private final Provider<Hk2ValidationResult> validationResult;

    public Hk2ValidationInterceptor(Provider<Hk2ValidationResult> validationResult) {
        this.validationResult = validationResult;
    }

    public static class Binder extends AbstractBinder {

        @Override
        protected void configure() {
            bindFactory(ValidationInterceptorFactory.class, Singleton.class)
                    .to(ValidationInterceptor.class).in(PerLookup.class);
        }

    }

    private static class ValidationInterceptorFactory implements Factory<ValidationInterceptor> {

        @Inject
        Provider<Hk2ValidationResult> validationResultProvider;

        @Override
        public ValidationInterceptor provide() {

            return new Hk2ValidationInterceptor(validationResultProvider);
        }

        @Override
        public void dispose(ValidationInterceptor validationInterceptor) {
        }
    }

    @Override
    public void onValidate(
            ValidationInterceptorContext ctx) throws ValidationException {
        try {
            ctx.proceed();
        } catch (ConstraintViolationException ex) {
            ensureValidationResultInjected(ctx, ex);
            validationResult.get().setViolations(ex.getConstraintViolations());
        }
    }

    private void ensureValidationResultInjected(
            final ValidationInterceptorContext ctx, final ConstraintViolationException ex) {

        if (!isValidationResultInArgs(ctx.getArgs())
                && !isValidationResultInResource(ctx)
                && !hasValidationResultProperty(ctx.getResource())) {

            throw ex;
        }
    }

    private boolean isValidationResultInResource(ValidationInterceptorContext ctx) {
        Class<?> clazz = ctx.getResource().getClass();
        do {
            for (Field f : clazz.getDeclaredFields()) {
                
                if (ValidationResult.class.isAssignableFrom(f.getType())
                        && f.getAnnotation(Context.class) != null) {
                    return true;
                }
            }
            clazz = clazz.getSuperclass();
        } while (clazz != Object.class);
        return false;
    }

    private boolean isValidationResultInArgs(Object[] args) {
        for (Object a : args) {
            if (a != null && ValidationResult.class.isAssignableFrom(a.getClass())) {
                return true;
            }
        }
        return false;
    }

    
    public static boolean hasValidationResultProperty(final Object resource) {
        return getValidationResultGetter(resource) != null && getValidationResultSetter(resource) != null;
    }

    
    public static Method getValidationResultGetter(final Object resource) {
        Class<?> clazz = resource.getClass();
        do {
            for (Method m : clazz.getDeclaredMethods()) {
                if (isValidationResultGetter(m)) {
                    return m;
                }
            }
            clazz = clazz.getSuperclass();
        } while (clazz != Object.class);
        return null;
    }

    
    private static boolean isValidationResultGetter(Method m) {
        return m.getName().startsWith("get")
                && ValidationResult.class.isAssignableFrom(m.getReturnType())
                && Modifier.isPublic(m.getModifiers()) && m.getParameterTypes().length == 0;
    }

    
    public static Method getValidationResultSetter(final Object resource) {
        Class<?> clazz = resource.getClass();
        do {
            for (Method m : clazz.getDeclaredMethods()) {
                if (isValidationResultSetter(m)) {
                    return m;
                }
            }
            clazz = clazz.getSuperclass();
        } while (clazz != Object.class);
        return null;
    }

    
    private static boolean isValidationResultSetter(Method m) {
        return m.getName().startsWith("set") && m.getParameterTypes().length == 1
                && ValidationResult.class.isAssignableFrom(m.getParameterTypes()[0])
                && m.getReturnType() == Void.TYPE && Modifier.isPublic(m.getModifiers())
                && m.getAnnotation(Context.class) != null;
    }

}

<code block>

package org.glassfish.jersey.tests.cdi.bv;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Set;

import javax.enterprise.inject.Vetoed;
import javax.enterprise.inject.spi.BeanManager;
import javax.inject.Inject;
import javax.validation.ConstraintViolation;


@Vetoed
public final class ValidationResultUtil {

    private static final String VALIDATION_RESULT = ValidationResult.class.getName();

    private ValidationResultUtil() {
        throw new AssertionError("Instantiation not allowed.");
    }

    
    public static Field getValidationResultField(final Object resource) {
        Class<?> clazz = resource.getClass();
        do {
            for (Field f : clazz.getDeclaredFields()) {
                
                if (f.getType().getName().equals(VALIDATION_RESULT)
                        && f.getAnnotation(Inject.class) != null) {
                    return f;
                }
            }
            clazz = clazz.getSuperclass();
        } while (clazz != Object.class);
        return null;
    }

    
    public static void updateValidationResultField(Object resource, Field field,
                                                   Set<ConstraintViolation<?>> constraints) {
        try {
            field.setAccessible(true);
            final Object obj = field.get(resource);
            Method setter;
            try {
                setter = obj.getClass().getMethod("setViolations", Set.class);
            } catch (NoSuchMethodException e) {
                setter = obj.getClass().getSuperclass().getMethod("setViolations", Set.class);
            }
            setter.invoke(obj, constraints);
        } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {
            
            System.out.println("Damn it...");
        } catch (Throwable t) {
            System.out.println("What the heck...");
        }
    }

    
    public static void updateValidationResultProperty(Object resource, Method getter,
                                                      Set<ConstraintViolation<?>> constraints) {
        try {
            final Object obj = getter.invoke(resource);
            Method setViolations;
            try {
                setViolations = obj.getClass().getMethod("setViolations", Set.class);
            } catch (NoSuchMethodException e) {
                setViolations = obj.getClass().getSuperclass().getMethod("setViolations", Set.class);
            }
            setViolations.invoke(obj, constraints);

            final Method setter = getValidationResultSetter(resource);

            if (setter != null) {
                setter.invoke(resource, obj);
            }
        } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {
            
        }
    }

    
    public static boolean hasValidationResultProperty(final Object resource) {
        return getValidationResultGetter(resource) != null && getValidationResultSetter(resource) != null;
    }

    
    public static Method getValidationResultGetter(final Object resource) {
        Class<?> clazz = resource.getClass();
        do {
            for (Method m : clazz.getDeclaredMethods()) {
                if (isValidationResultGetter(m)) {
                    return m;
                }
            }
            clazz = clazz.getSuperclass();
        } while (clazz != Object.class);
        return null;
    }

    
    private static boolean isValidationResultGetter(Method m) {
        return m.getName().startsWith("get")
                && m.getReturnType().getName().equals(VALIDATION_RESULT)
                && Modifier.isPublic(m.getModifiers()) && m.getParameterTypes().length == 0;
    }

    
    public static Method getValidationResultSetter(final Object resource) {
        return getValidationResultSetter(resource.getClass());
    }

    private static Method getValidationResultSetter(final Class<?> resourceClass) {
        Class<?> clazz = resourceClass;
        do {
            for (Method m : clazz.getDeclaredMethods()) {
                if (isValidationResultSetter(m)) {
                    return m;
                }
            }
            clazz = clazz.getSuperclass();
        } while (clazz != Object.class);
        return null;
    }

    
    private static boolean isValidationResultSetter(Method m) {
        return m.getName().startsWith("set") && m.getParameterTypes().length == 1
                && m.getParameterTypes()[0].getName().equals(VALIDATION_RESULT)
                && m.getReturnType() == Void.TYPE && Modifier.isPublic(m.getModifiers())
                && m.getAnnotation(Inject.class) != null;
    }
}

<code block>

package org.glassfish.jersey.tests.cdi.bv;

import javax.enterprise.inject.Vetoed;
import javax.validation.constraints.NotNull;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Context;


@Path("validated/param")
@Vetoed
public class Hk2ParamInjectedResource {

    
    @Path("validate")
    @GET
    public int getValidate(@QueryParam("q") @NotNull String q, @Context Hk2ValidationResult validationResult) {

        return validationResult.getViolationCount();
    }
}

<code block>

package org.glassfish.jersey.tests.cdi.bv;

import javax.enterprise.context.RequestScoped;

import javax.inject.Inject;
import javax.validation.ConstraintViolationException;
import javax.validation.constraints.NotNull;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.QueryParam;


@Path("validated/field")
@RequestScoped
public class CdiFieldInjectedResource {

    @Inject
    ValidationResult validationResult;

    @Inject
    NonJaxRsValidatedBean cdiBean;

    @QueryParam("q")
    @NotNull
    String q;

    
    @Path("validate")
    @GET
    public int getValidate() {

        return validationResult.getViolationCount();
    }

    
    @Path("validate/non-jaxrs")
    @GET
    public int getValidateNonJaxRs(@QueryParam("h") String h) {

        try {
            cdiBean.echo(h);
            return 0;
        } catch (ConstraintViolationException ex) {
            return ex.getConstraintViolations().size();
        }
    }

}

<code block>


package org.glassfish.jersey.tests.cdi.bv;

import javax.enterprise.context.RequestScoped;
import javax.validation.constraints.NotNull;


@RequestScoped
public class NonJaxRsValidatedBean {

    public String echo(@NotNull String value) {
        return value;
    }
}

<code block>

package org.glassfish.jersey.tests.cdi.bv;

import javax.enterprise.context.RequestScoped;
import javax.validation.constraints.NotNull;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Context;


@Path("validated/param")
@RequestScoped
public class CdiParamInjectedResource {

    
    @Path("validate")
    @GET
    public int getValidate(@QueryParam("q") @NotNull String q, @Context ValidationResult validationResult) {

        return validationResult.getViolationCount();
    }
}

<code block>

package org.glassfish.jersey.tests.cdi.bv;

import javax.enterprise.inject.Vetoed;
import javax.validation.constraints.NotNull;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Context;


@Path("validated/field")
@Vetoed
public class Hk2FieldInjectedResource {

    @QueryParam("q")
    @NotNull
    String q;

    @Context
    ValidationResult validationResult;

    
    @Path("validate")
    @GET
    public int getValidate() {
        return validationResult.getViolationCount();
    }
}

<code block>

package org.glassfish.jersey.tests.cdi.bv;

import javax.enterprise.inject.Vetoed;
import javax.validation.constraints.NotNull;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Context;


@Path("old/fashioned")
@Vetoed
public class Hk2OldFashionedResource {

    
    @Path("validate")
    @GET
    public String getQ(@QueryParam("q") @NotNull String q) {

        return q;
    }
}

<code block>

package org.glassfish.jersey.tests.cdi.bv;

import javax.enterprise.inject.Vetoed;
import javax.ws.rs.ApplicationPath;

import org.glassfish.jersey.process.internal.RequestScoped;
import org.glassfish.jersey.server.ResourceConfig;

import org.glassfish.hk2.utilities.binding.AbstractBinder;


@ApplicationPath("/hk2")
@Vetoed
public class Hk2Application extends ResourceConfig {

    public Hk2Application() {
        super(Hk2ParamInjectedResource.class,
                Hk2FieldInjectedResource.class,
                Hk2PropertyInjectedResource.class,
                Hk2OldFashionedResource.class);

        register(new Hk2ValidationInterceptor.Binder());
        register(new AbstractBinder(){

            @Override
            protected void configure() {
                bindAsContract(Hk2ValidationResult.class).to(ValidationResult.class).in(RequestScoped.class);
            }
        });
    }

}
<code block>

package org.glassfish.jersey.tests.cdi.bv;

import java.net.URI;

import javax.ws.rs.BadRequestException;
import javax.ws.rs.client.WebTarget;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.UriBuilder;

import org.glassfish.jersey.filter.LoggingFilter;
import org.glassfish.jersey.test.JerseyTest;
import org.glassfish.jersey.test.external.ExternalTestContainerFactory;

import org.junit.Ignore;
import org.junit.Test;
import org.junit.experimental.theories.Theory;

import static org.hamcrest.CoreMatchers.containsString;
import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertThat;


public abstract class BaseValidationTest extends JerseyTest {

    public abstract String getAppPath();

    @Override
    protected URI getBaseUri() {
        return UriBuilder.fromUri(super.getBaseUri()).path("cdi-beanvalidation-webapp").path(getAppPath()).build();
    }

    @Test
    public void testParamValidatedResourceNoParam() throws Exception {
        _testParamValidatedResourceNoParam(target());
    }

    public static void _testParamValidatedResourceNoParam(final WebTarget target) throws Exception {

        Integer errors = target.register(LoggingFilter.class)
                .path("validated").path("param").path("validate")
                .request().get(Integer.class);

        assertThat(errors, is(1));
    }

    @Test
    public void testParamValidatedResourceParamProvided() throws Exception {
        _testParamValidatedResourceParamProvided(target());
    }

    public static void _testParamValidatedResourceParamProvided(WebTarget target) throws Exception {
        Integer errors = target.register(LoggingFilter.class).path("validated").path("field").path("validate")
                .queryParam("q", "one").request().get(Integer.class);
        assertThat(errors, is(0));
    }

    @Test
    public void testFieldValidatedResourceNoParam() throws Exception {
        _testFieldValidatedResourceNoParam(target());
    }

    public static void _testFieldValidatedResourceNoParam(final WebTarget target) throws Exception {

        Integer errors = target.register(LoggingFilter.class)
                .path("validated").path("field").path("validate")
                .request().get(Integer.class);

        assertThat(errors, is(1));
    }

    @Test
    public void testFieldValidatedResourceParamProvided() throws Exception {
        _testFieldValidatedResourceParamProvided(target());
    }

    public static void _testFieldValidatedResourceParamProvided(final WebTarget target) throws Exception {
        Integer errors = target.register(LoggingFilter.class).path("validated").path("field").path("validate")
                .queryParam("q", "one").request().get(Integer.class);
        assertThat(errors, is(0));
    }

    @Test
    public void testPropertyValidatedResourceNoParam() throws Exception {
        _testPropertyValidatedResourceNoParam(target());
    }

    public static void _testPropertyValidatedResourceNoParam(final WebTarget target) throws Exception {

        Integer errors = target.register(LoggingFilter.class)
                .path("validated").path("property").path("validate")
                .request().get(Integer.class);

        assertThat(errors, is(1));
    }

    @Test
    public void testPropertyValidatedResourceParamProvided() throws Exception {
        _testPropertyValidatedResourceParamProvided(target());
    }

    public static void _testPropertyValidatedResourceParamProvided(final WebTarget target) throws Exception {
        Integer errors = target.register(LoggingFilter.class).path("validated").path("property").path("validate")
                .queryParam("q", "one").request().get(Integer.class);
        assertThat(errors, is(0));
    }

    @Test
    public void testOldFashionedResourceNoParam() {
        _testOldFashionedResourceNoParam(target());
    }

    public static void _testOldFashionedResourceNoParam(final WebTarget target) {

        Response response = target.register(LoggingFilter.class)
                .path("old").path("fashioned").path("validate")
                .request().get();

        assertThat(response.getStatus(), is(400));
    }

    @Test
    public void testOldFashionedResourceParamProvided() throws Exception {
        _testOldFashionedResourceParamProvided(target());
    }

    public static void _testOldFashionedResourceParamProvided(final WebTarget target) throws Exception {
        String response = target.register(LoggingFilter.class).path("old").path("fashioned").path("validate")
                .queryParam("q", "one").request().get(String.class);
        assertThat(response, is("one"));
    }

    public static void _testNonJaxRsValidationFieldValidatedResourceNoParam(final WebTarget target) {
        Integer errors = target.register(LoggingFilter.class)
                .path("validated").path("field").path("validate").path("non-jaxrs")
                .queryParam("q", "not-important-just-to-get-this-through-jax-rs").request().get(Integer.class);

        assertThat(errors, is(1));
    }

    public static void _testNonJaxRsValidationFieldValidatedResourceParamProvided(final WebTarget target) {
        Integer errors = target.register(LoggingFilter.class)
                .path("validated").path("field").path("validate").path("non-jaxrs")
                .queryParam("q", "not-important-just-to-get-this-through-jax-rs")
                .queryParam("h", "bummer")
                .request().get(Integer.class);

        assertThat(errors, is(0));
    }
}

<code block>


package org.glassfish.jersey.tests.cdi.bv;

import java.io.IOException;
import java.net.URI;
import java.util.Properties;

import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.client.WebTarget;

import org.glassfish.jersey.grizzly2.httpserver.GrizzlyHttpContainer;
import org.glassfish.jersey.grizzly2.httpserver.GrizzlyHttpContainerProvider;
import org.glassfish.jersey.grizzly2.httpserver.GrizzlyHttpServerFactory;
import org.glassfish.jersey.server.ResourceConfig;
import org.glassfish.jersey.test.TestProperties;

import org.glassfish.grizzly.http.server.HttpHandler;
import org.glassfish.grizzly.http.server.HttpServer;

import org.hamcrest.CoreMatchers;
import org.jboss.weld.environment.se.Weld;

import org.junit.After;
import org.junit.Assume;
import org.junit.Before;
import org.junit.Test;


public class CombinedTest {

    public static final String CDI_URI = "/cdi";
    public static final String HK2_URI = "/hk2";

    public static final String PORT_NUMBER = getSystemProperty(TestProperties.CONTAINER_PORT,
                                                    Integer.toString(TestProperties.DEFAULT_CONTAINER_PORT));

    private static final URI BASE_HK2_URI = URI.create("http:
    private static final URI BASE_CDI_URI = URI.create("http:

    private static final boolean isDefaultTestContainerFactorySet = isDefaultTestContainerFactorySet();

    Weld weld;
    HttpServer cdiServer;

    Client client;
    WebTarget cdiTarget, hk2Target;

    @Before
    public void before() throws IOException {
        if (isDefaultTestContainerFactorySet) {
            initializeWeld();
            startGrizzlyContainer();
            initializeClient();
        }
    }

    @After
    public void after() {
        if (isDefaultTestContainerFactorySet) {
            cdiServer.shutdownNow();
            weld.shutdown();
            client.close();
        }
    }

    @Test
    public void testParamValidatedResourceNoParam() throws Exception {
        Assume.assumeThat(isDefaultTestContainerFactorySet, CoreMatchers.is(true));
        BaseValidationTest._testParamValidatedResourceNoParam(cdiTarget);
        BaseValidationTest._testParamValidatedResourceNoParam(hk2Target);
    }

    @Test
    public void testParamValidatedResourceParamProvided() throws Exception {
        Assume.assumeThat(isDefaultTestContainerFactorySet, CoreMatchers.is(true));
        BaseValidationTest._testParamValidatedResourceParamProvided(cdiTarget);
        BaseValidationTest._testParamValidatedResourceParamProvided(hk2Target);
    }

    @Test
    public void testFieldValidatedResourceNoParam() throws Exception {
        Assume.assumeThat(isDefaultTestContainerFactorySet, CoreMatchers.is(true));
        BaseValidationTest._testFieldValidatedResourceNoParam(cdiTarget);
        BaseValidationTest._testFieldValidatedResourceNoParam(hk2Target);
    }

    @Test
    public void testFieldValidatedResourceParamProvided() throws Exception {
        Assume.assumeThat(isDefaultTestContainerFactorySet, CoreMatchers.is(true));
        BaseValidationTest._testFieldValidatedResourceParamProvided(cdiTarget);
        BaseValidationTest._testFieldValidatedResourceParamProvided(hk2Target);
    }

    @Test
    public void testPropertyValidatedResourceNoParam() throws Exception {
        Assume.assumeThat(isDefaultTestContainerFactorySet, CoreMatchers.is(true));
        BaseValidationTest._testPropertyValidatedResourceNoParam(cdiTarget);
        BaseValidationTest._testPropertyValidatedResourceNoParam(hk2Target);
    }

    @Test
    public void testPropertyValidatedResourceParamProvided() throws Exception {
        Assume.assumeThat(isDefaultTestContainerFactorySet, CoreMatchers.is(true));
        BaseValidationTest._testPropertyValidatedResourceParamProvided(cdiTarget);
        BaseValidationTest._testPropertyValidatedResourceParamProvided(hk2Target);
    }

    @Test
    public void testOldFashionedResourceNoParam() {
        Assume.assumeThat(isDefaultTestContainerFactorySet, CoreMatchers.is(true));
        BaseValidationTest._testOldFashionedResourceNoParam(cdiTarget);
        BaseValidationTest._testOldFashionedResourceNoParam(hk2Target);
    }

    @Test
    public void testOldFashionedResourceParamProvided() throws Exception {
        Assume.assumeThat(isDefaultTestContainerFactorySet, CoreMatchers.is(true));
        BaseValidationTest._testOldFashionedResourceParamProvided(cdiTarget);
        BaseValidationTest._testOldFashionedResourceParamProvided(hk2Target);
    }

    @Test
    public void testNonJaxRsValidationFieldValidatedResourceNoParam() {
        Assume.assumeThat(isDefaultTestContainerFactorySet, CoreMatchers.is(true));
        BaseValidationTest._testNonJaxRsValidationFieldValidatedResourceNoParam(cdiTarget);
    }

    @Test
    public void testNonJaxRsValidationFieldValidatedResourceParamProvided() {
        Assume.assumeThat(isDefaultTestContainerFactorySet, CoreMatchers.is(true));
        BaseValidationTest._testNonJaxRsValidationFieldValidatedResourceParamProvided(cdiTarget);
    }

    private void initializeWeld() {
        weld = new Weld();
        weld.initialize();
    }

    private void startGrizzlyContainer() throws IOException {
        final ResourceConfig cdiConfig = ResourceConfig.forApplicationClass(CdiApplication.class);
        final ResourceConfig hk2Config = ResourceConfig.forApplicationClass(Hk2Application.class);

        cdiServer = GrizzlyHttpServerFactory.createHttpServer(BASE_CDI_URI, cdiConfig, false);
        final HttpHandler hk2Handler = createGrizzlyContainer(hk2Config);
        cdiServer.getServerConfiguration().addHttpHandler(hk2Handler, HK2_URI);
        cdiServer.start();
    }

    private void initializeClient() {
        client = ClientBuilder.newClient();
        cdiTarget = client.target(BASE_CDI_URI);
        hk2Target = client.target(BASE_HK2_URI);
    }

    private GrizzlyHttpContainer createGrizzlyContainer(ResourceConfig resourceConfig) {
        return (new GrizzlyHttpContainerProvider()).createContainer(GrizzlyHttpContainer.class, resourceConfig);
    }

    private static boolean isDefaultTestContainerFactorySet() {
        final String testContainerFactory = getSystemProperty(TestProperties.CONTAINER_FACTORY, null);
        return testContainerFactory == null || TestProperties.DEFAULT_CONTAINER_FACTORY.equals(testContainerFactory);
    }

    private static String getSystemProperty(final String propertyName, final String defaultValue) {
        final Properties systemProperties = System.getProperties();
        return systemProperties.getProperty(propertyName, defaultValue);
    }
}
<code block>

package org.glassfish.jersey.tests.cdi.bv;

import javax.ws.rs.core.Application;

import org.glassfish.jersey.server.ResourceConfig;

import org.junit.Ignore;
import org.junit.Test;


public class RawHk2Test extends BaseValidationTest {

    @Override
    protected Application configure() {
        return ResourceConfig.forApplicationClass(Hk2Application.class);
    }

    @Override
    public String getAppPath() {
        return "hk2";
    }
}

<code block>

package org.glassfish.jersey.tests.cdi.bv;

import java.net.URI;

import javax.ws.rs.client.WebTarget;
import javax.ws.rs.core.Application;

import org.glassfish.jersey.filter.LoggingFilter;
import org.glassfish.jersey.server.ResourceConfig;
import org.glassfish.jersey.test.external.ExternalTestContainerFactory;

import org.jboss.weld.environment.se.Weld;
import org.junit.Test;
import org.junit.runner.JUnitCore;

import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertThat;


public class RawCdiTest extends BaseValidationTest {

    Weld weld;

    @Override
    public void setUp() throws Exception {
        if (!ExternalTestContainerFactory.class.isAssignableFrom(getTestContainerFactory().getClass())) {
            weld = new Weld();
            weld.initialize();
        }
        super.setUp();
    }

    @Override
    public void tearDown() throws Exception {
        if (!ExternalTestContainerFactory.class.isAssignableFrom(getTestContainerFactory().getClass())) {
            weld.shutdown();
        }
        super.tearDown();
    }

    @Override
    protected Application configure() {
        return ResourceConfig.forApplicationClass(CdiApplication.class);
    }

    @Override
    public String getAppPath() {
        return "cdi";
    }

    @Test
    public void testNonJaxRsValidationFieldValidatedResourceNoParam() {
        BaseValidationTest._testNonJaxRsValidationFieldValidatedResourceNoParam(target());
    }

    @Test
    public void testNonJaxRsValidationFieldValidatedResourceParamProvided() {
        BaseValidationTest._testNonJaxRsValidationFieldValidatedResourceParamProvided(target());
    }
}
<code block>

package org.glassfish.jersey.tests.cdi.resources;

import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.logging.Logger;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.inject.spi.BeanManager;
import javax.inject.Inject;
import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;


@ApplicationPath("secondary")
@ApplicationScoped
public class SecondaryApplication extends Application {


    private static final Logger LOGGER = Logger.getLogger(SecondaryApplication.class.getName());

    @Override
    public Set<Class<?>> getClasses() {
        final Set<Class<?>> classes = new HashSet<Class<?>>();
        classes.add(SecondNonJaxRsBeanInjectedResource.class);
        return classes;
    }
}
<code block>

package org.glassfish.jersey.tests.cdi.resources;

import javax.enterprise.context.RequestScoped;
import javax.ws.rs.HeaderParam;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.UriInfo;


@RequestScoped
public class JaxRsInjectedBean {

    @HeaderParam("x-test")
    String testHeader;

    @Context
    UriInfo uriInfo;

    public UriInfo getUriInfo() {
        return uriInfo;
    }

    public String getTestHeader() {
        return testHeader;
    }
}

<code block>


package org.glassfish.jersey.tests.cdi.resources;

import javax.enterprise.context.RequestScoped;
import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;


@Path("non-jaxrs-bean-injected")
@RequestScoped
public class FirstNonJaxRsBeanInjectedResource {

    @Inject
    JaxRsInjectedBean bean;

    @GET
    @Path("path/1")
    public String getPath() {
        return bean.getUriInfo().getPath();
    }

    @GET
    @Path("header/1")
    public String getAcceptHeader() {
        return bean.getTestHeader();
    }
}

<code block>


package org.glassfish.jersey.tests.cdi.resources;

import javax.enterprise.context.RequestScoped;
import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;


@Path("non-jaxrs-bean-injected")
@RequestScoped
public class SecondNonJaxRsBeanInjectedResource {

    @Inject
    JaxRsInjectedBean bean;

    @GET
    @Path("path/2")
    public String getPath() {
        return bean.getUriInfo().getPath();
    }

    @GET
    @Path("header/2")
    public String getAcceptHeader() {
        return bean.getTestHeader();
    }
}

<code block>

package org.glassfish.jersey.tests.cdi.resources;

import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.logging.Logger;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;

import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.inject.spi.BeanManager;

import javax.inject.Inject;

import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;


@ApplicationPath("main")
@ApplicationScoped
public class MainApplication extends Application {

    static AtomicInteger postConstructCounter = new AtomicInteger();

    @Inject BeanManager bm;

    private static final Logger LOGGER = Logger.getLogger(MainApplication.class.getName());

    @Override
    public Set<Class<?>> getClasses() {
        final Set<Class<?>> classes = new HashSet<Class<?>>();
        classes.add(JCDIBeanDependentResource.class);
        classes.add(JDCIBeanException.class);
        classes.add(JDCIBeanDependentException.class);
        classes.add(JCDIBeanSingletonResource.class);
        classes.add(JCDIBeanPerRequestResource.class);
        classes.add(JCDIBeanExceptionMapper.class);
        classes.add(JCDIBeanDependentSingletonResource.class);
        classes.add(JCDIBeanDependentPerRequestResource.class);
        classes.add(JCDIBeanDependentExceptionMapper.class);
        classes.add(StutteringEchoResource.class);
        classes.add(StutteringEcho.class);
        classes.add(ReversingEchoResource.class);
        classes.add(CounterResource.class);
        classes.add(ConstructorInjectedResource.class);
        classes.add(ProducerResource.class);
        classes.add(FirstNonJaxRsBeanInjectedResource.class);
        return classes;
    }

    
    @PostConstruct
    public void postConstruct() {
        LOGGER.info(String.format("%s: POST CONSTRUCT.", this.getClass().getName()));
        postConstructCounter.incrementAndGet();
        if (bm == null) {
            throw new IllegalStateException("BeanManager should have been injected into a CDI managed bean.");
        }
        if (postConstructCounter.intValue() > 1) {
            throw new IllegalStateException("postConstruct should have been invoked only once on app scoped bean.");
        }
    }

    @PreDestroy
    public void preDestroy() {
        LOGGER.info(String.format("%s: PRE DESTROY.", this.getClass().getName()));
    }
}
<code block>

package org.glassfish.jersey.tests.cdi.resources;

import javax.ws.rs.client.WebTarget;
import javax.ws.rs.core.Response;

import org.junit.Test;

import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;


public class JaxRsInjectedCdiBeanTest extends CdiTest {

    @Test
    public void testPathAndHeader() {
        _testPathAndHeader(target());
    }

    public static void _testPathAndHeader(final WebTarget webTarget) {
        final WebTarget target = webTarget.path("non-jaxrs-bean-injected");

        final Response pathResponse = target.path("path/1").request().get();
        assertThat(pathResponse.getStatus(), is(200));
        final String path = pathResponse.readEntity(String.class);

        assertThat(path, is("non-jaxrs-bean-injected/path/1"));

        final Response headerResponse = target.path("header/1").request().header("x-test", "bummer").get();
        assertThat(headerResponse.getStatus(), is(200));
        final String header = headerResponse.readEntity(String.class);

        assertThat(header, is("bummer"));
    }
}

<code block>

package org.glassfish.jersey.tests.cdi.resources;

import java.net.URI;

import javax.ws.rs.client.WebTarget;
import javax.ws.rs.core.Application;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.UriBuilder;

import org.glassfish.jersey.test.JerseyTest;

import org.jboss.weld.environment.se.Weld;
import org.junit.Test;

import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertThat;


public class SecondJaxRsInjectedCdiBeanTest extends JerseyTest {
    Weld weld;

    @Override
    public void setUp() throws Exception {
        weld = new Weld();
        weld.initialize();
        super.setUp();
    }

    @Override
    public void tearDown() throws Exception {
        weld.shutdown();
        super.tearDown();
    }

    @Override
    protected Application configure() {
        return new SecondaryApplication();
    }

    @Override
    protected URI getBaseUri() {
        return UriBuilder.fromUri(super.getBaseUri()).path("cdi-test-webapp/secondary").build();
    }

    @Test
    public void testPathAndHeader() {
        _testPathAndHeader(target());
    }

    public static void _testPathAndHeader(final WebTarget webTarget) {
        final WebTarget target = webTarget.path("non-jaxrs-bean-injected");

        final Response pathResponse = target.path("path/2").request().get();
        assertThat(pathResponse.getStatus(), is(200));
        final String path = pathResponse.readEntity(String.class);

        assertThat(path, is("non-jaxrs-bean-injected/path/2"));

        final Response headerResponse = target.path("header/2").request().header("x-test", "bummer2").get();
        assertThat(headerResponse.getStatus(), is(200));
        final String header = headerResponse.readEntity(String.class);

        assertThat(header, is("bummer2"));
    }
}

<code block>

package org.glassfish.jersey.tests.cdi.resources;

import java.net.URI;

import javax.ws.rs.core.Application;
import javax.ws.rs.core.UriBuilder;

import org.glassfish.jersey.test.JerseyTest;

import org.jboss.weld.environment.se.Weld;


public class CdiTest extends JerseyTest {

    Weld weld;

    @Override
    public void setUp() throws Exception {
        weld = new Weld();
        weld.initialize();
        super.setUp();
    }

    @Override
    public void tearDown() throws Exception {
        weld.shutdown();
        super.tearDown();
    }

    @Override
    protected Application configure() {
        return new MainApplication();
    }

    @Override
    protected URI getBaseUri() {
        return UriBuilder.fromUri(super.getBaseUri()).path("cdi-test-webapp/main").build();
    }
}


<code block>


package org.glassfish.jersey.tests.cdi.resources;

import java.io.IOException;
import java.net.URI;
import java.util.Properties;

import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.client.WebTarget;

import org.glassfish.jersey.grizzly2.httpserver.GrizzlyHttpContainer;
import org.glassfish.jersey.grizzly2.httpserver.GrizzlyHttpContainerProvider;
import org.glassfish.jersey.grizzly2.httpserver.GrizzlyHttpServerFactory;
import org.glassfish.jersey.server.ResourceConfig;
import org.glassfish.jersey.test.TestProperties;

import org.glassfish.grizzly.http.server.HttpHandler;
import org.glassfish.grizzly.http.server.HttpServer;

import org.hamcrest.CoreMatchers;
import org.jboss.weld.environment.se.Weld;
import org.junit.After;
import org.junit.Assume;
import org.junit.Before;
import org.junit.Test;


public class NonJaxRsBeanJaxRsInjectionTest {

    public static final String MAIN_URI = "/main";
    public static final String SECONDARY_URI = "/secondary";

    public static final String PORT_NUMBER = getSystemProperty(TestProperties.CONTAINER_PORT,
                                                    Integer.toString(TestProperties.DEFAULT_CONTAINER_PORT));

    private static final URI MAIN_APP_URI = URI.create("http:
    private static final URI SECONDARY_APP_URI = URI.create("http:

    private static final boolean isDefaultTestContainerFactorySet = isDefaultTestContainerFactorySet();

    Weld weld;
    HttpServer httpServer;

    Client client;
    WebTarget mainTarget, secondaryTarget;

    @Before
    public void before() throws IOException {
        if (isDefaultTestContainerFactorySet) {
            initializeWeld();
            startGrizzlyContainer();
            initializeClient();
        }
    }

    @After
    public void after() {
        if (isDefaultTestContainerFactorySet) {
            httpServer.shutdownNow();
            weld.shutdown();
            client.close();
        }
    }

    @Test
    public void testPathAndHeader() throws Exception {
        Assume.assumeThat(isDefaultTestContainerFactorySet, CoreMatchers.is(true));
        JaxRsInjectedCdiBeanTest._testPathAndHeader(mainTarget);
        SecondJaxRsInjectedCdiBeanTest._testPathAndHeader(secondaryTarget);
    }

    private void initializeWeld() {
        weld = new Weld();
        weld.initialize();
    }

    private void startGrizzlyContainer() throws IOException {
        final ResourceConfig firstConfig = ResourceConfig.forApplicationClass(MainApplication.class);
        final ResourceConfig secondConfig = ResourceConfig.forApplicationClass(SecondaryApplication.class);

        httpServer = GrizzlyHttpServerFactory.createHttpServer(MAIN_APP_URI, firstConfig, false);
        final HttpHandler secondHandler = createGrizzlyContainer(secondConfig);
        httpServer.getServerConfiguration().addHttpHandler(secondHandler, SECONDARY_URI);
        httpServer.start();
    }

    private GrizzlyHttpContainer createGrizzlyContainer(final ResourceConfig resourceConfig) {
        return (new GrizzlyHttpContainerProvider()).createContainer(GrizzlyHttpContainer.class, resourceConfig);
    }

    private void initializeClient() {
        client = ClientBuilder.newClient();
        mainTarget = client.target(MAIN_APP_URI);
        secondaryTarget = client.target(SECONDARY_APP_URI);
    }

    private static boolean isDefaultTestContainerFactorySet() {
        final String testContainerFactory = getSystemProperty(TestProperties.CONTAINER_FACTORY, null);
        return testContainerFactory == null || TestProperties.DEFAULT_CONTAINER_FACTORY.equals(testContainerFactory);
    }

    private static String getSystemProperty(final String propertyName, final String defaultValue) {
        final Properties systemProperties = System.getProperties();
        return systemProperties.getProperty(propertyName, defaultValue);
    }
}
<code block>

package org.glassfish.jersey.server;

import java.io.IOException;
import java.io.OutputStream;
import java.net.URI;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.ws.rs.HttpMethod;
import javax.ws.rs.InternalServerErrorException;
import javax.ws.rs.NotFoundException;
import javax.ws.rs.ServiceUnavailableException;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.container.AsyncResponse;
import javax.ws.rs.container.CompletionCallback;
import javax.ws.rs.container.ConnectionCallback;
import javax.ws.rs.container.TimeoutHandler;
import javax.ws.rs.core.Configuration;
import javax.ws.rs.core.HttpHeaders;
import javax.ws.rs.core.MultivaluedMap;
import javax.ws.rs.core.Response;
import javax.ws.rs.ext.ExceptionMapper;

import javax.inject.Inject;
import javax.inject.Provider;

import org.glassfish.jersey.internal.inject.Injections;
import org.glassfish.jersey.internal.inject.Providers;
import org.glassfish.jersey.internal.util.Closure;
import org.glassfish.jersey.internal.util.Producer;
import org.glassfish.jersey.internal.util.PropertiesHelper;
import org.glassfish.jersey.internal.util.collection.Ref;
import org.glassfish.jersey.internal.util.collection.Refs;
import org.glassfish.jersey.internal.util.collection.Value;
import org.glassfish.jersey.message.internal.HeaderValueException;
import org.glassfish.jersey.message.internal.MessageBodyProviderNotFoundException;
import org.glassfish.jersey.message.internal.OutboundJaxrsResponse;
import org.glassfish.jersey.message.internal.OutboundMessageContext;
import org.glassfish.jersey.message.internal.TracingLogger;
import org.glassfish.jersey.process.internal.RequestScope;
import org.glassfish.jersey.process.internal.Stage;
import org.glassfish.jersey.process.internal.Stages;
import org.glassfish.jersey.server.internal.LocalizationMessages;
import org.glassfish.jersey.server.internal.ProcessingProviders;
import org.glassfish.jersey.server.internal.ServerTraceEvent;
import org.glassfish.jersey.server.internal.monitoring.EmptyRequestEventBuilder;
import org.glassfish.jersey.server.internal.monitoring.RequestEventBuilder;
import org.glassfish.jersey.server.internal.monitoring.RequestEventImpl;
import org.glassfish.jersey.server.internal.process.AsyncContext;
import org.glassfish.jersey.server.internal.process.Endpoint;
import org.glassfish.jersey.server.internal.process.MappableException;
import org.glassfish.jersey.server.internal.process.RequestProcessingContext;
import org.glassfish.jersey.server.internal.routing.UriRoutingContext;
import org.glassfish.jersey.server.monitoring.ApplicationEventListener;
import org.glassfish.jersey.server.monitoring.RequestEvent;
import org.glassfish.jersey.server.monitoring.RequestEventListener;
import org.glassfish.jersey.server.spi.ContainerResponseWriter;
import org.glassfish.jersey.server.spi.ExternalRequestContext;
import org.glassfish.jersey.server.spi.ExternalRequestScope;
import org.glassfish.jersey.server.spi.ResponseErrorMapper;
import org.glassfish.jersey.spi.ExceptionMappers;

import org.glassfish.hk2.api.ServiceLocator;

import static org.glassfish.jersey.server.internal.process.AsyncContext.State.COMPLETED;
import static org.glassfish.jersey.server.internal.process.AsyncContext.State.RESUMED;
import static org.glassfish.jersey.server.internal.process.AsyncContext.State.RUNNING;
import static org.glassfish.jersey.server.internal.process.AsyncContext.State.SUSPENDED;

import jersey.repackaged.com.google.common.base.Preconditions;


public class ServerRuntime {

    private final Stage<RequestProcessingContext> requestProcessingRoot;
    private final ProcessingProviders processingProviders;

    private final ServiceLocator locator;

    private final ScheduledExecutorService backgroundScheduler;
    private final Provider<ExecutorService> managedAsyncExecutor;

    private final RequestScope requestScope;
    private final ExceptionMappers exceptionMappers;
    private final ApplicationEventListener applicationEventListener;
    private final Configuration configuration;

    private final ExternalRequestScope externalRequestScope;

    private final TracingConfig tracingConfig;
    private final TracingLogger.Level tracingThreshold;

    private final boolean processResponseErrors;

     static final ExternalRequestScope<Object> NOOP_EXTERNAL_REQ_SCOPE = new ExternalRequestScope<Object>() {

        @Override
        public ExternalRequestContext<Object> open(ServiceLocator serviceLocator) {
            return null;
        }

        @Override
        public void close() {
        }

        @Override
        public void suspend(ExternalRequestContext<Object> o, ServiceLocator serviceLocator) {
        }

        @Override
        public void resume(ExternalRequestContext<Object> o, ServiceLocator serviceLocator) {
        }
    };

    
    public static class Builder {

        @Inject
        private ServiceLocator locator;
        @Inject
        @BackgroundScheduler
        private ScheduledExecutorService backgroundScheduler;
        @Inject
        @ManagedAsyncExecutor
        private Provider<ExecutorService> asyncExecutorProvider;
        @Inject
        private RequestScope requestScope;
        @Inject
        private ExceptionMappers exceptionMappers;
        @Inject
        private Configuration configuration;
        @Inject
        private ExternalRequestScope externalRequestScope;

        
        public ServerRuntime build(
                final Stage<RequestProcessingContext> processingRoot,
                final ApplicationEventListener eventListener,
                final ProcessingProviders processingProviders) {

            final ExternalRequestScope externalScope =
                    externalRequestScope != null ? externalRequestScope : NOOP_EXTERNAL_REQ_SCOPE;

            return new ServerRuntime(
                    processingRoot,
                    processingProviders,
                    locator,
                    backgroundScheduler,
                    asyncExecutorProvider,
                    requestScope,
                    exceptionMappers,
                    eventListener,
                    externalScope,
                    configuration);
        }
    }

    private ServerRuntime(final Stage<RequestProcessingContext> requestProcessingRoot,
                          final ProcessingProviders processingProviders,
                          final ServiceLocator locator,
                          final ScheduledExecutorService backgroundScheduler,
                          final Provider<ExecutorService> managedAsyncExecutorProvider,
                          final RequestScope requestScope,
                          final ExceptionMappers exceptionMappers,
                          final ApplicationEventListener applicationEventListener,
                          final ExternalRequestScope externalScope,
                          final Configuration configuration) {
        this.requestProcessingRoot = requestProcessingRoot;
        this.processingProviders = processingProviders;
        this.locator = locator;

        this.backgroundScheduler = backgroundScheduler;
        this.managedAsyncExecutor = managedAsyncExecutorProvider;

        this.requestScope = requestScope;
        this.exceptionMappers = exceptionMappers;
        this.applicationEventListener = applicationEventListener;
        this.externalRequestScope = externalScope;
        this.configuration = configuration;

        this.tracingConfig = TracingUtils.getTracingConfig(configuration);
        this.tracingThreshold = TracingUtils.getTracingThreshold(configuration);

        this.processResponseErrors = PropertiesHelper.isProperty(
                configuration.getProperty(ServerProperties.PROCESSING_RESPONSE_ERRORS_ENABLED));
    }

    
    public void process(final ContainerRequest request) {
        TracingUtils.initTracingSupport(tracingConfig, tracingThreshold, request);
        TracingUtils.logStart(request);

        final UriRoutingContext routingContext = request.getUriRoutingContext();

        RequestEventBuilder monitoringEventBuilder = EmptyRequestEventBuilder.INSTANCE;
        RequestEventListener monitoringEventListener = null;

        if (applicationEventListener != null) {
            monitoringEventBuilder = new RequestEventImpl.Builder()
                    .setContainerRequest(request)
                    .setExtendedUriInfo(routingContext);
            monitoringEventListener = applicationEventListener.onRequest(
                    monitoringEventBuilder.build(RequestEvent.Type.START));
        }

        request.setProcessingProviders(processingProviders);

        final RequestProcessingContext context = new RequestProcessingContext(
                locator,
                request,
                routingContext,
                monitoringEventBuilder,
                monitoringEventListener);

        request.checkState();
        final Responder responder = new Responder(context, ServerRuntime.this);
        final RequestScope.Instance requestScopeInstance = requestScope.createInstance();
        final AsyncResponderHolder asyncResponderHolder =
                new AsyncResponderHolder(responder, externalRequestScope,
                        requestScopeInstance, externalRequestScope.open(locator));
        context.initAsyncContext(asyncResponderHolder);

        requestScope.runInScope(requestScopeInstance, new Runnable() {
            @Override
            public void run() {
                try {
                    
                    
                    OutboundJaxrsResponse.Builder.setBaseUri(request.getBaseUri());

                    final Ref<Endpoint> endpointRef = Refs.emptyRef();
                    final RequestProcessingContext data = Stages.process(context, requestProcessingRoot, endpointRef);

                    final Endpoint endpoint = endpointRef.get();
                    if (endpoint == null) {
                        
                        throw new NotFoundException();
                    }

                    final ContainerResponse response = endpoint.apply(data);

                    if (!asyncResponderHolder.isAsync()) {
                        responder.process(response);
                    } else {
                        externalRequestScope.suspend(asyncResponderHolder.externalContext, locator);
                    }
                } catch (final Throwable throwable) {
                    responder.process(throwable);
                } finally {
                    asyncResponderHolder.release();
                    
                    OutboundJaxrsResponse.Builder.clearBaseUri();
                }
            }
        });
    }

    
    ScheduledExecutorService getBackgroundScheduler() {
        return backgroundScheduler;
    }

    
    private static void ensureAbsolute(final URI location, final MultivaluedMap<String, Object> headers,
                                       final ContainerRequest request) {
        if (location == null || location.isAbsolute()) {
            return;
        }
        
        headers.putSingle(HttpHeaders.LOCATION, request.getBaseUri().resolve(location));
    }

    private static class AsyncResponderHolder implements Value<AsyncContext> {

        private final Responder responder;
        private final ExternalRequestScope externalScope;
        private final RequestScope.Instance scopeInstance;
        private final ExternalRequestContext<?> externalContext;

        private volatile AsyncResponder asyncResponder;

        private AsyncResponderHolder(final Responder responder,
                                     final ExternalRequestScope externalRequestScope,
                                     final RequestScope.Instance scopeInstance,
                                     final ExternalRequestContext<?> externalContext) {
            this.responder = responder;
            this.externalScope = externalRequestScope;
            this.scopeInstance = scopeInstance;
            this.externalContext = externalContext;
        }

        @Override
        public AsyncContext get() {
            final AsyncResponder ar = new AsyncResponder(responder, scopeInstance, externalScope, externalContext);
            asyncResponder = ar;
            return ar;
        }

        public boolean isAsync() {
            final AsyncResponder ar = asyncResponder;
            return ar != null && !ar.isRunning();
        }

        public void release() {
            if (asyncResponder == null) {
                scopeInstance.release();
            }
        }
    }

    private static class Responder {

        private static final Logger LOGGER = Logger.getLogger(Responder.class.getName());

        private final RequestProcessingContext processingContext;
        private final ServerRuntime runtime;

        private final CompletionCallbackRunner completionCallbackRunner = new CompletionCallbackRunner();
        private final ConnectionCallbackRunner connectionCallbackRunner = new ConnectionCallbackRunner();

        private final TracingLogger tracingLogger;

        public Responder(final RequestProcessingContext processingContext, final ServerRuntime runtime) {
            this.processingContext = processingContext;
            this.runtime = runtime;

            this.tracingLogger = TracingLogger.getInstance(processingContext.request());
        }

        public void process(ContainerResponse response) {
            processingContext.monitoringEventBuilder().setContainerResponse(response);
            response = processResponse(response);
            release(response);
        }

        private ContainerResponse processResponse(ContainerResponse response) {
            final Stage<ContainerResponse> respondingRoot = processingContext.createRespondingRoot();

            if (respondingRoot != null) {
                response = Stages.process(response, respondingRoot);
            }
            writeResponse(response);

            
            
            completionCallbackRunner.onComplete(null);
            return response;
        }

        
        public void process(final Throwable throwable) {
            final ContainerRequest request = processingContext.request();
            processingContext.monitoringEventBuilder().setException(throwable, RequestEvent.ExceptionCause.ORIGINAL);
            processingContext.triggerEvent(RequestEvent.Type.ON_EXCEPTION);

            ContainerResponse response = null;
            try {
                final Response exceptionResponse = mapException(throwable);
                try {
                    try {
                        response = convertResponse(exceptionResponse);
                        ensureAbsolute(response.getLocation(), response.getHeaders(), request);
                        processingContext.monitoringEventBuilder().setContainerResponse(response)
                                .setResponseSuccessfullyMapped(true);
                    } finally {
                        processingContext.triggerEvent(RequestEvent.Type.EXCEPTION_MAPPING_FINISHED);
                    }

                    processResponse(response);
                } catch (final Throwable respError) {
                    LOGGER.log(Level.SEVERE, LocalizationMessages.ERROR_PROCESSING_RESPONSE_FROM_ALREADY_MAPPED_EXCEPTION());
                    processingContext.monitoringEventBuilder()
                            .setException(respError, RequestEvent.ExceptionCause.MAPPED_RESPONSE);
                    processingContext.triggerEvent(RequestEvent.Type.ON_EXCEPTION);
                    throw respError;
                }
            } catch (final Throwable responseError) {
                if (throwable != responseError
                        && !(throwable instanceof MappableException && throwable.getCause() == responseError)) {
                    LOGGER.log(Level.FINE, LocalizationMessages.ERROR_EXCEPTION_MAPPING_ORIGINAL_EXCEPTION(), throwable);
                }

                if (!processResponseError(responseError)) {
                    
                    LOGGER.log(Level.FINE, LocalizationMessages.ERROR_EXCEPTION_MAPPING_THROWN_TO_CONTAINER(), responseError);

                    try {
                        request.getResponseWriter().failure(responseError);
                    } finally {
                        completionCallbackRunner.onComplete(responseError);
                    }
                }
            } finally {
                release(response);
            }
        }

        
        private boolean processResponseError(final Throwable responseError) {
            boolean processed = false;

            if (runtime.processResponseErrors) {
                
                final Iterable<ResponseErrorMapper> mappers = Providers.getAllProviders(runtime.locator,
                        ResponseErrorMapper.class);

                try {
                    Response processedError = null;
                    for (final ResponseErrorMapper mapper : mappers) {
                        processedError = mapper.toResponse(responseError);
                        if (processedError != null) {
                            break;
                        }
                    }

                    if (processedError != null) {
                        processResponse(new ContainerResponse(processingContext.request(), processedError));
                        processed = true;
                    }
                } catch (final Throwable throwable) {
                    LOGGER.log(Level.FINE, LocalizationMessages.ERROR_EXCEPTION_MAPPING_PROCESSED_RESPONSE_ERROR(), throwable);
                }
            }

            return processed;
        }

        private ContainerResponse convertResponse(final Response exceptionResponse) {
            final ContainerResponse containerResponse = new ContainerResponse(processingContext.request(), exceptionResponse);
            containerResponse.setMappedFromException(true);
            return containerResponse;
        }

        @SuppressWarnings("unchecked")
        private Response mapException(final Throwable originalThrowable) throws Throwable {
            LOGGER.log(Level.FINER, LocalizationMessages.EXCEPTION_MAPPING_START(), originalThrowable);

            Throwable throwable = originalThrowable;
            boolean inMappable = false;
            boolean mappingNotFound = false;

            do {
                if (throwable instanceof MappableException) {
                    inMappable = true;
                } else if (inMappable || throwable instanceof WebApplicationException) {
                    
                    
                    if (runtime.processResponseErrors && throwable instanceof InternalServerErrorException
                            && throwable.getCause() instanceof MessageBodyProviderNotFoundException) {
                        throw throwable;
                    }
                    Response waeResponse = null;

                    if (throwable instanceof WebApplicationException) {
                        final WebApplicationException webApplicationException = (WebApplicationException) throwable;

                        
                        processingContext.routingContext().setMappedThrowable(throwable);

                        waeResponse = webApplicationException.getResponse();
                        if (waeResponse.hasEntity()) {
                            LOGGER.log(Level.FINE, LocalizationMessages
                                    .EXCEPTION_MAPPING_WAE_ENTITY(waeResponse.getStatus()), throwable);
                            return waeResponse;
                        }
                    }

                    final long timestamp = tracingLogger.timestamp(ServerTraceEvent.EXCEPTION_MAPPING);
                    final ExceptionMapper mapper = runtime.exceptionMappers.findMapping(throwable);
                    if (mapper != null) {
                        processingContext.monitoringEventBuilder().setExceptionMapper(mapper);
                        processingContext.triggerEvent(RequestEvent.Type.EXCEPTION_MAPPER_FOUND);
                        try {
                            final Response mappedResponse = mapper.toResponse(throwable);

                            if (tracingLogger.isLogEnabled(ServerTraceEvent.EXCEPTION_MAPPING)) {
                                tracingLogger.logDuration(ServerTraceEvent.EXCEPTION_MAPPING,
                                        timestamp, mapper, throwable, throwable.getLocalizedMessage(),
                                        mappedResponse != null ? mappedResponse.getStatusInfo() : "-no-response-");
                            }

                            
                            processingContext.routingContext().setMappedThrowable(throwable);

                            if (mappedResponse != null) {
                                
                                if (LOGGER.isLoggable(Level.FINER)) {
                                    final String message = String.format(
                                            "Exception '%s' has been mapped by '%s' to response '%s' (%s:%s).",
                                            throwable.getLocalizedMessage(),
                                            mapper.getClass().getName(),
                                            mappedResponse.getStatusInfo().getReasonPhrase(),
                                            mappedResponse.getStatusInfo().getStatusCode(),
                                            mappedResponse.getStatusInfo().getFamily());
                                    LOGGER.log(Level.FINER, message);
                                }
                                return mappedResponse;
                            } else {
                                return Response.noContent().build();
                            }
                        } catch (final Throwable mapperThrowable) {
                            
                            
                            LOGGER.log(Level.SEVERE, LocalizationMessages.EXCEPTION_MAPPER_THROWS_EXCEPTION(mapper.getClass()),
                                    mapperThrowable);
                            LOGGER.log(Level.SEVERE, LocalizationMessages.EXCEPTION_MAPPER_FAILED_FOR_EXCEPTION(), throwable);
                            return Response.serverError().build();
                        }
                    }

                    if (waeResponse != null) {
                        LOGGER.log(Level.FINE, LocalizationMessages
                                .EXCEPTION_MAPPING_WAE_NO_ENTITY(waeResponse.getStatus()), throwable);

                        return waeResponse;
                    }

                    mappingNotFound = true;
                }
                
                if (throwable instanceof HeaderValueException) {
                    if (((HeaderValueException) throwable).getContext() == HeaderValueException.Context.INBOUND) {
                        return Response.status(Response.Status.BAD_REQUEST).build();
                    }
                }

                if (!inMappable || mappingNotFound) {
                    

                    
                    

                    
                    throw throwable;
                }

                throwable = throwable.getCause();
            } while (throwable != null);
            
            throw originalThrowable;
        }

        private ContainerResponse writeResponse(final ContainerResponse response) {
            final ContainerRequest request = processingContext.request();
            final ContainerResponseWriter writer = request.getResponseWriter();
            ServerRuntime.ensureAbsolute(response.getLocation(), response.getHeaders(),
                    response.getRequestContext());

            if (!response.hasEntity()) {
                tracingLogger.log(ServerTraceEvent.FINISHED, response.getStatusInfo());
                tracingLogger.flush(response.getHeaders());

                writer.writeResponseStatusAndHeaders(0, response);
                setWrittenResponse(response);
                return response;
            }

            final Object entity = response.getEntity();
            boolean skipFinally = false;

            final boolean isHead = request.getMethod().equals(HttpMethod.HEAD);

            try {
                response.setStreamProvider(new OutboundMessageContext.StreamProvider() {
                    @Override
                    public OutputStream getOutputStream(final int contentLength) throws IOException {
                        ServerRuntime.ensureAbsolute(response.getLocation(), response.getHeaders(),
                                response.getRequestContext());
                        final OutputStream outputStream = writer.writeResponseStatusAndHeaders(contentLength, response);
                        return isHead ? null : outputStream;
                    }
                });

                if ((writer.enableResponseBuffering() || isHead) && !response.isChunked()) {
                    response.enableBuffering(runtime.configuration);
                }

                try {
                    response.setEntityStream(request.getWorkers().writeTo(
                            entity,
                            entity.getClass(),
                            response.getEntityType(),
                            response.getEntityAnnotations(),
                            response.getMediaType(),
                            response.getHeaders(),
                            request.getPropertiesDelegate(),
                            response.getEntityStream(),
                            request.getWriterInterceptors()));
                } catch (final MappableException mpe) {
                    if (mpe.getCause() instanceof IOException) {
                        connectionCallbackRunner.onDisconnect(processingContext.asyncContext());
                    }
                    throw mpe;
                }
                tracingLogger.log(ServerTraceEvent.FINISHED, response.getStatusInfo());
                tracingLogger.flush(response.getHeaders());

                setWrittenResponse(response);

            } catch (final Throwable ex) {
                if (response.isCommitted()) {
                    
                    LOGGER.log(Level.SEVERE, LocalizationMessages.ERROR_WRITING_RESPONSE_ENTITY(), ex);
                } else {
                    skipFinally = true;
                    if (ex instanceof RuntimeException) {
                        throw (RuntimeException) ex;
                    } else {
                        throw new MappableException(ex);
                    }
                }
            } finally {
                if (!skipFinally) {
                    boolean close = !response.isChunked();
                    if (response.isChunked()) {
                        try {
                            response.commitStream();
                        } catch (final Exception e) {
                            LOGGER.log(Level.SEVERE, LocalizationMessages.ERROR_COMMITTING_OUTPUT_STREAM(), e);
                            close = true;
                        }

                        final ChunkedOutput chunked = (ChunkedOutput) entity;
                        try {
                            chunked.setContext(
                                    runtime.requestScope,
                                    runtime.requestScope.referenceCurrent(),
                                    request,
                                    response,
                                    connectionCallbackRunner,
                                    processingContext.asyncContextValue());
                        } catch (final IOException ex) {
                            LOGGER.log(Level.SEVERE, LocalizationMessages.ERROR_WRITING_RESPONSE_ENTITY_CHUNK(), ex);
                            close = true;
                        }
                        
                        
                        
                        if (!chunked.isClosed()
                                && !writer.suspend(AsyncResponder.NO_TIMEOUT, TimeUnit.SECONDS, null)) {
                            LOGGER.fine(LocalizationMessages.ERROR_SUSPENDING_CHUNKED_OUTPUT_RESPONSE());
                        }
                    }

                    if (close) {
                        try {
                            
                            
                            response.close();
                        } catch (final Exception e) {
                            LOGGER.log(Level.SEVERE, LocalizationMessages.ERROR_CLOSING_COMMIT_OUTPUT_STREAM(), e);
                        }
                    }
                }
            }

            return response;
        }

        private void setWrittenResponse(final ContainerResponse response) {
            processingContext.monitoringEventBuilder()
                    .setContainerResponse(response)
                    .setSuccess(response.getStatus() < Response.Status.BAD_REQUEST.getStatusCode())
                    .setResponseWritten(true);
        }

        private void release(final ContainerResponse responseContext) {
            try {
                processingContext.closeableService().close();

                
                
                if (responseContext != null && !responseContext.isChunked()) {
                    
                    responseContext.close();
                }

            } catch (final Throwable throwable) {
                LOGGER.log(Level.WARNING, LocalizationMessages.RELEASING_REQUEST_PROCESSING_RESOURCES_FAILED(), throwable);
            } finally {
                runtime.externalRequestScope.close();
                processingContext.triggerEvent(RequestEvent.Type.FINISHED);
            }
        }
    }

    private static class AsyncResponder implements AsyncContext, ContainerResponseWriter.TimeoutHandler, CompletionCallback {

        private static final Logger LOGGER = Logger.getLogger(AsyncResponder.class.getName());

        private static final TimeoutHandler DEFAULT_TIMEOUT_HANDLER = new TimeoutHandler() {
            @Override
            public void handleTimeout(final AsyncResponse asyncResponse) {
                throw new ServiceUnavailableException();
            }
        };

        private final Object stateLock = new Object();
        private State state = RUNNING;
        private boolean cancelled = false;

        private final Responder responder;
        
        private final RequestScope.Instance scopeInstance;
        private final ExternalRequestContext<?> foreignScopeInstance;
        private final ExternalRequestScope requestScopeListener;

        private volatile TimeoutHandler timeoutHandler = DEFAULT_TIMEOUT_HANDLER;

        private final List<AbstractCallbackRunner<?>> callbackRunners;

        public AsyncResponder(final Responder responder,
                              final RequestScope.Instance scopeInstance,
                              final ExternalRequestScope requestScopeListener,
                              final ExternalRequestContext<?> foreignScopeInstance) {
            this.responder = responder;
            this.scopeInstance = scopeInstance;
            this.foreignScopeInstance = foreignScopeInstance;
            this.requestScopeListener = requestScopeListener;

            this.callbackRunners = Collections.unmodifiableList(Arrays.asList(
                    responder.completionCallbackRunner, responder.connectionCallbackRunner));

            responder.completionCallbackRunner.register(this);
        }

        @Override
        public void onTimeout(final ContainerResponseWriter responseWriter) {
            final TimeoutHandler handler = timeoutHandler;
            try {
                synchronized (stateLock) {
                    if (state == SUSPENDED) {
                        handler.handleTimeout(this);
                    }
                }
            } catch (final Throwable throwable) {
                resume(throwable);
            }
        }

        @Override
        public void onComplete(final Throwable throwable) {
            synchronized (stateLock) {
                state = COMPLETED;
            }
        }

        @Override
        public void invokeManaged(final Producer<Response> producer) {
            responder.runtime.managedAsyncExecutor.get().submit(new Runnable() {
                @Override
                public void run() {
                    responder.runtime.requestScope.runInScope(scopeInstance, new Runnable() {
                        @Override
                        public void run() {
                            try {
                                requestScopeListener.resume(foreignScopeInstance, responder.runtime.locator);
                                final Response response = producer.call();
                                if (response != null) {
                                    resume(response);
                                }
                            } catch (final Throwable t) {
                                resume(t);
                            }
                        }
                    });
                }
            });
        }

        @Override
        public boolean suspend() {
            synchronized (stateLock) {
                if (state == RUNNING) {
                    if (responder.processingContext.request().getResponseWriter().suspend(
                            AsyncResponse.NO_TIMEOUT, TimeUnit.SECONDS, this)) {
                        state = SUSPENDED;
                        return true;
                    }
                }
            }
            return false;
        }

        @Override
        public boolean resume(final Object response) {
            return resume(new Runnable() {
                @Override
                public void run() {
                    try {
                        requestScopeListener.resume(foreignScopeInstance, responder.runtime.locator);
                        final Response jaxrsResponse =
                                (response instanceof Response) ? (Response) response : Response.ok(response).build();
                        ServerRuntime.ensureAbsolute(
                                jaxrsResponse.getLocation(), jaxrsResponse.getHeaders(), responder.processingContext.request());
                        responder.process(new ContainerResponse(responder.processingContext.request(), jaxrsResponse));
                    } catch (final Throwable t) {
                        responder.process(t);
                    }
                }
            });
        }

        @Override
        public boolean resume(final Throwable error) {
            return resume(new Runnable() {
                @Override
                public void run() {
                    try {
                        requestScopeListener.resume(foreignScopeInstance, responder.runtime.locator);
                        responder.process(new MappableException(error));
                    } catch (final Throwable error) {
                        
                    }
                }
            });
        }

        private boolean resume(final Runnable handler) {
            synchronized (stateLock) {
                if (state != SUSPENDED) {
                    return false;
                }
                state = RESUMED;
            }

            try {
                responder.runtime.requestScope.runInScope(scopeInstance, handler);
            } finally {
                scopeInstance.release();
            }

            return true;
        }

        @Override
        public boolean cancel() {
            return cancel(new Value<Response>() {
                @Override
                public Response get() {
                    return Response.status(Response.Status.SERVICE_UNAVAILABLE).build();
                }
            });
        }

        @Override
        public boolean cancel(final int retryAfter) {
            return cancel(new Value<Response>() {
                @Override
                public Response get() {
                    return Response
                            .status(Response.Status.SERVICE_UNAVAILABLE)
                            .header(HttpHeaders.RETRY_AFTER, retryAfter)
                            .build();
                }
            });
        }

        @Override
        public boolean cancel(final Date retryAfter) {
            return cancel(new Value<Response>() {
                @Override
                public Response get() {
                    return Response
                            .status(Response.Status.SERVICE_UNAVAILABLE)
                            .header(HttpHeaders.RETRY_AFTER, retryAfter)
                            .build();
                }
            });
        }

        private boolean cancel(final Value<Response> responseValue) {
            synchronized (stateLock) {
                if (cancelled) {
                    return true;
                }

                if (state != SUSPENDED) {
                    return false;
                }
                state = RESUMED;
                cancelled = true;
            }

            responder.runtime.requestScope.runInScope(scopeInstance, new Runnable() {
                @Override
                public void run() {
                    try {
                        requestScopeListener.resume(foreignScopeInstance, responder.runtime.locator);
                        final Response response = responseValue.get();
                        responder.process(new ContainerResponse(responder.processingContext.request(), response));
                    } catch (final Throwable t) {
                        responder.process(t);
                    }
                }
            });
            return true;
        }

        public boolean isRunning() {
            synchronized (stateLock) {
                return state == RUNNING;
            }
        }

        @Override
        public boolean isSuspended() {
            synchronized (stateLock) {
                return state == SUSPENDED;
            }
        }

        @Override
        public boolean isCancelled() {
            synchronized (stateLock) {
                return cancelled;
            }
        }

        @Override
        public boolean isDone() {
            synchronized (stateLock) {
                return state == COMPLETED;
            }
        }

        @Override
        public boolean setTimeout(final long time, final TimeUnit unit) {
            try {
                responder.processingContext.request().getResponseWriter().setSuspendTimeout(time, unit);
                return true;
            } catch (final IllegalStateException ex) {
                LOGGER.log(Level.FINER, "Unable to set timeout on the AsyncResponse.", ex);
                return false;
            }
        }

        @Override
        public void setTimeoutHandler(final TimeoutHandler handler) {
            timeoutHandler = handler;
        }

        @Override
        public Collection<Class<?>> register(final Class<?> callback) {
            Preconditions.checkNotNull(callback, LocalizationMessages.PARAM_NULL("callback"));

            return register(Injections.getOrCreate(responder.runtime.locator, callback));
        }

        @Override
        public Map<Class<?>, Collection<Class<?>>> register(final Class<?> callback, final Class<?>... callbacks) {
            Preconditions.checkNotNull(callback, LocalizationMessages.PARAM_NULL("callback"));
            Preconditions.checkNotNull(callbacks, LocalizationMessages.CALLBACK_ARRAY_NULL());
            for (final Class<?> additionalCallback : callbacks) {
                Preconditions.checkNotNull(additionalCallback, LocalizationMessages.CALLBACK_ARRAY_ELEMENT_NULL());
            }

            final Map<Class<?>, Collection<Class<?>>> results = new HashMap<>();

            results.put(callback, register(callback));

            for (final Class<?> c : callbacks) {
                results.put(c, register(c));
            }

            return results;
        }

        @Override
        public Collection<Class<?>> register(final Object callback) {
            Preconditions.checkNotNull(callback, LocalizationMessages.PARAM_NULL("callback"));

            final Collection<Class<?>> result = new LinkedList<>();
            for (final AbstractCallbackRunner<?> runner : callbackRunners) {
                if (runner.supports(callback.getClass())) {
                    if (runner.register(callback)) {
                        result.add(runner.getCallbackContract());
                    }
                }
            }

            return result;
        }

        @Override
        public Map<Class<?>, Collection<Class<?>>> register(final Object callback, final Object... callbacks) {
            Preconditions.checkNotNull(callback, LocalizationMessages.PARAM_NULL("callback"));
            Preconditions.checkNotNull(callbacks, LocalizationMessages.CALLBACK_ARRAY_NULL());
            for (final Object additionalCallback : callbacks) {
                Preconditions.checkNotNull(additionalCallback, LocalizationMessages.CALLBACK_ARRAY_ELEMENT_NULL());
            }

            final Map<Class<?>, Collection<Class<?>>> results = new HashMap<>();

            results.put(callback.getClass(), register(callback));

            for (final Object c : callbacks) {
                results.put(c.getClass(), register(c));
            }

            return results;
        }
    }

    
    abstract static class AbstractCallbackRunner<T> {

        private final Queue<T> callbacks = new ConcurrentLinkedQueue<>();
        private final Logger logger;

        
        protected AbstractCallbackRunner(final Logger logger) {
            this.logger = logger;
        }

        
        public final boolean supports(final Class<?> callbackClass) {
            return getCallbackContract().isAssignableFrom(callbackClass);
        }

        
        public abstract Class<?> getCallbackContract();

        
        @SuppressWarnings("unchecked")
        public boolean register(final Object callback) {
            return callbacks.offer((T) callback);
        }

        
        protected final void executeCallbacks(final Closure<T> invoker) {
            for (final T callback : callbacks) {
                try {
                    invoker.invoke(callback);
                } catch (final Throwable t) {
                    logger.log(Level.WARNING, LocalizationMessages.ERROR_ASYNC_CALLBACK_FAILED(callback.getClass().getName()), t);
                }
            }
        }
    }

    private static class CompletionCallbackRunner
            extends AbstractCallbackRunner<CompletionCallback> implements CompletionCallback {

        private static final Logger LOGGER = Logger.getLogger(CompletionCallbackRunner.class.getName());

        private CompletionCallbackRunner() {
            super(LOGGER);
        }

        @Override
        public Class<?> getCallbackContract() {
            return CompletionCallback.class;
        }

        @Override
        public void onComplete(final Throwable throwable) {
            executeCallbacks(new Closure<CompletionCallback>() {
                @Override
                public void invoke(final CompletionCallback callback) {
                    callback.onComplete(throwable);
                }
            });
        }
    }

    private static class ConnectionCallbackRunner
            extends AbstractCallbackRunner<ConnectionCallback> implements ConnectionCallback {

        private static final Logger LOGGER = Logger.getLogger(ConnectionCallbackRunner.class.getName());

        private ConnectionCallbackRunner() {
            super(LOGGER);
        }

        @Override
        public Class<?> getCallbackContract() {
            return ConnectionCallback.class;
        }

        @Override
        public void onDisconnect(final AsyncResponse disconnected) {
            executeCallbacks(new Closure<ConnectionCallback>() {
                @Override
                public void invoke(final ConnectionCallback callback) {
                    callback.onDisconnect(disconnected);
                }
            });
        }
    }
}

<code block>

package org.glassfish.jersey.server;

import java.io.OutputStream;
import java.lang.annotation.Annotation;
import java.lang.reflect.Type;
import java.security.Principal;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.inject.Singleton;
import javax.ws.rs.HttpMethod;
import javax.ws.rs.NameBinding;
import javax.ws.rs.RuntimeType;
import javax.ws.rs.container.ContainerRequestFilter;
import javax.ws.rs.container.ContainerResponseFilter;
import javax.ws.rs.container.DynamicFeature;
import javax.ws.rs.container.PreMatching;
import javax.ws.rs.core.Application;
import javax.ws.rs.core.Configuration;
import javax.ws.rs.core.GenericType;
import javax.ws.rs.core.HttpHeaders;
import javax.ws.rs.core.MultivaluedHashMap;
import javax.ws.rs.core.MultivaluedMap;
import javax.ws.rs.core.SecurityContext;
import javax.ws.rs.ext.MessageBodyReader;
import javax.ws.rs.ext.MessageBodyWriter;
import javax.ws.rs.ext.ReaderInterceptor;
import javax.ws.rs.ext.WriterInterceptor;

import org.glassfish.jersey.CommonProperties;
import org.glassfish.jersey.internal.Errors;
import org.glassfish.jersey.internal.ServiceConfigurationError;
import org.glassfish.jersey.internal.ServiceFinder;
import org.glassfish.jersey.internal.Version;
import org.glassfish.jersey.internal.inject.Injections;
import org.glassfish.jersey.internal.inject.JerseyClassAnalyzer;
import org.glassfish.jersey.internal.inject.ProviderBinder;
import org.glassfish.jersey.internal.inject.Providers;
import org.glassfish.jersey.internal.util.Producer;
import org.glassfish.jersey.internal.util.ReflectionHelper;
import org.glassfish.jersey.internal.util.collection.LazyValue;
import org.glassfish.jersey.internal.util.collection.Ref;
import org.glassfish.jersey.internal.util.collection.Value;
import org.glassfish.jersey.internal.util.collection.Values;
import org.glassfish.jersey.message.MessageBodyWorkers;
import org.glassfish.jersey.message.internal.NullOutputStream;
import org.glassfish.jersey.model.ContractProvider;
import org.glassfish.jersey.model.internal.ComponentBag;
import org.glassfish.jersey.model.internal.RankedComparator;
import org.glassfish.jersey.model.internal.RankedComparator.Order;
import org.glassfish.jersey.model.internal.RankedProvider;
import org.glassfish.jersey.process.internal.ChainableStage;
import org.glassfish.jersey.process.internal.ExecutorProviders;
import org.glassfish.jersey.process.internal.Stage;
import org.glassfish.jersey.process.internal.Stages;
import org.glassfish.jersey.server.internal.JerseyRequestTimeoutHandler;
import org.glassfish.jersey.server.internal.JerseyResourceContext;
import org.glassfish.jersey.server.internal.LocalizationMessages;
import org.glassfish.jersey.server.internal.ProcessingProviders;
import org.glassfish.jersey.server.internal.monitoring.ApplicationEventImpl;
import org.glassfish.jersey.server.internal.monitoring.CompositeApplicationEventListener;
import org.glassfish.jersey.server.internal.monitoring.MonitoringContainerListener;
import org.glassfish.jersey.server.internal.process.ReferencesInitializer;
import org.glassfish.jersey.server.internal.process.RequestProcessingContext;
import org.glassfish.jersey.server.internal.routing.Routing;
import org.glassfish.jersey.server.model.ComponentModelValidator;
import org.glassfish.jersey.server.model.ModelProcessor;
import org.glassfish.jersey.server.model.ModelValidationException;
import org.glassfish.jersey.server.model.Resource;
import org.glassfish.jersey.server.model.ResourceModel;
import org.glassfish.jersey.server.model.internal.ModelErrors;
import org.glassfish.jersey.server.monitoring.ApplicationEvent;
import org.glassfish.jersey.server.monitoring.ApplicationEventListener;
import org.glassfish.jersey.server.spi.ComponentProvider;
import org.glassfish.jersey.server.spi.Container;
import org.glassfish.jersey.server.spi.ContainerLifecycleListener;
import org.glassfish.jersey.server.spi.ContainerResponseWriter;
import org.glassfish.jersey.server.spi.ExternalRequestScope;

import org.glassfish.hk2.api.DynamicConfiguration;
import org.glassfish.hk2.api.Factory;
import org.glassfish.hk2.api.ServiceLocator;
import org.glassfish.hk2.utilities.Binder;
import org.glassfish.hk2.utilities.binding.AbstractBinder;
import org.glassfish.hk2.utilities.binding.ScopedBindingBuilder;

import jersey.repackaged.com.google.common.base.Function;
import jersey.repackaged.com.google.common.base.Predicate;
import jersey.repackaged.com.google.common.collect.Collections2;
import jersey.repackaged.com.google.common.collect.Lists;
import jersey.repackaged.com.google.common.collect.Sets;
import jersey.repackaged.com.google.common.util.concurrent.AbstractFuture;


public final class ApplicationHandler implements ContainerLifecycleListener {

    private static final Logger LOGGER = Logger.getLogger(ApplicationHandler.class.getName());

    
    private static final SecurityContext DEFAULT_SECURITY_CONTEXT = new SecurityContext() {

        @Override
        public boolean isUserInRole(final String role) {
            return false;
        }

        @Override
        public boolean isSecure() {
            return false;
        }

        @Override
        public Principal getUserPrincipal() {
            return null;
        }

        @Override
        public String getAuthenticationScheme() {
            return null;
        }
    };

    private class ApplicationBinder extends AbstractBinder {

        private class JaxrsApplicationProvider implements Factory<Application> {

            @Override
            public Application provide() {
                return ApplicationHandler.this.application;
            }

            @Override
            public void dispose(final Application instance) {
                
            }
        }

        private class RuntimeConfigProvider implements Factory<ServerConfig> {

            @Override
            public ServerConfig provide() {
                return ApplicationHandler.this.runtimeConfig;
            }

            @Override
            public void dispose(final ServerConfig instance) {
                
            }
        }

        @Override
        protected void configure() {
            bindFactory(new RuntimeConfigProvider()).to(ServerConfig.class).to(Configuration.class).in(Singleton.class);
            bindFactory(new JaxrsApplicationProvider()).to(Application.class).in(Singleton.class);
            bind(ApplicationHandler.this).to(ApplicationHandler.class);
        }
    }

    private final Application application;
    private final ResourceConfig runtimeConfig;
    private final ServiceLocator locator;
    private final ServerRuntime runtime;
    private final Iterable<ContainerLifecycleListener> containerLifecycleListeners;

    private MessageBodyWorkers msgBodyWorkers;

    
    public ApplicationHandler() {
        this(new Application());
    }

    
    public ApplicationHandler(final Class<? extends Application> jaxrsApplicationClass) {
        this.locator = Injections.createLocator(new ServerBinder(null), new ApplicationBinder());
        locator.setDefaultClassAnalyzerName(JerseyClassAnalyzer.NAME);

        final LazyValue<Iterable<ComponentProvider>> componentProviders = getLazyInitializedComponentProviders(locator);
        this.application = createApplication(jaxrsApplicationClass, componentProviders);
        this.runtimeConfig = ResourceConfig.createRuntimeConfig(application);

        this.runtime = Errors.processWithException(new Producer<ServerRuntime>() {
            @Override
            public ServerRuntime call() {
                return initialize(componentProviders.get());
            }
        });

        this.containerLifecycleListeners = Providers.getAllProviders(locator, ContainerLifecycleListener.class);
    }

    
    public ApplicationHandler(final Application application) {
        this(application, null, null);
    }

    
    public ApplicationHandler(final Application application, final Binder customBinder) {
        this(application, customBinder, null);
    }

    
    public ApplicationHandler(final Application application, final Binder customBinder, final ServiceLocator parent) {
        if (customBinder == null) {
            this.locator = Injections.createLocator(
                    parent,
                    new ServerBinder(application.getProperties()),
                    new ApplicationBinder());
        } else {
            this.locator = Injections.createLocator(parent,
                    new ServerBinder(application.getProperties()),
                    new ApplicationBinder(),
                    customBinder);
        }
        locator.setDefaultClassAnalyzerName(JerseyClassAnalyzer.NAME);
        final LazyValue<Iterable<ComponentProvider>> componentProviders = getLazyInitializedComponentProviders(locator);

        this.application = application;
        if (application instanceof ResourceConfig) {
            final ResourceConfig rc = (ResourceConfig) application;
            if (rc.getApplicationClass() != null) {
                rc.setApplication(createApplication(rc.getApplicationClass(), componentProviders));
            }
        }
        this.runtimeConfig = ResourceConfig.createRuntimeConfig(application);

        this.runtime = Errors.processWithException(new Producer<ServerRuntime>() {
            @Override
            public ServerRuntime call() {
                return initialize(componentProviders.get());
            }
        });

        this.containerLifecycleListeners = Providers.getAllProviders(locator, ContainerLifecycleListener.class);
    }

    private Application createApplication(final Class<? extends Application> applicationClass,
                                          final Value<Iterable<ComponentProvider>> componentProvidersValue) {
        
        
        if (applicationClass == ResourceConfig.class) {
            return new ResourceConfig();
        } else if (applicationClass == Application.class) {
            return new Application();
        } else {
            Iterable<ComponentProvider> componentProviders = componentProvidersValue.get();
            boolean appClassBound = false;
            for (ComponentProvider cp : componentProviders) {
                if (cp.bind(applicationClass, Collections.<Class<?>>emptySet())) {
                    appClassBound = true;
                    break;
                }
            }
            if (!appClassBound) {
                if (applicationClass.isAnnotationPresent(Singleton.class)) {
                    final DynamicConfiguration dc = Injections.getConfiguration(locator);
                    final ScopedBindingBuilder<? extends Application> binder =
                            Injections.newBinder(applicationClass).to(applicationClass).in(Singleton.class);
                    Injections.addBinding(binder, dc);
                    dc.commit();
                    appClassBound = true;
                }
            }
            final Application app = appClassBound
                    ? locator.getService(applicationClass) : locator.createAndInitialize(applicationClass);
            if (app instanceof ResourceConfig) {
                final ResourceConfig _rc = (ResourceConfig) app;
                final Class<? extends Application> innerAppClass = _rc.getApplicationClass();
                if (innerAppClass != null) {
                    final Application innerApp = createApplication(innerAppClass, componentProvidersValue);
                    _rc.setApplication(innerApp);
                }
            }
            return app;
        }
    }

    private static LazyValue<Iterable<ComponentProvider>> getLazyInitializedComponentProviders(final ServiceLocator locator) {
        return Values.lazy(new Value<Iterable<ComponentProvider>>() {
            @Override
            public Iterable<ComponentProvider> get() {
                
                List<ComponentProvider> result = new LinkedList<>();

                
                for (final RankedProvider<ComponentProvider> rankedProvider : getRankedComponentProviders()) {
                    final ComponentProvider provider = rankedProvider.getProvider();
                    provider.initialize(locator);
                    result.add(provider);
                }
                return result;
            }
        });
    }

    
    private ServerRuntime initialize(Iterable<ComponentProvider> componentProviders) {
        LOGGER.config(LocalizationMessages.INIT_MSG(Version.getBuildId()));

        
        if (application instanceof ResourceConfig) {
            ((ResourceConfig) application).lock();
        }

        final boolean ignoreValidationErrors = ServerProperties.getValue(runtimeConfig.getProperties(),
                ServerProperties.RESOURCE_VALIDATION_IGNORE_ERRORS,
                Boolean.FALSE,
                Boolean.class);
        final boolean disableValidation = ServerProperties.getValue(runtimeConfig.getProperties(),
                ServerProperties.RESOURCE_VALIDATION_DISABLE,
                Boolean.FALSE,
                Boolean.class);

        final ResourceBag resourceBag;
        final ProcessingProviders processingProviders;
        final ComponentBag componentBag;
        ResourceModel resourceModel;
        CompositeApplicationEventListener compositeListener = null;

        Errors.mark(); 
        try {
            
            if (!CommonProperties.getValue(runtimeConfig.getProperties(), RuntimeType.SERVER,
                    CommonProperties.FEATURE_AUTO_DISCOVERY_DISABLE, Boolean.FALSE, Boolean.class)) {
                runtimeConfig.configureAutoDiscoverableProviders(locator);
            } else {
                runtimeConfig.configureForcedAutoDiscoverableProviders(locator);
            }

            
            runtimeConfig.configureMetaProviders(locator);

            final ResourceBag.Builder resourceBagBuilder = new ResourceBag.Builder();

            
            for (final Resource programmaticResource : runtimeConfig.getResources()) {
                resourceBagBuilder.registerProgrammaticResource(programmaticResource);
            }

            
            for (final Class<?> c : runtimeConfig.getClasses()) {
                try {
                    final Resource resource = Resource.from(c, disableValidation);
                    if (resource != null) {
                        resourceBagBuilder.registerResource(c, resource);
                    }
                } catch (final IllegalArgumentException ex) {
                    LOGGER.warning(ex.getMessage());
                }
            }

            for (final Object o : runtimeConfig.getSingletons()) {
                try {
                    final Resource resource = Resource.from(o.getClass(), disableValidation);
                    if (resource != null) {
                        resourceBagBuilder.registerResource(o, resource);
                    }
                } catch (final IllegalArgumentException ex) {
                    LOGGER.warning(ex.getMessage());
                }
            }

            resourceBag = resourceBagBuilder.build();

            runtimeConfig.lock();

            componentBag = runtimeConfig.getComponentBag();
            final Class<ExternalRequestScope>[] extScopes = ServiceFinder.find(ExternalRequestScope.class, true).toClassArray();

            boolean extScopeBound = false;

            if (extScopes.length == 1) {
                for (final ComponentProvider p : componentProviders) {
                    if (p.bind(extScopes[0], new HashSet<Class<?>>() {{
                        add(ExternalRequestScope.class);
                    }})) {
                        extScopeBound = true;
                        break;
                    }
                }
            } else if (extScopes.length > 1) {
                if (LOGGER.isLoggable(Level.WARNING)) {
                    final StringBuilder scopeList = new StringBuilder("\n");
                    for (final Class<ExternalRequestScope> ers : extScopes) {
                        scopeList.append("   ").append(ers.getTypeParameters()[0]).append('\n');
                    }
                    LOGGER.warning(LocalizationMessages.WARNING_TOO_MANY_EXTERNAL_REQ_SCOPES(scopeList.toString()));
                }
            }

            if (!extScopeBound) {
                final DynamicConfiguration configuration = Injections.getConfiguration(locator);
                final ScopedBindingBuilder<ExternalRequestScope> binder = Injections
                        .newBinder((ExternalRequestScope) ServerRuntime.NOOP_EXTERNAL_REQ_SCOPE)
                        .to(ExternalRequestScope.class);
                Injections.addBinding(binder, configuration);
                configuration.commit();
            }

            bindProvidersAndResources(componentProviders, componentBag, resourceBag.classes, resourceBag.instances);
            for (final ComponentProvider componentProvider : componentProviders) {
                componentProvider.done();
            }

            final Iterable<ApplicationEventListener> appEventListeners = Providers.getAllProviders(locator,
                    ApplicationEventListener.class, new RankedComparator<ApplicationEventListener>());

            if (appEventListeners.iterator().hasNext()) {
                compositeListener = new CompositeApplicationEventListener(appEventListeners);
                compositeListener.onEvent(new ApplicationEventImpl(ApplicationEvent.Type.INITIALIZATION_START,
                        this.runtimeConfig, componentBag.getRegistrations(), resourceBag.classes, resourceBag.instances,
                        null));
            }

            processingProviders = getProcessingProviders(componentBag);

            
            final GenericType<Ref<ProcessingProviders>> refGenericType = new GenericType<Ref<ProcessingProviders>>() {
            };
            final Ref<ProcessingProviders> refProcessingProvider = locator.getService(refGenericType.getType());
            refProcessingProvider.set(processingProviders);

            resourceModel = new ResourceModel.Builder(resourceBag.getRootResources(), false).build();
            resourceModel = processResourceModel(resourceModel);

            if (!disableValidation) {
                final ComponentModelValidator validator = new ComponentModelValidator(locator);
                validator.validate(resourceModel);
            }

            if (Errors.fatalIssuesFound() && !ignoreValidationErrors) {
                throw new ModelValidationException(LocalizationMessages.RESOURCE_MODEL_VALIDATION_FAILED_AT_INIT(),
                        ModelErrors.getErrorsAsResourceModelIssues(true));
            }
        } finally {
            if (ignoreValidationErrors) {
                Errors.logErrors(true);
                Errors.reset(); 
            } else {
                Errors.unmark();
            }
        }

        bindEnhancingResourceClasses(resourceModel, resourceBag, componentProviders);

        ExecutorProviders.createInjectionBindings(locator);

        
        final JerseyResourceContext jerseyResourceContext = locator.getService(JerseyResourceContext.class);
        jerseyResourceContext.setResourceModel(resourceModel);

        msgBodyWorkers = locator.getService(MessageBodyWorkers.class);

        
        final ReferencesInitializer referencesInitializer = locator.createAndInitialize(ReferencesInitializer.class);
        final ContainerFilteringStage preMatchRequestFilteringStage = new ContainerFilteringStage(
                processingProviders.getPreMatchFilters(),
                processingProviders.getGlobalResponseFilters());
        final ChainableStage<RequestProcessingContext> routingStage = Routing.forModel(resourceModel.getRuntimeResourceModel())
                .locator(locator)
                .resourceContext(jerseyResourceContext)
                .configuration(runtimeConfig)
                .entityProviders(msgBodyWorkers)
                .processingProviders(processingProviders)
                .buildStage();
        final ContainerFilteringStage resourceFilteringStage =
                new ContainerFilteringStage(processingProviders.getGlobalRequestFilters(), null);
        
        final Stage<RequestProcessingContext> rootStage = Stages
                .chain(referencesInitializer)
                .to(preMatchRequestFilteringStage)
                .to(routingStage)
                .to(resourceFilteringStage)
                .build(Routing.matchedEndpointExtractor());
        final ServerRuntime serverRuntime = locator.createAndInitialize(ServerRuntime.Builder.class)
                .build(rootStage, compositeListener, processingProviders);

        
        for (final Object instance : componentBag.getInstances(ComponentBag.EXCLUDE_META_PROVIDERS)) {
            locator.inject(instance);
        }
        for (final Object instance : resourceBag.instances) {
            locator.inject(instance);
        }

        logApplicationInitConfiguration(locator, resourceBag, processingProviders);

        if (compositeListener != null) {
            final ApplicationEvent initFinishedEvent = new ApplicationEventImpl(
                    ApplicationEvent.Type.INITIALIZATION_APP_FINISHED, runtimeConfig,
                    componentBag.getRegistrations(), resourceBag.classes, resourceBag.instances, resourceModel);
            compositeListener.onEvent(initFinishedEvent);

            final MonitoringContainerListener containerListener
                    = locator.getService(MonitoringContainerListener.class);
            containerListener.init(compositeListener, initFinishedEvent);
        }

        return serverRuntime;
    }

    private static void logApplicationInitConfiguration(final ServiceLocator locator,
                                                        final ResourceBag resourceBag,
                                                        final ProcessingProviders processingProviders) {
        if (!LOGGER.isLoggable(Level.CONFIG)) {
            return;
        }

        final StringBuilder sb = new StringBuilder(LocalizationMessages.LOGGING_APPLICATION_INITIALIZED()).append('\n');

        final List<Resource> rootResourceClasses = resourceBag.getRootResources();

        if (!rootResourceClasses.isEmpty()) {
            sb.append(LocalizationMessages.LOGGING_ROOT_RESOURCE_CLASSES()).append(":");
            for (final Resource r : rootResourceClasses) {
                for (final Class clazz : r.getHandlerClasses()) {
                    sb.append('\n').append("  ").append(clazz.getName());
                }
            }
        }

        sb.append('\n');

        final Set<MessageBodyReader> messageBodyReaders;
        final Set<MessageBodyWriter> messageBodyWriters;

        if (LOGGER.isLoggable(Level.FINE)) {
            messageBodyReaders = Sets.newHashSet(Providers.getAllProviders(locator, MessageBodyReader.class));
            messageBodyWriters = Sets.newHashSet(Providers.getAllProviders(locator, MessageBodyWriter.class));
        } else {
            messageBodyReaders = Providers.getCustomProviders(locator, MessageBodyReader.class);
            messageBodyWriters = Providers.getCustomProviders(locator, MessageBodyWriter.class);
        }

        printProviders(LocalizationMessages.LOGGING_PRE_MATCH_FILTERS(),
                processingProviders.getPreMatchFilters(), sb);
        printProviders(LocalizationMessages.LOGGING_GLOBAL_REQUEST_FILTERS(),
                processingProviders.getGlobalRequestFilters(), sb);
        printProviders(LocalizationMessages.LOGGING_GLOBAL_RESPONSE_FILTERS(),
                processingProviders.getGlobalResponseFilters(), sb);
        printProviders(LocalizationMessages.LOGGING_GLOBAL_READER_INTERCEPTORS(),
                processingProviders.getGlobalReaderInterceptors(), sb);
        printProviders(LocalizationMessages.LOGGING_GLOBAL_WRITER_INTERCEPTORS(),
                processingProviders.getGlobalWriterInterceptors(), sb);
        printNameBoundProviders(LocalizationMessages.LOGGING_NAME_BOUND_REQUEST_FILTERS(),
                processingProviders.getNameBoundRequestFilters(), sb);
        printNameBoundProviders(LocalizationMessages.LOGGING_NAME_BOUND_RESPONSE_FILTERS(),
                processingProviders.getNameBoundResponseFilters(), sb);
        printNameBoundProviders(LocalizationMessages.LOGGING_NAME_BOUND_READER_INTERCEPTORS(),
                processingProviders.getNameBoundReaderInterceptors(), sb);
        printNameBoundProviders(LocalizationMessages.LOGGING_NAME_BOUND_WRITER_INTERCEPTORS(),
                processingProviders.getNameBoundWriterInterceptors(), sb);
        printProviders(LocalizationMessages.LOGGING_DYNAMIC_FEATURES(),
                processingProviders.getDynamicFeatures(), sb);
        printProviders(LocalizationMessages.LOGGING_MESSAGE_BODY_READERS(),
                Collections2.transform(messageBodyReaders, new WorkersToStringTransform<MessageBodyReader>()), sb);
        printProviders(LocalizationMessages.LOGGING_MESSAGE_BODY_WRITERS(),
                Collections2.transform(messageBodyWriters, new WorkersToStringTransform<MessageBodyWriter>()), sb);

        LOGGER.log(Level.CONFIG, sb.toString());
    }

    private static class WorkersToStringTransform<T> implements Function<T, String> {

        @Override
        public String apply(final T t) {
            if (t != null) {
                return t.getClass().getName();
            }
            return null;
        }
    }

    private static <T> void printNameBoundProviders(final String title,
                                                    final Map<Class<? extends Annotation>, List<RankedProvider<T>>> providers,
                                                    final StringBuilder sb) {
        if (!providers.isEmpty()) {
            sb.append(title).append(":").append('\n');

            for (final Map.Entry<Class<? extends Annotation>, List<RankedProvider<T>>> entry : providers.entrySet()) {
                for (final RankedProvider rankedProvider : entry.getValue()) {
                    sb.append("   ")
                            .append(LocalizationMessages.LOGGING_PROVIDER_BOUND(rankedProvider, entry.getKey()))
                            .append('\n');
                }
            }
        }
    }

    private static <T> void printProviders(final String title, final Iterable<T> providers, final StringBuilder sb) {
        final Iterator<T> iterator = providers.iterator();
        boolean first = true;
        while (iterator.hasNext()) {
            if (first) {
                sb.append(title).append(":").append('\n');
                first = false;
            }
            final T provider = iterator.next();
            sb.append("   ").append(provider).append('\n');
        }
    }

    private static Iterable<RankedProvider<ComponentProvider>> getRankedComponentProviders() throws ServiceConfigurationError {
        final List<RankedProvider<ComponentProvider>> result = new LinkedList<>();

        for (final ComponentProvider provider : ServiceFinder.find(ComponentProvider.class)) {
            result.add(new RankedProvider<>(provider));
        }
        Collections.sort(result, new RankedComparator<ComponentProvider>(Order.DESCENDING));
        return result;
    }

    private ProcessingProviders getProcessingProviders(final ComponentBag componentBag) {

        
        final Collection<Class<? extends Annotation>> applicationNameBindings = ReflectionHelper.getAnnotationTypes(
                ResourceConfig.unwrapApplication(runtimeConfig).getClass(), NameBinding.class);

        
        final Iterable<RankedProvider<ContainerResponseFilter>> responseFilters = Providers.getAllRankedProviders(locator,
                ContainerResponseFilter.class);

        final MultivaluedMap<RankedProvider<ContainerResponseFilter>, Class<? extends Annotation>> nameBoundRespFiltersInverse =
                new MultivaluedHashMap<>();
        final MultivaluedMap<RankedProvider<ContainerRequestFilter>, Class<? extends Annotation>> nameBoundReqFiltersInverse =
                new MultivaluedHashMap<>();
        final MultivaluedMap<RankedProvider<ReaderInterceptor>, Class<? extends Annotation>> nameBoundReaderInterceptorsInverse =
                new MultivaluedHashMap<>();
        final MultivaluedMap<RankedProvider<WriterInterceptor>, Class<? extends Annotation>> nameBoundWriterInterceptorsInverse =
                new MultivaluedHashMap<>();

        final MultivaluedMap<Class<? extends Annotation>, RankedProvider<ContainerResponseFilter>> nameBoundResponseFilters
                = filterNameBound(responseFilters, null, componentBag, applicationNameBindings, nameBoundRespFiltersInverse);

        final Iterable<RankedProvider<ContainerRequestFilter>> requestFilters = Providers.getAllRankedProviders(locator,
                ContainerRequestFilter.class);

        final List<RankedProvider<ContainerRequestFilter>> preMatchFilters = Lists.newArrayList();

        final MultivaluedMap<Class<? extends Annotation>, RankedProvider<ContainerRequestFilter>> nameBoundReqFilters =
                filterNameBound(requestFilters, preMatchFilters, componentBag, applicationNameBindings,
                        nameBoundReqFiltersInverse);

        final Iterable<RankedProvider<ReaderInterceptor>> readerInterceptors = Providers.getAllRankedProviders(locator,
                ReaderInterceptor.class);

        final MultivaluedMap<Class<? extends Annotation>, RankedProvider<ReaderInterceptor>> nameBoundReaderInterceptors =
                filterNameBound(readerInterceptors, null, componentBag, applicationNameBindings,
                        nameBoundReaderInterceptorsInverse);

        final Iterable<RankedProvider<WriterInterceptor>> writerInterceptors = Providers.getAllRankedProviders(locator,
                WriterInterceptor.class);

        final MultivaluedMap<Class<? extends Annotation>, RankedProvider<WriterInterceptor>> nameBoundWriterInterceptors =
                filterNameBound(writerInterceptors, null, componentBag, applicationNameBindings,
                        nameBoundWriterInterceptorsInverse);

        final Iterable<DynamicFeature> dynamicFeatures = Providers.getAllProviders(locator, DynamicFeature.class);

        return new ProcessingProviders(nameBoundReqFilters,
                nameBoundReqFiltersInverse,
                nameBoundResponseFilters,
                nameBoundRespFiltersInverse,
                nameBoundReaderInterceptors,
                nameBoundReaderInterceptorsInverse,
                nameBoundWriterInterceptors,
                nameBoundWriterInterceptorsInverse,
                requestFilters,
                preMatchFilters,
                responseFilters,
                readerInterceptors,
                writerInterceptors,
                dynamicFeatures);
    }

    private ResourceModel processResourceModel(ResourceModel resourceModel) {
        final Iterable<RankedProvider<ModelProcessor>> allRankedProviders = Providers.getAllRankedProviders(locator,
                ModelProcessor.class);
        final Iterable<ModelProcessor> modelProcessors = Providers.sortRankedProviders(new RankedComparator<ModelProcessor>(),
                allRankedProviders);

        for (final ModelProcessor modelProcessor : modelProcessors) {
            resourceModel = modelProcessor.processResourceModel(resourceModel, getConfiguration());
        }
        return resourceModel;
    }

    private void bindEnhancingResourceClasses(
            final ResourceModel resourceModel,
            final ResourceBag resourceBag,
            final Iterable<ComponentProvider> componentProviders) {

        final Set<Class<?>> newClasses = Sets.newHashSet();
        final Set<Object> newInstances = Sets.newHashSet();
        for (final Resource res : resourceModel.getRootResources()) {
            newClasses.addAll(res.getHandlerClasses());
            newInstances.addAll(res.getHandlerInstances());
        }
        newClasses.removeAll(resourceBag.classes);
        newInstances.removeAll(resourceBag.instances);

        final ComponentBag emptyComponentBag = ComponentBag.newInstance(new Predicate<ContractProvider>() {
            @Override
            public boolean apply(final ContractProvider input) {
                return false;
            }
        });
        bindProvidersAndResources(componentProviders, emptyComponentBag, newClasses, newInstances);
    }

    
    private static <T> MultivaluedMap<Class<? extends Annotation>, RankedProvider<T>> filterNameBound(
            final Iterable<RankedProvider<T>> all,
            final Collection<RankedProvider<ContainerRequestFilter>> preMatchingFilters,
            final ComponentBag componentBag,
            final Collection<Class<? extends Annotation>> applicationNameBindings,
            final MultivaluedMap<RankedProvider<T>, Class<? extends Annotation>> inverseNameBoundMap) {

        final MultivaluedMap<Class<? extends Annotation>, RankedProvider<T>> result
                = new MultivaluedHashMap<>();

        for (final Iterator<RankedProvider<T>> it = all.iterator(); it.hasNext(); ) {
            final RankedProvider<T> provider = it.next();
            Class<?> providerClass = provider.getProvider().getClass();
            final Set<Type> contractTypes = provider.getContractTypes();
            if (contractTypes != null && !contractTypes.contains(providerClass)) {
                providerClass = ReflectionHelper.theMostSpecificTypeOf(contractTypes);
            }

            ContractProvider model = componentBag.getModel(providerClass);
            if (model == null) {
                
                model = ComponentBag.modelFor(providerClass);
            }

            final boolean preMatching = providerClass.getAnnotation(PreMatching.class) != null;
            if (preMatching && preMatchingFilters != null) {
                it.remove();
                preMatchingFilters.add(new RankedProvider<>((ContainerRequestFilter) provider.getProvider(),
                        model.getPriority(ContainerRequestFilter.class)));
            }

            boolean nameBound = model.isNameBound();
            if (nameBound
                    && !applicationNameBindings.isEmpty()
                    && applicationNameBindings.containsAll(model.getNameBindings())) {
                
                nameBound = false;
            }

            if (nameBound) { 
                if (!preMatching) {
                    it.remove();
                    for (final Class<? extends Annotation> binding : model.getNameBindings()) {
                        result.add(binding, provider);
                        inverseNameBoundMap.add(provider, binding);
                    }
                } else {
                    LOGGER.warning(LocalizationMessages.PREMATCHING_ALSO_NAME_BOUND(providerClass));
                }
            }
        }

        return result;
    }

    private void bindProvidersAndResources(
            final Iterable<ComponentProvider> componentProviders,
            final ComponentBag componentBag,
            final Collection<Class<?>> resourceClasses,
            final Collection<Object> resourceInstances) {

        final JerseyResourceContext resourceContext = locator.getService(JerseyResourceContext.class);
        final DynamicConfiguration dc = Injections.getConfiguration(locator);
        final Set<Class<?>> registeredClasses = runtimeConfig.getRegisteredClasses();

        
        final Set<Class<?>> classes = Sets.newIdentityHashSet();
        classes.addAll(Sets.filter(componentBag.getClasses(ComponentBag.EXCLUDE_META_PROVIDERS),
                new Predicate<Class<?>>() {
                    @Override
                    public boolean apply(final Class<?> componentClass) {
                        return Providers.checkProviderRuntime(
                                componentClass,
                                componentBag.getModel(componentClass),
                                RuntimeType.SERVER,
                                !registeredClasses.contains(componentClass),
                                resourceClasses.contains(componentClass));
                    }
                }
        ));
        classes.addAll(resourceClasses);

        
        for (final Class<?> componentClass : classes) {

            ContractProvider model = componentBag.getModel(componentClass);

            if (bindWithComponentProvider(componentClass, model, componentProviders)) {
                continue;
            }

            if (resourceClasses.contains(componentClass)) {

                if (!Resource.isAcceptable(componentClass)) {
                    LOGGER.warning(LocalizationMessages.NON_INSTANTIABLE_COMPONENT(componentClass));
                    continue;
                }

                if (model != null && !Providers.checkProviderRuntime(
                        componentClass,
                        model,
                        RuntimeType.SERVER,
                        !registeredClasses.contains(componentClass),
                        true)) {
                    model = null;
                }
                resourceContext.unsafeBindResource(componentClass, model, dc);
            } else {
                ProviderBinder.bindProvider(componentClass, model, dc);
            }
        }

        
        final Set<Object> instances = Sets.newHashSet();
        instances.addAll(Sets.filter(componentBag.getInstances(ComponentBag.EXCLUDE_META_PROVIDERS),
                new Predicate<Object>() {
                    @Override
                    public boolean apply(final Object component) {
                        final Class<?> componentClass = component.getClass();
                        return Providers.checkProviderRuntime(
                                componentClass,
                                componentBag.getModel(componentClass),
                                RuntimeType.SERVER,
                                !registeredClasses.contains(componentClass),
                                resourceInstances.contains(component));
                    }
                }
        ));
        instances.addAll(resourceInstances);

        
        for (final Object component : instances) {
            ContractProvider model = componentBag.getModel(component.getClass());
            if (resourceInstances.contains(component)) {
                if (model != null && !Providers.checkProviderRuntime(
                        component.getClass(),
                        model,
                        RuntimeType.SERVER,
                        !registeredClasses.contains(component.getClass()),
                        true)) {
                    model = null;
                }
                resourceContext.unsafeBindResource(component, model, dc);
            } else {
                ProviderBinder.bindProvider(component, model, dc);
            }
        }

        dc.commit();
    }

    private boolean bindWithComponentProvider(
            final Class<?> component,
            final ContractProvider providerModel,
            final Iterable<ComponentProvider> componentProviders) {

        final Set<Class<?>> contracts = providerModel == null ? Collections.<Class<?>>emptySet() : providerModel.getContracts();
        for (final ComponentProvider provider : componentProviders) {
            if (provider.bind(component, contracts)) {
                return true;
            }
        }
        return false;
    }

    
    public Future<ContainerResponse> apply(final ContainerRequest requestContext) {
        return apply(requestContext, new NullOutputStream());
    }

    
    public Future<ContainerResponse> apply(final ContainerRequest request,
                                           final OutputStream outputStream) {
        final FutureResponseWriter responseFuture =
                new FutureResponseWriter(request.getMethod(), outputStream, runtime.getBackgroundScheduler());

        if (request.getSecurityContext() == null) {
            request.setSecurityContext(DEFAULT_SECURITY_CONTEXT);
        }
        request.setWriter(responseFuture);

        handle(request);

        return responseFuture;
    }

    private static class FutureResponseWriter extends AbstractFuture<ContainerResponse> implements ContainerResponseWriter {

        private ContainerResponse response = null;

        private final String requestMethodName;
        private final OutputStream outputStream;

        private final JerseyRequestTimeoutHandler requestTimeoutHandler;

        private FutureResponseWriter(final String requestMethodName,
                                     final OutputStream outputStream,
                                     final ScheduledExecutorService backgroundScheduler) {
            this.requestMethodName = requestMethodName;
            this.outputStream = outputStream;
            this.requestTimeoutHandler = new JerseyRequestTimeoutHandler(this, backgroundScheduler);
        }

        @Override
        public OutputStream writeResponseStatusAndHeaders(final long contentLength, final ContainerResponse response) {
            this.response = response;

            if (contentLength >= 0) {
                response.getHeaders().putSingle(HttpHeaders.CONTENT_LENGTH, Long.toString(contentLength));
            }

            return outputStream;
        }

        @Override
        public boolean suspend(final long time, final TimeUnit unit, final TimeoutHandler handler) {
            return requestTimeoutHandler.suspend(time, unit, handler);
        }

        @Override
        public void setSuspendTimeout(final long time, final TimeUnit unit) {
            requestTimeoutHandler.setSuspendTimeout(time, unit);
        }

        @Override
        public void commit() {
            final ContainerResponse current = response;
            if (current != null) {
                if (HttpMethod.HEAD.equals(requestMethodName) && current.hasEntity()) {
                    
                    
                    current.setEntity(null);
                }
                requestTimeoutHandler.close();
                super.set(current);
            }
        }

        @Override
        public void failure(final Throwable error) {
            requestTimeoutHandler.close();
            super.setException(error);
        }

        @Override
        public boolean enableResponseBuffering() {
            return true;
        }

        @Override
        protected void interruptTask() {
            
        }

    }

    
    public void handle(final ContainerRequest request) {
        request.setWorkers(msgBodyWorkers);
        runtime.process(request);
    }

    
    public ServiceLocator getServiceLocator() {
        return locator;
    }

    
    public ResourceConfig getConfiguration() {
        return runtimeConfig;
    }

    

    @Override
    public void onStartup(final Container container) {
        for (final ContainerLifecycleListener listener : containerLifecycleListeners) {
            listener.onStartup(container);
        }
    }

    @Override
    public void onReload(final Container container) {
        for (final ContainerLifecycleListener listener : containerLifecycleListeners) {
            listener.onReload(container);
        }
    }

    @Override
    public void onShutdown(final Container container) {
        try {
            for (final ContainerLifecycleListener listener : containerLifecycleListeners) {
                listener.onShutdown(container);
            }
        } finally {
            try {
                
                locator.preDestroy(ResourceConfig.unwrapApplication(application));
            } finally {
                
                
                Injections.shutdownLocator(locator);
            }
        }
    }
}

<code block>


package org.glassfish.jersey.server.spi;

import org.glassfish.hk2.api.ServiceLocator;


public interface ExternalRequestScope<T> extends AutoCloseable {

    
    public ExternalRequestContext<T> open(ServiceLocator locator);

    
    public void suspend(ExternalRequestContext<T> c, ServiceLocator locator);

    
    public void resume(ExternalRequestContext<T> c, ServiceLocator locator);

    
    @Override
    public void close();
}

<code block>

package org.glassfish.jersey.grizzly2.httpserver;

import java.io.IOException;
import java.io.OutputStream;
import java.lang.reflect.Type;
import java.net.URI;
import java.net.URISyntaxException;
import java.security.Principal;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.ws.rs.core.Application;
import javax.ws.rs.core.SecurityContext;
import javax.ws.rs.core.UriBuilder;

import javax.inject.Inject;
import javax.inject.Provider;

import org.glassfish.jersey.grizzly2.httpserver.internal.LocalizationMessages;
import org.glassfish.jersey.internal.inject.ReferencingFactory;
import org.glassfish.jersey.internal.util.ExtendedLogger;
import org.glassfish.jersey.internal.util.collection.Ref;
import org.glassfish.jersey.process.internal.RequestScoped;
import org.glassfish.jersey.server.ApplicationHandler;
import org.glassfish.jersey.server.ContainerException;
import org.glassfish.jersey.server.ContainerRequest;
import org.glassfish.jersey.server.ContainerResponse;
import org.glassfish.jersey.server.ResourceConfig;
import org.glassfish.jersey.server.ServerProperties;
import org.glassfish.jersey.server.internal.ContainerUtils;
import org.glassfish.jersey.server.spi.Container;
import org.glassfish.jersey.server.spi.ContainerResponseWriter;
import org.glassfish.jersey.server.spi.RequestScopedInitializer;

import org.glassfish.hk2.api.ServiceLocator;
import org.glassfish.hk2.api.TypeLiteral;
import org.glassfish.hk2.utilities.binding.AbstractBinder;

import org.glassfish.grizzly.CompletionHandler;
import org.glassfish.grizzly.http.server.HttpHandler;
import org.glassfish.grizzly.http.server.Request;
import org.glassfish.grizzly.http.server.Response;
import org.glassfish.grizzly.utils.Charsets;


public final class GrizzlyHttpContainer extends HttpHandler implements Container {

    private static final ExtendedLogger logger =
            new ExtendedLogger(Logger.getLogger(GrizzlyHttpContainer.class.getName()), Level.FINEST);

    private final Type RequestTYPE = (new TypeLiteral<Ref<Request>>() {
    }).getType();
    private final Type ResponseTYPE = (new TypeLiteral<Ref<Response>>() {
    }).getType();
    
    private boolean configSetStatusOverSendError;

    
    private static class GrizzlyRequestReferencingFactory extends ReferencingFactory<Request> {

        @Inject
        public GrizzlyRequestReferencingFactory(final Provider<Ref<Request>> referenceFactory) {
            super(referenceFactory);
        }
    }

    
    private static class GrizzlyResponseReferencingFactory extends ReferencingFactory<Response> {

        @Inject
        public GrizzlyResponseReferencingFactory(final Provider<Ref<Response>> referenceFactory) {
            super(referenceFactory);
        }
    }

    
    static class GrizzlyBinder extends AbstractBinder {

        @Override
        protected void configure() {
            bindFactory(GrizzlyRequestReferencingFactory.class).to(Request.class)
                    .proxy(false).in(RequestScoped.class);
            bindFactory(ReferencingFactory.<Request>referenceFactory()).to(new TypeLiteral<Ref<Request>>() {})
                    .in(RequestScoped.class);

            bindFactory(GrizzlyResponseReferencingFactory.class).to(Response.class)
                    .proxy(true).proxyForSameScope(false).in(RequestScoped.class);
            bindFactory(ReferencingFactory.<Response>referenceFactory()).to(new TypeLiteral<Ref<Response>>() {})
                    .in(RequestScoped.class);
        }
    }

    private static final CompletionHandler<Response> EMPTY_COMPLETION_HANDLER = new CompletionHandler<Response>() {

        @Override
        public void cancelled() {
            
        }

        @Override
        public void failed(final Throwable throwable) {
            
        }

        @Override
        public void completed(final Response result) {
            
        }

        @Override
        public void updated(final Response result) {
            
        }
    };

    private static final class ResponseWriter implements ContainerResponseWriter {

        private final String name;
        private final Response grizzlyResponse;
        private final boolean configSetStatusOverSendError;

        ResponseWriter(final Response response, final boolean configSetStatusOverSendError) {
            this.grizzlyResponse = response;
            this.configSetStatusOverSendError = configSetStatusOverSendError;

            if (logger.isDebugLoggable()) {
                this.name = "ResponseWriter {" + "id=" + UUID.randomUUID().toString() + ", grizzlyResponse="
                        + grizzlyResponse.hashCode() + '}';
                logger.debugLog("{0} - init", name);
            } else {
                this.name = "ResponseWriter";
            }
        }

        @Override
        public String toString() {
            return name;
        }

        @Override
        public void commit() {
            try {
                if (grizzlyResponse.isSuspended()) {
                    grizzlyResponse.resume();
                }
            } finally {
                logger.debugLog("{0} - commit() called", name);
            }
        }

        @Override
        public boolean suspend(final long timeOut, final TimeUnit timeUnit, final TimeoutHandler timeoutHandler) {
            try {
                grizzlyResponse.suspend(timeOut, timeUnit, EMPTY_COMPLETION_HANDLER,
                        new org.glassfish.grizzly.http.server.TimeoutHandler() {

                            @Override
                            public boolean onTimeout(final Response response) {
                                if (timeoutHandler != null) {
                                    timeoutHandler.onTimeout(ResponseWriter.this);
                                }

                                
                                
                                return false;
                            }
                        }
                );
                return true;
            } catch (final IllegalStateException ex) {
                return false;
            } finally {
                logger.debugLog("{0} - suspend(...) called", name);
            }
        }

        @Override
        public void setSuspendTimeout(final long timeOut, final TimeUnit timeUnit) throws IllegalStateException {
            try {
                grizzlyResponse.getSuspendContext().setTimeout(timeOut, timeUnit);
            } finally {
                logger.debugLog("{0} - setTimeout(...) called", name);
            }
        }

        @Override
        public OutputStream writeResponseStatusAndHeaders(final long contentLength,
                                                          final ContainerResponse context)
                throws ContainerException {
            try {
                final javax.ws.rs.core.Response.StatusType statusInfo = context.getStatusInfo();
                if (statusInfo.getReasonPhrase() == null) {
                    grizzlyResponse.setStatus(statusInfo.getStatusCode());
                } else {
                    grizzlyResponse.setStatus(statusInfo.getStatusCode(), statusInfo.getReasonPhrase());
                }

                grizzlyResponse.setContentLengthLong(contentLength);

                for (final Map.Entry<String, List<String>> e : context.getStringHeaders().entrySet()) {
                    for (final String value : e.getValue()) {
                        grizzlyResponse.addHeader(e.getKey(), value);
                    }
                }

                return grizzlyResponse.getOutputStream();
            } finally {
                logger.debugLog("{0} - writeResponseStatusAndHeaders() called", name);
            }
        }

        @Override
        @SuppressWarnings("MagicNumber")
        public void failure(final Throwable error) {
            try {
                if (!grizzlyResponse.isCommitted()) {
                    try {
                        if (configSetStatusOverSendError) {
                            grizzlyResponse.reset();
                            grizzlyResponse.setStatus(500, "Request failed.");
                        } else {
                            grizzlyResponse.sendError(500, "Request failed.");
                        }
                    } catch (final IllegalStateException ex) {
                        
                        logger.log(Level.FINER, "Unable to reset failed response.", ex);
                    } catch (final IOException ex) {
                        throw new ContainerException(
                                LocalizationMessages.EXCEPTION_SENDING_ERROR_RESPONSE(500, "Request failed."),
                                ex);
                    }
                }
            } finally {
                logger.debugLog("{0} - failure(...) called", name);
                rethrow(error);
            }
        }

        @Override
        public boolean enableResponseBuffering() {
            return true;
        }

        
        private void rethrow(final Throwable error) {
            if (error instanceof RuntimeException) {
                throw (RuntimeException) error;
            } else {
                throw new ContainerException(error);
            }
        }
    }

    private volatile ApplicationHandler appHandler;

    
    GrizzlyHttpContainer(final Application application) {
        this.appHandler = new ApplicationHandler(application, new GrizzlyBinder());
        cacheConfigSetStatusOverSendError();
    }

    
    GrizzlyHttpContainer(final Application application, final ServiceLocator parentLocator) {
        this.appHandler = new ApplicationHandler(application, new GrizzlyBinder(), parentLocator);
        cacheConfigSetStatusOverSendError();
    }

    @Override
    public void start() {
        super.start();
        appHandler.onStartup(this);
    }

    @Override
    public void service(final Request request, final Response response) {
        final ResponseWriter responseWriter = new ResponseWriter(response, configSetStatusOverSendError);
        try {
            logger.debugLog("GrizzlyHttpContainer.service(...) started");
            final URI baseUri = getBaseUri(request);
            final ContainerRequest requestContext = new ContainerRequest(baseUri,
                    getRequestUri(baseUri, request), request.getMethod().getMethodString(),
                    getSecurityContext(request), new GrizzlyRequestPropertiesDelegate(request));
            requestContext.setEntityStream(request.getInputStream());
            for (final String headerName : request.getHeaderNames()) {
                requestContext.headers(headerName, request.getHeaders(headerName));
            }
            requestContext.setWriter(responseWriter);

            requestContext.setRequestScopedInitializer(new RequestScopedInitializer() {

                @Override
                public void initialize(final ServiceLocator locator) {
                    locator.<Ref<Request>>getService(RequestTYPE).set(request);
                    locator.<Ref<Response>>getService(ResponseTYPE).set(response);
                }
            });
            appHandler.handle(requestContext);
        } finally {
            logger.debugLog("GrizzlyHttpContainer.service(...) finished");
        }
    }

    @Override
    public ResourceConfig getConfiguration() {
        return appHandler.getConfiguration();
    }

    @Override
    public void reload() {
        reload(appHandler.getConfiguration());
    }

    @Override
    public void reload(final ResourceConfig configuration) {
        appHandler.onShutdown(this);

        appHandler = new ApplicationHandler(configuration, new GrizzlyBinder());
        appHandler.onReload(this);
        appHandler.onStartup(this);
        cacheConfigSetStatusOverSendError();
    }

    @Override
    public ApplicationHandler getApplicationHandler() {
        return appHandler;
    }

    @Override
    public void destroy() {
        super.destroy();
        appHandler.onShutdown(this);
        appHandler = null;
    }

    private SecurityContext getSecurityContext(final Request request) {
        return new SecurityContext() {

            @Override
            public boolean isUserInRole(final String role) {
                return false;
            }

            @Override
            public boolean isSecure() {
                return request.isSecure();
            }

            @Override
            public Principal getUserPrincipal() {
                return request.getUserPrincipal();
            }

            @Override
            public String getAuthenticationScheme() {
                return request.getAuthType();
            }
        };
    }

    private URI getBaseUri(final Request request) {
        try {
            return new URI(request.getScheme(), null, request.getServerName(),
                    request.getServerPort(), getBasePath(request), null, null);
        } catch (final URISyntaxException ex) {
            throw new IllegalArgumentException(ex);
        }
    }

    private String getBasePath(final Request request) {
        final String contextPath = request.getContextPath();

        if (contextPath == null || contextPath.isEmpty()) {
            return "/";
        } else if (contextPath.charAt(contextPath.length() - 1) != '/') {
            return contextPath + "/";
        } else {
            return contextPath;
        }
    }

    private URI getRequestUri(final URI baseUri, final Request grizzlyRequest) {
        
        String originalUri = UriBuilder.fromPath(
                grizzlyRequest.getRequest().getRequestURIRef().getOriginalRequestURIBC().toString(Charsets.ASCII_CHARSET)
        ).build().toString();

        final String queryString = grizzlyRequest.getQueryString();
        if (queryString != null) {
            originalUri = originalUri + "?" + ContainerUtils.encodeUnsafeCharacters(queryString);
        }

        return baseUri.resolve(originalUri);
    }

    
    private void cacheConfigSetStatusOverSendError() {
        this.configSetStatusOverSendError = ServerProperties.getValue(getConfiguration().getProperties(),
                ServerProperties.RESPONSE_SET_STATUS_OVER_SEND_ERROR, false, Boolean.class);
    }
}

<code block>

package org.glassfish.jersey.weld.se;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;

import org.glassfish.jersey.ext.cdi1x.internal.JerseyVetoed;
import org.glassfish.jersey.server.spi.ExternalRequestContext;
import org.glassfish.jersey.server.spi.ExternalRequestScope;

import org.jboss.weld.context.bound.BoundRequestContext;


@ApplicationScoped
@JerseyVetoed
public class WeldRequestScope implements ExternalRequestScope<Map<String, Object>> {

    @Inject
    private BoundRequestContext context;
    private final ThreadLocal<Map<String, Object>> actualMap = new ThreadLocal<>();

    @Override
    public ExternalRequestContext<Map<String, Object>> open() {
        final Map<String, Object> newMap = new ConcurrentHashMap<>();
        actualMap.set(newMap);
        context.associate(newMap);
        context.activate();
        return new ExternalRequestContext<>(newMap);
    }

    @Override
    public void resume(final ExternalRequestContext<Map<String, Object>> ctx) {
        final Map<String, Object> newMap = ctx.getContext();
        actualMap.set(newMap);
        context.associate(newMap);
        context.activate();
    }

    @Override
    public void suspend(final ExternalRequestContext<Map<String, Object>> ctx) {
        try {
            final Map<String, Object> contextMap = actualMap.get();
            if (contextMap != null) {
                context.deactivate();
                context.dissociate(contextMap);
            }
        } finally {
            actualMap.remove();
        }
    }

    @Override
    public void close() {
        try {
            final Map<String, Object> contextMap = actualMap.get();
            if (contextMap != null) {
                context.invalidate();
                context.deactivate();
                context.dissociate(contextMap);
            } else {
                context.deactivate();
            }
        } finally {
            actualMap.remove();
        }
    }
}

<code block>

package org.glassfish.jersey.ext.cdi1x.internal;

import java.lang.annotation.Annotation;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Member;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.enterprise.context.RequestScoped;
import javax.ws.rs.core.Application;
import javax.ws.rs.core.Context;

import javax.annotation.ManagedBean;
import javax.annotation.Priority;
import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.context.Dependent;
import javax.enterprise.context.spi.CreationalContext;
import javax.enterprise.event.Observes;
import javax.enterprise.inject.Default;
import javax.enterprise.inject.spi.AfterBeanDiscovery;
import javax.enterprise.inject.spi.AfterTypeDiscovery;
import javax.enterprise.inject.spi.Annotated;
import javax.enterprise.inject.spi.AnnotatedCallable;
import javax.enterprise.inject.spi.AnnotatedConstructor;
import javax.enterprise.inject.spi.AnnotatedParameter;
import javax.enterprise.inject.spi.AnnotatedType;
import javax.enterprise.inject.spi.Bean;
import javax.enterprise.inject.spi.BeanManager;
import javax.enterprise.inject.spi.BeforeBeanDiscovery;
import javax.enterprise.inject.spi.Extension;
import javax.enterprise.inject.spi.InjectionPoint;
import javax.enterprise.inject.spi.InjectionTarget;
import javax.enterprise.inject.spi.ProcessAnnotatedType;
import javax.enterprise.inject.spi.ProcessInjectionTarget;
import javax.enterprise.util.AnnotationLiteral;
import javax.inject.Qualifier;

import org.glassfish.jersey.ext.cdi1x.internal.spi.Hk2InjectedTarget;
import org.glassfish.jersey.ext.cdi1x.internal.spi.InjectionTargetListener;
import org.glassfish.jersey.ext.cdi1x.spi.Hk2CustomBoundTypesProvider;
import org.glassfish.jersey.ext.cdi1x.internal.spi.Hk2LocatorManager;
import org.glassfish.jersey.internal.inject.ForeignRequestScopeBridge;
import org.glassfish.jersey.internal.inject.Injections;
import org.glassfish.jersey.internal.inject.Providers;
import org.glassfish.jersey.server.model.Parameter;
import org.glassfish.jersey.server.model.Resource;
import org.glassfish.jersey.server.spi.ComponentProvider;
import org.glassfish.jersey.server.spi.internal.ValueFactoryProvider;

import org.glassfish.hk2.api.ClassAnalyzer;
import org.glassfish.hk2.api.DynamicConfiguration;
import org.glassfish.hk2.api.Factory;
import org.glassfish.hk2.api.ServiceLocator;
import org.glassfish.hk2.utilities.binding.ScopedBindingBuilder;
import org.glassfish.hk2.utilities.binding.ServiceBindingBuilder;
import org.glassfish.hk2.utilities.cache.Cache;
import org.glassfish.hk2.utilities.cache.Computable;

import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.ElementType.TYPE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;


@Priority(200)
public class CdiComponentProvider implements ComponentProvider, Extension {

    private static final Logger LOGGER = Logger.getLogger(CdiComponentProvider.class.getName());

    
    private static final Set<Class<? extends Annotation>> JAX_RS_INJECT_ANNOTATIONS =
            new HashSet<Class<? extends Annotation>>() {{
                addAll(JaxRsParamProducer.JAX_RS_STRING_PARAM_ANNOTATIONS);
                add(Context.class);
            }};

    
    public static final String CDI_CLASS_ANALYZER = "CdiInjecteeSkippingClassAnalyzer";

    
    private final Set<Type> jaxrsInjectableTypes = new HashSet<>();
    private final Set<Type> hk2ProvidedTypes = Collections.synchronizedSet(new HashSet<Type>());
    private final Set<Type> jerseyVetoedTypes = Collections.synchronizedSet(new HashSet<Type>());

    
    private final Set<Class<?>> requestScopedComponents = new HashSet<>();


    private final Cache<Class<?>, Boolean> jaxRsComponentCache = new Cache<>(new Computable<Class<?>, Boolean>() {
        @Override
        public Boolean compute(final Class<?> clazz) {
            return Application.class.isAssignableFrom(clazz)
                    || jaxRsProvidersCache.compute(clazz)
                    || Resource.from(clazz) != null;
        }
    });

    private final Cache<Class<?>, Boolean> jaxRsProvidersCache = new Cache<>(new Computable<Class<?>, Boolean>() {
        @Override
        public Boolean compute(final Class<?> clazz) {
            return Providers.isJaxRsProvider(clazz);
        }
    });

    private final Hk2CustomBoundTypesProvider customHk2TypesProvider;
    private final Hk2LocatorManager locatorManager;

    private volatile ServiceLocator locator;
    private volatile BeanManager beanManager;

    private volatile Map<Class<?>, Set<Method>> methodsToSkip = new HashMap<>();
    private volatile Map<Class<?>, Set<Field>> fieldsToSkip = new HashMap<>();

    public CdiComponentProvider() {
        customHk2TypesProvider = CdiUtil.lookupService(Hk2CustomBoundTypesProvider.class);
        locatorManager = CdiUtil.createHk2LocatorManager();
    }

    @Override
    public void initialize(final ServiceLocator locator) {
        this.locator = locator;
        this.beanManager = CdiUtil.getBeanManager();

        if (beanManager != null) {
            
            final CdiComponentProvider extension = beanManager.getExtension(CdiComponentProvider.class);

            if (extension != null) {
                extension.addLocator(this.locator);

                this.fieldsToSkip = extension.getFieldsToSkip();
                this.methodsToSkip = extension.getMethodsToSkip();

                bindHk2ClassAnalyzer();

                LOGGER.config(LocalizationMessages.CDI_PROVIDER_INITIALIZED());
            }
        }
    }

    
    @ApplicationScoped
    public static class JaxRsParamProducer {

        @Qualifier
        @Retention(RUNTIME)
        @Target({METHOD, FIELD, PARAMETER, TYPE})
        public static @interface JaxRsParamQualifier {
        }

        private static final JaxRsParamQualifier JaxRsParamQUALIFIER = new JaxRsParamQualifier() {

            @Override
            public Class<? extends Annotation> annotationType() {
                return JaxRsParamQualifier.class;
            }
        };

        static final Set<Class<? extends Annotation>> JAX_RS_STRING_PARAM_ANNOTATIONS =
                new HashSet<Class<? extends Annotation>>() {{
                    add(javax.ws.rs.PathParam.class);
                    add(javax.ws.rs.QueryParam.class);
                    add(javax.ws.rs.CookieParam.class);
                    add(javax.ws.rs.HeaderParam.class);
                    add(javax.ws.rs.MatrixParam.class);
                    add(javax.ws.rs.FormParam.class);
                }};

        
        final Cache<InjectionPoint, Parameter> parameterCache = new Cache<>(new Computable<InjectionPoint, Parameter>() {

            @Override
            public Parameter compute(final InjectionPoint injectionPoint) {
                final Annotated annotated = injectionPoint.getAnnotated();
                final Class<?> clazz = injectionPoint.getMember().getDeclaringClass();

                if (annotated instanceof AnnotatedParameter) {

                    final AnnotatedParameter annotatedParameter = (AnnotatedParameter) annotated;
                    final AnnotatedCallable callable = annotatedParameter.getDeclaringCallable();

                    if (callable instanceof AnnotatedConstructor) {

                        final AnnotatedConstructor ac = (AnnotatedConstructor) callable;
                        final int position = annotatedParameter.getPosition();
                        final List<Parameter> parameters = Parameter.create(clazz, clazz, ac.getJavaMember(), false);

                        return parameters.get(position);
                    }
                }

                return null;
            }
        });

        
        @javax.enterprise.inject.Produces
        @JaxRsParamQualifier
        public String getParameterValue(final InjectionPoint injectionPoint, final BeanManager beanManager) {
            final Parameter parameter = parameterCache.compute(injectionPoint);

            if (parameter != null) {
                final ServiceLocator locator = beanManager.getExtension(CdiComponentProvider.class).getEffectiveLocator();
                final Set<ValueFactoryProvider> providers = Providers.getProviders(locator, ValueFactoryProvider.class);

                for (final ValueFactoryProvider vfp : providers) {
                    final Factory<?> valueFactory = vfp.getValueFactory(parameter);
                    if (valueFactory != null) {
                        return (String) valueFactory.provide();
                    }
                }
            }

            return null;
        }
    }

    @Override
    public boolean bind(final Class<?> clazz, final Set<Class<?>> providerContracts) {
        if (LOGGER.isLoggable(Level.FINE)) {
            LOGGER.fine(LocalizationMessages.CDI_CLASS_BEING_CHECKED(clazz));
        }

        if (beanManager == null) {
            return false;
        }

        if (isJerseyOrDependencyType(clazz)) {
            return false;
        }

        final boolean isCdiManaged = isCdiComponent(clazz);
        final boolean isManagedBean = isManagedBean(clazz);
        final boolean isJaxRsComponent = isJaxRsComponentType(clazz);


        if (!isCdiManaged && !isManagedBean && !isJaxRsComponent) {
            return false;
        }

        final boolean isJaxRsApp = isJaxRsComponent && Application.class.isAssignableFrom(clazz);
        final boolean isJaxRsProvider = jaxRsProvidersCache.compute(clazz);

        final DynamicConfiguration dc = Injections.getConfiguration(locator);

        final Class<? extends Annotation> beanScopeAnnotation = CdiUtil.getBeanScope(clazz, beanManager);
        final boolean isRequestScoped = beanScopeAnnotation == RequestScoped.class
                                        || (beanScopeAnnotation == Dependent.class && !isJaxRsApp && !isJaxRsProvider);

        Factory beanFactory = isRequestScoped
                ? new RequestScopedCdiBeanHk2Factory(clazz, locator, beanManager, isCdiManaged)
                : new GenericCdiBeanHk2Factory(clazz, locator, beanManager, isCdiManaged);

        final ServiceBindingBuilder bindingBuilder =
                    Injections.newFactoryBinder(beanFactory);

        bindingBuilder.to(clazz);
        for (final Class contract : providerContracts) {
            bindingBuilder.to(contract);
        }

        Injections.addBinding(bindingBuilder, dc);

        dc.commit();

        if (isRequestScoped) {
            requestScopedComponents.add(clazz);
        }

        if (LOGGER.isLoggable(Level.CONFIG)) {
            LOGGER.config(LocalizationMessages.CDI_CLASS_BOUND_WITH_CDI(clazz));
        }

        return true;
    }

    @Override
    public void done() {
        final DynamicConfiguration dc = Injections.getConfiguration(locator);
        Injections.addBinding(Injections.newBinder(new ForeignRequestScopeBridge() {
            @Override
            public Set<Class<?>> getRequestScopedComponents() {
                return requestScopedComponents;
            }
        }).to(ForeignRequestScopeBridge.class), dc);
        dc.commit();
    }

    private boolean isCdiComponent(final Class<?> component) {
        final Annotation[] qualifiers = CdiUtil.getQualifiers(component.getAnnotations());
        return !beanManager.getBeans(component, qualifiers).isEmpty();
    }

    private boolean isManagedBean(final Class<?> component) {
        return component.isAnnotationPresent(ManagedBean.class);
    }

    private static AnnotatedConstructor<?> enrichedConstructor(final AnnotatedConstructor<?> ctor) {
        return new AnnotatedConstructor(){

            @Override
            public Constructor getJavaMember() {
                return ctor.getJavaMember();
            }

            @Override
            public List<AnnotatedParameter> getParameters() {
                final List<AnnotatedParameter> parameters = new ArrayList<>(ctor.getParameters().size());

                for (final AnnotatedParameter<?> ap : ctor.getParameters()) {
                    parameters.add(new AnnotatedParameter() {

                        @Override
                        public int getPosition() {
                            return ap.getPosition();
                        }

                        @Override
                        public AnnotatedCallable getDeclaringCallable() {
                            return ap.getDeclaringCallable();
                        }

                        @Override
                        public Type getBaseType() {
                            return ap.getBaseType();
                        }

                        @Override
                        public Set<Type> getTypeClosure() {
                            return ap.getTypeClosure();
                        }

                        @Override
                        public <T extends Annotation> T getAnnotation(final Class<T> annotationType) {
                            if (annotationType == JaxRsParamProducer.JaxRsParamQualifier.class) {
                                return hasAnnotation(ap, JaxRsParamProducer.JAX_RS_STRING_PARAM_ANNOTATIONS)
                                        ? (T) JaxRsParamProducer.JaxRsParamQUALIFIER : null;
                            } else {
                                return ap.getAnnotation(annotationType);
                            }
                        }

                        @Override
                        public Set<Annotation> getAnnotations() {
                            final Set<Annotation> result = new HashSet<>();
                            for (final Annotation a : ap.getAnnotations()) {
                                result.add(a);
                                final Class<? extends Annotation> annotationType = a.annotationType();
                                if (JaxRsParamProducer.JAX_RS_STRING_PARAM_ANNOTATIONS.contains(annotationType)) {
                                    result.add(JaxRsParamProducer.JaxRsParamQUALIFIER);
                                }
                            }
                            return result;
                        }

                        @Override
                        public boolean isAnnotationPresent(final Class<? extends Annotation> annotationType) {
                            return (annotationType == JaxRsParamProducer.JaxRsParamQualifier.class
                                            && hasAnnotation(ap, JaxRsParamProducer.JAX_RS_STRING_PARAM_ANNOTATIONS))
                                    || ap.isAnnotationPresent(annotationType);
                        }
                    });
                }
                return parameters;
            }

            @Override
            public boolean isStatic() {
                return ctor.isStatic();
            }

            @Override
            public AnnotatedType getDeclaringType() {
                return ctor.getDeclaringType();
            }

            @Override
            public Type getBaseType() {
                return ctor.getBaseType();
            }

            @Override
            public Set<Type> getTypeClosure() {
                return ctor.getTypeClosure();
            }

            @Override
            public <T extends Annotation> T getAnnotation(final Class<T> annotationType) {
                return ctor.getAnnotation(annotationType);
            }

            @Override
            public Set<Annotation> getAnnotations() {
                return ctor.getAnnotations();
            }

            @Override
            public boolean isAnnotationPresent(final Class<? extends Annotation> annotationType) {
                return ctor.isAnnotationPresent(annotationType);
            }
        };
    }

    @SuppressWarnings("unused")
    private void processAnnotatedType(@Observes final ProcessAnnotatedType processAnnotatedType) {
        final AnnotatedType<?> annotatedType = processAnnotatedType.getAnnotatedType();

        
        if (containsJaxRsConstructorInjection(annotatedType)
                || containsJaxRsFieldInjection(annotatedType)
                || containsJaxRsMethodInjection(annotatedType)) {
            jaxrsInjectableTypes.add(annotatedType.getBaseType());
        }

        if (customHk2TypesProvider != null) {
            final Type baseType = annotatedType.getBaseType();
            if (customHk2TypesProvider.getHk2Types().contains(baseType)) {
                processAnnotatedType.veto();
                jerseyVetoedTypes.add(baseType);
            }
        }

        if (containsJaxRsParameterizedCtor(annotatedType)) {
            processAnnotatedType.setAnnotatedType(new AnnotatedType() {

                @Override
                public Class getJavaClass() {
                    return annotatedType.getJavaClass();
                }

                @Override
                public Set<AnnotatedConstructor> getConstructors() {
                    final Set<AnnotatedConstructor> result = new HashSet<>();
                    for (final AnnotatedConstructor c : annotatedType.getConstructors()) {
                        result.add(enrichedConstructor(c));
                    }
                    return result;
                }

                @Override
                public Set getMethods() {
                    return annotatedType.getMethods();
                }

                @Override
                public Set getFields() {
                    return annotatedType.getFields();
                }

                @Override
                public Type getBaseType() {
                    return annotatedType.getBaseType();
                }

                @Override
                public Set<Type> getTypeClosure() {
                    return annotatedType.getTypeClosure();
                }

                @Override
                public <T extends Annotation> T getAnnotation(final Class<T> annotationType) {
                    return annotatedType.getAnnotation(annotationType);
                }

                @Override
                public Set<Annotation> getAnnotations() {
                    return annotatedType.getAnnotations();
                }

                @Override
                public boolean isAnnotationPresent(final Class<? extends Annotation> annotationType) {
                    return annotatedType.isAnnotationPresent(annotationType);
                }
            });
        }
    }

    private boolean containsJaxRsParameterizedCtor(final AnnotatedType annotatedType) {
        return containAnnotatedParameters(annotatedType.getConstructors(), JaxRsParamProducer.JAX_RS_STRING_PARAM_ANNOTATIONS);
    }

    private boolean containsJaxRsConstructorInjection(final AnnotatedType annotatedType) {
        return containAnnotatedParameters(annotatedType.getConstructors(), JAX_RS_INJECT_ANNOTATIONS);
    }

    private boolean containsJaxRsMethodInjection(final AnnotatedType annotatedType) {
        return containAnnotatedParameters(annotatedType.getMethods(), JAX_RS_INJECT_ANNOTATIONS);
    }

    private boolean containsJaxRsFieldInjection(final AnnotatedType annotatedType) {
        return containAnnotation(annotatedType.getFields(), JAX_RS_INJECT_ANNOTATIONS);
    }

    private boolean containAnnotatedParameters(final Collection<AnnotatedCallable> annotatedCallables,
                                               final Set<Class<? extends Annotation>> annotationSet) {
        for (final AnnotatedCallable c : annotatedCallables) {
            if (containAnnotation(c.getParameters(), annotationSet)) {
                return true;
            }
        }
        return false;
    }

    private boolean containAnnotation(final Collection<Annotated> elements,
                                      final Set<Class<? extends Annotation>> annotationSet) {
        for (final Annotated element : elements) {
            if (hasAnnotation(element, annotationSet)) {
                return true;
            }
        }
        return false;
    }

    private static boolean hasAnnotation(final Annotated element, final Set<Class<? extends Annotation>> annotations) {
        for (final Class<? extends Annotation> a : annotations) {
            if (element.isAnnotationPresent(a)) {
                return true;
            }
        }
        return false;
    }

    @SuppressWarnings("unused")
    private void afterTypeDiscovery(@Observes final AfterTypeDiscovery afterTypeDiscovery) {
        if (LOGGER.isLoggable(Level.CONFIG) && !jerseyVetoedTypes.isEmpty()) {
            LOGGER.config(LocalizationMessages.CDI_TYPE_VETOED(customHk2TypesProvider,
                    listTypes(new StringBuilder().append("\n"), jerseyVetoedTypes).toString()));
        }
    }

    @SuppressWarnings("unused")
    private void beforeBeanDiscovery(@Observes final BeforeBeanDiscovery beforeBeanDiscovery, final BeanManager beanManager) {
        beforeBeanDiscovery.addAnnotatedType(beanManager.createAnnotatedType(JaxRsParamProducer.class));
    }

    @SuppressWarnings("unused")
    private void processInjectionTarget(@Observes final ProcessInjectionTarget event) {
        final InjectionTarget it = event.getInjectionTarget();
        final Class<?> componentClass = event.getAnnotatedType().getJavaClass();

        final Set<InjectionPoint> cdiInjectionPoints = filterHk2InjectionPointsOut(it.getInjectionPoints());

        for (final InjectionPoint injectionPoint : cdiInjectionPoints) {
            final Member member = injectionPoint.getMember();
            if (member instanceof Field) {
                addInjecteeToSkip(componentClass, fieldsToSkip, (Field) member);
            } else if (member instanceof Method) {
                addInjecteeToSkip(componentClass, methodsToSkip, (Method) member);
            }
        }

        Hk2InjectedCdiTarget target = null;
        if (isJerseyOrDependencyType(componentClass)) {
            target = new Hk2InjectedCdiTarget(it, componentClass.getClassLoader()) {

                @Override
                public Set<InjectionPoint> getInjectionPoints() {
                    
                    
                    return Collections.emptySet();
                }
            };
        } else if (isJaxRsComponentType(componentClass)
                || jaxrsInjectableTypes.contains(event.getAnnotatedType().getBaseType())) {
            target = new Hk2InjectedCdiTarget(it, componentClass.getClassLoader()) {

                @Override
                public Set<InjectionPoint> getInjectionPoints() {
                    
                    return cdiInjectionPoints;
                }
            };
        }

        if (target != null) {
            notify(target);
            
            event.setInjectionTarget(target);
        }
    }

    private Set<InjectionPoint> filterHk2InjectionPointsOut(final Set<InjectionPoint> originalInjectionPoints) {
        final Set<InjectionPoint> filteredInjectionPoints = new HashSet<>();
        for (final InjectionPoint ip : originalInjectionPoints) {
            final Type injectedType = ip.getType();
            if (customHk2TypesProvider != null && customHk2TypesProvider.getHk2Types().contains(injectedType)) {
                
                hk2ProvidedTypes.add(injectedType);
            } else {
                if (injectedType instanceof Class<?>) {
                    final Class<?> injectedClass = (Class<?>) injectedType;
                    if (isJerseyOrDependencyType(injectedClass)) {
                        
                        hk2ProvidedTypes.add(injectedType);
                    } else {
                        filteredInjectionPoints.add(ip);
                    }
                } else { 
                    if (isInjectionProvider(injectedType)
                            && (isProviderOfJerseyType((ParameterizedType) injectedType))) {
                        
                        hk2ProvidedTypes.add(((ParameterizedType) injectedType).getActualTypeArguments()[0]);
                    } else {
                        filteredInjectionPoints.add(ip);
                    }
                }
            }
        }
        return filteredInjectionPoints;
    }

    private boolean isInjectionProvider(final Type injectedType) {
        return injectedType instanceof ParameterizedType
                && ((ParameterizedType) injectedType).getRawType() == javax.inject.Provider.class;
    }

    private boolean isProviderOfJerseyType(final ParameterizedType provider) {
        final Type firstArgumentType = provider.getActualTypeArguments()[0];
        if (firstArgumentType instanceof Class && isJerseyOrDependencyType((Class<?>) firstArgumentType)) {
            return true;
        }
        return (customHk2TypesProvider != null && customHk2TypesProvider.getHk2Types().contains(firstArgumentType));
    }

    private <T> void addInjecteeToSkip(final Class<?> componentClass, final Map<Class<?>, Set<T>> toSkip, final T member) {
        if (!toSkip.containsKey(componentClass)) {
            toSkip.put(componentClass, new HashSet<T>());
        }
        toSkip.get(componentClass).add(member);
    }

    
    @SuppressWarnings("serial")
    public static class CdiDefaultAnnotation extends AnnotationLiteral<Default> implements Default {

        private static final long serialVersionUID = 1L;
    }

    @SuppressWarnings({"unused", "unchecked", "rawtypes"})
    private void afterDiscoveryObserver(@Observes final AfterBeanDiscovery abd) {
        if (customHk2TypesProvider != null) {
            hk2ProvidedTypes.addAll(customHk2TypesProvider.getHk2Types());
        }

        for (final Type t : hk2ProvidedTypes) {
            abd.addBean(new Hk2Bean(t));
        }
    }

    
     Map<Class<?>, Set<Field>> getFieldsToSkip() {
        return fieldsToSkip;
    }

    
     Map<Class<?>, Set<Method>> getMethodsToSkip() {
        return methodsToSkip;
    }

    
     ServiceLocator getEffectiveLocator() {
        return locatorManager.getEffectiveLocator();
    }

    
     void addLocator(final ServiceLocator locator) {
        locatorManager.registerLocator(locator);
    }

    
     void notify(final Hk2InjectedTarget target) {
        if (locatorManager instanceof InjectionTargetListener) {
            ((InjectionTargetListener) locatorManager).notify(target);
        }
    }

    
     boolean isJaxRsComponentType(final Class<?> clazz) {
        return jaxRsComponentCache.compute(clazz);
    }

    private static boolean isJerseyOrDependencyType(final Class<?> clazz) {
        if (clazz.isPrimitive() || clazz.isSynthetic()) {
            return false;
        }

        final Package pkg = clazz.getPackage();
        if (pkg == null) { 
            LOGGER.warning(String.format("Class %s has null package", clazz));
            return false;
        }

        final String pkgName = pkg.getName();
        return !clazz.isAnnotationPresent(JerseyVetoed.class)
                && (pkgName.contains("org.glassfish.hk2")
                            || pkgName.contains("jersey.repackaged")
                            || pkgName.contains("org.jvnet.hk2")
                            || (pkgName.startsWith("org.glassfish.jersey")
                                        && !pkgName.startsWith("org.glassfish.jersey.examples")
                                        && !pkgName.startsWith("org.glassfish.jersey.tests"))
                            || (pkgName.startsWith("com.sun.jersey")
                                        && !pkgName.startsWith("com.sun.jersey.examples")
                                        && !pkgName.startsWith("com.sun.jersey.tests")));
    }

    private void bindHk2ClassAnalyzer() {
        final ClassAnalyzer defaultClassAnalyzer =
                locator.getService(ClassAnalyzer.class, ClassAnalyzer.DEFAULT_IMPLEMENTATION_NAME);

        final int skippedElements = methodsToSkip.size() + fieldsToSkip.size();

        final ClassAnalyzer customizedClassAnalyzer = skippedElements > 0
                ? new InjecteeSkippingAnalyzer(defaultClassAnalyzer, methodsToSkip, fieldsToSkip)
                : defaultClassAnalyzer;

        final DynamicConfiguration dc = Injections.getConfiguration(locator);

        final ScopedBindingBuilder bindingBuilder =
                Injections.newBinder(customizedClassAnalyzer);

        bindingBuilder.analyzeWith(ClassAnalyzer.DEFAULT_IMPLEMENTATION_NAME)
                .to(ClassAnalyzer.class)
                .named(CDI_CLASS_ANALYZER);

        Injections.addBinding(bindingBuilder, dc);

        dc.commit();
    }

    private StringBuilder listTypes(final StringBuilder logMsgBuilder, final Collection<Type> types) {
        for (final Type t : types) {
            logMsgBuilder.append(String.format(" - %s%n", t));
        }
        return logMsgBuilder;
    }

    @SuppressWarnings("unchecked")
    private abstract class Hk2InjectedCdiTarget implements Hk2InjectedTarget {

        private final InjectionTarget delegate;
        private final ClassLoader targetClassLoader;

        private volatile ServiceLocator effectiveLocator;

        public Hk2InjectedCdiTarget(final InjectionTarget delegate,
                                    final ClassLoader targetClassLoader) {
            this.delegate = delegate;
            this.targetClassLoader = targetClassLoader;
        }

        @Override
        public abstract Set<InjectionPoint> getInjectionPoints();

        @Override
        public ClassLoader getInjectionTargetClassLoader() {
            return targetClassLoader;
        }

        @Override
        public void inject(final Object t, final CreationalContext cc) {
            delegate.inject(t, cc);

            if (effectiveLocator == null) {
                effectiveLocator = getEffectiveLocator();
            }
            if (effectiveLocator != null) {
                effectiveLocator.inject(t, CdiComponentProvider.CDI_CLASS_ANALYZER);
            }
        }

        @Override
        public void postConstruct(final Object t) {
            delegate.postConstruct(t);
        }

        @Override
        public void preDestroy(final Object t) {
            delegate.preDestroy(t);
        }

        @Override
        public Object produce(final CreationalContext cc) {
            return delegate.produce(cc);
        }

        @Override
        public void dispose(final Object t) {
            delegate.dispose(t);
        }

        @Override
        public void setLocator(final ServiceLocator effectiveLocator) {
            this.effectiveLocator = effectiveLocator;
        }
    }

    private class Hk2Bean implements Bean {

        private final Type t;

        public Hk2Bean(final Type t) {
            this.t = t;
        }

        @Override
        public Class getBeanClass() {
            return (Class) t;
        }

        @Override
        public Set getInjectionPoints() {
            return Collections.emptySet();
        }

        @Override
        public boolean isNullable() {
            return true;
        }

        @Override
        public Object create(final CreationalContext creationalContext) {
            return getEffectiveLocator().getService(t);
        }

        @Override
        public void destroy(final Object instance, final CreationalContext creationalContext) {
        }

        @Override
        public Set getTypes() {
            return Collections.singleton(t);
        }

        @Override
        public Set getQualifiers() {
            return Collections.singleton(new CdiDefaultAnnotation());
        }

        @Override
        public Class getScope() {
            return Dependent.class;
        }

        @Override
        public String getName() {
            return t.toString();
        }

        @Override
        public Set getStereotypes() {
            return Collections.emptySet();
        }

        @Override
        public boolean isAlternative() {
            return false;
        }
    }
}

<code block>

package org.glassfish.jersey.ext.cdi1x.internal;

import java.lang.annotation.Annotation;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import javax.enterprise.context.spi.CreationalContext;
import javax.enterprise.inject.AmbiguousResolutionException;
import javax.enterprise.inject.spi.Bean;
import javax.enterprise.inject.spi.BeanManager;
import javax.inject.Qualifier;

import org.glassfish.jersey.ext.cdi1x.internal.spi.BeanManagerProvider;
import org.glassfish.jersey.ext.cdi1x.internal.spi.Hk2LocatorManager;
import org.glassfish.jersey.internal.ServiceFinder;
import org.glassfish.jersey.model.internal.RankedComparator;
import org.glassfish.jersey.model.internal.RankedProvider;


public final class CdiUtil {

    private static final BeanManagerProvider BEAN_MANAGER_PROVIDER = new DefaultBeanManagerProvider();

    
    private CdiUtil() {
        throw new AssertionError("No instances allowed.");
    }

    
    public static Annotation[] getQualifiers(final Annotation[] annotations) {
        final List<Annotation> result = new ArrayList<>(annotations.length);
        for (final Annotation a : annotations) {
            if (a.annotationType().isAnnotationPresent(Qualifier.class)) {
                result.add(a);
            }
        }
        return result.toArray(new Annotation[result.size()]);
    }

    
    public static BeanManager getBeanManager() {
        final BeanManagerProvider provider = lookupService(BeanManagerProvider.class);
        if (provider != null) {
            return provider.getBeanManager();
        }

        return BEAN_MANAGER_PROVIDER.getBeanManager();
    }

    
    static Hk2LocatorManager createHk2LocatorManager() {
        final Hk2LocatorManager manager = lookupService(Hk2LocatorManager.class);
        return manager != null ? manager : new DefaultHk2LocatorManager();
    }

    
    static <T> T lookupService(final Class<T> clazz) {
        final List<RankedProvider<T>> providers = new LinkedList<>();

        for (final T provider : ServiceFinder.find(clazz)) {
            providers.add(new RankedProvider<>(provider));
        }
        Collections.sort(providers, new RankedComparator<T>(RankedComparator.Order.ASCENDING));

        return providers.isEmpty() ? null : providers.get(0).getProvider();
    }

    
    public static <T> T getBeanReference(final Class<T> beanClass, final BeanManager beanManager) {
        final Set<Bean<?>> beans = beanManager.getBeans(beanClass);
        if (beans.isEmpty()) {
            return null;
        }

        try {
            return getBeanReference(beanClass, beanManager.resolve(beans), beanManager);
        } catch (final AmbiguousResolutionException ex) {
            
            for (final Bean<?> b : beans) {
                final T reference = getBeanReference(beanClass, b, beanManager);
                if (reference != null) {
                    return reference;
                }
            }
        }

        return null;
    }

    
    static <T> T getBeanReference(final Class<T> clazz, final Bean extensionBean, final BeanManager beanManager) {
        final CreationalContext<?> creationalContext = beanManager.createCreationalContext(extensionBean);
        final Object result = beanManager.getReference(extensionBean, clazz, creationalContext);

        return clazz.cast(result);
    }

    
    public static Class<? extends Annotation> getBeanScope(final Class<?> beanClass, final BeanManager beanManager) {
        final Set<Bean<?>> beans = beanManager.getBeans(beanClass);
        if (beans.isEmpty()) {
            return null;
        }
        for (Bean b : beans) {
            return b.getScope();
        }
        return null;
    }
}

<code block>


package org.glassfish.jersey.ext.cdi1x.internal;

import javax.ws.rs.WebApplicationException;

import org.glassfish.jersey.ext.cdi1x.internal.spi.Hk2LocatorManager;

import org.glassfish.hk2.api.ServiceLocator;


final class DefaultHk2LocatorManager implements Hk2LocatorManager {

    private volatile ServiceLocator locator;

    @Override
    public void registerLocator(final ServiceLocator locator) {
        if (this.locator == null) {
            this.locator = locator;
        } else if (this.locator != locator) {
            throw new WebApplicationException(LocalizationMessages.CDI_MULTIPLE_LOCATORS_INTO_SIMPLE_APP());
        }
    }

    @Override
    public ServiceLocator getEffectiveLocator() {
        return locator;
    }
}

<code block>


package org.glassfish.jersey.ext.cdi1x.internal.spi;

import javax.enterprise.inject.spi.InjectionTarget;

import org.glassfish.hk2.api.ServiceLocator;


public interface Hk2InjectedTarget extends InjectionTarget {

    
    public ClassLoader getInjectionTargetClassLoader();

    
    public void setLocator(ServiceLocator locator);
}

<code block>


package org.glassfish.jersey.ext.cdi1x.internal;

import javax.annotation.Priority;
import javax.enterprise.inject.spi.BeanManager;

import org.glassfish.jersey.ext.cdi1x.internal.spi.BeanManagerProvider;
import org.glassfish.jersey.ext.cdi1x.internal.spi.Hk2LocatorManager;

import org.glassfish.hk2.api.ServiceLocator;

import org.junit.Test;

import static org.hamcrest.CoreMatchers.instanceOf;
import static org.hamcrest.CoreMatchers.nullValue;
import static org.junit.Assert.assertThat;

import mockit.Mock;
import mockit.MockUp;
import mockit.Mocked;
import mockit.Verifications;


public class CdiUtilTest {

    public static class TestBeanManagerProvider implements BeanManagerProvider {

        @Override
        public BeanManager getBeanManager() {
            throw new RuntimeException("BeanManager!");
        }
    }

    @Test
    public void getBeanManagerCustom(@Mocked final TestBeanManagerProvider custom,
                                     @Mocked final DefaultBeanManagerProvider fallback) throws Exception {
        CdiUtil.getBeanManager();

        new Verifications() {{
            custom.getBeanManager(); times = 1;
            fallback.getBeanManager(); times = 0;
        }};
    }

    @Test
    public void getDefaultBeanManagerDefault(@Mocked final DefaultBeanManagerProvider fallback) throws Exception {
        new MockUp<CdiUtil>() {
            @Mock
            @SuppressWarnings("UnusedDeclaration")
            <T> T lookupService(final Class<T> clazz) {
                return null;
            }
        };

        CdiUtil.getBeanManager();

        new Verifications() {{
            fallback.getBeanManager(); times = 1;
        }};
    }

    @Priority(500)
    public static class MyServiceOne implements MyService {
    }

    @Priority(100)
    public static class MyServiceTwo implements MyService {
    }

    @Priority(300)
    public static class MyServiceThree implements MyService {
    }

    @Test
    public void testLookupService() throws Exception {
        assertThat(CdiUtil.lookupService(MyService.class), instanceOf(MyServiceTwo.class));
    }

    @Test
    public void testLookupServiceNegative() throws Exception {
        assertThat(CdiUtil.lookupService(CdiUtil.class), nullValue());
    }

    public static class TestHk2LocatorManager implements Hk2LocatorManager {

        @Override
        public void registerLocator(final ServiceLocator locator) {
        }

        @Override
        public ServiceLocator getEffectiveLocator() {
            return null;
        }
    }

    @Test
    public void createHk2LocatorManagerCustom() throws Exception {
        assertThat(CdiUtil.createHk2LocatorManager(), instanceOf(TestHk2LocatorManager.class));
    }

    @Test
    public void createHk2LocatorManagerDefault() throws Exception {
        new MockUp<CdiUtil>() {
            @Mock
            @SuppressWarnings("UnusedDeclaration")
            <T> T lookupService(final Class<T> clazz) {
                return null;
            }
        };

        assertThat(CdiUtil.createHk2LocatorManager(), instanceOf(DefaultHk2LocatorManager.class));
    }
}

<code block>


package org.glassfish.jersey.ext.cdi1x.servlet.internal;

import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.ConcurrentMap;

import javax.enterprise.inject.spi.BeanManager;
import javax.servlet.ServletContext;

import org.glassfish.jersey.ext.cdi1x.internal.CdiUtil;
import org.glassfish.jersey.ext.cdi1x.internal.spi.Hk2InjectedTarget;
import org.glassfish.jersey.ext.cdi1x.internal.spi.InjectionTargetListener;
import org.glassfish.jersey.ext.cdi1x.internal.spi.Hk2LocatorManager;
import org.glassfish.jersey.internal.util.collection.DataStructures;

import org.glassfish.hk2.api.ServiceLocator;


public class ServletHk2LocatorManager implements Hk2LocatorManager, InjectionTargetListener {

    private final ConcurrentMap<String, ServiceLocator> locatorsByContextPath;
    private final ConcurrentMap<ClassLoader, List<Hk2InjectedTarget>> injectionTargetsByAppClassLoader;

    private volatile BeanManager beanManager;

    private volatile ServiceLocator locator;
    private volatile ServletContext servletContext;

    private volatile boolean multipleLocators = false;

    public ServletHk2LocatorManager() {
        locatorsByContextPath = DataStructures.createConcurrentMap();
        injectionTargetsByAppClassLoader = DataStructures.createConcurrentMap();
    }

    @Override
    public void registerLocator(final ServiceLocator locator) {
        if (this.locator == null) {
            this.locator = locator;
        } else {
            multipleLocators = true;
            
            servletContext = CdiUtil.getBeanReference(ServletContext.class, getBeanManager());
        }

        
        final javax.servlet.ServletConfig hk2ServletConfig = locator.getService(javax.servlet.ServletConfig.class);
        final ServletContext hk2ServletContext = hk2ServletConfig != null
                ? hk2ServletConfig.getServletContext()                      
                : locator.getService(javax.servlet.ServletContext.class);   

        locatorsByContextPath.put(hk2ServletContext.getContextPath(), locator);

        
        final ClassLoader webappClassLoader = hk2ServletContext.getClassLoader();
        final List<Hk2InjectedTarget> targets = injectionTargetsByAppClassLoader.get(webappClassLoader);
        if (targets != null) {
            for (final Hk2InjectedTarget target : targets) {
                target.setLocator(locator);
            }
        }
    }

    private BeanManager getBeanManager() {
        if (beanManager == null) {
            beanManager = CdiUtil.getBeanManager();
        }
        return beanManager;
    }

    @Override
    public ServiceLocator getEffectiveLocator() {
        return locator == null
                ? null
                : !multipleLocators ? locator : locatorsByContextPath.get(servletContext.getContextPath());
    }

    @Override
    public void notify(final Hk2InjectedTarget target) {
        final List<Hk2InjectedTarget> newList = new LinkedList<>();
        final List<Hk2InjectedTarget> existingList = injectionTargetsByAppClassLoader
                .putIfAbsent(target.getInjectionTargetClassLoader(), newList);

        ((existingList != null) ? existingList : newList).add(target);
    }
}

<code block>

package org.glassfish.jersey.tests.cdi.bv;

import javax.enterprise.context.RequestScoped;
import javax.validation.constraints.NotNull;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Context;


@Path("old/fashioned")
@RequestScoped
public class CdiOldFashionedResource {

    
    @Path("validate")
    @GET
    public String getQ(@QueryParam("q") @NotNull String q) {

        return q;
    }
}

<code block>

package org.glassfish.jersey.tests.cdi.bv;

import javax.validation.constraints.NotNull;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Context;


@Path("validated/property")
public class Hk2PropertyInjectedResource {

    @QueryParam("q")
    @NotNull
    String q;

    ValidationResult validationResult;

    public ValidationResult getValidationResult() {
        return validationResult;
    }

    @Context
    public void setValidationResult(ValidationResult validationResult) {
        this.validationResult = validationResult;
    }

    
    @Path("validate")
    @GET
    public int getValidate() {
        return validationResult.getViolationCount();
    }
}

<code block>

package org.glassfish.jersey.tests.cdi.bv;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;

import javax.inject.Inject;
import javax.inject.Provider;
import javax.inject.Singleton;
import javax.validation.ConstraintViolationException;
import javax.validation.ValidationException;
import javax.ws.rs.core.Context;

import org.glassfish.jersey.server.spi.ValidationInterceptorContext;
import org.glassfish.jersey.server.spi.ValidationInterceptor;

import org.glassfish.hk2.api.Factory;
import org.glassfish.hk2.api.PerLookup;
import org.glassfish.hk2.utilities.binding.AbstractBinder;


public class Hk2ValidationInterceptor implements ValidationInterceptor {


    private final Provider<Hk2ValidationResult> validationResult;

    public Hk2ValidationInterceptor(Provider<Hk2ValidationResult> validationResult) {
        this.validationResult = validationResult;
    }

    public static class Binder extends AbstractBinder {

        @Override
        protected void configure() {
            bindFactory(ValidationInterceptorFactory.class, Singleton.class)
                    .to(ValidationInterceptor.class).in(PerLookup.class);
        }

    }

    private static class ValidationInterceptorFactory implements Factory<ValidationInterceptor> {

        @Inject
        Provider<Hk2ValidationResult> validationResultProvider;

        @Override
        public ValidationInterceptor provide() {

            return new Hk2ValidationInterceptor(validationResultProvider);
        }

        @Override
        public void dispose(ValidationInterceptor validationInterceptor) {
        }
    }

    @Override
    public void onValidate(
            ValidationInterceptorContext ctx) throws ValidationException {
        try {
            ctx.proceed();
        } catch (ConstraintViolationException ex) {
            ensureValidationResultInjected(ctx, ex);
            validationResult.get().setViolations(ex.getConstraintViolations());
        }
    }

    private void ensureValidationResultInjected(
            final ValidationInterceptorContext ctx, final ConstraintViolationException ex) {

        if (!isValidationResultInArgs(ctx.getArgs())
                && !isValidationResultInResource(ctx)
                && !hasValidationResultProperty(ctx.getResource())) {

            throw ex;
        }
    }

    private boolean isValidationResultInResource(ValidationInterceptorContext ctx) {
        Class<?> clazz = ctx.getResource().getClass();
        do {
            for (Field f : clazz.getDeclaredFields()) {
                
                if (ValidationResult.class.isAssignableFrom(f.getType())
                        && f.getAnnotation(Context.class) != null) {
                    return true;
                }
            }
            clazz = clazz.getSuperclass();
        } while (clazz != Object.class);
        return false;
    }

    private boolean isValidationResultInArgs(Object[] args) {
        for (Object a : args) {
            if (a != null && ValidationResult.class.isAssignableFrom(a.getClass())) {
                return true;
            }
        }
        return false;
    }

    
    public static boolean hasValidationResultProperty(final Object resource) {
        return getValidationResultGetter(resource) != null && getValidationResultSetter(resource) != null;
    }

    
    public static Method getValidationResultGetter(final Object resource) {
        Class<?> clazz = resource.getClass();
        do {
            for (Method m : clazz.getDeclaredMethods()) {
                if (isValidationResultGetter(m)) {
                    return m;
                }
            }
            clazz = clazz.getSuperclass();
        } while (clazz != Object.class);
        return null;
    }

    
    private static boolean isValidationResultGetter(Method m) {
        return m.getName().startsWith("get")
                && ValidationResult.class.isAssignableFrom(m.getReturnType())
                && Modifier.isPublic(m.getModifiers()) && m.getParameterTypes().length == 0;
    }

    
    public static Method getValidationResultSetter(final Object resource) {
        Class<?> clazz = resource.getClass();
        do {
            for (Method m : clazz.getDeclaredMethods()) {
                if (isValidationResultSetter(m)) {
                    return m;
                }
            }
            clazz = clazz.getSuperclass();
        } while (clazz != Object.class);
        return null;
    }

    
    private static boolean isValidationResultSetter(Method m) {
        return m.getName().startsWith("set") && m.getParameterTypes().length == 1
                && ValidationResult.class.isAssignableFrom(m.getParameterTypes()[0])
                && m.getReturnType() == Void.TYPE && Modifier.isPublic(m.getModifiers())
                && m.getAnnotation(Context.class) != null;
    }

}

<code block>

package org.glassfish.jersey.tests.cdi.bv;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Set;

import javax.enterprise.inject.spi.BeanManager;
import javax.inject.Inject;
import javax.validation.ConstraintViolation;


public final class ValidationResultUtil {

    private static final String VALIDATION_RESULT = ValidationResult.class.getName();

    private ValidationResultUtil() {
        throw new AssertionError("Instantiation not allowed.");
    }

    
    public static Field getValidationResultField(final Object resource) {
        Class<?> clazz = resource.getClass();
        do {
            for (Field f : clazz.getDeclaredFields()) {
                
                if (f.getType().getName().equals(VALIDATION_RESULT)
                        && f.getAnnotation(Inject.class) != null) {
                    return f;
                }
            }
            clazz = clazz.getSuperclass();
        } while (clazz != Object.class);
        return null;
    }

    
    public static void updateValidationResultField(Object resource, Field field,
                                                   Set<ConstraintViolation<?>> constraints) {
        try {
            field.setAccessible(true);
            final Object obj = field.get(resource);
            Method setter;
            try {
                setter = obj.getClass().getMethod("setViolations", Set.class);
            } catch (NoSuchMethodException e) {
                setter = obj.getClass().getSuperclass().getMethod("setViolations", Set.class);
            }
            setter.invoke(obj, constraints);
        } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {
            
            System.out.println("Damn it...");
        } catch (Throwable t) {
            System.out.println("What the heck...");
        }
    }

    
    public static void updateValidationResultProperty(Object resource, Method getter,
                                                      Set<ConstraintViolation<?>> constraints) {
        try {
            final Object obj = getter.invoke(resource);
            Method setViolations;
            try {
                setViolations = obj.getClass().getMethod("setViolations", Set.class);
            } catch (NoSuchMethodException e) {
                setViolations = obj.getClass().getSuperclass().getMethod("setViolations", Set.class);
            }
            setViolations.invoke(obj, constraints);

            final Method setter = getValidationResultSetter(resource);

            if (setter != null) {
                setter.invoke(resource, obj);
            }
        } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {
            
        }
    }

    
    public static boolean hasValidationResultProperty(final Object resource) {
        return getValidationResultGetter(resource) != null && getValidationResultSetter(resource) != null;
    }

    
    public static Method getValidationResultGetter(final Object resource) {
        Class<?> clazz = resource.getClass();
        do {
            for (Method m : clazz.getDeclaredMethods()) {
                if (isValidationResultGetter(m)) {
                    return m;
                }
            }
            clazz = clazz.getSuperclass();
        } while (clazz != Object.class);
        return null;
    }

    
    private static boolean isValidationResultGetter(Method m) {
        return m.getName().startsWith("get")
                && m.getReturnType().getName().equals(VALIDATION_RESULT)
                && Modifier.isPublic(m.getModifiers()) && m.getParameterTypes().length == 0;
    }

    
    public static Method getValidationResultSetter(final Object resource) {
        return getValidationResultSetter(resource.getClass());
    }

    private static Method getValidationResultSetter(final Class<?> resourceClass) {
        Class<?> clazz = resourceClass;
        do {
            for (Method m : clazz.getDeclaredMethods()) {
                if (isValidationResultSetter(m)) {
                    return m;
                }
            }
            clazz = clazz.getSuperclass();
        } while (clazz != Object.class);
        return null;
    }

    
    private static boolean isValidationResultSetter(Method m) {
        return m.getName().startsWith("set") && m.getParameterTypes().length == 1
                && m.getParameterTypes()[0].getName().equals(VALIDATION_RESULT)
                && m.getReturnType() == Void.TYPE && Modifier.isPublic(m.getModifiers())
                && m.getAnnotation(Inject.class) != null;
    }
}

<code block>

package org.glassfish.jersey.tests.cdi.bv;

import javax.validation.constraints.NotNull;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Context;


@Path("validated/param")
public class Hk2ParamInjectedResource {

    
    @Path("validate")
    @GET
    public int getValidate(@QueryParam("q") @NotNull String q, @Context Hk2ValidationResult validationResult) {

        return validationResult.getViolationCount();
    }
}

<code block>

package org.glassfish.jersey.tests.cdi.bv;

import javax.enterprise.context.RequestScoped;

import javax.inject.Inject;
import javax.validation.constraints.NotNull;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.QueryParam;


@Path("validated/field")
@RequestScoped
public class CdiFieldInjectedResource {

    @Inject
    ValidationResult validationResult;

    @QueryParam("q")
    @NotNull
    String q;

    
    @Path("validate")
    @GET
    public int getValidate() {

        return validationResult.getViolationCount();
    }
}

<code block>

package org.glassfish.jersey.tests.cdi.bv;

import javax.enterprise.context.RequestScoped;

import javax.validation.constraints.NotNull;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Context;


@Path("validated/param")
@RequestScoped
public class CdiParamInjectedResource {

    
    @Path("validate")
    @GET
    public int getValidate(@QueryParam("q") @NotNull String q, @Context ValidationResult validationResult) {

        return validationResult.getViolationCount();
    }
}

<code block>

package org.glassfish.jersey.tests.cdi.bv;

import javax.validation.constraints.NotNull;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Context;


@Path("validated/field")
public class Hk2FieldInjectedResource {

    @QueryParam("q")
    @NotNull
    String q;

    @Context
    ValidationResult validationResult;

    
    @Path("validate")
    @GET
    public int getValidate() {
        return validationResult.getViolationCount();
    }
}

<code block>

package org.glassfish.jersey.tests.cdi.bv;

import javax.validation.constraints.NotNull;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Context;


@Path("old/fashioned")
public class Hk2OldFashionedResource {

    
    @Path("validate")
    @GET
    public String getQ(@QueryParam("q") @NotNull String q) {

        return q;
    }
}

<code block>

package org.glassfish.jersey.tests.cdi.bv;

import javax.ws.rs.ApplicationPath;

import org.glassfish.jersey.process.internal.RequestScoped;
import org.glassfish.jersey.server.ResourceConfig;

import org.glassfish.hk2.utilities.binding.AbstractBinder;


@ApplicationPath("/hk2")
public class Hk2Application extends ResourceConfig {

    public Hk2Application() {
        super(Hk2ParamInjectedResource.class,
                Hk2FieldInjectedResource.class,
                Hk2PropertyInjectedResource.class,
                Hk2OldFashionedResource.class);

        register(new Hk2ValidationInterceptor.Binder());
        register(new AbstractBinder(){

            @Override
            protected void configure() {
                bindAsContract(Hk2ValidationResult.class).to(ValidationResult.class).in(RequestScoped.class);
            }
        });
    }

}
<code block>

package org.glassfish.jersey.tests.cdi.bv;

import java.net.URI;

import javax.ws.rs.BadRequestException;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.UriBuilder;

import org.glassfish.jersey.filter.LoggingFilter;
import org.glassfish.jersey.test.JerseyTest;

import org.junit.Ignore;
import org.junit.Test;
import org.junit.experimental.theories.Theory;

import static org.hamcrest.CoreMatchers.containsString;
import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertThat;


public abstract class BaseValidationTest extends JerseyTest {

    public abstract String getAppPath();

    @Override
    protected URI getBaseUri() {
        return UriBuilder.fromUri(super.getBaseUri()).path("cdi-beanvalidation-webapp").path(getAppPath()).build();
    }

    @Test
    public void testParamValidatedResourceNoParam() throws Exception {

        Integer errors = target().register(LoggingFilter.class)
                .path("validated").path("param").path("validate")
                .request().get(Integer.class);

        assertThat(errors, is(1));
    }

    @Test
    public void testParamValidatedResourceParamProvided() throws Exception {
        Integer errors = target().register(LoggingFilter.class).path("validated").path("field").path("validate")
                .queryParam("q", "one").request().get(Integer.class);
        assertThat(errors, is(0));
    }

    @Test
    public void testFieldValidatedResourceNoParam() throws Exception {

        Integer errors = target().register(LoggingFilter.class)
                .path("validated").path("field").path("validate")
                .request().get(Integer.class);

        assertThat(errors, is(1));
    }

    @Test
    public void testFieldValidatedResourceParamProvided() throws Exception {
        Integer errors = target().register(LoggingFilter.class).path("validated").path("field").path("validate")
                .queryParam("q", "one").request().get(Integer.class);
        assertThat(errors, is(0));
    }

    @Test
    public void testPropertyValidatedResourceNoParam() throws Exception {

        Integer errors = target().register(LoggingFilter.class)
                .path("validated").path("property").path("validate")
                .request().get(Integer.class);

        assertThat(errors, is(1));
    }

    @Test
    public void testPropertyValidatedResourceParamProvided() throws Exception {
        Integer errors = target().register(LoggingFilter.class).path("validated").path("property").path("validate")
                .queryParam("q", "one").request().get(Integer.class);
        assertThat(errors, is(0));
    }

    @Test
    public void testOldFashionedResourceNoParam() {

        Response response = target().register(LoggingFilter.class)
                .path("old").path("fashioned").path("validate")
                .request().get();

        assertThat(response.getStatus(), is(400));
    }

    @Test
    public void testOldFashionedResourceParamProvided() throws Exception {
        String response = target().register(LoggingFilter.class).path("old").path("fashioned").path("validate")
                .queryParam("q", "one").request().get(String.class);
        assertThat(response, is("one"));
    }
}

<code block>

package org.glassfish.jersey.tests.cdi.bv;

import javax.ws.rs.core.Application;

import org.glassfish.jersey.server.ResourceConfig;

import org.jboss.weld.environment.se.Weld;
import org.junit.Ignore;


public class Hk2Test extends BaseValidationTest {

    @Override
    protected Application configure() {
        return ResourceConfig.forApplicationClass(Hk2Application.class);
    }

    @Override
    public String getAppPath() {
        return "hk2";
    }
}

<code block>

package org.glassfish.jersey.tests.cdi.bv;

import java.net.URI;

import javax.ws.rs.core.Application;

import org.glassfish.jersey.server.ResourceConfig;

import org.jboss.weld.environment.se.Weld;


public class CdiTest extends BaseValidationTest {

    Weld weld;

    @Override
    public void setUp() throws Exception {
        weld = new Weld();
        weld.initialize();
        super.setUp();
    }

    @Override
    public void tearDown() throws Exception {
        weld.shutdown();
        super.tearDown();
    }

    @Override
    protected Application configure() {
        return ResourceConfig.forApplicationClass(CdiApplication.class);
    }

    @Override
    public String getAppPath() {
        return "cdi";
    }
}

<code block>

package org.glassfish.jersey.tests.cdi.resources;

import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.logging.Logger;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;

import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.inject.spi.BeanManager;

import javax.inject.Inject;

import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;


@ApplicationPath("/*")
@ApplicationScoped
public class MyApplication extends Application {

    static AtomicInteger postConstructCounter = new AtomicInteger();

    @Inject BeanManager bm;

    private static final Logger LOGGER = Logger.getLogger(MyApplication.class.getName());

    @Override
    public Set<Class<?>> getClasses() {
        final Set<Class<?>> classes = new HashSet<Class<?>>();
        classes.add(JCDIBeanDependentResource.class);
        classes.add(JDCIBeanException.class);
        classes.add(JDCIBeanDependentException.class);
        classes.add(JCDIBeanSingletonResource.class);
        classes.add(JCDIBeanPerRequestResource.class);
        classes.add(JCDIBeanExceptionMapper.class);
        classes.add(JCDIBeanDependentSingletonResource.class);
        classes.add(JCDIBeanDependentPerRequestResource.class);
        classes.add(JCDIBeanDependentExceptionMapper.class);
        classes.add(StutteringEchoResource.class);
        classes.add(StutteringEcho.class);
        classes.add(ReversingEchoResource.class);
        classes.add(CounterResource.class);
        classes.add(ConstructorInjectedResource.class);
        classes.add(ProducerResource.class);
        return classes;
    }

    
    @PostConstruct
    public void postConstruct() {
        LOGGER.info(String.format("%s: POST CONSTRUCT.", this.getClass().getName()));
        postConstructCounter.incrementAndGet();
        if (bm == null) {
            throw new IllegalStateException("BeanManager should have been injected into a CDI managed bean.");
        }
        if (postConstructCounter.intValue() > 1) {
            throw new IllegalStateException("postConstruct should have been invoked only once on app scoped bean.");
        }
    }

    @PreDestroy
    public void preDestroy() {
        LOGGER.info(String.format("%s: PRE DESTROY.", this.getClass().getName()));
    }
}
<code block>

package org.glassfish.jersey.tests.cdi.resources;

import java.net.URI;

import javax.ws.rs.core.Application;
import javax.ws.rs.core.UriBuilder;

import org.glassfish.jersey.test.JerseyTest;

import org.jboss.weld.environment.se.Weld;


public class CdiTest extends JerseyTest {

    Weld weld;

    @Override
    public void setUp() throws Exception {
        weld = new Weld();
        weld.initialize();
        super.setUp();
    }

    @Override
    public void tearDown() throws Exception {
        weld.shutdown();
        super.tearDown();
    }

    @Override
    protected Application configure() {
        return new MyApplication();
    }

    @Override
    protected URI getBaseUri() {
        return UriBuilder.fromUri(super.getBaseUri()).path("cdi-test-webapp").build();
    }
}


<code block>

package org.glassfish.jersey.server;

import java.io.IOException;
import java.io.OutputStream;
import java.net.URI;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.ws.rs.HttpMethod;
import javax.ws.rs.InternalServerErrorException;
import javax.ws.rs.NotFoundException;
import javax.ws.rs.ServiceUnavailableException;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.container.AsyncResponse;
import javax.ws.rs.container.CompletionCallback;
import javax.ws.rs.container.ConnectionCallback;
import javax.ws.rs.container.TimeoutHandler;
import javax.ws.rs.core.Configuration;
import javax.ws.rs.core.HttpHeaders;
import javax.ws.rs.core.MultivaluedMap;
import javax.ws.rs.core.Response;
import javax.ws.rs.ext.ExceptionMapper;

import javax.inject.Inject;
import javax.inject.Provider;

import org.glassfish.jersey.internal.inject.Injections;
import org.glassfish.jersey.internal.inject.Providers;
import org.glassfish.jersey.internal.util.Closure;
import org.glassfish.jersey.internal.util.Producer;
import org.glassfish.jersey.internal.util.PropertiesHelper;
import org.glassfish.jersey.internal.util.collection.Ref;
import org.glassfish.jersey.internal.util.collection.Refs;
import org.glassfish.jersey.internal.util.collection.Value;
import org.glassfish.jersey.message.internal.HeaderValueException;
import org.glassfish.jersey.message.internal.MessageBodyProviderNotFoundException;
import org.glassfish.jersey.message.internal.OutboundJaxrsResponse;
import org.glassfish.jersey.message.internal.OutboundMessageContext;
import org.glassfish.jersey.message.internal.TracingLogger;
import org.glassfish.jersey.process.internal.RequestScope;
import org.glassfish.jersey.process.internal.Stage;
import org.glassfish.jersey.process.internal.Stages;
import org.glassfish.jersey.server.internal.LocalizationMessages;
import org.glassfish.jersey.server.internal.ProcessingProviders;
import org.glassfish.jersey.server.internal.ServerTraceEvent;
import org.glassfish.jersey.server.internal.monitoring.EmptyRequestEventBuilder;
import org.glassfish.jersey.server.internal.monitoring.RequestEventBuilder;
import org.glassfish.jersey.server.internal.monitoring.RequestEventImpl;
import org.glassfish.jersey.server.internal.process.AsyncContext;
import org.glassfish.jersey.server.internal.process.Endpoint;
import org.glassfish.jersey.server.internal.process.MappableException;
import org.glassfish.jersey.server.internal.process.RequestProcessingContext;
import org.glassfish.jersey.server.internal.routing.UriRoutingContext;
import org.glassfish.jersey.server.monitoring.ApplicationEventListener;
import org.glassfish.jersey.server.monitoring.RequestEvent;
import org.glassfish.jersey.server.monitoring.RequestEventListener;
import org.glassfish.jersey.server.spi.ContainerResponseWriter;
import org.glassfish.jersey.server.spi.ExternalRequestContext;
import org.glassfish.jersey.server.spi.ExternalRequestScope;
import org.glassfish.jersey.server.spi.ResponseErrorMapper;
import org.glassfish.jersey.spi.ExceptionMappers;

import org.glassfish.hk2.api.ServiceLocator;

import static org.glassfish.jersey.server.internal.process.AsyncContext.State.COMPLETED;
import static org.glassfish.jersey.server.internal.process.AsyncContext.State.RESUMED;
import static org.glassfish.jersey.server.internal.process.AsyncContext.State.RUNNING;
import static org.glassfish.jersey.server.internal.process.AsyncContext.State.SUSPENDED;

import jersey.repackaged.com.google.common.base.Preconditions;


public class ServerRuntime {

    private final Stage<RequestProcessingContext> requestProcessingRoot;
    private final ProcessingProviders processingProviders;

    private final ServiceLocator locator;

    private final ScheduledExecutorService backgroundScheduler;
    private final Provider<ExecutorService> managedAsyncExecutor;

    private final RequestScope requestScope;
    private final ExceptionMappers exceptionMappers;
    private final ApplicationEventListener applicationEventListener;
    private final Configuration configuration;

    private final ExternalRequestScope externalRequestScope;

    private final TracingConfig tracingConfig;
    private final TracingLogger.Level tracingThreshold;

    private final boolean processResponseErrors;

     static final ExternalRequestScope<Object> NOOP_EXTERNAL_REQ_SCOPE = new ExternalRequestScope<Object>() {

        @Override
        public ExternalRequestContext<Object> open() {
            return null;
        }

        @Override
        public void close() {
        }

        @Override
        public void suspend(final ExternalRequestContext<Object> o) {
        }

        @Override
        public void resume(final ExternalRequestContext<Object> o) {
        }
    };

    
    public static class Builder {

        @Inject
        private ServiceLocator locator;
        @Inject
        @BackgroundScheduler
        private ScheduledExecutorService backgroundScheduler;
        @Inject
        @ManagedAsyncExecutor
        private Provider<ExecutorService> asyncExecutorProvider;
        @Inject
        private RequestScope requestScope;
        @Inject
        private ExceptionMappers exceptionMappers;
        @Inject
        private Configuration configuration;
        @Inject
        private ExternalRequestScope externalRequestScope;

        
        public ServerRuntime build(
                final Stage<RequestProcessingContext> processingRoot,
                final ApplicationEventListener eventListener,
                final ProcessingProviders processingProviders) {

            final ExternalRequestScope externalScope =
                    externalRequestScope != null ? externalRequestScope : NOOP_EXTERNAL_REQ_SCOPE;

            return new ServerRuntime(
                    processingRoot,
                    processingProviders,
                    locator,
                    backgroundScheduler,
                    asyncExecutorProvider,
                    requestScope,
                    exceptionMappers,
                    eventListener,
                    externalScope,
                    configuration);
        }
    }

    private ServerRuntime(final Stage<RequestProcessingContext> requestProcessingRoot,
                          final ProcessingProviders processingProviders,
                          final ServiceLocator locator,
                          final ScheduledExecutorService backgroundScheduler,
                          final Provider<ExecutorService> managedAsyncExecutorProvider,
                          final RequestScope requestScope,
                          final ExceptionMappers exceptionMappers,
                          final ApplicationEventListener applicationEventListener,
                          final ExternalRequestScope externalScope,
                          final Configuration configuration) {
        this.requestProcessingRoot = requestProcessingRoot;
        this.processingProviders = processingProviders;
        this.locator = locator;

        this.backgroundScheduler = backgroundScheduler;
        this.managedAsyncExecutor = managedAsyncExecutorProvider;

        this.requestScope = requestScope;
        this.exceptionMappers = exceptionMappers;
        this.applicationEventListener = applicationEventListener;
        this.externalRequestScope = externalScope;
        this.configuration = configuration;

        this.tracingConfig = TracingUtils.getTracingConfig(configuration);
        this.tracingThreshold = TracingUtils.getTracingThreshold(configuration);

        this.processResponseErrors = PropertiesHelper.isProperty(
                configuration.getProperty(ServerProperties.PROCESSING_RESPONSE_ERRORS_ENABLED));
    }

    
    public void process(final ContainerRequest request) {
        TracingUtils.initTracingSupport(tracingConfig, tracingThreshold, request);
        TracingUtils.logStart(request);

        final UriRoutingContext routingContext = request.getUriRoutingContext();

        RequestEventBuilder monitoringEventBuilder = EmptyRequestEventBuilder.INSTANCE;
        RequestEventListener monitoringEventListener = null;

        if (applicationEventListener != null) {
            monitoringEventBuilder = new RequestEventImpl.Builder()
                    .setContainerRequest(request)
                    .setExtendedUriInfo(routingContext);
            monitoringEventListener = applicationEventListener.onRequest(
                    monitoringEventBuilder.build(RequestEvent.Type.START));
        }

        request.setProcessingProviders(processingProviders);

        final RequestProcessingContext context = new RequestProcessingContext(
                locator,
                request,
                routingContext,
                monitoringEventBuilder,
                monitoringEventListener);

        request.checkState();
        final Responder responder = new Responder(context, ServerRuntime.this);
        final RequestScope.Instance requestScopeInstance = requestScope.createInstance();
        final AsyncResponderHolder asyncResponderHolder =
                new AsyncResponderHolder(responder, externalRequestScope, requestScopeInstance, externalRequestScope.open());
        context.initAsyncContext(asyncResponderHolder);

        requestScope.runInScope(requestScopeInstance, new Runnable() {
            @Override
            public void run() {
                try {
                    
                    
                    OutboundJaxrsResponse.Builder.setBaseUri(request.getBaseUri());

                    final Ref<Endpoint> endpointRef = Refs.emptyRef();
                    final RequestProcessingContext data = Stages.process(context, requestProcessingRoot, endpointRef);

                    final Endpoint endpoint = endpointRef.get();
                    if (endpoint == null) {
                        
                        throw new NotFoundException();
                    }

                    final ContainerResponse response = endpoint.apply(data);

                    if (!asyncResponderHolder.isAsync()) {
                        responder.process(response);
                    } else {
                        externalRequestScope.suspend(asyncResponderHolder.externalContext);
                    }
                } catch (final Throwable throwable) {
                    responder.process(throwable);
                } finally {
                    asyncResponderHolder.release();
                    
                    OutboundJaxrsResponse.Builder.clearBaseUri();
                }
            }
        });
    }

    
    ScheduledExecutorService getBackgroundScheduler() {
        return backgroundScheduler;
    }

    
    private static void ensureAbsolute(final URI location, final MultivaluedMap<String, Object> headers,
                                       final ContainerRequest request) {
        if (location == null || location.isAbsolute()) {
            return;
        }
        
        headers.putSingle(HttpHeaders.LOCATION, request.getBaseUri().resolve(location));
    }

    private static class AsyncResponderHolder implements Value<AsyncContext> {

        private final Responder responder;
        private final ExternalRequestScope externalScope;
        private final RequestScope.Instance scopeInstance;
        private final ExternalRequestContext<?> externalContext;

        private volatile AsyncResponder asyncResponder;

        private AsyncResponderHolder(final Responder responder,
                                     final ExternalRequestScope externalRequestScope,
                                     final RequestScope.Instance scopeInstance,
                                     final ExternalRequestContext<?> externalContext) {
            this.responder = responder;
            this.externalScope = externalRequestScope;
            this.scopeInstance = scopeInstance;
            this.externalContext = externalContext;
        }

        @Override
        public AsyncContext get() {
            final AsyncResponder ar = new AsyncResponder(responder, scopeInstance, externalScope, externalContext);
            asyncResponder = ar;
            return ar;
        }

        public boolean isAsync() {
            final AsyncResponder ar = asyncResponder;
            return ar != null && !ar.isRunning();
        }

        public void release() {
            if (asyncResponder == null) {
                scopeInstance.release();
            }
        }
    }

    private static class Responder {

        private static final Logger LOGGER = Logger.getLogger(Responder.class.getName());

        private final RequestProcessingContext processingContext;
        private final ServerRuntime runtime;

        private final CompletionCallbackRunner completionCallbackRunner = new CompletionCallbackRunner();
        private final ConnectionCallbackRunner connectionCallbackRunner = new ConnectionCallbackRunner();

        private final TracingLogger tracingLogger;

        public Responder(final RequestProcessingContext processingContext, final ServerRuntime runtime) {
            this.processingContext = processingContext;
            this.runtime = runtime;

            this.tracingLogger = TracingLogger.getInstance(processingContext.request());
        }

        public void process(ContainerResponse response) {
            processingContext.monitoringEventBuilder().setContainerResponse(response);
            response = processResponse(response);
            release(response);
        }

        private ContainerResponse processResponse(ContainerResponse response) {
            final Stage<ContainerResponse> respondingRoot = processingContext.createRespondingRoot();

            if (respondingRoot != null) {
                response = Stages.process(response, respondingRoot);
            }
            writeResponse(response);

            
            
            completionCallbackRunner.onComplete(null);
            return response;
        }

        
        public void process(final Throwable throwable) {
            final ContainerRequest request = processingContext.request();
            processingContext.monitoringEventBuilder().setException(throwable, RequestEvent.ExceptionCause.ORIGINAL);
            processingContext.triggerEvent(RequestEvent.Type.ON_EXCEPTION);

            ContainerResponse response = null;
            try {
                final Response exceptionResponse = mapException(throwable);
                try {
                    try {
                        response = convertResponse(exceptionResponse);
                        ensureAbsolute(response.getLocation(), response.getHeaders(), request);
                        processingContext.monitoringEventBuilder().setContainerResponse(response)
                                .setResponseSuccessfullyMapped(true);
                    } finally {
                        processingContext.triggerEvent(RequestEvent.Type.EXCEPTION_MAPPING_FINISHED);
                    }

                    processResponse(response);
                } catch (final Throwable respError) {
                    LOGGER.log(Level.SEVERE, LocalizationMessages.ERROR_PROCESSING_RESPONSE_FROM_ALREADY_MAPPED_EXCEPTION());
                    processingContext.monitoringEventBuilder()
                            .setException(respError, RequestEvent.ExceptionCause.MAPPED_RESPONSE);
                    processingContext.triggerEvent(RequestEvent.Type.ON_EXCEPTION);
                    throw respError;
                }
            } catch (final Throwable responseError) {
                if (throwable != responseError
                        && !(throwable instanceof MappableException && throwable.getCause() == responseError)) {
                    LOGGER.log(Level.FINE, LocalizationMessages.ERROR_EXCEPTION_MAPPING_ORIGINAL_EXCEPTION(), throwable);
                }

                if (!processResponseError(responseError)) {
                    
                    LOGGER.log(Level.FINE, LocalizationMessages.ERROR_EXCEPTION_MAPPING_THROWN_TO_CONTAINER(), responseError);

                    try {
                        request.getResponseWriter().failure(responseError);
                    } finally {
                        completionCallbackRunner.onComplete(responseError);
                    }
                }
            } finally {
                release(response);
            }
        }

        
        private boolean processResponseError(final Throwable responseError) {
            boolean processed = false;

            if (runtime.processResponseErrors) {
                
                final Iterable<ResponseErrorMapper> mappers = Providers.getAllProviders(runtime.locator,
                        ResponseErrorMapper.class);

                try {
                    Response processedError = null;
                    for (final ResponseErrorMapper mapper : mappers) {
                        processedError = mapper.toResponse(responseError);
                        if (processedError != null) {
                            break;
                        }
                    }

                    if (processedError != null) {
                        processResponse(new ContainerResponse(processingContext.request(), processedError));
                        processed = true;
                    }
                } catch (final Throwable throwable) {
                    LOGGER.log(Level.FINE, LocalizationMessages.ERROR_EXCEPTION_MAPPING_PROCESSED_RESPONSE_ERROR(), throwable);
                }
            }

            return processed;
        }

        private ContainerResponse convertResponse(final Response exceptionResponse) {
            final ContainerResponse containerResponse = new ContainerResponse(processingContext.request(), exceptionResponse);
            containerResponse.setMappedFromException(true);
            return containerResponse;
        }

        @SuppressWarnings("unchecked")
        private Response mapException(final Throwable originalThrowable) throws Throwable {
            LOGGER.log(Level.FINER, LocalizationMessages.EXCEPTION_MAPPING_START(), originalThrowable);

            Throwable throwable = originalThrowable;
            boolean inMappable = false;
            boolean mappingNotFound = false;

            do {
                if (throwable instanceof MappableException) {
                    inMappable = true;
                } else if (inMappable || throwable instanceof WebApplicationException) {
                    
                    
                    if (runtime.processResponseErrors && throwable instanceof InternalServerErrorException
                            && throwable.getCause() instanceof MessageBodyProviderNotFoundException) {
                        throw throwable;
                    }
                    Response waeResponse = null;

                    if (throwable instanceof WebApplicationException) {
                        final WebApplicationException webApplicationException = (WebApplicationException) throwable;

                        
                        processingContext.routingContext().setMappedThrowable(throwable);

                        waeResponse = webApplicationException.getResponse();
                        if (waeResponse.hasEntity()) {
                            LOGGER.log(Level.FINE, LocalizationMessages
                                    .EXCEPTION_MAPPING_WAE_ENTITY(waeResponse.getStatus()), throwable);
                            return waeResponse;
                        }
                    }

                    final long timestamp = tracingLogger.timestamp(ServerTraceEvent.EXCEPTION_MAPPING);
                    final ExceptionMapper mapper = runtime.exceptionMappers.findMapping(throwable);
                    if (mapper != null) {
                        processingContext.monitoringEventBuilder().setExceptionMapper(mapper);
                        processingContext.triggerEvent(RequestEvent.Type.EXCEPTION_MAPPER_FOUND);
                        try {
                            final Response mappedResponse = mapper.toResponse(throwable);

                            if (tracingLogger.isLogEnabled(ServerTraceEvent.EXCEPTION_MAPPING)) {
                                tracingLogger.logDuration(ServerTraceEvent.EXCEPTION_MAPPING,
                                        timestamp, mapper, throwable, throwable.getLocalizedMessage(),
                                        mappedResponse != null ? mappedResponse.getStatusInfo() : "-no-response-");
                            }

                            
                            processingContext.routingContext().setMappedThrowable(throwable);

                            if (mappedResponse != null) {
                                
                                if (LOGGER.isLoggable(Level.FINER)) {
                                    final String message = String.format(
                                            "Exception '%s' has been mapped by '%s' to response '%s' (%s:%s).",
                                            throwable.getLocalizedMessage(),
                                            mapper.getClass().getName(),
                                            mappedResponse.getStatusInfo().getReasonPhrase(),
                                            mappedResponse.getStatusInfo().getStatusCode(),
                                            mappedResponse.getStatusInfo().getFamily());
                                    LOGGER.log(Level.FINER, message);
                                }
                                return mappedResponse;
                            } else {
                                return Response.noContent().build();
                            }
                        } catch (final Throwable mapperThrowable) {
                            
                            
                            LOGGER.log(Level.SEVERE, LocalizationMessages.EXCEPTION_MAPPER_THROWS_EXCEPTION(mapper.getClass()),
                                    mapperThrowable);
                            LOGGER.log(Level.SEVERE, LocalizationMessages.EXCEPTION_MAPPER_FAILED_FOR_EXCEPTION(), throwable);
                            return Response.serverError().build();
                        }
                    }

                    if (waeResponse != null) {
                        LOGGER.log(Level.FINE, LocalizationMessages
                                .EXCEPTION_MAPPING_WAE_NO_ENTITY(waeResponse.getStatus()), throwable);

                        return waeResponse;
                    }

                    mappingNotFound = true;
                }
                
                if (throwable instanceof HeaderValueException) {
                    if (((HeaderValueException) throwable).getContext() == HeaderValueException.Context.INBOUND) {
                        return Response.status(Response.Status.BAD_REQUEST).build();
                    }
                }

                if (!inMappable || mappingNotFound) {
                    

                    
                    

                    
                    throw throwable;
                }

                throwable = throwable.getCause();
            } while (throwable != null);
            
            throw originalThrowable;
        }

        private ContainerResponse writeResponse(final ContainerResponse response) {
            final ContainerRequest request = processingContext.request();
            final ContainerResponseWriter writer = request.getResponseWriter();
            ServerRuntime.ensureAbsolute(response.getLocation(), response.getHeaders(),
                    response.getRequestContext());

            if (!response.hasEntity()) {
                tracingLogger.log(ServerTraceEvent.FINISHED, response.getStatusInfo());
                tracingLogger.flush(response.getHeaders());

                writer.writeResponseStatusAndHeaders(0, response);
                setWrittenResponse(response);
                return response;
            }

            final Object entity = response.getEntity();
            boolean skipFinally = false;

            final boolean isHead = request.getMethod().equals(HttpMethod.HEAD);

            try {
                response.setStreamProvider(new OutboundMessageContext.StreamProvider() {
                    @Override
                    public OutputStream getOutputStream(final int contentLength) throws IOException {
                        ServerRuntime.ensureAbsolute(response.getLocation(), response.getHeaders(),
                                response.getRequestContext());
                        final OutputStream outputStream = writer.writeResponseStatusAndHeaders(contentLength, response);
                        return isHead ? null : outputStream;
                    }
                });

                if ((writer.enableResponseBuffering() || isHead) && !response.isChunked()) {
                    response.enableBuffering(runtime.configuration);
                }

                try {
                    response.setEntityStream(request.getWorkers().writeTo(
                            entity,
                            entity.getClass(),
                            response.getEntityType(),
                            response.getEntityAnnotations(),
                            response.getMediaType(),
                            response.getHeaders(),
                            request.getPropertiesDelegate(),
                            response.getEntityStream(),
                            request.getWriterInterceptors()));
                } catch (final MappableException mpe) {
                    if (mpe.getCause() instanceof IOException) {
                        connectionCallbackRunner.onDisconnect(processingContext.asyncContext());
                    }
                    throw mpe;
                }
                tracingLogger.log(ServerTraceEvent.FINISHED, response.getStatusInfo());
                tracingLogger.flush(response.getHeaders());

                setWrittenResponse(response);

            } catch (final Throwable ex) {
                if (response.isCommitted()) {
                    
                    LOGGER.log(Level.SEVERE, LocalizationMessages.ERROR_WRITING_RESPONSE_ENTITY(), ex);
                } else {
                    skipFinally = true;
                    if (ex instanceof RuntimeException) {
                        throw (RuntimeException) ex;
                    } else {
                        throw new MappableException(ex);
                    }
                }
            } finally {
                if (!skipFinally) {
                    boolean close = !response.isChunked();
                    if (response.isChunked()) {
                        try {
                            response.commitStream();
                        } catch (final Exception e) {
                            LOGGER.log(Level.SEVERE, LocalizationMessages.ERROR_COMMITTING_OUTPUT_STREAM(), e);
                            close = true;
                        }

                        final ChunkedOutput chunked = (ChunkedOutput) entity;
                        try {
                            chunked.setContext(
                                    runtime.requestScope,
                                    runtime.requestScope.referenceCurrent(),
                                    request,
                                    response,
                                    connectionCallbackRunner,
                                    processingContext.asyncContextValue());
                        } catch (final IOException ex) {
                            LOGGER.log(Level.SEVERE, LocalizationMessages.ERROR_WRITING_RESPONSE_ENTITY_CHUNK(), ex);
                            close = true;
                        }
                        
                        
                        
                        if (!chunked.isClosed()
                                && !writer.suspend(AsyncResponder.NO_TIMEOUT, TimeUnit.SECONDS, null)) {
                            LOGGER.fine(LocalizationMessages.ERROR_SUSPENDING_CHUNKED_OUTPUT_RESPONSE());
                        }
                    }

                    if (close) {
                        try {
                            
                            
                            response.close();
                        } catch (final Exception e) {
                            LOGGER.log(Level.SEVERE, LocalizationMessages.ERROR_CLOSING_COMMIT_OUTPUT_STREAM(), e);
                        }
                    }
                }
            }

            return response;
        }

        private void setWrittenResponse(final ContainerResponse response) {
            processingContext.monitoringEventBuilder()
                    .setContainerResponse(response)
                    .setSuccess(response.getStatus() < Response.Status.BAD_REQUEST.getStatusCode())
                    .setResponseWritten(true);
        }

        private void release(final ContainerResponse responseContext) {
            try {
                processingContext.closeableService().close();

                
                
                if (responseContext != null && !responseContext.isChunked()) {
                    
                    responseContext.close();
                }

            } catch (final Throwable throwable) {
                LOGGER.log(Level.WARNING, LocalizationMessages.RELEASING_REQUEST_PROCESSING_RESOURCES_FAILED(), throwable);
            } finally {
                runtime.externalRequestScope.close();
                processingContext.triggerEvent(RequestEvent.Type.FINISHED);
            }
        }
    }

    private static class AsyncResponder implements AsyncContext, ContainerResponseWriter.TimeoutHandler, CompletionCallback {

        private static final Logger LOGGER = Logger.getLogger(AsyncResponder.class.getName());

        private static final TimeoutHandler DEFAULT_TIMEOUT_HANDLER = new TimeoutHandler() {
            @Override
            public void handleTimeout(final AsyncResponse asyncResponse) {
                throw new ServiceUnavailableException();
            }
        };

        private final Object stateLock = new Object();
        private State state = RUNNING;
        private boolean cancelled = false;

        private final Responder responder;
        
        private final RequestScope.Instance scopeInstance;
        private final ExternalRequestContext<?> foreignScopeInstance;
        private final ExternalRequestScope requestScopeListener;

        private volatile TimeoutHandler timeoutHandler = DEFAULT_TIMEOUT_HANDLER;

        private final List<AbstractCallbackRunner<?>> callbackRunners;

        public AsyncResponder(final Responder responder,
                              final RequestScope.Instance scopeInstance,
                              final ExternalRequestScope requestScopeListener,
                              final ExternalRequestContext<?> foreignScopeInstance) {
            this.responder = responder;
            this.scopeInstance = scopeInstance;
            this.foreignScopeInstance = foreignScopeInstance;
            this.requestScopeListener = requestScopeListener;

            this.callbackRunners = Collections.unmodifiableList(Arrays.asList(
                    responder.completionCallbackRunner, responder.connectionCallbackRunner));

            responder.completionCallbackRunner.register(this);
        }

        @Override
        public void onTimeout(final ContainerResponseWriter responseWriter) {
            final TimeoutHandler handler = timeoutHandler;
            try {
                synchronized (stateLock) {
                    if (state == SUSPENDED) {
                        handler.handleTimeout(this);
                    }
                }
            } catch (final Throwable throwable) {
                resume(throwable);
            }
        }

        @Override
        public void onComplete(final Throwable throwable) {
            synchronized (stateLock) {
                state = COMPLETED;
            }
        }

        @Override
        public void invokeManaged(final Producer<Response> producer) {
            responder.runtime.managedAsyncExecutor.get().submit(new Runnable() {
                @Override
                public void run() {
                    responder.runtime.requestScope.runInScope(scopeInstance, new Runnable() {
                        @Override
                        public void run() {
                            try {
                                requestScopeListener.resume(foreignScopeInstance);
                                final Response response = producer.call();
                                if (response != null) {
                                    resume(response);
                                }
                            } catch (final Throwable t) {
                                resume(t);
                            }
                        }
                    });
                }
            });
        }

        @Override
        public boolean suspend() {
            synchronized (stateLock) {
                if (state == RUNNING) {
                    if (responder.processingContext.request().getResponseWriter().suspend(
                            AsyncResponse.NO_TIMEOUT, TimeUnit.SECONDS, this)) {
                        state = SUSPENDED;
                        return true;
                    }
                }
            }
            return false;
        }

        @Override
        public boolean resume(final Object response) {
            return resume(new Runnable() {
                @Override
                public void run() {
                    try {
                        requestScopeListener.resume(foreignScopeInstance);
                        final Response jaxrsResponse =
                                (response instanceof Response) ? (Response) response : Response.ok(response).build();
                        ServerRuntime.ensureAbsolute(
                                jaxrsResponse.getLocation(), jaxrsResponse.getHeaders(), responder.processingContext.request());
                        responder.process(new ContainerResponse(responder.processingContext.request(), jaxrsResponse));
                    } catch (final Throwable t) {
                        responder.process(t);
                    }
                }
            });
        }

        @Override
        public boolean resume(final Throwable error) {
            return resume(new Runnable() {
                @Override
                public void run() {
                    try {
                        requestScopeListener.resume(foreignScopeInstance);
                        responder.process(new MappableException(error));
                    } catch (final Throwable error) {
                        
                    }
                }
            });
        }

        private boolean resume(final Runnable handler) {
            synchronized (stateLock) {
                if (state != SUSPENDED) {
                    return false;
                }
                state = RESUMED;
            }

            try {
                responder.runtime.requestScope.runInScope(scopeInstance, handler);
            } finally {
                scopeInstance.release();
            }

            return true;
        }

        @Override
        public boolean cancel() {
            return cancel(new Value<Response>() {
                @Override
                public Response get() {
                    return Response.status(Response.Status.SERVICE_UNAVAILABLE).build();
                }
            });
        }

        @Override
        public boolean cancel(final int retryAfter) {
            return cancel(new Value<Response>() {
                @Override
                public Response get() {
                    return Response
                            .status(Response.Status.SERVICE_UNAVAILABLE)
                            .header(HttpHeaders.RETRY_AFTER, retryAfter)
                            .build();
                }
            });
        }

        @Override
        public boolean cancel(final Date retryAfter) {
            return cancel(new Value<Response>() {
                @Override
                public Response get() {
                    return Response
                            .status(Response.Status.SERVICE_UNAVAILABLE)
                            .header(HttpHeaders.RETRY_AFTER, retryAfter)
                            .build();
                }
            });
        }

        private boolean cancel(final Value<Response> responseValue) {
            synchronized (stateLock) {
                if (cancelled) {
                    return true;
                }

                if (state != SUSPENDED) {
                    return false;
                }
                state = RESUMED;
                cancelled = true;
            }

            responder.runtime.requestScope.runInScope(scopeInstance, new Runnable() {
                @Override
                public void run() {
                    try {
                        requestScopeListener.resume(foreignScopeInstance);
                        final Response response = responseValue.get();
                        responder.process(new ContainerResponse(responder.processingContext.request(), response));
                    } catch (final Throwable t) {
                        responder.process(t);
                    }
                }
            });
            return true;
        }

        public boolean isRunning() {
            synchronized (stateLock) {
                return state == RUNNING;
            }
        }

        @Override
        public boolean isSuspended() {
            synchronized (stateLock) {
                return state == SUSPENDED;
            }
        }

        @Override
        public boolean isCancelled() {
            synchronized (stateLock) {
                return cancelled;
            }
        }

        @Override
        public boolean isDone() {
            synchronized (stateLock) {
                return state == COMPLETED;
            }
        }

        @Override
        public boolean setTimeout(final long time, final TimeUnit unit) {
            try {
                responder.processingContext.request().getResponseWriter().setSuspendTimeout(time, unit);
                return true;
            } catch (final IllegalStateException ex) {
                LOGGER.log(Level.FINER, "Unable to set timeout on the AsyncResponse.", ex);
                return false;
            }
        }

        @Override
        public void setTimeoutHandler(final TimeoutHandler handler) {
            timeoutHandler = handler;
        }

        @Override
        public Collection<Class<?>> register(final Class<?> callback) {
            Preconditions.checkNotNull(callback, LocalizationMessages.PARAM_NULL("callback"));

            return register(Injections.getOrCreate(responder.runtime.locator, callback));
        }

        @Override
        public Map<Class<?>, Collection<Class<?>>> register(final Class<?> callback, final Class<?>... callbacks) {
            Preconditions.checkNotNull(callback, LocalizationMessages.PARAM_NULL("callback"));
            Preconditions.checkNotNull(callbacks, LocalizationMessages.CALLBACK_ARRAY_NULL());
            for (final Class<?> additionalCallback : callbacks) {
                Preconditions.checkNotNull(additionalCallback, LocalizationMessages.CALLBACK_ARRAY_ELEMENT_NULL());
            }

            final Map<Class<?>, Collection<Class<?>>> results = new HashMap<>();

            results.put(callback, register(callback));

            for (final Class<?> c : callbacks) {
                results.put(c, register(c));
            }

            return results;
        }

        @Override
        public Collection<Class<?>> register(final Object callback) {
            Preconditions.checkNotNull(callback, LocalizationMessages.PARAM_NULL("callback"));

            final Collection<Class<?>> result = new LinkedList<>();
            for (final AbstractCallbackRunner<?> runner : callbackRunners) {
                if (runner.supports(callback.getClass())) {
                    if (runner.register(callback)) {
                        result.add(runner.getCallbackContract());
                    }
                }
            }

            return result;
        }

        @Override
        public Map<Class<?>, Collection<Class<?>>> register(final Object callback, final Object... callbacks) {
            Preconditions.checkNotNull(callback, LocalizationMessages.PARAM_NULL("callback"));
            Preconditions.checkNotNull(callbacks, LocalizationMessages.CALLBACK_ARRAY_NULL());
            for (final Object additionalCallback : callbacks) {
                Preconditions.checkNotNull(additionalCallback, LocalizationMessages.CALLBACK_ARRAY_ELEMENT_NULL());
            }

            final Map<Class<?>, Collection<Class<?>>> results = new HashMap<>();

            results.put(callback.getClass(), register(callback));

            for (final Object c : callbacks) {
                results.put(c.getClass(), register(c));
            }

            return results;
        }
    }

    
    abstract static class AbstractCallbackRunner<T> {

        private final Queue<T> callbacks = new ConcurrentLinkedQueue<>();
        private final Logger logger;

        
        protected AbstractCallbackRunner(final Logger logger) {
            this.logger = logger;
        }

        
        public final boolean supports(final Class<?> callbackClass) {
            return getCallbackContract().isAssignableFrom(callbackClass);
        }

        
        public abstract Class<?> getCallbackContract();

        
        @SuppressWarnings("unchecked")
        public boolean register(final Object callback) {
            return callbacks.offer((T) callback);
        }

        
        protected final void executeCallbacks(final Closure<T> invoker) {
            for (final T callback : callbacks) {
                try {
                    invoker.invoke(callback);
                } catch (final Throwable t) {
                    logger.log(Level.WARNING, LocalizationMessages.ERROR_ASYNC_CALLBACK_FAILED(callback.getClass().getName()), t);
                }
            }
        }
    }

    private static class CompletionCallbackRunner
            extends AbstractCallbackRunner<CompletionCallback> implements CompletionCallback {

        private static final Logger LOGGER = Logger.getLogger(CompletionCallbackRunner.class.getName());

        private CompletionCallbackRunner() {
            super(LOGGER);
        }

        @Override
        public Class<?> getCallbackContract() {
            return CompletionCallback.class;
        }

        @Override
        public void onComplete(final Throwable throwable) {
            executeCallbacks(new Closure<CompletionCallback>() {
                @Override
                public void invoke(final CompletionCallback callback) {
                    callback.onComplete(throwable);
                }
            });
        }
    }

    private static class ConnectionCallbackRunner
            extends AbstractCallbackRunner<ConnectionCallback> implements ConnectionCallback {

        private static final Logger LOGGER = Logger.getLogger(ConnectionCallbackRunner.class.getName());

        private ConnectionCallbackRunner() {
            super(LOGGER);
        }

        @Override
        public Class<?> getCallbackContract() {
            return ConnectionCallback.class;
        }

        @Override
        public void onDisconnect(final AsyncResponse disconnected) {
            executeCallbacks(new Closure<ConnectionCallback>() {
                @Override
                public void invoke(final ConnectionCallback callback) {
                    callback.onDisconnect(disconnected);
                }
            });
        }
    }
}

<code block>

package org.glassfish.jersey.server;

import java.io.OutputStream;
import java.lang.annotation.Annotation;
import java.lang.reflect.Type;
import java.security.Principal;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.ws.rs.HttpMethod;
import javax.ws.rs.NameBinding;
import javax.ws.rs.RuntimeType;
import javax.ws.rs.container.ContainerRequestFilter;
import javax.ws.rs.container.ContainerResponseFilter;
import javax.ws.rs.container.DynamicFeature;
import javax.ws.rs.container.PreMatching;
import javax.ws.rs.core.Application;
import javax.ws.rs.core.Configuration;
import javax.ws.rs.core.GenericType;
import javax.ws.rs.core.HttpHeaders;
import javax.ws.rs.core.MultivaluedHashMap;
import javax.ws.rs.core.MultivaluedMap;
import javax.ws.rs.core.SecurityContext;
import javax.ws.rs.ext.MessageBodyReader;
import javax.ws.rs.ext.MessageBodyWriter;
import javax.ws.rs.ext.ReaderInterceptor;
import javax.ws.rs.ext.WriterInterceptor;

import javax.inject.Singleton;

import org.glassfish.jersey.CommonProperties;
import org.glassfish.jersey.internal.Errors;
import org.glassfish.jersey.internal.ServiceConfigurationError;
import org.glassfish.jersey.internal.ServiceFinder;
import org.glassfish.jersey.internal.Version;
import org.glassfish.jersey.internal.inject.Injections;
import org.glassfish.jersey.internal.inject.JerseyClassAnalyzer;
import org.glassfish.jersey.internal.inject.ProviderBinder;
import org.glassfish.jersey.internal.inject.Providers;
import org.glassfish.jersey.internal.util.Producer;
import org.glassfish.jersey.internal.util.ReflectionHelper;
import org.glassfish.jersey.internal.util.collection.LazyValue;
import org.glassfish.jersey.internal.util.collection.Ref;
import org.glassfish.jersey.internal.util.collection.Value;
import org.glassfish.jersey.internal.util.collection.Values;
import org.glassfish.jersey.message.MessageBodyWorkers;
import org.glassfish.jersey.message.internal.NullOutputStream;
import org.glassfish.jersey.model.ContractProvider;
import org.glassfish.jersey.model.internal.ComponentBag;
import org.glassfish.jersey.model.internal.RankedComparator;
import org.glassfish.jersey.model.internal.RankedComparator.Order;
import org.glassfish.jersey.model.internal.RankedProvider;
import org.glassfish.jersey.process.internal.ChainableStage;
import org.glassfish.jersey.process.internal.ExecutorProviders;
import org.glassfish.jersey.process.internal.Stage;
import org.glassfish.jersey.process.internal.Stages;
import org.glassfish.jersey.server.internal.JerseyRequestTimeoutHandler;
import org.glassfish.jersey.server.internal.JerseyResourceContext;
import org.glassfish.jersey.server.internal.LocalizationMessages;
import org.glassfish.jersey.server.internal.ProcessingProviders;
import org.glassfish.jersey.server.internal.monitoring.ApplicationEventImpl;
import org.glassfish.jersey.server.internal.monitoring.CompositeApplicationEventListener;
import org.glassfish.jersey.server.internal.monitoring.MonitoringContainerListener;
import org.glassfish.jersey.server.internal.process.ReferencesInitializer;
import org.glassfish.jersey.server.internal.process.RequestProcessingContext;
import org.glassfish.jersey.server.internal.routing.Routing;
import org.glassfish.jersey.server.model.ComponentModelValidator;
import org.glassfish.jersey.server.model.ModelProcessor;
import org.glassfish.jersey.server.model.ModelValidationException;
import org.glassfish.jersey.server.model.Resource;
import org.glassfish.jersey.server.model.ResourceModel;
import org.glassfish.jersey.server.model.internal.ModelErrors;
import org.glassfish.jersey.server.monitoring.ApplicationEvent;
import org.glassfish.jersey.server.monitoring.ApplicationEventListener;
import org.glassfish.jersey.server.spi.ComponentProvider;
import org.glassfish.jersey.server.spi.Container;
import org.glassfish.jersey.server.spi.ContainerLifecycleListener;
import org.glassfish.jersey.server.spi.ContainerResponseWriter;
import org.glassfish.jersey.server.spi.ExternalRequestScope;

import org.glassfish.hk2.api.DynamicConfiguration;
import org.glassfish.hk2.api.Factory;
import org.glassfish.hk2.api.ServiceLocator;
import org.glassfish.hk2.utilities.Binder;
import org.glassfish.hk2.utilities.binding.AbstractBinder;
import org.glassfish.hk2.utilities.binding.ScopedBindingBuilder;

import jersey.repackaged.com.google.common.base.Function;
import jersey.repackaged.com.google.common.base.Predicate;
import jersey.repackaged.com.google.common.collect.Collections2;
import jersey.repackaged.com.google.common.collect.Lists;
import jersey.repackaged.com.google.common.collect.Sets;
import jersey.repackaged.com.google.common.util.concurrent.AbstractFuture;


public final class ApplicationHandler implements ContainerLifecycleListener {

    private static final Logger LOGGER = Logger.getLogger(ApplicationHandler.class.getName());

    
    private static final SecurityContext DEFAULT_SECURITY_CONTEXT = new SecurityContext() {

        @Override
        public boolean isUserInRole(final String role) {
            return false;
        }

        @Override
        public boolean isSecure() {
            return false;
        }

        @Override
        public Principal getUserPrincipal() {
            return null;
        }

        @Override
        public String getAuthenticationScheme() {
            return null;
        }
    };

    private class ApplicationBinder extends AbstractBinder {

        private class JaxrsApplicationProvider implements Factory<Application> {

            @Override
            public Application provide() {
                return ApplicationHandler.this.application;
            }

            @Override
            public void dispose(final Application instance) {
                
            }
        }

        private class RuntimeConfigProvider implements Factory<ServerConfig> {

            @Override
            public ServerConfig provide() {
                return ApplicationHandler.this.runtimeConfig;
            }

            @Override
            public void dispose(final ServerConfig instance) {
                
            }
        }

        @Override
        protected void configure() {
            bindFactory(new RuntimeConfigProvider()).to(ServerConfig.class).to(Configuration.class).in(Singleton.class);
            bindFactory(new JaxrsApplicationProvider()).to(Application.class).in(Singleton.class);
            bind(ApplicationHandler.this).to(ApplicationHandler.class);
        }
    }

    private final Application application;
    private final ResourceConfig runtimeConfig;
    private final ServiceLocator locator;
    private final ServerRuntime runtime;
    private final Iterable<ContainerLifecycleListener> containerLifecycleListeners;

    private MessageBodyWorkers msgBodyWorkers;

    
    public ApplicationHandler() {
        this(new Application());
    }

    
    public ApplicationHandler(final Class<? extends Application> jaxrsApplicationClass) {
        this.locator = Injections.createLocator(new ServerBinder(null), new ApplicationBinder());
        locator.setDefaultClassAnalyzerName(JerseyClassAnalyzer.NAME);

        final LazyValue<Iterable<ComponentProvider>> componentProviders = getLazyInitializedComponentProviders(locator);
        this.application = createApplication(jaxrsApplicationClass, componentProviders);
        this.runtimeConfig = ResourceConfig.createRuntimeConfig(application);

        this.runtime = Errors.processWithException(new Producer<ServerRuntime>() {
            @Override
            public ServerRuntime call() {
                return initialize(componentProviders.get());
            }
        });

        this.containerLifecycleListeners = Providers.getAllProviders(locator, ContainerLifecycleListener.class);
    }

    
    public ApplicationHandler(final Application application) {
        this(application, null, null);
    }

    
    public ApplicationHandler(final Application application, final Binder customBinder) {
        this(application, customBinder, null);
    }

    
    public ApplicationHandler(final Application application, final Binder customBinder, final ServiceLocator parent) {
        if (customBinder == null) {
            this.locator = Injections.createLocator(
                    parent,
                    new ServerBinder(application.getProperties()),
                    new ApplicationBinder());
        } else {
            this.locator = Injections.createLocator(parent,
                    new ServerBinder(application.getProperties()),
                    new ApplicationBinder(),
                    customBinder);
        }
        locator.setDefaultClassAnalyzerName(JerseyClassAnalyzer.NAME);
        final LazyValue<Iterable<ComponentProvider>> componentProviders = getLazyInitializedComponentProviders(locator);

        this.application = application;
        if (application instanceof ResourceConfig) {
            final ResourceConfig rc = (ResourceConfig) application;
            if (rc.getApplicationClass() != null) {
                rc.setApplication(createApplication(rc.getApplicationClass(), componentProviders));
            }
        }
        this.runtimeConfig = ResourceConfig.createRuntimeConfig(application);

        this.runtime = Errors.processWithException(new Producer<ServerRuntime>() {
            @Override
            public ServerRuntime call() {
                return initialize(componentProviders.get());
            }
        });

        this.containerLifecycleListeners = Providers.getAllProviders(locator, ContainerLifecycleListener.class);
    }

    private Application createApplication(final Class<? extends Application> applicationClass,
                                          final Value<Iterable<ComponentProvider>> componentProvidersValue) {
        
        
        if (applicationClass == ResourceConfig.class) {
            return new ResourceConfig();
        } else if (applicationClass == Application.class) {
            return new Application();
        } else {
            Iterable<ComponentProvider> componentProviders = componentProvidersValue.get();
            boolean appClassBound = false;
            for (ComponentProvider cp : componentProviders) {
                if (cp.bind(applicationClass, Collections.<Class<?>>emptySet())) {
                    appClassBound = true;
                    break;
                }
            }
            if (!appClassBound) {
                if (applicationClass.isAnnotationPresent(Singleton.class)) {
                    final DynamicConfiguration dc = Injections.getConfiguration(locator);
                    final ScopedBindingBuilder<? extends Application> binder =
                            Injections.newBinder(applicationClass).to(applicationClass).in(Singleton.class);
                    Injections.addBinding(binder, dc);
                    dc.commit();
                    appClassBound = true;
                }
            }
            final Application app = appClassBound
                    ? locator.getService(applicationClass) : locator.createAndInitialize(applicationClass);
            if (app instanceof ResourceConfig) {
                final ResourceConfig _rc = (ResourceConfig) app;
                final Class<? extends Application> innerAppClass = _rc.getApplicationClass();
                if (innerAppClass != null) {
                    final Application innerApp = createApplication(innerAppClass, componentProvidersValue);
                    _rc.setApplication(innerApp);
                }
            }
            return app;
        }
    }

    private static LazyValue<Iterable<ComponentProvider>> getLazyInitializedComponentProviders(final ServiceLocator locator) {
        return Values.lazy(new Value<Iterable<ComponentProvider>>() {
            @Override
            public Iterable<ComponentProvider> get() {
                
                List<ComponentProvider> result = new LinkedList<>();

                
                for (final RankedProvider<ComponentProvider> rankedProvider : getRankedComponentProviders()) {
                    final ComponentProvider provider = rankedProvider.getProvider();
                    provider.initialize(locator);
                    result.add(provider);
                }
                return result;
            }
        });
    }

    
    private ServerRuntime initialize(Iterable<ComponentProvider> componentProviders) {
        LOGGER.config(LocalizationMessages.INIT_MSG(Version.getBuildId()));

        
        if (application instanceof ResourceConfig) {
            ((ResourceConfig) application).lock();
        }

        final boolean ignoreValidationErrors = ServerProperties.getValue(runtimeConfig.getProperties(),
                ServerProperties.RESOURCE_VALIDATION_IGNORE_ERRORS,
                Boolean.FALSE,
                Boolean.class);
        final boolean disableValidation = ServerProperties.getValue(runtimeConfig.getProperties(),
                ServerProperties.RESOURCE_VALIDATION_DISABLE,
                Boolean.FALSE,
                Boolean.class);

        final ResourceBag resourceBag;
        final ProcessingProviders processingProviders;
        final ComponentBag componentBag;
        ResourceModel resourceModel;
        CompositeApplicationEventListener compositeListener = null;

        Errors.mark(); 
        try {
            
            if (!CommonProperties.getValue(runtimeConfig.getProperties(), RuntimeType.SERVER,
                    CommonProperties.FEATURE_AUTO_DISCOVERY_DISABLE, Boolean.FALSE, Boolean.class)) {
                runtimeConfig.configureAutoDiscoverableProviders(locator);
            } else {
                runtimeConfig.configureForcedAutoDiscoverableProviders(locator);
            }

            
            runtimeConfig.configureMetaProviders(locator);

            final ResourceBag.Builder resourceBagBuilder = new ResourceBag.Builder();

            
            for (final Resource programmaticResource : runtimeConfig.getResources()) {
                resourceBagBuilder.registerProgrammaticResource(programmaticResource);
            }

            
            for (final Class<?> c : runtimeConfig.getClasses()) {
                try {
                    final Resource resource = Resource.from(c, disableValidation);
                    if (resource != null) {
                        resourceBagBuilder.registerResource(c, resource);
                    }
                } catch (final IllegalArgumentException ex) {
                    LOGGER.warning(ex.getMessage());
                }
            }

            for (final Object o : runtimeConfig.getSingletons()) {
                try {
                    final Resource resource = Resource.from(o.getClass(), disableValidation);
                    if (resource != null) {
                        resourceBagBuilder.registerResource(o, resource);
                    }
                } catch (final IllegalArgumentException ex) {
                    LOGGER.warning(ex.getMessage());
                }
            }

            resourceBag = resourceBagBuilder.build();

            runtimeConfig.lock();

            componentBag = runtimeConfig.getComponentBag();
            final Class<ExternalRequestScope>[] extScopes = ServiceFinder.find(ExternalRequestScope.class, true).toClassArray();

            boolean extScopesFound = false;

            if (extScopes.length == 1) {
                for (final ComponentProvider p : componentProviders) {
                    if (p.bind(extScopes[0], new HashSet<Class<?>>() {{
                        add(ExternalRequestScope.class);
                    }})) {
                        extScopesFound = true;
                        break;
                    }
                }
            } else if (extScopes.length > 1) {
                if (LOGGER.isLoggable(Level.WARNING)) {
                    final StringBuilder scopeList = new StringBuilder("\n");
                    for (final Class<ExternalRequestScope> ers : extScopes) {
                        scopeList.append("   ").append(ers.getTypeParameters()[0]).append('\n');
                    }
                    LOGGER.warning(LocalizationMessages.WARNING_TOO_MANY_EXTERNAL_REQ_SCOPES(scopeList.toString()));
                }
            }

            if (!extScopesFound) {
                final DynamicConfiguration configuration = Injections.getConfiguration(locator);
                final ScopedBindingBuilder<ExternalRequestScope> binder = Injections
                        .newBinder((ExternalRequestScope) ServerRuntime.NOOP_EXTERNAL_REQ_SCOPE)
                        .to(ExternalRequestScope.class);
                Injections.addBinding(binder, configuration);
                configuration.commit();
            }

            bindProvidersAndResources(componentProviders, componentBag, resourceBag.classes, resourceBag.instances);
            for (final ComponentProvider componentProvider : componentProviders) {
                componentProvider.done();
            }

            final Iterable<ApplicationEventListener> appEventListeners = Providers.getAllProviders(locator,
                    ApplicationEventListener.class, new RankedComparator<ApplicationEventListener>());

            if (appEventListeners.iterator().hasNext()) {
                compositeListener = new CompositeApplicationEventListener(appEventListeners);
                compositeListener.onEvent(new ApplicationEventImpl(ApplicationEvent.Type.INITIALIZATION_START,
                        this.runtimeConfig, componentBag.getRegistrations(), resourceBag.classes, resourceBag.instances,
                        null));
            }

            processingProviders = getProcessingProviders(componentBag);

            
            final GenericType<Ref<ProcessingProviders>> refGenericType = new GenericType<Ref<ProcessingProviders>>() {
            };
            final Ref<ProcessingProviders> refProcessingProvider = locator.getService(refGenericType.getType());
            refProcessingProvider.set(processingProviders);

            resourceModel = new ResourceModel.Builder(resourceBag.getRootResources(), false).build();
            resourceModel = processResourceModel(resourceModel);

            if (!disableValidation) {
                final ComponentModelValidator validator = new ComponentModelValidator(locator);
                validator.validate(resourceModel);
            }

            if (Errors.fatalIssuesFound() && !ignoreValidationErrors) {
                throw new ModelValidationException(LocalizationMessages.RESOURCE_MODEL_VALIDATION_FAILED_AT_INIT(),
                        ModelErrors.getErrorsAsResourceModelIssues(true));
            }
        } finally {
            if (ignoreValidationErrors) {
                Errors.logErrors(true);
                Errors.reset(); 
            } else {
                Errors.unmark();
            }
        }

        bindEnhancingResourceClasses(resourceModel, resourceBag, componentProviders);

        ExecutorProviders.createInjectionBindings(locator);

        
        final JerseyResourceContext jerseyResourceContext = locator.getService(JerseyResourceContext.class);
        jerseyResourceContext.setResourceModel(resourceModel);

        msgBodyWorkers = locator.getService(MessageBodyWorkers.class);

        
        final ReferencesInitializer referencesInitializer = locator.createAndInitialize(ReferencesInitializer.class);
        final ContainerFilteringStage preMatchRequestFilteringStage = new ContainerFilteringStage(
                processingProviders.getPreMatchFilters(),
                processingProviders.getGlobalResponseFilters());
        final ChainableStage<RequestProcessingContext> routingStage = Routing.forModel(resourceModel.getRuntimeResourceModel())
                .locator(locator)
                .resourceContext(jerseyResourceContext)
                .configuration(runtimeConfig)
                .entityProviders(msgBodyWorkers)
                .processingProviders(processingProviders)
                .buildStage();
        final ContainerFilteringStage resourceFilteringStage =
                new ContainerFilteringStage(processingProviders.getGlobalRequestFilters(), null);
        
        final Stage<RequestProcessingContext> rootStage = Stages
                .chain(referencesInitializer)
                .to(preMatchRequestFilteringStage)
                .to(routingStage)
                .to(resourceFilteringStage)
                .build(Routing.matchedEndpointExtractor());
        final ServerRuntime serverRuntime = locator.createAndInitialize(ServerRuntime.Builder.class)
                .build(rootStage, compositeListener, processingProviders);

        
        for (final Object instance : componentBag.getInstances(ComponentBag.EXCLUDE_META_PROVIDERS)) {
            locator.inject(instance);
        }
        for (final Object instance : resourceBag.instances) {
            locator.inject(instance);
        }

        logApplicationInitConfiguration(locator, resourceBag, processingProviders);

        if (compositeListener != null) {
            final ApplicationEvent initFinishedEvent = new ApplicationEventImpl(
                    ApplicationEvent.Type.INITIALIZATION_APP_FINISHED, runtimeConfig,
                    componentBag.getRegistrations(), resourceBag.classes, resourceBag.instances, resourceModel);
            compositeListener.onEvent(initFinishedEvent);

            final MonitoringContainerListener containerListener
                    = locator.getService(MonitoringContainerListener.class);
            containerListener.init(compositeListener, initFinishedEvent);
        }

        return serverRuntime;
    }

    private static void logApplicationInitConfiguration(final ServiceLocator locator,
                                                        final ResourceBag resourceBag,
                                                        final ProcessingProviders processingProviders) {
        if (!LOGGER.isLoggable(Level.CONFIG)) {
            return;
        }

        final StringBuilder sb = new StringBuilder(LocalizationMessages.LOGGING_APPLICATION_INITIALIZED()).append('\n');

        final List<Resource> rootResourceClasses = resourceBag.getRootResources();

        if (!rootResourceClasses.isEmpty()) {
            sb.append(LocalizationMessages.LOGGING_ROOT_RESOURCE_CLASSES()).append(":");
            for (final Resource r : rootResourceClasses) {
                for (final Class clazz : r.getHandlerClasses()) {
                    sb.append('\n').append("  ").append(clazz.getName());
                }
            }
        }

        sb.append('\n');

        final Set<MessageBodyReader> messageBodyReaders;
        final Set<MessageBodyWriter> messageBodyWriters;

        if (LOGGER.isLoggable(Level.FINE)) {
            messageBodyReaders = Sets.newHashSet(Providers.getAllProviders(locator, MessageBodyReader.class));
            messageBodyWriters = Sets.newHashSet(Providers.getAllProviders(locator, MessageBodyWriter.class));
        } else {
            messageBodyReaders = Providers.getCustomProviders(locator, MessageBodyReader.class);
            messageBodyWriters = Providers.getCustomProviders(locator, MessageBodyWriter.class);
        }

        printProviders(LocalizationMessages.LOGGING_PRE_MATCH_FILTERS(),
                processingProviders.getPreMatchFilters(), sb);
        printProviders(LocalizationMessages.LOGGING_GLOBAL_REQUEST_FILTERS(),
                processingProviders.getGlobalRequestFilters(), sb);
        printProviders(LocalizationMessages.LOGGING_GLOBAL_RESPONSE_FILTERS(),
                processingProviders.getGlobalResponseFilters(), sb);
        printProviders(LocalizationMessages.LOGGING_GLOBAL_READER_INTERCEPTORS(),
                processingProviders.getGlobalReaderInterceptors(), sb);
        printProviders(LocalizationMessages.LOGGING_GLOBAL_WRITER_INTERCEPTORS(),
                processingProviders.getGlobalWriterInterceptors(), sb);
        printNameBoundProviders(LocalizationMessages.LOGGING_NAME_BOUND_REQUEST_FILTERS(),
                processingProviders.getNameBoundRequestFilters(), sb);
        printNameBoundProviders(LocalizationMessages.LOGGING_NAME_BOUND_RESPONSE_FILTERS(),
                processingProviders.getNameBoundResponseFilters(), sb);
        printNameBoundProviders(LocalizationMessages.LOGGING_NAME_BOUND_READER_INTERCEPTORS(),
                processingProviders.getNameBoundReaderInterceptors(), sb);
        printNameBoundProviders(LocalizationMessages.LOGGING_NAME_BOUND_WRITER_INTERCEPTORS(),
                processingProviders.getNameBoundWriterInterceptors(), sb);
        printProviders(LocalizationMessages.LOGGING_DYNAMIC_FEATURES(),
                processingProviders.getDynamicFeatures(), sb);
        printProviders(LocalizationMessages.LOGGING_MESSAGE_BODY_READERS(),
                Collections2.transform(messageBodyReaders, new WorkersToStringTransform<MessageBodyReader>()), sb);
        printProviders(LocalizationMessages.LOGGING_MESSAGE_BODY_WRITERS(),
                Collections2.transform(messageBodyWriters, new WorkersToStringTransform<MessageBodyWriter>()), sb);

        LOGGER.log(Level.CONFIG, sb.toString());
    }

    private static class WorkersToStringTransform<T> implements Function<T, String> {

        @Override
        public String apply(final T t) {
            if (t != null) {
                return t.getClass().getName();
            }
            return null;
        }
    }

    private static <T> void printNameBoundProviders(final String title,
                                                    final Map<Class<? extends Annotation>, List<RankedProvider<T>>> providers,
                                                    final StringBuilder sb) {
        if (!providers.isEmpty()) {
            sb.append(title).append(":").append('\n');

            for (final Map.Entry<Class<? extends Annotation>, List<RankedProvider<T>>> entry : providers.entrySet()) {
                for (final RankedProvider rankedProvider : entry.getValue()) {
                    sb.append("   ")
                            .append(LocalizationMessages.LOGGING_PROVIDER_BOUND(rankedProvider, entry.getKey()))
                            .append('\n');
                }
            }
        }
    }

    private static <T> void printProviders(final String title, final Iterable<T> providers, final StringBuilder sb) {
        final Iterator<T> iterator = providers.iterator();
        boolean first = true;
        while (iterator.hasNext()) {
            if (first) {
                sb.append(title).append(":").append('\n');
                first = false;
            }
            final T provider = iterator.next();
            sb.append("   ").append(provider).append('\n');
        }
    }

    private static Iterable<RankedProvider<ComponentProvider>> getRankedComponentProviders() throws ServiceConfigurationError {
        final List<RankedProvider<ComponentProvider>> result = new LinkedList<>();

        for (final ComponentProvider provider : ServiceFinder.find(ComponentProvider.class)) {
            result.add(new RankedProvider<>(provider));
        }
        Collections.sort(result, new RankedComparator<ComponentProvider>(Order.DESCENDING));
        return result;
    }

    private ProcessingProviders getProcessingProviders(final ComponentBag componentBag) {

        
        final Collection<Class<? extends Annotation>> applicationNameBindings = ReflectionHelper.getAnnotationTypes(
                ResourceConfig.unwrapApplication(runtimeConfig).getClass(), NameBinding.class);

        
        final Iterable<RankedProvider<ContainerResponseFilter>> responseFilters = Providers.getAllRankedProviders(locator,
                ContainerResponseFilter.class);

        final MultivaluedMap<RankedProvider<ContainerResponseFilter>, Class<? extends Annotation>> nameBoundRespFiltersInverse =
                new MultivaluedHashMap<>();
        final MultivaluedMap<RankedProvider<ContainerRequestFilter>, Class<? extends Annotation>> nameBoundReqFiltersInverse =
                new MultivaluedHashMap<>();
        final MultivaluedMap<RankedProvider<ReaderInterceptor>, Class<? extends Annotation>> nameBoundReaderInterceptorsInverse =
                new MultivaluedHashMap<>();
        final MultivaluedMap<RankedProvider<WriterInterceptor>, Class<? extends Annotation>> nameBoundWriterInterceptorsInverse =
                new MultivaluedHashMap<>();

        final MultivaluedMap<Class<? extends Annotation>, RankedProvider<ContainerResponseFilter>> nameBoundResponseFilters
                = filterNameBound(responseFilters, null, componentBag, applicationNameBindings, nameBoundRespFiltersInverse);

        final Iterable<RankedProvider<ContainerRequestFilter>> requestFilters = Providers.getAllRankedProviders(locator,
                ContainerRequestFilter.class);

        final List<RankedProvider<ContainerRequestFilter>> preMatchFilters = Lists.newArrayList();

        final MultivaluedMap<Class<? extends Annotation>, RankedProvider<ContainerRequestFilter>> nameBoundReqFilters =
                filterNameBound(requestFilters, preMatchFilters, componentBag, applicationNameBindings,
                        nameBoundReqFiltersInverse);

        final Iterable<RankedProvider<ReaderInterceptor>> readerInterceptors = Providers.getAllRankedProviders(locator,
                ReaderInterceptor.class);

        final MultivaluedMap<Class<? extends Annotation>, RankedProvider<ReaderInterceptor>> nameBoundReaderInterceptors =
                filterNameBound(readerInterceptors, null, componentBag, applicationNameBindings,
                        nameBoundReaderInterceptorsInverse);

        final Iterable<RankedProvider<WriterInterceptor>> writerInterceptors = Providers.getAllRankedProviders(locator,
                WriterInterceptor.class);

        final MultivaluedMap<Class<? extends Annotation>, RankedProvider<WriterInterceptor>> nameBoundWriterInterceptors =
                filterNameBound(writerInterceptors, null, componentBag, applicationNameBindings,
                        nameBoundWriterInterceptorsInverse);

        final Iterable<DynamicFeature> dynamicFeatures = Providers.getAllProviders(locator, DynamicFeature.class);

        return new ProcessingProviders(nameBoundReqFilters,
                nameBoundReqFiltersInverse,
                nameBoundResponseFilters,
                nameBoundRespFiltersInverse,
                nameBoundReaderInterceptors,
                nameBoundReaderInterceptorsInverse,
                nameBoundWriterInterceptors,
                nameBoundWriterInterceptorsInverse,
                requestFilters,
                preMatchFilters,
                responseFilters,
                readerInterceptors,
                writerInterceptors,
                dynamicFeatures);
    }

    private ResourceModel processResourceModel(ResourceModel resourceModel) {
        final Iterable<RankedProvider<ModelProcessor>> allRankedProviders = Providers.getAllRankedProviders(locator,
                ModelProcessor.class);
        final Iterable<ModelProcessor> modelProcessors = Providers.sortRankedProviders(new RankedComparator<ModelProcessor>(),
                allRankedProviders);

        for (final ModelProcessor modelProcessor : modelProcessors) {
            resourceModel = modelProcessor.processResourceModel(resourceModel, getConfiguration());
        }
        return resourceModel;
    }

    private void bindEnhancingResourceClasses(
            final ResourceModel resourceModel,
            final ResourceBag resourceBag,
            final Iterable<ComponentProvider> componentProviders) {

        final Set<Class<?>> newClasses = Sets.newHashSet();
        final Set<Object> newInstances = Sets.newHashSet();
        for (final Resource res : resourceModel.getRootResources()) {
            newClasses.addAll(res.getHandlerClasses());
            newInstances.addAll(res.getHandlerInstances());
        }
        newClasses.removeAll(resourceBag.classes);
        newInstances.removeAll(resourceBag.instances);

        final ComponentBag emptyComponentBag = ComponentBag.newInstance(new Predicate<ContractProvider>() {
            @Override
            public boolean apply(final ContractProvider input) {
                return false;
            }
        });
        bindProvidersAndResources(componentProviders, emptyComponentBag, newClasses, newInstances);
    }

    
    private static <T> MultivaluedMap<Class<? extends Annotation>, RankedProvider<T>> filterNameBound(
            final Iterable<RankedProvider<T>> all,
            final Collection<RankedProvider<ContainerRequestFilter>> preMatchingFilters,
            final ComponentBag componentBag,
            final Collection<Class<? extends Annotation>> applicationNameBindings,
            final MultivaluedMap<RankedProvider<T>, Class<? extends Annotation>> inverseNameBoundMap) {

        final MultivaluedMap<Class<? extends Annotation>, RankedProvider<T>> result
                = new MultivaluedHashMap<>();

        for (final Iterator<RankedProvider<T>> it = all.iterator(); it.hasNext(); ) {
            final RankedProvider<T> provider = it.next();
            Class<?> providerClass = provider.getProvider().getClass();
            final Set<Type> contractTypes = provider.getContractTypes();
            if (contractTypes != null && !contractTypes.contains(providerClass)) {
                providerClass = ReflectionHelper.theMostSpecificTypeOf(contractTypes);
            }

            ContractProvider model = componentBag.getModel(providerClass);
            if (model == null) {
                
                model = ComponentBag.modelFor(providerClass);
            }

            final boolean preMatching = providerClass.getAnnotation(PreMatching.class) != null;
            if (preMatching && preMatchingFilters != null) {
                it.remove();
                preMatchingFilters.add(new RankedProvider<>((ContainerRequestFilter) provider.getProvider(),
                        model.getPriority(ContainerRequestFilter.class)));
            }

            boolean nameBound = model.isNameBound();
            if (nameBound
                    && !applicationNameBindings.isEmpty()
                    && applicationNameBindings.containsAll(model.getNameBindings())) {
                
                nameBound = false;
            }

            if (nameBound) { 
                if (!preMatching) {
                    it.remove();
                    for (final Class<? extends Annotation> binding : model.getNameBindings()) {
                        result.add(binding, provider);
                        inverseNameBoundMap.add(provider, binding);
                    }
                } else {
                    LOGGER.warning(LocalizationMessages.PREMATCHING_ALSO_NAME_BOUND(providerClass));
                }
            }
        }

        return result;
    }

    private void bindProvidersAndResources(
            final Iterable<ComponentProvider> componentProviders,
            final ComponentBag componentBag,
            final Collection<Class<?>> resourceClasses,
            final Collection<Object> resourceInstances) {

        final JerseyResourceContext resourceContext = locator.getService(JerseyResourceContext.class);
        final DynamicConfiguration dc = Injections.getConfiguration(locator);
        final Set<Class<?>> registeredClasses = runtimeConfig.getRegisteredClasses();

        
        final Set<Class<?>> classes = Sets.newIdentityHashSet();
        classes.addAll(Sets.filter(componentBag.getClasses(ComponentBag.EXCLUDE_META_PROVIDERS),
                new Predicate<Class<?>>() {
                    @Override
                    public boolean apply(final Class<?> componentClass) {
                        return Providers.checkProviderRuntime(
                                componentClass,
                                componentBag.getModel(componentClass),
                                RuntimeType.SERVER,
                                !registeredClasses.contains(componentClass),
                                resourceClasses.contains(componentClass));
                    }
                }
        ));
        classes.addAll(resourceClasses);

        
        for (final Class<?> componentClass : classes) {

            ContractProvider model = componentBag.getModel(componentClass);

            if (bindWithComponentProvider(componentClass, model, componentProviders)) {
                continue;
            }

            if (resourceClasses.contains(componentClass)) {

                if (!Resource.isAcceptable(componentClass)) {
                    LOGGER.warning(LocalizationMessages.NON_INSTANTIABLE_COMPONENT(componentClass));
                    continue;
                }

                if (model != null && !Providers.checkProviderRuntime(
                        componentClass,
                        model,
                        RuntimeType.SERVER,
                        !registeredClasses.contains(componentClass),
                        true)) {
                    model = null;
                }
                resourceContext.unsafeBindResource(componentClass, model, dc);
            } else {
                ProviderBinder.bindProvider(componentClass, model, dc);
            }
        }

        
        final Set<Object> instances = Sets.newHashSet();
        instances.addAll(Sets.filter(componentBag.getInstances(ComponentBag.EXCLUDE_META_PROVIDERS),
                new Predicate<Object>() {
                    @Override
                    public boolean apply(final Object component) {
                        final Class<?> componentClass = component.getClass();
                        return Providers.checkProviderRuntime(
                                componentClass,
                                componentBag.getModel(componentClass),
                                RuntimeType.SERVER,
                                !registeredClasses.contains(componentClass),
                                resourceInstances.contains(component));
                    }
                }
        ));
        instances.addAll(resourceInstances);

        
        for (final Object component : instances) {
            ContractProvider model = componentBag.getModel(component.getClass());
            if (resourceInstances.contains(component)) {
                if (model != null && !Providers.checkProviderRuntime(
                        component.getClass(),
                        model,
                        RuntimeType.SERVER,
                        !registeredClasses.contains(component.getClass()),
                        true)) {
                    model = null;
                }
                resourceContext.unsafeBindResource(component, model, dc);
            } else {
                ProviderBinder.bindProvider(component, model, dc);
            }
        }

        dc.commit();
    }

    private boolean bindWithComponentProvider(
            final Class<?> component,
            final ContractProvider providerModel,
            final Iterable<ComponentProvider> componentProviders) {

        final Set<Class<?>> contracts = providerModel == null ? Collections.<Class<?>>emptySet() : providerModel.getContracts();
        for (final ComponentProvider provider : componentProviders) {
            if (provider.bind(component, contracts)) {
                return true;
            }
        }
        return false;
    }

    
    public Future<ContainerResponse> apply(final ContainerRequest requestContext) {
        return apply(requestContext, new NullOutputStream());
    }

    
    public Future<ContainerResponse> apply(final ContainerRequest request,
                                           final OutputStream outputStream) {
        final FutureResponseWriter responseFuture =
                new FutureResponseWriter(request.getMethod(), outputStream, runtime.getBackgroundScheduler());

        if (request.getSecurityContext() == null) {
            request.setSecurityContext(DEFAULT_SECURITY_CONTEXT);
        }
        request.setWriter(responseFuture);

        handle(request);

        return responseFuture;
    }

    private static class FutureResponseWriter extends AbstractFuture<ContainerResponse> implements ContainerResponseWriter {

        private ContainerResponse response = null;

        private final String requestMethodName;
        private final OutputStream outputStream;

        private final JerseyRequestTimeoutHandler requestTimeoutHandler;

        private FutureResponseWriter(final String requestMethodName,
                                     final OutputStream outputStream,
                                     final ScheduledExecutorService backgroundScheduler) {
            this.requestMethodName = requestMethodName;
            this.outputStream = outputStream;
            this.requestTimeoutHandler = new JerseyRequestTimeoutHandler(this, backgroundScheduler);
        }

        @Override
        public OutputStream writeResponseStatusAndHeaders(final long contentLength, final ContainerResponse response) {
            this.response = response;

            if (contentLength >= 0) {
                response.getHeaders().putSingle(HttpHeaders.CONTENT_LENGTH, Long.toString(contentLength));
            }

            return outputStream;
        }

        @Override
        public boolean suspend(final long time, final TimeUnit unit, final TimeoutHandler handler) {
            return requestTimeoutHandler.suspend(time, unit, handler);
        }

        @Override
        public void setSuspendTimeout(final long time, final TimeUnit unit) {
            requestTimeoutHandler.setSuspendTimeout(time, unit);
        }

        @Override
        public void commit() {
            final ContainerResponse current = response;
            if (current != null) {
                if (HttpMethod.HEAD.equals(requestMethodName) && current.hasEntity()) {
                    
                    
                    current.setEntity(null);
                }
                requestTimeoutHandler.close();
                super.set(current);
            }
        }

        @Override
        public void failure(final Throwable error) {
            requestTimeoutHandler.close();
            super.setException(error);
        }

        @Override
        public boolean enableResponseBuffering() {
            return true;
        }

        @Override
        protected void interruptTask() {
            
        }

    }

    
    public void handle(final ContainerRequest request) {
        request.setWorkers(msgBodyWorkers);
        runtime.process(request);
    }

    
    public ServiceLocator getServiceLocator() {
        return locator;
    }

    
    public ResourceConfig getConfiguration() {
        return runtimeConfig;
    }

    

    @Override
    public void onStartup(final Container container) {
        for (final ContainerLifecycleListener listener : containerLifecycleListeners) {
            listener.onStartup(container);
        }
    }

    @Override
    public void onReload(final Container container) {
        for (final ContainerLifecycleListener listener : containerLifecycleListeners) {
            listener.onReload(container);
        }
    }

    @Override
    public void onShutdown(final Container container) {
        try {
            for (final ContainerLifecycleListener listener : containerLifecycleListeners) {
                listener.onShutdown(container);
            }
        } finally {
            try {
                
                locator.preDestroy(ResourceConfig.unwrapApplication(application));
            } finally {
                
                
                Injections.shutdownLocator(locator);
            }
        }
    }
}

<code block>


package org.glassfish.jersey.server.spi;


public interface ExternalRequestScope<T> extends AutoCloseable {

    
    public ExternalRequestContext<T> open();

    
    public void suspend(ExternalRequestContext<T> c);

    
    public void resume(ExternalRequestContext<T> c);

    
    @Override
    public void close();
}

<code block>

package org.glassfish.jersey.servlet;

import java.io.IOException;
import java.io.InputStream;
import java.util.Deque;
import java.util.LinkedList;
import java.util.NoSuchElementException;
import java.util.Set;

import javax.servlet.ServletContext;

import org.glassfish.jersey.server.internal.AbstractResourceFinderAdapter;
import org.glassfish.jersey.server.internal.scanning.JarFileScanner;
import org.glassfish.jersey.server.internal.scanning.ResourceFinderException;
import org.glassfish.jersey.server.internal.scanning.CompositeResourceFinder;


final class WebAppResourcesScanner extends AbstractResourceFinderAdapter {

    private static final String[] paths = new String[] {"/WEB-INF/lib/", "/WEB-INF/classes/"};

    private final ServletContext sc;
    private CompositeResourceFinder compositeResourceFinder = new CompositeResourceFinder();

    
    WebAppResourcesScanner(final ServletContext sc) {
        this.sc = sc;

        processPaths(paths);
    }

    private void processPaths(final String... paths) {
        for (final String path : paths) {

            final Set<String> resourcePaths = sc.getResourcePaths(path);
            if (resourcePaths == null) {
                break;
            }

            compositeResourceFinder.push(new AbstractResourceFinderAdapter() {

                private final Deque<String> resourcePathsStack = new LinkedList<String>() {

                    private static final long serialVersionUID = 3109256773218160485L;

                    {
                        for (final String resourcePath : resourcePaths) {
                            push(resourcePath);
                        }
                    }
                };

                private String current;
                private String next;

                @Override
                public boolean hasNext() {
                    while (next == null && !resourcePathsStack.isEmpty()) {
                        next = resourcePathsStack.pop();

                        if (next.endsWith("/")) {
                            processPaths(next);
                            next = null;
                        } else if (next.endsWith(".jar")) {
                            try {
                                compositeResourceFinder.push(new JarFileScanner(sc.getResourceAsStream(next), "", true));
                            } catch (final IOException ioe) {
                                throw new ResourceFinderException(ioe);
                            }
                            next = null;
                        }
                    }

                    return next != null;
                }

                @Override
                public String next() {
                    if (next != null || hasNext()) {
                        current = next;
                        next = null;
                        return current;
                    }

                    throw new NoSuchElementException();
                }

                @Override
                public InputStream open() {
                    return sc.getResourceAsStream(current);
                }

                @Override
                public void reset() {
                    throw new UnsupportedOperationException();
                }
            });

        }
    }

    @Override
    public boolean hasNext() {
        return compositeResourceFinder.hasNext();
    }

    @Override
    public String next() {
        return compositeResourceFinder.next();
    }

    @Override
    public InputStream open() {
        return compositeResourceFinder.open();
    }

    @Override
    public void close() {
        compositeResourceFinder.close();
    }

    @Override
    public void reset() {
        compositeResourceFinder = new CompositeResourceFinder();
        processPaths(paths);
    }
}

<code block>


package org.glassfish.jersey.server;

import java.io.IOException;
import java.io.InputStream;
import java.security.AccessController;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.ws.rs.RuntimeType;
import javax.ws.rs.core.Application;
import javax.ws.rs.core.Configurable;
import javax.ws.rs.core.Configuration;
import javax.ws.rs.core.Feature;

import org.glassfish.jersey.internal.Errors;
import org.glassfish.jersey.internal.util.PropertiesHelper;
import org.glassfish.jersey.internal.util.ReflectionHelper;
import org.glassfish.jersey.internal.util.Tokenizer;
import org.glassfish.jersey.model.ContractProvider;
import org.glassfish.jersey.model.internal.CommonConfig;
import org.glassfish.jersey.model.internal.ComponentBag;
import org.glassfish.jersey.process.Inflector;
import org.glassfish.jersey.process.internal.RequestScoped;
import org.glassfish.jersey.server.internal.LocalizationMessages;
import org.glassfish.jersey.server.internal.scanning.AnnotationAcceptingListener;
import org.glassfish.jersey.server.internal.scanning.FilesScanner;
import org.glassfish.jersey.server.internal.scanning.PackageNamesScanner;
import org.glassfish.jersey.server.model.Resource;

import org.glassfish.hk2.api.ServiceLocator;
import org.glassfish.hk2.utilities.Binder;

import jersey.repackaged.com.google.common.base.Predicate;
import jersey.repackaged.com.google.common.collect.Sets;


public class ResourceConfig extends Application implements Configurable<ResourceConfig>, ServerConfig {

    private static final Logger LOGGER = Logger.getLogger(ResourceConfig.class.getName());

    private transient Set<Class<?>> cachedClasses = null;
    private transient Set<Class<?>> cachedClassesView = null;
    private transient Set<Object> cachedSingletons = null;
    private transient Set<Object> cachedSingletonsView = null;

    private transient boolean resetFinders = false;

    private volatile State state;

    private static class State extends CommonConfig implements ServerConfig {

        private final Set<ResourceFinder> resourceFinders;

        private final Set<Resource> resources;
        private final Set<Resource> resourcesView;
        private volatile String applicationName;

        private volatile ClassLoader classLoader = null;

        public State() {
            super(RuntimeType.SERVER, ComponentBag.INCLUDE_ALL);
            this.classLoader = AccessController.doPrivileged(ReflectionHelper.getContextClassLoaderPA());

            this.resourceFinders = Sets.newHashSet();

            this.resources = Sets.newHashSet();
            this.resourcesView = Collections.unmodifiableSet(this.resources);
        }

        public State(final State original) {
            super(original);
            this.classLoader = original.classLoader;
            this.applicationName = original.applicationName;

            this.resources = Sets.newHashSet(original.resources);
            this.resourcesView = Collections.unmodifiableSet(this.resources);

            this.resourceFinders = Sets.newHashSet(original.resourceFinders);
        }

        public void setClassLoader(final ClassLoader classLoader) {
            this.classLoader = classLoader;
        }

        public void setApplicationName(final String applicationName) {
            this.applicationName = applicationName;
        }

        public void registerResources(final Set<Resource> resources) {
            this.resources.addAll(resources);
        }

        public void registerFinder(final ResourceFinder resourceFinder) {
            this.resourceFinders.add(resourceFinder);
        }

        @Override
        protected Inflector<ContractProvider.Builder, ContractProvider> getModelEnhancer(final Class<?> componentClass) {
            return new Inflector<ContractProvider.Builder, ContractProvider>() {
                @Override
                public ContractProvider apply(final ContractProvider.Builder builder) {
                    if (builder.getScope() == null && builder.getContracts().isEmpty()
                            && Resource.getPath(componentClass) != null) {
                        builder.scope(RequestScoped.class);
                    }

                    return builder.build();
                }
            };

        }

        @Override
        public State loadFrom(final Configuration config) {
            super.loadFrom(config);
            this.resourceFinders.clear();
            this.resources.clear();

            State other = null;
            if (config instanceof ResourceConfig) {
                other = ((ResourceConfig) config).state;
            }
            if (config instanceof State) {
                other = (State) config;
            }

            if (other != null) {
                this.resourceFinders.addAll(other.resourceFinders);
                this.resources.addAll(other.resources);
            }

            return this;
        }

        @Override
        public final Set<Resource> getResources() {
            return resourcesView;
        }

        @Override
        public ServerConfig getConfiguration() {
            return this;
        }

        
        public Set<ResourceFinder> getResourceFinders() {
            return resourceFinders;
        }

        
        public ClassLoader getClassLoader() {
            return classLoader;
        }

        private String getApplicationName() {
            return applicationName;
        }
    }

    private static final class ImmutableState extends State {

        private ImmutableState(final State original) {
            super(original);
        }

        @Override
        public void setClassLoader(final ClassLoader classLoader) {
            throw new IllegalStateException(LocalizationMessages.RC_NOT_MODIFIABLE());
        }

        @Override
        public void registerResources(final Set<Resource> resources) {
            throw new IllegalStateException(LocalizationMessages.RC_NOT_MODIFIABLE());
        }

        @Override
        public void registerFinder(final ResourceFinder resourceFinder) {
            throw new IllegalStateException(LocalizationMessages.RC_NOT_MODIFIABLE());
        }

        @Override
        public State addProperties(final Map<String, ?> properties) {
            throw new IllegalStateException(LocalizationMessages.RC_NOT_MODIFIABLE());
        }

        @Override
        public State property(final String name, final Object value) {
            throw new IllegalStateException(LocalizationMessages.RC_NOT_MODIFIABLE());
        }

        @Override
        public State register(final Class<?> componentClass) {
            throw new IllegalStateException(LocalizationMessages.RC_NOT_MODIFIABLE());
        }

        @Override
        public State register(final Class<?> componentClass, final int bindingPriority) {
            throw new IllegalStateException(LocalizationMessages.RC_NOT_MODIFIABLE());
        }

        @Override
        public State register(final Class<?> componentClass, final Class<?>... contracts) {
            throw new IllegalStateException(LocalizationMessages.RC_NOT_MODIFIABLE());
        }

        @Override
        public State register(final Class<?> componentClass, final Map<Class<?>, Integer> contracts) {
            throw new IllegalStateException(LocalizationMessages.RC_NOT_MODIFIABLE());
        }

        @Override
        public State register(final Object component) {
            throw new IllegalStateException(LocalizationMessages.RC_NOT_MODIFIABLE());
        }

        @Override
        public State register(final Object component, final int bindingPriority) {
            throw new IllegalStateException(LocalizationMessages.RC_NOT_MODIFIABLE());
        }

        @Override
        public State register(final Object component, final Class<?>... contracts) {
            throw new IllegalStateException(LocalizationMessages.RC_NOT_MODIFIABLE());
        }

        @Override
        public State register(final Object component, final Map<Class<?>, Integer> contracts) {
            throw new IllegalStateException(LocalizationMessages.RC_NOT_MODIFIABLE());
        }

        @Override
        public State setProperties(final Map<String, ?> properties) {
            throw new IllegalStateException(LocalizationMessages.RC_NOT_MODIFIABLE());
        }

        @Override
        public void configureAutoDiscoverableProviders(final ServiceLocator locator, final boolean forcedOnly) {
            throw new IllegalStateException(LocalizationMessages.RC_NOT_MODIFIABLE());
        }

        @Override
        public void configureMetaProviders(final ServiceLocator locator) {
            throw new IllegalStateException(LocalizationMessages.RC_NOT_MODIFIABLE());
        }
    }

    
    public static ResourceConfig forApplication(final Application application) {
        return application instanceof ResourceConfig
                ? ((ResourceConfig) application)
                : new WrappingResourceConfig(application, null, null);
    }

    
    public static ResourceConfig forApplicationClass(final Class<? extends Application> applicationClass) {
        return new WrappingResourceConfig(null, applicationClass, null);
    }

    
    public static ResourceConfig forApplicationClass(final Class<? extends Application> applicationClass,
                                                     final Set<Class<?>> defaultClasses) {
        return new WrappingResourceConfig(null, applicationClass, defaultClasses);
    }

    
    public ResourceConfig() {
        this.state = new State();
    }

    
    public ResourceConfig(final Set<Class<?>> classes) {
        this();
        this.registerClasses(classes);
    }

    
    public ResourceConfig(final Class<?>... classes) {
        this(Sets.newHashSet(classes));
    }

    
    public ResourceConfig(final ResourceConfig original) {
        this.state = new State(original.state);
    }

    
    public final ResourceConfig addProperties(final Map<String, Object> properties) {
        state.addProperties(properties);
        return this;
    }

    
    public ResourceConfig setProperties(final Map<String, ?> properties) {
        state.setProperties(properties);
        return this;
    }

    @Override
    public ResourceConfig property(final String name, final Object value) {
        state.property(name, value);
        return this;
    }

    @Override
    public ResourceConfig register(final Class<?> componentClass) {
        invalidateCache();
        state.register(componentClass);
        return this;
    }

    @Override
    public ResourceConfig register(final Class<?> componentClass, final int bindingPriority) {
        invalidateCache();
        state.register(componentClass, bindingPriority);
        return this;
    }

    @Override
    public ResourceConfig register(final Class<?> componentClass, final Class<?>... contracts) {
        invalidateCache();
        state.register(componentClass, contracts);
        return this;
    }

    @Override
    public ResourceConfig register(final Class<?> componentClass, final Map<Class<?>, Integer> contracts) {
        invalidateCache();
        state.register(componentClass, contracts);
        return this;
    }

    @Override
    public ResourceConfig register(final Object component) {
        invalidateCache();
        state.register(component);
        return this;
    }

    @Override
    public ResourceConfig register(final Object component, final int bindingPriority) {
        invalidateCache();
        state.register(component, bindingPriority);
        return this;
    }

    @Override
    public ResourceConfig register(final Object component, final Class<?>... contracts) {
        invalidateCache();
        state.register(component, contracts);
        return this;
    }

    @Override
    public ResourceConfig register(final Object component, final Map<Class<?>, Integer> contracts) {
        invalidateCache();
        state.register(component, contracts);
        return this;
    }

    
    public final ResourceConfig registerClasses(final Set<Class<?>> classes) {
        if (classes == null) {
            return this;
        }

        for (final Class<?> cls : classes) {
            register(cls);
        }
        return this;
    }

    
    public final ResourceConfig registerClasses(final Class<?>... classes) {
        if (classes == null) {
            return this;
        }

        return registerClasses(Sets.newHashSet(classes));
    }

    
    public final ResourceConfig registerInstances(final Set<Object> instances) {
        if (instances == null) {
            return this;
        }

        for (final Object instance : instances) {
            register(instance);
        }
        return this;
    }

    
    public final ResourceConfig registerInstances(final Object... instances) {
        if (instances == null) {
            return this;
        }

        return registerInstances(Sets.newHashSet(instances));
    }

    
    public final ResourceConfig registerResources(final Resource... resources) {
        if (resources == null) {
            return this;
        }

        return registerResources(Sets.newHashSet(resources));
    }

    
    public final ResourceConfig registerResources(final Set<Resource> resources) {
        if (resources == null) {
            return this;
        }

        this.state.registerResources(resources);
        return this;
    }

    
    public final ResourceConfig registerFinder(final ResourceFinder resourceFinder) {
        if (resourceFinder == null) {
            return this;
        }
        invalidateCache();

        this.state.registerFinder(resourceFinder);
        return this;
    }

    
    public final ResourceConfig setApplicationName(final String applicationName) {
        state.setApplicationName(applicationName);
        return this;
    }

    
    public final ResourceConfig setClassLoader(final ClassLoader classLoader) {
        this.state.setClassLoader(classLoader);
        return this;
    }

    
    public final ResourceConfig packages(final String... packages) {
        return packages(true, packages);
    }

    
    public final ResourceConfig packages(final boolean recursive, final String... packages) {
        if (packages == null || packages.length == 0) {
            return this;
        }
        return registerFinder(new PackageNamesScanner(packages, recursive));
    }

    
    public final ResourceConfig files(final String... files) {
        return files(true, files);
    }

    
    public final ResourceConfig files(final boolean recursive, final String... files) {
        if (files == null || files.length == 0) {
            return this;
        }
        return registerFinder(new FilesScanner(files, recursive));
    }

    
    final void invalidateCache() {
        this.cachedClasses = null;
        this.cachedClassesView = null;
        this.cachedSingletons = null;
        this.cachedSingletonsView = null;

        
        if (resetFinders) {
            for (final ResourceFinder finder : this.state.resourceFinders) {
                finder.reset();
            }
            resetFinders = false;
        }
    }

    
    final void lock() {
        final State current = state;
        if (!(current instanceof ImmutableState)) {
            setupApplicationName();
            state = new ImmutableState(current);
        }
    }

    @Override
    public final ServerConfig getConfiguration() {
        return this;
    }

    @Override
    public final Map<String, Object> getProperties() {
        return state.getProperties();
    }

    @Override
    public final Object getProperty(final String name) {
        return state.getProperty(name);
    }

    @Override
    public Collection<String> getPropertyNames() {
        return state.getPropertyNames();
    }

    @Override
    public final boolean isProperty(final String name) {
        return state.isProperty(name);
    }

    @Override
    public final Set<Class<?>> getClasses() {
        if (cachedClassesView == null) {
            cachedClasses = _getClasses();
            cachedClassesView = Collections.unmodifiableSet(cachedClasses);
        }
        return cachedClassesView;
    }

    @Override
    public final Set<Object> getInstances() {
        return getSingletons();
    }

    @Override
    public final Set<Object> getSingletons() {
        if (cachedSingletonsView == null) {
            cachedSingletons = _getSingletons();
            cachedSingletonsView = Collections.unmodifiableSet(cachedSingletons == null ? new HashSet<>() : cachedSingletons);
        }

        return cachedSingletonsView;
    }

    
    final ComponentBag getComponentBag() {
        return state.getComponentBag();
    }

    
    final void configureAutoDiscoverableProviders(final ServiceLocator locator) {
        state.configureAutoDiscoverableProviders(locator, false);
    }

    
    final void configureForcedAutoDiscoverableProviders(final ServiceLocator locator) {
        state.configureAutoDiscoverableProviders(locator, true);
    }

    
    final void configureMetaProviders(final ServiceLocator locator) {
        state.configureMetaProviders(locator);
    }

    @Override
    public RuntimeType getRuntimeType() {
        return state.getRuntimeType();
    }

    @Override
    public boolean isEnabled(final Feature feature) {
        return state.isEnabled(feature);
    }

    @Override
    public boolean isEnabled(final Class<? extends Feature> featureClass) {
        return state.isEnabled(featureClass);
    }

    @Override
    public boolean isRegistered(final Object component) {
        return state.isRegistered(component);
    }

    @Override
    public boolean isRegistered(final Class<?> componentClass) {
        return state.isRegistered(componentClass);
    }

    @Override
    public Map<Class<?>, Integer> getContracts(final Class<?> componentClass) {
        return state.getContracts(componentClass);
    }

    
    Set<Class<?>> _getClasses() {
        final Set<Class<?>> result = scanClasses();
        result.addAll(state.getClasses());
        return result;
    }

    private Set<Class<?>> scanClasses() {
        final Set<Class<?>> result = Sets.newHashSet();

        final ResourceConfig.State _state = state;
        final Set<ResourceFinder> rfs = Sets.newHashSet(_state.getResourceFinders());

        
        resetFinders = true;

        
        final String[] classNames = parsePropertyValue(ServerProperties.PROVIDER_CLASSNAMES);
        if (classNames != null) {
            for (final String className : classNames) {
                try {
                    result.add(_state.getClassLoader().loadClass(className));
                } catch (final ClassNotFoundException e) {
                    LOGGER.log(Level.CONFIG, LocalizationMessages.UNABLE_TO_LOAD_CLASS(className));
                }
            }
        }

        final String[] packageNames = parsePropertyValue(ServerProperties.PROVIDER_PACKAGES);
        if (packageNames != null) {
            final Object p = getProperty(ServerProperties.PROVIDER_SCANNING_RECURSIVE);
            final boolean recursive = p == null || PropertiesHelper.isProperty(p);
            rfs.add(new PackageNamesScanner(packageNames, recursive));
        }

        final String[] classPathElements = parsePropertyValue(ServerProperties.PROVIDER_CLASSPATH);
        if (classPathElements != null) {
            rfs.add(new FilesScanner(classPathElements, true));
        }

        final AnnotationAcceptingListener afl =
                AnnotationAcceptingListener.newJaxrsResourceAndProviderListener(_state.getClassLoader());
        for (final ResourceFinder resourceFinder : rfs) {
            while (resourceFinder.hasNext()) {
                final String next = resourceFinder.next();
                if (afl.accept(next)) {
                    final InputStream in = resourceFinder.open();
                    try {
                        afl.process(next, in);
                    } catch (final IOException e) {
                        LOGGER.log(Level.WARNING, LocalizationMessages.RESOURCE_CONFIG_UNABLE_TO_PROCESS(next));
                    } finally {
                        try {
                            in.close();
                        } catch (final IOException ex) {
                            LOGGER.log(Level.FINER, "Error closing resource stream.", ex);
                        }
                    }
                }
            }
        }

        result.addAll(afl.getAnnotatedClasses());
        return result;
    }

    private String[] parsePropertyValue(final String propertyName) {
        String[] classNames = null;
        final Object o = state.getProperties().get(propertyName);
        if (o != null) {
            if (o instanceof String) {
                classNames = Tokenizer.tokenize((String) o);
            } else if (o instanceof String[]) {
                classNames = Tokenizer.tokenize((String[]) o);
            }
        }
        return classNames;
    }

    
    Set<Class<?>> getRegisteredClasses() {
        return state.getComponentBag().getRegistrations();
    }

    
    Set<Object> _getSingletons() {
        final Set<Object> result = Sets.newHashSet();
        result.addAll(state.getInstances());
        return result;
    }

    @Override
    public final Set<Resource> getResources() {
        return state.getResources();
    }

    
    public final ClassLoader getClassLoader() {
        return state.getClassLoader();
    }

    
    public final Application getApplication() {
        return _getApplication();
    }

    
    Application _getApplication() {
        return this;
    }

    
    public String getApplicationName() {
        return state.getApplicationName();
    }

    
    Class<? extends Application> getApplicationClass() {
        return null;
    }

    
    final ResourceConfig setApplication(final Application app) {
        return _setApplication(app);
    }

    
    ResourceConfig _setApplication(final Application app) {
        throw new UnsupportedOperationException();
    }

    private static class WrappingResourceConfig extends ResourceConfig {

        private Application application;
        private Class<? extends Application> applicationClass;
        private final Set<Class<?>> defaultClasses = Sets.newHashSet();

        public WrappingResourceConfig(
                final Application application, final Class<? extends Application> applicationClass,
                final Set<Class<?>> defaultClasses) {

            if (application == null && applicationClass == null) {
                throw new IllegalArgumentException(LocalizationMessages.RESOURCE_CONFIG_ERROR_NULL_APPLICATIONCLASS());
            }
            this.application = application;
            this.applicationClass = applicationClass;
            if (defaultClasses != null) {
                this.defaultClasses.addAll(defaultClasses);
            }
            mergeApplications(application);
        }

        
        @Override
        ResourceConfig _setApplication(final Application application) {
            this.application = application;
            this.applicationClass = null;
            mergeApplications(application);
            return this;
        }

        
        @Override
        Application _getApplication() {
            return application;
        }

        
        @Override
        Class<? extends Application> getApplicationClass() {
            return applicationClass;
        }

        
        private void mergeApplications(final Application application) {
            if (application instanceof ResourceConfig) {
                
                final ResourceConfig rc = (ResourceConfig) application;

                
                super.registerResources(rc.getResources());

                
                
                rc.invalidateCache();
                rc.addProperties(super.getProperties());
                super.addProperties(rc.getProperties());
                super.setApplicationName(rc.getApplicationName());
                super.setClassLoader(rc.getClassLoader());

                rc.lock();
            } else if (application != null) {
                super.addProperties(application.getProperties());
            }
        }

        @Override
        Set<Class<?>> _getClasses() {
            final Set<Class<?>> result = Sets.newHashSet();
            final Set<Class<?>> applicationClasses = application.getClasses();
            result.addAll(applicationClasses == null ? new HashSet<Class<?>>() : applicationClasses);
            if (result.isEmpty() && getSingletons().isEmpty()) {
                result.addAll(defaultClasses);
            }

            
            if (!(application instanceof ResourceConfig)) {
                result.addAll(super._getClasses());
            }
            return result;
        }

        @Override
        Set<Object> _getSingletons() {
            return application.getSingletons();
        }
    }

    
    static ResourceConfig createRuntimeConfig(final Application application) {
        return (application instanceof ResourceConfig)
                ? new RuntimeConfig((ResourceConfig) application) : new RuntimeConfig(application);
    }

    private static class RuntimeConfig extends ResourceConfig {

        private final Set<Class<?>> originalRegistrations;
        private final Application application;

        private RuntimeConfig(final ResourceConfig original) {
            super(original);

            this.application = original;

            final Application customRootApp = ResourceConfig.unwrapCustomRootApplication(original);
            if (customRootApp != null) {
                registerComponentsOf(customRootApp);
            }

            originalRegistrations = Sets.newIdentityHashSet();
            originalRegistrations.addAll(super.getRegisteredClasses());

            
            final Set<Object> externalInstances = Sets.filter(original.getSingletons(), new Predicate<Object>() {
                @Override
                public boolean apply(final Object external) {
                    return !originalRegistrations.contains(external.getClass());
                }
            });
            registerInstances(externalInstances);

            
            final Set<Class<?>> externalClasses = Sets.filter(original.getClasses(), new Predicate<Class<?>>() {
                @Override
                public boolean apply(final Class<?> external) {
                    return !originalRegistrations.contains(external);
                }
            });
            registerClasses(externalClasses);
        }

        private void registerComponentsOf(final Application application) {
            Errors.processWithException(new Runnable() {
                @Override
                public void run() {
                    
                    
                    final Set<Object> singletons = application.getSingletons();
                    if (singletons != null) {
                        registerInstances(Sets.filter(singletons, new Predicate<Object>() {
                            @Override
                            public boolean apply(final Object input) {
                                if (input == null) {
                                    Errors.warning(application, LocalizationMessages.NON_INSTANTIABLE_COMPONENT(null));
                                }
                                return input != null;
                            }
                        }));
                    }

                    final Set<Class<?>> classes = application.getClasses();
                    if (classes != null) {
                        registerClasses(Sets.filter(classes, new Predicate<Class<?>>() {
                            @Override
                            public boolean apply(final Class<?> input) {
                                if (input == null) {
                                    Errors.warning(application, LocalizationMessages.NON_INSTANTIABLE_COMPONENT(null));
                                }
                                return input != null;
                            }
                        }));
                    }
                }
            });
        }

        private RuntimeConfig(final Application application) {
            super();

            this.application = application;

            if (application != null) {
                registerComponentsOf(application);

                
                addProperties(application.getProperties());
            }

            originalRegistrations = super.getRegisteredClasses();
        }

        @Override
        Set<Class<?>> _getClasses() {
            
            return super.state.getClasses();
        }

        @Override
        Set<Object> _getSingletons() {
            
            return super.state.getInstances();
        }

        @Override
        Set<Class<?>> getRegisteredClasses() {
            return originalRegistrations;
        }

        @Override
        Application _getApplication() {
            return application;
        }
    }

    private static Application unwrapCustomRootApplication(ResourceConfig resourceConfig) {
        Application app = null;
        while (resourceConfig != null) {
            app = resourceConfig.getApplication();
            if (app == resourceConfig) {
                
                return null;
            } else if (app instanceof ResourceConfig) {
                resourceConfig = (ResourceConfig) app;
            } else {
                break;
            }
        }
        return app;
    }

    
    static Application unwrapApplication(Application application) {
        while (application instanceof ResourceConfig) {
            final Application wrappedApplication = ((ResourceConfig) application).getApplication();
            if (wrappedApplication == application) {
                break;
            }
            application = wrappedApplication;
        }
        return application;
    }

    private void setupApplicationName() {
        final String appName = ServerProperties.getValue(getProperties(), ServerProperties.APPLICATION_NAME, null, String.class);
        if (appName != null && getApplicationName() == null) {
            setApplicationName(appName);
        }
    }
}

<code block>

package org.glassfish.jersey.server;

import java.io.InputStream;
import java.util.Iterator;


public interface ResourceFinder extends Iterator<String>, AutoCloseable {

    
    public InputStream open();

    
    public void close();

    
    public void reset();

    
    @Override
    public void remove();
}

<code block>

package org.glassfish.jersey.server.internal;

import org.glassfish.jersey.server.ResourceFinder;


public abstract class AbstractResourceFinderAdapter implements ResourceFinder {

    
    @Override
    public void remove() {
        throw new UnsupportedOperationException();
    }

    
    @Override
    public void close() {
        
    }
}

<code block>

package org.glassfish.jersey.server.internal.scanning;

import java.io.InputStream;
import java.util.Deque;
import java.util.LinkedList;
import java.util.NoSuchElementException;
import java.util.Stack;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.glassfish.jersey.server.ResourceFinder;
import org.glassfish.jersey.server.internal.AbstractResourceFinderAdapter;
import org.glassfish.jersey.server.internal.LocalizationMessages;


public final class CompositeResourceFinder extends AbstractResourceFinderAdapter {

    private static final Logger LOGGER = Logger.getLogger(CompositeResourceFinder.class.getName());

    private final Deque<ResourceFinder> stack = new LinkedList<>();
    private ResourceFinder current = null;

    @Override
    public boolean hasNext() {
        if (current == null) {
            if (!stack.isEmpty()) {
                current = stack.pop();
            } else {
                return false;
            }
        }

        if (current.hasNext()) {
            return true;
        } else {
            if (!stack.isEmpty()) {
                current = stack.pop();
                return hasNext();
            } else {
                return false;
            }
        }
    }

    @Override
    public String next() {
        if (hasNext()) {
            return current.next();
        }

        throw new NoSuchElementException();
    }

    @Override
    public InputStream open() {
        return current.open();
    }

    @Override
    public void close() {
        if (current != null) {
            
            stack.addFirst(current);
            current = null;
        }
        for (final ResourceFinder finder : stack) {
            try {
                finder.close();
            } catch (final RuntimeException e) {
                LOGGER.log(Level.CONFIG, LocalizationMessages.ERROR_CLOSING_FINDER(finder.getClass()), e);
            }
        }
        stack.clear();
    }

    @Override
    public void reset() {
        throw new UnsupportedOperationException();
    }

    public void push(final ResourceFinder iterator) {
        stack.push(iterator);
    }
}

<code block>

package org.glassfish.jersey.server.internal.scanning;

import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Method;
import java.net.URI;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Set;

import org.glassfish.jersey.server.ResourceFinder;
import org.glassfish.jersey.server.internal.AbstractResourceFinderAdapter;


final class VfsSchemeResourceFinderFactory implements UriSchemeResourceFinderFactory {

    private static final Set<String> SCHEMES = Collections
            .unmodifiableSet(new HashSet<>(Arrays.asList("vfsfile", "vfszip", "vfs")));

    public Set<String> getSchemes() {
        return SCHEMES;
    }

    VfsSchemeResourceFinderFactory() {
    }

    @Override
    public ResourceFinder create(final URI uri, final boolean recursive) {
        return new VfsResourceFinder(uri, recursive);
    }

    private static class VfsResourceFinder extends AbstractResourceFinderAdapter {

        private Object current;
        private Object next;
        private final Method openStream;
        private final Method getName;
        private final Method isLeaf;
        private final Iterator<?> iterator;

        public VfsResourceFinder(final URI uri, final boolean recursive) {
            final Object directory = bindDirectory(uri);
            this.openStream = bindMethod(directory, "openStream");
            this.getName = bindMethod(directory, "getName");
            this.isLeaf = bindMethod(directory, "isLeaf");
            this.iterator = getChildren(directory, recursive);
        }

        private Iterator<?> getChildren(final Object directory, final boolean recursive) {
            final Method getChildren = bindMethod(directory, recursive ? "getChildrenRecursively" : "getChildren");

            final List<?> list = invoke(directory, getChildren, List.class);
            if (list == null) {
                throw new ResourceFinderException("VFS object returned null when accessing children");
            }

            return list.iterator();
        }

        private Method bindMethod(final Object object, final String name) {
            if (System.getSecurityManager() != null) {
                AccessController.doPrivileged(new PrivilegedAction<Method>() {
                    public Method run() {
                        return bindMethod0(object, name);
                    }
                });
            }

            return bindMethod0(object, name);
        }

        private <T> T invoke(final Object instance, final Method method, final Class<T> type) {
            try {
                return type.cast(method.invoke(instance));
            } catch (final Exception e) {
                throw new ResourceFinderException("VFS object could not be invoked upon");
            }
        }

        private Method bindMethod0(final Object object, final String name) {
            final Class<?> clazz = object.getClass();

            try {
                return clazz.getMethod(name);
            } catch (final NoSuchMethodException e) {
                throw new ResourceFinderException("VFS object did not have a valid signature");
            }
        }

        private Object bindDirectory(final URI uri) {
            Object directory = null;
            try {
                directory = uri.toURL().getContent();
            } catch (final IOException e) {
                
            }

            if (directory == null || !directory.getClass().getSimpleName().equals("VirtualFile")) {
                throw new ResourceFinderException("VFS URL did not map to a valid VFS object");
            }

            return directory;
        }

        @Override
        public InputStream open() {
            final Object current = this.current;
            if (current == null) {
                throw new IllegalStateException("next() must be called before open()");
            }

            return invoke(current, openStream, InputStream.class);
        }

        @Override
        public void reset() {
            throw new UnsupportedOperationException();
        }

        public boolean advance() {
            while (iterator.hasNext()) {
                final Object next = iterator.next();
                if (invoke(next, isLeaf, Boolean.class)) {
                    this.next = next;
                    return true;
                }
            }

            return false;
        }

        @Override
        public boolean hasNext() {
            return next != null || advance();
        }

        @Override
        public String next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }

            current = next;
            next = null;
            return invoke(current, getName, String.class);
        }
    }
}

<code block>

package org.glassfish.jersey.server.internal.scanning;

import java.io.IOException;
import java.io.InputStream;
import java.util.NoSuchElementException;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.glassfish.jersey.server.internal.AbstractResourceFinderAdapter;
import org.glassfish.jersey.server.internal.LocalizationMessages;


public final class JarFileScanner extends AbstractResourceFinderAdapter {

    private static final Logger LOGGER = Logger.getLogger(JarFileScanner.class.getName());
    
    private static final char JAR_FILE_SEPARATOR = '/';

    private final JarInputStream jarInputStream;
    private final String parent;
    private final boolean recursive;

    
    public JarFileScanner(final InputStream inputStream, final String parent, final boolean recursive) throws IOException {
        this.jarInputStream = new JarInputStream(inputStream);
        this.parent = (parent.isEmpty() || parent.endsWith(String.valueOf(JAR_FILE_SEPARATOR)))
                ? parent : parent + JAR_FILE_SEPARATOR;
        this.recursive = recursive;
    }

    private JarEntry next = null;

    @Override
    public boolean hasNext() {
        if (next == null) {
            try {
                do {
                    this.next = jarInputStream.getNextJarEntry();
                    if (next == null) {
                        break;
                    }
                    if (!next.isDirectory() && next.getName().startsWith(parent)) {
                        if (recursive || next.getName().substring(parent.length()).indexOf(JAR_FILE_SEPARATOR) == -1) {
                            break;
                        }
                    }
                } while (true);
            } catch (final IOException | SecurityException e) {
                LOGGER.log(Level.CONFIG, LocalizationMessages.JAR_SCANNER_UNABLE_TO_READ_ENTRY(), e);
                return false;
            }
        }

        if (next == null) {
            close();

            return false;
        }

        return true;
    }

    @Override
    public String next() {
        if (next != null || hasNext()) {
            final String name = next.getName();
            next = null;
            return name;
        }

        throw new NoSuchElementException();
    }

    @Override
    public void reset() {
        throw new UnsupportedOperationException();
    }

    @Override
    public InputStream open() {
        
        return new InputStream() {

            @Override
            public int read() throws IOException {
                return jarInputStream.read();
            }

            @Override
            public int read(final byte[] bytes) throws IOException {
                return jarInputStream.read(bytes);
            }

            @Override
            public int read(final byte[] bytes, final int i, final int i2) throws IOException {
                return jarInputStream.read(bytes, i, i2);
            }

            @Override
            public long skip(final long l) throws IOException {
                return jarInputStream.skip(l);
            }

            @Override
            public int available() throws IOException {
                return jarInputStream.available();
            }

            @Override
            public void close() throws IOException {
                jarInputStream.closeEntry();
            }

            @Override
            public synchronized void mark(final int i) {
                jarInputStream.mark(i);
            }

            @Override
            public synchronized void reset() throws IOException {
                jarInputStream.reset();
            }

            @Override
            public boolean markSupported() {
                return jarInputStream.markSupported();
            }
        };
    }

    @Override
    public void close() {
        try {
            jarInputStream.close();
        } catch (final IOException ioe) {
            LOGGER.log(Level.FINE, LocalizationMessages.JAR_SCANNER_UNABLE_TO_CLOSE_FILE(), ioe);
        }
    }
}


<code block>

package org.glassfish.jersey.server.internal.scanning;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URL;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.glassfish.jersey.server.internal.AbstractResourceFinderAdapter;
import org.glassfish.jersey.uri.UriComponent;


final class JarZipSchemeResourceFinderFactory implements UriSchemeResourceFinderFactory {

    private static final Set<String> SCHEMES = Collections.unmodifiableSet(new HashSet<>(Arrays.asList("jar", "zip", "wsjar")));

    @Override
    public Set<String> getSchemes() {
        return SCHEMES;
    }

    
    JarZipSchemeResourceFinderFactory() {
    }

    @Override
    public JarZipSchemeScanner create(final URI uri, final boolean recursive) {
        final String ssp = uri.getRawSchemeSpecificPart();
        final String jarUrlString = ssp.substring(0, ssp.lastIndexOf('!'));
        final String parent = ssp.substring(ssp.lastIndexOf('!') + 2);

        try {
            return new JarZipSchemeScanner(getInputStream(jarUrlString), parent, recursive);
        } catch (final IOException e) {
            throw new ResourceFinderException(e);
        }
    }

    private class JarZipSchemeScanner extends AbstractResourceFinderAdapter {

        private final InputStream inputStream;
        private final JarFileScanner jarFileScanner;

        private JarZipSchemeScanner(final InputStream inputStream, final String parent, final boolean recursive)
                throws IOException {
            this.inputStream = inputStream;
            this.jarFileScanner = new JarFileScanner(inputStream, parent, recursive);
        }

        @Override
        public boolean hasNext() {
            final boolean hasNext = jarFileScanner.hasNext();
            if (!hasNext) {
                try {
                    inputStream.close();
                } catch (final IOException e) {
                    Logger.getLogger(JarZipSchemeScanner.class.getName()).log(Level.FINE, "Unable to close jar file.", e);
                }
                return false;
            }

            return true;
        }

        @Override
        public String next() {
            return jarFileScanner.next();
        }

        @Override
        public InputStream open() {
            return jarFileScanner.open();
        }

        @Override
        public void close() {
            jarFileScanner.close();
        }

        @Override
        public void reset() {
            jarFileScanner.reset();
        }
    }

    
    private InputStream getInputStream(final String jarUrlString) throws IOException {
        try {
            return new URL(jarUrlString).openStream();
        } catch (final MalformedURLException e) {
            return new FileInputStream(
                    UriComponent.decode(jarUrlString, UriComponent.Type.PATH));
        }
    }
}

<code block>

package org.glassfish.jersey.server.internal.scanning;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.NoSuchElementException;
import java.util.Stack;

import org.glassfish.jersey.internal.util.Tokenizer;
import org.glassfish.jersey.server.internal.AbstractResourceFinderAdapter;


public final class FilesScanner extends AbstractResourceFinderAdapter {

    private final File[] files;
    private final boolean recursive;

    private CompositeResourceFinder compositeResourceFinder;

    
    public FilesScanner(final String[] fileNames, final boolean recursive) {
        this.recursive = recursive;
        this.files = new File[Tokenizer.tokenize(fileNames, Tokenizer.COMMON_DELIMITERS).length];
        for (int i = 0; i < files.length; i++) {
            files[i] = new File(fileNames[i]);
        }

        init();
    }

    private void processFile(final File f) {
        if (f.getName().endsWith(".jar") || f.getName().endsWith(".zip")) {
            try {
                compositeResourceFinder.push(new JarFileScanner(new FileInputStream(f), "", true));
            } catch (final IOException e) {
                
                throw new ResourceFinderException(e);
            }

        } else {
            compositeResourceFinder.push(new AbstractResourceFinderAdapter() {

                Stack<File> files = new Stack<File>() {{
                    if (f.isDirectory()) {
                        final File[] subDirFiles = f.listFiles();
                        if (subDirFiles != null) {
                            for (final File file : subDirFiles) {
                                push(file);
                            }
                        }
                    } else {
                        push(f);
                    }
                }};

                private File current;
                private File next;

                @Override
                public boolean hasNext() {
                    while (next == null && !files.empty()) {
                        next = files.pop();

                        if (next.isDirectory()) {
                            if (recursive) {
                                processFile(next);
                            }
                            next = null;
                        } else if (next.getName().endsWith(".jar") || next.getName().endsWith(".zip")) {
                            processFile(next);
                            next = null;
                        }
                    }

                    return next != null;
                }

                @Override
                public String next() {
                    if (next != null || hasNext()) {
                        current = next;
                        next = null;
                        return current.getName();
                    }
                    throw new NoSuchElementException();
                }

                @Override
                public InputStream open() {
                    try {
                        return new FileInputStream(current);
                    } catch (final FileNotFoundException e) {
                        throw new ResourceFinderException(e);
                    }
                }

                @Override
                public void reset() {
                    throw new UnsupportedOperationException();
                }
            });
        }
    }

    @Override
    public boolean hasNext() {
        return compositeResourceFinder.hasNext();
    }

    @Override
    public String next() {
        return compositeResourceFinder.next();
    }

    @Override
    public InputStream open() {
        return compositeResourceFinder.open();
    }

    @Override
    public void close() {
        compositeResourceFinder.close();
    }

    @Override
    public void reset() {
        close();
        init();
    }

    private void init() {
        this.compositeResourceFinder = new CompositeResourceFinder();

        for (final File file : files) {
            processFile(file);
        }
    }
}

<code block>

package org.glassfish.jersey.server.internal.scanning;

import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.util.Collections;
import java.util.NoSuchElementException;
import java.util.Set;

import org.glassfish.jersey.server.internal.AbstractResourceFinderAdapter;


final class BundleSchemeResourceFinderFactory implements UriSchemeResourceFinderFactory {

    private static final Set<String> SCHEMES = Collections.singleton("bundle");

    @Override
    public Set<String> getSchemes() {
        return SCHEMES;
    }

    
    BundleSchemeResourceFinderFactory() {
    }

    @Override
    public BundleSchemeScanner create(final URI uri, final boolean recursive) {
        return new BundleSchemeScanner(uri);
    }

    private class BundleSchemeScanner extends AbstractResourceFinderAdapter {

        private BundleSchemeScanner(final URI uri) {
            this.uri = uri;
        }

        private final URI uri;

        
        private boolean accessed = false;

        
        private boolean iterated = false;

        @Override
        public boolean hasNext() {
            return !accessed && !iterated;
        }

        @Override
        public String next() {
            if (hasNext()) {
                iterated = true;
                return uri.getPath();
            }

            throw new NoSuchElementException();
        }

        @Override
        public InputStream open() {
            if (!accessed) {
                try {
                    accessed = true;
                    return uri.toURL().openStream();
                } catch (final IOException e) {
                    throw new ResourceFinderException(e);
                }
            }

            return null;
        }

        @Override
        public void reset() {
            throw new UnsupportedOperationException();
        }
    }

}

<code block>

package org.glassfish.jersey.server.internal.scanning;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.net.URI;
import java.util.Collections;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.Stack;

import org.glassfish.jersey.server.internal.AbstractResourceFinderAdapter;


final class FileSchemeResourceFinderFactory implements UriSchemeResourceFinderFactory {

    private static final Set<String> SCHEMES = Collections.singleton("file");

    @Override
    public Set<String> getSchemes() {
        return SCHEMES;
    }

    
    FileSchemeResourceFinderFactory() {
    }

    @Override
    public FileSchemeScanner create(final URI uri, final boolean recursive) {
        return new FileSchemeScanner(uri, recursive);
    }

    private class FileSchemeScanner extends AbstractResourceFinderAdapter {

        private final CompositeResourceFinder compositeResourceFinder;
        private final boolean recursive;

        private FileSchemeScanner(final URI uri, final boolean recursive) {
            this.compositeResourceFinder = new CompositeResourceFinder();
            this.recursive = recursive;

            processFile(new File(uri.getPath()));
        }

        @Override
        public boolean hasNext() {
            return compositeResourceFinder.hasNext();
        }

        @Override
        public String next() {
            return compositeResourceFinder.next();
        }

        @Override
        public InputStream open() {
            return compositeResourceFinder.open();
        }

        @Override
        public void close() {
            compositeResourceFinder.close();
        }

        @Override
        public void reset() {
            throw new UnsupportedOperationException();
        }

        private void processFile(final File f) {
            compositeResourceFinder.push(new AbstractResourceFinderAdapter() {

                Stack<File> files = new Stack<File>() {{
                    if (f.isDirectory()) {
                        final File[] subDirFiles = f.listFiles();
                        if (subDirFiles != null) {
                            for (final File file : subDirFiles) {
                                push(file);
                            }
                        }
                    } else {
                        push(f);
                    }
                }};

                private File current;
                private File next;

                @Override
                public boolean hasNext() {
                    while (next == null && !files.empty()) {
                        next = files.pop();

                        if (next.isDirectory()) {
                            if (recursive) {
                                processFile(next);
                            }
                            next = null;
                        }
                    }

                    return next != null;
                }

                @Override
                public String next() {
                    if (next != null || hasNext()) {
                        current = next;
                        next = null;
                        return current.getName();
                    }

                    throw new NoSuchElementException();
                }

                @Override
                public InputStream open() {
                    try {
                        return new FileInputStream(current);
                    } catch (final FileNotFoundException e) {
                        throw new ResourceFinderException(e);
                    }
                }

                @Override
                public void reset() {
                    throw new UnsupportedOperationException();
                }
            });
        }
    }
}

<code block>

package org.glassfish.jersey.server.internal.scanning;

import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.ReflectPermission;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.security.AccessController;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;

import org.glassfish.jersey.internal.OsgiRegistry;
import org.glassfish.jersey.internal.util.ReflectionHelper;
import org.glassfish.jersey.internal.util.Tokenizer;
import org.glassfish.jersey.server.internal.AbstractResourceFinderAdapter;
import org.glassfish.jersey.uri.UriComponent;


public final class PackageNamesScanner extends AbstractResourceFinderAdapter {

    private final boolean recursive;
    private final String[] packages;
    private final ClassLoader classloader;
    private final Map<String, UriSchemeResourceFinderFactory> finderFactories;

    private CompositeResourceFinder compositeResourceFinder;

    
    public PackageNamesScanner(final String[] packages, final boolean recursive) {
        this(AccessController.doPrivileged(ReflectionHelper.getContextClassLoaderPA()),
                Tokenizer.tokenize(packages, Tokenizer.COMMON_DELIMITERS), recursive);
    }

    
    public PackageNamesScanner(final ClassLoader classLoader, final String[] packages, final boolean recursive) {
        this.recursive = recursive;
        this.packages = packages.clone();
        this.classloader = classLoader;

        this.finderFactories = new HashMap<>();
        add(new JarZipSchemeResourceFinderFactory());
        add(new FileSchemeResourceFinderFactory());
        add(new VfsSchemeResourceFinderFactory());
        add(new BundleSchemeResourceFinderFactory());

        
        
        
        

        final OsgiRegistry osgiRegistry = ReflectionHelper.getOsgiRegistryInstance();
        if (osgiRegistry != null) {
            setResourcesProvider(new PackageNamesScanner.ResourcesProvider() {

                @Override
                public Enumeration<URL> getResources(final String packagePath, final ClassLoader classLoader) throws IOException {
                    return osgiRegistry.getPackageResources(packagePath, classLoader, recursive);
                }
            });
        }

        init();
    }

    private void add(final UriSchemeResourceFinderFactory uriSchemeResourceFinderFactory) {
        for (final String scheme : uriSchemeResourceFinderFactory.getSchemes()) {
            finderFactories.put(scheme.toLowerCase(), uriSchemeResourceFinderFactory);
        }
    }

    @Override
    public boolean hasNext() {
        return compositeResourceFinder.hasNext();
    }

    @Override
    public String next() {
        return compositeResourceFinder.next();
    }

    @Override
    public InputStream open() {
        return compositeResourceFinder.open();
    }

    @Override
    public void close() {
        compositeResourceFinder.close();
    }

    @Override
    public void reset() {
        close();
        init();
    }

    private void init() {
        compositeResourceFinder = new CompositeResourceFinder();

        for (final String p : packages) {
            try {
                final Enumeration<URL> urls =
                        ResourcesProvider.getInstance().getResources(p.replace('.', '/'), classloader);
                while (urls.hasMoreElements()) {
                    try {
                        addResourceFinder(toURI(urls.nextElement()));
                    } catch (final URISyntaxException e) {
                        throw new ResourceFinderException("Error when converting a URL to a URI", e);
                    }
                }
            } catch (final IOException e) {
                throw new ResourceFinderException("IO error when package scanning jar", e);
            }
        }

    }

    
    public abstract static class ResourcesProvider {

        private static volatile ResourcesProvider provider;

        private static ResourcesProvider getInstance() {
            
            ResourcesProvider result = provider;

            if (result == null) { 
                synchronized (ResourcesProvider.class) {
                    result = provider;
                    if (result == null) { 
                        provider = result = new ResourcesProvider() {

                            @Override
                            public Enumeration<URL> getResources(final String name, final ClassLoader cl)
                                    throws IOException {
                                return cl.getResources(name);
                            }
                        };

                    }
                }

            }
            return result;
        }

        private static void setInstance(final ResourcesProvider provider) throws SecurityException {
            final SecurityManager security = System.getSecurityManager();
            if (security != null) {
                final ReflectPermission rp = new ReflectPermission("suppressAccessChecks");
                security.checkPermission(rp);
            }
            synchronized (ResourcesProvider.class) {
                ResourcesProvider.provider = provider;
            }
        }

        
        public abstract Enumeration<URL> getResources(String name, ClassLoader cl) throws IOException;
    }

    
    public static void setResourcesProvider(final ResourcesProvider provider) throws SecurityException {
        ResourcesProvider.setInstance(provider);
    }

    private void addResourceFinder(final URI u) {
        final UriSchemeResourceFinderFactory finderFactory = finderFactories.get(u.getScheme().toLowerCase());
        if (finderFactory != null) {
            compositeResourceFinder.push(finderFactory.create(u, recursive));
        } else {
            throw new ResourceFinderException("The URI scheme " + u.getScheme()
                    + " of the URI " + u
                    + " is not supported. Package scanning deployment is not"
                    + " supported for such URIs."
                    + "\nTry using a different deployment mechanism such as"
                    + " explicitly declaring root resource and provider classes"
                    + " using an extension of javax.ws.rs.core.Application");
        }
    }

    private URI toURI(final URL url) throws URISyntaxException {
        try {
            return url.toURI();
        } catch (final URISyntaxException e) {
            
            
            
            return URI.create(toExternalForm(url));
        }
    }

    private String toExternalForm(final URL u) {

        
        int len = u.getProtocol().length() + 1;
        if (u.getAuthority() != null && u.getAuthority().length() > 0) {
            len += 2 + u.getAuthority().length();
        }
        if (u.getPath() != null) {
            len += u.getPath().length();
        }
        if (u.getQuery() != null) {
            len += 1 + u.getQuery().length();
        }
        if (u.getRef() != null) {
            len += 1 + u.getRef().length();
        }

        final StringBuilder result = new StringBuilder(len);
        result.append(u.getProtocol());
        result.append(":");
        if (u.getAuthority() != null && u.getAuthority().length() > 0) {
            result.append("
            result.append(u.getAuthority());
        }
        if (u.getPath() != null) {
            result.append(UriComponent.contextualEncode(u.getPath(), UriComponent.Type.PATH));
        }
        if (u.getQuery() != null) {
            result.append('?');
            result.append(UriComponent.contextualEncode(u.getQuery(), UriComponent.Type.QUERY));
        }
        if (u.getRef() != null) {
            result.append("#");
            result.append(u.getRef());
        }
        return result.toString();
    }
}

<code block>

package org.glassfish.jersey.server;

import java.io.File;
import java.io.IOException;
import java.util.Set;
import java.util.concurrent.ExecutionException;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Application;
import javax.ws.rs.core.Context;

import org.glassfish.jersey.internal.util.Tokenizer;
import org.glassfish.jersey.model.internal.ComponentBag;
import org.glassfish.jersey.server.config.innerstatic.InnerStaticClass;
import org.glassfish.jersey.server.config.toplevel.PublicRootResourceClass;
import org.glassfish.jersey.server.config.toplevelinnerstatic.PublicRootResourceInnerStaticClass;
import org.glassfish.jersey.server.internal.scanning.PackageNamesScanner;

import org.glassfish.hk2.utilities.binding.AbstractBinder;

import org.junit.Test;
import static org.glassfish.jersey.server.JarUtils.createJarFile;
import static org.hamcrest.CoreMatchers.hasItem;
import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;

import mockit.Mocked;
import mockit.Verifications;


public class ResourceConfigTest {

    @Test
    public void testGetElementsDefault1() {
        final String[] elements = Tokenizer.tokenize(new String[] {"a b,c;d\ne"});

        assertEquals(elements[0], "a");
        assertEquals(elements[1], "b");
        assertEquals(elements[2], "c");
        assertEquals(elements[3], "d");
        assertEquals(elements[4], "e");
    }

    @Test
    public void testGetElementsDefault2() {
        final String[] elements = Tokenizer.tokenize(new String[] {"a    b, ,c;d\n\n\ne"});

        assertEquals(elements[0], "a");
        assertEquals(elements[1], "b");
        assertEquals(elements[2], "c");
        assertEquals(elements[3], "d");
        assertEquals(elements[4], "e");
    }

    @Test
    public void testGetElementsExplicitDelimiter() {
        final String[] elements = Tokenizer.tokenize(new String[] {"a b,c;d\ne"}, " ;");

        assertEquals(elements[0], "a");
        assertEquals(elements[1], "b,c");
        assertEquals(elements[2], "d\ne");
    }

    @Test
    public void testResourceConfigClasses() {
        final ResourceConfig resourceConfig = new MyResourceConfig2();
        final ApplicationHandler ah = new ApplicationHandler(resourceConfig);

        assertTrue(ah.getConfiguration().getClasses().contains(MyResource.class));
    }

    @Test
    public void testResourceConfigInjection() throws InterruptedException, ExecutionException {
        final int rcId = 12345;
        final ResourceConfig resourceConfig = new MyResourceConfig2(rcId);
        final ApplicationHandler handler = new ApplicationHandler(resourceConfig);

        assertSame(resourceConfig, handler.getServiceLocator().getService(Application.class));

        final ContainerResponse r = handler.apply(RequestContextBuilder.from("/", "/resource?id=" + rcId, "GET").build()).get();
        assertEquals(200, r.getStatus());
        assertEquals("Injected application instance not same as used for building the Jersey handler.",
                "true", r.getEntity());
    }

    @Test
    public void testResourceConfigMergeApplications() throws Exception {
        
        final MyOtherBinder defaultBinder = new MyOtherBinder();
        final ResourceConfig rc = ResourceConfig.forApplicationClass(MyResourceConfig1.class);
        rc.register(defaultBinder);
        final ApplicationHandler handler = new ApplicationHandler(rc);
        assertTrue(handler.getConfiguration().getComponentBag().getInstances(ComponentBag.BINDERS_ONLY).contains(defaultBinder));
    }

    @Test
    public void testApplicationName() {
        final ResourceConfig resourceConfig = new ResourceConfig(MyResource.class);
        resourceConfig.setApplicationName("app");
        assertEquals("app", resourceConfig.getApplicationName());
        resourceConfig.lock();
        assertEquals("app", resourceConfig.getApplicationName());
    }

    @Test
    public void testApplicationNameDefinedByProperty() {
        final ResourceConfig resourceConfig = new ResourceConfig(MyResource.class);
        resourceConfig.property(ServerProperties.APPLICATION_NAME, "app");
        assertNull(resourceConfig.getApplicationName());
        resourceConfig.lock();
        assertEquals("app", resourceConfig.getApplicationName());
    }

    public static class MyResourceConfig1 extends ResourceConfig {

        public MyResourceConfig1() {
            property(ServerProperties.WADL_FEATURE_DISABLE, true);
            register(new MyBinder());
        }
    }

    public static class MyResourceConfig2 extends ResourceConfig {

        private final int id;

        public MyResourceConfig2() {
            this(0);
        }

        public MyResourceConfig2(final int id) {
            property(ServerProperties.WADL_FEATURE_DISABLE, true);
            this.id = id;
            registerClasses(MyResource.class);
        }
    }

    @Path("resource")
    public static class MyResource {

        @Context
        Application app;

        @GET
        public String test(@QueryParam("id") final int rcId) {
            return Boolean.toString((app instanceof MyResourceConfig2) && ((MyResourceConfig2) app).id == rcId);
        }
    }

    public static class MyBinder extends AbstractBinder {

        @Override
        protected void configure() {
            
        }
    }

    public static class MyOtherBinder extends AbstractBinder {

        @Override
        protected void configure() {
            
        }
    }

    @Test
    public void testClassPathPropertyTopLevel() {
        final ResourceConfig rc = new ResourceConfig()
                .property(ServerProperties.PROVIDER_CLASSPATH, PublicRootResourceClass.class.getResource("").getPath());

        final Set<Class<?>> classes = rc.getClasses();
        assertThat(classes, hasItem(PublicRootResourceClass.class));
        assertThat(classes.size(), is(1));
    }

    @Test
    public void testClassPathPropertyInnerStatic() {
        final ResourceConfig rc = new ResourceConfig()
                .property(ServerProperties.PROVIDER_CLASSPATH, InnerStaticClass.class.getResource("").getPath());

        final Set<Class<?>> classes = rc.getClasses();
        assertThat(classes, hasItem(InnerStaticClass.PublicClass.class));
        assertThat(classes.size(), is(1));
    }

    @Test
    public void testClassPathPropertyTopLevelInnerStatic() {
        final ResourceConfig rc = new ResourceConfig()
                .property(ServerProperties.PROVIDER_CLASSPATH,
                        PublicRootResourceInnerStaticClass.class.getResource("").getPath());

        final Set<Class<?>> classes = rc.getClasses();
        assertThat(classes, hasItem(PublicRootResourceInnerStaticClass.class));
        assertThat(classes, hasItem(PublicRootResourceInnerStaticClass.PublicClass.class));
        assertThat(classes.size(), is(2));
    }

    @Test
    public void testClassPathPropertyAll() {
        final ResourceConfig rc = new ResourceConfig()
                .property(ServerProperties.PROVIDER_CLASSPATH, ResourceConfigTest.class.getResource("").getPath() + "/config");

        final Set<Class<?>> classes = rc.getClasses();
        assertThat(classes, hasItem(PublicRootResourceClass.class));
        assertThat(classes, hasItem(InnerStaticClass.PublicClass.class));
        assertThat(classes, hasItem(PublicRootResourceInnerStaticClass.class));
        assertThat(classes, hasItem(PublicRootResourceInnerStaticClass.PublicClass.class));
        assertThat(classes.size(), is(4));
    }

    @Test
    public void testClassPathPropertyAllMultiplePaths() {
        final String paths = PublicRootResourceClass.class.getResource("").getPath() + ";"
                + InnerStaticClass.class.getResource("").getPath() + ";"
                + PublicRootResourceInnerStaticClass.class.getResource("").getPath();
        final ResourceConfig rc = new ResourceConfig()
                .property(ServerProperties.PROVIDER_CLASSPATH, paths);

        final Set<Class<?>> classes = rc.getClasses();
        assertThat(classes, hasItem(PublicRootResourceClass.class));
        assertThat(classes, hasItem(InnerStaticClass.PublicClass.class));
        assertThat(classes, hasItem(PublicRootResourceInnerStaticClass.class));
        assertThat(classes, hasItem(PublicRootResourceInnerStaticClass.PublicClass.class));
        assertThat(classes.size(), is(4));
    }

    @Test
    public void testClassPathPropertyAllMultiplePathsWithSpaces() {
        final String paths = PublicRootResourceClass.class.getResource("").getPath() + "; "
                + InnerStaticClass.class.getResource("").getPath() + ";;"
                + PublicRootResourceInnerStaticClass.class.getResource("").getPath() + "; ;; ";
        final ResourceConfig rc = new ResourceConfig()
                .property(ServerProperties.PROVIDER_CLASSPATH, paths);

        final Set<Class<?>> classes = rc.getClasses();
        assertThat(classes, hasItem(PublicRootResourceClass.class));
        assertThat(classes, hasItem(InnerStaticClass.PublicClass.class));
        assertThat(classes, hasItem(PublicRootResourceInnerStaticClass.class));
        assertThat(classes, hasItem(PublicRootResourceInnerStaticClass.PublicClass.class));
        assertThat(classes.size(), is(4));
    }

    @Test
    public void testClassPathPropertyJarTopLevel() throws Exception {
        final ResourceConfig rc = createConfigWithClassPathProperty(
                createJarFile(ResourceConfigTest.class.getResource("").getPath(),
                        "config/toplevel/PublicRootResourceClass.class",
                        "config/toplevel/PackageRootResourceClass.class")
        );

        final Set<Class<?>> classes = rc.getClasses();
        assertThat(classes, hasItem(PublicRootResourceClass.class));
        assertThat(classes.size(), is(1));
    }

    @Test
    public void testClassPathPropertyJarInnerStatic() throws Exception {
        final ResourceConfig rc = createConfigWithClassPathProperty(
                createJarFile(ResourceConfigTest.class.getResource("").getPath(),
                        "config/innerstatic/InnerStaticClass.class",
                        "config/innerstatic/InnerStaticClass$PublicClass.class",
                        "config/innerstatic/InnerStaticClass$PackageClass.class",
                        "config/innerstatic/InnerStaticClass$ProtectedClass.class",
                        "config/innerstatic/InnerStaticClass$PrivateClass.class")
        );

        final Set<Class<?>> classes = rc.getClasses();
        assertThat(classes, hasItem(InnerStaticClass.PublicClass.class));
        assertThat(classes.size(), is(1));
    }

    @Test
    public void testClassPathPropertyJarAll() throws Exception {
        final ResourceConfig rc = createConfigWithClassPathProperty(
                createJarFile(ResourceConfigTest.class.getResource("").getPath(),
                        "config/toplevel/PublicRootResourceClass.class",
                        "config/toplevel/PackageRootResourceClass.class",
                        "config/innerstatic/InnerStaticClass.class",
                        "config/innerstatic/InnerStaticClass$PublicClass.class",
                        "config/innerstatic/InnerStaticClass$PackageClass.class",
                        "config/innerstatic/InnerStaticClass$ProtectedClass.class",
                        "config/innerstatic/InnerStaticClass$PrivateClass.class")
        );

        final Set<Class<?>> classes = rc.getClasses();
        assertThat(classes, hasItem(PublicRootResourceClass.class));
        assertThat(classes, hasItem(InnerStaticClass.PublicClass.class));
        assertThat(classes.size(), is(2));
    }

    @Test
    public void testClassPathPropertyZipAll() throws Exception {
        final ResourceConfig rc = createConfigWithClassPathProperty(
                createJarFile(JarUtils.Suffix.zip, ResourceConfigTest.class.getResource("").getPath(),
                        "config/toplevel/PublicRootResourceClass.class", "config/toplevel/PackageRootResourceClass.class",
                        "config/innerstatic/InnerStaticClass.class", "config/innerstatic/InnerStaticClass$PublicClass.class",
                        "config/innerstatic/InnerStaticClass$PackageClass.class",
                        "config/innerstatic/InnerStaticClass$ProtectedClass.class",
                        "config/innerstatic/InnerStaticClass$PrivateClass.class")
        );

        final Set<Class<?>> classes = rc.getClasses();
        assertThat(classes, hasItem(PublicRootResourceClass.class));
        assertThat(classes, hasItem(InnerStaticClass.PublicClass.class));
        assertThat(classes.size(), is(2));
    }

    
    @Test
    public void testGetClasses() throws Exception {
        final ResourceConfig rc = new ResourceConfig()
                .packages(false, PublicRootResourceClass.class.getPackage().getName());

        Set<Class<?>> classes = rc.getClasses();
        assertThat(classes.size(), is(1));
        assertThat(classes, hasItem(PublicRootResourceClass.class));

        rc.register(InnerStaticClass.PublicClass.class);

        classes = rc.getClasses();
        assertThat(classes.size(), is(2));
        assertThat(classes, hasItem(PublicRootResourceClass.class));
        assertThat(classes, hasItem(InnerStaticClass.PublicClass.class));
    }

    
    @Test
    public void testInvalidateResourceFinders(@Mocked final PackageNamesScanner scanner) throws Exception {
        final ResourceConfig resourceConfig = new ResourceConfig()
                .packages(false, PublicRootResourceClass.class.getPackage().getName());

        
        resourceConfig.getClasses();

        
        new Verifications() {{
            scanner.reset();
            times = 0;
        }};

        resourceConfig.register(InnerStaticClass.PublicClass.class);

        
        new Verifications() {{
            scanner.reset();
            times = 1;
        }};

        
        resourceConfig.register(PublicRootResourceClass.class);
        resourceConfig.register(PublicRootResourceInnerStaticClass.PublicClass.class);

        
        new Verifications() {{
            scanner.reset();
            times = 1;
        }};

        
        resourceConfig.getClasses();

        resourceConfig.registerFinder(new PackageNamesScanner(new String[] {"javax.ws.rs"}, false));

        
        new Verifications() {{
            scanner.reset();
            times = 2;
        }};
    }

    @Test
    public void testResourceFinderStreamsClosed() throws IOException {
        System.out.println(new ResourceConfig().packages("javax.ws.rs").getClasses());
    }

    private ResourceConfig createConfigWithClassPathProperty(final File jarFile) {
        return new ResourceConfig().property(ServerProperties.PROVIDER_CLASSPATH, jarFile.getAbsolutePath());
    }
}

<code block>

package org.glassfish.jersey.server.internal.scanning;

import java.io.IOException;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLStreamHandler;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.Vector;
import java.util.jar.JarInputStream;

import org.junit.Before;
import org.junit.Test;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import mockit.Expectations;
import mockit.Mocked;
import mockit.Verifications;


public class PackageNamesScannerTest {

    private static final String[] packages = {"javax.ws.rs"};

    private String jaxRsApiPath;

    @Before
    public void setUp() throws Exception {
        final String classPath = System.getProperty("java.class.path");
        final String[] entries = classPath.split(System.getProperty("path.separator"));

        for (final String entry : entries) {
            if (entry.contains("javax.ws.rs-api")) {
                jaxRsApiPath = entry;
                break;
            }
        }

        if (jaxRsApiPath == null) {
            fail("Could not find javax.ws.rs-api.");
        }
    }

    @Test
    public void testWsJarScheme() {
        assertTrue("Expected at least one class to be found.",
                new PackageNamesScanner(createTestClassLoader("wsjar", createTestURLStreamHandler("wsjar"), jaxRsApiPath),
                        packages, false).hasNext());
    }

    @Test
    public void testJarScheme() {
        
        assertTrue("Expected at least one class to be found.", new PackageNamesScanner(packages, false).hasNext());
    }

    @Test
    public void testZipScheme() {
        assertTrue("Expected at least one class to be found.",
                new PackageNamesScanner(createTestClassLoader("zip", createTestURLStreamHandler("zip"), jaxRsApiPath),
                        packages, false).hasNext());
    }

    @Test(expected = ResourceFinderException.class)
    public void testInvalidScheme() {
        new PackageNamesScanner(createTestClassLoader("bad", createTestURLStreamHandler("bad"), jaxRsApiPath), packages, false);
    }

    
    @Test
    public void testInputStreamClosedAfterReset(@Mocked final JarInputStream stream) throws Exception {
        final PackageNamesScanner scanner1 = new PackageNamesScanner(new String[] {"javax.ws.rs"}, false);
        final PackageNamesScanner scanner2 = new PackageNamesScanner(new String[] {"javax.ws.rs.core"}, false);
        final PackageNamesScanner scanner3 = new PackageNamesScanner(new String[] {"javax.ws.rs.client"}, false);

        scanner1.reset();

        scanner2.reset();
        scanner2.reset();

        scanner3.reset();

        new Verifications() {{
            stream.close();
            times = 4;
        }};
    }

    
    @Test
    public void testInputStreamClosedAfterClose(@Mocked final JarInputStream stream) throws Exception {
        final PackageNamesScanner scanner1 = new PackageNamesScanner(new String[] {"javax.ws.rs"}, false);
        final PackageNamesScanner scanner2 = new PackageNamesScanner(new String[] {"javax.ws.rs.core"}, false);
        final PackageNamesScanner scanner3 = new PackageNamesScanner(new String[] {"javax.ws.rs.client"}, false);

        scanner1.close();

        scanner2.close();
        scanner2.close();

        scanner3.close();

        new Verifications() {{
            stream.close();
            times = 3;
        }};
    }

    
    @Test
    public void testInputStreamClosedAfterIteration(@Mocked final JarInputStream stream) throws Exception {
        new Expectations() {{
            stream.getNextJarEntry();
            result = null;
            stream.close();
        }};

        final PackageNamesScanner scanner = new PackageNamesScanner(new String[] {"javax.ws.rs"}, false);

        while (scanner.hasNext()) {
            scanner.next();
        }
    }

    private ClassLoader createTestClassLoader(final String scheme,
                                              final URLStreamHandler urlStreamHandler,
                                              final String resourceFilePath) {
        return new ClassLoader() {
            public Enumeration<URL> getResources(final String name) throws IOException {
                final List<URL> list = new ArrayList<>();
                list.add((urlStreamHandler == null
                                  ? new URL(null, scheme + ":" + resourceFilePath + "!/" + name)
                                  : new URL(null, scheme + ":" + resourceFilePath + "!/" + name, urlStreamHandler)));
                return new Vector<>(list).elements();
            }
        };
    }

    
    private URLStreamHandler createTestURLStreamHandler(final String scheme) {
        return new URLStreamHandler() {
            @Override
            protected URLConnection openConnection(final URL u) throws IOException {
                throw new UnsupportedOperationException();
            }

            @Override
            protected void parseURL(final URL u, final String spec, final int start, final int limit) {
                setURL(u, scheme, "", -1, null, null, spec.substring(scheme.length() + 1), null, null);
            }
        };
    }
}

<code block>

package org.glassfish.jersey.server.internal.scanning;

import java.io.InputStream;
import java.util.NoSuchElementException;

import org.glassfish.jersey.server.ResourceFinder;
import org.glassfish.jersey.server.internal.AbstractResourceFinderAdapter;

import org.junit.Test;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;


public class CompositeResourceFinderTest {

    public static class MyIterator extends AbstractResourceFinderAdapter {

        boolean iterated = false;

        @Override
        public boolean hasNext() {
            return !iterated;
        }

        @Override
        public String next() {
            if (!iterated) {
                iterated = true;
                return "value";
            }

            throw new NoSuchElementException();
        }

        @Override
        public void reset() {
        }

        @Override
        public InputStream open() {
            return null;
        }
    }

    @Test
    public void test() {
        final ResourceFinder i = new MyIterator();
        final ResourceFinder j = new MyIterator();

        final CompositeResourceFinder iteratorStack = new CompositeResourceFinder();
        iteratorStack.push(i);
        iteratorStack.push(j);

        assertEquals(iteratorStack.next(), "value");
        assertEquals(iteratorStack.next(), "value");

        try {
            iteratorStack.next();
            assertTrue(false);
        } catch (final NoSuchElementException nsee) {
            assertTrue(true);
        }
    }
}

<code block>

package org.glassfish.jersey.servlet;

import java.io.IOException;
import java.io.InputStream;
import java.util.Deque;
import java.util.LinkedList;
import java.util.NoSuchElementException;
import java.util.Set;

import javax.servlet.ServletContext;

import org.glassfish.jersey.server.internal.AbstractResourceFinderAdapter;
import org.glassfish.jersey.server.internal.scanning.JarFileScanner;
import org.glassfish.jersey.server.internal.scanning.ResourceFinderException;
import org.glassfish.jersey.server.internal.scanning.ResourceFinderStack;


class WebAppResourcesScanner extends AbstractResourceFinderAdapter {


    private final ServletContext sc;
    private ResourceFinderStack resourceFinderStack = new ResourceFinderStack();
    private static String[] paths = new String[]{"/WEB-INF/lib/", "/WEB-INF/classes/"};

    
    WebAppResourcesScanner(final ServletContext sc) {
        this.sc = sc;

        processPaths(paths);
    }

    private void processPaths(String... paths) {
        for (final String path : paths) {

            final Set<String> resourcePaths = sc.getResourcePaths(path);
            if (resourcePaths == null) {
                break;
            }

            resourceFinderStack.push(new AbstractResourceFinderAdapter() {

                private Deque<String> resourcePathsStack = new LinkedList<String>() {

                    private static final long serialVersionUID = 3109256773218160485L;

                    {
                        for (String resourcePath : resourcePaths) {
                            push(resourcePath);
                        }
                    }
                };
                private String current;
                private String next;

                @Override
                public boolean hasNext() {
                    while (next == null && !resourcePathsStack.isEmpty()) {
                        next = resourcePathsStack.pop();

                        if (next.endsWith("/")) {
                            processPaths(next);
                            next = null;
                        } else if (next.endsWith(".jar")) {
                            try {
                                resourceFinderStack.push(new JarFileScanner(sc.getResourceAsStream(next), "", true));
                            } catch (IOException ioe) {
                                throw new ResourceFinderException(ioe);
                            }
                            next = null;
                        }
                    }

                    return next != null;
                }

                @Override
                public String next() {
                    if (next != null || hasNext()) {
                        current = next;
                        next = null;
                        return current;
                    }

                    throw new NoSuchElementException();
                }

                @Override
                public InputStream open() {
                    return sc.getResourceAsStream(current);
                }

                @Override
                public void reset() {
                    throw new UnsupportedOperationException();
                }
            });

        }
    }

    @Override
    public boolean hasNext() {
        return resourceFinderStack.hasNext();
    }

    @Override
    public String next() {
        return resourceFinderStack.next();
    }

    @Override
    public InputStream open() {
        return resourceFinderStack.open();
    }

    @Override
    public void reset() {
        resourceFinderStack = new ResourceFinderStack();
        processPaths(paths);
    }
}

<code block>


package org.glassfish.jersey.server;

import java.io.IOException;
import java.io.InputStream;
import java.security.AccessController;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.ws.rs.RuntimeType;
import javax.ws.rs.core.Application;
import javax.ws.rs.core.Configurable;
import javax.ws.rs.core.Configuration;
import javax.ws.rs.core.Feature;

import org.glassfish.jersey.internal.Errors;
import org.glassfish.jersey.internal.util.PropertiesHelper;
import org.glassfish.jersey.internal.util.ReflectionHelper;
import org.glassfish.jersey.internal.util.Tokenizer;
import org.glassfish.jersey.model.ContractProvider;
import org.glassfish.jersey.model.internal.CommonConfig;
import org.glassfish.jersey.model.internal.ComponentBag;
import org.glassfish.jersey.process.Inflector;
import org.glassfish.jersey.process.internal.RequestScoped;
import org.glassfish.jersey.server.internal.LocalizationMessages;
import org.glassfish.jersey.server.internal.scanning.AnnotationAcceptingListener;
import org.glassfish.jersey.server.internal.scanning.FilesScanner;
import org.glassfish.jersey.server.internal.scanning.PackageNamesScanner;
import org.glassfish.jersey.server.model.Resource;

import org.glassfish.hk2.api.ServiceLocator;
import org.glassfish.hk2.utilities.Binder;

import jersey.repackaged.com.google.common.base.Predicate;
import jersey.repackaged.com.google.common.collect.Sets;


public class ResourceConfig extends Application implements Configurable<ResourceConfig>, ServerConfig {

    private static final Logger LOGGER = Logger.getLogger(ResourceConfig.class.getName());

    private transient Set<Class<?>> cachedClasses = null;
    private transient Set<Class<?>> cachedClassesView = null;
    private transient Set<Object> cachedSingletons = null;
    private transient Set<Object> cachedSingletonsView = null;

    private volatile State state;

    private static class State extends CommonConfig implements ServerConfig {

        private final Set<ResourceFinder> resourceFinders;

        private final Set<Resource> resources;
        private final Set<Resource> resourcesView;
        private volatile String applicationName;

        private volatile ClassLoader classLoader = null;

        public State() {
            super(RuntimeType.SERVER, ComponentBag.INCLUDE_ALL);
            this.classLoader = AccessController.doPrivileged(ReflectionHelper.getContextClassLoaderPA());

            this.resourceFinders = Sets.newHashSet();

            this.resources = Sets.newHashSet();
            this.resourcesView = Collections.unmodifiableSet(this.resources);
        }

        public State(final State original) {
            super(original);
            this.classLoader = original.classLoader;
            this.applicationName = original.applicationName;

            this.resources = Sets.newHashSet(original.resources);
            this.resourcesView = Collections.unmodifiableSet(this.resources);

            this.resourceFinders = Sets.newHashSet(original.resourceFinders);
        }

        public void setClassLoader(final ClassLoader classLoader) {
            this.classLoader = classLoader;
        }

        public void setApplicationName(final String applicationName) {
            this.applicationName = applicationName;
        }

        public void registerResources(final Set<Resource> resources) {
            this.resources.addAll(resources);
        }

        public void registerFinder(final ResourceFinder resourceFinder) {
            this.resourceFinders.add(resourceFinder);
        }

        @Override
        protected Inflector<ContractProvider.Builder, ContractProvider> getModelEnhancer(final Class<?> componentClass) {
            return new Inflector<ContractProvider.Builder, ContractProvider>() {
                @Override
                public ContractProvider apply(final ContractProvider.Builder builder) {
                    if (builder.getScope() == null && builder.getContracts().isEmpty()
                            && Resource.getPath(componentClass) != null) {
                        builder.scope(RequestScoped.class);
                    }

                    return builder.build();
                }
            };

        }

        @Override
        public State loadFrom(final Configuration config) {
            super.loadFrom(config);
            this.resourceFinders.clear();
            this.resources.clear();

            State other = null;
            if (config instanceof ResourceConfig) {
                other = ((ResourceConfig) config).state;
            }
            if (config instanceof State) {
                other = (State) config;
            }

            if (other != null) {
                this.resourceFinders.addAll(other.resourceFinders);
                this.resources.addAll(other.resources);
            }

            return this;
        }

        @Override
        public final Set<Resource> getResources() {
            return resourcesView;
        }

        @Override
        public ServerConfig getConfiguration() {
            return this;
        }

        
        public Set<ResourceFinder> getResourceFinders() {
            return resourceFinders;
        }

        
        public ClassLoader getClassLoader() {
            return classLoader;
        }

        private String getApplicationName() {
            return applicationName;
        }
    }

    private static final class ImmutableState extends State {

        private ImmutableState(final State original) {
            super(original);
        }

        @Override
        public void setClassLoader(final ClassLoader classLoader) {
            throw new IllegalStateException(LocalizationMessages.RC_NOT_MODIFIABLE());
        }

        @Override
        public void registerResources(final Set<Resource> resources) {
            throw new IllegalStateException(LocalizationMessages.RC_NOT_MODIFIABLE());
        }

        @Override
        public void registerFinder(final ResourceFinder resourceFinder) {
            throw new IllegalStateException(LocalizationMessages.RC_NOT_MODIFIABLE());
        }

        @Override
        public State addProperties(final Map<String, ?> properties) {
            throw new IllegalStateException(LocalizationMessages.RC_NOT_MODIFIABLE());
        }

        @Override
        public State property(final String name, final Object value) {
            throw new IllegalStateException(LocalizationMessages.RC_NOT_MODIFIABLE());
        }

        @Override
        public State register(final Class<?> componentClass) {
            throw new IllegalStateException(LocalizationMessages.RC_NOT_MODIFIABLE());
        }

        @Override
        public State register(final Class<?> componentClass, final int bindingPriority) {
            throw new IllegalStateException(LocalizationMessages.RC_NOT_MODIFIABLE());
        }

        @Override
        public State register(final Class<?> componentClass, final Class<?>... contracts) {
            throw new IllegalStateException(LocalizationMessages.RC_NOT_MODIFIABLE());
        }

        @Override
        public State register(final Class<?> componentClass, final Map<Class<?>, Integer> contracts) {
            throw new IllegalStateException(LocalizationMessages.RC_NOT_MODIFIABLE());
        }

        @Override
        public State register(final Object component) {
            throw new IllegalStateException(LocalizationMessages.RC_NOT_MODIFIABLE());
        }

        @Override
        public State register(final Object component, final int bindingPriority) {
            throw new IllegalStateException(LocalizationMessages.RC_NOT_MODIFIABLE());
        }

        @Override
        public State register(final Object component, final Class<?>... contracts) {
            throw new IllegalStateException(LocalizationMessages.RC_NOT_MODIFIABLE());
        }

        @Override
        public State register(final Object component, final Map<Class<?>, Integer> contracts) {
            throw new IllegalStateException(LocalizationMessages.RC_NOT_MODIFIABLE());
        }

        @Override
        public State setProperties(final Map<String, ?> properties) {
            throw new IllegalStateException(LocalizationMessages.RC_NOT_MODIFIABLE());
        }

        @Override
        public void configureAutoDiscoverableProviders(final ServiceLocator locator, final boolean forcedOnly) {
            throw new IllegalStateException(LocalizationMessages.RC_NOT_MODIFIABLE());
        }

        @Override
        public void configureMetaProviders(final ServiceLocator locator) {
            throw new IllegalStateException(LocalizationMessages.RC_NOT_MODIFIABLE());
        }
    }

    
    public static ResourceConfig forApplication(final Application application) {
        return application instanceof ResourceConfig
                ? ((ResourceConfig) application)
                : new WrappingResourceConfig(application, null, null);
    }

    
    public static ResourceConfig forApplicationClass(final Class<? extends Application> applicationClass) {
        return new WrappingResourceConfig(null, applicationClass, null);
    }

    
    public static ResourceConfig forApplicationClass(final Class<? extends Application> applicationClass,
                                                     final Set<Class<?>> defaultClasses) {
        return new WrappingResourceConfig(null, applicationClass, defaultClasses);
    }

    
    public ResourceConfig() {
        this.state = new State();
    }

    
    public ResourceConfig(final Set<Class<?>> classes) {
        this();
        this.registerClasses(classes);
    }

    
    public ResourceConfig(final Class<?>... classes) {
        this(Sets.newHashSet(classes));
    }

    
    public ResourceConfig(final ResourceConfig original) {
        this.state = new State(original.state);
    }

    
    public final ResourceConfig addProperties(final Map<String, Object> properties) {
        state.addProperties(properties);
        return this;
    }

    
    public ResourceConfig setProperties(final Map<String, ?> properties) {
        state.setProperties(properties);
        return this;
    }

    @Override
    public ResourceConfig property(final String name, final Object value) {
        state.property(name, value);
        return this;
    }

    @Override
    public ResourceConfig register(final Class<?> componentClass) {
        invalidateCache();
        state.register(componentClass);
        return this;
    }

    @Override
    public ResourceConfig register(final Class<?> componentClass, final int bindingPriority) {
        invalidateCache();
        state.register(componentClass, bindingPriority);
        return this;
    }

    @Override
    public ResourceConfig register(final Class<?> componentClass, final Class<?>... contracts) {
        invalidateCache();
        state.register(componentClass, contracts);
        return this;
    }

    @Override
    public ResourceConfig register(final Class<?> componentClass, final Map<Class<?>, Integer> contracts) {
        invalidateCache();
        state.register(componentClass, contracts);
        return this;
    }

    @Override
    public ResourceConfig register(final Object component) {
        invalidateCache();
        state.register(component);
        return this;
    }

    @Override
    public ResourceConfig register(final Object component, final int bindingPriority) {
        invalidateCache();
        state.register(component, bindingPriority);
        return this;
    }

    @Override
    public ResourceConfig register(final Object component, final Class<?>... contracts) {
        invalidateCache();
        state.register(component, contracts);
        return this;
    }

    @Override
    public ResourceConfig register(final Object component, final Map<Class<?>, Integer> contracts) {
        invalidateCache();
        state.register(component, contracts);
        return this;
    }

    
    public final ResourceConfig registerClasses(final Set<Class<?>> classes) {
        if (classes == null) {
            return this;
        }

        for (final Class<?> cls : classes) {
            register(cls);
        }
        return this;
    }

    
    public final ResourceConfig registerClasses(final Class<?>... classes) {
        if (classes == null) {
            return this;
        }

        return registerClasses(Sets.newHashSet(classes));
    }

    
    public final ResourceConfig registerInstances(final Set<Object> instances) {
        if (instances == null) {
            return this;
        }

        for (final Object instance : instances) {
            register(instance);
        }
        return this;
    }

    
    public final ResourceConfig registerInstances(final Object... instances) {
        if (instances == null) {
            return this;
        }

        return registerInstances(Sets.newHashSet(instances));
    }

    
    public final ResourceConfig registerResources(final Resource... resources) {
        if (resources == null) {
            return this;
        }

        return registerResources(Sets.newHashSet(resources));
    }

    
    public final ResourceConfig registerResources(final Set<Resource> resources) {
        if (resources == null) {
            return this;
        }

        this.state.registerResources(resources);
        return this;
    }

    
    public final ResourceConfig registerFinder(final ResourceFinder resourceFinder) {
        if (resourceFinder == null) {
            return this;
        }

        this.state.registerFinder(resourceFinder);
        return this;
    }

    
    public final ResourceConfig setApplicationName(final String applicationName) {
        state.setApplicationName(applicationName);
        return this;
    }

    
    public final ResourceConfig setClassLoader(final ClassLoader classLoader) {
        this.state.setClassLoader(classLoader);
        return this;
    }

    
    public final ResourceConfig packages(final String... packages) {
        return packages(true, packages);
    }

    
    public final ResourceConfig packages(final boolean recursive, final String... packages) {
        if (packages == null || packages.length == 0) {
            return this;
        }
        return registerFinder(new PackageNamesScanner(packages, recursive));
    }

    
    public final ResourceConfig files(final String... files) {
        return files(true, files);
    }

    
    public final ResourceConfig files(final boolean recursive, final String... files) {
        if (files == null || files.length == 0) {
            return this;
        }
        return registerFinder(new FilesScanner(files, recursive));
    }

    
    final void invalidateCache() {
        this.cachedClasses = null;
        this.cachedClassesView = null;
        this.cachedSingletons = null;
        this.cachedSingletonsView = null;

        
        for (final ResourceFinder finder : this.state.resourceFinders) {
            finder.reset();
        }
    }

    
    final void lock() {
        final State current = state;
        if (!(current instanceof ImmutableState)) {
            setupApplicationName();
            state = new ImmutableState(current);
        }
    }

    @Override
    public final ServerConfig getConfiguration() {
        return this;
    }

    @Override
    public final Map<String, Object> getProperties() {
        return state.getProperties();
    }

    @Override
    public final Object getProperty(final String name) {
        return state.getProperty(name);
    }

    @Override
    public Collection<String> getPropertyNames() {
        return state.getPropertyNames();
    }

    @Override
    public final boolean isProperty(final String name) {
        return state.isProperty(name);
    }

    @Override
    public final Set<Class<?>> getClasses() {
        if (cachedClassesView == null) {
            cachedClasses = _getClasses();
            cachedClassesView = Collections.unmodifiableSet(cachedClasses);
        }
        return cachedClassesView;
    }

    @Override
    public final Set<Object> getInstances() {
        return getSingletons();
    }

    @Override
    public final Set<Object> getSingletons() {
        if (cachedSingletonsView == null) {
            cachedSingletons = _getSingletons();
            cachedSingletonsView = Collections.unmodifiableSet(cachedSingletons == null ? new HashSet<>() : cachedSingletons);
        }

        return cachedSingletonsView;
    }

    
    final ComponentBag getComponentBag() {
        return state.getComponentBag();
    }

    
    final void configureAutoDiscoverableProviders(final ServiceLocator locator) {
        state.configureAutoDiscoverableProviders(locator, false);
    }

    
    final void configureForcedAutoDiscoverableProviders(final ServiceLocator locator) {
        state.configureAutoDiscoverableProviders(locator, true);
    }

    
    final void configureMetaProviders(final ServiceLocator locator) {
        state.configureMetaProviders(locator);
    }

    @Override
    public RuntimeType getRuntimeType() {
        return state.getRuntimeType();
    }

    @Override
    public boolean isEnabled(final Feature feature) {
        return state.isEnabled(feature);
    }

    @Override
    public boolean isEnabled(final Class<? extends Feature> featureClass) {
        return state.isEnabled(featureClass);
    }

    @Override
    public boolean isRegistered(final Object component) {
        return state.isRegistered(component);
    }

    @Override
    public boolean isRegistered(final Class<?> componentClass) {
        return state.isRegistered(componentClass);
    }

    @Override
    public Map<Class<?>, Integer> getContracts(final Class<?> componentClass) {
        return state.getContracts(componentClass);
    }

    
    Set<Class<?>> _getClasses() {
        final Set<Class<?>> result = scanClasses();
        result.addAll(state.getClasses());
        return result;
    }

    private Set<Class<?>> scanClasses() {
        final Set<Class<?>> result = Sets.newHashSet();

        final ResourceConfig.State _state = state;
        final Set<ResourceFinder> rfs = Sets.newHashSet(_state.getResourceFinders());

        
        final String[] classNames = parsePropertyValue(ServerProperties.PROVIDER_CLASSNAMES);
        if (classNames != null) {
            for (final String className : classNames) {
                try {
                    result.add(_state.getClassLoader().loadClass(className));
                } catch (final ClassNotFoundException e) {
                    LOGGER.log(Level.CONFIG, LocalizationMessages.UNABLE_TO_LOAD_CLASS(className));
                }
            }
        }

        final String[] packageNames = parsePropertyValue(ServerProperties.PROVIDER_PACKAGES);
        if (packageNames != null) {
            final Object p = getProperty(ServerProperties.PROVIDER_SCANNING_RECURSIVE);
            final boolean recursive = p == null || PropertiesHelper.isProperty(p);
            rfs.add(new PackageNamesScanner(packageNames, recursive));
        }

        final String[] classPathElements = parsePropertyValue(ServerProperties.PROVIDER_CLASSPATH);
        if (classPathElements != null) {
            rfs.add(new FilesScanner(classPathElements, true));
        }

        final AnnotationAcceptingListener afl =
                AnnotationAcceptingListener.newJaxrsResourceAndProviderListener(_state.getClassLoader());
        for (final ResourceFinder resourceFinder : rfs) {
            while (resourceFinder.hasNext()) {
                final String next = resourceFinder.next();
                if (afl.accept(next)) {
                    final InputStream in = resourceFinder.open();
                    try {
                        afl.process(next, in);
                    } catch (final IOException e) {
                        LOGGER.log(Level.WARNING, LocalizationMessages.RESOURCE_CONFIG_UNABLE_TO_PROCESS(next));
                    } finally {
                        try {
                            in.close();
                        } catch (final IOException ex) {
                            LOGGER.log(Level.FINER, "Error closing resource stream.", ex);
                        }
                    }
                }
            }
        }

        result.addAll(afl.getAnnotatedClasses());
        return result;
    }

    private String[] parsePropertyValue(final String propertyName) {
        String[] classNames = null;
        final Object o = state.getProperties().get(propertyName);
        if (o != null) {
            if (o instanceof String) {
                classNames = Tokenizer.tokenize((String) o);
            } else if (o instanceof String[]) {
                classNames = Tokenizer.tokenize((String[]) o);
            }
        }
        return classNames;
    }

    
    Set<Class<?>> getRegisteredClasses() {
        return state.getComponentBag().getRegistrations();
    }

    
    Set<Object> _getSingletons() {
        final Set<Object> result = Sets.newHashSet();
        result.addAll(state.getInstances());
        return result;
    }

    @Override
    public final Set<Resource> getResources() {
        return state.getResources();
    }

    
    public final ClassLoader getClassLoader() {
        return state.getClassLoader();
    }

    
    public final Application getApplication() {
        return _getApplication();
    }

    
    Application _getApplication() {
        return this;
    }

    
    public String getApplicationName() {
        return state.getApplicationName();
    }

    
    Class<? extends Application> getApplicationClass() {
        return null;
    }

    
    final ResourceConfig setApplication(final Application app) {
        return _setApplication(app);
    }

    
    ResourceConfig _setApplication(final Application app) {
        throw new UnsupportedOperationException();
    }

    private static class WrappingResourceConfig extends ResourceConfig {

        private Application application;
        private Class<? extends Application> applicationClass;
        private final Set<Class<?>> defaultClasses = Sets.newHashSet();

        public WrappingResourceConfig(
                final Application application, final Class<? extends Application> applicationClass,
                final Set<Class<?>> defaultClasses) {

            if (application == null && applicationClass == null) {
                throw new IllegalArgumentException(LocalizationMessages.RESOURCE_CONFIG_ERROR_NULL_APPLICATIONCLASS());
            }
            this.application = application;
            this.applicationClass = applicationClass;
            if (defaultClasses != null) {
                this.defaultClasses.addAll(defaultClasses);
            }
            mergeApplications(application);
        }

        
        @Override
        ResourceConfig _setApplication(final Application application) {
            this.application = application;
            this.applicationClass = null;
            mergeApplications(application);
            return this;
        }

        
        @Override
        Application _getApplication() {
            return application;
        }

        
        @Override
        Class<? extends Application> getApplicationClass() {
            return applicationClass;
        }

        
        private void mergeApplications(final Application application) {
            if (application instanceof ResourceConfig) {
                
                final ResourceConfig rc = (ResourceConfig) application;

                
                super.registerResources(rc.getResources());

                
                
                rc.invalidateCache();
                rc.addProperties(super.getProperties());
                super.addProperties(rc.getProperties());
                super.setApplicationName(rc.getApplicationName());
                super.setClassLoader(rc.getClassLoader());

                rc.lock();
            } else if (application != null) {
                super.addProperties(application.getProperties());
            }
        }

        @Override
        Set<Class<?>> _getClasses() {
            final Set<Class<?>> result = Sets.newHashSet();
            final Set<Class<?>> applicationClasses = application.getClasses();
            result.addAll(applicationClasses == null ? new HashSet<Class<?>>() : applicationClasses);
            if (result.isEmpty() && getSingletons().isEmpty()) {
                result.addAll(defaultClasses);
            }

            
            if (!(application instanceof ResourceConfig)) {
                result.addAll(super._getClasses());
            }
            return result;
        }

        @Override
        Set<Object> _getSingletons() {
            return application.getSingletons();
        }
    }

    
    static ResourceConfig createRuntimeConfig(final Application application) {
        return (application instanceof ResourceConfig)
                ? new RuntimeConfig((ResourceConfig) application) : new RuntimeConfig(application);
    }

    private static class RuntimeConfig extends ResourceConfig {

        private final Set<Class<?>> originalRegistrations;
        private final Application application;

        private RuntimeConfig(final ResourceConfig original) {
            super(original);

            this.application = original;

            final Application customRootApp = ResourceConfig.unwrapCustomRootApplication(original);
            if (customRootApp != null) {
                registerComponentsOf(customRootApp);
            }

            originalRegistrations = Sets.newIdentityHashSet();
            originalRegistrations.addAll(super.getRegisteredClasses());

            
            final Set<Object> externalInstances = Sets.filter(original.getSingletons(), new Predicate<Object>() {
                @Override
                public boolean apply(final Object external) {
                    return !originalRegistrations.contains(external.getClass());
                }
            });
            registerInstances(externalInstances);

            
            final Set<Class<?>> externalClasses = Sets.filter(original.getClasses(), new Predicate<Class<?>>() {
                @Override
                public boolean apply(final Class<?> external) {
                    return !originalRegistrations.contains(external);
                }
            });
            registerClasses(externalClasses);
        }

        private void registerComponentsOf(final Application application) {
            Errors.processWithException(new Runnable() {
                @Override
                public void run() {
                    
                    
                    final Set<Object> singletons = application.getSingletons();
                    if (singletons != null) {
                        registerInstances(Sets.filter(singletons, new Predicate<Object>() {
                            @Override
                            public boolean apply(final Object input) {
                                if (input == null) {
                                    Errors.warning(application, LocalizationMessages.NON_INSTANTIABLE_COMPONENT(null));
                                }
                                return input != null;
                            }
                        }));
                    }

                    final Set<Class<?>> classes = application.getClasses();
                    if (classes != null) {
                        registerClasses(Sets.filter(classes, new Predicate<Class<?>>() {
                            @Override
                            public boolean apply(final Class<?> input) {
                                if (input == null) {
                                    Errors.warning(application, LocalizationMessages.NON_INSTANTIABLE_COMPONENT(null));
                                }
                                return input != null;
                            }
                        }));
                    }
                }
            });
        }

        private RuntimeConfig(final Application application) {
            super();

            this.application = application;

            if (application != null) {
                registerComponentsOf(application);

                
                addProperties(application.getProperties());
            }

            originalRegistrations = super.getRegisteredClasses();
        }

        @Override
        Set<Class<?>> _getClasses() {
            
            return super.state.getClasses();
        }

        @Override
        Set<Object> _getSingletons() {
            
            return super.state.getInstances();
        }

        @Override
        Set<Class<?>> getRegisteredClasses() {
            return originalRegistrations;
        }

        @Override
        Application _getApplication() {
            return application;
        }
    }

    private static Application unwrapCustomRootApplication(ResourceConfig resourceConfig) {
        Application app = null;
        while (resourceConfig != null) {
            app = resourceConfig.getApplication();
            if (app == resourceConfig) {
                
                return null;
            } else if (app instanceof ResourceConfig) {
                resourceConfig = (ResourceConfig) app;
            } else {
                break;
            }
        }
        return app;
    }

    
    static Application unwrapApplication(Application application) {
        while (application instanceof ResourceConfig) {
            final Application wrappedApplication = ((ResourceConfig) application).getApplication();
            if (wrappedApplication == application) {
                break;
            }
            application = wrappedApplication;
        }
        return application;
    }

    private void setupApplicationName() {
        final String appName = ServerProperties.getValue(getProperties(), ServerProperties.APPLICATION_NAME, null, String.class);
        if (appName != null && getApplicationName() == null) {
            setApplicationName(appName);
        }
    }
}

<code block>

package org.glassfish.jersey.server;

import java.io.InputStream;
import java.util.Iterator;


public interface ResourceFinder extends Iterator<String> {

    
    InputStream open();

    
    void reset();

    
    @Override
    void remove();
}

<code block>

package org.glassfish.jersey.server.internal;

import org.glassfish.jersey.server.ResourceFinder;


public abstract class AbstractResourceFinderAdapter implements ResourceFinder {

    
    @Override
    public void remove() {
        throw new UnsupportedOperationException();
    }
}

<code block>

package org.glassfish.jersey.server.internal.scanning;

import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Method;
import java.net.URI;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Set;

import org.glassfish.jersey.server.internal.AbstractResourceFinderAdapter;
import org.glassfish.jersey.server.ResourceFinder;


class VfsSchemeResourceFinderFactory implements UriSchemeResourceFinderFactory {

    public Set<String> getSchemes() {
        return new HashSet<String>(Arrays.asList("vfsfile", "vfszip", "vfs"));
    }

    VfsSchemeResourceFinderFactory() {
    }

    @Override
    public ResourceFinder create(final URI uri, boolean recursive) {
        return new VfsResourceFinder(uri, recursive);
    }

    private static class VfsResourceFinder extends AbstractResourceFinderAdapter {
        private Object current;
        private Object next;
        private final Method openStream;
        private final Method getName;
        private final Method isLeaf;
        private final Iterator<?> iterator;

        public VfsResourceFinder(URI uri, boolean recursive) {
            Object directory = bindDirectory(uri);
            this.openStream = bindMethod(directory, "openStream");
            this.getName = bindMethod(directory, "getName");
            this.isLeaf = bindMethod(directory, "isLeaf");
            this.iterator = getChildren(directory, recursive);
        }

        private Iterator<?> getChildren(Object directory, boolean recursive) {
            Method getChildren = bindMethod(directory, recursive ? "getChildrenRecursively" : "getChildren");

            List<?> list = invoke(directory, getChildren, List.class);
            if (list == null) {
                throw new ResourceFinderException("VFS object returned null when accessing children");
            }

            return list.iterator();
        }

        private Method bindMethod(final Object object, final String name) {
            if (System.getSecurityManager() != null) {
                AccessController.doPrivileged(new PrivilegedAction<Method>() {
                    public Method run() {
                        return bindMethod0(object, name);
                    }
                });
            }

            return bindMethod0(object, name);
        }

        private <T> T invoke(Object instance, Method method, Class<T> type) {
            try {
                return type.cast(method.invoke(instance));
            } catch (Exception e) {
                throw new ResourceFinderException("VFS object could not be invoked upon");
            }
        }

        private Method bindMethod0(Object object, String name) {
            Class<?> clazz = object.getClass();

            try {
                return clazz.getMethod(name);
            } catch (NoSuchMethodException e) {
                throw new ResourceFinderException("VFS object did not have a valid signature");
            }
        }

        private Object bindDirectory(URI uri) {
            Object directory = null;
            try {
                directory = uri.toURL().getContent();
            } catch (IOException e) {
                
            }

            if (directory == null || !directory.getClass().getSimpleName().equals("VirtualFile")) {
                throw new ResourceFinderException("VFS URL did not map to a valid VFS object");
            }

            return directory;
        }

        @Override
        public InputStream open() {
            Object current = this.current;
            if (current == null) {
                throw new IllegalStateException("next() must be called before open()");
            }

            return invoke(current, openStream, InputStream.class);
        }

        @Override
        public void reset() {
            throw new UnsupportedOperationException();
        }

        public boolean advance() {
            while (iterator.hasNext()) {
                Object next = iterator.next();
                if (invoke(next, isLeaf, Boolean.class)) {
                    this.next = next;
                    return true;
                }
            }

            return false;
        }

        @Override
        public boolean hasNext() {
            return next != null || advance();
        }

        @Override
        public String next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }

            current = next;
            next = null;
            return invoke(current, getName, String.class);
        }
    }
}

<code block>

package org.glassfish.jersey.server.internal.scanning;

import java.io.IOException;
import java.io.InputStream;
import java.util.NoSuchElementException;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.glassfish.jersey.server.internal.AbstractResourceFinderAdapter;


public final class JarFileScanner extends AbstractResourceFinderAdapter {

    private static final Logger LOGGER = Logger.getLogger(JarFileScanner.class.getName());
    
    private static final char JAR_FILE_SEPARATOR = '/';

    private final JarInputStream jarInputStream;
    private final String parent;
    private final boolean recursive;

    
    public JarFileScanner(final InputStream inputStream, final String parent, final boolean recursive) throws IOException {
        this.jarInputStream = new JarInputStream(inputStream);
        this.parent = (parent.isEmpty() || parent.endsWith(String.valueOf(JAR_FILE_SEPARATOR)))
                ? parent : parent + JAR_FILE_SEPARATOR;
        this.recursive = recursive;
    }

    private JarEntry next = null;

    @Override
    public boolean hasNext() {
        if (next == null) {
            try {
                do {
                    this.next = jarInputStream.getNextJarEntry();
                    if (next == null) {
                        break;
                    }
                    if (!next.isDirectory() && next.getName().startsWith(parent)) {
                        if (recursive || next.getName().substring(parent.length()).indexOf(JAR_FILE_SEPARATOR) == -1) {
                            break;
                        }
                    }
                } while (true);
            } catch (final IOException e) {
                LOGGER.log(Level.CONFIG, "Unable to read the next jar entry.", e);
                return false;
            } catch (final SecurityException e) {
                LOGGER.log(Level.CONFIG, "Unable to read the next jar entry.", e);
                return false;
            }
        }

        if (next == null) {
            try {
                jarInputStream.close();
            } catch (final IOException e) {
                LOGGER.log(Level.FINE, "Unable to close jar file.", e);
            }

            return false;
        }

        return true;
    }

    @Override
    public String next() {
        if (next != null || hasNext()) {
            final String name = next.getName();
            next = null;
            return name;
        }

        throw new NoSuchElementException();
    }

    @Override
    public void reset() {
        throw new UnsupportedOperationException();
    }

    @Override
    public InputStream open() {
        return new InputStream() {

            @Override
            public int read() throws IOException {
                return jarInputStream.read();
            }

            @Override
            public int read(final byte[] bytes) throws IOException {
                return jarInputStream.read(bytes);
            }

            @Override
            public int read(final byte[] bytes, final int i, final int i2) throws IOException {
                return jarInputStream.read(bytes, i, i2);
            }

            @Override
            public long skip(final long l) throws IOException {
                return jarInputStream.skip(l);
            }

            @Override
            public int available() throws IOException {
                return jarInputStream.available();
            }

            @Override
            public void close() throws IOException {
                jarInputStream.closeEntry();
            }

            @Override
            public synchronized void mark(final int i) {
                jarInputStream.mark(i);
            }

            @Override
            public synchronized void reset() throws IOException {
                jarInputStream.reset();
            }

            @Override
            public boolean markSupported() {
                return jarInputStream.markSupported();
            }
        };
    }
}


<code block>

package org.glassfish.jersey.server.internal.scanning;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URL;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.glassfish.jersey.server.internal.AbstractResourceFinderAdapter;
import org.glassfish.jersey.uri.UriComponent;


class JarZipSchemeResourceFinderFactory implements UriSchemeResourceFinderFactory {

    @Override
    public Set<String> getSchemes() {
        return new HashSet<String>(Arrays.asList("jar", "zip", "wsjar"));
    }

    
    JarZipSchemeResourceFinderFactory() {
    }

    @Override
    public JarZipSchemeScanner create(final URI uri, boolean recursive) {
        final String ssp = uri.getRawSchemeSpecificPart();
        final String jarUrlString = ssp.substring(0, ssp.lastIndexOf('!'));
        final String parent = ssp.substring(ssp.lastIndexOf('!') + 2);

        try {
            return new JarZipSchemeScanner(getInputStream(jarUrlString), parent, recursive);
        } catch (IOException e) {
            throw new ResourceFinderException(e);
        }
    }

    private class JarZipSchemeScanner extends AbstractResourceFinderAdapter {

        private InputStream inputStream;
        private JarFileScanner jarFileScanner;

        private JarZipSchemeScanner(InputStream inputStream, String parent, boolean recursive) throws IOException {
            this.inputStream = inputStream;
            this.jarFileScanner = new JarFileScanner(inputStream, parent, recursive);
        }

        @Override
        public boolean hasNext() {
            final boolean hasNext = jarFileScanner.hasNext();
            if (!hasNext) {
                try {
                    inputStream.close();
                } catch (IOException e) {
                    Logger.getLogger(JarZipSchemeScanner.class.getName()).log(Level.FINE, "Unable to close jar file.", e);
                }
                return false;
            }

            return true;
        }

        @Override
        public String next() {
            return jarFileScanner.next();
        }

        @Override
        public InputStream open() {
            return jarFileScanner.open();
        }

        @Override
        public void reset() {
            jarFileScanner.reset();
        }
    }

    
    private InputStream getInputStream(String jarUrlString) throws IOException {
        try {
            return new URL(jarUrlString).openStream();
        } catch (MalformedURLException e) {
            return new FileInputStream(
                    UriComponent.decode(jarUrlString, UriComponent.Type.PATH));
        }
    }
}

<code block>

package org.glassfish.jersey.server.internal.scanning;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.NoSuchElementException;
import java.util.Stack;

import org.glassfish.jersey.internal.util.Tokenizer;
import org.glassfish.jersey.server.internal.AbstractResourceFinderAdapter;


public class FilesScanner extends AbstractResourceFinderAdapter {

    private ResourceFinderStack resourceFinderStack = new ResourceFinderStack();

    private final File[] files;
    private final boolean recursive;

    
    public FilesScanner(final String[] fileNames, boolean recursive) {
        this.recursive = recursive;
        this.files = new File[Tokenizer.tokenize(fileNames, Tokenizer.COMMON_DELIMITERS).length];
        for (int i = 0; i < files.length; i++) {
            files[i] = new File(fileNames[i]);
        }

        for (final File f : files) {
            processFile(f);
        }
    }

    private void processFile(final File f) {
        if (f.getName().endsWith(".jar") || f.getName().endsWith(".zip")) {
            try {
                resourceFinderStack.push(new JarFileScanner(new FileInputStream(f), "", true));
            } catch (IOException e) {
                
                throw new ResourceFinderException(e);
            }

        } else {
            resourceFinderStack.push(new AbstractResourceFinderAdapter() {

                Stack<File> files = new Stack<File>() {{
                    if (f.isDirectory()) {
                        final File[] subDirFiles = f.listFiles();
                        if (subDirFiles != null) {
                            for (File file : subDirFiles) {
                                push(file);
                            }
                        }
                    } else {
                        push(f);
                    }
                }};

                private File current;
                private File next;

                @Override
                public boolean hasNext() {
                    while (next == null && !files.empty()) {
                        next = files.pop();

                        if (next.isDirectory()) {
                            if (recursive) {
                                processFile(next);
                            }
                            next = null;
                        } else if (next.getName().endsWith(".jar") || next.getName().endsWith(".zip")) {
                            processFile(next);
                            next = null;
                        }
                    }

                    return next != null;
                }

                @Override
                public String next() {
                    if (next != null || hasNext()) {
                        current = next;
                        next = null;
                        return current.getName();
                    }
                    throw new NoSuchElementException();
                }

                @Override
                public InputStream open() {
                    try {
                        return new FileInputStream(current);
                    } catch (FileNotFoundException e) {
                        throw new ResourceFinderException(e);
                    }
                }

                @Override
                public void reset() {
                }
            });
        }
    }

    @Override
    public boolean hasNext() {
        return resourceFinderStack.hasNext();
    }

    @Override
    public String next() {
        return resourceFinderStack.next();
    }

    @Override
    public InputStream open() {
        return resourceFinderStack.open();
    }

    @Override
    public void reset() {
        this.resourceFinderStack = new ResourceFinderStack();

        for (File f : files) {
            processFile(f);
        }
    }
}

<code block>

package org.glassfish.jersey.server.internal.scanning;

import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.util.Arrays;
import java.util.HashSet;
import java.util.NoSuchElementException;
import java.util.Set;

import org.glassfish.jersey.server.internal.AbstractResourceFinderAdapter;


class BundleSchemeResourceFinderFactory implements UriSchemeResourceFinderFactory {

    @Override
    public Set<String> getSchemes() {
        return new HashSet<>(Arrays.asList("bundle"));
    }

    
    BundleSchemeResourceFinderFactory() {
    }

    @Override
    public BundleSchemeScanner create(URI uri, boolean recursive) {
        return new BundleSchemeScanner(uri);
    }

    private class BundleSchemeScanner extends AbstractResourceFinderAdapter {

        private BundleSchemeScanner(URI uri) {
            this.uri = uri;
        }

        private URI uri;

        
        private boolean accessed = false;

        
        private boolean iterated = false;

        @Override
        public boolean hasNext() {
            return !accessed && !iterated;
        }

        @Override
        public String next() {
            if (hasNext()) {
                iterated = true;
                return uri.getPath();
            }

            throw new NoSuchElementException();
        }

        @Override
        public InputStream open() {
            if (!accessed) {
                try {
                    accessed = true;
                    return uri.toURL().openStream();
                } catch (IOException e) {
                    throw new ResourceFinderException(e);
                }
            }

            return null;
        }

        @Override
        public void reset() {
            throw new UnsupportedOperationException();
        }
    }

}

<code block>

package org.glassfish.jersey.server.internal.scanning;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.net.URI;
import java.util.Collections;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.Stack;

import org.glassfish.jersey.server.internal.AbstractResourceFinderAdapter;


class FileSchemeResourceFinderFactory implements UriSchemeResourceFinderFactory {

    @Override
    public Set<String> getSchemes() {
        return Collections.singleton("file");
    }

    
    FileSchemeResourceFinderFactory() {
    }

    @Override
    public FileSchemeScanner create(URI uri, boolean recursive) {
        return new FileSchemeScanner(uri, recursive);
    }

    private class FileSchemeScanner extends AbstractResourceFinderAdapter {

        private final ResourceFinderStack resourceFinderStack;
        private final boolean recursive;

        private FileSchemeScanner(final URI uri, boolean recursive) {
            this.resourceFinderStack = new ResourceFinderStack();
            this.recursive = recursive;

            processFile(new File(uri.getPath()));
        }

        @Override
        public boolean hasNext() {
            return resourceFinderStack.hasNext();
        }

        @Override
        public String next() {
            return resourceFinderStack.next();
        }

        @Override
        public InputStream open() {
            return resourceFinderStack.open();
        }

        @Override
        public void reset() {
            throw new UnsupportedOperationException();
        }

        private void processFile(final File f) {
            resourceFinderStack.push(new AbstractResourceFinderAdapter() {

                Stack<File> files = new Stack<File>() {{
                    if (f.isDirectory()) {
                        final File[] subDirFiles = f.listFiles();
                        if (subDirFiles != null) {
                            for (File file : subDirFiles) {
                                push(file);
                            }
                        }
                    } else {
                        push(f);
                    }
                }};

                private File current;
                private File next;

                @Override
                public boolean hasNext() {
                    while (next == null && !files.empty()) {
                        next = files.pop();

                        if (next.isDirectory()) {
                            if (recursive) {
                                processFile(next);
                            }
                            next = null;
                        }
                    }

                    return next != null;
                }

                @Override
                public String next() {
                    if (next != null || hasNext()) {
                        current = next;
                        next = null;
                        return current.getName();
                    }

                    throw new NoSuchElementException();
                }

                @Override
                public InputStream open() {
                    try {
                        return new FileInputStream(current);
                    } catch (FileNotFoundException e) {
                        throw new ResourceFinderException(e);
                    }
                }

                @Override
                public void reset() {
                    throw new UnsupportedOperationException();
                }
            });
        }
    }
}

<code block>

package org.glassfish.jersey.server.internal.scanning;

import java.io.InputStream;
import java.util.Deque;
import java.util.LinkedList;
import java.util.NoSuchElementException;
import java.util.Stack;

import org.glassfish.jersey.server.internal.AbstractResourceFinderAdapter;
import org.glassfish.jersey.server.ResourceFinder;


public class ResourceFinderStack extends AbstractResourceFinderAdapter {

    private final Deque<ResourceFinder> stack = new LinkedList<ResourceFinder>();
    private ResourceFinder current = null;

    @Override
    public boolean hasNext() {
        if (current == null) {
            if (!stack.isEmpty()) {
                current = stack.pop();
            } else {
                return false;
            }
        }

        if (current.hasNext()) {
            return true;
        } else {
            if (!stack.isEmpty()) {
                current = stack.pop();
                return hasNext();
            } else {
                return false;
            }
        }
    }

    @Override
    public String next() {
        if (hasNext()) {
            return current.next();
        }

        throw new NoSuchElementException();
    }

    @Override
    public InputStream open() {
        return current.open();
    }

    public void push(ResourceFinder iterator) {
        stack.push(iterator);
    }

    @Override
    public void reset() {
        throw new UnsupportedOperationException();
    }
}

<code block>

package org.glassfish.jersey.server.internal.scanning;

import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.ReflectPermission;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.security.AccessController;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;

import org.glassfish.jersey.internal.OsgiRegistry;
import org.glassfish.jersey.internal.util.ReflectionHelper;
import org.glassfish.jersey.internal.util.Tokenizer;
import org.glassfish.jersey.server.internal.AbstractResourceFinderAdapter;
import org.glassfish.jersey.uri.UriComponent;


public class PackageNamesScanner extends AbstractResourceFinderAdapter {

    private final boolean recursive;
    private final String[] packages;
    private final ClassLoader classloader;
    private final Map<String, UriSchemeResourceFinderFactory> finderFactories;

    private ResourceFinderStack resourceFinderStack;

    
    public PackageNamesScanner(final String[] packages, final boolean recursive) {
        this(AccessController.doPrivileged(ReflectionHelper.getContextClassLoaderPA()),
                Tokenizer.tokenize(packages, Tokenizer.COMMON_DELIMITERS), recursive);
    }

    
    public PackageNamesScanner(final ClassLoader classLoader, final String[] packages, final boolean recursive) {
        this.recursive = recursive;
        this.packages = packages.clone();
        this.classloader = classLoader;

        this.finderFactories = new HashMap<>();
        add(new JarZipSchemeResourceFinderFactory());
        add(new FileSchemeResourceFinderFactory());
        add(new VfsSchemeResourceFinderFactory());
        add(new BundleSchemeResourceFinderFactory());

        
        
        
        

        final OsgiRegistry osgiRegistry = ReflectionHelper.getOsgiRegistryInstance();
        if (osgiRegistry != null) {
            setResourcesProvider(new PackageNamesScanner.ResourcesProvider() {

                @Override
                public Enumeration<URL> getResources(String packagePath, ClassLoader classLoader) throws IOException {
                    return osgiRegistry.getPackageResources(packagePath, classLoader, recursive);
                }
            });
        }

        init();
    }

    private void add(final UriSchemeResourceFinderFactory uriSchemeResourceFinderFactory) {
        for (final String s : uriSchemeResourceFinderFactory.getSchemes()) {
            finderFactories.put(s.toLowerCase(), uriSchemeResourceFinderFactory);
        }
    }

    @Override
    public boolean hasNext() {
        return resourceFinderStack.hasNext();
    }

    @Override
    public String next() {
        return resourceFinderStack.next();
    }

    @Override
    public InputStream open() {
        return resourceFinderStack.open();
    }

    @Override
    public void reset() {
        init();
    }

    private void init() {
        resourceFinderStack = new ResourceFinderStack();

        for (final String p : packages) {
            try {
                final Enumeration<URL> urls =
                        ResourcesProvider.getInstance().getResources(p.replace('.', '/'), classloader);
                while (urls.hasMoreElements()) {
                    try {
                        addResourceFinder(toURI(urls.nextElement()));
                    } catch (URISyntaxException e) {
                        throw new ResourceFinderException("Error when converting a URL to a URI", e);
                    }
                }
            } catch (IOException e) {
                throw new ResourceFinderException("IO error when package scanning jar", e);
            }
        }

    }

    
    public abstract static class ResourcesProvider {

        private static volatile ResourcesProvider provider;

        private static ResourcesProvider getInstance() {
            
            ResourcesProvider result = provider;

            if (result == null) { 
                synchronized (ResourcesProvider.class) {
                    result = provider;
                    if (result == null) { 
                        provider = result = new ResourcesProvider() {

                            @Override
                            public Enumeration<URL> getResources(String name, ClassLoader cl)
                                    throws IOException {
                                return cl.getResources(name);
                            }
                        };

                    }
                }

            }
            return result;
        }

        private static void setInstance(ResourcesProvider provider) throws SecurityException {
            SecurityManager security = System.getSecurityManager();
            if (security != null) {
                ReflectPermission rp = new ReflectPermission("suppressAccessChecks");
                security.checkPermission(rp);
            }
            synchronized (ResourcesProvider.class) {
                ResourcesProvider.provider = provider;
            }
        }

        
        public abstract Enumeration<URL> getResources(String name, ClassLoader cl) throws IOException;
    }

    
    public static void setResourcesProvider(ResourcesProvider provider) throws SecurityException {
        ResourcesProvider.setInstance(provider);
    }

    private void addResourceFinder(final URI u) {
        final UriSchemeResourceFinderFactory finderFactory = finderFactories.get(u.getScheme().toLowerCase());
        if (finderFactory != null) {
            resourceFinderStack.push(finderFactory.create(u, recursive));
        } else {
            throw new ResourceFinderException("The URI scheme " + u.getScheme()
                    + " of the URI " + u
                    + " is not supported. Package scanning deployment is not"
                    + " supported for such URIs."
                    + "\nTry using a different deployment mechanism such as"
                    + " explicitly declaring root resource and provider classes"
                    + " using an extension of javax.ws.rs.core.Application");
        }
    }

    private URI toURI(URL url) throws URISyntaxException {
        try {
            return url.toURI();
        } catch (URISyntaxException e) {
            
            
            
            return URI.create(toExternalForm(url));
        }
    }

    private String toExternalForm(URL u) {

        
        int len = u.getProtocol().length() + 1;
        if (u.getAuthority() != null && u.getAuthority().length() > 0) {
            len += 2 + u.getAuthority().length();
        }
        if (u.getPath() != null) {
            len += u.getPath().length();
        }
        if (u.getQuery() != null) {
            len += 1 + u.getQuery().length();
        }
        if (u.getRef() != null) {
            len += 1 + u.getRef().length();
        }

        StringBuilder result = new StringBuilder(len);
        result.append(u.getProtocol());
        result.append(":");
        if (u.getAuthority() != null && u.getAuthority().length() > 0) {
            result.append("
            result.append(u.getAuthority());
        }
        if (u.getPath() != null) {
            result.append(UriComponent.contextualEncode(u.getPath(), UriComponent.Type.PATH));
        }
        if (u.getQuery() != null) {
            result.append('?');
            result.append(UriComponent.contextualEncode(u.getQuery(), UriComponent.Type.QUERY));
        }
        if (u.getRef() != null) {
            result.append("#");
            result.append(u.getRef());
        }
        return result.toString();
    }
}

<code block>

package org.glassfish.jersey.server;

import java.io.File;
import java.util.Set;
import java.util.concurrent.ExecutionException;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Application;
import javax.ws.rs.core.Context;

import org.glassfish.jersey.internal.util.Tokenizer;
import org.glassfish.jersey.model.internal.ComponentBag;
import org.glassfish.jersey.server.config.innerstatic.InnerStaticClass;
import org.glassfish.jersey.server.config.toplevel.PublicRootResourceClass;
import org.glassfish.jersey.server.config.toplevelinnerstatic.PublicRootResourceInnerStaticClass;

import org.glassfish.hk2.utilities.binding.AbstractBinder;

import org.junit.Test;
import static org.glassfish.jersey.server.JarUtils.createJarFile;
import static org.hamcrest.CoreMatchers.hasItem;
import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;


public class ResourceConfigTest {

    @Test
    public void testGetElementsDefault1() {
        final String[] elements = Tokenizer.tokenize(new String[] {"a b,c;d\ne"});

        assertEquals(elements[0], "a");
        assertEquals(elements[1], "b");
        assertEquals(elements[2], "c");
        assertEquals(elements[3], "d");
        assertEquals(elements[4], "e");
    }

    @Test
    public void testGetElementsDefault2() {
        final String[] elements = Tokenizer.tokenize(new String[] {"a    b, ,c;d\n\n\ne"});

        assertEquals(elements[0], "a");
        assertEquals(elements[1], "b");
        assertEquals(elements[2], "c");
        assertEquals(elements[3], "d");
        assertEquals(elements[4], "e");
    }

    @Test
    public void testGetElementsExplicitDelimiter() {
        final String[] elements = Tokenizer.tokenize(new String[] {"a b,c;d\ne"}, " ;");

        assertEquals(elements[0], "a");
        assertEquals(elements[1], "b,c");
        assertEquals(elements[2], "d\ne");
    }

    @Test
    public void testResourceConfigClasses() {
        final ResourceConfig resourceConfig = new MyResourceConfig2();
        final ApplicationHandler ah = new ApplicationHandler(resourceConfig);

        assertTrue(ah.getConfiguration().getClasses().contains(MyResource.class));
    }

    @Test
    public void testResourceConfigInjection() throws InterruptedException, ExecutionException {
        final int rcId = 12345;
        final ResourceConfig resourceConfig = new MyResourceConfig2(rcId);
        final ApplicationHandler handler = new ApplicationHandler(resourceConfig);

        assertSame(resourceConfig, handler.getServiceLocator().getService(Application.class));

        final ContainerResponse r = handler.apply(RequestContextBuilder.from("/", "/resource?id=" + rcId, "GET").build()).get();
        assertEquals(200, r.getStatus());
        assertEquals("Injected application instance not same as used for building the Jersey handler.",
                "true", r.getEntity());
    }

    @Test
    public void testResourceConfigMergeApplications() throws Exception {
        
        final MyOtherBinder defaultBinder = new MyOtherBinder();
        final ResourceConfig rc = ResourceConfig.forApplicationClass(MyResourceConfig1.class);
        rc.register(defaultBinder);
        final ApplicationHandler handler = new ApplicationHandler(rc);
        assertTrue(handler.getConfiguration().getComponentBag().getInstances(ComponentBag.BINDERS_ONLY).contains(defaultBinder));
    }

    @Test
    public void testApplicationName() {
        final ResourceConfig resourceConfig = new ResourceConfig(MyResource.class);
        resourceConfig.setApplicationName("app");
        assertEquals("app", resourceConfig.getApplicationName());
        resourceConfig.lock();
        assertEquals("app", resourceConfig.getApplicationName());
    }

    @Test
    public void testApplicationNameDefinedByProperty() {
        final ResourceConfig resourceConfig = new ResourceConfig(MyResource.class);
        resourceConfig.property(ServerProperties.APPLICATION_NAME, "app");
        assertNull(resourceConfig.getApplicationName());
        resourceConfig.lock();
        assertEquals("app", resourceConfig.getApplicationName());
    }

    public static class MyResourceConfig1 extends ResourceConfig {

        public MyResourceConfig1() {
            property(ServerProperties.WADL_FEATURE_DISABLE, true);
            register(new MyBinder());
        }
    }

    public static class MyResourceConfig2 extends ResourceConfig {

        private final int id;

        public MyResourceConfig2() {
            this(0);
        }

        public MyResourceConfig2(final int id) {
            property(ServerProperties.WADL_FEATURE_DISABLE, true);
            this.id = id;
            registerClasses(MyResource.class);
        }
    }

    @Path("resource")
    public static class MyResource {

        @Context
        Application app;

        @GET
        public String test(@QueryParam("id") final int rcId) {
            return Boolean.toString((app instanceof MyResourceConfig2) && ((MyResourceConfig2) app).id == rcId);
        }
    }

    public static class MyBinder extends AbstractBinder {

        @Override
        protected void configure() {
            
        }
    }

    public static class MyOtherBinder extends AbstractBinder {

        @Override
        protected void configure() {
            
        }
    }

    @Test
    public void testClassPathPropertyTopLevel() {
        final ResourceConfig rc = new ResourceConfig()
                .property(ServerProperties.PROVIDER_CLASSPATH, PublicRootResourceClass.class.getResource("").getPath());

        final Set<Class<?>> classes = rc.getClasses();
        assertThat(classes, hasItem(PublicRootResourceClass.class));
        assertThat(classes.size(), is(1));
    }

    @Test
    public void testClassPathPropertyInnerStatic() {
        final ResourceConfig rc = new ResourceConfig()
                .property(ServerProperties.PROVIDER_CLASSPATH, InnerStaticClass.class.getResource("").getPath());

        final Set<Class<?>> classes = rc.getClasses();
        assertThat(classes, hasItem(InnerStaticClass.PublicClass.class));
        assertThat(classes.size(), is(1));
    }

    @Test
    public void testClassPathPropertyTopLevelInnerStatic() {
        final ResourceConfig rc = new ResourceConfig()
                .property(ServerProperties.PROVIDER_CLASSPATH,
                        PublicRootResourceInnerStaticClass.class.getResource("").getPath());

        final Set<Class<?>> classes = rc.getClasses();
        assertThat(classes, hasItem(PublicRootResourceInnerStaticClass.class));
        assertThat(classes, hasItem(PublicRootResourceInnerStaticClass.PublicClass.class));
        assertThat(classes.size(), is(2));
    }

    @Test
    public void testClassPathPropertyAll() {
        final ResourceConfig rc = new ResourceConfig()
                .property(ServerProperties.PROVIDER_CLASSPATH, ResourceConfigTest.class.getResource("").getPath() + "/config");

        final Set<Class<?>> classes = rc.getClasses();
        assertThat(classes, hasItem(PublicRootResourceClass.class));
        assertThat(classes, hasItem(InnerStaticClass.PublicClass.class));
        assertThat(classes, hasItem(PublicRootResourceInnerStaticClass.class));
        assertThat(classes, hasItem(PublicRootResourceInnerStaticClass.PublicClass.class));
        assertThat(classes.size(), is(4));
    }

    @Test
    public void testClassPathPropertyAllMultiplePaths() {
        final String paths = PublicRootResourceClass.class.getResource("").getPath() + ";"
                + InnerStaticClass.class.getResource("").getPath() + ";"
                + PublicRootResourceInnerStaticClass.class.getResource("").getPath();
        final ResourceConfig rc = new ResourceConfig()
                .property(ServerProperties.PROVIDER_CLASSPATH, paths);

        final Set<Class<?>> classes = rc.getClasses();
        assertThat(classes, hasItem(PublicRootResourceClass.class));
        assertThat(classes, hasItem(InnerStaticClass.PublicClass.class));
        assertThat(classes, hasItem(PublicRootResourceInnerStaticClass.class));
        assertThat(classes, hasItem(PublicRootResourceInnerStaticClass.PublicClass.class));
        assertThat(classes.size(), is(4));
    }

    @Test
    public void testClassPathPropertyAllMultiplePathsWithSpaces() {
        final String paths = PublicRootResourceClass.class.getResource("").getPath() + "; "
                + InnerStaticClass.class.getResource("").getPath() + ";;"
                + PublicRootResourceInnerStaticClass.class.getResource("").getPath() + "; ;; ";
        final ResourceConfig rc = new ResourceConfig()
                .property(ServerProperties.PROVIDER_CLASSPATH, paths);

        final Set<Class<?>> classes = rc.getClasses();
        assertThat(classes, hasItem(PublicRootResourceClass.class));
        assertThat(classes, hasItem(InnerStaticClass.PublicClass.class));
        assertThat(classes, hasItem(PublicRootResourceInnerStaticClass.class));
        assertThat(classes, hasItem(PublicRootResourceInnerStaticClass.PublicClass.class));
        assertThat(classes.size(), is(4));
    }

    @Test
    public void testClassPathPropertyJarTopLevel() throws Exception {
        final ResourceConfig rc = createConfigWithClassPathProperty(
                createJarFile(ResourceConfigTest.class.getResource("").getPath(),
                        "config/toplevel/PublicRootResourceClass.class",
                        "config/toplevel/PackageRootResourceClass.class")
        );

        final Set<Class<?>> classes = rc.getClasses();
        assertThat(classes, hasItem(PublicRootResourceClass.class));
        assertThat(classes.size(), is(1));
    }

    @Test
    public void testClassPathPropertyJarInnerStatic() throws Exception {
        final ResourceConfig rc = createConfigWithClassPathProperty(
                createJarFile(ResourceConfigTest.class.getResource("").getPath(),
                        "config/innerstatic/InnerStaticClass.class",
                        "config/innerstatic/InnerStaticClass$PublicClass.class",
                        "config/innerstatic/InnerStaticClass$PackageClass.class",
                        "config/innerstatic/InnerStaticClass$ProtectedClass.class",
                        "config/innerstatic/InnerStaticClass$PrivateClass.class")
        );

        final Set<Class<?>> classes = rc.getClasses();
        assertThat(classes, hasItem(InnerStaticClass.PublicClass.class));
        assertThat(classes.size(), is(1));
    }

    @Test
    public void testClassPathPropertyJarAll() throws Exception {
        final ResourceConfig rc = createConfigWithClassPathProperty(
                createJarFile(ResourceConfigTest.class.getResource("").getPath(),
                        "config/toplevel/PublicRootResourceClass.class",
                        "config/toplevel/PackageRootResourceClass.class",
                        "config/innerstatic/InnerStaticClass.class",
                        "config/innerstatic/InnerStaticClass$PublicClass.class",
                        "config/innerstatic/InnerStaticClass$PackageClass.class",
                        "config/innerstatic/InnerStaticClass$ProtectedClass.class",
                        "config/innerstatic/InnerStaticClass$PrivateClass.class")
        );

        final Set<Class<?>> classes = rc.getClasses();
        assertThat(classes, hasItem(PublicRootResourceClass.class));
        assertThat(classes, hasItem(InnerStaticClass.PublicClass.class));
        assertThat(classes.size(), is(2));
    }

    @Test
    public void testClassPathPropertyZipAll() throws Exception {
        final ResourceConfig rc = createConfigWithClassPathProperty(
                createJarFile(JarUtils.Suffix.zip, ResourceConfigTest.class.getResource("").getPath(),
                        "config/toplevel/PublicRootResourceClass.class", "config/toplevel/PackageRootResourceClass.class",
                        "config/innerstatic/InnerStaticClass.class", "config/innerstatic/InnerStaticClass$PublicClass.class",
                        "config/innerstatic/InnerStaticClass$PackageClass.class",
                        "config/innerstatic/InnerStaticClass$ProtectedClass.class",
                        "config/innerstatic/InnerStaticClass$PrivateClass.class")
        );

        final Set<Class<?>> classes = rc.getClasses();
        assertThat(classes, hasItem(PublicRootResourceClass.class));
        assertThat(classes, hasItem(InnerStaticClass.PublicClass.class));
        assertThat(classes.size(), is(2));
    }

    
    @Test
    public void testGetClasses() throws Exception {
        final ResourceConfig rc = new ResourceConfig()
                .packages(false, PublicRootResourceClass.class.getPackage().getName());

        Set<Class<?>> classes = rc.getClasses();
        assertThat(classes.size(), is(1));
        assertThat(classes, hasItem(PublicRootResourceClass.class));

        rc.register(InnerStaticClass.PublicClass.class);

        classes = rc.getClasses();
        assertThat(classes.size(), is(2));
        assertThat(classes, hasItem(PublicRootResourceClass.class));
        assertThat(classes, hasItem(InnerStaticClass.PublicClass.class));
    }

    private ResourceConfig createConfigWithClassPathProperty(final File jarFile) {
        return new ResourceConfig().property(ServerProperties.PROVIDER_CLASSPATH, jarFile.getAbsolutePath());
    }
}

<code block>

package org.glassfish.jersey.server.internal.scanning;

import java.io.IOException;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLStreamHandler;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.Vector;

import org.junit.Before;
import org.junit.Test;
import static org.junit.Assert.fail;


public class PackageNamesScannerTest {

    private String jaxRsApiPath;
    private String[] packages = {"javax.ws.rs-api"};

    @Before
    public void setUp() throws Exception {
        final String classPath = System.getProperty("java.class.path");
        final String[] entries = classPath.split(System
                .getProperty("path.separator"));

        for (final String entry : entries) {
            if (entry.contains("javax.ws.rs-api")) {
                jaxRsApiPath = entry;
                break;
            }
        }

        if (jaxRsApiPath == null) {
            fail("Could not find javax.ws.rs-api.");
        }
    }

    @Test
    public void testWsJarScheme() {
        new PackageNamesScanner(createTestClassLoader("wsjar", createTestURLStreamHandler("wsjar"), jaxRsApiPath), packages,
                false);
    }

    @Test
    public void testJarScheme() {
        
        new PackageNamesScanner(packages, false);
    }

    @Test
    public void testZipScheme() {
        new PackageNamesScanner(createTestClassLoader("zip", createTestURLStreamHandler("zip"), jaxRsApiPath), packages, false);
    }

    @Test
    public void testFileScheme() {
        
        new PackageNamesScanner(packages, false);
    }

    @Test(expected = ResourceFinderException.class)
    public void testInvalidScheme() {
        new PackageNamesScanner(createTestClassLoader("bad", createTestURLStreamHandler("bad"), jaxRsApiPath), packages, false);
    }

    private ClassLoader createTestClassLoader(final String scheme,
                                              final URLStreamHandler urlStreamHandler,
                                              final String resourceFilePath) {
        return new ClassLoader() {
            public Enumeration<URL> getResources(String name) throws IOException {
                List<URL> list = new ArrayList<URL>();
                list.add((urlStreamHandler == null
                        ? new URL(null, scheme + ":" + resourceFilePath + "!/" + name)
                        : new URL(null, scheme + ":" + resourceFilePath + "!/" + name, urlStreamHandler)));
                return new Vector<URL>(list).elements();
            }
        };
    }

    
    private URLStreamHandler createTestURLStreamHandler(final String scheme) {
        return new URLStreamHandler() {
            @Override
            protected URLConnection openConnection(URL u) throws IOException {
                throw new UnsupportedOperationException();
            }

            @Override
            protected void parseURL(URL u, String spec, int start, int limit) {
                setURL(u, scheme, "", -1, null, null, spec.substring(scheme.length() + 1), null, null);
            }
        };
    }
}

<code block>

package org.glassfish.jersey.server.internal.scanning;

import java.io.InputStream;
import java.util.NoSuchElementException;

import org.glassfish.jersey.server.internal.AbstractResourceFinderAdapter;
import org.glassfish.jersey.server.ResourceFinder;

import org.junit.Test;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;


public class ResourceFinderStackTest {

    public static class MyIterator extends AbstractResourceFinderAdapter {
        boolean iterated = false;

        @Override
        public boolean hasNext() {
            return !iterated;
        }

        @Override
        public String next() {
            if (!iterated) {
                iterated = true;
                return "value";
            }

            throw new NoSuchElementException();
        }

        @Override
        public void reset() {
        }

        @Override
        public InputStream open() {
            return null;
        }
    }


    @Test
    public void test() {
        ResourceFinder i = new MyIterator();
        ResourceFinder j = new MyIterator();

        ResourceFinderStack iteratorStack = new ResourceFinderStack();
        iteratorStack.push(i);
        iteratorStack.push(j);

        assertEquals(iteratorStack.next(), "value");
        assertEquals(iteratorStack.next(), "value");

        try {
            iteratorStack.next();
            assertTrue(false);
        } catch (NoSuchElementException nsee) {
            assertTrue(true);
        }
    }
}

<code block>


package org.glassfish.jersey.tests.integration.client.connector.provider;

import java.net.HttpURLConnection;

import javax.ws.rs.client.Client;

import org.glassfish.jersey.client.HttpUrlConnectorProvider;
import org.glassfish.jersey.client.internal.HttpUrlConnector;
import org.glassfish.jersey.client.spi.Connector;


public final class CustomConnectorProvider extends HttpUrlConnectorProvider {

    public static volatile boolean invoked = false;

    @Override
    protected Connector createHttpUrlConnector(Client client, ConnectionFactory connectionFactory, int chunkSize,
                                               boolean fixLengthStreaming, boolean setMethodWorkaround) {

        return new HttpUrlConnector(
                client,
                connectionFactory,
                chunkSize,
                fixLengthStreaming,
                setMethodWorkaround) {

            @Override
            protected void secureConnection(Client client, HttpURLConnection uc) {
                invoked = true;
            }
        };
    }
}

<code block>


package org.glassfish.jersey.tests.integration.client.connector.provider;

import javax.ws.rs.GET;
import javax.ws.rs.Path;


@Path("test")
public class TestResource {

    @GET
    public String get() {
        return "test";
    }
}

<code block>


package org.glassfish.jersey.tests.integration.client.connector.provider;

import javax.ws.rs.core.Response;

import org.glassfish.jersey.server.ResourceConfig;
import org.glassfish.jersey.test.JerseyTest;

import org.junit.Test;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;


public class CustomConnectorProviderTest extends JerseyTest {

    @Override
    protected ResourceConfig configure() {
        return new ResourceConfig(TestResource.class);
    }

    @Test
    public void testInvoked() {
        assertFalse(CustomConnectorProvider.invoked);

        Response response = target().path("test").request("text/plain").get();
        assertEquals(200, response.getStatus());

        assertTrue(CustomConnectorProvider.invoked);
    }
}

<code block>

package org.glassfish.jersey.tests.e2e.server;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.client.WebTarget;
import javax.ws.rs.core.Application;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

import javax.xml.bind.annotation.XmlRootElement;

import org.glassfish.jersey.client.ClientConfig;
import org.glassfish.jersey.client.internal.HttpUrlConnector;
import org.glassfish.jersey.filter.LoggingFilter;
import org.glassfish.jersey.server.ResourceConfig;
import org.glassfish.jersey.test.JerseyTest;

import org.junit.Assert;
import org.junit.Test;


public class ContentNegotiationTest extends JerseyTest {

    @Path("persons")
    public static class MyResource {
        private static final Person[] LIST = new Person[] {
                new Person("Penny", 1),
                new Person("Howard", 2),
                new Person("Sheldon", 3)
        };

        @GET
        @Produces({"application/xml;qs=0.75", "application/json;qs=1.0"})
        public Person[] getList() {
            return LIST;
        }

        @GET
        @Produces({"application/json;qs=1", "application/xml;qs=0.75"})
        @Path("reordered")
        public Person[] getListReordered() {
            return LIST;
        }

        @GET
        @Produces({"application/json;qs=0.75", "application/xml;qs=1"})
        @Path("inverted")
        public Person[] getListInverted() {
            return LIST;
        }


        @GET
        @Produces({"application/xml;qs=0.75", "application/json;qs=0.9", "unknown/hello;qs=1.0"})
        @Path("unkownMT")
        public Person[] getListWithUnkownType() {
            return LIST;
        }

        @GET
        @Produces({"application/json", "application/xml", "text/plain"})
        @Path("shouldPickFirstJson")
        public Person[] getJsonArrayUnlessOtherwiseSpecified() {
            return LIST;
        }

        @GET
        @Produces({"application/xml", "text/plain", "application/json"})
        @Path("shouldPickFirstXml")
        public Person[] getXmlUnlessOtherwiseSpecified() {
            return LIST;
        }

        @GET
        @Produces("application/json;qs=0.75")
        @Path("twoMethodsOneEndpoint")
        public Person[] getJsonArray() {
            return LIST;
        }

        @GET
        @Produces("application/xml;qs=1")
        @Path("twoMethodsOneEndpoint")
        public Person[] getXml() {
            return LIST;
        }
    }

    @XmlRootElement
    public static class Person {
        private String name;
        private int age;

        public Person() {
        }

        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public int getAge() {
            return age;
        }

        public void setAge(int age) {
            this.age = age;
        }

        @Override
        public String toString() {
            return name + "(" + age + ")";
        }
    }

    @Override
    protected void configureClient(ClientConfig config) {
        config.register(LoggingFilter.class);
    }

    @Override
    protected Application configure() {
        return new ResourceConfig(MyResource.class);
    }

    
    @Test
    public void testWithoutDefinedRequestedMediaType() {
        WebTarget target = target().path("/persons");
        Response response = target.request().get();
        Assert.assertEquals(200, response.getStatus());
        Assert.assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getMediaType());
    }

    @Test
    public void testWithoutDefinedRequestedMediaTypeAndTwoMethods() {
        
        
        
        Response response = target().path("/persons/twoMethodsOneEndpoint").request().get();
        Assert.assertEquals(200, response.getStatus());
        Assert.assertEquals(MediaType.APPLICATION_XML_TYPE, response.getMediaType());
    }

    @Test
    public void testWithoutDefinedRequestedMediaTypeOrQualityModifiersJson() {
        Response response = target().path("/persons/shouldPickFirstJson").request().get();
        Assert.assertEquals(200, response.getStatus());
        Assert.assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getMediaType());
    }

    @Test
    public void testWithoutDefinedRequestedMediaTypeOrQualityModifiersXml() {
        Response response = target().path("/persons/shouldPickFirstXml").request().get();
        Assert.assertEquals(200, response.getStatus());
        Assert.assertEquals(MediaType.APPLICATION_XML_TYPE, response.getMediaType());
    }

    @Test
    public void test() {
        WebTarget target = target().path("/persons");
        Response response = target.request(MediaType.WILDCARD).get();
        Assert.assertEquals(200, response.getStatus());
        Assert.assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getMediaType());
    }

    @Test
    public void testInverted() {
        WebTarget target = target().path("/persons/inverted");
        Response response = target.request(MediaType.WILDCARD).get();
        Assert.assertEquals(200, response.getStatus());
        Assert.assertEquals(MediaType.APPLICATION_XML_TYPE, response.getMediaType());
    }

    @Test
    public void testInvertedWithJSONPreferredByClient() {
        WebTarget target = target().path("/persons/inverted");
        Response response = target.request("application/json;q=1.0", "application/xml;q=0.8").get();
        Assert.assertEquals(200, response.getStatus());
        Assert.assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getMediaType());
    }

    @Test
    public void testReordered() {
        WebTarget target = target().path("/persons/reordered");
        Response response = target.request(MediaType.WILDCARD).get();
        Assert.assertEquals(200, response.getStatus());
        Assert.assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getMediaType());
    }

    
    @Test
    public void testWithUnknownTypePreferredByClient() {
        WebTarget target = target().path("/persons/reordered");
        Response response = target.request("application/json;q=0.8", "application/xml;q=0.9",
                "unknown/hello;qs=1.0").get();
        Assert.assertEquals(200, response.getStatus());
        Assert.assertEquals(MediaType.APPLICATION_XML_TYPE, response.getMediaType());
    }
}

<code block>


package org.glassfish.jersey.client;

import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import javax.ws.rs.RuntimeType;
import javax.ws.rs.core.Configurable;
import javax.ws.rs.core.Configuration;
import javax.ws.rs.core.Feature;

import org.glassfish.jersey.CommonProperties;
import org.glassfish.jersey.ExtendedConfig;
import org.glassfish.jersey.client.internal.LocalizationMessages;
import org.glassfish.jersey.client.spi.Connector;
import org.glassfish.jersey.client.spi.ConnectorProvider;
import org.glassfish.jersey.internal.ServiceFinder;
import org.glassfish.jersey.internal.inject.Injections;
import org.glassfish.jersey.internal.inject.JerseyClassAnalyzer;
import org.glassfish.jersey.internal.inject.ProviderBinder;
import org.glassfish.jersey.internal.util.collection.LazyValue;
import org.glassfish.jersey.internal.util.collection.Value;
import org.glassfish.jersey.internal.util.collection.Values;
import org.glassfish.jersey.model.internal.CommonConfig;
import org.glassfish.jersey.model.internal.ComponentBag;
import org.glassfish.jersey.process.internal.ExecutorProviders;

import org.glassfish.hk2.api.DynamicConfiguration;
import org.glassfish.hk2.api.ServiceLocator;
import org.glassfish.hk2.utilities.binding.AbstractBinder;


public class ClientConfig implements Configurable<ClientConfig>, ExtendedConfig {
    
    private State state;

    
    private static class State implements Configurable<State>, ExtendedConfig {

        
        private static final StateChangeStrategy IDENTITY = new StateChangeStrategy() {

            @Override
            public State onChange(final State state) {
                return state;
            }
        };
        
        private static final StateChangeStrategy COPY_ON_CHANGE = new StateChangeStrategy() {

            @Override
            public State onChange(final State state) {
                return state.copy();
            }
        };

        private volatile StateChangeStrategy strategy;
        private final CommonConfig commonConfig;
        private final JerseyClient client;
        private volatile ConnectorProvider connectorProvider;


        private final LazyValue<ClientRuntime> runtime = Values.lazy(new Value<ClientRuntime>() {
            @Override
            public ClientRuntime get() {
                return initRuntime();
            }
        });

        
        private static interface StateChangeStrategy {

            
            public State onChange(final State state);
        }

        
        State(final JerseyClient client) {
            this.strategy = IDENTITY;
            this.commonConfig = new CommonConfig(RuntimeType.CLIENT, ComponentBag.EXCLUDE_EMPTY);
            this.client = client;
            final Iterator<ConnectorProvider> iterator = ServiceFinder.find(ConnectorProvider.class).iterator();
            if (iterator.hasNext()) {
                this.connectorProvider = iterator.next();
            } else {
                this.connectorProvider = new HttpUrlConnectorProvider();
            }
        }

        
        private State(final JerseyClient client, final State original) {
            this.strategy = IDENTITY;
            this.client = client;
            this.commonConfig = new CommonConfig(original.commonConfig);
            this.connectorProvider = original.connectorProvider;
        }

        
        State copy() {
            return new State(this.client, this);
        }

        
        State copy(final JerseyClient client) {
            return new State(client, this);
        }

        void markAsShared() {
            strategy = COPY_ON_CHANGE;
        }

        State preInitialize() {
            final State state = strategy.onChange(this);
            state.strategy = COPY_ON_CHANGE;
            state.runtime.get().preInitialize();
            return state;

        }

        @Override
        public State property(final String name, final Object value) {
            final State state = strategy.onChange(this);
            state.commonConfig.property(name, value);
            return state;
        }

        public State loadFrom(final Configuration config) {
            final State state = strategy.onChange(this);
            state.commonConfig.loadFrom(config);
            return state;
        }

        @Override
        public State register(final Class<?> providerClass) {
            final State state = strategy.onChange(this);
            state.commonConfig.register(providerClass);
            return state;
        }

        @Override
        public State register(final Object provider) {
            final State state = strategy.onChange(this);
            state.commonConfig.register(provider);
            return state;
        }

        @Override
        public State register(final Class<?> providerClass, final int bindingPriority) {
            final State state = strategy.onChange(this);
            state.commonConfig.register(providerClass, bindingPriority);
            return state;
        }

        @Override
        public State register(final Class<?> providerClass, final Class<?>... contracts) {
            final State state = strategy.onChange(this);
            state.commonConfig.register(providerClass, contracts);
            return state;
        }

        @Override
        public State register(final Class<?> providerClass, final Map<Class<?>, Integer> contracts) {
            final State state = strategy.onChange(this);
            state.commonConfig.register(providerClass, contracts);
            return state;
        }

        @Override
        public State register(final Object provider, final int bindingPriority) {
            final State state = strategy.onChange(this);
            state.commonConfig.register(provider, bindingPriority);
            return state;
        }

        @Override
        public State register(final Object provider, final Class<?>... contracts) {
            final State state = strategy.onChange(this);
            state.commonConfig.register(provider, contracts);
            return state;
        }

        @Override
        public State register(final Object provider, final Map<Class<?>, Integer> contracts) {
            final State state = strategy.onChange(this);
            state.commonConfig.register(provider, contracts);
            return state;
        }

        State connectorProvider(final ConnectorProvider provider) {
            if (provider == null) {
                throw new NullPointerException(LocalizationMessages.NULL_CONNECTOR_PROVIDER());
            }
            final State state = strategy.onChange(this);
            state.connectorProvider = provider;
            return state;
        }

        Connector getConnector() {
            
            return (runtime.isInitialized()) ? runtime.get().getConnector() : null;
        }

        ConnectorProvider getConnectorProvider() {
            return connectorProvider;
        }

        JerseyClient getClient() {
            return client;
        }

        @Override
        public State getConfiguration() {
            return this;
        }

        @Override
        public RuntimeType getRuntimeType() {
            return commonConfig.getConfiguration().getRuntimeType();
        }

        @Override
        public Map<String, Object> getProperties() {
            return commonConfig.getConfiguration().getProperties();
        }

        @Override
        public Object getProperty(final String name) {
            return commonConfig.getConfiguration().getProperty(name);
        }

        @Override
        public Collection<String> getPropertyNames() {
            return commonConfig.getConfiguration().getPropertyNames();
        }

        @Override
        public boolean isProperty(final String name) {
            return commonConfig.getConfiguration().isProperty(name);
        }

        @Override
        public boolean isEnabled(final Feature feature) {
            return commonConfig.getConfiguration().isEnabled(feature);
        }

        @Override
        public boolean isEnabled(final Class<? extends Feature> featureClass) {
            return commonConfig.getConfiguration().isEnabled(featureClass);
        }

        @Override
        public boolean isRegistered(final Object component) {
            return commonConfig.getConfiguration().isRegistered(component);
        }

        @Override
        public boolean isRegistered(final Class<?> componentClass) {
            return commonConfig.getConfiguration().isRegistered(componentClass);
        }

        @Override
        public Map<Class<?>, Integer> getContracts(final Class<?> componentClass) {
            return commonConfig.getConfiguration().getContracts(componentClass);
        }

        @Override
        public Set<Class<?>> getClasses() {
            return commonConfig.getConfiguration().getClasses();
        }

        @Override
        public Set<Object> getInstances() {
            return commonConfig.getConfiguration().getInstances();
        }

        public void configureAutoDiscoverableProviders(final ServiceLocator locator) {
            commonConfig.configureAutoDiscoverableProviders(locator, false);
        }

        public void configureForcedAutoDiscoverableProviders(final ServiceLocator locator) {
            commonConfig.configureAutoDiscoverableProviders(locator, true);
        }

        public void configureMetaProviders(final ServiceLocator locator) {
            commonConfig.configureMetaProviders(locator);
        }

        public ComponentBag getComponentBag() {
            return commonConfig.getComponentBag();
        }

        
        @SuppressWarnings("MethodOnlyUsedFromInnerClass")
        private ClientRuntime initRuntime() {
            
            markAsShared();

            final State runtimeCfgState = this.copy();
            runtimeCfgState.markAsShared();

            final ServiceLocator locator = Injections.createLocator(new ClientBinder(runtimeCfgState.getProperties()));
            locator.setDefaultClassAnalyzerName(JerseyClassAnalyzer.NAME);

            
            if (!CommonProperties.getValue(runtimeCfgState.getProperties(), RuntimeType.CLIENT,
                    CommonProperties.FEATURE_AUTO_DISCOVERY_DISABLE, Boolean.FALSE, Boolean.class)) {
                runtimeCfgState.configureAutoDiscoverableProviders(locator);
            } else {
                runtimeCfgState.configureForcedAutoDiscoverableProviders(locator);
            }

            
            runtimeCfgState.configureMetaProviders(locator);

            
            final AbstractBinder configBinder = new AbstractBinder() {
                @Override
                protected void configure() {
                    bind(runtimeCfgState).to(Configuration.class);
                }
            };
            final DynamicConfiguration dc = Injections.getConfiguration(locator);
            configBinder.bind(dc);
            dc.commit();

            
            ProviderBinder.bindProviders(runtimeCfgState.getComponentBag(), RuntimeType.CLIENT, null, locator);

            
            ExecutorProviders.createInjectionBindings(locator);

            final ClientConfig configuration = new ClientConfig(runtimeCfgState);
            final Connector connector = connectorProvider.getConnector(client, configuration);
            final ClientRuntime crt = new ClientRuntime(configuration, connector, locator);

            client.registerShutdownHook(crt);

            return crt;
        }

        @Override
        public boolean equals(final Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }

            final State state = (State) o;

            if (client != null ? !client.equals(state.client) : state.client != null) {
                return false;
            }
            if (!commonConfig.equals(state.commonConfig)) {
                return false;
            }
            return connectorProvider == null ? state.connectorProvider == null
                    : connectorProvider.equals(state.connectorProvider);
        }

        @Override
        public int hashCode() {
            int result = commonConfig.hashCode();
            result = 31 * result + (client != null ? client.hashCode() : 0);
            result = 31 * result + (connectorProvider != null ? connectorProvider.hashCode() : 0);
            return result;
        }
    }

    
    public ClientConfig() {
        this.state = new State(null);
    }

    
    public ClientConfig(final Class<?>... providerClasses) {
        this();
        for (final Class<?> providerClass : providerClasses) {
            state.register(providerClass);
        }
    }

    
    public ClientConfig(final Object... providers) {
        this();
        for (final Object provider : providers) {
            state.register(provider);
        }
    }

    
    ClientConfig(final JerseyClient parent) {
        this.state = new State(parent);
    }

    
    ClientConfig(final JerseyClient parent, final Configuration that) {
        if (that instanceof ClientConfig) {
            state = ((ClientConfig) that).state.copy(parent);
        } else {
            state = new State(parent);
            state.loadFrom(that);
        }
    }

    
    private ClientConfig(final State state) {
        this.state = state;
    }

    
    ClientConfig snapshot() {
        state.markAsShared();
        return new ClientConfig(state);
    }

    
    public ClientConfig loadFrom(final Configuration config) {
        if (config instanceof ClientConfig) {
            state = ((ClientConfig) config).state.copy();
        } else {
            state.loadFrom(config);
        }
        return this;
    }

    @Override
    public ClientConfig register(final Class<?> providerClass) {
        state = state.register(providerClass);
        return this;
    }

    @Override
    public ClientConfig register(final Object provider) {
        state = state.register(provider);
        return this;
    }

    @Override
    public ClientConfig register(final Class<?> providerClass, final int bindingPriority) {
        state = state.register(providerClass, bindingPriority);
        return this;
    }

    @Override
    public ClientConfig register(final Class<?> providerClass, final Class<?>... contracts) {
        state = state.register(providerClass, contracts);
        return this;
    }

    @Override
    public ClientConfig register(final Class<?> providerClass, final Map<Class<?>, Integer> contracts) {
        state = state.register(providerClass, contracts);
        return this;
    }

    @Override
    public ClientConfig register(final Object provider, final int bindingPriority) {
        state = state.register(provider, bindingPriority);
        return this;
    }

    @Override
    public ClientConfig register(final Object provider, final Class<?>... contracts) {
        state = state.register(provider, contracts);
        return this;
    }

    @Override
    public ClientConfig register(final Object provider, final Map<Class<?>, Integer> contracts) {
        state = state.register(provider, contracts);
        return this;
    }

    @Override
    public ClientConfig property(final String name, final Object value) {
        state = state.property(name, value);
        return this;
    }

    @Override
    public ClientConfig getConfiguration() {
        return this;
    }

    @Override
    public RuntimeType getRuntimeType() {
        return state.getRuntimeType();
    }

    @Override
    public Map<String, Object> getProperties() {
        return state.getProperties();
    }

    @Override
    public Object getProperty(final String name) {
        return state.getProperty(name);
    }

    @Override
    public Collection<String> getPropertyNames() {
        return state.getPropertyNames();
    }

    @Override
    public boolean isProperty(final String name) {
        return state.isProperty(name);
    }

    @Override
    public boolean isEnabled(final Feature feature) {
        return state.isEnabled(feature);
    }

    @Override
    public boolean isEnabled(final Class<? extends Feature> featureClass) {
        return state.isEnabled(featureClass);
    }

    @Override
    public boolean isRegistered(final Object component) {
        return state.isRegistered(component);
    }

    @Override
    public Map<Class<?>, Integer> getContracts(final Class<?> componentClass) {
        return state.getContracts(componentClass);
    }

    @Override
    public boolean isRegistered(final Class<?> componentClass) {
        return state.isRegistered(componentClass);
    }

    @Override
    public Set<Class<?>> getClasses() {
        return state.getClasses();
    }

    @Override
    public Set<Object> getInstances() {
        return state.getInstances();
    }

    
    public ClientConfig connectorProvider(final ConnectorProvider connectorProvider) {
        state = state.connectorProvider(connectorProvider);
        return this;
    }

    
    public Connector getConnector() {
        return state.getConnector();
    }

    
    public ConnectorProvider getConnectorProvider() {
        return state.getConnectorProvider();
    }

    
    ClientRuntime getRuntime() {
        return state.runtime.get();
    }

    
    public JerseyClient getClient() {
        return state.getClient();
    }


    
    ClientConfig preInitialize() {
        state = state.preInitialize();
        return this;
    }

    
    void checkClient() throws IllegalStateException {
        if (getClient() == null) {
            throw new IllegalStateException("Client configuration does not contain a parent client instance.");
        }
    }

    @Override
    public boolean equals(final Object obj) {
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final ClientConfig other = (ClientConfig) obj;
        return this.state == other.state || (this.state != null && this.state.equals(other.state));
    }

    @Override
    public int hashCode() {
        int hash = 7;
        hash = 47 * hash + (this.state != null ? this.state.hashCode() : 0);
        return hash;
    }
}

<code block>

package org.glassfish.jersey.client;

import java.util.Map;

import org.glassfish.jersey.CommonProperties;
import org.glassfish.jersey.client.internal.HttpUrlConnector;
import org.glassfish.jersey.internal.util.PropertiesClass;
import org.glassfish.jersey.internal.util.PropertiesHelper;
import org.glassfish.jersey.internal.util.PropertyAlias;


@PropertiesClass
public final class ClientProperties {

    
    public static final String FOLLOW_REDIRECTS = "jersey.config.client.followRedirects";

    
    public static final String READ_TIMEOUT = "jersey.config.client.readTimeout";

    
    public static final String CONNECT_TIMEOUT = "jersey.config.client.connectTimeout";

    
    public static final String CHUNKED_ENCODING_SIZE = "jersey.config.client.chunkedEncodingSize";
    
    public static final int DEFAULT_CHUNK_SIZE = 4096;

    
    public static final String ASYNC_THREADPOOL_SIZE = "jersey.config.client.async.threadPoolSize";

    
    public static final String USE_ENCODING = "jersey.config.client.useEncoding";

    
    @PropertyAlias
    public static final String FEATURE_AUTO_DISCOVERY_DISABLE = CommonProperties.FEATURE_AUTO_DISCOVERY_DISABLE_CLIENT;

    
    @PropertyAlias
    public static final String OUTBOUND_CONTENT_LENGTH_BUFFER = CommonProperties.OUTBOUND_CONTENT_LENGTH_BUFFER_CLIENT;

    
    @PropertyAlias
    public static final String JSON_PROCESSING_FEATURE_DISABLE = CommonProperties.JSON_PROCESSING_FEATURE_DISABLE_CLIENT;

    
    @PropertyAlias
    public static final String METAINF_SERVICES_LOOKUP_DISABLE = CommonProperties.METAINF_SERVICES_LOOKUP_DISABLE_CLIENT;

    
    @PropertyAlias
    public static final String MOXY_JSON_FEATURE_DISABLE = CommonProperties.MOXY_JSON_FEATURE_DISABLE_CLIENT;

    
    public static final String SUPPRESS_HTTP_COMPLIANCE_VALIDATION =
            "jersey.config.client.suppressHttpComplianceValidation";

    
    public static final String DIGESTAUTH_URI_CACHE_SIZELIMIT = "jersey.config.client.digestAuthUriCacheSizeLimit";

    
    
    public static final String PROXY_URI = "jersey.config.client.proxy.uri";

    
    public static final String PROXY_USERNAME = "jersey.config.client.proxy.username";

    
    public static final String PROXY_PASSWORD = "jersey.config.client.proxy.password";
    
    public static final String REQUEST_ENTITY_PROCESSING = "jersey.config.client.request.entity.processing";

    private ClientProperties() {
        
    }

    
    public static <T> T getValue(final Map<String, ?> properties, final String key, final T defaultValue) {
        return PropertiesHelper.getValue(properties, key, defaultValue, null);
    }

    
    public static <T> T getValue(final Map<String, ?> properties, final String key, final T defaultValue, final Class<T> type) {
        return PropertiesHelper.getValue(properties, key, defaultValue, type, null);
    }

    
    public static <T> T getValue(final Map<String, ?> properties, final String key, final Class<T> type) {
        return PropertiesHelper.getValue(properties, key, type, null);
    }
}

<code block>

package org.glassfish.jersey.client;

import java.io.IOException;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.Map;
import java.util.logging.Logger;

import javax.ws.rs.client.Client;
import javax.ws.rs.core.Configuration;

import org.glassfish.jersey.client.internal.HttpUrlConnector;
import org.glassfish.jersey.client.internal.LocalizationMessages;
import org.glassfish.jersey.client.spi.Connector;
import org.glassfish.jersey.client.spi.ConnectorProvider;


public class HttpUrlConnectorProvider implements ConnectorProvider {
    
    public static final String USE_FIXED_LENGTH_STREAMING =
            "jersey.config.client.httpUrlConnector.useFixedLengthStreaming";

    
    public static final String SET_METHOD_WORKAROUND =
            "jersey.config.client.httpUrlConnection.setMethodWorkaround";
    
    private static final ConnectionFactory DEFAULT_CONNECTION_FACTORY = new DefaultConnectionFactory();

    private static final Logger LOGGER = Logger.getLogger(HttpUrlConnectorProvider.class.getName());

    private ConnectionFactory connectionFactory;
    private int chunkSize;
    private boolean useFixedLengthStreaming;
    private boolean useSetMethodWorkaround;

    
    public HttpUrlConnectorProvider() {
        this.connectionFactory = DEFAULT_CONNECTION_FACTORY;
        this.chunkSize = ClientProperties.DEFAULT_CHUNK_SIZE;
        this.useFixedLengthStreaming = false;
        this.useSetMethodWorkaround = false;
    }

    
    public HttpUrlConnectorProvider connectionFactory(final ConnectionFactory connectionFactory) {
        if (connectionFactory == null) {
            throw new NullPointerException(LocalizationMessages.NULL_INPUT_PARAMETER("connectionFactory"));
        }

        this.connectionFactory = connectionFactory;
        return this;
    }

    
    public HttpUrlConnectorProvider chunkSize(final int chunkSize) {
        if (chunkSize < 0) {
            throw new IllegalArgumentException(LocalizationMessages.NEGATIVE_INPUT_PARAMETER("chunkSize"));
        }
        this.chunkSize = chunkSize;
        return this;
    }

    
    public HttpUrlConnectorProvider useFixedLengthStreaming() {
        this.useFixedLengthStreaming = true;
        return this;
    }

    
    public HttpUrlConnectorProvider useSetMethodWorkaround() {
        this.useSetMethodWorkaround = true;
        return this;
    }

    @Override
    public Connector getConnector(final Client client, final Configuration config) {
        final Map<String, Object> properties = config.getProperties();

        int computedChunkSize = ClientProperties.getValue(properties,
                ClientProperties.CHUNKED_ENCODING_SIZE, chunkSize, Integer.class);
        if (computedChunkSize < 0) {
            LOGGER.warning(LocalizationMessages.NEGATIVE_CHUNK_SIZE(computedChunkSize, chunkSize));
            computedChunkSize = chunkSize;
        }

        final boolean computedUseFixedLengthStreaming = ClientProperties.getValue(properties,
                USE_FIXED_LENGTH_STREAMING, useFixedLengthStreaming, Boolean.class);
        final boolean computedUseSetMethodWorkaround = ClientProperties.getValue(properties,
                SET_METHOD_WORKAROUND, useSetMethodWorkaround, Boolean.class);

        return createHttpUrlConnector(client, connectionFactory, computedChunkSize, computedUseFixedLengthStreaming,
                                      computedUseSetMethodWorkaround);
    }

    
    protected Connector createHttpUrlConnector(Client client, ConnectionFactory connectionFactory,
                                               int chunkSize, boolean fixLengthStreaming,
                                               boolean setMethodWorkaround) {
        return new HttpUrlConnector(
                client,
                connectionFactory,
                chunkSize,
                fixLengthStreaming,
                setMethodWorkaround);
    }

    
    public interface ConnectionFactory {

        
        public HttpURLConnection getConnection(URL url) throws IOException;
    }

    private static class DefaultConnectionFactory implements ConnectionFactory {

        @Override
        public HttpURLConnection getConnection(final URL url) throws IOException {
            return (HttpURLConnection) url.openConnection();
        }
    }

    @Override
    public boolean equals(final Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        final HttpUrlConnectorProvider that = (HttpUrlConnectorProvider) o;

        if (chunkSize != that.chunkSize) {
            return false;
        }
        if (useFixedLengthStreaming != that.useFixedLengthStreaming) {
            return false;
        }

        return connectionFactory.equals(that.connectionFactory);
    }

    @Override
    public int hashCode() {
        int result = connectionFactory.hashCode();
        result = 31 * result + chunkSize;
        result = 31 * result + (useFixedLengthStreaming ? 1 : 0);
        return result;
    }
}

<code block>

package org.glassfish.jersey.client.internal;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.reflect.Field;
import java.net.HttpURLConnection;
import java.net.ProtocolException;
import java.net.URI;
import java.net.URISyntaxException;
import java.security.AccessController;
import java.security.PrivilegedActionException;
import java.security.PrivilegedExceptionAction;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Future;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.ws.rs.ProcessingException;
import javax.ws.rs.client.Client;
import javax.ws.rs.core.MultivaluedMap;
import javax.ws.rs.core.Response;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLSocketFactory;

import org.glassfish.jersey.client.ClientProperties;
import org.glassfish.jersey.client.ClientRequest;
import org.glassfish.jersey.client.ClientResponse;
import org.glassfish.jersey.client.HttpUrlConnectorProvider;
import org.glassfish.jersey.client.RequestEntityProcessing;
import org.glassfish.jersey.client.spi.AsyncConnectorCallback;
import org.glassfish.jersey.client.spi.Connector;
import org.glassfish.jersey.internal.util.PropertiesHelper;
import org.glassfish.jersey.internal.util.collection.LazyValue;
import org.glassfish.jersey.internal.util.collection.UnsafeValue;
import org.glassfish.jersey.internal.util.collection.Value;
import org.glassfish.jersey.internal.util.collection.Values;
import org.glassfish.jersey.message.internal.OutboundMessageContext;
import org.glassfish.jersey.message.internal.Statuses;

import jersey.repackaged.com.google.common.base.Predicates;
import jersey.repackaged.com.google.common.collect.Maps;
import jersey.repackaged.com.google.common.util.concurrent.MoreExecutors;


public class HttpUrlConnector implements Connector {

    private static final Logger LOGGER = Logger.getLogger(HttpUrlConnector.class.getName());
    private static final String ALLOW_RESTRICTED_HEADERS_SYSTEM_PROPERTY = "sun.net.http.allowRestrictedHeaders";
    
    private static final String[] restrictedHeaders = {
            "Access-Control-Request-Headers",
            "Access-Control-Request-Method",
            "Connection", 
            "Content-Length",
            "Content-Transfer-Encoding",
            "Host",
            "Keep-Alive",
            "Origin",
            "Trailer",
            "Transfer-Encoding",
            "Upgrade",
            "Via"
    };

    private static final Set<String> restrictedHeaderSet = new HashSet<String>(restrictedHeaders.length);

    static {
        for (String headerName : restrictedHeaders) {
            restrictedHeaderSet.add(headerName.toLowerCase());
        }
    }

    private final HttpUrlConnectorProvider.ConnectionFactory connectionFactory;
    private final int chunkSize;
    private final boolean fixLengthStreaming;
    private final boolean setMethodWorkaround;
    private final boolean isRestrictedHeaderPropertySet;
    private final LazyValue<SSLSocketFactory> sslSocketFactory;

    
    public HttpUrlConnector(
            final Client client,
            final HttpUrlConnectorProvider.ConnectionFactory connectionFactory,
            final int chunkSize,
            final boolean fixLengthStreaming,
            final boolean setMethodWorkaround) {

        sslSocketFactory = Values.lazy(new Value<SSLSocketFactory>() {
            @Override
            public SSLSocketFactory get() {
                return client.getSslContext().getSocketFactory();
            }
        });

        this.connectionFactory = connectionFactory;
        this.chunkSize = chunkSize;
        this.fixLengthStreaming = fixLengthStreaming;
        this.setMethodWorkaround = setMethodWorkaround;

        
        
        
        isRestrictedHeaderPropertySet = Boolean.valueOf(AccessController.doPrivileged(
                PropertiesHelper.getSystemProperty(ALLOW_RESTRICTED_HEADERS_SYSTEM_PROPERTY, "false")
        ));

        LOGGER.config(isRestrictedHeaderPropertySet
                        ? LocalizationMessages.RESTRICTED_HEADER_PROPERTY_SETTING_TRUE(ALLOW_RESTRICTED_HEADERS_SYSTEM_PROPERTY)
                        : LocalizationMessages.RESTRICTED_HEADER_PROPERTY_SETTING_FALSE(ALLOW_RESTRICTED_HEADERS_SYSTEM_PROPERTY)
        );
    }

    private static InputStream getInputStream(final HttpURLConnection uc) throws IOException {
        return new InputStream() {
            private final UnsafeValue<InputStream, IOException> in = Values.lazy(new UnsafeValue<InputStream, IOException>() {
                @Override
                public InputStream get() throws IOException {
                    if (uc.getResponseCode() < Response.Status.BAD_REQUEST.getStatusCode()) {
                        return uc.getInputStream();
                    } else {
                        InputStream ein = uc.getErrorStream();
                        return (ein != null) ? ein : new ByteArrayInputStream(new byte[0]);
                    }
                }
            });

            @Override
            public int read() throws IOException {
                return in.get().read();
            }

            @Override
            public int read(byte[] b) throws IOException {
                return in.get().read(b);
            }

            @Override
            public int read(byte[] b, int off, int len) throws IOException {
                return in.get().read(b, off, len);
            }

            @Override
            public long skip(long n) throws IOException {
                return in.get().skip(n);
            }

            @Override
            public int available() throws IOException {
                return in.get().available();
            }

            @Override
            public void close() throws IOException {
                in.get().close();
            }

            @Override
            public void mark(int readLimit) {
                try {
                    in.get().mark(readLimit);
                } catch (IOException e) {
                    throw new IllegalStateException("Unable to retrieve the underlying input stream.", e);
                }
            }

            @Override
            public void reset() throws IOException {
                in.get().reset();
            }

            @Override
            public boolean markSupported() {
                try {
                    return in.get().markSupported();
                } catch (IOException e) {
                    throw new IllegalStateException("Unable to retrieve the underlying input stream.", e);
                }
            }
        };
    }

    @Override
    public ClientResponse apply(ClientRequest request) {
        try {
            return _apply(request);
        } catch (IOException ex) {
            throw new ProcessingException(ex);
        }
    }

    @Override
    public Future<?> apply(final ClientRequest request, final AsyncConnectorCallback callback) {
        return MoreExecutors.sameThreadExecutor().submit(new Runnable() {
            @Override
            public void run() {
                try {
                    callback.response(_apply(request));
                } catch (IOException ex) {
                    callback.failure(new ProcessingException(ex));
                } catch (Throwable t) {
                    callback.failure(t);
                }
            }
        });
    }

    @Override
    public void close() {
        
    }

    
    protected void secureConnection(final Client client, final HttpURLConnection uc) {
        if (uc instanceof HttpsURLConnection) {
            HttpsURLConnection suc = (HttpsURLConnection) uc;

            final HostnameVerifier verifier = client.getHostnameVerifier();
            if (verifier != null) {
                suc.setHostnameVerifier(verifier);
            }
            suc.setSSLSocketFactory(sslSocketFactory.get());
        }
    }

    private ClientResponse _apply(final ClientRequest request) throws IOException {
        final HttpURLConnection uc;

        uc = this.connectionFactory.getConnection(request.getUri().toURL());
        uc.setDoInput(true);

        final String httpMethod = request.getMethod();
        if (request.resolveProperty(HttpUrlConnectorProvider.SET_METHOD_WORKAROUND, setMethodWorkaround)) {
            setRequestMethodViaJreBugWorkaround(uc, httpMethod);
        } else {
            uc.setRequestMethod(httpMethod);
        }

        uc.setInstanceFollowRedirects(request.resolveProperty(ClientProperties.FOLLOW_REDIRECTS, true));

        uc.setConnectTimeout(request.resolveProperty(ClientProperties.CONNECT_TIMEOUT, uc.getConnectTimeout()));

        uc.setReadTimeout(request.resolveProperty(ClientProperties.READ_TIMEOUT, uc.getReadTimeout()));

        secureConnection(request.getClient(), uc);

        final Object entity = request.getEntity();
        if (entity != null) {
            RequestEntityProcessing entityProcessing = request.resolveProperty(
                    ClientProperties.REQUEST_ENTITY_PROCESSING, RequestEntityProcessing.class);

            if (entityProcessing == null || entityProcessing != RequestEntityProcessing.BUFFERED) {
                final int length = request.getLength();
                if (fixLengthStreaming && length > 0) {
                    uc.setFixedLengthStreamingMode(length);
                } else if (entityProcessing == RequestEntityProcessing.CHUNKED) {
                    uc.setChunkedStreamingMode(chunkSize);
                }
            }
            uc.setDoOutput(true);

            if ("GET".equalsIgnoreCase(httpMethod)) {
                final Logger logger = Logger.getLogger(HttpUrlConnector.class.getName());
                if (logger.isLoggable(Level.INFO)) {
                    logger.log(Level.INFO, LocalizationMessages.HTTPURLCONNECTION_REPLACES_GET_WITH_ENTITY());
                }
            }

            request.setStreamProvider(new OutboundMessageContext.StreamProvider() {

                @Override
                public OutputStream getOutputStream(int contentLength) throws IOException {
                    setOutboundHeaders(request.getStringHeaders(), uc);
                    return uc.getOutputStream();
                }
            });
            request.writeEntity();

        } else {
            setOutboundHeaders(request.getStringHeaders(), uc);
        }

        final int code = uc.getResponseCode();
        final String reasonPhrase = uc.getResponseMessage();
        final Response.StatusType status =
                reasonPhrase == null ? Statuses.from(code) : Statuses.from(code, reasonPhrase);
        final URI resolvedRequestUri;
        try {
            resolvedRequestUri = uc.getURL().toURI();
        } catch (URISyntaxException e) {
            throw new ProcessingException(e);
        }

        ClientResponse responseContext = new ClientResponse(status, request, resolvedRequestUri);
        responseContext.headers(Maps.filterKeys(uc.getHeaderFields(), Predicates.notNull()));
        responseContext.setEntityStream(getInputStream(uc));

        return responseContext;
    }

    private void setOutboundHeaders(MultivaluedMap<String, String> headers, HttpURLConnection uc) {
        boolean restrictedSent = false;
        for (Map.Entry<String, List<String>> header : headers.entrySet()) {
            String headerName = header.getKey();
            String headerValue;

            List<String> headerValues = header.getValue();
            if (headerValues.size() == 1) {
                headerValue = headerValues.get(0);
                uc.setRequestProperty(headerName, headerValue);
            } else {
                StringBuilder b = new StringBuilder();
                boolean add = false;
                for (Object value : headerValues) {
                    if (add) {
                        b.append(',');
                    }
                    add = true;
                    b.append(value);
                }
                headerValue = b.toString();
                uc.setRequestProperty(headerName, headerValue);
            }
            
            if (!isRestrictedHeaderPropertySet && !restrictedSent) {
                if (isHeaderRestricted(headerName, headerValue)) {
                    restrictedSent = true;
                }
            }
        }
        if (restrictedSent) {
            LOGGER.warning(LocalizationMessages.RESTRICTED_HEADER_POSSIBLY_IGNORED(ALLOW_RESTRICTED_HEADERS_SYSTEM_PROPERTY));
        }
    }

    private boolean isHeaderRestricted(String name, String value) {
        name = name.toLowerCase();
        return name.startsWith("sec-")
                || restrictedHeaderSet.contains(name)
                && !("connection".equalsIgnoreCase(name) && "close".equalsIgnoreCase(value));
    }

    
    private static void setRequestMethodViaJreBugWorkaround(final HttpURLConnection httpURLConnection,
                                                            final String method) {
        try {
            httpURLConnection.setRequestMethod(method); 
        } catch (final ProtocolException pe) {
            try {
                AccessController
                        .doPrivileged(new PrivilegedExceptionAction<Object>() {
                            @Override
                            public Object run() throws NoSuchFieldException,
                                    IllegalAccessException {
                                try {
                                    httpURLConnection.setRequestMethod(method);
                                    
                                    
                                } catch (final ProtocolException pe) {
                                    Class<?> connectionClass = httpURLConnection
                                            .getClass();
                                    try {
                                        final Field delegateField = connectionClass.getDeclaredField("delegate");
                                        delegateField.setAccessible(true);

                                        HttpURLConnection delegateConnection =
                                                (HttpURLConnection) delegateField.get(httpURLConnection);
                                        setRequestMethodViaJreBugWorkaround(delegateConnection, method);
                                    } catch (NoSuchFieldException e) {
                                        
                                    } catch (IllegalArgumentException e) {
                                        throw new RuntimeException(e);
                                    } catch (IllegalAccessException e) {
                                        throw new RuntimeException(e);
                                    }
                                    try {
                                        Field methodField;
                                        while (connectionClass != null) {
                                            try {
                                                methodField = connectionClass
                                                        .getDeclaredField("method");
                                            } catch (NoSuchFieldException e) {
                                                connectionClass = connectionClass
                                                        .getSuperclass();
                                                continue;
                                            }
                                            methodField.setAccessible(true);
                                            methodField.set(httpURLConnection, method);
                                            break;
                                        }
                                    } catch (final Exception e) {
                                        throw new RuntimeException(e);
                                    }
                                }
                                return null;
                            }
                        });
            } catch (final PrivilegedActionException e) {
                final Throwable cause = e.getCause();
                if (cause instanceof RuntimeException) {
                    throw (RuntimeException) cause;
                } else {
                    throw new RuntimeException(cause);
                }
            }
        }
    }

    @Override
    public String getName() {
        return "HttpUrlConnection " + AccessController.doPrivileged(PropertiesHelper.getSystemProperty("java.version"));
    }
}

<code block>

package org.glassfish.jersey.client;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.ProtocolException;
import java.net.SocketTimeoutException;
import java.net.URI;
import java.net.URL;
import java.security.Permission;
import java.security.Principal;
import java.security.cert.Certificate;
import java.util.List;
import java.util.Map;

import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.client.Entity;
import javax.ws.rs.client.Invocation;
import javax.ws.rs.client.WebTarget;
import javax.ws.rs.core.HttpHeaders;
import javax.ws.rs.core.Link;
import javax.ws.rs.core.Response;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLPeerUnverifiedException;
import javax.net.ssl.SSLSocketFactory;

import org.glassfish.jersey.client.internal.HttpUrlConnector;

import org.junit.Assert;
import org.junit.Ignore;
import org.junit.Test;
import static org.junit.Assert.assertEquals;


public class HttpUrlConnectorTest {

    
    private final int TimeoutBASE = 500;

    
    @Test
    @Ignore
    public void testConnectionTimeoutWithEntity() {
        _testInvocationTimeout(createNonRoutableTarget().request().buildPost(Entity.text("does not matter")));
    }

    
    @Test
    @Ignore
    public void testConnectionTimeoutNoEntity() {
        _testInvocationTimeout(createNonRoutableTarget().request().buildGet());
    }

    
    @Test
    public void testResolvedRequestUri() {
        HttpUrlConnectorProvider.ConnectionFactory factory = new HttpUrlConnectorProvider.ConnectionFactory() {
            @Override
            public HttpURLConnection getConnection(URL endpointUrl) throws IOException {
                HttpURLConnection result = (HttpURLConnection) endpointUrl.openConnection();
                return wrapRedirectedHttp(result);
            }
        };
        JerseyClient client = new JerseyClientBuilder().build();

        ClientRequest request = client.target("http:
        final HttpUrlConnectorProvider connectorProvider = new HttpUrlConnectorProvider().connectionFactory(factory);
        HttpUrlConnector connector = (HttpUrlConnector) connectorProvider.getConnector(client, client.getConfiguration());
        ClientResponse res = connector.apply(request);
        assertEquals(URI.create("http:
        assertEquals(URI.create("http:


        res.getHeaders().putSingle(HttpHeaders.LINK, Link.fromPath("action").rel("test").build().toString());
                assertEquals(URI.create("http:
    }

    private HttpURLConnection wrapRedirectedHttp(final HttpURLConnection connection) {
        if (connection instanceof HttpsURLConnection) {
            return connection;
        }

        return new HttpURLConnection(connection.getURL()) {

            @Override
            public URL getURL() {
                return url;
            }

            @Override
            public int getResponseCode() throws IOException {
                
                url = new URL("http:
                
                return Response.Status.NO_CONTENT.getStatusCode();
            }

            @Override
            public String getResponseMessage() throws IOException {
                return Response.Status.NO_CONTENT.getReasonPhrase();
            }

            
            
            public long getContentLengthLong() {
                return connection.getContentLength();
                
                
            }

            
            
            public long getHeaderFieldLong(String name, long Default) {
                return connection.getHeaderFieldInt(name, (int) Default);
                
                
            }

            
            
            public void setFixedLengthStreamingMode(long contentLength) {
                
                
            }

            @Override
            public void setInstanceFollowRedirects(boolean followRedirects) {
                connection.setInstanceFollowRedirects(followRedirects);
            }

            @Override
            public boolean getInstanceFollowRedirects() {
                return connection.getInstanceFollowRedirects();
            }

            @Override
            public void setRequestMethod(String method) throws ProtocolException {
                connection.setRequestMethod(method);
            }

            @Override
            public String getRequestMethod() {
                return connection.getRequestMethod();
            }

            @Override
            public long getHeaderFieldDate(String name, long Default) {
                return connection.getHeaderFieldDate(name, Default);
            }

            @Override
            public void disconnect() {
                connection.disconnect();
            }

            @Override
            public boolean usingProxy() {
                return connection.usingProxy();
            }

            @Override
            public Permission getPermission() throws IOException {
                return connection.getPermission();
            }

            @Override
            public InputStream getErrorStream() {
                return connection.getErrorStream();
            }

            @Override
            public String getHeaderField(int n) {
                return connection.getHeaderField(n);
            }

            @Override
            public void setChunkedStreamingMode(int chunklen) {
                connection.setChunkedStreamingMode(chunklen);
            }

            @Override
            public void setFixedLengthStreamingMode(int contentLength) {
                connection.setFixedLengthStreamingMode(contentLength);
            }

            @Override
            public String getHeaderFieldKey(int n) {
                return connection.getHeaderFieldKey(n);
            }

            @Override
            public void connect() throws IOException {
                connection.connect();
            }

            @Override
            public void setConnectTimeout(int timeout) {
                connection.setConnectTimeout(timeout);
            }

            @Override
            public int getConnectTimeout() {
                return connection.getConnectTimeout();
            }

            @Override
            public void setReadTimeout(int timeout) {
                connection.setReadTimeout(timeout);
            }

            @Override
            public int getReadTimeout() {
                return connection.getReadTimeout();
            }

            @Override
            public int getContentLength() {
                return connection.getContentLength();
            }

            @Override
            public String getContentType() {
                return connection.getContentType();
            }

            @Override
            public String getContentEncoding() {
                return connection.getContentEncoding();
            }

            @Override
            public long getExpiration() {
                return connection.getExpiration();
            }

            @Override
            public long getDate() {
                return connection.getDate();
            }

            @Override
            public long getLastModified() {
                return connection.getLastModified();
            }

            @Override
            public String getHeaderField(String name) {
                return connection.getHeaderField(name);
            }

            @Override
            public Map<String, List<String>> getHeaderFields() {
                return connection.getHeaderFields();
            }

            @Override
            public int getHeaderFieldInt(String name, int Default) {
                return connection.getHeaderFieldInt(name, Default);
            }

            @Override
            public Object getContent() throws IOException {
                return connection.getContent();
            }

            @Override
            public Object getContent(Class[] classes) throws IOException {
                return connection.getContent(classes);
            }

            @Override
            public InputStream getInputStream() throws IOException {
                return connection.getInputStream();
            }

            @Override
            public OutputStream getOutputStream() throws IOException {
                return connection.getOutputStream();
            }

            @Override
            public String toString() {
                return connection.toString();
            }

            @Override
            public void setDoInput(boolean doinput) {
                connection.setDoInput(doinput);
            }

            @Override
            public boolean getDoInput() {
                return connection.getDoInput();
            }

            @Override
            public void setDoOutput(boolean dooutput) {
                connection.setDoOutput(dooutput);
            }

            @Override
            public boolean getDoOutput() {
                return connection.getDoOutput();
            }

            @Override
            public void setAllowUserInteraction(boolean allowuserinteraction) {
                connection.setAllowUserInteraction(allowuserinteraction);
            }

            @Override
            public boolean getAllowUserInteraction() {
                return connection.getAllowUserInteraction();
            }

            @Override
            public void setUseCaches(boolean usecaches) {
                connection.setUseCaches(usecaches);
            }

            @Override
            public boolean getUseCaches() {
                return connection.getUseCaches();
            }

            @Override
            public void setIfModifiedSince(long ifmodifiedsince) {
                connection.setIfModifiedSince(ifmodifiedsince);
            }

            @Override
            public long getIfModifiedSince() {
                return connection.getIfModifiedSince();
            }

            @Override
            public boolean getDefaultUseCaches() {
                return connection.getDefaultUseCaches();
            }

            @Override
            public void setDefaultUseCaches(boolean defaultusecaches) {
                connection.setDefaultUseCaches(defaultusecaches);
            }

            @Override
            public void setRequestProperty(String key, String value) {
                connection.setRequestProperty(key, value);
            }

            @Override
            public void addRequestProperty(String key, String value) {
                connection.addRequestProperty(key, value);
            }

            @Override
            public String getRequestProperty(String key) {
                return connection.getRequestProperty(key);
            }

            @Override
            public Map<String, List<String>> getRequestProperties() {
                return connection.getRequestProperties();
            }
        };

    }

    private void _testInvocationTimeout(Invocation invocation) {

        final long start = System.currentTimeMillis();

        try {
            invocation.invoke();

            Assert.fail("Timeout expected!");

        } catch (Exception ex) {

            Assert.assertTrue(String.format("Bad exception, %s, caught! Timeout expected.", ex.getCause()),
                    ex.getCause() instanceof SocketTimeoutException);

            final long stop = System.currentTimeMillis();
            long time = stop - start;

            Assert.assertTrue(
               String.format(
                    "Actual time, %d ms, should not be more than twice as longer as the original timeout, %d ms",
                                 time,                                                              TimeoutBASE),
               time < 2 * TimeoutBASE);
        }
    }

    
    @Test
    public void testSSLConnection() {
        JerseyClient client = new JerseyClientBuilder().build();
        ClientRequest request = client.target("https:
        HttpUrlConnectorProvider.ConnectionFactory factory = new HttpUrlConnectorProvider.ConnectionFactory() {
            @Override
            public HttpURLConnection getConnection(URL endpointUrl) throws IOException {
                HttpURLConnection result = (HttpURLConnection) endpointUrl.openConnection();
                return wrapNoContentHttps(result);
            }
        };
        final HttpUrlConnectorProvider connectorProvider = new HttpUrlConnectorProvider().connectionFactory(factory);
        HttpUrlConnector connector = (HttpUrlConnector) connectorProvider.getConnector(client, client.getConfiguration());
        ClientResponse res = connector.apply(request);
        assertEquals(Response.Status.NO_CONTENT.getStatusCode(), res.getStatusInfo().getStatusCode());
        assertEquals(Response.Status.NO_CONTENT.getReasonPhrase(), res.getStatusInfo().getReasonPhrase());
    }

    private HttpURLConnection wrapNoContentHttps(final HttpURLConnection result) {
        if (result instanceof HttpsURLConnection) {
            return new HttpsURLConnection(result.getURL()) {
                private final HttpsURLConnection delegate = (HttpsURLConnection) result;

                @Override
                public int getResponseCode() throws IOException {
                    return Response.Status.NO_CONTENT.getStatusCode();
                }

                @Override
                public String getResponseMessage() throws IOException {
                    return Response.Status.NO_CONTENT.getReasonPhrase();
                }

                
                
                public long getContentLengthLong() {
                    return delegate.getContentLength();
                    
                    
                }

                
                
                public long getHeaderFieldLong(String name, long Default) {
                    return delegate.getHeaderFieldInt(name, (int) Default);
                    
                    
                }

                
                
                public void setFixedLengthStreamingMode(long contentLength) {
                    
                    
                }

                @Override
                public String getHeaderFieldKey(int n) {
                    return delegate.getHeaderFieldKey(n);
                }

                @Override
                public String getHeaderField(int n) {
                    return delegate.getHeaderField(n);
                }

                @Override
                public void connect() throws IOException {
                    delegate.connect();
                }

                @Override
                public boolean getInstanceFollowRedirects() {
                    return delegate.getInstanceFollowRedirects();
                }

                @Override
                public int getConnectTimeout() {
                    return delegate.getConnectTimeout();
                }

                @Override
                public int getContentLength() {
                    return delegate.getContentLength();
                }

                @Override
                public String getContentType() {
                    return delegate.getContentType();
                }

                @Override
                public long getHeaderFieldDate(String name, long Default) {
                    return delegate.getHeaderFieldDate(name, Default);
                }

                @Override
                public String getContentEncoding() {
                    return delegate.getContentEncoding();
                }

                @Override
                public void disconnect() {
                    delegate.disconnect();
                }

                @Override
                public long getExpiration() {
                    return delegate.getExpiration();
                }

                @Override
                public long getDate() {
                    return delegate.getDate();
                }

                @Override
                public InputStream getErrorStream() {
                    return delegate.getErrorStream();
                }

                @Override
                public long getLastModified() {
                    return delegate.getLastModified();
                }

                @Override
                public String getHeaderField(String name) {
                    return delegate.getHeaderField(name);
                }

                @Override
                public Map<String, List<String>> getHeaderFields() {
                    return delegate.getHeaderFields();
                }

                @Override
                public int getHeaderFieldInt(String name, int Default) {
                    return delegate.getHeaderFieldInt(name, Default);
                }

                @Override
                public Object getContent() throws IOException {
                    return delegate.getContent();
                }

                @Override
                public Object getContent(@SuppressWarnings("rawtypes") Class[] classes) throws IOException {
                    return delegate.getContent(classes);
                }

                @Override
                public InputStream getInputStream() throws IOException {
                    return delegate.getInputStream();
                }

                @Override
                public boolean getDoInput() {
                    return delegate.getDoInput();
                }

                @Override
                public boolean getDoOutput() {
                    return delegate.getDoOutput();
                }

                @Override
                public boolean getAllowUserInteraction() {
                    return delegate.getAllowUserInteraction();
                }

                @Override
                public void addRequestProperty(String key, String value) {
                    delegate.addRequestProperty(key, value);
                }

                @Override
                public String getCipherSuite() {
                    return delegate.getCipherSuite();
                }

                @Override
                public boolean getDefaultUseCaches() {
                    return delegate.getDefaultUseCaches();
                }

                @Override
                public HostnameVerifier getHostnameVerifier() {
                    return delegate.getHostnameVerifier();
                }

                @Override
                public long getIfModifiedSince() {
                    return delegate.getIfModifiedSince();
                }

                @Override
                public Certificate[] getLocalCertificates() {
                    return delegate.getLocalCertificates();
                }

                @Override
                public Principal getLocalPrincipal() {
                    return delegate.getLocalPrincipal();
                }

                @Override
                public void setFixedLengthStreamingMode(int contentLength) {
                    delegate.setFixedLengthStreamingMode(contentLength);
                }

                @Override
                public void setChunkedStreamingMode(int chunklen) {
                    delegate.setChunkedStreamingMode(chunklen);
                }

                @Override
                public void setConnectTimeout(int timeout) {
                    delegate.setConnectTimeout(timeout);
                }

                @Override
                public OutputStream getOutputStream() throws IOException {
                    return delegate.getOutputStream();
                }

                @Override
                public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
                    return delegate.getPeerPrincipal();
                }

                @Override
                public void setInstanceFollowRedirects(boolean followRedirects) {
                    delegate.setInstanceFollowRedirects(followRedirects);
                }

                @Override
                public void setRequestMethod(String method) throws ProtocolException {
                    delegate.setRequestMethod(method);
                }

                @Override
                public String getRequestMethod() {
                    return delegate.getRequestMethod();
                }

                @Override
                public void setReadTimeout(int timeout) {
                    delegate.setReadTimeout(timeout);
                }

                @Override
                public int getReadTimeout() {
                    return delegate.getReadTimeout();
                }

                @Override
                public URL getURL() {
                    return delegate.getURL();
                }

                @Override
                public boolean usingProxy() {
                    return delegate.usingProxy();
                }

                @Override
                public Permission getPermission() throws IOException {
                    return delegate.getPermission();
                }

                @Override
                public void setDoInput(boolean doinput) {
                    delegate.setDoInput(doinput);
                }

                @Override
                public void setDoOutput(boolean dooutput) {
                    delegate.setDoOutput(dooutput);
                }

                @Override
                public void setAllowUserInteraction(boolean allowuserinteraction) {
                    delegate.setAllowUserInteraction(allowuserinteraction);
                }

                @Override
                public void setUseCaches(boolean usecaches) {
                    delegate.setUseCaches(usecaches);
                }

                @Override
                public boolean getUseCaches() {
                    return delegate.getUseCaches();
                }

                @Override
                public void setIfModifiedSince(long ifmodifiedsince) {
                    delegate.setIfModifiedSince(ifmodifiedsince);
                }

                @Override
                public void setDefaultUseCaches(boolean defaultusecaches) {
                    delegate.setDefaultUseCaches(defaultusecaches);
                }

                @Override
                public String getRequestProperty(String key) {
                    return delegate.getRequestProperty(key);
                }

                @Override
                public Map<String, List<String>> getRequestProperties() {
                    return delegate.getRequestProperties();
                }

                @Override
                public SSLSocketFactory getSSLSocketFactory() {
                    return delegate.getSSLSocketFactory();
                }

                @Override
                public Certificate[] getServerCertificates() throws SSLPeerUnverifiedException {
                    return delegate.getServerCertificates();
                }

                @Override
                public void setHostnameVerifier(HostnameVerifier v) {
                    delegate.setHostnameVerifier(v);
                }

                @Override
                public void setRequestProperty(String key, String value) {
                    delegate.setRequestProperty(key, value);
                }

                @Override
                public void setSSLSocketFactory(SSLSocketFactory sf) {
                    delegate.setSSLSocketFactory(sf);
                }
            };
        }
        return result;
    }

    private WebTarget createNonRoutableTarget() {
        Client client = ClientBuilder.newClient();
        client.property(ClientProperties.CONNECT_TIMEOUT, TimeoutBASE);
        
        return client.target("http:
    }
}

<code block>

package org.glassfish.jersey.tests.e2e.server;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.client.WebTarget;
import javax.ws.rs.core.Application;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

import javax.xml.bind.annotation.XmlRootElement;

import org.glassfish.jersey.client.ClientConfig;
import org.glassfish.jersey.filter.LoggingFilter;
import org.glassfish.jersey.server.ResourceConfig;
import org.glassfish.jersey.test.JerseyTest;

import org.junit.Assert;
import org.junit.Test;


public class ContentNegotiationTest extends JerseyTest {

    @Path("persons")
    public static class MyResource {
        private static final Person[] LIST = new Person[] {
                new Person("Penny", 1),
                new Person("Howard", 2),
                new Person("Sheldon", 3)
        };

        @GET
        @Produces({"application/xml;qs=0.75", "application/json;qs=1.0"})
        public Person[] getList() {
            return LIST;
        }

        @GET
        @Produces({"application/json;qs=1", "application/xml;qs=0.75"})
        @Path("reordered")
        public Person[] getListReordered() {
            return LIST;
        }

        @GET
        @Produces({"application/json;qs=0.75", "application/xml;qs=1"})
        @Path("inverted")
        public Person[] getListInverted() {
            return LIST;
        }


        @GET
        @Produces({"application/xml;qs=0.75", "application/json;qs=0.9", "unknown/hello;qs=1.0"})
        @Path("unkownMT")
        public Person[] getListWithUnkownType() {
            return LIST;
        }

        @GET
        @Produces({"application/json", "application/xml", "text/plain"})
        @Path("shouldPickFirstJson")
        public Person[] getJsonArrayUnlessOtherwiseSpecified() {
            return LIST;
        }

        @GET
        @Produces({"application/xml", "text/plain", "application/json"})
        @Path("shouldPickFirstXml")
        public Person[] getXmlUnlessOtherwiseSpecified() {
            return LIST;
        }

        @GET
        @Produces("application/json;qs=0.75")
        @Path("twoMethodsOneEndpoint")
        public Person[] getJsonArray() {
            return LIST;
        }

        @GET
        @Produces("application/xml;qs=1")
        @Path("twoMethodsOneEndpoint")
        public Person[] getXml() {
            return LIST;
        }
    }

    @XmlRootElement
    public static class Person {
        private String name;
        private int age;

        public Person() {
        }

        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public int getAge() {
            return age;
        }

        public void setAge(int age) {
            this.age = age;
        }

        @Override
        public String toString() {
            return name + "(" + age + ")";
        }
    }

    @Override
    protected void configureClient(ClientConfig config) {
        config.register(LoggingFilter.class);
    }

    @Override
    protected Application configure() {
        return new ResourceConfig(MyResource.class);
    }

    
    @Test
    public void testWithoutDefinedRequestedMediaType() {
        WebTarget target = target().path("/persons");
        Response response = target.request().get();
        Assert.assertEquals(200, response.getStatus());
        Assert.assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getMediaType());
    }

    @Test
    public void testWithoutDefinedRequestedMediaTypeAndTwoMethods() {
        
        
        
        Response response = target().path("/persons/twoMethodsOneEndpoint").request().get();
        Assert.assertEquals(200, response.getStatus());
        Assert.assertEquals(MediaType.APPLICATION_XML_TYPE, response.getMediaType());
    }

    @Test
    public void testWithoutDefinedRequestedMediaTypeOrQualityModifiersJson() {
        Response response = target().path("/persons/shouldPickFirstJson").request().get();
        Assert.assertEquals(200, response.getStatus());
        Assert.assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getMediaType());
    }

    @Test
    public void testWithoutDefinedRequestedMediaTypeOrQualityModifiersXml() {
        Response response = target().path("/persons/shouldPickFirstXml").request().get();
        Assert.assertEquals(200, response.getStatus());
        Assert.assertEquals(MediaType.APPLICATION_XML_TYPE, response.getMediaType());
    }

    @Test
    public void test() {
        WebTarget target = target().path("/persons");
        Response response = target.request(MediaType.WILDCARD).get();
        Assert.assertEquals(200, response.getStatus());
        Assert.assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getMediaType());
    }

    @Test
    public void testInverted() {
        WebTarget target = target().path("/persons/inverted");
        Response response = target.request(MediaType.WILDCARD).get();
        Assert.assertEquals(200, response.getStatus());
        Assert.assertEquals(MediaType.APPLICATION_XML_TYPE, response.getMediaType());
    }

    @Test
    public void testInvertedWithJSONPreferredByClient() {
        WebTarget target = target().path("/persons/inverted");
        Response response = target.request("application/json;q=1.0", "application/xml;q=0.8").get();
        Assert.assertEquals(200, response.getStatus());
        Assert.assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getMediaType());
    }

    @Test
    public void testReordered() {
        WebTarget target = target().path("/persons/reordered");
        Response response = target.request(MediaType.WILDCARD).get();
        Assert.assertEquals(200, response.getStatus());
        Assert.assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getMediaType());
    }

    
    @Test
    public void testWithUnknownTypePreferredByClient() {
        WebTarget target = target().path("/persons/reordered");
        Response response = target.request("application/json;q=0.8", "application/xml;q=0.9",
                "unknown/hello;qs=1.0").get();
        Assert.assertEquals(200, response.getStatus());
        Assert.assertEquals(MediaType.APPLICATION_XML_TYPE, response.getMediaType());
    }
}

<code block>

package org.glassfish.jersey.client;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.reflect.Field;
import java.net.HttpURLConnection;
import java.net.ProtocolException;
import java.net.URI;
import java.net.URISyntaxException;
import java.security.AccessController;
import java.security.PrivilegedActionException;
import java.security.PrivilegedExceptionAction;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Future;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.ws.rs.ProcessingException;
import javax.ws.rs.client.Client;
import javax.ws.rs.core.MultivaluedMap;
import javax.ws.rs.core.Response;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLSocketFactory;

import org.glassfish.jersey.client.internal.LocalizationMessages;
import org.glassfish.jersey.client.spi.AsyncConnectorCallback;
import org.glassfish.jersey.client.spi.Connector;
import org.glassfish.jersey.internal.util.PropertiesHelper;
import org.glassfish.jersey.internal.util.collection.LazyValue;
import org.glassfish.jersey.internal.util.collection.UnsafeValue;
import org.glassfish.jersey.internal.util.collection.Value;
import org.glassfish.jersey.internal.util.collection.Values;
import org.glassfish.jersey.message.internal.OutboundMessageContext;
import org.glassfish.jersey.message.internal.Statuses;

import jersey.repackaged.com.google.common.base.Predicates;
import jersey.repackaged.com.google.common.collect.Maps;
import jersey.repackaged.com.google.common.util.concurrent.MoreExecutors;


class HttpUrlConnector implements Connector {

    private static final Logger LOGGER = Logger.getLogger(HttpUrlConnector.class.getName());
    private static final String ALLOW_RESTRICTED_HEADERS_SYSTEM_PROPERTY = "sun.net.http.allowRestrictedHeaders";
    
    private static final String[] restrictedHeaders = {
            "Access-Control-Request-Headers",
            "Access-Control-Request-Method",
            "Connection", 
            "Content-Length",
            "Content-Transfer-Encoding",
            "Host",
            "Keep-Alive",
            "Origin",
            "Trailer",
            "Transfer-Encoding",
            "Upgrade",
            "Via"
    };

    private static final Set<String> restrictedHeaderSet = new HashSet<String>(restrictedHeaders.length);

    static {
        for (String headerName : restrictedHeaders) {
            restrictedHeaderSet.add(headerName.toLowerCase());
        }
    }

    private final HttpUrlConnectorProvider.ConnectionFactory connectionFactory;
    private final int chunkSize;
    private final boolean fixLengthStreaming;
    private final boolean setMethodWorkaround;
    private final boolean isRestrictedHeaderPropertySet;
    private final LazyValue<SSLSocketFactory> sslSocketFactory;

    
    HttpUrlConnector(
            final Client client,
            final HttpUrlConnectorProvider.ConnectionFactory connectionFactory,
            final int chunkSize,
            final boolean fixLengthStreaming,
            final boolean setMethodWorkaround) {

        sslSocketFactory = Values.lazy(new Value<SSLSocketFactory>() {
            @Override
            public SSLSocketFactory get() {
                return client.getSslContext().getSocketFactory();
            }
        });

        this.connectionFactory = connectionFactory;
        this.chunkSize = chunkSize;
        this.fixLengthStreaming = fixLengthStreaming;
        this.setMethodWorkaround = setMethodWorkaround;

        
        
        
        isRestrictedHeaderPropertySet = Boolean.valueOf(AccessController.doPrivileged(
                PropertiesHelper.getSystemProperty(ALLOW_RESTRICTED_HEADERS_SYSTEM_PROPERTY, "false")
        ));

        LOGGER.config(isRestrictedHeaderPropertySet
                        ? LocalizationMessages.RESTRICTED_HEADER_PROPERTY_SETTING_TRUE(ALLOW_RESTRICTED_HEADERS_SYSTEM_PROPERTY)
                        : LocalizationMessages.RESTRICTED_HEADER_PROPERTY_SETTING_FALSE(ALLOW_RESTRICTED_HEADERS_SYSTEM_PROPERTY)
        );
    }

    private static InputStream getInputStream(final HttpURLConnection uc) throws IOException {
        return new InputStream() {
            private final UnsafeValue<InputStream, IOException> in = Values.lazy(new UnsafeValue<InputStream, IOException>() {
                @Override
                public InputStream get() throws IOException {
                    if (uc.getResponseCode() < Response.Status.BAD_REQUEST.getStatusCode()) {
                        return uc.getInputStream();
                    } else {
                        InputStream ein = uc.getErrorStream();
                        return (ein != null) ? ein : new ByteArrayInputStream(new byte[0]);
                    }
                }
            });

            @Override
            public int read() throws IOException {
                return in.get().read();
            }

            @Override
            public int read(byte[] b) throws IOException {
                return in.get().read(b);
            }

            @Override
            public int read(byte[] b, int off, int len) throws IOException {
                return in.get().read(b, off, len);
            }

            @Override
            public long skip(long n) throws IOException {
                return in.get().skip(n);
            }

            @Override
            public int available() throws IOException {
                return in.get().available();
            }

            @Override
            public void close() throws IOException {
                in.get().close();
            }

            @Override
            public void mark(int readLimit) {
                try {
                    in.get().mark(readLimit);
                } catch (IOException e) {
                    throw new IllegalStateException("Unable to retrieve the underlying input stream.", e);
                }
            }

            @Override
            public void reset() throws IOException {
                in.get().reset();
            }

            @Override
            public boolean markSupported() {
                try {
                    return in.get().markSupported();
                } catch (IOException e) {
                    throw new IllegalStateException("Unable to retrieve the underlying input stream.", e);
                }
            }
        };
    }

    @Override
    public ClientResponse apply(ClientRequest request) {
        try {
            return _apply(request);
        } catch (IOException ex) {
            throw new ProcessingException(ex);
        }
    }

    @Override
    public Future<?> apply(final ClientRequest request, final AsyncConnectorCallback callback) {
        return MoreExecutors.sameThreadExecutor().submit(new Runnable() {
            @Override
            public void run() {
                try {
                    callback.response(_apply(request));
                } catch (IOException ex) {
                    callback.failure(new ProcessingException(ex));
                } catch (Throwable t) {
                    callback.failure(t);
                }
            }
        });
    }

    @Override
    public void close() {
        
    }

    private ClientResponse _apply(final ClientRequest request) throws IOException {
        final HttpURLConnection uc;

        uc = this.connectionFactory.getConnection(request.getUri().toURL());
        uc.setDoInput(true);

        final String httpMethod = request.getMethod();
        if (request.resolveProperty(HttpUrlConnectorProvider.SET_METHOD_WORKAROUND, setMethodWorkaround)) {
            setRequestMethodViaJreBugWorkaround(uc, httpMethod);
        } else {
            uc.setRequestMethod(httpMethod);
        }

        uc.setInstanceFollowRedirects(request.resolveProperty(ClientProperties.FOLLOW_REDIRECTS, true));

        uc.setConnectTimeout(request.resolveProperty(ClientProperties.CONNECT_TIMEOUT, uc.getConnectTimeout()));

        uc.setReadTimeout(request.resolveProperty(ClientProperties.READ_TIMEOUT, uc.getReadTimeout()));

        if (uc instanceof HttpsURLConnection) {
            HttpsURLConnection suc = (HttpsURLConnection) uc;

            final JerseyClient client = request.getClient();
            final HostnameVerifier verifier = client.getHostnameVerifier();
            if (verifier != null) {
                suc.setHostnameVerifier(verifier);
            }
            suc.setSSLSocketFactory(sslSocketFactory.get());
        }

        final Object entity = request.getEntity();
        if (entity != null) {
            RequestEntityProcessing entityProcessing = request.resolveProperty(
                    ClientProperties.REQUEST_ENTITY_PROCESSING, RequestEntityProcessing.class);

            if (entityProcessing == null || entityProcessing != RequestEntityProcessing.BUFFERED) {
                final int length = request.getLength();
                if (fixLengthStreaming && length > 0) {
                    uc.setFixedLengthStreamingMode(length);
                } else if (entityProcessing == RequestEntityProcessing.CHUNKED) {
                    uc.setChunkedStreamingMode(chunkSize);
                }
            }
            uc.setDoOutput(true);

            if ("GET".equalsIgnoreCase(httpMethod)) {
                final Logger logger = Logger.getLogger(HttpUrlConnector.class.getName());
                if (logger.isLoggable(Level.INFO)) {
                    logger.log(Level.INFO, LocalizationMessages.HTTPURLCONNECTION_REPLACES_GET_WITH_ENTITY());
                }
            }

            request.setStreamProvider(new OutboundMessageContext.StreamProvider() {

                @Override
                public OutputStream getOutputStream(int contentLength) throws IOException {
                    setOutboundHeaders(request.getStringHeaders(), uc);
                    return uc.getOutputStream();
                }
            });
            request.writeEntity();

        } else {
            setOutboundHeaders(request.getStringHeaders(), uc);
        }

        final int code = uc.getResponseCode();
        final String reasonPhrase = uc.getResponseMessage();
        final Response.StatusType status =
                reasonPhrase == null ? Statuses.from(code) : Statuses.from(code, reasonPhrase);
        final URI resolvedRequestUri;
        try {
            resolvedRequestUri = uc.getURL().toURI();
        } catch (URISyntaxException e) {
            throw new ProcessingException(e);
        }

        ClientResponse responseContext = new ClientResponse(status, request, resolvedRequestUri);
        responseContext.headers(Maps.filterKeys(uc.getHeaderFields(), Predicates.notNull()));
        responseContext.setEntityStream(getInputStream(uc));

        return responseContext;
    }

    private void setOutboundHeaders(MultivaluedMap<String, String> headers, HttpURLConnection uc) {
        boolean restrictedSent = false;
        for (Map.Entry<String, List<String>> header : headers.entrySet()) {
            String headerName = header.getKey();
            String headerValue;

            List<String> headerValues = header.getValue();
            if (headerValues.size() == 1) {
                headerValue = headerValues.get(0);
                uc.setRequestProperty(headerName, headerValue);
            } else {
                StringBuilder b = new StringBuilder();
                boolean add = false;
                for (Object value : headerValues) {
                    if (add) {
                        b.append(',');
                    }
                    add = true;
                    b.append(value);
                }
                headerValue = b.toString();
                uc.setRequestProperty(headerName, headerValue);
            }
            
            if (!isRestrictedHeaderPropertySet && !restrictedSent) {
                if (isHeaderRestricted(headerName, headerValue)) {
                    restrictedSent = true;
                }
            }
        }
        if (restrictedSent) {
            LOGGER.warning(LocalizationMessages.RESTRICTED_HEADER_POSSIBLY_IGNORED(ALLOW_RESTRICTED_HEADERS_SYSTEM_PROPERTY));
        }
    }

    private boolean isHeaderRestricted(String name, String value) {
        name = name.toLowerCase();
        return name.startsWith("sec-")
                || restrictedHeaderSet.contains(name)
                && !("connection".equalsIgnoreCase(name) && "close".equalsIgnoreCase(value));
    }

    
    private static void setRequestMethodViaJreBugWorkaround(final HttpURLConnection httpURLConnection, final String method) {
        try {
            httpURLConnection.setRequestMethod(method); 
        } catch (final ProtocolException pe) {
            try {
                AccessController
                        .doPrivileged(new PrivilegedExceptionAction<Object>() {
                            @Override
                            public Object run() throws NoSuchFieldException,
                                    IllegalAccessException {
                                try {
                                    httpURLConnection.setRequestMethod(method);
                                    
                                    
                                } catch (final ProtocolException pe) {
                                    Class<?> connectionClass = httpURLConnection
                                            .getClass();
                                    try {
                                        final Field delegateField = connectionClass.getDeclaredField("delegate");
                                        delegateField.setAccessible(true);

                                        HttpURLConnection delegateConnection =
                                                (HttpURLConnection) delegateField.get(httpURLConnection);
                                        setRequestMethodViaJreBugWorkaround(delegateConnection, method);
                                    } catch (NoSuchFieldException e) {
                                        
                                    } catch (IllegalArgumentException e) {
                                        throw new RuntimeException(e);
                                    } catch (IllegalAccessException e) {
                                        throw new RuntimeException(e);
                                    }
                                    try {
                                        Field methodField;
                                        while (connectionClass != null) {
                                            try {
                                                methodField = connectionClass
                                                        .getDeclaredField("method");
                                            } catch (NoSuchFieldException e) {
                                                connectionClass = connectionClass
                                                        .getSuperclass();
                                                continue;
                                            }
                                            methodField.setAccessible(true);
                                            methodField.set(httpURLConnection,
                                                    method);
                                            break;
                                        }
                                    } catch (final Exception e) {
                                        throw new RuntimeException(e);
                                    }
                                }
                                return null;
                            }
                        });
            } catch (final PrivilegedActionException e) {
                final Throwable cause = e.getCause();
                if (cause instanceof RuntimeException) {
                    throw (RuntimeException) cause;
                } else {
                    throw new RuntimeException(cause);
                }
            }
        }
    }

    @Override
    public String getName() {
        return "HttpUrlConnection " + AccessController.doPrivileged(PropertiesHelper.getSystemProperty("java.version"));
    }
}

<code block>


package org.glassfish.jersey.client;

import java.util.Collection;
import java.util.Map;
import java.util.Set;

import javax.ws.rs.RuntimeType;
import javax.ws.rs.core.Configurable;
import javax.ws.rs.core.Configuration;
import javax.ws.rs.core.Feature;

import org.glassfish.jersey.CommonProperties;
import org.glassfish.jersey.ExtendedConfig;
import org.glassfish.jersey.client.internal.LocalizationMessages;
import org.glassfish.jersey.client.spi.Connector;
import org.glassfish.jersey.client.spi.ConnectorProvider;
import org.glassfish.jersey.internal.inject.Injections;
import org.glassfish.jersey.internal.inject.JerseyClassAnalyzer;
import org.glassfish.jersey.internal.inject.ProviderBinder;
import org.glassfish.jersey.internal.util.collection.LazyValue;
import org.glassfish.jersey.internal.util.collection.Value;
import org.glassfish.jersey.internal.util.collection.Values;
import org.glassfish.jersey.model.internal.CommonConfig;
import org.glassfish.jersey.model.internal.ComponentBag;
import org.glassfish.jersey.process.internal.ExecutorProviders;

import org.glassfish.hk2.api.DynamicConfiguration;
import org.glassfish.hk2.api.ServiceLocator;
import org.glassfish.hk2.utilities.binding.AbstractBinder;


public class ClientConfig implements Configurable<ClientConfig>, ExtendedConfig {
    
    private State state;

    
    private static class State implements Configurable<State>, ExtendedConfig {

        
        private static final StateChangeStrategy IDENTITY = new StateChangeStrategy() {

            @Override
            public State onChange(final State state) {
                return state;
            }
        };
        
        private static final StateChangeStrategy COPY_ON_CHANGE = new StateChangeStrategy() {

            @Override
            public State onChange(final State state) {
                return state.copy();
            }
        };

        private volatile StateChangeStrategy strategy;
        private final CommonConfig commonConfig;
        private final JerseyClient client;
        private volatile ConnectorProvider connectorProvider;


        private final LazyValue<ClientRuntime> runtime = Values.lazy(new Value<ClientRuntime>() {
            @Override
            public ClientRuntime get() {
                return initRuntime();
            }
        });

        
        private static interface StateChangeStrategy {

            
            public State onChange(final State state);
        }

        
        State(final JerseyClient client) {
            this.strategy = IDENTITY;
            this.commonConfig = new CommonConfig(RuntimeType.CLIENT, ComponentBag.EXCLUDE_EMPTY);
            this.client = client;
            this.connectorProvider = new HttpUrlConnectorProvider();
        }

        
        private State(final JerseyClient client, final State original) {
            this.strategy = IDENTITY;
            this.client = client;
            this.commonConfig = new CommonConfig(original.commonConfig);
            this.connectorProvider = original.connectorProvider;
        }

        
        State copy() {
            return new State(this.client, this);
        }

        
        State copy(final JerseyClient client) {
            return new State(client, this);
        }

        void markAsShared() {
            strategy = COPY_ON_CHANGE;
        }

        State preInitialize() {
            final State state = strategy.onChange(this);
            state.strategy = COPY_ON_CHANGE;
            state.runtime.get().preInitialize();
            return state;

        }

        @Override
        public State property(final String name, final Object value) {
            final State state = strategy.onChange(this);
            state.commonConfig.property(name, value);
            return state;
        }

        public State loadFrom(final Configuration config) {
            final State state = strategy.onChange(this);
            state.commonConfig.loadFrom(config);
            return state;
        }

        @Override
        public State register(final Class<?> providerClass) {
            final State state = strategy.onChange(this);
            state.commonConfig.register(providerClass);
            return state;
        }

        @Override
        public State register(final Object provider) {
            final State state = strategy.onChange(this);
            state.commonConfig.register(provider);
            return state;
        }

        @Override
        public State register(final Class<?> providerClass, final int bindingPriority) {
            final State state = strategy.onChange(this);
            state.commonConfig.register(providerClass, bindingPriority);
            return state;
        }

        @Override
        public State register(final Class<?> providerClass, final Class<?>... contracts) {
            final State state = strategy.onChange(this);
            state.commonConfig.register(providerClass, contracts);
            return state;
        }

        @Override
        public State register(final Class<?> providerClass, final Map<Class<?>, Integer> contracts) {
            final State state = strategy.onChange(this);
            state.commonConfig.register(providerClass, contracts);
            return state;
        }

        @Override
        public State register(final Object provider, final int bindingPriority) {
            final State state = strategy.onChange(this);
            state.commonConfig.register(provider, bindingPriority);
            return state;
        }

        @Override
        public State register(final Object provider, final Class<?>... contracts) {
            final State state = strategy.onChange(this);
            state.commonConfig.register(provider, contracts);
            return state;
        }

        @Override
        public State register(final Object provider, final Map<Class<?>, Integer> contracts) {
            final State state = strategy.onChange(this);
            state.commonConfig.register(provider, contracts);
            return state;
        }

        State connectorProvider(final ConnectorProvider provider) {
            if (provider == null) {
                throw new NullPointerException(LocalizationMessages.NULL_CONNECTOR_PROVIDER());
            }
            final State state = strategy.onChange(this);
            state.connectorProvider = provider;
            return state;
        }

        Connector getConnector() {
            
            return (runtime.isInitialized()) ? runtime.get().getConnector() : null;
        }

        ConnectorProvider getConnectorProvider() {
            return connectorProvider;
        }

        JerseyClient getClient() {
            return client;
        }

        @Override
        public State getConfiguration() {
            return this;
        }

        @Override
        public RuntimeType getRuntimeType() {
            return commonConfig.getConfiguration().getRuntimeType();
        }

        @Override
        public Map<String, Object> getProperties() {
            return commonConfig.getConfiguration().getProperties();
        }

        @Override
        public Object getProperty(final String name) {
            return commonConfig.getConfiguration().getProperty(name);
        }

        @Override
        public Collection<String> getPropertyNames() {
            return commonConfig.getConfiguration().getPropertyNames();
        }

        @Override
        public boolean isProperty(final String name) {
            return commonConfig.getConfiguration().isProperty(name);
        }

        @Override
        public boolean isEnabled(final Feature feature) {
            return commonConfig.getConfiguration().isEnabled(feature);
        }

        @Override
        public boolean isEnabled(final Class<? extends Feature> featureClass) {
            return commonConfig.getConfiguration().isEnabled(featureClass);
        }

        @Override
        public boolean isRegistered(final Object component) {
            return commonConfig.getConfiguration().isRegistered(component);
        }

        @Override
        public boolean isRegistered(final Class<?> componentClass) {
            return commonConfig.getConfiguration().isRegistered(componentClass);
        }

        @Override
        public Map<Class<?>, Integer> getContracts(final Class<?> componentClass) {
            return commonConfig.getConfiguration().getContracts(componentClass);
        }

        @Override
        public Set<Class<?>> getClasses() {
            return commonConfig.getConfiguration().getClasses();
        }

        @Override
        public Set<Object> getInstances() {
            return commonConfig.getConfiguration().getInstances();
        }

        public void configureAutoDiscoverableProviders(final ServiceLocator locator) {
            commonConfig.configureAutoDiscoverableProviders(locator, false);
        }

        public void configureForcedAutoDiscoverableProviders(final ServiceLocator locator) {
            commonConfig.configureAutoDiscoverableProviders(locator, true);
        }

        public void configureMetaProviders(final ServiceLocator locator) {
            commonConfig.configureMetaProviders(locator);
        }

        public ComponentBag getComponentBag() {
            return commonConfig.getComponentBag();
        }

        
        @SuppressWarnings("MethodOnlyUsedFromInnerClass")
        private ClientRuntime initRuntime() {
            
            markAsShared();

            final State runtimeCfgState = this.copy();
            runtimeCfgState.markAsShared();

            final ServiceLocator locator = Injections.createLocator(new ClientBinder(runtimeCfgState.getProperties()));
            locator.setDefaultClassAnalyzerName(JerseyClassAnalyzer.NAME);

            
            if (!CommonProperties.getValue(runtimeCfgState.getProperties(), RuntimeType.CLIENT,
                    CommonProperties.FEATURE_AUTO_DISCOVERY_DISABLE, Boolean.FALSE, Boolean.class)) {
                runtimeCfgState.configureAutoDiscoverableProviders(locator);
            } else {
                runtimeCfgState.configureForcedAutoDiscoverableProviders(locator);
            }

            
            runtimeCfgState.configureMetaProviders(locator);

            
            final AbstractBinder configBinder = new AbstractBinder() {
                @Override
                protected void configure() {
                    bind(runtimeCfgState).to(Configuration.class);
                }
            };
            final DynamicConfiguration dc = Injections.getConfiguration(locator);
            configBinder.bind(dc);
            dc.commit();

            
            ProviderBinder.bindProviders(runtimeCfgState.getComponentBag(), RuntimeType.CLIENT, null, locator);

            
            ExecutorProviders.createInjectionBindings(locator);

            final ClientConfig configuration = new ClientConfig(runtimeCfgState);
            final Connector connector = connectorProvider.getConnector(client, configuration);
            final ClientRuntime crt = new ClientRuntime(configuration, connector, locator);

            client.registerShutdownHook(crt);

            return crt;
        }

        @Override
        public boolean equals(final Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }

            final State state = (State) o;

            if (client != null ? !client.equals(state.client) : state.client != null) {
                return false;
            }
            if (!commonConfig.equals(state.commonConfig)) {
                return false;
            }
            return connectorProvider == null ? state.connectorProvider == null
                    : connectorProvider.equals(state.connectorProvider);
        }

        @Override
        public int hashCode() {
            int result = commonConfig.hashCode();
            result = 31 * result + (client != null ? client.hashCode() : 0);
            result = 31 * result + (connectorProvider != null ? connectorProvider.hashCode() : 0);
            return result;
        }
    }

    
    public ClientConfig() {
        this.state = new State(null);
    }

    
    public ClientConfig(final Class<?>... providerClasses) {
        this();
        for (final Class<?> providerClass : providerClasses) {
            state.register(providerClass);
        }
    }

    
    public ClientConfig(final Object... providers) {
        this();
        for (final Object provider : providers) {
            state.register(provider);
        }
    }

    
    ClientConfig(final JerseyClient parent) {
        this.state = new State(parent);
    }

    
    ClientConfig(final JerseyClient parent, final Configuration that) {
        if (that instanceof ClientConfig) {
            state = ((ClientConfig) that).state.copy(parent);
        } else {
            state = new State(parent);
            state.loadFrom(that);
        }
    }

    
    private ClientConfig(final State state) {
        this.state = state;
    }

    
    ClientConfig snapshot() {
        state.markAsShared();
        return new ClientConfig(state);
    }

    
    public ClientConfig loadFrom(final Configuration config) {
        if (config instanceof ClientConfig) {
            state = ((ClientConfig) config).state.copy();
        } else {
            state.loadFrom(config);
        }
        return this;
    }

    @Override
    public ClientConfig register(final Class<?> providerClass) {
        state = state.register(providerClass);
        return this;
    }

    @Override
    public ClientConfig register(final Object provider) {
        state = state.register(provider);
        return this;
    }

    @Override
    public ClientConfig register(final Class<?> providerClass, final int bindingPriority) {
        state = state.register(providerClass, bindingPriority);
        return this;
    }

    @Override
    public ClientConfig register(final Class<?> providerClass, final Class<?>... contracts) {
        state = state.register(providerClass, contracts);
        return this;
    }

    @Override
    public ClientConfig register(final Class<?> providerClass, final Map<Class<?>, Integer> contracts) {
        state = state.register(providerClass, contracts);
        return this;
    }

    @Override
    public ClientConfig register(final Object provider, final int bindingPriority) {
        state = state.register(provider, bindingPriority);
        return this;
    }

    @Override
    public ClientConfig register(final Object provider, final Class<?>... contracts) {
        state = state.register(provider, contracts);
        return this;
    }

    @Override
    public ClientConfig register(final Object provider, final Map<Class<?>, Integer> contracts) {
        state = state.register(provider, contracts);
        return this;
    }

    @Override
    public ClientConfig property(final String name, final Object value) {
        state = state.property(name, value);
        return this;
    }

    @Override
    public ClientConfig getConfiguration() {
        return this;
    }

    @Override
    public RuntimeType getRuntimeType() {
        return state.getRuntimeType();
    }

    @Override
    public Map<String, Object> getProperties() {
        return state.getProperties();
    }

    @Override
    public Object getProperty(final String name) {
        return state.getProperty(name);
    }

    @Override
    public Collection<String> getPropertyNames() {
        return state.getPropertyNames();
    }

    @Override
    public boolean isProperty(final String name) {
        return state.isProperty(name);
    }

    @Override
    public boolean isEnabled(final Feature feature) {
        return state.isEnabled(feature);
    }

    @Override
    public boolean isEnabled(final Class<? extends Feature> featureClass) {
        return state.isEnabled(featureClass);
    }

    @Override
    public boolean isRegistered(final Object component) {
        return state.isRegistered(component);
    }

    @Override
    public Map<Class<?>, Integer> getContracts(final Class<?> componentClass) {
        return state.getContracts(componentClass);
    }

    @Override
    public boolean isRegistered(final Class<?> componentClass) {
        return state.isRegistered(componentClass);
    }

    @Override
    public Set<Class<?>> getClasses() {
        return state.getClasses();
    }

    @Override
    public Set<Object> getInstances() {
        return state.getInstances();
    }

    
    public ClientConfig connectorProvider(final ConnectorProvider connectorProvider) {
        state = state.connectorProvider(connectorProvider);
        return this;
    }

    
    public Connector getConnector() {
        return state.getConnector();
    }

    
    public ConnectorProvider getConnectorProvider() {
        return state.getConnectorProvider();
    }

    
    ClientRuntime getRuntime() {
        return state.runtime.get();
    }

    
    public JerseyClient getClient() {
        return state.getClient();
    }


    
    ClientConfig preInitialize() {
        state = state.preInitialize();
        return this;
    }

    
    void checkClient() throws IllegalStateException {
        if (getClient() == null) {
            throw new IllegalStateException("Client configuration does not contain a parent client instance.");
        }
    }

    @Override
    public boolean equals(final Object obj) {
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final ClientConfig other = (ClientConfig) obj;
        return this.state == other.state || (this.state != null && this.state.equals(other.state));
    }

    @Override
    public int hashCode() {
        int hash = 7;
        hash = 47 * hash + (this.state != null ? this.state.hashCode() : 0);
        return hash;
    }
}

<code block>

package org.glassfish.jersey.client;

import java.util.Map;

import org.glassfish.jersey.CommonProperties;
import org.glassfish.jersey.internal.util.PropertiesClass;
import org.glassfish.jersey.internal.util.PropertiesHelper;
import org.glassfish.jersey.internal.util.PropertyAlias;


@PropertiesClass
public final class ClientProperties {

    
    public static final String FOLLOW_REDIRECTS = "jersey.config.client.followRedirects";

    
    public static final String READ_TIMEOUT = "jersey.config.client.readTimeout";

    
    public static final String CONNECT_TIMEOUT = "jersey.config.client.connectTimeout";

    
    public static final String CHUNKED_ENCODING_SIZE = "jersey.config.client.chunkedEncodingSize";
    
    public static final int DEFAULT_CHUNK_SIZE = 4096;

    
    public static final String ASYNC_THREADPOOL_SIZE = "jersey.config.client.async.threadPoolSize";

    
    public static final String USE_ENCODING = "jersey.config.client.useEncoding";

    
    @PropertyAlias
    public static final String FEATURE_AUTO_DISCOVERY_DISABLE = CommonProperties.FEATURE_AUTO_DISCOVERY_DISABLE_CLIENT;

    
    @PropertyAlias
    public static final String OUTBOUND_CONTENT_LENGTH_BUFFER = CommonProperties.OUTBOUND_CONTENT_LENGTH_BUFFER_CLIENT;

    
    @PropertyAlias
    public static final String JSON_PROCESSING_FEATURE_DISABLE = CommonProperties.JSON_PROCESSING_FEATURE_DISABLE_CLIENT;

    
    @PropertyAlias
    public static final String METAINF_SERVICES_LOOKUP_DISABLE = CommonProperties.METAINF_SERVICES_LOOKUP_DISABLE_CLIENT;

    
    @PropertyAlias
    public static final String MOXY_JSON_FEATURE_DISABLE = CommonProperties.MOXY_JSON_FEATURE_DISABLE_CLIENT;

    
    public static final String SUPPRESS_HTTP_COMPLIANCE_VALIDATION =
            "jersey.config.client.suppressHttpComplianceValidation";

    
    public static final String DIGESTAUTH_URI_CACHE_SIZELIMIT = "jersey.config.client.digestAuthUriCacheSizeLimit";

    
    
    public static final String PROXY_URI = "jersey.config.client.proxy.uri";

    
    public static final String PROXY_USERNAME = "jersey.config.client.proxy.username";

    
    public static final String PROXY_PASSWORD = "jersey.config.client.proxy.password";
    
    public static final String REQUEST_ENTITY_PROCESSING = "jersey.config.client.request.entity.processing";

    private ClientProperties() {
        
    }

    
    public static <T> T getValue(final Map<String, ?> properties, final String key, final T defaultValue) {
        return PropertiesHelper.getValue(properties, key, defaultValue, null);
    }

    
    public static <T> T getValue(final Map<String, ?> properties, final String key, final T defaultValue, final Class<T> type) {
        return PropertiesHelper.getValue(properties, key, defaultValue, type, null);
    }

    
    public static <T> T getValue(final Map<String, ?> properties, final String key, final Class<T> type) {
        return PropertiesHelper.getValue(properties, key, type, null);
    }
}

<code block>

package org.glassfish.jersey.client;

import java.io.IOException;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.Map;
import java.util.logging.Logger;

import javax.ws.rs.client.Client;
import javax.ws.rs.core.Configuration;

import org.glassfish.jersey.client.internal.LocalizationMessages;
import org.glassfish.jersey.client.spi.Connector;
import org.glassfish.jersey.client.spi.ConnectorProvider;


public class HttpUrlConnectorProvider implements ConnectorProvider {
    
    public static final String USE_FIXED_LENGTH_STREAMING =
            "jersey.config.client.httpUrlConnector.useFixedLengthStreaming";

    
    public static final String SET_METHOD_WORKAROUND =
            "jersey.config.client.httpUrlConnection.setMethodWorkaround";
    
    private static final ConnectionFactory DEFAULT_CONNECTION_FACTORY = new DefaultConnectionFactory();

    private static final Logger LOGGER = Logger.getLogger(HttpUrlConnectorProvider.class.getName());

    private ConnectionFactory connectionFactory;
    private int chunkSize;
    private boolean useFixedLengthStreaming;
    private boolean useSetMethodWorkaround;

    
    public HttpUrlConnectorProvider() {
        this.connectionFactory = DEFAULT_CONNECTION_FACTORY;
        this.chunkSize = ClientProperties.DEFAULT_CHUNK_SIZE;
        this.useFixedLengthStreaming = false;
        this.useSetMethodWorkaround = false;
    }


    
    public HttpUrlConnectorProvider connectionFactory(final ConnectionFactory connectionFactory) {
        if (connectionFactory == null) {
            throw new NullPointerException(LocalizationMessages.NULL_INPUT_PARAMETER("connectionFactory"));
        }

        this.connectionFactory = connectionFactory;
        return this;
    }

    
    public HttpUrlConnectorProvider chunkSize(final int chunkSize) {
        if (chunkSize < 0) {
            throw new IllegalArgumentException(LocalizationMessages.NEGATIVE_INPUT_PARAMETER("chunkSize"));
        }
        this.chunkSize = chunkSize;
        return this;
    }

    
    public HttpUrlConnectorProvider useFixedLengthStreaming() {
        this.useFixedLengthStreaming = true;
        return this;
    }

    
    public HttpUrlConnectorProvider useSetMethodWorkaround() {
        this.useSetMethodWorkaround = true;
        return this;
    }

    @Override
    public Connector getConnector(final Client client, final Configuration config) {
        final Map<String, Object> properties = config.getProperties();

        int computedChunkSize = ClientProperties.getValue(properties,
                ClientProperties.CHUNKED_ENCODING_SIZE, chunkSize, Integer.class);
        if (computedChunkSize < 0) {
            LOGGER.warning(LocalizationMessages.NEGATIVE_CHUNK_SIZE(computedChunkSize, chunkSize));
            computedChunkSize = chunkSize;
        }

        final boolean computedUseFixedLengthStreaming = ClientProperties.getValue(properties,
                USE_FIXED_LENGTH_STREAMING, useFixedLengthStreaming, Boolean.class);
        final boolean computedUseSetMethodWorkaround = ClientProperties.getValue(properties,
                SET_METHOD_WORKAROUND, useSetMethodWorkaround, Boolean.class);

        return new HttpUrlConnector(
                client,
                connectionFactory,
                computedChunkSize,
                computedUseFixedLengthStreaming,
                computedUseSetMethodWorkaround);
    }

    
    public interface ConnectionFactory {

        
        public HttpURLConnection getConnection(URL url) throws IOException;
    }

    private static class DefaultConnectionFactory implements ConnectionFactory {

        @Override
        public HttpURLConnection getConnection(final URL url) throws IOException {
            return (HttpURLConnection) url.openConnection();
        }
    }

    @Override
    public boolean equals(final Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        final HttpUrlConnectorProvider that = (HttpUrlConnectorProvider) o;

        if (chunkSize != that.chunkSize) {
            return false;
        }
        if (useFixedLengthStreaming != that.useFixedLengthStreaming) {
            return false;
        }

        return connectionFactory.equals(that.connectionFactory);
    }

    @Override
    public int hashCode() {
        int result = connectionFactory.hashCode();
        result = 31 * result + chunkSize;
        result = 31 * result + (useFixedLengthStreaming ? 1 : 0);
        return result;
    }
}

<code block>

package org.glassfish.jersey.client;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.ProtocolException;
import java.net.SocketTimeoutException;
import java.net.URI;
import java.net.URL;
import java.security.Permission;
import java.security.Principal;
import java.security.cert.Certificate;
import java.util.List;
import java.util.Map;

import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.client.Entity;
import javax.ws.rs.client.Invocation;
import javax.ws.rs.client.WebTarget;
import javax.ws.rs.core.HttpHeaders;
import javax.ws.rs.core.Link;
import javax.ws.rs.core.Response;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLPeerUnverifiedException;
import javax.net.ssl.SSLSocketFactory;

import org.junit.Assert;
import org.junit.Ignore;
import org.junit.Test;
import static org.junit.Assert.assertEquals;


public class HttpUrlConnectorTest {

    
    private final int TimeoutBASE = 500;

    
    @Test
    @Ignore
    public void testConnectionTimeoutWithEntity() {
        _testInvocationTimeout(createNonRoutableTarget().request().buildPost(Entity.text("does not matter")));
    }

    
    @Test
    @Ignore
    public void testConnectionTimeoutNoEntity() {
        _testInvocationTimeout(createNonRoutableTarget().request().buildGet());
    }

    
    @Test
    public void testResolvedRequestUri() {
        HttpUrlConnectorProvider.ConnectionFactory factory = new HttpUrlConnectorProvider.ConnectionFactory() {
            @Override
            public HttpURLConnection getConnection(URL endpointUrl) throws IOException {
                HttpURLConnection result = (HttpURLConnection) endpointUrl.openConnection();
                return wrapRedirectedHttp(result);
            }
        };
        JerseyClient client = new JerseyClientBuilder().build();

        ClientRequest request = client.target("http:
        final HttpUrlConnectorProvider connectorProvider = new HttpUrlConnectorProvider().connectionFactory(factory);
        HttpUrlConnector connector = (HttpUrlConnector) connectorProvider.getConnector(client, client.getConfiguration());
        ClientResponse res = connector.apply(request);
        assertEquals(URI.create("http:
        assertEquals(URI.create("http:


        res.getHeaders().putSingle(HttpHeaders.LINK, Link.fromPath("action").rel("test").build().toString());
                assertEquals(URI.create("http:
    }

    private HttpURLConnection wrapRedirectedHttp(final HttpURLConnection connection) {
        if (connection instanceof HttpsURLConnection) {
            return connection;
        }

        return new HttpURLConnection(connection.getURL()) {

            @Override
            public URL getURL() {
                return url;
            }

            @Override
            public int getResponseCode() throws IOException {
                
                url = new URL("http:
                
                return Response.Status.NO_CONTENT.getStatusCode();
            }

            @Override
            public String getResponseMessage() throws IOException {
                return Response.Status.NO_CONTENT.getReasonPhrase();
            }

            
            
            public long getContentLengthLong() {
                return connection.getContentLength();
                
                
            }

            
            
            public long getHeaderFieldLong(String name, long Default) {
                return connection.getHeaderFieldInt(name, (int) Default);
                
                
            }

            
            
            public void setFixedLengthStreamingMode(long contentLength) {
                
                
            }

            @Override
            public void setInstanceFollowRedirects(boolean followRedirects) {
                connection.setInstanceFollowRedirects(followRedirects);
            }

            @Override
            public boolean getInstanceFollowRedirects() {
                return connection.getInstanceFollowRedirects();
            }

            @Override
            public void setRequestMethod(String method) throws ProtocolException {
                connection.setRequestMethod(method);
            }

            @Override
            public String getRequestMethod() {
                return connection.getRequestMethod();
            }

            @Override
            public long getHeaderFieldDate(String name, long Default) {
                return connection.getHeaderFieldDate(name, Default);
            }

            @Override
            public void disconnect() {
                connection.disconnect();
            }

            @Override
            public boolean usingProxy() {
                return connection.usingProxy();
            }

            @Override
            public Permission getPermission() throws IOException {
                return connection.getPermission();
            }

            @Override
            public InputStream getErrorStream() {
                return connection.getErrorStream();
            }

            @Override
            public String getHeaderField(int n) {
                return connection.getHeaderField(n);
            }

            @Override
            public void setChunkedStreamingMode(int chunklen) {
                connection.setChunkedStreamingMode(chunklen);
            }

            @Override
            public void setFixedLengthStreamingMode(int contentLength) {
                connection.setFixedLengthStreamingMode(contentLength);
            }

            @Override
            public String getHeaderFieldKey(int n) {
                return connection.getHeaderFieldKey(n);
            }

            @Override
            public void connect() throws IOException {
                connection.connect();
            }

            @Override
            public void setConnectTimeout(int timeout) {
                connection.setConnectTimeout(timeout);
            }

            @Override
            public int getConnectTimeout() {
                return connection.getConnectTimeout();
            }

            @Override
            public void setReadTimeout(int timeout) {
                connection.setReadTimeout(timeout);
            }

            @Override
            public int getReadTimeout() {
                return connection.getReadTimeout();
            }

            @Override
            public int getContentLength() {
                return connection.getContentLength();
            }

            @Override
            public String getContentType() {
                return connection.getContentType();
            }

            @Override
            public String getContentEncoding() {
                return connection.getContentEncoding();
            }

            @Override
            public long getExpiration() {
                return connection.getExpiration();
            }

            @Override
            public long getDate() {
                return connection.getDate();
            }

            @Override
            public long getLastModified() {
                return connection.getLastModified();
            }

            @Override
            public String getHeaderField(String name) {
                return connection.getHeaderField(name);
            }

            @Override
            public Map<String, List<String>> getHeaderFields() {
                return connection.getHeaderFields();
            }

            @Override
            public int getHeaderFieldInt(String name, int Default) {
                return connection.getHeaderFieldInt(name, Default);
            }

            @Override
            public Object getContent() throws IOException {
                return connection.getContent();
            }

            @Override
            public Object getContent(Class[] classes) throws IOException {
                return connection.getContent(classes);
            }

            @Override
            public InputStream getInputStream() throws IOException {
                return connection.getInputStream();
            }

            @Override
            public OutputStream getOutputStream() throws IOException {
                return connection.getOutputStream();
            }

            @Override
            public String toString() {
                return connection.toString();
            }

            @Override
            public void setDoInput(boolean doinput) {
                connection.setDoInput(doinput);
            }

            @Override
            public boolean getDoInput() {
                return connection.getDoInput();
            }

            @Override
            public void setDoOutput(boolean dooutput) {
                connection.setDoOutput(dooutput);
            }

            @Override
            public boolean getDoOutput() {
                return connection.getDoOutput();
            }

            @Override
            public void setAllowUserInteraction(boolean allowuserinteraction) {
                connection.setAllowUserInteraction(allowuserinteraction);
            }

            @Override
            public boolean getAllowUserInteraction() {
                return connection.getAllowUserInteraction();
            }

            @Override
            public void setUseCaches(boolean usecaches) {
                connection.setUseCaches(usecaches);
            }

            @Override
            public boolean getUseCaches() {
                return connection.getUseCaches();
            }

            @Override
            public void setIfModifiedSince(long ifmodifiedsince) {
                connection.setIfModifiedSince(ifmodifiedsince);
            }

            @Override
            public long getIfModifiedSince() {
                return connection.getIfModifiedSince();
            }

            @Override
            public boolean getDefaultUseCaches() {
                return connection.getDefaultUseCaches();
            }

            @Override
            public void setDefaultUseCaches(boolean defaultusecaches) {
                connection.setDefaultUseCaches(defaultusecaches);
            }

            @Override
            public void setRequestProperty(String key, String value) {
                connection.setRequestProperty(key, value);
            }

            @Override
            public void addRequestProperty(String key, String value) {
                connection.addRequestProperty(key, value);
            }

            @Override
            public String getRequestProperty(String key) {
                return connection.getRequestProperty(key);
            }

            @Override
            public Map<String, List<String>> getRequestProperties() {
                return connection.getRequestProperties();
            }
        };

    }

    private void _testInvocationTimeout(Invocation invocation) {

        final long start = System.currentTimeMillis();

        try {
            invocation.invoke();

            Assert.fail("Timeout expected!");

        } catch (Exception ex) {

            Assert.assertTrue(String.format("Bad exception, %s, caught! Timeout expected.", ex.getCause()),
                    ex.getCause() instanceof SocketTimeoutException);

            final long stop = System.currentTimeMillis();
            long time = stop - start;

            Assert.assertTrue(
               String.format(
                    "Actual time, %d ms, should not be more than twice as longer as the original timeout, %d ms",
                                 time,                                                              TimeoutBASE),
               time < 2 * TimeoutBASE);
        }
    }

    
    @Test
    public void testSSLConnection() {
        JerseyClient client = new JerseyClientBuilder().build();
        ClientRequest request = client.target("https:
        HttpUrlConnectorProvider.ConnectionFactory factory = new HttpUrlConnectorProvider.ConnectionFactory() {
            @Override
            public HttpURLConnection getConnection(URL endpointUrl) throws IOException {
                HttpURLConnection result = (HttpURLConnection) endpointUrl.openConnection();
                return wrapNoContentHttps(result);
            }
        };
        final HttpUrlConnectorProvider connectorProvider = new HttpUrlConnectorProvider().connectionFactory(factory);
        HttpUrlConnector connector = (HttpUrlConnector) connectorProvider.getConnector(client, client.getConfiguration());
        ClientResponse res = connector.apply(request);
        assertEquals(Response.Status.NO_CONTENT.getStatusCode(), res.getStatusInfo().getStatusCode());
        assertEquals(Response.Status.NO_CONTENT.getReasonPhrase(), res.getStatusInfo().getReasonPhrase());
    }

    private HttpURLConnection wrapNoContentHttps(final HttpURLConnection result) {
        if (result instanceof HttpsURLConnection) {
            return new HttpsURLConnection(result.getURL()) {
                private final HttpsURLConnection delegate = (HttpsURLConnection) result;

                @Override
                public int getResponseCode() throws IOException {
                    return Response.Status.NO_CONTENT.getStatusCode();
                }

                @Override
                public String getResponseMessage() throws IOException {
                    return Response.Status.NO_CONTENT.getReasonPhrase();
                }

                
                
                public long getContentLengthLong() {
                    return delegate.getContentLength();
                    
                    
                }

                
                
                public long getHeaderFieldLong(String name, long Default) {
                    return delegate.getHeaderFieldInt(name, (int) Default);
                    
                    
                }

                
                
                public void setFixedLengthStreamingMode(long contentLength) {
                    
                    
                }

                @Override
                public String getHeaderFieldKey(int n) {
                    return delegate.getHeaderFieldKey(n);
                }

                @Override
                public String getHeaderField(int n) {
                    return delegate.getHeaderField(n);
                }

                @Override
                public void connect() throws IOException {
                    delegate.connect();
                }

                @Override
                public boolean getInstanceFollowRedirects() {
                    return delegate.getInstanceFollowRedirects();
                }

                @Override
                public int getConnectTimeout() {
                    return delegate.getConnectTimeout();
                }

                @Override
                public int getContentLength() {
                    return delegate.getContentLength();
                }

                @Override
                public String getContentType() {
                    return delegate.getContentType();
                }

                @Override
                public long getHeaderFieldDate(String name, long Default) {
                    return delegate.getHeaderFieldDate(name, Default);
                }

                @Override
                public String getContentEncoding() {
                    return delegate.getContentEncoding();
                }

                @Override
                public void disconnect() {
                    delegate.disconnect();
                }

                @Override
                public long getExpiration() {
                    return delegate.getExpiration();
                }

                @Override
                public long getDate() {
                    return delegate.getDate();
                }

                @Override
                public InputStream getErrorStream() {
                    return delegate.getErrorStream();
                }

                @Override
                public long getLastModified() {
                    return delegate.getLastModified();
                }

                @Override
                public String getHeaderField(String name) {
                    return delegate.getHeaderField(name);
                }

                @Override
                public Map<String, List<String>> getHeaderFields() {
                    return delegate.getHeaderFields();
                }

                @Override
                public int getHeaderFieldInt(String name, int Default) {
                    return delegate.getHeaderFieldInt(name, Default);
                }

                @Override
                public Object getContent() throws IOException {
                    return delegate.getContent();
                }

                @Override
                public Object getContent(@SuppressWarnings("rawtypes") Class[] classes) throws IOException {
                    return delegate.getContent(classes);
                }

                @Override
                public InputStream getInputStream() throws IOException {
                    return delegate.getInputStream();
                }

                @Override
                public boolean getDoInput() {
                    return delegate.getDoInput();
                }

                @Override
                public boolean getDoOutput() {
                    return delegate.getDoOutput();
                }

                @Override
                public boolean getAllowUserInteraction() {
                    return delegate.getAllowUserInteraction();
                }

                @Override
                public void addRequestProperty(String key, String value) {
                    delegate.addRequestProperty(key, value);
                }

                @Override
                public String getCipherSuite() {
                    return delegate.getCipherSuite();
                }

                @Override
                public boolean getDefaultUseCaches() {
                    return delegate.getDefaultUseCaches();
                }

                @Override
                public HostnameVerifier getHostnameVerifier() {
                    return delegate.getHostnameVerifier();
                }

                @Override
                public long getIfModifiedSince() {
                    return delegate.getIfModifiedSince();
                }

                @Override
                public Certificate[] getLocalCertificates() {
                    return delegate.getLocalCertificates();
                }

                @Override
                public Principal getLocalPrincipal() {
                    return delegate.getLocalPrincipal();
                }

                @Override
                public void setFixedLengthStreamingMode(int contentLength) {
                    delegate.setFixedLengthStreamingMode(contentLength);
                }

                @Override
                public void setChunkedStreamingMode(int chunklen) {
                    delegate.setChunkedStreamingMode(chunklen);
                }

                @Override
                public void setConnectTimeout(int timeout) {
                    delegate.setConnectTimeout(timeout);
                }

                @Override
                public OutputStream getOutputStream() throws IOException {
                    return delegate.getOutputStream();
                }

                @Override
                public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
                    return delegate.getPeerPrincipal();
                }

                @Override
                public void setInstanceFollowRedirects(boolean followRedirects) {
                    delegate.setInstanceFollowRedirects(followRedirects);
                }

                @Override
                public void setRequestMethod(String method) throws ProtocolException {
                    delegate.setRequestMethod(method);
                }

                @Override
                public String getRequestMethod() {
                    return delegate.getRequestMethod();
                }

                @Override
                public void setReadTimeout(int timeout) {
                    delegate.setReadTimeout(timeout);
                }

                @Override
                public int getReadTimeout() {
                    return delegate.getReadTimeout();
                }

                @Override
                public URL getURL() {
                    return delegate.getURL();
                }

                @Override
                public boolean usingProxy() {
                    return delegate.usingProxy();
                }

                @Override
                public Permission getPermission() throws IOException {
                    return delegate.getPermission();
                }

                @Override
                public void setDoInput(boolean doinput) {
                    delegate.setDoInput(doinput);
                }

                @Override
                public void setDoOutput(boolean dooutput) {
                    delegate.setDoOutput(dooutput);
                }

                @Override
                public void setAllowUserInteraction(boolean allowuserinteraction) {
                    delegate.setAllowUserInteraction(allowuserinteraction);
                }

                @Override
                public void setUseCaches(boolean usecaches) {
                    delegate.setUseCaches(usecaches);
                }

                @Override
                public boolean getUseCaches() {
                    return delegate.getUseCaches();
                }

                @Override
                public void setIfModifiedSince(long ifmodifiedsince) {
                    delegate.setIfModifiedSince(ifmodifiedsince);
                }

                @Override
                public void setDefaultUseCaches(boolean defaultusecaches) {
                    delegate.setDefaultUseCaches(defaultusecaches);
                }

                @Override
                public String getRequestProperty(String key) {
                    return delegate.getRequestProperty(key);
                }

                @Override
                public Map<String, List<String>> getRequestProperties() {
                    return delegate.getRequestProperties();
                }

                @Override
                public SSLSocketFactory getSSLSocketFactory() {
                    return delegate.getSSLSocketFactory();
                }

                @Override
                public Certificate[] getServerCertificates() throws SSLPeerUnverifiedException {
                    return delegate.getServerCertificates();
                }

                @Override
                public void setHostnameVerifier(HostnameVerifier v) {
                    delegate.setHostnameVerifier(v);
                }

                @Override
                public void setRequestProperty(String key, String value) {
                    delegate.setRequestProperty(key, value);
                }

                @Override
                public void setSSLSocketFactory(SSLSocketFactory sf) {
                    delegate.setSSLSocketFactory(sf);
                }
            };
        }
        return result;
    }

    private WebTarget createNonRoutableTarget() {
        Client client = ClientBuilder.newClient();
        client.property(ClientProperties.CONNECT_TIMEOUT, TimeoutBASE);
        
        return client.target("http:
    }
}
